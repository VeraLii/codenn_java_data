[{
	"Path": "com.google.crypto.tink.subtle.SubtleUtil.toDigestAlgo",
	"Comment": "returns the digest algorithm name corresponding to a hash type.",
	"Method": "String toDigestAlgo(HashType hash){\r\n    switch(hash) {\r\n        case SHA1:\r\n            return \"SHA-1\";\r\n        case SHA256:\r\n            return \"SHA-256\";\r\n        case SHA512:\r\n            return \"SHA-512\";\r\n    }\r\n    throw new GeneralSecurityException(\"Unsupported hash \" + hash);\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.swipelistview.SwipeListView.setSwipeCloseAllItemsWhenMoveList",
	"Comment": "set if all items opened will be closed when the user moves the listview",
	"Method": "void setSwipeCloseAllItemsWhenMoveList(boolean swipeCloseAllItemsWhenMoveList){\r\n    touchListener.setSwipeClosesAllItemsWhenListMoves(swipeCloseAllItemsWhenMoveList);\r\n}"
}, {
	"Path": "org.b3log.symphony.service.InvitecodeMgmtService.updateInvitecode",
	"Comment": "updates the specified invitecode by the given invitecode id.",
	"Method": "void updateInvitecode(String invitecodeId,JSONObject invitecode){\r\n    final Transaction transaction = invitecodeRepository.beginTransaction();\r\n    try {\r\n        invitecodeRepository.update(invitecodeId, invitecode);\r\n        transaction.commit();\r\n    } catch (final RepositoryException e) {\r\n        if (transaction.isActive()) {\r\n            transaction.rollback();\r\n        }\r\n        LOGGER.log(Level.ERROR, \"Updates an invitecode[id=\" + invitecodeId + \"] failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.oned.rss.expanded.RSSExpandedReader.isPartialRow",
	"Comment": "returns true when one of the rows already contains all the pairs",
	"Method": "boolean isPartialRow(Iterable<ExpandedPair> pairs,Iterable<ExpandedRow> rows){\r\n    for (ExpandedRow r : rows) {\r\n        boolean allFound = true;\r\n        for (ExpandedPair p : pairs) {\r\n            boolean found = false;\r\n            for (ExpandedPair pp : r.getPairs()) {\r\n                if (p.equals(pp)) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                allFound = false;\r\n                break;\r\n            }\r\n        }\r\n        if (allFound) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.demo.modules.CircularImageView.setSelectorColor",
	"Comment": "sets the color of the selector to be draw over the\tcircularimageview. be sure to provide some opacity.",
	"Method": "void setSelectorColor(int selectorColor){\r\n    this.selectorFilter = new PorterDuffColorFilter(selectorColor, PorterDuff.Mode.SRC_ATOP);\r\n    this.invalidate();\r\n}"
}, {
	"Path": "io.vertx.it.Log4J2LogDelegateTest.testMethodName",
	"Comment": "we use anonymous class instead of a lambda since we have to know the calling method name",
	"Method": "void testMethodName(){\r\n    Logger logger = LoggerFactory.getLogger(\"my-log4j2-logger\");\r\n    String result = recording.execute(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            logger.warn(\"hello\");\r\n        }\r\n    });\r\n    assertTrue(result.contains(\".run:\"));\r\n}"
}, {
	"Path": "io.vertx.it.Log4J2LogDelegateTest.testMethodName",
	"Comment": "we use anonymous class instead of a lambda since we have to know the calling method name",
	"Method": "void testMethodName(){\r\n    logger.warn(\"hello\");\r\n}"
}, {
	"Path": "com.google.zxing.common.detector.MonochromeRectangleDetector.findCornerFromCenter",
	"Comment": "attempts to locate a corner of the barcode by scanning up, down, left or right from a centerpoint which should be within the barcode.",
	"Method": "ResultPoint findCornerFromCenter(int centerX,int deltaX,int left,int right,int centerY,int deltaY,int top,int bottom,int maxWhiteRun){\r\n    int[] lastRange = null;\r\n    for (int y = centerY, x = centerX; y < bottom && y >= top && x < right && x >= left; y += deltaY, x += deltaX) {\r\n        int[] range;\r\n        if (deltaX == 0) {\r\n            range = blackWhiteRange(y, maxWhiteRun, left, right, true);\r\n        } else {\r\n            range = blackWhiteRange(x, maxWhiteRun, top, bottom, false);\r\n        }\r\n        if (range == null) {\r\n            if (lastRange == null) {\r\n                throw NotFoundException.getNotFoundInstance();\r\n            }\r\n            if (deltaX == 0) {\r\n                int lastY = y - deltaY;\r\n                if (lastRange[0] < centerX) {\r\n                    if (lastRange[1] > centerX) {\r\n                        return new ResultPoint(lastRange[deltaY > 0 ? 0 : 1], lastY);\r\n                    }\r\n                    return new ResultPoint(lastRange[0], lastY);\r\n                } else {\r\n                    return new ResultPoint(lastRange[1], lastY);\r\n                }\r\n            } else {\r\n                int lastX = x - deltaX;\r\n                if (lastRange[0] < centerY) {\r\n                    if (lastRange[1] > centerY) {\r\n                        return new ResultPoint(lastX, lastRange[deltaX < 0 ? 0 : 1]);\r\n                    }\r\n                    return new ResultPoint(lastX, lastRange[0]);\r\n                } else {\r\n                    return new ResultPoint(lastX, lastRange[1]);\r\n                }\r\n            }\r\n        }\r\n        lastRange = range;\r\n    }\r\n    throw NotFoundException.getNotFoundInstance();\r\n}"
}, {
	"Path": "org.b3log.symphony.cache.ArticleCache.putArticleAbstract",
	"Comment": "puts an article abstract by the specified article id and article abstract.",
	"Method": "void putArticleAbstract(String articleId,String articleAbstract){\r\n    final JSONObject value = new JSONObject();\r\n    value.put(Common.DATA, articleAbstract);\r\n    ARTICLE_ABSTRACT_CACHE.put(articleId, value);\r\n}"
}, {
	"Path": "org.b3log.symphony.service.BreezemoonQueryService.organizeBreezemoons",
	"Comment": "organizes the specified breezemoons with the specified avatar view mode and current user id.",
	"Method": "void organizeBreezemoons(int avatarViewMode,String currentUserId,List<JSONObject> breezemoons){\r\n    try {\r\n        final Iterator<JSONObject> iterator = breezemoons.iterator();\r\n        while (iterator.hasNext()) {\r\n            final JSONObject bm = iterator.next();\r\n            final String authorId = bm.optString(Breezemoon.BREEZEMOON_AUTHOR_ID);\r\n            final JSONObject author = userRepository.get(authorId);\r\n            if (UserExt.USER_XXX_STATUS_C_PRIVATE == author.optInt(UserExt.USER_BREEZEMOON_STATUS) && !StringUtils.equals(currentUserId, authorId) && !\"admin\".equals(currentUserId)) {\r\n                iterator.remove();\r\n                continue;\r\n            }\r\n            bm.put(Breezemoon.BREEZEMOON_T_AUTHOR_NAME, author.optString(User.USER_NAME));\r\n            bm.put(Breezemoon.BREEZEMOON_T_AUTHOR_THUMBNAIL_URL + \"48\", avatarQueryService.getAvatarURLByUser(avatarViewMode, author, \"48\"));\r\n            final long time = bm.optLong(Breezemoon.BREEZEMOON_CREATED);\r\n            bm.put(Common.TIME_AGO, Times.getTimeAgo(time, Locales.getLocale()));\r\n            bm.put(Breezemoon.BREEZEMOON_T_CREATE_TIME, new Date(time));\r\n            String content = bm.optString(Breezemoon.BREEZEMOON_CONTENT);\r\n            content = shortLinkQueryService.linkArticle(content);\r\n            content = Emotions.convert(content);\r\n            content = Markdowns.toHTML(content);\r\n            content = Markdowns.clean(content, \"\");\r\n            content = Images.qiniuImgProcessing(content);\r\n            bm.put(Breezemoon.BREEZEMOON_CONTENT, content);\r\n        }\r\n    } catch (final Exception e) {\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.service.PointtransferQueryService.getTopConsumptionUsers",
	"Comment": "gets the top consumption users with the specified fetch size.",
	"Method": "List<JSONObject> getTopConsumptionUsers(int avatarViewMode,int fetchSize){\r\n    final List<JSONObject> ret = new ArrayList();\r\n    final Query query = new Query().addSort(UserExt.USER_USED_POINT, SortDirection.DESCENDING).setCurrentPageNum(1).setPageSize(fetchSize).setFilter(new PropertyFilter(UserExt.USER_JOIN_USED_POINT_RANK, FilterOperator.EQUAL, UserExt.USER_JOIN_USED_POINT_RANK_C_JOIN));\r\n    final int moneyUnit = Symphonys.getInt(\"pointExchangeUnit\");\r\n    try {\r\n        final JSONObject result = userRepository.get(query);\r\n        final List<JSONObject> users = CollectionUtils.jsonArrayToList(result.optJSONArray(Keys.RESULTS));\r\n        for (final JSONObject user : users) {\r\n            if (UserExt.USER_APP_ROLE_C_HACKER == user.optInt(UserExt.USER_APP_ROLE)) {\r\n                user.put(UserExt.USER_T_POINT_HEX, Integer.toHexString(user.optInt(UserExt.USER_POINT)));\r\n            } else {\r\n                user.put(UserExt.USER_T_POINT_CC, UserExt.toCCString(user.optInt(UserExt.USER_POINT)));\r\n            }\r\n            user.put(Common.MONEY, (int) Math.floor(user.optInt(UserExt.USER_USED_POINT) / moneyUnit));\r\n            avatarQueryService.fillUserAvatarURL(avatarViewMode, user);\r\n            ret.add(user);\r\n        }\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Gets top consumption users error\", e);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateRecyclerviewViewHolder.isLongClickable",
	"Comment": "determine if a long click listener should be automatically added to the view of this view holder",
	"Method": "boolean isLongClickable(){\r\n    return false;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.RoleQueryService.hasPermissions",
	"Comment": "checks whether the specified role has the specified requisite permissions.",
	"Method": "boolean hasPermissions(String roleId,Set<String> requisitePermissions){\r\n    final Set<String> permissions = getPermissions(roleId);\r\n    return Permission.hasPermission(requisitePermissions, permissions);\r\n}"
}, {
	"Path": "org.b3log.symphony.service.BreezemoonMgmtService.updateBreezemoon",
	"Comment": "updates a breezemoon with the specified request json object.",
	"Method": "void updateBreezemoon(JSONObject requestJSONObject){\r\n    final String content = requestJSONObject.optString(Breezemoon.BREEZEMOON_CONTENT);\r\n    if (optionQueryService.containReservedWord(content)) {\r\n        throw new ServiceException(langPropsService.get(\"contentContainReservedWordLabel\"));\r\n    }\r\n    final String id = requestJSONObject.optString(Keys.OBJECT_ID);\r\n    JSONObject old;\r\n    try {\r\n        old = breezemoonRepository.get(id);\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Gets a breezemoon [id=\" + id + \"] failed\", e);\r\n        throw new ServiceException(langPropsService.get(\"systemErrLabel\"));\r\n    }\r\n    if (null == old) {\r\n        throw new ServiceException(langPropsService.get(\"queryFailedLabel\"));\r\n    }\r\n    old.put(Breezemoon.BREEZEMOON_CONTENT, content);\r\n    old.put(Breezemoon.BREEZEMOON_AUTHOR_ID, requestJSONObject.optString(Breezemoon.BREEZEMOON_AUTHOR_ID, old.optString(Breezemoon.BREEZEMOON_AUTHOR_ID)));\r\n    old.put(Breezemoon.BREEZEMOON_IP, requestJSONObject.optString(Breezemoon.BREEZEMOON_IP));\r\n    String ua = requestJSONObject.optString(Breezemoon.BREEZEMOON_UA);\r\n    if (StringUtils.length(ua) > Common.MAX_LENGTH_UA) {\r\n        ua = StringUtils.substring(ua, 0, Common.MAX_LENGTH_UA);\r\n    }\r\n    old.put(Breezemoon.BREEZEMOON_UA, ua);\r\n    old.put(Breezemoon.BREEZEMOON_STATUS, requestJSONObject.optInt(Breezemoon.BREEZEMOON_STATUS, Breezemoon.BREEZEMOON_STATUS_C_VALID));\r\n    final long now = System.currentTimeMillis();\r\n    old.put(Breezemoon.BREEZEMOON_UPDATED, now);\r\n    try {\r\n        breezemoonRepository.update(id, old);\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Updates a breezemoon failed\", e);\r\n        throw new ServiceException(langPropsService.get(\"systemErrLabel\"));\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.client.android.result.AddressBookResultHandler.mapIndexToAction",
	"Comment": "positions, based on which fields are present in this barcode.",
	"Method": "int mapIndexToAction(int index){\r\n    if (index < buttonCount) {\r\n        int count = -1;\r\n        for (int x = 0; x < MAX_BUTTON_COUNT; x++) {\r\n            if (fields[x]) {\r\n                count++;\r\n            }\r\n            if (count == index) {\r\n                return x;\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.vip.vjstar.gc.ProactiveGcTask.preGc",
	"Comment": "stuff before gc. you can override this method to do your own stuff, for example, cache clean up, deregister from register center.",
	"Method": "void preGc(){\r\n    logger.warn(\"old gen is occupied larger than occupancy fraction[{}], trying to trigger gc...\", oldGenOccupancyFraction);\r\n}"
}, {
	"Path": "io.vertx.core.DeploymentOptions.setWorkerPoolName",
	"Comment": "set the worker pool name to use for this verticle. when no name is set, the vert.xworker pool will be used, when a name is set, the verticle will use a named worker pool.",
	"Method": "DeploymentOptions setWorkerPoolName(String workerPoolName){\r\n    this.workerPoolName = workerPoolName;\r\n    return this;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.LinkMgmtService.pingLink",
	"Comment": "pings the specified link with the specified count down latch.",
	"Method": "void pingLink(JSONObject link,CountDownLatch countDownLatch){\r\n    Symphonys.EXECUTOR_SERVICE.submit(new CheckTask(link, countDownLatch));\r\n}"
}, {
	"Path": "org.b3log.symphony.util.Symphonys.get",
	"Comment": "gets a configuration string property with the specified key.",
	"Method": "String get(String key){\r\n    return CFG.getProperty(key);\r\n}"
}, {
	"Path": "io.vertx.core.http.WebSocketFrame.pingFrame",
	"Comment": "create a ping websocket frame.will be a final frame. there is no option for non final ping frames.",
	"Method": "WebSocketFrame pingFrame(Buffer data){\r\n    return factory.pingFrame(data);\r\n}"
}, {
	"Path": "org.b3log.symphony.service.FollowMgmtService.followArticle",
	"Comment": "the specified follower follows the specified following article.",
	"Method": "void followArticle(String followerId,String followingArticleId){\r\n    try {\r\n        follow(followerId, followingArticleId, Follow.FOLLOWING_TYPE_C_ARTICLE);\r\n    } catch (final RepositoryException e) {\r\n        final String msg = \"User[id=\" + followerId + \"] follows an article[id=\" + followingArticleId + \"] failed\";\r\n        LOGGER.log(Level.ERROR, msg, e);\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.impl.launcher.commands.ExecUtils.addArgument",
	"Comment": "adds an argument to the given list. it automatically adds quotes to the argument if necessary.",
	"Method": "void addArgument(List<String> args,String argument){\r\n    args.add(quoteArgument(argument));\r\n}"
}, {
	"Path": "io.vertx.core.http.HttpServerOptions.getWebsocketAllowServerNoContext",
	"Comment": "get current setting to allow server no context for websocket compression",
	"Method": "boolean getWebsocketAllowServerNoContext(){\r\n    return this.websocketCompressionAllowServerNoContext;\r\n}"
}, {
	"Path": "io.vertx.core.parsetools.RecordParserTest.delimited",
	"Comment": "we create some input datahandler which containslines of lengths in randm order between 0 and linesand then passes them into the recordparser in chunk sizes from 0 to twice the total input buffer size",
	"Method": "void delimited(Buffer delim){\r\n    int lines = 50;\r\n    Buffer[] expected = new Buffer[lines];\r\n    List<Buffer> lineList = generateLines(lines, true, delim.getByte(0));\r\n    expected = lineList.toArray(expected);\r\n    int totLength = lines * (lines - 1) / 2;\r\n    Buffer inp = Buffer.buffer(totLength + lines * delim.length());\r\n    for (int i = 0; i < lines; i++) {\r\n        inp.appendBuffer(expected[i]);\r\n        inp.appendBuffer(delim);\r\n    }\r\n    for (int i = 1; i < inp.length() * 2; i++) {\r\n        doTestDelimited(inp, delim, new Integer[] { i }, expected);\r\n    }\r\n    List<Integer> chunkSizes = generateChunkSizes(lines);\r\n    for (int i = 0; i < 10; i++) {\r\n        Collections.shuffle(chunkSizes);\r\n        doTestDelimited(inp, delim, chunkSizes.toArray(new Integer[] {}), expected);\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.aztec.detector.Detector.getFirstDifferent",
	"Comment": "gets the coordinate of the first point with a different color in the given direction",
	"Method": "Point getFirstDifferent(Point init,boolean color,int dx,int dy){\r\n    int x = init.getX() + dx;\r\n    int y = init.getY() + dy;\r\n    while (isValid(x, y) && image.get(x, y) == color) {\r\n        x += dx;\r\n        y += dy;\r\n    }\r\n    x -= dx;\r\n    y -= dy;\r\n    while (isValid(x, y) && image.get(x, y) == color) {\r\n        x += dx;\r\n    }\r\n    x -= dx;\r\n    while (isValid(x, y) && image.get(x, y) == color) {\r\n        y += dy;\r\n    }\r\n    y -= dy;\r\n    return new Point(x, y);\r\n}"
}, {
	"Path": "com.vip.vjstar.gc.ProactiveGcTask.postGc",
	"Comment": "stuff after gc. you can override this method to do your own stuff, for example, cache warmup, reregister to register center.",
	"Method": "void postGc(){\r\n    logOldGenStatus(\"post gc\");\r\n}"
}, {
	"Path": "com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender.seal",
	"Comment": "seals the input message according to the payment method token specification.",
	"Method": "String seal(String message){\r\n    if (protocolVersion.equals(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V1) || protocolVersion.equals(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2) || protocolVersion.equals(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2_SIGNING_ONLY)) {\r\n        return sealV1OrV2(message);\r\n    }\r\n    throw new GeneralSecurityException(\"Unsupported version: \" + protocolVersion);\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.HkdfTest.computeHkdfHex",
	"Comment": "test version of hkdf where all inputs and outputs are hexadecimal.",
	"Method": "String computeHkdfHex(String macAlgorithm,String ikmHex,String saltHex,String infoHex,int size){\r\n    return TestUtil.hexEncode(Hkdf.computeHkdf(macAlgorithm, TestUtil.hexDecode(ikmHex), TestUtil.hexDecode(saltHex), TestUtil.hexDecode(infoHex), size));\r\n}"
}, {
	"Path": "us.codecraft.webmagic.Spider.setSpawnUrl",
	"Comment": "whether add urls extracted to download.add urls to download when it is true, and just download seed urls when it is false. do not set it unless you know what it means!",
	"Method": "Spider setSpawnUrl(boolean spawnUrl){\r\n    this.spawnUrl = spawnUrl;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.crypto.tink.util.KeysDownloader.getCurrentTimeInMillis",
	"Comment": "returns the current time in milliseconds since epoch.visible so tests can override it in subclasses.",
	"Method": "long getCurrentTimeInMillis(){\r\n    return Instant.now().getMillis();\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.gridSection.SectionedRecyclerViewAdapter.isSectionHeaderPosition",
	"Comment": "returns true if the argument position corresponds to a header",
	"Method": "boolean isSectionHeaderPosition(int position){\r\n    if (isHeader == null) {\r\n        setupIndices();\r\n    }\r\n    return isHeader[position];\r\n}"
}, {
	"Path": "io.vertx.test.core.TestUtils.assertNullPointerException",
	"Comment": "asserts that a nullpointerexception is thrown by the code block.",
	"Method": "void assertNullPointerException(Runnable runnable){\r\n    try {\r\n        runnable.run();\r\n        fail(\"Should throw NullPointerException\");\r\n    } catch (NullPointerException e) {\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.client.android.CaptureActivity.handleDecodeExternally",
	"Comment": "briefly show the contents of the barcode, then handle the result outside barcode scanner.",
	"Method": "void handleDecodeExternally(Result rawResult,ResultHandler resultHandler,Bitmap barcode){\r\n    if (barcode != null) {\r\n        viewfinderView.drawResultBitmap(barcode);\r\n    }\r\n    long resultDurationMS;\r\n    if (getIntent() == null) {\r\n        resultDurationMS = DEFAULT_INTENT_RESULT_DURATION_MS;\r\n    } else {\r\n        resultDurationMS = getIntent().getLongExtra(Intents.Scan.RESULT_DISPLAY_DURATION_MS, DEFAULT_INTENT_RESULT_DURATION_MS);\r\n    }\r\n    if (resultDurationMS > 0) {\r\n        String rawResultString = String.valueOf(rawResult);\r\n        if (rawResultString.length() > 32) {\r\n            rawResultString = rawResultString.substring(0, 32) + \" ...\";\r\n        }\r\n        statusView.setText(getString(resultHandler.getDisplayTitle()) + \" : \" + rawResultString);\r\n    }\r\n    maybeSetClipboard(resultHandler);\r\n    switch(source) {\r\n        case NATIVE_APP_INTENT:\r\n            Intent intent = new Intent(getIntent().getAction());\r\n            intent.addFlags(Intents.FLAG_NEW_DOC);\r\n            intent.putExtra(Intents.Scan.RESULT, rawResult.toString());\r\n            intent.putExtra(Intents.Scan.RESULT_FORMAT, rawResult.getBarcodeFormat().toString());\r\n            byte[] rawBytes = rawResult.getRawBytes();\r\n            if (rawBytes != null && rawBytes.length > 0) {\r\n                intent.putExtra(Intents.Scan.RESULT_BYTES, rawBytes);\r\n            }\r\n            Map<ResultMetadataType, ?> metadata = rawResult.getResultMetadata();\r\n            if (metadata != null) {\r\n                if (metadata.containsKey(ResultMetadataType.UPC_EAN_EXTENSION)) {\r\n                    intent.putExtra(Intents.Scan.RESULT_UPC_EAN_EXTENSION, metadata.get(ResultMetadataType.UPC_EAN_EXTENSION).toString());\r\n                }\r\n                Number orientation = (Number) metadata.get(ResultMetadataType.ORIENTATION);\r\n                if (orientation != null) {\r\n                    intent.putExtra(Intents.Scan.RESULT_ORIENTATION, orientation.intValue());\r\n                }\r\n                String ecLevel = (String) metadata.get(ResultMetadataType.ERROR_CORRECTION_LEVEL);\r\n                if (ecLevel != null) {\r\n                    intent.putExtra(Intents.Scan.RESULT_ERROR_CORRECTION_LEVEL, ecLevel);\r\n                }\r\n                @SuppressWarnings(\"unchecked\")\r\n                Iterable<byte[]> byteSegments = (Iterable<byte[]>) metadata.get(ResultMetadataType.BYTE_SEGMENTS);\r\n                if (byteSegments != null) {\r\n                    int i = 0;\r\n                    for (byte[] byteSegment : byteSegments) {\r\n                        intent.putExtra(Intents.Scan.RESULT_BYTE_SEGMENTS_PREFIX + i, byteSegment);\r\n                        i++;\r\n                    }\r\n                }\r\n            }\r\n            sendReplyMessage(R.id.return_scan_result, intent, resultDurationMS);\r\n            break;\r\n        case PRODUCT_SEARCH_LINK:\r\n            int end = sourceUrl.lastIndexOf(\"/scan\");\r\n            String productReplyURL = sourceUrl.substring(0, end) + \"?q=\" + resultHandler.getDisplayContents() + \"&source=zxing\";\r\n            sendReplyMessage(R.id.launch_product_query, productReplyURL, resultDurationMS);\r\n            break;\r\n        case ZXING_LINK:\r\n            if (scanFromWebPageManager != null && scanFromWebPageManager.isScanFromWebPage()) {\r\n                String linkReplyURL = scanFromWebPageManager.buildReplyURL(rawResult, resultHandler);\r\n                scanFromWebPageManager = null;\r\n                sendReplyMessage(R.id.launch_product_query, linkReplyURL, resultDurationMS);\r\n            }\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.util.Sessions.put",
	"Comment": "puts a value into session cache with the specified key and value.",
	"Method": "void put(String key,JSONObject value){\r\n    SESSION_CACHE.put(key, value);\r\n}"
}, {
	"Path": "io.vertx.core.dns.AddressResolverOptions.setSearchDomains",
	"Comment": "set the lists of dns search domains.when the search domain list is null, the effective search domain list will be populated usingthe system dns search domains.",
	"Method": "AddressResolverOptions setSearchDomains(List<String> searchDomains){\r\n    this.searchDomains = searchDomains;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateRecyclerView.setDefaultOnRefreshListener",
	"Comment": "set the listener when refresh is triggered and enable the swiperefreshlayout",
	"Method": "void setDefaultOnRefreshListener(SwipeRefreshLayout.OnRefreshListener listener){\r\n    mSwipeRefreshLayout.setEnabled(true);\r\n    if (defaultSwipeToDismissColors != null && defaultSwipeToDismissColors.length > 0) {\r\n        mSwipeRefreshLayout.setColorSchemeColors(defaultSwipeToDismissColors);\r\n    } else {\r\n        mSwipeRefreshLayout.setColorSchemeResources(android.R.color.holo_blue_bright, android.R.color.holo_green_light, android.R.color.holo_orange_light, android.R.color.holo_red_light);\r\n    }\r\n    mSwipeRefreshLayout.setOnRefreshListener(listener);\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.EllipticCurves.getModulus",
	"Comment": "returns the modulus of the field used by the curve specified in ecparams.",
	"Method": "BigInteger getModulus(EllipticCurve curve){\r\n    java.security.spec.ECField field = curve.getField();\r\n    if (field instanceof java.security.spec.ECFieldFp) {\r\n        return ((java.security.spec.ECFieldFp) field).getP();\r\n    } else {\r\n        throw new GeneralSecurityException(\"Only curves over prime order fields are supported\");\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.gridSection.SimpleSectionedAdapter.getTitleTextID",
	"Comment": "provides the identifier of the textview to render the section header title. override it ifyou provide a custom layout for a header.",
	"Method": "int getTitleTextID(){\r\n    return R.id.title_text;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.OptionQueryService.containReservedWord",
	"Comment": "checks whether the specified content contains reserved words.",
	"Method": "boolean containReservedWord(String content){\r\n    if (StringUtils.isBlank(content)) {\r\n        return false;\r\n    }\r\n    try {\r\n        final List<JSONObject> reservedWords = getReservedWords();\r\n        for (final JSONObject reservedWord : reservedWords) {\r\n            if (content.contains(reservedWord.optString(Option.OPTION_VALUE))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    } catch (final Exception e) {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.qrcode.decoder.DataBlock.getDataBlocks",
	"Comment": "when qr codes use multiple data blocks, they are actually interleaved.that is, the first byte of data block 1 to n is written, then the second bytes, and so on. thismethod will separate the data into original blocks.",
	"Method": "DataBlock[] getDataBlocks(byte[] rawCodewords,Version version,ErrorCorrectionLevel ecLevel){\r\n    if (rawCodewords.length != version.getTotalCodewords()) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    Version.ECBlocks ecBlocks = version.getECBlocksForLevel(ecLevel);\r\n    int totalBlocks = 0;\r\n    Version.ECB[] ecBlockArray = ecBlocks.getECBlocks();\r\n    for (Version.ECB ecBlock : ecBlockArray) {\r\n        totalBlocks += ecBlock.getCount();\r\n    }\r\n    DataBlock[] result = new DataBlock[totalBlocks];\r\n    int numResultBlocks = 0;\r\n    for (Version.ECB ecBlock : ecBlockArray) {\r\n        for (int i = 0; i < ecBlock.getCount(); i++) {\r\n            int numDataCodewords = ecBlock.getDataCodewords();\r\n            int numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;\r\n            result[numResultBlocks++] = new DataBlock(numDataCodewords, new byte[numBlockCodewords]);\r\n        }\r\n    }\r\n    int shorterBlocksTotalCodewords = result[0].codewords.length;\r\n    int longerBlocksStartAt = result.length - 1;\r\n    while (longerBlocksStartAt >= 0) {\r\n        int numCodewords = result[longerBlocksStartAt].codewords.length;\r\n        if (numCodewords == shorterBlocksTotalCodewords) {\r\n            break;\r\n        }\r\n        longerBlocksStartAt--;\r\n    }\r\n    longerBlocksStartAt++;\r\n    int shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();\r\n    int rawCodewordsOffset = 0;\r\n    for (int i = 0; i < shorterBlocksNumDataCodewords; i++) {\r\n        for (int j = 0; j < numResultBlocks; j++) {\r\n            result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];\r\n        }\r\n    }\r\n    for (int j = longerBlocksStartAt; j < numResultBlocks; j++) {\r\n        result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];\r\n    }\r\n    int max = result[0].codewords.length;\r\n    for (int i = shorterBlocksNumDataCodewords; i < max; i++) {\r\n        for (int j = 0; j < numResultBlocks; j++) {\r\n            int iOffset = j < longerBlocksStartAt ? i : i + 1;\r\n            result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.google.zxing.BinaryBitmap.getBlackRow",
	"Comment": "converts one row of luminance data to 1 bit data. may actually do the conversion, or returncached data. callers should assume this method is expensive and call it as seldom as possible.this method is intended for decoding 1d barcodes and may choose to apply sharpening.",
	"Method": "BitArray getBlackRow(int y,BitArray row){\r\n    return binarizer.getBlackRow(y, row);\r\n}"
}, {
	"Path": "org.b3log.symphony.service.FollowMgmtService.followTag",
	"Comment": "the specified follower follows the specified following tag.",
	"Method": "void followTag(String followerId,String followingTagId){\r\n    try {\r\n        follow(followerId, followingTagId, Follow.FOLLOWING_TYPE_C_TAG);\r\n    } catch (final RepositoryException e) {\r\n        final String msg = \"User[id=\" + followerId + \"] follows a tag[id=\" + followingTagId + \"] failed\";\r\n        LOGGER.log(Level.ERROR, msg, e);\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManagerTest.testGetPublicKeyData",
	"Comment": "tests that a public key is extracted properly from a private key.",
	"Method": "void testGetPublicKeyData(){\r\n    KeysetHandle privateHandle = KeysetHandle.generateNew(HybridKeyTemplates.ECIES_P256_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256);\r\n    KeyData privateKeyData = TestUtil.getKeyset(privateHandle).getKey(0).getKeyData();\r\n    EciesAeadHkdfPrivateKeyManager privateManager = new EciesAeadHkdfPrivateKeyManager();\r\n    KeyData publicKeyData = privateManager.getPublicKeyData(privateKeyData.getValue());\r\n    assertEquals(EciesAeadHkdfPublicKeyManager.TYPE_URL, publicKeyData.getTypeUrl());\r\n    assertEquals(KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC, publicKeyData.getKeyMaterialType());\r\n    EciesAeadHkdfPrivateKey privateKey = EciesAeadHkdfPrivateKey.parseFrom(privateKeyData.getValue());\r\n    assertArrayEquals(privateKey.getPublicKey().toByteArray(), publicKeyData.getValue().toByteArray());\r\n    EciesAeadHkdfPublicKeyManager publicManager = new EciesAeadHkdfPublicKeyManager();\r\n    HybridEncrypt hybridEncrypt = publicManager.getPrimitive(publicKeyData.getValue());\r\n    HybridDecrypt hybridDecrypt = privateManager.getPrimitive(privateKeyData.getValue());\r\n    byte[] message = Random.randBytes(20);\r\n    byte[] contextInfo = Random.randBytes(20);\r\n    assertArrayEquals(message, hybridDecrypt.decrypt(hybridEncrypt.encrypt(message, contextInfo), contextInfo));\r\n}"
}, {
	"Path": "io.swagger.v3.jaxrs2.resources.SubResourceHead.getWildcardClass",
	"Comment": "this path is expected to be skipped as resource class is unknown here.",
	"Method": "Class<?> getWildcardClass(){\r\n    return null;\r\n}"
}, {
	"Path": "org.b3log.symphony.processor.channel.ArticleListChannel.onConnect",
	"Comment": "called when the socket connection with the browser is established.",
	"Method": "void onConnect(Session session){\r\n    final String articleIds = Channels.getHttpParameter(session, Article.ARTICLE_T_IDS);\r\n    if (StringUtils.isBlank(articleIds)) {\r\n        return;\r\n    }\r\n    SESSIONS.put(session, articleIds);\r\n}"
}, {
	"Path": "io.vertx.core.dns.AddressResolverOptions.setHostsPath",
	"Comment": "set the path of an alternate hosts configuration file to use instead of the one provided by the os.the default value is null, so the operating system hosts config is used.",
	"Method": "AddressResolverOptions setHostsPath(String hostsPath){\r\n    this.hostsPath = hostsPath;\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.http.HttpClientOptions.setDefaultHost",
	"Comment": "set the default host name to be used by this client in requests if none is provided when making the request.",
	"Method": "HttpClientOptions setDefaultHost(String defaultHost){\r\n    this.defaultHost = defaultHost;\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.net.impl.VertxHandler.setConnection",
	"Comment": "set the connection, this is called when the channel is added to the pipeline.",
	"Method": "void setConnection(C connection){\r\n    conn = connection;\r\n    endReadAndFlush = v -> conn.endReadAndFlush();\r\n    messageHandler = ((ConnectionBase) conn)::handleRead;\r\n    if (addHandler != null) {\r\n        addHandler.handle(connection);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.repository.CommentRepository.removeComment",
	"Comment": "removes a comment specified with the given comment id. calls this method will remove all existed data relatedwith the specified comment forcibly.",
	"Method": "void removeComment(String commentId){\r\n    final JSONObject comment = get(commentId);\r\n    if (null == comment) {\r\n        return;\r\n    }\r\n    remove(comment.optString(Keys.OBJECT_ID));\r\n    final String commentAuthorId = comment.optString(Comment.COMMENT_AUTHOR_ID);\r\n    final JSONObject commenter = userRepository.get(commentAuthorId);\r\n    commenter.put(UserExt.USER_COMMENT_COUNT, commenter.optInt(UserExt.USER_COMMENT_COUNT) - 1);\r\n    userRepository.update(commentAuthorId, commenter);\r\n    final String articleId = comment.optString(Comment.COMMENT_ON_ARTICLE_ID);\r\n    final JSONObject article = articleRepository.get(articleId);\r\n    article.put(Article.ARTICLE_COMMENT_CNT, article.optInt(Article.ARTICLE_COMMENT_CNT) - 1);\r\n    if (0 < article.optInt(Article.ARTICLE_COMMENT_CNT)) {\r\n        final Query latestCmtQuery = new Query().setFilter(new PropertyFilter(Comment.COMMENT_ON_ARTICLE_ID, FilterOperator.EQUAL, articleId)).addSort(Keys.OBJECT_ID, SortDirection.DESCENDING).setCurrentPageNum(1).setPageSize(1);\r\n        final JSONObject latestCmt = get(latestCmtQuery).optJSONArray(Keys.RESULTS).optJSONObject(0);\r\n        article.put(Article.ARTICLE_LATEST_CMT_TIME, latestCmt.optLong(Keys.OBJECT_ID));\r\n        final JSONObject latestCmtAuthor = userRepository.get(latestCmt.optString(Comment.COMMENT_AUTHOR_ID));\r\n        article.put(Article.ARTICLE_LATEST_CMTER_NAME, latestCmtAuthor.optString(User.USER_NAME));\r\n    } else {\r\n        article.put(Article.ARTICLE_LATEST_CMT_TIME, articleId);\r\n        article.put(Article.ARTICLE_LATEST_CMTER_NAME, \"\");\r\n    }\r\n    articleRepository.update(articleId, article);\r\n    final Query query = new Query().setFilter(CompositeFilterOperator.and(new PropertyFilter(Revision.REVISION_DATA_ID, FilterOperator.EQUAL, commentId), new PropertyFilter(Revision.REVISION_DATA_TYPE, FilterOperator.EQUAL, Revision.DATA_TYPE_C_COMMENT)));\r\n    final JSONArray commentRevisions = revisionRepository.get(query).optJSONArray(Keys.RESULTS);\r\n    for (int j = 0; j < commentRevisions.length(); j++) {\r\n        final JSONObject articleRevision = commentRevisions.optJSONObject(j);\r\n        revisionRepository.remove(articleRevision.optString(Keys.OBJECT_ID));\r\n    }\r\n    final JSONObject commentCntOption = optionRepository.get(Option.ID_C_STATISTIC_CMT_COUNT);\r\n    commentCntOption.put(Option.OPTION_VALUE, commentCntOption.optInt(Option.OPTION_VALUE) - 1);\r\n    optionRepository.update(Option.ID_C_STATISTIC_CMT_COUNT, commentCntOption);\r\n    final String originalCommentId = comment.optString(Comment.COMMENT_ORIGINAL_COMMENT_ID);\r\n    if (StringUtils.isNotBlank(originalCommentId)) {\r\n        final JSONObject originalComment = get(originalCommentId);\r\n        if (null != originalComment) {\r\n            originalComment.put(Comment.COMMENT_REPLY_CNT, originalComment.optInt(Comment.COMMENT_REPLY_CNT) - 1);\r\n            update(originalCommentId, originalComment);\r\n        }\r\n    }\r\n    notificationRepository.removeByDataId(commentId);\r\n}"
}, {
	"Path": "org.b3log.symphony.service.VoteQueryService.isOwn",
	"Comment": "determines whether the specified data dose belong to the specified user.",
	"Method": "boolean isOwn(String userId,String dataId,int dataType){\r\n    try {\r\n        if (Vote.DATA_TYPE_C_ARTICLE == dataType) {\r\n            final JSONObject article = articleRepository.get(dataId);\r\n            if (null == article) {\r\n                LOGGER.log(Level.ERROR, \"Not found article [id={0}]\", dataId);\r\n                return false;\r\n            }\r\n            return article.optString(Article.ARTICLE_AUTHOR_ID).equals(userId);\r\n        } else if (Vote.DATA_TYPE_C_COMMENT == dataType) {\r\n            final JSONObject comment = commentRepository.get(dataId);\r\n            if (null == comment) {\r\n                LOGGER.log(Level.ERROR, \"Not found comment [id={0}]\", dataId);\r\n                return false;\r\n            }\r\n            return comment.optString(Comment.COMMENT_AUTHOR_ID).equals(userId);\r\n        }\r\n        return false;\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, e.getMessage());\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.NormalUltimateViewAdapter.getItemCount",
	"Comment": "returns the total number of items in the data set hold by the adapter.",
	"Method": "int getItemCount(){\r\n    int headerOrFooter = 0;\r\n    if (customHeaderView != null)\r\n        headerOrFooter++;\r\n    if (customLoadMoreView != null)\r\n        headerOrFooter++;\r\n    return getAdapterItemCount() + headerOrFooter;\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest.testEncryptDecryptRandomAccess",
	"Comment": "encrypt and then decrypt partially, and check that the result is the same.",
	"Method": "void testEncryptDecryptRandomAccess(int keySizeInBytes,int segmentSize,int firstSegmentOffset,int plaintextSize){\r\n    if (TestUtil.shouldSkipTestWithAesKeySize(keySizeInBytes)) {\r\n        return;\r\n    }\r\n    byte[] ikm = TestUtil.hexDecode(\"000102030405060708090a0b0c0d0e0f00112233445566778899aabbccddeeff\");\r\n    AesGcmHkdfStreaming ags = new AesGcmHkdfStreaming(ikm, \"HmacSha256\", keySizeInBytes, segmentSize, firstSegmentOffset);\r\n    StreamingTestUtil.testEncryptDecryptRandomAccess(ags, firstSegmentOffset, plaintextSize);\r\n}"
}, {
	"Path": "com.google.crypto.tink.StreamingTestUtil.testSkipWithStream",
	"Comment": "encrypts and decrypts some plaintext in a stream using skips and checks that the expectedplaintext is returned for the parts not skipped.",
	"Method": "void testSkipWithStream(StreamingAead ags,int firstSegmentOffset,int plaintextSize,int chunkSize){\r\n    byte[] aad = TestUtil.hexDecode(\"aabbccddeeff\");\r\n    byte[] plaintext = generatePlaintext(plaintextSize);\r\n    byte[] ciphertext = encryptWithStream(ags, plaintext, aad, firstSegmentOffset);\r\n    for (int skipChunk = 0; skipChunk < 2; skipChunk++) {\r\n        InputStream ctStream = new ByteArrayInputStream(ciphertext);\r\n        ctStream.read(new byte[firstSegmentOffset]);\r\n        InputStream ptStream = ags.newDecryptingStream(ctStream, aad);\r\n        int decryptedSize = 0;\r\n        int chunkNumber = 0;\r\n        while (true) {\r\n            if (chunkNumber % 2 == skipChunk) {\r\n                int bytesSkipped = (int) ptStream.skip(chunkSize);\r\n                if (bytesSkipped < 0) {\r\n                    fail(\"skip must not return a negative integer (not even at eof).\");\r\n                }\r\n                if (bytesSkipped == 0) {\r\n                    assertEquals(\"Expecting end of stream after a 0-byte skip.\", -1, ptStream.read());\r\n                    break;\r\n                }\r\n                decryptedSize += bytesSkipped;\r\n                if (decryptedSize < plaintextSize) {\r\n                    assertEquals(\"Size of skipped chunk is invalid\", chunkSize, bytesSkipped);\r\n                }\r\n            } else {\r\n                byte[] chunk = new byte[chunkSize];\r\n                int read = ptStream.read(chunk);\r\n                if (read == -1) {\r\n                    break;\r\n                }\r\n                byte[] expected = Arrays.copyOfRange(plaintext, decryptedSize, decryptedSize + read);\r\n                TestUtil.assertByteArrayEquals(expected, Arrays.copyOf(chunk, read));\r\n                decryptedSize += read;\r\n                if (read < chunkSize && decryptedSize < plaintextSize) {\r\n                    fail(\"read did not return enough bytes\");\r\n                }\r\n            }\r\n            chunkNumber += 1;\r\n        }\r\n        assertEquals(\"Size of decryption does not match plaintext\", plaintextSize, decryptedSize);\r\n    }\r\n    InputStream brokenCtStream = new ByteArrayInputStream(ciphertext, 0, ciphertext.length - 1);\r\n    brokenCtStream.read(new byte[firstSegmentOffset]);\r\n    InputStream brokenPtStream = ags.newDecryptingStream(brokenCtStream, aad);\r\n    try {\r\n        brokenPtStream.skip(2 * plaintextSize);\r\n        brokenPtStream.read();\r\n        fail(\"Failed to detect invalid ciphertext\");\r\n    } catch (IOException ex) {\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.Kwp.computeW",
	"Comment": "computes the pseudorandom permutation w over the ivconcatenated with zero padded key material.",
	"Method": "byte[] computeW(byte[] iv,byte[] key){\r\n    if (key.length <= 8 || key.length > Integer.MAX_VALUE - 16 || iv.length != 8) {\r\n        throw new GeneralSecurityException(\"computeW called with invalid parameters\");\r\n    }\r\n    byte[] data = new byte[wrappingSize(key.length)];\r\n    System.arraycopy(iv, 0, data, 0, iv.length);\r\n    System.arraycopy(key, 0, data, 8, key.length);\r\n    int blocks = data.length / 8 - 1;\r\n    Cipher aes = EngineFactory.CIPHER.getInstance(\"AES/ECB/NoPadding\");\r\n    aes.init(Cipher.ENCRYPT_MODE, aesKey);\r\n    byte[] block = new byte[16];\r\n    System.arraycopy(data, 0, block, 0, 8);\r\n    for (int i = 0; i < ROUNDS; i++) {\r\n        for (int j = 0; j < blocks; j++) {\r\n            System.arraycopy(data, 8 * (j + 1), block, 8, 8);\r\n            int length = aes.doFinal(block, 0, 16, block);\r\n            assert length == 16;\r\n            int roundConst = i * blocks + j + 1;\r\n            for (int b = 0; b < 4; b++) {\r\n                block[7 - b] ^= (byte) (roundConst & 0xff);\r\n                roundConst >>>= 8;\r\n            }\r\n            System.arraycopy(block, 8, data, 8 * (j + 1), 8);\r\n        }\r\n    }\r\n    System.arraycopy(block, 0, data, 0, 8);\r\n    return data;\r\n}"
}, {
	"Path": "com.google.zxing.datamatrix.detector.Detector.correctTopRight",
	"Comment": "calculates the corner position of the white top right module.",
	"Method": "ResultPoint correctTopRight(ResultPoint[] points){\r\n    ResultPoint pointA = points[0];\r\n    ResultPoint pointB = points[1];\r\n    ResultPoint pointC = points[2];\r\n    ResultPoint pointD = points[3];\r\n    int trTop = transitionsBetween(pointA, pointD);\r\n    int trRight = transitionsBetween(pointB, pointD);\r\n    ResultPoint pointAs = shiftPoint(pointA, pointB, (trRight + 1) * 4);\r\n    ResultPoint pointCs = shiftPoint(pointC, pointB, (trTop + 1) * 4);\r\n    trTop = transitionsBetween(pointAs, pointD);\r\n    trRight = transitionsBetween(pointCs, pointD);\r\n    ResultPoint candidate1 = new ResultPoint(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));\r\n    ResultPoint candidate2 = new ResultPoint(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));\r\n    if (!isValid(candidate1)) {\r\n        if (isValid(candidate2)) {\r\n            return candidate2;\r\n        }\r\n        return null;\r\n    }\r\n    if (!isValid(candidate2)) {\r\n        return candidate1;\r\n    }\r\n    int sumc1 = transitionsBetween(pointAs, candidate1) + transitionsBetween(pointCs, candidate1);\r\n    int sumc2 = transitionsBetween(pointAs, candidate2) + transitionsBetween(pointCs, candidate2);\r\n    if (sumc1 > sumc2) {\r\n        return candidate1;\r\n    } else {\r\n        return candidate2;\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.impl.launcher.commands.RunCommand.setWorker",
	"Comment": "whether or not the verticle is deployed as a worker verticle.",
	"Method": "void setWorker(boolean worker){\r\n    this.worker = worker;\r\n}"
}, {
	"Path": "com.vip.vjtools.vjkit.collection.type.primitive.LongObjectHashMap.removeAt",
	"Comment": "removes entry at the given index position. also performs opportunistic, incremental rehashing if necessary to not\tbreak conflict chains.",
	"Method": "boolean removeAt(int index){\r\n    --size;\r\n    keys[index] = 0;\r\n    values[index] = null;\r\n    int nextFree = index;\r\n    int i = probeNext(index);\r\n    for (V value = values[i]; value != null; value = values[i = probeNext(i)]) {\r\n        long key = keys[i];\r\n        int bucket = hashIndex(key);\r\n        if (i < bucket && (bucket <= nextFree || nextFree <= i) || bucket <= nextFree && nextFree <= i) {\r\n            keys[nextFree] = key;\r\n            values[nextFree] = value;\r\n            keys[i] = 0;\r\n            values[i] = null;\r\n            nextFree = i;\r\n        }\r\n    }\r\n    return nextFree != index;\r\n}"
}, {
	"Path": "io.vertx.core.spi.metrics.VertxMetrics.createHttpClientMetrics",
	"Comment": "provides the http client metrics spi when an http client has been created.no specific thread and context can be expected when this method is called.",
	"Method": "HttpClientMetrics<?, ?, ?, ?, ?> createHttpClientMetrics(HttpClientOptions options){\r\n    return null;\r\n}"
}, {
	"Path": "com.google.crypto.tink.KeysetHandle.assertEnoughKeyMaterial",
	"Comment": "validates that an keyset handle contains enough key material to build a keyset on.",
	"Method": "void assertEnoughKeyMaterial(Keyset keyset){\r\n    if (keyset == null || keyset.getKeyCount() <= 0) {\r\n        throw new GeneralSecurityException(\"empty keyset\");\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.impl.HAManager.init",
	"Comment": "initialize the ha manager, i.e register the node listener to propagates the node events andstart the quorum timer. the quorum will be checked as well.",
	"Method": "void init(){\r\n    synchronized (haInfo) {\r\n        clusterMap.put(nodeID, haInfo.encode());\r\n    }\r\n    clusterManager.nodeListener(new NodeListener() {\r\n        @Override\r\n        public void nodeAdded(String nodeID) {\r\n            HAManager.this.nodeAdded(nodeID);\r\n        }\r\n        @Override\r\n        public void nodeLeft(String leftNodeID) {\r\n            HAManager.this.nodeLeft(leftNodeID);\r\n        }\r\n    });\r\n    quorumTimerID = vertx.setPeriodic(QUORUM_CHECK_PERIOD, tid -> checkHADeployments());\r\n    synchronized (this) {\r\n        checkQuorum();\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.impl.HAManager.init",
	"Comment": "initialize the ha manager, i.e register the node listener to propagates the node events andstart the quorum timer. the quorum will be checked as well.",
	"Method": "void init(){\r\n    HAManager.this.nodeAdded(nodeID);\r\n}"
}, {
	"Path": "io.vertx.core.impl.HAManager.init",
	"Comment": "initialize the ha manager, i.e register the node listener to propagates the node events andstart the quorum timer. the quorum will be checked as well.",
	"Method": "void init(){\r\n    HAManager.this.nodeLeft(leftNodeID);\r\n}"
}, {
	"Path": "com.google.zxing.common.GlobalHistogramBinarizer.getBlackMatrix",
	"Comment": "does not sharpen the data, as this call is intended to only be used by 2d readers.",
	"Method": "BitMatrix getBlackMatrix(){\r\n    LuminanceSource source = getLuminanceSource();\r\n    int width = source.getWidth();\r\n    int height = source.getHeight();\r\n    BitMatrix matrix = new BitMatrix(width, height);\r\n    initArrays(width);\r\n    int[] localBuckets = buckets;\r\n    for (int y = 1; y < 5; y++) {\r\n        int row = height * y / 5;\r\n        byte[] localLuminances = source.getRow(row, luminances);\r\n        int right = (width * 4) / 5;\r\n        for (int x = width / 5; x < right; x++) {\r\n            int pixel = localLuminances[x] & 0xff;\r\n            localBuckets[pixel >> LUMINANCE_SHIFT]++;\r\n        }\r\n    }\r\n    int blackPoint = estimateBlackPoint(localBuckets);\r\n    byte[] localLuminances = source.getMatrix();\r\n    for (int y = 0; y < height; y++) {\r\n        int offset = y * width;\r\n        for (int x = 0; x < width; x++) {\r\n            int pixel = localLuminances[offset + x] & 0xff;\r\n            if (pixel < blackPoint) {\r\n                matrix.set(x, y);\r\n            }\r\n        }\r\n    }\r\n    return matrix;\r\n}"
}, {
	"Path": "com.google.zxing.pdf417.decoder.DetectionResultRowIndicatorColumn.adjustCompleteIndicatorColumnRowNumbers",
	"Comment": "use row height count to make detection of invalid row numbers more reliable",
	"Method": "void adjustCompleteIndicatorColumnRowNumbers(BarcodeMetadata barcodeMetadata){\r\n    Codeword[] codewords = getCodewords();\r\n    setRowNumbers();\r\n    removeIncorrectCodewords(codewords, barcodeMetadata);\r\n    BoundingBox boundingBox = getBoundingBox();\r\n    ResultPoint top = isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();\r\n    ResultPoint bottom = isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();\r\n    int firstRow = imageRowToCodewordIndex((int) top.getY());\r\n    int lastRow = imageRowToCodewordIndex((int) bottom.getY());\r\n    int barcodeRow = -1;\r\n    int maxRowHeight = 1;\r\n    int currentRowHeight = 0;\r\n    for (int codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {\r\n        if (codewords[codewordsRow] == null) {\r\n            continue;\r\n        }\r\n        Codeword codeword = codewords[codewordsRow];\r\n        int rowDifference = codeword.getRowNumber() - barcodeRow;\r\n        if (rowDifference == 0) {\r\n            currentRowHeight++;\r\n        } else if (rowDifference == 1) {\r\n            maxRowHeight = Math.max(maxRowHeight, currentRowHeight);\r\n            currentRowHeight = 1;\r\n            barcodeRow = codeword.getRowNumber();\r\n        } else if (rowDifference < 0 || codeword.getRowNumber() >= barcodeMetadata.getRowCount() || rowDifference > codewordsRow) {\r\n            codewords[codewordsRow] = null;\r\n        } else {\r\n            int checkedRows;\r\n            if (maxRowHeight > 2) {\r\n                checkedRows = (maxRowHeight - 2) * rowDifference;\r\n            } else {\r\n                checkedRows = rowDifference;\r\n            }\r\n            boolean closePreviousCodewordFound = checkedRows >= codewordsRow;\r\n            for (int i = 1; i <= checkedRows && !closePreviousCodewordFound; i++) {\r\n                closePreviousCodewordFound = codewords[codewordsRow - i] != null;\r\n            }\r\n            if (closePreviousCodewordFound) {\r\n                codewords[codewordsRow] = null;\r\n            } else {\r\n                barcodeRow = codeword.getRowNumber();\r\n                currentRowHeight = 1;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.model.UserExt.isWhitelistMailDomain",
	"Comment": "checks the specified email whether in a whitelist mail domain.",
	"Method": "boolean isWhitelistMailDomain(String email){\r\n    final String whitelistMailDomains = Symphonys.get(\"whitelist.mailDomains\");\r\n    if (StringUtils.isBlank(whitelistMailDomains)) {\r\n        return true;\r\n    }\r\n    final String domain = StringUtils.substringAfter(email, \"@\");\r\n    return StringUtils.containsIgnoreCase(whitelistMailDomains, domain);\r\n}"
}, {
	"Path": "com.vip.vjtools.vjtop.VMInfo.createDeadVM",
	"Comment": "creates a dead vminfo, representing a jvm in a given state which cannot\tbe attached or other monitoring issues occurred.",
	"Method": "VMInfo createDeadVM(String pid,VMInfoState state){\r\n    VMInfo vmInfo = new VMInfo();\r\n    vmInfo.state = state;\r\n    vmInfo.pid = pid;\r\n    return vmInfo;\r\n}"
}, {
	"Path": "com.google.zxing.client.android.DecodeHandler.decode",
	"Comment": "decode the data within the viewfinder rectangle, and time how long it took. for efficiency,reuse the same reader objects from one decode to the next.",
	"Method": "void decode(byte[] data,int width,int height){\r\n    long start = System.currentTimeMillis();\r\n    Result rawResult = null;\r\n    PlanarYUVLuminanceSource source = activity.getCameraManager().buildLuminanceSource(data, width, height);\r\n    if (source != null) {\r\n        BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));\r\n        try {\r\n            rawResult = multiFormatReader.decodeWithState(bitmap);\r\n        } catch (ReaderException re) {\r\n        } finally {\r\n            multiFormatReader.reset();\r\n        }\r\n    }\r\n    Handler handler = activity.getHandler();\r\n    if (rawResult != null) {\r\n        long end = System.currentTimeMillis();\r\n        Log.d(TAG, \"Found barcode in \" + (end - start) + \" ms\");\r\n        if (handler != null) {\r\n            Message message = Message.obtain(handler, R.id.decode_succeeded, rawResult);\r\n            Bundle bundle = new Bundle();\r\n            bundleThumbnail(source, bundle);\r\n            message.setData(bundle);\r\n            message.sendToTarget();\r\n        }\r\n    } else {\r\n        if (handler != null) {\r\n            Message message = Message.obtain(handler, R.id.decode_failed);\r\n            message.sendToTarget();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.ChaCha20Poly1305Test.testRandomNonce",
	"Comment": "this is a very simple test for the randomness of the nonce. the test simply checks that themultiple ciphertexts of the same message are distinct.",
	"Method": "void testRandomNonce(){\r\n    byte[] key = Random.randBytes(KEY_SIZE);\r\n    Aead aead = createInstance(key);\r\n    byte[] message = new byte[0];\r\n    byte[] aad = new byte[0];\r\n    HashSet<String> ciphertexts = new HashSet<String>();\r\n    final int samples = 1 << 10;\r\n    for (int i = 0; i < samples; i++) {\r\n        byte[] ct = aead.encrypt(message, aad);\r\n        String ctHex = TestUtil.hexEncode(ct);\r\n        assertFalse(ciphertexts.contains(ctHex));\r\n        ciphertexts.add(ctHex);\r\n    }\r\n    assertEquals(samples, ciphertexts.size());\r\n}"
}, {
	"Path": "com.google.zxing.common.BitMatrix.getRow",
	"Comment": "a fast method to retrieve one row of data from the matrix as a bitarray.",
	"Method": "BitArray getRow(int y,BitArray row){\r\n    if (row == null || row.getSize() < width) {\r\n        row = new BitArray(width);\r\n    } else {\r\n        row.clear();\r\n    }\r\n    int offset = y * rowSize;\r\n    for (int x = 0; x < rowSize; x++) {\r\n        row.setBulk(x * 32, bits[offset + x]);\r\n    }\r\n    return row;\r\n}"
}, {
	"Path": "io.vertx.core.net.TCPSSLOptions.addEnabledCipherSuite",
	"Comment": "add an enabled cipher suite, appended to the ordered suites.",
	"Method": "TCPSSLOptions addEnabledCipherSuite(String suite){\r\n    enabledCipherSuites.add(suite);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel.tryReadHeader",
	"Comment": "tries to read the header of the ciphertext and derive the key used for theciphertext from the information in the header.",
	"Method": "boolean tryReadHeader(){\r\n    ciphertextChannel.position(header.position() + firstSegmentOffset);\r\n    ciphertextChannel.read(header);\r\n    if (header.remaining() > 0) {\r\n        return false;\r\n    } else {\r\n        header.flip();\r\n        try {\r\n            decrypter.init(header, aad);\r\n            headerRead = true;\r\n        } catch (GeneralSecurityException ex) {\r\n            throw new IOException(ex);\r\n        }\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.VertxOptions.getClusterPingInterval",
	"Comment": "get the value of cluster ping interval, in ms.nodes in the cluster ping each other at this interval to determine whether they are still running.",
	"Method": "long getClusterPingInterval(){\r\n    return getEventBusOptions().getClusterPingInterval();\r\n}"
}, {
	"Path": "org.b3log.symphony.service.FollowMgmtService.unfollowTag",
	"Comment": "the specified follower unfollows the specified following tag.",
	"Method": "void unfollowTag(String followerId,String followingTagId){\r\n    try {\r\n        unfollow(followerId, followingTagId, Follow.FOLLOWING_TYPE_C_TAG);\r\n    } catch (final RepositoryException e) {\r\n        final String msg = \"User[id=\" + followerId + \"] unfollows a tag[id=\" + followingTagId + \"] failed\";\r\n        LOGGER.log(Level.ERROR, msg, e);\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.cli.UsageMessageFormatter.computeOptionsAndArguments",
	"Comment": "computes the help for the specified options to the specified writer.",
	"Method": "void computeOptionsAndArguments(StringBuilder buffer,List<Option> options,List<Argument> arguments){\r\n    renderOptionsAndArguments(buffer, options, arguments);\r\n    buffer.append(newLine);\r\n}"
}, {
	"Path": "us.codecraft.webmagic.Site.getCycleRetryTimes",
	"Comment": "when cycleretrytimes is more than 0, it will add back to scheduler and try download again.",
	"Method": "int getCycleRetryTimes(){\r\n    return cycleRetryTimes;\r\n}"
}, {
	"Path": "org.b3log.symphony.processor.SkinRenderer.getTemplate",
	"Comment": "gets a template with the specified search engine bot flag and user.",
	"Method": "Template getTemplate(boolean isSearchEngineBot,JSONObject user,Template getTemplate){\r\n    final boolean isSearchEngineBot = (Boolean) request.getAttribute(Keys.HttpRequest.IS_SEARCH_ENGINE_BOT);\r\n    final JSONObject user = (JSONObject) request.getAttribute(Common.CURRENT_USER);\r\n    return getTemplate(isSearchEngineBot, user);\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.ItemTouchListenerAdapter.shiftAdjustInt",
	"Comment": "case out and fix the bug from offseted number from admobadapterfixed by jjheskone more thing is that the first item display in the list got to be clickable.",
	"Method": "int shiftAdjustInt(int position){\r\n    if (recyclerView.getAdapter() instanceof AdmobAdapter && position > 0) {\r\n        AdmobAdapter adp = (AdmobAdapter) recyclerView.getAdapter();\r\n        return adp.isPosOnAdView(position) ? AdmobAdapter.POSITION_ON_AD : adp.getFinalShiftPosition(position);\r\n    } else {\r\n        return position;\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.cli.UsageMessageFormatter.appendArgument",
	"Comment": "appends the usage clause for an argument to a stringbuilder.",
	"Method": "void appendArgument(StringBuilder buff,Argument argument,boolean required){\r\n    if (argument.isHidden()) {\r\n        return;\r\n    }\r\n    if (!required) {\r\n        buff.append(\"[\");\r\n    }\r\n    buff.append(argument.getArgName());\r\n    if (argument.isMultiValued()) {\r\n        buff.append(\"...\");\r\n    }\r\n    if (!required) {\r\n        buff.append(\"]\");\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.net.NetTest.testConnectSSLWithSocks5Proxy",
	"Comment": "test socks5 proxy when accessing ssl server port with correct cert.",
	"Method": "void testConnectSSLWithSocks5Proxy(){\r\n    server.close();\r\n    NetServerOptions options = new NetServerOptions().setPort(1234).setHost(\"localhost\").setSsl(true).setKeyCertOptions(Cert.SERVER_JKS_ROOT_CA.get());\r\n    NetServer server = vertx.createNetServer(options);\r\n    NetClientOptions clientOptions = new NetClientOptions().setHostnameVerificationAlgorithm(\"HTTPS\").setSsl(true).setProxyOptions(new ProxyOptions().setType(ProxyType.SOCKS5).setHost(\"127.0.0.1\").setPort(11080)).setTrustOptions(Trust.SERVER_JKS_ROOT_CA.get());\r\n    NetClient client = vertx.createNetClient(clientOptions);\r\n    server.connectHandler(sock -> {\r\n    });\r\n    proxy = new SocksProxy(null);\r\n    proxy.start(vertx);\r\n    server.listen(ar -> {\r\n        assertTrue(ar.succeeded());\r\n        client.connect(1234, \"localhost\", ar2 -> {\r\n            assertTrue(ar2.succeeded());\r\n            testComplete();\r\n        });\r\n    });\r\n    await();\r\n}"
}, {
	"Path": "org.b3log.symphony.service.ArticleMgmtService.removeArticleByAdmin",
	"Comment": "removes an article specified with the given article id. calls this method will remove all existed data relatedwith the specified article forcibly.",
	"Method": "void removeArticleByAdmin(String articleId){\r\n    try {\r\n        final JSONObject article = articleRepository.get(articleId);\r\n        if (null == article) {\r\n            return;\r\n        }\r\n        Query query = new Query().setFilter(new PropertyFilter(Comment.COMMENT_ON_ARTICLE_ID, FilterOperator.EQUAL, articleId)).setPageCount(1);\r\n        final JSONArray comments = commentRepository.get(query).optJSONArray(Keys.RESULTS);\r\n        final int commentCnt = comments.length();\r\n        for (int i = 0; i < commentCnt; i++) {\r\n            final JSONObject comment = comments.optJSONObject(i);\r\n            final String commentId = comment.optString(Keys.OBJECT_ID);\r\n            commentRepository.removeComment(commentId);\r\n        }\r\n        final String authorId = article.optString(Article.ARTICLE_AUTHOR_ID);\r\n        final JSONObject author = userRepository.get(authorId);\r\n        author.put(UserExt.USER_ARTICLE_COUNT, author.optInt(UserExt.USER_ARTICLE_COUNT) - 1);\r\n        userRepository.update(author.optString(Keys.OBJECT_ID), author);\r\n        final String city = article.optString(Article.ARTICLE_CITY);\r\n        final String cityStatId = city + \"-ArticleCount\";\r\n        final JSONObject cityArticleCntOption = optionRepository.get(cityStatId);\r\n        if (null != cityArticleCntOption) {\r\n            cityArticleCntOption.put(Option.OPTION_VALUE, cityArticleCntOption.optInt(Option.OPTION_VALUE) - 1);\r\n            optionRepository.update(cityStatId, cityArticleCntOption);\r\n        }\r\n        final JSONObject articleCntOption = optionRepository.get(Option.ID_C_STATISTIC_ARTICLE_COUNT);\r\n        articleCntOption.put(Option.OPTION_VALUE, articleCntOption.optInt(Option.OPTION_VALUE) - 1);\r\n        optionRepository.update(Option.ID_C_STATISTIC_ARTICLE_COUNT, articleCntOption);\r\n        articleRepository.remove(articleId);\r\n        query = new Query().setFilter(CompositeFilterOperator.and(new PropertyFilter(Revision.REVISION_DATA_ID, FilterOperator.EQUAL, articleId), new PropertyFilter(Revision.REVISION_DATA_TYPE, FilterOperator.EQUAL, Revision.DATA_TYPE_C_ARTICLE)));\r\n        final JSONArray articleRevisions = revisionRepository.get(query).optJSONArray(Keys.RESULTS);\r\n        for (int i = 0; i < articleRevisions.length(); i++) {\r\n            final JSONObject articleRevision = articleRevisions.optJSONObject(i);\r\n            revisionRepository.remove(articleRevision.optString(Keys.OBJECT_ID));\r\n        }\r\n        final List<JSONObject> tagArticleRels = tagArticleRepository.getByArticleId(articleId);\r\n        for (final JSONObject tagArticleRel : tagArticleRels) {\r\n            final String tagId = tagArticleRel.optString(Tag.TAG + \"_\" + Keys.OBJECT_ID);\r\n            final JSONObject tag = tagRepository.get(tagId);\r\n            int cnt = tag.optInt(Tag.TAG_REFERENCE_CNT) - 1;\r\n            cnt = cnt < 0 ? 0 : cnt;\r\n            tag.put(Tag.TAG_REFERENCE_CNT, cnt);\r\n            tag.put(Tag.TAG_RANDOM_DOUBLE, Math.random());\r\n            tagRepository.update(tagId, tag);\r\n        }\r\n        tagArticleRepository.removeByArticleId(articleId);\r\n        notificationRepository.removeByDataId(articleId);\r\n        rewardRepository.removeByDataId(articleId);\r\n        voteRepository.removeByDataId(articleId);\r\n        if (Symphonys.getBoolean(\"algolia.enabled\")) {\r\n            searchMgmtService.removeAlgoliaDocument(article);\r\n        }\r\n        if (Symphonys.getBoolean(\"es.enabled\")) {\r\n            searchMgmtService.removeESDocument(article, Article.ARTICLE);\r\n        }\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Removes an article error [id=\" + articleId + \"]\", e);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.service.RoleQueryService.getUserPermissionsGrant",
	"Comment": "gets all permissions and marks grant of a user specified by the given user id.",
	"Method": "List<JSONObject> getUserPermissionsGrant(String userId){\r\n    try {\r\n        final JSONObject user = userRepository.get(userId);\r\n        if (null == user) {\r\n            return getPermissionsGrant(Role.ROLE_ID_C_VISITOR);\r\n        }\r\n        final String roleId = user.optString(User.USER_ROLE);\r\n        return getPermissionsGrant(roleId);\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Gets user permissions grant failed\", e);\r\n        return getPermissionsGrant(Role.ROLE_ID_C_VISITOR);\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.http.impl.VertxHttp2ConnectionHandler.addHandler",
	"Comment": "set an handler to be called when the connection is set on this handler.",
	"Method": "VertxHttp2ConnectionHandler<C> addHandler(Handler<C> handler){\r\n    this.addHandler = handler;\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.cli.UsageMessageFormatter.setOptionComparator",
	"Comment": "set the comparator used to sort the options when they output in help text.passing in a null comparator will keep the options in the order they were declared.",
	"Method": "void setOptionComparator(Comparator<Option> comparator){\r\n    this.optionComparator = comparator;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateViewAdapter.getItemCount",
	"Comment": "retrieve the amount of the total items in the urv for display that will be including all data items as well as the decorative items",
	"Method": "int getItemCount(){\r\n    return getAdapterItemCount() + totalAdditionalItems();\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.HkdfTest.testVectors",
	"Comment": "tests the implementation against the test vectors from rfc 5869.",
	"Method": "void testVectors(){\r\n    assertEquals(\"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865\", computeHkdfHex(\"HmacSha256\", \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\", \"000102030405060708090a0b0c\", \"f0f1f2f3f4f5f6f7f8f9\", 42));\r\n    assertEquals(\"b11e398dc80327a1c8e7f78c596a49344f012eda2d4efad8a050cc4c19afa97c\" + \"59045a99cac7827271cb41c65e590e09da3275600c2f09b8367793a9aca3db71\" + \"cc30c58179ec3e87c14c01d5c1f3434f1d87\", computeHkdfHex(\"HmacSha256\", \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\" + \"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\" + \"404142434445464748494a4b4c4d4e4f\", \"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f\" + \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\" + \"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\", \"b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\" + \"d0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeef\" + \"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\", 82));\r\n    assertEquals(\"8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d\" + \"9d201395faa4b61a96c8\", computeHkdfHex(\"HmacSha256\", \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\", \"\", \"\", 42));\r\n    assertEquals(\"085a01ea1b10f36933068b56efa5ad81a4f14b822f5b091568a9cdd4f155fda2c22e422478d305f3f896\", computeHkdfHex(\"HmacSha1\", \"0b0b0b0b0b0b0b0b0b0b0b\", \"000102030405060708090a0b0c\", \"f0f1f2f3f4f5f6f7f8f9\", 42));\r\n    assertEquals(\"0bd770a74d1160f7c9f12cd5912a06ebff6adcae899d92191fe4305673ba2ffe\" + \"8fa3f1a4e5ad79f3f334b3b202b2173c486ea37ce3d397ed034c7f9dfeb15c5e\" + \"927336d0441f4c4300e2cff0d0900b52d3b4\", computeHkdfHex(\"HmacSha1\", \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\" + \"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\" + \"404142434445464748494a4b4c4d4e4f\", \"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f\" + \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\" + \"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\", \"b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\" + \"d0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeef\" + \"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\", 82));\r\n    assertEquals(\"0ac1af7002b3d761d1e55298da9d0506b9ae52057220a306e07b6b87e8df21d0\" + \"ea00033de03984d34918\", computeHkdfHex(\"HmacSha1\", \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\", \"\", \"\", 42));\r\n    assertEquals(\"2c91117204d745f3500d636a62f64f0ab3bae548aa53d423b0d1f27ebba6f5e5\" + \"673a081d70cce7acfc48\", computeHkdfHex(\"HmacSha1\", \"0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c\", \"\", \"\", 42));\r\n}"
}, {
	"Path": "com.google.zxing.qrcode.detector.Detector.calculateModuleSize",
	"Comment": "computes an average estimated module size based on estimated derived from the positionsof the three finder patterns.",
	"Method": "float calculateModuleSize(ResultPoint topLeft,ResultPoint topRight,ResultPoint bottomLeft){\r\n    return (calculateModuleSizeOneWay(topLeft, topRight) + calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0f;\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.EllipticCurves.getY",
	"Comment": "computes the y coordinate of a point on an elliptic curve. this method can be used todecompress elliptic curve points.",
	"Method": "BigInteger getY(BigInteger x,boolean lsb,EllipticCurve curve){\r\n    BigInteger p = getModulus(curve);\r\n    BigInteger a = curve.getA();\r\n    BigInteger b = curve.getB();\r\n    BigInteger rhs = x.multiply(x).add(a).multiply(x).add(b).mod(p);\r\n    BigInteger y = modSqrt(rhs, p);\r\n    if (lsb != y.testBit(0)) {\r\n        y = p.subtract(y).mod(p);\r\n    }\r\n    return y;\r\n}"
}, {
	"Path": "com.google.zxing.qrcode.decoder.Version.getProvisionalVersionForDimension",
	"Comment": "deduces version information purely from qr code dimensions.",
	"Method": "Version getProvisionalVersionForDimension(int dimension){\r\n    if (dimension % 4 != 1) {\r\n        throw FormatException.getFormatInstance();\r\n    }\r\n    try {\r\n        return getVersionForNumber((dimension - 17) / 4);\r\n    } catch (IllegalArgumentException ignored) {\r\n        throw FormatException.getFormatInstance();\r\n    }\r\n}"
}, {
	"Path": "com.vip.vjtools.vjkit.concurrent.jsr166e.Striped64.getUnsafe",
	"Comment": "returns a sun.misc.unsafe.suitable for use in a 3rd party package.\treplace with a simple call to unsafe.getunsafe when integrating\tinto a jdk.",
	"Method": "sun.misc.Unsafe getUnsafe(){\r\n    try {\r\n        return sun.misc.Unsafe.getUnsafe();\r\n    } catch (SecurityException tryReflectionInstead) {\r\n    }\r\n    try {\r\n        return java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\r\n            public sun.misc.Unsafe run() throws Exception {\r\n                Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\r\n                for (java.lang.reflect.Field f : k.getDeclaredFields()) {\r\n                    f.setAccessible(true);\r\n                    Object x = f.get(null);\r\n                    if (k.isInstance(x))\r\n                        return k.cast(x);\r\n                }\r\n                throw new NoSuchFieldError(\"the Unsafe\");\r\n            }\r\n        });\r\n    } catch (java.security.PrivilegedActionException e) {\r\n        throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\r\n    }\r\n}"
}, {
	"Path": "com.vip.vjtools.vjkit.concurrent.jsr166e.Striped64.getUnsafe",
	"Comment": "returns a sun.misc.unsafe.suitable for use in a 3rd party package.\treplace with a simple call to unsafe.getunsafe when integrating\tinto a jdk.",
	"Method": "sun.misc.Unsafe getUnsafe(){\r\n    Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\r\n    for (java.lang.reflect.Field f : k.getDeclaredFields()) {\r\n        f.setAccessible(true);\r\n        Object x = f.get(null);\r\n        if (k.isInstance(x))\r\n            return k.cast(x);\r\n    }\r\n    throw new NoSuchFieldError(\"the Unsafe\");\r\n}"
}, {
	"Path": "com.google.zxing.integration.android.IntentIntegrator.initiateScan",
	"Comment": "initiates a scan for all known barcode types with the specified camera.",
	"Method": "AlertDialog initiateScan(AlertDialog initiateScan,int cameraId,AlertDialog initiateScan,Collection<String> desiredBarcodeFormats,AlertDialog initiateScan,Collection<String> desiredBarcodeFormats,int cameraId){\r\n    Intent intentScan = new Intent(BS_PACKAGE + \".SCAN\");\r\n    intentScan.addCategory(Intent.CATEGORY_DEFAULT);\r\n    if (desiredBarcodeFormats != null) {\r\n        StringBuilder joinedByComma = new StringBuilder();\r\n        for (String format : desiredBarcodeFormats) {\r\n            if (joinedByComma.length() > 0) {\r\n                joinedByComma.append(',');\r\n            }\r\n            joinedByComma.append(format);\r\n        }\r\n        intentScan.putExtra(\"SCAN_FORMATS\", joinedByComma.toString());\r\n    }\r\n    if (cameraId >= 0) {\r\n        intentScan.putExtra(\"SCAN_CAMERA_ID\", cameraId);\r\n    }\r\n    String targetAppPackage = findTargetAppPackage(intentScan);\r\n    if (targetAppPackage == null) {\r\n        return showDownloadDialog();\r\n    }\r\n    intentScan.setPackage(targetAppPackage);\r\n    intentScan.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\r\n    intentScan.addFlags(FLAG_NEW_DOC);\r\n    attachMoreExtras(intentScan);\r\n    startActivityForResult(intentScan, REQUEST_CODE);\r\n    return null;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.ArticleMgmtService.incArticleViewCount",
	"Comment": "increments the view count of the specified article by the given visit.",
	"Method": "void incArticleViewCount(JSONObject visit){\r\n    Symphonys.EXECUTOR_SERVICE.submit(() -> {\r\n        final String visitURL = visit.optString(Visit.VISIT_URL);\r\n        final String articleId = StringUtils.substringAfter(visitURL, \"/article/\");\r\n        boolean visitedB4 = false;\r\n        try {\r\n            if (\"1\".equals(optionRepository.get(Option.ID_C_MISC_ARTICLE_VISIT_COUNT_MODE).optString(Option.OPTION_VALUE))) {\r\n                visitedB4 = visitMgmtService.add(visit);\r\n            }\r\n        } catch (final Exception e) {\r\n            LOGGER.log(Level.ERROR, \"Gets visit count mode failed\", e);\r\n        }\r\n        if (visitedB4) {\r\n            return;\r\n        }\r\n        final Transaction transaction = articleRepository.beginTransaction();\r\n        try {\r\n            final JSONObject article = articleRepository.get(articleId);\r\n            if (null == article) {\r\n                if (transaction.isActive()) {\r\n                    transaction.rollback();\r\n                }\r\n                return;\r\n            }\r\n            final int viewCnt = article.optInt(Article.ARTICLE_VIEW_CNT);\r\n            article.put(Article.ARTICLE_VIEW_CNT, viewCnt + 1);\r\n            article.put(Article.ARTICLE_RANDOM_DOUBLE, Math.random());\r\n            articleRepository.update(articleId, article);\r\n            transaction.commit();\r\n        } catch (final RepositoryException e) {\r\n            if (transaction.isActive()) {\r\n                transaction.rollback();\r\n            }\r\n            LOGGER.log(Level.ERROR, \"Incs an article view count failed\", e);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.yalantis.ucrop.view.OverlayView.onDraw",
	"Comment": "along with image there are dimmed layer, crop bounds and crop guidelines that must be drawn.",
	"Method": "void onDraw(Canvas canvas){\r\n    super.onDraw(canvas);\r\n    drawDimmedLayer(canvas);\r\n    drawCropGrid(canvas);\r\n}"
}, {
	"Path": "com.google.zxing.client.result.ProductResultParser.parse",
	"Comment": "treat all upc and ean variants as upcs, in the sense that they are all product barcodes.",
	"Method": "ProductParsedResult parse(Result result){\r\n    BarcodeFormat format = result.getBarcodeFormat();\r\n    if (!(format == BarcodeFormat.UPC_A || format == BarcodeFormat.UPC_E || format == BarcodeFormat.EAN_8 || format == BarcodeFormat.EAN_13)) {\r\n        return null;\r\n    }\r\n    String rawText = getMassagedText(result);\r\n    if (!isStringOfDigits(rawText, rawText.length())) {\r\n        return null;\r\n    }\r\n    String normalizedProductID;\r\n    if (format == BarcodeFormat.UPC_E && rawText.length() == 8) {\r\n        normalizedProductID = UPCEReader.convertUPCEtoUPCA(rawText);\r\n    } else {\r\n        normalizedProductID = rawText;\r\n    }\r\n    return new ProductParsedResult(rawText, normalizedProductID);\r\n}"
}, {
	"Path": "org.b3log.symphony.util.Tesseracts.recognizeCharacter",
	"Comment": "recognizes a single character from the specified image file path.",
	"Method": "String recognizeCharacter(String imagePath){\r\n    Execs.exec(\"tesseract \" + imagePath + \" \" + imagePath + \" -l chi_sim -psm 10\", 1000 * 10);\r\n    try {\r\n        return StringUtils.trim(IOUtils.toString(new FileInputStream(imagePath + \".txt\"), \"UTF-8\"));\r\n    } catch (final IOException e) {\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.stickyheadersrecyclerview.StickyRecyclerHeadersDecoration.invalidateHeaders",
	"Comment": "invalidates cached headers.this does not invalidate the recyclerview, you should do that manually aftercalling this method.",
	"Method": "void invalidateHeaders(){\r\n    mHeaderProvider.invalidate();\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.XChaCha20Poly1305Test.testRandomNonce",
	"Comment": "this is a very simple test for the randomness of the nonce. the test simply checks that themultiple ciphertexts of the same message are distinct.",
	"Method": "void testRandomNonce(){\r\n    if (TestUtil.isTsan()) {\r\n        System.out.println(\"testRandomNonce takes too long under tsan, skipping\");\r\n        return;\r\n    }\r\n    byte[] key = Random.randBytes(KEY_SIZE);\r\n    Aead aead = createInstance(key);\r\n    byte[] message = new byte[0];\r\n    byte[] aad = new byte[0];\r\n    HashSet<String> ciphertexts = new HashSet();\r\n    final int samples = 1 << 17;\r\n    for (int i = 0; i < samples; i++) {\r\n        byte[] ct = aead.encrypt(message, aad);\r\n        String ctHex = TestUtil.hexEncode(ct);\r\n        assertFalse(ciphertexts.contains(ctHex));\r\n        ciphertexts.add(ctHex);\r\n    }\r\n    assertEquals(samples, ciphertexts.size());\r\n}"
}, {
	"Path": "com.vip.vjtools.jmx.Client.doBean",
	"Comment": "get attribute or run operation against passed bean instance.",
	"Method": "Object[] doBean(MBeanServerConnection mbsc,ObjectInstance instance,String[] command){\r\n    if (command == null || command.length <= 0) {\r\n        return new String[] { listOptions(mbsc, instance) };\r\n    }\r\n    Object[] result = new Object[command.length];\r\n    for (int i = 0; i < command.length; i++) {\r\n        result[i] = doSubCommand(mbsc, instance, command[i]);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.vertx.core.net.PemKeyCertOptions.setCertPath",
	"Comment": "set the path of the first certificate, replacing the previous certificates paths",
	"Method": "PemKeyCertOptions setCertPath(String certPath){\r\n    certPaths.clear();\r\n    if (certPath != null) {\r\n        certPaths.add(certPath);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.file.OpenOptions.setSparse",
	"Comment": "set whether a hint should be provided that the file to created is sparse",
	"Method": "OpenOptions setSparse(boolean sparse){\r\n    this.sparse = sparse;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.crypto.tink.JsonKeysetWriter.withFile",
	"Comment": "static method to create a jsonkeysetwriter that writes to a file.",
	"Method": "KeysetWriter withFile(File file){\r\n    return new JsonKeysetWriter(new FileOutputStream(file));\r\n}"
}, {
	"Path": "com.yalantis.ucrop.view.CropImageView.setCropRect",
	"Comment": "updates current crop rectangle with given. also recalculates image properties and positionto fit new crop rectangle.",
	"Method": "void setCropRect(RectF cropRect){\r\n    mTargetAspectRatio = cropRect.width() / cropRect.height();\r\n    mCropRect.set(cropRect.left - getPaddingLeft(), cropRect.top - getPaddingTop(), cropRect.right - getPaddingRight(), cropRect.bottom - getPaddingBottom());\r\n    calculateImageScaleBounds();\r\n    setImageToWrapCropBounds();\r\n}"
}, {
	"Path": "com.google.zxing.pdf417.encoder.PDF417.determineDimensions",
	"Comment": "determine optimal nr of columns and rows for the specified number ofcodewords.",
	"Method": "int[] determineDimensions(int sourceCodeWords,int errorCorrectionCodeWords){\r\n    float ratio = 0.0f;\r\n    int[] dimension = null;\r\n    for (int cols = minCols; cols <= maxCols; cols++) {\r\n        int rows = calculateNumberOfRows(sourceCodeWords, errorCorrectionCodeWords, cols);\r\n        if (rows < minRows) {\r\n            break;\r\n        }\r\n        if (rows > maxRows) {\r\n            continue;\r\n        }\r\n        float newRatio = ((float) (17 * cols + 69) * DEFAULT_MODULE_WIDTH) / (rows * HEIGHT);\r\n        if (dimension != null && Math.abs(newRatio - PREFERRED_RATIO) > Math.abs(ratio - PREFERRED_RATIO)) {\r\n            continue;\r\n        }\r\n        ratio = newRatio;\r\n        dimension = new int[] { cols, rows };\r\n    }\r\n    if (dimension == null) {\r\n        int rows = calculateNumberOfRows(sourceCodeWords, errorCorrectionCodeWords, minCols);\r\n        if (rows < minRows) {\r\n            dimension = new int[] { minCols, minRows };\r\n        }\r\n    }\r\n    if (dimension == null) {\r\n        throw new WriterException(\"Unable to fit message in columns\");\r\n    }\r\n    return dimension;\r\n}"
}, {
	"Path": "io.swagger.v3.jaxrs2.PetResourceTest.getClasses",
	"Comment": "scans all classes accessible from the context class loader which belong to the given package and subpackages.",
	"Method": "Class[] getClasses(String packageName){\r\n    final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\r\n    assert classLoader != null;\r\n    final String path = packageName.replace(DOT, SLASH);\r\n    final Enumeration<URL> resources = classLoader.getResources(path);\r\n    final List<File> dirs = new ArrayList();\r\n    while (resources.hasMoreElements()) {\r\n        final URL resource = resources.nextElement();\r\n        dirs.add(new File(resource.getFile()));\r\n    }\r\n    final ArrayList<Class> classes = new ArrayList();\r\n    for (final File directory : dirs) {\r\n        classes.addAll(findClasses(directory, packageName));\r\n    }\r\n    return classes.toArray(new Class[classes.size()]);\r\n}"
}, {
	"Path": "com.google.zxing.qrcode.encoder.MaskUtil.applyMaskPenaltyRule4",
	"Comment": "apply mask penalty rule 4 and return the penalty. calculate the ratio of dark cells and givepenalty if the ratio is far from 50%. it gives 10 penalty for 5% distance.",
	"Method": "int applyMaskPenaltyRule4(ByteMatrix matrix){\r\n    int numDarkCells = 0;\r\n    byte[][] array = matrix.getArray();\r\n    int width = matrix.getWidth();\r\n    int height = matrix.getHeight();\r\n    for (int y = 0; y < height; y++) {\r\n        byte[] arrayY = array[y];\r\n        for (int x = 0; x < width; x++) {\r\n            if (arrayY[x] == 1) {\r\n                numDarkCells++;\r\n            }\r\n        }\r\n    }\r\n    int numTotalCells = matrix.getHeight() * matrix.getWidth();\r\n    int fivePercentVariances = Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells;\r\n    return fivePercentVariances * N4;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.PointtransferQueryService.getLatestPointtransfers",
	"Comment": "gets the latest pointtransfers with the specified user id, type and fetch size.",
	"Method": "List<JSONObject> getLatestPointtransfers(String userId,int type,int fetchSize){\r\n    final List<JSONObject> ret = new ArrayList();\r\n    final List<Filter> userFilters = new ArrayList();\r\n    userFilters.add(new PropertyFilter(Pointtransfer.FROM_ID, FilterOperator.EQUAL, userId));\r\n    userFilters.add(new PropertyFilter(Pointtransfer.TO_ID, FilterOperator.EQUAL, userId));\r\n    final List<Filter> filters = new ArrayList();\r\n    filters.add(new CompositeFilter(CompositeFilterOperator.OR, userFilters));\r\n    filters.add(new PropertyFilter(Pointtransfer.TYPE, FilterOperator.EQUAL, type));\r\n    final Query query = new Query().addSort(Keys.OBJECT_ID, SortDirection.DESCENDING).setCurrentPageNum(1).setPageSize(fetchSize).setFilter(new CompositeFilter(CompositeFilterOperator.AND, filters));\r\n    try {\r\n        final JSONObject result = pointtransferRepository.get(query);\r\n        return CollectionUtils.jsonArrayToList(result.optJSONArray(Keys.RESULTS));\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Gets latest pointtransfers error\", e);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "io.vertx.core.VertxOptions.getInternalBlockingPoolSize",
	"Comment": "get the value of internal blocking pool size.vert.x maintains a pool for internal blocking operations",
	"Method": "int getInternalBlockingPoolSize(){\r\n    return internalBlockingPoolSize;\r\n}"
}, {
	"Path": "io.vertx.core.net.ClientOptionsBase.setLocalAddress",
	"Comment": "set the local interface to bind for network connections. when the local address is null,it will pick any local address, the default local address is null.",
	"Method": "ClientOptionsBase setLocalAddress(String localAddress){\r\n    this.localAddress = localAddress;\r\n    return this;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.FollowMgmtService.unwatchArticle",
	"Comment": "the specified follower unwatches the specified following article.",
	"Method": "void unwatchArticle(String followerId,String followingArticleId){\r\n    try {\r\n        unfollow(followerId, followingArticleId, Follow.FOLLOWING_TYPE_C_ARTICLE_WATCH);\r\n    } catch (final RepositoryException e) {\r\n        final String msg = \"User[id=\" + followerId + \"] unwatches an article[id=\" + followingArticleId + \"] failed\";\r\n        LOGGER.log(Level.ERROR, msg, e);\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.VertxOptions.setPreferNativeTransport",
	"Comment": "set wether to prefer the native transport to the jdk transport.",
	"Method": "VertxOptions setPreferNativeTransport(boolean preferNativeTransport){\r\n    this.preferNativeTransport = preferNativeTransport;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.uiUtils.RecyclerViewPositionHelper.findFirstVisibleItemPosition",
	"Comment": "returns the adapter position of the first visible view. this position does not includeadapter changes that were dispatched after the last layout pass.",
	"Method": "int findFirstVisibleItemPosition(){\r\n    final View child = findOneVisibleChild(0, layoutManager.getChildCount(), false, true);\r\n    return child == null ? RecyclerView.NO_POSITION : recyclerView.getChildAdapterPosition(child);\r\n}"
}, {
	"Path": "com.vip.vjtools.vjtop.util.LongObjectHashMap.indexOf",
	"Comment": "locates the index for the given key. this method probes using double hashing.",
	"Method": "int indexOf(long key){\r\n    int startIndex = hashIndex(key);\r\n    int index = startIndex;\r\n    for (; ; ) {\r\n        if (values[index] == null) {\r\n            return -1;\r\n        }\r\n        if (key == keys[index]) {\r\n            return index;\r\n        }\r\n        if ((index = probeNext(index)) == startIndex) {\r\n            return -1;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.cli.converters.Converters.getConverter",
	"Comment": "searches a suitable converter to convert string to the given type.",
	"Method": "Converter<T> getConverter(Class<T> type){\r\n    if (type == String.class) {\r\n        return (Converter<T>) StringConverter.INSTANCE;\r\n    }\r\n    if (type == Boolean.class) {\r\n        return (Converter<T>) BooleanConverter.INSTANCE;\r\n    }\r\n    Converter<T> converter = ConstructorBasedConverter.getIfEligible(type);\r\n    if (converter != null) {\r\n        return converter;\r\n    }\r\n    converter = ValueOfBasedConverter.getIfEligible(type);\r\n    if (converter != null) {\r\n        return converter;\r\n    }\r\n    converter = FromBasedConverter.getIfEligible(type);\r\n    if (converter != null) {\r\n        return converter;\r\n    }\r\n    converter = FromStringBasedConverter.getIfEligible(type);\r\n    if (converter != null) {\r\n        return converter;\r\n    }\r\n    if (type == Character.class) {\r\n        return (Converter<T>) CharacterConverter.INSTANCE;\r\n    }\r\n    throw new NoSuchElementException(\"Cannot find a converter able to create instance of \" + type.getName());\r\n}"
}, {
	"Path": "org.b3log.symphony.processor.SkinRenderer.isPJAX",
	"Comment": "determines whether the specified request is sending with pjax.",
	"Method": "boolean isPJAX(HttpServletRequest request){\r\n    final boolean pjax = Boolean.valueOf(request.getHeader(\"X-PJAX\"));\r\n    final String pjaxContainer = request.getHeader(\"X-PJAX-Container\");\r\n    return pjax && StringUtils.isNotBlank(pjaxContainer);\r\n}"
}, {
	"Path": "io.vertx.core.json.JsonArray.addAll",
	"Comment": "appends all of the elements in the specified array to the end of this json array.",
	"Method": "JsonArray addAll(JsonArray array){\r\n    Objects.requireNonNull(array);\r\n    list.addAll(array.list);\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.spi.launcher.DefaultCommand.applySystemProperties",
	"Comment": "sets the system properties specified by the user command line.",
	"Method": "void applySystemProperties(){\r\n    if (systemProperties != null) {\r\n        for (String prop : systemProperties) {\r\n            int p = prop.indexOf('=');\r\n            if (p > 0) {\r\n                String key = prop.substring(0, p);\r\n                String val = prop.substring(p + 1);\r\n                System.setProperty(key, val);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.signature.RsaSsaPssSignKeyManagerTest.testGetPublicKeyData",
	"Comment": "tests that a public key is extracted properly from a private key.",
	"Method": "void testGetPublicKeyData(){\r\n    if (TestUtil.isTsan()) {\r\n        return;\r\n    }\r\n    KeysetHandle privateHandle = KeysetHandle.generateNew(SignatureKeyTemplates.RSA_SSA_PSS_4096_SHA512_SHA512_64_F4);\r\n    KeyData privateKeyData = TestUtil.getKeyset(privateHandle).getKey(0).getKeyData();\r\n    RsaSsaPssSignKeyManager privateManager = new RsaSsaPssSignKeyManager();\r\n    KeyData publicKeyData = privateManager.getPublicKeyData(privateKeyData.getValue());\r\n    assertEquals(RsaSsaPssVerifyKeyManager.TYPE_URL, publicKeyData.getTypeUrl());\r\n    assertEquals(KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC, publicKeyData.getKeyMaterialType());\r\n    RsaSsaPssPrivateKey privateKey = RsaSsaPssPrivateKey.parseFrom(privateKeyData.getValue());\r\n    assertArrayEquals(privateKey.getPublicKey().toByteArray(), publicKeyData.getValue().toByteArray());\r\n    RsaSsaPssVerifyKeyManager publicManager = new RsaSsaPssVerifyKeyManager();\r\n    PublicKeySign signer = privateManager.getPrimitive(privateKeyData.getValue());\r\n    PublicKeyVerify verifier = publicManager.getPrimitive(publicKeyData.getValue());\r\n    byte[] message = Random.randBytes(20);\r\n    try {\r\n        verifier.verify(signer.sign(message), message);\r\n    } catch (GeneralSecurityException e) {\r\n        fail(\"Should not fail: \" + e);\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.http.HttpServerOptions.perMessageWebsocketCompressionSupported",
	"Comment": "get whether websocket permessage deflate compression is supported",
	"Method": "boolean perMessageWebsocketCompressionSupported(){\r\n    return this.websocketPermessageDeflateCompressionSupported;\r\n}"
}, {
	"Path": "com.yalantis.ucrop.sample.BaseActivity.showAlertDialog",
	"Comment": "this method shows dialog with given title & message.also there is an option to pass onclicklistener for positive & negative button.",
	"Method": "void showAlertDialog(String title,String message,DialogInterface.OnClickListener onPositiveButtonClickListener,String positiveText,DialogInterface.OnClickListener onNegativeButtonClickListener,String negativeText){\r\n    AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n    builder.setTitle(title);\r\n    builder.setMessage(message);\r\n    builder.setPositiveButton(positiveText, onPositiveButtonClickListener);\r\n    builder.setNegativeButton(negativeText, onNegativeButtonClickListener);\r\n    mAlertDialog = builder.show();\r\n}"
}, {
	"Path": "com.google.zxing.client.android.result.AddressBookResultHandler.getDisplayContents",
	"Comment": "overriden so we can hyphenate phone numbers, format birthdays, and bold the name.",
	"Method": "CharSequence getDisplayContents(){\r\n    AddressBookParsedResult result = (AddressBookParsedResult) getResult();\r\n    StringBuilder contents = new StringBuilder(100);\r\n    ParsedResult.maybeAppend(result.getNames(), contents);\r\n    int namesLength = contents.length();\r\n    String pronunciation = result.getPronunciation();\r\n    if (pronunciation != null && !pronunciation.isEmpty()) {\r\n        contents.append(\"\\n(\");\r\n        contents.append(pronunciation);\r\n        contents.append(')');\r\n    }\r\n    ParsedResult.maybeAppend(result.getTitle(), contents);\r\n    ParsedResult.maybeAppend(result.getOrg(), contents);\r\n    ParsedResult.maybeAppend(result.getAddresses(), contents);\r\n    String[] numbers = result.getPhoneNumbers();\r\n    if (numbers != null) {\r\n        for (String number : numbers) {\r\n            if (number != null) {\r\n                ParsedResult.maybeAppend(formatPhone(number), contents);\r\n            }\r\n        }\r\n    }\r\n    ParsedResult.maybeAppend(result.getEmails(), contents);\r\n    ParsedResult.maybeAppend(result.getURLs(), contents);\r\n    String birthday = result.getBirthday();\r\n    if (birthday != null && !birthday.isEmpty()) {\r\n        long date = parseDate(birthday);\r\n        if (date >= 0L) {\r\n            ParsedResult.maybeAppend(DateFormat.getDateInstance(DateFormat.MEDIUM).format(date), contents);\r\n        }\r\n    }\r\n    ParsedResult.maybeAppend(result.getNote(), contents);\r\n    if (namesLength > 0) {\r\n        Spannable styled = new SpannableString(contents.toString());\r\n        styled.setSpan(new StyleSpan(Typeface.BOLD), 0, namesLength, 0);\r\n        return styled;\r\n    } else {\r\n        return contents.toString();\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.impl.launcher.commands.ExecUtils.exitBecauseOfVertxInitializationIssue",
	"Comment": "exits the jvm and indicate an issue during the vert.x initialization.",
	"Method": "void exitBecauseOfVertxInitializationIssue(){\r\n    exit(VERTX_INITIALIZATION_EXIT_CODE);\r\n}"
}, {
	"Path": "io.vertx.core.cli.UsageMessageFormatter.renderWrappedTextBlock",
	"Comment": "renders the specified text width a maximum width. this method differsfrom renderwrappedtext by not removing leading spaces after a new line.",
	"Method": "Appendable renderWrappedTextBlock(StringBuilder sb,int width,int nextLineTabStop,String text){\r\n    try {\r\n        BufferedReader in = new BufferedReader(new StringReader(text));\r\n        String line;\r\n        boolean firstLine = true;\r\n        while ((line = in.readLine()) != null) {\r\n            if (!firstLine) {\r\n                sb.append(getNewLine());\r\n            } else {\r\n                firstLine = false;\r\n            }\r\n            renderWrappedText(sb, width, nextLineTabStop, line);\r\n        }\r\n    } catch (IOException e) {\r\n    }\r\n    return sb;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.VoteQueryService.isVoted",
	"Comment": "determines whether the specified user dose vote the specified entity.",
	"Method": "int isVoted(String userId,String dataId){\r\n    try {\r\n        final List<Filter> filters = new ArrayList();\r\n        filters.add(new PropertyFilter(Vote.USER_ID, FilterOperator.EQUAL, userId));\r\n        filters.add(new PropertyFilter(Vote.DATA_ID, FilterOperator.EQUAL, dataId));\r\n        final Query query = new Query().setFilter(new CompositeFilter(CompositeFilterOperator.AND, filters));\r\n        final JSONObject result = voteRepository.get(query);\r\n        final JSONArray array = result.optJSONArray(Keys.RESULTS);\r\n        if (0 == array.length()) {\r\n            return -1;\r\n        }\r\n        final JSONObject vote = array.optJSONObject(0);\r\n        return vote.optInt(Vote.TYPE);\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, e.getMessage());\r\n        return -1;\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.StreamingTestUtil.testEncryptDecryptRandomAccess",
	"Comment": "encrypt and then decrypt partially, and check that the result is the same.",
	"Method": "void testEncryptDecryptRandomAccess(StreamingAead ags,int firstSegmentOffset,int plaintextSize){\r\n    byte[] aad = TestUtil.hexDecode(\"aabbccddeeff\");\r\n    byte[] plaintext = generatePlaintext(plaintextSize);\r\n    byte[] ciphertext = encryptWithChannel(ags, plaintext, aad, firstSegmentOffset);\r\n    SeekableByteChannel bbc = new SeekableByteBufferChannel(ciphertext);\r\n    SeekableByteChannel ptChannel = ags.newSeekableDecryptingChannel(bbc, aad);\r\n    for (int start = 0; start < plaintextSize; start += 1 + start / 2) {\r\n        for (int length = 1; length < plaintextSize; length += 1 + length / 2) {\r\n            ByteBuffer pt = ByteBuffer.allocate(length);\r\n            ptChannel.position(start);\r\n            int read = ptChannel.read(pt);\r\n            assertTrue(\"start:\" + start + \" read:\" + read + \" length:\" + length, pt.remaining() == 0 || start + pt.position() == plaintext.length);\r\n            String expected = TestUtil.hexEncode(Arrays.copyOfRange(plaintext, start, start + pt.position()));\r\n            String actual = TestUtil.hexEncode(Arrays.copyOf(pt.array(), pt.position()));\r\n            assertEquals(\"start: \" + start, expected, actual);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.aztec.detector.Detector.expandSquare",
	"Comment": "expand the square represented by the corner points by pushing out equally in all directions",
	"Method": "ResultPoint[] expandSquare(ResultPoint[] cornerPoints,int oldSide,int newSide){\r\n    float ratio = newSide / (2.0f * oldSide);\r\n    float dx = cornerPoints[0].getX() - cornerPoints[2].getX();\r\n    float dy = cornerPoints[0].getY() - cornerPoints[2].getY();\r\n    float centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0f;\r\n    float centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0f;\r\n    ResultPoint result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);\r\n    ResultPoint result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);\r\n    dx = cornerPoints[1].getX() - cornerPoints[3].getX();\r\n    dy = cornerPoints[1].getY() - cornerPoints[3].getY();\r\n    centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0f;\r\n    centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0f;\r\n    ResultPoint result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);\r\n    ResultPoint result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);\r\n    return new ResultPoint[] { result0, result1, result2, result3 };\r\n}"
}, {
	"Path": "io.vertx.core.file.OpenOptions.setCreateNew",
	"Comment": "set whether the file should be created and fail if it does exist already.",
	"Method": "OpenOptions setCreateNew(boolean createNew){\r\n    this.createNew = createNew;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.loader.tools.Repackager.setLayoutFactory",
	"Comment": "sets the layout factory for the jar. the factory can be used when no specific\tlayout is specified.",
	"Method": "void setLayoutFactory(LayoutFactory layoutFactory){\r\n    this.layoutFactory = layoutFactory;\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.AesGcmHkdfStreaming.expectedCiphertextSize",
	"Comment": "returns the expected size of the ciphertext for a given plaintext the returned value includesthe header and offset.",
	"Method": "long expectedCiphertextSize(long plaintextSize){\r\n    long offset = getCiphertextOffset();\r\n    long fullSegments = (plaintextSize + offset) / plaintextSegmentSize;\r\n    long ciphertextSize = fullSegments * ciphertextSegmentSize;\r\n    long lastSegmentSize = (plaintextSize + offset) % plaintextSegmentSize;\r\n    if (lastSegmentSize > 0) {\r\n        ciphertextSize += lastSegmentSize + TAG_SIZE_IN_BYTES;\r\n    }\r\n    return ciphertextSize;\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.SubtleUtil.toEcdsaAlgo",
	"Comment": "returns the ecdsa algorithm name corresponding to a hash type.",
	"Method": "String toEcdsaAlgo(HashType hash){\r\n    Validators.validateSignatureHash(hash);\r\n    return hash + \"withECDSA\";\r\n}"
}, {
	"Path": "org.b3log.symphony.repository.FollowRepository.getByFollowerIdAndFollowingId",
	"Comment": "gets a follow relationship by the specified follower id and the specified following entity id.",
	"Method": "JSONObject getByFollowerIdAndFollowingId(String followerId,String followingId,int followingType){\r\n    final List<Filter> filters = new ArrayList<Filter>();\r\n    filters.add(new PropertyFilter(Follow.FOLLOWER_ID, FilterOperator.EQUAL, followerId));\r\n    filters.add(new PropertyFilter(Follow.FOLLOWING_ID, FilterOperator.EQUAL, followingId));\r\n    filters.add(new PropertyFilter(Follow.FOLLOWING_TYPE, FilterOperator.EQUAL, followingType));\r\n    final Query query = new Query().setFilter(new CompositeFilter(CompositeFilterOperator.AND, filters));\r\n    final JSONObject result = get(query);\r\n    final JSONArray array = result.optJSONArray(Keys.RESULTS);\r\n    if (0 == array.length()) {\r\n        return null;\r\n    }\r\n    return array.optJSONObject(0);\r\n}"
}, {
	"Path": "com.yalantis.ucrop.view.CropImageView.isImageWrapCropBounds",
	"Comment": "this method checks whether current image fills the crop bounds.",
	"Method": "boolean isImageWrapCropBounds(boolean isImageWrapCropBounds,float[] imageCorners){\r\n    mTempMatrix.reset();\r\n    mTempMatrix.setRotate(-getCurrentAngle());\r\n    float[] unrotatedImageCorners = Arrays.copyOf(imageCorners, imageCorners.length);\r\n    mTempMatrix.mapPoints(unrotatedImageCorners);\r\n    float[] unrotatedCropBoundsCorners = RectUtils.getCornersFromRect(mCropRect);\r\n    mTempMatrix.mapPoints(unrotatedCropBoundsCorners);\r\n    return RectUtils.trapToRect(unrotatedImageCorners).contains(RectUtils.trapToRect(unrotatedCropBoundsCorners));\r\n}"
}, {
	"Path": "io.vertx.core.http.HttpServerOptions.setPerFrameWebsocketCompressionSupported",
	"Comment": "enable or disable support for websocket defalte frame compression",
	"Method": "HttpServerOptions setPerFrameWebsocketCompressionSupported(boolean perFrameWebsocketCompressionSupported){\r\n    this.websocketDeflateFrameCompressionSupported = perFrameWebsocketCompressionSupported;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.zxing.qrcode.decoder.BitMatrixParser.readVersion",
	"Comment": "reads version information from one of its two locations within the qr code.",
	"Method": "Version readVersion(){\r\n    if (parsedVersion != null) {\r\n        return parsedVersion;\r\n    }\r\n    int dimension = bitMatrix.getHeight();\r\n    int provisionalVersion = (dimension - 17) / 4;\r\n    if (provisionalVersion <= 6) {\r\n        return Version.getVersionForNumber(provisionalVersion);\r\n    }\r\n    int versionBits = 0;\r\n    int ijMin = dimension - 11;\r\n    for (int j = 5; j >= 0; j--) {\r\n        for (int i = dimension - 9; i >= ijMin; i--) {\r\n            versionBits = copyBit(i, j, versionBits);\r\n        }\r\n    }\r\n    Version theParsedVersion = Version.decodeVersionInformation(versionBits);\r\n    if (theParsedVersion != null && theParsedVersion.getDimensionForVersion() == dimension) {\r\n        parsedVersion = theParsedVersion;\r\n        return theParsedVersion;\r\n    }\r\n    versionBits = 0;\r\n    for (int i = 5; i >= 0; i--) {\r\n        for (int j = dimension - 9; j >= ijMin; j--) {\r\n            versionBits = copyBit(i, j, versionBits);\r\n        }\r\n    }\r\n    theParsedVersion = Version.decodeVersionInformation(versionBits);\r\n    if (theParsedVersion != null && theParsedVersion.getDimensionForVersion() == dimension) {\r\n        parsedVersion = theParsedVersion;\r\n        return theParsedVersion;\r\n    }\r\n    throw FormatException.getFormatInstance();\r\n}"
}, {
	"Path": "com.google.zxing.aztec.decoder.Decoder.readCode",
	"Comment": "reads a code of given length and at given index in an array of bits",
	"Method": "int readCode(boolean[] rawbits,int startIndex,int length){\r\n    int res = 0;\r\n    for (int i = startIndex; i < startIndex + length; i++) {\r\n        res <<= 1;\r\n        if (rawbits[i]) {\r\n            res |= 0x01;\r\n        }\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.quickAdapter.extBaseAdapter.BaseAdapterHelper.get",
	"Comment": "this method is package private and should only be used by quickadapter.",
	"Method": "BaseAdapterHelper get(Context context,View convertView,ViewGroup parent,int layoutId,BaseAdapterHelper get,Context context,View convertView,ViewGroup parent,int layoutId,int position){\r\n    if (convertView == null) {\r\n        return new BaseAdapterHelper(context, parent, layoutId, position);\r\n    }\r\n    BaseAdapterHelper existingHelper = (BaseAdapterHelper) convertView.getTag();\r\n    if (existingHelper.layoutId != layoutId) {\r\n        return new BaseAdapterHelper(context, parent, layoutId, position);\r\n    }\r\n    existingHelper.position = position;\r\n    return existingHelper;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.swipelistview.SwipeListViewTouchListener.removePendingDismisses",
	"Comment": "will delete all pending dismisses.will call callback ondismiss for all pending dismisses.will reset all cell height to originalheight.",
	"Method": "void removePendingDismisses(int originalHeight){\r\n    Collections.sort(pendingDismisses);\r\n    int[] dismissPositions = new int[pendingDismisses.size()];\r\n    for (int i = pendingDismisses.size() - 1; i >= 0; i--) {\r\n        dismissPositions[i] = pendingDismisses.get(i).position;\r\n    }\r\n    swipeListView.onDismiss(dismissPositions);\r\n    ViewGroup.LayoutParams lp;\r\n    for (PendingDismissData pendingDismiss : pendingDismisses) {\r\n        if (pendingDismiss.view != null) {\r\n            ViewCompat.setAlpha(pendingDismiss.view, 1f);\r\n            ViewCompat.setTranslationX(pendingDismiss.view, 0);\r\n            lp = pendingDismiss.view.getLayoutParams();\r\n            lp.height = originalHeight;\r\n            pendingDismiss.view.setLayoutParams(lp);\r\n        }\r\n    }\r\n    resetPendingDismisses();\r\n}"
}, {
	"Path": "org.b3log.symphony.service.ArticleQueryService.getArticlePreviewContent",
	"Comment": "gets preview content of the article specified with the given article id.",
	"Method": "String getArticlePreviewContent(String articleId,HttpServletRequest request){\r\n    final JSONObject article = getArticle(articleId);\r\n    if (null == article) {\r\n        return null;\r\n    }\r\n    final int articleType = article.optInt(Article.ARTICLE_TYPE);\r\n    if (Article.ARTICLE_TYPE_C_THOUGHT == articleType) {\r\n        return null;\r\n    }\r\n    Stopwatchs.start(\"Get preview content\");\r\n    try {\r\n        final int length = Integer.valueOf(\"150\");\r\n        String ret = article.optString(Article.ARTICLE_CONTENT);\r\n        final String authorId = article.optString(Article.ARTICLE_AUTHOR_ID);\r\n        final JSONObject author = userQueryService.getUser(authorId);\r\n        if (null != author && UserExt.USER_STATUS_C_INVALID == author.optInt(UserExt.USER_STATUS) || Article.ARTICLE_STATUS_C_INVALID == article.optInt(Article.ARTICLE_STATUS)) {\r\n            return Jsoup.clean(langPropsService.get(\"articleContentBlockLabel\"), Whitelist.none());\r\n        }\r\n        final Set<String> userNames = userQueryService.getUserNames(ret);\r\n        final JSONObject currentUser = (JSONObject) request.getAttribute(Common.CURRENT_USER);\r\n        final String currentUserName = null == currentUser ? \"\" : currentUser.optString(User.USER_NAME);\r\n        final String authorName = author.optString(User.USER_NAME);\r\n        if (Article.ARTICLE_TYPE_C_DISCUSSION == articleType && !authorName.equals(currentUserName)) {\r\n            boolean invited = false;\r\n            for (final String userName : userNames) {\r\n                if (userName.equals(currentUserName)) {\r\n                    invited = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!invited) {\r\n                String blockContent = langPropsService.get(\"articleDiscussionLabel\");\r\n                blockContent = blockContent.replace(\"{user}\", UserExt.getUserLink(authorName));\r\n                return blockContent;\r\n            }\r\n        }\r\n        ret = Emotions.convert(ret);\r\n        ret = Markdowns.toHTML(ret);\r\n        ret = Jsoup.clean(ret, Whitelist.none());\r\n        if (ret.length() >= length) {\r\n            ret = StringUtils.substring(ret, 0, length) + \" ....\";\r\n        }\r\n        return ret;\r\n    } finally {\r\n        Stopwatchs.end();\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.testing.CliUtil.read",
	"Comment": "reads the specified inputstream and returns the contents as a byte array.in case of errors throws an exception.",
	"Method": "byte[] read(String filename,byte[] read,InputStream inputStream){\r\n    ByteArrayOutputStream result = new ByteArrayOutputStream();\r\n    byte[] buffer = new byte[512];\r\n    int length;\r\n    while ((length = inputStream.read(buffer)) != -1) {\r\n        result.write(buffer, 0, length);\r\n    }\r\n    inputStream.close();\r\n    return result.toByteArray();\r\n}"
}, {
	"Path": "com.vip.vjtools.vjkit.collection.type.primitive.IntObjectHashMap.growSize",
	"Comment": "grows the map size after an insertion. if necessary, performs a rehash of the map.",
	"Method": "void growSize(){\r\n    size++;\r\n    if (size > maxSize) {\r\n        if (keys.length == Integer.MAX_VALUE) {\r\n            throw new IllegalStateException(\"Max capacity reached at size=\" + size);\r\n        }\r\n        rehash(keys.length << 1);\r\n    }\r\n}"
}, {
	"Path": "us.codecraft.webmagic.ResultItems.isSkip",
	"Comment": "whether to skip the result.result which is skipped will not be processed by pipeline.",
	"Method": "boolean isSkip(){\r\n    return skip;\r\n}"
}, {
	"Path": "io.vertx.core.file.OpenOptions.setTruncateExisting",
	"Comment": "set whether the file should be truncated to zero length on opening if it exists and is opened for write",
	"Method": "OpenOptions setTruncateExisting(boolean truncateExisting){\r\n    this.truncateExisting = truncateExisting;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.zxing.qrcode.detector.AlignmentPatternFinder.handlePossibleCenter",
	"Comment": "this is called when a horizontal scan finds a possible alignment pattern. it willcross check with a vertical scan, and if successful, will see if this pattern had beenfound on a previous horizontal scan. if so, we consider it confirmed and conclude we havefound the alignment pattern.",
	"Method": "AlignmentPattern handlePossibleCenter(int[] stateCount,int i,int j){\r\n    int stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\r\n    float centerJ = centerFromEnd(stateCount, j);\r\n    float centerI = crossCheckVertical(i, (int) centerJ, 2 * stateCount[1], stateCountTotal);\r\n    if (!Float.isNaN(centerI)) {\r\n        float estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0f;\r\n        for (AlignmentPattern center : possibleCenters) {\r\n            if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\r\n                return center.combineEstimate(centerI, centerJ, estimatedModuleSize);\r\n            }\r\n        }\r\n        AlignmentPattern point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);\r\n        possibleCenters.add(point);\r\n        if (resultPointCallback != null) {\r\n            resultPointCallback.foundPossibleResultPoint(point);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.zxing.common.detector.MonochromeRectangleDetector.blackWhiteRange",
	"Comment": "computes the start and end of a region of pixels, either horizontally or vertically, that couldbe part of a data matrix barcode.",
	"Method": "int[] blackWhiteRange(int fixedDimension,int maxWhiteRun,int minDim,int maxDim,boolean horizontal){\r\n    int center = (minDim + maxDim) / 2;\r\n    int start = center;\r\n    while (start >= minDim) {\r\n        if (horizontal ? image.get(start, fixedDimension) : image.get(fixedDimension, start)) {\r\n            start--;\r\n        } else {\r\n            int whiteRunStart = start;\r\n            do {\r\n                start--;\r\n            } while (start >= minDim && !(horizontal ? image.get(start, fixedDimension) : image.get(fixedDimension, start)));\r\n            int whiteRunSize = whiteRunStart - start;\r\n            if (start < minDim || whiteRunSize > maxWhiteRun) {\r\n                start = whiteRunStart;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    start++;\r\n    int end = center;\r\n    while (end < maxDim) {\r\n        if (horizontal ? image.get(end, fixedDimension) : image.get(fixedDimension, end)) {\r\n            end++;\r\n        } else {\r\n            int whiteRunStart = end;\r\n            do {\r\n                end++;\r\n            } while (end < maxDim && !(horizontal ? image.get(end, fixedDimension) : image.get(fixedDimension, end)));\r\n            int whiteRunSize = end - whiteRunStart;\r\n            if (end >= maxDim || whiteRunSize > maxWhiteRun) {\r\n                end = whiteRunStart;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    end--;\r\n    return end > start ? new int[] { start, end } : null;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.ActivityQueryService.getEatingSnakeAvgPoint",
	"Comment": "gets average point of activity eating snake of a user specified by the given user id.",
	"Method": "int getEatingSnakeAvgPoint(String userId){\r\n    return pointtransferRepository.getActivityEatingSnakeAvg(userId);\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.uiUtils.RecyclerViewPositionHelper.findFirstCompletelyVisibleItemPosition",
	"Comment": "returns the adapter position of the first fully visible view. this position does not includeadapter changes that were dispatched after the last layout pass.",
	"Method": "int findFirstCompletelyVisibleItemPosition(){\r\n    final View child = findOneVisibleChild(0, layoutManager.getChildCount(), true, false);\r\n    return child == null ? RecyclerView.NO_POSITION : recyclerView.getChildAdapterPosition(child);\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.EllipticCurves.fieldSizeInBits",
	"Comment": "returns the size of an element of the field over which the curve is defined.",
	"Method": "int fieldSizeInBits(EllipticCurve curve){\r\n    return getModulus(curve).subtract(BigInteger.ONE).bitLength();\r\n}"
}, {
	"Path": "org.b3log.symphony.service.RoleQueryService.getPermissionsGrant",
	"Comment": "gets all permissions and marks grant of an role specified by the given role id.",
	"Method": "List<JSONObject> getPermissionsGrant(String roleId){\r\n    final List<JSONObject> ret = new ArrayList();\r\n    try {\r\n        final List<JSONObject> permissions = CollectionUtils.jsonArrayToList(permissionRepository.get(new Query()).optJSONArray(Keys.RESULTS));\r\n        final List<JSONObject> rolePermissions = rolePermissionRepository.getByRoleId(roleId);\r\n        for (final JSONObject permission : permissions) {\r\n            final String permissionId = permission.optString(Keys.OBJECT_ID);\r\n            permission.put(Permission.PERMISSION_T_GRANT, false);\r\n            ret.add(permission);\r\n            for (final JSONObject rolePermission : rolePermissions) {\r\n                final String grantPermissionId = rolePermission.optString(Permission.PERMISSION_ID);\r\n                if (permissionId.equals(grantPermissionId)) {\r\n                    permission.put(Permission.PERMISSION_T_GRANT, true);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Gets permissions grant of role [id=\" + roleId + \"] failed\", e);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.quickAdapter.extBaseAdapter.BaseAdapterHelper.setTypeface",
	"Comment": "apply the typeface to all the given viewids, and enable subpixelrendering.",
	"Method": "BaseAdapterHelper setTypeface(int viewId,Typeface typeface,BaseAdapterHelper setTypeface,Typeface typeface,int viewIds){\r\n    for (int viewId : viewIds) {\r\n        TextView view = retrieveView(viewId);\r\n        view.setTypeface(typeface);\r\n        view.setPaintFlags(view.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.http.HttpClientOptions.getDefaultHost",
	"Comment": "get the default host name to be used by this client in requests if none is provided when making the request.",
	"Method": "String getDefaultHost(){\r\n    return defaultHost;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.ArticleMgmtService.adminCancelStick",
	"Comment": "admin cancels stick an article specified by the given article id.",
	"Method": "void adminCancelStick(String articleId){\r\n    try {\r\n        final JSONObject article = articleRepository.get(articleId);\r\n        if (null == article) {\r\n            return;\r\n        }\r\n        article.put(Article.ARTICLE_STICK, 0L);\r\n        articleRepository.update(articleId, article);\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Admin cancel sticks an article[id=\" + articleId + \"] failed\", e);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.ui.header.RecyclerViewHeader.fromXml",
	"Comment": "inflates layout from xml and encapsulates it with recyclerviewheader.",
	"Method": "RecyclerViewHeader fromXml(Context context,int layoutRes,RecyclerViewHeader fromXml,Context context,int layoutRes,RecyclerView.ItemDecoration decoration){\r\n    RecyclerViewHeader header = new RecyclerViewHeader(context);\r\n    View.inflate(context, layoutRes, header);\r\n    header.setDecor(decoration);\r\n    return header;\r\n}"
}, {
	"Path": "io.vertx.core.http.HttpClientOptions.setMaxWaitQueueSize",
	"Comment": "set the maximum requests allowed in the wait queue, any requests beyond the max size will result ina connectionpooltoobusyexception.if the value is set to a negative number then the queue will be unbounded.",
	"Method": "HttpClientOptions setMaxWaitQueueSize(int maxWaitQueueSize){\r\n    this.maxWaitQueueSize = maxWaitQueueSize;\r\n    return this;\r\n}"
}, {
	"Path": "com.yalantis.ucrop.view.TransformImageView.getMatrixScale",
	"Comment": "this method calculates scale value for given matrix object.",
	"Method": "float getMatrixScale(Matrix matrix){\r\n    return (float) Math.sqrt(Math.pow(getMatrixValue(matrix, Matrix.MSCALE_X), 2) + Math.pow(getMatrixValue(matrix, Matrix.MSKEW_Y), 2));\r\n}"
}, {
	"Path": "org.b3log.symphony.util.Symphonys.getFloat",
	"Comment": "gets a configuration float property with the specified key.",
	"Method": "Float getFloat(String key){\r\n    final String stringValue = get(key);\r\n    if (null == stringValue) {\r\n        return null;\r\n    }\r\n    return Float.valueOf(stringValue);\r\n}"
}, {
	"Path": "com.google.crypto.tink.signature.EcdsaSignKeyManagerTest.testGetPublicKeyData",
	"Comment": "tests that a public key is extracted properly from a private key.",
	"Method": "void testGetPublicKeyData(){\r\n    KeysetHandle privateHandle = KeysetHandle.generateNew(SignatureKeyTemplates.ECDSA_P256);\r\n    KeyData privateKeyData = TestUtil.getKeyset(privateHandle).getKey(0).getKeyData();\r\n    EcdsaSignKeyManager privateManager = new EcdsaSignKeyManager();\r\n    KeyData publicKeyData = privateManager.getPublicKeyData(privateKeyData.getValue());\r\n    assertEquals(EcdsaVerifyKeyManager.TYPE_URL, publicKeyData.getTypeUrl());\r\n    assertEquals(KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC, publicKeyData.getKeyMaterialType());\r\n    EcdsaPrivateKey privateKey = EcdsaPrivateKey.parseFrom(privateKeyData.getValue());\r\n    assertArrayEquals(privateKey.getPublicKey().toByteArray(), publicKeyData.getValue().toByteArray());\r\n    EcdsaVerifyKeyManager publicManager = new EcdsaVerifyKeyManager();\r\n    PublicKeySign signer = privateManager.getPrimitive(privateKeyData.getValue());\r\n    PublicKeyVerify verifier = publicManager.getPrimitive(publicKeyData.getValue());\r\n    byte[] message = Random.randBytes(20);\r\n    try {\r\n        verifier.verify(signer.sign(message), message);\r\n    } catch (GeneralSecurityException e) {\r\n        fail(\"Should not fail: \" + e);\r\n    }\r\n}"
}, {
	"Path": "com.vip.vjtools.vjkit.collection.type.primitive.IntObjectHashMap.removeAt",
	"Comment": "removes entry at the given index position. also performs opportunistic, incremental rehashing if necessary to not\tbreak conflict chains.",
	"Method": "boolean removeAt(int index){\r\n    --size;\r\n    keys[index] = 0;\r\n    values[index] = null;\r\n    int nextFree = index;\r\n    int i = probeNext(index);\r\n    for (V value = values[i]; value != null; value = values[i = probeNext(i)]) {\r\n        int key = keys[i];\r\n        int bucket = hashIndex(key);\r\n        if (i < bucket && (bucket <= nextFree || nextFree <= i) || bucket <= nextFree && nextFree <= i) {\r\n            keys[nextFree] = key;\r\n            values[nextFree] = value;\r\n            keys[i] = 0;\r\n            values[i] = null;\r\n            nextFree = i;\r\n        }\r\n    }\r\n    return nextFree != index;\r\n}"
}, {
	"Path": "com.vip.vjtools.vjtop.util.LongObjectHashMap.growSize",
	"Comment": "grows the map size after an insertion. if necessary, performs a rehash of the map.",
	"Method": "void growSize(){\r\n    size++;\r\n    if (size > maxSize) {\r\n        if (keys.length == Integer.MAX_VALUE) {\r\n            throw new IllegalStateException(\"Max capacity reached at size=\" + size);\r\n        }\r\n        rehash(keys.length << 1);\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.client.android.camera.CameraManager.getFramingRect",
	"Comment": "calculates the framing rect which the ui should draw to show the user where to place thebarcode. this target helps with alignment as well as forces the user to hold the devicefar enough away to ensure the image will be in focus.",
	"Method": "Rect getFramingRect(){\r\n    if (framingRect == null) {\r\n        if (camera == null) {\r\n            return null;\r\n        }\r\n        Point screenResolution = configManager.getScreenResolution();\r\n        if (screenResolution == null) {\r\n            return null;\r\n        }\r\n        int width = findDesiredDimensionInRange(screenResolution.x, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);\r\n        int height = findDesiredDimensionInRange(screenResolution.y, MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);\r\n        int leftOffset = (screenResolution.x - width) / 2;\r\n        int topOffset = (screenResolution.y - height) / 2;\r\n        framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);\r\n        Log.d(TAG, \"Calculated framing rect: \" + framingRect);\r\n    }\r\n    return framingRect;\r\n}"
}, {
	"Path": "io.vertx.core.http.HttpClientOptions.setDefaultPort",
	"Comment": "set the default port to be used by this client in requests if none is provided when making the request.",
	"Method": "HttpClientOptions setDefaultPort(int defaultPort){\r\n    this.defaultPort = defaultPort;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateRecyclerView.setRefreshing",
	"Comment": "notify the widget that refresh state has changed. do not call this when refresh is triggered by a swipe gesture.",
	"Method": "void setRefreshing(boolean refreshing){\r\n    if (mSwipeRefreshLayout != null)\r\n        mSwipeRefreshLayout.setRefreshing(refreshing);\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateRecyclerviewViewHolder.onBindView",
	"Comment": "method called when we need to update the view hold by this class.",
	"Method": "void onBindView(Object object){\r\n    mObject = (T) object;\r\n    updateView(mView.getContext(), mObject);\r\n}"
}, {
	"Path": "com.vip.vjtools.vjtop.util.LongObjectHashMap.removeAt",
	"Comment": "removes entry at the given index position. also performs opportunistic, incremental rehashing if necessary to not\tbreak conflict chains.",
	"Method": "boolean removeAt(int index){\r\n    --size;\r\n    keys[index] = 0;\r\n    values[index] = null;\r\n    int nextFree = index;\r\n    int i = probeNext(index);\r\n    for (V value = values[i]; value != null; value = values[i = probeNext(i)]) {\r\n        long key = keys[i];\r\n        int bucket = hashIndex(key);\r\n        if (i < bucket && (bucket <= nextFree || nextFree <= i) || bucket <= nextFree && nextFree <= i) {\r\n            keys[nextFree] = key;\r\n            values[nextFree] = value;\r\n            keys[i] = 0;\r\n            values[i] = null;\r\n            nextFree = i;\r\n        }\r\n    }\r\n    return nextFree != index;\r\n}"
}, {
	"Path": "io.vertx.core.json.JsonObject.encodePrettily",
	"Comment": "encode this json object a a string, with whitespace to make the object easier to read by a human, or othersentient organism.",
	"Method": "String encodePrettily(){\r\n    return Json.encodePrettily(map);\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.demo.modules.CircularImageView.setSelectorStrokeWidth",
	"Comment": "sets the stroke width to be drawn around the circularimageview\tduring click events when the selector is enabled.",
	"Method": "void setSelectorStrokeWidth(int selectorStrokeWidth){\r\n    this.selectorStrokeWidth = selectorStrokeWidth;\r\n    this.requestLayout();\r\n    this.invalidate();\r\n}"
}, {
	"Path": "io.vertx.core.net.PemKeyCertOptions.setKeyValue",
	"Comment": "set the first key a a buffer, replacing the previous keys buffers",
	"Method": "PemKeyCertOptions setKeyValue(Buffer keyValue){\r\n    keyValues.clear();\r\n    if (keyValue != null) {\r\n        keyValues.add(keyValue);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.net.impl.ConnectionBase.sendFileRegion",
	"Comment": "send a file as a file region for zero copy transfer to the socket.the implementation splits the file into multiple regions to avoid stalling the pipelineand producing idle timeouts for very large files.",
	"Method": "void sendFileRegion(RandomAccessFile file,long offset,long length,ChannelPromise writeFuture){\r\n    if (length < MAX_REGION_SIZE) {\r\n        writeToChannel(new DefaultFileRegion(file.getChannel(), offset, length), writeFuture);\r\n    } else {\r\n        ChannelPromise promise = chctx.newPromise();\r\n        FileRegion region = new DefaultFileRegion(file.getChannel(), offset, MAX_REGION_SIZE);\r\n        region.retain();\r\n        writeToChannel(region, promise);\r\n        promise.addListener(future -> {\r\n            if (future.isSuccess()) {\r\n                sendFileRegion(file, offset + MAX_REGION_SIZE, length - MAX_REGION_SIZE, writeFuture);\r\n            } else {\r\n                future.cause().printStackTrace();\r\n                writeFuture.setFailure(future.cause());\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.spi.metrics.VertxMetrics.createNetClientMetrics",
	"Comment": "provides the net client metrics spi when a net client is created.no specific thread and context can be expected when this method is called.",
	"Method": "TCPMetrics<?> createNetClientMetrics(NetClientOptions options){\r\n    return null;\r\n}"
}, {
	"Path": "com.google.zxing.qrcode.encoder.Encoder.recommendVersion",
	"Comment": "decides the smallest version of qr code that will contain all of the provided data.",
	"Method": "Version recommendVersion(ErrorCorrectionLevel ecLevel,Mode mode,BitArray headerBits,BitArray dataBits){\r\n    int provisionalBitsNeeded = calculateBitsNeeded(mode, headerBits, dataBits, Version.getVersionForNumber(1));\r\n    Version provisionalVersion = chooseVersion(provisionalBitsNeeded, ecLevel);\r\n    int bitsNeeded = calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);\r\n    return chooseVersion(bitsNeeded, ecLevel);\r\n}"
}, {
	"Path": "org.b3log.symphony.repository.NotificationRepository.hasSentByDataIdAndType",
	"Comment": "checks whether has sent a notification to a user specified by the given user id with the specified data id and data type.",
	"Method": "boolean hasSentByDataIdAndType(String userId,String dataId,int notificationDataType){\r\n    try {\r\n        return 0 < count(new Query().setFilter(CompositeFilterOperator.and(new PropertyFilter(Notification.NOTIFICATION_USER_ID, FilterOperator.EQUAL, userId), new PropertyFilter(Notification.NOTIFICATION_DATA_ID, FilterOperator.EQUAL, dataId), new PropertyFilter(Notification.NOTIFICATION_DATA_TYPE, FilterOperator.EQUAL, notificationDataType))));\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Checks [\" + notificationDataType + \"] notification sent failed [userId=\" + userId + \", dataId=\" + dataId + \"]\", e);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "us.codecraft.webmagic.Request.setPriority",
	"Comment": "set the priority of request for sorting.need a scheduler supporting priority.",
	"Method": "Request setPriority(long priority){\r\n    this.priority = priority;\r\n    return this;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.NotificationQueryService.getUnreadNotificationCount",
	"Comment": "gets the count of unread notifications of a user specified with the given user id.",
	"Method": "int getUnreadNotificationCount(String userId){\r\n    Stopwatchs.start(\"Gets unread notification count\");\r\n    try {\r\n        final Query query = new Query();\r\n        query.setFilter(CompositeFilterOperator.and(new PropertyFilter(Notification.NOTIFICATION_USER_ID, FilterOperator.EQUAL, userId), new PropertyFilter(Notification.NOTIFICATION_HAS_READ, FilterOperator.EQUAL, false)));\r\n        try {\r\n            return (int) notificationRepository.count(query);\r\n        } catch (final RepositoryException e) {\r\n            LOGGER.log(Level.ERROR, \"Gets unread notification count failed [userId=\" + userId + \"]\", e);\r\n            return 0;\r\n        }\r\n    } finally {\r\n        Stopwatchs.end();\r\n    }\r\n}"
}, {
	"Path": "io.vertx.test.core.TestUtils.assertIndexOutOfBoundsException",
	"Comment": "asserts that an indexoutofboundsexception is thrown by the code block.",
	"Method": "void assertIndexOutOfBoundsException(Runnable runnable){\r\n    try {\r\n        runnable.run();\r\n        fail(\"Should throw IndexOutOfBoundsException\");\r\n    } catch (IndexOutOfBoundsException e) {\r\n    }\r\n}"
}, {
	"Path": "us.codecraft.webmagic.ResultItems.setSkip",
	"Comment": "set whether to skip the result.result which is skipped will not be processed by pipeline.",
	"Method": "ResultItems setSkip(boolean skip){\r\n    this.skip = skip;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.zxing.pdf417.encoder.PDF417HighLevelEncoder.determineConsecutiveTextCount",
	"Comment": "determines the number of consecutive characters that are encodable using text compaction.",
	"Method": "int determineConsecutiveTextCount(CharSequence msg,int startpos){\r\n    int len = msg.length();\r\n    int idx = startpos;\r\n    while (idx < len) {\r\n        char ch = msg.charAt(idx);\r\n        int numericCount = 0;\r\n        while (numericCount < 13 && isDigit(ch) && idx < len) {\r\n            numericCount++;\r\n            idx++;\r\n            if (idx < len) {\r\n                ch = msg.charAt(idx);\r\n            }\r\n        }\r\n        if (numericCount >= 13) {\r\n            return idx - startpos - numericCount;\r\n        }\r\n        if (numericCount > 0) {\r\n            continue;\r\n        }\r\n        ch = msg.charAt(idx);\r\n        if (!isText(ch)) {\r\n            break;\r\n        }\r\n        idx++;\r\n    }\r\n    return idx - startpos;\r\n}"
}, {
	"Path": "com.google.zxing.qrcode.QRCodeWriterTestCase.createMatrixFromImage",
	"Comment": "in case the golden images are not monochromatic, convert the rgb values to greyscale.",
	"Method": "BitMatrix createMatrixFromImage(BufferedImage image){\r\n    int width = image.getWidth();\r\n    int height = image.getHeight();\r\n    int[] pixels = new int[width * height];\r\n    image.getRGB(0, 0, width, height, pixels, 0, width);\r\n    BitMatrix matrix = new BitMatrix(width, height);\r\n    for (int y = 0; y < height; y++) {\r\n        for (int x = 0; x < width; x++) {\r\n            int pixel = pixels[y * width + x];\r\n            int luminance = (306 * ((pixel >> 16) & 0xFF) + 601 * ((pixel >> 8) & 0xFF) + 117 * (pixel & 0xFF)) >> 10;\r\n            if (luminance <= 0x7F) {\r\n                matrix.set(x, y);\r\n            }\r\n        }\r\n    }\r\n    return matrix;\r\n}"
}, {
	"Path": "io.vertx.core.cli.UsageMessageFormatter.renderWrappedText",
	"Comment": "render the specified text and return the rendered optionsin a stringbuilder.",
	"Method": "StringBuilder renderWrappedText(StringBuilder sb,int width,int nextLineTabStop,String text){\r\n    int pos = findWrapPos(text, width, 0);\r\n    if (pos == -1) {\r\n        sb.append(rtrim(text));\r\n        return sb;\r\n    }\r\n    sb.append(rtrim(text.substring(0, pos))).append(getNewLine());\r\n    if (nextLineTabStop >= width) {\r\n        nextLineTabStop = 1;\r\n    }\r\n    final String padding = createPadding(nextLineTabStop);\r\n    while (true) {\r\n        text = padding + text.substring(pos).trim();\r\n        pos = findWrapPos(text, width, 0);\r\n        if (pos == -1) {\r\n            sb.append(text);\r\n            return sb;\r\n        }\r\n        if (text.length() > width && pos == nextLineTabStop - 1) {\r\n            pos = width;\r\n        }\r\n        sb.append(rtrim(text.substring(0, pos))).append(getNewLine());\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.SignatureThreadSafetyTest.testSigningDistinctMessages",
	"Comment": "sign distinct messages concurrently in multiple threads. the purpose of this test is to finddeterministic signatures schemes, that share state to compute nonces.",
	"Method": "void testSigningDistinctMessages(PublicKeySign signer,PublicKeyVerify verifier,boolean isDeterministic,int maxMessageSize,int numberOfThreads,int numberOfSignatures){\r\n    ExceptionHandler exceptionHandler = new ExceptionHandler();\r\n    Thread[] thread = new Thread[numberOfThreads];\r\n    ArrayList<HashSet<String>> signatures = new ArrayList<HashSet<String>>();\r\n    byte[][] messages = new byte[numberOfThreads][];\r\n    for (int i = 0; i < numberOfThreads; i++) {\r\n        int p = 28657;\r\n        int size = i * p % (maxMessageSize + 1);\r\n        messages[i] = new byte[size];\r\n        HashSet<String> sigs = new HashSet<String>();\r\n        signatures.add(sigs);\r\n        thread[i] = new SigningThread(signer, sigs, messages[i], numberOfSignatures);\r\n        thread[i].setUncaughtExceptionHandler(exceptionHandler);\r\n    }\r\n    for (int i = 0; i < numberOfThreads; i++) {\r\n        thread[i].start();\r\n    }\r\n    for (int i = 0; i < numberOfThreads; i++) {\r\n        thread[i].join();\r\n    }\r\n    exceptionHandler.check();\r\n    if (isDeterministic) {\r\n        for (int i = 0; i < numberOfThreads; i++) {\r\n            String expectedSignature = TestUtil.hexEncode(signer.sign(messages[i]));\r\n            assertEquals(1, signatures.get(i).size());\r\n            assertTrue(signatures.get(i).contains(expectedSignature));\r\n        }\r\n    } else {\r\n        for (int i = 0; i < numberOfThreads; i++) {\r\n            assertEquals(numberOfSignatures, signatures.get(i).size());\r\n            for (String sig : signatures.get(i)) {\r\n                verifier.verify(TestUtil.hexDecode(sig), messages[i]);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.dns.AddressResolverOptions.setHostsValue",
	"Comment": "set an alternate hosts configuration file to use instead of the one provided by the os.the value should contain the hosts content literaly, for instance 127.0.0.1 localhostthe default value is null, so the operating system hosts config is used.",
	"Method": "AddressResolverOptions setHostsValue(Buffer hostsValue){\r\n    this.hostsValue = hostsValue;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.zxing.pdf417.detector.Detector.detect",
	"Comment": "detects pdf417 codes in an image. only checks 0 degree rotation",
	"Method": "PDF417DetectorResult detect(BinaryBitmap image,Map<DecodeHintType, ?> hints,boolean multiple,List<ResultPoint[]> detect,boolean multiple,BitMatrix bitMatrix){\r\n    List<ResultPoint[]> barcodeCoordinates = new ArrayList();\r\n    int row = 0;\r\n    int column = 0;\r\n    boolean foundBarcodeInRow = false;\r\n    while (row < bitMatrix.getHeight()) {\r\n        ResultPoint[] vertices = findVertices(bitMatrix, row, column);\r\n        if (vertices[0] == null && vertices[3] == null) {\r\n            if (!foundBarcodeInRow) {\r\n                break;\r\n            }\r\n            foundBarcodeInRow = false;\r\n            column = 0;\r\n            for (ResultPoint[] barcodeCoordinate : barcodeCoordinates) {\r\n                if (barcodeCoordinate[1] != null) {\r\n                    row = (int) Math.max(row, barcodeCoordinate[1].getY());\r\n                }\r\n                if (barcodeCoordinate[3] != null) {\r\n                    row = Math.max(row, (int) barcodeCoordinate[3].getY());\r\n                }\r\n            }\r\n            row += ROW_STEP;\r\n            continue;\r\n        }\r\n        foundBarcodeInRow = true;\r\n        barcodeCoordinates.add(vertices);\r\n        if (!multiple) {\r\n            break;\r\n        }\r\n        if (vertices[2] != null) {\r\n            column = (int) vertices[2].getX();\r\n            row = (int) vertices[2].getY();\r\n        } else {\r\n            column = (int) vertices[4].getX();\r\n            row = (int) vertices[4].getY();\r\n        }\r\n    }\r\n    return barcodeCoordinates;\r\n}"
}, {
	"Path": "io.vertx.core.net.impl.SSLHelper.validate",
	"Comment": "this is called to validate some of the ssl params as that only happens when the context is created",
	"Method": "void validate(VertxInternal vertx){\r\n    if (ssl) {\r\n        getContext(vertx, null);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.service.CommentQueryService.getUserComments",
	"Comment": "gets the user comments with the specified user id, page number and page size.",
	"Method": "List<JSONObject> getUserComments(int avatarViewMode,String userId,int anonymous,int currentPageNum,int pageSize,JSONObject viewer){\r\n    final Query query = new Query().addSort(Comment.COMMENT_CREATE_TIME, SortDirection.DESCENDING).setCurrentPageNum(currentPageNum).setPageSize(pageSize).setFilter(CompositeFilterOperator.and(new PropertyFilter(Comment.COMMENT_AUTHOR_ID, FilterOperator.EQUAL, userId), new PropertyFilter(Comment.COMMENT_ANONYMOUS, FilterOperator.EQUAL, anonymous)));\r\n    try {\r\n        final JSONObject result = commentRepository.get(query);\r\n        final List<JSONObject> ret = CollectionUtils.jsonArrayToList(result.optJSONArray(Keys.RESULTS));\r\n        if (ret.isEmpty()) {\r\n            return ret;\r\n        }\r\n        String currentUserId = null;\r\n        if (null != viewer) {\r\n            currentUserId = viewer.optString(Keys.OBJECT_ID);\r\n        }\r\n        final JSONObject pagination = result.optJSONObject(Pagination.PAGINATION);\r\n        final int recordCount = pagination.optInt(Pagination.PAGINATION_RECORD_COUNT);\r\n        final int pageCount = pagination.optInt(Pagination.PAGINATION_PAGE_COUNT);\r\n        final JSONObject first = ret.get(0);\r\n        first.put(Pagination.PAGINATION_RECORD_COUNT, recordCount);\r\n        first.put(Pagination.PAGINATION_PAGE_COUNT, pageCount);\r\n        for (final JSONObject comment : ret) {\r\n            comment.put(Comment.COMMENT_CREATE_TIME, new Date(comment.optLong(Comment.COMMENT_CREATE_TIME)));\r\n            final String articleId = comment.optString(Comment.COMMENT_ON_ARTICLE_ID);\r\n            final JSONObject article = articleRepository.get(articleId);\r\n            comment.put(Comment.COMMENT_T_ARTICLE_TITLE, Article.ARTICLE_STATUS_C_INVALID == article.optInt(Article.ARTICLE_STATUS) ? langPropsService.get(\"articleTitleBlockLabel\") : Emotions.convert(article.optString(Article.ARTICLE_TITLE)));\r\n            comment.put(Comment.COMMENT_T_ARTICLE_TYPE, article.optInt(Article.ARTICLE_TYPE));\r\n            comment.put(Comment.COMMENT_T_ARTICLE_PERMALINK, article.optString(Article.ARTICLE_PERMALINK));\r\n            comment.put(Comment.COMMENT_T_ARTICLE_PERFECT, article.optInt(Article.ARTICLE_PERFECT));\r\n            final JSONObject commenter = userRepository.get(userId);\r\n            comment.put(Comment.COMMENT_T_COMMENTER, commenter);\r\n            final String articleAuthorId = article.optString(Article.ARTICLE_AUTHOR_ID);\r\n            final JSONObject articleAuthor = userRepository.get(articleAuthorId);\r\n            final String articleAuthorName = articleAuthor.optString(User.USER_NAME);\r\n            if (Article.ARTICLE_ANONYMOUS_C_PUBLIC == article.optInt(Article.ARTICLE_ANONYMOUS)) {\r\n                comment.put(Comment.COMMENT_T_ARTICLE_AUTHOR_NAME, articleAuthorName);\r\n                comment.put(Comment.COMMENT_T_ARTICLE_AUTHOR_URL, \"/member/\" + articleAuthor.optString(User.USER_NAME));\r\n                final String articleAuthorThumbnailURL = avatarQueryService.getAvatarURLByUser(avatarViewMode, articleAuthor, \"48\");\r\n                comment.put(Comment.COMMENT_T_ARTICLE_AUTHOR_THUMBNAIL_URL, articleAuthorThumbnailURL);\r\n            } else {\r\n                comment.put(Comment.COMMENT_T_ARTICLE_AUTHOR_NAME, UserExt.ANONYMOUS_USER_NAME);\r\n                comment.put(Comment.COMMENT_T_ARTICLE_AUTHOR_URL, \"\");\r\n                comment.put(Comment.COMMENT_T_ARTICLE_AUTHOR_THUMBNAIL_URL, avatarQueryService.getDefaultAvatarURL(\"48\"));\r\n            }\r\n            final String commentId = comment.optString(Keys.OBJECT_ID);\r\n            final int cmtViewMode = UserExt.USER_COMMENT_VIEW_MODE_C_TRADITIONAL;\r\n            final int cmtPage = getCommentPage(articleId, commentId, cmtViewMode, Symphonys.getInt(\"articleCommentsPageSize\"));\r\n            comment.put(Comment.COMMENT_SHARP_URL, \"/article/\" + articleId + \"?p=\" + cmtPage + \"&m=\" + cmtViewMode + \"#\" + commentId);\r\n            if (Article.ARTICLE_TYPE_C_DISCUSSION == article.optInt(Article.ARTICLE_TYPE) && Article.ARTICLE_ANONYMOUS_C_PUBLIC == article.optInt(Article.ARTICLE_ANONYMOUS)) {\r\n                final String msgContent = langPropsService.get(\"articleDiscussionLabel\").replace(\"{user}\", UserExt.getUserLink(articleAuthorName));\r\n                if (null == viewer) {\r\n                    comment.put(Comment.COMMENT_CONTENT, msgContent);\r\n                } else {\r\n                    final String commenterName = commenter.optString(User.USER_NAME);\r\n                    final String viewerUserName = viewer.optString(User.USER_NAME);\r\n                    final String viewerRole = viewer.optString(User.USER_ROLE);\r\n                    if (!commenterName.equals(viewerUserName) && !Role.ROLE_ID_C_ADMIN.equals(viewerRole)) {\r\n                        final String articleContent = article.optString(Article.ARTICLE_CONTENT);\r\n                        final Set<String> userNames = userQueryService.getUserNames(articleContent);\r\n                        boolean invited = false;\r\n                        for (final String userName : userNames) {\r\n                            if (userName.equals(viewerUserName)) {\r\n                                invited = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!invited) {\r\n                            comment.put(Comment.COMMENT_CONTENT, msgContent);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            processCommentContent(comment);\r\n            if (Comment.COMMENT_VISIBLE_C_AUTHOR == comment.optInt(Comment.COMMENT_VISIBLE)) {\r\n                if (StringUtils.isBlank(currentUserId) || (!StringUtils.equals(currentUserId, userId) && !StringUtils.equals(currentUserId, articleAuthorId))) {\r\n                    comment.put(Comment.COMMENT_CONTENT, langPropsService.get(\"onlySelfAndArticleAuthorVisibleLabel\"));\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Gets user comments failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.impl.VertxImpl.getWorkerPool",
	"Comment": "the background pool is used for making blocking calls to legacy synchronous apis",
	"Method": "ExecutorService getWorkerPool(){\r\n    return workerPool.executor();\r\n}"
}, {
	"Path": "io.vertx.core.http.impl.HttpServerImpl.closeAll",
	"Comment": "internal method that closes all servers when vert.x is closing",
	"Method": "void closeAll(Handler<AsyncResult<Void>> handler){\r\n    List<HttpHandlers> list = httpHandlerMgr.handlers();\r\n    List<Future> futures = list.stream().<Future<Void>>map(handlers -> Future.future(handlers.server::close)).collect(Collectors.toList());\r\n    CompositeFuture fut = CompositeFuture.all(futures);\r\n    fut.setHandler(ar -> handler.handle(ar.mapEmpty()));\r\n}"
}, {
	"Path": "io.vertx.core.Vertx.clusteredVertx",
	"Comment": "creates a clustered instance using the specified options.the instance is created asynchronously and the resulthandler is called with the result when it is ready.",
	"Method": "void clusteredVertx(VertxOptions options,Handler<AsyncResult<Vertx>> resultHandler){\r\n    factory.clusteredVertx(options, resultHandler);\r\n}"
}, {
	"Path": "org.b3log.symphony.processor.channel.Channels.getHttpParameter",
	"Comment": "gets a parameter of the specified http session by the given session.",
	"Method": "String getHttpParameter(Session session,String parameterName){\r\n    final Map<String, List<String>> parameterMap = session.getRequestParameterMap();\r\n    for (final String key : parameterMap.keySet()) {\r\n        if (!key.equals(parameterName)) {\r\n            continue;\r\n        }\r\n        final List<String> values = parameterMap.get(key);\r\n        if (null != values && !values.isEmpty()) {\r\n            return values.get(0);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.vertx.core.streams.impl.PumpImpl.start",
	"Comment": "start the pump. the pump can be started and stopped multiple times.",
	"Method": "PumpImpl start(){\r\n    readStream.handler(dataHandler);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.zxing.client.result.URIParsedResult.massageURI",
	"Comment": "transforms a string that represents a uri into something more proper, by adding or canonicalizingthe protocol.",
	"Method": "String massageURI(String uri){\r\n    uri = uri.trim();\r\n    int protocolEnd = uri.indexOf(':');\r\n    if (protocolEnd < 0 || isColonFollowedByPortNumber(uri, protocolEnd)) {\r\n        uri = \"http://\" + uri;\r\n    }\r\n    return uri;\r\n}"
}, {
	"Path": "com.google.zxing.integration.android.IntentIntegrator.shareText",
	"Comment": "shares the given text by encoding it as a barcode, such that another user canscan the text off the screen of the device.",
	"Method": "AlertDialog shareText(CharSequence text,AlertDialog shareText,CharSequence text,CharSequence type){\r\n    Intent intent = new Intent();\r\n    intent.addCategory(Intent.CATEGORY_DEFAULT);\r\n    intent.setAction(BS_PACKAGE + \".ENCODE\");\r\n    intent.putExtra(\"ENCODE_TYPE\", type);\r\n    intent.putExtra(\"ENCODE_DATA\", text);\r\n    String targetAppPackage = findTargetAppPackage(intent);\r\n    if (targetAppPackage == null) {\r\n        return showDownloadDialog();\r\n    }\r\n    intent.setPackage(targetAppPackage);\r\n    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\r\n    intent.addFlags(FLAG_NEW_DOC);\r\n    attachMoreExtras(intent);\r\n    if (fragment == null) {\r\n        activity.startActivity(intent);\r\n    } else {\r\n        fragment.startActivity(intent);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.yalantis.ucrop.sample.SampleActivity.onRequestPermissionsResult",
	"Comment": "callback received when a permissions request has been completed.",
	"Method": "void onRequestPermissionsResult(int requestCode,String[] permissions,int[] grantResults){\r\n    switch(requestCode) {\r\n        case REQUEST_STORAGE_READ_ACCESS_PERMISSION:\r\n            if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\r\n                pickFromGallery();\r\n            }\r\n            break;\r\n        default:\r\n            super.onRequestPermissionsResult(requestCode, permissions, grantResults);\r\n    }\r\n}"
}, {
	"Path": "com.yalantis.ucrop.sample.ResultActivity.onRequestPermissionsResult",
	"Comment": "callback received when a permissions request has been completed.",
	"Method": "void onRequestPermissionsResult(int requestCode,String[] permissions,int[] grantResults){\r\n    switch(requestCode) {\r\n        case REQUEST_STORAGE_WRITE_ACCESS_PERMISSION:\r\n            if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\r\n                saveCroppedImage();\r\n            }\r\n            break;\r\n        default:\r\n            super.onRequestPermissionsResult(requestCode, permissions, grantResults);\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.client.android.result.ResultHandler.areContentsSecure",
	"Comment": "some barcode contents are considered secure, and should not be saved to history, copied tothe clipboard, or otherwise persisted.",
	"Method": "boolean areContentsSecure(){\r\n    return false;\r\n}"
}, {
	"Path": "org.b3log.symphony.model.UserExt.isReservedUserName",
	"Comment": "checks the specified user name whether is a reserved user name.",
	"Method": "boolean isReservedUserName(String userName){\r\n    for (final String reservedUserName : Symphonys.RESERVED_USER_NAMES) {\r\n        if (StringUtils.equalsIgnoreCase(userName, reservedUserName)) {\r\n            return true;\r\n        }\r\n    }\r\n    return StringUtils.containsIgnoreCase(userName, UserExt.ANONYMOUS_USER_NAME);\r\n}"
}, {
	"Path": "org.b3log.symphony.util.Symphonys.getBoolean",
	"Comment": "gets a configuration boolean property with the specified key.",
	"Method": "Boolean getBoolean(String key){\r\n    final String stringValue = get(key);\r\n    if (null == stringValue) {\r\n        return null;\r\n    }\r\n    return Boolean.valueOf(stringValue);\r\n}"
}, {
	"Path": "io.vertx.core.cli.UsageMessageFormatter.getLongOptionSeparator",
	"Comment": "returns the separator displayed between a long option and its value.",
	"Method": "String getLongOptionSeparator(){\r\n    return longOptSeparator;\r\n}"
}, {
	"Path": "io.vertx.core.net.ClientOptionsBase.setMetricsName",
	"Comment": "set the metrics name identifying the reported metrics, useful for grouping metricswith the same name.",
	"Method": "ClientOptionsBase setMetricsName(String metricsName){\r\n    this.metricsName = metricsName;\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.streams.impl.PumpImpl.stop",
	"Comment": "stop the pump. the pump can be started and stopped multiple times.",
	"Method": "PumpImpl stop(){\r\n    writeStream.drainHandler(null);\r\n    readStream.handler(null);\r\n    return this;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.VerifycodeQueryService.getVerifycodeByUserId",
	"Comment": "gets a verifycode with the specified type, biz type and user id.",
	"Method": "JSONObject getVerifycodeByUserId(int type,int bizType,String userId){\r\n    final Query query = new Query().setFilter(CompositeFilterOperator.and(new PropertyFilter(Verifycode.TYPE, FilterOperator.EQUAL, type), new PropertyFilter(Verifycode.BIZ_TYPE, FilterOperator.EQUAL, bizType), new PropertyFilter(Verifycode.USER_ID, FilterOperator.EQUAL, userId))).addSort(Keys.OBJECT_ID, SortDirection.DESCENDING);\r\n    try {\r\n        final JSONObject result = verifycodeRepository.get(query);\r\n        final JSONArray codes = result.optJSONArray(Keys.RESULTS);\r\n        if (0 == codes.length()) {\r\n            return null;\r\n        }\r\n        return codes.optJSONObject(0);\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Gets verifycode failed\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.dns.DnsClientOptions.setQueryTimeout",
	"Comment": "set the query timeout in milliseconds, i.e the amount of time after a query is considered to be failed.",
	"Method": "DnsClientOptions setQueryTimeout(long queryTimeout){\r\n    if (queryTimeout < 1) {\r\n        throw new IllegalArgumentException(\"queryTimeout must be > 0\");\r\n    }\r\n    this.queryTimeout = queryTimeout;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.loader.tools.Repackager.addMainClassTimeoutWarningListener",
	"Comment": "add a listener that will be triggered to display a warning if searching for the\tmain class takes too long.",
	"Method": "void addMainClassTimeoutWarningListener(MainClassTimeoutWarningListener listener){\r\n    this.mainClassTimeoutListeners.add(listener);\r\n}"
}, {
	"Path": "io.vertx.core.http.HttpServerOptions.setPerMessageWebsocketCompressionSupported",
	"Comment": "enable or disable support for websocket permessage deflate compression",
	"Method": "HttpServerOptions setPerMessageWebsocketCompressionSupported(boolean perMessageWebsocketCompressionSupported){\r\n    this.websocketPermessageDeflateCompressionSupported = perMessageWebsocketCompressionSupported;\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.test.core.TestUtils.assertIllegalArgumentException",
	"Comment": "asserts that an illegalargumentexception is thrown by the code block.",
	"Method": "void assertIllegalArgumentException(Runnable runnable){\r\n    try {\r\n        runnable.run();\r\n        fail(\"Should throw IllegalArgumentException\");\r\n    } catch (IllegalArgumentException e) {\r\n    }\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master == null) {\r\n        return patch;\r\n    } else if (patch == null) {\r\n        return master;\r\n    } else if (!hasSchemaAnnotation(patch)) {\r\n        return master;\r\n    }\r\n    Annotation schema = new io.swagger.v3.oas.annotations.media.Schema() {\r\n        @Override\r\n        public Class<?> implementation() {\r\n            if (!master.implementation().equals(Void.class) || patch.implementation().equals(Void.class)) {\r\n                return master.implementation();\r\n            }\r\n            return patch.implementation();\r\n        }\r\n        @Override\r\n        public Class<?> not() {\r\n            if (!master.not().equals(Void.class) || patch.not().equals(Void.class)) {\r\n                return master.not();\r\n            }\r\n            return patch.not();\r\n        }\r\n        @Override\r\n        public Class<?>[] oneOf() {\r\n            if (master.oneOf().length > 0 || patch.oneOf().length == 0) {\r\n                return master.oneOf();\r\n            }\r\n            return patch.oneOf();\r\n        }\r\n        @Override\r\n        public Class<?>[] anyOf() {\r\n            if (master.anyOf().length > 0 || patch.anyOf().length == 0) {\r\n                return master.anyOf();\r\n            }\r\n            return patch.anyOf();\r\n        }\r\n        @Override\r\n        public Class<?>[] allOf() {\r\n            if (master.allOf().length > 0 || patch.allOf().length == 0) {\r\n                return master.allOf();\r\n            }\r\n            return patch.allOf();\r\n        }\r\n        @Override\r\n        public String name() {\r\n            if (StringUtils.isNotBlank(master.name()) || StringUtils.isBlank(patch.name())) {\r\n                return master.name();\r\n            }\r\n            return patch.name();\r\n        }\r\n        @Override\r\n        public String title() {\r\n            if (StringUtils.isNotBlank(master.title()) || StringUtils.isBlank(patch.title())) {\r\n                return master.title();\r\n            }\r\n            return patch.title();\r\n        }\r\n        @Override\r\n        public double multipleOf() {\r\n            if (master.multipleOf() != 0 || patch.multipleOf() == 0) {\r\n                return master.multipleOf();\r\n            }\r\n            return patch.multipleOf();\r\n        }\r\n        @Override\r\n        public String maximum() {\r\n            if (StringUtils.isNotBlank(master.maximum()) || StringUtils.isBlank(patch.maximum())) {\r\n                return master.maximum();\r\n            }\r\n            return patch.maximum();\r\n        }\r\n        @Override\r\n        public boolean exclusiveMaximum() {\r\n            if (master.exclusiveMaximum() || !patch.exclusiveMaximum()) {\r\n                return master.exclusiveMaximum();\r\n            }\r\n            return patch.exclusiveMaximum();\r\n        }\r\n        @Override\r\n        public String minimum() {\r\n            if (StringUtils.isNotBlank(master.minimum()) || StringUtils.isBlank(patch.minimum())) {\r\n                return master.minimum();\r\n            }\r\n            return patch.minimum();\r\n        }\r\n        @Override\r\n        public boolean exclusiveMinimum() {\r\n            if (master.exclusiveMinimum() || !patch.exclusiveMinimum()) {\r\n                return master.exclusiveMinimum();\r\n            }\r\n            return patch.exclusiveMinimum();\r\n        }\r\n        @Override\r\n        public int maxLength() {\r\n            if ((master.maxLength() != Integer.MAX_VALUE && master.maxLength() > 0) || (patch.maxLength() == Integer.MAX_VALUE || patch.maxLength() == 0)) {\r\n                return master.maxLength();\r\n            }\r\n            return patch.maxLength();\r\n        }\r\n        @Override\r\n        public int minLength() {\r\n            if (master.minLength() != 0 || patch.minLength() == 0) {\r\n                return master.minLength();\r\n            }\r\n            return patch.minLength();\r\n        }\r\n        @Override\r\n        public String pattern() {\r\n            if (StringUtils.isNotBlank(master.pattern()) || StringUtils.isBlank(patch.pattern())) {\r\n                return master.pattern();\r\n            }\r\n            return patch.pattern();\r\n        }\r\n        @Override\r\n        public int maxProperties() {\r\n            if (master.maxProperties() != 0 || patch.maxProperties() == 0) {\r\n                return master.maxProperties();\r\n            }\r\n            return patch.maxProperties();\r\n        }\r\n        @Override\r\n        public int minProperties() {\r\n            if (master.minProperties() != 0 || patch.minProperties() == 0) {\r\n                return master.minProperties();\r\n            }\r\n            return patch.minProperties();\r\n        }\r\n        @Override\r\n        public String[] requiredProperties() {\r\n            if (master.requiredProperties().length > 0 || patch.requiredProperties().length == 0) {\r\n                return master.requiredProperties();\r\n            }\r\n            return patch.requiredProperties();\r\n        }\r\n        @Override\r\n        public boolean required() {\r\n            if (master.required() || !patch.required()) {\r\n                return master.required();\r\n            }\r\n            return patch.required();\r\n        }\r\n        @Override\r\n        public String description() {\r\n            if (StringUtils.isNotBlank(master.description()) || StringUtils.isBlank(patch.description())) {\r\n                return master.description();\r\n            }\r\n            return patch.description();\r\n        }\r\n        @Override\r\n        public String format() {\r\n            if (StringUtils.isNotBlank(master.format()) || StringUtils.isBlank(patch.format())) {\r\n                return master.format();\r\n            }\r\n            return patch.format();\r\n        }\r\n        @Override\r\n        public String ref() {\r\n            if (StringUtils.isNotBlank(master.ref()) || StringUtils.isBlank(patch.ref())) {\r\n                return master.ref();\r\n            }\r\n            return patch.ref();\r\n        }\r\n        @Override\r\n        public boolean nullable() {\r\n            if (master.nullable() || !patch.nullable()) {\r\n                return master.nullable();\r\n            }\r\n            return patch.nullable();\r\n        }\r\n        @Override\r\n        public boolean readOnly() {\r\n            if (master.readOnly() || !patch.readOnly()) {\r\n                return master.readOnly();\r\n            }\r\n            return patch.readOnly();\r\n        }\r\n        @Override\r\n        public boolean writeOnly() {\r\n            if (master.writeOnly() || !patch.writeOnly()) {\r\n                return master.writeOnly();\r\n            }\r\n            return patch.writeOnly();\r\n        }\r\n        @Override\r\n        public AccessMode accessMode() {\r\n            if (!master.accessMode().equals(AccessMode.AUTO) || patch.accessMode().equals(AccessMode.AUTO)) {\r\n                return master.accessMode();\r\n            }\r\n            return patch.accessMode();\r\n        }\r\n        @Override\r\n        public String example() {\r\n            if (StringUtils.isNotBlank(master.example()) || StringUtils.isBlank(patch.example())) {\r\n                return master.example();\r\n            }\r\n            return patch.example();\r\n        }\r\n        @Override\r\n        public io.swagger.v3.oas.annotations.ExternalDocumentation externalDocs() {\r\n            if (getExternalDocumentation(master.externalDocs()).isPresent() || !getExternalDocumentation(patch.externalDocs()).isPresent()) {\r\n                return master.externalDocs();\r\n            }\r\n            return patch.externalDocs();\r\n        }\r\n        @Override\r\n        public boolean deprecated() {\r\n            if (master.deprecated() || !patch.deprecated()) {\r\n                return master.deprecated();\r\n            }\r\n            return patch.deprecated();\r\n        }\r\n        @Override\r\n        public String type() {\r\n            if (StringUtils.isNotBlank(master.type()) || StringUtils.isBlank(patch.type())) {\r\n                return master.type();\r\n            }\r\n            return patch.type();\r\n        }\r\n        @Override\r\n        public String[] allowableValues() {\r\n            if (master.requiredProperties().length > 0 || patch.requiredProperties().length == 0) {\r\n                return master.requiredProperties();\r\n            }\r\n            return patch.requiredProperties();\r\n        }\r\n        @Override\r\n        public String defaultValue() {\r\n            if (StringUtils.isNotBlank(master.defaultValue()) || StringUtils.isBlank(patch.defaultValue())) {\r\n                return master.defaultValue();\r\n            }\r\n            return patch.defaultValue();\r\n        }\r\n        @Override\r\n        public String discriminatorProperty() {\r\n            if (StringUtils.isNotBlank(master.defaultValue()) || StringUtils.isBlank(patch.defaultValue())) {\r\n                return master.defaultValue();\r\n            }\r\n            return patch.defaultValue();\r\n        }\r\n        @Override\r\n        public DiscriminatorMapping[] discriminatorMapping() {\r\n            if (master.discriminatorMapping().length > 0 || patch.discriminatorMapping().length == 0) {\r\n                return master.discriminatorMapping();\r\n            }\r\n            return patch.discriminatorMapping();\r\n        }\r\n        @Override\r\n        public boolean hidden() {\r\n            if (master.hidden() || !patch.hidden()) {\r\n                return master.hidden();\r\n            }\r\n            return patch.hidden();\r\n        }\r\n        @Override\r\n        public Class<?>[] subTypes() {\r\n            if (master.subTypes().length > 0 || patch.subTypes().length == 0) {\r\n                return master.subTypes();\r\n            }\r\n            return patch.subTypes();\r\n        }\r\n        @Override\r\n        public Extension[] extensions() {\r\n            if (master.extensions().length > 0 || patch.extensions().length == 0) {\r\n                return master.extensions();\r\n            }\r\n            return patch.extensions();\r\n        }\r\n        @Override\r\n        public Class<? extends Annotation> annotationType() {\r\n            return io.swagger.v3.oas.annotations.media.Schema.class;\r\n        }\r\n    };\r\n    return (io.swagger.v3.oas.annotations.media.Schema) schema;\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (!master.implementation().equals(Void.class) || patch.implementation().equals(Void.class)) {\r\n        return master.implementation();\r\n    }\r\n    return patch.implementation();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (!master.not().equals(Void.class) || patch.not().equals(Void.class)) {\r\n        return master.not();\r\n    }\r\n    return patch.not();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.oneOf().length > 0 || patch.oneOf().length == 0) {\r\n        return master.oneOf();\r\n    }\r\n    return patch.oneOf();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.anyOf().length > 0 || patch.anyOf().length == 0) {\r\n        return master.anyOf();\r\n    }\r\n    return patch.anyOf();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.allOf().length > 0 || patch.allOf().length == 0) {\r\n        return master.allOf();\r\n    }\r\n    return patch.allOf();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (StringUtils.isNotBlank(master.name()) || StringUtils.isBlank(patch.name())) {\r\n        return master.name();\r\n    }\r\n    return patch.name();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (StringUtils.isNotBlank(master.title()) || StringUtils.isBlank(patch.title())) {\r\n        return master.title();\r\n    }\r\n    return patch.title();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.multipleOf() != 0 || patch.multipleOf() == 0) {\r\n        return master.multipleOf();\r\n    }\r\n    return patch.multipleOf();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (StringUtils.isNotBlank(master.maximum()) || StringUtils.isBlank(patch.maximum())) {\r\n        return master.maximum();\r\n    }\r\n    return patch.maximum();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.exclusiveMaximum() || !patch.exclusiveMaximum()) {\r\n        return master.exclusiveMaximum();\r\n    }\r\n    return patch.exclusiveMaximum();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (StringUtils.isNotBlank(master.minimum()) || StringUtils.isBlank(patch.minimum())) {\r\n        return master.minimum();\r\n    }\r\n    return patch.minimum();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.exclusiveMinimum() || !patch.exclusiveMinimum()) {\r\n        return master.exclusiveMinimum();\r\n    }\r\n    return patch.exclusiveMinimum();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if ((master.maxLength() != Integer.MAX_VALUE && master.maxLength() > 0) || (patch.maxLength() == Integer.MAX_VALUE || patch.maxLength() == 0)) {\r\n        return master.maxLength();\r\n    }\r\n    return patch.maxLength();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.minLength() != 0 || patch.minLength() == 0) {\r\n        return master.minLength();\r\n    }\r\n    return patch.minLength();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (StringUtils.isNotBlank(master.pattern()) || StringUtils.isBlank(patch.pattern())) {\r\n        return master.pattern();\r\n    }\r\n    return patch.pattern();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.maxProperties() != 0 || patch.maxProperties() == 0) {\r\n        return master.maxProperties();\r\n    }\r\n    return patch.maxProperties();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.minProperties() != 0 || patch.minProperties() == 0) {\r\n        return master.minProperties();\r\n    }\r\n    return patch.minProperties();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.requiredProperties().length > 0 || patch.requiredProperties().length == 0) {\r\n        return master.requiredProperties();\r\n    }\r\n    return patch.requiredProperties();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.required() || !patch.required()) {\r\n        return master.required();\r\n    }\r\n    return patch.required();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (StringUtils.isNotBlank(master.description()) || StringUtils.isBlank(patch.description())) {\r\n        return master.description();\r\n    }\r\n    return patch.description();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (StringUtils.isNotBlank(master.format()) || StringUtils.isBlank(patch.format())) {\r\n        return master.format();\r\n    }\r\n    return patch.format();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (StringUtils.isNotBlank(master.ref()) || StringUtils.isBlank(patch.ref())) {\r\n        return master.ref();\r\n    }\r\n    return patch.ref();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.nullable() || !patch.nullable()) {\r\n        return master.nullable();\r\n    }\r\n    return patch.nullable();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.readOnly() || !patch.readOnly()) {\r\n        return master.readOnly();\r\n    }\r\n    return patch.readOnly();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.writeOnly() || !patch.writeOnly()) {\r\n        return master.writeOnly();\r\n    }\r\n    return patch.writeOnly();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (!master.accessMode().equals(AccessMode.AUTO) || patch.accessMode().equals(AccessMode.AUTO)) {\r\n        return master.accessMode();\r\n    }\r\n    return patch.accessMode();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (StringUtils.isNotBlank(master.example()) || StringUtils.isBlank(patch.example())) {\r\n        return master.example();\r\n    }\r\n    return patch.example();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (getExternalDocumentation(master.externalDocs()).isPresent() || !getExternalDocumentation(patch.externalDocs()).isPresent()) {\r\n        return master.externalDocs();\r\n    }\r\n    return patch.externalDocs();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.deprecated() || !patch.deprecated()) {\r\n        return master.deprecated();\r\n    }\r\n    return patch.deprecated();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (StringUtils.isNotBlank(master.type()) || StringUtils.isBlank(patch.type())) {\r\n        return master.type();\r\n    }\r\n    return patch.type();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.requiredProperties().length > 0 || patch.requiredProperties().length == 0) {\r\n        return master.requiredProperties();\r\n    }\r\n    return patch.requiredProperties();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (StringUtils.isNotBlank(master.defaultValue()) || StringUtils.isBlank(patch.defaultValue())) {\r\n        return master.defaultValue();\r\n    }\r\n    return patch.defaultValue();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (StringUtils.isNotBlank(master.defaultValue()) || StringUtils.isBlank(patch.defaultValue())) {\r\n        return master.defaultValue();\r\n    }\r\n    return patch.defaultValue();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.discriminatorMapping().length > 0 || patch.discriminatorMapping().length == 0) {\r\n        return master.discriminatorMapping();\r\n    }\r\n    return patch.discriminatorMapping();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.hidden() || !patch.hidden()) {\r\n        return master.hidden();\r\n    }\r\n    return patch.hidden();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.subTypes().length > 0 || patch.subTypes().length == 0) {\r\n        return master.subTypes();\r\n    }\r\n    return patch.subTypes();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    if (master.extensions().length > 0 || patch.extensions().length == 0) {\r\n        return master.extensions();\r\n    }\r\n    return patch.extensions();\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.AnnotationsUtils.mergeSchemaAnnotations",
	"Comment": "returns null if no annotations, otherwise either arrayschema or schema",
	"Method": "Annotation mergeSchemaAnnotations(Annotation[] ctxAnnotations,JavaType type,io.swagger.v3.oas.annotations.media.Schema mergeSchemaAnnotations,io.swagger.v3.oas.annotations.media.Schema master,io.swagger.v3.oas.annotations.media.Schema patch){\r\n    return io.swagger.v3.oas.annotations.media.Schema.class;\r\n}"
}, {
	"Path": "com.yalantis.ucrop.view.CropImageView.setImageToWrapCropBoundsAnimDuration",
	"Comment": "this method sets animation duration for image to wrap the crop bounds",
	"Method": "void setImageToWrapCropBoundsAnimDuration(long imageToWrapCropBoundsAnimDuration){\r\n    if (imageToWrapCropBoundsAnimDuration > 0) {\r\n        mImageToWrapCropBoundsAnimDuration = imageToWrapCropBoundsAnimDuration;\r\n    } else {\r\n        throw new IllegalArgumentException(\"Animation duration cannot be negative value.\");\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.net.PemKeyCertOptions.setCertValue",
	"Comment": "set the first certificate as a buffer, replacing the previous certificates buffers",
	"Method": "PemKeyCertOptions setCertValue(Buffer certValue){\r\n    certValues.clear();\r\n    if (certValue != null) {\r\n        certValues.add(certValue);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.demo.modules.CircularImageView.setSelectorStrokeColor",
	"Comment": "sets the stroke color to be drawn around the circularimageview\tduring click events when the selector is enabled.",
	"Method": "void setSelectorStrokeColor(int selectorStrokeColor){\r\n    if (paintSelectorBorder != null)\r\n        paintSelectorBorder.setColor(selectorStrokeColor);\r\n    this.invalidate();\r\n}"
}, {
	"Path": "io.vertx.core.cli.impl.DefaultCommandLine.create",
	"Comment": "creates the value for the given option from the given raw value.",
	"Method": "T create(String value,TypedArgument<T> argument,T create,String value,TypedOption<T> option){\r\n    Objects.requireNonNull(option);\r\n    if (value == null) {\r\n        value = option.getDefaultValue();\r\n    }\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    try {\r\n        if (option.getConverter() != null) {\r\n            return Converters.create(value, option.getConverter());\r\n        } else {\r\n            return Converters.create(option.getType(), value);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new InvalidValueException(option, value, e);\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.DeploymentOptions.setWorkerPoolSize",
	"Comment": "set the maximum number of worker threads to be used by the vert.x instance.",
	"Method": "DeploymentOptions setWorkerPoolSize(int workerPoolSize){\r\n    if (workerPoolSize < 1) {\r\n        throw new IllegalArgumentException(\"workerPoolSize must be > 0\");\r\n    }\r\n    this.workerPoolSize = workerPoolSize;\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.http.HttpServerOptions.getWebsocketPreferredClientNoContext",
	"Comment": "get the current setting of the websocket compression preferred client no context setting",
	"Method": "boolean getWebsocketPreferredClientNoContext(){\r\n    return this.websocketCompressionPreferredClientNoContext;\r\n}"
}, {
	"Path": "io.vertx.core.buffer.Buffer.buffer",
	"Comment": "create a new buffer from a string and using the specified encoding.the string will be encoded into the buffer using the specified encoding.",
	"Method": "Buffer buffer(Buffer buffer,int initialSizeHint,Buffer buffer,String string,Buffer buffer,String string,String enc,Buffer buffer,byte[] bytes,Buffer buffer,ByteBuf byteBuf){\r\n    return factory.buffer(byteBuf);\r\n}"
}, {
	"Path": "io.vertx.core.spi.metrics.PoolMetrics.submitted",
	"Comment": "a new task has been submitted to access the resource.this method is called from the submitter context.",
	"Method": "T submitted(){\r\n    return null;\r\n}"
}, {
	"Path": "com.google.zxing.datamatrix.decoder.BitMatrixParser.readModule",
	"Comment": "reads a bit of the mapping matrix accounting for boundary wrapping.",
	"Method": "boolean readModule(int row,int column,int numRows,int numColumns){\r\n    if (row < 0) {\r\n        row += numRows;\r\n        column += 4 - ((numRows + 4) & 0x07);\r\n    }\r\n    if (column < 0) {\r\n        column += numColumns;\r\n        row += 4 - ((numColumns + 4) & 0x07);\r\n    }\r\n    readMappingMatrix.set(column, row);\r\n    return mappingBitMatrix.get(column, row);\r\n}"
}, {
	"Path": "io.vertx.core.VertxOptions.getEventLoopPoolSize",
	"Comment": "get the number of event loop threads to be used by the vert.x instance.",
	"Method": "int getEventLoopPoolSize(){\r\n    return eventLoopPoolSize;\r\n}"
}, {
	"Path": "org.b3log.symphony.model.Character.getCharacter",
	"Comment": "gets a character by the specified character content in the specified characters.",
	"Method": "JSONObject getCharacter(String content,Set<JSONObject> characters){\r\n    for (final JSONObject character : characters) {\r\n        if (character.optString(CHARACTER_CONTENT).equals(content)) {\r\n            return character;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.b3log.symphony.util.Headers.getHeader",
	"Comment": "gets a value of a header specified by the given header name from the specified request.",
	"Method": "String getHeader(HttpServletRequest request,String name,String defaultVal){\r\n    String value = request.getHeader(name);\r\n    if (StringUtils.isBlank(value)) {\r\n        return defaultVal;\r\n    }\r\n    return Jsoup.clean(value, Whitelist.none());\r\n}"
}, {
	"Path": "com.google.crypto.tink.Registry.wrap",
	"Comment": "looks up the globally registered primitivewrapper for this primitive and wraps the givenprimitiveset with it.",
	"Method": "P wrap(PrimitiveSet<P> primitiveSet){\r\n    @SuppressWarnings(\"unchecked\")\r\n    PrimitiveWrapper<P> wrapper = (PrimitiveWrapper<P>) primitiveWrapperMap.get(primitiveSet.getPrimitiveClass());\r\n    if (wrapper == null) {\r\n        throw new GeneralSecurityException(\"No wrapper found for \" + primitiveSet.getPrimitiveClass().getName());\r\n    }\r\n    return wrapper.wrap(primitiveSet);\r\n}"
}, {
	"Path": "org.b3log.symphony.service.BreezemoonQueryService.getBreezemoons",
	"Comment": "get breezemoons with the specified user id, current page number.",
	"Method": "JSONObject getBreezemoons(int avatarViewMode,String currentUserId,String authorId,int page,int pageSize,int windowSize,JSONObject getBreezemoons,int avatarViewMode,JSONObject requestJSONObject,Map<String, Class<?>> fields){\r\n    final JSONObject ret = new JSONObject();\r\n    final int currentPageNum = requestJSONObject.optInt(Pagination.PAGINATION_CURRENT_PAGE_NUM);\r\n    final int pageSize = requestJSONObject.optInt(Pagination.PAGINATION_PAGE_SIZE);\r\n    final int windowSize = requestJSONObject.optInt(Pagination.PAGINATION_WINDOW_SIZE);\r\n    final Query query = new Query().setCurrentPageNum(currentPageNum).setPageSize(pageSize).addSort(Keys.OBJECT_ID, SortDirection.DESCENDING);\r\n    for (final Map.Entry<String, Class<?>> field : fields.entrySet()) {\r\n        query.addProjection(field.getKey(), field.getValue());\r\n    }\r\n    JSONObject result;\r\n    try {\r\n        result = breezemoonRepository.get(query);\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Get breezemoons failed\", e);\r\n        return null;\r\n    }\r\n    final int pageCount = result.optJSONObject(Pagination.PAGINATION).optInt(Pagination.PAGINATION_PAGE_COUNT);\r\n    final JSONObject pagination = new JSONObject();\r\n    ret.put(Pagination.PAGINATION, pagination);\r\n    final List<Integer> pageNums = Paginator.paginate(currentPageNum, pageSize, pageCount, windowSize);\r\n    pagination.put(Pagination.PAGINATION_PAGE_COUNT, pageCount);\r\n    pagination.put(Pagination.PAGINATION_PAGE_NUMS, pageNums);\r\n    final JSONArray data = result.optJSONArray(Keys.RESULTS);\r\n    final List<JSONObject> breezemoons = CollectionUtils.jsonArrayToList(data);\r\n    try {\r\n        organizeBreezemoons(avatarViewMode, \"admin\", breezemoons);\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Organize breezemoons failed\", e);\r\n        return null;\r\n    }\r\n    ret.put(Breezemoon.BREEZEMOONS, breezemoons);\r\n    return ret;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.uiUtils.RecyclerViewPositionHelper.findLastCompletelyVisibleItemPosition",
	"Comment": "returns the adapter position of the last fully visible view. this position does not includeadapter changes that were dispatched after the last layout pass.",
	"Method": "int findLastCompletelyVisibleItemPosition(){\r\n    final View child = findOneVisibleChild(layoutManager.getChildCount() - 1, -1, true, false);\r\n    return child == null ? RecyclerView.NO_POSITION : recyclerView.getChildAdapterPosition(child);\r\n}"
}, {
	"Path": "io.vertx.core.cli.UsageMessageFormatter.renderOptionsAndArguments",
	"Comment": "renders the specified options and arguments and return the rendered outputin a stringbuilder.",
	"Method": "StringBuilder renderOptionsAndArguments(StringBuilder sb,List<Option> options,List<Argument> arguments){\r\n    final String lpad = createPadding(leftPad);\r\n    final String dpad = createPadding(descPad);\r\n    int max = 0;\r\n    List<StringBuilder> prefixList = new ArrayList();\r\n    if (getOptionComparator() != null) {\r\n        Collections.sort(options, getOptionComparator());\r\n    }\r\n    for (Option option : options) {\r\n        StringBuilder buf = new StringBuilder();\r\n        if (option.isHidden()) {\r\n            continue;\r\n        }\r\n        if (isNullOrEmpty(option.getShortName())) {\r\n            buf.append(lpad).append(\"   \").append(getLongOptionPrefix()).append(option.getLongName());\r\n        } else {\r\n            buf.append(lpad).append(getOptionPrefix()).append(option.getShortName());\r\n            if (!isNullOrEmpty(option.getLongName())) {\r\n                buf.append(',').append(getLongOptionPrefix()).append(option.getLongName());\r\n            }\r\n        }\r\n        if (!option.getChoices().isEmpty()) {\r\n            buf.append(!isNullOrEmpty(option.getLongName()) ? longOptSeparator : \" \");\r\n            buf.append(option.getChoices().stream().collect(Collectors.joining(\", \", \"{\", \"}\")));\r\n        } else if (option.acceptValue()) {\r\n            String argName = option.getArgName();\r\n            if (argName != null && argName.length() == 0) {\r\n                buf.append(' ');\r\n            } else {\r\n                buf.append(!isNullOrEmpty(option.getLongName()) ? longOptSeparator : \" \");\r\n                buf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\r\n            }\r\n        }\r\n        prefixList.add(buf);\r\n        max = buf.length() > max ? buf.length() : max;\r\n    }\r\n    for (Argument argument : arguments) {\r\n        StringBuilder buf = new StringBuilder();\r\n        if (argument.isHidden()) {\r\n            continue;\r\n        }\r\n        buf.append(lpad).append(\"<\").append(argument.getArgName()).append(\">\");\r\n        prefixList.add(buf);\r\n        max = buf.length() > max ? buf.length() : max;\r\n    }\r\n    int x = 0;\r\n    for (Iterator<Option> it = options.iterator(); it.hasNext(); ) {\r\n        Option option = it.next();\r\n        if (option.isHidden()) {\r\n            continue;\r\n        }\r\n        StringBuilder optBuf = new StringBuilder(prefixList.get(x++).toString());\r\n        if (optBuf.length() < max) {\r\n            optBuf.append(createPadding(max - optBuf.length()));\r\n        }\r\n        optBuf.append(dpad);\r\n        int nextLineTabStop = max + descPad;\r\n        if (option.getDescription() != null) {\r\n            optBuf.append(option.getDescription());\r\n        }\r\n        renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\r\n        if (it.hasNext()) {\r\n            sb.append(getNewLine());\r\n        }\r\n    }\r\n    if (!options.isEmpty() && !arguments.isEmpty()) {\r\n        sb.append(getNewLine());\r\n    }\r\n    for (Iterator<Argument> it = arguments.iterator(); it.hasNext(); ) {\r\n        Argument argument = it.next();\r\n        if (argument.isHidden()) {\r\n            continue;\r\n        }\r\n        StringBuilder argBuf = new StringBuilder(prefixList.get(x++).toString());\r\n        if (argBuf.length() < max) {\r\n            argBuf.append(createPadding(max - argBuf.length()));\r\n        }\r\n        argBuf.append(dpad);\r\n        int nextLineTabStop = max + descPad;\r\n        if (argument.getDescription() != null) {\r\n            argBuf.append(argument.getDescription());\r\n        }\r\n        renderWrappedText(sb, width, nextLineTabStop, argBuf.toString());\r\n        if (it.hasNext()) {\r\n            sb.append(getNewLine());\r\n        }\r\n    }\r\n    return sb;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.FollowQueryService.isFollowing",
	"Comment": "determines whether exists a follow relationship for the specified follower and the specified following entity.",
	"Method": "boolean isFollowing(String followerId,String followingId,int followingType){\r\n    Stopwatchs.start(\"Is following\");\r\n    try {\r\n        return followRepository.exists(followerId, followingId, followingType);\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Determines following failed [followerId=\" + followerId + \", followingId=\" + followingId + ']', e);\r\n        return false;\r\n    } finally {\r\n        Stopwatchs.end();\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.pdf417.decoder.DetectionResultRowIndicatorColumn.adjustIncompleteIndicatorColumnRowNumbers",
	"Comment": "use row height count to make detection of invalid row numbers more reliable",
	"Method": "void adjustIncompleteIndicatorColumnRowNumbers(BarcodeMetadata barcodeMetadata){\r\n    BoundingBox boundingBox = getBoundingBox();\r\n    ResultPoint top = isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();\r\n    ResultPoint bottom = isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();\r\n    int firstRow = imageRowToCodewordIndex((int) top.getY());\r\n    int lastRow = imageRowToCodewordIndex((int) bottom.getY());\r\n    Codeword[] codewords = getCodewords();\r\n    int barcodeRow = -1;\r\n    int maxRowHeight = 1;\r\n    int currentRowHeight = 0;\r\n    for (int codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {\r\n        if (codewords[codewordsRow] == null) {\r\n            continue;\r\n        }\r\n        Codeword codeword = codewords[codewordsRow];\r\n        codeword.setRowNumberAsRowIndicatorColumn();\r\n        int rowDifference = codeword.getRowNumber() - barcodeRow;\r\n        if (rowDifference == 0) {\r\n            currentRowHeight++;\r\n        } else if (rowDifference == 1) {\r\n            maxRowHeight = Math.max(maxRowHeight, currentRowHeight);\r\n            currentRowHeight = 1;\r\n            barcodeRow = codeword.getRowNumber();\r\n        } else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {\r\n            codewords[codewordsRow] = null;\r\n        } else {\r\n            barcodeRow = codeword.getRowNumber();\r\n            currentRowHeight = 1;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.integration.awskms.AwsKmsClient.withCredentials",
	"Comment": "loads aws credentials from a properties file.the aws access key id is expected to be in the accesskey property and the awssecret key is expected to be in the secretkey property.",
	"Method": "KmsClient withCredentials(String credentialPath){\r\n    try {\r\n        if (credentialPath == null) {\r\n            return withDefaultCredentials();\r\n        }\r\n        return withCredentialsProvider(new PropertiesFileCredentialsProvider(credentialPath));\r\n    } catch (AmazonServiceException e) {\r\n        throw new GeneralSecurityException(\"cannot load credentials\", e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.maven.AbstractRunMojo.logDisabledFork",
	"Comment": "log a warning indicating that fork mode has been explicitly disabled while some\tconditions are present that require to enable it.",
	"Method": "void logDisabledFork(){\r\n    if (getLog().isWarnEnabled()) {\r\n        if (hasAgent()) {\r\n            getLog().warn(\"Fork mode disabled, ignoring agent\");\r\n        }\r\n        if (hasJvmArgs()) {\r\n            RunArguments runArguments = resolveJvmArguments();\r\n            getLog().warn(\"Fork mode disabled, ignoring JVM argument(s) [\" + Arrays.stream(runArguments.asArray()).collect(Collectors.joining(\" \")) + \"]\");\r\n        }\r\n        if (hasWorkingDirectorySet()) {\r\n            getLog().warn(\"Fork mode disabled, ignoring working directory configuration\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.http.HttpClientOptions.setWebsocketCompressionAllowClientNoContext",
	"Comment": "set the websocket compression allow client no context option.",
	"Method": "HttpClientOptions setWebsocketCompressionAllowClientNoContext(boolean allowClientNoContext){\r\n    this.websocketAllowClientNoContext = allowClientNoContext;\r\n    return this;\r\n}"
}, {
	"Path": "com.yalantis.ucrop.view.TransformImageView.setImageUri",
	"Comment": "this method takes an uri as a parameter, then calls method to decode it into bitmap with specified size.",
	"Method": "void setImageUri(Uri imageUri,Uri outputUri){\r\n    int maxBitmapSize = getMaxBitmapSize();\r\n    BitmapLoadUtils.decodeBitmapInBackground(getContext(), imageUri, outputUri, maxBitmapSize, maxBitmapSize, new BitmapLoadCallback() {\r\n        @Override\r\n        public void onBitmapLoaded(@NonNull Bitmap bitmap, @NonNull ExifInfo exifInfo, @NonNull String imageInputPath, @Nullable String imageOutputPath) {\r\n            mImageInputPath = imageInputPath;\r\n            mImageOutputPath = imageOutputPath;\r\n            mExifInfo = exifInfo;\r\n            mBitmapDecoded = true;\r\n            setImageBitmap(bitmap);\r\n        }\r\n        @Override\r\n        public void onFailure(@NonNull Exception bitmapWorkerException) {\r\n            Log.e(TAG, \"onFailure: setImageUri\", bitmapWorkerException);\r\n            if (mTransformImageListener != null) {\r\n                mTransformImageListener.onLoadFailure(bitmapWorkerException);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.yalantis.ucrop.view.TransformImageView.setImageUri",
	"Comment": "this method takes an uri as a parameter, then calls method to decode it into bitmap with specified size.",
	"Method": "void setImageUri(Uri imageUri,Uri outputUri){\r\n    mImageInputPath = imageInputPath;\r\n    mImageOutputPath = imageOutputPath;\r\n    mExifInfo = exifInfo;\r\n    mBitmapDecoded = true;\r\n    setImageBitmap(bitmap);\r\n}"
}, {
	"Path": "com.yalantis.ucrop.view.TransformImageView.setImageUri",
	"Comment": "this method takes an uri as a parameter, then calls method to decode it into bitmap with specified size.",
	"Method": "void setImageUri(Uri imageUri,Uri outputUri){\r\n    Log.e(TAG, \"onFailure: setImageUri\", bitmapWorkerException);\r\n    if (mTransformImageListener != null) {\r\n        mTransformImageListener.onLoadFailure(bitmapWorkerException);\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.shareddata.Shareable.copy",
	"Comment": "returns a copy of the object.only mutable objects should provide a custom implementation of the method.",
	"Method": "Shareable copy(){\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.file.OpenOptions.isTruncateExisting",
	"Comment": "if the file exists and is opened for writing should the file be truncated to zero length on open?",
	"Method": "boolean isTruncateExisting(){\r\n    return truncateExisting;\r\n}"
}, {
	"Path": "io.vertx.core.VertxOptions.setEventLoopPoolSize",
	"Comment": "set the number of event loop threads to be used by the vert.x instance.",
	"Method": "VertxOptions setEventLoopPoolSize(int eventLoopPoolSize){\r\n    if (eventLoopPoolSize < 1) {\r\n        throw new IllegalArgumentException(\"eventLoopPoolSize must be > 0\");\r\n    }\r\n    this.eventLoopPoolSize = eventLoopPoolSize;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.zxing.oned.rss.expanded.ExpandedRow.equals",
	"Comment": "two rows are equal if they contain the same pairs in the same order.",
	"Method": "boolean equals(Object o){\r\n    if (!(o instanceof ExpandedRow)) {\r\n        return false;\r\n    }\r\n    ExpandedRow that = (ExpandedRow) o;\r\n    return this.pairs.equals(that.getPairs()) && wasReversed == that.wasReversed;\r\n}"
}, {
	"Path": "org.springframework.boot.loader.tools.Repackager.setBackupSource",
	"Comment": "sets if source files should be backed up when they would be overwritten.",
	"Method": "void setBackupSource(boolean backupSource){\r\n    this.backupSource = backupSource;\r\n}"
}, {
	"Path": "com.yalantis.ucrop.view.CropImageView.processStyledAttributes",
	"Comment": "this method extracts all needed values from the styled attributes.those are used to configure the view.",
	"Method": "void processStyledAttributes(TypedArray a){\r\n    float targetAspectRatioX = Math.abs(a.getFloat(R.styleable.ucrop_UCropView_ucrop_aspect_ratio_x, DEFAULT_ASPECT_RATIO));\r\n    float targetAspectRatioY = Math.abs(a.getFloat(R.styleable.ucrop_UCropView_ucrop_aspect_ratio_y, DEFAULT_ASPECT_RATIO));\r\n    if (targetAspectRatioX == SOURCE_IMAGE_ASPECT_RATIO || targetAspectRatioY == SOURCE_IMAGE_ASPECT_RATIO) {\r\n        mTargetAspectRatio = SOURCE_IMAGE_ASPECT_RATIO;\r\n    } else {\r\n        mTargetAspectRatio = targetAspectRatioX / targetAspectRatioY;\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.dns.AddressResolverOptions.setOptResourceEnabled",
	"Comment": "set to true to enable the automatic inclusion in dns queries of an optional record that hintsthe remote dns server about how much data the resolver can read per response.",
	"Method": "AddressResolverOptions setOptResourceEnabled(boolean optResourceEnabled){\r\n    this.optResourceEnabled = optResourceEnabled;\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.spi.metrics.VertxMetrics.createEventBusMetrics",
	"Comment": "provides the event bus metrics spi when the event bus is created.no specific thread and context can be expected when this method is called.this method should be called only once.",
	"Method": "EventBusMetrics createEventBusMetrics(){\r\n    return null;\r\n}"
}, {
	"Path": "io.vertx.core.net.NetTest.testServerNetSocketShouldBeClosedWhenTheClosedHandlerIsCalled",
	"Comment": "we only do it for server, as client uses the same netsocket implementation",
	"Method": "void testServerNetSocketShouldBeClosedWhenTheClosedHandlerIsCalled(){\r\n    waitFor(2);\r\n    server.connectHandler(so -> {\r\n        CheckingSender sender = new CheckingSender(vertx.getOrCreateContext(), 2, so);\r\n        sender.send();\r\n        so.closeHandler(v -> {\r\n            Throwable failure = sender.close();\r\n            if (failure != null) {\r\n                fail(failure);\r\n            } else {\r\n                complete();\r\n            }\r\n        });\r\n        so.endHandler(v -> {\r\n            Throwable failure = sender.close();\r\n            if (failure != null) {\r\n                fail(failure);\r\n            } else {\r\n                complete();\r\n            }\r\n        });\r\n    });\r\n    startServer();\r\n    client.connect(testAddress, onSuccess(so -> {\r\n        vertx.setTimer(1000, id -> {\r\n            so.close();\r\n        });\r\n    }));\r\n    await();\r\n}"
}, {
	"Path": "io.vertx.core.eventbus.DeliveryOptions.getSendTimeout",
	"Comment": "get the send timeout.when sending a message with a response handler a send timeout can be provided. if no response is receivedwithin the timeout the handler will be called with a failure.",
	"Method": "long getSendTimeout(){\r\n    return timeout;\r\n}"
}, {
	"Path": "io.vertx.core.net.impl.VertxHandler.addHandler",
	"Comment": "set an handler to be called when the connection is set on this handler.",
	"Method": "VertxHandler<C> addHandler(Handler<C> handler){\r\n    this.addHandler = handler;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.swipelistview.SwipeListViewTouchListener.setSwipeClosesAllItemsWhenListMoves",
	"Comment": "set if all item opened will be close when the user move listview",
	"Method": "void setSwipeClosesAllItemsWhenListMoves(boolean swipeClosesAllItemsWhenListMoves){\r\n    this.swipeClosesAllItemsWhenListMoves = swipeClosesAllItemsWhenListMoves;\r\n}"
}, {
	"Path": "org.b3log.symphony.util.JSONs.clone",
	"Comment": "clones a json object list from the specified source object list.",
	"Method": "JSONObject clone(JSONObject src,List<JSONObject> clone,List<JSONObject> src){\r\n    return src.stream().map(JSONs::clone).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.b3log.symphony.service.DomainQueryService.containTag",
	"Comment": "whether a tag specified by the given tag title in a domain specified by the given domain id.",
	"Method": "boolean containTag(String tagTitle,String domainId){\r\n    try {\r\n        final JSONObject domain = domainRepository.get(domainId);\r\n        if (null == domain) {\r\n            return true;\r\n        }\r\n        final JSONObject tag = tagRepository.getByTitle(tagTitle);\r\n        if (null == tag) {\r\n            return true;\r\n        }\r\n        final Query query = new Query().setFilter(CompositeFilterOperator.and(new PropertyFilter(Domain.DOMAIN + \"_\" + Keys.OBJECT_ID, FilterOperator.EQUAL, domainId), new PropertyFilter(Tag.TAG + \"_\" + Keys.OBJECT_ID, FilterOperator.EQUAL, tag.optString(Keys.OBJECT_ID))));\r\n        return domainTagRepository.count(query) > 0;\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Check domain tag [tagTitle=\" + tagTitle + \", domainId=\" + domainId + \"] failed\", e);\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest.testEncryptDecrypt",
	"Comment": "encrypts and decrypts some plaintext in a stream and checks that the expected plaintext isreturned.",
	"Method": "void testEncryptDecrypt(int keySizeInBytes,int segmentSize,int firstSegmentOffset,int plaintextSize,int chunkSize){\r\n    if (TestUtil.shouldSkipTestWithAesKeySize(keySizeInBytes)) {\r\n        return;\r\n    }\r\n    byte[] ikm = TestUtil.hexDecode(\"000102030405060708090a0b0c0d0e0f00112233445566778899aabbccddeeff\");\r\n    AesGcmHkdfStreaming ags = new AesGcmHkdfStreaming(ikm, \"HmacSha256\", keySizeInBytes, segmentSize, firstSegmentOffset);\r\n    StreamingTestUtil.testEncryptDecrypt(ags, firstSegmentOffset, plaintextSize, chunkSize);\r\n}"
}, {
	"Path": "com.google.zxing.qrcode.encoder.MaskUtil.applyMaskPenaltyRule1Internal",
	"Comment": "helper function for applymaskpenaltyrule1. we need this for doing this calculation in bothvertical and horizontal orders respectively.",
	"Method": "int applyMaskPenaltyRule1Internal(ByteMatrix matrix,boolean isHorizontal){\r\n    int penalty = 0;\r\n    int iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();\r\n    int jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();\r\n    byte[][] array = matrix.getArray();\r\n    for (int i = 0; i < iLimit; i++) {\r\n        int numSameBitCells = 0;\r\n        int prevBit = -1;\r\n        for (int j = 0; j < jLimit; j++) {\r\n            int bit = isHorizontal ? array[i][j] : array[j][i];\r\n            if (bit == prevBit) {\r\n                numSameBitCells++;\r\n            } else {\r\n                if (numSameBitCells >= 5) {\r\n                    penalty += N1 + (numSameBitCells - 5);\r\n                }\r\n                numSameBitCells = 1;\r\n                prevBit = bit;\r\n            }\r\n        }\r\n        if (numSameBitCells >= 5) {\r\n            penalty += N1 + (numSameBitCells - 5);\r\n        }\r\n    }\r\n    return penalty;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.RoleQueryService.getUserPermissionsGrantMap",
	"Comment": "gets all permissions and marks grant of a user specified by the given user id.",
	"Method": "Map<String, JSONObject> getUserPermissionsGrantMap(String userId){\r\n    final List<JSONObject> permissions = getUserPermissionsGrant(userId);\r\n    if (permissions.isEmpty()) {\r\n        return Collections.emptyMap();\r\n    }\r\n    final Map<String, JSONObject> ret = new HashMap();\r\n    for (final JSONObject permission : permissions) {\r\n        ret.put(permission.optString(Keys.OBJECT_ID), permission);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "us.codecraft.webmagic.Site.setUseGzip",
	"Comment": "whether use gzip. default is true, you can set it to false to disable gzip.",
	"Method": "Site setUseGzip(boolean useGzip){\r\n    this.useGzip = useGzip;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.zxing.client.android.camera.CameraManager.buildLuminanceSource",
	"Comment": "a factory method to build the appropriate luminancesource object based on the formatof the preview buffers, as described by camera.parameters.",
	"Method": "PlanarYUVLuminanceSource buildLuminanceSource(byte[] data,int width,int height){\r\n    Rect rect = getFramingRectInPreview();\r\n    if (rect == null) {\r\n        return null;\r\n    }\r\n    return new PlanarYUVLuminanceSource(data, width, height, rect.left, rect.top, rect.width(), rect.height(), false);\r\n}"
}, {
	"Path": "io.vertx.core.http.impl.pool.Pool.acquireConnection",
	"Comment": "attempt to acquire a connection for the waiter, either borrowed from the pool or by creating a new connection.this method does not modify the waitersqueue list.",
	"Method": "boolean acquireConnection(Waiter<C> waiter){\r\n    if (available.size() > 0) {\r\n        Holder<C> conn = available.peek();\r\n        long capacity = conn.capacity--;\r\n        if (capacity == 1) {\r\n            conn.expirationTimestamp = -1L;\r\n            available.poll();\r\n        }\r\n        ContextInternal ctx = conn.context;\r\n        waitersCount--;\r\n        if (capacity == conn.concurrency) {\r\n            connector.activate(conn.connection);\r\n        }\r\n        ctx.nettyEventLoop().execute(() -> {\r\n            waiter.handler.handle(Future.succeededFuture(conn.connection));\r\n        });\r\n        return true;\r\n    } else if (weight < maxWeight) {\r\n        weight += initialWeight;\r\n        waiter.context.nettyEventLoop().execute(() -> {\r\n            createConnection(waiter);\r\n        });\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel.toString",
	"Comment": "a description of the state of this streamingaeadseekabledecryptingchannel.while this description does not contain plaintext or key materialit contains length information that might be confidential.",
	"Method": "String toString(){\r\n    StringBuilder res = new StringBuilder();\r\n    String ctChannel;\r\n    try {\r\n        ctChannel = \"position:\" + ciphertextChannel.position();\r\n    } catch (IOException ex) {\r\n        ctChannel = \"position: n/a\";\r\n    }\r\n    res.append(\"StreamingAeadSeekableDecryptingChannel\").append(\"\\nciphertextChannel\").append(ctChannel).append(\"\\nciphertextChannelSize:\").append(ciphertextChannelSize).append(\"\\nplaintextSize:\").append(plaintextSize).append(\"\\nciphertextSegmentSize:\").append(ciphertextSegmentSize).append(\"\\nnumberOfSegments:\").append(numberOfSegments).append(\"\\nheaderRead:\").append(headerRead).append(\"\\nplaintextPosition:\").append(plaintextPosition).append(\"\\nHeader\").append(\" position:\").append(header.position()).append(\" limit:\").append(header.position()).append(\"\\ncurrentSegmentNr:\").append(currentSegmentNr).append(\"\\nciphertextSgement\").append(\" position:\").append(ciphertextSegment.position()).append(\" limit:\").append(ciphertextSegment.limit()).append(\"\\nisCurrentSegmentDecrypted:\").append(isCurrentSegmentDecrypted).append(\"\\nplaintextSegment\").append(\" position:\").append(plaintextSegment.position()).append(\" limit:\").append(plaintextSegment.limit());\r\n    return res.toString();\r\n}"
}, {
	"Path": "com.google.zxing.client.android.CaptureActivity.handleDecode",
	"Comment": "a valid barcode has been found, so give an indication of success and show the results.",
	"Method": "void handleDecode(Result rawResult,Bitmap barcode,float scaleFactor){\r\n    inactivityTimer.onActivity();\r\n    lastResult = rawResult;\r\n    ResultHandler resultHandler = ResultHandlerFactory.makeResultHandler(this, rawResult);\r\n    boolean fromLiveScan = barcode != null;\r\n    if (fromLiveScan) {\r\n        historyManager.addHistoryItem(rawResult, resultHandler);\r\n        beepManager.playBeepSoundAndVibrate();\r\n        drawResultPoints(barcode, scaleFactor, rawResult);\r\n    }\r\n    switch(source) {\r\n        case NATIVE_APP_INTENT:\r\n        case PRODUCT_SEARCH_LINK:\r\n            handleDecodeExternally(rawResult, resultHandler, barcode);\r\n            break;\r\n        case ZXING_LINK:\r\n            if (scanFromWebPageManager == null || !scanFromWebPageManager.isScanFromWebPage()) {\r\n                handleDecodeInternally(rawResult, resultHandler, barcode);\r\n            } else {\r\n                handleDecodeExternally(rawResult, resultHandler, barcode);\r\n            }\r\n            break;\r\n        case NONE:\r\n            SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\r\n            if (fromLiveScan && prefs.getBoolean(PreferencesActivity.KEY_BULK_MODE, false)) {\r\n                Toast.makeText(getApplicationContext(), getResources().getString(R.string.msg_bulk_mode_scanned) + \" (\" + rawResult.getText() + ')', Toast.LENGTH_SHORT).show();\r\n                maybeSetClipboard(resultHandler);\r\n                restartPreviewAfterDelay(BULK_MODE_SCAN_DELAY_MS);\r\n            } else {\r\n                handleDecodeInternally(rawResult, resultHandler, barcode);\r\n            }\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.service.CharacterQueryService.getWrittenCharacterCount",
	"Comment": "gets written character count of a user specified by the given user id.",
	"Method": "int getWrittenCharacterCount(int getWrittenCharacterCount,String userId){\r\n    final Query query = new Query().setFilter(new PropertyFilter(org.b3log.symphony.model.Character.CHARACTER_USER_ID, FilterOperator.EQUAL, userId));\r\n    try {\r\n        return (int) characterRepository.count(query);\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Counts user written characters failed\", e);\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.DeploymentOptions.setExtraClasspath",
	"Comment": "set any extra classpath to be used when deploying the verticle.ignored if no isolation group is set.",
	"Method": "DeploymentOptions setExtraClasspath(List<String> extraClasspath){\r\n    this.extraClasspath = extraClasspath;\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.VertxOptions.setFileResolverCachingEnabled",
	"Comment": "set whether the vert.x file resolver uses caching for classpath resources.deprecated. use filesystemoptions instead.",
	"Method": "VertxOptions setFileResolverCachingEnabled(boolean fileResolverCachingEnabled){\r\n    if (fileSystemOptions == null) {\r\n        fileSystemOptions = new FileSystemOptions();\r\n    }\r\n    this.fileSystemOptions.setFileCachingEnabled(fileResolverCachingEnabled);\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.stickyheadersrecyclerview.HeaderPositionCalculator.hasNewHeader",
	"Comment": "determines if an item in the list should have a header that is different than the item in thelist that immediately precedes it. items with no headers will always return false.",
	"Method": "boolean hasNewHeader(int position){\r\n    if (indexOutOfBounds(position)) {\r\n        return false;\r\n    }\r\n    long headerId = mAdapter.getHeaderId(position);\r\n    if (headerId < 0) {\r\n        return false;\r\n    }\r\n    return position == 0 || headerId != mAdapter.getHeaderId(position - 1);\r\n}"
}, {
	"Path": "io.vertx.core.DeploymentOptions.getExtraClasspath",
	"Comment": "get any extra classpath to be used when deploying the verticle.ignored if no isolation group is set.",
	"Method": "List<String> getExtraClasspath(){\r\n    return extraClasspath;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.DataModelService.fillMinified",
	"Comment": "fills minified directory and file postfix for static javascript, css.",
	"Method": "void fillMinified(Map<String, Object> dataModel){\r\n    switch(Latkes.getRuntimeMode()) {\r\n        case DEVELOPMENT:\r\n            dataModel.put(Common.MINI_POSTFIX, \"\");\r\n            break;\r\n        case PRODUCTION:\r\n            dataModel.put(Common.MINI_POSTFIX, Common.MINI_POSTFIX_VALUE);\r\n            break;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.processor.channel.Channels.getHttpSessionAttribute",
	"Comment": "gets an attribute of the specified http session by the given session.",
	"Method": "Object getHttpSessionAttribute(Session session,String attributeName){\r\n    final HttpSession httpSession = (HttpSession) session.getUserProperties().get(HttpSession.class.getName());\r\n    if (null == httpSession) {\r\n        return null;\r\n    }\r\n    try {\r\n        return httpSession.getAttribute(attributeName);\r\n    } catch (final Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.yalantis.ucrop.view.CropImageView.setMaxScaleMultiplier",
	"Comment": "this method sets multiplier that is used to calculate max image scale from min image scale.",
	"Method": "void setMaxScaleMultiplier(float maxScaleMultiplier){\r\n    mMaxScaleMultiplier = maxScaleMultiplier;\r\n}"
}, {
	"Path": "com.google.zxing.aztec.decoder.Decoder.readByte",
	"Comment": "reads a code of length 8 in an array of bits, padding with zeros",
	"Method": "byte readByte(boolean[] rawbits,int startIndex){\r\n    int n = rawbits.length - startIndex;\r\n    if (n >= 8) {\r\n        return (byte) readCode(rawbits, startIndex, 8);\r\n    }\r\n    return (byte) (readCode(rawbits, startIndex, n) << (8 - n));\r\n}"
}, {
	"Path": "com.google.zxing.integration.android.IntentIntegrator.startActivityForResult",
	"Comment": "start an activity. this method is defined to allow different methods of activity starting fornewer versions of android and for compatibility library.",
	"Method": "void startActivityForResult(Intent intent,int code){\r\n    if (fragment == null) {\r\n        activity.startActivityForResult(intent, code);\r\n    } else {\r\n        fragment.startActivityForResult(intent, code);\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.impl.launcher.commands.ExecUtils.exitBecauseOfProcessIssue",
	"Comment": "exits the jvm and indicate an issue with a process creation or termination.",
	"Method": "void exitBecauseOfProcessIssue(){\r\n    exit(PROCESS_ERROR_EXIT_CODE);\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.ReflectionUtils.isOverriddenMethod",
	"Comment": "checks if the method methodtofind is the overridden method from the superclass or superinterface.",
	"Method": "boolean isOverriddenMethod(Method methodToFind,Class<?> cls){\r\n    Set<Class<?>> superClasses = new HashSet();\r\n    for (Class c : cls.getInterfaces()) {\r\n        superClasses.add(c);\r\n    }\r\n    if (cls.getSuperclass() != null) {\r\n        superClasses.add(cls.getSuperclass());\r\n    }\r\n    for (Class<?> superClass : superClasses) {\r\n        if (superClass != null && !(superClass.equals(Object.class))) {\r\n            for (Method method : superClass.getMethods()) {\r\n                if (method.getName().equals(methodToFind.getName()) && method.getReturnType().isAssignableFrom(methodToFind.getReturnType()) && Arrays.equals(method.getParameterTypes(), methodToFind.getParameterTypes()) && !Arrays.equals(method.getGenericParameterTypes(), methodToFind.getGenericParameterTypes())) {\r\n                    return true;\r\n                }\r\n            }\r\n            if (isOverriddenMethod(methodToFind, superClass)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.google.zxing.pdf417.encoder.PDF417HighLevelEncoder.determineConsecutiveDigitCount",
	"Comment": "determines the number of consecutive characters that are encodable using numeric compaction.",
	"Method": "int determineConsecutiveDigitCount(CharSequence msg,int startpos){\r\n    int count = 0;\r\n    int len = msg.length();\r\n    int idx = startpos;\r\n    if (idx < len) {\r\n        char ch = msg.charAt(idx);\r\n        while (isDigit(ch) && idx < len) {\r\n            count++;\r\n            idx++;\r\n            if (idx < len) {\r\n                ch = msg.charAt(idx);\r\n            }\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.vip.vjtools.vjkit.collection.type.SortedArrayList.getComparator",
	"Comment": "returns comparator assigned to this collection, if such exist.",
	"Method": "Comparator getComparator(){\r\n    return comparator;\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.AesCtrHmacStreamingTest.testEncryptDecryptRandomAccess",
	"Comment": "encrypt and then decrypt partially, and check that the result is the same.",
	"Method": "void testEncryptDecryptRandomAccess(int keySizeInBytes,int tagSizeInBytes,int segmentSize,int firstSegmentOffset,int plaintextSize){\r\n    if (TestUtil.shouldSkipTestWithAesKeySize(keySizeInBytes)) {\r\n        return;\r\n    }\r\n    byte[] ikm = TestUtil.hexDecode(\"000102030405060708090a0b0c0d0e0f00112233445566778899aabbccddeeff\");\r\n    AesCtrHmacStreaming ags = new AesCtrHmacStreaming(ikm, \"HmacSha256\", keySizeInBytes, \"HmacSha256\", tagSizeInBytes, segmentSize, firstSegmentOffset);\r\n    StreamingTestUtil.testEncryptDecryptRandomAccess(ags, firstSegmentOffset, plaintextSize);\r\n}"
}, {
	"Path": "io.vertx.core.net.impl.NetServerImpl.closeAll",
	"Comment": "internal method that closes all servers when vert.x is closing",
	"Method": "void closeAll(Handler<AsyncResult<Void>> handler){\r\n    List<Handlers> list = handlerManager.handlers();\r\n    List<Future> futures = list.stream().<Future<Void>>map(handlers -> Future.future(handlers.server::close)).collect(Collectors.toList());\r\n    CompositeFuture fut = CompositeFuture.all(futures);\r\n    fut.setHandler(ar -> handler.handle(ar.mapEmpty()));\r\n}"
}, {
	"Path": "io.vertx.core.file.OpenOptions.isCreateNew",
	"Comment": "should the file be created if and the open fail if it already exists?",
	"Method": "boolean isCreateNew(){\r\n    return createNew;\r\n}"
}, {
	"Path": "io.vertx.core.cli.impl.DefaultCommandLine.isValid",
	"Comment": "checks whether or not the command line is valid, i.e. all constraints from arguments and options have beensatisfied. this method is used when the parser validation is disabled.",
	"Method": "boolean isValid(){\r\n    return valid;\r\n}"
}, {
	"Path": "com.yalantis.ucrop.util.RectUtils.trapToRect",
	"Comment": "takes an array of 2d coordinates representing corners and returns thesmallest rectangle containing those coordinates.",
	"Method": "RectF trapToRect(float[] array){\r\n    RectF r = new RectF(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY);\r\n    for (int i = 1; i < array.length; i += 2) {\r\n        float x = Math.round(array[i - 1] * 10) / 10.f;\r\n        float y = Math.round(array[i] * 10) / 10.f;\r\n        r.left = (x < r.left) ? x : r.left;\r\n        r.top = (y < r.top) ? y : r.top;\r\n        r.right = (x > r.right) ? x : r.right;\r\n        r.bottom = (y > r.bottom) ? y : r.bottom;\r\n    }\r\n    r.sort();\r\n    return r;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.ArticleMgmtService.tagExists",
	"Comment": "determines whether the specified tag title exists in the specified tags.",
	"Method": "boolean tagExists(String tagTitle,List<JSONObject> tags){\r\n    for (final JSONObject tag : tags) {\r\n        if (tag.getString(Tag.TAG_TITLE).equals(tagTitle)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.vertx.core.Future.recover",
	"Comment": "handles a failure of this future by returning the result of another future.if the mapper fails, then the returned future will be failed with this failure.",
	"Method": "Future<T> recover(Function<Throwable, Future<T>> mapper){\r\n    if (mapper == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    Future<T> ret = Future.future();\r\n    setHandler(ar -> {\r\n        if (ar.succeeded()) {\r\n            ret.complete(result());\r\n        } else {\r\n            Future<T> mapped;\r\n            try {\r\n                mapped = mapper.apply(ar.cause());\r\n            } catch (Throwable e) {\r\n                ret.fail(e);\r\n                return;\r\n            }\r\n            mapped.setHandler(ret);\r\n        }\r\n    });\r\n    return ret;\r\n}"
}, {
	"Path": "org.b3log.symphony.processor.channel.GobangChannel.onConnect",
	"Comment": "called when the socket connection with the browser is established.",
	"Method": "void onConnect(Session session){\r\n    final JSONObject user = (JSONObject) Channels.getHttpSessionAttribute(session, User.USER);\r\n    if (null == user) {\r\n        return;\r\n    }\r\n    final String userId = user.optString(Keys.OBJECT_ID);\r\n    final String userName = user.optString(User.USER_NAME);\r\n    boolean playing = false;\r\n    LOGGER.debug(\"new connection from \" + userName);\r\n    if (SESSIONS.containsKey(userId)) {\r\n        JSONObject sendText = new JSONObject();\r\n        sendText.put(\"type\", 6);\r\n        sendText.put(\"message\", \"??\");\r\n        session.getAsyncRemote().sendText(sendText.toString());\r\n        return;\r\n    } else {\r\n        SESSIONS.put(userId, session);\r\n    }\r\n    for (String temp : chessPlaying.keySet()) {\r\n        ChessGame chessGame = chessPlaying.get(temp);\r\n        if (userId.equals(chessGame.getPlayer1())) {\r\n            recoverGame(userId, userName, chessGame.getPlayer2(), chessGame);\r\n            chessGame.setPlayState1(true);\r\n            playing = true;\r\n        } else if (userId.equals(chessGame.getPlayer2())) {\r\n            recoverGame(userId, userName, chessGame.getPlayer1(), chessGame);\r\n            chessGame.setPlayState2(true);\r\n            playing = true;\r\n        }\r\n    }\r\n    if (playing) {\r\n        return;\r\n    } else {\r\n        ChessGame chessGame = null;\r\n        JSONObject sendText = new JSONObject();\r\n        do {\r\n            chessGame = chessRandomWait.poll();\r\n        } while (chessRandomWait.size() > 0 && SESSIONS.get(chessGame.getPlayer1()) == null);\r\n        if (chessGame == null) {\r\n            chessGame = new ChessGame(userId, userName);\r\n            chessRandomWait.add(chessGame);\r\n            sendText.put(\"type\", 3);\r\n            sendText.put(\"playerName\", userName);\r\n            sendText.put(\"message\", \"???\");\r\n            session.getAsyncRemote().sendText(sendText.toString());\r\n        } else if (userId.equals(chessGame.getPlayer1())) {\r\n            chessRandomWait.add(chessGame);\r\n            sendText.put(\"type\", 3);\r\n            sendText.put(\"playerName\", userName);\r\n            sendText.put(\"message\", \"???\");\r\n            session.getAsyncRemote().sendText(sendText.toString());\r\n        } else {\r\n            final BeanManager beanManager = BeanManager.getInstance();\r\n            chessGame.setPlayer2(userId);\r\n            chessGame.setName2(userName);\r\n            chessGame.setPlayState2(true);\r\n            chessGame.setStep(1);\r\n            chessPlaying.put(chessGame.getPlayer1(), chessGame);\r\n            antiPlayer.put(chessGame.getPlayer1(), chessGame.getPlayer2());\r\n            final ActivityMgmtService activityMgmtService = beanManager.getReference(ActivityMgmtService.class);\r\n            sendText.put(\"type\", 4);\r\n            sendText.put(\"message\", \"? [\" + userName + \"] ??\");\r\n            sendText.put(\"player\", chessGame.getPlayer1());\r\n            SESSIONS.get(chessGame.getPlayer1()).getAsyncRemote().sendText(sendText.toString());\r\n            sendText.put(\"message\", \"?~? [\" + chessGame.getName1() + \"] \");\r\n            sendText.put(\"player\", chessGame.getPlayer2());\r\n            session.getAsyncRemote().sendText(sendText.toString());\r\n            JSONObject r1 = activityMgmtService.startGobang(chessGame.getPlayer1());\r\n            JSONObject r2 = activityMgmtService.startGobang(chessGame.getPlayer2());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.cli.impl.DefaultParser.stripLeadingHyphens",
	"Comment": "remove the hyphens from the beginning of str andreturn the new string.",
	"Method": "String stripLeadingHyphens(String str){\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    if (str.startsWith(\"--\")) {\r\n        return str.substring(2, str.length());\r\n    } else if (str.startsWith(\"-\")) {\r\n        return str.substring(1, str.length());\r\n    }\r\n    return str;\r\n}"
}, {
	"Path": "io.vertx.core.file.OpenOptions.isSparse",
	"Comment": "set whether a hint should be provided that the file to created is sparse",
	"Method": "boolean isSparse(){\r\n    return sparse;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.swipe.SwipeLayout.computeSurfaceLayoutArea",
	"Comment": "a helper function to compute the rect area that surface will hold in.",
	"Method": "Rect computeSurfaceLayoutArea(boolean open){\r\n    int l = getPaddingLeft(), t = getPaddingTop();\r\n    if (open) {\r\n        if (mCurrentDragEdge == DragEdge.Left)\r\n            l = getPaddingLeft() + mDragDistance;\r\n        else if (mCurrentDragEdge == DragEdge.Right)\r\n            l = getPaddingLeft() - mDragDistance;\r\n        else if (mCurrentDragEdge == DragEdge.Top)\r\n            t = getPaddingTop() + mDragDistance;\r\n        else\r\n            t = getPaddingTop() - mDragDistance;\r\n    }\r\n    return new Rect(l, t, l + getMeasuredWidth(), t + getMeasuredHeight());\r\n}"
}, {
	"Path": "io.swagger.v3.oas.models.media.Schema.getName",
	"Comment": "returns the name property from a from a schema instance. ignored in serialization.",
	"Method": "String getName(){\r\n    return this.name;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.CommentQueryService.getArticleComments",
	"Comment": "gets the article comments with the specified article id, page number and page size.",
	"Method": "List<JSONObject> getArticleComments(int avatarViewMode,String articleId,int currentPageNum,int pageSize,int sortMode){\r\n    Stopwatchs.start(\"Get comments\");\r\n    final Query query = new Query().setPageCount(1).setCurrentPageNum(currentPageNum).setPageSize(pageSize).setFilter(new PropertyFilter(Comment.COMMENT_ON_ARTICLE_ID, FilterOperator.EQUAL, articleId));\r\n    if (UserExt.USER_COMMENT_VIEW_MODE_C_REALTIME == sortMode) {\r\n        query.addSort(Keys.OBJECT_ID, SortDirection.DESCENDING);\r\n    } else {\r\n        query.addSort(Keys.OBJECT_ID, SortDirection.ASCENDING);\r\n    }\r\n    try {\r\n        Stopwatchs.start(\"Query comments\");\r\n        JSONObject result;\r\n        try {\r\n            result = commentRepository.get(query);\r\n        } finally {\r\n            Stopwatchs.end();\r\n        }\r\n        final List<JSONObject> ret = CollectionUtils.jsonArrayToList(result.optJSONArray(Keys.RESULTS));\r\n        organizeComments(avatarViewMode, ret);\r\n        Stopwatchs.start(\"Revision, paging, original\");\r\n        try {\r\n            for (final JSONObject comment : ret) {\r\n                final String commentId = comment.optString(Keys.OBJECT_ID);\r\n                comment.put(Comment.COMMENT_REVISION_COUNT, 0);\r\n                if (Comment.COMMENT_STATUS_C_VALID == comment.optInt(Comment.COMMENT_STATUS)) {\r\n                    comment.put(Comment.COMMENT_REVISION_COUNT, revisionQueryService.count(commentId, Revision.DATA_TYPE_C_COMMENT));\r\n                }\r\n                final String originalCmtId = comment.optString(Comment.COMMENT_ORIGINAL_COMMENT_ID);\r\n                if (StringUtils.isBlank(originalCmtId)) {\r\n                    continue;\r\n                }\r\n                comment.put(Pagination.PAGINATION_CURRENT_PAGE_NUM, getCommentPage(articleId, originalCmtId, sortMode, pageSize));\r\n                final JSONObject originalCmt = commentRepository.get(originalCmtId);\r\n                if (null != originalCmt) {\r\n                    organizeComment(avatarViewMode, originalCmt);\r\n                    comment.put(Comment.COMMENT_T_ORIGINAL_AUTHOR_THUMBNAIL_URL, originalCmt.optString(Comment.COMMENT_T_AUTHOR_THUMBNAIL_URL));\r\n                } else {\r\n                    comment.put(Comment.COMMENT_ORIGINAL_COMMENT_ID, \"\");\r\n                }\r\n            }\r\n        } finally {\r\n            Stopwatchs.end();\r\n        }\r\n        return ret;\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Gets article [\" + articleId + \"] comments failed\", e);\r\n        return Collections.emptyList();\r\n    } finally {\r\n        Stopwatchs.end();\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.cli.annotations.CLIConfigurator.define",
	"Comment": "creates an instance of the given class, and extracts the metadata from the given class.",
	"Method": "CLI define(Class<?> clazz){\r\n    CLI cli = new DefaultCLI();\r\n    final Summary summary = clazz.getAnnotation(Summary.class);\r\n    final Description desc = clazz.getAnnotation(Description.class);\r\n    final Hidden hidden = clazz.getAnnotation(Hidden.class);\r\n    final Name name = clazz.getAnnotation(Name.class);\r\n    if (name == null) {\r\n        throw new IllegalArgumentException(\"The command cannot be defined, the @Name annotation is missing.\");\r\n    }\r\n    if (name.value() == null || name.value().isEmpty()) {\r\n        throw new IllegalArgumentException(\"The command cannot be defined, the @Name value is empty or null.\");\r\n    }\r\n    cli.setName(name.value());\r\n    if (summary != null) {\r\n        cli.setSummary(summary.value());\r\n    }\r\n    if (desc != null) {\r\n        cli.setDescription(desc.value());\r\n    }\r\n    if (hidden != null) {\r\n        cli.setHidden(true);\r\n    }\r\n    final List<Method> methods = ReflectionUtils.getSetterMethods(clazz);\r\n    for (Method method : methods) {\r\n        final Option option = method.getAnnotation(Option.class);\r\n        final Argument argument = method.getAnnotation(Argument.class);\r\n        if (option != null) {\r\n            cli.addOption(createOption(method));\r\n        }\r\n        if (argument != null) {\r\n            cli.addArgument(createArgument(method));\r\n        }\r\n    }\r\n    return cli;\r\n}"
}, {
	"Path": "io.vertx.test.core.VertxTestBase.createWorker",
	"Comment": "create a worker verticle for the current vert.x and return its context.",
	"Method": "Context createWorker(){\r\n    CompletableFuture<Context> fut = new CompletableFuture();\r\n    vertx.deployVerticle(new AbstractVerticle() {\r\n        @Override\r\n        public void start() throws Exception {\r\n            fut.complete(context);\r\n        }\r\n    }, new DeploymentOptions().setWorker(true), ar -> {\r\n        if (ar.failed()) {\r\n            fut.completeExceptionally(ar.cause());\r\n        }\r\n    });\r\n    return fut.get();\r\n}"
}, {
	"Path": "io.vertx.test.core.VertxTestBase.createWorker",
	"Comment": "create a worker verticle for the current vert.x and return its context.",
	"Method": "Context createWorker(){\r\n    fut.complete(context);\r\n}"
}, {
	"Path": "com.vip.vjtools.vjkit.collection.type.SortedArrayList.compare",
	"Comment": "compares two keys using the correct comparison method for this\tcollection.",
	"Method": "int compare(E k1,E k2){\r\n    if (comparator == null) {\r\n        return ((Comparable) k1).compareTo(k2);\r\n    }\r\n    return comparator.compare(k1, k2);\r\n}"
}, {
	"Path": "com.google.zxing.pdf417.encoder.PDF417HighLevelEncoder.determineConsecutiveBinaryCount",
	"Comment": "determines the number of consecutive characters that are encodable using binary compaction.",
	"Method": "int determineConsecutiveBinaryCount(String msg,int startpos,Charset encoding){\r\n    CharsetEncoder encoder = encoding.newEncoder();\r\n    int len = msg.length();\r\n    int idx = startpos;\r\n    while (idx < len) {\r\n        char ch = msg.charAt(idx);\r\n        int numericCount = 0;\r\n        while (numericCount < 13 && isDigit(ch)) {\r\n            numericCount++;\r\n            int i = idx + numericCount;\r\n            if (i >= len) {\r\n                break;\r\n            }\r\n            ch = msg.charAt(i);\r\n        }\r\n        if (numericCount >= 13) {\r\n            return idx - startpos;\r\n        }\r\n        ch = msg.charAt(idx);\r\n        if (!encoder.canEncode(ch)) {\r\n            throw new WriterException(\"Non-encodable character detected: \" + ch + \" (Unicode: \" + (int) ch + ')');\r\n        }\r\n        idx++;\r\n    }\r\n    return idx - startpos;\r\n}"
}, {
	"Path": "io.vertx.core.net.NetworkOptions.setReusePort",
	"Comment": "set the value of reuse port.this is only supported by native transports.",
	"Method": "NetworkOptions setReusePort(boolean reusePort){\r\n    this.reusePort = reusePort;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.uiUtils.ScrollUtils.getColorWithAlpha",
	"Comment": "create a color integer value with specified alpha.this may be useful to change alpha value of background color.",
	"Method": "int getColorWithAlpha(float alpha,int baseColor){\r\n    int a = Math.min(255, Math.max(0, (int) (alpha * 255))) << 24;\r\n    int rgb = 0x00ffffff & baseColor;\r\n    return a + rgb;\r\n}"
}, {
	"Path": "com.vip.vjtools.vjkit.collection.type.primitive.LongObjectHashMap.growSize",
	"Comment": "grows the map size after an insertion. if necessary, performs a rehash of the map.",
	"Method": "void growSize(){\r\n    size++;\r\n    if (size > maxSize) {\r\n        if (keys.length == Integer.MAX_VALUE) {\r\n            throw new IllegalStateException(\"Max capacity reached at size=\" + size);\r\n        }\r\n        rehash(keys.length << 1);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.stickyheadersrecyclerview.HeaderPositionCalculator.getFirstViewUnobscuredByHeader",
	"Comment": "returns the first item currently in the recyclerview that is not obscured by a header.",
	"Method": "View getFirstViewUnobscuredByHeader(RecyclerView parent,View firstHeader){\r\n    for (int i = 0; i < parent.getChildCount(); i++) {\r\n        View child = parent.getChildAt(i);\r\n        if (!itemIsObscuredByHeader(parent, child, firstHeader, mOrientationProvider.getOrientation(parent))) {\r\n            return child;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.FollowQueryService.getFollowingCount",
	"Comment": "gets the following count of a follower specified by the given follower id and following type.",
	"Method": "long getFollowingCount(String followerId,int followingType){\r\n    Stopwatchs.start(\"Gets following count [\" + followingType + \"]\");\r\n    try {\r\n        final List<Filter> filters = new ArrayList();\r\n        filters.add(new PropertyFilter(Follow.FOLLOWER_ID, FilterOperator.EQUAL, followerId));\r\n        filters.add(new PropertyFilter(Follow.FOLLOWING_TYPE, FilterOperator.EQUAL, followingType));\r\n        final Query query = new Query().setFilter(new CompositeFilter(CompositeFilterOperator.AND, filters));\r\n        try {\r\n            return followRepository.count(query);\r\n        } catch (final RepositoryException e) {\r\n            LOGGER.log(Level.ERROR, \"Counts following count error\", e);\r\n            return 0;\r\n        }\r\n    } finally {\r\n        Stopwatchs.end();\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.service.TagQueryService.getRelatedTags",
	"Comment": "gets the related tags of the specified tag of the given tag id.",
	"Method": "List<JSONObject> getRelatedTags(String tagId,int fetchSize){\r\n    final List<JSONObject> ret = new ArrayList();\r\n    final Set<String> tagIds = new HashSet();\r\n    try {\r\n        JSONObject result = tagTagRepository.getByTag1Id(tagId, 1, fetchSize);\r\n        JSONArray relations = result.optJSONArray(Keys.RESULTS);\r\n        boolean full = false;\r\n        for (int i = 0; i < relations.length(); i++) {\r\n            tagIds.add(relations.optJSONObject(i).optString(Tag.TAG + \"2_\" + Keys.OBJECT_ID));\r\n            if (tagIds.size() >= fetchSize) {\r\n                full = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!full) {\r\n            result = tagTagRepository.getByTag2Id(tagId, 1, fetchSize);\r\n            relations = result.optJSONArray(Keys.RESULTS);\r\n            for (int i = 0; i < relations.length(); i++) {\r\n                tagIds.add(relations.optJSONObject(i).optString(Tag.TAG + \"1_\" + Keys.OBJECT_ID));\r\n                if (tagIds.size() >= fetchSize) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        for (final String tId : tagIds) {\r\n            final JSONObject tag = tagRepository.get(tId);\r\n            if (null != tag) {\r\n                Tag.fillDescription(tag);\r\n                ret.add(tag);\r\n            }\r\n        }\r\n        return ret;\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Gets related tags failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "com.vip.vjtools.vjkit.collection.type.SortedArrayList.findInsertionPoint",
	"Comment": "conducts a binary search to find the index where object\tshould be inserted.",
	"Method": "int findInsertionPoint(E o,int findInsertionPoint,E o,int originalLow,int originalHigh){\r\n    int low = originalLow;\r\n    int high = originalHigh;\r\n    while (low <= high) {\r\n        int mid = low + ((high - low) >>> 1);\r\n        int delta = compare(get(mid), o);\r\n        if (delta > 0) {\r\n            high = mid - 1;\r\n        } else {\r\n            low = mid + 1;\r\n        }\r\n    }\r\n    return low;\r\n}"
}, {
	"Path": "com.google.zxing.client.android.result.WifiResultHandler.getDisplayContents",
	"Comment": "display the name of the network and the network type to the user.",
	"Method": "CharSequence getDisplayContents(){\r\n    WifiParsedResult wifiResult = (WifiParsedResult) getResult();\r\n    return wifiResult.getSsid() + \" (\" + wifiResult.getNetworkEncryption() + ')';\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.AesCtrHmacStreamingTest.testEncryptDecrypt",
	"Comment": "encrypts and decrypts some plaintext in a stream and checks that the expected plaintext isreturned.",
	"Method": "void testEncryptDecrypt(int keySizeInBytes,int tagSizeInBytes,int segmentSize,int firstSegmentOffset,int plaintextSize,int chunkSize){\r\n    if (TestUtil.shouldSkipTestWithAesKeySize(keySizeInBytes)) {\r\n        return;\r\n    }\r\n    byte[] ikm = TestUtil.hexDecode(\"000102030405060708090a0b0c0d0e0f00112233445566778899aabbccddeeff\");\r\n    AesCtrHmacStreaming ags = new AesCtrHmacStreaming(ikm, \"HmacSha256\", keySizeInBytes, \"HmacSha256\", tagSizeInBytes, segmentSize, firstSegmentOffset);\r\n    StreamingTestUtil.testEncryptDecrypt(ags, firstSegmentOffset, plaintextSize, chunkSize);\r\n}"
}, {
	"Path": "io.vertx.core.spi.metrics.EventBusMetrics.handlerRegistered",
	"Comment": "called when a handler is registered on the event bus.no specific thread and context can be expected when this method is called.",
	"Method": "H handlerRegistered(String address,String repliedAddress){\r\n    return null;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.InvitecodeMgmtService.adminGenInvitecodes",
	"Comment": "admin generates invitecodes with the specified quantity and memo.",
	"Method": "void adminGenInvitecodes(int quantity,String memo){\r\n    final Transaction transaction = invitecodeRepository.beginTransaction();\r\n    try {\r\n        for (int i = 0; i < quantity; i++) {\r\n            final JSONObject invitecode = new JSONObject();\r\n            invitecode.put(Invitecode.CODE, RandomStringUtils.randomAlphanumeric(16));\r\n            invitecode.put(Invitecode.MEMO, memo);\r\n            invitecode.put(Invitecode.STATUS, Invitecode.STATUS_C_UNUSED);\r\n            invitecode.put(Invitecode.GENERATOR_ID, Pointtransfer.ID_C_SYS);\r\n            invitecode.put(Invitecode.USER_ID, \"\");\r\n            invitecode.put(Invitecode.USE_TIME, 0);\r\n            invitecodeRepository.add(invitecode);\r\n        }\r\n        transaction.commit();\r\n    } catch (final RepositoryException e) {\r\n        if (transaction.isActive()) {\r\n            transaction.rollback();\r\n        }\r\n        LOGGER.log(Level.ERROR, \"Generates invitecodes failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.service.UserQueryService.getInvitedUserCount",
	"Comment": "gets invite user count of a user specified by the given user id.",
	"Method": "int getInvitedUserCount(String userId){\r\n    final Query query = new Query().setFilter(CompositeFilterOperator.and(new PropertyFilter(Pointtransfer.TO_ID, FilterOperator.EQUAL, userId), CompositeFilterOperator.or(new PropertyFilter(Pointtransfer.TYPE, FilterOperator.EQUAL, Pointtransfer.TRANSFER_TYPE_C_INVITECODE_USED), new PropertyFilter(Pointtransfer.TYPE, FilterOperator.EQUAL, Pointtransfer.TRANSFER_TYPE_C_INVITE_REGISTER))));\r\n    try {\r\n        return (int) pointtransferRepository.count(query);\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Gets invited user count failed\", e);\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.common.BitArray.isRange",
	"Comment": "efficient method to check if a range of bits is set, or not set.",
	"Method": "boolean isRange(int start,int end,boolean value){\r\n    if (end < start || start < 0 || end > size) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (end == start) {\r\n        return true;\r\n    }\r\n    end--;\r\n    int firstInt = start / 32;\r\n    int lastInt = end / 32;\r\n    for (int i = firstInt; i <= lastInt; i++) {\r\n        int firstBit = i > firstInt ? 0 : start & 0x1F;\r\n        int lastBit = i < lastInt ? 31 : end & 0x1F;\r\n        int mask = (2 << lastBit) - (1 << firstBit);\r\n        if ((bits[i] & mask) != (value ? mask : 0)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.swagger.v3.core.util.ReflectionUtils.getOverriddenMethod",
	"Comment": "returns overridden method from superclass if it exists. if method was not found returns null.",
	"Method": "Method getOverriddenMethod(Method method){\r\n    Class<?> declaringClass = method.getDeclaringClass();\r\n    Class<?> superClass = declaringClass.getSuperclass();\r\n    Method result = null;\r\n    if (superClass != null && !(superClass.equals(Object.class))) {\r\n        result = findMethod(method, superClass);\r\n    }\r\n    if (result == null) {\r\n        for (Class<?> anInterface : declaringClass.getInterfaces()) {\r\n            result = findMethod(method, anInterface);\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.b3log.symphony.processor.channel.ChatRoomChannel.onConnect",
	"Comment": "called when the socket connection with the browser is established.",
	"Method": "void onConnect(Session session){\r\n    SESSIONS.add(session);\r\n    synchronized (SESSIONS) {\r\n        final Iterator<Session> i = SESSIONS.iterator();\r\n        while (i.hasNext()) {\r\n            final Session s = i.next();\r\n            if (s.isOpen()) {\r\n                final String msgStr = new JSONObject().put(Common.ONLINE_CHAT_CNT, SESSIONS.size()).put(Common.TYPE, \"online\").toString();\r\n                s.getAsyncRemote().sendText(msgStr);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.streamingaead.StreamingAeadUtil.toHmacAlgo",
	"Comment": "returns the hmac algorithm name corresponding to a hash type.",
	"Method": "String toHmacAlgo(HashType hash){\r\n    switch(hash) {\r\n        case SHA1:\r\n            return \"HmacSha1\";\r\n        case SHA256:\r\n            return \"HmacSha256\";\r\n        case SHA512:\r\n            return \"HmacSha512\";\r\n        default:\r\n            throw new NoSuchAlgorithmException(\"hash unsupported for HMAC: \" + hash);\r\n    }\r\n}"
}, {
	"Path": "io.swagger.v3.jaxrs2.resources.SubResourceHead.getClasses",
	"Comment": "this path is expected to be skipped as method result is an array.",
	"Method": "Class<?>[] getClasses(){\r\n    return null;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.NotificationQueryService.getUnreadNotificationCountByType",
	"Comment": "gets the count of unread notifications of a user specified with the given user id and data type.",
	"Method": "int getUnreadNotificationCountByType(String userId,int notificationDataType){\r\n    final List<Filter> filters = new ArrayList();\r\n    filters.add(new PropertyFilter(Notification.NOTIFICATION_USER_ID, FilterOperator.EQUAL, userId));\r\n    filters.add(new PropertyFilter(Notification.NOTIFICATION_HAS_READ, FilterOperator.EQUAL, false));\r\n    filters.add(new PropertyFilter(Notification.NOTIFICATION_DATA_TYPE, FilterOperator.EQUAL, notificationDataType));\r\n    final Query query = new Query();\r\n    query.setFilter(new CompositeFilter(CompositeFilterOperator.AND, filters)).addProjection(Keys.OBJECT_ID, String.class);\r\n    try {\r\n        final JSONObject result = notificationRepository.get(query);\r\n        return result.optJSONObject(Pagination.PAGINATION).optInt(Pagination.PAGINATION_RECORD_COUNT);\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Gets [\" + notificationDataType + \"] notification count failed [userId=\" + userId + \"]\", e);\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.client.android.camera.CameraManager.openDriver",
	"Comment": "opens the camera driver and initializes the hardware parameters.",
	"Method": "void openDriver(SurfaceHolder holder){\r\n    OpenCamera theCamera = camera;\r\n    if (theCamera == null) {\r\n        theCamera = OpenCameraInterface.open(requestedCameraId);\r\n        if (theCamera == null) {\r\n            throw new IOException(\"Camera.open() failed to return object from driver\");\r\n        }\r\n        camera = theCamera;\r\n    }\r\n    if (!initialized) {\r\n        initialized = true;\r\n        configManager.initFromCameraParameters(theCamera);\r\n        if (requestedFramingRectWidth > 0 && requestedFramingRectHeight > 0) {\r\n            setManualFramingRect(requestedFramingRectWidth, requestedFramingRectHeight);\r\n            requestedFramingRectWidth = 0;\r\n            requestedFramingRectHeight = 0;\r\n        }\r\n    }\r\n    Camera cameraObject = theCamera.getCamera();\r\n    Camera.Parameters parameters = cameraObject.getParameters();\r\n    String parametersFlattened = parameters == null ? null : parameters.flatten();\r\n    try {\r\n        configManager.setDesiredCameraParameters(theCamera, false);\r\n    } catch (RuntimeException re) {\r\n        Log.w(TAG, \"Camera rejected parameters. Setting only minimal safe-mode parameters\");\r\n        Log.i(TAG, \"Resetting to saved camera params: \" + parametersFlattened);\r\n        if (parametersFlattened != null) {\r\n            parameters = cameraObject.getParameters();\r\n            parameters.unflatten(parametersFlattened);\r\n            try {\r\n                cameraObject.setParameters(parameters);\r\n                configManager.setDesiredCameraParameters(theCamera, true);\r\n            } catch (RuntimeException re2) {\r\n                Log.w(TAG, \"Camera rejected even safe-mode parameters! No configuration\");\r\n            }\r\n        }\r\n    }\r\n    cameraObject.setPreviewDisplay(holder);\r\n}"
}, {
	"Path": "com.google.zxing.qrcode.decoder.BitMatrixParser.readFormatInformation",
	"Comment": "reads format information from one of its two locations within the qr code.",
	"Method": "FormatInformation readFormatInformation(){\r\n    if (parsedFormatInfo != null) {\r\n        return parsedFormatInfo;\r\n    }\r\n    int formatInfoBits1 = 0;\r\n    for (int i = 0; i < 6; i++) {\r\n        formatInfoBits1 = copyBit(i, 8, formatInfoBits1);\r\n    }\r\n    formatInfoBits1 = copyBit(7, 8, formatInfoBits1);\r\n    formatInfoBits1 = copyBit(8, 8, formatInfoBits1);\r\n    formatInfoBits1 = copyBit(8, 7, formatInfoBits1);\r\n    for (int j = 5; j >= 0; j--) {\r\n        formatInfoBits1 = copyBit(8, j, formatInfoBits1);\r\n    }\r\n    int dimension = bitMatrix.getHeight();\r\n    int formatInfoBits2 = 0;\r\n    int jMin = dimension - 7;\r\n    for (int j = dimension - 1; j >= jMin; j--) {\r\n        formatInfoBits2 = copyBit(8, j, formatInfoBits2);\r\n    }\r\n    for (int i = dimension - 8; i < dimension; i++) {\r\n        formatInfoBits2 = copyBit(i, 8, formatInfoBits2);\r\n    }\r\n    parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);\r\n    if (parsedFormatInfo != null) {\r\n        return parsedFormatInfo;\r\n    }\r\n    throw FormatException.getFormatInstance();\r\n}"
}, {
	"Path": "com.google.zxing.pdf417.encoder.PDF417ErrorCorrection.getErrorCorrectionCodewordCount",
	"Comment": "determines the number of error correction codewords for a specified error correctionlevel.",
	"Method": "int getErrorCorrectionCodewordCount(int errorCorrectionLevel){\r\n    if (errorCorrectionLevel < 0 || errorCorrectionLevel > 8) {\r\n        throw new IllegalArgumentException(\"Error correction level must be between 0 and 8!\");\r\n    }\r\n    return 1 << (errorCorrectionLevel + 1);\r\n}"
}, {
	"Path": "org.b3log.symphony.util.Gravatars.getRandomAvatarData",
	"Comment": "gets random avatar image byte array data with the specified hash.",
	"Method": "byte[] getRandomAvatarData(String hash){\r\n    try {\r\n        String h = hash;\r\n        if (StringUtils.isBlank(h)) {\r\n            h = RandomStringUtils.randomAlphanumeric(16);\r\n        }\r\n        final HttpResponse response = HttpRequest.get(\"http://www.gravatar.com/avatar/\" + h + \"?s=256&d=\" + d[RandomUtils.nextInt(d.length)]).connectionTimeout(5000).timeout(5000).send();\r\n        if (HttpServletResponse.SC_OK != response.statusCode()) {\r\n            LOGGER.log(Level.WARN, \"Gets avatar data failed [sc=\" + response.statusCode() + \"]\");\r\n            return null;\r\n        }\r\n        return response.bodyBytes();\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Gets avatar data failed\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.gridSection.SectionedRecyclerViewAdapter.isSectionFooterPosition",
	"Comment": "returns true if the argument position corresponds to a footer",
	"Method": "boolean isSectionFooterPosition(int position){\r\n    if (isFooter == null) {\r\n        setupIndices();\r\n    }\r\n    return isFooter[position];\r\n}"
}, {
	"Path": "us.codecraft.webmagic.Site.setSleepTime",
	"Comment": "set the interval between the processing of two pages.time unit is micro seconds.",
	"Method": "Site setSleepTime(int sleepTime){\r\n    this.sleepTime = sleepTime;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.crypto.tink.JsonKeysetReader.withBytes",
	"Comment": "static method to create a jsonkeysetreader from a byte array.",
	"Method": "JsonKeysetReader withBytes(byte[] bytes){\r\n    return new JsonKeysetReader(new ByteArrayInputStream(bytes));\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.Hkdf.computeEciesHkdfSymmetricKey",
	"Comment": "computes symmetric key for ecies with hkdf from the provided parameters.",
	"Method": "byte[] computeEciesHkdfSymmetricKey(byte[] ephemeralPublicKeyBytes,byte[] sharedSecret,String hmacAlgo,byte[] hkdfSalt,byte[] hkdfInfo,int keySizeInBytes){\r\n    byte[] hkdfInput = Bytes.concat(ephemeralPublicKeyBytes, sharedSecret);\r\n    return Hkdf.computeHkdf(hmacAlgo, hkdfInput, hkdfSalt, hkdfInfo, keySizeInBytes);\r\n}"
}, {
	"Path": "io.vertx.core.DeploymentOptions.fromJson",
	"Comment": "initialise the fields of this instance from the specified json",
	"Method": "void fromJson(JsonObject json){\r\n    this.config = json.getJsonObject(\"config\");\r\n    this.worker = json.getBoolean(\"worker\", DEFAULT_WORKER);\r\n    this.multiThreaded = json.getBoolean(\"multiThreaded\", DEFAULT_MULTI_THREADED);\r\n    this.isolationGroup = json.getString(\"isolationGroup\", DEFAULT_ISOLATION_GROUP);\r\n    this.ha = json.getBoolean(\"ha\", DEFAULT_HA);\r\n    JsonArray arr = json.getJsonArray(\"extraClasspath\", null);\r\n    if (arr != null) {\r\n        this.extraClasspath = arr.getList();\r\n    }\r\n    this.instances = json.getInteger(\"instances\", DEFAULT_INSTANCES);\r\n    JsonArray arrIsolated = json.getJsonArray(\"isolatedClasses\", null);\r\n    if (arrIsolated != null) {\r\n        this.isolatedClasses = arrIsolated.getList();\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.DaeadThreadSafetyTest.testEncryptionDecryption",
	"Comment": "encrypt and decrypt concurrently with one deterministicaead cipher.",
	"Method": "void testEncryptionDecryption(DeterministicAead cipher,int numberOfThreads,int maxPlaintextSize,int numberOfEncryptionsPerThread){\r\n    ExceptionHandler exceptionHandler = new ExceptionHandler();\r\n    Thread[] thread = new Thread[numberOfThreads];\r\n    for (int i = 0; i < numberOfThreads; i++) {\r\n        thread[i] = new CryptingThread(cipher, maxPlaintextSize, numberOfEncryptionsPerThread);\r\n        thread[i].setUncaughtExceptionHandler(exceptionHandler);\r\n    }\r\n    for (int i = 0; i < numberOfThreads; i++) {\r\n        thread[i].start();\r\n    }\r\n    for (int i = 0; i < numberOfThreads; i++) {\r\n        thread[i].join();\r\n    }\r\n    exceptionHandler.check();\r\n}"
}, {
	"Path": "io.vertx.core.net.OpenSSLEngineOptions.isSessionCacheEnabled",
	"Comment": "whether session cache is enabled in open ssl session server context",
	"Method": "boolean isSessionCacheEnabled(){\r\n    return sessionCacheEnabled;\r\n}"
}, {
	"Path": "org.springframework.boot.loader.tools.Repackager.setMainClass",
	"Comment": "sets the main class that should be run. if not specified the value from the\tmanifest will be used, or if no manifest entry is found the archive will be\tsearched for a suitable class.",
	"Method": "void setMainClass(String mainClass){\r\n    this.mainClass = mainClass;\r\n}"
}, {
	"Path": "io.vertx.core.http.WebSocketFrame.pongFrame",
	"Comment": "create a pong websocket frame.will be a final frame. there is no option for non final pong frames.",
	"Method": "WebSocketFrame pongFrame(Buffer data){\r\n    return factory.pongFrame(data);\r\n}"
}, {
	"Path": "com.google.zxing.datamatrix.encoder.HighLevelEncodeTestCase.visualize",
	"Comment": "convert a string of char codewords into a different string which lists each characterusing its decimal value.",
	"Method": "String visualize(CharSequence codewords){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < codewords.length(); i++) {\r\n        if (i > 0) {\r\n            sb.append(' ');\r\n        }\r\n        sb.append((int) codewords.charAt(i));\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.quickAdapter.extBaseAdapter.BaseAdapterHelper.setImageBitmap",
	"Comment": "add an action to set the image of an image view. can be called multipletimes.",
	"Method": "BaseAdapterHelper setImageBitmap(int viewId,Bitmap bitmap){\r\n    ImageView view = retrieveView(viewId);\r\n    view.setImageBitmap(bitmap);\r\n    return this;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.FollowQueryService.getFollowerCount",
	"Comment": "gets the follower count of a following specified by the given following id and following type.",
	"Method": "long getFollowerCount(String followingId,int followingType){\r\n    final List<Filter> filters = new ArrayList();\r\n    filters.add(new PropertyFilter(Follow.FOLLOWING_ID, FilterOperator.EQUAL, followingId));\r\n    filters.add(new PropertyFilter(Follow.FOLLOWING_TYPE, FilterOperator.EQUAL, followingType));\r\n    final Query query = new Query().setFilter(new CompositeFilter(CompositeFilterOperator.AND, filters));\r\n    try {\r\n        return followRepository.count(query);\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Counts follower count error\", e);\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.dns.AddressResolverOptions.setCacheMinTimeToLive",
	"Comment": "set the cache minimum ttl value in seconds. after resolution successful ip addresses are cached with their dns response ttl,use this to set a minimum value to all responses ttl.",
	"Method": "AddressResolverOptions setCacheMinTimeToLive(int cacheMinTimeToLive){\r\n    if (cacheMinTimeToLive < 0) {\r\n        throw new IllegalArgumentException(\"cacheMinTimeToLive must be >= 0\");\r\n    }\r\n    this.cacheMinTimeToLive = cacheMinTimeToLive;\r\n    return this;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.NotificationMgmtService.addNotification",
	"Comment": "adds a notification with the specified request json object.",
	"Method": "void addNotification(JSONObject requestJSONObject){\r\n    final JSONObject notification = new JSONObject();\r\n    notification.put(Notification.NOTIFICATION_HAS_READ, false);\r\n    notification.put(Notification.NOTIFICATION_USER_ID, requestJSONObject.optString(Notification.NOTIFICATION_USER_ID));\r\n    notification.put(Notification.NOTIFICATION_DATA_ID, requestJSONObject.optString(Notification.NOTIFICATION_DATA_ID));\r\n    notification.put(Notification.NOTIFICATION_DATA_TYPE, requestJSONObject.optInt(Notification.NOTIFICATION_DATA_TYPE));\r\n    notificationRepository.add(notification);\r\n    Symphonys.EXECUTOR_SERVICE.submit(() -> {\r\n        final JSONObject cmd = new JSONObject();\r\n        cmd.put(UserExt.USER_T_ID, requestJSONObject.optString(Notification.NOTIFICATION_USER_ID));\r\n        cmd.put(Common.COMMAND, \"refreshNotification\");\r\n        UserChannel.sendCmd(cmd);\r\n    });\r\n}"
}, {
	"Path": "com.yalantis.ucrop.sample.SampleActivity.basisConfig",
	"Comment": "in most cases you need only to set crop aspect ration and max size for resulting image.",
	"Method": "UCrop basisConfig(UCrop uCrop){\r\n    switch(mRadioGroupAspectRatio.getCheckedRadioButtonId()) {\r\n        case R.id.radio_origin:\r\n            uCrop = uCrop.useSourceImageAspectRatio();\r\n            break;\r\n        case R.id.radio_square:\r\n            uCrop = uCrop.withAspectRatio(1, 1);\r\n            break;\r\n        case R.id.radio_dynamic:\r\n            break;\r\n        default:\r\n            try {\r\n                float ratioX = Float.valueOf(mEditTextRatioX.getText().toString().trim());\r\n                float ratioY = Float.valueOf(mEditTextRatioY.getText().toString().trim());\r\n                if (ratioX > 0 && ratioY > 0) {\r\n                    uCrop = uCrop.withAspectRatio(ratioX, ratioY);\r\n                }\r\n            } catch (NumberFormatException e) {\r\n                Log.i(TAG, String.format(\"Number please: %s\", e.getMessage()));\r\n            }\r\n            break;\r\n    }\r\n    if (mCheckBoxMaxSize.isChecked()) {\r\n        try {\r\n            int maxWidth = Integer.valueOf(mEditTextMaxWidth.getText().toString().trim());\r\n            int maxHeight = Integer.valueOf(mEditTextMaxHeight.getText().toString().trim());\r\n            if (maxWidth > UCrop.MIN_SIZE && maxHeight > UCrop.MIN_SIZE) {\r\n                uCrop = uCrop.withMaxResultSize(maxWidth, maxHeight);\r\n            }\r\n        } catch (NumberFormatException e) {\r\n            Log.e(TAG, \"Number please\", e);\r\n        }\r\n    }\r\n    return uCrop;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateRecyclerView.setOnScrollListener",
	"Comment": "set a listener that will be notified of any changes in scroll state or position.",
	"Method": "void setOnScrollListener(RecyclerView.OnScrollListener customOnScrollListener){\r\n    mRecyclerView.setOnScrollListener(customOnScrollListener);\r\n}"
}, {
	"Path": "com.google.crypto.tink.StreamingTestUtil.testEncryptDecryptWithChannel",
	"Comment": "encrypts and decrypts some plaintext in a stream and checks that the expected plaintext isreturned.",
	"Method": "void testEncryptDecryptWithChannel(StreamingAead ags,int firstSegmentOffset,int plaintextSize,int chunkSize){\r\n    byte[] aad = TestUtil.hexDecode(\"aabbccddeeff\");\r\n    byte[] plaintext = generatePlaintext(plaintextSize);\r\n    byte[] ciphertext = encryptWithChannel(ags, plaintext, aad, firstSegmentOffset);\r\n    ReadableByteChannel ctChannel = new SeekableByteBufferChannel(ciphertext).position(firstSegmentOffset);\r\n    ReadableByteChannel ptChannel = ags.newDecryptingChannel(ctChannel, aad);\r\n    int decryptedSize = 0;\r\n    while (true) {\r\n        ByteBuffer chunk = ByteBuffer.allocate(chunkSize);\r\n        int read = ptChannel.read(chunk);\r\n        if (read == -1) {\r\n            break;\r\n        }\r\n        assertEquals(read, chunk.position());\r\n        byte[] expectedPlaintext = Arrays.copyOfRange(plaintext, decryptedSize, decryptedSize + read);\r\n        TestUtil.assertByteArrayEquals(expectedPlaintext, Arrays.copyOf(chunk.array(), read));\r\n        decryptedSize += read;\r\n        if (decryptedSize < plaintextSize) {\r\n            assertEquals(\"Decrypted chunk is shorter than expected\\n\" + ptChannel.toString(), chunk.limit(), chunk.position());\r\n        }\r\n    }\r\n    assertEquals(plaintext.length, decryptedSize);\r\n}"
}, {
	"Path": "io.vertx.core.http.impl.VertxHttp2ConnectionHandler.removeHandler",
	"Comment": "set an handler to be called when the connection is unset from this handler.",
	"Method": "VertxHttp2ConnectionHandler<C> removeHandler(Handler<C> handler){\r\n    this.removeHandler = handler;\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.http.HttpClientOptions.getDefaultPort",
	"Comment": "get the default port to be used by this client in requests if none is provided when making the request.",
	"Method": "int getDefaultPort(){\r\n    return defaultPort;\r\n}"
}, {
	"Path": "io.vertx.core.dns.AddressResolverOptions.setQueryTimeout",
	"Comment": "set the query timeout in milliseconds, i.e the amount of time after a query is considered to be failed.",
	"Method": "AddressResolverOptions setQueryTimeout(long queryTimeout){\r\n    if (queryTimeout < 1) {\r\n        throw new IllegalArgumentException(\"queryTimeout must be > 0\");\r\n    }\r\n    this.queryTimeout = queryTimeout;\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.net.NetTest.testWithSocks4aProxyAuth",
	"Comment": "test socks4a proxy for accessing arbitrary server port using username auth.",
	"Method": "void testWithSocks4aProxyAuth(){\r\n    NetClientOptions clientOptions = new NetClientOptions().setProxyOptions(new ProxyOptions().setType(ProxyType.SOCKS4).setPort(11080).setUsername(\"username\"));\r\n    NetClient client = vertx.createNetClient(clientOptions);\r\n    server.connectHandler(sock -> {\r\n    });\r\n    proxy = new Socks4Proxy(\"username\");\r\n    proxy.start(vertx);\r\n    server.listen(1234, \"localhost\", ar -> {\r\n        assertTrue(ar.succeeded());\r\n        client.connect(1234, \"localhost\", ar2 -> {\r\n            if (ar2.failed()) {\r\n                log.warn(\"failed\", ar2.cause());\r\n            }\r\n            assertTrue(ar2.succeeded());\r\n            assertEquals(\"localhost:1234\", proxy.getLastUri());\r\n            testComplete();\r\n        });\r\n    });\r\n    await();\r\n}"
}, {
	"Path": "org.b3log.symphony.service.ArticleQueryService.getUserArticles",
	"Comment": "gets the user articles with the specified user id, page number and page size.",
	"Method": "List<JSONObject> getUserArticles(int avatarViewMode,String userId,int anonymous,int currentPageNum,int pageSize){\r\n    final Query query = new Query().addSort(Article.ARTICLE_CREATE_TIME, SortDirection.DESCENDING).setCurrentPageNum(currentPageNum).setPageSize(pageSize).setFilter(CompositeFilterOperator.and(new PropertyFilter(Article.ARTICLE_AUTHOR_ID, FilterOperator.EQUAL, userId), new PropertyFilter(Article.ARTICLE_ANONYMOUS, FilterOperator.EQUAL, anonymous), new PropertyFilter(Article.ARTICLE_STATUS, FilterOperator.NOT_EQUAL, Article.ARTICLE_STATUS_C_INVALID)));\r\n    try {\r\n        final JSONObject result = articleRepository.get(query);\r\n        final List<JSONObject> ret = CollectionUtils.jsonArrayToList(result.optJSONArray(Keys.RESULTS));\r\n        if (ret.isEmpty()) {\r\n            return ret;\r\n        }\r\n        final JSONObject pagination = result.optJSONObject(Pagination.PAGINATION);\r\n        final int recordCount = pagination.optInt(Pagination.PAGINATION_RECORD_COUNT);\r\n        final int pageCount = pagination.optInt(Pagination.PAGINATION_PAGE_COUNT);\r\n        final JSONObject first = ret.get(0);\r\n        first.put(Pagination.PAGINATION_RECORD_COUNT, recordCount);\r\n        first.put(Pagination.PAGINATION_PAGE_COUNT, pageCount);\r\n        organizeArticles(avatarViewMode, ret);\r\n        return ret;\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Gets user articles failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.datamatrix.encoder.HighLevelEncoder.determineConsecutiveDigitCount",
	"Comment": "determines the number of consecutive characters that are encodable using numeric compaction.",
	"Method": "int determineConsecutiveDigitCount(CharSequence msg,int startpos){\r\n    int count = 0;\r\n    int len = msg.length();\r\n    int idx = startpos;\r\n    if (idx < len) {\r\n        char ch = msg.charAt(idx);\r\n        while (isDigit(ch) && idx < len) {\r\n            count++;\r\n            idx++;\r\n            if (idx < len) {\r\n                ch = msg.charAt(idx);\r\n            }\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.RoleQueryService.userHasPermissions",
	"Comment": "checks whether the specified user has the specified requisite permissions.",
	"Method": "boolean userHasPermissions(String userId,Set<String> requisitePermissions){\r\n    try {\r\n        final JSONObject user = userRepository.get(userId);\r\n        final String roleId = user.optString(User.USER_ROLE);\r\n        final Set<String> permissions = getPermissions(roleId);\r\n        return Permission.hasPermission(requisitePermissions, permissions);\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Checks user [\" + userId + \"] has permission failed\", e);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.Bytes.intToByteArray",
	"Comment": "transforms a passed value to a lsb first byte array with the size of the specified capacity",
	"Method": "byte[] intToByteArray(int capacity,int value){\r\n    final byte[] result = new byte[capacity];\r\n    for (int i = 0; i < capacity; i++) {\r\n        result[i] = (byte) ((value >> (8 * i)) & 0xFF);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.vertx.core.http.HttpClientOptions.setPoolCleanerPeriod",
	"Comment": "set the connection pool cleaner period in milli seconds, a non positive value disables expiration checks and connectionswill remain in the pool until they are closed.",
	"Method": "HttpClientOptions setPoolCleanerPeriod(int poolCleanerPeriod){\r\n    this.poolCleanerPeriod = poolCleanerPeriod;\r\n    return this;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.FollowQueryService.getFollowers",
	"Comment": "gets the followers of a following specified by the given following id and follow type.",
	"Method": "JSONObject getFollowers(String followingId,int followingType,int currentPageNum,int pageSize){\r\n    final List<Filter> filters = new ArrayList();\r\n    filters.add(new PropertyFilter(Follow.FOLLOWING_ID, FilterOperator.EQUAL, followingId));\r\n    filters.add(new PropertyFilter(Follow.FOLLOWING_TYPE, FilterOperator.EQUAL, followingType));\r\n    final Query query = new Query().addSort(Keys.OBJECT_ID, SortDirection.DESCENDING).setFilter(new CompositeFilter(CompositeFilterOperator.AND, filters)).setPageSize(pageSize).setCurrentPageNum(currentPageNum);\r\n    final JSONObject result = followRepository.get(query);\r\n    final List<JSONObject> records = CollectionUtils.jsonArrayToList(result.optJSONArray(Keys.RESULTS));\r\n    final int recordCnt = result.optJSONObject(Pagination.PAGINATION).optInt(Pagination.PAGINATION_RECORD_COUNT);\r\n    final JSONObject ret = new JSONObject();\r\n    ret.put(Keys.RESULTS, (Object) records);\r\n    ret.put(Pagination.PAGINATION_RECORD_COUNT, recordCnt);\r\n    return ret;\r\n}"
}, {
	"Path": "us.codecraft.webmagic.Site.getRetryTimes",
	"Comment": "get retry times immediately when download fail, 0 by default.",
	"Method": "int getRetryTimes(){\r\n    return retryTimes;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.FollowMgmtService.watchArticle",
	"Comment": "the specified follower watches the specified following article.",
	"Method": "void watchArticle(String followerId,String followingArticleId){\r\n    try {\r\n        follow(followerId, followingArticleId, Follow.FOLLOWING_TYPE_C_ARTICLE_WATCH);\r\n    } catch (final RepositoryException e) {\r\n        final String msg = \"User[id=\" + followerId + \"] watches an article[id=\" + followingArticleId + \"] failed\";\r\n        LOGGER.log(Level.ERROR, msg, e);\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.KeysetHandleTest.testGetPublicKeysetHandle",
	"Comment": "tests a public keyset is extracted properly from a private keyset.",
	"Method": "void testGetPublicKeysetHandle(){\r\n    KeysetHandle privateHandle = KeysetHandle.generateNew(SignatureKeyTemplates.ECDSA_P256);\r\n    KeyData privateKeyData = privateHandle.getKeyset().getKey(0).getKeyData();\r\n    EcdsaPrivateKey privateKey = EcdsaPrivateKey.parseFrom(privateKeyData.getValue());\r\n    KeysetHandle publicHandle = privateHandle.getPublicKeysetHandle();\r\n    assertEquals(1, publicHandle.getKeyset().getKeyCount());\r\n    assertEquals(privateHandle.getKeyset().getPrimaryKeyId(), publicHandle.getKeyset().getPrimaryKeyId());\r\n    KeyData publicKeyData = publicHandle.getKeyset().getKey(0).getKeyData();\r\n    assertEquals(SignatureConfig.ECDSA_PUBLIC_KEY_TYPE_URL, publicKeyData.getTypeUrl());\r\n    assertEquals(KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC, publicKeyData.getKeyMaterialType());\r\n    assertArrayEquals(privateKey.getPublicKey().toByteArray(), publicKeyData.getValue().toByteArray());\r\n    PublicKeySign signer = PublicKeySignFactory.getPrimitive(privateHandle);\r\n    PublicKeyVerify verifier = PublicKeyVerifyFactory.getPrimitive(publicHandle);\r\n    byte[] message = Random.randBytes(20);\r\n    try {\r\n        verifier.verify(signer.sign(message), message);\r\n    } catch (GeneralSecurityException e) {\r\n        fail(\"Should not fail: \" + e);\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.EllipticCurves.fieldSizeInBytes",
	"Comment": "returns the size of an element of the field over which the curve is defined.",
	"Method": "int fieldSizeInBytes(EllipticCurve curve){\r\n    return (fieldSizeInBits(curve) + 7) / 8;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.swipe.SwipeLayout.safeBottomView",
	"Comment": "prevent bottom view get any touch event. especially in laydown mode.",
	"Method": "void safeBottomView(){\r\n    Status status = getOpenStatus();\r\n    List<View> bottoms = getBottomViews();\r\n    if (status == Status.Close) {\r\n        for (View bottom : bottoms) {\r\n            if (bottom != null && bottom.getVisibility() != INVISIBLE) {\r\n                bottom.setVisibility(INVISIBLE);\r\n            }\r\n        }\r\n    } else {\r\n        View currentBottomView = getCurrentBottomView();\r\n        if (currentBottomView != null && currentBottomView.getVisibility() != VISIBLE) {\r\n            currentBottomView.setVisibility(VISIBLE);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.yalantis.ucrop.sample.BaseActivity.requestPermission",
	"Comment": "requests given permission.if the permission has been denied previously, a dialog will prompt the user to grant thepermission, otherwise it is requested directly.",
	"Method": "void requestPermission(String permission,String rationale,int requestCode){\r\n    if (ActivityCompat.shouldShowRequestPermissionRationale(this, permission)) {\r\n        showAlertDialog(getString(R.string.permission_title_rationale), rationale, new DialogInterface.OnClickListener() {\r\n            @Override\r\n            public void onClick(DialogInterface dialog, int which) {\r\n                ActivityCompat.requestPermissions(BaseActivity.this, new String[] { permission }, requestCode);\r\n            }\r\n        }, getString(R.string.label_ok), null, getString(R.string.label_cancel));\r\n    } else {\r\n        ActivityCompat.requestPermissions(this, new String[] { permission }, requestCode);\r\n    }\r\n}"
}, {
	"Path": "com.yalantis.ucrop.sample.BaseActivity.requestPermission",
	"Comment": "requests given permission.if the permission has been denied previously, a dialog will prompt the user to grant thepermission, otherwise it is requested directly.",
	"Method": "void requestPermission(String permission,String rationale,int requestCode){\r\n    ActivityCompat.requestPermissions(BaseActivity.this, new String[] { permission }, requestCode);\r\n}"
}, {
	"Path": "com.google.zxing.ResultPoint.crossProductZ",
	"Comment": "returns the z component of the cross product between vectors bc and ba.",
	"Method": "float crossProductZ(ResultPoint pointA,ResultPoint pointB,ResultPoint pointC){\r\n    float bX = pointB.x;\r\n    float bY = pointB.y;\r\n    return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));\r\n}"
}, {
	"Path": "org.b3log.symphony.service.ArticleQueryService.getRelevantArticles",
	"Comment": "gets the relevant articles of the specified article with the specified fetch size.the relevant articles exist the same tag with the specified article.",
	"Method": "List<JSONObject> getRelevantArticles(int avatarViewMode,JSONObject article,int fetchSize){\r\n    final String tagsString = article.optString(Article.ARTICLE_TAGS);\r\n    String[] tagTitles = tagsString.split(\",\");\r\n    final List<String> excludedB3logTitles = new ArrayList();\r\n    for (int i = 0; i < tagTitles.length; i++) {\r\n        if (!\"B3log\".equalsIgnoreCase(tagTitles[i])) {\r\n            excludedB3logTitles.add(tagTitles[i]);\r\n        }\r\n    }\r\n    if (excludedB3logTitles.size() < 1) {\r\n        excludedB3logTitles.add(\"B3log\");\r\n    }\r\n    tagTitles = excludedB3logTitles.toArray(new String[0]);\r\n    final int tagTitlesLength = tagTitles.length;\r\n    final int subCnt = tagTitlesLength > RELEVANT_ARTICLE_RANDOM_FETCH_TAG_CNT ? RELEVANT_ARTICLE_RANDOM_FETCH_TAG_CNT : tagTitlesLength;\r\n    final List<Integer> tagIdx = CollectionUtils.getRandomIntegers(0, tagTitlesLength, subCnt);\r\n    final int subFetchSize = fetchSize / subCnt;\r\n    final Set<String> fetchedArticleIds = new HashSet();\r\n    final List<JSONObject> ret = new ArrayList();\r\n    try {\r\n        for (int i = 0; i < tagIdx.size(); i++) {\r\n            final String tagTitle = tagTitles[tagIdx.get(i)].trim();\r\n            final JSONObject tag = tagRepository.getByTitle(tagTitle);\r\n            final String tagId = tag.optString(Keys.OBJECT_ID);\r\n            JSONObject result = tagArticleRepository.getByTagId(tagId, 1, subFetchSize);\r\n            final JSONArray tagArticleRelations = result.optJSONArray(Keys.RESULTS);\r\n            final Set<String> articleIds = new HashSet();\r\n            for (int j = 0; j < tagArticleRelations.length(); j++) {\r\n                final String articleId = tagArticleRelations.optJSONObject(j).optString(Article.ARTICLE + '_' + Keys.OBJECT_ID);\r\n                if (fetchedArticleIds.contains(articleId)) {\r\n                    continue;\r\n                }\r\n                articleIds.add(articleId);\r\n                fetchedArticleIds.add(articleId);\r\n            }\r\n            articleIds.remove(article.optString(Keys.OBJECT_ID));\r\n            final Query query = new Query().setFilter(new PropertyFilter(Keys.OBJECT_ID, FilterOperator.IN, articleIds)).addProjection(Article.ARTICLE_TITLE, String.class).addProjection(Article.ARTICLE_PERMALINK, String.class).addProjection(Article.ARTICLE_AUTHOR_ID, String.class);\r\n            result = articleRepository.get(query);\r\n            ret.addAll(CollectionUtils.jsonArrayToList(result.optJSONArray(Keys.RESULTS)));\r\n        }\r\n        organizeArticles(avatarViewMode, ret);\r\n        return ret;\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Gets relevant articles failed\", e);\r\n        return Collections.emptyList();\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.qrcode.decoder.BitMatrixParser.remask",
	"Comment": "revert the mask removal done while reading the code words. the bit matrix should revert to its original state.",
	"Method": "void remask(){\r\n    if (parsedFormatInfo == null) {\r\n        return;\r\n    }\r\n    DataMask dataMask = DataMask.values()[parsedFormatInfo.getDataMask()];\r\n    int dimension = bitMatrix.getHeight();\r\n    dataMask.unmaskBitMatrix(bitMatrix, dimension);\r\n}"
}, {
	"Path": "org.b3log.symphony.repository.FollowRepository.exists",
	"Comment": "determines whether exists a follow relationship for the specified follower and the specified following entity.",
	"Method": "boolean exists(String followerId,String followingId,int followingType){\r\n    return null != getByFollowerIdAndFollowingId(followerId, followingId, followingType);\r\n}"
}, {
	"Path": "org.b3log.symphony.service.PointtransferQueryService.getUserPoints",
	"Comment": "gets the user points with the specified user id, page number and page size.",
	"Method": "JSONObject getUserPoints(String userId,int currentPageNum,int pageSize){\r\n    final Query query = new Query().addSort(Keys.OBJECT_ID, SortDirection.DESCENDING).setCurrentPageNum(currentPageNum).setPageSize(pageSize);\r\n    final List<Filter> filters = new ArrayList();\r\n    filters.add(new PropertyFilter(Pointtransfer.FROM_ID, FilterOperator.EQUAL, userId));\r\n    filters.add(new PropertyFilter(Pointtransfer.TO_ID, FilterOperator.EQUAL, userId));\r\n    query.setFilter(new CompositeFilter(CompositeFilterOperator.OR, filters));\r\n    try {\r\n        final JSONObject ret = pointtransferRepository.get(query);\r\n        final JSONArray records = ret.optJSONArray(Keys.RESULTS);\r\n        for (int i = 0; i < records.length(); i++) {\r\n            final JSONObject record = records.optJSONObject(i);\r\n            record.put(Common.CREATE_TIME, new Date(record.optLong(Pointtransfer.TIME)));\r\n            final String toId = record.optString(Pointtransfer.TO_ID);\r\n            final String fromId = record.optString(Pointtransfer.FROM_ID);\r\n            String typeStr = record.optString(Pointtransfer.TYPE);\r\n            if ((\"3\".equals(typeStr) && userId.equals(toId)) || (\"5\".equals(typeStr) && userId.equals(fromId)) || (\"9\".equals(typeStr) && userId.equals(toId)) || (\"14\".equals(typeStr) && userId.equals(toId)) || (\"22\".equals(typeStr) && userId.equals(toId)) || (\"34\".equals(typeStr) && userId.equals(toId))) {\r\n                typeStr += \"In\";\r\n            }\r\n            if (fromId.equals(userId)) {\r\n                record.put(Common.BALANCE, record.optInt(Pointtransfer.FROM_BALANCE));\r\n                record.put(Common.OPERATION, \"-\");\r\n            } else {\r\n                record.put(Common.BALANCE, record.optInt(Pointtransfer.TO_BALANCE));\r\n                record.put(Common.OPERATION, \"+\");\r\n            }\r\n            record.put(Common.DISPLAY_TYPE, langPropsService.get(\"pointType\" + typeStr + \"Label\"));\r\n            final int type = record.optInt(Pointtransfer.TYPE);\r\n            final String dataId = record.optString(Pointtransfer.DATA_ID);\r\n            String desTemplate = langPropsService.get(\"pointType\" + typeStr + \"DesLabel\");\r\n            switch(type) {\r\n                case Pointtransfer.TRANSFER_TYPE_C_DATA_EXPORT:\r\n                    desTemplate = desTemplate.replace(\"{num}\", record.optString(Pointtransfer.DATA_ID));\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_INIT:\r\n                    desTemplate = desTemplate.replace(\"{point}\", record.optString(Pointtransfer.SUM));\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_ADD_ARTICLE:\r\n                    final JSONObject addArticle = articleRepository.get(dataId);\r\n                    if (null == addArticle) {\r\n                        desTemplate = langPropsService.get(\"removedLabel\");\r\n                        break;\r\n                    }\r\n                    final String addArticleLink = \"<a href=\\\"\" + addArticle.optString(Article.ARTICLE_PERMALINK) + \"\\\">\" + Escapes.escapeHTML(addArticle.optString(Article.ARTICLE_TITLE)) + \"<\/a>\";\r\n                    desTemplate = desTemplate.replace(\"{article}\", addArticleLink);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_UPDATE_ARTICLE:\r\n                    final JSONObject updateArticle = articleRepository.get(dataId);\r\n                    if (null == updateArticle) {\r\n                        desTemplate = langPropsService.get(\"removedLabel\");\r\n                        break;\r\n                    }\r\n                    final String updateArticleLink = \"<a href=\\\"\" + updateArticle.optString(Article.ARTICLE_PERMALINK) + \"\\\">\" + Escapes.escapeHTML(updateArticle.optString(Article.ARTICLE_TITLE)) + \"<\/a>\";\r\n                    desTemplate = desTemplate.replace(\"{article}\", updateArticleLink);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_ADD_COMMENT:\r\n                    final JSONObject comment = commentRepository.get(dataId);\r\n                    if (null == comment) {\r\n                        desTemplate = langPropsService.get(\"removedLabel\");\r\n                        break;\r\n                    }\r\n                    final String articleId = comment.optString(Comment.COMMENT_ON_ARTICLE_ID);\r\n                    final JSONObject commentArticle = articleRepository.get(articleId);\r\n                    final String commentArticleLink = \"<a href=\\\"\" + commentArticle.optString(Article.ARTICLE_PERMALINK) + \"\\\">\" + Escapes.escapeHTML(commentArticle.optString(Article.ARTICLE_TITLE)) + \"<\/a>\";\r\n                    desTemplate = desTemplate.replace(\"{article}\", commentArticleLink);\r\n                    if (\"3In\".equals(typeStr)) {\r\n                        final JSONObject commenter = userRepository.get(fromId);\r\n                        final String commenterLink = UserExt.getUserLink(commenter);\r\n                        desTemplate = desTemplate.replace(\"{user}\", commenterLink);\r\n                    }\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_UPDATE_COMMENT:\r\n                    final JSONObject comment32 = commentRepository.get(dataId);\r\n                    if (null == comment32) {\r\n                        desTemplate = langPropsService.get(\"removedLabel\");\r\n                        break;\r\n                    }\r\n                    final String articleId32 = comment32.optString(Comment.COMMENT_ON_ARTICLE_ID);\r\n                    final JSONObject commentArticle32 = articleRepository.get(articleId32);\r\n                    final String commentArticleLink32 = \"<a href=\\\"\" + commentArticle32.optString(Article.ARTICLE_PERMALINK) + \"\\\">\" + Escapes.escapeHTML(commentArticle32.optString(Article.ARTICLE_TITLE)) + \"<\/a>\";\r\n                    desTemplate = desTemplate.replace(\"{article}\", commentArticleLink32);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_ADD_ARTICLE_REWARD:\r\n                    final JSONObject addArticleReword = articleRepository.get(dataId);\r\n                    if (null == addArticleReword) {\r\n                        desTemplate = langPropsService.get(\"removedLabel\");\r\n                        break;\r\n                    }\r\n                    final String addArticleRewordLink = \"<a href=\\\"\" + addArticleReword.optString(Article.ARTICLE_PERMALINK) + \"\\\">\" + Escapes.escapeHTML(addArticleReword.optString(Article.ARTICLE_TITLE)) + \"<\/a>\";\r\n                    desTemplate = desTemplate.replace(\"{article}\", addArticleRewordLink);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_ARTICLE_REWARD:\r\n                    final JSONObject reward = rewardRepository.get(dataId);\r\n                    String senderId = reward.optString(Reward.SENDER_ID);\r\n                    if (\"5In\".equals(typeStr)) {\r\n                        senderId = toId;\r\n                    }\r\n                    final String rewardArticleId = reward.optString(Reward.DATA_ID);\r\n                    final JSONObject sender = userRepository.get(senderId);\r\n                    final String senderLink = UserExt.getUserLink(sender);\r\n                    desTemplate = desTemplate.replace(\"{user}\", senderLink);\r\n                    final JSONObject articleReward = articleRepository.get(rewardArticleId);\r\n                    if (null == articleReward) {\r\n                        desTemplate = langPropsService.get(\"removedLabel\");\r\n                        break;\r\n                    }\r\n                    final String articleRewardLink = \"<a href=\\\"\" + articleReward.optString(Article.ARTICLE_PERMALINK) + \"\\\">\" + Escapes.escapeHTML(articleReward.optString(Article.ARTICLE_TITLE)) + \"<\/a>\";\r\n                    desTemplate = desTemplate.replace(\"{article}\", articleRewardLink);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_COMMENT_REWARD:\r\n                    final JSONObject reward14 = rewardRepository.get(dataId);\r\n                    JSONObject user14;\r\n                    if (\"14In\".equals(typeStr)) {\r\n                        user14 = userRepository.get(fromId);\r\n                    } else {\r\n                        user14 = userRepository.get(toId);\r\n                    }\r\n                    final String userLink14 = UserExt.getUserLink(user14);\r\n                    desTemplate = desTemplate.replace(\"{user}\", userLink14);\r\n                    final String articleId14 = reward14.optString(Reward.DATA_ID);\r\n                    final JSONObject article14 = articleRepository.get(articleId14);\r\n                    if (null == article14) {\r\n                        desTemplate = langPropsService.get(\"removedLabel\");\r\n                        break;\r\n                    }\r\n                    final String articleLink14 = \"<a href=\\\"\" + article14.optString(Article.ARTICLE_PERMALINK) + \"\\\">\" + Escapes.escapeHTML(article14.optString(Article.ARTICLE_TITLE)) + \"<\/a>\";\r\n                    desTemplate = desTemplate.replace(\"{article}\", articleLink14);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_ARTICLE_THANK:\r\n                    final JSONObject thank22 = rewardRepository.get(dataId);\r\n                    JSONObject user22;\r\n                    if (\"22In\".equals(typeStr)) {\r\n                        user22 = userRepository.get(fromId);\r\n                    } else {\r\n                        user22 = userRepository.get(toId);\r\n                    }\r\n                    final String articleId22 = thank22.optString(Reward.DATA_ID);\r\n                    final JSONObject article22 = articleRepository.get(articleId22);\r\n                    if (null == article22) {\r\n                        desTemplate = langPropsService.get(\"removedLabel\");\r\n                        break;\r\n                    }\r\n                    final String userLink22 = UserExt.getUserLink(user22);\r\n                    desTemplate = desTemplate.replace(\"{user}\", userLink22);\r\n                    final String articleLink22 = \"<a href=\\\"\" + article22.optString(Article.ARTICLE_PERMALINK) + \"\\\">\" + Escapes.escapeHTML(article22.optString(Article.ARTICLE_TITLE)) + \"<\/a>\";\r\n                    desTemplate = desTemplate.replace(\"{article}\", articleLink22);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_INVITE_REGISTER:\r\n                    final JSONObject newUser = userRepository.get(dataId);\r\n                    final String newUserLink = UserExt.getUserLink(newUser);\r\n                    desTemplate = desTemplate.replace(\"{user}\", newUserLink);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_INVITED_REGISTER:\r\n                    final JSONObject referralUser = userRepository.get(dataId);\r\n                    final String referralUserLink = UserExt.getUserLink(referralUser);\r\n                    desTemplate = desTemplate.replace(\"{user}\", referralUserLink);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_INVITECODE_USED:\r\n                    final JSONObject newUser1 = userRepository.get(dataId);\r\n                    final String newUserLink1 = UserExt.getUserLink(newUser1);\r\n                    desTemplate = desTemplate.replace(\"{user}\", newUserLink1);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_ACTIVITY_CHECKIN:\r\n                case Pointtransfer.TRANSFER_TYPE_C_ACTIVITY_YESTERDAY_LIVENESS_REWARD:\r\n                case Pointtransfer.TRANSFER_TYPE_C_ACTIVITY_1A0001:\r\n                case Pointtransfer.TRANSFER_TYPE_C_ACTIVITY_1A0001_COLLECT:\r\n                case Pointtransfer.TRANSFER_TYPE_C_ACTIVITY_CHARACTER:\r\n                case Pointtransfer.TRANSFER_TYPE_C_BUY_INVITECODE:\r\n                case Pointtransfer.TRANSFER_TYPE_C_ACTIVITY_EATINGSNAKE:\r\n                case Pointtransfer.TRANSFER_TYPE_C_ACTIVITY_EATINGSNAKE_COLLECT:\r\n                case Pointtransfer.TRANSFER_TYPE_C_ACTIVITY_GOBANG:\r\n                case Pointtransfer.TRANSFER_TYPE_C_ACTIVITY_GOBANG_COLLECT:\r\n                case Pointtransfer.TRANSFER_TYPE_C_REPORT_HANDLED:\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_AT_PARTICIPANTS:\r\n                    final JSONObject comment20 = commentRepository.get(dataId);\r\n                    if (null == comment20) {\r\n                        desTemplate = langPropsService.get(\"removedLabel\");\r\n                        break;\r\n                    }\r\n                    final String articleId20 = comment20.optString(Comment.COMMENT_ON_ARTICLE_ID);\r\n                    final JSONObject atParticipantsArticle = articleRepository.get(articleId20);\r\n                    if (null == atParticipantsArticle) {\r\n                        desTemplate = langPropsService.get(\"removedLabel\");\r\n                        break;\r\n                    }\r\n                    final String ArticleLink20 = \"<a href=\\\"\" + atParticipantsArticle.optString(Article.ARTICLE_PERMALINK) + \"\\\">\" + Escapes.escapeHTML(atParticipantsArticle.optString(Article.ARTICLE_TITLE)) + \"<\/a>\";\r\n                    desTemplate = desTemplate.replace(\"{article}\", ArticleLink20);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_STICK_ARTICLE:\r\n                    final JSONObject stickArticle = articleRepository.get(dataId);\r\n                    if (null == stickArticle) {\r\n                        desTemplate = langPropsService.get(\"removedLabel\");\r\n                        break;\r\n                    }\r\n                    final String stickArticleLink = \"<a href=\\\"\" + stickArticle.optString(Article.ARTICLE_PERMALINK) + \"\\\">\" + Escapes.escapeHTML(stickArticle.optString(Article.ARTICLE_TITLE)) + \"<\/a>\";\r\n                    desTemplate = desTemplate.replace(\"{article}\", stickArticleLink);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_ACCOUNT2ACCOUNT:\r\n                    JSONObject user9;\r\n                    if (\"9In\".equals(typeStr)) {\r\n                        user9 = userRepository.get(fromId);\r\n                    } else {\r\n                        user9 = userRepository.get(toId);\r\n                    }\r\n                    final String userLink = UserExt.getUserLink(user9);\r\n                    desTemplate = desTemplate.replace(\"{user}\", userLink);\r\n                    final String memo = record.optString(Pointtransfer.MEMO);\r\n                    if (StringUtils.isNotBlank(memo)) {\r\n                        desTemplate = desTemplate.replace(\"{memo}\", memo);\r\n                    } else {\r\n                        desTemplate = desTemplate.replace(\"{memo}\", langPropsService.get(\"noMemoLabel\"));\r\n                    }\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_ACTIVITY_CHECKIN_STREAK:\r\n                    desTemplate = desTemplate.replace(\"{point}\", record.optString(Pointtransfer.SUM));\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_CHARGE:\r\n                    final String yuan = dataId.split(\"-\")[0];\r\n                    desTemplate = desTemplate.replace(\"{yuan}\", yuan);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_EXCHANGE:\r\n                    final String exYuan = dataId;\r\n                    desTemplate = desTemplate.replace(\"{yuan}\", exYuan);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_ABUSE_DEDUCT:\r\n                    desTemplate = desTemplate.replace(\"{action}\", dataId);\r\n                    desTemplate = desTemplate.replace(\"{point}\", record.optString(Pointtransfer.SUM));\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_ADD_ARTICLE_BROADCAST:\r\n                    final JSONObject addArticleBroadcast = articleRepository.get(dataId);\r\n                    if (null == addArticleBroadcast) {\r\n                        desTemplate = langPropsService.get(\"removedLabel\");\r\n                        break;\r\n                    }\r\n                    final String addArticleBroadcastLink = \"<a href=\\\"\" + addArticleBroadcast.optString(Article.ARTICLE_PERMALINK) + \"\\\">\" + Escapes.escapeHTML(addArticleBroadcast.optString(Article.ARTICLE_TITLE)) + \"<\/a>\";\r\n                    desTemplate = desTemplate.replace(\"{article}\", addArticleBroadcastLink);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_PERFECT_ARTICLE:\r\n                    final JSONObject perfectArticle = articleRepository.get(dataId);\r\n                    if (null == perfectArticle) {\r\n                        desTemplate = langPropsService.get(\"removedLabel\");\r\n                        break;\r\n                    }\r\n                    final String perfectArticleLink = \"<a href=\\\"\" + perfectArticle.optString(Article.ARTICLE_PERMALINK) + \"\\\">\" + Escapes.escapeHTML(perfectArticle.optString(Article.ARTICLE_TITLE)) + \"<\/a>\";\r\n                    desTemplate = desTemplate.replace(\"{article}\", perfectArticleLink);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_QNA_OFFER:\r\n                    final JSONObject reward34 = rewardRepository.get(dataId);\r\n                    JSONObject user34;\r\n                    if (\"34In\".equals(typeStr)) {\r\n                        user34 = userRepository.get(fromId);\r\n                    } else {\r\n                        user34 = userRepository.get(toId);\r\n                    }\r\n                    final String userLink34 = UserExt.getUserLink(user34);\r\n                    desTemplate = desTemplate.replace(\"{user}\", userLink34);\r\n                    final String articleId34 = reward34.optString(Reward.DATA_ID);\r\n                    final JSONObject article34 = articleRepository.get(articleId34);\r\n                    if (null == article34) {\r\n                        desTemplate = langPropsService.get(\"removedLabel\");\r\n                        break;\r\n                    }\r\n                    final String articleLink34 = \"<a href=\\\"\" + article34.optString(Article.ARTICLE_PERMALINK) + \"\\\">\" + Escapes.escapeHTML(article34.optString(Article.ARTICLE_TITLE)) + \"<\/a>\";\r\n                    desTemplate = desTemplate.replace(\"{article}\", articleLink34);\r\n                    break;\r\n                case Pointtransfer.TRANSFER_TYPE_C_CHANGE_USERNAME:\r\n                    final String oldName = dataId.split(\"-\")[0];\r\n                    final String newName = dataId.split(\"-\")[1];\r\n                    desTemplate = desTemplate.replace(\"{oldName}\", oldName).replace(\"{newName}\", newName);\r\n                    break;\r\n                default:\r\n                    LOGGER.warn(\"Invalid point type [\" + type + \"]\");\r\n            }\r\n            desTemplate = Emotions.convert(desTemplate);\r\n            record.put(Common.DESCRIPTION, desTemplate);\r\n        }\r\n        final int recordCnt = ret.optJSONObject(Pagination.PAGINATION).optInt(Pagination.PAGINATION_RECORD_COUNT);\r\n        ret.remove(Pagination.PAGINATION);\r\n        ret.put(Pagination.PAGINATION_RECORD_COUNT, recordCnt);\r\n        return ret;\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Gets user points failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.aztec.detector.DetectorTest.testErrorInParameterLocator",
	"Comment": "test that we can tolerate errors in the parameter locator bits",
	"Method": "void testErrorInParameterLocator(String data){\r\n    AztecCode aztec = Encoder.encode(data.getBytes(StandardCharsets.ISO_8859_1), 25, Encoder.DEFAULT_AZTEC_LAYERS);\r\n    Random random = new Random(aztec.getMatrix().hashCode());\r\n    int layers = aztec.getLayers();\r\n    boolean compact = aztec.isCompact();\r\n    List<Point> orientationPoints = getOrientationPoints(aztec);\r\n    for (boolean isMirror : new boolean[] { false, true }) {\r\n        for (BitMatrix matrix : getRotations(aztec.getMatrix())) {\r\n            for (int error1 = 0; error1 < orientationPoints.size(); error1++) {\r\n                for (int error2 = error1; error2 < orientationPoints.size(); error2++) {\r\n                    BitMatrix copy = isMirror ? transpose(matrix) : clone(matrix);\r\n                    copy.flip(orientationPoints.get(error1).getX(), orientationPoints.get(error1).getY());\r\n                    if (error2 > error1) {\r\n                        copy.flip(orientationPoints.get(error2).getX(), orientationPoints.get(error2).getY());\r\n                    }\r\n                    AztecDetectorResult r = new Detector(makeLarger(copy, 3)).detect(isMirror);\r\n                    assertNotNull(r);\r\n                    assertEquals(r.getNbLayers(), layers);\r\n                    assertEquals(r.isCompact(), compact);\r\n                    DecoderResult res = new Decoder().decode(r);\r\n                    assertEquals(data, res.getText());\r\n                }\r\n            }\r\n            for (int i = 0; i < 5; i++) {\r\n                BitMatrix copy = clone(matrix);\r\n                Collection<Integer> errors = new TreeSet();\r\n                while (errors.size() < 3) {\r\n                    errors.add(random.nextInt(orientationPoints.size()));\r\n                }\r\n                for (int error : errors) {\r\n                    copy.flip(orientationPoints.get(error).getX(), orientationPoints.get(error).getY());\r\n                }\r\n                try {\r\n                    new Detector(makeLarger(copy, 3)).detect(false);\r\n                    fail(\"Should not reach here\");\r\n                } catch (NotFoundException expected) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.service.CommentQueryService.getNiceComments",
	"Comment": "gets nice comments of an article specified by the given article id.",
	"Method": "List<JSONObject> getNiceComments(int avatarViewMode,int commentViewMode,String articleId,int fetchSize){\r\n    Stopwatchs.start(\"Gets nice comments\");\r\n    try {\r\n        final Query query = new Query().addSort(Comment.COMMENT_SCORE, SortDirection.DESCENDING).setPageSize(fetchSize).setCurrentPageNum(1).setPageCount(1).setFilter(CompositeFilterOperator.and(new PropertyFilter(Comment.COMMENT_ON_ARTICLE_ID, FilterOperator.EQUAL, articleId), new PropertyFilter(Comment.COMMENT_SCORE, FilterOperator.GREATER_THAN, 0D), new PropertyFilter(Comment.COMMENT_STATUS, FilterOperator.EQUAL, Comment.COMMENT_STATUS_C_VALID)));\r\n        try {\r\n            final List<JSONObject> ret = CollectionUtils.jsonArrayToList(commentRepository.get(query).optJSONArray(Keys.RESULTS));\r\n            organizeComments(avatarViewMode, ret);\r\n            final int pageSize = Symphonys.getInt(\"articleCommentsPageSize\");\r\n            for (final JSONObject comment : ret) {\r\n                comment.put(Pagination.PAGINATION_CURRENT_PAGE_NUM, getCommentPage(articleId, comment.optString(Keys.OBJECT_ID), commentViewMode, pageSize));\r\n            }\r\n            return ret;\r\n        } catch (final RepositoryException e) {\r\n            LOGGER.log(Level.ERROR, \"Get nice comments failed\", e);\r\n            return Collections.emptyList();\r\n        }\r\n    } finally {\r\n        Stopwatchs.end();\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.dns.impl.decoder.StartOfAuthorityRecord.expireTime",
	"Comment": "returns time before information stored in secondary name servers becomesnon authoritative.",
	"Method": "int expireTime(){\r\n    return expireTime;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.ArticleMgmtService.reward",
	"Comment": "a user specified by the given sender id rewards the author of an article specified by the given article id.",
	"Method": "void reward(String articleId,String senderId){\r\n    try {\r\n        final JSONObject article = articleRepository.get(articleId);\r\n        if (null == article) {\r\n            return;\r\n        }\r\n        if (Article.ARTICLE_STATUS_C_INVALID == article.optInt(Article.ARTICLE_STATUS)) {\r\n            return;\r\n        }\r\n        final JSONObject sender = userRepository.get(senderId);\r\n        if (null == sender) {\r\n            return;\r\n        }\r\n        if (UserExt.USER_STATUS_C_VALID != sender.optInt(UserExt.USER_STATUS)) {\r\n            return;\r\n        }\r\n        final String receiverId = article.optString(Article.ARTICLE_AUTHOR_ID);\r\n        final JSONObject receiver = userRepository.get(receiverId);\r\n        if (null == receiver) {\r\n            return;\r\n        }\r\n        if (UserExt.USER_STATUS_C_VALID != receiver.optInt(UserExt.USER_STATUS)) {\r\n            return;\r\n        }\r\n        if (receiverId.equals(senderId)) {\r\n            return;\r\n        }\r\n        final int rewardPoint = article.optInt(Article.ARTICLE_REWARD_POINT);\r\n        if (rewardPoint < 1) {\r\n            return;\r\n        }\r\n        if (rewardQueryService.isRewarded(senderId, articleId, Reward.TYPE_C_ARTICLE)) {\r\n            return;\r\n        }\r\n        final String rewardId = Ids.genTimeMillisId();\r\n        if (Article.ARTICLE_ANONYMOUS_C_PUBLIC == article.optInt(Article.ARTICLE_ANONYMOUS)) {\r\n            final boolean succ = null != pointtransferMgmtService.transfer(senderId, receiverId, Pointtransfer.TRANSFER_TYPE_C_ARTICLE_REWARD, rewardPoint, rewardId, System.currentTimeMillis(), \"\");\r\n            if (!succ) {\r\n                throw new ServiceException();\r\n            }\r\n        }\r\n        final JSONObject reward = new JSONObject();\r\n        reward.put(Keys.OBJECT_ID, rewardId);\r\n        reward.put(Reward.SENDER_ID, senderId);\r\n        reward.put(Reward.DATA_ID, articleId);\r\n        reward.put(Reward.TYPE, Reward.TYPE_C_ARTICLE);\r\n        rewardMgmtService.addReward(reward);\r\n        final JSONObject notification = new JSONObject();\r\n        notification.put(Notification.NOTIFICATION_USER_ID, receiverId);\r\n        notification.put(Notification.NOTIFICATION_DATA_ID, rewardId);\r\n        notificationMgmtService.addArticleRewardNotification(notification);\r\n        livenessMgmtService.incLiveness(senderId, Liveness.LIVENESS_REWARD);\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Rewards an article[id=\" + articleId + \"] failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "com.vip.vjtools.vjkit.concurrent.jsr166e.LongAdder.reset",
	"Comment": "resets variables maintaining the sum to zero.this method may\tbe a useful alternative to creating a new adder, but is only\teffective if there are no concurrent updates.because this\tmethod is intrinsically racy, it should only be used when it is\tknown that no threads are concurrently updating.",
	"Method": "void reset(){\r\n    internalReset(0L);\r\n}"
}, {
	"Path": "io.vertx.core.json.JsonArray.contains",
	"Comment": "does the json array contain the specified value? this method will scan the entire array until it finds a valueor reaches the end.",
	"Method": "boolean contains(Object value){\r\n    return list.contains(value);\r\n}"
}, {
	"Path": "com.google.zxing.common.detector.WhiteRectangleDetector.centerEdges",
	"Comment": "recenters the points of a constant distance towards the center",
	"Method": "ResultPoint[] centerEdges(ResultPoint y,ResultPoint z,ResultPoint x,ResultPoint t){\r\n    float yi = y.getX();\r\n    float yj = y.getY();\r\n    float zi = z.getX();\r\n    float zj = z.getY();\r\n    float xi = x.getX();\r\n    float xj = x.getY();\r\n    float ti = t.getX();\r\n    float tj = t.getY();\r\n    if (yi < width / 2.0f) {\r\n        return new ResultPoint[] { new ResultPoint(ti - CORR, tj + CORR), new ResultPoint(zi + CORR, zj + CORR), new ResultPoint(xi - CORR, xj - CORR), new ResultPoint(yi + CORR, yj - CORR) };\r\n    } else {\r\n        return new ResultPoint[] { new ResultPoint(ti + CORR, tj + CORR), new ResultPoint(zi + CORR, zj - CORR), new ResultPoint(xi - CORR, xj + CORR), new ResultPoint(yi - CORR, yj - CORR) };\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.VertxOptions.getClusterManager",
	"Comment": "get the cluster manager to be used when clustering.if the cluster manager has been programmatically set here, then that will be used when clustering.otherwise vert.x attempts to locate a cluster manager on the classpath.",
	"Method": "ClusterManager getClusterManager(){\r\n    return clusterManager;\r\n}"
}, {
	"Path": "io.vertx.core.net.TCPSSLOptions.setIdleTimeoutUnit",
	"Comment": "set the idle timeout unit. if not specified, default is seconds.",
	"Method": "TCPSSLOptions setIdleTimeoutUnit(TimeUnit idleTimeoutUnit){\r\n    this.idleTimeoutUnit = idleTimeoutUnit;\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.impl.launcher.commands.ExecUtils.exitBecauseOfSystemConfigurationIssue",
	"Comment": "exits the jvm and indicate an issue with the system configuration.",
	"Method": "void exitBecauseOfSystemConfigurationIssue(){\r\n    exit(SYSTEM_CONFIGURATION_EXIT_CODE);\r\n}"
}, {
	"Path": "org.b3log.symphony.model.Tag.containsWhiteListTags",
	"Comment": "checks the specified tag string whether contains the white list tags.",
	"Method": "boolean containsWhiteListTags(String tagStr){\r\n    for (final String whiteListTag : Symphonys.WHITE_LIST_TAGS) {\r\n        if (StringUtils.equalsIgnoreCase(tagStr, whiteListTag)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.yalantis.ucrop.UCrop.of",
	"Comment": "this method creates new intent builder and sets both source and destination image uris.",
	"Method": "UCrop of(Uri source,Uri destination){\r\n    return new UCrop(source, destination);\r\n}"
}, {
	"Path": "io.vertx.core.spi.VerticleFactory.order",
	"Comment": "the order of the factory. if there is more than one matching verticle they will be tried in ascending order.",
	"Method": "int order(){\r\n    return 0;\r\n}"
}, {
	"Path": "io.vertx.core.impl.HAManager.nodeAdded",
	"Comment": "synchronize this in case the cluster manager is naughty and calls it concurrently",
	"Method": "void nodeAdded(String nodeID){\r\n    addHaInfoIfLost();\r\n    checkQuorumWhenAdded(nodeID, System.currentTimeMillis());\r\n}"
}, {
	"Path": "com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManagerTest.testGetPublicKeyData",
	"Comment": "tests that a public key is extracted properly from a private key.",
	"Method": "void testGetPublicKeyData(){\r\n    if (TestUtil.isTsan()) {\r\n        return;\r\n    }\r\n    KeysetHandle privateHandle = KeysetHandle.generateNew(SignatureKeyTemplates.RSA_SSA_PKCS1_3072_SHA256_F4);\r\n    KeyData privateKeyData = TestUtil.getKeyset(privateHandle).getKey(0).getKeyData();\r\n    RsaSsaPkcs1SignKeyManager privateManager = new RsaSsaPkcs1SignKeyManager();\r\n    KeyData publicKeyData = privateManager.getPublicKeyData(privateKeyData.getValue());\r\n    assertEquals(RsaSsaPkcs1VerifyKeyManager.TYPE_URL, publicKeyData.getTypeUrl());\r\n    assertEquals(KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC, publicKeyData.getKeyMaterialType());\r\n    RsaSsaPkcs1PrivateKey privateKey = RsaSsaPkcs1PrivateKey.parseFrom(privateKeyData.getValue());\r\n    assertArrayEquals(privateKey.getPublicKey().toByteArray(), publicKeyData.getValue().toByteArray());\r\n    RsaSsaPkcs1VerifyKeyManager publicManager = new RsaSsaPkcs1VerifyKeyManager();\r\n    PublicKeySign signer = privateManager.getPrimitive(privateKeyData.getValue());\r\n    PublicKeyVerify verifier = publicManager.getPrimitive(publicKeyData.getValue());\r\n    byte[] message = Random.randBytes(20);\r\n    try {\r\n        verifier.verify(signer.sign(message), message);\r\n    } catch (GeneralSecurityException e) {\r\n        fail(\"Should not fail: \" + e);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateRecyclerviewViewHolder.getContext",
	"Comment": "returns the context the view is running in, through which it canaccess the current theme, resources, etc.",
	"Method": "Context getContext(){\r\n    return mView.getContext();\r\n}"
}, {
	"Path": "io.vertx.core.eventbus.impl.HandlerHolder.setRemoved",
	"Comment": "we use a synchronized block to protect removed as it can be unregistered from a different thread",
	"Method": "boolean setRemoved(){\r\n    boolean unregistered = false;\r\n    synchronized (this) {\r\n        if (!removed) {\r\n            removed = true;\r\n            unregistered = true;\r\n        }\r\n    }\r\n    if (metrics != null && unregistered) {\r\n        metrics.handlerUnregistered(handler.getMetric());\r\n    }\r\n    return unregistered;\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.EllipticCurves.modSqrt",
	"Comment": "computes a square root modulo an odd prime. timing and exceptions can leak information aboutthe inputs. therefore this method must only be used to decompress public keys.",
	"Method": "BigInteger modSqrt(BigInteger x,BigInteger p){\r\n    if (p.signum() != 1) {\r\n        throw new InvalidAlgorithmParameterException(\"p must be positive\");\r\n    }\r\n    x = x.mod(p);\r\n    BigInteger squareRoot = null;\r\n    if (x.equals(BigInteger.ZERO)) {\r\n        return BigInteger.ZERO;\r\n    }\r\n    if (p.testBit(0) && p.testBit(1)) {\r\n        BigInteger q = p.add(BigInteger.ONE).shiftRight(2);\r\n        squareRoot = x.modPow(q, p);\r\n    } else if (p.testBit(0) && !p.testBit(1)) {\r\n        BigInteger a = BigInteger.ONE;\r\n        BigInteger d = null;\r\n        BigInteger q1 = p.subtract(BigInteger.ONE).shiftRight(1);\r\n        int tries = 0;\r\n        while (true) {\r\n            d = a.multiply(a).subtract(x).mod(p);\r\n            if (d.equals(BigInteger.ZERO)) {\r\n                return a;\r\n            }\r\n            BigInteger t = d.modPow(q1, p);\r\n            if (t.add(BigInteger.ONE).equals(p)) {\r\n                break;\r\n            } else if (!t.equals(BigInteger.ONE)) {\r\n                throw new InvalidAlgorithmParameterException(\"p is not prime\");\r\n            } else {\r\n                a = a.add(BigInteger.ONE);\r\n            }\r\n            tries++;\r\n            if (tries == 128) {\r\n                if (!p.isProbablePrime(80)) {\r\n                    throw new InvalidAlgorithmParameterException(\"p is not prime\");\r\n                }\r\n            }\r\n        }\r\n        BigInteger q = p.add(BigInteger.ONE).shiftRight(1);\r\n        BigInteger u = a;\r\n        BigInteger v = BigInteger.ONE;\r\n        for (int bit = q.bitLength() - 2; bit >= 0; bit--) {\r\n            BigInteger tmp = u.multiply(v);\r\n            u = u.multiply(u).add(v.multiply(v).mod(p).multiply(d)).mod(p);\r\n            v = tmp.add(tmp).mod(p);\r\n            if (q.testBit(bit)) {\r\n                tmp = u.multiply(a).add(v.multiply(d)).mod(p);\r\n                v = a.multiply(v).add(u).mod(p);\r\n                u = tmp;\r\n            }\r\n        }\r\n        squareRoot = u;\r\n    }\r\n    if (squareRoot != null && squareRoot.multiply(squareRoot).mod(p).compareTo(x) != 0) {\r\n        throw new GeneralSecurityException(\"Could not find a modular square root\");\r\n    }\r\n    return squareRoot;\r\n}"
}, {
	"Path": "com.yalantis.ucrop.view.CropImageView.onImageLaidOut",
	"Comment": "when image is laid out it must be centered properly to fit current crop bounds.",
	"Method": "void onImageLaidOut(){\r\n    super.onImageLaidOut();\r\n    final Drawable drawable = getDrawable();\r\n    if (drawable == null) {\r\n        return;\r\n    }\r\n    float drawableWidth = drawable.getIntrinsicWidth();\r\n    float drawableHeight = drawable.getIntrinsicHeight();\r\n    if (mTargetAspectRatio == SOURCE_IMAGE_ASPECT_RATIO) {\r\n        mTargetAspectRatio = drawableWidth / drawableHeight;\r\n    }\r\n    int height = (int) (mThisWidth / mTargetAspectRatio);\r\n    if (height > mThisHeight) {\r\n        int width = (int) (mThisHeight * mTargetAspectRatio);\r\n        int halfDiff = (mThisWidth - width) / 2;\r\n        mCropRect.set(halfDiff, 0, width + halfDiff, mThisHeight);\r\n    } else {\r\n        int halfDiff = (mThisHeight - height) / 2;\r\n        mCropRect.set(0, halfDiff, mThisWidth, height + halfDiff);\r\n    }\r\n    calculateImageScaleBounds(drawableWidth, drawableHeight);\r\n    setupInitialImagePosition(drawableWidth, drawableHeight);\r\n    if (mCropBoundsChangeListener != null) {\r\n        mCropBoundsChangeListener.onCropAspectRatioChanged(mTargetAspectRatio);\r\n    }\r\n    if (mTransformImageListener != null) {\r\n        mTransformImageListener.onScale(getCurrentScale());\r\n        mTransformImageListener.onRotate(getCurrentAngle());\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.VertxOptions.setWorkerPoolSize",
	"Comment": "set the maximum number of worker threads to be used by the vert.x instance.",
	"Method": "VertxOptions setWorkerPoolSize(int workerPoolSize){\r\n    if (workerPoolSize < 1) {\r\n        throw new IllegalArgumentException(\"workerPoolSize must be > 0\");\r\n    }\r\n    this.workerPoolSize = workerPoolSize;\r\n    return this;\r\n}"
}, {
	"Path": "org.b3log.symphony.repository.PointtransferRepository.getActivityEatingSnakeAvg",
	"Comment": "gets average point of activity eating snake of a user specified by the given user id.",
	"Method": "int getActivityEatingSnakeAvg(String userId){\r\n    int ret = Pointtransfer.TRANSFER_SUM_C_ACTIVITY_EATINGSNAKE;\r\n    try {\r\n        final List<JSONObject> result = select(\"SELECT\\n\" + \"\tAVG(sum) AS point\\n\" + \"FROM\\n\" + \"\t`\" + getName() + \"`\\n\" + \"WHERE\\n\" + \"\ttype = 27\\n\" + \"AND toId = ?\\n\" + \"\", userId);\r\n        if (!result.isEmpty()) {\r\n            ret = result.get(0).optInt(Common.POINT, ret);\r\n        }\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Calc avg point failed\", e);\r\n    }\r\n    if (ret < 1) {\r\n        ret = Pointtransfer.TRANSFER_SUM_C_ACTIVITY_EATINGSNAKE;\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.CommentMgmtService.removeCommentByAdmin",
	"Comment": "removes a comment specified with the given comment id. calls this method will remove all existed data relatedwith the specified comment forcibly.",
	"Method": "void removeCommentByAdmin(String commentId){\r\n    try {\r\n        commentRepository.removeComment(commentId);\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Removes a comment error [id=\" + commentId + \"]\", e);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.service.FollowMgmtService.followUser",
	"Comment": "the specified follower follows the specified following user.",
	"Method": "void followUser(String followerId,String followingUserId){\r\n    try {\r\n        follow(followerId, followingUserId, Follow.FOLLOWING_TYPE_C_USER);\r\n    } catch (final RepositoryException e) {\r\n        final String msg = \"User[id=\" + followerId + \"] follows a user[id=\" + followingUserId + \"] failed\";\r\n        LOGGER.log(Level.ERROR, msg, e);\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.impl.launcher.commands.StartCommand.setRedirect",
	"Comment": "whether or not the created process error streams and output streams needs to be redirected to the launcher process.",
	"Method": "void setRedirect(boolean redirect){\r\n    this.redirect = redirect;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.RoleQueryService.getUserPermissions",
	"Comment": "gets grant permissions of a user specified by the given user id.",
	"Method": "Set<String> getUserPermissions(String userId){\r\n    try {\r\n        final JSONObject user = userRepository.get(userId);\r\n        if (null == user) {\r\n            return Collections.emptySet();\r\n        }\r\n        final String roleId = user.optString(User.USER_ROLE);\r\n        return getPermissions(roleId);\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Gets grant permissions of user [id=\" + userId + \"] failed\", e);\r\n        return Collections.emptySet();\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.impl.launcher.commands.ClasspathHandler.deploy",
	"Comment": "deploys the given verticle using the given deployment options.",
	"Method": "void deploy(String verticle,Vertx vertx,DeploymentOptions options,Handler<AsyncResult<String>> completionHandler){\r\n    if (manager == null) {\r\n        manager = newInstance();\r\n    }\r\n    final ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();\r\n    try {\r\n        Thread.currentThread().setContextClassLoader(classloader);\r\n        Method method = manager.getClass().getMethod(\"deploy\", String.class, Vertx.class, DeploymentOptions.class, Handler.class);\r\n        method.invoke(manager, verticle, vertx, options, completionHandler);\r\n    } catch (InvocationTargetException e) {\r\n        log.error(\"Failed to deploy verticle \" + verticle, e.getCause());\r\n    } catch (Exception e) {\r\n        log.error(\"Failed to deploy verticle \" + verticle, e);\r\n    } finally {\r\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.file.OpenOptions.setCreate",
	"Comment": "set whether the file should be created if it does not already exist.",
	"Method": "OpenOptions setCreate(boolean create){\r\n    this.create = create;\r\n    return this;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.gridSection.SimpleSectionedAdapter.getLayoutResource",
	"Comment": "provides a layout identifier for the header. override it to change the appearance of theheader view.",
	"Method": "int getLayoutResource(){\r\n    return R.layout.slm_header;\r\n}"
}, {
	"Path": "io.vertx.core.dns.impl.decoder.RecordDecoder.getName",
	"Comment": "retrieves a domain name given a buffer containing a dns packet withoutadvancing the readerindex for the buffer.",
	"Method": "String getName(ByteBuf buf,int offset){\r\n    StringBuilder name = new StringBuilder();\r\n    for (int len = buf.getUnsignedByte(offset++); buf.writerIndex() > offset && len != 0; len = buf.getUnsignedByte(offset++)) {\r\n        boolean pointer = (len & 0xc0) == 0xc0;\r\n        if (pointer) {\r\n            offset = (len & 0x3f) << 8 | buf.getUnsignedByte(offset++);\r\n        } else {\r\n            name.append(buf.toString(offset, len, CharsetUtil.UTF_8)).append(\".\");\r\n            offset += len;\r\n        }\r\n    }\r\n    if (name.length() == 0) {\r\n        return null;\r\n    }\r\n    return name.substring(0, name.length() - 1);\r\n}"
}, {
	"Path": "com.google.zxing.client.android.result.CalendarResultHandler.addCalendarEvent",
	"Comment": "sends an intent to create a new calendar event by prepopulating the add event ui. olderversions of the system have a bug where the event title will not be filled out.",
	"Method": "void addCalendarEvent(String summary,long start,boolean allDay,long end,String location,String description,String[] attendees){\r\n    Intent intent = new Intent(Intent.ACTION_INSERT);\r\n    intent.setType(\"vnd.android.cursor.item/event\");\r\n    intent.putExtra(\"beginTime\", start);\r\n    if (allDay) {\r\n        intent.putExtra(\"allDay\", true);\r\n    }\r\n    if (end < 0L) {\r\n        if (allDay) {\r\n            end = start + 24 * 60 * 60 * 1000;\r\n        } else {\r\n            end = start;\r\n        }\r\n    }\r\n    intent.putExtra(\"endTime\", end);\r\n    intent.putExtra(\"title\", summary);\r\n    intent.putExtra(\"eventLocation\", location);\r\n    intent.putExtra(\"description\", description);\r\n    if (attendees != null) {\r\n        intent.putExtra(Intent.EXTRA_EMAIL, attendees);\r\n    }\r\n    try {\r\n        rawLaunchIntent(intent);\r\n    } catch (ActivityNotFoundException anfe) {\r\n        Log.w(TAG, \"No calendar app available that responds to \" + Intent.ACTION_INSERT);\r\n        intent.setAction(Intent.ACTION_EDIT);\r\n        launchIntent(intent);\r\n    }\r\n}"
}, {
	"Path": "com.yalantis.ucrop.util.FileUtils.copyFile",
	"Comment": "copies one file into the other with the given paths.in the event that the paths are the same, trying to copy one file to the otherwill cause both files to become null.simply skipping this step if the paths are identical.",
	"Method": "void copyFile(String pathFrom,String pathTo){\r\n    if (pathFrom.equalsIgnoreCase(pathTo)) {\r\n        return;\r\n    }\r\n    FileChannel outputChannel = null;\r\n    FileChannel inputChannel = null;\r\n    try {\r\n        inputChannel = new FileInputStream(new File(pathFrom)).getChannel();\r\n        outputChannel = new FileOutputStream(new File(pathTo)).getChannel();\r\n        inputChannel.transferTo(0, inputChannel.size(), outputChannel);\r\n        inputChannel.close();\r\n    } finally {\r\n        if (inputChannel != null)\r\n            inputChannel.close();\r\n        if (outputChannel != null)\r\n            outputChannel.close();\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateRecyclerView.enableDefaultSwipeRefresh",
	"Comment": "enable or disable the swiperefreshlayout.default is false",
	"Method": "void enableDefaultSwipeRefresh(boolean isSwipeRefresh){\r\n    if (mSwipeRefreshLayout != null)\r\n        mSwipeRefreshLayout.setEnabled(isSwipeRefresh);\r\n}"
}, {
	"Path": "io.vertx.core.streams.impl.InboundBuffer.read",
	"Comment": "read the most recent element synchronously.no handler will be called.",
	"Method": "E read(){\r\n    synchronized (this) {\r\n        return pending.poll();\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.VertxOptions.getClusterPingReplyInterval",
	"Comment": "get the value of cluster ping reply interval, in ms.after sending a ping, if a pong is not received in this time, the node will be considered dead.",
	"Method": "long getClusterPingReplyInterval(){\r\n    return eventBusOptions.getClusterPingReplyInterval();\r\n}"
}, {
	"Path": "io.vertx.core.net.impl.SSLHelper.resolveEngineOptions",
	"Comment": "resolve the ssl engine options to use for properly running the configured options.",
	"Method": "SSLEngineOptions resolveEngineOptions(TCPSSLOptions options){\r\n    SSLEngineOptions engineOptions = options.getSslEngineOptions();\r\n    if (engineOptions == null) {\r\n        if (options.isUseAlpn()) {\r\n            if (JdkSSLEngineOptions.isAlpnAvailable()) {\r\n                engineOptions = new JdkSSLEngineOptions();\r\n            } else if (OpenSSLEngineOptions.isAlpnAvailable()) {\r\n                engineOptions = new OpenSSLEngineOptions();\r\n            }\r\n        }\r\n    }\r\n    if (engineOptions == null) {\r\n        engineOptions = new JdkSSLEngineOptions();\r\n    } else if (engineOptions instanceof OpenSSLEngineOptions) {\r\n        if (!OpenSsl.isAvailable()) {\r\n            VertxException ex = new VertxException(\"OpenSSL is not available\");\r\n            Throwable cause = OpenSsl.unavailabilityCause();\r\n            if (cause != null) {\r\n                ex.initCause(cause);\r\n            }\r\n            throw ex;\r\n        }\r\n    }\r\n    if (options.isUseAlpn()) {\r\n        if (engineOptions instanceof JdkSSLEngineOptions) {\r\n            if (!JdkSSLEngineOptions.isAlpnAvailable()) {\r\n                throw new VertxException(\"ALPN not available for JDK SSL/TLS engine\");\r\n            }\r\n        }\r\n        if (engineOptions instanceof OpenSSLEngineOptions) {\r\n            if (!OpenSSLEngineOptions.isAlpnAvailable()) {\r\n                throw new VertxException(\"ALPN is not available for OpenSSL SSL/TLS engine\");\r\n            }\r\n        }\r\n    }\r\n    return engineOptions;\r\n}"
}, {
	"Path": "com.google.zxing.client.android.camera.CameraManager.setManualFramingRect",
	"Comment": "allows third party apps to specify the scanning rectangle dimensions, rather than determinethem automatically based on screen resolution.",
	"Method": "void setManualFramingRect(int width,int height){\r\n    if (initialized) {\r\n        Point screenResolution = configManager.getScreenResolution();\r\n        if (width > screenResolution.x) {\r\n            width = screenResolution.x;\r\n        }\r\n        if (height > screenResolution.y) {\r\n            height = screenResolution.y;\r\n        }\r\n        int leftOffset = (screenResolution.x - width) / 2;\r\n        int topOffset = (screenResolution.y - height) / 2;\r\n        framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);\r\n        Log.d(TAG, \"Calculated manual framing rect: \" + framingRect);\r\n        framingRectInPreview = null;\r\n    } else {\r\n        requestedFramingRectWidth = width;\r\n        requestedFramingRectHeight = height;\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.util.Symphonys.getInt",
	"Comment": "gets a configuration integer property with the specified key.",
	"Method": "Integer getInt(String key){\r\n    final String stringValue = get(key);\r\n    if (null == stringValue) {\r\n        return null;\r\n    }\r\n    return Integer.valueOf(stringValue);\r\n}"
}, {
	"Path": "org.b3log.symphony.model.Tag.exists",
	"Comment": "checks the specified title exists in the specified title set.",
	"Method": "boolean exists(Set<String> titles,String title){\r\n    for (final String setTitle : titles) {\r\n        if (setTitle.equalsIgnoreCase(title)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.google.crypto.tink.KeysetHandle.assertEnoughEncryptedKeyMaterial",
	"Comment": "validates that an encrypted keyset contains enough key material to build a keyset on.",
	"Method": "void assertEnoughEncryptedKeyMaterial(EncryptedKeyset keyset){\r\n    if (keyset == null || keyset.getEncryptedKeyset().size() == 0) {\r\n        throw new GeneralSecurityException(\"empty keyset\");\r\n    }\r\n}"
}, {
	"Path": "io.vertx.test.core.VertxTestBase.createWorkers",
	"Comment": "create worker verticles for the current vert.x and returns the list of their contexts.",
	"Method": "List<Context> createWorkers(int num){\r\n    List<Context> contexts = new ArrayList();\r\n    for (int i = 0; i < num; i++) {\r\n        contexts.add(createWorker());\r\n    }\r\n    return contexts;\r\n}"
}, {
	"Path": "io.vertx.core.net.impl.ConnectionBase.isNotWritable",
	"Comment": "this is a volatile read inside the netty channel implementation",
	"Method": "boolean isNotWritable(){\r\n    return !chctx.channel().isWritable();\r\n}"
}, {
	"Path": "io.vertx.core.VertxOptions.getWorkerPoolSize",
	"Comment": "get the maximum number of worker threads to be used by the vert.x instance.worker threads are used for running blocking code and worker verticles.",
	"Method": "int getWorkerPoolSize(){\r\n    return workerPoolSize;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.CommentQueryService.getOriginalComment",
	"Comment": "gets original comment of a comment specified by the given comment id.",
	"Method": "JSONObject getOriginalComment(String currentUserId,int avatarViewMode,int commentViewMode,String commentId){\r\n    try {\r\n        final JSONObject comment = commentRepository.get(commentId);\r\n        organizeComment(avatarViewMode, comment);\r\n        final int pageSize = Symphonys.getInt(\"articleCommentsPageSize\");\r\n        final JSONObject ret = new JSONObject();\r\n        final JSONObject commentAuthor = comment.optJSONObject(Comment.COMMENT_T_COMMENTER);\r\n        if (UserExt.USER_XXX_STATUS_C_PRIVATE == commentAuthor.optInt(UserExt.USER_UA_STATUS)) {\r\n            ret.put(Comment.COMMENT_UA, \"\");\r\n        }\r\n        ret.put(Comment.COMMENT_T_AUTHOR_NAME, comment.optString(Comment.COMMENT_T_AUTHOR_NAME));\r\n        ret.put(Comment.COMMENT_T_AUTHOR_THUMBNAIL_URL, comment.optString(Comment.COMMENT_T_AUTHOR_THUMBNAIL_URL));\r\n        ret.put(Common.TIME_AGO, comment.optString(Common.TIME_AGO));\r\n        ret.put(Comment.COMMENT_CREATE_TIME_STR, comment.optString(Comment.COMMENT_CREATE_TIME_STR));\r\n        ret.put(Common.REWARED_COUNT, comment.optString(Common.REWARED_COUNT));\r\n        ret.put(Common.REWARDED, comment.optBoolean(Common.REWARDED));\r\n        ret.put(Keys.OBJECT_ID, commentId);\r\n        ret.put(Comment.COMMENT_CONTENT, comment.optString(Comment.COMMENT_CONTENT));\r\n        ret.put(Pagination.PAGINATION_CURRENT_PAGE_NUM, getCommentPage(comment.optString(Comment.COMMENT_ON_ARTICLE_ID), commentId, commentViewMode, pageSize));\r\n        if (Comment.COMMENT_VISIBLE_C_AUTHOR == comment.optInt(Comment.COMMENT_VISIBLE)) {\r\n            final String commentAuthorId = comment.optString(Comment.COMMENT_AUTHOR_ID);\r\n            final String articleId = comment.optString(Comment.COMMENT_ON_ARTICLE_ID);\r\n            final JSONObject article = articleRepository.get(articleId);\r\n            final String articleAuthorId = article.optString(Article.ARTICLE_AUTHOR_ID);\r\n            if (StringUtils.isBlank(currentUserId) || (!StringUtils.equals(currentUserId, commentAuthorId) && !StringUtils.equals(currentUserId, articleAuthorId))) {\r\n                ret.put(Comment.COMMENT_CONTENT, langPropsService.get(\"onlySelfAndArticleAuthorVisibleLabel\"));\r\n            }\r\n        }\r\n        return ret;\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Get replies failed\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.processor.SkinRenderer.genHTML",
	"Comment": "processes the specified freemarker template with the specified request, data model, pjax hacking.",
	"Method": "String genHTML(HttpServletRequest request,Map<String, Object> dataModel,Template template){\r\n    final boolean isPJAX = isPJAX(request);\r\n    dataModel.put(\"pjax\", isPJAX);\r\n    if (!isPJAX) {\r\n        return super.genHTML(request, dataModel, template);\r\n    }\r\n    final StringWriter stringWriter = new StringWriter();\r\n    template.setOutputEncoding(\"UTF-8\");\r\n    template.process(dataModel, stringWriter);\r\n    final long endTimeMillis = System.currentTimeMillis();\r\n    final String dateString = DateFormatUtils.format(endTimeMillis, \"yyyy/MM/dd HH:mm:ss\");\r\n    final long startTimeMillis = (Long) request.getAttribute(Keys.HttpRequest.START_TIME_MILLIS);\r\n    final String msg = String.format(\"\\n<!-- Generated by Latke (https://github.com/b3log/latke) in %1$dms, %2$s -->\", endTimeMillis - startTimeMillis, dateString);\r\n    final String pjaxContainer = request.getHeader(\"X-PJAX-Container\");\r\n    return StringUtils.substringBetween(stringWriter.toString(), \"<!---- pjax {\" + pjaxContainer + \"} start ---->\", \"<!---- pjax {\" + pjaxContainer + \"} end ---->\") + msg;\r\n}"
}, {
	"Path": "io.vertx.test.core.TestUtils.assertIllegalStateException",
	"Comment": "asserts that an illegalstateexception is thrown by the code block.",
	"Method": "void assertIllegalStateException(Runnable runnable){\r\n    try {\r\n        runnable.run();\r\n        fail(\"Should throw IllegalStateException\");\r\n    } catch (IllegalStateException e) {\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.service.VoteMgmtService.up",
	"Comment": "the specified user vote up the specified data entity with the specified data type.",
	"Method": "void up(String userId,String dataId,int dataType){\r\n    final int oldType = voteRepository.removeIfExists(userId, dataId, dataType);\r\n    if (Vote.DATA_TYPE_C_ARTICLE == dataType) {\r\n        final JSONObject article = articleRepository.get(dataId);\r\n        if (null == article) {\r\n            LOGGER.log(Level.ERROR, \"Not found article [id={0}] to vote up\", dataId);\r\n            return;\r\n        }\r\n        if (-1 == oldType) {\r\n            article.put(Article.ARTICLE_GOOD_CNT, article.optInt(Article.ARTICLE_GOOD_CNT) + 1);\r\n        } else if (Vote.TYPE_C_DOWN == oldType) {\r\n            article.put(Article.ARTICLE_BAD_CNT, article.optInt(Article.ARTICLE_BAD_CNT) - 1);\r\n            article.put(Article.ARTICLE_GOOD_CNT, article.optInt(Article.ARTICLE_GOOD_CNT) + 1);\r\n        }\r\n        final int ups = article.optInt(Article.ARTICLE_GOOD_CNT);\r\n        final int downs = article.optInt(Article.ARTICLE_BAD_CNT);\r\n        final long t = article.optLong(Keys.OBJECT_ID) / 1000;\r\n        final double redditScore = redditArticleScore(ups, downs, t);\r\n        article.put(Article.REDDIT_SCORE, redditScore);\r\n        updateTagArticleScore(article);\r\n        articleRepository.update(dataId, article);\r\n    } else if (Vote.DATA_TYPE_C_COMMENT == dataType) {\r\n        final JSONObject comment = commentRepository.get(dataId);\r\n        if (null == comment) {\r\n            LOGGER.log(Level.ERROR, \"Not found comment [id={0}] to vote up\", dataId);\r\n            return;\r\n        }\r\n        if (-1 == oldType) {\r\n            comment.put(Comment.COMMENT_GOOD_CNT, comment.optInt(Comment.COMMENT_GOOD_CNT) + 1);\r\n        } else if (Vote.TYPE_C_DOWN == oldType) {\r\n            comment.put(Comment.COMMENT_BAD_CNT, comment.optInt(Comment.COMMENT_BAD_CNT) - 1);\r\n            comment.put(Comment.COMMENT_GOOD_CNT, comment.optInt(Comment.COMMENT_GOOD_CNT) + 1);\r\n        }\r\n        final int ups = comment.optInt(Comment.COMMENT_GOOD_CNT);\r\n        final int downs = comment.optInt(Comment.COMMENT_BAD_CNT);\r\n        final double redditScore = redditCommentScore(ups, downs);\r\n        comment.put(Comment.COMMENT_SCORE, redditScore);\r\n        commentRepository.update(dataId, comment);\r\n    } else {\r\n        LOGGER.warn(\"Wrong data type [\" + dataType + \"]\");\r\n    }\r\n    final JSONObject vote = new JSONObject();\r\n    vote.put(Vote.USER_ID, userId);\r\n    vote.put(Vote.DATA_ID, dataId);\r\n    vote.put(Vote.TYPE, Vote.TYPE_C_UP);\r\n    vote.put(Vote.DATA_TYPE, dataType);\r\n    voteRepository.add(vote);\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateRecyclerView.setDefaultSwipeToRefreshColorScheme",
	"Comment": "set the color resources used in the progress animation from color resources. the first color will also be the color of the bar that grows in response to a user swipe gesture.",
	"Method": "void setDefaultSwipeToRefreshColorScheme(int colors){\r\n    mSwipeRefreshLayout.setColorSchemeColors(colors);\r\n}"
}, {
	"Path": "us.codecraft.webmagic.Site.setCycleRetryTimes",
	"Comment": "set cycleretrytimes times when download fail, 0 by default.",
	"Method": "Site setCycleRetryTimes(int cycleRetryTimes){\r\n    this.cycleRetryTimes = cycleRetryTimes;\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.net.NetTest.testWithSocks4LocalResolver",
	"Comment": "test socks4a proxy for accessing arbitrary server port using an already resolved address.",
	"Method": "void testWithSocks4LocalResolver(){\r\n    NetClientOptions clientOptions = new NetClientOptions().setProxyOptions(new ProxyOptions().setType(ProxyType.SOCKS4).setPort(11080));\r\n    NetClient client = vertx.createNetClient(clientOptions);\r\n    server.connectHandler(sock -> {\r\n    });\r\n    proxy = new Socks4Proxy(null).start(vertx);\r\n    server.listen(1234, \"localhost\", ar -> {\r\n        assertTrue(ar.succeeded());\r\n        client.connect(1234, \"127.0.0.1\", ar2 -> {\r\n            if (ar2.failed()) {\r\n                log.warn(\"failed\", ar2.cause());\r\n            }\r\n            assertTrue(ar2.succeeded());\r\n            assertEquals(\"127.0.0.1:1234\", proxy.getLastUri());\r\n            testComplete();\r\n        });\r\n    });\r\n    await();\r\n}"
}, {
	"Path": "com.google.zxing.client.android.encode.QRCodeEncoder.encodeContentsFromShareIntent",
	"Comment": "handles send intents from multitude of android applications",
	"Method": "void encodeContentsFromShareIntent(Intent intent){\r\n    if (intent.hasExtra(Intent.EXTRA_STREAM)) {\r\n        encodeFromStreamExtra(intent);\r\n    } else {\r\n        encodeFromTextExtras(intent);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.service.FollowMgmtService.unfollowArticle",
	"Comment": "the specified follower unfollows the specified following article.",
	"Method": "void unfollowArticle(String followerId,String followingArticleId){\r\n    try {\r\n        unfollow(followerId, followingArticleId, Follow.FOLLOWING_TYPE_C_ARTICLE);\r\n    } catch (final RepositoryException e) {\r\n        final String msg = \"User[id=\" + followerId + \"] unfollows an article[id=\" + followingArticleId + \"] failed\";\r\n        LOGGER.log(Level.ERROR, msg, e);\r\n    }\r\n}"
}, {
	"Path": "io.vertx.core.AbstractVerticle.config",
	"Comment": "get the configuration of the verticle.this can be specified when the verticle is deployed.",
	"Method": "JsonObject config(){\r\n    return context.config();\r\n}"
}, {
	"Path": "io.vertx.core.cli.Argument.setMultiValued",
	"Comment": "sets whether or not the argument can receive several values. only the last argument can receive several values.",
	"Method": "Argument setMultiValued(boolean multiValued){\r\n    this.multiValued = multiValued;\r\n    return this;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.PointtransferMgmtService.transfer",
	"Comment": "transfers point from the specified from id to the specified to id with type, sum, data id and time.",
	"Method": "String transfer(String fromId,String toId,int type,int sum,String dataId,long time,String memo){\r\n    if (StringUtils.equals(fromId, toId)) {\r\n        LOGGER.log(Level.WARN, \"The from id is equal to the to id [\" + fromId + \"]\");\r\n        return null;\r\n    }\r\n    final Transaction transaction = pointtransferRepository.beginTransaction();\r\n    try {\r\n        int fromBalance = 0;\r\n        if (!Pointtransfer.ID_C_SYS.equals(fromId)) {\r\n            final JSONObject fromUser = userRepository.get(fromId);\r\n            fromBalance = fromUser.optInt(UserExt.USER_POINT) - sum;\r\n            if (fromBalance < 0) {\r\n                throw new Exception(\"Insufficient balance\");\r\n            }\r\n            fromUser.put(UserExt.USER_POINT, fromBalance);\r\n            fromUser.put(UserExt.USER_USED_POINT, fromUser.optInt(UserExt.USER_USED_POINT) + sum);\r\n            userRepository.update(fromId, fromUser);\r\n        }\r\n        int toBalance = 0;\r\n        if (!Pointtransfer.ID_C_SYS.equals(toId)) {\r\n            final JSONObject toUser = userRepository.get(toId);\r\n            toBalance = toUser.optInt(UserExt.USER_POINT) + sum;\r\n            toUser.put(UserExt.USER_POINT, toBalance);\r\n            userRepository.update(toId, toUser);\r\n        }\r\n        final JSONObject pointtransfer = new JSONObject();\r\n        pointtransfer.put(Pointtransfer.FROM_ID, fromId);\r\n        pointtransfer.put(Pointtransfer.TO_ID, toId);\r\n        pointtransfer.put(Pointtransfer.SUM, sum);\r\n        pointtransfer.put(Pointtransfer.FROM_BALANCE, fromBalance);\r\n        pointtransfer.put(Pointtransfer.TO_BALANCE, toBalance);\r\n        pointtransfer.put(Pointtransfer.TIME, time);\r\n        pointtransfer.put(Pointtransfer.TYPE, type);\r\n        pointtransfer.put(Pointtransfer.DATA_ID, dataId);\r\n        pointtransfer.put(Pointtransfer.MEMO, memo);\r\n        final String ret = pointtransferRepository.add(pointtransfer);\r\n        transaction.commit();\r\n        return ret;\r\n    } catch (final Exception e) {\r\n        if (transaction.isActive()) {\r\n            transaction.rollback();\r\n        }\r\n        LOGGER.log(Level.ERROR, \"Transfer [fromId=\" + fromId + \", toId=\" + toId + \", sum=\" + sum + \", type=\" + type + \", dataId=\" + dataId + \", memo=\" + memo + \"] error\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel.position",
	"Comment": "sets the position in the plaintext.setting the position to a value greater than the plaintext size is legal.a later attempt to read byte will throw an ioexception.",
	"Method": "long position(SeekableByteChannel position,long newPosition){\r\n    plaintextPosition = newPosition;\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.json.JsonArray.add",
	"Comment": "add a instant value to the json array.json has no notion of temporal data so the instant will be isostring encoded, and the string added.",
	"Method": "JsonArray add(Enum value,JsonArray add,CharSequence value,JsonArray add,String value,JsonArray add,Integer value,JsonArray add,Long value,JsonArray add,Double value,JsonArray add,Float value,JsonArray add,Boolean value,JsonArray add,JsonObject value,JsonArray add,JsonArray value,JsonArray add,byte[] value,JsonArray add,Instant value,JsonArray add,Object value){\r\n    Objects.requireNonNull(value);\r\n    value = Json.checkAndCopy(value, false);\r\n    list.add(value);\r\n    return this;\r\n}"
}, {
	"Path": "io.swagger.v3.jaxrs2.DecoratorExtensionTest.scanSimpleResourceWithDecorator",
	"Comment": "test for method annotated with vendor annotation which could be used for swagger documentation.",
	"Method": "void scanSimpleResourceWithDecorator(){\r\n    final OpenAPI openAPI = getOpenAPI(SimpleResourceWithVendorAnnotation.class);\r\n    Assert.assertEquals(openAPI.getPaths().size(), 2);\r\n    final Operation get = getGet(openAPI, \"/{id}\");\r\n    Assert.assertNotNull(get);\r\n    Assert.assertEquals(get.getParameters().size(), 2);\r\n    final ApiResponse response = get.getResponses().get(RESPONSE_STATUS_401);\r\n    Assert.assertNotNull(response);\r\n    Assert.assertEquals(response.getDescription(), RESPONSE_DESCRIPTION);\r\n}"
}, {
	"Path": "io.vertx.core.impl.launcher.commands.ExecUtils.exitBecauseOfVertxDeploymentIssue",
	"Comment": "exits the jvm and indicate an issue during the deployment of the main verticle.",
	"Method": "void exitBecauseOfVertxDeploymentIssue(){\r\n    exit(VERTX_DEPLOYMENT_EXIT_CODE);\r\n}"
}, {
	"Path": "io.swagger.v3.jaxrs2.PetResourceTest.compare",
	"Comment": "compare a class that were read and parsed to a yaml against a yaml file.",
	"Method": "void compare(Class clazz,String source){\r\n    final String file = source + clazz.getSimpleName() + YAML_EXTENSION;\r\n    try {\r\n        compareAsYaml(clazz, getOpenAPIAsString(file));\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n        fail();\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.AesCtrHmacStreamingTest.testEncryptSingleBytes",
	"Comment": "one case that is sometimes problematic is writing single bytes to a stream. this testconstructs an outputstream from a writablebytechannel and tests whether encryption works onthis stream.",
	"Method": "void testEncryptSingleBytes(int keySizeInBytes,int plaintextSize){\r\n    if (TestUtil.shouldSkipTestWithAesKeySize(keySizeInBytes)) {\r\n        return;\r\n    }\r\n    int firstSegmentOffset = 0;\r\n    int segmentSize = 512;\r\n    int tagSizeInBytes = 12;\r\n    byte[] ikm = TestUtil.hexDecode(\"000102030405060708090a0b0c0d0e0f00112233445566778899aabbccddeeff\");\r\n    AesCtrHmacStreaming ags = new AesCtrHmacStreaming(ikm, \"HmacSha256\", keySizeInBytes, \"HmacSha256\", tagSizeInBytes, segmentSize, firstSegmentOffset);\r\n    StreamingTestUtil.testEncryptSingleBytes(ags, plaintextSize);\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateViewAdapter.onDetachedFromRecyclerView",
	"Comment": "called by recyclerview when it stops observing this adapter.",
	"Method": "void onDetachedFromRecyclerView(RecyclerView recyclerView){\r\n    super.onDetachedFromRecyclerView(recyclerView);\r\n    timer.removeCallbacks(cbloadmore);\r\n}"
}, {
	"Path": "io.vertx.core.net.NetTest.testWithSocks5ProxyAuth",
	"Comment": "test socks5 proxy for accessing arbitrary server port with authentication.",
	"Method": "void testWithSocks5ProxyAuth(){\r\n    NetClientOptions clientOptions = new NetClientOptions().setProxyOptions(new ProxyOptions().setType(ProxyType.SOCKS5).setPort(11080).setUsername(\"username\").setPassword(\"username\"));\r\n    NetClient client = vertx.createNetClient(clientOptions);\r\n    server.connectHandler(sock -> {\r\n    });\r\n    proxy = new SocksProxy(\"username\");\r\n    proxy.start(vertx);\r\n    server.listen(1234, \"localhost\", ar -> {\r\n        assertTrue(ar.succeeded());\r\n        client.connect(1234, \"localhost\", ar2 -> {\r\n            assertTrue(ar2.succeeded());\r\n            testComplete();\r\n        });\r\n    });\r\n    await();\r\n}"
}, {
	"Path": "org.b3log.symphony.service.VoteMgmtService.down",
	"Comment": "the specified user vote down the specified data entity with the specified data type.",
	"Method": "void down(String userId,String dataId,int dataType){\r\n    final int oldType = voteRepository.removeIfExists(userId, dataId, dataType);\r\n    if (Vote.DATA_TYPE_C_ARTICLE == dataType) {\r\n        final JSONObject article = articleRepository.get(dataId);\r\n        if (null == article) {\r\n            LOGGER.log(Level.ERROR, \"Not found article [id={0}] to vote down\", dataId);\r\n            return;\r\n        }\r\n        if (-1 == oldType) {\r\n            article.put(Article.ARTICLE_BAD_CNT, article.optInt(Article.ARTICLE_BAD_CNT) + 1);\r\n        } else if (Vote.TYPE_C_UP == oldType) {\r\n            article.put(Article.ARTICLE_GOOD_CNT, article.optInt(Article.ARTICLE_GOOD_CNT) - 1);\r\n            article.put(Article.ARTICLE_BAD_CNT, article.optInt(Article.ARTICLE_BAD_CNT) + 1);\r\n        }\r\n        final int ups = article.optInt(Article.ARTICLE_GOOD_CNT);\r\n        final int downs = article.optInt(Article.ARTICLE_BAD_CNT);\r\n        final long t = article.optLong(Keys.OBJECT_ID) / 1000;\r\n        final double redditScore = redditArticleScore(ups, downs, t);\r\n        article.put(Article.REDDIT_SCORE, redditScore);\r\n        updateTagArticleScore(article);\r\n        articleRepository.update(dataId, article);\r\n    } else if (Vote.DATA_TYPE_C_COMMENT == dataType) {\r\n        final JSONObject comment = commentRepository.get(dataId);\r\n        if (null == comment) {\r\n            LOGGER.log(Level.ERROR, \"Not found comment [id={0}] to vote up\", dataId);\r\n            return;\r\n        }\r\n        if (-1 == oldType) {\r\n            comment.put(Comment.COMMENT_BAD_CNT, comment.optInt(Comment.COMMENT_BAD_CNT) + 1);\r\n        } else if (Vote.TYPE_C_UP == oldType) {\r\n            comment.put(Comment.COMMENT_GOOD_CNT, comment.optInt(Comment.COMMENT_GOOD_CNT) - 1);\r\n            comment.put(Comment.COMMENT_BAD_CNT, comment.optInt(Comment.COMMENT_BAD_CNT) + 1);\r\n        }\r\n        final int ups = comment.optInt(Comment.COMMENT_GOOD_CNT);\r\n        final int downs = comment.optInt(Comment.COMMENT_BAD_CNT);\r\n        final double redditScore = redditCommentScore(ups, downs);\r\n        comment.put(Comment.COMMENT_SCORE, redditScore);\r\n        commentRepository.update(dataId, comment);\r\n    } else {\r\n        LOGGER.warn(\"Wrong data type [\" + dataType + \"]\");\r\n    }\r\n    final JSONObject vote = new JSONObject();\r\n    vote.put(Vote.USER_ID, userId);\r\n    vote.put(Vote.DATA_ID, dataId);\r\n    vote.put(Vote.TYPE, Vote.TYPE_C_DOWN);\r\n    vote.put(Vote.DATA_TYPE, dataType);\r\n    voteRepository.add(vote);\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateRecyclerView.setAdapterInternal",
	"Comment": "set a ultimateviewadapter or the subclass of ultimateviewadapter to the recyclerview",
	"Method": "void setAdapterInternal(UltimateViewAdapter adapter){\r\n    mAdapter = adapter;\r\n    if (mSwipeRefreshLayout != null)\r\n        mSwipeRefreshLayout.setRefreshing(false);\r\n    if (mAdapter != null)\r\n        mAdapter.registerAdapterDataObserver(new RecyclerView.AdapterDataObserver() {\r\n            @Override\r\n            public void onItemRangeChanged(int positionStart, int itemCount) {\r\n                super.onItemRangeChanged(positionStart, itemCount);\r\n                updateHelperDisplays();\r\n            }\r\n            @Override\r\n            public void onItemRangeInserted(int positionStart, int itemCount) {\r\n                super.onItemRangeInserted(positionStart, itemCount);\r\n                updateHelperDisplays();\r\n            }\r\n            @Override\r\n            public void onItemRangeRemoved(int positionStart, int itemCount) {\r\n                super.onItemRangeRemoved(positionStart, itemCount);\r\n                updateHelperDisplays();\r\n            }\r\n            @Override\r\n            public void onItemRangeMoved(int fromPosition, int toPosition, int itemCount) {\r\n                super.onItemRangeMoved(fromPosition, toPosition, itemCount);\r\n                updateHelperDisplays();\r\n            }\r\n            @Override\r\n            public void onChanged() {\r\n                super.onChanged();\r\n                updateHelperDisplays();\r\n            }\r\n        });\r\n    mRecyclerViewHelper = RecyclerViewPositionHelper.createHelper(mRecyclerView);\r\n    mAdapter.setEmptyViewPolicy(policy_empty);\r\n    mAdapter.setEmptyViewOnInitPolicy(policy_init);\r\n    if (mAdapter.getAdapterItemCount() == 0 && policy_init == UltimateRecyclerView.STARTWITH_OFFLINE_ITEMS) {\r\n        showEmptyView();\r\n    }\r\n    if (policy_init == UltimateRecyclerView.STARTWITH_ONLINE_ITEMS) {\r\n        hideEmptyView();\r\n    }\r\n    if (mAdapter.getCustomLoadMoreView() == null && mLoadMoreView != null) {\r\n        mAdapter.setCustomLoadMoreView(mLoadMoreView);\r\n        mAdapter.enableLoadMore(true);\r\n        mAdapter.notifyDataSetChanged();\r\n        mIsLoadMoreWidgetEnabled = true;\r\n    }\r\n    if (mHeader != null) {\r\n        mAdapter.setCustomHeaderView(mHeader);\r\n    }\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateRecyclerView.setAdapterInternal",
	"Comment": "set a ultimateviewadapter or the subclass of ultimateviewadapter to the recyclerview",
	"Method": "void setAdapterInternal(UltimateViewAdapter adapter){\r\n    super.onItemRangeChanged(positionStart, itemCount);\r\n    updateHelperDisplays();\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateRecyclerView.setAdapterInternal",
	"Comment": "set a ultimateviewadapter or the subclass of ultimateviewadapter to the recyclerview",
	"Method": "void setAdapterInternal(UltimateViewAdapter adapter){\r\n    super.onItemRangeInserted(positionStart, itemCount);\r\n    updateHelperDisplays();\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateRecyclerView.setAdapterInternal",
	"Comment": "set a ultimateviewadapter or the subclass of ultimateviewadapter to the recyclerview",
	"Method": "void setAdapterInternal(UltimateViewAdapter adapter){\r\n    super.onItemRangeRemoved(positionStart, itemCount);\r\n    updateHelperDisplays();\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateRecyclerView.setAdapterInternal",
	"Comment": "set a ultimateviewadapter or the subclass of ultimateviewadapter to the recyclerview",
	"Method": "void setAdapterInternal(UltimateViewAdapter adapter){\r\n    super.onItemRangeMoved(fromPosition, toPosition, itemCount);\r\n    updateHelperDisplays();\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateRecyclerView.setAdapterInternal",
	"Comment": "set a ultimateviewadapter or the subclass of ultimateviewadapter to the recyclerview",
	"Method": "void setAdapterInternal(UltimateViewAdapter adapter){\r\n    super.onChanged();\r\n    updateHelperDisplays();\r\n}"
}, {
	"Path": "io.vertx.core.net.KeyCertOptions.getKeyManagerFactory",
	"Comment": "create and return the key manager factory for these options.the returned key manager factory should be already initialized and ready to use.",
	"Method": "KeyManagerFactory getKeyManagerFactory(Vertx vertx){\r\n    return KeyStoreHelper.create((VertxInternal) vertx, this).getKeyMgrFactory();\r\n}"
}, {
	"Path": "io.swagger.v3.jaxrs2.PetResourceTest.findClasses",
	"Comment": "recursive method used to find all classes in a given directory and subdirectories.",
	"Method": "List<Class> findClasses(File directory,String packageName){\r\n    final List<Class> classes = new ArrayList();\r\n    if (!directory.exists()) {\r\n        return classes;\r\n    }\r\n    final File[] files = directory.listFiles();\r\n    if (files != null) {\r\n        for (final File file : files) {\r\n            if (file.isDirectory()) {\r\n                assert !file.getName().contains(\".\");\r\n                classes.addAll(findClasses(file, packageName + \".\" + file.getName()));\r\n            } else if (file.getName().endsWith(\".class\")) {\r\n                classes.add(Class.forName(packageName + '.' + file.getName().substring(0, file.getName().length() - 6)));\r\n            }\r\n        }\r\n    }\r\n    return classes;\r\n}"
}, {
	"Path": "org.b3log.symphony.service.ArticleQueryService.genArticleAuthor",
	"Comment": "generates the specified article author name and thumbnail url.",
	"Method": "void genArticleAuthor(int avatarViewMode,JSONObject article){\r\n    final String authorId = article.optString(Article.ARTICLE_AUTHOR_ID);\r\n    final JSONObject author = userRepository.get(authorId);\r\n    article.put(Article.ARTICLE_T_AUTHOR, author);\r\n    if (Article.ARTICLE_ANONYMOUS_C_ANONYMOUS == article.optInt(Article.ARTICLE_ANONYMOUS)) {\r\n        article.put(Article.ARTICLE_T_AUTHOR_NAME, UserExt.ANONYMOUS_USER_NAME);\r\n        article.put(Article.ARTICLE_T_AUTHOR_THUMBNAIL_URL + \"210\", avatarQueryService.getDefaultAvatarURL(\"210\"));\r\n        article.put(Article.ARTICLE_T_AUTHOR_THUMBNAIL_URL + \"48\", avatarQueryService.getDefaultAvatarURL(\"48\"));\r\n        article.put(Article.ARTICLE_T_AUTHOR_THUMBNAIL_URL + \"20\", avatarQueryService.getDefaultAvatarURL(\"20\"));\r\n    } else {\r\n        article.put(Article.ARTICLE_T_AUTHOR_NAME, author.optString(User.USER_NAME));\r\n        article.put(Article.ARTICLE_T_AUTHOR_THUMBNAIL_URL + \"210\", avatarQueryService.getAvatarURLByUser(avatarViewMode, author, \"210\"));\r\n        article.put(Article.ARTICLE_T_AUTHOR_THUMBNAIL_URL + \"48\", avatarQueryService.getAvatarURLByUser(avatarViewMode, author, \"48\"));\r\n        article.put(Article.ARTICLE_T_AUTHOR_THUMBNAIL_URL + \"20\", avatarQueryService.getAvatarURLByUser(avatarViewMode, author, \"20\"));\r\n    }\r\n}"
}, {
	"Path": "com.vip.vjtools.vjkit.collection.type.SortedArrayList.addAll",
	"Comment": "add all of the elements in the given collection to this list.",
	"Method": "boolean addAll(Collection<? extends E> c,boolean addAll,int index,Collection<? extends E> c){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.zxing.pdf417.decoder.BarcodeValue.getValue",
	"Comment": "determines the maximum occurrence of a set value and returns all values which were set with this occurrence.",
	"Method": "int[] getValue(){\r\n    int maxConfidence = -1;\r\n    Collection<Integer> result = new ArrayList();\r\n    for (Entry<Integer, Integer> entry : values.entrySet()) {\r\n        if (entry.getValue() > maxConfidence) {\r\n            maxConfidence = entry.getValue();\r\n            result.clear();\r\n            result.add(entry.getKey());\r\n        } else if (entry.getValue() == maxConfidence) {\r\n            result.add(entry.getKey());\r\n        }\r\n    }\r\n    return PDF417Common.toIntArray(result);\r\n}"
}, {
	"Path": "org.b3log.symphony.service.CommentMgmtService.thankComment",
	"Comment": "a user specified by the given sender id thanks the author of a comment specified by the given comment id.",
	"Method": "void thankComment(String commentId,String senderId){\r\n    try {\r\n        final JSONObject comment = commentRepository.get(commentId);\r\n        if (null == comment) {\r\n            return;\r\n        }\r\n        if (Comment.COMMENT_STATUS_C_INVALID == comment.optInt(Comment.COMMENT_STATUS)) {\r\n            return;\r\n        }\r\n        final JSONObject sender = userRepository.get(senderId);\r\n        if (null == sender) {\r\n            return;\r\n        }\r\n        if (UserExt.USER_STATUS_C_VALID != sender.optInt(UserExt.USER_STATUS)) {\r\n            return;\r\n        }\r\n        final String receiverId = comment.optString(Comment.COMMENT_AUTHOR_ID);\r\n        final JSONObject receiver = userRepository.get(receiverId);\r\n        if (null == receiver) {\r\n            return;\r\n        }\r\n        if (UserExt.USER_STATUS_C_VALID != receiver.optInt(UserExt.USER_STATUS)) {\r\n            return;\r\n        }\r\n        if (receiverId.equals(senderId)) {\r\n            throw new ServiceException(langPropsService.get(\"thankSelfLabel\"));\r\n        }\r\n        final int rewardPoint = Symphonys.getInt(\"pointThankComment\");\r\n        if (rewardQueryService.isRewarded(senderId, commentId, Reward.TYPE_C_COMMENT)) {\r\n            return;\r\n        }\r\n        final String rewardId = Ids.genTimeMillisId();\r\n        if (Comment.COMMENT_ANONYMOUS_C_PUBLIC == comment.optInt(Comment.COMMENT_ANONYMOUS)) {\r\n            final boolean succ = null != pointtransferMgmtService.transfer(senderId, receiverId, Pointtransfer.TRANSFER_TYPE_C_COMMENT_REWARD, rewardPoint, rewardId, System.currentTimeMillis(), \"\");\r\n            if (!succ) {\r\n                throw new ServiceException(langPropsService.get(\"transferFailLabel\"));\r\n            }\r\n        }\r\n        final JSONObject reward = new JSONObject();\r\n        reward.put(Keys.OBJECT_ID, rewardId);\r\n        reward.put(Reward.SENDER_ID, senderId);\r\n        reward.put(Reward.DATA_ID, commentId);\r\n        reward.put(Reward.TYPE, Reward.TYPE_C_COMMENT);\r\n        rewardMgmtService.addReward(reward);\r\n        final JSONObject notification = new JSONObject();\r\n        notification.put(Notification.NOTIFICATION_USER_ID, receiverId);\r\n        notification.put(Notification.NOTIFICATION_DATA_ID, rewardId);\r\n        notificationMgmtService.addCommentThankNotification(notification);\r\n        livenessMgmtService.incLiveness(senderId, Liveness.LIVENESS_THANK);\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Thanks a comment[id=\" + commentId + \"] failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.common.GridSampler.setGridSampler",
	"Comment": "sets the implementation of gridsampler used by the library. one globalinstance is stored, which may sound problematic. but, the implementation providedought to be appropriate for the entire platform, and all uses of this libraryin the whole lifetime of the jvm. for instance, an android activity can swap inan implementation that takes advantage of native platform libraries.",
	"Method": "void setGridSampler(GridSampler newGridSampler){\r\n    gridSampler = newGridSampler;\r\n}"
}, {
	"Path": "com.yalantis.ucrop.view.CropImageView.setupInitialImagePosition",
	"Comment": "this method calculates initial image position so it is positioned properly.then it sets those values to the current image matrix.",
	"Method": "void setupInitialImagePosition(float drawableWidth,float drawableHeight){\r\n    float cropRectWidth = mCropRect.width();\r\n    float cropRectHeight = mCropRect.height();\r\n    float widthScale = mCropRect.width() / drawableWidth;\r\n    float heightScale = mCropRect.height() / drawableHeight;\r\n    float initialMinScale = Math.max(widthScale, heightScale);\r\n    float tw = (cropRectWidth - drawableWidth * initialMinScale) / 2.0f + mCropRect.left;\r\n    float th = (cropRectHeight - drawableHeight * initialMinScale) / 2.0f + mCropRect.top;\r\n    mCurrentImageMatrix.reset();\r\n    mCurrentImageMatrix.postScale(initialMinScale, initialMinScale);\r\n    mCurrentImageMatrix.postTranslate(tw, th);\r\n    setImageMatrix(mCurrentImageMatrix);\r\n}"
}, {
	"Path": "com.google.zxing.client.android.result.ResultHandler.getDisplayContents",
	"Comment": "create a possibly styled string for the contents of the current barcode.",
	"Method": "CharSequence getDisplayContents(){\r\n    String contents = result.getDisplayResult();\r\n    return contents.replace(\"\\r\", \"\");\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.EllipticCurves.ecPointDecode",
	"Comment": "decodes an encoded point on an elliptic curve. this method checks that the encoded point is onthe curve.",
	"Method": "ECPoint ecPointDecode(EllipticCurve curve,PointFormatType format,byte[] encoded){\r\n    return pointDecode(curve, format, encoded);\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.uiUtils.RecyclerViewPositionHelper.findLastVisibleItemPosition",
	"Comment": "returns the adapter position of the last visible view. this position does not includeadapter changes that were dispatched after the last layout pass.",
	"Method": "int findLastVisibleItemPosition(){\r\n    final View child = findOneVisibleChild(layoutManager.getChildCount() - 1, -1, false, true);\r\n    return child == null ? RecyclerView.NO_POSITION : recyclerView.getChildAdapterPosition(child);\r\n}"
}, {
	"Path": "com.google.zxing.datamatrix.encoder.ErrorCorrection.encodeECC200",
	"Comment": "creates the ecc200 error correction for an encoded message.",
	"Method": "String encodeECC200(String codewords,SymbolInfo symbolInfo){\r\n    if (codewords.length() != symbolInfo.getDataCapacity()) {\r\n        throw new IllegalArgumentException(\"The number of codewords does not match the selected symbol\");\r\n    }\r\n    StringBuilder sb = new StringBuilder(symbolInfo.getDataCapacity() + symbolInfo.getErrorCodewords());\r\n    sb.append(codewords);\r\n    int blockCount = symbolInfo.getInterleavedBlockCount();\r\n    if (blockCount == 1) {\r\n        String ecc = createECCBlock(codewords, symbolInfo.getErrorCodewords());\r\n        sb.append(ecc);\r\n    } else {\r\n        sb.setLength(sb.capacity());\r\n        int[] dataSizes = new int[blockCount];\r\n        int[] errorSizes = new int[blockCount];\r\n        int[] startPos = new int[blockCount];\r\n        for (int i = 0; i < blockCount; i++) {\r\n            dataSizes[i] = symbolInfo.getDataLengthForInterleavedBlock(i + 1);\r\n            errorSizes[i] = symbolInfo.getErrorLengthForInterleavedBlock(i + 1);\r\n            startPos[i] = 0;\r\n            if (i > 0) {\r\n                startPos[i] = startPos[i - 1] + dataSizes[i];\r\n            }\r\n        }\r\n        for (int block = 0; block < blockCount; block++) {\r\n            StringBuilder temp = new StringBuilder(dataSizes[block]);\r\n            for (int d = block; d < symbolInfo.getDataCapacity(); d += blockCount) {\r\n                temp.append(codewords.charAt(d));\r\n            }\r\n            String ecc = createECCBlock(temp.toString(), errorSizes[block]);\r\n            int pos = 0;\r\n            for (int e = block; e < errorSizes[block] * blockCount; e += blockCount) {\r\n                sb.setCharAt(symbolInfo.getDataCapacity() + e, ecc.charAt(pos++));\r\n            }\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "io.vertx.core.spi.metrics.TCPMetrics.connected",
	"Comment": "called when a client has connected, which is applicable for tcp connections.the remote name of the client is a best effort to provide the name of the remote host, i.e if the nameis specified at creation time, this name will be used otherwise it will be the remote address.",
	"Method": "S connected(SocketAddress remoteAddress,String remoteName){\r\n    return null;\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.AesCtrHmacStreaming.expectedCiphertextSize",
	"Comment": "returns the expected size of the ciphertext for a given plaintext the returned value includesthe header and offset.",
	"Method": "long expectedCiphertextSize(long plaintextSize){\r\n    long offset = getCiphertextOffset();\r\n    long fullSegments = (plaintextSize + offset) / plaintextSegmentSize;\r\n    long ciphertextSize = fullSegments * ciphertextSegmentSize;\r\n    long lastSegmentSize = (plaintextSize + offset) % plaintextSegmentSize;\r\n    if (lastSegmentSize > 0) {\r\n        ciphertextSize += lastSegmentSize + tagSizeInBytes;\r\n    }\r\n    return ciphertextSize;\r\n}"
}, {
	"Path": "com.marshalchen.ultimaterecyclerview.UltimateRecyclerView.showEmptyView",
	"Comment": "show the custom or default empty viewyou can customize it as loading view",
	"Method": "boolean showEmptyView(){\r\n    if (mEmpty != null && mEmptyView != null && mAdapter != null) {\r\n        if (mAdapter.getEmptyViewPolicy() == EMPTY_CLEAR_ALL || mAdapter.getEmptyViewPolicy() == EMPTY_KEEP_HEADER) {\r\n            mEmpty.setVisibility(View.VISIBLE);\r\n            if (mEmptyViewListener != null) {\r\n                mEmptyViewListener.onEmptyViewShow(mEmptyView);\r\n            }\r\n        }\r\n        return true;\r\n    } else {\r\n        Log.d(VIEW_LOG_TAG, \"it is unable to show empty view\");\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.b3log.symphony.service.ArticleMgmtService.thank",
	"Comment": "a user specified by the given sender id thanks the author of an article specified by the given article id.",
	"Method": "void thank(String articleId,String senderId){\r\n    try {\r\n        final JSONObject article = articleRepository.get(articleId);\r\n        if (null == article) {\r\n            return;\r\n        }\r\n        if (Article.ARTICLE_STATUS_C_INVALID == article.optInt(Article.ARTICLE_STATUS)) {\r\n            return;\r\n        }\r\n        final JSONObject sender = userRepository.get(senderId);\r\n        if (null == sender) {\r\n            return;\r\n        }\r\n        if (UserExt.USER_STATUS_C_VALID != sender.optInt(UserExt.USER_STATUS)) {\r\n            return;\r\n        }\r\n        final String receiverId = article.optString(Article.ARTICLE_AUTHOR_ID);\r\n        final JSONObject receiver = userRepository.get(receiverId);\r\n        if (null == receiver) {\r\n            return;\r\n        }\r\n        if (UserExt.USER_STATUS_C_VALID != receiver.optInt(UserExt.USER_STATUS)) {\r\n            return;\r\n        }\r\n        if (receiverId.equals(senderId)) {\r\n            return;\r\n        }\r\n        if (rewardQueryService.isRewarded(senderId, articleId, Reward.TYPE_C_THANK_ARTICLE)) {\r\n            return;\r\n        }\r\n        final String thankId = Ids.genTimeMillisId();\r\n        if (Article.ARTICLE_ANONYMOUS_C_PUBLIC == article.optInt(Article.ARTICLE_ANONYMOUS)) {\r\n            final boolean succ = null != pointtransferMgmtService.transfer(senderId, receiverId, Pointtransfer.TRANSFER_TYPE_C_ARTICLE_THANK, Pointtransfer.TRANSFER_SUM_C_ARTICLE_THANK, thankId, System.currentTimeMillis(), \"\");\r\n            if (!succ) {\r\n                throw new ServiceException();\r\n            }\r\n        }\r\n        final JSONObject reward = new JSONObject();\r\n        reward.put(Keys.OBJECT_ID, thankId);\r\n        reward.put(Reward.SENDER_ID, senderId);\r\n        reward.put(Reward.DATA_ID, articleId);\r\n        reward.put(Reward.TYPE, Reward.TYPE_C_THANK_ARTICLE);\r\n        rewardMgmtService.addReward(reward);\r\n        final JSONObject notification = new JSONObject();\r\n        notification.put(Notification.NOTIFICATION_USER_ID, receiverId);\r\n        notification.put(Notification.NOTIFICATION_DATA_ID, thankId);\r\n        notificationMgmtService.addArticleThankNotification(notification);\r\n        livenessMgmtService.incLiveness(senderId, Liveness.LIVENESS_REWARD);\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Thanks an article[id=\" + articleId + \"] failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel.reachedEnd",
	"Comment": "returns true if plaintextpositon is at the end of the fileand this has been verified, by decrypting the last segment.",
	"Method": "boolean reachedEnd(){\r\n    return (isCurrentSegmentDecrypted && currentSegmentNr == numberOfSegments - 1 && plaintextSegment.remaining() == 0);\r\n}"
}, {
	"Path": "io.vertx.core.dns.impl.decoder.StartOfAuthorityRecord.refreshTime",
	"Comment": "returns time between refreshes for secondary name servers.",
	"Method": "int refreshTime(){\r\n    return refreshTime;\r\n}"
}, {
	"Path": "io.vertx.core.impl.FutureImpl.result",
	"Comment": "the result of the operation. this will be null if the operation failed.",
	"Method": "T result(){\r\n    return result;\r\n}"
}, {
	"Path": "io.vertx.core.net.OpenSSLEngineOptions.setSessionCacheEnabled",
	"Comment": "set whether session cache is enabled in open ssl session server context",
	"Method": "OpenSSLEngineOptions setSessionCacheEnabled(boolean sessionCacheEnabled){\r\n    this.sessionCacheEnabled = sessionCacheEnabled;\r\n    return this;\r\n}"
}, {
	"Path": "io.vertx.core.Vertx.vertx",
	"Comment": "creates a non clustered instance using the specified options",
	"Method": "Vertx vertx(Vertx vertx,VertxOptions options){\r\n    return factory.vertx(options);\r\n}"
}, {
	"Path": "com.google.zxing.MultiFormatReader.decode",
	"Comment": "decode an image using the hints provided. does not honor existing state.",
	"Method": "Result decode(BinaryBitmap image,Result decode,BinaryBitmap image,Map<DecodeHintType, ?> hints){\r\n    setHints(hints);\r\n    return decodeInternal(image);\r\n}"
}, {
	"Path": "io.swagger.v3.jaxrs2.resources.SubResourceHead.getAnyClass",
	"Comment": "this path is expected to be skipped as resource class is unknown here.",
	"Method": "Class<T> getAnyClass(){\r\n    return null;\r\n}"
}, {
	"Path": "com.google.zxing.common.GlobalHistogramBinarizer.getBlackRow",
	"Comment": "applies simple sharpening to the row data to improve performance of the 1d readers.",
	"Method": "BitArray getBlackRow(int y,BitArray row){\r\n    LuminanceSource source = getLuminanceSource();\r\n    int width = source.getWidth();\r\n    if (row == null || row.getSize() < width) {\r\n        row = new BitArray(width);\r\n    } else {\r\n        row.clear();\r\n    }\r\n    initArrays(width);\r\n    byte[] localLuminances = source.getRow(y, luminances);\r\n    int[] localBuckets = buckets;\r\n    for (int x = 0; x < width; x++) {\r\n        localBuckets[(localLuminances[x] & 0xff) >> LUMINANCE_SHIFT]++;\r\n    }\r\n    int blackPoint = estimateBlackPoint(localBuckets);\r\n    if (width < 3) {\r\n        for (int x = 0; x < width; x++) {\r\n            if ((localLuminances[x] & 0xff) < blackPoint) {\r\n                row.set(x);\r\n            }\r\n        }\r\n    } else {\r\n        int left = localLuminances[0] & 0xff;\r\n        int center = localLuminances[1] & 0xff;\r\n        for (int x = 1; x < width - 1; x++) {\r\n            int right = localLuminances[x + 1] & 0xff;\r\n            if (((center * 4) - left - right) / 2 < blackPoint) {\r\n                row.set(x);\r\n            }\r\n            left = center;\r\n            center = right;\r\n        }\r\n    }\r\n    return row;\r\n}"
}, {
	"Path": "io.vertx.core.http.HttpServerOptions.perFrameWebsocketCompressionSupported",
	"Comment": "get whether websocket deflate frame compression is supported",
	"Method": "boolean perFrameWebsocketCompressionSupported(){\r\n    return this.websocketDeflateFrameCompressionSupported;\r\n}"
}, {
	"Path": "io.vertx.core.json.JsonObject.put",
	"Comment": "put another json object into the json object with the specified key.",
	"Method": "JsonObject put(String key,Enum value,JsonObject put,String key,CharSequence value,JsonObject put,String key,String value,JsonObject put,String key,Integer value,JsonObject put,String key,Long value,JsonObject put,String key,Double value,JsonObject put,String key,Float value,JsonObject put,String key,Boolean value,JsonObject put,String key,JsonObject value,JsonObject put,String key,JsonArray value,JsonObject put,String key,byte[] value,JsonObject put,String key,Instant value,JsonObject put,String key,Object value){\r\n    Objects.requireNonNull(key);\r\n    value = Json.checkAndCopy(value, false);\r\n    map.put(key, value);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.crypto.tink.subtle.EllipticCurves.validateSharedSecret",
	"Comment": "checks that the shared secret is on the curve of the private key, to prevent arithmetic errorsor fault attacks.",
	"Method": "void validateSharedSecret(byte[] secret,ECPrivateKey privateKey){\r\n    EllipticCurve privateKeyCurve = privateKey.getParams().getCurve();\r\n    BigInteger x = new BigInteger(1, secret);\r\n    if (x.signum() == -1 || x.compareTo(getModulus(privateKeyCurve)) != -1) {\r\n        throw new GeneralSecurityException(\"shared secret is out of range\");\r\n    }\r\n    getY(x, true, privateKeyCurve);\r\n}"
}, {
	"Path": "us.codecraft.webmagic.Site.setCharset",
	"Comment": "set charset of page manually.when charset is not set or set to null, it can be auto detected by http header.",
	"Method": "Site setCharset(String charset){\r\n    this.charset = charset;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.crypto.tink.StreamingTestUtil.testEncryptDecryptWithStream",
	"Comment": "encrypts and decrypts some plaintext in a stream and checks that the expected plaintext isreturned.",
	"Method": "void testEncryptDecryptWithStream(StreamingAead ags,int firstSegmentOffset,int plaintextSize,int chunkSize){\r\n    byte[] aad = TestUtil.hexDecode(\"aabbccddeeff\");\r\n    byte[] plaintext = generatePlaintext(plaintextSize);\r\n    byte[] ciphertext = encryptWithStream(ags, plaintext, aad, firstSegmentOffset);\r\n    InputStream ctStream = new ByteArrayInputStream(ciphertext);\r\n    ctStream.read(new byte[firstSegmentOffset]);\r\n    InputStream ptStream = ags.newDecryptingStream(ctStream, aad);\r\n    int decryptedSize = 0;\r\n    while (true) {\r\n        byte[] chunk = new byte[chunkSize];\r\n        int read = ptStream.read(chunk);\r\n        if (read == -1) {\r\n            break;\r\n        }\r\n        byte[] expected = Arrays.copyOfRange(plaintext, decryptedSize, decryptedSize + read);\r\n        TestUtil.assertByteArrayEquals(expected, Arrays.copyOf(chunk, read));\r\n        decryptedSize += read;\r\n        if (read < chunkSize && decryptedSize < plaintextSize) {\r\n            fail(\"read did not return enough bytes\");\r\n        }\r\n    }\r\n    assertEquals(\"Size of decryption does not match plaintext\", plaintextSize, decryptedSize);\r\n}"
}]