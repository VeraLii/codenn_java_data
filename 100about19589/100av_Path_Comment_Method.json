[{
	"Path": "android.icu.util.TimeZoneRule.isEquivalentTo",
	"Comment": "returns if this rule represents the same rule and offsets as another.when two timezonerule objects differ only its names, this method returnstrue.",
	"Method": "boolean isEquivalentTo(TimeZoneRule other){\r\n    if (rawOffset == other.rawOffset && dstSavings == other.dstSavings) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "android.icu.text.Transliterator.getAvailableVariants",
	"Comment": "returns an enumeration over the variant names of registeredtransliterators having a given source name and target name.",
	"Method": "Enumeration<String> getAvailableVariants(String source,String target){\r\n    return registry.getAvailableVariants(source, target);\r\n}"
}, {
	"Path": "android.icu.text.BreakIterator.getWordInstance",
	"Comment": "returns a new instance of breakiterator that locates word boundaries.",
	"Method": "BreakIterator getWordInstance(BreakIterator getWordInstance,Locale where,BreakIterator getWordInstance,ULocale where){\r\n    return getBreakInstance(where, KIND_WORD);\r\n}"
}, {
	"Path": "android.icu.impl.OlsonTimeZone.getDSTSavings",
	"Comment": "timezone apireturns the amount of time to be added to local standard timeto get local wall clock time.",
	"Method": "int getDSTSavings(){\r\n    if (finalZone != null) {\r\n        return finalZone.getDSTSavings();\r\n    }\r\n    return super.getDSTSavings();\r\n}"
}, {
	"Path": "android.icu.impl.PluralRulesLoader.getPluralBundle",
	"Comment": "return the plurals resource. note missingresourceexception is unchecked,listed here for clarity. callers should handle this exception.",
	"Method": "UResourceBundle getPluralBundle(){\r\n    return ICUResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, \"plurals\", ICUResourceBundle.ICU_DATA_CLASS_LOADER, true);\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.getName",
	"Comment": "returns the name of the class represented by this descriptor.",
	"Method": "String getName(){\r\n    return className;\r\n}"
}, {
	"Path": "android.icu.text.DateFormat.format",
	"Comment": "formats a time object into a time string. examples of time objectsare a time value expressed in milliseconds and a date object.",
	"Method": "StringBuffer format(Object obj,StringBuffer toAppendTo,FieldPosition fieldPosition,StringBuffer format,Calendar cal,StringBuffer toAppendTo,FieldPosition fieldPosition,StringBuffer format,Date date,StringBuffer toAppendTo,FieldPosition fieldPosition,String format,Date date){\r\n    return format(date, new StringBuffer(64), new FieldPosition(0)).toString();\r\n}"
}, {
	"Path": "android.icu.impl.CharacterIteration.next32",
	"Comment": "move the iterator forward to the next code point, and return that code point,leaving the iterator positioned at char returned.for supplementary chars, the iterator is left positioned at the lead surrogate.",
	"Method": "int next32(CharacterIterator ci){\r\n    int c = ci.current();\r\n    if (c >= UTF16.LEAD_SURROGATE_MIN_VALUE && c <= UTF16.LEAD_SURROGATE_MAX_VALUE) {\r\n        c = ci.next();\r\n        if (c < UTF16.TRAIL_SURROGATE_MIN_VALUE || c > UTF16.TRAIL_SURROGATE_MAX_VALUE) {\r\n            ci.previous();\r\n        }\r\n    }\r\n    c = ci.next();\r\n    if (c >= UTF16.LEAD_SURROGATE_MIN_VALUE) {\r\n        c = nextTrail32(ci, c);\r\n    }\r\n    if (c >= UTF16.SUPPLEMENTARY_MIN_VALUE && c != DONE32) {\r\n        ci.previous();\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "android.icu.impl.ZoneMeta.getCanonicalCountry",
	"Comment": "return the canonical country code for this tzid.if we have none, or if the time zoneis not associated with a country or unknown, return null. when the given zone is theprimary zone of the country, true is set to isprimary.",
	"Method": "String getCanonicalCountry(String tzid,String getCanonicalCountry,String tzid,Output<Boolean> isPrimary){\r\n    isPrimary.value = Boolean.FALSE;\r\n    String country = getRegion(tzid);\r\n    if (country != null && country.equals(kWorld)) {\r\n        return null;\r\n    }\r\n    Boolean singleZone = SINGLE_COUNTRY_CACHE.get(tzid);\r\n    if (singleZone == null) {\r\n        Set<String> ids = TimeZone.getAvailableIDs(SystemTimeZoneType.CANONICAL_LOCATION, country, null);\r\n        assert (ids.size() >= 1);\r\n        singleZone = Boolean.valueOf(ids.size() <= 1);\r\n        SINGLE_COUNTRY_CACHE.put(tzid, singleZone);\r\n    }\r\n    if (singleZone) {\r\n        isPrimary.value = Boolean.TRUE;\r\n    } else {\r\n        try {\r\n            UResourceBundle bundle = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, \"metaZones\");\r\n            UResourceBundle primaryZones = bundle.get(\"primaryZones\");\r\n            String primaryZone = primaryZones.getString(country);\r\n            if (tzid.equals(primaryZone)) {\r\n                isPrimary.value = Boolean.TRUE;\r\n            } else {\r\n                String canonicalID = getCanonicalCLDRID(tzid);\r\n                if (canonicalID != null && canonicalID.equals(primaryZone)) {\r\n                    isPrimary.value = Boolean.TRUE;\r\n                }\r\n            }\r\n        } catch (MissingResourceException e) {\r\n        }\r\n    }\r\n    return country;\r\n}"
}, {
	"Path": "android.icu.util.Calendar.setLocale",
	"Comment": "set information about the locales that were used to create thisobject.if the object was not constructed from locale data,both arguments should be set to null.otherwise, neithershould be null.the actual locale must be at the same level orless specific than the valid locale.this method is intendedfor use by factories or other entities that create objects ofthis class.",
	"Method": "void setLocale(ULocale valid,ULocale actual){\r\n    if ((valid == null) != (actual == null)) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    this.validLocale = valid;\r\n    this.actualLocale = actual;\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.setSuperclass",
	"Comment": "set the descriptor for the superclass of the class described by thereceiver",
	"Method": "void setSuperclass(ObjectStreamClass c){\r\n    superclass = c;\r\n}"
}, {
	"Path": "android.icu.text.CanonicalIterator.getSource",
	"Comment": "gets the nfd form of the current source we are iterating over.",
	"Method": "String getSource(){\r\n    return source;\r\n}"
}, {
	"Path": "android.icu.text.DateFormatSymbols.readObject",
	"Comment": "3.8 or older version did not have localized gmt formatpatterns.",
	"Method": "void readObject(ObjectInputStream stream){\r\n    stream.defaultReadObject();\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.setDecimalSeparator",
	"Comment": "sets the character used for decimal sign. different for french, etc.",
	"Method": "void setDecimalSeparator(char decimalSeparator){\r\n    this.decimalSeparator = decimalSeparator;\r\n    this.decimalSeparatorString = String.valueOf(decimalSeparator);\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.complementAll",
	"Comment": "complements in this set all elements contained in the specifiedset.any character in the other set will be removed if it isin this set, or will be added if it is not in this set.",
	"Method": "UnicodeSet complementAll(CharSequence s,UnicodeSet complementAll,UnicodeSet c){\r\n    checkFrozen();\r\n    xor(c.list, c.len, 0);\r\n    SortedSetRelation.doOperation(strings, SortedSetRelation.COMPLEMENTALL, c.strings);\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.impl.LocaleIDParser.atTerminator",
	"Comment": "returns true if the character at index in the id is a terminator.",
	"Method": "boolean atTerminator(){\r\n    return index >= id.length || isTerminator(id[index]);\r\n}"
}, {
	"Path": "android.icu.text.NumberFormat.setParseIntegerOnly",
	"Comment": "sets whether or not numbers should be parsed as integers only.",
	"Method": "void setParseIntegerOnly(boolean value){\r\n    parseIntegerOnly = value;\r\n}"
}, {
	"Path": "android.icu.text.TransliteratorRegistry.getAvailableTargets",
	"Comment": "returns an enumeration over visible target names for the givensource.",
	"Method": "Enumeration<String> getAvailableTargets(String source){\r\n    CaseInsensitiveString cisrc = new CaseInsensitiveString(source);\r\n    Map<CaseInsensitiveString, List<CaseInsensitiveString>> targets = specDAG.get(cisrc);\r\n    if (targets == null) {\r\n        return new IDEnumeration(null);\r\n    }\r\n    return new IDEnumeration(Collections.enumeration(targets.keySet()));\r\n}"
}, {
	"Path": "android.icu.impl.LocaleIDParser.skipUntilTerminatorOrIDSeparator",
	"Comment": "advance index until the next terminator or id separator, and leave it there.",
	"Method": "void skipUntilTerminatorOrIDSeparator(){\r\n    while (!isTerminatorOrIDSeparator(next())) ;\r\n    --index;\r\n}"
}, {
	"Path": "android.icu.text.RelativeDateTimeFormatter.getAbsoluteUnitString",
	"Comment": "gets the string value from qualitativeunitmap with fallback based on style.",
	"Method": "String getAbsoluteUnitString(Style style,AbsoluteUnit unit,Direction direction){\r\n    EnumMap<AbsoluteUnit, EnumMap<Direction, String>> unitMap;\r\n    EnumMap<Direction, String> dirMap;\r\n    do {\r\n        unitMap = qualitativeUnitMap.get(style);\r\n        if (unitMap != null) {\r\n            dirMap = unitMap.get(unit);\r\n            if (dirMap != null) {\r\n                String result = dirMap.get(direction);\r\n                if (result != null) {\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n    } while ((style = fallbackCache[style.ordinal()]) != null);\r\n    return null;\r\n}"
}, {
	"Path": "java.io.File.getTotalSpace",
	"Comment": "returns the total size in bytes of the partition containing this path.returns 0 if this path does not exist.",
	"Method": "long getTotalSpace(){\r\n    try {\r\n        StructStatVfs sb = Libcore.os.statvfs(path);\r\n        return sb.f_blocks * sb.f_bsize;\r\n    } catch (ErrnoException errnoException) {\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.ReplaceableContextIterator.replace",
	"Comment": "replace the current code point by its case mapping,and update the indexes.",
	"Method": "int replace(String text){\r\n    int delta = text.length() - (cpLimit - cpStart);\r\n    rep.replace(cpStart, cpLimit, text);\r\n    cpLimit += delta;\r\n    limit += delta;\r\n    contextLimit += delta;\r\n    return delta;\r\n}"
}, {
	"Path": "android.icu.util.CompactByteArray.getIndexArray",
	"Comment": "for internal use only.do not modify the result, the behavior ofmodified results are undefined.",
	"Method": "char[] getIndexArray(){\r\n    return indices;\r\n}"
}, {
	"Path": "android.icu.text.UTF16.getSingleCodePoint",
	"Comment": "utility for getting a code point from a charsequence that contains exactly one code point.",
	"Method": "int getSingleCodePoint(CharSequence s){\r\n    if (s == null || s.length() == 0) {\r\n        return -1;\r\n    } else if (s.length() == 1) {\r\n        return s.charAt(0);\r\n    } else if (s.length() > 2) {\r\n        return -1;\r\n    }\r\n    int cp = Character.codePointAt(s, 0);\r\n    if (cp > 0xFFFF) {\r\n        return cp;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "java.text.StringCharacterIterator.current",
	"Comment": "returns the character at the current index in the source string.",
	"Method": "char current(){\r\n    if (offset == end) {\r\n        return DONE;\r\n    }\r\n    return string.charAt(offset);\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.getFields",
	"Comment": "returns a collection of field descriptors for the serialized fields ofthe class represented by this class descriptor.",
	"Method": "ObjectStreamField[] getFields(){\r\n    copyFieldAttributes();\r\n    return loadFields == null ? fields().clone() : loadFields.clone();\r\n}"
}, {
	"Path": "android.icu.util.GlobalizationPreferences.setCurrency",
	"Comment": "sets the currency code. if this has not been set, uses default for territory.",
	"Method": "GlobalizationPreferences setCurrency(Currency currency){\r\n    if (isFrozen()) {\r\n        throw new UnsupportedOperationException(\"Attempt to modify immutable object\");\r\n    }\r\n    this.currency = currency;\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.impl.duration.Period.inPast",
	"Comment": "mark the duration as extending into the past ifpast is true, and into the future otherwise.",
	"Method": "Period inPast(Period inPast,boolean past){\r\n    return setFuture(!past);\r\n}"
}, {
	"Path": "libcore.java.io.OldPushbackReaderTest.tearDown",
	"Comment": "tears down the fixture, for example, close a network connection. thismethod is called after a test is executed.",
	"Method": "void tearDown(){\r\n    try {\r\n        pbr.close();\r\n    } catch (IOException e) {\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneGenericNames.readObject",
	"Comment": "the custom deserialization method.this implementation only read locale used by the object.",
	"Method": "void readObject(ObjectInputStream in){\r\n    in.defaultReadObject();\r\n    init();\r\n}"
}, {
	"Path": "android.icu.text.DateTimePatternGenerator.getInstance",
	"Comment": "construct a flexible generator according to data for a given locale.",
	"Method": "DateTimePatternGenerator getInstance(DateTimePatternGenerator getInstance,ULocale uLocale,DateTimePatternGenerator getInstance,Locale locale){\r\n    return getInstance(ULocale.forLocale(locale));\r\n}"
}, {
	"Path": "android.icu.impl.LocaleIDParser.getKeywordValue",
	"Comment": "returns the value for the named keyword, or null if the keyword is notpresent.",
	"Method": "String getKeywordValue(String keywordName){\r\n    Map<String, String> m = getKeywordMap();\r\n    return m.isEmpty() ? null : m.get(AsciiUtil.toLowerString(keywordName.trim()));\r\n}"
}, {
	"Path": "android.icu.text.Collator.cloneAsThawed",
	"Comment": "provides for the clone operation. any clone is initially unfrozen.",
	"Method": "Collator cloneAsThawed(){\r\n    throw new UnsupportedOperationException(\"Needs to be implemented by the subclass.\");\r\n}"
}, {
	"Path": "org.apache.harmony.xml.dom.DOMImplementationImpl.getInstance",
	"Comment": "requests the singleton instance of the class. creates it first, ifnecessary.",
	"Method": "DOMImplementationImpl getInstance(){\r\n    if (instance == null) {\r\n        instance = new DOMImplementationImpl();\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "android.icu.text.NFSubstitution.makeSubstitution",
	"Comment": "parses the description, creates the right kind of substitution,and initializes it based on the description.",
	"Method": "NFSubstitution makeSubstitution(int pos,NFRule rule,NFRule rulePredecessor,NFRuleSet ruleSet,RuleBasedNumberFormat formatter,String description){\r\n    if (description.length() == 0) {\r\n        return null;\r\n    }\r\n    switch(description.charAt(0)) {\r\n        case '<':\r\n            if (rule.getBaseValue() == NFRule.NEGATIVE_NUMBER_RULE) {\r\n                throw new IllegalArgumentException(\"<< not allowed in negative-number rule\");\r\n            } else if (rule.getBaseValue() == NFRule.IMPROPER_FRACTION_RULE || rule.getBaseValue() == NFRule.PROPER_FRACTION_RULE || rule.getBaseValue() == NFRule.MASTER_RULE) {\r\n                return new IntegralPartSubstitution(pos, ruleSet, description);\r\n            } else if (ruleSet.isFractionSet()) {\r\n                return new NumeratorSubstitution(pos, rule.getBaseValue(), formatter.getDefaultRuleSet(), description);\r\n            } else {\r\n                return new MultiplierSubstitution(pos, rule, ruleSet, description);\r\n            }\r\n        case '>':\r\n            if (rule.getBaseValue() == NFRule.NEGATIVE_NUMBER_RULE) {\r\n                return new AbsoluteValueSubstitution(pos, ruleSet, description);\r\n            } else if (rule.getBaseValue() == NFRule.IMPROPER_FRACTION_RULE || rule.getBaseValue() == NFRule.PROPER_FRACTION_RULE || rule.getBaseValue() == NFRule.MASTER_RULE) {\r\n                return new FractionalPartSubstitution(pos, ruleSet, description);\r\n            } else if (ruleSet.isFractionSet()) {\r\n                throw new IllegalArgumentException(\">> not allowed in fraction rule set\");\r\n            } else {\r\n                return new ModulusSubstitution(pos, rule, rulePredecessor, ruleSet, description);\r\n            }\r\n        case '=':\r\n            return new SameValueSubstitution(pos, ruleSet, description);\r\n        default:\r\n            throw new IllegalArgumentException(\"Illegal substitution character\");\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.LocaleIDParser.getBaseName",
	"Comment": "returns the normalized base form of the locale id.the baseform does not include keywords.",
	"Method": "String getBaseName(){\r\n    if (baseName != null) {\r\n        return baseName;\r\n    }\r\n    parseBaseName();\r\n    return getString(0);\r\n}"
}, {
	"Path": "android.icu.impl.ICUResourceBundle.getFunctionalEquivalent",
	"Comment": "returns a functionally equivalent locale, considering keywords as well, for the specified keyword.",
	"Method": "ULocale getFunctionalEquivalent(String baseName,ClassLoader loader,String resName,String keyword,ULocale locID,boolean isAvailable,boolean omitDefault){\r\n    String kwVal = locID.getKeywordValue(keyword);\r\n    String baseLoc = locID.getBaseName();\r\n    String defStr = null;\r\n    ULocale parent = new ULocale(baseLoc);\r\n    ULocale defLoc = null;\r\n    boolean lookForDefault = false;\r\n    ULocale fullBase = null;\r\n    int defDepth = 0;\r\n    int resDepth = 0;\r\n    if ((kwVal == null) || (kwVal.length() == 0) || kwVal.equals(DEFAULT_TAG)) {\r\n        kwVal = \"\";\r\n        lookForDefault = true;\r\n    }\r\n    ICUResourceBundle r = null;\r\n    r = (ICUResourceBundle) UResourceBundle.getBundleInstance(baseName, parent);\r\n    if (isAvailable != null) {\r\n        isAvailable[0] = false;\r\n        ULocale[] availableULocales = getAvailEntry(baseName, loader).getULocaleList();\r\n        for (int i = 0; i < availableULocales.length; i++) {\r\n            if (parent.equals(availableULocales[i])) {\r\n                isAvailable[0] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    do {\r\n        try {\r\n            ICUResourceBundle irb = (ICUResourceBundle) r.get(resName);\r\n            defStr = irb.getString(DEFAULT_TAG);\r\n            if (lookForDefault == true) {\r\n                kwVal = defStr;\r\n                lookForDefault = false;\r\n            }\r\n            defLoc = r.getULocale();\r\n        } catch (MissingResourceException t) {\r\n        }\r\n        if (defLoc == null) {\r\n            r = r.getParent();\r\n            defDepth++;\r\n        }\r\n    } while ((r != null) && (defLoc == null));\r\n    parent = new ULocale(baseLoc);\r\n    r = (ICUResourceBundle) UResourceBundle.getBundleInstance(baseName, parent);\r\n    do {\r\n        try {\r\n            ICUResourceBundle irb = (ICUResourceBundle) r.get(resName);\r\n            irb.get(kwVal);\r\n            fullBase = irb.getULocale();\r\n            if ((fullBase != null) && ((resDepth) > defDepth)) {\r\n                defStr = irb.getString(DEFAULT_TAG);\r\n                defLoc = r.getULocale();\r\n                defDepth = resDepth;\r\n            }\r\n        } catch (MissingResourceException t) {\r\n        }\r\n        if (fullBase == null) {\r\n            r = r.getParent();\r\n            resDepth++;\r\n        }\r\n    } while ((r != null) && (fullBase == null));\r\n    if (fullBase == null && (defStr != null) && !defStr.equals(kwVal)) {\r\n        kwVal = defStr;\r\n        parent = new ULocale(baseLoc);\r\n        r = (ICUResourceBundle) UResourceBundle.getBundleInstance(baseName, parent);\r\n        resDepth = 0;\r\n        do {\r\n            try {\r\n                ICUResourceBundle irb = (ICUResourceBundle) r.get(resName);\r\n                ICUResourceBundle urb = (ICUResourceBundle) irb.get(kwVal);\r\n                fullBase = r.getULocale();\r\n                if (!fullBase.getBaseName().equals(urb.getULocale().getBaseName())) {\r\n                    fullBase = null;\r\n                }\r\n                if ((fullBase != null) && ((resDepth) > defDepth)) {\r\n                    defStr = irb.getString(DEFAULT_TAG);\r\n                    defLoc = r.getULocale();\r\n                    defDepth = resDepth;\r\n                }\r\n            } catch (MissingResourceException t) {\r\n            }\r\n            if (fullBase == null) {\r\n                r = r.getParent();\r\n                resDepth++;\r\n            }\r\n        } while ((r != null) && (fullBase == null));\r\n    }\r\n    if (fullBase == null) {\r\n        throw new MissingResourceException(\"Could not find locale containing requested or default keyword.\", baseName, keyword + \"=\" + kwVal);\r\n    }\r\n    if (omitDefault && defStr.equals(kwVal) && resDepth <= defDepth) {\r\n        return fullBase;\r\n    } else {\r\n        return new ULocale(fullBase.getBaseName() + \"@\" + keyword + \"=\" + kwVal);\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.Region.loadRegionData",
	"Comment": "initializes the region data from the icu resource bundles.the region datacontains the basic relationships such as which regions are known, what the numericcodes are, any known aliases, and the territory containment data.if the region data has already loaded, then this method simply returns without doinganything meaningful.",
	"Method": "void loadRegionData(){\r\n    if (regionDataIsLoaded) {\r\n        return;\r\n    }\r\n    regionAliases = new HashMap<String, Region>();\r\n    regionIDMap = new HashMap<String, Region>();\r\n    numericCodeMap = new HashMap<Integer, Region>();\r\n    availableRegions = new ArrayList<Set<Region>>(RegionType.values().length);\r\n    UResourceBundle metadataAlias = null;\r\n    UResourceBundle territoryAlias = null;\r\n    UResourceBundle codeMappings = null;\r\n    UResourceBundle idValidity = null;\r\n    UResourceBundle regionList = null;\r\n    UResourceBundle regionRegular = null;\r\n    UResourceBundle regionMacro = null;\r\n    UResourceBundle regionUnknown = null;\r\n    UResourceBundle worldContainment = null;\r\n    UResourceBundle territoryContainment = null;\r\n    UResourceBundle groupingContainment = null;\r\n    UResourceBundle metadata = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, \"metadata\", ICUResourceBundle.ICU_DATA_CLASS_LOADER);\r\n    metadataAlias = metadata.get(\"alias\");\r\n    territoryAlias = metadataAlias.get(\"territory\");\r\n    UResourceBundle supplementalData = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, \"supplementalData\", ICUResourceBundle.ICU_DATA_CLASS_LOADER);\r\n    codeMappings = supplementalData.get(\"codeMappings\");\r\n    idValidity = supplementalData.get(\"idValidity\");\r\n    regionList = idValidity.get(\"region\");\r\n    regionRegular = regionList.get(\"regular\");\r\n    regionMacro = regionList.get(\"macroregion\");\r\n    regionUnknown = regionList.get(\"unknown\");\r\n    territoryContainment = supplementalData.get(\"territoryContainment\");\r\n    worldContainment = territoryContainment.get(\"001\");\r\n    groupingContainment = territoryContainment.get(\"grouping\");\r\n    String[] continentsArr = worldContainment.getStringArray();\r\n    List<String> continents = Arrays.asList(continentsArr);\r\n    String[] groupingArr = groupingContainment.getStringArray();\r\n    List<String> groupings = Arrays.asList(groupingArr);\r\n    List<String> regionCodes = new ArrayList<String>();\r\n    List<String> allRegions = new ArrayList<String>();\r\n    allRegions.addAll(Arrays.asList(regionRegular.getStringArray()));\r\n    allRegions.addAll(Arrays.asList(regionMacro.getStringArray()));\r\n    allRegions.add(regionUnknown.getString());\r\n    for (String r : allRegions) {\r\n        int rangeMarkerLocation = r.indexOf(\"~\");\r\n        if (rangeMarkerLocation > 0) {\r\n            StringBuilder regionName = new StringBuilder(r);\r\n            char endRange = regionName.charAt(rangeMarkerLocation + 1);\r\n            regionName.setLength(rangeMarkerLocation);\r\n            char lastChar = regionName.charAt(rangeMarkerLocation - 1);\r\n            while (lastChar <= endRange) {\r\n                String newRegion = regionName.toString();\r\n                regionCodes.add(newRegion);\r\n                lastChar++;\r\n                regionName.setCharAt(rangeMarkerLocation - 1, lastChar);\r\n            }\r\n        } else {\r\n            regionCodes.add(r);\r\n        }\r\n    }\r\n    regions = new ArrayList<Region>(regionCodes.size());\r\n    for (String id : regionCodes) {\r\n        Region r = new Region();\r\n        r.id = id;\r\n        r.type = RegionType.TERRITORY;\r\n        regionIDMap.put(id, r);\r\n        if (id.matches(\"[0-9]{3}\")) {\r\n            r.code = Integer.valueOf(id).intValue();\r\n            numericCodeMap.put(r.code, r);\r\n            r.type = RegionType.SUBCONTINENT;\r\n        } else {\r\n            r.code = -1;\r\n        }\r\n        regions.add(r);\r\n    }\r\n    for (int i = 0; i < territoryAlias.getSize(); i++) {\r\n        UResourceBundle res = territoryAlias.get(i);\r\n        String aliasFrom = res.getKey();\r\n        String aliasTo = res.get(\"replacement\").getString();\r\n        if (regionIDMap.containsKey(aliasTo) && !regionIDMap.containsKey(aliasFrom)) {\r\n            regionAliases.put(aliasFrom, regionIDMap.get(aliasTo));\r\n        } else {\r\n            Region r;\r\n            if (regionIDMap.containsKey(aliasFrom)) {\r\n                r = regionIDMap.get(aliasFrom);\r\n            } else {\r\n                r = new Region();\r\n                r.id = aliasFrom;\r\n                regionIDMap.put(aliasFrom, r);\r\n                if (aliasFrom.matches(\"[0-9]{3}\")) {\r\n                    r.code = Integer.valueOf(aliasFrom).intValue();\r\n                    numericCodeMap.put(r.code, r);\r\n                } else {\r\n                    r.code = -1;\r\n                }\r\n                regions.add(r);\r\n            }\r\n            r.type = RegionType.DEPRECATED;\r\n            List<String> aliasToRegionStrings = Arrays.asList(aliasTo.split(\" \"));\r\n            r.preferredValues = new ArrayList<Region>();\r\n            for (String s : aliasToRegionStrings) {\r\n                if (regionIDMap.containsKey(s)) {\r\n                    r.preferredValues.add(regionIDMap.get(s));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < codeMappings.getSize(); i++) {\r\n        UResourceBundle mapping = codeMappings.get(i);\r\n        if (mapping.getType() == UResourceBundle.ARRAY) {\r\n            String[] codeMappingStrings = mapping.getStringArray();\r\n            String codeMappingID = codeMappingStrings[0];\r\n            Integer codeMappingNumber = Integer.valueOf(codeMappingStrings[1]);\r\n            String codeMapping3Letter = codeMappingStrings[2];\r\n            if (regionIDMap.containsKey(codeMappingID)) {\r\n                Region r = regionIDMap.get(codeMappingID);\r\n                r.code = codeMappingNumber.intValue();\r\n                numericCodeMap.put(r.code, r);\r\n                regionAliases.put(codeMapping3Letter, r);\r\n            }\r\n        }\r\n    }\r\n    Region r;\r\n    if (regionIDMap.containsKey(WORLD_ID)) {\r\n        r = regionIDMap.get(WORLD_ID);\r\n        r.type = RegionType.WORLD;\r\n    }\r\n    if (regionIDMap.containsKey(UNKNOWN_REGION_ID)) {\r\n        r = regionIDMap.get(UNKNOWN_REGION_ID);\r\n        r.type = RegionType.UNKNOWN;\r\n    }\r\n    for (String continent : continents) {\r\n        if (regionIDMap.containsKey(continent)) {\r\n            r = regionIDMap.get(continent);\r\n            r.type = RegionType.CONTINENT;\r\n        }\r\n    }\r\n    for (String grouping : groupings) {\r\n        if (regionIDMap.containsKey(grouping)) {\r\n            r = regionIDMap.get(grouping);\r\n            r.type = RegionType.GROUPING;\r\n        }\r\n    }\r\n    if (regionIDMap.containsKey(OUTLYING_OCEANIA_REGION_ID)) {\r\n        r = regionIDMap.get(OUTLYING_OCEANIA_REGION_ID);\r\n        r.type = RegionType.SUBCONTINENT;\r\n    }\r\n    for (int i = 0; i < territoryContainment.getSize(); i++) {\r\n        UResourceBundle mapping = territoryContainment.get(i);\r\n        String parent = mapping.getKey();\r\n        if (parent.equals(\"containedGroupings\") || parent.equals(\"deprecated\")) {\r\n            continue;\r\n        }\r\n        Region parentRegion = regionIDMap.get(parent);\r\n        for (int j = 0; j < mapping.getSize(); j++) {\r\n            String child = mapping.getString(j);\r\n            Region childRegion = regionIDMap.get(child);\r\n            if (parentRegion != null && childRegion != null) {\r\n                parentRegion.containedRegions.add(childRegion);\r\n                if (parentRegion.getType() != RegionType.GROUPING) {\r\n                    childRegion.containingRegion = parentRegion;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < RegionType.values().length; i++) {\r\n        availableRegions.add(new TreeSet<Region>());\r\n    }\r\n    for (Region ar : regions) {\r\n        Set<Region> currentSet = availableRegions.get(ar.type.ordinal());\r\n        currentSet.add(ar);\r\n        availableRegions.set(ar.type.ordinal(), currentSet);\r\n    }\r\n    regionDataIsLoaded = true;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.setCurrency",
	"Comment": "sets the currency object used to display currency amounts. this takeseffect immediately, if this format is a currency format. if this format is not acurrency format, then the currency object is used if and when this object becomes acurrency format through the application of a new pattern.",
	"Method": "void setCurrency(Currency theCurrency){\r\n    super.setCurrency(theCurrency);\r\n    if (theCurrency != null) {\r\n        String s = theCurrency.getName(symbols.getULocale(), Currency.SYMBOL_NAME, null);\r\n        symbols.setCurrency(theCurrency);\r\n        symbols.setCurrencySymbol(s);\r\n    }\r\n    if (currencySignCount != CURRENCY_SIGN_COUNT_ZERO) {\r\n        if (theCurrency != null) {\r\n            setRoundingIncrement(theCurrency.getRoundingIncrement(currencyUsage));\r\n            int d = theCurrency.getDefaultFractionDigits(currencyUsage);\r\n            setMinimumFractionDigits(d);\r\n            setMaximumFractionDigits(d);\r\n        }\r\n        if (currencySignCount != CURRENCY_SIGN_COUNT_IN_PLURAL_FORMAT) {\r\n            expandAffixes(null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.SimpleTimeZone.hasSameRules",
	"Comment": "returns true if this zone has the same rules and offset as another zone.",
	"Method": "boolean hasSameRules(TimeZone othr){\r\n    if (this == othr) {\r\n        return true;\r\n    }\r\n    if (!(othr instanceof SimpleTimeZone)) {\r\n        return false;\r\n    }\r\n    SimpleTimeZone other = (SimpleTimeZone) othr;\r\n    return other != null && raw == other.raw && useDaylight == other.useDaylight && (!useDaylight || (dst == other.dst && startMode == other.startMode && startMonth == other.startMonth && startDay == other.startDay && startDayOfWeek == other.startDayOfWeek && startTime == other.startTime && startTimeMode == other.startTimeMode && endMode == other.endMode && endMonth == other.endMonth && endDay == other.endDay && endDayOfWeek == other.endDayOfWeek && endTime == other.endTime && endTimeMode == other.endTimeMode && startYear == other.startYear));\r\n}"
}, {
	"Path": "android.icu.text.AlphabeticIndex.separated",
	"Comment": "return the string with interspersed cgjs. input must have more than 2 codepoints.this is used to test whether contractions sort differently from their components.",
	"Method": "String separated(String item){\r\n    StringBuilder result = new StringBuilder();\r\n    char last = item.charAt(0);\r\n    result.append(last);\r\n    for (int i = 1; i < item.length(); ++i) {\r\n        char ch = item.charAt(i);\r\n        if (!UCharacter.isHighSurrogate(last) || !UCharacter.isLowSurrogate(ch)) {\r\n            result.append(CGJ);\r\n        }\r\n        result.append(ch);\r\n        last = ch;\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "android.icu.text.Bidi.createLineBidi",
	"Comment": "create a bidi object representing the bidi information on a line of textwithin the paragraph represented by the current bidi. this call is notrequired if the entire paragraph fits on one line.",
	"Method": "Bidi createLineBidi(int lineStart,int lineLimit){\r\n    return setLine(lineStart, lineLimit);\r\n}"
}, {
	"Path": "android.icu.util.CompactCharArray.getIndexArray",
	"Comment": "for internal use only.do not modify the result, the behavior ofmodified results are undefined.",
	"Method": "char[] getIndexArray(){\r\n    return indices;\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedBreakIterator.previous",
	"Comment": "moves the iterator backwards, to the last boundary preceding this one.",
	"Method": "int previous(){\r\n    int result;\r\n    int startPos;\r\n    CharacterIterator text = getText();\r\n    fLastStatusIndexValid = false;\r\n    if (fCachedBreakPositions != null) {\r\n        if (fPositionInCache > 0) {\r\n            --fPositionInCache;\r\n            if (fPositionInCache <= 0) {\r\n                fLastStatusIndexValid = false;\r\n            }\r\n            int pos = fCachedBreakPositions[fPositionInCache];\r\n            text.setIndex(pos);\r\n            return pos;\r\n        } else {\r\n            reset();\r\n        }\r\n    }\r\n    startPos = current();\r\n    if (fText == null || startPos == fText.getBeginIndex()) {\r\n        fLastRuleStatusIndex = 0;\r\n        fLastStatusIndexValid = true;\r\n        return BreakIterator.DONE;\r\n    }\r\n    if (fRData.fSRTable != null || fRData.fSFTable != null) {\r\n        result = handlePrevious(fRData.fRTable);\r\n        if (fDictionaryCharCount > 0) {\r\n            result = checkDictionary(result, startPos, true);\r\n        }\r\n        return result;\r\n    }\r\n    int start = current();\r\n    previous32(fText);\r\n    int lastResult = handlePrevious(fRData.fRTable);\r\n    if (lastResult == BreakIterator.DONE) {\r\n        lastResult = fText.getBeginIndex();\r\n        fText.setIndex(lastResult);\r\n    }\r\n    result = lastResult;\r\n    int lastTag = 0;\r\n    boolean breakTagValid = false;\r\n    for (; ; ) {\r\n        result = next();\r\n        if (result == BreakIterator.DONE || result >= start) {\r\n            break;\r\n        }\r\n        lastResult = result;\r\n        lastTag = fLastRuleStatusIndex;\r\n        breakTagValid = true;\r\n    }\r\n    fText.setIndex(lastResult);\r\n    fLastRuleStatusIndex = lastTag;\r\n    fLastStatusIndexValid = breakTagValid;\r\n    return lastResult;\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationIteratorTest.TestNormalizedUnicodeChar",
	"Comment": "test for collationelementiterator previous and next for the whole set ofunicode characters with normalization on.",
	"Method": "void TestNormalizedUnicodeChar(){\r\n    RuleBasedCollator th_th = null;\r\n    try {\r\n        th_th = (RuleBasedCollator) Collator.getInstance(new Locale(\"th\", \"TH\"));\r\n    } catch (Exception e) {\r\n        warnln(\"Error creating Thai collator\");\r\n        return;\r\n    }\r\n    StringBuffer source = new StringBuffer();\r\n    source.append('?');\r\n    CollationElementIterator iter = th_th.getCollationElementIterator(source.toString());\r\n    CollationTest.backAndForth(this, iter);\r\n    for (char codepoint = 0x1; codepoint < 0xfffe; ) {\r\n        source.delete(0, source.length());\r\n        while (codepoint % 0xFF != 0) {\r\n            if (UCharacter.isDefined(codepoint)) {\r\n                source.append(codepoint);\r\n            }\r\n            codepoint++;\r\n        }\r\n        if (UCharacter.isDefined(codepoint)) {\r\n            source.append(codepoint);\r\n        }\r\n        if (codepoint != 0xFFFF) {\r\n            codepoint++;\r\n        }\r\n        iter = th_th.getCollationElementIterator(source.toString());\r\n        CollationTest.backAndForth(this, iter);\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.CalendarAstronomer.eclipticToEquatorial",
	"Comment": "convert from ecliptic longitude to equatorial coordinates.",
	"Method": "Equatorial eclipticToEquatorial(Ecliptic ecliptic,Equatorial eclipticToEquatorial,double eclipLong,double eclipLat,Equatorial eclipticToEquatorial,double eclipLong){\r\n    return eclipticToEquatorial(eclipLong, 0);\r\n}"
}, {
	"Path": "android.icu.text.ArabicShaping.normalize",
	"Comment": "convert the input buffer from fexx range into 06xx rangeto put all characters into the 06xx rangeeven the lamalef is converted to the special region inthe 06xx range.return the number of lamalef chars found.",
	"Method": "int normalize(char[] dest,int start,int length){\r\n    int lacount = 0;\r\n    for (int i = start, e = i + length; i < e; ++i) {\r\n        char ch = dest[i];\r\n        if (ch >= '?' && ch <= '?') {\r\n            if (isLamAlefChar(ch)) {\r\n                ++lacount;\r\n            }\r\n            dest[i] = (char) convertFEto06[ch - '?'];\r\n        }\r\n    }\r\n    return lacount;\r\n}"
}, {
	"Path": "java.text.Normalizer.normalize",
	"Comment": "normalize the character sequence src according to thenormalization method form.",
	"Method": "String normalize(CharSequence src,Form form){\r\n    switch(form) {\r\n        case NFD:\r\n            return normalizeNFD(src.toString());\r\n        case NFC:\r\n            return normalizeNFC(src.toString());\r\n        case NFKD:\r\n            return normalizeNFKD(src.toString());\r\n        case NFKC:\r\n            return normalizeNFKC(src.toString());\r\n        default:\r\n            throw new AssertionError(\"unknown Form: \" + form);\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.ICULocaleService.getAvailableULocales",
	"Comment": "convenience method for callers using locales.this returns the standardulocale list, built from the set of visible ids.",
	"Method": "ULocale[] getAvailableULocales(){\r\n    Set<String> visIDs = getVisibleIDs();\r\n    ULocale[] locales = new ULocale[visIDs.size()];\r\n    int n = 0;\r\n    for (String id : visIDs) {\r\n        locales[n++] = new ULocale(id);\r\n    }\r\n    return locales;\r\n}"
}, {
	"Path": "android.icu.util.ChineseCalendar.synodicMonthsBetween",
	"Comment": "return the nearest integer number of synodic months betweentwo dates.",
	"Method": "int synodicMonthsBetween(int day1,int day2){\r\n    return (int) Math.round((day2 - day1) / CalendarAstronomer.SYNODIC_MONTH);\r\n}"
}, {
	"Path": "android.icu.impl.LocaleIDParser.getLanguageScriptCountryVariant",
	"Comment": "returns the language, script, country, and variant as separate strings.",
	"Method": "String[] getLanguageScriptCountryVariant(){\r\n    reset();\r\n    return new String[] { getString(parseLanguage()), getString(parseScript()), getString(parseCountry()), getString(parseVariant()) };\r\n}"
}, {
	"Path": "android.icu.impl.coll.CollationBuilder.findOrInsertWeakNode",
	"Comment": "finds or inserts the node for a secondary or tertiary weight.",
	"Method": "int findOrInsertWeakNode(int index,int weight16,int level){\r\n    assert (0 <= index && index < nodes.size());\r\n    assert (Collator.SECONDARY <= level && level <= Collator.TERTIARY);\r\n    if (weight16 == Collation.COMMON_WEIGHT16) {\r\n        return findCommonNode(index, level);\r\n    }\r\n    long node = nodes.elementAti(index);\r\n    assert (strengthFromNode(node) < level);\r\n    if (weight16 != 0 && weight16 < Collation.COMMON_WEIGHT16) {\r\n        int hasThisLevelBefore = level == Collator.SECONDARY ? HAS_BEFORE2 : HAS_BEFORE3;\r\n        if ((node & hasThisLevelBefore) == 0) {\r\n            long commonNode = nodeFromWeight16(Collation.COMMON_WEIGHT16) | nodeFromStrength(level);\r\n            if (level == Collator.SECONDARY) {\r\n                commonNode |= node & HAS_BEFORE3;\r\n                node &= ~(long) HAS_BEFORE3;\r\n            }\r\n            nodes.setElementAt(node | hasThisLevelBefore, index);\r\n            int nextIndex = nextIndexFromNode(node);\r\n            node = nodeFromWeight16(weight16) | nodeFromStrength(level);\r\n            index = insertNodeBetween(index, nextIndex, node);\r\n            insertNodeBetween(index, nextIndex, commonNode);\r\n            return index;\r\n        }\r\n    }\r\n    int nextIndex;\r\n    while ((nextIndex = nextIndexFromNode(node)) != 0) {\r\n        node = nodes.elementAti(nextIndex);\r\n        int nextStrength = strengthFromNode(node);\r\n        if (nextStrength <= level) {\r\n            if (nextStrength < level) {\r\n                break;\r\n            }\r\n            if (!isTailoredNode(node)) {\r\n                int nextWeight16 = weight16FromNode(node);\r\n                if (nextWeight16 == weight16) {\r\n                    return nextIndex;\r\n                }\r\n                if (nextWeight16 > weight16) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        index = nextIndex;\r\n    }\r\n    node = nodeFromWeight16(weight16) | nodeFromStrength(level);\r\n    return insertNodeBetween(index, nextIndex, node);\r\n}"
}, {
	"Path": "android.icu.impl.ClassLoaderUtil.getBootstrapClassLoader",
	"Comment": "lazily create a singleton bootstrapclassloader.this class loader might be necessary when icu4j classes areinitialized by bootstrap class loader.",
	"Method": "ClassLoader getBootstrapClassLoader(){\r\n    if (BOOTSTRAP_CLASSLOADER == null) {\r\n        synchronized (ClassLoaderUtil.class) {\r\n            if (BOOTSTRAP_CLASSLOADER == null) {\r\n                ClassLoader cl = null;\r\n                if (System.getSecurityManager() != null) {\r\n                    cl = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\r\n                        @Override\r\n                        public BootstrapClassLoader run() {\r\n                            return new BootstrapClassLoader();\r\n                        }\r\n                    });\r\n                } else {\r\n                    cl = new BootstrapClassLoader();\r\n                }\r\n                BOOTSTRAP_CLASSLOADER = cl;\r\n            }\r\n        }\r\n    }\r\n    return BOOTSTRAP_CLASSLOADER;\r\n}"
}, {
	"Path": "android.icu.impl.ClassLoaderUtil.getBootstrapClassLoader",
	"Comment": "lazily create a singleton bootstrapclassloader.this class loader might be necessary when icu4j classes areinitialized by bootstrap class loader.",
	"Method": "ClassLoader getBootstrapClassLoader(){\r\n    return new BootstrapClassLoader();\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedNumberFormat.initLocalizations",
	"Comment": "take the localizations array and create a map from the locale strings tothe localization arrays.",
	"Method": "void initLocalizations(String[][] localizations){\r\n    if (localizations != null) {\r\n        publicRuleSetNames = localizations[0].clone();\r\n        Map<String, String[]> m = new HashMap<String, String[]>();\r\n        for (int i = 1; i < localizations.length; ++i) {\r\n            String[] data = localizations[i];\r\n            String loc = data[0];\r\n            String[] names = new String[data.length - 1];\r\n            if (names.length != publicRuleSetNames.length) {\r\n                throw new IllegalArgumentException(\"public name length: \" + publicRuleSetNames.length + \" != localized names[\" + i + \"] length: \" + names.length);\r\n            }\r\n            System.arraycopy(data, 1, names, 0, names.length);\r\n            m.put(loc, names);\r\n        }\r\n        if (!m.isEmpty()) {\r\n            ruleSetDisplayNames = m;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.patternCharToDateFormatField",
	"Comment": "returns a dateformat.field constant associated with the specified format patterncharacter.",
	"Method": "DateFormat.Field patternCharToDateFormatField(char ch){\r\n    int patternCharIndex = getIndexFromChar(ch);\r\n    if (patternCharIndex != -1) {\r\n        return PATTERN_INDEX_TO_DATE_FORMAT_ATTRIBUTE[patternCharIndex];\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.text.CurrencyPluralInfo.getInstance",
	"Comment": "gets a currencypluralinfo instance for the default locale.",
	"Method": "CurrencyPluralInfo getInstance(CurrencyPluralInfo getInstance,Locale locale,CurrencyPluralInfo getInstance,ULocale locale){\r\n    return new CurrencyPluralInfo(locale);\r\n}"
}, {
	"Path": "android.icu.text.UCharacterIterator.getInstance",
	"Comment": "returns a ucharacteriterator object given a characteriterator.",
	"Method": "UCharacterIterator getInstance(Replaceable source,UCharacterIterator getInstance,String source,UCharacterIterator getInstance,char[] source,UCharacterIterator getInstance,char[] source,int start,int limit,UCharacterIterator getInstance,StringBuffer source,UCharacterIterator getInstance,CharacterIterator source){\r\n    return new CharacterIteratorWrapper(source);\r\n}"
}, {
	"Path": "android.icu.util.VTimeZone.isEquivalentDateRule",
	"Comment": "check if the dow rule specified by month, weekinmonth and dayofweek is equivalentto the datetimerule.",
	"Method": "boolean isEquivalentDateRule(int month,int weekInMonth,int dayOfWeek,DateTimeRule dtrule){\r\n    if (month != dtrule.getRuleMonth() || dayOfWeek != dtrule.getRuleDayOfWeek()) {\r\n        return false;\r\n    }\r\n    if (dtrule.getTimeRuleType() != DateTimeRule.WALL_TIME) {\r\n        return false;\r\n    }\r\n    if (dtrule.getDateRuleType() == DateTimeRule.DOW && dtrule.getRuleWeekInMonth() == weekInMonth) {\r\n        return true;\r\n    }\r\n    int ruleDOM = dtrule.getRuleDayOfMonth();\r\n    if (dtrule.getDateRuleType() == DateTimeRule.DOW_GEQ_DOM) {\r\n        if (ruleDOM % 7 == 1 && (ruleDOM + 6) / 7 == weekInMonth) {\r\n            return true;\r\n        }\r\n        if (month != Calendar.FEBRUARY && (MONTHLENGTH[month] - ruleDOM) % 7 == 6 && weekInMonth == -1 * ((MONTHLENGTH[month] - ruleDOM + 1) / 7)) {\r\n            return true;\r\n        }\r\n    }\r\n    if (dtrule.getDateRuleType() == DateTimeRule.DOW_LEQ_DOM) {\r\n        if (ruleDOM % 7 == 0 && ruleDOM / 7 == weekInMonth) {\r\n            return true;\r\n        }\r\n        if (month != Calendar.FEBRUARY && (MONTHLENGTH[month] - ruleDOM) % 7 == 0 && weekInMonth == -1 * ((MONTHLENGTH[month] - ruleDOM) / 7 + 1)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "android.icu.impl.CacheValue.isNull",
	"Comment": "distinguishes a null value from a reference value that has been cleared.",
	"Method": "boolean isNull(boolean isNull){\r\n    return false;\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationSpanishTest.doTest",
	"Comment": "amin test routine, tests rules specific to the spanish locale",
	"Method": "void doTest(char[] source,char[] target,int result){\r\n    String s = new String(source);\r\n    String t = new String(target);\r\n    int compareResult = myCollation.compare(s, t);\r\n    CollationKey sortKey1, sortKey2;\r\n    sortKey1 = myCollation.getCollationKey(s);\r\n    sortKey2 = myCollation.getCollationKey(t);\r\n    int keyResult = sortKey1.compareTo(sortKey2);\r\n    reportCResult(s, t, sortKey1, sortKey2, compareResult, keyResult, compareResult, result);\r\n}"
}, {
	"Path": "libcore.java.util.TreeSetTest.assertBounded",
	"Comment": "regrettably, serializing a treeset causes it to forget its bounds. thisis unlike a serialized treemap which retains its bounds when serialized.",
	"Method": "void assertBounded(SortedSet<String> deserialized,boolean bounded){\r\n    if (bounded) {\r\n        try {\r\n            deserialized.add(\"e\");\r\n            fail();\r\n        } catch (IllegalArgumentException expected) {\r\n        }\r\n    } else {\r\n        assertTrue(deserialized.add(\"e\"));\r\n        assertTrue(deserialized.remove(\"e\"));\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.DateFormat.getTimeInstance",
	"Comment": "returns the time formatter with the given formatting stylefor the given locale.",
	"Method": "DateFormat getTimeInstance(DateFormat getTimeInstance,int style,DateFormat getTimeInstance,int style,Locale aLocale,DateFormat getTimeInstance,int style,ULocale locale,DateFormat getTimeInstance,Calendar cal,int timeStyle,Locale locale,DateFormat getTimeInstance,Calendar cal,int timeStyle,ULocale locale,DateFormat getTimeInstance,Calendar cal,int timeStyle){\r\n    return getTimeInstance(cal, timeStyle, ULocale.getDefault(Category.FORMAT));\r\n}"
}, {
	"Path": "android.icu.impl.UCharacterName.getGroupChar",
	"Comment": "compares and retrieve character if name is found within the argument group",
	"Method": "int getGroupChar(String name,int choice,int getGroupChar,int index,char length,String name,int choice){\r\n    byte b = 0;\r\n    char token;\r\n    int len;\r\n    int namelen = name.length();\r\n    int nindex;\r\n    int count;\r\n    for (int result = 0; result <= LINES_PER_GROUP_; result++) {\r\n        nindex = 0;\r\n        len = length[result];\r\n        if (choice != UCharacterNameChoice.UNICODE_CHAR_NAME && choice != UCharacterNameChoice.EXTENDED_CHAR_NAME) {\r\n            int fieldIndex = choice == UCharacterNameChoice.ISO_COMMENT_ ? 2 : choice;\r\n            do {\r\n                int oldindex = index;\r\n                index += UCharacterUtility.skipByteSubString(m_groupstring_, index, len, (byte) ';');\r\n                len -= (index - oldindex);\r\n            } while (--fieldIndex > 0);\r\n        }\r\n        for (count = 0; count < len && nindex != -1 && nindex < namelen; ) {\r\n            b = m_groupstring_[index + count];\r\n            count++;\r\n            if (b >= m_tokentable_.length) {\r\n                if (name.charAt(nindex++) != (b & 0xFF)) {\r\n                    nindex = -1;\r\n                }\r\n            } else {\r\n                token = m_tokentable_[b & 0xFF];\r\n                if (token == 0xFFFE) {\r\n                    token = m_tokentable_[b << 8 | (m_groupstring_[index + count] & 0x00ff)];\r\n                    count++;\r\n                }\r\n                if (token == 0xFFFF) {\r\n                    if (name.charAt(nindex++) != (b & 0xFF)) {\r\n                        nindex = -1;\r\n                    }\r\n                } else {\r\n                    nindex = UCharacterUtility.compareNullTermByteSubString(name, m_tokenstring_, nindex, token);\r\n                }\r\n            }\r\n        }\r\n        if (namelen == nindex && (count == len || m_groupstring_[index + count] == ';')) {\r\n            return result;\r\n        }\r\n        index += len;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "android.icu.util.BytesTrie.getUniqueValue",
	"Comment": "determines whether all byte sequences reachable from the current statemap to the same value, and if so, returns that value.",
	"Method": "long getUniqueValue(){\r\n    int pos = pos_;\r\n    if (pos < 0) {\r\n        return 0;\r\n    }\r\n    long uniqueValue = findUniqueValue(bytes_, pos + remainingMatchLength_ + 1, 0);\r\n    return (uniqueValue << 31) >> 31;\r\n}"
}, {
	"Path": "android.icu.util.Holiday.isBetween",
	"Comment": "check whether this holiday occurs at least once between the twodates given.",
	"Method": "boolean isBetween(Date start,Date end){\r\n    return rule.isBetween(start, end);\r\n}"
}, {
	"Path": "android.icu.text.CompactDecimalDataCache.calculateDivisor",
	"Comment": "calculate a divisor based on the magnitude and number of zeros in thetemplate string.",
	"Method": "long calculateDivisor(long power10,int numZeros){\r\n    long divisor = power10;\r\n    for (int i = 1; i < numZeros; i++) {\r\n        divisor /= 10;\r\n    }\r\n    return divisor;\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.removeAll",
	"Comment": "removes from this set all of its elements that are contained in thespecified set.this operation effectively modifies thisset so that its value is the asymmetric set difference ofthe two sets.",
	"Method": "UnicodeSet removeAll(CharSequence s,UnicodeSet removeAll,UnicodeSet c,UnicodeSet removeAll,Iterable<T> collection){\r\n    checkFrozen();\r\n    for (T o : collection) {\r\n        remove(o);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "java.text.StringCharacterIterator.first",
	"Comment": "sets the current position to the begin index and returns the character atthe new position in the source string.",
	"Method": "char first(){\r\n    if (start == end) {\r\n        return DONE;\r\n    }\r\n    offset = start;\r\n    return string.charAt(offset);\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationMiscTest.TestSameStrengthListRangesWithSupplementalCharacters",
	"Comment": "tests the compact range syntax with supplemental codepoints.",
	"Method": "void TestSameStrengthListRangesWithSupplementalCharacters(){\r\n    String[] rules = new String[] { \"&һ<*'?'?-'?' \" + \"&'?'<<*'?'-'?'  \" + \"&'?'=*'?'-'??' \" };\r\n    doTestCollation(m_rangeTestCasesSupplemental_, rules);\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.getRangeEnd",
	"Comment": "iteration method that returns the last character in thespecified range of this set.",
	"Method": "int getRangeEnd(int index){\r\n    return (list[index * 2 + 1] - 1);\r\n}"
}, {
	"Path": "android.icu.text.UTF16.appendCodePoint",
	"Comment": "cover jdk 1.5 apis. append the code point to the buffer and return the buffer as aconvenience.",
	"Method": "StringBuffer appendCodePoint(StringBuffer target,int cp){\r\n    return append(target, cp);\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedNumberFormat.initCapitalizationContextInfo",
	"Comment": "set capitalizationforlistormenu, capitalizationforstandalone",
	"Method": "void initCapitalizationContextInfo(ULocale theLocale){\r\n    ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, theLocale);\r\n    try {\r\n        ICUResourceBundle rdb = rb.getWithFallback(\"contextTransforms/number-spellout\");\r\n        int[] intVector = rdb.getIntVector();\r\n        if (intVector.length >= 2) {\r\n            capitalizationForListOrMenu = (intVector[0] != 0);\r\n            capitalizationForStandAlone = (intVector[1] != 0);\r\n        }\r\n    } catch (MissingResourceException e) {\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.Currency.getAvailableCurrencies",
	"Comment": "returns the set of available currencies. the returned set of currencies contains all of theavailable currencies, including obsolete ones. the result set can be modified withoutaffecting the available currencies in the runtime.",
	"Method": "Set<Currency> getAvailableCurrencies(){\r\n    CurrencyMetaInfo info = CurrencyMetaInfo.getInstance();\r\n    List<String> list = info.currencies(CurrencyFilter.all());\r\n    HashSet<Currency> resultSet = new HashSet<Currency>(list.size());\r\n    for (String code : list) {\r\n        resultSet.add(getInstance(code));\r\n    }\r\n    return resultSet;\r\n}"
}, {
	"Path": "android.icu.text.Transliterator.setID",
	"Comment": "set the programmatic identifier for this transliterator.onlyfor use by subclasses.",
	"Method": "void setID(String id){\r\n    ID = id;\r\n}"
}, {
	"Path": "libcore.java.io.OldObjectOutputStreamTest.tearDown",
	"Comment": "tears down the fixture, for example, close a network connection. thismethod is called after a test is executed.",
	"Method": "void tearDown(){\r\n    super.tearDown();\r\n    if (oos != null) {\r\n        try {\r\n            oos.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    if (oos_ioe != null) {\r\n        try {\r\n            oos_ioe.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    if (f != null && f.exists()) {\r\n        if (!f.delete()) {\r\n            fail(\"Error cleaning up files during teardown\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.getRangeStart",
	"Comment": "iteration method that returns the first character in thespecified range of this set.",
	"Method": "int getRangeStart(int index){\r\n    return list[index * 2];\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.adjustNumberAsInFormatting",
	"Comment": "this is a special function used by the compactdecimalformat subclass.it completes only the rounding portion of the formatting and returnsthe resulting double. compactdecimalformat uses the result to computethe plural form to use.",
	"Method": "double adjustNumberAsInFormatting(double number){\r\n    if (Double.isNaN(number)) {\r\n        return number;\r\n    }\r\n    number = round(multiply(number));\r\n    if (Double.isInfinite(number)) {\r\n        return number;\r\n    }\r\n    return toDigitList(number).getDouble();\r\n}"
}, {
	"Path": "android.icu.impl.PropsVectors.getRowEnd",
	"Comment": "returns an int which is the limit codepointminus 1 in row rowindex.",
	"Method": "int getRowEnd(int rowIndex){\r\n    if (isCompacted) {\r\n        throw new IllegalStateException(\"Illegal Invocation of the method after compact()\");\r\n    }\r\n    if (rowIndex < 0 || rowIndex > rows) {\r\n        throw new IllegalArgumentException(\"rowIndex out of bound!\");\r\n    }\r\n    return v[rowIndex * columns + 1] - 1;\r\n}"
}, {
	"Path": "android.icu.util.GlobalizationPreferences.getBreakIterator",
	"Comment": "get a copy of the break iterator for the specified type according to thesettings.",
	"Method": "BreakIterator getBreakIterator(int type){\r\n    if (type < BI_CHARACTER || type >= BI_LIMIT) {\r\n        throw new IllegalArgumentException(\"Illegal break iterator type\");\r\n    }\r\n    if (breakIterators == null || breakIterators[type] == null) {\r\n        return guessBreakIterator(type);\r\n    }\r\n    return (BreakIterator) breakIterators[type].clone();\r\n}"
}, {
	"Path": "java.io.FileInputStream.finalize",
	"Comment": "ensures that all resources for this stream are released when it is aboutto be garbage collected.",
	"Method": "void finalize(){\r\n    try {\r\n        if (guard != null) {\r\n            guard.warnIfOpen();\r\n        }\r\n        close();\r\n    } finally {\r\n        try {\r\n            super.finalize();\r\n        } catch (Throwable t) {\r\n            throw new AssertionError(t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.getDisplayName",
	"Comment": "given a visible id, return the display name in the requested locale.if there is no directly supported id corresponding to this id, returnnull.",
	"Method": "String getDisplayName(String id,ULocale locale,String getDisplayName,String identifier,ULocale locale,String getDisplayName,String id,String getDisplayName,String id,ULocale locale){\r\n    Map<String, Factory> m = getVisibleIDMap();\r\n    Factory f = m.get(id);\r\n    if (f != null) {\r\n        return f.getDisplayName(id, locale);\r\n    }\r\n    Key key = createKey(id);\r\n    while (key.fallback()) {\r\n        f = m.get(key.currentID());\r\n        if (f != null) {\r\n            return f.getDisplayName(id, locale);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.ChineseTest.TestJulianDayMapping",
	"Comment": "run through several standard tests from dershowitz & reingold.",
	"Method": "void TestJulianDayMapping(){\r\n    final TestCase[] tests = { // *\r\n    new ChineseTestCase(1507231.5, 35, 11, 6, false, 12, SUN), // *\r\n    new ChineseTestCase(1660037.5, 42, 9, 10, false, 27, WED), // *\r\n    new ChineseTestCase(1746893.5, 46, 7, 8, false, 4, WED), // *\r\n    new ChineseTestCase(1770641.5, 47, 12, 8, false, 9, SUN), // *\r\n    new ChineseTestCase(1892731.5, 52, 46, 11, false, 20, WED), // *\r\n    new ChineseTestCase(1931579.5, 54, 33, 4, false, 5, MON), // *\r\n    new ChineseTestCase(1974851.5, 56, 31, 10, false, 15, SAT), // *\r\n    new ChineseTestCase(2091164.5, 61, 50, 3, false, 7, SUN), // *\r\n    new ChineseTestCase(2121509.5, 63, 13, 4, false, 24, SUN), // *\r\n    new ChineseTestCase(2155779.5, 64, 47, 2, false, 9, FRI), // *\r\n    new ChineseTestCase(2174029.5, 65, 37, 2, false, 9, SAT), new ChineseTestCase(2191584.5, 66, 25, 2, false, 23, FRI), new ChineseTestCase(2195261.5, 66, 35, 3, false, 9, SUN), new ChineseTestCase(2229274.5, 68, 8, 5, false, 2, SUN), // *\r\n    new ChineseTestCase(2245580.5, 68, 53, 1, false, 8, WED), new ChineseTestCase(2266100.5, 69, 49, 3, false, 4, SAT), new ChineseTestCase(2288542.5, 70, 50, 8, false, 2, SAT), new ChineseTestCase(2290901.5, 70, 57, 1, false, 29, SAT), // year 60\r\n    new ChineseTestCase(2323140.5, 72, 25, 4, true, 20, WED), // year 60\r\n    new ChineseTestCase(2334848.5, 72, 57, 6, false, 5, SUN), // year 60\r\n    new ChineseTestCase(2348020.5, 73, 33, 6, false, 6, FRI), // year 60\r\n    new ChineseTestCase(2366978.5, 74, 25, 5, false, 5, SUN), // year 60\r\n    new ChineseTestCase(2385648.5, 75, 16, 6, false, 12, MON), // year 60\r\n    new ChineseTestCase(2392825.5, 75, 36, 2, false, 13, WED), // year 60\r\n    new ChineseTestCase(2416223.5, 76, 40, 3, false, 22, SUN), // year 60\r\n    new ChineseTestCase(2425848.5, 77, 6, 7, false, 21, SUN), // year 60\r\n    new ChineseTestCase(2430266.5, 77, 18, 8, false, 9, MON), // year 60\r\n    new ChineseTestCase(2430833.5, 77, 20, 3, false, 15, MON), // year 60\r\n    new ChineseTestCase(2431004.5, 77, 20, 9, false, 9, THU), // year 60\r\n    new ChineseTestCase(2448698.5, 78, 9, 2, false, 14, TUE), // year 60\r\n    new ChineseTestCase(2450138.5, 78, 13, 1, false, 7, SUN), // year 60\r\n    new ChineseTestCase(2465737.5, 78, 55, 10, false, 14, WED), new ChineseTestCase(2486076.5, 79, 51, 6, false, 7, SUN), new ChineseTestCase(2467496.5, 78, 60, 8, false, 2, FRI) };\r\n    ChineseCalendar cal = new ChineseCalendar();\r\n    cal.setLenient(true);\r\n    doTestCases(tests, cal);\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.intervalFormatByAlgorithm",
	"Comment": "format date interval by algorithm.it is supposed to be used only by cldr survey tool.",
	"Method": "StringBuffer intervalFormatByAlgorithm(Calendar fromCalendar,Calendar toCalendar,StringBuffer appendTo,FieldPosition pos){\r\n    if (!fromCalendar.isEquivalentTo(toCalendar)) {\r\n        throw new IllegalArgumentException(\"can not format on two different calendars\");\r\n    }\r\n    Object[] items = getPatternItems();\r\n    int diffBegin = -1;\r\n    int diffEnd = -1;\r\n    try {\r\n        for (int i = 0; i < items.length; i++) {\r\n            if (diffCalFieldValue(fromCalendar, toCalendar, items, i)) {\r\n                diffBegin = i;\r\n                break;\r\n            }\r\n        }\r\n        if (diffBegin == -1) {\r\n            return format(fromCalendar, appendTo, pos);\r\n        }\r\n        for (int i = items.length - 1; i >= diffBegin; i--) {\r\n            if (diffCalFieldValue(fromCalendar, toCalendar, items, i)) {\r\n                diffEnd = i;\r\n                break;\r\n            }\r\n        }\r\n    } catch (IllegalArgumentException e) {\r\n        throw new IllegalArgumentException(e.toString());\r\n    }\r\n    if (diffBegin == 0 && diffEnd == items.length - 1) {\r\n        format(fromCalendar, appendTo, pos);\r\n        appendTo.append(\" �C \");\r\n        format(toCalendar, appendTo, pos);\r\n        return appendTo;\r\n    }\r\n    int highestLevel = 1000;\r\n    for (int i = diffBegin; i <= diffEnd; i++) {\r\n        if (items[i] instanceof String) {\r\n            continue;\r\n        }\r\n        PatternItem item = (PatternItem) items[i];\r\n        char ch = item.type;\r\n        int patternCharIndex = getIndexFromChar(ch);\r\n        if (patternCharIndex == -1) {\r\n            throw new IllegalArgumentException(\"Illegal pattern character \" + \"'\" + ch + \"' in \\\"\" + pattern + '\"');\r\n        }\r\n        if (patternCharIndex < highestLevel) {\r\n            highestLevel = patternCharIndex;\r\n        }\r\n    }\r\n    try {\r\n        for (int i = 0; i < diffBegin; i++) {\r\n            if (lowerLevel(items, i, highestLevel)) {\r\n                diffBegin = i;\r\n                break;\r\n            }\r\n        }\r\n        for (int i = items.length - 1; i > diffEnd; i--) {\r\n            if (lowerLevel(items, i, highestLevel)) {\r\n                diffEnd = i;\r\n                break;\r\n            }\r\n        }\r\n    } catch (IllegalArgumentException e) {\r\n        throw new IllegalArgumentException(e.toString());\r\n    }\r\n    if (diffBegin == 0 && diffEnd == items.length - 1) {\r\n        format(fromCalendar, appendTo, pos);\r\n        appendTo.append(\" �C \");\r\n        format(toCalendar, appendTo, pos);\r\n        return appendTo;\r\n    }\r\n    pos.setBeginIndex(0);\r\n    pos.setEndIndex(0);\r\n    DisplayContext capSetting = getContext(DisplayContext.Type.CAPITALIZATION);\r\n    for (int i = 0; i <= diffEnd; i++) {\r\n        if (items[i] instanceof String) {\r\n            appendTo.append((String) items[i]);\r\n        } else {\r\n            PatternItem item = (PatternItem) items[i];\r\n            if (useFastFormat) {\r\n                subFormat(appendTo, item.type, item.length, appendTo.length(), i, capSetting, pos, fromCalendar);\r\n            } else {\r\n                appendTo.append(subFormat(item.type, item.length, appendTo.length(), i, capSetting, pos, fromCalendar));\r\n            }\r\n        }\r\n    }\r\n    appendTo.append(\" �C \");\r\n    for (int i = diffBegin; i < items.length; i++) {\r\n        if (items[i] instanceof String) {\r\n            appendTo.append((String) items[i]);\r\n        } else {\r\n            PatternItem item = (PatternItem) items[i];\r\n            if (useFastFormat) {\r\n                subFormat(appendTo, item.type, item.length, appendTo.length(), i, capSetting, pos, toCalendar);\r\n            } else {\r\n                appendTo.append(subFormat(item.type, item.length, appendTo.length(), i, capSetting, pos, toCalendar));\r\n            }\r\n        }\r\n    }\r\n    return appendTo;\r\n}"
}, {
	"Path": "java.io.File.getName",
	"Comment": "returns the name of the file or directory represented by this file.",
	"Method": "String getName(){\r\n    int separatorIndex = path.lastIndexOf(separator);\r\n    return (separatorIndex < 0) ? path : path.substring(separatorIndex + 1, path.length());\r\n}"
}, {
	"Path": "android.icu.text.UCharacterIterator.clone",
	"Comment": "creates a copy of this iterator, independent from other iterators. if it is not possible to clone the iterator,returns null.",
	"Method": "Object clone(){\r\n    return super.clone();\r\n}"
}, {
	"Path": "android.icu.text.NumberingSystem.getInstance",
	"Comment": "returns the default numbering system for the default format locale.",
	"Method": "NumberingSystem getInstance(int radix_in,boolean isAlgorithmic_in,String desc_in,NumberingSystem getInstance,String name_in,int radix_in,boolean isAlgorithmic_in,String desc_in,NumberingSystem getInstance,Locale inLocale,NumberingSystem getInstance,ULocale locale,NumberingSystem getInstance){\r\n    return getInstance(ULocale.getDefault(Category.FORMAT));\r\n}"
}, {
	"Path": "android.icu.text.DateTimePatternGenerator.getBestPattern",
	"Comment": "return the best pattern matching the input skeleton. it is guaranteed tohave all of the fields in the skeleton.",
	"Method": "String getBestPattern(String skeleton,String getBestPattern,String skeleton,int options,String getBestPattern,String skeleton,DateTimeMatcher skipMatcher,int options){\r\n    EnumSet<DTPGflags> flags = EnumSet.noneOf(DTPGflags.class);\r\n    StringBuilder skeletonCopy = new StringBuilder(skeleton);\r\n    boolean inQuoted = false;\r\n    for (int patPos = 0; patPos < skeleton.length(); patPos++) {\r\n        char patChr = skeleton.charAt(patPos);\r\n        if (patChr == '\\'') {\r\n            inQuoted = !inQuoted;\r\n        } else if (!inQuoted) {\r\n            if (patChr == 'j') {\r\n                skeletonCopy.setCharAt(patPos, defaultHourFormatChar);\r\n            } else if (patChr == 'C') {\r\n                String preferred = allowedHourFormats[0];\r\n                skeletonCopy.setCharAt(patPos, preferred.charAt(0));\r\n                final DTPGflags alt = DTPGflags.getFlag(preferred);\r\n                if (alt != null) {\r\n                    flags.add(alt);\r\n                }\r\n            } else if (patChr == 'J') {\r\n                skeletonCopy.setCharAt(patPos, 'H');\r\n                flags.add(DTPGflags.SKELETON_USES_CAP_J);\r\n            }\r\n        }\r\n    }\r\n    String datePattern, timePattern;\r\n    synchronized (this) {\r\n        current.set(skeletonCopy.toString(), fp, false);\r\n        PatternWithMatcher bestWithMatcher = getBestRaw(current, -1, _distanceInfo, skipMatcher);\r\n        if (_distanceInfo.missingFieldMask == 0 && _distanceInfo.extraFieldMask == 0) {\r\n            return adjustFieldTypes(bestWithMatcher, current, flags, options);\r\n        }\r\n        int neededFields = current.getFieldMask();\r\n        datePattern = getBestAppending(current, neededFields & DATE_MASK, _distanceInfo, skipMatcher, flags, options);\r\n        timePattern = getBestAppending(current, neededFields & TIME_MASK, _distanceInfo, skipMatcher, flags, options);\r\n    }\r\n    if (datePattern == null)\r\n        return timePattern == null ? \"\" : timePattern;\r\n    if (timePattern == null)\r\n        return datePattern;\r\n    return SimpleFormatterImpl.formatRawPattern(getDateTimeFormat(), 2, 2, timePattern, datePattern);\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.contains",
	"Comment": "returns true if this set contains the givenmulticharacter string.",
	"Method": "boolean contains(int c,boolean contains,int start,int end,boolean contains,CharSequence s,boolean contains,int codePoint,boolean contains,int ch,boolean contains,int ch,boolean contains,int ch,boolean contains,int c,boolean contains,int ch){\r\n    int cp = getSingleCP(s);\r\n    if (cp < 0) {\r\n        return strings.contains(s.toString());\r\n    } else {\r\n        return contains(cp);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.SimpleFormatter.toString",
	"Comment": "returns a string similar to the original pattern, only for debugging.",
	"Method": "String toString(){\r\n    String[] values = new String[getArgumentLimit()];\r\n    for (int i = 0; i < values.length; i++) {\r\n        values[i] = \"{\" + i + '}';\r\n    }\r\n    return formatAndAppend(new StringBuilder(), null, values).toString();\r\n}"
}, {
	"Path": "android.icu.util.UResourceBundle.keySet",
	"Comment": "returns a set of all keys contained in this resourcebundle and its parent bundles.",
	"Method": "Set<String> keySet(){\r\n    Set<String> keys = null;\r\n    ICUResourceBundle icurb = null;\r\n    if (isTopLevelResource() && this instanceof ICUResourceBundle) {\r\n        icurb = (ICUResourceBundle) this;\r\n        keys = icurb.getTopLevelKeySet();\r\n    }\r\n    if (keys == null) {\r\n        if (isTopLevelResource()) {\r\n            TreeSet<String> newKeySet;\r\n            if (parent == null) {\r\n                newKeySet = new TreeSet<String>();\r\n            } else if (parent instanceof UResourceBundle) {\r\n                newKeySet = new TreeSet<String>(((UResourceBundle) parent).keySet());\r\n            } else {\r\n                newKeySet = new TreeSet<String>();\r\n                Enumeration<String> parentKeys = parent.getKeys();\r\n                while (parentKeys.hasMoreElements()) {\r\n                    newKeySet.add(parentKeys.nextElement());\r\n                }\r\n            }\r\n            newKeySet.addAll(handleKeySet());\r\n            keys = Collections.unmodifiableSet(newKeySet);\r\n            if (icurb != null) {\r\n                icurb.setTopLevelKeySet(keys);\r\n            }\r\n        } else {\r\n            return handleKeySet();\r\n        }\r\n    }\r\n    return keys;\r\n}"
}, {
	"Path": "android.icu.text.NumberFormat.getAvailableLocales",
	"Comment": "returns the list of locales for which numberformats are available.",
	"Method": "Locale[] getAvailableLocales(Locale[] getAvailableLocales){\r\n    if (shim == null) {\r\n        return ICUResourceBundle.getAvailableLocales();\r\n    }\r\n    return getShim().getAvailableLocales();\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.readStreamHeader",
	"Comment": "reads and validates the objectinputstream header from the source stream.",
	"Method": "void readStreamHeader(){\r\n    if (input.readShort() == STREAM_MAGIC && input.readShort() == STREAM_VERSION) {\r\n        return;\r\n    }\r\n    throw new StreamCorruptedException();\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.addMatchSetTo",
	"Comment": "implementation of unicodematcher api.union the set of allcharacters that may be matched by this object into the givenset.",
	"Method": "void addMatchSetTo(UnicodeSet toUnionTo){\r\n    toUnionTo.addAll(this);\r\n}"
}, {
	"Path": "java.io.ObjectStreamField.defaultResolve",
	"Comment": "resolves typestring into type. returns true if the type is primitiveand false otherwise.",
	"Method": "boolean defaultResolve(){\r\n    switch(typeString.charAt(0)) {\r\n        case 'I':\r\n            type = int.class;\r\n            return true;\r\n        case 'B':\r\n            type = byte.class;\r\n            return true;\r\n        case 'C':\r\n            type = char.class;\r\n            return true;\r\n        case 'S':\r\n            type = short.class;\r\n            return true;\r\n        case 'Z':\r\n            type = boolean.class;\r\n            return true;\r\n        case 'J':\r\n            type = long.class;\r\n            return true;\r\n        case 'F':\r\n            type = float.class;\r\n            return true;\r\n        case 'D':\r\n            type = double.class;\r\n            return true;\r\n        default:\r\n            type = Object.class;\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "libcore.java.io.OldInputStreamReaderTest.test_readWhenCharacterSpansBuffer",
	"Comment": "test for regression of a bug that dropped characters whenmultibyte encodings spanned buffer boundaries.",
	"Method": "void test_readWhenCharacterSpansBuffer(){\r\n    final byte[] suffix = { (byte) 0x93, (byte) 0xa1, (byte) 0x8c, (byte) 0xb4, (byte) 0x97, (byte) 0x43, (byte) 0x88, (byte) 0xea, (byte) 0x98, (byte) 0x59 };\r\n    final char[] decodedSuffix = { (char) 0x85e4, (char) 0x539f, (char) 0x4f51, (char) 0x4e00, (char) 0x90ce };\r\n    final int prefixLength = 8189;\r\n    byte[] bytes = new byte[prefixLength + 10];\r\n    Arrays.fill(bytes, (byte) ' ');\r\n    System.arraycopy(suffix, 0, bytes, prefixLength, suffix.length);\r\n    ByteArrayInputStream is = new ByteArrayInputStream(bytes);\r\n    try {\r\n        InputStreamReader isr = new InputStreamReader(is, \"SHIFT_JIS\");\r\n        char[] chars = new char[8192];\r\n        int at = 0;\r\n        for (; ; ) {\r\n            int amt = isr.read(chars);\r\n            if (amt <= 0) {\r\n                break;\r\n            }\r\n            for (int i = 0; i < amt; i++) {\r\n                char c = chars[i];\r\n                if (at < prefixLength) {\r\n                    if (c != ' ') {\r\n                        fail(\"Found bad prefix character \" + (int) c + \" at \" + at);\r\n                    }\r\n                } else {\r\n                    char decoded = decodedSuffix[at - prefixLength];\r\n                    if (c != decoded) {\r\n                        fail(\"Found mismatched character \" + (int) c + \" at \" + at);\r\n                    }\r\n                }\r\n                at++;\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        throw new RuntimeException(\"unexpected exception\", ex);\r\n    }\r\n}"
}, {
	"Path": "libcore.io.NetworkBridge.getSocketOption",
	"Comment": "java.net has its own socket options similar to the underlying unix ones. we paper over thedifferences here.",
	"Method": "Object getSocketOption(FileDescriptor fd,int option){\r\n    try {\r\n        return getSocketOptionErrno(fd, option);\r\n    } catch (ErrnoException errnoException) {\r\n        throw new SocketException(errnoException.getMessage(), errnoException);\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.ULocale.getLanguage",
	"Comment": "returns the language code for the locale id,which will either be the empty stringor a lowercase iso 639 code.",
	"Method": "String getLanguage(String getLanguage,String localeID){\r\n    return new LocaleIDParser(localeID).getLanguage();\r\n}"
}, {
	"Path": "android.icu.util.ChineseCalendar.isLeapMonthBetween",
	"Comment": "return true if there is a leap month on or after month newmoon1 andat or before month newmoon2.",
	"Method": "boolean isLeapMonthBetween(int newMoon1,int newMoon2){\r\n    if (synodicMonthsBetween(newMoon1, newMoon2) >= 50) {\r\n        throw new IllegalArgumentException(\"isLeapMonthBetween(\" + newMoon1 + \", \" + newMoon2 + \"): Invalid parameters\");\r\n    }\r\n    return (newMoon2 >= newMoon1) && (isLeapMonthBetween(newMoon1, newMoonNear(newMoon2 - SYNODIC_GAP, false)) || hasNoMajorSolarTerm(newMoon2));\r\n}"
}, {
	"Path": "android.icu.util.StringTrieBuilder.registerFinalValue",
	"Comment": "makes sure that there is only one unique finalvaluenode registeredwith this value.avoids creating a node if the value is a duplicate.",
	"Method": "ValueNode registerFinalValue(int value){\r\n    lookupFinalValueNode.setFinalValue(value);\r\n    Node oldNode = nodes.get(lookupFinalValueNode);\r\n    if (oldNode != null) {\r\n        return (ValueNode) oldNode;\r\n    }\r\n    ValueNode newNode = new ValueNode(value);\r\n    oldNode = nodes.put(newNode, newNode);\r\n    assert (oldNode == null);\r\n    return newNode;\r\n}"
}, {
	"Path": "android.icu.impl.CalendarAstronomer.getMoonTime",
	"Comment": "find the next or previous time at which the moon will be in thedesired phase.",
	"Method": "long getMoonTime(double desired,boolean next,long getMoonTime,MoonAge desired,boolean next){\r\n    return getMoonTime(desired.value, next);\r\n}"
}, {
	"Path": "android.icu.util.RuleBasedTimeZone.complete",
	"Comment": "resolve historic transition times and update fields used for offsetcalculation.",
	"Method": "void complete(){\r\n    if (upToDate) {\r\n        return;\r\n    }\r\n    if (finalRules != null && finalRules[1] == null) {\r\n        throw new IllegalStateException(\"Incomplete final rules\");\r\n    }\r\n    if (historicRules != null || finalRules != null) {\r\n        TimeZoneRule curRule = initialRule;\r\n        long lastTransitionTime = Grego.MIN_MILLIS;\r\n        if (historicRules != null) {\r\n            BitSet done = new BitSet(historicRules.size());\r\n            while (true) {\r\n                int curStdOffset = curRule.getRawOffset();\r\n                int curDstSavings = curRule.getDSTSavings();\r\n                long nextTransitionTime = Grego.MAX_MILLIS;\r\n                TimeZoneRule nextRule = null;\r\n                Date d;\r\n                long tt;\r\n                for (int i = 0; i < historicRules.size(); i++) {\r\n                    if (done.get(i)) {\r\n                        continue;\r\n                    }\r\n                    TimeZoneRule r = historicRules.get(i);\r\n                    d = r.getNextStart(lastTransitionTime, curStdOffset, curDstSavings, false);\r\n                    if (d == null) {\r\n                        done.set(i);\r\n                    } else {\r\n                        if (r == curRule || (r.getName().equals(curRule.getName()) && r.getRawOffset() == curRule.getRawOffset() && r.getDSTSavings() == curRule.getDSTSavings())) {\r\n                            continue;\r\n                        }\r\n                        tt = d.getTime();\r\n                        if (tt < nextTransitionTime) {\r\n                            nextTransitionTime = tt;\r\n                            nextRule = r;\r\n                        }\r\n                    }\r\n                }\r\n                if (nextRule == null) {\r\n                    boolean bDoneAll = true;\r\n                    for (int j = 0; j < historicRules.size(); j++) {\r\n                        if (!done.get(j)) {\r\n                            bDoneAll = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (bDoneAll) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (finalRules != null) {\r\n                    for (int i = 0; i < 2; i++) {\r\n                        if (finalRules[i] == curRule) {\r\n                            continue;\r\n                        }\r\n                        d = finalRules[i].getNextStart(lastTransitionTime, curStdOffset, curDstSavings, false);\r\n                        if (d != null) {\r\n                            tt = d.getTime();\r\n                            if (tt < nextTransitionTime) {\r\n                                nextTransitionTime = tt;\r\n                                nextRule = finalRules[i];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (nextRule == null) {\r\n                    break;\r\n                }\r\n                if (historicTransitions == null) {\r\n                    historicTransitions = new ArrayList<TimeZoneTransition>();\r\n                }\r\n                historicTransitions.add(new TimeZoneTransition(nextTransitionTime, curRule, nextRule));\r\n                lastTransitionTime = nextTransitionTime;\r\n                curRule = nextRule;\r\n            }\r\n        }\r\n        if (finalRules != null) {\r\n            if (historicTransitions == null) {\r\n                historicTransitions = new ArrayList<TimeZoneTransition>();\r\n            }\r\n            Date d0 = finalRules[0].getNextStart(lastTransitionTime, curRule.getRawOffset(), curRule.getDSTSavings(), false);\r\n            Date d1 = finalRules[1].getNextStart(lastTransitionTime, curRule.getRawOffset(), curRule.getDSTSavings(), false);\r\n            if (d1.after(d0)) {\r\n                historicTransitions.add(new TimeZoneTransition(d0.getTime(), curRule, finalRules[0]));\r\n                d1 = finalRules[1].getNextStart(d0.getTime(), finalRules[0].getRawOffset(), finalRules[0].getDSTSavings(), false);\r\n                historicTransitions.add(new TimeZoneTransition(d1.getTime(), finalRules[0], finalRules[1]));\r\n            } else {\r\n                historicTransitions.add(new TimeZoneTransition(d1.getTime(), curRule, finalRules[1]));\r\n                d0 = finalRules[0].getNextStart(d1.getTime(), finalRules[1].getRawOffset(), finalRules[1].getDSTSavings(), false);\r\n                historicTransitions.add(new TimeZoneTransition(d0.getTime(), finalRules[1], finalRules[0]));\r\n            }\r\n        }\r\n    }\r\n    upToDate = true;\r\n}"
}, {
	"Path": "android.icu.text.DateFormat.getDateInstance",
	"Comment": "returns the date formatter with the given formatting stylefor the given locale.",
	"Method": "DateFormat getDateInstance(DateFormat getDateInstance,int style,DateFormat getDateInstance,int style,Locale aLocale,DateFormat getDateInstance,int style,ULocale locale,DateFormat getDateInstance,Calendar cal,int dateStyle,Locale locale,DateFormat getDateInstance,Calendar cal,int dateStyle,ULocale locale,DateFormat getDateInstance,Calendar cal,int dateStyle){\r\n    return getDateInstance(cal, dateStyle, ULocale.getDefault(Category.FORMAT));\r\n}"
}, {
	"Path": "libcore.java.util.TreeMapTest.testJava5SubMapSerialization",
	"Comment": "on jdk5, this fails with a nullpointerexception after deserialization!",
	"Method": "void testJava5SubMapSerialization(){\r\n    String s = \"aced0005737200186a6176612e7574696c2e547265654d6170245375624d6170\" + \"a5818343a213c27f0200055a000966726f6d53746172745a0005746f456e644c0\" + \"00766726f6d4b65797400124c6a6176612f6c616e672f4f626a6563743b4c0006\" + \"7468697324307400134c6a6176612f7574696c2f547265654d61703b4c0005746\" + \"f4b657971007e00017870000074000161737200116a6176612e7574696c2e5472\" + \"65654d61700cc1f63e2d256ae60300014c000a636f6d70617261746f727400164\" + \"c6a6176612f7574696c2f436f6d70617261746f723b78707372002a6a6176612e\" + \"6c616e672e537472696e672443617365496e73656e736974697665436f6d70617\" + \"261746f7277035c7d5c50e5ce020000787077040000000471007e000471007e00\" + \"047400016271007e000a7400016371007e000b7400016471007e000c7871007e0\" + \"00b\";\r\n    TreeMap<String, String> map = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\r\n    map.put(\"a\", \"a\");\r\n    map.put(\"b\", \"b\");\r\n    map.put(\"c\", \"c\");\r\n    map.put(\"d\", \"d\");\r\n    SortedMap<String, String> subMap = map.subMap(\"a\", \"c\");\r\n    new SerializationTester<SortedMap<String, String>>(subMap, s) {\r\n        @Override\r\n        protected void verify(SortedMap<String, String> deserialized) {\r\n            try {\r\n                deserialized.put(\"e\", \"e\");\r\n                fail();\r\n            } catch (IllegalArgumentException expected) {\r\n            }\r\n        }\r\n    }.test();\r\n}"
}, {
	"Path": "libcore.java.util.TreeMapTest.testJava5SubMapSerialization",
	"Comment": "on jdk5, this fails with a nullpointerexception after deserialization!",
	"Method": "void testJava5SubMapSerialization(){\r\n    try {\r\n        deserialized.put(\"e\", \"e\");\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.Bidi.getRunStart",
	"Comment": "return the index of the character at the start of the nth logical run inthis line, as an offset from the start of the line.",
	"Method": "int getRunStart(int run){\r\n    verifyValidParaOrLine();\r\n    BidiLine.getRuns(this);\r\n    verifyRange(run, 0, runCount);\r\n    getLogicalToVisualRunsMap();\r\n    return runs[logicalToVisualRunsMap[run]].start;\r\n}"
}, {
	"Path": "android.icu.impl.coll.FCDIterCollationIterator.nextSegment",
	"Comment": "extends the fcd text segment forward or normalizes around pos.",
	"Method": "boolean nextSegment(){\r\n    assert (state == State.ITER_CHECK_FWD);\r\n    pos = iter.getIndex();\r\n    if (s == null) {\r\n        s = new StringBuilder();\r\n    } else {\r\n        s.setLength(0);\r\n    }\r\n    int prevCC = 0;\r\n    for (; ; ) {\r\n        int c = iter.nextCodePoint();\r\n        if (c < 0) {\r\n            break;\r\n        }\r\n        int fcd16 = nfcImpl.getFCD16(c);\r\n        int leadCC = fcd16 >> 8;\r\n        if (leadCC == 0 && s.length() != 0) {\r\n            iter.previousCodePoint();\r\n            break;\r\n        }\r\n        s.appendCodePoint(c);\r\n        if (leadCC != 0 && (prevCC > leadCC || CollationFCD.isFCD16OfTibetanCompositeVowel(fcd16))) {\r\n            for (; ; ) {\r\n                c = iter.nextCodePoint();\r\n                if (c < 0) {\r\n                    break;\r\n                }\r\n                if (nfcImpl.getFCD16(c) <= 0xff) {\r\n                    iter.previousCodePoint();\r\n                    break;\r\n                }\r\n                s.appendCodePoint(c);\r\n            }\r\n            normalize(s);\r\n            start = pos;\r\n            limit = pos + s.length();\r\n            state = State.IN_NORM_ITER_AT_LIMIT;\r\n            pos = 0;\r\n            return true;\r\n        }\r\n        prevCC = fcd16 & 0xff;\r\n        if (prevCC == 0) {\r\n            break;\r\n        }\r\n    }\r\n    limit = pos + s.length();\r\n    assert (pos != limit);\r\n    iter.moveIndex(-s.length());\r\n    state = State.ITER_IN_FCD_SEGMENT;\r\n    return true;\r\n}"
}, {
	"Path": "android.icu.impl.duration.TimeUnit.larger",
	"Comment": "returns the next larger time unit, or null if this is the largest.",
	"Method": "TimeUnit larger(){\r\n    return ordinal == 0 ? null : units[ordinal - 1];\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.CompatibilityTest.TestGregorianChangeover",
	"Comment": "test the behavior of the gregoriancalendar around the changeover.",
	"Method": "void TestGregorianChangeover(){\r\n    java.util.TimeZone jdkGMT = java.util.TimeZone.getTimeZone(\"GMT\");\r\n    java.util.Calendar jdkCal = java.util.Calendar.getInstance(jdkGMT);\r\n    jdkCal.clear();\r\n    jdkCal.set(1582, Calendar.OCTOBER, 15);\r\n    long a = jdkCal.getTime().getTime();\r\n    Date c = jdkCal.getTime();\r\n    c.toString();\r\n    long b = c.getTime();\r\n    if (a != b) {\r\n        logln(\" \" + a + \" != \" + b);\r\n        logln(\"JDK has Gregorian cutover anomaly (1.5?) - skipping this test.\");\r\n        return;\r\n    }\r\n    Date co = jdkCal.getTime();\r\n    logln(\"Change over (Oct 15 1582) = \" + co + \" (\" + co.getTime() + \")\");\r\n    final int ONE_DAY = 24 * 60 * 60 * 1000;\r\n    TimeZone gmt = TimeZone.getTimeZone(\"GMT\");\r\n    GregorianCalendar cal = new GregorianCalendar(gmt);\r\n    int[] MON = { 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 };\r\n    int[] DOM = { 28, 29, 30, 1, 2, 3, 4, 15, 16, 17, 18, 19, 20, 21, 22 };\r\n    int[] DOW = { 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6 };\r\n    int j = 0;\r\n    for (int i = -7; i <= 7; ++i, ++j) {\r\n        Date d = new Date(co.getTime() + i * ONE_DAY);\r\n        cal.setTime(d);\r\n        int y = cal.get(Calendar.YEAR), mon = cal.get(Calendar.MONTH) + 1 - Calendar.JANUARY, dom = cal.get(Calendar.DATE), dow = cal.get(Calendar.DAY_OF_WEEK);\r\n        logln(\"Changeover \" + (i >= 0 ? \"+\" : \"\") + i + \" days: \" + y + \"/\" + mon + \"/\" + dom + \" dow=\" + dow);\r\n        if (y != 1582 || mon != MON[j] || dom != DOM[j] || dow != DOW[j])\r\n            errln(\" Fail: Above line is wrong\");\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.addAllTo",
	"Comment": "utility for adding the contents of an iterable to a collection.",
	"Method": "T addAllTo(T target,String[] addAllTo,String[] target,U addAllTo,Iterable<T> source,U target,T[] addAllTo,Iterable<T> source,T[] target){\r\n    int i = 0;\r\n    for (T item : source) {\r\n        target[i++] = item;\r\n    }\r\n    return target;\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedCollator.setUpperCaseFirst",
	"Comment": "sets whether uppercase characters sort before lowercase characters or vice versa, in strength tertiary. thedefault mode is false, and so lowercase characters sort before uppercase characters. if true, sort upper casecharacters first.",
	"Method": "void setUpperCaseFirst(boolean upperfirst){\r\n    checkNotFrozen();\r\n    if (upperfirst == isUpperCaseFirst()) {\r\n        return;\r\n    }\r\n    CollationSettings ownedSettings = getOwnedSettings();\r\n    ownedSettings.setCaseFirst(upperfirst ? CollationSettings.CASE_FIRST_AND_UPPER_MASK : 0);\r\n    setFastLatinOptions(ownedSettings);\r\n}"
}, {
	"Path": "android.icu.impl.ICUBinary.getByteBufferFromInputStreamAndCloseStream",
	"Comment": "reads the entire contents from the stream into a byte arrayand wraps it into a bytebuffer. closes the inputstream at the end.",
	"Method": "ByteBuffer getByteBufferFromInputStreamAndCloseStream(InputStream is){\r\n    try {\r\n        byte[] bytes;\r\n        int avail = is.available();\r\n        if (avail > 32) {\r\n            bytes = new byte[avail];\r\n        } else {\r\n            bytes = new byte[128];\r\n        }\r\n        int length = 0;\r\n        for (; ; ) {\r\n            if (length < bytes.length) {\r\n                int numRead = is.read(bytes, length, bytes.length - length);\r\n                if (numRead < 0) {\r\n                    break;\r\n                }\r\n                length += numRead;\r\n            } else {\r\n                int nextByte = is.read();\r\n                if (nextByte < 0) {\r\n                    break;\r\n                }\r\n                int capacity = 2 * bytes.length;\r\n                if (capacity < 128) {\r\n                    capacity = 128;\r\n                } else if (capacity < 0x4000) {\r\n                    capacity *= 2;\r\n                }\r\n                byte[] newBytes = new byte[capacity];\r\n                System.arraycopy(bytes, 0, newBytes, 0, length);\r\n                bytes = newBytes;\r\n                bytes[length++] = (byte) nextByte;\r\n            }\r\n        }\r\n        return ByteBuffer.wrap(bytes, 0, length);\r\n    } finally {\r\n        is.close();\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.Bidi.getRunLimit",
	"Comment": "return the index of the character past the end of the nth logical run inthis line, as an offset from the start of the line. for example, thiswill return the length of the line for the last run on the line.",
	"Method": "int getRunLimit(int run){\r\n    verifyValidParaOrLine();\r\n    BidiLine.getRuns(this);\r\n    verifyRange(run, 0, runCount);\r\n    getLogicalToVisualRunsMap();\r\n    int idx = logicalToVisualRunsMap[run];\r\n    int len = idx == 0 ? runs[idx].limit : runs[idx].limit - runs[idx - 1].limit;\r\n    return runs[idx].start + len;\r\n}"
}, {
	"Path": "android.icu.text.TimeZoneFormat.parseDefaultOffsetFields",
	"Comment": "parses the input gmt offset fields with the default offset pattern.",
	"Method": "int parseDefaultOffsetFields(String text,int start,char separator,int[] parsedLen){\r\n    int max = text.length();\r\n    int idx = start;\r\n    int[] len = { 0 };\r\n    int hour = 0, min = 0, sec = 0;\r\n    do {\r\n        hour = parseOffsetFieldWithLocalizedDigits(text, idx, 1, 2, 0, MAX_OFFSET_HOUR, len);\r\n        if (len[0] == 0) {\r\n            break;\r\n        }\r\n        idx += len[0];\r\n        if (idx + 1 < max && text.charAt(idx) == separator) {\r\n            min = parseOffsetFieldWithLocalizedDigits(text, idx + 1, 2, 2, 0, MAX_OFFSET_MINUTE, len);\r\n            if (len[0] == 0) {\r\n                break;\r\n            }\r\n            idx += (1 + len[0]);\r\n            if (idx + 1 < max && text.charAt(idx) == separator) {\r\n                sec = parseOffsetFieldWithLocalizedDigits(text, idx + 1, 2, 2, 0, MAX_OFFSET_SECOND, len);\r\n                if (len[0] == 0) {\r\n                    break;\r\n                }\r\n                idx += (1 + len[0]);\r\n            }\r\n        }\r\n    } while (false);\r\n    if (idx == start) {\r\n        parsedLen[0] = 0;\r\n        return 0;\r\n    }\r\n    parsedLen[0] = idx - start;\r\n    return hour * MILLIS_PER_HOUR + min * MILLIS_PER_MINUTE + sec * MILLIS_PER_SECOND;\r\n}"
}, {
	"Path": "android.icu.util.GregorianCalendar.inDaylightTime",
	"Comment": "return true if the current time for this calendar is in dayligntsavings time.",
	"Method": "boolean inDaylightTime(){\r\n    if (!getTimeZone().useDaylightTime())\r\n        return false;\r\n    complete();\r\n    return internalGet(DST_OFFSET) != 0;\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.nextHandle",
	"Comment": "return the next handle to be used to indicate cyclicreferences being saved to the stream.",
	"Method": "int nextHandle(){\r\n    return currentHandle++;\r\n}"
}, {
	"Path": "android.icu.text.QuantityFormatter.format",
	"Comment": "formats the pattern with the value and adjusts the fieldposition.",
	"Method": "String format(double number,NumberFormat numberFormat,PluralRules pluralRules,StringBuilder format,String compiledPattern,CharSequence value,StringBuilder appendTo,FieldPosition pos){\r\n    int[] offsets = new int[1];\r\n    SimpleFormatterImpl.formatAndAppend(compiledPattern, appendTo, offsets, value);\r\n    if (pos.getBeginIndex() != 0 || pos.getEndIndex() != 0) {\r\n        if (offsets[0] >= 0) {\r\n            pos.setBeginIndex(pos.getBeginIndex() + offsets[0]);\r\n            pos.setEndIndex(pos.getEndIndex() + offsets[0]);\r\n        } else {\r\n            pos.setBeginIndex(0);\r\n            pos.setEndIndex(0);\r\n        }\r\n    }\r\n    return appendTo;\r\n}"
}, {
	"Path": "java.nio.charset.Charset.toString",
	"Comment": "gets a string representation of this charset. usually this contains thecanonical name of the charset.",
	"Method": "String toString(){\r\n    return getClass().getName() + \"[\" + this.canonicalName + \"]\";\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.stats",
	"Comment": "when the statistics for this service is already enabled,return the log and resets he statistics.when the statistics is not enabled, this method enablethe statistics. used for debugging purposes.",
	"Method": "String stats(){\r\n    ICURWLock.Stats stats = factoryLock.resetStats();\r\n    if (stats != null) {\r\n        return stats.toString();\r\n    }\r\n    return \"no stats\";\r\n}"
}, {
	"Path": "android.icu.util.Currency.getTenderCurrencies",
	"Comment": "returns the list of remaining tender currencies after a filter is applied.",
	"Method": "List<String> getTenderCurrencies(CurrencyFilter filter){\r\n    CurrencyMetaInfo info = CurrencyMetaInfo.getInstance();\r\n    return info.currencies(filter.withTender());\r\n}"
}, {
	"Path": "android.icu.lang.UScriptRun.sameScript",
	"Comment": "compare two script codes to see if they are in the same script. if one script isa strong script, and the other is inherited or common, it will compare equal.",
	"Method": "boolean sameScript(int scriptOne,int scriptTwo){\r\n    return scriptOne <= UScript.INHERITED || scriptTwo <= UScript.INHERITED || scriptOne == scriptTwo;\r\n}"
}, {
	"Path": "android.icu.impl.ZoneMeta.getCustomID",
	"Comment": "parse a custom time zone identifier and return the normalizedcustom time zone identifier for the given custom id string.",
	"Method": "String getCustomID(String id){\r\n    int[] fields = new int[4];\r\n    if (parseCustomID(id, fields)) {\r\n        return formatCustomID(fields[1], fields[2], fields[3], fields[0] < 0);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationTest.getOrders",
	"Comment": "return an integer array containing all of the collation ordersreturned by calls to next on the specified iterator",
	"Method": "int[] getOrders(CollationElementIterator iter){\r\n    int maxSize = 100;\r\n    int size = 0;\r\n    int[] orders = new int[maxSize];\r\n    int order;\r\n    while ((order = iter.next()) != CollationElementIterator.NULLORDER) {\r\n        if (size == maxSize) {\r\n            maxSize *= 2;\r\n            int[] temp = new int[maxSize];\r\n            System.arraycopy(orders, 0, temp, 0, size);\r\n            orders = temp;\r\n        }\r\n        orders[size++] = order;\r\n    }\r\n    if (maxSize > size) {\r\n        int[] temp = new int[size];\r\n        System.arraycopy(orders, 0, temp, 0, size);\r\n        orders = temp;\r\n    }\r\n    return orders;\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.getField",
	"Comment": "gets a field descriptor of the class represented by this classdescriptor.",
	"Method": "ObjectStreamField getField(String name){\r\n    ObjectStreamField[] allFields = getFields();\r\n    for (int i = 0; i < allFields.length; i++) {\r\n        ObjectStreamField f = allFields[i];\r\n        if (f.getName().equals(name)) {\r\n            return f;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.impl.LocaleIDParser.parseKeywords",
	"Comment": "parse the keywords and return start of the string in the buffer.",
	"Method": "int parseKeywords(){\r\n    int oldBlen = buffer.length();\r\n    Map<String, String> m = getKeywordMap();\r\n    if (!m.isEmpty()) {\r\n        boolean first = true;\r\n        for (Map.Entry<String, String> e : m.entrySet()) {\r\n            append(first ? KEYWORD_SEPARATOR : ITEM_SEPARATOR);\r\n            first = false;\r\n            append(e.getKey());\r\n            append(KEYWORD_ASSIGN);\r\n            append(e.getValue());\r\n        }\r\n        if (first == false) {\r\n            ++oldBlen;\r\n        }\r\n    }\r\n    return oldBlen;\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.getDisplayNames",
	"Comment": "return a snapshot of the mapping from display names to visibleids for this service.this set will not change as factoriesare added or removed, but the supported ids will, so there isno guarantee that all and only the ids in the returned map willbe visible and supported by the service in subsequent calls,nor is there any guarantee that the current display names matchthose in the set.the display names are sorted based on thecomparator provided.",
	"Method": "SortedMap<String, String> getDisplayNames(SortedMap<String, String> getDisplayNames,ULocale locale,SortedMap<String, String> getDisplayNames,ULocale locale,Comparator<Object> com,SortedMap<String, String> getDisplayNames,ULocale locale,String matchID,SortedMap<String, String> getDisplayNames,ULocale locale,Comparator<Object> com,String matchID){\r\n    SortedMap<String, String> dncache = null;\r\n    LocaleRef ref = dnref;\r\n    if (ref != null) {\r\n        dncache = ref.get(locale, com);\r\n    }\r\n    while (dncache == null) {\r\n        synchronized (this) {\r\n            if (ref == dnref || dnref == null) {\r\n                dncache = new TreeMap<String, String>(com);\r\n                Map<String, Factory> m = getVisibleIDMap();\r\n                Iterator<Entry<String, Factory>> ei = m.entrySet().iterator();\r\n                while (ei.hasNext()) {\r\n                    Entry<String, Factory> e = ei.next();\r\n                    String id = e.getKey();\r\n                    Factory f = e.getValue();\r\n                    dncache.put(f.getDisplayName(id, locale), id);\r\n                }\r\n                dncache = Collections.unmodifiableSortedMap(dncache);\r\n                dnref = new LocaleRef(dncache, locale, com);\r\n            } else {\r\n                ref = dnref;\r\n                dncache = ref.get(locale, com);\r\n            }\r\n        }\r\n    }\r\n    Key matchKey = createKey(matchID);\r\n    if (matchKey == null) {\r\n        return dncache;\r\n    }\r\n    SortedMap<String, String> result = new TreeMap<String, String>(dncache);\r\n    Iterator<Entry<String, String>> iter = result.entrySet().iterator();\r\n    while (iter.hasNext()) {\r\n        Entry<String, String> e = iter.next();\r\n        if (!matchKey.isFallbackOf(e.getValue())) {\r\n            iter.remove();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.impl.coll.BOCSU.getNegDivMod",
	"Comment": "integer division and modulo with negative numeratorsyields negative modulo results and quotients that are one more thanwhat we need here.",
	"Method": "long getNegDivMod(int number,int factor){\r\n    int modulo = number % factor;\r\n    long result = number / factor;\r\n    if (modulo < 0) {\r\n        --result;\r\n        modulo += factor;\r\n    }\r\n    return (result << 32) | modulo;\r\n}"
}, {
	"Path": "java.nio.charset.Charset.canEncode",
	"Comment": "returns true if this charset supports encoding, false otherwise.",
	"Method": "boolean canEncode(){\r\n    return true;\r\n}"
}, {
	"Path": "android.icu.impl.Trie.checkHeader",
	"Comment": "authenticates raw data header. checking the header information, signature and options.",
	"Method": "boolean checkHeader(int signature){\r\n    if (signature != HEADER_SIGNATURE_) {\r\n        return false;\r\n    }\r\n    if ((m_options_ & HEADER_OPTIONS_SHIFT_MASK_) != INDEX_STAGE_1_SHIFT_ || ((m_options_ >> HEADER_OPTIONS_INDEX_SHIFT_) & HEADER_OPTIONS_SHIFT_MASK_) != INDEX_STAGE_2_SHIFT_) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "android.icu.impl.ICUNotifier.removeListener",
	"Comment": "stop notifying this listener.the listener mustnot be null.attemps to remove a listener that isnot registered will be silently ignored.",
	"Method": "void removeListener(EventListener l){\r\n    if (l == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    synchronized (notifyLock) {\r\n        if (listeners != null) {\r\n            Iterator<EventListener> iter = listeners.iterator();\r\n            while (iter.hasNext()) {\r\n                if (iter.next() == l) {\r\n                    iter.remove();\r\n                    if (listeners.size() == 0) {\r\n                        listeners = null;\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.CalendarRegressionTest.TestT9968",
	"Comment": "test case for ticket 9968subparse fails to return an error indication when start pos is 0",
	"Method": "void TestT9968(){\r\n    SimpleDateFormat sdf0 = new SimpleDateFormat(\"-MMMM\");\r\n    ParsePosition pos0 = new ParsePosition(0);\r\n    sdf0.parse(\"-September\", pos0);\r\n    logln(\"sdf0: \" + pos0.getErrorIndex() + \"/\" + pos0.getIndex());\r\n    assertTrue(\"Fail: failed a good test\", pos0.getErrorIndex() == -1);\r\n    SimpleDateFormat sdf1 = new SimpleDateFormat(\"-MMMM\");\r\n    ParsePosition pos1 = new ParsePosition(0);\r\n    sdf1.parse(\"-????\", pos1);\r\n    logln(\"sdf1: \" + pos1.getErrorIndex() + \"/\" + pos1.getIndex());\r\n    assertTrue(\"Fail: failed to detect bad parse\", pos1.getErrorIndex() == 1);\r\n    SimpleDateFormat sdf2 = new SimpleDateFormat(\"MMMM\");\r\n    ParsePosition pos2 = new ParsePosition(0);\r\n    sdf2.parse(\"????\", pos2);\r\n    logln(\"sdf2: \" + pos2.getErrorIndex() + \"/\" + pos2.getIndex());\r\n    assertTrue(\"Fail: failed to detect bad parse\", pos2.getErrorIndex() == 0);\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedNumberFormat.format",
	"Comment": "formats the specified number according to the specified rule set.",
	"Method": "String format(double number,String ruleSet,String format,long number,String ruleSet,StringBuffer format,double number,StringBuffer toAppendTo,FieldPosition ignore,StringBuffer format,long number,StringBuffer toAppendTo,FieldPosition ignore,StringBuffer format,BigInteger number,StringBuffer toAppendTo,FieldPosition pos,StringBuffer format,java.math.BigDecimal number,StringBuffer toAppendTo,FieldPosition pos,StringBuffer format,android.icu.math.BigDecimal number,StringBuffer toAppendTo,FieldPosition pos,String format,double number,NFRuleSet ruleSet,String format,long number,NFRuleSet ruleSet){\r\n    StringBuilder result = new StringBuilder();\r\n    if (number == Long.MIN_VALUE) {\r\n        result.append(getDecimalFormat().format(Long.MIN_VALUE));\r\n    } else {\r\n        ruleSet.format(number, result, 0, 0);\r\n    }\r\n    postProcess(result, ruleSet);\r\n    return result.toString();\r\n}"
}, {
	"Path": "java.text.Collator.compare",
	"Comment": "compares two objects to determine their relative order. the objects mustbe strings.",
	"Method": "int compare(Object object1,Object object2,int compare,String string1,String string2){\r\n    return compare((String) object1, (String) object2);\r\n}"
}, {
	"Path": "android.icu.text.CompoundTransliterator.safeClone",
	"Comment": "temporary hack for registry problem. needs to be replaced by better architecture.",
	"Method": "Transliterator safeClone(){\r\n    UnicodeFilter filter = getFilter();\r\n    if (filter != null && filter instanceof UnicodeSet) {\r\n        filter = new UnicodeSet((UnicodeSet) filter);\r\n    }\r\n    return new CompoundTransliterator(getID(), filter, trans, numAnonymousRBTs);\r\n}"
}, {
	"Path": "android.icu.util.UResourceBundle.findTopLevel",
	"Comment": "returns a resource in a given resource that has a given index, or null if theresource is not found.",
	"Method": "UResourceBundle findTopLevel(String aKey,UResourceBundle findTopLevel,int index){\r\n    for (UResourceBundle res = this; res != null; res = res.getParent()) {\r\n        UResourceBundle obj = res.handleGet(index, null, this);\r\n        if (obj != null) {\r\n            return obj;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.setNaN",
	"Comment": "sets the string used to represent nan. almost always leftunchanged.",
	"Method": "void setNaN(String NaN){\r\n    this.NaN = NaN;\r\n}"
}, {
	"Path": "android.icu.impl.Trie.getBMPOffset",
	"Comment": "gets the offset to data which the bmp character points to treats a lead surrogate as a normal code point.",
	"Method": "int getBMPOffset(char ch){\r\n    return (ch >= UTF16.LEAD_SURROGATE_MIN_VALUE && ch <= UTF16.LEAD_SURROGATE_MAX_VALUE) ? getRawOffset(LEAD_INDEX_OFFSET_, ch) : getRawOffset(0, ch);\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.setDecimalPatternMatchRequired",
	"Comment": "when decimal match is not required, the input does not have tocontain a decimal mark when there is a decimal mark specified in thepattern.",
	"Method": "void setDecimalPatternMatchRequired(boolean value){\r\n    parseRequireDecimalPoint = value;\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.IBMCalendarTest.TestLeapFieldDifference",
	"Comment": "test behavior of fielddifference around leap years.also test a largefield difference to check binary search.",
	"Method": "void TestLeapFieldDifference(){\r\n    Calendar cal = Calendar.getInstance();\r\n    cal.set(2004, Calendar.FEBRUARY, 29);\r\n    Date date2004 = cal.getTime();\r\n    cal.set(2000, Calendar.FEBRUARY, 29);\r\n    Date date2000 = cal.getTime();\r\n    int y = cal.fieldDifference(date2004, Calendar.YEAR);\r\n    int d = cal.fieldDifference(date2004, Calendar.DAY_OF_YEAR);\r\n    if (d == 0) {\r\n        logln(\"Ok: 2004/Feb/29 - 2000/Feb/29 = \" + y + \" years, \" + d + \" days\");\r\n    } else {\r\n        errln(\"FAIL: 2004/Feb/29 - 2000/Feb/29 = \" + y + \" years, \" + d + \" days\");\r\n    }\r\n    cal.setTime(date2004);\r\n    y = cal.fieldDifference(date2000, Calendar.YEAR);\r\n    d = cal.fieldDifference(date2000, Calendar.DAY_OF_YEAR);\r\n    if (d == 0) {\r\n        logln(\"Ok: 2000/Feb/29 - 2004/Feb/29 = \" + y + \" years, \" + d + \" days\");\r\n    } else {\r\n        errln(\"FAIL: 2000/Feb/29 - 2004/Feb/29 = \" + y + \" years, \" + d + \" days\");\r\n    }\r\n    cal.set(2001, Calendar.APRIL, 5);\r\n    Date ayl = cal.getTime();\r\n    cal.set(1964, Calendar.SEPTEMBER, 7);\r\n    Date asl = cal.getTime();\r\n    d = cal.fieldDifference(ayl, Calendar.DAY_OF_MONTH);\r\n    cal.setTime(ayl);\r\n    int d2 = cal.fieldDifference(asl, Calendar.DAY_OF_MONTH);\r\n    if (d == -d2 && d == 13359) {\r\n        logln(\"Ok: large field difference symmetrical \" + d);\r\n    } else {\r\n        logln(\"FAIL: large field difference incorrect \" + d + \", \" + d2 + \", expect +/- 13359\");\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.readObjectOverride",
	"Comment": "method to be overridden by subclasses to read the next object from thesource stream.",
	"Method": "Object readObjectOverride(){\r\n    if (input == null) {\r\n        return null;\r\n    }\r\n    throw new IOException();\r\n}"
}, {
	"Path": "android.icu.text.AlphabeticIndex.getFirstCharactersInScripts",
	"Comment": "return a list of the first character in each script. only exposed for testing.",
	"Method": "List<String> getFirstCharactersInScripts(){\r\n    List<String> dest = new ArrayList<String>(200);\r\n    UnicodeSet set = new UnicodeSet();\r\n    collatorPrimaryOnly.internalAddContractions(0xFDD1, set);\r\n    if (set.isEmpty()) {\r\n        throw new UnsupportedOperationException(\"AlphabeticIndex requires script-first-primary contractions\");\r\n    }\r\n    for (String boundary : set) {\r\n        int gcMask = 1 << UCharacter.getType(boundary.codePointAt(1));\r\n        if ((gcMask & (GC_L_MASK | GC_CN_MASK)) == 0) {\r\n            continue;\r\n        }\r\n        dest.add(boundary);\r\n    }\r\n    return dest;\r\n}"
}, {
	"Path": "java.io.RandomAccessFile.getFilePointer",
	"Comment": "gets the current position within this file. all reads andwrites take place at the current file pointer position.",
	"Method": "long getFilePointer(){\r\n    try {\r\n        return Libcore.os.lseek(fd, 0L, SEEK_CUR);\r\n    } catch (ErrnoException errnoException) {\r\n        throw errnoException.rethrowAsIOException();\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.NumberingSystem.getName",
	"Comment": "returns the string representing the name of the numbering system.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "android.icu.impl.coll.CollationRootElements.lastCEWithPrimaryBefore",
	"Comment": "returns the last root ce with a primary weight before p.intended only for reordering group boundaries.",
	"Method": "long lastCEWithPrimaryBefore(long p){\r\n    if (p == 0) {\r\n        return 0;\r\n    }\r\n    assert (p > elements[(int) elements[IX_FIRST_PRIMARY_INDEX]]);\r\n    int index = findP(p);\r\n    long q = elements[index];\r\n    long secTer;\r\n    if (p == (q & 0xffffff00L)) {\r\n        assert ((q & PRIMARY_STEP_MASK) == 0);\r\n        secTer = elements[index - 1];\r\n        if ((secTer & SEC_TER_DELTA_FLAG) == 0) {\r\n            p = secTer & 0xffffff00L;\r\n            secTer = Collation.COMMON_SEC_AND_TER_CE;\r\n        } else {\r\n            index -= 2;\r\n            for (; ; ) {\r\n                p = elements[index];\r\n                if ((p & SEC_TER_DELTA_FLAG) == 0) {\r\n                    p &= 0xffffff00L;\r\n                    break;\r\n                }\r\n                --index;\r\n            }\r\n        }\r\n    } else {\r\n        p = q & 0xffffff00L;\r\n        secTer = Collation.COMMON_SEC_AND_TER_CE;\r\n        for (; ; ) {\r\n            q = elements[++index];\r\n            if ((q & SEC_TER_DELTA_FLAG) == 0) {\r\n                assert ((q & PRIMARY_STEP_MASK) == 0);\r\n                break;\r\n            }\r\n            secTer = q;\r\n        }\r\n    }\r\n    return (p << 32) | (secTer & ~SEC_TER_DELTA_FLAG);\r\n}"
}, {
	"Path": "org.apache.harmony.xml.dom.TextImpl.firstTextNodeInCurrentRun",
	"Comment": "returns the first text or cdata node in the current sequence of text andcdata nodes.",
	"Method": "TextImpl firstTextNodeInCurrentRun(){\r\n    TextImpl firstTextInCurrentRun = this;\r\n    for (Node p = getPreviousSibling(); p != null; p = p.getPreviousSibling()) {\r\n        short nodeType = p.getNodeType();\r\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\r\n            firstTextInCurrentRun = (TextImpl) p;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    return firstTextInCurrentRun;\r\n}"
}, {
	"Path": "android.icu.text.ReplaceableString.length",
	"Comment": "return the number of characters contained in this object.replaceable api.",
	"Method": "int length(){\r\n    return buf.length();\r\n}"
}, {
	"Path": "android.icu.impl.UCharacterName.convert",
	"Comment": "converts the char set cset into a unicode set uset.equivalent to charsettouset.",
	"Method": "void convert(int set,UnicodeSet uset){\r\n    uset.clear();\r\n    if (!initNameSetsLengths()) {\r\n        return;\r\n    }\r\n    for (char c = 255; c > 0; c--) {\r\n        if (contains(set, c)) {\r\n            uset.add(c);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.ULocale.getVariant",
	"Comment": "returns the variant code for this locale, which might be the empty string.",
	"Method": "String getVariant(String getVariant,String localeID){\r\n    return new LocaleIDParser(localeID).getVariant();\r\n}"
}, {
	"Path": "libcore.java.io.InterruptedStreamTest.newSocketChannelPair",
	"Comment": "returns a pair of connected sockets backed by nio socket channels.",
	"Method": "Socket[] newSocketChannelPair(){\r\n    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\r\n    serverSocketChannel.socket().bind(new InetSocketAddress(0));\r\n    SocketChannel clientSocketChannel = SocketChannel.open();\r\n    clientSocketChannel.connect(serverSocketChannel.socket().getLocalSocketAddress());\r\n    SocketChannel server = serverSocketChannel.accept();\r\n    serverSocketChannel.close();\r\n    return new Socket[] { clientSocketChannel.socket(), server.socket() };\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.lookupAny",
	"Comment": "returns the descriptor for any class, whether or not the classimplements serializable or externalizable.",
	"Method": "ObjectStreamClass lookupAny(Class<?> cl){\r\n    return lookupStreamClass(cl);\r\n}"
}, {
	"Path": "java.util.Grego.previousMonthLength",
	"Comment": "return the length of a previous month of the gregorian calendar.",
	"Method": "int previousMonthLength(int year,int month){\r\n    return (month > 0) ? monthLength(year, month - 1) : 31;\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.getInstance",
	"Comment": "creates an instance of simpledateformat for the given format configuration",
	"Method": "SimpleDateFormat getInstance(Calendar.FormatConfiguration formatConfig){\r\n    String ostr = formatConfig.getOverrideString();\r\n    boolean useFast = (ostr != null && ostr.length() > 0);\r\n    return new SimpleDateFormat(formatConfig.getPatternString(), formatConfig.getDateFormatSymbols(), formatConfig.getCalendar(), null, formatConfig.getLocale(), useFast, formatConfig.getOverrideString());\r\n}"
}, {
	"Path": "android.icu.util.StringTokenizer.nextElement",
	"Comment": "returns the same value as the nexttoken method, except that its declared return value is object rather than string. it exists so that this class can implement the enumeration interface.",
	"Method": "Object nextElement(){\r\n    return nextToken();\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedBreakIterator.following",
	"Comment": "sets the iterator to refer to the first boundary position followingthe specified position.",
	"Method": "int following(int offset){\r\n    CharacterIterator text = getText();\r\n    if (fCachedBreakPositions == null || offset < fCachedBreakPositions[0] || offset >= fCachedBreakPositions[fCachedBreakPositions.length - 1]) {\r\n        fCachedBreakPositions = null;\r\n        return rulesFollowing(offset);\r\n    } else {\r\n        fPositionInCache = 0;\r\n        while (fPositionInCache < fCachedBreakPositions.length && offset >= fCachedBreakPositions[fPositionInCache]) ++fPositionInCache;\r\n        text.setIndex(fCachedBreakPositions[fPositionInCache]);\r\n        return text.getIndex();\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.VersionInfo.getInstance",
	"Comment": "returns an instance of versioninfo with the argument version.",
	"Method": "VersionInfo getInstance(String version,VersionInfo getInstance,int major,int minor,int milli,int micro,VersionInfo getInstance,int major,int minor,int milli,VersionInfo getInstance,int major,int minor,VersionInfo getInstance,int major){\r\n    return getInstance(major, 0, 0, 0);\r\n}"
}, {
	"Path": "org.apache.harmony.xml.dom.DocumentImpl.shallowCopy",
	"Comment": "returns a shallow copy of the given node. if the node is an element node,its attributes are always copied.",
	"Method": "NodeImpl shallowCopy(short operation,Node node){\r\n    switch(node.getNodeType()) {\r\n        case Node.ATTRIBUTE_NODE:\r\n            AttrImpl attr = (AttrImpl) node;\r\n            AttrImpl attrCopy;\r\n            if (attr.namespaceAware) {\r\n                attrCopy = createAttributeNS(attr.getNamespaceURI(), attr.getLocalName());\r\n                attrCopy.setPrefix(attr.getPrefix());\r\n            } else {\r\n                attrCopy = createAttribute(attr.getName());\r\n            }\r\n            attrCopy.setNodeValue(attr.getValue());\r\n            return attrCopy;\r\n        case Node.CDATA_SECTION_NODE:\r\n            return createCDATASection(((CharacterData) node).getData());\r\n        case Node.COMMENT_NODE:\r\n            return createComment(((Comment) node).getData());\r\n        case Node.DOCUMENT_FRAGMENT_NODE:\r\n            return createDocumentFragment();\r\n        case Node.DOCUMENT_NODE:\r\n        case Node.DOCUMENT_TYPE_NODE:\r\n            throw new DOMException(DOMException.NOT_SUPPORTED_ERR, \"Cannot copy node of type \" + node.getNodeType());\r\n        case Node.ELEMENT_NODE:\r\n            ElementImpl element = (ElementImpl) node;\r\n            ElementImpl elementCopy;\r\n            if (element.namespaceAware) {\r\n                elementCopy = createElementNS(element.getNamespaceURI(), element.getLocalName());\r\n                elementCopy.setPrefix(element.getPrefix());\r\n            } else {\r\n                elementCopy = createElement(element.getTagName());\r\n            }\r\n            NamedNodeMap attributes = element.getAttributes();\r\n            for (int i = 0; i < attributes.getLength(); i++) {\r\n                AttrImpl elementAttr = (AttrImpl) attributes.item(i);\r\n                AttrImpl elementAttrCopy = (AttrImpl) shallowCopy(operation, elementAttr);\r\n                notifyUserDataHandlers(operation, elementAttr, elementAttrCopy);\r\n                if (elementAttr.namespaceAware) {\r\n                    elementCopy.setAttributeNodeNS(elementAttrCopy);\r\n                } else {\r\n                    elementCopy.setAttributeNode(elementAttrCopy);\r\n                }\r\n            }\r\n            return elementCopy;\r\n        case Node.ENTITY_NODE:\r\n        case Node.NOTATION_NODE:\r\n            throw new UnsupportedOperationException();\r\n        case Node.ENTITY_REFERENCE_NODE:\r\n            return createEntityReference(node.getNodeName());\r\n        case Node.PROCESSING_INSTRUCTION_NODE:\r\n            ProcessingInstruction pi = (ProcessingInstruction) node;\r\n            return createProcessingInstruction(pi.getTarget(), pi.getData());\r\n        case Node.TEXT_NODE:\r\n            return createTextNode(((Text) node).getData());\r\n        default:\r\n            throw new DOMException(DOMException.NOT_SUPPORTED_ERR, \"Unsupported node type \" + node.getNodeType());\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.setSerialVersionUID",
	"Comment": "set the serial version user id of the class represented by the receiver",
	"Method": "void setSerialVersionUID(long l){\r\n    svUID = l;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.resetActualRounding",
	"Comment": "set roundingdouble, roundingdoublereciprocal and actualroundingincrementbased on rounding mode and width of fractional digits. whenever setting affectingrounding mode, rounding increment and maximum width of fractional digits, thenthis method must be called.roundingincrementicu is the field storing the custom rounding increment value,while actual rounding increment could be larger.",
	"Method": "void resetActualRounding(){\r\n    if (roundingIncrementICU != null) {\r\n        BigDecimal byWidth = getMaximumFractionDigits() > 0 ? BigDecimal.ONE.movePointLeft(getMaximumFractionDigits()) : BigDecimal.ONE;\r\n        if (roundingIncrementICU.compareTo(byWidth) >= 0) {\r\n            actualRoundingIncrementICU = roundingIncrementICU;\r\n        } else {\r\n            actualRoundingIncrementICU = byWidth.equals(BigDecimal.ONE) ? null : byWidth;\r\n        }\r\n    } else {\r\n        if (roundingMode == BigDecimal.ROUND_HALF_EVEN || isScientificNotation()) {\r\n            actualRoundingIncrementICU = null;\r\n        } else {\r\n            if (getMaximumFractionDigits() > 0) {\r\n                actualRoundingIncrementICU = BigDecimal.ONE.movePointLeft(getMaximumFractionDigits());\r\n            } else {\r\n                actualRoundingIncrementICU = BigDecimal.ONE;\r\n            }\r\n        }\r\n    }\r\n    if (actualRoundingIncrementICU == null) {\r\n        setRoundingDouble(0.0d);\r\n        actualRoundingIncrement = null;\r\n    } else {\r\n        setRoundingDouble(actualRoundingIncrementICU.doubleValue());\r\n        actualRoundingIncrement = actualRoundingIncrementICU.toBigDecimal();\r\n    }\r\n}"
}, {
	"Path": "libcore.java.io.OldDataInputStreamTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this methodis called before a test is executed.",
	"Method": "void setUp(){\r\n    bos = new ByteArrayOutputStream();\r\n    os = new DataOutputStream(bos);\r\n}"
}, {
	"Path": "android.icu.impl.JavaTimeZone.createTimeZone",
	"Comment": "creates an instance of javatimezone with the given timezone id.",
	"Method": "JavaTimeZone createTimeZone(String id){\r\n    java.util.TimeZone jtz = null;\r\n    if (AVAILABLESET.contains(id)) {\r\n        jtz = java.util.TimeZone.getTimeZone(id);\r\n    }\r\n    if (jtz == null) {\r\n        boolean[] isSystemID = new boolean[1];\r\n        String canonicalID = TimeZone.getCanonicalID(id, isSystemID);\r\n        if (isSystemID[0] && AVAILABLESET.contains(canonicalID)) {\r\n            jtz = java.util.TimeZone.getTimeZone(canonicalID);\r\n        }\r\n    }\r\n    if (jtz == null) {\r\n        return null;\r\n    }\r\n    return new JavaTimeZone(jtz, id);\r\n}"
}, {
	"Path": "android.icu.util.Calendar.getPatternData",
	"Comment": "retrieves the datetime patterns and overrides from the resource bundle and generates anew patterndata object.",
	"Method": "PatternData getPatternData(ULocale locale,String calType){\r\n    ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, locale);\r\n    ICUResourceBundle dtPatternsRb = rb.findWithFallback(\"calendar/\" + calType + \"/DateTimePatterns\");\r\n    if (dtPatternsRb == null) {\r\n        dtPatternsRb = rb.getWithFallback(\"calendar/gregorian/DateTimePatterns\");\r\n    }\r\n    int patternsSize = dtPatternsRb.getSize();\r\n    String[] dateTimePatterns = new String[patternsSize];\r\n    String[] dateTimePatternsOverrides = new String[patternsSize];\r\n    for (int i = 0; i < patternsSize; i++) {\r\n        ICUResourceBundle concatenationPatternRb = (ICUResourceBundle) dtPatternsRb.get(i);\r\n        switch(concatenationPatternRb.getType()) {\r\n            case UResourceBundle.STRING:\r\n                dateTimePatterns[i] = concatenationPatternRb.getString();\r\n                break;\r\n            case UResourceBundle.ARRAY:\r\n                dateTimePatterns[i] = concatenationPatternRb.getString(0);\r\n                dateTimePatternsOverrides[i] = concatenationPatternRb.getString(1);\r\n                break;\r\n        }\r\n    }\r\n    return new PatternData(dateTimePatterns, dateTimePatternsOverrides);\r\n}"
}, {
	"Path": "android.icu.impl.Grego.previousMonthLength",
	"Comment": "return the length of a previous month of the gregorian calendar.",
	"Method": "int previousMonthLength(int year,int month){\r\n    return (month > 0) ? monthLength(year, month - 1) : 31;\r\n}"
}, {
	"Path": "android.icu.text.StringReplacer.addReplacementSetTo",
	"Comment": "union the set of all characters that may output by this objectinto the given set.",
	"Method": "void addReplacementSetTo(UnicodeSet toUnionTo){\r\n    int ch;\r\n    for (int i = 0; i < output.length(); i += UTF16.getCharCount(ch)) {\r\n        ch = UTF16.charAt(output, i);\r\n        UnicodeReplacer r = data.lookupReplacer(ch);\r\n        if (r == null) {\r\n            toUnionTo.add(ch);\r\n        } else {\r\n            r.addReplacementSetTo(toUnionTo);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.CompactDecimalFormat.getData",
	"Comment": "gets the data for a particular locale and style. if style is unrecognized,we just return data for compactstyle.short.",
	"Method": "Data getData(ULocale locale,CompactStyle style){\r\n    CompactDecimalDataCache.DataBundle bundle = cache.get(locale);\r\n    switch(style) {\r\n        case SHORT:\r\n            return bundle.shortData;\r\n        case LONG:\r\n            return bundle.longData;\r\n        default:\r\n            return bundle.shortData;\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.RuleBasedTimeZone.getLocalDelta",
	"Comment": "returns amount of local time adjustment used for checking rule transitions",
	"Method": "int getLocalDelta(int rawBefore,int dstBefore,int rawAfter,int dstAfter,int NonExistingTimeOpt,int DuplicatedTimeOpt){\r\n    int delta = 0;\r\n    int offsetBefore = rawBefore + dstBefore;\r\n    int offsetAfter = rawAfter + dstAfter;\r\n    boolean dstToStd = (dstBefore != 0) && (dstAfter == 0);\r\n    boolean stdToDst = (dstBefore == 0) && (dstAfter != 0);\r\n    if (offsetAfter - offsetBefore >= 0) {\r\n        if (((NonExistingTimeOpt & STD_DST_MASK) == LOCAL_STD && dstToStd) || ((NonExistingTimeOpt & STD_DST_MASK) == LOCAL_DST && stdToDst)) {\r\n            delta = offsetBefore;\r\n        } else if (((NonExistingTimeOpt & STD_DST_MASK) == LOCAL_STD && stdToDst) || ((NonExistingTimeOpt & STD_DST_MASK) == LOCAL_DST && dstToStd)) {\r\n            delta = offsetAfter;\r\n        } else if ((NonExistingTimeOpt & FORMER_LATTER_MASK) == LOCAL_LATTER) {\r\n            delta = offsetBefore;\r\n        } else {\r\n            delta = offsetAfter;\r\n        }\r\n    } else {\r\n        if (((DuplicatedTimeOpt & STD_DST_MASK) == LOCAL_STD && dstToStd) || ((DuplicatedTimeOpt & STD_DST_MASK) == LOCAL_DST && stdToDst)) {\r\n            delta = offsetAfter;\r\n        } else if (((DuplicatedTimeOpt & STD_DST_MASK) == LOCAL_STD && stdToDst) || ((DuplicatedTimeOpt & STD_DST_MASK) == LOCAL_DST && dstToStd)) {\r\n            delta = offsetBefore;\r\n        } else if ((DuplicatedTimeOpt & FORMER_LATTER_MASK) == LOCAL_FORMER) {\r\n            delta = offsetBefore;\r\n        } else {\r\n            delta = offsetAfter;\r\n        }\r\n    }\r\n    return delta;\r\n}"
}, {
	"Path": "android.icu.impl.ICURWLock.releaseWrite",
	"Comment": "release the write lock and return.an error will be thrownif the write lock is not currently held.if there are waiting readers, make them all active andnotify all of them.otherwise, notify the oldest waitingwriter, if any.call when finished with work controlled byacquirewrite.",
	"Method": "void releaseWrite(){\r\n    rwl.writeLock().unlock();\r\n}"
}, {
	"Path": "android.icu.impl.duration.BasicPeriodBuilderFactory.getMultiUnitBuilder",
	"Comment": "return a builder that formats the given number of periods,starting with the largest period less than or equal to theduration.",
	"Method": "PeriodBuilder getMultiUnitBuilder(int periodCount){\r\n    return MultiUnitBuilder.get(periodCount, getSettings());\r\n}"
}, {
	"Path": "android.icu.impl.ZoneMeta.getAvailableIDs",
	"Comment": "returns an immutable set of system ids for the given conditions.",
	"Method": "Set<String> getAvailableIDs(SystemTimeZoneType type,String region,Integer rawOffset){\r\n    Set<String> baseSet = null;\r\n    switch(type) {\r\n        case ANY:\r\n            baseSet = getSystemZIDs();\r\n            break;\r\n        case CANONICAL:\r\n            baseSet = getCanonicalSystemZIDs();\r\n            break;\r\n        case CANONICAL_LOCATION:\r\n            baseSet = getCanonicalSystemLocationZIDs();\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown SystemTimeZoneType\");\r\n    }\r\n    if (region == null && rawOffset == null) {\r\n        return baseSet;\r\n    }\r\n    if (region != null) {\r\n        region = region.toUpperCase(Locale.ENGLISH);\r\n    }\r\n    Set<String> result = new TreeSet<String>();\r\n    for (String id : baseSet) {\r\n        if (region != null) {\r\n            String r = getRegion(id);\r\n            if (!region.equals(r)) {\r\n                continue;\r\n            }\r\n        }\r\n        if (rawOffset != null) {\r\n            TimeZone z = getSystemTimeZone(id);\r\n            if (z == null || !rawOffset.equals(z.getRawOffset())) {\r\n                continue;\r\n            }\r\n        }\r\n        result.add(id);\r\n    }\r\n    if (result.isEmpty()) {\r\n        return Collections.emptySet();\r\n    }\r\n    return Collections.unmodifiableSet(result);\r\n}"
}, {
	"Path": "android.icu.util.ULocale.getDefault",
	"Comment": "returns the current default ulocale for the specified category.",
	"Method": "ULocale getDefault(ULocale getDefault,Category category,Locale getDefault,Category category){\r\n    synchronized (ULocale.class) {\r\n        int idx = category.ordinal();\r\n        if (defaultCategoryULocales[idx] == null) {\r\n            return ULocale.ROOT;\r\n        }\r\n        if (JDKLocaleHelper.hasLocaleCategories()) {\r\n            Locale currentCategoryDefault = JDKLocaleHelper.getDefault(category);\r\n            if (!defaultCategoryLocales[idx].equals(currentCategoryDefault)) {\r\n                defaultCategoryLocales[idx] = currentCategoryDefault;\r\n                defaultCategoryULocales[idx] = forLocale(currentCategoryDefault);\r\n            }\r\n        } else {\r\n            Locale currentDefault = Locale.getDefault();\r\n            if (!defaultLocale.equals(currentDefault)) {\r\n                defaultLocale = currentDefault;\r\n                defaultULocale = forLocale(currentDefault);\r\n                for (Category cat : Category.values()) {\r\n                    int tmpIdx = cat.ordinal();\r\n                    defaultCategoryLocales[tmpIdx] = currentDefault;\r\n                    defaultCategoryULocales[tmpIdx] = forLocale(currentDefault);\r\n                }\r\n            }\r\n        }\r\n        return defaultCategoryULocales[idx];\r\n    }\r\n}"
}, {
	"Path": "libcore.java.io.OldDataInputStreamTest.tearDown",
	"Comment": "tears down the fixture, for example, close a network connection. thismethod is called after a test is executed.",
	"Method": "void tearDown(){\r\n    try {\r\n        os.close();\r\n    } catch (Exception e) {\r\n    }\r\n    try {\r\n        dis.close();\r\n    } catch (Exception e) {\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.NumberFormat.setCurrency",
	"Comment": "sets the currency object used to display currencyamounts.this takes effect immediately, if this format is acurrency format.if this format is not a currency format, thenthe currency object is used if and when this object becomes acurrency format.",
	"Method": "void setCurrency(Currency theCurrency){\r\n    currency = theCurrency;\r\n}"
}, {
	"Path": "org.apache.harmony.xml.dom.NodeImpl.validatePrefix",
	"Comment": "validates the element or attribute namespace prefix on this node.",
	"Method": "String validatePrefix(String prefix,boolean namespaceAware,String namespaceURI){\r\n    if (!namespaceAware) {\r\n        throw new DOMException(DOMException.NAMESPACE_ERR, prefix);\r\n    }\r\n    if (prefix != null) {\r\n        if (namespaceURI == null || !DocumentImpl.isXMLIdentifier(prefix) || \"xml\".equals(prefix) && !\"http://www.w3.org/XML/1998/namespace\".equals(namespaceURI) || \"xmlns\".equals(prefix) && !\"http://www.w3.org/2000/xmlns/\".equals(namespaceURI)) {\r\n            throw new DOMException(DOMException.NAMESPACE_ERR, prefix);\r\n        }\r\n    }\r\n    return prefix;\r\n}"
}, {
	"Path": "android.icu.impl.SimpleFormatterImpl.formatAndReplace",
	"Comment": "formats the given values, replacing the contents of the result builder.may optimize by actually appending to the result if it is the same objectas the value corresponding to the initial argument in the pattern.",
	"Method": "StringBuilder formatAndReplace(String compiledPattern,StringBuilder result,int[] offsets,CharSequence values){\r\n    int valuesLength = values != null ? values.length : 0;\r\n    if (valuesLength < getArgumentLimit(compiledPattern)) {\r\n        throw new IllegalArgumentException(\"Too few values.\");\r\n    }\r\n    int firstArg = -1;\r\n    String resultCopy = null;\r\n    if (getArgumentLimit(compiledPattern) > 0) {\r\n        for (int i = 1; i < compiledPattern.length(); ) {\r\n            int n = compiledPattern.charAt(i++);\r\n            if (n < ARG_NUM_LIMIT) {\r\n                if (values[n] == result) {\r\n                    if (i == 2) {\r\n                        firstArg = n;\r\n                    } else if (resultCopy == null) {\r\n                        resultCopy = result.toString();\r\n                    }\r\n                }\r\n            } else {\r\n                i += n - ARG_NUM_LIMIT;\r\n            }\r\n        }\r\n    }\r\n    if (firstArg < 0) {\r\n        result.setLength(0);\r\n    }\r\n    return format(compiledPattern, values, result, resultCopy, false, offsets);\r\n}"
}, {
	"Path": "android.icu.impl.LocaleIDParser.defaultKeywordValue",
	"Comment": "set the keyword value only if it is not already set to something else.",
	"Method": "void defaultKeywordValue(String keywordName,String value){\r\n    setKeywordValue(keywordName, value, false);\r\n}"
}, {
	"Path": "android.icu.impl.UPropertyAliases.getPropertyEnum",
	"Comment": "returns a property enum given one of its property names.if the property name is not known, this method returnsuproperty.undefined.",
	"Method": "int getPropertyEnum(CharSequence alias){\r\n    return getPropertyOrValueEnum(0, alias);\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.applyPropertyAlias",
	"Comment": "modifies this set to contain those code points which have thegiven value for the given property.prior contents of thisset are lost.",
	"Method": "UnicodeSet applyPropertyAlias(String propertyAlias,String valueAlias,UnicodeSet applyPropertyAlias,String propertyAlias,String valueAlias,SymbolTable symbols,boolean applyPropertyAlias,String propertyName,String propertyValue,UnicodeSet result){\r\n    checkFrozen();\r\n    int p;\r\n    int v;\r\n    boolean mustNotBeEmpty = false, invert = false;\r\n    if (symbols != null && (symbols instanceof XSymbolTable) && ((XSymbolTable) symbols).applyPropertyAlias(propertyAlias, valueAlias, this)) {\r\n        return this;\r\n    }\r\n    if (XSYMBOL_TABLE != null) {\r\n        if (XSYMBOL_TABLE.applyPropertyAlias(propertyAlias, valueAlias, this)) {\r\n            return this;\r\n        }\r\n    }\r\n    if (valueAlias.length() > 0) {\r\n        p = UCharacter.getPropertyEnum(propertyAlias);\r\n        if (p == UProperty.GENERAL_CATEGORY) {\r\n            p = UProperty.GENERAL_CATEGORY_MASK;\r\n        }\r\n        if ((p >= UProperty.BINARY_START && p < UProperty.BINARY_LIMIT) || (p >= UProperty.INT_START && p < UProperty.INT_LIMIT) || (p >= UProperty.MASK_START && p < UProperty.MASK_LIMIT)) {\r\n            try {\r\n                v = UCharacter.getPropertyValueEnum(p, valueAlias);\r\n            } catch (IllegalArgumentException e) {\r\n                if (p == UProperty.CANONICAL_COMBINING_CLASS || p == UProperty.LEAD_CANONICAL_COMBINING_CLASS || p == UProperty.TRAIL_CANONICAL_COMBINING_CLASS) {\r\n                    v = Integer.parseInt(PatternProps.trimWhiteSpace(valueAlias));\r\n                    if (v < 0 || v > 255)\r\n                        throw e;\r\n                } else {\r\n                    throw e;\r\n                }\r\n            }\r\n        } else {\r\n            switch(p) {\r\n                case UProperty.NUMERIC_VALUE:\r\n                    {\r\n                        double value = Double.parseDouble(PatternProps.trimWhiteSpace(valueAlias));\r\n                        applyFilter(new NumericValueFilter(value), UCharacterProperty.SRC_CHAR);\r\n                        return this;\r\n                    }\r\n                case UProperty.NAME:\r\n                    {\r\n                        String buf = mungeCharName(valueAlias);\r\n                        int ch = UCharacter.getCharFromExtendedName(buf);\r\n                        if (ch == -1) {\r\n                            throw new IllegalArgumentException(\"Invalid character name\");\r\n                        }\r\n                        clear();\r\n                        add_unchecked(ch);\r\n                        return this;\r\n                    }\r\n                case UProperty.UNICODE_1_NAME:\r\n                    throw new IllegalArgumentException(\"Unicode_1_Name (na1) not supported\");\r\n                case UProperty.AGE:\r\n                    {\r\n                        VersionInfo version = VersionInfo.getInstance(mungeCharName(valueAlias));\r\n                        applyFilter(new VersionFilter(version), UCharacterProperty.SRC_PROPSVEC);\r\n                        return this;\r\n                    }\r\n                case UProperty.SCRIPT_EXTENSIONS:\r\n                    v = UCharacter.getPropertyValueEnum(UProperty.SCRIPT, valueAlias);\r\n                    break;\r\n                default:\r\n                    throw new IllegalArgumentException(\"Unsupported property\");\r\n            }\r\n        }\r\n    } else {\r\n        UPropertyAliases pnames = UPropertyAliases.INSTANCE;\r\n        p = UProperty.GENERAL_CATEGORY_MASK;\r\n        v = pnames.getPropertyValueEnum(p, propertyAlias);\r\n        if (v == UProperty.UNDEFINED) {\r\n            p = UProperty.SCRIPT;\r\n            v = pnames.getPropertyValueEnum(p, propertyAlias);\r\n            if (v == UProperty.UNDEFINED) {\r\n                p = pnames.getPropertyEnum(propertyAlias);\r\n                if (p == UProperty.UNDEFINED) {\r\n                    p = -1;\r\n                }\r\n                if (p >= UProperty.BINARY_START && p < UProperty.BINARY_LIMIT) {\r\n                    v = 1;\r\n                } else if (p == -1) {\r\n                    if (0 == UPropertyAliases.compare(ANY_ID, propertyAlias)) {\r\n                        set(MIN_VALUE, MAX_VALUE);\r\n                        return this;\r\n                    } else if (0 == UPropertyAliases.compare(ASCII_ID, propertyAlias)) {\r\n                        set(0, 0x7F);\r\n                        return this;\r\n                    } else if (0 == UPropertyAliases.compare(ASSIGNED, propertyAlias)) {\r\n                        p = UProperty.GENERAL_CATEGORY_MASK;\r\n                        v = (1 << UCharacter.UNASSIGNED);\r\n                        invert = true;\r\n                    } else {\r\n                        throw new IllegalArgumentException(\"Invalid property alias: \" + propertyAlias + \"=\" + valueAlias);\r\n                    }\r\n                } else {\r\n                    throw new IllegalArgumentException(\"Missing property value\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n    applyIntPropertyValue(p, v);\r\n    if (invert) {\r\n        complement();\r\n    }\r\n    if (mustNotBeEmpty && isEmpty()) {\r\n        throw new IllegalArgumentException(\"Invalid property value\");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.text.DateFormatSymbols.setLocale",
	"Comment": "sets information about the locales that were used to create thisobject.if the object was not constructed from locale data,both arguments should be set to null.otherwise, neithershould be null.the actual locale must be at the same level orless specific than the valid locale.this method is intendedfor use by factories or other entities that create objects ofthis class.",
	"Method": "void setLocale(ULocale valid,ULocale actual){\r\n    if ((valid == null) != (actual == null)) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    this.validLocale = valid;\r\n    this.actualLocale = actual;\r\n}"
}, {
	"Path": "android.icu.util.Currency.getInstance",
	"Comment": "returns a currency object for the default currency in the givenlocale.",
	"Method": "Currency getInstance(Locale locale,Currency getInstance,ULocale locale,Currency getInstance,String theISOCode){\r\n    if (theISOCode == null) {\r\n        throw new NullPointerException(\"The input currency code is null.\");\r\n    }\r\n    if (!isAlpha3Code(theISOCode)) {\r\n        throw new IllegalArgumentException(\"The input currency code is not 3-letter alphabetic code.\");\r\n    }\r\n    return (Currency) MeasureUnit.internalGetInstance(\"currency\", theISOCode.toUpperCase(Locale.ENGLISH));\r\n}"
}, {
	"Path": "android.icu.impl.ICUResourceBundle.findWithFallback",
	"Comment": "like getwithfallback, but returns null if the resource is not found instead ofthrowing an exception.",
	"Method": "ICUResourceBundle findWithFallback(String path){\r\n    return findResourceWithFallback(path, this, null);\r\n}"
}, {
	"Path": "android.icu.text.Normalizer.getEndIndex",
	"Comment": "retrieve the index of the end of the input text.this is the end indexof the characteriterator or the length of the stringover which this normalizer is iterating",
	"Method": "int getEndIndex(){\r\n    return endIndex();\r\n}"
}, {
	"Path": "android.icu.text.UTF16.bounds",
	"Comment": "returns the type of the boundaries around the char at offset16. used for random access.",
	"Method": "int bounds(String source,int offset16,int bounds,StringBuffer source,int offset16,int bounds,char source,int start,int limit,int offset16){\r\n    offset16 += start;\r\n    if (offset16 < start || offset16 >= limit) {\r\n        throw new ArrayIndexOutOfBoundsException(offset16);\r\n    }\r\n    char ch = source[offset16];\r\n    if (isSurrogate(ch)) {\r\n        if (isLeadSurrogate(ch)) {\r\n            ++offset16;\r\n            if (offset16 < limit && isTrailSurrogate(source[offset16])) {\r\n                return LEAD_SURROGATE_BOUNDARY;\r\n            }\r\n        } else {\r\n            --offset16;\r\n            if (offset16 >= start && isLeadSurrogate(source[offset16])) {\r\n                return TRAIL_SURROGATE_BOUNDARY;\r\n            }\r\n        }\r\n    }\r\n    return SINGLE_CHAR_BOUNDARY;\r\n}"
}, {
	"Path": "android.icu.text.DateTimePatternGenerator.getRedundants",
	"Comment": "redundant patterns are those which if removed, make no difference in theresulting getbestpattern values. this method returns a list of them, tohelp check the consistency of the patterns used to build this generator.",
	"Method": "Collection<String> getRedundants(Collection<String> output){\r\n    synchronized (this) {\r\n        if (output == null) {\r\n            output = new LinkedHashSet<String>();\r\n        }\r\n        for (DateTimeMatcher cur : skeleton2pattern.keySet()) {\r\n            PatternWithSkeletonFlag patternWithSkelFlag = skeleton2pattern.get(cur);\r\n            String pattern = patternWithSkelFlag.pattern;\r\n            if (CANONICAL_SET.contains(pattern)) {\r\n                continue;\r\n            }\r\n            String trial = getBestPattern(cur.toString(), cur, MATCH_NO_OPTIONS);\r\n            if (trial.equals(pattern)) {\r\n                output.add(pattern);\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.TimeZoneTransition.getTime",
	"Comment": "returns the time of transition in milliseconds since the base time.",
	"Method": "long getTime(){\r\n    return time;\r\n}"
}, {
	"Path": "android.icu.impl.ICULocaleService.registerObject",
	"Comment": "convenience function for callers using locales.thisinstantiatesa simplelocalekeyfactory, and registers the factory.",
	"Method": "Factory registerObject(Object obj,ULocale locale,Factory registerObject,Object obj,ULocale locale,boolean visible,Factory registerObject,Object obj,ULocale locale,int kind,Factory registerObject,Object obj,ULocale locale,int kind,boolean visible){\r\n    Factory factory = new SimpleLocaleKeyFactory(obj, locale, kind, visible);\r\n    return registerFactory(factory);\r\n}"
}, {
	"Path": "android.icu.text.PluralRanges.isExplicitlySet",
	"Comment": "internal method to determines whether the standardpluralcategories was explicitly used in any add statement.",
	"Method": "boolean isExplicitlySet(StandardPlural count){\r\n    return explicit[count.ordinal()];\r\n}"
}, {
	"Path": "android.icu.impl.RuleCharacterIterator.atEnd",
	"Comment": "returns true if this iterator has no more characters to return.",
	"Method": "boolean atEnd(){\r\n    return buf == null && pos.getIndex() == text.length();\r\n}"
}, {
	"Path": "android.icu.text.Bidi.fixN0c",
	"Comment": "change n0c1 to n0c2 when a preceding bracket is assigned the embedding level",
	"Method": "void fixN0c(BracketData bd,int openingIndex,int newPropPosition,byte newProp){\r\n    IsoRun pLastIsoRun = bd.isoRuns[bd.isoRunLast];\r\n    Opening qOpening;\r\n    int k, openingPosition, closingPosition;\r\n    for (k = openingIndex + 1; k < pLastIsoRun.limit; k++) {\r\n        qOpening = bd.openings[k];\r\n        if (qOpening.match >= 0)\r\n            continue;\r\n        if (newPropPosition < qOpening.contextPos)\r\n            break;\r\n        if (newPropPosition >= qOpening.position)\r\n            continue;\r\n        if (newProp == qOpening.contextDir)\r\n            break;\r\n        openingPosition = qOpening.position;\r\n        dirProps[openingPosition] = newProp;\r\n        closingPosition = -(qOpening.match);\r\n        dirProps[closingPosition] = newProp;\r\n        qOpening.match = 0;\r\n        fixN0c(bd, k, openingPosition, newProp);\r\n        fixN0c(bd, k, closingPosition, newProp);\r\n    }\r\n}"
}, {
	"Path": "java.io.File.canWrite",
	"Comment": "indicates whether the current context is allowed to write to this file.",
	"Method": "boolean canWrite(){\r\n    return doAccess(W_OK);\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.resetState",
	"Comment": "reset the receiver. the collection of objects already read by thereceiver is reset, and internal structures are also reset so that thereceiver knows it is in a fresh clean state.",
	"Method": "void resetState(){\r\n    resetSeenObjects();\r\n    hasPushbackTC = false;\r\n    pushbackTC = 0;\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.checkReadPrimitiveTypes",
	"Comment": "checks to if it is ok to read primitive types from this stream atthis point. one is not supposed to read primitive types when about toread an object, for example, so an exception has to be thrown.",
	"Method": "void checkReadPrimitiveTypes(){\r\n    if (primitiveData == input || primitiveData.available() > 0) {\r\n        return;\r\n    }\r\n    do {\r\n        int next = 0;\r\n        if (hasPushbackTC) {\r\n            hasPushbackTC = false;\r\n        } else {\r\n            next = input.read();\r\n            pushbackTC = (byte) next;\r\n        }\r\n        switch(pushbackTC) {\r\n            case TC_BLOCKDATA:\r\n                primitiveData = new ByteArrayInputStream(readBlockData());\r\n                return;\r\n            case TC_BLOCKDATALONG:\r\n                primitiveData = new ByteArrayInputStream(readBlockDataLong());\r\n                return;\r\n            case TC_RESET:\r\n                resetState();\r\n                break;\r\n            default:\r\n                if (next != -1) {\r\n                    pushbackTC();\r\n                }\r\n                return;\r\n        }\r\n    } while (true);\r\n}"
}, {
	"Path": "android.icu.text.NumberFormat.getCurrency",
	"Comment": "returns the currency object used to display currencyamounts.this may be null.",
	"Method": "Currency getCurrency(){\r\n    return currency;\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.readNewLongString",
	"Comment": "read a new string in utf format from the receiver. return the stringread.",
	"Method": "Object readNewLongString(boolean unshared){\r\n    long length = input.readLong();\r\n    Object result = input.decodeUTF((int) length);\r\n    if (enableResolve) {\r\n        result = resolveObject(result);\r\n    }\r\n    registerObjectRead(result, nextHandle(), unshared);\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.impl.duration.BasicDurationFormatterFactory.createFormatter",
	"Comment": "create the formatter.all local fields are already initialized.",
	"Method": "BasicDurationFormatter createFormatter(){\r\n    return new BasicDurationFormatter(formatter, builder, fallback, fallbackLimit, localeName, timeZone);\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.resemblesPattern",
	"Comment": "return true if the given position, in the given pattern, appearsto be the start of a unicodeset pattern.",
	"Method": "boolean resemblesPattern(String pattern,int pos){\r\n    return ((pos + 1) < pattern.length() && pattern.charAt(pos) == '[') || resemblesPropertyPattern(pattern, pos);\r\n}"
}, {
	"Path": "tests.security.spec.RSAMultiPrimePrivateCrtKeySpecTest.testIsStatePreserved1",
	"Comment": "tests that internal state of the objectcan not be modified by modifying initial array",
	"Method": "void testIsStatePreserved1(){\r\n    RSAOtherPrimeInfo[] opi1 = opi.clone();\r\n    RSAMultiPrimePrivateCrtKeySpec ks = new RSAMultiPrimePrivateCrtKeySpec(BigInteger.ONE, BigInteger.ONE, BigInteger.ONE, BigInteger.ONE, BigInteger.ONE, BigInteger.ONE, BigInteger.ONE, BigInteger.ONE, opi1);\r\n    opi1[2] = new RSAOtherPrimeInfo(BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO);\r\n    assertTrue(checkOtherPrimeInfo(ks.getOtherPrimeInfo()));\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.HebrewTest.TestMonthMovement",
	"Comment": "test of the behavior of the month field.this requires specialhandling in the hebrew calendar because of the pattern of leapyears.",
	"Method": "void TestMonthMovement(){\r\n    try {\r\n        HebrewCalendar cal = new HebrewCalendar();\r\n        int[] DATA = { // *set != add; also see '*' below\r\n        10, // *set != add; also see '*' below\r\n        2, // *set != add; also see '*' below\r\n        +24, // *set != add; also see '*' below\r\n        9, // *set != add; also see '*' below\r\n        4, // *set != add; also see '*' below\r\n        9, // *set != add; also see '*' below\r\n        4, // *set != add; also see '*' below\r\n        10, // *set != add; also see '*' below\r\n        2, // *set != add; also see '*' below\r\n        +60, // *set != add; also see '*' below\r\n        8, // *set != add; also see '*' below\r\n        7, // *set != add; also see '*' below\r\n        8, 7, 1, 2, +12, 1, 3, 13, // Leap year - no skip 4,5,6,7,8\r\n        2, // Leap year - no skip 4,5,6,7,8\r\n        3, // Leap year - no skip 4,5,6,7,8\r\n        18, // Leap year - no skip 4,5,6,7,8\r\n        -24, // Leap year - no skip 4,5,6,7,8\r\n        4, // Leap year - no skip 4,5,6,7,8\r\n        16, // Leap year - no skip 4,5,6,7,8\r\n        4, // Leap year - no skip 4,5,6,7,8\r\n        16, // Leap year - no skip 4,5,6,7,8\r\n        1, // Leap year - no skip 4,5,6,7,8\r\n        6, // Leap year - no skip 4,5,6,7,8\r\n        -24, // Leap year - no skip 4,5,6,7,8\r\n        1, // Leap year - no skip 4,5,6,7,8\r\n        4, // Leap year - no skip 4,5,6,7,8\r\n        1, 4, 4, 3, +2, 6, 3, 6, 3, 8, 3, -2, 6, 3, 6, 3, 4, 2, +2, 7, 2, 7, 2, 8, 2, -2, 5, 2, 7, 2 };\r\n        for (int i = 0; i < DATA.length; ) {\r\n            int m = DATA[i++], y = DATA[i++];\r\n            int monthDelta = DATA[i++];\r\n            int m2 = DATA[i++], y2 = DATA[i++];\r\n            int m3 = DATA[i++], y3 = DATA[i++];\r\n            int mact, yact;\r\n            cal.clear();\r\n            cal.set(Calendar.YEAR, y);\r\n            cal.set(Calendar.MONTH, m - 1);\r\n            cal.add(Calendar.MONTH, monthDelta);\r\n            yact = cal.get(Calendar.YEAR);\r\n            mact = cal.get(Calendar.MONTH) + 1;\r\n            if (y2 != yact || m2 != mact) {\r\n                errln(\"Fail: \" + m + \"/\" + y + \" -> add(MONTH, \" + monthDelta + \") -> \" + mact + \"/\" + yact + \", expected \" + m2 + \"/\" + y2);\r\n                cal.clear();\r\n                cal.set(Calendar.YEAR, y);\r\n                cal.set(Calendar.MONTH, m - 1);\r\n                logln(\"Start: \" + m + \"/\" + y);\r\n                int delta = monthDelta > 0 ? 1 : -1;\r\n                for (int c = 0; c != monthDelta; c += delta) {\r\n                    cal.add(Calendar.MONTH, delta);\r\n                    logln(\"+ \" + delta + \" MONTH -> \" + (cal.get(Calendar.MONTH) + 1) + \"/\" + cal.get(Calendar.YEAR));\r\n                }\r\n            }\r\n            cal.clear();\r\n            cal.set(Calendar.YEAR, y);\r\n            cal.set(Calendar.MONTH, m + monthDelta - 1);\r\n            yact = cal.get(Calendar.YEAR);\r\n            mact = cal.get(Calendar.MONTH) + 1;\r\n            if (y3 != yact || m3 != mact) {\r\n                errln(\"Fail: \" + (m + monthDelta) + \"/\" + y + \" -> complete() -> \" + mact + \"/\" + yact + \", expected \" + m3 + \"/\" + y3);\r\n            }\r\n        }\r\n    } catch (MissingResourceException ex) {\r\n        warnln(\"Got Exception: \" + ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.Collator.getReorderCodes",
	"Comment": "retrieves the reordering codes for this collator.these reordering codes are a combination of uscript codes and reordercodes.",
	"Method": "int[] getReorderCodes(){\r\n    throw new UnsupportedOperationException(\"Needs to be implemented by the subclass.\");\r\n}"
}, {
	"Path": "android.icu.impl.Normalizer2Impl.hasDecompBoundary",
	"Comment": "at the cost of building the fcd trie for a decomposition normalizer.",
	"Method": "boolean hasDecompBoundary(int c,boolean before){\r\n    for (; ; ) {\r\n        if (c < minDecompNoCP) {\r\n            return true;\r\n        }\r\n        int norm16 = getNorm16(c);\r\n        if (isHangul(norm16) || isDecompYesAndZeroCC(norm16)) {\r\n            return true;\r\n        } else if (norm16 > MIN_NORMAL_MAYBE_YES) {\r\n            return false;\r\n        } else if (isDecompNoAlgorithmic(norm16)) {\r\n            c = mapAlgorithmic(c, norm16);\r\n        } else {\r\n            int firstUnit = extraData.charAt(norm16);\r\n            if ((firstUnit & MAPPING_LENGTH_MASK) == 0) {\r\n                return false;\r\n            }\r\n            if (!before) {\r\n                if (firstUnit > 0x1ff) {\r\n                    return false;\r\n                }\r\n                if (firstUnit <= 0xff) {\r\n                    return true;\r\n                }\r\n            }\r\n            return (firstUnit & MAPPING_HAS_CCC_LCCC_WORD) == 0 || (extraData.charAt(norm16 - 1) & 0xff00) == 0;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.StringPrepParseException.getError",
	"Comment": "returns the error code of this exception.this method is only used for testing to verify the error.",
	"Method": "int getError(){\r\n    return error;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.isNumberNegative",
	"Comment": "this is a special function used by the compactdecimalformat subclass to determine if the number to be formatted is negative.",
	"Method": "boolean isNumberNegative(double number){\r\n    if (Double.isNaN(number)) {\r\n        return false;\r\n    }\r\n    return isNegative(multiply(number));\r\n}"
}, {
	"Path": "android.icu.text.PluralFormat.applyPattern",
	"Comment": "sets the pattern used by this plural format.the method parses the pattern and creates a map of format stringsfor the plural rules.patterns and their interpretation are specified in the class description.",
	"Method": "void applyPattern(String pattern){\r\n    this.pattern = pattern;\r\n    if (msgPattern == null) {\r\n        msgPattern = new MessagePattern();\r\n    }\r\n    try {\r\n        msgPattern.parsePluralStyle(pattern);\r\n        offset = msgPattern.getPluralOffset(0);\r\n    } catch (RuntimeException e) {\r\n        resetPattern();\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.Currency.getDefaultFractionDigits",
	"Comment": "returns the number of the number of fraction digits that shouldbe displayed for this currency with usage.",
	"Method": "int getDefaultFractionDigits(int getDefaultFractionDigits,CurrencyUsage Usage){\r\n    CurrencyMetaInfo info = CurrencyMetaInfo.getInstance();\r\n    CurrencyDigits digits = info.currencyDigits(subType, Usage);\r\n    return digits.fractionDigits;\r\n}"
}, {
	"Path": "android.icu.util.GlobalizationPreferences.setCalendar",
	"Comment": "sets the calendar. if this has not been set, uses default for territory.",
	"Method": "GlobalizationPreferences setCalendar(Calendar calendar){\r\n    if (isFrozen()) {\r\n        throw new UnsupportedOperationException(\"Attempt to modify immutable object\");\r\n    }\r\n    this.calendar = (Calendar) calendar.clone();\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.toString",
	"Comment": "returns the result of super.tostring, appending the name in curly braces.",
	"Method": "String toString(String toString){\r\n    return super.toString() + \"{\" + name + \"}\";\r\n}"
}, {
	"Path": "android.icu.text.Bidi.setCustomClassifier",
	"Comment": "set a custom bidi classifier used by the uba implementation for bidiclass determination.",
	"Method": "void setCustomClassifier(BidiClassifier classifier){\r\n    this.customClassifier = classifier;\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.setFields",
	"Comment": "set the collection of field descriptors for the fields of thecorresponding class",
	"Method": "void setFields(ObjectStreamField[] f){\r\n    fields = f;\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.findMethod",
	"Comment": "return the java.lang.reflect.method if class cl implementsmethodname . return null otherwise.",
	"Method": "Method findMethod(Class<?> cl,String methodName){\r\n    Class<?> search = cl;\r\n    Method method = null;\r\n    while (search != null) {\r\n        try {\r\n            method = search.getDeclaredMethod(methodName, (Class[]) null);\r\n            if (search == cl || (method.getModifiers() & Modifier.PRIVATE) == 0) {\r\n                method.setAccessible(true);\r\n                return method;\r\n            }\r\n        } catch (NoSuchMethodException nsm) {\r\n        }\r\n        search = search.getSuperclass();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.util.MeasureUnit.getAvailable",
	"Comment": "get all of the available units. returned set is unmodifiable.",
	"Method": "Set<MeasureUnit> getAvailable(String type,Set<MeasureUnit> getAvailable){\r\n    Set<MeasureUnit> result = new HashSet<MeasureUnit>();\r\n    for (String type : new HashSet<String>(MeasureUnit.getAvailableTypes())) {\r\n        for (MeasureUnit unit : MeasureUnit.getAvailable(type)) {\r\n            result.add(unit);\r\n        }\r\n    }\r\n    return Collections.unmodifiableSet(result);\r\n}"
}, {
	"Path": "android.icu.text.Quantifier.addMatchSetTo",
	"Comment": "implementation of unicodematcher api.union the set of allcharacters that may be matched by this object into the givenset.",
	"Method": "void addMatchSetTo(UnicodeSet toUnionTo){\r\n    if (maxCount > 0) {\r\n        matcher.addMatchSetTo(toUnionTo);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.translatePattern",
	"Comment": "translate a pattern, mapping each character in the from string to thecorresponding character in the to string.",
	"Method": "String translatePattern(String pat,String from,String to){\r\n    StringBuilder result = new StringBuilder();\r\n    boolean inQuote = false;\r\n    for (int i = 0; i < pat.length(); ++i) {\r\n        char c = pat.charAt(i);\r\n        if (inQuote) {\r\n            if (c == '\\'')\r\n                inQuote = false;\r\n        } else {\r\n            if (c == '\\'') {\r\n                inQuote = true;\r\n            } else if (isSyntaxChar(c)) {\r\n                int ci = from.indexOf(c);\r\n                if (ci != -1) {\r\n                    c = to.charAt(ci);\r\n                }\r\n            }\r\n        }\r\n        result.append(c);\r\n    }\r\n    if (inQuote) {\r\n        throw new IllegalArgumentException(\"Unfinished quote in pattern\");\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.AlphabeticIndexTest.TestNoLabels",
	"Comment": "with no real labels, there should be only the underflow label.",
	"Method": "void TestNoLabels(){\r\n    RuleBasedCollator coll = (RuleBasedCollator) Collator.getInstance(ULocale.ROOT);\r\n    AlphabeticIndex<Integer> index = new AlphabeticIndex<Integer>(coll);\r\n    index.addRecord(\"��\", 0);\r\n    index.addRecord(\"i\", 0);\r\n    index.addRecord(\"��\", 0);\r\n    assertEquals(\"getRecordCount()\", 3, index.getRecordCount());\r\n    assertEquals(\"getBucketCount()\", 1, index.getBucketCount());\r\n    Bucket<Integer> bucket = index.iterator().next();\r\n    assertEquals(\"underflow label type\", LabelType.UNDERFLOW, bucket.getLabelType());\r\n    assertEquals(\"all records in the underflow bucket\", 3, bucket.size());\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.setCurrencyUsage",
	"Comment": "sets the currency usage object used to display currency.this takes effect immediately, if this format is acurrency format.",
	"Method": "void setCurrencyUsage(CurrencyUsage newUsage){\r\n    if (newUsage == null) {\r\n        throw new NullPointerException(\"return value is null at method AAA\");\r\n    }\r\n    currencyUsage = newUsage;\r\n    Currency theCurrency = this.getCurrency();\r\n    if (theCurrency != null) {\r\n        setRoundingIncrement(theCurrency.getRoundingIncrement(currencyUsage));\r\n        int d = theCurrency.getDefaultFractionDigits(currencyUsage);\r\n        setMinimumFractionDigits(d);\r\n        _setMaximumFractionDigits(d);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.getParseMaxDigits",
	"Comment": "get the current maximum number of exponent digits when parsing a number.",
	"Method": "int getParseMaxDigits(){\r\n    return PARSE_MAX_EXPONENT;\r\n}"
}, {
	"Path": "android.icu.impl.UCharacterIteratorWrapper.setIndex",
	"Comment": "sets the position to the specified position in the text and returns thatcharacter.",
	"Method": "char setIndex(int position){\r\n    iterator.setIndex(position);\r\n    return (char) iterator.current();\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.getGroupingSeparator",
	"Comment": "returns the character used for grouping separator. different for french, etc.",
	"Method": "char getGroupingSeparator(){\r\n    return groupingSeparator;\r\n}"
}, {
	"Path": "android.icu.util.Calendar.getMinimalDaysInFirstWeek",
	"Comment": "returns what the minimal days required in the first week of the year are.that is, if the first week is defined as one that contains the first dayof the first month of a year, getminimaldaysinfirstweek returns 1. ifthe minimal days required must be a full week, getminimaldaysinfirstweekreturns 7.",
	"Method": "int getMinimalDaysInFirstWeek(){\r\n    return minimalDaysInFirstWeek;\r\n}"
}, {
	"Path": "java.io.StreamTokenizer.resetSyntax",
	"Comment": "specifies that all characters shall be treated as ordinary characters.",
	"Method": "void resetSyntax(){\r\n    for (int i = 0; i < 256; i++) {\r\n        tokenTypes[i] = 0;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.clear",
	"Comment": "removes all of the elements from this set.this set will beempty after this call returns.",
	"Method": "UnicodeSet clear(){\r\n    checkFrozen();\r\n    list[0] = HIGH;\r\n    len = 1;\r\n    pat = null;\r\n    strings.clear();\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.text.BidiRun.getLimit",
	"Comment": "get position of one character after the end of the run in the source text",
	"Method": "int getLimit(){\r\n    return limit;\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.compare",
	"Comment": "utility to compare two collections, optionally by size, and then lexicographically.",
	"Method": "int compare(CharSequence string,int codePoint,int compare,int codePoint,CharSequence string,int compare,Iterable<T> collection1,Iterable<T> collection2,int compare,Iterator<T> first,Iterator<T> other,int compare,Collection<T> collection1,Collection<T> collection2,ComparisonStyle style){\r\n    if (style != ComparisonStyle.LEXICOGRAPHIC) {\r\n        int diff = collection1.size() - collection2.size();\r\n        if (diff != 0) {\r\n            return (diff < 0) == (style == ComparisonStyle.SHORTER_FIRST) ? -1 : 1;\r\n        }\r\n    }\r\n    return compare(collection1, collection2);\r\n}"
}, {
	"Path": "java.io.File.fixSlashes",
	"Comment": "removes duplicate adjacent slashes and any trailing slash.",
	"Method": "String fixSlashes(String origPath){\r\n    boolean lastWasSlash = false;\r\n    char[] newPath = origPath.toCharArray();\r\n    int length = newPath.length;\r\n    int newLength = 0;\r\n    for (int i = 0; i < length; ++i) {\r\n        char ch = newPath[i];\r\n        if (ch == '/') {\r\n            if (!lastWasSlash) {\r\n                newPath[newLength++] = separatorChar;\r\n                lastWasSlash = true;\r\n            }\r\n        } else {\r\n            newPath[newLength++] = ch;\r\n            lastWasSlash = false;\r\n        }\r\n    }\r\n    if (lastWasSlash && newLength > 1) {\r\n        newLength--;\r\n    }\r\n    return (newLength != length) ? new String(newPath, 0, newLength) : origPath;\r\n}"
}, {
	"Path": "android.icu.impl.ClassLoaderUtil.getClassLoader",
	"Comment": "returns the class loader used for loading the specified class.",
	"Method": "ClassLoader getClassLoader(Class<?> cls,ClassLoader getClassLoader){\r\n    ClassLoader cl = Thread.currentThread().getContextClassLoader();\r\n    if (cl == null) {\r\n        cl = ClassLoader.getSystemClassLoader();\r\n        if (cl == null) {\r\n            cl = getBootstrapClassLoader();\r\n        }\r\n    }\r\n    return cl;\r\n}"
}, {
	"Path": "android.icu.impl.RelativeDateFormat.initializeCalendar",
	"Comment": "initializes fcalendar from parameters.returns fcalendar as a convenience.",
	"Method": "Calendar initializeCalendar(TimeZone zone,ULocale locale){\r\n    if (calendar == null) {\r\n        if (zone == null) {\r\n            calendar = Calendar.getInstance(locale);\r\n        } else {\r\n            calendar = Calendar.getInstance(zone, locale);\r\n        }\r\n    }\r\n    return calendar;\r\n}"
}, {
	"Path": "android.icu.text.UnescapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    Transliterator.registerFactory(\"Hex-Any/Unicode\", new Transliterator.Factory() {\r\n        @Override\r\n        public Transliterator getInstance(String ID) {\r\n            return new UnescapeTransliterator(\"Hex-Any/Unicode\", new char[] { 2, 0, 16, 4, 6, 'U', '+', END });\r\n        }\r\n    });\r\n    Transliterator.registerFactory(\"Hex-Any/Java\", new Transliterator.Factory() {\r\n        @Override\r\n        public Transliterator getInstance(String ID) {\r\n            return new UnescapeTransliterator(\"Hex-Any/Java\", new char[] { 2, 0, 16, 4, 4, '\\\\', 'u', END });\r\n        }\r\n    });\r\n    Transliterator.registerFactory(\"Hex-Any/C\", new Transliterator.Factory() {\r\n        @Override\r\n        public Transliterator getInstance(String ID) {\r\n            return new UnescapeTransliterator(\"Hex-Any/C\", new char[] { 2, 0, 16, 4, 4, '\\\\', 'u', 2, 0, 16, 8, 8, '\\\\', 'U', END });\r\n        }\r\n    });\r\n    Transliterator.registerFactory(\"Hex-Any/XML\", new Transliterator.Factory() {\r\n        @Override\r\n        public Transliterator getInstance(String ID) {\r\n            return new UnescapeTransliterator(\"Hex-Any/XML\", new char[] { 3, 1, 16, 1, 6, '&', '#', 'x', ';', END });\r\n        }\r\n    });\r\n    Transliterator.registerFactory(\"Hex-Any/XML10\", new Transliterator.Factory() {\r\n        @Override\r\n        public Transliterator getInstance(String ID) {\r\n            return new UnescapeTransliterator(\"Hex-Any/XML10\", new char[] { 2, 1, 10, 1, 7, '&', '#', ';', END });\r\n        }\r\n    });\r\n    Transliterator.registerFactory(\"Hex-Any/Perl\", new Transliterator.Factory() {\r\n        @Override\r\n        public Transliterator getInstance(String ID) {\r\n            return new UnescapeTransliterator(\"Hex-Any/Perl\", new char[] { 3, 1, 16, 1, 6, '\\\\', 'x', '{', '}', END });\r\n        }\r\n    });\r\n    Transliterator.registerFactory(\"Hex-Any\", new Transliterator.Factory() {\r\n        @Override\r\n        public Transliterator getInstance(String ID) {\r\n            return new UnescapeTransliterator(\"Hex-Any\", new char[] { 2, 0, 16, 4, 6, 'U', '+', 2, 0, 16, 4, 4, '\\\\', 'u', 2, 0, 16, 8, 8, '\\\\', 'U', 3, 1, 16, 1, 6, '&', '#', 'x', ';', 2, 1, 10, 1, 7, '&', '#', ';', 3, 1, 16, 1, 6, '\\\\', 'x', '{', '}', END });\r\n        }\r\n    });\r\n}"
}, {
	"Path": "android.icu.text.UnescapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    return new UnescapeTransliterator(\"Hex-Any/Unicode\", new char[] { 2, 0, 16, 4, 6, 'U', '+', END });\r\n}"
}, {
	"Path": "android.icu.text.UnescapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    return new UnescapeTransliterator(\"Hex-Any/Java\", new char[] { 2, 0, 16, 4, 4, '\\\\', 'u', END });\r\n}"
}, {
	"Path": "android.icu.text.UnescapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    return new UnescapeTransliterator(\"Hex-Any/C\", new char[] { 2, 0, 16, 4, 4, '\\\\', 'u', 2, 0, 16, 8, 8, '\\\\', 'U', END });\r\n}"
}, {
	"Path": "android.icu.text.UnescapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    return new UnescapeTransliterator(\"Hex-Any/XML\", new char[] { 3, 1, 16, 1, 6, '&', '#', 'x', ';', END });\r\n}"
}, {
	"Path": "android.icu.text.UnescapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    return new UnescapeTransliterator(\"Hex-Any/XML10\", new char[] { 2, 1, 10, 1, 7, '&', '#', ';', END });\r\n}"
}, {
	"Path": "android.icu.text.UnescapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    return new UnescapeTransliterator(\"Hex-Any/Perl\", new char[] { 3, 1, 16, 1, 6, '\\\\', 'x', '{', '}', END });\r\n}"
}, {
	"Path": "android.icu.text.UnescapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    return new UnescapeTransliterator(\"Hex-Any\", new char[] { 2, 0, 16, 4, 6, 'U', '+', 2, 0, 16, 4, 4, '\\\\', 'u', 2, 0, 16, 8, 8, '\\\\', 'U', 3, 1, 16, 1, 6, '&', '#', 'x', ';', 2, 1, 10, 1, 7, '&', '#', ';', 3, 1, 16, 1, 6, '\\\\', 'x', '{', '}', END });\r\n}"
}, {
	"Path": "android.icu.text.CollationElementIterator.tertiaryOrder",
	"Comment": "return the tertiary order of the specified collation element, i.e. the last8 bits.this value is unsigned.",
	"Method": "int tertiaryOrder(int ce){\r\n    return ce & 0xff;\r\n}"
}, {
	"Path": "android.icu.util.Calendar.julianDayToDayOfWeek",
	"Comment": "returns the day of week, from sunday to saturday, given a julian day.",
	"Method": "int julianDayToDayOfWeek(int julian){\r\n    int dayOfWeek = (julian + MONDAY) % 7;\r\n    if (dayOfWeek < SUNDAY) {\r\n        dayOfWeek += 7;\r\n    }\r\n    return dayOfWeek;\r\n}"
}, {
	"Path": "android.icu.impl.CalendarUtil.getCalendarType",
	"Comment": "returns a calendar type for the given locale.when the given locale has calendar keyword, thevalue of calendar keyword is returned.otherwise,the default calendar type for the locale is returned.",
	"Method": "String getCalendarType(ULocale loc){\r\n    String calType = loc.getKeywordValue(CALKEY);\r\n    if (calType != null) {\r\n        return calType;\r\n    }\r\n    ULocale canonical = ULocale.createCanonical(loc.toString());\r\n    calType = canonical.getKeywordValue(CALKEY);\r\n    if (calType != null) {\r\n        return calType;\r\n    }\r\n    String region = ULocale.getRegionForSupplementalData(canonical, true);\r\n    return CalendarPreferences.INSTANCE.getCalendarTypeForRegion(region);\r\n}"
}, {
	"Path": "android.icu.util.UniversalTimeScale.bigDecimalFrom",
	"Comment": "convert a bigdecimal datetime from the given time scale to the universal time scale.all calculations are done using bigdecimal to guarantee that the valuedoes not go out of range.",
	"Method": "BigDecimal bigDecimalFrom(double otherTime,int timeScale,BigDecimal bigDecimalFrom,long otherTime,int timeScale,BigDecimal bigDecimalFrom,BigDecimal otherTime,int timeScale){\r\n    TimeScaleData data = getTimeScaleData(timeScale);\r\n    BigDecimal units = new BigDecimal(data.units);\r\n    BigDecimal epochOffset = new BigDecimal(data.epochOffset);\r\n    return otherTime.add(epochOffset).multiply(units);\r\n}"
}, {
	"Path": "android.icu.text.TransliteratorParser.pragmaNormalizeRules",
	"Comment": "begin normalizing all rules using the given mode, in responseto a pragma statement.",
	"Method": "void pragmaNormalizeRules(Normalizer.Mode mode){\r\n    throw new IllegalIcuArgumentException(\"use normalize rules pragma not implemented yet\");\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedNumberFormat.getLenientScannerProvider",
	"Comment": "returns the lenient scanner provider.if none was set, and lenient parse isenabled, this will attempt to instantiate a default scanner, setting it ifit was successful.otherwise this returns false.",
	"Method": "RbnfLenientScannerProvider getLenientScannerProvider(){\r\n    if (scannerProvider == null && lenientParse && !lookedForScanner) {\r\n        try {\r\n            lookedForScanner = true;\r\n            Class<?> cls = Class.forName(\"android.icu.impl.text.RbnfScannerProviderImpl\");\r\n            RbnfLenientScannerProvider provider = (RbnfLenientScannerProvider) cls.newInstance();\r\n            setLenientScannerProvider(provider);\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return scannerProvider;\r\n}"
}, {
	"Path": "android.icu.impl.Trie.unserialize",
	"Comment": "parses the byte buffer and creates the trie index with it.the position of the input bytebuffer must be right after the trie header.this is overwritten by the child classes.",
	"Method": "void unserialize(ByteBuffer bytes){\r\n    m_index_ = ICUBinary.getChars(bytes, m_dataOffset_, 0);\r\n}"
}, {
	"Path": "android.icu.util.Currency.getSymbol",
	"Comment": "convenience and compatibility override of getname thatrequests the symbol name.",
	"Method": "String getSymbol(String getSymbol,Locale loc,String getSymbol,ULocale uloc){\r\n    return getName(uloc, SYMBOL_NAME, new boolean[1]);\r\n}"
}, {
	"Path": "android.icu.impl.Trie.getLeadOffset",
	"Comment": "gets the offset to the data which this lead surrogate character points to. data at the returned offset may contain folding offset information for the next trailing surrogate character.",
	"Method": "int getLeadOffset(char ch){\r\n    return getRawOffset(0, ch);\r\n}"
}, {
	"Path": "android.icu.impl.IntTrie.getValue",
	"Comment": "gets the value at the argument index. for use internally in trieiterator",
	"Method": "int getValue(int index){\r\n    return m_data_[index];\r\n}"
}, {
	"Path": "android.icu.impl.ICUResourceBundle.isRoot",
	"Comment": "returns true if this is the root bundle, or an item in the root bundle.",
	"Method": "boolean isRoot(){\r\n    return wholeBundle.localeID.isEmpty() || wholeBundle.localeID.equals(\"root\");\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.setRoundingMode",
	"Comment": "sets the rounding mode. this has no effect unless the rounding increment is greaterthan zero.",
	"Method": "void setRoundingMode(int roundingMode){\r\n    if (roundingMode < BigDecimal.ROUND_UP || roundingMode > BigDecimal.ROUND_UNNECESSARY) {\r\n        throw new IllegalArgumentException(\"Invalid rounding mode: \" + roundingMode);\r\n    }\r\n    this.roundingMode = roundingMode;\r\n    resetActualRounding();\r\n}"
}, {
	"Path": "android.icu.impl.ICUResourceBundle.getAvailableLocaleNameSet",
	"Comment": "return a set of the locale names supported by a collection of resourcebundles.",
	"Method": "Set<String> getAvailableLocaleNameSet(String bundlePrefix,ClassLoader loader,Set<String> getAvailableLocaleNameSet){\r\n    return getAvailableLocaleNameSet(ICUData.ICU_BASE_NAME, ICU_DATA_CLASS_LOADER);\r\n}"
}, {
	"Path": "android.icu.util.ChineseCalendar.newMoonNear",
	"Comment": "return the closest new moon to the given date, searching eitherforward or backward in time.",
	"Method": "int newMoonNear(int days,boolean after){\r\n    astro.setTime(daysToMillis(days));\r\n    long newMoon = astro.getMoonTime(CalendarAstronomer.NEW_MOON, after);\r\n    return millisToDays(newMoon);\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.setParseMaxDigits",
	"Comment": "set the maximum number of exponent digits when parsing a number. if the limit is set too high, an outofmemoryexception may be triggered. the default value is 1000.",
	"Method": "void setParseMaxDigits(int newValue){\r\n    if (newValue > 0) {\r\n        PARSE_MAX_EXPONENT = newValue;\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.ZoneMeta.countEquivalentIDs",
	"Comment": "returns the number of ids in the equivalency group thatincludes the given id.an equivalency group contains zonesthat behave identically to the given zone.if there are no equivalent zones, then this method returns0.this means either the given id is not a valid zone, or itis and there are no other equivalent zones.",
	"Method": "int countEquivalentIDs(String id){\r\n    int count = 0;\r\n    UResourceBundle res = openOlsonResource(null, id);\r\n    if (res != null) {\r\n        try {\r\n            UResourceBundle links = res.get(\"links\");\r\n            int[] v = links.getIntVector();\r\n            count = v.length;\r\n        } catch (MissingResourceException ex) {\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "android.icu.util.TimeZone.setDefault",
	"Comment": "sets the timezone that isreturned by the getdefault method.if zoneis null, reset the default to the value it had originally when thevm first started.",
	"Method": "void setDefault(TimeZone tz){\r\n    defaultZone = tz;\r\n    java.util.TimeZone jdkZone = null;\r\n    if (defaultZone instanceof JavaTimeZone) {\r\n        jdkZone = ((JavaTimeZone) defaultZone).unwrap();\r\n    } else {\r\n        if (tz != null) {\r\n            if (tz instanceof android.icu.impl.OlsonTimeZone) {\r\n                String icuID = tz.getID();\r\n                jdkZone = java.util.TimeZone.getTimeZone(icuID);\r\n                if (!icuID.equals(jdkZone.getID())) {\r\n                    icuID = getCanonicalID(icuID);\r\n                    jdkZone = java.util.TimeZone.getTimeZone(icuID);\r\n                    if (!icuID.equals(jdkZone.getID())) {\r\n                        jdkZone = null;\r\n                    }\r\n                }\r\n            }\r\n            if (jdkZone == null) {\r\n                jdkZone = TimeZoneAdapter.wrap(tz);\r\n            }\r\n        }\r\n    }\r\n    java.util.TimeZone.setDefault(jdkZone);\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.setInternationalCurrencySymbol",
	"Comment": "sets the international string denoting the local currency.",
	"Method": "void setInternationalCurrencySymbol(String currency){\r\n    intlCurrencySymbol = currency;\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.containsNone",
	"Comment": "returns true if this set contains none of the charactersof the given string.",
	"Method": "boolean containsNone(int start,int end,boolean containsNone,UnicodeSet b,boolean containsNone,CharSequence s,boolean containsNone,Iterable<T> collection){\r\n    for (T o : collection) {\r\n        if (contains(o)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.setLoadFields",
	"Comment": "set the collection of field descriptors for the input fields of thecorresponding class",
	"Method": "void setLoadFields(ObjectStreamField[] f){\r\n    loadFields = f;\r\n}"
}, {
	"Path": "android.icu.util.Holiday.getDisplayName",
	"Comment": "return the name of this holiday in the language of the default display locale.",
	"Method": "String getDisplayName(String getDisplayName,Locale locale,String getDisplayName,ULocale locale){\r\n    String dispName = name;\r\n    try {\r\n        ResourceBundle bundle = UResourceBundle.getBundleInstance(\"android.icu.impl.data.HolidayBundle\", locale);\r\n        dispName = bundle.getString(name);\r\n    } catch (MissingResourceException e) {\r\n    }\r\n    return dispName;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.setInfinity",
	"Comment": "sets the string used to represent infinity. almost always leftunchanged.",
	"Method": "void setInfinity(String infinity){\r\n    this.infinity = infinity;\r\n}"
}, {
	"Path": "android.icu.impl.CalendarAstronomer.setJulianDay",
	"Comment": "set the current date and time of this calendarastronomer object.allastronomical calculations are performed based on this time setting.",
	"Method": "void setJulianDay(double jdn){\r\n    time = (long) (jdn * DAY_MS) + JULIAN_EPOCH_MS;\r\n    clearCache();\r\n    julianDay = jdn;\r\n}"
}, {
	"Path": "org.apache.harmony.xml.dom.DocumentImpl.cloneOrImportNode",
	"Comment": "returns a copy of the given node or subtree with this document as itsowner.",
	"Method": "Node cloneOrImportNode(short operation,Node node,boolean deep){\r\n    NodeImpl copy = shallowCopy(operation, node);\r\n    if (deep) {\r\n        NodeList list = node.getChildNodes();\r\n        for (int i = 0; i < list.getLength(); i++) {\r\n            copy.appendChild(cloneOrImportNode(operation, list.item(i), deep));\r\n        }\r\n    }\r\n    notifyUserDataHandlers(operation, node, copy);\r\n    return copy;\r\n}"
}, {
	"Path": "android.icu.util.Calendar.updateTime",
	"Comment": "recompute the time and update the status fields istimesetand arefieldsset.callers should check istimeset and onlycall this method if istimeset is false.",
	"Method": "void updateTime(){\r\n    computeTime();\r\n    if (isLenient() || !areAllFieldsSet)\r\n        areFieldsSet = false;\r\n    isTimeSet = true;\r\n    areFieldsVirtuallySet = false;\r\n}"
}, {
	"Path": "java.io.OutputStreamWriter.flush",
	"Comment": "flushes this writer. this implementation ensures that all buffered bytesare written to the target stream. after writing the bytes, the targetstream is flushed as well.",
	"Method": "void flush(){\r\n    flushBytes(true);\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.precision",
	"Comment": "return the number of fraction digits to display, or the totalnumber of digits for significant digit formats and exponentialformats.",
	"Method": "int precision(boolean isIntegral){\r\n    if (areSignificantDigitsUsed()) {\r\n        return getMaximumSignificantDigits();\r\n    } else if (useExponentialNotation) {\r\n        return getMinimumIntegerDigits() + getMaximumFractionDigits();\r\n    } else {\r\n        return isIntegral ? 0 : getMaximumFractionDigits();\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.IntTrie.getCodePointValue",
	"Comment": "gets the value associated with the codepoint. if no value is associated with the codepoint, a default value will be returned.",
	"Method": "int getCodePointValue(int ch){\r\n    int offset;\r\n    if (0 <= ch && ch < UTF16.LEAD_SURROGATE_MIN_VALUE) {\r\n        offset = (m_index_[ch >> INDEX_STAGE_1_SHIFT_] << INDEX_STAGE_2_SHIFT_) + (ch & INDEX_STAGE_3_MASK_);\r\n        return m_data_[offset];\r\n    }\r\n    offset = getCodePointOffset(ch);\r\n    return (offset >= 0) ? m_data_[offset] : m_initialValue_;\r\n}"
}, {
	"Path": "android.icu.text.MeasureFormat.formatMeasures",
	"Comment": "formats a sequence of measures.if the fieldposition argument identifies a numberformat field,then its indices are set to the beginning and end of the first such fieldencountered. measureformat itself does not supply any fields.",
	"Method": "String formatMeasures(Measure measures,StringBuilder formatMeasures,StringBuilder appendTo,FieldPosition fieldPosition,Measure measures){\r\n    if (measures.length == 0) {\r\n        return appendTo;\r\n    }\r\n    if (measures.length == 1) {\r\n        return formatMeasure(measures[0], numberFormat, appendTo, fieldPosition);\r\n    }\r\n    if (formatWidth == FormatWidth.NUMERIC) {\r\n        Number[] hms = toHMS(measures);\r\n        if (hms != null) {\r\n            return formatNumeric(hms, appendTo);\r\n        }\r\n    }\r\n    ListFormatter listFormatter = ListFormatter.getInstance(getLocale(), formatWidth.getListFormatterStyle());\r\n    if (fieldPosition != DontCareFieldPosition.INSTANCE) {\r\n        return formatMeasuresSlowTrack(listFormatter, appendTo, fieldPosition, measures);\r\n    }\r\n    String[] results = new String[measures.length];\r\n    for (int i = 0; i < measures.length; i++) {\r\n        results[i] = formatMeasure(measures[i], i == measures.length - 1 ? numberFormat : integerFormat);\r\n    }\r\n    return appendTo.append(listFormatter.format((Object[]) results));\r\n}"
}, {
	"Path": "android.icu.impl.duration.Period.isLessThan",
	"Comment": "returns true if this represents a durationless than the defined duration.",
	"Method": "boolean isLessThan(){\r\n    return timeLimit == ETimeLimit.LT;\r\n}"
}, {
	"Path": "android.icu.impl.Trie2.iterator",
	"Comment": "create an iterator over the value ranges in this trie2. values from the trie2 are not remapped or filtered, but are returned as they are stored in the trie2.",
	"Method": "Iterator<Range> iterator(Iterator<Range> iterator,ValueMapper mapper){\r\n    return new Trie2Iterator(mapper);\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.initializeTimeZoneFormat",
	"Comment": "private method lazily instantiate the timezoneformat field",
	"Method": "void initializeTimeZoneFormat(boolean bForceUpdate){\r\n    if (bForceUpdate || tzFormat == null) {\r\n        tzFormat = TimeZoneFormat.getInstance(locale);\r\n        String digits = null;\r\n        if (numberFormat instanceof DecimalFormat) {\r\n            DecimalFormatSymbols decsym = ((DecimalFormat) numberFormat).getDecimalFormatSymbols();\r\n            digits = new String(decsym.getDigits());\r\n        } else if (numberFormat instanceof DateNumberFormat) {\r\n            digits = new String(((DateNumberFormat) numberFormat).getDigits());\r\n        }\r\n        if (digits != null) {\r\n            if (!tzFormat.getGMTOffsetDigits().equals(digits)) {\r\n                if (tzFormat.isFrozen()) {\r\n                    tzFormat = tzFormat.cloneAsThawed();\r\n                }\r\n                tzFormat.setGMTOffsetDigits(digits);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.computePutField",
	"Comment": "computes the collection of emulated fields that users can manipulate tostore a representation different than the one declared by the class ofthe object being dumped.",
	"Method": "void computePutField(){\r\n    currentPutField = new EmulatedFieldsForDumping(this, currentClass);\r\n}"
}, {
	"Path": "android.icu.util.SimpleDateRule.firstBetween",
	"Comment": "return the first occurrance of the event represented by this rulethat is on or after the given start date and before the givenend date.",
	"Method": "Date firstBetween(Date start,Date end){\r\n    return doFirstBetween(start, end);\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneGenericNames.getTargetRegion",
	"Comment": "private method returning the target region. the target regions is determined bythe locale of this instance. when a generic name is coming froma meta zone, this region is used for checking if the time zoneis a reference zone of the meta zone.",
	"Method": "String getTargetRegion(){\r\n    if (_region == null) {\r\n        _region = _locale.getCountry();\r\n        if (_region.length() == 0) {\r\n            ULocale tmp = ULocale.addLikelySubtags(_locale);\r\n            _region = tmp.getCountry();\r\n            if (_region.length() == 0) {\r\n                _region = \"001\";\r\n            }\r\n        }\r\n    }\r\n    return _region;\r\n}"
}, {
	"Path": "android.icu.impl.ZoneMeta.getRegion",
	"Comment": "return the region code for this tzid.if tzid is not a system zone id, this method returns null.",
	"Method": "String getRegion(String tzid){\r\n    String region = REGION_CACHE.get(tzid);\r\n    if (region == null) {\r\n        int zoneIdx = getZoneIndex(tzid);\r\n        if (zoneIdx >= 0) {\r\n            try {\r\n                UResourceBundle top = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, ZONEINFORESNAME, ICUResourceBundle.ICU_DATA_CLASS_LOADER);\r\n                UResourceBundle regions = top.get(kREGIONS);\r\n                if (zoneIdx < regions.getSize()) {\r\n                    region = regions.getString(zoneIdx);\r\n                }\r\n            } catch (MissingResourceException e) {\r\n            }\r\n            if (region != null) {\r\n                REGION_CACHE.put(tzid, region);\r\n            }\r\n        }\r\n    }\r\n    return region;\r\n}"
}, {
	"Path": "android.icu.text.AlphabeticIndex.initBuckets",
	"Comment": "creates an index, and buckets and sorts the list of records into the index.",
	"Method": "void initBuckets(){\r\n    if (buckets != null) {\r\n        return;\r\n    }\r\n    buckets = createBucketList();\r\n    if (inputList == null || inputList.isEmpty()) {\r\n        return;\r\n    }\r\n    Collections.sort(inputList, recordComparator);\r\n    Iterator<Bucket<V>> bucketIterator = buckets.fullIterator();\r\n    Bucket<V> currentBucket = bucketIterator.next();\r\n    Bucket<V> nextBucket;\r\n    String upperBoundary;\r\n    if (bucketIterator.hasNext()) {\r\n        nextBucket = bucketIterator.next();\r\n        upperBoundary = nextBucket.lowerBoundary;\r\n    } else {\r\n        nextBucket = null;\r\n        upperBoundary = null;\r\n    }\r\n    for (Record<V> r : inputList) {\r\n        while (upperBoundary != null && collatorPrimaryOnly.compare(r.name, upperBoundary) >= 0) {\r\n            currentBucket = nextBucket;\r\n            if (bucketIterator.hasNext()) {\r\n                nextBucket = bucketIterator.next();\r\n                upperBoundary = nextBucket.lowerBoundary;\r\n            } else {\r\n                upperBoundary = null;\r\n            }\r\n        }\r\n        Bucket<V> bucket = currentBucket;\r\n        if (bucket.displayBucket != null) {\r\n            bucket = bucket.displayBucket;\r\n        }\r\n        if (bucket.records == null) {\r\n            bucket.records = new ArrayList<Record<V>>();\r\n        }\r\n        bucket.records.add(r);\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.Currency.getAvailableCurrencyCodes",
	"Comment": "returns an array of strings which contain the currencyidentifiers that are valid for the given locale on thegiven date.if there are no such identifiers, returns null.returned identifiers are in preference order.",
	"Method": "String[] getAvailableCurrencyCodes(ULocale loc,Date d,String[] getAvailableCurrencyCodes,Locale loc,Date d){\r\n    return getAvailableCurrencyCodes(ULocale.forLocale(loc), d);\r\n}"
}, {
	"Path": "android.icu.text.NFRule.makeRules",
	"Comment": "creates one or more rules based on the description passed in.",
	"Method": "void makeRules(String description,NFRuleSet owner,NFRule predecessor,RuleBasedNumberFormat ownersOwner,List<NFRule> returnList){\r\n    NFRule rule1 = new NFRule(ownersOwner, description);\r\n    description = rule1.ruleText;\r\n    int brack1 = description.indexOf('[');\r\n    int brack2 = brack1 < 0 ? -1 : description.indexOf(']');\r\n    if (brack2 < 0 || brack1 > brack2 || rule1.baseValue == PROPER_FRACTION_RULE || rule1.baseValue == NEGATIVE_NUMBER_RULE || rule1.baseValue == INFINITY_RULE || rule1.baseValue == NAN_RULE) {\r\n        rule1.extractSubstitutions(owner, description, predecessor);\r\n    } else {\r\n        NFRule rule2 = null;\r\n        StringBuilder sbuf = new StringBuilder();\r\n        if ((rule1.baseValue > 0 && rule1.baseValue % (power(rule1.radix, rule1.exponent)) == 0) || rule1.baseValue == IMPROPER_FRACTION_RULE || rule1.baseValue == MASTER_RULE) {\r\n            rule2 = new NFRule(ownersOwner, null);\r\n            if (rule1.baseValue >= 0) {\r\n                rule2.baseValue = rule1.baseValue;\r\n                if (!owner.isFractionSet()) {\r\n                    ++rule1.baseValue;\r\n                }\r\n            } else if (rule1.baseValue == IMPROPER_FRACTION_RULE) {\r\n                rule2.baseValue = PROPER_FRACTION_RULE;\r\n            } else if (rule1.baseValue == MASTER_RULE) {\r\n                rule2.baseValue = rule1.baseValue;\r\n                rule1.baseValue = IMPROPER_FRACTION_RULE;\r\n            }\r\n            rule2.radix = rule1.radix;\r\n            rule2.exponent = rule1.exponent;\r\n            sbuf.append(description.substring(0, brack1));\r\n            if (brack2 + 1 < description.length()) {\r\n                sbuf.append(description.substring(brack2 + 1));\r\n            }\r\n            rule2.extractSubstitutions(owner, sbuf.toString(), predecessor);\r\n        }\r\n        sbuf.setLength(0);\r\n        sbuf.append(description.substring(0, brack1));\r\n        sbuf.append(description.substring(brack1 + 1, brack2));\r\n        if (brack2 + 1 < description.length()) {\r\n            sbuf.append(description.substring(brack2 + 1));\r\n        }\r\n        rule1.extractSubstitutions(owner, sbuf.toString(), predecessor);\r\n        if (rule2 != null) {\r\n            if (rule2.baseValue >= 0) {\r\n                returnList.add(rule2);\r\n            } else {\r\n                owner.setNonNumericalRule(rule2);\r\n            }\r\n        }\r\n    }\r\n    if (rule1.baseValue >= 0) {\r\n        returnList.add(rule1);\r\n    } else {\r\n        owner.setNonNumericalRule(rule1);\r\n    }\r\n}"
}, {
	"Path": "libcore.net.MimeUtils.guessExtensionFromMimeType",
	"Comment": "returns the registered extension for the given mime type. note that somemime types map to multiple extensions. this call will return the mostcommon extension for the given mime type.",
	"Method": "String guessExtensionFromMimeType(String mimeType){\r\n    if (mimeType == null || mimeType.isEmpty()) {\r\n        return null;\r\n    }\r\n    return mimeTypeToExtensionMap.get(mimeType);\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.initializeDefaultCenturyStart",
	"Comment": "initialize defaultcenturystart and defaultcenturystartyear by base time.the default start time is 80 years before the creation time of this object.",
	"Method": "void initializeDefaultCenturyStart(long baseTime){\r\n    defaultCenturyBase = baseTime;\r\n    Calendar tmpCal = (Calendar) calendar.clone();\r\n    tmpCal.setTimeInMillis(baseTime);\r\n    tmpCal.add(Calendar.YEAR, -80);\r\n    defaultCenturyStart = tmpCal.getTime();\r\n    defaultCenturyStartYear = tmpCal.get(Calendar.YEAR);\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.hashCode",
	"Comment": "override hashcode.generates the hash code for the simpledateformat object",
	"Method": "int hashCode(){\r\n    return pattern.hashCode();\r\n}"
}, {
	"Path": "android.icu.text.DateFormat.setTimeZone",
	"Comment": "sets the time zone for the calendar of this dateformat object.",
	"Method": "void setTimeZone(TimeZone zone){\r\n    calendar.setTimeZone(zone);\r\n}"
}, {
	"Path": "android.icu.impl.PluralRulesLoader.getRulesIdForLocale",
	"Comment": "gets the rulesid from the locale,with locale fallback. if there is norulesid, return null. the rulesid might be the empty string if the ruleis the default rule.",
	"Method": "String getRulesIdForLocale(ULocale locale,PluralType type){\r\n    Map<String, String> idMap = getLocaleIdToRulesIdMap(type);\r\n    String localeId = ULocale.canonicalize(locale.getBaseName());\r\n    String rulesId = null;\r\n    while (null == (rulesId = idMap.get(localeId))) {\r\n        int ix = localeId.lastIndexOf(\"_\");\r\n        if (ix == -1) {\r\n            break;\r\n        }\r\n        localeId = localeId.substring(0, ix);\r\n    }\r\n    return rulesId;\r\n}"
}, {
	"Path": "org.apache.harmony.xml.dom.CDATASectionImpl.replaceWithText",
	"Comment": "replaces this node with a semantically equivalent text node. this nodewill be removed from the dom tree and the new node inserted in its place.",
	"Method": "TextImpl replaceWithText(){\r\n    TextImpl replacement = new TextImpl(document, getData());\r\n    parent.insertBefore(replacement, this);\r\n    parent.removeChild(this);\r\n    return replacement;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.toLocalizedPattern",
	"Comment": "synthesizes a localized pattern string that represents the current state of thisformat object.",
	"Method": "String toLocalizedPattern(){\r\n    if (style == NumberFormat.PLURALCURRENCYSTYLE) {\r\n        return formatPattern;\r\n    }\r\n    return toPattern(true);\r\n}"
}, {
	"Path": "android.icu.util.Calendar.getFieldResolutionTable",
	"Comment": "returns the field resolution array for this calendar.calendars thatdefine additional fields or change the semantics of existing fieldsshould override this method to adjust the field resolution semanticsaccordingly.other subclasses should not override this method.",
	"Method": "int[][][] getFieldResolutionTable(){\r\n    return DATE_PRECEDENCE;\r\n}"
}, {
	"Path": "android.icu.impl.coll.CollationRootElements.findPrimary",
	"Comment": "finds the index of the input primary.p must occur as a root primary, and must not be 0.",
	"Method": "int findPrimary(long p){\r\n    assert ((p & 0xff) == 0);\r\n    int index = findP(p);\r\n    assert (isEndOfPrimaryRange(elements[index + 1]) || p == (elements[index] & 0xffffff00L));\r\n    return index;\r\n}"
}, {
	"Path": "android.icu.text.EscapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    Transliterator.registerFactory(\"Any-Hex/Unicode\", new Transliterator.Factory() {\r\n        @Override\r\n        public Transliterator getInstance(String ID) {\r\n            return new EscapeTransliterator(\"Any-Hex/Unicode\", \"U+\", \"\", 16, 4, true, null);\r\n        }\r\n    });\r\n    Transliterator.registerFactory(\"Any-Hex/Java\", new Transliterator.Factory() {\r\n        @Override\r\n        public Transliterator getInstance(String ID) {\r\n            return new EscapeTransliterator(\"Any-Hex/Java\", \"\\\%u\", \"\", 16, 4, false, null);\r\n        }\r\n    });\r\n    Transliterator.registerFactory(\"Any-Hex/C\", new Transliterator.Factory() {\r\n        @Override\r\n        public Transliterator getInstance(String ID) {\r\n            return new EscapeTransliterator(\"Any-Hex/C\", \"\\\%u\", \"\", 16, 4, true, new EscapeTransliterator(\"\", \"\\\\U\", \"\", 16, 8, true, null));\r\n        }\r\n    });\r\n    Transliterator.registerFactory(\"Any-Hex/XML\", new Transliterator.Factory() {\r\n        @Override\r\n        public Transliterator getInstance(String ID) {\r\n            return new EscapeTransliterator(\"Any-Hex/XML\", \"&#x\", \";\", 16, 1, true, null);\r\n        }\r\n    });\r\n    Transliterator.registerFactory(\"Any-Hex/XML10\", new Transliterator.Factory() {\r\n        @Override\r\n        public Transliterator getInstance(String ID) {\r\n            return new EscapeTransliterator(\"Any-Hex/XML10\", \"&#\", \";\", 10, 1, true, null);\r\n        }\r\n    });\r\n    Transliterator.registerFactory(\"Any-Hex/Perl\", new Transliterator.Factory() {\r\n        @Override\r\n        public Transliterator getInstance(String ID) {\r\n            return new EscapeTransliterator(\"Any-Hex/Perl\", \"\\\\x{\", \"}\", 16, 1, true, null);\r\n        }\r\n    });\r\n    Transliterator.registerFactory(\"Any-Hex/Plain\", new Transliterator.Factory() {\r\n        @Override\r\n        public Transliterator getInstance(String ID) {\r\n            return new EscapeTransliterator(\"Any-Hex/Plain\", \"\", \"\", 16, 4, true, null);\r\n        }\r\n    });\r\n    Transliterator.registerFactory(\"Any-Hex\", new Transliterator.Factory() {\r\n        @Override\r\n        public Transliterator getInstance(String ID) {\r\n            return new EscapeTransliterator(\"Any-Hex\", \"\\\%u\", \"\", 16, 4, false, null);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "android.icu.text.EscapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    return new EscapeTransliterator(\"Any-Hex/Unicode\", \"U+\", \"\", 16, 4, true, null);\r\n}"
}, {
	"Path": "android.icu.text.EscapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    return new EscapeTransliterator(\"Any-Hex/Java\", \"\\\%u\", \"\", 16, 4, false, null);\r\n}"
}, {
	"Path": "android.icu.text.EscapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    return new EscapeTransliterator(\"Any-Hex/C\", \"\\\%u\", \"\", 16, 4, true, new EscapeTransliterator(\"\", \"\\\\U\", \"\", 16, 8, true, null));\r\n}"
}, {
	"Path": "android.icu.text.EscapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    return new EscapeTransliterator(\"Any-Hex/XML\", \"&#x\", \";\", 16, 1, true, null);\r\n}"
}, {
	"Path": "android.icu.text.EscapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    return new EscapeTransliterator(\"Any-Hex/XML10\", \"&#\", \";\", 10, 1, true, null);\r\n}"
}, {
	"Path": "android.icu.text.EscapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    return new EscapeTransliterator(\"Any-Hex/Perl\", \"\\\\x{\", \"}\", 16, 1, true, null);\r\n}"
}, {
	"Path": "android.icu.text.EscapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    return new EscapeTransliterator(\"Any-Hex/Plain\", \"\", \"\", 16, 4, true, null);\r\n}"
}, {
	"Path": "android.icu.text.EscapeTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    return new EscapeTransliterator(\"Any-Hex\", \"\\\%u\", \"\", 16, 4, false, null);\r\n}"
}, {
	"Path": "android.icu.impl.duration.BasicDurationFormatterFactory.setPeriodBuilder",
	"Comment": "set the builder used by the factory.new formatters createdwith this factory will use the given locale.",
	"Method": "DurationFormatterFactory setPeriodBuilder(PeriodBuilder builder){\r\n    if (builder != this.builder) {\r\n        this.builder = builder;\r\n        reset();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.impl.PluralRulesLoader.getRulesForRulesId",
	"Comment": "gets the rule from the rulesid. if there is no rule for this rulesid,return null.",
	"Method": "PluralRules getRulesForRulesId(String rulesId){\r\n    PluralRules rules = null;\r\n    boolean hasRules;\r\n    synchronized (rulesIdToRules) {\r\n        hasRules = rulesIdToRules.containsKey(rulesId);\r\n        if (hasRules) {\r\n            rules = rulesIdToRules.get(rulesId);\r\n        }\r\n    }\r\n    if (!hasRules) {\r\n        try {\r\n            UResourceBundle pluralb = getPluralBundle();\r\n            UResourceBundle rulesb = pluralb.get(\"rules\");\r\n            UResourceBundle setb = rulesb.get(rulesId);\r\n            StringBuilder sb = new StringBuilder();\r\n            for (int i = 0; i < setb.getSize(); ++i) {\r\n                UResourceBundle b = setb.get(i);\r\n                if (i > 0) {\r\n                    sb.append(\"; \");\r\n                }\r\n                sb.append(b.getKey());\r\n                sb.append(\": \");\r\n                sb.append(b.getString());\r\n            }\r\n            rules = PluralRules.parseDescription(sb.toString());\r\n        } catch (ParseException e) {\r\n        } catch (MissingResourceException e) {\r\n        }\r\n        synchronized (rulesIdToRules) {\r\n            if (rulesIdToRules.containsKey(rulesId)) {\r\n                rules = rulesIdToRules.get(rulesId);\r\n            } else {\r\n                rulesIdToRules.put(rulesId, rules);\r\n            }\r\n        }\r\n    }\r\n    return rules;\r\n}"
}, {
	"Path": "android.icu.util.ULocale.getUnicodeLocaleAttributes",
	"Comment": "returns the set of unicode locale attributes associated withthis locale, or the empty set if it has no attributes. thereturned set is unmodifiable.",
	"Method": "Set<String> getUnicodeLocaleAttributes(){\r\n    return extensions().getUnicodeLocaleAttributes();\r\n}"
}, {
	"Path": "android.icu.util.TimeZoneTransition.toString",
	"Comment": "returns a string representation of this timezonetransition object.this method is used for debugging purpose only.the string representation can be changedin future version of icu without any notice.",
	"Method": "String toString(){\r\n    StringBuilder buf = new StringBuilder();\r\n    buf.append(\"time=\" + time);\r\n    buf.append(\", from={\" + from + \"}\");\r\n    buf.append(\", to={\" + to + \"}\");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "android.icu.impl.ICULocaleService.getAvailableLocales",
	"Comment": "convenience method for callers using locales.this returns the standardlocale list, built from the set of visible ids.",
	"Method": "Locale[] getAvailableLocales(){\r\n    Set<String> visIDs = getVisibleIDs();\r\n    Locale[] locales = new Locale[visIDs.size()];\r\n    int n = 0;\r\n    for (String id : visIDs) {\r\n        Locale loc = LocaleUtility.getLocaleFromName(id);\r\n        locales[n++] = loc;\r\n    }\r\n    return locales;\r\n}"
}, {
	"Path": "android.icu.text.TimeZoneFormat.parseOffsetLocalizedGMTPattern",
	"Comment": "parse localized gmt format generated by the pattern used by this formatter, exceptgmt zero format.",
	"Method": "int parseOffsetLocalizedGMTPattern(String text,int start,boolean isShort,int[] parsedLen){\r\n    int idx = start;\r\n    int offset = 0;\r\n    boolean parsed = false;\r\n    do {\r\n        int len = _gmtPatternPrefix.length();\r\n        if (len > 0 && !text.regionMatches(true, idx, _gmtPatternPrefix, 0, len)) {\r\n            break;\r\n        }\r\n        idx += len;\r\n        int[] offsetLen = new int[1];\r\n        offset = parseOffsetFields(text, idx, false, offsetLen);\r\n        if (offsetLen[0] == 0) {\r\n            break;\r\n        }\r\n        idx += offsetLen[0];\r\n        len = _gmtPatternSuffix.length();\r\n        if (len > 0 && !text.regionMatches(true, idx, _gmtPatternSuffix, 0, len)) {\r\n            break;\r\n        }\r\n        idx += len;\r\n        parsed = true;\r\n    } while (false);\r\n    parsedLen[0] = parsed ? idx - start : 0;\r\n    return offset;\r\n}"
}, {
	"Path": "java.io.File.setReadable",
	"Comment": "manipulates the read permissions for the abstract path designated by thisfile.",
	"Method": "boolean setReadable(boolean readable,boolean ownerOnly,boolean setReadable,boolean readable){\r\n    return setReadable(readable, true);\r\n}"
}, {
	"Path": "android.icu.util.DateTimeRule.toString",
	"Comment": "returns a string representation of this datetimerule object.this method is used for debugging purpose only.the string representation can be changedin future version of icu without any notice.",
	"Method": "String toString(){\r\n    String sDate = null;\r\n    String sTimeRuleType = null;\r\n    switch(dateRuleType) {\r\n        case DOM:\r\n            sDate = Integer.toString(dayOfMonth);\r\n            break;\r\n        case DOW:\r\n            sDate = Integer.toString(weekInMonth) + DOWSTR[dayOfWeek];\r\n            break;\r\n        case DOW_GEQ_DOM:\r\n            sDate = DOWSTR[dayOfWeek] + \">=\" + Integer.toString(dayOfMonth);\r\n            break;\r\n        case DOW_LEQ_DOM:\r\n            sDate = DOWSTR[dayOfWeek] + \"<=\" + Integer.toString(dayOfMonth);\r\n            break;\r\n    }\r\n    switch(timeRuleType) {\r\n        case WALL_TIME:\r\n            sTimeRuleType = \"WALL\";\r\n            break;\r\n        case STANDARD_TIME:\r\n            sTimeRuleType = \"STD\";\r\n            break;\r\n        case UTC_TIME:\r\n            sTimeRuleType = \"UTC\";\r\n            break;\r\n    }\r\n    int time = millisInDay;\r\n    int millis = time % 1000;\r\n    time /= 1000;\r\n    int secs = time % 60;\r\n    time /= 60;\r\n    int mins = time % 60;\r\n    int hours = time / 60;\r\n    StringBuilder buf = new StringBuilder();\r\n    buf.append(\"month=\");\r\n    buf.append(MONSTR[month]);\r\n    buf.append(\", date=\");\r\n    buf.append(sDate);\r\n    buf.append(\", time=\");\r\n    buf.append(hours);\r\n    buf.append(\":\");\r\n    buf.append(mins / 10);\r\n    buf.append(mins % 10);\r\n    buf.append(\":\");\r\n    buf.append(secs / 10);\r\n    buf.append(secs % 10);\r\n    buf.append(\".\");\r\n    buf.append(millis / 100);\r\n    buf.append((millis / 10) % 10);\r\n    buf.append(millis % 10);\r\n    buf.append(\"(\");\r\n    buf.append(sTimeRuleType);\r\n    buf.append(\")\");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "android.icu.text.BreakIterator.clone",
	"Comment": "clone method.creates another breakiterator with the same behavior andcurrent state as this one.",
	"Method": "Object clone(){\r\n    try {\r\n        return super.clone();\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new ICUCloneNotSupportedException(e);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.isSyntaxChar",
	"Comment": "tell if a character can be used to define a field in a format string.",
	"Method": "boolean isSyntaxChar(char ch){\r\n    return ch < PATTERN_CHAR_IS_SYNTAX.length ? PATTERN_CHAR_IS_SYNTAX[ch & 0xff] : false;\r\n}"
}, {
	"Path": "libcore.net.url.JarHandler.openConnection",
	"Comment": "returns a connection to the jar file pointed by this urlin the file system",
	"Method": "URLConnection openConnection(URL u){\r\n    return new JarURLConnectionImpl(u);\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.getMinusSign",
	"Comment": "returns the character used to represent minus sign. if no explicitnegative format is specified, one is formed by prefixingminussign to the positive format.",
	"Method": "char getMinusSign(){\r\n    return minusSign;\r\n}"
}, {
	"Path": "android.icu.impl.ValidIdentifiers.isValid",
	"Comment": "returns the datasubtype containing the code, or null if there is none.",
	"Method": "Datasubtype isValid(Datatype datatype,Set<Datasubtype> datasubtypes,String code,Datasubtype isValid,Datatype datatype,Set<Datasubtype> datasubtypes,String code,String value){\r\n    Map<Datasubtype, ValiditySet> subtable = ValidityData.data.get(datatype);\r\n    if (subtable != null) {\r\n        code = AsciiUtil.toLowerString(code);\r\n        value = AsciiUtil.toLowerString(value);\r\n        for (Datasubtype datasubtype : datasubtypes) {\r\n            ValiditySet validitySet = subtable.get(datasubtype);\r\n            if (validitySet != null) {\r\n                if (validitySet.contains(code, value)) {\r\n                    return datasubtype;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "libcore.java.io.OldPushbackInputStreamTest.tearDown",
	"Comment": "tears down the fixture, for example, close a network connection. thismethod is called after a test is executed.",
	"Method": "void tearDown(){\r\n    try {\r\n        pis.close();\r\n    } catch (IOException e) {\r\n        fail(\"IOException during tearDown : \" + e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.close",
	"Comment": "closes this stream. any buffered data is flushed. this implementationcloses the target stream.",
	"Method": "void close(){\r\n    flush();\r\n    output.close();\r\n}"
}, {
	"Path": "android.icu.impl.coll.CollationRootElements.firstCEWithPrimaryAtLeast",
	"Comment": "returns the first root ce with a primary weight of at least p.intended only for reordering group boundaries.",
	"Method": "long firstCEWithPrimaryAtLeast(long p){\r\n    if (p == 0) {\r\n        return 0;\r\n    }\r\n    int index = findP(p);\r\n    if (p != (elements[index] & 0xffffff00L)) {\r\n        for (; ; ) {\r\n            p = elements[++index];\r\n            if ((p & SEC_TER_DELTA_FLAG) == 0) {\r\n                assert ((p & PRIMARY_STEP_MASK) == 0);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return (p << 32) | Collation.COMMON_SEC_AND_TER_CE;\r\n}"
}, {
	"Path": "android.icu.impl.ICUDataVersion.getDataVersion",
	"Comment": "this function retrieves the data version from icuver and returns a versioninfo object with that version information.",
	"Method": "VersionInfo getDataVersion(){\r\n    UResourceBundle icudatares = null;\r\n    try {\r\n        icudatares = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, ICUDataVersion.U_ICU_VERSION_BUNDLE, ICUResourceBundle.ICU_DATA_CLASS_LOADER);\r\n        icudatares = icudatares.get(ICUDataVersion.U_ICU_DATA_KEY);\r\n    } catch (MissingResourceException ex) {\r\n        return null;\r\n    }\r\n    return VersionInfo.getInstance(icudatares.getString());\r\n}"
}, {
	"Path": "java.text.Collator.equals",
	"Comment": "compares two strings using the collation rules to determine if they areequal.",
	"Method": "boolean equals(String string1,String string2){\r\n    return compare(string1, string2) == 0;\r\n}"
}, {
	"Path": "android.icu.text.MessageFormat.setFormatByArgumentIndex",
	"Comment": "sets the format object to use for the format elements within thepreviously set pattern string that use the given argumentindex.the argument index is part of the format element definition andrepresents an index into the arguments array passedto the format methods or the result array returnedby the parse methods.if the argument index is used for more than one format elementin the pattern string, then the new format is used for all suchformat elements. if the argument index is not used for any formatelement in the pattern string, then the new format is ignored.this method is only supported when exclusively numbers are used forargument names. otherwise an illegalargumentexception is thrown.",
	"Method": "void setFormatByArgumentIndex(int argumentIndex,Format newFormat){\r\n    if (msgPattern.hasNamedArguments()) {\r\n        throw new IllegalArgumentException(\"This method is not available in MessageFormat objects \" + \"that use alphanumeric argument names.\");\r\n    }\r\n    for (int partIndex = 0; (partIndex = nextTopLevelArgStart(partIndex)) >= 0; ) {\r\n        if (msgPattern.getPart(partIndex + 1).getValue() == argumentIndex) {\r\n            setCustomArgStartFormat(partIndex, newFormat);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.reset",
	"Comment": "reset the service to the default factories.the factorylock is acquired and then reinitializefactories is called.",
	"Method": "void reset(){\r\n    try {\r\n        factoryLock.acquireWrite();\r\n        reInitializeFactories();\r\n        clearCaches();\r\n    } finally {\r\n        factoryLock.releaseWrite();\r\n    }\r\n    notifyChanged();\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.setDecimalFormatSymbols",
	"Comment": "sets the decimal format symbols used by this format. the format uses a copy of theprovided symbols.",
	"Method": "void setDecimalFormatSymbols(DecimalFormatSymbols newSymbols){\r\n    symbols = (DecimalFormatSymbols) newSymbols.clone();\r\n    setCurrencyForSymbols();\r\n    expandAffixes(null);\r\n}"
}, {
	"Path": "android.icu.util.VTimeZone.load",
	"Comment": "read the input stream to locate the vtimezone block andparse the contents to initialize this vtimezone object.the reader skips other rfc2445 message headers.afterthe parse is completed, the reader points at the beginningof the header field just after the end of vtimezone block.when vtimezone block is found and this object is successfullyinitialized by the rules described in the data, this methodreturns true.otherwise, returns false.",
	"Method": "boolean load(Reader reader){\r\n    try {\r\n        vtzlines = new LinkedList<String>();\r\n        boolean eol = false;\r\n        boolean start = false;\r\n        boolean success = false;\r\n        StringBuilder line = new StringBuilder();\r\n        while (true) {\r\n            int ch = reader.read();\r\n            if (ch == -1) {\r\n                if (start && line.toString().startsWith(ICAL_END_VTIMEZONE)) {\r\n                    vtzlines.add(line.toString());\r\n                    success = true;\r\n                }\r\n                break;\r\n            }\r\n            if (ch == 0x0D) {\r\n                continue;\r\n            }\r\n            if (eol) {\r\n                if (ch != 0x09 && ch != 0x20) {\r\n                    if (start) {\r\n                        if (line.length() > 0) {\r\n                            vtzlines.add(line.toString());\r\n                        }\r\n                    }\r\n                    line.setLength(0);\r\n                    if (ch != 0x0A) {\r\n                        line.append((char) ch);\r\n                    }\r\n                }\r\n                eol = false;\r\n            } else {\r\n                if (ch == 0x0A) {\r\n                    eol = true;\r\n                    if (start) {\r\n                        if (line.toString().startsWith(ICAL_END_VTIMEZONE)) {\r\n                            vtzlines.add(line.toString());\r\n                            success = true;\r\n                            break;\r\n                        }\r\n                    } else {\r\n                        if (line.toString().startsWith(ICAL_BEGIN_VTIMEZONE)) {\r\n                            vtzlines.add(line.toString());\r\n                            line.setLength(0);\r\n                            start = true;\r\n                            eol = false;\r\n                        }\r\n                    }\r\n                } else {\r\n                    line.append((char) ch);\r\n                }\r\n            }\r\n        }\r\n        if (!success) {\r\n            return false;\r\n        }\r\n    } catch (IOException ioe) {\r\n        return false;\r\n    }\r\n    return parse();\r\n}"
}, {
	"Path": "libcore.java.io.FileTest.test_subclassing",
	"Comment": "isabsolute from the file constructor, potentially breaking subclasses.",
	"Method": "void test_subclassing(){\r\n    class MyFile extends File {\r\n        private String field;\r\n        MyFile(String s) {\r\n            super(s);\r\n            field = \"\";\r\n        }\r\n        @Override\r\n        public boolean isAbsolute() {\r\n            field.length();\r\n            return super.isAbsolute();\r\n        }\r\n    }\r\n    new MyFile(\"\");\r\n}"
}, {
	"Path": "libcore.java.io.FileTest.test_subclassing",
	"Comment": "isabsolute from the file constructor, potentially breaking subclasses.",
	"Method": "void test_subclassing(){\r\n    field.length();\r\n    return super.isAbsolute();\r\n}"
}, {
	"Path": "android.icu.text.CollationElementIterator.equals",
	"Comment": "tests that argument object is equals to this collationelementiterator.iterators are equal if the objects uses the same rulebasedcollator,the same source text and have the same current position in iteration.",
	"Method": "boolean equals(Object that){\r\n    if (that == this) {\r\n        return true;\r\n    }\r\n    if (that instanceof CollationElementIterator) {\r\n        CollationElementIterator thatceiter = (CollationElementIterator) that;\r\n        return rbc_.equals(thatceiter.rbc_) && otherHalf_ == thatceiter.otherHalf_ && normalizeDir() == thatceiter.normalizeDir() && string_.equals(thatceiter.string_) && iter_.equals(thatceiter.iter_);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "android.icu.util.Calendar.getInstanceInternal",
	"Comment": "all getinstance implementations call this private method to create a newcalendar instance.",
	"Method": "Calendar getInstanceInternal(TimeZone tz,ULocale locale){\r\n    if (locale == null) {\r\n        locale = ULocale.getDefault(Category.FORMAT);\r\n    }\r\n    if (tz == null) {\r\n        tz = TimeZone.getDefault();\r\n    }\r\n    Calendar cal = createInstance(locale);\r\n    cal.setTimeZone(tz);\r\n    cal.setTimeInMillis(System.currentTimeMillis());\r\n    return cal;\r\n}"
}, {
	"Path": "android.icu.impl.UCharArrayIterator.clone",
	"Comment": "creates a copy of this iterator, does not clone the underlyingreplaceableobject",
	"Method": "Object clone(){\r\n    try {\r\n        return super.clone();\r\n    } catch (CloneNotSupportedException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.SimpleTimeZone.setDSTSavings",
	"Comment": "sets the amount of time in ms that the clock is advanced during dst.",
	"Method": "void setDSTSavings(int millisSavedDuringDST){\r\n    if (isFrozen()) {\r\n        throw new UnsupportedOperationException(\"Attempt to modify a frozen SimpleTimeZone instance.\");\r\n    }\r\n    if (millisSavedDuringDST <= 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    dst = millisSavedDuringDST;\r\n    transitionRulesInitialized = false;\r\n}"
}, {
	"Path": "android.icu.impl.LocaleIDParser.getKeywords",
	"Comment": "returns an iterator over the keywords, or null if we have an empty map.",
	"Method": "Iterator<String> getKeywords(){\r\n    Map<String, String> m = getKeywordMap();\r\n    return m.isEmpty() ? null : m.keySet().iterator();\r\n}"
}, {
	"Path": "android.icu.text.TimeZoneFormat.getDefaultParseOptions",
	"Comment": "returns the default parse options used by this timezoneformat instance.",
	"Method": "EnumSet<ParseOption> getDefaultParseOptions(){\r\n    if (_parseAllStyles && _parseTZDBNames) {\r\n        return EnumSet.of(ParseOption.ALL_STYLES, ParseOption.TZ_DATABASE_ABBREVIATIONS);\r\n    } else if (_parseAllStyles) {\r\n        return EnumSet.of(ParseOption.ALL_STYLES);\r\n    } else if (_parseTZDBNames) {\r\n        return EnumSet.of(ParseOption.TZ_DATABASE_ABBREVIATIONS);\r\n    }\r\n    return EnumSet.noneOf(ParseOption.class);\r\n}"
}, {
	"Path": "android.icu.util.GlobalizationPreferences.guessTerritory",
	"Comment": "this function can be overridden by subclasses to use different heuristics.",
	"Method": "String guessTerritory(){\r\n    String result;\r\n    for (ULocale locale : getLocales()) {\r\n        result = locale.getCountry();\r\n        if (result.length() != 0) {\r\n            return result;\r\n        }\r\n    }\r\n    ULocale firstLocale = getLocale(0);\r\n    String language = firstLocale.getLanguage();\r\n    String script = firstLocale.getScript();\r\n    result = null;\r\n    if (script.length() != 0) {\r\n        result = language_territory_hack_map.get(language + \"_\" + script);\r\n    }\r\n    if (result == null) {\r\n        result = language_territory_hack_map.get(language);\r\n    }\r\n    if (result == null) {\r\n        result = \"US\";\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.impl.UCharacterName.addExtendedName",
	"Comment": "adds all extended names into the name set.equivalent to part of calcextnamesetslengths.",
	"Method": "int addExtendedName(int maxlength){\r\n    for (int i = TYPE_NAMES_.length - 1; i >= 0; i--) {\r\n        int length = 9 + add(m_nameSet_, TYPE_NAMES_[i]);\r\n        if (length > maxlength) {\r\n            maxlength = length;\r\n        }\r\n    }\r\n    return maxlength;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.setPatternSeparator",
	"Comment": "sets the character used to separate positive and negative subpatternsin a pattern.",
	"Method": "void setPatternSeparator(char patternSeparator){\r\n    this.patternSeparator = patternSeparator;\r\n}"
}, {
	"Path": "android.icu.util.RangeDateRule.isBetween",
	"Comment": "check whether this event occurs at least once between the twodates given.",
	"Method": "boolean isBetween(Date start,Date end){\r\n    return firstBetween(start, end) == null;\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.getDefaultXSymbolTable",
	"Comment": "get the default symbol table. null means ordinary processing. for internal use only.",
	"Method": "XSymbolTable getDefaultXSymbolTable(){\r\n    return XSYMBOL_TABLE;\r\n}"
}, {
	"Path": "android.icu.text.Normalizer.quickCheck",
	"Comment": "performing quick check on a string, to quickly determine if the string isin a particular normalization format.three types of result can be returned normalizer.yes, normalizer.no ornormalizer.maybe. result normalizer.yes indicates that the argumentstring is in the desired normalized format, normalizer.no determines thatargument string is not in the desired normalized format. anormalizer.maybe result indicates that a more thorough check is required,the user may have to put the string in its normalized form and comparethe results.",
	"Method": "QuickCheckResult quickCheck(String source,Mode mode,QuickCheckResult quickCheck,String source,Mode mode,int options,QuickCheckResult quickCheck,char[] source,Mode mode,int options,QuickCheckResult quickCheck,char[] source,int start,int limit,Mode mode,int options){\r\n    CharBuffer srcBuffer = CharBuffer.wrap(source, start, limit - start);\r\n    return mode.getNormalizer2(options).quickCheck(srcBuffer);\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.CompatibilityTest.TestDisambiguation765",
	"Comment": "test the correct behavior of the disambiguation algorithm.",
	"Method": "void TestDisambiguation765(){\r\n    Calendar c = Calendar.getInstance();\r\n    c.setLenient(false);\r\n    c.clear();\r\n    c.set(Calendar.YEAR, 1997);\r\n    c.set(Calendar.MONTH, Calendar.JUNE);\r\n    c.set(Calendar.DATE, 3);\r\n    verify765(\"1997 third day of June = \", c, 1997, Calendar.JUNE, 3);\r\n    c.clear();\r\n    c.set(Calendar.YEAR, 1997);\r\n    c.set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY);\r\n    c.set(Calendar.MONTH, Calendar.JUNE);\r\n    c.set(Calendar.DAY_OF_WEEK_IN_MONTH, 1);\r\n    verify765(\"1997 first Tuesday in June = \", c, 1997, Calendar.JUNE, 3);\r\n    c.clear();\r\n    c.set(Calendar.YEAR, 1997);\r\n    c.set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY);\r\n    c.set(Calendar.MONTH, Calendar.JUNE);\r\n    c.set(Calendar.DAY_OF_WEEK_IN_MONTH, -1);\r\n    verify765(\"1997 last Tuesday in June = \", c, 1997, Calendar.JUNE, 24);\r\n    IllegalArgumentException e = null;\r\n    try {\r\n        c.clear();\r\n        c.set(Calendar.YEAR, 1997);\r\n        c.set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY);\r\n        c.set(Calendar.MONTH, Calendar.JUNE);\r\n        c.set(Calendar.DAY_OF_WEEK_IN_MONTH, 0);\r\n        c.getTime();\r\n    } catch (IllegalArgumentException ex) {\r\n        e = ex;\r\n    }\r\n    verify765(\"1997 zero-th Tuesday in June = \", e, c);\r\n    c.clear();\r\n    c.set(Calendar.YEAR, 1997);\r\n    c.set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY);\r\n    c.set(Calendar.MONTH, Calendar.JUNE);\r\n    c.set(Calendar.WEEK_OF_MONTH, 1);\r\n    verify765(\"1997 Tuesday in week 1 of June = \", c, 1997, Calendar.JUNE, 3);\r\n    c.clear();\r\n    c.set(Calendar.YEAR, 1997);\r\n    c.set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY);\r\n    c.set(Calendar.MONTH, Calendar.JUNE);\r\n    c.set(Calendar.WEEK_OF_MONTH, 5);\r\n    verify765(\"1997 Tuesday in week 5 of June = \", c, 1997, Calendar.JULY, 1);\r\n    try {\r\n        c.clear();\r\n        c.set(Calendar.YEAR, 1997);\r\n        c.set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY);\r\n        c.set(Calendar.MONTH, Calendar.JUNE);\r\n        c.set(Calendar.WEEK_OF_MONTH, 0);\r\n        c.getTime();\r\n    } catch (IllegalArgumentException ex) {\r\n        e = ex;\r\n    }\r\n    verify765(\"1997 Tuesday in week 0 of June = \", e, c);\r\n    c.clear();\r\n    c.set(Calendar.YEAR, 1997);\r\n    c.set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY);\r\n    c.set(Calendar.WEEK_OF_YEAR, 1);\r\n    verify765(\"1997 Tuesday in week 1 of year = \", c, 1996, Calendar.DECEMBER, 31);\r\n    c.clear();\r\n    c.set(Calendar.YEAR, 1997);\r\n    c.set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY);\r\n    c.set(Calendar.WEEK_OF_YEAR, 10);\r\n    verify765(\"1997 Tuesday in week 10 of year = \", c, 1997, Calendar.MARCH, 4);\r\n    e = null;\r\n    try {\r\n        c.clear();\r\n        c.set(Calendar.YEAR, 1997);\r\n        c.set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY);\r\n        c.set(Calendar.WEEK_OF_YEAR, 0);\r\n        c.getTime();\r\n    } catch (IllegalArgumentException ex) {\r\n        e = ex;\r\n    }\r\n    verify765(\"1997 Tuesday in week 0 of year = \", e, c);\r\n}"
}, {
	"Path": "android.icu.impl.LocaleIDParser.parseLanguage",
	"Comment": "advance index past language, and accumulate normalized language code in buffer.index must be at 0 when this is called.index is left at a terminator or idseparator.returns the start of the language code in the buffer.",
	"Method": "int parseLanguage(){\r\n    int startLength = buffer.length();\r\n    if (haveExperimentalLanguagePrefix()) {\r\n        append(AsciiUtil.toLower(id[0]));\r\n        append(HYPHEN);\r\n        index = 2;\r\n    }\r\n    char c;\r\n    while (!isTerminatorOrIDSeparator(c = next())) {\r\n        append(AsciiUtil.toLower(c));\r\n    }\r\n    --index;\r\n    if (buffer.length() - startLength == 3) {\r\n        String lang = LocaleIDs.threeToTwoLetterLanguage(getString(0));\r\n        if (lang != null) {\r\n            set(0, lang);\r\n        }\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "android.icu.lang.UCharacter.isJavaIdentifierStart",
	"Comment": "compatibility override of java method, delegates tojava.lang.character.isjavaidentifierstart.",
	"Method": "boolean isJavaIdentifierStart(int cp){\r\n    return java.lang.Character.isJavaIdentifierStart((char) cp);\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.getEquivalentDecimals",
	"Comment": "returns a set of characters equivalent to the given desimal separator used forparsing number.this method may return an empty set.",
	"Method": "UnicodeSet getEquivalentDecimals(String decimal,boolean strictParse){\r\n    UnicodeSet equivSet = UnicodeSet.EMPTY;\r\n    if (strictParse) {\r\n        if (strictDotEquivalents.contains(decimal)) {\r\n            equivSet = strictDotEquivalents;\r\n        } else if (strictCommaEquivalents.contains(decimal)) {\r\n            equivSet = strictCommaEquivalents;\r\n        }\r\n    } else {\r\n        if (dotEquivalents.contains(decimal)) {\r\n            equivSet = dotEquivalents;\r\n        } else if (commaEquivalents.contains(decimal)) {\r\n            equivSet = commaEquivalents;\r\n        }\r\n    }\r\n    return equivSet;\r\n}"
}, {
	"Path": "android.icu.util.DateTimeRule.getRuleWeekInMonth",
	"Comment": "gets the rule day of week ordinal number in the month.when the date rule type is not dow, the value isalways 0.",
	"Method": "int getRuleWeekInMonth(){\r\n    return weekInMonth;\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationMiscTest.TestNumericCollation",
	"Comment": "test for collationelementiterator previous and next for the whole set ofunicode characters with normalization on.",
	"Method": "void TestNumericCollation(){\r\n    String[] basicTestStrings = { \"hello1\", \"hello2\", \"hello123456\" };\r\n    String[] preZeroTestStrings = { \"avery1\", \"avery01\", \"avery001\", \"avery0001\" };\r\n    String[] thirtyTwoBitNumericStrings = { \"avery42949672960\", \"avery42949672961\", \"avery42949672962\", \"avery429496729610\" };\r\n    String[] supplementaryDigits = { \"?\", \"?\", \"?\", \"?\", \"??\", \"??\", \"??\", \"??\", \"??\", \"??\" };\r\n    String[] foreignDigits = { \"?\", \"?\", \"?\", \"??\", \"??\", \"??\", \"??\", \"??\", \"??\", \"??\", \"??\", \"??\" };\r\n    String[] lastDigitDifferent = { \"2004\", \"2005\", \"110005\", \"110006\", \"11005\", \"11006\", \"100000000005\", \"100000000006\" };\r\n    RuleBasedCollator coll = (RuleBasedCollator) Collator.getInstance(Locale.ENGLISH);\r\n    String[] att = { \"NumericCollation\" };\r\n    Boolean[] val = { Boolean.TRUE };\r\n    genericLocaleStarterWithOptions(Locale.ENGLISH, basicTestStrings, att, val);\r\n    genericLocaleStarterWithOptions(Locale.ENGLISH, thirtyTwoBitNumericStrings, att, val);\r\n    genericLocaleStarterWithOptions(Locale.ENGLISH, foreignDigits, att, val);\r\n    genericLocaleStarterWithOptions(Locale.ENGLISH, supplementaryDigits, att, val);\r\n    coll.setNumericCollation(true);\r\n    for (int i = 0; i < preZeroTestStrings.length - 1; i++) {\r\n        for (int j = i + 1; j < preZeroTestStrings.length; j++) {\r\n            CollationTest.doTest(this, coll, preZeroTestStrings[i], preZeroTestStrings[j], 0);\r\n        }\r\n    }\r\n    for (int i = 0; i < lastDigitDifferent.length - 1; i = i + 2) {\r\n        CollationTest.doTest(this, coll, lastDigitDifferent[i], lastDigitDifferent[i + 1], -1);\r\n    }\r\n    assertTrue(\"The Numeric Collation setting is on\", coll.getNumericCollation());\r\n    coll.setNumericCollationDefault();\r\n    logln(\"After set Numeric to default, the setting is: \" + coll.getNumericCollation());\r\n}"
}, {
	"Path": "android.icu.util.IllformedLocaleException.getErrorIndex",
	"Comment": "returns the index where the error was found. a negative value indicateseither the error index is not applicable or unknown.",
	"Method": "int getErrorIndex(){\r\n    return _errIdx;\r\n}"
}, {
	"Path": "android.icu.text.PluralRules.getKeywordStatus",
	"Comment": "find the status for the keyword, given a certain set of explicit values.",
	"Method": "KeywordStatus getKeywordStatus(String keyword,int offset,Set<Double> explicits,Output<Double> uniqueValue,KeywordStatus getKeywordStatus,String keyword,int offset,Set<Double> explicits,Output<Double> uniqueValue,SampleType sampleType){\r\n    if (uniqueValue != null) {\r\n        uniqueValue.value = null;\r\n    }\r\n    if (!keywords.contains(keyword)) {\r\n        return KeywordStatus.INVALID;\r\n    }\r\n    if (!isLimited(keyword, sampleType)) {\r\n        return KeywordStatus.UNBOUNDED;\r\n    }\r\n    Collection<Double> values = getSamples(keyword, sampleType);\r\n    int originalSize = values.size();\r\n    if (explicits == null) {\r\n        explicits = Collections.emptySet();\r\n    }\r\n    if (originalSize > explicits.size()) {\r\n        if (originalSize == 1) {\r\n            if (uniqueValue != null) {\r\n                uniqueValue.value = values.iterator().next();\r\n            }\r\n            return KeywordStatus.UNIQUE;\r\n        }\r\n        return KeywordStatus.BOUNDED;\r\n    }\r\n    HashSet<Double> subtractedSet = new HashSet<Double>(values);\r\n    for (Double explicit : explicits) {\r\n        subtractedSet.remove(explicit - offset);\r\n    }\r\n    if (subtractedSet.size() == 0) {\r\n        return KeywordStatus.SUPPRESSED;\r\n    }\r\n    if (uniqueValue != null && subtractedSet.size() == 1) {\r\n        uniqueValue.value = subtractedSet.iterator().next();\r\n    }\r\n    return originalSize == 1 ? KeywordStatus.UNIQUE : KeywordStatus.BOUNDED;\r\n}"
}, {
	"Path": "android.icu.util.ByteArrayWrapper.releaseBytes",
	"Comment": "releases the internal byte array to the caller, resets the internalbyte array to null and its size to 0.",
	"Method": "byte[] releaseBytes(){\r\n    byte[] result = bytes;\r\n    bytes = null;\r\n    size = 0;\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.impl.coll.CollationRootElements.getPrimaryBefore",
	"Comment": "returns the primary weight before p.p must be greater than the first root primary.",
	"Method": "long getPrimaryBefore(long p,boolean isCompressible){\r\n    int index = findPrimary(p);\r\n    int step;\r\n    long q = elements[index];\r\n    if (p == (q & 0xffffff00L)) {\r\n        step = (int) q & PRIMARY_STEP_MASK;\r\n        if (step == 0) {\r\n            do {\r\n                p = elements[--index];\r\n            } while ((p & SEC_TER_DELTA_FLAG) != 0);\r\n            return p & 0xffffff00L;\r\n        }\r\n    } else {\r\n        long nextElement = elements[index + 1];\r\n        assert (isEndOfPrimaryRange(nextElement));\r\n        step = (int) nextElement & PRIMARY_STEP_MASK;\r\n    }\r\n    if ((p & 0xffff) == 0) {\r\n        return Collation.decTwoBytePrimaryByOneStep(p, isCompressible, step);\r\n    } else {\r\n        return Collation.decThreeBytePrimaryByOneStep(p, isCompressible, step);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.getDigits",
	"Comment": "returns the array of characters used as digits, in order from 0 through 9",
	"Method": "char[] getDigits(){\r\n    return digits.clone();\r\n}"
}, {
	"Path": "android.icu.util.BytesTrie.readValue",
	"Comment": "pos is already after the leadbyte, and the lead byte is already shifted right by 1.",
	"Method": "int readValue(byte[] bytes,int pos,int leadByte){\r\n    int value;\r\n    if (leadByte < kMinTwoByteValueLead) {\r\n        value = leadByte - kMinOneByteValueLead;\r\n    } else if (leadByte < kMinThreeByteValueLead) {\r\n        value = ((leadByte - kMinTwoByteValueLead) << 8) | (bytes[pos] & 0xff);\r\n    } else if (leadByte < kFourByteValueLead) {\r\n        value = ((leadByte - kMinThreeByteValueLead) << 16) | ((bytes[pos] & 0xff) << 8) | (bytes[pos + 1] & 0xff);\r\n    } else if (leadByte == kFourByteValueLead) {\r\n        value = ((bytes[pos] & 0xff) << 16) | ((bytes[pos + 1] & 0xff) << 8) | (bytes[pos + 2] & 0xff);\r\n    } else {\r\n        value = (bytes[pos] << 24) | ((bytes[pos + 1] & 0xff) << 16) | ((bytes[pos + 2] & 0xff) << 8) | (bytes[pos + 3] & 0xff);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "android.icu.impl.duration.BasicDurationFormatterFactory.setTimeZone",
	"Comment": "set the name of the locale that will be used whencreating new formatters.",
	"Method": "DurationFormatterFactory setTimeZone(TimeZone timeZone){\r\n    if (!timeZone.equals(this.timeZone)) {\r\n        this.timeZone = timeZone;\r\n        if (builder != null) {\r\n            builder = builder.withTimeZone(timeZone);\r\n        }\r\n        reset();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedNumberFormat.getRuleSetDisplayName",
	"Comment": "return the rule set display name for the provided rule set in the current default display locale.",
	"Method": "String getRuleSetDisplayName(String ruleSetName,ULocale loc,String getRuleSetDisplayName,String ruleSetName){\r\n    return getRuleSetDisplayName(ruleSetName, ULocale.getDefault(Category.DISPLAY));\r\n}"
}, {
	"Path": "android.icu.text.UnicodeCompressor.findDynamicWindow",
	"Comment": "determine if a dynamic window for a certain character is defined",
	"Method": "int findDynamicWindow(int c){\r\n    for (int i = NUMWINDOWS - 1; i >= 0; --i) {\r\n        if (inDynamicWindow(c, i)) {\r\n            ++fTimeStamps[i];\r\n            return i;\r\n        }\r\n    }\r\n    return INVALIDWINDOW;\r\n}"
}, {
	"Path": "android.icu.impl.ICURWLock.releaseRead",
	"Comment": "release a read lock and return.an error will be thrownif a read lock is not currently held.if this is the last active reader, notify the oldestwaiting writer.call when finished with workcontrolled by acquireread.",
	"Method": "void releaseRead(){\r\n    rwl.readLock().unlock();\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneNamesImpl.readObject",
	"Comment": "the custom deserialization method.this implementation only read locale object used by the object.",
	"Method": "void readObject(ObjectInputStream in){\r\n    ULocale locale = (ULocale) in.readObject();\r\n    initialize(locale);\r\n}"
}, {
	"Path": "android.icu.text.DateFormatSymbols.hashCode",
	"Comment": "override hashcode.generates a hash code for the dateformatsymbols object.",
	"Method": "int hashCode(){\r\n    return requestedLocale.toString().hashCode();\r\n}"
}, {
	"Path": "android.icu.impl.UCharacterIteratorWrapper.getEndIndex",
	"Comment": "returns the end index of the text.this index is the index of the firstcharacter following the end of the text.",
	"Method": "int getEndIndex(){\r\n    return iterator.getLength();\r\n}"
}, {
	"Path": "java.io.File.join",
	"Comment": "joins two path components, adding a separator only if necessary.",
	"Method": "String join(String prefix,String suffix){\r\n    int prefixLength = prefix.length();\r\n    boolean haveSlash = (prefixLength > 0 && prefix.charAt(prefixLength - 1) == separatorChar);\r\n    if (!haveSlash) {\r\n        haveSlash = (suffix.length() > 0 && suffix.charAt(0) == separatorChar);\r\n    }\r\n    return haveSlash ? (prefix + suffix) : (prefix + separatorChar + suffix);\r\n}"
}, {
	"Path": "android.icu.text.Normalizer.compose",
	"Comment": "compose a string.the string will be composed to according to the specified mode.",
	"Method": "String compose(String str,boolean compat,String compose,String str,boolean compat,int options,int compose,char[] source,char[] target,boolean compat,int options,int compose,char[] src,int srcStart,int srcLimit,char[] dest,int destStart,int destLimit,boolean compat,int options){\r\n    CharBuffer srcBuffer = CharBuffer.wrap(src, srcStart, srcLimit - srcStart);\r\n    CharsAppendable app = new CharsAppendable(dest, destStart, destLimit);\r\n    getComposeNormalizer2(compat, options).normalize(srcBuffer, app);\r\n    return app.length();\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedNumberFormat.getLenientScanner",
	"Comment": "returns the scanner to use for lenient parsing.the scanner isprovided by the provider.",
	"Method": "RbnfLenientScanner getLenientScanner(){\r\n    if (lenientParse) {\r\n        RbnfLenientScannerProvider provider = getLenientScannerProvider();\r\n        if (provider != null) {\r\n            return provider.get(locale, lenientParseRules);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.text.DigitList.wasRounded",
	"Comment": "indicates if last digit set was rounded or not.true indicates it was rounded.false indicates rounding has not been done.",
	"Method": "boolean wasRounded(){\r\n    return didRound;\r\n}"
}, {
	"Path": "android.icu.impl.coll.CollationRuleParser.getReorderCode",
	"Comment": "gets a script or reorder code from its string representation.",
	"Method": "int getReorderCode(String word){\r\n    for (int i = 0; i < gSpecialReorderCodes.length; ++i) {\r\n        if (word.equalsIgnoreCase(gSpecialReorderCodes[i])) {\r\n            return Collator.ReorderCodes.FIRST + i;\r\n        }\r\n    }\r\n    try {\r\n        int script = UCharacter.getPropertyValueEnum(UProperty.SCRIPT, word);\r\n        if (script >= 0) {\r\n            return script;\r\n        }\r\n    } catch (IllegalIcuArgumentException e) {\r\n    }\r\n    if (word.equalsIgnoreCase(\"others\")) {\r\n        return Collator.ReorderCodes.OTHERS;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedCollator.cloneAsThawed",
	"Comment": "provides for the clone operation. any clone is initially unfrozen.",
	"Method": "RuleBasedCollator cloneAsThawed(){\r\n    try {\r\n        RuleBasedCollator result = (RuleBasedCollator) super.clone();\r\n        result.settings = settings.clone();\r\n        result.collationBuffer = null;\r\n        result.frozenLock = null;\r\n        return result;\r\n    } catch (CloneNotSupportedException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.buildFieldDescriptors",
	"Comment": "builds the collection of field descriptors for the receiver",
	"Method": "void buildFieldDescriptors(Field[] declaredFields){\r\n    final Field f = ObjectStreamClass.fieldSerialPersistentFields(this.forClass());\r\n    boolean useReflectFields = f == null;\r\n    ObjectStreamField[] _fields = null;\r\n    if (!useReflectFields) {\r\n        f.setAccessible(true);\r\n        try {\r\n            _fields = (ObjectStreamField[]) f.get(null);\r\n        } catch (IllegalAccessException ex) {\r\n            throw new AssertionError(ex);\r\n        }\r\n    } else {\r\n        List<ObjectStreamField> serializableFields = new ArrayList<ObjectStreamField>(declaredFields.length);\r\n        for (Field declaredField : declaredFields) {\r\n            int modifiers = declaredField.getModifiers();\r\n            if (!Modifier.isStatic(modifiers) && !Modifier.isTransient(modifiers)) {\r\n                ObjectStreamField field = new ObjectStreamField(declaredField.getName(), declaredField.getType());\r\n                serializableFields.add(field);\r\n            }\r\n        }\r\n        if (serializableFields.size() == 0) {\r\n            _fields = NO_FIELDS;\r\n        } else {\r\n            _fields = serializableFields.toArray(new ObjectStreamField[serializableFields.size()]);\r\n        }\r\n    }\r\n    Arrays.sort(_fields);\r\n    int primOffset = 0, objectOffset = 0;\r\n    for (int i = 0; i < _fields.length; i++) {\r\n        Class<?> type = _fields[i].getType();\r\n        if (type.isPrimitive()) {\r\n            _fields[i].offset = primOffset;\r\n            primOffset += primitiveSize(type);\r\n        } else {\r\n            _fields[i].offset = objectOffset++;\r\n        }\r\n    }\r\n    fields = _fields;\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationMiscTest.TestBeforeRuleWithScriptReordering",
	"Comment": "this test ensures that characters placed before a character in a different script have the same lead bytein their collation key before and after script reordering.",
	"Method": "void TestBeforeRuleWithScriptReordering(){\r\n    String rules = \"&[before 1]�� < ?\";\r\n    int[] reorderCodes = { UScript.GREEK };\r\n    int result;\r\n    Collator myCollation = new RuleBasedCollator(rules);\r\n    myCollation.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\r\n    myCollation.setStrength(Collator.TERTIARY);\r\n    String base = \"��\";\r\n    String before = \"?\";\r\n    result = myCollation.compare(base, before);\r\n    if (!(result > 0)) {\r\n        errln(\"Collation result not correct before script reordering.\");\r\n    }\r\n    CollationKey baseKey = myCollation.getCollationKey(base);\r\n    CollationKey beforeKey = myCollation.getCollationKey(before);\r\n    byte[] baseKeyBytes = baseKey.toByteArray();\r\n    byte[] beforeKeyBytes = beforeKey.toByteArray();\r\n    if (baseKeyBytes[0] != beforeKeyBytes[0]) {\r\n        errln(\"Different lead byte for sort keys using before rule and before script reordering. base character lead byte = \" + baseKeyBytes[0] + \", before character lead byte = \" + beforeKeyBytes[0]);\r\n    }\r\n    myCollation.setReorderCodes(reorderCodes);\r\n    result = myCollation.compare(base, before);\r\n    if (!(result > 0)) {\r\n        errln(\"Collation result not correct after script reordering.\");\r\n    }\r\n    baseKey = myCollation.getCollationKey(base);\r\n    beforeKey = myCollation.getCollationKey(before);\r\n    baseKeyBytes = baseKey.toByteArray();\r\n    beforeKeyBytes = beforeKey.toByteArray();\r\n    if (baseKeyBytes[0] != beforeKeyBytes[0]) {\r\n        errln(\"Different lead byte for sort keys using before rule and before script reordering. base character lead byte = \" + baseKeyBytes[0] + \", before character lead byte = \" + beforeKeyBytes[0]);\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.LocaleData.getInstance",
	"Comment": "gets the localedata object associated with the default format locale",
	"Method": "LocaleData getInstance(ULocale locale,LocaleData getInstance){\r\n    return LocaleData.getInstance(ULocale.getDefault(Category.FORMAT));\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneGenericNames.getLocaleDisplayNames",
	"Comment": "private method returning localedisplaynames instance for the locale of thisinstance. because localedisplaynames is only used for genericlocation formant and partial location format, the localedisplaynamesis instantiated lazily.",
	"Method": "LocaleDisplayNames getLocaleDisplayNames(){\r\n    LocaleDisplayNames locNames = null;\r\n    if (_localeDisplayNamesRef != null) {\r\n        locNames = _localeDisplayNamesRef.get();\r\n    }\r\n    if (locNames == null) {\r\n        locNames = LocaleDisplayNames.getInstance(_locale);\r\n        _localeDisplayNamesRef = new WeakReference<LocaleDisplayNames>(locNames);\r\n    }\r\n    return locNames;\r\n}"
}, {
	"Path": "android.icu.text.UnicodeDecompressor.decompress",
	"Comment": "decompress a byte array into a unicode character array.this function will either completely fill the output buffer, or consume the entire input.",
	"Method": "String decompress(byte[] buffer,char[] decompress,byte[] buffer,int start,int limit,int decompress,byte[] byteBuffer,int byteBufferStart,int byteBufferLimit,int[] bytesRead,char[] charBuffer,int charBufferStart,int charBufferLimit){\r\n    int bytePos = byteBufferStart;\r\n    int ucPos = charBufferStart;\r\n    int aByte = 0x00;\r\n    if (charBuffer.length < 2 || (charBufferLimit - charBufferStart) < 2)\r\n        throw new IllegalArgumentException(\"charBuffer.length < 2\");\r\n    if (fBufferLength > 0) {\r\n        int newBytes = 0;\r\n        if (fBufferLength != BUFSIZE) {\r\n            newBytes = fBuffer.length - fBufferLength;\r\n            if (byteBufferLimit - byteBufferStart < newBytes)\r\n                newBytes = byteBufferLimit - byteBufferStart;\r\n            System.arraycopy(byteBuffer, byteBufferStart, fBuffer, fBufferLength, newBytes);\r\n        }\r\n        fBufferLength = 0;\r\n        int count = decompress(fBuffer, 0, fBuffer.length, null, charBuffer, charBufferStart, charBufferLimit);\r\n        ucPos += count;\r\n        bytePos += newBytes;\r\n    }\r\n    mainLoop: while (bytePos < byteBufferLimit && ucPos < charBufferLimit) {\r\n        switch(fMode) {\r\n            case SINGLEBYTEMODE:\r\n                singleByteModeLoop: while (bytePos < byteBufferLimit && ucPos < charBufferLimit) {\r\n                    aByte = byteBuffer[bytePos++] & 0xFF;\r\n                    switch(aByte) {\r\n                        case 0x80:\r\n                        case 0x81:\r\n                        case 0x82:\r\n                        case 0x83:\r\n                        case 0x84:\r\n                        case 0x85:\r\n                        case 0x86:\r\n                        case 0x87:\r\n                        case 0x88:\r\n                        case 0x89:\r\n                        case 0x8A:\r\n                        case 0x8B:\r\n                        case 0x8C:\r\n                        case 0x8D:\r\n                        case 0x8E:\r\n                        case 0x8F:\r\n                        case 0x90:\r\n                        case 0x91:\r\n                        case 0x92:\r\n                        case 0x93:\r\n                        case 0x94:\r\n                        case 0x95:\r\n                        case 0x96:\r\n                        case 0x97:\r\n                        case 0x98:\r\n                        case 0x99:\r\n                        case 0x9A:\r\n                        case 0x9B:\r\n                        case 0x9C:\r\n                        case 0x9D:\r\n                        case 0x9E:\r\n                        case 0x9F:\r\n                        case 0xA0:\r\n                        case 0xA1:\r\n                        case 0xA2:\r\n                        case 0xA3:\r\n                        case 0xA4:\r\n                        case 0xA5:\r\n                        case 0xA6:\r\n                        case 0xA7:\r\n                        case 0xA8:\r\n                        case 0xA9:\r\n                        case 0xAA:\r\n                        case 0xAB:\r\n                        case 0xAC:\r\n                        case 0xAD:\r\n                        case 0xAE:\r\n                        case 0xAF:\r\n                        case 0xB0:\r\n                        case 0xB1:\r\n                        case 0xB2:\r\n                        case 0xB3:\r\n                        case 0xB4:\r\n                        case 0xB5:\r\n                        case 0xB6:\r\n                        case 0xB7:\r\n                        case 0xB8:\r\n                        case 0xB9:\r\n                        case 0xBA:\r\n                        case 0xBB:\r\n                        case 0xBC:\r\n                        case 0xBD:\r\n                        case 0xBE:\r\n                        case 0xBF:\r\n                        case 0xC0:\r\n                        case 0xC1:\r\n                        case 0xC2:\r\n                        case 0xC3:\r\n                        case 0xC4:\r\n                        case 0xC5:\r\n                        case 0xC6:\r\n                        case 0xC7:\r\n                        case 0xC8:\r\n                        case 0xC9:\r\n                        case 0xCA:\r\n                        case 0xCB:\r\n                        case 0xCC:\r\n                        case 0xCD:\r\n                        case 0xCE:\r\n                        case 0xCF:\r\n                        case 0xD0:\r\n                        case 0xD1:\r\n                        case 0xD2:\r\n                        case 0xD3:\r\n                        case 0xD4:\r\n                        case 0xD5:\r\n                        case 0xD6:\r\n                        case 0xD7:\r\n                        case 0xD8:\r\n                        case 0xD9:\r\n                        case 0xDA:\r\n                        case 0xDB:\r\n                        case 0xDC:\r\n                        case 0xDD:\r\n                        case 0xDE:\r\n                        case 0xDF:\r\n                        case 0xE0:\r\n                        case 0xE1:\r\n                        case 0xE2:\r\n                        case 0xE3:\r\n                        case 0xE4:\r\n                        case 0xE5:\r\n                        case 0xE6:\r\n                        case 0xE7:\r\n                        case 0xE8:\r\n                        case 0xE9:\r\n                        case 0xEA:\r\n                        case 0xEB:\r\n                        case 0xEC:\r\n                        case 0xED:\r\n                        case 0xEE:\r\n                        case 0xEF:\r\n                        case 0xF0:\r\n                        case 0xF1:\r\n                        case 0xF2:\r\n                        case 0xF3:\r\n                        case 0xF4:\r\n                        case 0xF5:\r\n                        case 0xF6:\r\n                        case 0xF7:\r\n                        case 0xF8:\r\n                        case 0xF9:\r\n                        case 0xFA:\r\n                        case 0xFB:\r\n                        case 0xFC:\r\n                        case 0xFD:\r\n                        case 0xFE:\r\n                        case 0xFF:\r\n                            if (fOffsets[fCurrentWindow] <= 0xFFFF) {\r\n                                charBuffer[ucPos++] = (char) (aByte + fOffsets[fCurrentWindow] - COMPRESSIONOFFSET);\r\n                            } else {\r\n                                if ((ucPos + 1) >= charBufferLimit) {\r\n                                    --bytePos;\r\n                                    System.arraycopy(byteBuffer, bytePos, fBuffer, 0, byteBufferLimit - bytePos);\r\n                                    fBufferLength = byteBufferLimit - bytePos;\r\n                                    bytePos += fBufferLength;\r\n                                    break mainLoop;\r\n                                }\r\n                                int normalizedBase = fOffsets[fCurrentWindow] - 0x10000;\r\n                                charBuffer[ucPos++] = (char) (0xD800 + (normalizedBase >> 10));\r\n                                charBuffer[ucPos++] = (char) (0xDC00 + (normalizedBase & 0x3FF) + (aByte & 0x7F));\r\n                            }\r\n                            break;\r\n                        case 0x00:\r\n                        case 0x09:\r\n                        case 0x0A:\r\n                        case 0x0D:\r\n                        case 0x20:\r\n                        case 0x21:\r\n                        case 0x22:\r\n                        case 0x23:\r\n                        case 0x24:\r\n                        case 0x25:\r\n                        case 0x26:\r\n                        case 0x27:\r\n                        case 0x28:\r\n                        case 0x29:\r\n                        case 0x2A:\r\n                        case 0x2B:\r\n                        case 0x2C:\r\n                        case 0x2D:\r\n                        case 0x2E:\r\n                        case 0x2F:\r\n                        case 0x30:\r\n                        case 0x31:\r\n                        case 0x32:\r\n                        case 0x33:\r\n                        case 0x34:\r\n                        case 0x35:\r\n                        case 0x36:\r\n                        case 0x37:\r\n                        case 0x38:\r\n                        case 0x39:\r\n                        case 0x3A:\r\n                        case 0x3B:\r\n                        case 0x3C:\r\n                        case 0x3D:\r\n                        case 0x3E:\r\n                        case 0x3F:\r\n                        case 0x40:\r\n                        case 0x41:\r\n                        case 0x42:\r\n                        case 0x43:\r\n                        case 0x44:\r\n                        case 0x45:\r\n                        case 0x46:\r\n                        case 0x47:\r\n                        case 0x48:\r\n                        case 0x49:\r\n                        case 0x4A:\r\n                        case 0x4B:\r\n                        case 0x4C:\r\n                        case 0x4D:\r\n                        case 0x4E:\r\n                        case 0x4F:\r\n                        case 0x50:\r\n                        case 0x51:\r\n                        case 0x52:\r\n                        case 0x53:\r\n                        case 0x54:\r\n                        case 0x55:\r\n                        case 0x56:\r\n                        case 0x57:\r\n                        case 0x58:\r\n                        case 0x59:\r\n                        case 0x5A:\r\n                        case 0x5B:\r\n                        case 0x5C:\r\n                        case 0x5D:\r\n                        case 0x5E:\r\n                        case 0x5F:\r\n                        case 0x60:\r\n                        case 0x61:\r\n                        case 0x62:\r\n                        case 0x63:\r\n                        case 0x64:\r\n                        case 0x65:\r\n                        case 0x66:\r\n                        case 0x67:\r\n                        case 0x68:\r\n                        case 0x69:\r\n                        case 0x6A:\r\n                        case 0x6B:\r\n                        case 0x6C:\r\n                        case 0x6D:\r\n                        case 0x6E:\r\n                        case 0x6F:\r\n                        case 0x70:\r\n                        case 0x71:\r\n                        case 0x72:\r\n                        case 0x73:\r\n                        case 0x74:\r\n                        case 0x75:\r\n                        case 0x76:\r\n                        case 0x77:\r\n                        case 0x78:\r\n                        case 0x79:\r\n                        case 0x7A:\r\n                        case 0x7B:\r\n                        case 0x7C:\r\n                        case 0x7D:\r\n                        case 0x7E:\r\n                        case 0x7F:\r\n                            charBuffer[ucPos++] = (char) aByte;\r\n                            break;\r\n                        case SQUOTEU:\r\n                            if ((bytePos + 1) >= byteBufferLimit) {\r\n                                --bytePos;\r\n                                System.arraycopy(byteBuffer, bytePos, fBuffer, 0, byteBufferLimit - bytePos);\r\n                                fBufferLength = byteBufferLimit - bytePos;\r\n                                bytePos += fBufferLength;\r\n                                break mainLoop;\r\n                            }\r\n                            aByte = byteBuffer[bytePos++];\r\n                            charBuffer[ucPos++] = (char) (aByte << 8 | (byteBuffer[bytePos++] & 0xFF));\r\n                            break;\r\n                        case SCHANGEU:\r\n                            fMode = UNICODEMODE;\r\n                            break singleByteModeLoop;\r\n                        case SQUOTE0:\r\n                        case SQUOTE1:\r\n                        case SQUOTE2:\r\n                        case SQUOTE3:\r\n                        case SQUOTE4:\r\n                        case SQUOTE5:\r\n                        case SQUOTE6:\r\n                        case SQUOTE7:\r\n                            if (bytePos >= byteBufferLimit) {\r\n                                --bytePos;\r\n                                System.arraycopy(byteBuffer, bytePos, fBuffer, 0, byteBufferLimit - bytePos);\r\n                                fBufferLength = byteBufferLimit - bytePos;\r\n                                bytePos += fBufferLength;\r\n                                break mainLoop;\r\n                            }\r\n                            int dByte = byteBuffer[bytePos++] & 0xFF;\r\n                            charBuffer[ucPos++] = (char) (dByte + (dByte >= 0x00 && dByte < 0x80 ? sOffsets[aByte - SQUOTE0] : (fOffsets[aByte - SQUOTE0] - COMPRESSIONOFFSET)));\r\n                            break;\r\n                        case SCHANGE0:\r\n                        case SCHANGE1:\r\n                        case SCHANGE2:\r\n                        case SCHANGE3:\r\n                        case SCHANGE4:\r\n                        case SCHANGE5:\r\n                        case SCHANGE6:\r\n                        case SCHANGE7:\r\n                            fCurrentWindow = aByte - SCHANGE0;\r\n                            break;\r\n                        case SDEFINE0:\r\n                        case SDEFINE1:\r\n                        case SDEFINE2:\r\n                        case SDEFINE3:\r\n                        case SDEFINE4:\r\n                        case SDEFINE5:\r\n                        case SDEFINE6:\r\n                        case SDEFINE7:\r\n                            if (bytePos >= byteBufferLimit) {\r\n                                --bytePos;\r\n                                System.arraycopy(byteBuffer, bytePos, fBuffer, 0, byteBufferLimit - bytePos);\r\n                                fBufferLength = byteBufferLimit - bytePos;\r\n                                bytePos += fBufferLength;\r\n                                break mainLoop;\r\n                            }\r\n                            fCurrentWindow = aByte - SDEFINE0;\r\n                            fOffsets[fCurrentWindow] = sOffsetTable[byteBuffer[bytePos++] & 0xFF];\r\n                            break;\r\n                        case SDEFINEX:\r\n                            if ((bytePos + 1) >= byteBufferLimit) {\r\n                                --bytePos;\r\n                                System.arraycopy(byteBuffer, bytePos, fBuffer, 0, byteBufferLimit - bytePos);\r\n                                fBufferLength = byteBufferLimit - bytePos;\r\n                                bytePos += fBufferLength;\r\n                                break mainLoop;\r\n                            }\r\n                            aByte = byteBuffer[bytePos++] & 0xFF;\r\n                            fCurrentWindow = (aByte & 0xE0) >> 5;\r\n                            fOffsets[fCurrentWindow] = 0x10000 + (0x80 * (((aByte & 0x1F) << 8) | (byteBuffer[bytePos++] & 0xFF)));\r\n                            break;\r\n                        case SRESERVED:\r\n                            break;\r\n                    }\r\n                }\r\n                break;\r\n            case UNICODEMODE:\r\n                unicodeModeLoop: while (bytePos < byteBufferLimit && ucPos < charBufferLimit) {\r\n                    aByte = byteBuffer[bytePos++] & 0xFF;\r\n                    switch(aByte) {\r\n                        case UDEFINE0:\r\n                        case UDEFINE1:\r\n                        case UDEFINE2:\r\n                        case UDEFINE3:\r\n                        case UDEFINE4:\r\n                        case UDEFINE5:\r\n                        case UDEFINE6:\r\n                        case UDEFINE7:\r\n                            if (bytePos >= byteBufferLimit) {\r\n                                --bytePos;\r\n                                System.arraycopy(byteBuffer, bytePos, fBuffer, 0, byteBufferLimit - bytePos);\r\n                                fBufferLength = byteBufferLimit - bytePos;\r\n                                bytePos += fBufferLength;\r\n                                break mainLoop;\r\n                            }\r\n                            fCurrentWindow = aByte - UDEFINE0;\r\n                            fOffsets[fCurrentWindow] = sOffsetTable[byteBuffer[bytePos++] & 0xFF];\r\n                            fMode = SINGLEBYTEMODE;\r\n                            break unicodeModeLoop;\r\n                        case UDEFINEX:\r\n                            if ((bytePos + 1) >= byteBufferLimit) {\r\n                                --bytePos;\r\n                                System.arraycopy(byteBuffer, bytePos, fBuffer, 0, byteBufferLimit - bytePos);\r\n                                fBufferLength = byteBufferLimit - bytePos;\r\n                                bytePos += fBufferLength;\r\n                                break mainLoop;\r\n                            }\r\n                            aByte = byteBuffer[bytePos++] & 0xFF;\r\n                            fCurrentWindow = (aByte & 0xE0) >> 5;\r\n                            fOffsets[fCurrentWindow] = 0x10000 + (0x80 * (((aByte & 0x1F) << 8) | (byteBuffer[bytePos++] & 0xFF)));\r\n                            fMode = SINGLEBYTEMODE;\r\n                            break unicodeModeLoop;\r\n                        case UCHANGE0:\r\n                        case UCHANGE1:\r\n                        case UCHANGE2:\r\n                        case UCHANGE3:\r\n                        case UCHANGE4:\r\n                        case UCHANGE5:\r\n                        case UCHANGE6:\r\n                        case UCHANGE7:\r\n                            fCurrentWindow = aByte - UCHANGE0;\r\n                            fMode = SINGLEBYTEMODE;\r\n                            break unicodeModeLoop;\r\n                        case UQUOTEU:\r\n                            if (bytePos >= byteBufferLimit - 1) {\r\n                                --bytePos;\r\n                                System.arraycopy(byteBuffer, bytePos, fBuffer, 0, byteBufferLimit - bytePos);\r\n                                fBufferLength = byteBufferLimit - bytePos;\r\n                                bytePos += fBufferLength;\r\n                                break mainLoop;\r\n                            }\r\n                            aByte = byteBuffer[bytePos++];\r\n                            charBuffer[ucPos++] = (char) (aByte << 8 | (byteBuffer[bytePos++] & 0xFF));\r\n                            break;\r\n                        default:\r\n                            if (bytePos >= byteBufferLimit) {\r\n                                --bytePos;\r\n                                System.arraycopy(byteBuffer, bytePos, fBuffer, 0, byteBufferLimit - bytePos);\r\n                                fBufferLength = byteBufferLimit - bytePos;\r\n                                bytePos += fBufferLength;\r\n                                break mainLoop;\r\n                            }\r\n                            charBuffer[ucPos++] = (char) (aByte << 8 | (byteBuffer[bytePos++] & 0xFF));\r\n                            break;\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    if (bytesRead != null)\r\n        bytesRead[0] = (bytePos - byteBufferStart);\r\n    return (ucPos - charBufferStart);\r\n}"
}, {
	"Path": "org.apache.harmony.xml.dom.NodeImpl.getContainingElement",
	"Comment": "returns the nearest ancestor element that contains this node.",
	"Method": "NodeImpl getContainingElement(){\r\n    for (Node p = getParentNode(); p != null; p = p.getParentNode()) {\r\n        if (p.getNodeType() == ELEMENT_NODE) {\r\n            return (NodeImpl) p;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.util.CharsTrie.readValue",
	"Comment": "pos is already after the leadunit, and the lead unit has bit 15 reset.",
	"Method": "int readValue(CharSequence chars,int pos,int leadUnit){\r\n    int value;\r\n    if (leadUnit < kMinTwoUnitValueLead) {\r\n        value = leadUnit;\r\n    } else if (leadUnit < kThreeUnitValueLead) {\r\n        value = ((leadUnit - kMinTwoUnitValueLead) << 16) | chars.charAt(pos);\r\n    } else {\r\n        value = (chars.charAt(pos) << 16) | chars.charAt(pos + 1);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "android.icu.impl.coll.CollationBuilder.countTailoredNodes",
	"Comment": "counts the tailored nodes of the given strength up to the next nodewhich is either stronger or has an explicit weight of this strength.",
	"Method": "int countTailoredNodes(long[] nodesArray,int i,int strength){\r\n    int count = 0;\r\n    for (; ; ) {\r\n        if (i == 0) {\r\n            break;\r\n        }\r\n        long node = nodesArray[i];\r\n        if (strengthFromNode(node) < strength) {\r\n            break;\r\n        }\r\n        if (strengthFromNode(node) == strength) {\r\n            if (isTailoredNode(node)) {\r\n                ++count;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        i = nextIndexFromNode(node);\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "android.icu.text.CurrencyPluralInfo.setLocale",
	"Comment": "set locale.this also sets both the plural rules and the currency plural patterns to bethe defaults for the locale.",
	"Method": "void setLocale(ULocale loc){\r\n    ulocale = loc;\r\n    initialize(loc);\r\n}"
}, {
	"Path": "android.icu.text.DateIntervalFormat.concatSingleDate2TimeInterval",
	"Comment": "concat a single date pattern with a time interval pattern,set it into the intervalpatterns, while field is time field.this is used to handle time interval patterns on skeleton withboth time and date. present the date followed by the range expression for the time.",
	"Method": "void concatSingleDate2TimeInterval(String dtfmt,String datePattern,int field,Map<String, PatternInfo> intervalPatterns){\r\n    PatternInfo timeItvPtnInfo = intervalPatterns.get(DateIntervalInfo.CALENDAR_FIELD_TO_PATTERN_LETTER[field]);\r\n    if (timeItvPtnInfo != null) {\r\n        String timeIntervalPattern = timeItvPtnInfo.getFirstPart() + timeItvPtnInfo.getSecondPart();\r\n        String pattern = SimpleFormatterImpl.formatRawPattern(dtfmt, 2, 2, timeIntervalPattern, datePattern);\r\n        timeItvPtnInfo = DateIntervalInfo.genPatternInfo(pattern, timeItvPtnInfo.firstDateInPtnIsLaterDate());\r\n        intervalPatterns.put(DateIntervalInfo.CALENDAR_FIELD_TO_PATTERN_LETTER[field], timeItvPtnInfo);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedCollator.getReorderCodes",
	"Comment": "retrieves the reordering codes for this collator.these reordering codes are a combination of uscript codes and reordercodes.",
	"Method": "int[] getReorderCodes(){\r\n    return settings.readOnly().reorderCodes.clone();\r\n}"
}, {
	"Path": "org.apache.harmony.xml.parsers.DocumentBuilderImpl.setIgnoreElementContentWhitespace",
	"Comment": "controls whether this documentbuilder ignores element content whitespace.",
	"Method": "void setIgnoreElementContentWhitespace(boolean value){\r\n    ignoreElementContentWhitespace = value;\r\n}"
}, {
	"Path": "android.icu.text.TransliterationRule.toRule",
	"Comment": "create a source string that represents this rule.append it to thegiven string.",
	"Method": "String toRule(boolean escapeUnprintable){\r\n    StringBuffer rule = new StringBuffer();\r\n    StringBuffer quoteBuf = new StringBuffer();\r\n    boolean emitBraces = (anteContext != null) || (postContext != null);\r\n    if ((flags & ANCHOR_START) != 0) {\r\n        rule.append('^');\r\n    }\r\n    Utility.appendToRule(rule, anteContext, escapeUnprintable, quoteBuf);\r\n    if (emitBraces) {\r\n        Utility.appendToRule(rule, '{', true, escapeUnprintable, quoteBuf);\r\n    }\r\n    Utility.appendToRule(rule, key, escapeUnprintable, quoteBuf);\r\n    if (emitBraces) {\r\n        Utility.appendToRule(rule, '}', true, escapeUnprintable, quoteBuf);\r\n    }\r\n    Utility.appendToRule(rule, postContext, escapeUnprintable, quoteBuf);\r\n    if ((flags & ANCHOR_END) != 0) {\r\n        rule.append('$');\r\n    }\r\n    Utility.appendToRule(rule, \" > \", true, escapeUnprintable, quoteBuf);\r\n    Utility.appendToRule(rule, output.toReplacerPattern(escapeUnprintable), true, escapeUnprintable, quoteBuf);\r\n    Utility.appendToRule(rule, ';', true, escapeUnprintable, quoteBuf);\r\n    return rule.toString();\r\n}"
}, {
	"Path": "java.io.PipedInputStream.close",
	"Comment": "closes this stream. this implementation releases the buffer used for thepipe and notifies all threads waiting to read or write.",
	"Method": "void close(){\r\n    buffer = null;\r\n    notifyAll();\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.createKey",
	"Comment": "create a key from an id.this creates a key instance.subclasses can override to define more useful keys appropriateto the factories they accept.if id is null, returns null.",
	"Method": "Key createKey(String id){\r\n    return id == null ? null : new Key(id);\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.getDecimalSeparator",
	"Comment": "returns the character used for decimal sign. different for french, etc.",
	"Method": "char getDecimalSeparator(){\r\n    return decimalSeparator;\r\n}"
}, {
	"Path": "java.nio.charset.Charset.isRegistered",
	"Comment": "indicates whether this charset is known to be registered in the ianacharset registry.",
	"Method": "boolean isRegistered(){\r\n    return !canonicalName.startsWith(\"x-\") && !canonicalName.startsWith(\"X-\");\r\n}"
}, {
	"Path": "android.icu.text.DateFormat.getBooleanAttribute",
	"Comment": "returns the current value for the specified booleanattribute for this instanceif attribute is missing false is returned.",
	"Method": "boolean getBooleanAttribute(BooleanAttribute key){\r\n    if (key == DateFormat.BooleanAttribute.PARSE_PARTIAL_MATCH) {\r\n        key = DateFormat.BooleanAttribute.PARSE_PARTIAL_LITERAL_MATCH;\r\n    }\r\n    return booleanAttributes.contains(key);\r\n}"
}, {
	"Path": "android.icu.text.Transliterator.setFilter",
	"Comment": "changes the filter used by this transliterator.if the filteris set to null then no filtering will occur.callers must take care if a transliterator is in use bymultiple threads.the filter should not be changed by onethread while another thread may be transliterating.",
	"Method": "void setFilter(UnicodeFilter filter){\r\n    if (filter == null) {\r\n        this.filter = null;\r\n    } else {\r\n        try {\r\n            this.filter = new UnicodeSet((UnicodeSet) filter).freeze();\r\n        } catch (Exception e) {\r\n            this.filter = new UnicodeSet();\r\n            filter.addMatchSetTo(this.filter);\r\n            this.filter.freeze();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.setMaximumIntegerDigits",
	"Comment": "sets the maximum number of digits allowed in the integer portion of a number. thisoverride limits the integer digit count to 2,000,000,000 to match icu4c.",
	"Method": "void setMaximumIntegerDigits(int newValue){\r\n    super.setMaximumIntegerDigits(Math.min(newValue, MAX_INTEGER_DIGITS));\r\n}"
}, {
	"Path": "android.icu.util.IslamicCalendar.civilLeapYear",
	"Comment": "determine whether a year is a leap year in the islamic civil calendar",
	"Method": "boolean civilLeapYear(int year){\r\n    return (14 + 11 * year) % 30 < 11;\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.isNumeric",
	"Comment": "return true if the given format character, occuring counttimes, represents a numeric field.",
	"Method": "boolean isNumeric(char formatChar,int count){\r\n    return NUMERIC_FORMAT_CHARS.indexOf(formatChar) >= 0 || (count <= 2 && NUMERIC_FORMAT_CHARS2.indexOf(formatChar) >= 0);\r\n}"
}, {
	"Path": "android.icu.impl.UCharacterName.getExtendedOr10Name",
	"Comment": "gets the extended and 1.0 name when the most current unicode namesfail",
	"Method": "String getExtendedOr10Name(int ch){\r\n    String result = null;\r\n    if (result == null) {\r\n        int type = getType(ch);\r\n        if (type >= TYPE_NAMES_.length) {\r\n            result = UNKNOWN_TYPE_NAME_;\r\n        } else {\r\n            result = TYPE_NAMES_[type];\r\n        }\r\n        synchronized (m_utilStringBuffer_) {\r\n            m_utilStringBuffer_.setLength(0);\r\n            m_utilStringBuffer_.append('<');\r\n            m_utilStringBuffer_.append(result);\r\n            m_utilStringBuffer_.append('-');\r\n            String chStr = Integer.toHexString(ch).toUpperCase(Locale.ENGLISH);\r\n            int zeros = 4 - chStr.length();\r\n            while (zeros > 0) {\r\n                m_utilStringBuffer_.append('0');\r\n                zeros--;\r\n            }\r\n            m_utilStringBuffer_.append(chStr);\r\n            m_utilStringBuffer_.append('>');\r\n            result = m_utilStringBuffer_.toString();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.impl.Trie.getSerializedDataSize",
	"Comment": "gets the serialized data file size of the trie. this is used duringtrie data reading for size checking purposes.",
	"Method": "int getSerializedDataSize(){\r\n    int result = (4 << 2);\r\n    result += (m_dataOffset_ << 1);\r\n    if (isCharTrie()) {\r\n        result += (m_dataLength_ << 1);\r\n    } else if (isIntTrie()) {\r\n        result += (m_dataLength_ << 2);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.setGroupingSeparator",
	"Comment": "sets the character used for grouping separator. different for french, etc.",
	"Method": "void setGroupingSeparator(char groupingSeparator){\r\n    this.groupingSeparator = groupingSeparator;\r\n    this.groupingSeparatorString = String.valueOf(groupingSeparator);\r\n}"
}, {
	"Path": "android.icu.util.ULocale.getScript",
	"Comment": "returns the script code for this locale, which might be the empty string.",
	"Method": "String getScript(String getScript,String localeID){\r\n    return new LocaleIDParser(localeID).getScript();\r\n}"
}, {
	"Path": "android.icu.text.DateTimePatternGenerator.getFrozenInstance",
	"Comment": "construct a frozen instance of datetimepatterngenerator for agiven locale.this method returns a cached frozen instance ofdatetimepatterngenerator, so less expensive than the regularfactory method.",
	"Method": "DateTimePatternGenerator getFrozenInstance(ULocale uLocale){\r\n    String localeKey = uLocale.toString();\r\n    DateTimePatternGenerator result = DTPNG_CACHE.get(localeKey);\r\n    if (result != null) {\r\n        return result;\r\n    }\r\n    result = new DateTimePatternGenerator();\r\n    result.initData(uLocale);\r\n    result.freeze();\r\n    DTPNG_CACHE.put(localeKey, result);\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.reInitializeFactories",
	"Comment": "reinitialize the factory list to its default state.by defaultthis clears the list.subclasses can override to provide otherdefault initialization of the factory list.subclasses mustnot call this method directly, as it must only be called whileholding write access to the factory list.",
	"Method": "void reInitializeFactories(){\r\n    factories.clear();\r\n}"
}, {
	"Path": "android.icu.text.DateIntervalFormat.genIntervalPattern",
	"Comment": "generate interval pattern from existing resourceit not only save the interval patterns,but also return the skeleton and its best match skeleton.",
	"Method": "SkeletonAndItsBestMatch genIntervalPattern(int field,String skeleton,String bestSkeleton,int differenceInfo,Map<String, PatternInfo> intervalPatterns){\r\n    SkeletonAndItsBestMatch retValue = null;\r\n    PatternInfo pattern = fInfo.getIntervalPattern(bestSkeleton, field);\r\n    if (pattern == null) {\r\n        if (SimpleDateFormat.isFieldUnitIgnored(bestSkeleton, field)) {\r\n            PatternInfo ptnInfo = new PatternInfo(fDateFormat.toPattern(), null, fInfo.getDefaultOrder());\r\n            intervalPatterns.put(DateIntervalInfo.CALENDAR_FIELD_TO_PATTERN_LETTER[field], ptnInfo);\r\n            return null;\r\n        }\r\n        if (field == Calendar.AM_PM) {\r\n            pattern = fInfo.getIntervalPattern(bestSkeleton, Calendar.HOUR);\r\n            if (pattern != null) {\r\n                intervalPatterns.put(DateIntervalInfo.CALENDAR_FIELD_TO_PATTERN_LETTER[field], pattern);\r\n            }\r\n            return null;\r\n        }\r\n        String fieldLetter = DateIntervalInfo.CALENDAR_FIELD_TO_PATTERN_LETTER[field];\r\n        bestSkeleton = fieldLetter + bestSkeleton;\r\n        skeleton = fieldLetter + skeleton;\r\n        pattern = fInfo.getIntervalPattern(bestSkeleton, field);\r\n        if (pattern == null && differenceInfo == 0) {\r\n            BestMatchInfo tmpRetValue = fInfo.getBestSkeleton(skeleton);\r\n            String tmpBestSkeleton = tmpRetValue.bestMatchSkeleton;\r\n            differenceInfo = tmpRetValue.bestMatchDistanceInfo;\r\n            if (tmpBestSkeleton.length() != 0 && differenceInfo != -1) {\r\n                pattern = fInfo.getIntervalPattern(tmpBestSkeleton, field);\r\n                bestSkeleton = tmpBestSkeleton;\r\n            }\r\n        }\r\n        if (pattern != null) {\r\n            retValue = new SkeletonAndItsBestMatch(skeleton, bestSkeleton);\r\n        }\r\n    }\r\n    if (pattern != null) {\r\n        if (differenceInfo != 0) {\r\n            String part1 = adjustFieldWidth(skeleton, bestSkeleton, pattern.getFirstPart(), differenceInfo);\r\n            String part2 = adjustFieldWidth(skeleton, bestSkeleton, pattern.getSecondPart(), differenceInfo);\r\n            pattern = new PatternInfo(part1, part2, pattern.firstDateInPtnIsLaterDate());\r\n        } else {\r\n        }\r\n        intervalPatterns.put(DateIntervalInfo.CALENDAR_FIELD_TO_PATTERN_LETTER[field], pattern);\r\n    }\r\n    return retValue;\r\n}"
}, {
	"Path": "android.icu.text.NumberFormat.readObject",
	"Comment": "first, read in the default serializable data.then, if serialversiononstream is less than 1, indicating thatthe stream was written by jdk 1.1,set the int fields such as maximumintegerdigitsto be equal to the byte fields such as maxintegerdigits,since the int fields were not present in jdk 1.1.finally, set serialversiononstream back to the maximum allowed value so thatdefault serialization will work properly if this object is streamed out again.",
	"Method": "void readObject(ObjectInputStream stream){\r\n    stream.defaultReadObject();\r\n    if (serialVersionOnStream < 1) {\r\n        maximumIntegerDigits = maxIntegerDigits;\r\n        minimumIntegerDigits = minIntegerDigits;\r\n        maximumFractionDigits = maxFractionDigits;\r\n        minimumFractionDigits = minFractionDigits;\r\n    }\r\n    if (serialVersionOnStream < 2) {\r\n        capitalizationSetting = DisplayContext.CAPITALIZATION_NONE;\r\n    }\r\n    if (minimumIntegerDigits > maximumIntegerDigits || minimumFractionDigits > maximumFractionDigits || minimumIntegerDigits < 0 || minimumFractionDigits < 0) {\r\n        throw new InvalidObjectException(\"Digit count range invalid\");\r\n    }\r\n    serialVersionOnStream = currentSerialVersion;\r\n}"
}, {
	"Path": "android.icu.lang.UCharacter.isJavaLetter",
	"Comment": "compatibility override of java deprecated method.thismethod will always remain deprecated.delegates tojava.lang.character.isjavaidentifierstart.",
	"Method": "boolean isJavaLetter(int cp){\r\n    return isJavaIdentifierStart(cp);\r\n}"
}, {
	"Path": "android.icu.util.CharsTrie.clone",
	"Comment": "clones this trie reader object and its state,but not the char array which will be shared.",
	"Method": "Object clone(){\r\n    return super.clone();\r\n}"
}, {
	"Path": "android.icu.text.CharsetMatch.getString",
	"Comment": "create a java string from unicode character data correspondingto the original byte data supplied to the charset detect operation.",
	"Method": "String getString(String getString,int maxLength){\r\n    String result = null;\r\n    if (fInputStream != null) {\r\n        StringBuilder sb = new StringBuilder();\r\n        char[] buffer = new char[1024];\r\n        Reader reader = getReader();\r\n        int max = maxLength < 0 ? Integer.MAX_VALUE : maxLength;\r\n        int bytesRead = 0;\r\n        while ((bytesRead = reader.read(buffer, 0, Math.min(max, 1024))) >= 0) {\r\n            sb.append(buffer, 0, bytesRead);\r\n            max -= bytesRead;\r\n        }\r\n        reader.close();\r\n        return sb.toString();\r\n    } else {\r\n        String name = getName();\r\n        int startSuffix = name.indexOf(\"_rtl\") < 0 ? name.indexOf(\"_ltr\") : name.indexOf(\"_rtl\");\r\n        if (startSuffix > 0) {\r\n            name = name.substring(0, startSuffix);\r\n        }\r\n        result = new String(fRawInput, name);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.text.CompactDecimalFormat.parse",
	"Comment": "parsing is currently unsupported, and throws an unsupportedoperationexception.",
	"Method": "Number parse(String text,ParsePosition parsePosition){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "android.icu.impl.Trie2.charSequenceIterator",
	"Comment": "create an iterator that will produce the values from the trie2 for the sequence of code points in an input text.",
	"Method": "CharSequenceIterator charSequenceIterator(CharSequence text,int index){\r\n    return new CharSequenceIterator(text, index);\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedCollator.getTailoredSet",
	"Comment": "get a unicodeset that contains all the characters and sequences tailored in this collator.",
	"Method": "UnicodeSet getTailoredSet(){\r\n    UnicodeSet tailored = new UnicodeSet();\r\n    if (data.base != null) {\r\n        new TailoredSet(tailored).forData(data);\r\n    }\r\n    return tailored;\r\n}"
}, {
	"Path": "android.icu.util.ByteArrayWrapper.copyBytes",
	"Comment": "copies the contents of src byte array from offset srcoff to the target of tgt byte array at the offset tgtoff.",
	"Method": "void copyBytes(byte[] src,int srcoff,byte[] tgt,int tgtoff,int length){\r\n    if (length < 64) {\r\n        for (int i = srcoff, n = tgtoff; --length >= 0; ++i, ++n) {\r\n            tgt[n] = src[i];\r\n        }\r\n    } else {\r\n        System.arraycopy(src, srcoff, tgt, tgtoff, length);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedNumberFormat.setRoundingMode",
	"Comment": "sets the rounding mode. this has no effect unless the rounding increment is greaterthan zero.",
	"Method": "void setRoundingMode(int roundingMode){\r\n    if (roundingMode < BigDecimal.ROUND_UP || roundingMode > BigDecimal.ROUND_UNNECESSARY) {\r\n        throw new IllegalArgumentException(\"Invalid rounding mode: \" + roundingMode);\r\n    }\r\n    this.roundingMode = roundingMode;\r\n}"
}, {
	"Path": "android.icu.dev.test.bidi.TestCharFromDirProp.testCharFromDirProp",
	"Comment": "verify that the exemplar characters have the expected bidi classes",
	"Method": "void testCharFromDirProp(){\r\n    logln(\"\\nEntering TestCharFromDirProp\");\r\n    int i = UCharacterDirection.CHAR_DIRECTION_COUNT;\r\n    while (i-- > 0) {\r\n        char c = charFromDirProp[i];\r\n        int dir = UCharacter.getDirection(c);\r\n        assertEquals(\"UCharacter.getDirection(TestData.charFromDirProp[\" + i + \"] == U+\" + Utility.hex(c) + \") failed\", i, dir);\r\n    }\r\n    logln(\"\\nExiting TestCharFromDirProp\");\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.matchDayPeriodString",
	"Comment": "similar to matchquarterstring but customized for day periods.",
	"Method": "int matchDayPeriodString(String text,int start,String[] data,int dataLength,Output<DayPeriodRules.DayPeriod> dayPeriod){\r\n    int bestMatchLength = 0, bestMatch = -1;\r\n    int matchLength = 0;\r\n    for (int i = 0; i < dataLength; ++i) {\r\n        if (data[i] != null) {\r\n            int length = data[i].length();\r\n            if (length > bestMatchLength && (matchLength = regionMatchesWithOptionalDot(text, start, data[i], length)) >= 0) {\r\n                bestMatch = i;\r\n                bestMatchLength = matchLength;\r\n            }\r\n        }\r\n    }\r\n    if (bestMatch >= 0) {\r\n        dayPeriod.value = DayPeriodRules.DayPeriod.VALUES[bestMatch];\r\n        return start + bestMatchLength;\r\n    }\r\n    return -start;\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.CompatibilityTest.TestFieldSet4781",
	"Comment": "verify that setting fields works.this test fails when an exception is thrown.",
	"Method": "void TestFieldSet4781(){\r\n    try {\r\n        GregorianCalendar g = new GregorianCalendar();\r\n        GregorianCalendar g2 = new GregorianCalendar();\r\n        g2.set(Calendar.HOUR, 12);\r\n        g2.set(Calendar.MINUTE, 0);\r\n        g2.set(Calendar.SECOND, 0);\r\n        if (g2.equals(g))\r\n            logln(\"Same\");\r\n        else\r\n            logln(\"Different\");\r\n    } catch (IllegalArgumentException e) {\r\n        errln(\"Unexpected exception seen: \" + e);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.CharsetRecog_mbcs.match",
	"Comment": "test the match of this charset with the input text data which is obtained via the charsetdetector object.",
	"Method": "int match(CharsetDetector det,int[] commonChars,CharsetMatch match,CharsetDetector det,CharsetMatch match,CharsetDetector det,CharsetMatch match,CharsetDetector det,CharsetMatch match,CharsetDetector det,CharsetMatch match,CharsetDetector det){\r\n    @SuppressWarnings(\"unused\")\r\n    int singleByteCharCount = 0;\r\n    int doubleByteCharCount = 0;\r\n    int commonCharCount = 0;\r\n    int badCharCount = 0;\r\n    int totalCharCount = 0;\r\n    int confidence = 0;\r\n    iteratedChar iter = new iteratedChar();\r\n    detectBlock: {\r\n        for (iter.reset(); nextChar(iter, det); ) {\r\n            totalCharCount++;\r\n            if (iter.error) {\r\n                badCharCount++;\r\n            } else {\r\n                long cv = iter.charValue & 0xFFFFFFFFL;\r\n                if (cv <= 0xff) {\r\n                    singleByteCharCount++;\r\n                } else {\r\n                    doubleByteCharCount++;\r\n                    if (commonChars != null) {\r\n                        if (Arrays.binarySearch(commonChars, (int) cv) >= 0) {\r\n                            commonCharCount++;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount) {\r\n                break detectBlock;\r\n            }\r\n        }\r\n        if (doubleByteCharCount <= 10 && badCharCount == 0) {\r\n            if (doubleByteCharCount == 0 && totalCharCount < 10) {\r\n                confidence = 0;\r\n            } else {\r\n                confidence = 10;\r\n            }\r\n            break detectBlock;\r\n        }\r\n        if (doubleByteCharCount < 20 * badCharCount) {\r\n            confidence = 0;\r\n            break detectBlock;\r\n        }\r\n        if (commonChars == null) {\r\n            confidence = 30 + doubleByteCharCount - 20 * badCharCount;\r\n            if (confidence > 100) {\r\n                confidence = 100;\r\n            }\r\n        } else {\r\n            double maxVal = Math.log((float) doubleByteCharCount / 4);\r\n            double scaleFactor = 90.0 / maxVal;\r\n            confidence = (int) (Math.log(commonCharCount + 1) * scaleFactor + 10);\r\n            confidence = Math.min(confidence, 100);\r\n        }\r\n    }\r\n    return confidence;\r\n}"
}, {
	"Path": "android.icu.util.CharsTrie.current",
	"Comment": "determines whether the string so far matches, whether it has a value,and whether another input char can continue a matching string.",
	"Method": "Result current(){\r\n    int pos = pos_;\r\n    if (pos < 0) {\r\n        return Result.NO_MATCH;\r\n    } else {\r\n        int node;\r\n        return (remainingMatchLength_ < 0 && (node = chars_.charAt(pos)) >= kMinValueLead) ? valueResults_[node >> 15] : Result.NO_VALUE;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedCollator.setCaseLevel",
	"Comment": "when case level is set to true, an additional weight is formed between the secondary and tertiary weight, knownas the case level. the case level is used to distinguish large and small japanese kana characters. case levelcould also be used in other situations. for example to distinguish certain pinyin characters. the default valueis false, which means the case level is not generated. the contents of the case level are affected by the casefirst mode. a simple way to ignore accent differences in a string is to set the strength to primary and enablecase level.see the section on caselevel for more information.",
	"Method": "void setCaseLevel(boolean flag){\r\n    checkNotFrozen();\r\n    if (flag == isCaseLevel()) {\r\n        return;\r\n    }\r\n    CollationSettings ownedSettings = getOwnedSettings();\r\n    ownedSettings.setFlag(CollationSettings.CASE_LEVEL, flag);\r\n    setFastLatinOptions(ownedSettings);\r\n}"
}, {
	"Path": "android.icu.text.SimpleFormatter.compileMinMaxArguments",
	"Comment": "creates a formatter from the pattern string.the number of arguments checked against the given limits is thehighest argument number plus one, not the number of occurrences of arguments.",
	"Method": "SimpleFormatter compileMinMaxArguments(CharSequence pattern,int min,int max){\r\n    StringBuilder sb = new StringBuilder();\r\n    String compiledPattern = SimpleFormatterImpl.compileToStringMinMaxArguments(pattern, sb, min, max);\r\n    return new SimpleFormatter(compiledPattern);\r\n}"
}, {
	"Path": "android.icu.impl.ZoneMeta.getZoneIDs",
	"Comment": "icu frequently refers the zone id array in zoneinfo resource",
	"Method": "String[] getZoneIDs(){\r\n    if (ZONEIDS == null) {\r\n        try {\r\n            UResourceBundle top = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, ZONEINFORESNAME, ICUResourceBundle.ICU_DATA_CLASS_LOADER);\r\n            ZONEIDS = top.getStringArray(kNAMES);\r\n        } catch (MissingResourceException ex) {\r\n        }\r\n    }\r\n    if (ZONEIDS == null) {\r\n        ZONEIDS = new String[0];\r\n    }\r\n    return ZONEIDS;\r\n}"
}, {
	"Path": "android.icu.text.CurrencyMetaInfo.currencyDigits",
	"Comment": "returns the currencydigits for the currency code with context usage.",
	"Method": "CurrencyDigits currencyDigits(String isoCode,CurrencyDigits currencyDigits,String isoCode,CurrencyUsage currencyUsage){\r\n    return defaultDigits;\r\n}"
}, {
	"Path": "android.icu.text.CollationElementIterator.getMaxExpansion",
	"Comment": "returns the maximum length of any expansion sequence that ends withthe specified collation element. if there is no expansion with thiscollation element as the last element, returns 1.",
	"Method": "int getMaxExpansion(int ce,int getMaxExpansion,Map<Integer, Integer> maxExpansions,int order){\r\n    if (order == 0) {\r\n        return 1;\r\n    }\r\n    Integer max;\r\n    if (maxExpansions != null && (max = maxExpansions.get(order)) != null) {\r\n        return max;\r\n    }\r\n    if ((order & 0xc0) == 0xc0) {\r\n        return 2;\r\n    } else {\r\n        return 1;\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.LocaleData.getMeasurementSystem",
	"Comment": "returns the measurement system used in the locale specified by the locale.",
	"Method": "MeasurementSystem getMeasurementSystem(ULocale locale){\r\n    UResourceBundle sysBundle = measurementTypeBundleForLocale(locale, MEASUREMENT_SYSTEM);\r\n    switch(sysBundle.getInt()) {\r\n        case 0:\r\n            return MeasurementSystem.SI;\r\n        case 1:\r\n            return MeasurementSystem.US;\r\n        case 2:\r\n            return MeasurementSystem.UK;\r\n        default:\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.toPattern",
	"Comment": "synthesizes a pattern string that represents the current state of this formatobject.",
	"Method": "String toPattern(String toPattern,boolean localized){\r\n    StringBuffer result = new StringBuffer();\r\n    char zero = localized ? symbols.getZeroDigit() : PATTERN_ZERO_DIGIT;\r\n    char digit = localized ? symbols.getDigit() : PATTERN_DIGIT;\r\n    char sigDigit = 0;\r\n    boolean useSigDig = areSignificantDigitsUsed();\r\n    if (useSigDig) {\r\n        sigDigit = localized ? symbols.getSignificantDigit() : PATTERN_SIGNIFICANT_DIGIT;\r\n    }\r\n    char group = localized ? symbols.getGroupingSeparator() : PATTERN_GROUPING_SEPARATOR;\r\n    int i;\r\n    int roundingDecimalPos = 0;\r\n    String roundingDigits = null;\r\n    int padPos = (formatWidth > 0) ? padPosition : -1;\r\n    String padSpec = (formatWidth > 0) ? new StringBuffer(2).append(localized ? symbols.getPadEscape() : PATTERN_PAD_ESCAPE).append(pad).toString() : null;\r\n    if (roundingIncrementICU != null) {\r\n        i = roundingIncrementICU.scale();\r\n        roundingDigits = roundingIncrementICU.movePointRight(i).toString();\r\n        roundingDecimalPos = roundingDigits.length() - i;\r\n    }\r\n    for (int part = 0; part < 2; ++part) {\r\n        if (padPos == PAD_BEFORE_PREFIX) {\r\n            result.append(padSpec);\r\n        }\r\n        appendAffixPattern(result, part != 0, true, localized);\r\n        if (padPos == PAD_AFTER_PREFIX) {\r\n            result.append(padSpec);\r\n        }\r\n        int sub0Start = result.length();\r\n        int g = isGroupingUsed() ? Math.max(0, groupingSize) : 0;\r\n        if (g > 0 && groupingSize2 > 0 && groupingSize2 != groupingSize) {\r\n            g += groupingSize2;\r\n        }\r\n        int maxDig = 0, minDig = 0, maxSigDig = 0;\r\n        if (useSigDig) {\r\n            minDig = getMinimumSignificantDigits();\r\n            maxDig = maxSigDig = getMaximumSignificantDigits();\r\n        } else {\r\n            minDig = getMinimumIntegerDigits();\r\n            maxDig = getMaximumIntegerDigits();\r\n        }\r\n        if (useExponentialNotation) {\r\n            if (maxDig > MAX_SCIENTIFIC_INTEGER_DIGITS) {\r\n                maxDig = 1;\r\n            }\r\n        } else if (useSigDig) {\r\n            maxDig = Math.max(maxDig, g + 1);\r\n        } else {\r\n            maxDig = Math.max(Math.max(g, getMinimumIntegerDigits()), roundingDecimalPos) + 1;\r\n        }\r\n        for (i = maxDig; i > 0; --i) {\r\n            if (!useExponentialNotation && i < maxDig && isGroupingPosition(i)) {\r\n                result.append(group);\r\n            }\r\n            if (useSigDig) {\r\n                result.append((maxSigDig >= i && i > (maxSigDig - minDig)) ? sigDigit : digit);\r\n            } else {\r\n                if (roundingDigits != null) {\r\n                    int pos = roundingDecimalPos - i;\r\n                    if (pos >= 0 && pos < roundingDigits.length()) {\r\n                        result.append((char) (roundingDigits.charAt(pos) - '0' + zero));\r\n                        continue;\r\n                    }\r\n                }\r\n                result.append(i <= minDig ? zero : digit);\r\n            }\r\n        }\r\n        if (!useSigDig) {\r\n            if (getMaximumFractionDigits() > 0 || decimalSeparatorAlwaysShown) {\r\n                result.append(localized ? symbols.getDecimalSeparator() : PATTERN_DECIMAL_SEPARATOR);\r\n            }\r\n            int pos = roundingDecimalPos;\r\n            for (i = 0; i < getMaximumFractionDigits(); ++i) {\r\n                if (roundingDigits != null && pos < roundingDigits.length()) {\r\n                    result.append(pos < 0 ? zero : (char) (roundingDigits.charAt(pos) - '0' + zero));\r\n                    ++pos;\r\n                    continue;\r\n                }\r\n                result.append(i < getMinimumFractionDigits() ? zero : digit);\r\n            }\r\n        }\r\n        if (useExponentialNotation) {\r\n            if (localized) {\r\n                result.append(symbols.getExponentSeparator());\r\n            } else {\r\n                result.append(PATTERN_EXPONENT);\r\n            }\r\n            if (exponentSignAlwaysShown) {\r\n                result.append(localized ? symbols.getPlusSign() : PATTERN_PLUS_SIGN);\r\n            }\r\n            for (i = 0; i < minExponentDigits; ++i) {\r\n                result.append(zero);\r\n            }\r\n        }\r\n        if (padSpec != null && !useExponentialNotation) {\r\n            int add = formatWidth - result.length() + sub0Start - ((part == 0) ? positivePrefix.length() + positiveSuffix.length() : negativePrefix.length() + negativeSuffix.length());\r\n            while (add > 0) {\r\n                result.insert(sub0Start, digit);\r\n                ++maxDig;\r\n                --add;\r\n                if (add > 1 && isGroupingPosition(maxDig)) {\r\n                    result.insert(sub0Start, group);\r\n                    --add;\r\n                }\r\n            }\r\n        }\r\n        if (padPos == PAD_BEFORE_SUFFIX) {\r\n            result.append(padSpec);\r\n        }\r\n        appendAffixPattern(result, part != 0, false, localized);\r\n        if (padPos == PAD_AFTER_SUFFIX) {\r\n            result.append(padSpec);\r\n        }\r\n        if (part == 0) {\r\n            if (negativeSuffix.equals(positiveSuffix) && negativePrefix.equals(PATTERN_MINUS_SIGN + positivePrefix)) {\r\n                break;\r\n            } else {\r\n                result.append(localized ? symbols.getPatternSeparator() : PATTERN_SEPARATOR);\r\n            }\r\n        }\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "android.icu.text.PluralRanges.add",
	"Comment": "internal method for building. if the start or end are null, it means everything of that type.",
	"Method": "void add(StandardPlural rangeStart,StandardPlural rangeEnd,StandardPlural result){\r\n    if (isFrozen) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n    explicit[result.ordinal()] = true;\r\n    if (rangeStart == null) {\r\n        for (StandardPlural rs : StandardPlural.values()) {\r\n            if (rangeEnd == null) {\r\n                for (StandardPlural re : StandardPlural.values()) {\r\n                    matrix.setIfNew(rs, re, result);\r\n                }\r\n            } else {\r\n                explicit[rangeEnd.ordinal()] = true;\r\n                matrix.setIfNew(rs, rangeEnd, result);\r\n            }\r\n        }\r\n    } else if (rangeEnd == null) {\r\n        explicit[rangeStart.ordinal()] = true;\r\n        for (StandardPlural re : StandardPlural.values()) {\r\n            matrix.setIfNew(rangeStart, re, result);\r\n        }\r\n    } else {\r\n        explicit[rangeStart.ordinal()] = true;\r\n        explicit[rangeEnd.ordinal()] = true;\r\n        matrix.setIfNew(rangeStart, rangeEnd, result);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.TransliterationRuleSet.addRule",
	"Comment": "add a rule to this set.rules are added in order, and order issignificant.",
	"Method": "void addRule(TransliterationRule rule){\r\n    ruleVector.add(rule);\r\n    int len;\r\n    if ((len = rule.getAnteContextLength()) > maxContextLength) {\r\n        maxContextLength = len;\r\n    }\r\n    rules = null;\r\n}"
}, {
	"Path": "android.icu.text.ScientificNumberFormatter.getMarkupInstance",
	"Comment": "gets a scientificnumberformatter instance that uses markup for exponents.",
	"Method": "ScientificNumberFormatter getMarkupInstance(ULocale locale,String beginMarkup,String endMarkup,ScientificNumberFormatter getMarkupInstance,DecimalFormat df,String beginMarkup,String endMarkup){\r\n    return getInstance(df, new MarkupStyle(beginMarkup, endMarkup));\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.isDefault",
	"Comment": "return true if the service is in its default state.the defaultimplementation returns true if there are no factories registered.",
	"Method": "boolean isDefault(){\r\n    return factories.size() == defaultSize;\r\n}"
}, {
	"Path": "android.icu.text.CompactDecimalFormat.getCurrencyData",
	"Comment": "gets the currency data for a particular locale.currently only short currency format is supported, since that isthe only form in cldr.",
	"Method": "Data getCurrencyData(ULocale locale){\r\n    CompactDecimalDataCache.DataBundle bundle = cache.get(locale);\r\n    return bundle.shortCurrencyData;\r\n}"
}, {
	"Path": "android.icu.impl.CalendarAstronomer.setDate",
	"Comment": "set the current date and time of this calendarastronomer object.allastronomical calculations are performed based on this time setting.",
	"Method": "void setDate(Date date){\r\n    setTime(date.getTime());\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.getPatternSeparator",
	"Comment": "returns the character used to separate positive and negative subpatternsin a pattern.",
	"Method": "char getPatternSeparator(){\r\n    return patternSeparator;\r\n}"
}, {
	"Path": "android.icu.util.UResourceBundle.getString",
	"Comment": "returns the string in a given resource at the specified index.",
	"Method": "String getString(String getString,int index){\r\n    ICUResourceBundle temp = (ICUResourceBundle) get(index);\r\n    if (temp.getType() == STRING) {\r\n        return temp.getString();\r\n    }\r\n    throw new UResourceTypeMismatchException(\"\");\r\n}"
}, {
	"Path": "android.icu.impl.LocaleIDParser.setToKeywordStart",
	"Comment": "if we have keywords, advance index to the start of the keywords and return true,otherwise return false.",
	"Method": "boolean setToKeywordStart(){\r\n    for (int i = index; i < id.length; ++i) {\r\n        if (id[i] == KEYWORD_SEPARATOR) {\r\n            if (canonicalize) {\r\n                for (int j = ++i; j < id.length; ++j) {\r\n                    if (id[j] == KEYWORD_ASSIGN) {\r\n                        index = i;\r\n                        return true;\r\n                    }\r\n                }\r\n            } else {\r\n                if (++i < id.length) {\r\n                    index = i;\r\n                    return true;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "android.icu.text.MeasureFormat.withLocale",
	"Comment": "this method changes the numberformat object as well to match the new locale.",
	"Method": "MeasureFormat withLocale(ULocale locale){\r\n    return MeasureFormat.getInstance(locale, getWidth());\r\n}"
}, {
	"Path": "android.icu.lang.UScript.getSampleString",
	"Comment": "returns the script sample character string.this string normally consists of one code point but might be longer.the string is empty if the script is not encoded.",
	"Method": "String getSampleString(int script){\r\n    int sampleChar = ScriptMetadata.getScriptProps(script) & 0x1fffff;\r\n    if (sampleChar != 0) {\r\n        return new StringBuilder().appendCodePoint(sampleChar).toString();\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.IBMCalendarTest.TestTimeZoneTransitionAdd",
	"Comment": "make sure that when adding a day, we actually wind up in adifferent day.the dst adjustments we use to keep the hourconstant across dst changes can backfire and change the day.",
	"Method": "void TestTimeZoneTransitionAdd(){\r\n    Locale locale = Locale.US;\r\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"MM/dd/yyyy HH:mm z\", locale);\r\n    String[] tz = TimeZone.getAvailableIDs();\r\n    for (int z = 0; z < tz.length; ++z) {\r\n        TimeZone t = TimeZone.getTimeZone(tz[z]);\r\n        dateFormat.setTimeZone(t);\r\n        Calendar cal = Calendar.getInstance(t, locale);\r\n        cal.clear();\r\n        cal.set(Calendar.YEAR, 2002);\r\n        cal.set(Calendar.MONTH, Calendar.DECEMBER);\r\n        cal.set(Calendar.DAY_OF_MONTH, 25);\r\n        for (int i = 0; i < 365 + 10; ++i) {\r\n            Date yesterday = cal.getTime();\r\n            int yesterday_day = cal.get(Calendar.DAY_OF_MONTH);\r\n            cal.add(Calendar.DAY_OF_MONTH, 1);\r\n            if (yesterday_day == cal.get(Calendar.DAY_OF_MONTH)) {\r\n                errln(tz[z] + \" \" + dateFormat.format(yesterday) + \" +1d= \" + dateFormat.format(cal.getTime()));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.Bidi.getParagraphIndex",
	"Comment": "get the index of a paragraph, given a position within the text.",
	"Method": "int getParagraphIndex(int charIndex){\r\n    verifyValidParaOrLine();\r\n    Bidi bidi = paraBidi;\r\n    verifyRange(charIndex, 0, bidi.length);\r\n    int paraIndex;\r\n    for (paraIndex = 0; charIndex >= bidi.paras_limit[paraIndex]; paraIndex++) {\r\n    }\r\n    return paraIndex;\r\n}"
}, {
	"Path": "android.icu.impl.duration.BasicDurationFormatterFactory.reset",
	"Comment": "clear the cached formatter.subclasses must call this if theirstate has changed. this is automatically invoked by setbuilder,setformatter, setfallback, setlocalename, and settimezone",
	"Method": "void reset(){\r\n    f = null;\r\n}"
}, {
	"Path": "android.icu.text.UCharacterIterator.getText",
	"Comment": "convenience method for returning the underlying text storage as as string",
	"Method": "int getText(char[] fillIn,int offset,int getText,char[] fillIn,String getText){\r\n    char[] text = new char[getLength()];\r\n    getText(text);\r\n    return new String(text);\r\n}"
}, {
	"Path": "libcore.io.NetworkBridge.setSocketOption",
	"Comment": "java.net has its own socket options similar to the underlying unix ones. we paper over thedifferences here.",
	"Method": "void setSocketOption(FileDescriptor fd,int option,Object value){\r\n    try {\r\n        setSocketOptionErrno(fd, option, value);\r\n    } catch (ErrnoException errnoException) {\r\n        throw new SocketException(errnoException.getMessage(), errnoException);\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.CompactByteArray.getValueArray",
	"Comment": "for internal use only.do not modify the result, the behavior ofmodified results are undefined.",
	"Method": "byte[] getValueArray(){\r\n    return values;\r\n}"
}, {
	"Path": "android.icu.text.SelectFormat.applyPattern",
	"Comment": "sets the pattern used by this select format.patterns and their interpretation are specified in the class description.",
	"Method": "void applyPattern(String pattern){\r\n    this.pattern = pattern;\r\n    if (msgPattern == null) {\r\n        msgPattern = new MessagePattern();\r\n    }\r\n    try {\r\n        msgPattern.parseSelectStyle(pattern);\r\n    } catch (RuntimeException e) {\r\n        reset();\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.setMinimumIntegerDigits",
	"Comment": "sets the minimum number of digits allowed in the integer portion of a number. thisoverride limits the integer digit count to 309.",
	"Method": "void setMinimumIntegerDigits(int newValue){\r\n    super.setMinimumIntegerDigits(Math.min(newValue, DOUBLE_INTEGER_DIGITS));\r\n}"
}, {
	"Path": "android.icu.text.CharsetDetector.getDetectableCharsets",
	"Comment": "get the names of charsets that can be recognized by this charsetdetector instance.",
	"Method": "String[] getDetectableCharsets(){\r\n    List<String> csnames = new ArrayList<String>(ALL_CS_RECOGNIZERS.size());\r\n    for (int i = 0; i < ALL_CS_RECOGNIZERS.size(); i++) {\r\n        CSRecognizerInfo rcinfo = ALL_CS_RECOGNIZERS.get(i);\r\n        boolean active = (fEnabledRecognizers == null) ? rcinfo.isDefaultEnabled : fEnabledRecognizers[i];\r\n        if (active) {\r\n            csnames.add(rcinfo.recognizer.getName());\r\n        }\r\n    }\r\n    return csnames.toArray(new String[csnames.size()]);\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.initLocalZeroPaddingNumberFormat",
	"Comment": "initializes transient fields for fast simple numeric formattingcode. this method should be called whenever number format is updated.",
	"Method": "void initLocalZeroPaddingNumberFormat(){\r\n    if (numberFormat instanceof DecimalFormat) {\r\n        decDigits = ((DecimalFormat) numberFormat).getDecimalFormatSymbols().getDigits();\r\n        useLocalZeroPaddingNumberFormat = true;\r\n    } else if (numberFormat instanceof DateNumberFormat) {\r\n        decDigits = ((DateNumberFormat) numberFormat).getDigits();\r\n        useLocalZeroPaddingNumberFormat = true;\r\n    } else {\r\n        useLocalZeroPaddingNumberFormat = false;\r\n    }\r\n    if (useLocalZeroPaddingNumberFormat) {\r\n        decimalBuf = new char[DECIMAL_BUF_SIZE];\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.ULocale.getDisplayCountryInternal",
	"Comment": "displaylocaleid is canonical, localeid need not be since parsing will fix this.",
	"Method": "String getDisplayCountryInternal(ULocale locale,ULocale displayLocale){\r\n    return LocaleDisplayNames.getInstance(displayLocale).regionDisplayName(locale.getCountry());\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedBreakIterator.equals",
	"Comment": "returns true if both breakiterators are of the same class, have the samerules, and iterate over the same text.",
	"Method": "boolean equals(Object that){\r\n    if (that == null) {\r\n        return false;\r\n    }\r\n    if (this == that) {\r\n        return true;\r\n    }\r\n    try {\r\n        RuleBasedBreakIterator other = (RuleBasedBreakIterator) that;\r\n        if (fRData != other.fRData && (fRData == null || other.fRData == null)) {\r\n            return false;\r\n        }\r\n        if (fRData != null && other.fRData != null && (!fRData.fRuleSource.equals(other.fRData.fRuleSource))) {\r\n            return false;\r\n        }\r\n        if (fText == null && other.fText == null) {\r\n            return true;\r\n        }\r\n        if (fText == null || other.fText == null) {\r\n            return false;\r\n        }\r\n        return fText.equals(other.fText);\r\n    } catch (ClassCastException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.coll.FCDIterCollationIterator.previousSegment",
	"Comment": "extends the fcd text segment backward or normalizes around pos.",
	"Method": "boolean previousSegment(){\r\n    assert (state == State.ITER_CHECK_BWD);\r\n    pos = iter.getIndex();\r\n    if (s == null) {\r\n        s = new StringBuilder();\r\n    } else {\r\n        s.setLength(0);\r\n    }\r\n    int nextCC = 0;\r\n    for (; ; ) {\r\n        int c = iter.previousCodePoint();\r\n        if (c < 0) {\r\n            break;\r\n        }\r\n        int fcd16 = nfcImpl.getFCD16(c);\r\n        int trailCC = fcd16 & 0xff;\r\n        if (trailCC == 0 && s.length() != 0) {\r\n            iter.nextCodePoint();\r\n            break;\r\n        }\r\n        s.appendCodePoint(c);\r\n        if (trailCC != 0 && ((nextCC != 0 && trailCC > nextCC) || CollationFCD.isFCD16OfTibetanCompositeVowel(fcd16))) {\r\n            while (fcd16 > 0xff) {\r\n                c = iter.previousCodePoint();\r\n                if (c < 0) {\r\n                    break;\r\n                }\r\n                fcd16 = nfcImpl.getFCD16(c);\r\n                if (fcd16 == 0) {\r\n                    iter.nextCodePoint();\r\n                    break;\r\n                }\r\n                s.appendCodePoint(c);\r\n            }\r\n            s.reverse();\r\n            normalize(s);\r\n            limit = pos;\r\n            start = pos - s.length();\r\n            state = State.IN_NORM_ITER_AT_START;\r\n            pos = normalized.length();\r\n            return true;\r\n        }\r\n        nextCC = fcd16 >> 8;\r\n        if (nextCC == 0) {\r\n            break;\r\n        }\r\n    }\r\n    start = pos - s.length();\r\n    assert (pos != start);\r\n    iter.moveIndex(s.length());\r\n    state = State.ITER_IN_FCD_SEGMENT;\r\n    return true;\r\n}"
}, {
	"Path": "android.icu.text.BreakTransliterator.register",
	"Comment": "registers standard variants with the system.called bytransliterator during initialization.",
	"Method": "void register(){\r\n    Transliterator trans = new BreakTransliterator(\"Any-BreakInternal\", null);\r\n    Transliterator.registerInstance(trans, false);\r\n}"
}, {
	"Path": "android.icu.text.SimpleFormatter.formatAndAppend",
	"Comment": "formats the given values, appending to the appendto builder.",
	"Method": "StringBuilder formatAndAppend(StringBuilder appendTo,int[] offsets,CharSequence values){\r\n    return SimpleFormatterImpl.formatAndAppend(compiledPattern, appendTo, offsets, values);\r\n}"
}, {
	"Path": "android.icu.util.UResourceBundleIterator.hasNext",
	"Comment": "checks whether the given resource has another element to iterate over.",
	"Method": "boolean hasNext(){\r\n    return index < size;\r\n}"
}, {
	"Path": "android.icu.impl.duration.Period.at",
	"Comment": "constructs a period representing a duration ofcount units extending into the past.",
	"Method": "Period at(float count,TimeUnit unit,Period at){\r\n    return setTimeLimit(ETimeLimit.NOLIMIT);\r\n}"
}, {
	"Path": "android.icu.text.RelativeDateTimeFormatter.getInstance",
	"Comment": "returns a relativedatetimeformatter for a particular locale that uses a particularnumberformat object, style, and capitalization context",
	"Method": "RelativeDateTimeFormatter getInstance(RelativeDateTimeFormatter getInstance,ULocale locale,RelativeDateTimeFormatter getInstance,Locale locale,RelativeDateTimeFormatter getInstance,ULocale locale,NumberFormat nf,RelativeDateTimeFormatter getInstance,ULocale locale,NumberFormat nf,Style style,DisplayContext capitalizationContext,RelativeDateTimeFormatter getInstance,Locale locale,NumberFormat nf){\r\n    return getInstance(ULocale.forLocale(locale), nf);\r\n}"
}, {
	"Path": "android.icu.impl.coll.CollationDataBuilder.copyFrom",
	"Comment": "copies all mappings from the src builder, with modifications.this builder here must not be built yet, and should be empty.",
	"Method": "void copyFrom(CollationDataBuilder src,CEModifier modifier){\r\n    if (!isMutable()) {\r\n        throw new IllegalStateException(\"attempt to copyFrom() after build()\");\r\n    }\r\n    CopyHelper helper = new CopyHelper(src, this, modifier);\r\n    Iterator<Trie2.Range> trieIterator = src.trie.iterator();\r\n    Trie2.Range range;\r\n    while (trieIterator.hasNext() && !(range = trieIterator.next()).leadSurrogate) {\r\n        enumRangeForCopy(range.startCodePoint, range.endCodePoint, range.value, helper);\r\n    }\r\n    modified |= src.modified;\r\n}"
}, {
	"Path": "android.icu.util.VersionInfo.getVersionString",
	"Comment": "generate version string separated by dots withthe specified digit width.version digit 0after mindigits will be trimmed off.",
	"Method": "String getVersionString(int minDigits,int maxDigits){\r\n    if (minDigits < 1 || maxDigits < 1 || minDigits > 4 || maxDigits > 4 || minDigits > maxDigits) {\r\n        throw new IllegalArgumentException(\"Invalid min/maxDigits range\");\r\n    }\r\n    int[] digits = new int[4];\r\n    digits[0] = getMajor();\r\n    digits[1] = getMinor();\r\n    digits[2] = getMilli();\r\n    digits[3] = getMicro();\r\n    int numDigits = maxDigits;\r\n    while (numDigits > minDigits) {\r\n        if (digits[numDigits - 1] != 0) {\r\n            break;\r\n        }\r\n        numDigits--;\r\n    }\r\n    StringBuilder verStr = new StringBuilder(7);\r\n    verStr.append(digits[0]);\r\n    for (int i = 1; i < numDigits; i++) {\r\n        verStr.append(\".\");\r\n        verStr.append(digits[i]);\r\n    }\r\n    return verStr.toString();\r\n}"
}, {
	"Path": "android.icu.impl.USerializedSet.contains",
	"Comment": "returns true if the given userializedset contains the givencharacter.",
	"Method": "boolean contains(int c){\r\n    if (c > 0x10ffff) {\r\n        return false;\r\n    }\r\n    if (c <= 0xffff) {\r\n        int i;\r\n        for (i = 0; i < bmpLength && (char) c >= array[i]; ++i) {\r\n        }\r\n        return ((i & 1) != 0);\r\n    } else {\r\n        int i;\r\n        char high = (char) (c >> 16), low = (char) c;\r\n        for (i = bmpLength; i < length && (high > array[i] || (high == array[i] && low >= array[i + 1])); i += 2) {\r\n        }\r\n        return (((i + bmpLength) & 2) != 0);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.Normalizer.decompose",
	"Comment": "decompose a string.the string will be decomposed to according to the specified mode.",
	"Method": "String decompose(String str,boolean compat,String decompose,String str,boolean compat,int options,int decompose,char[] source,char[] target,boolean compat,int options,int decompose,char[] src,int srcStart,int srcLimit,char[] dest,int destStart,int destLimit,boolean compat,int options){\r\n    CharBuffer srcBuffer = CharBuffer.wrap(src, srcStart, srcLimit - srcStart);\r\n    CharsAppendable app = new CharsAppendable(dest, destStart, destLimit);\r\n    getDecomposeNormalizer2(compat, options).normalize(srcBuffer, app);\r\n    return app.length();\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedBreakIterator.dump",
	"Comment": "dump the contents of the state table and character classes for this break iterator.for debugging only.",
	"Method": "void dump(java.io.PrintStream out){\r\n    if (out == null) {\r\n        out = System.out;\r\n    }\r\n    this.fRData.dump(out);\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.parse",
	"Comment": "parses the given text as either a number or a currencyamount.",
	"Method": "Number parse(String text,ParsePosition parsePosition,Object parse,String text,ParsePosition parsePosition,Currency[] currency){\r\n    int backup;\r\n    int i = backup = parsePosition.getIndex();\r\n    if (formatWidth > 0 && (padPosition == PAD_BEFORE_PREFIX || padPosition == PAD_AFTER_PREFIX)) {\r\n        i = skipPadding(text, i);\r\n    }\r\n    if (text.regionMatches(i, symbols.getNaN(), 0, symbols.getNaN().length())) {\r\n        i += symbols.getNaN().length();\r\n        if (formatWidth > 0 && (padPosition == PAD_BEFORE_SUFFIX || padPosition == PAD_AFTER_SUFFIX)) {\r\n            i = skipPadding(text, i);\r\n        }\r\n        parsePosition.setIndex(i);\r\n        return new Double(Double.NaN);\r\n    }\r\n    i = backup;\r\n    boolean[] status = new boolean[STATUS_LENGTH];\r\n    if (currencySignCount != CURRENCY_SIGN_COUNT_ZERO) {\r\n        if (!parseForCurrency(text, parsePosition, currency, status)) {\r\n            return null;\r\n        }\r\n    } else if (currency != null) {\r\n        return null;\r\n    } else {\r\n        if (!subparse(text, parsePosition, digitList, status, currency, negPrefixPattern, negSuffixPattern, posPrefixPattern, posSuffixPattern, false, Currency.SYMBOL_NAME)) {\r\n            parsePosition.setIndex(backup);\r\n            return null;\r\n        }\r\n    }\r\n    Number n = null;\r\n    if (status[STATUS_INFINITE]) {\r\n        n = new Double(status[STATUS_POSITIVE] ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY);\r\n    } else if (status[STATUS_UNDERFLOW]) {\r\n        n = status[STATUS_POSITIVE] ? new Double(\"0.0\") : new Double(\"-0.0\");\r\n    } else if (!status[STATUS_POSITIVE] && digitList.isZero()) {\r\n        n = new Double(\"-0.0\");\r\n    } else {\r\n        int mult = multiplier;\r\n        while (mult % 10 == 0) {\r\n            --digitList.decimalAt;\r\n            mult /= 10;\r\n        }\r\n        if (!parseBigDecimal && mult == 1 && digitList.isIntegral()) {\r\n            if (digitList.decimalAt < 12) {\r\n                long l = 0;\r\n                if (digitList.count > 0) {\r\n                    int nx = 0;\r\n                    while (nx < digitList.count) {\r\n                        l = l * 10 + (char) digitList.digits[nx++] - '0';\r\n                    }\r\n                    while (nx++ < digitList.decimalAt) {\r\n                        l *= 10;\r\n                    }\r\n                    if (!status[STATUS_POSITIVE]) {\r\n                        l = -l;\r\n                    }\r\n                }\r\n                n = Long.valueOf(l);\r\n            } else {\r\n                BigInteger big = digitList.getBigInteger(status[STATUS_POSITIVE]);\r\n                n = (big.bitLength() < 64) ? (Number) Long.valueOf(big.longValue()) : (Number) big;\r\n            }\r\n        } else {\r\n            BigDecimal big = digitList.getBigDecimalICU(status[STATUS_POSITIVE]);\r\n            n = big;\r\n            if (mult != 1) {\r\n                n = big.divide(BigDecimal.valueOf(mult), mathContext);\r\n            }\r\n        }\r\n    }\r\n    return (currency != null) ? (Object) new CurrencyAmount(n, currency[0]) : (Object) n;\r\n}"
}, {
	"Path": "android.icu.util.SimpleTimeZone.inDaylightTime",
	"Comment": "overrides timezonequeries if the give date is in daylight saving time.",
	"Method": "boolean inDaylightTime(Date date){\r\n    GregorianCalendar gc = new GregorianCalendar(this);\r\n    gc.setTime(date);\r\n    return gc.inDaylightTime();\r\n}"
}, {
	"Path": "android.icu.impl.coll.CollationData.getSingleCE",
	"Comment": "returns the single ce that c maps to.throws unsupportedoperationexception if c does not map to a single ce.",
	"Method": "long getSingleCE(int c){\r\n    CollationData d;\r\n    int ce32 = getCE32(c);\r\n    if (ce32 == Collation.FALLBACK_CE32) {\r\n        d = base;\r\n        ce32 = base.getCE32(c);\r\n    } else {\r\n        d = this;\r\n    }\r\n    while (Collation.isSpecialCE32(ce32)) {\r\n        switch(Collation.tagFromCE32(ce32)) {\r\n            case Collation.LATIN_EXPANSION_TAG:\r\n            case Collation.BUILDER_DATA_TAG:\r\n            case Collation.PREFIX_TAG:\r\n            case Collation.CONTRACTION_TAG:\r\n            case Collation.HANGUL_TAG:\r\n            case Collation.LEAD_SURROGATE_TAG:\r\n                throw new UnsupportedOperationException(String.format(\"there is not exactly one collation element for U+X (CE32 0xx)\", c, ce32));\r\n            case Collation.FALLBACK_TAG:\r\n            case Collation.RESERVED_TAG_3:\r\n                throw new AssertionError(String.format(\"unexpected CE32 tag for U+X (CE32 0xx)\", c, ce32));\r\n            case Collation.LONG_PRIMARY_TAG:\r\n                return Collation.ceFromLongPrimaryCE32(ce32);\r\n            case Collation.LONG_SECONDARY_TAG:\r\n                return Collation.ceFromLongSecondaryCE32(ce32);\r\n            case Collation.EXPANSION32_TAG:\r\n                if (Collation.lengthFromCE32(ce32) == 1) {\r\n                    ce32 = d.ce32s[Collation.indexFromCE32(ce32)];\r\n                    break;\r\n                } else {\r\n                    throw new UnsupportedOperationException(String.format(\"there is not exactly one collation element for U+X (CE32 0xx)\", c, ce32));\r\n                }\r\n            case Collation.EXPANSION_TAG:\r\n                {\r\n                    if (Collation.lengthFromCE32(ce32) == 1) {\r\n                        return d.ces[Collation.indexFromCE32(ce32)];\r\n                    } else {\r\n                        throw new UnsupportedOperationException(String.format(\"there is not exactly one collation element for U+X (CE32 0xx)\", c, ce32));\r\n                    }\r\n                }\r\n            case Collation.DIGIT_TAG:\r\n                ce32 = d.ce32s[Collation.indexFromCE32(ce32)];\r\n                break;\r\n            case Collation.U0000_TAG:\r\n                assert (c == 0);\r\n                ce32 = d.ce32s[0];\r\n                break;\r\n            case Collation.OFFSET_TAG:\r\n                return d.getCEFromOffsetCE32(c, ce32);\r\n            case Collation.IMPLICIT_TAG:\r\n                return Collation.unassignedCEFromCodePoint(c);\r\n        }\r\n    }\r\n    return Collation.ceFromSimpleCE32(ce32);\r\n}"
}, {
	"Path": "android.icu.util.GregorianCalendar.getGregorianChange",
	"Comment": "gets the gregorian calendar change date.this is the point when theswitch from julian dates to gregorian dates occurred. default isoctober 15, 1582. previous to this, dates will be in the juliancalendar.",
	"Method": "Date getGregorianChange(){\r\n    return new Date(gregorianCutover);\r\n}"
}, {
	"Path": "tests.security.spec.ECFieldF2mTest.testIsStatePreserved01",
	"Comment": "tests that object state is preserved against modificationsthrough array reference passed to the constructor.",
	"Method": "void testIsStatePreserved01(){\r\n    int[] a = new int[] { 367 };\r\n    int[] aCopy = a.clone();\r\n    ECFieldF2m f = new ECFieldF2m(1999, aCopy);\r\n    aCopy[0] = 5;\r\n    assertTrue(Arrays.equals(a, f.getMidTermsOfReductionPolynomial()));\r\n}"
}, {
	"Path": "android.icu.util.TimeZone.getDefault",
	"Comment": "gets the default timezone for this host.the source of the default timezonemay vary with implementation.",
	"Method": "TimeZone getDefault(){\r\n    TimeZone result = defaultZone;\r\n    if (result == null) {\r\n        synchronized (java.util.TimeZone.class) {\r\n            synchronized (TimeZone.class) {\r\n                result = defaultZone;\r\n                if (result == null) {\r\n                    if (TZ_IMPL == TIMEZONE_JDK) {\r\n                        result = new JavaTimeZone();\r\n                    } else {\r\n                        java.util.TimeZone temp = java.util.TimeZone.getDefault();\r\n                        result = getFrozenTimeZone(temp.getID());\r\n                    }\r\n                    defaultZone = result;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result.cloneAsThawed();\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.applyIntPropertyValue",
	"Comment": "modifies this set to contain those code points which have thegiven value for the given binary or enumerated property, asreturned by ucharacter.getintpropertyvalue.prior contents ofthis set are lost.",
	"Method": "UnicodeSet applyIntPropertyValue(int prop,int value){\r\n    checkFrozen();\r\n    if (prop == UProperty.GENERAL_CATEGORY_MASK) {\r\n        applyFilter(new GeneralCategoryMaskFilter(value), UCharacterProperty.SRC_CHAR);\r\n    } else if (prop == UProperty.SCRIPT_EXTENSIONS) {\r\n        applyFilter(new ScriptExtensionsFilter(value), UCharacterProperty.SRC_PROPSVEC);\r\n    } else {\r\n        applyFilter(new IntPropertyFilter(prop, value), UCharacterProperty.INSTANCE.getSource(prop));\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.impl.ICUBinary.getVersionInfoFromCompactInt",
	"Comment": "returns a versioninfo for the bytes in the compact version integer.",
	"Method": "VersionInfo getVersionInfoFromCompactInt(int version){\r\n    return VersionInfo.getInstance(version >>> 24, (version >> 16) & 0xff, (version >> 8) & 0xff, version & 0xff);\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneGenericNames.findBestMatch",
	"Comment": "returns the best match of time zone display name for the specified types in thegiven text at the given offset.",
	"Method": "GenericMatchInfo findBestMatch(String text,int start,EnumSet<GenericNameType> genericTypes){\r\n    if (text == null || text.length() == 0 || start < 0 || start >= text.length()) {\r\n        throw new IllegalArgumentException(\"bad input text or range\");\r\n    }\r\n    GenericMatchInfo bestMatch = null;\r\n    Collection<MatchInfo> tznamesMatches = findTimeZoneNames(text, start, genericTypes);\r\n    if (tznamesMatches != null) {\r\n        MatchInfo longestMatch = null;\r\n        for (MatchInfo match : tznamesMatches) {\r\n            if (longestMatch == null || match.matchLength() > longestMatch.matchLength()) {\r\n                longestMatch = match;\r\n            }\r\n        }\r\n        if (longestMatch != null) {\r\n            bestMatch = createGenericMatchInfo(longestMatch);\r\n            if (bestMatch.matchLength() == (text.length() - start)) {\r\n                if (bestMatch.timeType != TimeType.STANDARD) {\r\n                    return bestMatch;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Collection<GenericMatchInfo> localMatches = findLocal(text, start, genericTypes);\r\n    if (localMatches != null) {\r\n        for (GenericMatchInfo match : localMatches) {\r\n            if (bestMatch == null || match.matchLength() >= bestMatch.matchLength()) {\r\n                bestMatch = match;\r\n            }\r\n        }\r\n    }\r\n    return bestMatch;\r\n}"
}, {
	"Path": "android.icu.lang.UCharacterNameIterator.next",
	"Comment": "gets the next result for this iteration and returns true if we are not at the end of the iteration, false otherwise. if the return boolean is a false, the contents of elements will not be updated.",
	"Method": "boolean next(ValueIterator.Element element){\r\n    if (m_current_ >= m_limit_) {\r\n        return false;\r\n    }\r\n    if (m_choice_ == UCharacterNameChoice.UNICODE_CHAR_NAME || m_choice_ == UCharacterNameChoice.EXTENDED_CHAR_NAME) {\r\n        int length = m_name_.getAlgorithmLength();\r\n        if (m_algorithmIndex_ < length) {\r\n            while (m_algorithmIndex_ < length) {\r\n                if (m_algorithmIndex_ < 0 || m_name_.getAlgorithmEnd(m_algorithmIndex_) < m_current_) {\r\n                    m_algorithmIndex_++;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n            if (m_algorithmIndex_ < length) {\r\n                int start = m_name_.getAlgorithmStart(m_algorithmIndex_);\r\n                if (m_current_ < start) {\r\n                    int end = start;\r\n                    if (m_limit_ <= start) {\r\n                        end = m_limit_;\r\n                    }\r\n                    if (!iterateGroup(element, end)) {\r\n                        m_current_++;\r\n                        return true;\r\n                    }\r\n                }\r\n                if (m_current_ >= m_limit_) {\r\n                    return false;\r\n                }\r\n                element.integer = m_current_;\r\n                element.value = m_name_.getAlgorithmName(m_algorithmIndex_, m_current_);\r\n                m_groupIndex_ = -1;\r\n                m_current_++;\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    if (!iterateGroup(element, m_limit_)) {\r\n        m_current_++;\r\n        return true;\r\n    } else if (m_choice_ == UCharacterNameChoice.EXTENDED_CHAR_NAME) {\r\n        if (!iterateExtended(element, m_limit_)) {\r\n            m_current_++;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "android.icu.util.Calendar.isGregorianLeapYear",
	"Comment": "determines if the given year is a leap year. returns true if thegiven year is a leap year.",
	"Method": "boolean isGregorianLeapYear(int year){\r\n    return (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0));\r\n}"
}, {
	"Path": "android.icu.util.TimeArrayTimeZoneRule.toString",
	"Comment": "returns a string representation of this timearraytimezonerule object.this method is used for debugging purpose only.the string representation can be changedin future version of icu without any notice.",
	"Method": "String toString(){\r\n    StringBuilder buf = new StringBuilder();\r\n    buf.append(super.toString());\r\n    buf.append(\", timeType=\");\r\n    buf.append(timeType);\r\n    buf.append(\", startTimes=[\");\r\n    for (int i = 0; i < startTimes.length; i++) {\r\n        if (i != 0) {\r\n            buf.append(\", \");\r\n        }\r\n        buf.append(Long.toString(startTimes[i]));\r\n    }\r\n    buf.append(\"]\");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "android.icu.impl.ICUNotifier.notifyChanged",
	"Comment": "queue a notification on the notification thread for the currentlisteners.when the thread unqueues the notification, notifylisteneris called on each listener from the notification thread.",
	"Method": "void notifyChanged(){\r\n    if (listeners != null) {\r\n        synchronized (notifyLock) {\r\n            if (listeners != null) {\r\n                if (notifyThread == null) {\r\n                    notifyThread = new NotifyThread(this);\r\n                    notifyThread.setDaemon(true);\r\n                    notifyThread.start();\r\n                }\r\n                notifyThread.queue(listeners.toArray(new EventListener[listeners.size()]));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.IBMCalendarTest.TestBuddhist",
	"Comment": "verify that buddhistcalendar shifts years to buddhist era but otherwisebehaves like gregoriancalendar.",
	"Method": "void TestBuddhist(){\r\n    quasiGregorianTest(new BuddhistCalendar(), new int[] { 0, 2542, 1999, Calendar.JUNE, 4 });\r\n}"
}, {
	"Path": "android.icu.impl.USerializedSet.getRange",
	"Comment": "returns a range of characters contained in the given serializedset.",
	"Method": "boolean getRange(int rangeIndex,int[] range){\r\n    if (rangeIndex < 0) {\r\n        return false;\r\n    }\r\n    if (array == null) {\r\n        array = new char[8];\r\n    }\r\n    if (range == null || range.length < 2) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    rangeIndex *= 2;\r\n    if (rangeIndex < bmpLength) {\r\n        range[0] = array[rangeIndex++];\r\n        if (rangeIndex < bmpLength) {\r\n            range[1] = array[rangeIndex] - 1;\r\n        } else if (rangeIndex < length) {\r\n            range[1] = ((((int) array[rangeIndex]) << 16) | array[rangeIndex + 1]) - 1;\r\n        } else {\r\n            range[1] = 0x10ffff;\r\n        }\r\n        return true;\r\n    } else {\r\n        rangeIndex -= bmpLength;\r\n        rangeIndex *= 2;\r\n        int suppLength = length - bmpLength;\r\n        if (rangeIndex < suppLength) {\r\n            int offset = arrayOffset + bmpLength;\r\n            range[0] = (((int) array[offset + rangeIndex]) << 16) | array[offset + rangeIndex + 1];\r\n            rangeIndex += 2;\r\n            if (rangeIndex < suppLength) {\r\n                range[1] = ((((int) array[offset + rangeIndex]) << 16) | array[offset + rangeIndex + 1]) - 1;\r\n            } else {\r\n                range[1] = 0x10ffff;\r\n            }\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedNumberFormat.setDecimalFormatSymbols",
	"Comment": "sets the decimal format symbols used by this formatter. the formatter uses a copy of theprovided symbols.",
	"Method": "void setDecimalFormatSymbols(DecimalFormatSymbols newSymbols){\r\n    if (newSymbols != null) {\r\n        decimalFormatSymbols = (DecimalFormatSymbols) newSymbols.clone();\r\n        if (decimalFormat != null) {\r\n            decimalFormat.setDecimalFormatSymbols(decimalFormatSymbols);\r\n        }\r\n        if (defaultInfinityRule != null) {\r\n            defaultInfinityRule = null;\r\n            getDefaultInfinityRule();\r\n        }\r\n        if (defaultNaNRule != null) {\r\n            defaultNaNRule = null;\r\n            getDefaultNaNRule();\r\n        }\r\n        for (NFRuleSet ruleSet : ruleSets) {\r\n            ruleSet.setDecimalFormatSymbols(decimalFormatSymbols);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.LocaleIDParser.isTerminatorOrIDSeparator",
	"Comment": "returns true if the character is a terminator or id separator.",
	"Method": "boolean isTerminatorOrIDSeparator(char c){\r\n    return c == UNDERSCORE || c == HYPHEN || isTerminator(c);\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedCollator.getDecomposition",
	"Comment": "returns the decomposition mode of this collator. the decomposition modedetermines how unicode composed characters are handled.see the collator class description for more details.",
	"Method": "int getDecomposition(){\r\n    return (settings.readOnly().options & CollationSettings.CHECK_FCD) != 0 ? CANONICAL_DECOMPOSITION : NO_DECOMPOSITION;\r\n}"
}, {
	"Path": "libcore.net.MimeUtils.hasExtension",
	"Comment": "returns true if the given extension has a registered mime type.",
	"Method": "boolean hasExtension(String extension){\r\n    if (extension == null || extension.isEmpty()) {\r\n        return false;\r\n    }\r\n    return extensionToMimeTypeMap.containsKey(extension);\r\n}"
}, {
	"Path": "android.icu.impl.LocaleIDParser.skipLanguage",
	"Comment": "advance index past language.index must be at 0 when this is called.indexis left at a terminator or id separator.",
	"Method": "void skipLanguage(){\r\n    if (haveExperimentalLanguagePrefix()) {\r\n        index = 2;\r\n    }\r\n    skipUntilTerminatorOrIDSeparator();\r\n}"
}, {
	"Path": "android.icu.impl.IntTrie.getSurrogateOffset",
	"Comment": "gets the offset to the data which the surrogate pair points to.",
	"Method": "int getSurrogateOffset(char lead,char trail){\r\n    if (m_dataManipulate_ == null) {\r\n        throw new NullPointerException(\"The field DataManipulate in this Trie is null\");\r\n    }\r\n    int offset = m_dataManipulate_.getFoldingOffset(getLeadValue(lead));\r\n    if (offset > 0) {\r\n        return getRawOffset(offset, (char) (trail & SURROGATE_MASK_));\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "android.icu.text.FunctionReplacer.addReplacementSetTo",
	"Comment": "union the set of all characters that may output by this objectinto the given set.",
	"Method": "void addReplacementSetTo(UnicodeSet toUnionTo){\r\n    toUnionTo.addAll(translit.getTargetSet());\r\n}"
}, {
	"Path": "android.icu.text.CurrencyMetaInfo.getInstance",
	"Comment": "returns the unique instance of the currency meta info, or null ifnosubstitute is true and there is no data to support this api.",
	"Method": "CurrencyMetaInfo getInstance(CurrencyMetaInfo getInstance,boolean noSubstitute){\r\n    return hasData ? impl : null;\r\n}"
}, {
	"Path": "android.icu.text.Bidi.DirPropFlag",
	"Comment": "sometimes, bit values are more appropriateto deal with directionality properties.abbreviations in these method names refer to namesused in the bidi algorithm.",
	"Method": "int DirPropFlag(byte dir){\r\n    return (1 << dir);\r\n}"
}, {
	"Path": "org.apache.harmony.xml.dom.ElementImpl.getElementById",
	"Comment": "this implementation walks the entire document looking for an elementwith the given id attribute. we should consider adding an index to speednavigation of large documents.",
	"Method": "Element getElementById(String name){\r\n    for (Attr attr : attributes) {\r\n        if (attr.isId() && name.equals(attr.getValue())) {\r\n            return this;\r\n        }\r\n    }\r\n    if (name.equals(getAttribute(\"id\"))) {\r\n        return this;\r\n    }\r\n    for (NodeImpl node : children) {\r\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\r\n            Element element = ((ElementImpl) node).getElementById(name);\r\n            if (element != null) {\r\n                return element;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "dalvik.system.JniTest.testPassingObjectReferences",
	"Comment": "test passing object references as arguments to a native method",
	"Method": "void testPassingObjectReferences(){\r\n    final Object[] literals = { \"Bradshaw\", \"Isherwood\", \"Oldknow\", \"Mallet\", JniTest.class, null, Integer.valueOf(0) };\r\n    final Object[] a = new Object[16];\r\n    for (Object literal : literals) {\r\n        for (int i = 0; i < 16; i++) {\r\n            a[i] = literal;\r\n        }\r\n        for (int i = 0; i < 16; i++) {\r\n            assertEquals(a[i], returnObjectArgFrom16(i, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]));\r\n        }\r\n    }\r\n    for (int j = 0; j < literals.length; j++) {\r\n        for (int i = 0; i < 16; i++) {\r\n            a[i] = literals[(i + j) % literals.length];\r\n        }\r\n        for (int i = 0; i < 16; i++) {\r\n            assertEquals(a[i], returnObjectArgFrom16(i, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.Calendar.getAvailableLocales",
	"Comment": "returns the list of locales for which calendars are installed.",
	"Method": "Locale[] getAvailableLocales(){\r\n    return ICUResourceBundle.getAvailableLocales();\r\n}"
}, {
	"Path": "android.icu.impl.duration.BasicPeriodFormatterFactory.getDefault",
	"Comment": "return the default rdf factory as a basicperiodformatterfactory.",
	"Method": "BasicPeriodFormatterFactory getDefault(){\r\n    return (BasicPeriodFormatterFactory) BasicPeriodFormatterService.getInstance().newPeriodFormatterFactory();\r\n}"
}, {
	"Path": "android.icu.impl.duration.Period.and",
	"Comment": "set the given unit to have the given count.marks theunit as having been set.this can be used to setmultiple units, or to reset a unit to have a new count.this does not add the count to an existing countfor this unit.",
	"Method": "Period and(float count,TimeUnit unit){\r\n    checkCount(count);\r\n    return setTimeUnitValue(unit, count);\r\n}"
}, {
	"Path": "android.icu.text.UTF16.moveCodePointOffset",
	"Comment": "shifts offset16 by the argument number of codepoints within a subarray.",
	"Method": "int moveCodePointOffset(String source,int offset16,int shift32,int moveCodePointOffset,StringBuffer source,int offset16,int shift32,int moveCodePointOffset,char source,int start,int limit,int offset16,int shift32){\r\n    int size = source.length;\r\n    int count;\r\n    char ch;\r\n    int result = offset16 + start;\r\n    if (start < 0 || limit < start) {\r\n        throw new StringIndexOutOfBoundsException(start);\r\n    }\r\n    if (limit > size) {\r\n        throw new StringIndexOutOfBoundsException(limit);\r\n    }\r\n    if (offset16 < 0 || result > limit) {\r\n        throw new StringIndexOutOfBoundsException(offset16);\r\n    }\r\n    if (shift32 > 0) {\r\n        if (shift32 + result > size) {\r\n            throw new StringIndexOutOfBoundsException(result);\r\n        }\r\n        count = shift32;\r\n        while (result < limit && count > 0) {\r\n            ch = source[result];\r\n            if (isLeadSurrogate(ch) && (result + 1 < limit) && isTrailSurrogate(source[result + 1])) {\r\n                result++;\r\n            }\r\n            count--;\r\n            result++;\r\n        }\r\n    } else {\r\n        if (result + shift32 < start) {\r\n            throw new StringIndexOutOfBoundsException(result);\r\n        }\r\n        for (count = -shift32; count > 0; count--) {\r\n            result--;\r\n            if (result < start) {\r\n                break;\r\n            }\r\n            ch = source[result];\r\n            if (isTrailSurrogate(ch) && result > start && isLeadSurrogate(source[result - 1])) {\r\n                result--;\r\n            }\r\n        }\r\n    }\r\n    if (count != 0) {\r\n        throw new StringIndexOutOfBoundsException(shift32);\r\n    }\r\n    result -= start;\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.util.VTimeZone.writeZonePropsByDOM",
	"Comment": "write start times defined by a dom rule using vtimezone rrule",
	"Method": "void writeZonePropsByDOM(Writer writer,boolean isDst,String tzname,int fromOffset,int toOffset,int month,int dayOfMonth,long startTime,long untilTime){\r\n    beginZoneProps(writer, isDst, tzname, fromOffset, toOffset, startTime);\r\n    beginRRULE(writer, month);\r\n    writer.write(ICAL_BYMONTHDAY);\r\n    writer.write(EQUALS_SIGN);\r\n    writer.write(Integer.toString(dayOfMonth));\r\n    if (untilTime != MAX_TIME) {\r\n        appendUNTIL(writer, getDateTimeString(untilTime + fromOffset));\r\n    }\r\n    writer.write(NEWLINE);\r\n    endZoneProps(writer, isDst);\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneNamesImpl.loadTimeZoneNames",
	"Comment": "returns a set of names for the given time zone id. this method loadsthe set of names into the internal map and trie for future references.",
	"Method": "ZNames loadTimeZoneNames(String tzID){\r\n    ZNames tznames = _tzNamesMap.get(tzID);\r\n    if (tznames == null) {\r\n        ZNamesLoader loader = new ZNamesLoader();\r\n        loader.loadTimeZone(_zoneStrings, tzID);\r\n        tznames = ZNames.createTimeZoneAndPutInCache(_tzNamesMap, loader.getNames(), tzID);\r\n    }\r\n    return tznames;\r\n}"
}, {
	"Path": "android.icu.text.DigitList.setBigDecimalDigits",
	"Comment": "internal method that sets this digit list to represent thegiven value.the value is given as a string of the formatreturned by bigdecimal.",
	"Method": "void setBigDecimalDigits(String stringDigits,int maximumDigits,boolean fixedPoint){\r\n    didRound = false;\r\n    set(stringDigits, stringDigits.length());\r\n    round(fixedPoint ? (maximumDigits + decimalAt) : maximumDigits == 0 ? -1 : maximumDigits);\r\n}"
}, {
	"Path": "android.icu.text.MessageFormat.writeObject",
	"Comment": "custom serialization, new in icu 4.8.we do not want to use default serialization because we only have a smallamount of persistent state which is better expressed explicitlyrather than via writing field objects.",
	"Method": "void writeObject(java.io.ObjectOutputStream out){\r\n    out.defaultWriteObject();\r\n    out.writeObject(ulocale.toLanguageTag());\r\n    if (msgPattern == null) {\r\n        msgPattern = new MessagePattern();\r\n    }\r\n    out.writeObject(msgPattern.getApostropheMode());\r\n    out.writeObject(msgPattern.getPatternString());\r\n    if (customFormatArgStarts == null || customFormatArgStarts.isEmpty()) {\r\n        out.writeInt(0);\r\n    } else {\r\n        out.writeInt(customFormatArgStarts.size());\r\n        int formatIndex = 0;\r\n        for (int partIndex = 0; (partIndex = nextTopLevelArgStart(partIndex)) >= 0; ) {\r\n            if (customFormatArgStarts.contains(partIndex)) {\r\n                out.writeInt(formatIndex);\r\n                out.writeObject(cachedFormatters.get(partIndex));\r\n            }\r\n            ++formatIndex;\r\n        }\r\n    }\r\n    out.writeInt(0);\r\n}"
}, {
	"Path": "android.icu.util.Currency.getAvailableLocales",
	"Comment": "return an array of the locales for which a currencyis defined.",
	"Method": "Locale[] getAvailableLocales(Locale[] getAvailableLocales){\r\n    if (shim == null) {\r\n        return ICUResourceBundle.getAvailableLocales();\r\n    } else {\r\n        return shim.getAvailableLocales();\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.SearchIterator.reset",
	"Comment": "resets the iteration. search will begin at the start of the text string if a forward iteration is initiated before a backwards iteration. otherwise if a backwards iteration is initiated before a forwards iteration, the search will begin at the end of the text string.",
	"Method": "void reset(){\r\n    setMatchNotFound();\r\n    setIndex(search_.beginIndex());\r\n    search_.isOverlap_ = false;\r\n    search_.isCanonicalMatch_ = false;\r\n    search_.elementComparisonType_ = ElementComparisonType.STANDARD_ELEMENT_COMPARISON;\r\n    search_.isForwardSearching_ = true;\r\n    search_.reset_ = true;\r\n}"
}, {
	"Path": "android.icu.text.StringSearch.isBreakBoundary",
	"Comment": "returns true if index is on a break boundary. if the ustringsearchhas an external break iterator, test using that, otherwise testusing the internal character break iterator.",
	"Method": "boolean isBreakBoundary(int index){\r\n    BreakIterator breakiterator = search_.breakIter();\r\n    if (breakiterator == null) {\r\n        breakiterator = search_.internalBreakIter_;\r\n    }\r\n    return (breakiterator != null && breakiterator.isBoundary(index));\r\n}"
}, {
	"Path": "android.icu.util.StringTokenizer.hasMoreElements",
	"Comment": "returns the same value as the hasmoretokens method. it exists so that this class can implement the enumeration interface.",
	"Method": "boolean hasMoreElements(){\r\n    return hasMoreTokens();\r\n}"
}, {
	"Path": "org.apache.harmony.xml.dom.TextImpl.nextTextNode",
	"Comment": "returns the next sibling node if it exists and it is text or cdata.otherwise returns null.",
	"Method": "TextImpl nextTextNode(){\r\n    Node nextSibling = getNextSibling();\r\n    if (nextSibling == null) {\r\n        return null;\r\n    }\r\n    short nodeType = nextSibling.getNodeType();\r\n    return nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE ? (TextImpl) nextSibling : null;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.multiply",
	"Comment": "number. if there is no multiplier, returns the number passed in unchanged.",
	"Method": "double multiply(double number){\r\n    if (multiplier != 1) {\r\n        return number * multiplier;\r\n    }\r\n    return number;\r\n}"
}, {
	"Path": "android.icu.impl.CharTrie.getSurrogateOffset",
	"Comment": "gets the offset to the data which the surrogate pair points to.",
	"Method": "int getSurrogateOffset(char lead,char trail){\r\n    if (m_dataManipulate_ == null) {\r\n        throw new NullPointerException(\"The field DataManipulate in this Trie is null\");\r\n    }\r\n    int offset = m_dataManipulate_.getFoldingOffset(getLeadValue(lead));\r\n    if (offset > 0) {\r\n        return getRawOffset(offset, (char) (trail & SURROGATE_MASK_));\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "android.icu.text.StringMatcher.resetMatch",
	"Comment": "remove any match data.this must be called before performing aset of matches with this segment.",
	"Method": "void resetMatch(){\r\n    matchStart = matchLimit = -1;\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.add",
	"Comment": "adds the specified character to this set if it is not alreadypresent.if this set already contains the specified character,the call leaves this set unchanged.",
	"Method": "UnicodeSet add(int start,int end,UnicodeSet add,int c,UnicodeSet add,CharSequence s,UnicodeSet add,Iterable<?> source,UnicodeSet add,int[] other,int otherLen,int polarity){\r\n    ensureBufferCapacity(len + otherLen);\r\n    int i = 0, j = 0, k = 0;\r\n    int a = list[i++];\r\n    int b = other[j++];\r\n    main: while (true) {\r\n        switch(polarity) {\r\n            case 0:\r\n                if (a < b) {\r\n                    if (k > 0 && a <= buffer[k - 1]) {\r\n                        a = max(list[i], buffer[--k]);\r\n                    } else {\r\n                        buffer[k++] = a;\r\n                        a = list[i];\r\n                    }\r\n                    i++;\r\n                    polarity ^= 1;\r\n                } else if (b < a) {\r\n                    if (k > 0 && b <= buffer[k - 1]) {\r\n                        b = max(other[j], buffer[--k]);\r\n                    } else {\r\n                        buffer[k++] = b;\r\n                        b = other[j];\r\n                    }\r\n                    j++;\r\n                    polarity ^= 2;\r\n                } else {\r\n                    if (a == HIGH)\r\n                        break main;\r\n                    if (k > 0 && a <= buffer[k - 1]) {\r\n                        a = max(list[i], buffer[--k]);\r\n                    } else {\r\n                        buffer[k++] = a;\r\n                        a = list[i];\r\n                    }\r\n                    i++;\r\n                    polarity ^= 1;\r\n                    b = other[j++];\r\n                    polarity ^= 2;\r\n                }\r\n                break;\r\n            case 3:\r\n                if (b <= a) {\r\n                    if (a == HIGH)\r\n                        break main;\r\n                    buffer[k++] = a;\r\n                } else {\r\n                    if (b == HIGH)\r\n                        break main;\r\n                    buffer[k++] = b;\r\n                }\r\n                a = list[i++];\r\n                polarity ^= 1;\r\n                b = other[j++];\r\n                polarity ^= 2;\r\n                break;\r\n            case 1:\r\n                if (a < b) {\r\n                    buffer[k++] = a;\r\n                    a = list[i++];\r\n                    polarity ^= 1;\r\n                } else if (b < a) {\r\n                    b = other[j++];\r\n                    polarity ^= 2;\r\n                } else {\r\n                    if (a == HIGH)\r\n                        break main;\r\n                    a = list[i++];\r\n                    polarity ^= 1;\r\n                    b = other[j++];\r\n                    polarity ^= 2;\r\n                }\r\n                break;\r\n            case 2:\r\n                if (b < a) {\r\n                    buffer[k++] = b;\r\n                    b = other[j++];\r\n                    polarity ^= 2;\r\n                } else if (a < b) {\r\n                    a = list[i++];\r\n                    polarity ^= 1;\r\n                } else {\r\n                    if (a == HIGH)\r\n                        break main;\r\n                    a = list[i++];\r\n                    polarity ^= 1;\r\n                    b = other[j++];\r\n                    polarity ^= 2;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    buffer[k++] = HIGH;\r\n    len = k;\r\n    int[] temp = list;\r\n    list = buffer;\r\n    buffer = temp;\r\n    pat = null;\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.util.UResourceBundle.handleKeySet",
	"Comment": "returns a set of the keys contained only in this resourcebundle.this does not include further keys from parent bundles.",
	"Method": "Set<String> handleKeySet(){\r\n    return Collections.emptySet();\r\n}"
}, {
	"Path": "android.icu.text.SimpleFormatter.formatAndReplace",
	"Comment": "formats the given values, replacing the contents of the result builder.may optimize by actually appending to the result if it is the same objectas the value corresponding to the initial argument in the pattern.",
	"Method": "StringBuilder formatAndReplace(StringBuilder result,int[] offsets,CharSequence values){\r\n    return SimpleFormatterImpl.formatAndReplace(compiledPattern, result, offsets, values);\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.EthiopicTest.TestCases",
	"Comment": "a huge list of test cases to make sure that computetime and computefieldswork properly for a wide range of data in the civil calendar.",
	"Method": "void TestCases(){\r\n    final TestCase[] tests = { new TestCase(2401442.5, 1, 1855, 2, 20, WED, 0, 0, 0), new TestCase(2402422.5, 1, 1857, 10, 29, WED, 0, 0, 0), new TestCase(2402630.5, 1, 1858, 5, 22, MON, 0, 0, 0), new TestCase(2402708.5, 1, 1858, 8, 10, TUE, 0, 0, 0), new TestCase(2402971.5, 1, 1859, 4, 28, SAT, 0, 0, 0), new TestCase(2403344.5, 1, 1860, 5, 5, MON, 0, 0, 0), new TestCase(1721059.5, 0, 5492, 5, 7, SAT, 0, 0, 0), new TestCase(1721425.5, 0, 5493, 5, 8, MON, 0, 0, 0), new TestCase(1723854.5, 0, 5499, 13, 6, MON, 0, 0, 0), new TestCase(1723855.5, 0, 5500, 1, 1, TUE, 0, 0, 0), new TestCase(1724220.5, 1, 1, 1, 1, WED, 0, 0, 0), new TestCase(1724585.5, 1, 2, 1, 1, THU, 0, 0, 0), new TestCase(1724950.5, 1, 3, 1, 1, FRI, 0, 0, 0), new TestCase(1725316.5, 1, 4, 1, 1, SUN, 0, 0, 0), new TestCase(1724219.5, 0, 5500, 13, 5, TUE, 0, 0, 0), new TestCase(1724584.5, 1, 1, 13, 5, WED, 0, 0, 0), new TestCase(1724949.5, 1, 2, 13, 5, THU, 0, 0, 0), new TestCase(1725314.5, 1, 3, 13, 5, FRI, 0, 0, 0), new TestCase(1725315.5, 1, 3, 13, 6, SAT, 0, 0, 0), new TestCase(1725680.5, 1, 4, 13, 5, SUN, 0, 0, 0), new TestCase(2299158.5, 1, 1575, 2, 6, WED, 0, 0, 0), new TestCase(2299159.5, 1, 1575, 2, 7, THU, 0, 0, 0), new TestCase(2299160.5, 1, 1575, 2, 8, FRI, 0, 0, 0), new TestCase(2299161.5, 1, 1575, 2, 9, SAT, 0, 0, 0), new TestCase(2415020.5, 1, 1892, 4, 23, MON, 0, 0, 0), new TestCase(2453371.5, 1, 1997, 4, 23, SAT, 0, 0, 0), new TestCase(2454719.5, 1, 2000, 13, 5, WED, 0, 0, 0) };\r\n    final TestCase[] testsAmeteAlem = { new TestCase(2401442.5, 0, 7355, 2, 20, WED, 0, 0, 0), new TestCase(2402422.5, 0, 7357, 10, 29, WED, 0, 0, 0), new TestCase(2402630.5, 0, 7358, 5, 22, MON, 0, 0, 0), new TestCase(2402708.5, 0, 7358, 8, 10, TUE, 0, 0, 0), new TestCase(2402971.5, 0, 7359, 4, 28, SAT, 0, 0, 0), new TestCase(2403344.5, 0, 7360, 5, 5, MON, 0, 0, 0), new TestCase(1721059.5, 0, 5492, 5, 7, SAT, 0, 0, 0), new TestCase(1721425.5, 0, 5493, 5, 8, MON, 0, 0, 0), new TestCase(1723854.5, 0, 5499, 13, 6, MON, 0, 0, 0), new TestCase(1723855.5, 0, 5500, 1, 1, TUE, 0, 0, 0), new TestCase(1724220.5, 0, 5501, 1, 1, WED, 0, 0, 0), new TestCase(1724585.5, 0, 5502, 1, 1, THU, 0, 0, 0), new TestCase(1724950.5, 0, 5503, 1, 1, FRI, 0, 0, 0), new TestCase(1725316.5, 0, 5504, 1, 1, SUN, 0, 0, 0), new TestCase(1724219.5, 0, 5500, 13, 5, TUE, 0, 0, 0), new TestCase(1724584.5, 0, 5501, 13, 5, WED, 0, 0, 0), new TestCase(1724949.5, 0, 5502, 13, 5, THU, 0, 0, 0), new TestCase(1725314.5, 0, 5503, 13, 5, FRI, 0, 0, 0), new TestCase(1725315.5, 0, 5503, 13, 6, SAT, 0, 0, 0), new TestCase(1725680.5, 0, 5504, 13, 5, SUN, 0, 0, 0), new TestCase(2299158.5, 0, 7075, 2, 6, WED, 0, 0, 0), new TestCase(2299159.5, 0, 7075, 2, 7, THU, 0, 0, 0), new TestCase(2299160.5, 0, 7075, 2, 8, FRI, 0, 0, 0), new TestCase(2299161.5, 0, 7075, 2, 9, SAT, 0, 0, 0), new TestCase(2415020.5, 0, 7392, 4, 23, MON, 0, 0, 0), new TestCase(2453371.5, 0, 7497, 4, 23, SAT, 0, 0, 0), new TestCase(2454719.5, 0, 7500, 13, 5, WED, 0, 0, 0) };\r\n    EthiopicCalendar testCalendar = new EthiopicCalendar();\r\n    testCalendar.setLenient(true);\r\n    doTestCases(tests, testCalendar);\r\n    EthiopicCalendar testCalendarAmeteAlem = new EthiopicCalendar();\r\n    testCalendarAmeteAlem.setAmeteAlemEra(true);\r\n    testCalendarAmeteAlem.setLenient(true);\r\n    doTestCases(testsAmeteAlem, testCalendarAmeteAlem);\r\n}"
}, {
	"Path": "java.text.StringCharacterIterator.setText",
	"Comment": "sets the source string to iterate over. the begin and end positions areset to the start and end of this string.",
	"Method": "void setText(String value){\r\n    string = value;\r\n    start = offset = 0;\r\n    end = value.length();\r\n}"
}, {
	"Path": "android.icu.impl.PluralRulesLoader.checkBuildRulesIdMaps",
	"Comment": "lazily constructs the localeidtorulesid and rulesidtoequivalentulocalemaps if necessary. these exactly reflect the contents of the localesresource in plurals.res.",
	"Method": "void checkBuildRulesIdMaps(){\r\n    boolean haveMap;\r\n    synchronized (this) {\r\n        haveMap = localeIdToCardinalRulesId != null;\r\n    }\r\n    if (!haveMap) {\r\n        Map<String, String> tempLocaleIdToCardinalRulesId;\r\n        Map<String, String> tempLocaleIdToOrdinalRulesId;\r\n        Map<String, ULocale> tempRulesIdToEquivalentULocale;\r\n        try {\r\n            UResourceBundle pluralb = getPluralBundle();\r\n            UResourceBundle localeb = pluralb.get(\"locales\");\r\n            tempLocaleIdToCardinalRulesId = new TreeMap<String, String>();\r\n            tempRulesIdToEquivalentULocale = new HashMap<String, ULocale>();\r\n            for (int i = 0; i < localeb.getSize(); ++i) {\r\n                UResourceBundle b = localeb.get(i);\r\n                String id = b.getKey();\r\n                String value = b.getString().intern();\r\n                tempLocaleIdToCardinalRulesId.put(id, value);\r\n                if (!tempRulesIdToEquivalentULocale.containsKey(value)) {\r\n                    tempRulesIdToEquivalentULocale.put(value, new ULocale(id));\r\n                }\r\n            }\r\n            localeb = pluralb.get(\"locales_ordinals\");\r\n            tempLocaleIdToOrdinalRulesId = new TreeMap<String, String>();\r\n            for (int i = 0; i < localeb.getSize(); ++i) {\r\n                UResourceBundle b = localeb.get(i);\r\n                String id = b.getKey();\r\n                String value = b.getString().intern();\r\n                tempLocaleIdToOrdinalRulesId.put(id, value);\r\n            }\r\n        } catch (MissingResourceException e) {\r\n            tempLocaleIdToCardinalRulesId = Collections.emptyMap();\r\n            tempLocaleIdToOrdinalRulesId = Collections.emptyMap();\r\n            tempRulesIdToEquivalentULocale = Collections.emptyMap();\r\n        }\r\n        synchronized (this) {\r\n            if (localeIdToCardinalRulesId == null) {\r\n                localeIdToCardinalRulesId = tempLocaleIdToCardinalRulesId;\r\n                localeIdToOrdinalRulesId = tempLocaleIdToOrdinalRulesId;\r\n                rulesIdToEquivalentULocale = tempRulesIdToEquivalentULocale;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.ULocale.parseTagString",
	"Comment": "parse the language, script, and region subtags from a tag string, and return the results.this function does not return the canonical strings for the unknown script and region.",
	"Method": "int parseTagString(String localeID,String tags){\r\n    LocaleIDParser parser = new LocaleIDParser(localeID);\r\n    String lang = parser.getLanguage();\r\n    String script = parser.getScript();\r\n    String region = parser.getCountry();\r\n    if (isEmptyString(lang)) {\r\n        tags[0] = UNDEFINED_LANGUAGE;\r\n    } else {\r\n        tags[0] = lang;\r\n    }\r\n    if (script.equals(UNDEFINED_SCRIPT)) {\r\n        tags[1] = \"\";\r\n    } else {\r\n        tags[1] = script;\r\n    }\r\n    if (region.equals(UNDEFINED_REGION)) {\r\n        tags[2] = \"\";\r\n    } else {\r\n        tags[2] = region;\r\n    }\r\n    String variant = parser.getVariant();\r\n    if (!isEmptyString(variant)) {\r\n        int index = localeID.indexOf(variant);\r\n        return index > 0 ? index - 1 : index;\r\n    } else {\r\n        int index = localeID.indexOf('@');\r\n        return index == -1 ? localeID.length() : index;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.BreakIterator.getAvailableLocales",
	"Comment": "returns a list of locales for which breakiterators can be used.",
	"Method": "Locale[] getAvailableLocales(Locale[] getAvailableLocales){\r\n    return getShim().getAvailableLocales();\r\n}"
}, {
	"Path": "android.icu.util.SimpleDateRule.firstAfter",
	"Comment": "return the first occurrance of the event represented by this rulethat is on or after the given start date.",
	"Method": "Date firstAfter(Date start){\r\n    return doFirstBetween(start, null);\r\n}"
}, {
	"Path": "android.icu.util.VTimeZone.writeZonePropsByDOW",
	"Comment": "write start times defined by a dow rule using vtimezone rrule",
	"Method": "void writeZonePropsByDOW(Writer writer,boolean isDst,String tzname,int fromOffset,int toOffset,int month,int weekInMonth,int dayOfWeek,long startTime,long untilTime){\r\n    beginZoneProps(writer, isDst, tzname, fromOffset, toOffset, startTime);\r\n    beginRRULE(writer, month);\r\n    writer.write(ICAL_BYDAY);\r\n    writer.write(EQUALS_SIGN);\r\n    writer.write(Integer.toString(weekInMonth));\r\n    writer.write(ICAL_DOW_NAMES[dayOfWeek - 1]);\r\n    if (untilTime != MAX_TIME) {\r\n        appendUNTIL(writer, getDateTimeString(untilTime + fromOffset));\r\n    }\r\n    writer.write(NEWLINE);\r\n    endZoneProps(writer, isDst);\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneNamesImpl.writeObject",
	"Comment": "the custom serialization method.this implementation only preserve locale object used for the names.",
	"Method": "void writeObject(ObjectOutputStream out){\r\n    ULocale locale = _zoneStrings.getULocale();\r\n    out.writeObject(locale);\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.HebrewTest.TestAdd",
	"Comment": "test the behavior of hebrewcalendar.rollthe only real nastiness with roll is the month field, since a year canhave a variable number of months.",
	"Method": "void TestAdd(){\r\n    int[][] tests = new int[][] { { 5759, HESHVAN, 2, MONTH, 1, 5759, KISLEV, 2 }, { 5759, SHEVAT, 2, MONTH, 1, 5759, ADAR, 2 }, { 5759, SHEVAT, 2, MONTH, 2, 5759, NISAN, 2 }, { 5759, SHEVAT, 2, MONTH, 12, 5760, SHEVAT, 2 }, { 5757, HESHVAN, 2, MONTH, 1, 5757, KISLEV, 2 }, { 5757, SHEVAT, 2, MONTH, 1, 5757, ADAR_1, 2 }, { 5757, SHEVAT, 2, MONTH, 2, 5757, ADAR, 2 }, { 5757, SHEVAT, 2, MONTH, 3, 5757, NISAN, 2 }, { 5757, SHEVAT, 2, MONTH, 12, 5758, TEVET, 2 }, { 5757, SHEVAT, 2, MONTH, 13, 5758, SHEVAT, 2 }, { 5762, AV, 1, MONTH, 1, 5762, ELUL, 1 }, { 5762, AV, 30, DATE, 1, 5762, ELUL, 1 }, { 5762, ELUL, 1, DATE, -1, 5762, AV, 30 }, { 5762, ELUL, 1, MONTH, -1, 5762, AV, 1 }, { 5757, KISLEV, 1, DATE, 30, 5757, TEVET, 2 }, { 5758, KISLEV, 1, DATE, 31, 5758, TEVET, 2 } };\r\n    try {\r\n        HebrewCalendar cal = new HebrewCalendar(UTC, Locale.getDefault());\r\n        doRollAdd(ADD, cal, tests);\r\n    } catch (MissingResourceException ex) {\r\n        warnln(\"Could not load the locale data\");\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.duration.TimeUnit.smaller",
	"Comment": "returns the next smaller time unit, or null if this is the smallest.",
	"Method": "TimeUnit smaller(){\r\n    return ordinal == units.length - 1 ? null : units[ordinal + 1];\r\n}"
}, {
	"Path": "android.icu.impl.IntTrie.getLatin1LinearValue",
	"Comment": "gets the latin 1 fast path value.note this only works if latin 1 characters have their own lineararray.",
	"Method": "int getLatin1LinearValue(char ch){\r\n    return m_data_[INDEX_STAGE_3_MASK_ + 1 + ch];\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedNumberFormat.setDefaultRuleSet",
	"Comment": "override the default rule set to use.if rulesetname is null, resetto the initial default rule set.",
	"Method": "void setDefaultRuleSet(String ruleSetName){\r\n    if (ruleSetName == null) {\r\n        if (publicRuleSetNames.length > 0) {\r\n            defaultRuleSet = findRuleSet(publicRuleSetNames[0]);\r\n        } else {\r\n            defaultRuleSet = null;\r\n            int n = ruleSets.length;\r\n            while (--n >= 0) {\r\n                String currentName = ruleSets[n].getName();\r\n                if (currentName.equals(\"%spellout-numbering\") || currentName.equals(\"%digits-ordinal\") || currentName.equals(\"%duration\")) {\r\n                    defaultRuleSet = ruleSets[n];\r\n                    return;\r\n                }\r\n            }\r\n            n = ruleSets.length;\r\n            while (--n >= 0) {\r\n                if (ruleSets[n].isPublic()) {\r\n                    defaultRuleSet = ruleSets[n];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    } else if (ruleSetName.startsWith(\"%%\")) {\r\n        throw new IllegalArgumentException(\"cannot use private rule set: \" + ruleSetName);\r\n    } else {\r\n        defaultRuleSet = findRuleSet(ruleSetName);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.RBBIDataWrapper.getRowIndex",
	"Comment": "rbbi state table indexing function.given a state number, return thearray index of the start of the state table row for that state.",
	"Method": "int getRowIndex(int state){\r\n    return ROW_DATA + state * (fHeader.fCatCount + 4);\r\n}"
}, {
	"Path": "android.icu.text.DateFormat.setBooleanAttribute",
	"Comment": "sets a boolean attribute for this instance. aspects of dateformat leniency are controlled byboolean attributes.",
	"Method": "DateFormat setBooleanAttribute(BooleanAttribute key,boolean value){\r\n    if (key.equals(DateFormat.BooleanAttribute.PARSE_PARTIAL_MATCH)) {\r\n        key = DateFormat.BooleanAttribute.PARSE_PARTIAL_LITERAL_MATCH;\r\n    }\r\n    if (value) {\r\n        booleanAttributes.add(key);\r\n    } else {\r\n        booleanAttributes.remove(key);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.util.TimeZoneRule.getDSTSavings",
	"Comment": "gets the amount of daylight saving delta time from the standard time.",
	"Method": "int getDSTSavings(){\r\n    return dstSavings;\r\n}"
}, {
	"Path": "android.icu.impl.CalendarAstronomer.getMoonPosition",
	"Comment": "the position of the moon at the time set on thisobject, in equatorial coordinates.",
	"Method": "Equatorial getMoonPosition(){\r\n    if (moonPosition == null) {\r\n        double sunLong = getSunLongitude();\r\n        double day = getJulianDay() - JD_EPOCH;\r\n        double meanLongitude = norm2PI(13.1763966 * PI / 180 * day + moonL0);\r\n        double meanAnomalyMoon = norm2PI(meanLongitude - 0.1114041 * PI / 180 * day - moonP0);\r\n        double evection = 1.2739 * PI / 180 * Math.sin(2 * (meanLongitude - sunLong) - meanAnomalyMoon);\r\n        double annual = 0.1858 * PI / 180 * Math.sin(meanAnomalySun);\r\n        double a3 = 0.3700 * PI / 180 * Math.sin(meanAnomalySun);\r\n        meanAnomalyMoon += evection - annual - a3;\r\n        double center = 6.2886 * PI / 180 * Math.sin(meanAnomalyMoon);\r\n        double a4 = 0.2140 * PI / 180 * Math.sin(2 * meanAnomalyMoon);\r\n        moonLongitude = meanLongitude + evection + center - annual + a4;\r\n        double variation = 0.6583 * PI / 180 * Math.sin(2 * (moonLongitude - sunLong));\r\n        moonLongitude += variation;\r\n        double nodeLongitude = norm2PI(moonN0 - 0.0529539 * PI / 180 * day);\r\n        nodeLongitude -= 0.16 * PI / 180 * Math.sin(meanAnomalySun);\r\n        double y = Math.sin(moonLongitude - nodeLongitude);\r\n        double x = Math.cos(moonLongitude - nodeLongitude);\r\n        moonEclipLong = Math.atan2(y * Math.cos(moonI), x) + nodeLongitude;\r\n        double moonEclipLat = Math.asin(y * Math.sin(moonI));\r\n        moonPosition = eclipticToEquatorial(moonEclipLong, moonEclipLat);\r\n    }\r\n    return moonPosition;\r\n}"
}, {
	"Path": "android.icu.lang.CharSequences.equals",
	"Comment": "utility function for comparing objects that may be nullstring.",
	"Method": "boolean equals(int codepoint,CharSequence other,boolean equals,CharSequence other,int codepoint,boolean equals,T a,T b){\r\n    return a == null ? b == null : b == null ? false : a.equals(b);\r\n}"
}, {
	"Path": "libcore.net.url.JarURLConnectionImpl.getInputStream",
	"Comment": "creates an input stream for reading from this url connection.",
	"Method": "InputStream getInputStream(){\r\n    if (closed) {\r\n        throw new IllegalStateException(\"JarURLConnection InputStream has been closed\");\r\n    }\r\n    connect();\r\n    if (jarInput != null) {\r\n        return jarInput;\r\n    }\r\n    if (jarEntry == null) {\r\n        throw new IOException(\"Jar entry not specified\");\r\n    }\r\n    return jarInput = new JarURLConnectionInputStream(jarFile.getInputStream(jarEntry), jarFile);\r\n}"
}, {
	"Path": "android.icu.text.TimeZoneFormat.getTimeZoneID",
	"Comment": "private method returns a time zone id. if tzid is not null, the value of tzid is returned.if tzid is null, then this method look up a time zone id for the current region. this is asmall helper method used by the parse implementation method",
	"Method": "String getTimeZoneID(String tzID,String mzID){\r\n    String id = tzID;\r\n    if (id == null) {\r\n        assert (mzID != null);\r\n        id = _tznames.getReferenceZoneID(mzID, getTargetRegion());\r\n        if (id == null) {\r\n            throw new IllegalArgumentException(\"Invalid mzID: \" + mzID);\r\n        }\r\n    }\r\n    return id;\r\n}"
}, {
	"Path": "android.icu.impl.ZoneMeta.getSystemTimeZone",
	"Comment": "returns a frozen olsontimezone instance for the given id.this method returns null when the given id is unknown.",
	"Method": "OlsonTimeZone getSystemTimeZone(String id){\r\n    return SYSTEM_ZONE_CACHE.getInstance(id, id);\r\n}"
}, {
	"Path": "android.icu.text.CurrencyPluralInfo.setCurrencyPluralPattern",
	"Comment": "set currency plural patterns.these are initially set in the constructor based on thelocale, and usually do not need to be changed.",
	"Method": "void setCurrencyPluralPattern(String pluralCount,String pattern){\r\n    pluralCountToCurrencyUnitPattern.put(pluralCount, pattern);\r\n}"
}, {
	"Path": "android.icu.util.CharsTrie.next",
	"Comment": "traverses the trie from the current state for this input char.",
	"Method": "Result next(int inUnit,Result next,CharSequence s,int sIndex,int sLimit,Entry next){\r\n    if (sIndex >= sLimit) {\r\n        return current();\r\n    }\r\n    int pos = pos_;\r\n    if (pos < 0) {\r\n        return Result.NO_MATCH;\r\n    }\r\n    int length = remainingMatchLength_;\r\n    for (; ; ) {\r\n        char inUnit;\r\n        for (; ; ) {\r\n            if (sIndex == sLimit) {\r\n                remainingMatchLength_ = length;\r\n                pos_ = pos;\r\n                int node;\r\n                return (length < 0 && (node = chars_.charAt(pos)) >= kMinValueLead) ? valueResults_[node >> 15] : Result.NO_VALUE;\r\n            }\r\n            inUnit = s.charAt(sIndex++);\r\n            if (length < 0) {\r\n                remainingMatchLength_ = length;\r\n                break;\r\n            }\r\n            if (inUnit != chars_.charAt(pos)) {\r\n                stop();\r\n                return Result.NO_MATCH;\r\n            }\r\n            ++pos;\r\n            --length;\r\n        }\r\n        int node = chars_.charAt(pos++);\r\n        for (; ; ) {\r\n            if (node < kMinLinearMatch) {\r\n                Result result = branchNext(pos, node, inUnit);\r\n                if (result == Result.NO_MATCH) {\r\n                    return Result.NO_MATCH;\r\n                }\r\n                if (sIndex == sLimit) {\r\n                    return result;\r\n                }\r\n                if (result == Result.FINAL_VALUE) {\r\n                    stop();\r\n                    return Result.NO_MATCH;\r\n                }\r\n                inUnit = s.charAt(sIndex++);\r\n                pos = pos_;\r\n                node = chars_.charAt(pos++);\r\n            } else if (node < kMinValueLead) {\r\n                length = node - kMinLinearMatch;\r\n                if (inUnit != chars_.charAt(pos)) {\r\n                    stop();\r\n                    return Result.NO_MATCH;\r\n                }\r\n                ++pos;\r\n                --length;\r\n                break;\r\n            } else if ((node & kValueIsFinal) != 0) {\r\n                stop();\r\n                return Result.NO_MATCH;\r\n            } else {\r\n                pos = skipNodeValue(pos, node);\r\n                node &= kNodeTypeMask;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.FilteredBreakIteratorBuilder.createInstance",
	"Comment": "construct an empty filteredbreakiteratorbuilder.in this state, it will not suppress any segment boundaries.",
	"Method": "FilteredBreakIteratorBuilder createInstance(ULocale where,FilteredBreakIteratorBuilder createInstance){\r\n    FilteredBreakIteratorBuilder ret = new SimpleFilteredSentenceBreakIterator.Builder();\r\n    return ret;\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.useProtocolVersion",
	"Comment": "sets the specified protocol version to be used by this stream.",
	"Method": "void useProtocolVersion(int version){\r\n    if (!objectsWritten.isEmpty()) {\r\n        throw new IllegalStateException(\"Cannot set protocol version when stream in use\");\r\n    }\r\n    if (version != ObjectStreamConstants.PROTOCOL_VERSION_1 && version != ObjectStreamConstants.PROTOCOL_VERSION_2) {\r\n        throw new IllegalArgumentException(\"Unknown protocol: \" + version);\r\n    }\r\n    protocolVersion = version;\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.parseInt",
	"Comment": "parse an integer using numberformat.this method is semanticallyconst, but actually may modify fnumberformat.",
	"Method": "Number parseInt(String text,ParsePosition pos,boolean allowNegative,NumberFormat fmt,Number parseInt,String text,int maxDigits,ParsePosition pos,boolean allowNegative,NumberFormat fmt){\r\n    Number number;\r\n    int oldPos = pos.getIndex();\r\n    if (allowNegative) {\r\n        number = fmt.parse(text, pos);\r\n    } else {\r\n        if (fmt instanceof DecimalFormat) {\r\n            String oldPrefix = ((DecimalFormat) fmt).getNegativePrefix();\r\n            ((DecimalFormat) fmt).setNegativePrefix(SUPPRESS_NEGATIVE_PREFIX);\r\n            number = fmt.parse(text, pos);\r\n            ((DecimalFormat) fmt).setNegativePrefix(oldPrefix);\r\n        } else {\r\n            boolean dateNumberFormat = (fmt instanceof DateNumberFormat);\r\n            if (dateNumberFormat) {\r\n                ((DateNumberFormat) fmt).setParsePositiveOnly(true);\r\n            }\r\n            number = fmt.parse(text, pos);\r\n            if (dateNumberFormat) {\r\n                ((DateNumberFormat) fmt).setParsePositiveOnly(false);\r\n            }\r\n        }\r\n    }\r\n    if (maxDigits > 0) {\r\n        int nDigits = pos.getIndex() - oldPos;\r\n        if (nDigits > maxDigits) {\r\n            double val = number.doubleValue();\r\n            nDigits -= maxDigits;\r\n            while (nDigits > 0) {\r\n                val /= 10;\r\n                nDigits--;\r\n            }\r\n            pos.setIndex(oldPos + maxDigits);\r\n            number = Integer.valueOf((int) val);\r\n        }\r\n    }\r\n    return number;\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.getName",
	"Comment": "return the name of this service. this will be the empty string if none was assigned.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "android.icu.util.UResourceBundleIterator.next",
	"Comment": "returns the next element of this iterator if this iterator object has at least one more element to provide",
	"Method": "UResourceBundle next(){\r\n    if (index < size) {\r\n        return bundle.get(index++);\r\n    }\r\n    throw new NoSuchElementException();\r\n}"
}, {
	"Path": "android.icu.text.ReplaceableString.charAt",
	"Comment": "return the character at the given position in this object.replaceable api.",
	"Method": "char charAt(int offset){\r\n    return buf.charAt(offset);\r\n}"
}, {
	"Path": "android.icu.util.Calendar.handleGetMonthLength",
	"Comment": "returns the number of days in the given month of the given extendedyear of this calendar system.subclasses should override thismethod if they can provide a more correct or more efficientimplementation than the default implementation in calendar.",
	"Method": "int handleGetMonthLength(int extendedYear,int month){\r\n    return handleComputeMonthStart(extendedYear, month + 1, true) - handleComputeMonthStart(extendedYear, month, true);\r\n}"
}, {
	"Path": "android.icu.util.TimeZone.setID",
	"Comment": "sets the time zone id. this does not change any other data inthe time zone object.",
	"Method": "void setID(String ID){\r\n    if (ID == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (isFrozen()) {\r\n        throw new UnsupportedOperationException(\"Attempt to modify a frozen TimeZone instance.\");\r\n    }\r\n    this.ID = ID;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.readObject",
	"Comment": "first, read the default serializable fields from the stream. then ifserialversiononstream is less than 1, indicating that the stream waswritten by jdk 1.1, initialize useexponentialnotation to false, sinceit was not present in jdk 1.1. finally, set serialversiononstream back to themaximum allowed value so that default serialization will work properly if thisobject is streamed out again.",
	"Method": "void readObject(ObjectInputStream stream){\r\n    stream.defaultReadObject();\r\n    if (getMaximumIntegerDigits() > MAX_INTEGER_DIGITS) {\r\n        setMaximumIntegerDigits(MAX_INTEGER_DIGITS);\r\n    }\r\n    if (getMaximumFractionDigits() > DOUBLE_FRACTION_DIGITS) {\r\n        _setMaximumFractionDigits(DOUBLE_FRACTION_DIGITS);\r\n    }\r\n    if (serialVersionOnStream < 2) {\r\n        exponentSignAlwaysShown = false;\r\n        setInternalRoundingIncrement(null);\r\n        roundingMode = BigDecimal.ROUND_HALF_EVEN;\r\n        formatWidth = 0;\r\n        pad = ' ';\r\n        padPosition = PAD_BEFORE_PREFIX;\r\n        if (serialVersionOnStream < 1) {\r\n            useExponentialNotation = false;\r\n        }\r\n    }\r\n    if (serialVersionOnStream < 3) {\r\n        setCurrencyForSymbols();\r\n    }\r\n    if (serialVersionOnStream < 4) {\r\n        currencyUsage = CurrencyUsage.STANDARD;\r\n    }\r\n    serialVersionOnStream = currentSerialVersion;\r\n    digitList = new DigitList();\r\n    if (roundingIncrement != null) {\r\n        setInternalRoundingIncrement(new BigDecimal(roundingIncrement));\r\n    }\r\n    resetActualRounding();\r\n}"
}, {
	"Path": "android.icu.util.ULocale.getDisplayScriptInternal",
	"Comment": "displaylocaleid is canonical, localeid need not be since parsing will fix this.",
	"Method": "String getDisplayScriptInternal(ULocale locale,ULocale displayLocale){\r\n    return LocaleDisplayNames.getInstance(displayLocale).scriptDisplayName(locale.getScript());\r\n}"
}, {
	"Path": "android.icu.impl.UCharacterName.addAlgorithmName",
	"Comment": "adds all algorithmic names into the name set.equivalent to part of calcalgnamesetslengths.",
	"Method": "int addAlgorithmName(int maxlength){\r\n    int result = 0;\r\n    for (int i = m_algorithm_.length - 1; i >= 0; i--) {\r\n        result = m_algorithm_[i].add(m_nameSet_, maxlength);\r\n        if (result > maxlength) {\r\n            maxlength = result;\r\n        }\r\n    }\r\n    return maxlength;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.setPercent",
	"Comment": "sets the character used for percent sign. different for arabic, etc.",
	"Method": "void setPercent(char percent){\r\n    this.percent = percent;\r\n    this.percentString = String.valueOf(percent);\r\n}"
}, {
	"Path": "java.io.PipedOutputStream.close",
	"Comment": "closes this stream. if this stream is connected to an input stream, theinput stream is closed and the pipe is disconnected.",
	"Method": "void close(){\r\n    PipedInputStream stream = target;\r\n    if (stream != null) {\r\n        stream.done();\r\n        target = null;\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.Trie2Writable.findHighStart",
	"Comment": "find the start of the last range in the trie by enumerating backward.indexes for supplementary code points higher than this will be omitted.",
	"Method": "int findHighStart(int highValue){\r\n    int value;\r\n    int c, prev;\r\n    int i1, i2, j, i2Block, prevI2Block, block, prevBlock;\r\n    if (highValue == initialValue) {\r\n        prevI2Block = index2NullOffset;\r\n        prevBlock = dataNullOffset;\r\n    } else {\r\n        prevI2Block = -1;\r\n        prevBlock = -1;\r\n    }\r\n    prev = 0x110000;\r\n    i1 = UNEWTRIE2_INDEX_1_LENGTH;\r\n    c = prev;\r\n    while (c > 0) {\r\n        i2Block = index1[--i1];\r\n        if (i2Block == prevI2Block) {\r\n            c -= UTRIE2_CP_PER_INDEX_1_ENTRY;\r\n            continue;\r\n        }\r\n        prevI2Block = i2Block;\r\n        if (i2Block == index2NullOffset) {\r\n            if (highValue != initialValue) {\r\n                return c;\r\n            }\r\n            c -= UTRIE2_CP_PER_INDEX_1_ENTRY;\r\n        } else {\r\n            for (i2 = UTRIE2_INDEX_2_BLOCK_LENGTH; i2 > 0; ) {\r\n                block = index2[i2Block + --i2];\r\n                if (block == prevBlock) {\r\n                    c -= UTRIE2_DATA_BLOCK_LENGTH;\r\n                    continue;\r\n                }\r\n                prevBlock = block;\r\n                if (block == dataNullOffset) {\r\n                    if (highValue != initialValue) {\r\n                        return c;\r\n                    }\r\n                    c -= UTRIE2_DATA_BLOCK_LENGTH;\r\n                } else {\r\n                    for (j = UTRIE2_DATA_BLOCK_LENGTH; j > 0; ) {\r\n                        value = data[block + --j];\r\n                        if (value != highValue) {\r\n                            return c;\r\n                        }\r\n                        --c;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "android.icu.text.TransliteratorIDParser.specsToID",
	"Comment": "givens a spec object, convert it to a singleid object.thespec object is a more unprocessed parse result.the singleidobject contains information about canonical and basic ids.",
	"Method": "SingleID specsToID(Specs specs,int dir){\r\n    String canonID = \"\";\r\n    String basicID = \"\";\r\n    String basicPrefix = \"\";\r\n    if (specs != null) {\r\n        StringBuilder buf = new StringBuilder();\r\n        if (dir == FORWARD) {\r\n            if (specs.sawSource) {\r\n                buf.append(specs.source).append(TARGET_SEP);\r\n            } else {\r\n                basicPrefix = specs.source + TARGET_SEP;\r\n            }\r\n            buf.append(specs.target);\r\n        } else {\r\n            buf.append(specs.target).append(TARGET_SEP).append(specs.source);\r\n        }\r\n        if (specs.variant != null) {\r\n            buf.append(VARIANT_SEP).append(specs.variant);\r\n        }\r\n        basicID = basicPrefix + buf.toString();\r\n        if (specs.filter != null) {\r\n            buf.insert(0, specs.filter);\r\n        }\r\n        canonID = buf.toString();\r\n    }\r\n    return new SingleID(canonID, basicID);\r\n}"
}, {
	"Path": "android.icu.util.Holiday.firstAfter",
	"Comment": "return the first occurrence of this holiday on or after the given date",
	"Method": "Date firstAfter(Date start){\r\n    return rule.firstAfter(start);\r\n}"
}, {
	"Path": "android.icu.impl.ICUBinary.writeHeader",
	"Comment": "writes an icu data header.does not write a copyright string.",
	"Method": "int writeHeader(int dataFormat,int formatVersion,int dataVersion,DataOutputStream dos){\r\n    dos.writeChar(32);\r\n    dos.writeByte(MAGIC1);\r\n    dos.writeByte(MAGIC2);\r\n    dos.writeChar(20);\r\n    dos.writeChar(0);\r\n    dos.writeByte(1);\r\n    dos.writeByte(CHAR_SET_);\r\n    dos.writeByte(CHAR_SIZE_);\r\n    dos.writeByte(0);\r\n    dos.writeInt(dataFormat);\r\n    dos.writeInt(formatVersion);\r\n    dos.writeInt(dataVersion);\r\n    dos.writeLong(0);\r\n    assert dos.size() == 32;\r\n    return 32;\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneGenericNames.find",
	"Comment": "returns a collection of time zone display name matches for the specified types in thegiven text at the given offset.",
	"Method": "Collection<GenericMatchInfo> find(String text,int start,EnumSet<GenericNameType> genericTypes){\r\n    if (text == null || text.length() == 0 || start < 0 || start >= text.length()) {\r\n        throw new IllegalArgumentException(\"bad input text or range\");\r\n    }\r\n    Collection<GenericMatchInfo> results = findLocal(text, start, genericTypes);\r\n    Collection<MatchInfo> tznamesMatches = findTimeZoneNames(text, start, genericTypes);\r\n    if (tznamesMatches != null) {\r\n        for (MatchInfo match : tznamesMatches) {\r\n            if (results == null) {\r\n                results = new LinkedList<GenericMatchInfo>();\r\n            }\r\n            results.add(createGenericMatchInfo(match));\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "android.icu.text.CurrencyPluralInfo.select",
	"Comment": "given a number, returns the keyword of the first rule that appliesto the number.",
	"Method": "String select(double number,String select,PluralRules.FixedDecimal numberInfo){\r\n    return pluralRules.select(numberInfo);\r\n}"
}, {
	"Path": "android.icu.util.UniversalTimeScale.from",
	"Comment": "convert a long datetime from the given time scale to the universal time scale.",
	"Method": "long from(long otherTime,int timeScale){\r\n    TimeScaleData data = fromRangeCheck(otherTime, timeScale);\r\n    return (otherTime + data.epochOffset) * data.units;\r\n}"
}, {
	"Path": "android.icu.text.DateFormat.setCalendar",
	"Comment": "sets the calendar to be used by this date format.initially, the defaultcalendar for the specified or default locale is used.",
	"Method": "void setCalendar(Calendar newCalendar){\r\n    this.calendar = newCalendar;\r\n}"
}, {
	"Path": "java.nio.charset.Charset.isSupported",
	"Comment": "determines whether the specified charset is supported by this runtime.",
	"Method": "boolean isSupported(String charsetName){\r\n    try {\r\n        forName(charsetName);\r\n        return true;\r\n    } catch (UnsupportedCharsetException ex) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.Calendar.getDisplayName",
	"Comment": "returns the name of this calendar in the language of the given locale.",
	"Method": "String getDisplayName(Locale loc,String getDisplayName,ULocale loc){\r\n    return this.getClass().getName();\r\n}"
}, {
	"Path": "android.icu.util.BytesTrie.next",
	"Comment": "traverses the trie from the current state for this input byte.",
	"Method": "Result next(int inByte,Result next,byte[] s,int sIndex,int sLimit,Entry next){\r\n    if (sIndex >= sLimit) {\r\n        return current();\r\n    }\r\n    int pos = pos_;\r\n    if (pos < 0) {\r\n        return Result.NO_MATCH;\r\n    }\r\n    int length = remainingMatchLength_;\r\n    for (; ; ) {\r\n        byte inByte;\r\n        for (; ; ) {\r\n            if (sIndex == sLimit) {\r\n                remainingMatchLength_ = length;\r\n                pos_ = pos;\r\n                int node;\r\n                return (length < 0 && (node = (bytes_[pos] & 0xff)) >= kMinValueLead) ? valueResults_[node & kValueIsFinal] : Result.NO_VALUE;\r\n            }\r\n            inByte = s[sIndex++];\r\n            if (length < 0) {\r\n                remainingMatchLength_ = length;\r\n                break;\r\n            }\r\n            if (inByte != bytes_[pos]) {\r\n                stop();\r\n                return Result.NO_MATCH;\r\n            }\r\n            ++pos;\r\n            --length;\r\n        }\r\n        for (; ; ) {\r\n            int node = bytes_[pos++] & 0xff;\r\n            if (node < kMinLinearMatch) {\r\n                Result result = branchNext(pos, node, inByte & 0xff);\r\n                if (result == Result.NO_MATCH) {\r\n                    return Result.NO_MATCH;\r\n                }\r\n                if (sIndex == sLimit) {\r\n                    return result;\r\n                }\r\n                if (result == Result.FINAL_VALUE) {\r\n                    stop();\r\n                    return Result.NO_MATCH;\r\n                }\r\n                inByte = s[sIndex++];\r\n                pos = pos_;\r\n            } else if (node < kMinValueLead) {\r\n                length = node - kMinLinearMatch;\r\n                if (inByte != bytes_[pos]) {\r\n                    stop();\r\n                    return Result.NO_MATCH;\r\n                }\r\n                ++pos;\r\n                --length;\r\n                break;\r\n            } else if ((node & kValueIsFinal) != 0) {\r\n                stop();\r\n                return Result.NO_MATCH;\r\n            } else {\r\n                pos = skipValue(pos, node);\r\n                assert ((bytes_[pos] & 0xff) < kMinValueLead);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.Currency.getRoundingIncrement",
	"Comment": "returns the rounding increment for this currency, or 0.0 if norounding is done by this currency with the usage.",
	"Method": "double getRoundingIncrement(double getRoundingIncrement,CurrencyUsage Usage){\r\n    CurrencyMetaInfo info = CurrencyMetaInfo.getInstance();\r\n    CurrencyDigits digits = info.currencyDigits(subType, Usage);\r\n    int data1 = digits.roundingIncrement;\r\n    if (data1 == 0) {\r\n        return 0.0;\r\n    }\r\n    int data0 = digits.fractionDigits;\r\n    if (data0 < 0 || data0 >= POW10.length) {\r\n        return 0.0;\r\n    }\r\n    return (double) data1 / POW10[data0];\r\n}"
}, {
	"Path": "android.icu.util.DateTimeRule.getRuleDayOfMonth",
	"Comment": "gets the rule day of month.when the date rule typeis dow, the value is always 0.",
	"Method": "int getRuleDayOfMonth(){\r\n    return dayOfMonth;\r\n}"
}, {
	"Path": "android.icu.text.DateFormatSymbols.loadDayPeriodStrings",
	"Comment": "loads localized names for day periods in the requested format.",
	"Method": "String[] loadDayPeriodStrings(Map<String, String> resourceMap){\r\n    String[] strings = new String[DAY_PERIOD_KEYS.length];\r\n    if (resourceMap != null) {\r\n        for (int i = 0; i < DAY_PERIOD_KEYS.length; ++i) {\r\n            strings[i] = resourceMap.get(DAY_PERIOD_KEYS[i]);\r\n        }\r\n    }\r\n    return strings;\r\n}"
}, {
	"Path": "android.icu.text.MeasureFormat.equals",
	"Comment": "two measureformats, a and b, are equal if and only if they have the same formatwidth,locale, and equal number formats.",
	"Method": "boolean equals(Object other){\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (!(other instanceof MeasureFormat)) {\r\n        return false;\r\n    }\r\n    MeasureFormat rhs = (MeasureFormat) other;\r\n    return getWidth() == rhs.getWidth() && getLocale().equals(rhs.getLocale()) && getNumberFormat().equals(rhs.getNumberFormat());\r\n}"
}, {
	"Path": "android.icu.impl.PropsVectors.getRow",
	"Comment": "returns an array which contains value elementsin row rowindex.",
	"Method": "int[] getRow(int rowIndex){\r\n    if (isCompacted) {\r\n        throw new IllegalStateException(\"Illegal Invocation of the method after compact()\");\r\n    }\r\n    if (rowIndex < 0 || rowIndex > rows) {\r\n        throw new IllegalArgumentException(\"rowIndex out of bound!\");\r\n    }\r\n    int[] rowToReturn = new int[columns - 2];\r\n    System.arraycopy(v, rowIndex * columns + 2, rowToReturn, 0, columns - 2);\r\n    return rowToReturn;\r\n}"
}, {
	"Path": "android.icu.text.Bidi.bracketProcessChar",
	"Comment": "handle strong characters, digits and candidates for closing brackets",
	"Method": "void bracketProcessChar(BracketData bd,int position){\r\n    IsoRun pLastIsoRun = bd.isoRuns[bd.isoRunLast];\r\n    byte dirProp, newProp;\r\n    byte level;\r\n    dirProp = dirProps[position];\r\n    if (dirProp == ON) {\r\n        char c, match;\r\n        int idx;\r\n        c = text[position];\r\n        for (idx = pLastIsoRun.limit - 1; idx >= pLastIsoRun.start; idx--) {\r\n            if (bd.openings[idx].match != c)\r\n                continue;\r\n            newProp = bracketProcessClosing(bd, idx, position);\r\n            if (newProp == ON) {\r\n                c = 0;\r\n                break;\r\n            }\r\n            pLastIsoRun.lastBase = ON;\r\n            pLastIsoRun.contextDir = newProp;\r\n            pLastIsoRun.contextPos = position;\r\n            level = levels[position];\r\n            if ((level & LEVEL_OVERRIDE) != 0) {\r\n                short flag;\r\n                int i;\r\n                newProp = (byte) (level & 1);\r\n                pLastIsoRun.lastStrong = newProp;\r\n                flag = (short) DirPropFlag(newProp);\r\n                for (i = pLastIsoRun.start; i < idx; i++) bd.openings[i].flags |= flag;\r\n                levels[position] &= ~LEVEL_OVERRIDE;\r\n            }\r\n            levels[bd.openings[idx].position] &= ~LEVEL_OVERRIDE;\r\n            return;\r\n        }\r\n        if (c != 0)\r\n            match = (char) UCharacter.getBidiPairedBracket(c);\r\n        else\r\n            match = 0;\r\n        if (match != c && UCharacter.getIntPropertyValue(c, UProperty.BIDI_PAIRED_BRACKET_TYPE) == UCharacter.BidiPairedBracketType.OPEN) {\r\n            if (match == 0x232A) {\r\n                bracketAddOpening(bd, (char) 0x3009, position);\r\n            } else if (match == 0x3009) {\r\n                bracketAddOpening(bd, (char) 0x232A, position);\r\n            }\r\n            bracketAddOpening(bd, match, position);\r\n        }\r\n    }\r\n    level = levels[position];\r\n    if ((level & LEVEL_OVERRIDE) != 0) {\r\n        newProp = (byte) (level & 1);\r\n        if (dirProp != S && dirProp != WS && dirProp != ON)\r\n            dirProps[position] = newProp;\r\n        pLastIsoRun.lastBase = newProp;\r\n        pLastIsoRun.lastStrong = newProp;\r\n        pLastIsoRun.contextDir = newProp;\r\n        pLastIsoRun.contextPos = position;\r\n    } else if (dirProp <= R || dirProp == AL) {\r\n        newProp = DirFromStrong(dirProp);\r\n        pLastIsoRun.lastBase = dirProp;\r\n        pLastIsoRun.lastStrong = dirProp;\r\n        pLastIsoRun.contextDir = newProp;\r\n        pLastIsoRun.contextPos = position;\r\n    } else if (dirProp == EN) {\r\n        pLastIsoRun.lastBase = EN;\r\n        if (pLastIsoRun.lastStrong == L) {\r\n            newProp = L;\r\n            if (!bd.isNumbersSpecial)\r\n                dirProps[position] = ENL;\r\n            pLastIsoRun.contextDir = L;\r\n            pLastIsoRun.contextPos = position;\r\n        } else {\r\n            newProp = R;\r\n            if (pLastIsoRun.lastStrong == AL)\r\n                dirProps[position] = AN;\r\n            else\r\n                dirProps[position] = ENR;\r\n            pLastIsoRun.contextDir = R;\r\n            pLastIsoRun.contextPos = position;\r\n        }\r\n    } else if (dirProp == AN) {\r\n        newProp = R;\r\n        pLastIsoRun.lastBase = AN;\r\n        pLastIsoRun.contextDir = R;\r\n        pLastIsoRun.contextPos = position;\r\n    } else if (dirProp == NSM) {\r\n        newProp = pLastIsoRun.lastBase;\r\n        if (newProp == ON)\r\n            dirProps[position] = newProp;\r\n    } else {\r\n        newProp = dirProp;\r\n        pLastIsoRun.lastBase = dirProp;\r\n    }\r\n    if (newProp <= R || newProp == AL) {\r\n        int i;\r\n        short flag = (short) DirPropFlag(DirFromStrong(newProp));\r\n        for (i = pLastIsoRun.start; i < pLastIsoRun.limit; i++) if (position > bd.openings[i].position)\r\n            bd.openings[i].flags |= flag;\r\n    }\r\n}"
}, {
	"Path": "javax.security.cert.Certificate.equals",
	"Comment": "compares the argument to this certificate. if both have the same bytesthey are assumed to be equal.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == this) {\r\n        return true;\r\n    }\r\n    if (!(obj instanceof Certificate)) {\r\n        return false;\r\n    }\r\n    Certificate object = (Certificate) obj;\r\n    try {\r\n        return Arrays.equals(getEncoded(), object.getEncoded());\r\n    } catch (CertificateEncodingException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.UCharacterIterator.currentCodePoint",
	"Comment": "returns the codepoint at the current index. if the current index is invalid, done is returned. if the currentindex points to a lead surrogate, and there is a following trail surrogate, then the code point is returned.otherwise, the code unit at index is returned. index is not changed.",
	"Method": "int currentCodePoint(){\r\n    int ch = current();\r\n    if (UTF16.isLeadSurrogate((char) ch)) {\r\n        next();\r\n        int ch2 = current();\r\n        previous();\r\n        if (UTF16.isTrailSurrogate((char) ch2)) {\r\n            return Character.toCodePoint((char) ch, (char) ch2);\r\n        }\r\n    }\r\n    return ch;\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSetSpanner.getUnicodeSet",
	"Comment": "returns the unicodeset used for processing. it is frozen iff the original was.",
	"Method": "UnicodeSet getUnicodeSet(){\r\n    return unicodeSet;\r\n}"
}, {
	"Path": "android.icu.util.ULocale.getDisplayName",
	"Comment": "returns this locale name localized for display in the provided locale.",
	"Method": "String getDisplayName(String getDisplayName,ULocale displayLocale,String getDisplayName,String localeID,String displayLocaleID,String getDisplayName,String localeID,ULocale displayLocale){\r\n    return getDisplayNameInternal(new ULocale(localeID), displayLocale);\r\n}"
}, {
	"Path": "android.icu.util.Calendar.getInstance",
	"Comment": "returns a calendar using the default time zone and specified locale.",
	"Method": "Calendar getInstance(Calendar getInstance,TimeZone zone,Calendar getInstance,Locale aLocale,Calendar getInstance,ULocale locale,Calendar getInstance,TimeZone zone,Locale aLocale,Calendar getInstance,TimeZone zone,ULocale locale){\r\n    return getInstanceInternal(zone, locale);\r\n}"
}, {
	"Path": "android.icu.text.DateIntervalFormat.format",
	"Comment": "format an object to produce a string. this method handles formattableobjects with a dateinterval type. if a the formattable object type is not a dateinterval,illegalargumentexception is thrown.",
	"Method": "StringBuffer format(Object obj,StringBuffer appendTo,FieldPosition fieldPosition,StringBuffer format,DateInterval dtInterval,StringBuffer appendTo,FieldPosition fieldPosition,StringBuffer format,Calendar fromCalendar,Calendar toCalendar,StringBuffer appendTo,FieldPosition pos){\r\n    if (!fromCalendar.isEquivalentTo(toCalendar)) {\r\n        throw new IllegalArgumentException(\"can not format on two different calendars\");\r\n    }\r\n    int field = -1;\r\n    if (fromCalendar.get(Calendar.ERA) != toCalendar.get(Calendar.ERA)) {\r\n        field = Calendar.ERA;\r\n    } else if (fromCalendar.get(Calendar.YEAR) != toCalendar.get(Calendar.YEAR)) {\r\n        field = Calendar.YEAR;\r\n    } else if (fromCalendar.get(Calendar.MONTH) != toCalendar.get(Calendar.MONTH)) {\r\n        field = Calendar.MONTH;\r\n    } else if (fromCalendar.get(Calendar.DATE) != toCalendar.get(Calendar.DATE)) {\r\n        field = Calendar.DATE;\r\n    } else if (fromCalendar.get(Calendar.AM_PM) != toCalendar.get(Calendar.AM_PM)) {\r\n        field = Calendar.AM_PM;\r\n    } else if (fromCalendar.get(Calendar.HOUR) != toCalendar.get(Calendar.HOUR)) {\r\n        field = Calendar.HOUR;\r\n    } else if (fromCalendar.get(Calendar.MINUTE) != toCalendar.get(Calendar.MINUTE)) {\r\n        field = Calendar.MINUTE;\r\n    } else if (fromCalendar.get(Calendar.SECOND) != toCalendar.get(Calendar.SECOND)) {\r\n        field = Calendar.SECOND;\r\n    } else {\r\n        return fDateFormat.format(fromCalendar, appendTo, pos);\r\n    }\r\n    boolean fromToOnSameDay = (field == Calendar.AM_PM || field == Calendar.HOUR || field == Calendar.MINUTE || field == Calendar.SECOND);\r\n    PatternInfo intervalPattern = fIntervalPatterns.get(DateIntervalInfo.CALENDAR_FIELD_TO_PATTERN_LETTER[field]);\r\n    if (intervalPattern == null) {\r\n        if (fDateFormat.isFieldUnitIgnored(field)) {\r\n            return fDateFormat.format(fromCalendar, appendTo, pos);\r\n        }\r\n        return fallbackFormat(fromCalendar, toCalendar, fromToOnSameDay, appendTo, pos);\r\n    }\r\n    if (intervalPattern.getFirstPart() == null) {\r\n        return fallbackFormat(fromCalendar, toCalendar, fromToOnSameDay, appendTo, pos, intervalPattern.getSecondPart());\r\n    }\r\n    Calendar firstCal;\r\n    Calendar secondCal;\r\n    if (intervalPattern.firstDateInPtnIsLaterDate()) {\r\n        firstCal = toCalendar;\r\n        secondCal = fromCalendar;\r\n    } else {\r\n        firstCal = fromCalendar;\r\n        secondCal = toCalendar;\r\n    }\r\n    String originalPattern = fDateFormat.toPattern();\r\n    fDateFormat.applyPattern(intervalPattern.getFirstPart());\r\n    fDateFormat.format(firstCal, appendTo, pos);\r\n    if (intervalPattern.getSecondPart() != null) {\r\n        fDateFormat.applyPattern(intervalPattern.getSecondPart());\r\n        FieldPosition otherPos = new FieldPosition(pos.getField());\r\n        fDateFormat.format(secondCal, appendTo, otherPos);\r\n        if (pos.getEndIndex() == 0 && otherPos.getEndIndex() > 0) {\r\n            pos.setBeginIndex(otherPos.getBeginIndex());\r\n            pos.setEndIndex(otherPos.getEndIndex());\r\n        }\r\n    }\r\n    fDateFormat.applyPattern(originalPattern);\r\n    return appendTo;\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneGenericNames.init",
	"Comment": "private method initializing the instance of timezonegenericname.this method should be called from a constructor and readobject.",
	"Method": "void init(){\r\n    if (_tznames == null) {\r\n        _tznames = TimeZoneNames.getInstance(_locale);\r\n    }\r\n    _genericLocationNamesMap = new ConcurrentHashMap<String, String>();\r\n    _genericPartialLocationNamesMap = new ConcurrentHashMap<String, String>();\r\n    _gnamesTrie = new TextTrieMap<NameInfo>(true);\r\n    _gnamesTrieFullyLoaded = false;\r\n    TimeZone tz = TimeZone.getDefault();\r\n    String tzCanonicalID = ZoneMeta.getCanonicalCLDRID(tz);\r\n    if (tzCanonicalID != null) {\r\n        loadStrings(tzCanonicalID);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedCollator.internalAddContractions",
	"Comment": "adds the contractions that start with character c to the set.ignores prefixes. used by alphabeticindex.",
	"Method": "void internalAddContractions(int c,UnicodeSet set){\r\n    new ContractionsAndExpansions(set, null, null, false).forCodePoint(data, c);\r\n}"
}, {
	"Path": "android.icu.impl.ICUResourceBundle.getKeywordValues",
	"Comment": "given a tree path and keyword, return a string enumeration of all possible values for that keyword.",
	"Method": "String[] getKeywordValues(String baseName,String keyword){\r\n    Set<String> keywords = new HashSet<String>();\r\n    ULocale[] locales = getAvailEntry(baseName, ICU_DATA_CLASS_LOADER).getULocaleList();\r\n    int i;\r\n    for (i = 0; i < locales.length; i++) {\r\n        try {\r\n            UResourceBundle b = UResourceBundle.getBundleInstance(baseName, locales[i]);\r\n            ICUResourceBundle irb = (ICUResourceBundle) (b.getObject(keyword));\r\n            Enumeration<String> e = irb.getKeys();\r\n            while (e.hasMoreElements()) {\r\n                String s = e.nextElement();\r\n                if (!DEFAULT_TAG.equals(s) && !s.startsWith(\"private-\")) {\r\n                    keywords.add(s);\r\n                }\r\n            }\r\n        } catch (Throwable t) {\r\n        }\r\n    }\r\n    return keywords.toArray(new String[0]);\r\n}"
}, {
	"Path": "android.icu.impl.CalendarAstronomer.setTime",
	"Comment": "set the current date and time of this calendarastronomer object.allastronomical calculations are performed based on this time setting.",
	"Method": "void setTime(long aTime){\r\n    time = aTime;\r\n    clearCache();\r\n}"
}, {
	"Path": "android.icu.lang.UScriptRun.getScriptLimit",
	"Comment": "get the index of the first character after the current script run.",
	"Method": "int getScriptLimit(){\r\n    return scriptLimit;\r\n}"
}, {
	"Path": "android.icu.text.CanonicalIterator.getEquivalents",
	"Comment": "we have a segment, in nfd. find all the strings that are canonically equivalent to it.",
	"Method": "String[] getEquivalents(String segment){\r\n    Set<String> result = new HashSet<String>();\r\n    Set<String> basic = getEquivalents2(segment);\r\n    Set<String> permutations = new HashSet<String>();\r\n    Iterator<String> it = basic.iterator();\r\n    while (it.hasNext()) {\r\n        String item = it.next();\r\n        permutations.clear();\r\n        permute(item, SKIP_ZEROS, permutations);\r\n        Iterator<String> it2 = permutations.iterator();\r\n        while (it2.hasNext()) {\r\n            String possible = it2.next();\r\n            if (Normalizer.compare(possible, segment, 0) == 0) {\r\n                if (PROGRESS)\r\n                    System.out.println(\"Adding Permutation: \" + Utility.hex(possible));\r\n                result.add(possible);\r\n            } else {\r\n                if (PROGRESS)\r\n                    System.out.println(\"-Skipping Permutation: \" + Utility.hex(possible));\r\n            }\r\n        }\r\n    }\r\n    String[] finalResult = new String[result.size()];\r\n    result.toArray(finalResult);\r\n    return finalResult;\r\n}"
}, {
	"Path": "android.icu.util.Calendar.compare",
	"Comment": "returns the difference in milliseconds between the moment thiscalendar is set to and the moment the given calendar or date objectis set to.",
	"Method": "long compare(Object that){\r\n    long thatMs;\r\n    if (that instanceof Calendar) {\r\n        thatMs = ((Calendar) that).getTimeInMillis();\r\n    } else if (that instanceof Date) {\r\n        thatMs = ((Date) that).getTime();\r\n    } else {\r\n        throw new IllegalArgumentException(that + \"is not a Calendar or Date\");\r\n    }\r\n    return getTimeInMillis() - thatMs;\r\n}"
}, {
	"Path": "libcore.java.util.TreeMapTest.testEntrySetUsesComparatorOnly",
	"Comment": "test that entry set contains and removal use the comparator rather than equals.",
	"Method": "void testEntrySetUsesComparatorOnly(){\r\n    Map<String, String> map = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\r\n    map.put(\"ABC\", \"a\");\r\n    assertTrue(map.entrySet().contains(new SimpleEntry<String, String>(\"abc\", \"a\")));\r\n    assertTrue(map.entrySet().remove(new SimpleEntry<String, String>(\"abc\", \"a\")));\r\n    assertEquals(0, map.size());\r\n}"
}, {
	"Path": "android.icu.text.Bidi.isOrderParagraphsLTR",
	"Comment": "is this bidi object set to allocate level 0 to blockseparators so that successive paragraphs progress from left to right?",
	"Method": "boolean isOrderParagraphsLTR(){\r\n    return orderParagraphsLTR;\r\n}"
}, {
	"Path": "android.icu.impl.UnicodeSetStringSpan.spanWithStrings",
	"Comment": "synchronized method for complicated spans using the offsets.avoids synchronization for simple cases.",
	"Method": "int spanWithStrings(CharSequence s,int start,int spanLimit,SpanCondition spanCondition){\r\n    int initSize = 0;\r\n    if (spanCondition == SpanCondition.CONTAINED) {\r\n        initSize = maxLength16;\r\n    }\r\n    offsets.setMaxLength(initSize);\r\n    int length = s.length();\r\n    int pos = spanLimit, rest = length - spanLimit;\r\n    int spanLength = spanLimit - start;\r\n    int i, stringsLength = strings.size();\r\n    for (; ; ) {\r\n        if (spanCondition == SpanCondition.CONTAINED) {\r\n            for (i = 0; i < stringsLength; ++i) {\r\n                int overlap = spanLengths[i];\r\n                if (overlap == ALL_CP_CONTAINED) {\r\n                    continue;\r\n                }\r\n                String string = strings.get(i);\r\n                int length16 = string.length();\r\n                if (overlap >= LONG_SPAN) {\r\n                    overlap = length16;\r\n                    overlap = string.offsetByCodePoints(overlap, -1);\r\n                }\r\n                if (overlap > spanLength) {\r\n                    overlap = spanLength;\r\n                }\r\n                int inc = length16 - overlap;\r\n                for (; ; ) {\r\n                    if (inc > rest) {\r\n                        break;\r\n                    }\r\n                    if (!offsets.containsOffset(inc) && matches16CPB(s, pos - overlap, length, string, length16)) {\r\n                        if (inc == rest) {\r\n                            return length;\r\n                        }\r\n                        offsets.addOffset(inc);\r\n                    }\r\n                    if (overlap == 0) {\r\n                        break;\r\n                    }\r\n                    --overlap;\r\n                    ++inc;\r\n                }\r\n            }\r\n        } else {\r\n            int maxInc = 0, maxOverlap = 0;\r\n            for (i = 0; i < stringsLength; ++i) {\r\n                int overlap = spanLengths[i];\r\n                String string = strings.get(i);\r\n                int length16 = string.length();\r\n                if (overlap >= LONG_SPAN) {\r\n                    overlap = length16;\r\n                }\r\n                if (overlap > spanLength) {\r\n                    overlap = spanLength;\r\n                }\r\n                int inc = length16 - overlap;\r\n                for (; ; ) {\r\n                    if (inc > rest || overlap < maxOverlap) {\r\n                        break;\r\n                    }\r\n                    if ((overlap > maxOverlap || inc > maxInc) && matches16CPB(s, pos - overlap, length, string, length16)) {\r\n                        maxInc = inc;\r\n                        maxOverlap = overlap;\r\n                        break;\r\n                    }\r\n                    --overlap;\r\n                    ++inc;\r\n                }\r\n            }\r\n            if (maxInc != 0 || maxOverlap != 0) {\r\n                pos += maxInc;\r\n                rest -= maxInc;\r\n                if (rest == 0) {\r\n                    return length;\r\n                }\r\n                spanLength = 0;\r\n                continue;\r\n            }\r\n        }\r\n        if (spanLength != 0 || pos == 0) {\r\n            if (offsets.isEmpty()) {\r\n                return pos;\r\n            }\r\n        } else {\r\n            if (offsets.isEmpty()) {\r\n                spanLimit = spanSet.span(s, pos, SpanCondition.CONTAINED);\r\n                spanLength = spanLimit - pos;\r\n                if (spanLength == rest || spanLength == 0) {\r\n                    return spanLimit;\r\n                }\r\n                pos += spanLength;\r\n                rest -= spanLength;\r\n                continue;\r\n            } else {\r\n                spanLength = spanOne(spanSet, s, pos, rest);\r\n                if (spanLength > 0) {\r\n                    if (spanLength == rest) {\r\n                        return length;\r\n                    }\r\n                    pos += spanLength;\r\n                    rest -= spanLength;\r\n                    offsets.shift(spanLength);\r\n                    spanLength = 0;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        int minOffset = offsets.popMinimum(null);\r\n        pos += minOffset;\r\n        rest -= minOffset;\r\n        spanLength = 0;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.StringSearch.getPattern",
	"Comment": "returns the pattern for which stringsearch is searching for.",
	"Method": "String getPattern(){\r\n    return pattern_.text_;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.formatToCharacterIterator",
	"Comment": "formats the object to an attributed string, and return the corresponding iterator.",
	"Method": "AttributedCharacterIterator formatToCharacterIterator(Object obj,AttributedCharacterIterator formatToCharacterIterator,Object obj,Unit unit){\r\n    if (!(obj instanceof Number))\r\n        throw new IllegalArgumentException();\r\n    Number number = (Number) obj;\r\n    StringBuffer text = new StringBuffer();\r\n    unit.writePrefix(text);\r\n    attributes.clear();\r\n    if (obj instanceof BigInteger) {\r\n        format((BigInteger) number, text, new FieldPosition(0), true);\r\n    } else if (obj instanceof java.math.BigDecimal) {\r\n        format((java.math.BigDecimal) number, text, new FieldPosition(0), true);\r\n    } else if (obj instanceof Double) {\r\n        format(number.doubleValue(), text, new FieldPosition(0), true);\r\n    } else if (obj instanceof Integer || obj instanceof Long) {\r\n        format(number.longValue(), text, new FieldPosition(0), true);\r\n    } else {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    unit.writeSuffix(text);\r\n    AttributedString as = new AttributedString(text.toString());\r\n    for (int i = 0; i < attributes.size(); i++) {\r\n        FieldPosition pos = attributes.get(i);\r\n        Format.Field attribute = pos.getFieldAttribute();\r\n        as.addAttribute(attribute, attribute, pos.getBeginIndex(), pos.getEndIndex());\r\n    }\r\n    return as.getIterator();\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.applyPattern",
	"Comment": "apply the given unlocalized pattern string to this date format.",
	"Method": "void applyPattern(String pat){\r\n    this.pattern = pat;\r\n    parsePattern();\r\n    setLocale(null, null);\r\n    patternItems = null;\r\n}"
}, {
	"Path": "android.icu.util.Holiday.firstBetween",
	"Comment": "return the first occurrence of this holiday that is on or afterthe given start date and before the given end date.",
	"Method": "Date firstBetween(Date start,Date end){\r\n    return rule.firstBetween(start, end);\r\n}"
}, {
	"Path": "android.icu.text.TimeZoneFormat.truncateOffsetPattern",
	"Comment": "todo this code will be obsoleted once we add hour pattern data in cldr",
	"Method": "String truncateOffsetPattern(String offsetHM){\r\n    int idx_mm = offsetHM.indexOf(\"mm\");\r\n    if (idx_mm < 0) {\r\n        throw new RuntimeException(\"Bad time zone hour pattern data\");\r\n    }\r\n    int idx_HH = offsetHM.substring(0, idx_mm).lastIndexOf(\"HH\");\r\n    if (idx_HH >= 0) {\r\n        return offsetHM.substring(0, idx_HH + 2);\r\n    }\r\n    int idx_H = offsetHM.substring(0, idx_mm).lastIndexOf(\"H\");\r\n    if (idx_H >= 0) {\r\n        return offsetHM.substring(0, idx_H + 1);\r\n    }\r\n    throw new RuntimeException(\"Bad time zone hour pattern data\");\r\n}"
}, {
	"Path": "android.icu.text.Bidi.setReorderingOptions",
	"Comment": "specify which of the reordering options should be applied during biditransformations.",
	"Method": "void setReorderingOptions(int options){\r\n    if ((options & OPTION_REMOVE_CONTROLS) != 0) {\r\n        this.reorderingOptions = options & ~OPTION_INSERT_MARKS;\r\n    } else {\r\n        this.reorderingOptions = options;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.Transliterator.getFilter",
	"Comment": "returns the filter used by this transliterator, or nullif this transliterator uses no filter.",
	"Method": "UnicodeFilter getFilter(){\r\n    return filter;\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.CopticTest.TestEraStart",
	"Comment": "eventually should modify to use locale strings and formatter appropriate to coptic calendar",
	"Method": "void TestEraStart(){\r\n    SimpleDateFormat fmt = new SimpleDateFormat(\"EEE MMM dd, yyyy GG\");\r\n    SimpleDateFormat copticFmt = new SimpleDateFormat(\"EEE MMM dd, yyyy GG\");\r\n    copticFmt.setCalendar(new CopticCalendar());\r\n    CopticCalendar cal = new CopticCalendar(1, 0, 1);\r\n    assertEquals(\"Coptic Date\", \"Fri Jan 01, 0001 AD\", copticFmt.format(cal));\r\n    assertEquals(\"Gregorian Date\", \"Fri Aug 29, 0284 AD\", fmt.format(cal.getTime()));\r\n    cal.set(Calendar.ERA, 0);\r\n    cal.set(Calendar.YEAR, 1);\r\n    assertEquals(\"Coptic Date\", \"Thu Jan 01, 0001 BC\", copticFmt.format(cal));\r\n    assertEquals(\"Gregorian Date\", \"Thu Aug 30, 0283 AD\", fmt.format(cal.getTime()));\r\n}"
}, {
	"Path": "android.icu.text.CurrencyPluralInfo.getPluralRules",
	"Comment": "gets plural rules of this locale, used for currency plural format",
	"Method": "PluralRules getPluralRules(){\r\n    return pluralRules;\r\n}"
}, {
	"Path": "android.icu.text.DateIntervalFormat.genFallbackPattern",
	"Comment": "generate fall back interval pattern given a calendar field,a skeleton, and a date time pattern generator",
	"Method": "void genFallbackPattern(int field,String skeleton,Map<String, PatternInfo> intervalPatterns,DateTimePatternGenerator dtpng){\r\n    String pattern = dtpng.getBestPattern(skeleton);\r\n    PatternInfo ptn = new PatternInfo(null, pattern, fInfo.getDefaultOrder());\r\n    intervalPatterns.put(DateIntervalInfo.CALENDAR_FIELD_TO_PATTERN_LETTER[field], ptn);\r\n}"
}, {
	"Path": "android.icu.util.Currency.getAvailableULocales",
	"Comment": "return an array of the ulocales for which a currencyis defined.",
	"Method": "ULocale[] getAvailableULocales(ULocale[] getAvailableULocales){\r\n    if (shim == null) {\r\n        return ICUResourceBundle.getAvailableULocales();\r\n    } else {\r\n        return shim.getAvailableULocales();\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.readFields",
	"Comment": "reads the persistent fields of the object that is currently being readfrom the source stream. the values read are stored in a getfield objectthat provides access to the persistent fields. this getfield object isthen returned.",
	"Method": "GetField readFields(){\r\n    if (currentObject == null) {\r\n        throw new NotActiveException();\r\n    }\r\n    EmulatedFieldsForLoading result = new EmulatedFieldsForLoading(currentClass);\r\n    readFieldValues(result);\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.text.StringCharacterIterator.equals",
	"Comment": "compares the equality of two stringcharacteriterator objects.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (!(obj instanceof StringCharacterIterator)) {\r\n        return false;\r\n    }\r\n    StringCharacterIterator that = (StringCharacterIterator) obj;\r\n    if (hashCode() != that.hashCode()) {\r\n        return false;\r\n    }\r\n    if (!text.equals(that.text)) {\r\n        return false;\r\n    }\r\n    if (pos != that.pos || begin != that.begin || end != that.end) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "android.icu.text.PluralRules.select",
	"Comment": "given a number information, returns the keyword of the first rule that applies tothe number.",
	"Method": "String select(FixedDecimal n,boolean select,FixedDecimal sample,String keyword,String select,double number,String select,double number,int countVisibleFractionDigits,long fractionaldigits,String select,FixedDecimal number){\r\n    return rules.select(number);\r\n}"
}, {
	"Path": "android.icu.util.ChineseCalendar.handleGetLimit",
	"Comment": "override calendar to return the limit value for the given field.",
	"Method": "int handleGetLimit(int field,int limitType){\r\n    return LIMITS[field][limitType];\r\n}"
}, {
	"Path": "android.icu.util.UResourceBundleIterator.reset",
	"Comment": "resets the internal context of a resource so that iteration starts from the first element.",
	"Method": "void reset(){\r\n    index = 0;\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.HebrewTest.TestRoll",
	"Comment": "test the behavior of hebrewcalendar.rollthe only real nastiness with roll is the month field, since a year canhave a variable number of months.",
	"Method": "void TestRoll(){\r\n    int[][] tests = new int[][] { { 5759, HESHVAN, 2, MONTH, 1, 5759, KISLEV, 2 }, { 5759, SHEVAT, 2, MONTH, 1, 5759, ADAR, 2 }, { 5759, SHEVAT, 2, MONTH, 2, 5759, NISAN, 2 }, { 5759, SHEVAT, 2, MONTH, 12, 5759, SHEVAT, 2 }, { 5759, AV, 1, MONTH, 12, 5759, AV, 1 }, { 5757, HESHVAN, 2, MONTH, 1, 5757, KISLEV, 2 }, { 5757, SHEVAT, 2, MONTH, 1, 5757, ADAR_1, 2 }, { 5757, SHEVAT, 2, MONTH, 2, 5757, ADAR, 2 }, { 5757, SHEVAT, 2, MONTH, 3, 5757, NISAN, 2 }, { 5757, SHEVAT, 2, MONTH, 12, 5757, TEVET, 2 }, { 5757, SHEVAT, 2, MONTH, 13, 5757, SHEVAT, 2 }, { 5757, AV, 1, MONTH, 12, 5757, TAMUZ, 1 }, { 5757, KISLEV, 1, DATE, 30, 5757, KISLEV, 2 }, { 5758, KISLEV, 1, DATE, 31, 5758, KISLEV, 2 }, { 5757, TISHRI, 1, YEAR, 1, 5758, TISHRI, 1 }, { 5757, TISHRI, 30, MONTH, 1, 5757, HESHVAN, 29 }, { 5758, KISLEV, 30, YEAR, -1, 5757, KISLEV, 29 } };\r\n    HebrewCalendar cal = new HebrewCalendar(UTC, Locale.getDefault());\r\n    doRollAdd(ROLL, cal, tests);\r\n}"
}, {
	"Path": "android.icu.text.DateIntervalInfo.getIntervalPattern",
	"Comment": "get the interval pattern given the largest different calendar field.",
	"Method": "PatternInfo getIntervalPattern(String skeleton,int field){\r\n    if (field > MINIMUM_SUPPORTED_CALENDAR_FIELD) {\r\n        throw new IllegalArgumentException(\"no support for field less than SECOND\");\r\n    }\r\n    Map<String, PatternInfo> patternsOfOneSkeleton = fIntervalPatterns.get(skeleton);\r\n    if (patternsOfOneSkeleton != null) {\r\n        PatternInfo intervalPattern = patternsOfOneSkeleton.get(CALENDAR_FIELD_TO_PATTERN_LETTER[field]);\r\n        if (intervalPattern != null) {\r\n            return intervalPattern;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.impl.TextTrieMap.get",
	"Comment": "gets an iterator of the objects associated with thelongest prefix matching string key starting at thespecified position.",
	"Method": "Iterator<V> get(String text,Iterator<V> get,CharSequence text,int start,Iterator<V> get,CharSequence text,int start,int[] matchLen){\r\n    LongestMatchHandler<V> handler = new LongestMatchHandler<V>();\r\n    find(text, start, handler);\r\n    if (matchLen != null && matchLen.length > 0) {\r\n        matchLen[0] = handler.getMatchLength();\r\n    }\r\n    return handler.getMatches();\r\n}"
}, {
	"Path": "android.icu.util.ChineseCalendar.majorSolarTerm",
	"Comment": "return the major solar term on or before a given date.thiswill be an integer from 1..12, with 1 corresponding to 330 degrees,2 to 0 degrees, 3 to 30 degrees,..., and 12 to 300 degrees.",
	"Method": "int majorSolarTerm(int days){\r\n    astro.setTime(daysToMillis(days));\r\n    int term = ((int) Math.floor(6 * astro.getSunLongitude() / Math.PI) + 2) % 12;\r\n    if (term < 1) {\r\n        term += 12;\r\n    }\r\n    return term;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.subparse",
	"Comment": "parses the given text into a number. the text is parsed beginning at parseposition,until an unparseable character is seen.",
	"Method": "boolean subparse(String text,ParsePosition parsePosition,DigitList digits,boolean status,Currency currency,String negPrefix,String negSuffix,String posPrefix,String posSuffix,boolean parseComplexCurrency,int type){\r\n    int position = parsePosition.getIndex();\r\n    int oldStart = parsePosition.getIndex();\r\n    if (formatWidth > 0 && padPosition == PAD_BEFORE_PREFIX) {\r\n        position = skipPadding(text, position);\r\n    }\r\n    int posMatch = compareAffix(text, position, false, true, posPrefix, parseComplexCurrency, type, currency);\r\n    int negMatch = compareAffix(text, position, true, true, negPrefix, parseComplexCurrency, type, currency);\r\n    if (posMatch >= 0 && negMatch >= 0) {\r\n        if (posMatch > negMatch) {\r\n            negMatch = -1;\r\n        } else if (negMatch > posMatch) {\r\n            posMatch = -1;\r\n        }\r\n    }\r\n    if (posMatch >= 0) {\r\n        position += posMatch;\r\n    } else if (negMatch >= 0) {\r\n        position += negMatch;\r\n    } else {\r\n        parsePosition.setErrorIndex(position);\r\n        return false;\r\n    }\r\n    if (formatWidth > 0 && padPosition == PAD_AFTER_PREFIX) {\r\n        position = skipPadding(text, position);\r\n    }\r\n    status[STATUS_INFINITE] = false;\r\n    if (text.regionMatches(position, symbols.getInfinity(), 0, symbols.getInfinity().length())) {\r\n        position += symbols.getInfinity().length();\r\n        status[STATUS_INFINITE] = true;\r\n    } else {\r\n        digits.decimalAt = digits.count = 0;\r\n        String decimal = (currencySignCount == CURRENCY_SIGN_COUNT_ZERO) ? symbols.getDecimalSeparatorString() : symbols.getMonetaryDecimalSeparatorString();\r\n        String grouping = (currencySignCount == CURRENCY_SIGN_COUNT_ZERO) ? symbols.getGroupingSeparatorString() : symbols.getMonetaryGroupingSeparatorString();\r\n        String exponentSep = symbols.getExponentSeparator();\r\n        boolean sawDecimal = false;\r\n        boolean sawGrouping = false;\r\n        boolean sawDigit = false;\r\n        long exponent = 0;\r\n        boolean strictParse = isParseStrict();\r\n        boolean strictFail = false;\r\n        int lastGroup = -1;\r\n        int groupedDigitCount = 0;\r\n        int gs2 = groupingSize2 == 0 ? groupingSize : groupingSize2;\r\n        UnicodeSet decimalEquiv = skipExtendedSeparatorParsing ? UnicodeSet.EMPTY : getEquivalentDecimals(decimal, strictParse);\r\n        UnicodeSet groupEquiv = skipExtendedSeparatorParsing ? UnicodeSet.EMPTY : (strictParse ? strictDefaultGroupingSeparators : defaultGroupingSeparators);\r\n        int digitCount = 0;\r\n        int backup = -1;\r\n        int[] parsedDigit = { -1 };\r\n        while (position < text.length()) {\r\n            int matchLen = matchesDigit(text, position, parsedDigit);\r\n            if (matchLen > 0) {\r\n                if (backup != -1) {\r\n                    if (strictParse) {\r\n                        if ((lastGroup != -1 && groupedDigitCount != gs2) || (lastGroup == -1 && groupedDigitCount > gs2)) {\r\n                            strictFail = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    lastGroup = backup;\r\n                    groupedDigitCount = 0;\r\n                }\r\n                groupedDigitCount++;\r\n                position += matchLen;\r\n                backup = -1;\r\n                sawDigit = true;\r\n                if (parsedDigit[0] == 0 && digits.count == 0) {\r\n                    if (!sawDecimal) {\r\n                        continue;\r\n                    }\r\n                    --digits.decimalAt;\r\n                } else {\r\n                    ++digitCount;\r\n                    digits.append((char) (parsedDigit[0] + '0'));\r\n                }\r\n                continue;\r\n            }\r\n            int decimalStrLen = decimal.length();\r\n            if (text.regionMatches(position, decimal, 0, decimalStrLen)) {\r\n                if (strictParse) {\r\n                    if (backup != -1 || (lastGroup != -1 && groupedDigitCount != groupingSize)) {\r\n                        strictFail = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (isParseIntegerOnly() || sawDecimal) {\r\n                    break;\r\n                }\r\n                digits.decimalAt = digitCount;\r\n                sawDecimal = true;\r\n                position += decimalStrLen;\r\n                continue;\r\n            }\r\n            if (isGroupingUsed()) {\r\n                int groupingStrLen = grouping.length();\r\n                if (text.regionMatches(position, grouping, 0, groupingStrLen)) {\r\n                    if (sawDecimal) {\r\n                        break;\r\n                    }\r\n                    if (strictParse) {\r\n                        if ((!sawDigit || backup != -1)) {\r\n                            strictFail = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    backup = position;\r\n                    position += groupingStrLen;\r\n                    sawGrouping = true;\r\n                    continue;\r\n                }\r\n            }\r\n            int cp = text.codePointAt(position);\r\n            if (!sawDecimal && decimalEquiv.contains(cp)) {\r\n                if (strictParse) {\r\n                    if (backup != -1 || (lastGroup != -1 && groupedDigitCount != groupingSize)) {\r\n                        strictFail = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (isParseIntegerOnly()) {\r\n                    break;\r\n                }\r\n                digits.decimalAt = digitCount;\r\n                decimal = String.valueOf(Character.toChars(cp));\r\n                sawDecimal = true;\r\n                position += Character.charCount(cp);\r\n                continue;\r\n            }\r\n            if (isGroupingUsed() && !sawGrouping && groupEquiv.contains(cp)) {\r\n                if (sawDecimal) {\r\n                    break;\r\n                }\r\n                if (strictParse) {\r\n                    if ((!sawDigit || backup != -1)) {\r\n                        strictFail = true;\r\n                        break;\r\n                    }\r\n                }\r\n                grouping = String.valueOf(Character.toChars(cp));\r\n                backup = position;\r\n                position += Character.charCount(cp);\r\n                sawGrouping = true;\r\n                continue;\r\n            }\r\n            int exponentSepStrLen = exponentSep.length();\r\n            if (text.regionMatches(true, position, exponentSep, 0, exponentSepStrLen)) {\r\n                boolean negExp = false;\r\n                int pos = position + exponentSep.length();\r\n                if (pos < text.length()) {\r\n                    String plusSign = symbols.getPlusSignString();\r\n                    String minusSign = symbols.getMinusSignString();\r\n                    if (text.regionMatches(pos, plusSign, 0, plusSign.length())) {\r\n                        pos += plusSign.length();\r\n                    } else if (text.regionMatches(pos, minusSign, 0, minusSign.length())) {\r\n                        pos += minusSign.length();\r\n                        negExp = true;\r\n                    }\r\n                }\r\n                DigitList exponentDigits = new DigitList();\r\n                exponentDigits.count = 0;\r\n                while (pos < text.length()) {\r\n                    int digitMatchLen = matchesDigit(text, pos, parsedDigit);\r\n                    if (digitMatchLen > 0) {\r\n                        exponentDigits.append((char) (parsedDigit[0] + '0'));\r\n                        pos += digitMatchLen;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                if (exponentDigits.count > 0) {\r\n                    if (strictParse && sawGrouping) {\r\n                        strictFail = true;\r\n                        break;\r\n                    }\r\n                    if (exponentDigits.count > 10) {\r\n                        if (negExp) {\r\n                            status[STATUS_UNDERFLOW] = true;\r\n                        } else {\r\n                            status[STATUS_INFINITE] = true;\r\n                        }\r\n                    } else {\r\n                        exponentDigits.decimalAt = exponentDigits.count;\r\n                        exponent = exponentDigits.getLong();\r\n                        if (negExp) {\r\n                            exponent = -exponent;\r\n                        }\r\n                    }\r\n                    position = pos;\r\n                }\r\n                break;\r\n            }\r\n            break;\r\n        }\r\n        if (digits.decimalAt == 0 && isDecimalPatternMatchRequired()) {\r\n            if (this.formatPattern.indexOf(decimal) != -1) {\r\n                parsePosition.setIndex(oldStart);\r\n                parsePosition.setErrorIndex(position);\r\n                return false;\r\n            }\r\n        }\r\n        if (backup != -1)\r\n            position = backup;\r\n        if (!sawDecimal) {\r\n            digits.decimalAt = digitCount;\r\n        }\r\n        if (strictParse && !sawDecimal) {\r\n            if (lastGroup != -1 && groupedDigitCount != groupingSize) {\r\n                strictFail = true;\r\n            }\r\n        }\r\n        if (strictFail) {\r\n            parsePosition.setIndex(oldStart);\r\n            parsePosition.setErrorIndex(position);\r\n            return false;\r\n        }\r\n        exponent += digits.decimalAt;\r\n        if (exponent < -getParseMaxDigits()) {\r\n            status[STATUS_UNDERFLOW] = true;\r\n        } else if (exponent > getParseMaxDigits()) {\r\n            status[STATUS_INFINITE] = true;\r\n        } else {\r\n            digits.decimalAt = (int) exponent;\r\n        }\r\n        if (!sawDigit && digitCount == 0) {\r\n            parsePosition.setIndex(oldStart);\r\n            parsePosition.setErrorIndex(oldStart);\r\n            return false;\r\n        }\r\n    }\r\n    if (formatWidth > 0 && padPosition == PAD_BEFORE_SUFFIX) {\r\n        position = skipPadding(text, position);\r\n    }\r\n    if (posMatch >= 0) {\r\n        posMatch = compareAffix(text, position, false, false, posSuffix, parseComplexCurrency, type, currency);\r\n    }\r\n    if (negMatch >= 0) {\r\n        negMatch = compareAffix(text, position, true, false, negSuffix, parseComplexCurrency, type, currency);\r\n    }\r\n    if (posMatch >= 0 && negMatch >= 0) {\r\n        if (posMatch > negMatch) {\r\n            negMatch = -1;\r\n        } else if (negMatch > posMatch) {\r\n            posMatch = -1;\r\n        }\r\n    }\r\n    if ((posMatch >= 0) == (negMatch >= 0)) {\r\n        parsePosition.setErrorIndex(position);\r\n        return false;\r\n    }\r\n    position += (posMatch >= 0 ? posMatch : negMatch);\r\n    if (formatWidth > 0 && padPosition == PAD_AFTER_SUFFIX) {\r\n        position = skipPadding(text, position);\r\n    }\r\n    parsePosition.setIndex(position);\r\n    status[STATUS_POSITIVE] = (posMatch >= 0);\r\n    if (parsePosition.getIndex() == oldStart) {\r\n        parsePosition.setErrorIndex(position);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "android.icu.text.Transliterator.createFromRules",
	"Comment": "returns a transliterator object constructed fromthe given rule string.this will be a rulebasedtransliterator,if the rule string contains only rules, or acompoundtransliterator, if it contains id blocks, or anulltransliterator, if it contains id blocks which parse asempty for the given direction.",
	"Method": "Transliterator createFromRules(String ID,String rules,int dir){\r\n    Transliterator t = null;\r\n    TransliteratorParser parser = new TransliteratorParser();\r\n    parser.parse(rules, dir);\r\n    if (parser.idBlockVector.size() == 0 && parser.dataVector.size() == 0) {\r\n        t = new NullTransliterator();\r\n    } else if (parser.idBlockVector.size() == 0 && parser.dataVector.size() == 1) {\r\n        t = new RuleBasedTransliterator(ID, parser.dataVector.get(0), parser.compoundFilter);\r\n    } else if (parser.idBlockVector.size() == 1 && parser.dataVector.size() == 0) {\r\n        if (parser.compoundFilter != null) {\r\n            t = getInstance(parser.compoundFilter.toPattern(false) + \";\" + parser.idBlockVector.get(0));\r\n        } else {\r\n            t = getInstance(parser.idBlockVector.get(0));\r\n        }\r\n        if (t != null) {\r\n            t.setID(ID);\r\n        }\r\n    } else {\r\n        List<Transliterator> transliterators = new ArrayList<Transliterator>();\r\n        int passNumber = 1;\r\n        int limit = Math.max(parser.idBlockVector.size(), parser.dataVector.size());\r\n        for (int i = 0; i < limit; i++) {\r\n            if (i < parser.idBlockVector.size()) {\r\n                String idBlock = parser.idBlockVector.get(i);\r\n                if (idBlock.length() > 0) {\r\n                    Transliterator temp = getInstance(idBlock);\r\n                    if (!(temp instanceof NullTransliterator))\r\n                        transliterators.add(getInstance(idBlock));\r\n                }\r\n            }\r\n            if (i < parser.dataVector.size()) {\r\n                Data data = parser.dataVector.get(i);\r\n                transliterators.add(new RuleBasedTransliterator(\"%Pass\" + passNumber++, data, null));\r\n            }\r\n        }\r\n        t = new CompoundTransliterator(transliterators, passNumber - 1);\r\n        t.setID(ID);\r\n        if (parser.compoundFilter != null) {\r\n            t.setFilter(parser.compoundFilter);\r\n        }\r\n    }\r\n    return t;\r\n}"
}, {
	"Path": "android.icu.util.BytesTrie.current",
	"Comment": "determines whether the byte sequence so far matches, whether it has a value,and whether another input byte can continue a matching byte sequence.",
	"Method": "Result current(){\r\n    int pos = pos_;\r\n    if (pos < 0) {\r\n        return Result.NO_MATCH;\r\n    } else {\r\n        int node;\r\n        return (remainingMatchLength_ < 0 && (node = bytes_[pos] & 0xff) >= kMinValueLead) ? valueResults_[node & kValueIsFinal] : Result.NO_VALUE;\r\n    }\r\n}"
}, {
	"Path": "java.io.FileDescriptor.sync",
	"Comment": "ensures that data which is buffered within the underlying implementationis written out to the appropriate device before returning.",
	"Method": "void sync(){\r\n    try {\r\n        if (Libcore.os.isatty(this)) {\r\n            Libcore.os.tcdrain(this);\r\n        } else {\r\n            Libcore.os.fsync(this);\r\n        }\r\n    } catch (ErrnoException errnoException) {\r\n        SyncFailedException sfe = new SyncFailedException(errnoException.getMessage());\r\n        sfe.initCause(errnoException);\r\n        throw sfe;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.TransliteratorRegistry.getAvailableIDs",
	"Comment": "returns an enumeration over the programmatic names of visibleregistered transliterators.",
	"Method": "Enumeration<String> getAvailableIDs(){\r\n    return new IDEnumeration(Collections.enumeration(availableIDs));\r\n}"
}, {
	"Path": "android.icu.text.PluralRules.matches",
	"Comment": "given a number information, and keyword, return whether the keyword would match the number.",
	"Method": "boolean matches(FixedDecimal sample,String keyword){\r\n    return rules.select(sample, keyword);\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedTransliterator.safeClone",
	"Comment": "temporary hack for registry problem. needs to be replaced by better architecture.",
	"Method": "Transliterator safeClone(){\r\n    UnicodeFilter filter = getFilter();\r\n    if (filter != null && filter instanceof UnicodeSet) {\r\n        filter = new UnicodeSet((UnicodeSet) filter);\r\n    }\r\n    return new RuleBasedTransliterator(getID(), data, filter);\r\n}"
}, {
	"Path": "android.icu.impl.UCharacterName.getGroup",
	"Comment": "gets the group index for the codepoint, or the group before it.",
	"Method": "int getGroup(int codepoint){\r\n    int endGroup = m_groupcount_;\r\n    int msb = getCodepointMSB(codepoint);\r\n    int result = 0;\r\n    while (result < endGroup - 1) {\r\n        int gindex = (result + endGroup) >> 1;\r\n        if (msb < getGroupMSB(gindex)) {\r\n            endGroup = gindex;\r\n        } else {\r\n            result = gindex;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.setPerMill",
	"Comment": "sets the character used for mille percent sign. different for arabic, etc.",
	"Method": "void setPerMill(char perMill){\r\n    this.perMill = perMill;\r\n    this.perMillString = String.valueOf(perMill);\r\n}"
}, {
	"Path": "android.icu.util.AnnualTimeZoneRule.toString",
	"Comment": "returns a string representation of this annualtimezonerule object.this method is used for debugging purpose only.the string representation can be changedin future version of icu without any notice.",
	"Method": "String toString(){\r\n    StringBuilder buf = new StringBuilder();\r\n    buf.append(super.toString());\r\n    buf.append(\", rule={\" + dateTimeRule + \"}\");\r\n    buf.append(\", startYear=\" + startYear);\r\n    buf.append(\", endYear=\");\r\n    if (endYear == MAX_YEAR) {\r\n        buf.append(\"max\");\r\n    } else {\r\n        buf.append(endYear);\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "android.icu.text.Bidi.getReorderingOptions",
	"Comment": "what are the reordering options applied to a given bidi object?",
	"Method": "int getReorderingOptions(){\r\n    return this.reorderingOptions;\r\n}"
}, {
	"Path": "android.icu.text.LocaleDisplayNames.getInstance",
	"Comment": "returns an instance of localedisplaynames that returns names formatted for the provided locale,using the provided displaycontext settings",
	"Method": "LocaleDisplayNames getInstance(ULocale locale,LocaleDisplayNames getInstance,Locale locale,LocaleDisplayNames getInstance,ULocale locale,DialectHandling dialectHandling,LocaleDisplayNames getInstance,ULocale locale,DisplayContext contexts,LocaleDisplayNames getInstance,Locale locale,DisplayContext contexts){\r\n    return getInstance(ULocale.forLocale(locale), contexts);\r\n}"
}, {
	"Path": "android.icu.impl.CharTrie.getValue",
	"Comment": "gets the value at the argument index. for use internally in trieiterator.",
	"Method": "int getValue(int index){\r\n    return m_data_[index];\r\n}"
}, {
	"Path": "android.icu.text.TimeZoneNames.getInstance",
	"Comment": "returns an instance of timezonenames for the specified locale.",
	"Method": "TimeZoneNames getInstance(ULocale locale,TimeZoneNames getInstance,Locale locale){\r\n    return getInstance(ULocale.forLocale(locale));\r\n}"
}, {
	"Path": "android.icu.impl.ICULocaleService.validateFallbackLocale",
	"Comment": "return the name of the current fallback locale.if it has changed since this waslast accessed, the service cache is cleared.",
	"Method": "String validateFallbackLocale(){\r\n    ULocale loc = ULocale.getDefault();\r\n    if (loc != fallbackLocale) {\r\n        synchronized (this) {\r\n            if (loc != fallbackLocale) {\r\n                fallbackLocale = loc;\r\n                fallbackLocaleName = loc.getBaseName();\r\n                clearServiceCache();\r\n            }\r\n        }\r\n    }\r\n    return fallbackLocaleName;\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.HebrewTest.TestTimeFields",
	"Comment": "problem reported by armand bendanan in which setting of the monthfield in a hebrew calendar causes the time fields to go negative.",
	"Method": "void TestTimeFields(){\r\n    try {\r\n        HebrewCalendar calendar = new HebrewCalendar(5761, 0, 11, 12, 28, 15);\r\n        calendar.set(Calendar.YEAR, 5717);\r\n        calendar.set(Calendar.MONTH, 2);\r\n        calendar.set(Calendar.DAY_OF_MONTH, 23);\r\n        if (calendar.get(Calendar.HOUR_OF_DAY) != 12) {\r\n            errln(\"Fail: HebrewCalendar HOUR_OF_DAY = \" + calendar.get(Calendar.HOUR_OF_DAY));\r\n        }\r\n    } catch (MissingResourceException ex) {\r\n        warnln(\"Got Exception: \" + ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationMiscTest.doTestOneReorderingAPITestCase",
	"Comment": "utility function to test one collation reordering test case.",
	"Method": "void doTestOneReorderingAPITestCase(OneTestCase testCases,int reorderTokens){\r\n    Collator myCollation = Collator.getInstance(ULocale.ENGLISH);\r\n    myCollation.setReorderCodes(reorderTokens);\r\n    for (OneTestCase testCase : testCases) {\r\n        CollationTest.doTest(this, (RuleBasedCollator) myCollation, testCase.m_source_, testCase.m_target_, testCase.m_result_);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedCollator.setFrenchCollation",
	"Comment": "sets the mode for the direction of secondary weights to be used in french collation. the default value is false,which treats secondary weights in the order they appear. if set to true, the secondary weights will be sortedbackwards. see the section on french collation for more information.",
	"Method": "void setFrenchCollation(boolean flag){\r\n    checkNotFrozen();\r\n    if (flag == isFrenchCollation()) {\r\n        return;\r\n    }\r\n    CollationSettings ownedSettings = getOwnedSettings();\r\n    ownedSettings.setFlag(CollationSettings.BACKWARD_SECONDARY, flag);\r\n    setFastLatinOptions(ownedSettings);\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.factories",
	"Comment": "return a snapshot of the currently registered factories.thereis no guarantee that the list will still match the currentfactory list of the service subsequent to this call.",
	"Method": "List<Factory> factories(){\r\n    try {\r\n        factoryLock.acquireRead();\r\n        return new ArrayList<Factory>(factories);\r\n    } finally {\r\n        factoryLock.releaseRead();\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneNamesImpl.loadMetaZoneNames",
	"Comment": "returns a set of names for the given meta zone id. this method loadsthe set of names into the internal map and trie for future references.",
	"Method": "ZNames loadMetaZoneNames(String mzID){\r\n    ZNames mznames = _mzNamesMap.get(mzID);\r\n    if (mznames == null) {\r\n        ZNamesLoader loader = new ZNamesLoader();\r\n        loader.loadMetaZone(_zoneStrings, mzID);\r\n        mznames = ZNames.createMetaZoneAndPutInCache(_mzNamesMap, loader.getNames(), mzID);\r\n    }\r\n    return mznames;\r\n}"
}, {
	"Path": "android.icu.impl.Grego.timeToString",
	"Comment": "convenient method for formatting time to iso 8601 styledate string.",
	"Method": "String timeToString(long time){\r\n    int[] fields = timeToFields(time, null);\r\n    int millis = fields[5];\r\n    int hour = millis / MILLIS_PER_HOUR;\r\n    millis = millis % MILLIS_PER_HOUR;\r\n    int min = millis / MILLIS_PER_MINUTE;\r\n    millis = millis % MILLIS_PER_MINUTE;\r\n    int sec = millis / MILLIS_PER_SECOND;\r\n    millis = millis % MILLIS_PER_SECOND;\r\n    return String.format((Locale) null, \"d-d-dTd:d:d.dZ\", fields[0], fields[1] + 1, fields[2], hour, min, sec, millis);\r\n}"
}, {
	"Path": "android.icu.text.BreakIterator.setLocale",
	"Comment": "set information about the locales that were used to create thisobject.if the object was not constructed from locale data,both arguments should be set to null.otherwise, neithershould be null.the actual locale must be at the same level orless specific than the valid locale.this method is intendedfor use by factories or other entities that create objects ofthis class.",
	"Method": "void setLocale(ULocale valid,ULocale actual){\r\n    if ((valid == null) != (actual == null)) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    this.validLocale = valid;\r\n    this.actualLocale = actual;\r\n}"
}, {
	"Path": "java.text.CollationKey.getSourceString",
	"Comment": "returns the string from which this collation key was created.",
	"Method": "String getSourceString(){\r\n    return source;\r\n}"
}, {
	"Path": "android.icu.impl.CharTrie.getCodePointValue",
	"Comment": "gets the value associated with the codepoint. if no value is associated with the codepoint, a default value will be returned.",
	"Method": "char getCodePointValue(int ch){\r\n    int offset;\r\n    if (0 <= ch && ch < UTF16.LEAD_SURROGATE_MIN_VALUE) {\r\n        offset = (m_index_[ch >> INDEX_STAGE_1_SHIFT_] << INDEX_STAGE_2_SHIFT_) + (ch & INDEX_STAGE_3_MASK_);\r\n        return m_data_[offset];\r\n    }\r\n    offset = getCodePointOffset(ch);\r\n    return (offset >= 0) ? m_data_[offset] : m_initialValue_;\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneAdapter.wrap",
	"Comment": "given a java.util.timezone, wrap it in the appropriate adaptersubclass of android.icu.util.timezone and return the adapter.",
	"Method": "java.util.TimeZone wrap(android.icu.util.TimeZone tz){\r\n    return new TimeZoneAdapter(tz);\r\n}"
}, {
	"Path": "android.icu.impl.Punycode.encode",
	"Comment": "converts unicode to punycode.the input string must not contain single, unpaired surrogates.the output will be represented as an array of ascii code points.",
	"Method": "StringBuilder encode(CharSequence src,boolean[] caseFlags){\r\n    int n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, srcCPCount;\r\n    char c, c2;\r\n    int srcLength = src.length();\r\n    int[] cpBuffer = new int[srcLength];\r\n    StringBuilder dest = new StringBuilder(srcLength);\r\n    srcCPCount = 0;\r\n    for (j = 0; j < srcLength; ++j) {\r\n        c = src.charAt(j);\r\n        if (isBasic(c)) {\r\n            cpBuffer[srcCPCount++] = 0;\r\n            dest.append(caseFlags != null ? asciiCaseMap(c, caseFlags[j]) : c);\r\n        } else {\r\n            n = ((caseFlags != null && caseFlags[j]) ? 1 : 0) << 31L;\r\n            if (!UTF16.isSurrogate(c)) {\r\n                n |= c;\r\n            } else if (UTF16.isLeadSurrogate(c) && (j + 1) < srcLength && UTF16.isTrailSurrogate(c2 = src.charAt(j + 1))) {\r\n                ++j;\r\n                n |= UCharacter.getCodePoint(c, c2);\r\n            } else {\r\n                throw new StringPrepParseException(\"Illegal char found\", StringPrepParseException.ILLEGAL_CHAR_FOUND);\r\n            }\r\n            cpBuffer[srcCPCount++] = n;\r\n        }\r\n    }\r\n    basicLength = dest.length();\r\n    if (basicLength > 0) {\r\n        dest.append(DELIMITER);\r\n    }\r\n    n = INITIAL_N;\r\n    delta = 0;\r\n    bias = INITIAL_BIAS;\r\n    for (handledCPCount = basicLength; handledCPCount < srcCPCount; ) {\r\n        for (m = 0x7fffffff, j = 0; j < srcCPCount; ++j) {\r\n            q = cpBuffer[j] & 0x7fffffff;\r\n            if (n <= q && q < m) {\r\n                m = q;\r\n            }\r\n        }\r\n        if (m - n > (0x7fffffff - delta) / (handledCPCount + 1)) {\r\n            throw new IllegalStateException(\"Internal program error\");\r\n        }\r\n        delta += (m - n) * (handledCPCount + 1);\r\n        n = m;\r\n        for (j = 0; j < srcCPCount; ++j) {\r\n            q = cpBuffer[j] & 0x7fffffff;\r\n            if (q < n) {\r\n                ++delta;\r\n            } else if (q == n) {\r\n                for (q = delta, k = BASE; ; k += BASE) {\r\n                    t = k - bias;\r\n                    if (t < TMIN) {\r\n                        t = TMIN;\r\n                    } else if (k >= (bias + TMAX)) {\r\n                        t = TMAX;\r\n                    }\r\n                    if (q < t) {\r\n                        break;\r\n                    }\r\n                    dest.append(digitToBasic(t + (q - t) % (BASE - t), false));\r\n                    q = (q - t) / (BASE - t);\r\n                }\r\n                dest.append(digitToBasic(q, (cpBuffer[j] < 0)));\r\n                bias = adaptBias(delta, handledCPCount + 1, (handledCPCount == basicLength));\r\n                delta = 0;\r\n                ++handledCPCount;\r\n            }\r\n        }\r\n        ++delta;\r\n        ++n;\r\n    }\r\n    return dest;\r\n}"
}, {
	"Path": "android.icu.impl.ICURWLock.getStats",
	"Comment": "return a snapshot of the current stats.this does not reset the stats.",
	"Method": "Stats getStats(){\r\n    return stats == null ? null : new Stats(stats);\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.notifyListener",
	"Comment": "notify the listener, which by default is a servicelistener.subclasses can override to use a different listener.",
	"Method": "void notifyListener(EventListener l){\r\n    ((ServiceListener) l).serviceChanged(this);\r\n}"
}, {
	"Path": "android.icu.impl.ICUResourceBundle.getStringWithFallback",
	"Comment": "will throw type mismatch exception if the resource is not a string",
	"Method": "String getStringWithFallback(String path){\r\n    ICUResourceBundle actualBundle = this;\r\n    String result = findStringWithFallback(path, actualBundle, null);\r\n    if (result == null) {\r\n        throw new MissingResourceException(\"Can't find resource for bundle \" + this.getClass().getName() + \", key \" + getType(), path, getKey());\r\n    }\r\n    if (result.equals(NO_INHERITANCE_MARKER)) {\r\n        throw new MissingResourceException(\"Encountered NO_INHERITANCE_MARKER\", path, getKey());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedBreakIterator.handleNext",
	"Comment": "the state machine engine for moving forward is here.this function is the heart of the rbbi run time engine.",
	"Method": "int handleNext(short stateTable){\r\n    if (TRACE) {\r\n        System.out.println(\"Handle Next   pos      char  state category\");\r\n    }\r\n    fLastStatusIndexValid = true;\r\n    fLastRuleStatusIndex = 0;\r\n    CharacterIterator text = fText;\r\n    CharTrie trie = fRData.fTrie;\r\n    int c = text.current();\r\n    if (c >= UTF16.LEAD_SURROGATE_MIN_VALUE) {\r\n        c = nextTrail32(text, c);\r\n        if (c == DONE32) {\r\n            return BreakIterator.DONE;\r\n        }\r\n    }\r\n    int initialPosition = text.getIndex();\r\n    int result = initialPosition;\r\n    int state = START_STATE;\r\n    int row = fRData.getRowIndex(state);\r\n    short category = 3;\r\n    int flagsState = fRData.getStateTableFlags(stateTable);\r\n    int mode = RBBI_RUN;\r\n    if ((flagsState & RBBIDataWrapper.RBBI_BOF_REQUIRED) != 0) {\r\n        category = 2;\r\n        mode = RBBI_START;\r\n        if (TRACE) {\r\n            System.out.print(\"            \" + RBBIDataWrapper.intToString(text.getIndex(), 5));\r\n            System.out.print(RBBIDataWrapper.intToHexString(c, 10));\r\n            System.out.println(RBBIDataWrapper.intToString(state, 7) + RBBIDataWrapper.intToString(category, 6));\r\n        }\r\n    }\r\n    fLookAheadMatches.reset();\r\n    while (state != STOP_STATE) {\r\n        if (c == DONE32) {\r\n            if (mode == RBBI_END) {\r\n                break;\r\n            }\r\n            mode = RBBI_END;\r\n            category = 1;\r\n        } else if (mode == RBBI_RUN) {\r\n            category = (short) trie.getCodePointValue(c);\r\n            if ((category & 0x4000) != 0) {\r\n                fDictionaryCharCount++;\r\n                category &= ~0x4000;\r\n            }\r\n            if (TRACE) {\r\n                System.out.print(\"            \" + RBBIDataWrapper.intToString(text.getIndex(), 5));\r\n                System.out.print(RBBIDataWrapper.intToHexString(c, 10));\r\n                System.out.println(RBBIDataWrapper.intToString(state, 7) + RBBIDataWrapper.intToString(category, 6));\r\n            }\r\n            c = text.next();\r\n            if (c >= UTF16.LEAD_SURROGATE_MIN_VALUE) {\r\n                c = nextTrail32(text, c);\r\n            }\r\n        } else {\r\n            mode = RBBI_RUN;\r\n        }\r\n        state = stateTable[row + RBBIDataWrapper.NEXTSTATES + category];\r\n        row = fRData.getRowIndex(state);\r\n        if (stateTable[row + RBBIDataWrapper.ACCEPTING] == -1) {\r\n            result = text.getIndex();\r\n            if (c >= UTF16.SUPPLEMENTARY_MIN_VALUE && c <= UTF16.CODEPOINT_MAX_VALUE) {\r\n                result--;\r\n            }\r\n            fLastRuleStatusIndex = stateTable[row + RBBIDataWrapper.TAGIDX];\r\n        }\r\n        int completedRule = stateTable[row + RBBIDataWrapper.ACCEPTING];\r\n        if (completedRule > 0) {\r\n            int lookaheadResult = fLookAheadMatches.getPosition(completedRule);\r\n            if (lookaheadResult >= 0) {\r\n                fLastRuleStatusIndex = stateTable[row + RBBIDataWrapper.TAGIDX];\r\n                text.setIndex(lookaheadResult);\r\n                return lookaheadResult;\r\n            }\r\n        }\r\n        int rule = stateTable[row + RBBIDataWrapper.LOOKAHEAD];\r\n        if (rule != 0) {\r\n            int pos = text.getIndex();\r\n            if (c >= UTF16.SUPPLEMENTARY_MIN_VALUE && c <= UTF16.CODEPOINT_MAX_VALUE) {\r\n                pos--;\r\n            }\r\n            fLookAheadMatches.setPosition(rule, pos);\r\n        }\r\n    }\r\n    if (result == initialPosition) {\r\n        if (TRACE) {\r\n            System.out.println(\"Iterator did not move. Advancing by 1.\");\r\n        }\r\n        text.setIndex(initialPosition);\r\n        next32(text);\r\n        result = text.getIndex();\r\n    } else {\r\n        text.setIndex(result);\r\n    }\r\n    if (TRACE) {\r\n        System.out.println(\"result = \" + result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.util.Calendar.gregorianPreviousMonthLength",
	"Comment": "returns the length of a previous month of the gregorian calendar.",
	"Method": "int gregorianPreviousMonthLength(int y,int m){\r\n    return (m > 0) ? gregorianMonthLength(y, m - 1) : 31;\r\n}"
}, {
	"Path": "android.icu.text.Normalizer.endIndex",
	"Comment": "retrieve the index of the end of the input text.this is the end indexof the characteriterator or the length of the stringover which this normalizer is iterating",
	"Method": "int endIndex(){\r\n    return text.getLength();\r\n}"
}, {
	"Path": "android.icu.text.TimeZoneFormat.getTargetRegion",
	"Comment": "private method returning the target region. the target regions is determined bythe locale of this instance. when a generic name is coming froma meta zone, this region is used for checking if the time zoneis a reference zone of the meta zone.",
	"Method": "String getTargetRegion(){\r\n    if (_region == null) {\r\n        _region = _locale.getCountry();\r\n        if (_region.length() == 0) {\r\n            ULocale tmp = ULocale.addLikelySubtags(_locale);\r\n            _region = tmp.getCountry();\r\n            if (_region.length() == 0) {\r\n                _region = \"001\";\r\n            }\r\n        }\r\n    }\r\n    return _region;\r\n}"
}, {
	"Path": "android.icu.lang.CharSequences.codePointLength",
	"Comment": "count the code point length. unpaired surrogates count as 1.",
	"Method": "int codePointLength(CharSequence s){\r\n    return Character.codePointCount(s, 0, s.length());\r\n}"
}, {
	"Path": "android.icu.text.NumberFormat.setGroupingUsed",
	"Comment": "sets whether or not grouping will be used in this format.groupingaffects both parsing and formatting.",
	"Method": "void setGroupingUsed(boolean newValue){\r\n    groupingUsed = newValue;\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.HebrewTest.TestCases",
	"Comment": "a huge list of test cases to make sure that computetime and computefieldswork properly for a wide range of data.",
	"Method": "void TestCases(){\r\n    try {\r\n        final TestCase[] testCases = { // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(1507231.5, 0, 3174, 12, 10, SUN, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(1660037.5, 0, 3593, 3, 25, WED, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(1746893.5, 0, 3831, 1, 3, WED, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(1770641.5, 0, 3896, 1, 9, SUN, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(1892731.5, 0, 4230, 4, 18, WED, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(1931579.5, 0, 4336, 10, 4, MON, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(1974851.5, 0, 4455, 2, 13, SAT, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2091164.5, 0, 4773, 9, 6, SUN, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2121509.5, 0, 4856, 9, 23, SUN, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2155779.5, 0, 4950, 8, 7, FRI, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2174029.5, 0, 5000, 7, 8, SAT, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2191584.5, 0, 5048, 8, 21, FRI, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2195261.5, 0, 5058, 9, 7, SUN, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2229274.5, 0, 5151, 11, 1, SUN, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2245580.5, 0, 5196, 5, 7, WED, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2266100.5, 0, 5252, 8, 3, SAT, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2288542.5, 0, 5314, 1, 1, SAT, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2290901.5, 0, 5320, 6, 27, SAT, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2323140.5, 0, 5408, 10, 20, WED, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2334551.5, 0, 5440, 1, 1, THU, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2334581.5, 0, 5440, 2, 1, SAT, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2334610.5, 0, 5440, 3, 1, SUN, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2334639.5, 0, 5440, 4, 1, MON, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2334668.5, 0, 5440, 5, 1, TUE, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2334698.5, 0, 5440, 6, 1, THU, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2334728.5, 0, 5440, 7, 1, SAT, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2334757.5, 0, 5440, 8, 1, SUN, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2334787.5, 0, 5440, 9, 1, TUE, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2334816.5, 0, 5440, 10, 1, WED, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2334846.5, 0, 5440, 11, 1, FRI, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2334848.5, 0, 5440, 11, 3, SUN, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2334934.5, 0, 5441, 1, 1, TUE, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2348020.5, 0, 5476, 12, 5, FRI, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2366978.5, 0, 5528, 11, 4, SUN, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2385648.5, 0, 5579, 12, 11, MON, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2392825.5, 0, 5599, 8, 12, WED, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2416223.5, 0, 5663, 8, 22, SUN, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2425848.5, 0, 5689, 12, 19, SUN, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2430266.5, 0, 5702, 1, 8, MON, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2430833.5, 0, 5703, 8, 14, MON, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2431004.5, 0, 5704, 1, 8, THU, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2448698.5, 0, 5752, 7, 12, TUE, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2450138.5, 0, 5756, 7, 5, SUN, 0, 0, 0), // G.YY/MM/DD  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2465737.5, 0, 5799, 2, 12, WED, 0, 0, 0), new TestCase(2486076.5, 0, 5854, 12, 5, SUN, 0, 0, 0), // of the application \"Hebrew Calendar\"\r\n        new TestCase(1013, 9, 8, 0, 4774, 1, 1, TUE, 0, 0, 0), // of the application \"Hebrew Calendar\"\r\n        new TestCase(1239, 9, 1, 0, 5000, 1, 1, THU, 0, 0, 0), new TestCase(1240, 9, 18, 0, 5001, 1, 1, TUE, 0, 0, 0), // Julian Day  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2456187.5, 0, 5773, 1, 1, MON, 0, 0, 0), // Julian Day  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2459111.5, 0, 5781, 1, 1, SAT, 0, 0, 0), // Julian Day  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2453647.5, 0, 5766, 1, 1, TUE, 0, 0, 0), // Julian Day  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2462035.5, 0, 5789, 1, 1, THU, 0, 0, 0), // Julian Day  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2458756.5, 0, 5780, 1, 1, MON, 0, 0, 0), // Julian Day  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2460586.5, 0, 5785, 1, 1, THU, 0, 0, 0), // Julian Day  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2463864.5, 0, 5794, 1, 1, SAT, 0, 0, 0), // Julian Day  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2463481.5, 0, 5793, 1, 1, MON, 0, 0, 0), // Julian Day  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2470421.5, 0, 5812, 1, 1, THU, 0, 0, 0), // Julian Day  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2460203.5, 0, 5784, 1, 1, SAT, 0, 0, 0), // Julian Day  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2459464.5, 0, 5782, 1, 1, TUE, 0, 0, 0), // Julian Day  Era  Year  Month Day  WkDay Hour Min Sec\r\n        new TestCase(2467142.5, 0, 5803, 1, 1, MON, 0, 0, 0), new TestCase(2455448.5, 0, 5771, 1, 1, THU, 0, 0, 0), new TestCase(2452465.5, 0, 5762, AV + 1, 1, WED, 0, 0, 0), new TestCase(2452494.5, 0, 5762, AV + 1, 30, THU, 0, 0, 0), new TestCase(2452495.5, 0, 5762, ELUL + 1, 1, FRI, 0, 0, 0), new TestCase(2452523.5, 0, 5762, ELUL + 1, 29, FRI, 0, 0, 0), new TestCase(2452524.5, 0, 5763, TISHRI + 1, 1, SAT, 0, 0, 0) };\r\n        doTestCases(testCases, new HebrewCalendar());\r\n    } catch (MissingResourceException ex) {\r\n        warnln(\"Got Exception: \" + ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.ListFormatter.getInstance",
	"Comment": "create a list formatter that is appropriate for the default format locale.",
	"Method": "ListFormatter getInstance(ULocale locale,ListFormatter getInstance,Locale locale,ListFormatter getInstance,ULocale locale,Style style,ListFormatter getInstance){\r\n    return getInstance(ULocale.getDefault(ULocale.Category.FORMAT));\r\n}"
}, {
	"Path": "org.apache.harmony.testframework.serialization.SerializationTest.testSelf",
	"Comment": "tests that data objects can be serialized and deserialized withoutexceptions, and that deserialization really produces deeply clonedobjects.",
	"Method": "void testSelf(){\r\n    if (this instanceof SerializableAssert) {\r\n        verifySelf(getData(), (SerializableAssert) this);\r\n    } else {\r\n        verifySelf(getData());\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.TransliteratorIDParser.specsToSpecialInverse",
	"Comment": "given a specs object, return a singleid representing thespecial inverse of that id.if there is no special inversethen return null.",
	"Method": "SingleID specsToSpecialInverse(Specs specs){\r\n    if (!specs.source.equalsIgnoreCase(ANY)) {\r\n        return null;\r\n    }\r\n    String inverseTarget = SPECIAL_INVERSES.get(new CaseInsensitiveString(specs.target));\r\n    if (inverseTarget != null) {\r\n        StringBuilder buf = new StringBuilder();\r\n        if (specs.filter != null) {\r\n            buf.append(specs.filter);\r\n        }\r\n        if (specs.sawSource) {\r\n            buf.append(ANY).append(TARGET_SEP);\r\n        }\r\n        buf.append(inverseTarget);\r\n        String basicID = ANY + TARGET_SEP + inverseTarget;\r\n        if (specs.variant != null) {\r\n            buf.append(VARIANT_SEP).append(specs.variant);\r\n            basicID = basicID + VARIANT_SEP + specs.variant;\r\n        }\r\n        return new SingleID(buf.toString(), basicID);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.isGroupingPosition",
	"Comment": "returns true if a grouping separator belongs at the given position, based on whethergrouping is in use and the values of the primary and secondary grouping interval.",
	"Method": "boolean isGroupingPosition(int pos){\r\n    boolean result = false;\r\n    if (isGroupingUsed() && (pos > 0) && (groupingSize > 0)) {\r\n        if ((groupingSize2 > 0) && (pos > groupingSize)) {\r\n            result = ((pos - groupingSize) % groupingSize2) == 0;\r\n        } else {\r\n            result = pos % groupingSize == 0;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.impl.SortedSetRelation.hasRelation",
	"Comment": "utility that could be on sortedset. faster implementation thanwhat is in java for doing contains, equals, etc.",
	"Method": "boolean hasRelation(SortedSet<T> a,int allow,SortedSet<T> b){\r\n    if (allow < NONE || allow > ANY) {\r\n        throw new IllegalArgumentException(\"Relation \" + allow + \" out of range\");\r\n    }\r\n    boolean anb = (allow & A_NOT_B) != 0;\r\n    boolean ab = (allow & A_AND_B) != 0;\r\n    boolean bna = (allow & B_NOT_A) != 0;\r\n    switch(allow) {\r\n        case CONTAINS:\r\n            if (a.size() < b.size())\r\n                return false;\r\n            break;\r\n        case ISCONTAINED:\r\n            if (a.size() > b.size())\r\n                return false;\r\n            break;\r\n        case EQUALS:\r\n            if (a.size() != b.size())\r\n                return false;\r\n            break;\r\n    }\r\n    if (a.size() == 0) {\r\n        if (b.size() == 0)\r\n            return true;\r\n        return bna;\r\n    } else if (b.size() == 0) {\r\n        return anb;\r\n    }\r\n    Iterator<? extends T> ait = a.iterator();\r\n    Iterator<? extends T> bit = b.iterator();\r\n    T aa = ait.next();\r\n    T bb = bit.next();\r\n    while (true) {\r\n        int comp = aa.compareTo(bb);\r\n        if (comp == 0) {\r\n            if (!ab)\r\n                return false;\r\n            if (!ait.hasNext()) {\r\n                if (!bit.hasNext())\r\n                    return true;\r\n                return bna;\r\n            } else if (!bit.hasNext()) {\r\n                return anb;\r\n            }\r\n            aa = ait.next();\r\n            bb = bit.next();\r\n        } else if (comp < 0) {\r\n            if (!anb)\r\n                return false;\r\n            if (!ait.hasNext()) {\r\n                return bna;\r\n            }\r\n            aa = ait.next();\r\n        } else {\r\n            if (!bna)\r\n                return false;\r\n            if (!bit.hasNext()) {\r\n                return anb;\r\n            }\r\n            bb = bit.next();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.TransliteratorIDParser.parseCompoundID",
	"Comment": "parse a compound id, consisting of an optional forward globalfilter, a separator, one or more single ids delimited byseparators, an an optional reverse global filter.theseparator is a semicolon.the global filters are unicodesetpatterns.the reverse global filter must be enclosed inparentheses.",
	"Method": "boolean parseCompoundID(String id,int dir,StringBuffer canonID,List<SingleID> list,UnicodeSet[] globalFilter){\r\n    int[] pos = new int[] { 0 };\r\n    int[] withParens = new int[1];\r\n    list.clear();\r\n    UnicodeSet filter;\r\n    globalFilter[0] = null;\r\n    canonID.setLength(0);\r\n    withParens[0] = 0;\r\n    filter = parseGlobalFilter(id, pos, dir, withParens, canonID);\r\n    if (filter != null) {\r\n        if (!Utility.parseChar(id, pos, ID_DELIM)) {\r\n            canonID.setLength(0);\r\n            pos[0] = 0;\r\n        }\r\n        if (dir == FORWARD) {\r\n            globalFilter[0] = filter;\r\n        }\r\n    }\r\n    boolean sawDelimiter = true;\r\n    for (; ; ) {\r\n        SingleID single = parseSingleID(id, pos, dir);\r\n        if (single == null) {\r\n            break;\r\n        }\r\n        if (dir == FORWARD) {\r\n            list.add(single);\r\n        } else {\r\n            list.add(0, single);\r\n        }\r\n        if (!Utility.parseChar(id, pos, ID_DELIM)) {\r\n            sawDelimiter = false;\r\n            break;\r\n        }\r\n    }\r\n    if (list.size() == 0) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < list.size(); ++i) {\r\n        SingleID single = list.get(i);\r\n        canonID.append(single.canonID);\r\n        if (i != (list.size() - 1)) {\r\n            canonID.append(ID_DELIM);\r\n        }\r\n    }\r\n    if (sawDelimiter) {\r\n        withParens[0] = 1;\r\n        filter = parseGlobalFilter(id, pos, dir, withParens, canonID);\r\n        if (filter != null) {\r\n            Utility.parseChar(id, pos, ID_DELIM);\r\n            if (dir == REVERSE) {\r\n                globalFilter[0] = filter;\r\n            }\r\n        }\r\n    }\r\n    pos[0] = PatternProps.skipWhiteSpace(id, pos[0]);\r\n    if (pos[0] != id.length()) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "android.icu.util.UniversalTimeScale.toBigDecimal",
	"Comment": "convert a datetime from the universal time scale to a bigdecimal in the given time scale.",
	"Method": "BigDecimal toBigDecimal(long universalTime,int timeScale,BigDecimal toBigDecimal,BigDecimal universalTime,int timeScale){\r\n    TimeScaleData data = getTimeScaleData(timeScale);\r\n    BigDecimal units = new BigDecimal(data.units);\r\n    BigDecimal epochOffset = new BigDecimal(data.epochOffset);\r\n    return universalTime.divide(units, BigDecimal.ROUND_HALF_UP).subtract(epochOffset);\r\n}"
}, {
	"Path": "android.icu.text.TimeZoneFormat.parseSingleLocalizedDigit",
	"Comment": "reads a single decimal digit, either localized digits used by this objector any unicode numeric character.",
	"Method": "int parseSingleLocalizedDigit(String text,int start,int[] len){\r\n    int digit = -1;\r\n    len[0] = 0;\r\n    if (start < text.length()) {\r\n        int cp = Character.codePointAt(text, start);\r\n        for (int i = 0; i < _gmtOffsetDigits.length; i++) {\r\n            if (cp == _gmtOffsetDigits[i].codePointAt(0)) {\r\n                digit = i;\r\n                break;\r\n            }\r\n        }\r\n        if (digit < 0) {\r\n            digit = UCharacter.digit(cp);\r\n        }\r\n        if (digit >= 0) {\r\n            len[0] = Character.charCount(cp);\r\n        }\r\n    }\r\n    return digit;\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.unregisterFactory",
	"Comment": "unregister a factory.the first matching registered factory willbe removed from the list.returns true if a matching factory wasremoved.",
	"Method": "boolean unregisterFactory(Factory factory){\r\n    if (factory == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    boolean result = false;\r\n    try {\r\n        factoryLock.acquireWrite();\r\n        if (factories.remove(factory)) {\r\n            result = true;\r\n            clearCaches();\r\n        }\r\n    } finally {\r\n        factoryLock.releaseWrite();\r\n    }\r\n    if (result) {\r\n        notifyChanged();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.cloneAsThawed",
	"Comment": "clone a thawed version of this class, according to the freezable interface.",
	"Method": "UnicodeSet cloneAsThawed(){\r\n    UnicodeSet result = new UnicodeSet(this);\r\n    assert !result.isFrozen();\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.util.ULocale.getDisplayKeywordValueInternal",
	"Comment": "displaylocaleid is canonical, localeid need not be since parsing will fix this.",
	"Method": "String getDisplayKeywordValueInternal(ULocale locale,String keyword,ULocale displayLocale){\r\n    keyword = AsciiUtil.toLowerString(keyword.trim());\r\n    String value = locale.getKeywordValue(keyword);\r\n    return LocaleDisplayNames.getInstance(displayLocale).keyValueDisplayName(keyword, value);\r\n}"
}, {
	"Path": "libcore.java.io.OldPushbackInputStreamTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this methodis called before a test is executed.",
	"Method": "void setUp(){\r\n    pis = new PushbackInputStream(new ByteArrayInputStream(fileString.getBytes()), 65535);\r\n}"
}, {
	"Path": "java.io.OutputStreamWriter.close",
	"Comment": "closes this writer. this implementation flushes the buffer as well as thetarget stream. the target stream is then closed and the resources for thebuffer and converter are released.only the first invocation of this method has any effect. subsequent callsdo nothing.",
	"Method": "void close(){\r\n    synchronized (lock) {\r\n        if (encoder != null) {\r\n            drainEncoder();\r\n            flushBytes(false);\r\n            out.close();\r\n            encoder = null;\r\n            bytes = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.nio.charset.Charset.displayName",
	"Comment": "gets the name of this charset for the specified locale.the default implementation returns the canonical name of this charset.subclasses may return a localized display name.",
	"Method": "String displayName(String displayName,Locale l){\r\n    return this.canonicalName;\r\n}"
}, {
	"Path": "android.icu.util.LocalePriorityList.getWeight",
	"Comment": "return the weight for a given language, or null if there is none. note thatthe weights may be adjusted from those used to build the list.",
	"Method": "Double getWeight(ULocale language){\r\n    return languagesAndWeights.get(language);\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.CalendarRegressionTest.Test4173516",
	"Comment": "calendar.roll broken this bug relies on the timezone bug 4173604 to alsobe fixed.",
	"Method": "void Test4173516(){\r\n    int[][] fieldsList = { { 1997, Calendar.FEBRUARY, 1, 10, 45, 15, 900 }, { 1999, Calendar.DECEMBER, 22, 23, 59, 59, 999 } };\r\n    int limit = 40;\r\n    GregorianCalendar cal = new GregorianCalendar();\r\n    cal.setTime(new Date(0));\r\n    cal.roll(Calendar.HOUR, 0x7F000000);\r\n    cal.roll(Calendar.HOUR, -0x7F000000);\r\n    if (cal.getTime().getTime() != 0) {\r\n        errln(\"Hour rolling broken\");\r\n    }\r\n    for (int op = 0; op < 2; ++op) {\r\n        logln(\"Testing GregorianCalendar \" + (op == 0 ? \"add\" : \"roll\"));\r\n        for (int field = 0; field < cal.getFieldCount(); ++field) {\r\n            if (field != Calendar.ZONE_OFFSET && field != Calendar.DST_OFFSET && field != Calendar.IS_LEAP_MONTH) {\r\n                for (int j = 0; j < fieldsList.length; ++j) {\r\n                    int[] fields = fieldsList[j];\r\n                    cal.clear();\r\n                    cal.set(fields[0], fields[1], fields[2], fields[3], fields[4], fields[5]);\r\n                    cal.set(Calendar.MILLISECOND, fields[6]);\r\n                    cal.setMinimalDaysInFirstWeek(1);\r\n                    for (int i = 0; i < 2 * limit; i++) {\r\n                        if (op == 0) {\r\n                            cal.add(field, i < limit ? 1 : -1);\r\n                        } else {\r\n                            cal.roll(field, i < limit ? 1 : -1);\r\n                        }\r\n                    }\r\n                    if (cal.get(Calendar.YEAR) != fields[0] || cal.get(Calendar.MONTH) != fields[1] || cal.get(Calendar.DATE) != fields[2] || cal.get(Calendar.HOUR_OF_DAY) != fields[3] || cal.get(Calendar.MINUTE) != fields[4] || cal.get(Calendar.SECOND) != fields[5] || cal.get(Calendar.MILLISECOND) != fields[6]) {\r\n                        errln(\"Field \" + field + \" (\" + FIELD_NAME[field] + \") FAIL, expected \" + fields[0] + \"/\" + (fields[1] + 1) + \"/\" + fields[2] + \" \" + fields[3] + \":\" + fields[4] + \":\" + fields[5] + \".\" + fields[6] + \", got \" + cal.get(Calendar.YEAR) + \"/\" + (cal.get(Calendar.MONTH) + 1) + \"/\" + cal.get(Calendar.DATE) + \" \" + cal.get(Calendar.HOUR_OF_DAY) + \":\" + cal.get(Calendar.MINUTE) + \":\" + cal.get(Calendar.SECOND) + \".\" + cal.get(Calendar.MILLISECOND));\r\n                        cal.clear();\r\n                        cal.set(fields[0], fields[1], fields[2], fields[3], fields[4], fields[5]);\r\n                        cal.set(Calendar.MILLISECOND, fields[6]);\r\n                        logln(\"Start date: \" + cal.get(Calendar.YEAR) + \"/\" + (cal.get(Calendar.MONTH) + 1) + \"/\" + cal.get(Calendar.DATE) + \" \" + cal.get(Calendar.HOUR_OF_DAY) + \":\" + cal.get(Calendar.MINUTE) + \":\" + cal.get(Calendar.SECOND) + \".\" + cal.get(Calendar.MILLISECOND));\r\n                        long prev = cal.getTime().getTime();\r\n                        for (int i = 0; i < 2 * limit; i++) {\r\n                            if (op == 0) {\r\n                                cal.add(field, i < limit ? 1 : -1);\r\n                            } else {\r\n                                cal.roll(field, i < limit ? 1 : -1);\r\n                            }\r\n                            long t = cal.getTime().getTime();\r\n                            long delta = t - prev;\r\n                            prev = t;\r\n                            logln((op == 0 ? \"add(\" : \"roll(\") + FIELD_NAME[field] + (i < limit ? \", +1) => \" : \", -1) => \") + cal.get(Calendar.YEAR) + \"/\" + (cal.get(Calendar.MONTH) + 1) + \"/\" + cal.get(Calendar.DATE) + \" \" + cal.get(Calendar.HOUR_OF_DAY) + \":\" + cal.get(Calendar.MINUTE) + \":\" + cal.get(Calendar.SECOND) + \".\" + cal.get(Calendar.MILLISECOND) + \" delta=\" + delta + \" ms\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.Transliterator.registerAlias",
	"Comment": "register an id as an alias of another id.instantiatingalias id produces the same result as instantiating the original id.this is generally used to create short aliases of compound ids.because icu may choose to cache transliterator objects internally, this mustbe called at application startup, prior to any calls totransliterator.getinstance to avoid undefined behavior.",
	"Method": "void registerAlias(String aliasID,String realID){\r\n    registry.put(aliasID, realID, true);\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.matchesIndexValue",
	"Comment": "implementation of unicodematcher api.returns true ifthis set contains any character whose low byte is the givenvalue.this is used by rulebasedtransliterator forindexing.",
	"Method": "boolean matchesIndexValue(int v){\r\n    for (int i = 0; i < getRangeCount(); ++i) {\r\n        int low = getRangeStart(i);\r\n        int high = getRangeEnd(i);\r\n        if ((low & ~0xFF) == (high & ~0xFF)) {\r\n            if ((low & 0xFF) <= v && v <= (high & 0xFF)) {\r\n                return true;\r\n            }\r\n        } else if ((low & 0xFF) <= v || v <= (high & 0xFF)) {\r\n            return true;\r\n        }\r\n    }\r\n    if (strings.size() != 0) {\r\n        for (String s : strings) {\r\n            int c = UTF16.charAt(s, 0);\r\n            if ((c & 0xFF) == v) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "android.icu.text.NumberFormat.getPercentInstance",
	"Comment": "returns a percentage format for the current default format locale.",
	"Method": "NumberFormat getPercentInstance(NumberFormat getPercentInstance,Locale inLocale,NumberFormat getPercentInstance,ULocale inLocale){\r\n    return getInstance(inLocale, PERCENTSTYLE);\r\n}"
}, {
	"Path": "android.icu.util.Calendar.before",
	"Comment": "compares the time field records.equivalent to comparing result of conversion to utc.",
	"Method": "boolean before(Object when){\r\n    return compare(when) < 0;\r\n}"
}, {
	"Path": "android.icu.impl.CalendarAstronomer.getGreenwichSidereal",
	"Comment": "returns the current greenwich sidereal time, measured in hours",
	"Method": "double getGreenwichSidereal(){\r\n    if (siderealTime == INVALID) {\r\n        double UT = normalize((double) time / HOUR_MS, 24);\r\n        siderealTime = normalize(getSiderealOffset() + UT * 1.002737909, 24);\r\n    }\r\n    return siderealTime;\r\n}"
}, {
	"Path": "android.icu.util.ULocale.createTagString",
	"Comment": "create a tag string from the supplied parameters.the lang, script and regionparameters may be null references.if the lang parameter is an empty string, thedefault value for an unknown language is written to the output buffer.",
	"Method": "String createTagString(String lang,String script,String region,String trailing,String alternateTags,String createTagString,String lang,String script,String region,String trailing){\r\n    return createTagString(lang, script, region, trailing, null);\r\n}"
}, {
	"Path": "android.icu.util.CompactCharArray.getValueArray",
	"Comment": "for internal use only.do not modify the result, the behavior ofmodified results are undefined.",
	"Method": "char[] getValueArray(){\r\n    return values;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.getZeroDigit",
	"Comment": "returns the character used for zero. different for arabic, etc.",
	"Method": "char getZeroDigit(){\r\n    return zeroDigit;\r\n}"
}, {
	"Path": "android.icu.util.ULocale.getUnicodeLocaleKeys",
	"Comment": "returns the set of unicode locale keys defined by this locale, or the empty set ifthis locale has none.the returned set is immutable.keys are all lower case.",
	"Method": "Set<String> getUnicodeLocaleKeys(){\r\n    return extensions().getUnicodeLocaleKeys();\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationMiscTest.TestQuoteAndSpace",
	"Comment": "they work a little different than expected.desired rules are commented out.",
	"Method": "void TestQuoteAndSpace(){\r\n    String[] rules = new String[] { \"&';'<'+'<','<'-'<'&'<''<'*'<' '\", \"&';'<*'+,-&''''* '\", \"&';'<*'+'-'-&''''* '\" };\r\n    OneTestCase[] testCases = new OneTestCase[] { new OneTestCase(\";\", \"+\", -1), new OneTestCase(\"+\", \",\", -1), new OneTestCase(\",\", \"-\", -1), new OneTestCase(\"-\", \"&\", -1), new OneTestCase(\"&\", \"'\", -1), new OneTestCase(\"'\", \"*\", -1) };\r\n    doTestCollation(testCases, rules);\r\n}"
}, {
	"Path": "android.icu.text.AnyTransliterator.safeClone",
	"Comment": "temporary hack for registry problem. needs to be replaced by better architecture.",
	"Method": "Transliterator safeClone(){\r\n    UnicodeFilter filter = getFilter();\r\n    if (filter != null && filter instanceof UnicodeSet) {\r\n        filter = new UnicodeSet((UnicodeSet) filter);\r\n    }\r\n    return new AnyTransliterator(getID(), filter, target, targetScript, widthFix, cache);\r\n}"
}, {
	"Path": "android.icu.impl.coll.CollationBuilder.makeTailoredCEs",
	"Comment": "walks the tailoring graph and overwrites tailored nodes with new ces.after this, the graph is destroyed.the nodes array can then be used only as a source of tailored ces.",
	"Method": "void makeTailoredCEs(){\r\n    CollationWeights primaries = new CollationWeights();\r\n    CollationWeights secondaries = new CollationWeights();\r\n    CollationWeights tertiaries = new CollationWeights();\r\n    long[] nodesArray = nodes.getBuffer();\r\n    if (DEBUG) {\r\n        System.out.println(\"\\nCollationBuilder.makeTailoredCEs()\");\r\n    }\r\n    for (int rpi = 0; rpi < rootPrimaryIndexes.size(); ++rpi) {\r\n        int i = rootPrimaryIndexes.elementAti(rpi);\r\n        long node = nodesArray[i];\r\n        long p = weight32FromNode(node);\r\n        int s = p == 0 ? 0 : Collation.COMMON_WEIGHT16;\r\n        int t = s;\r\n        int q = 0;\r\n        boolean pIsTailored = false;\r\n        boolean sIsTailored = false;\r\n        boolean tIsTailored = false;\r\n        if (DEBUG) {\r\n            System.out.printf(\"\\nprimary     %x\\n\", alignWeightRight((int) p));\r\n        }\r\n        int pIndex = p == 0 ? 0 : rootElements.findPrimary(p);\r\n        int nextIndex = nextIndexFromNode(node);\r\n        while (nextIndex != 0) {\r\n            i = nextIndex;\r\n            node = nodesArray[i];\r\n            nextIndex = nextIndexFromNode(node);\r\n            int strength = strengthFromNode(node);\r\n            if (strength == Collator.QUATERNARY) {\r\n                assert (isTailoredNode(node));\r\n                if (DEBUG) {\r\n                    System.out.print(\"      quat+     \");\r\n                }\r\n                if (q == 3) {\r\n                    throw new UnsupportedOperationException(\"quaternary tailoring gap too small\");\r\n                }\r\n                ++q;\r\n            } else {\r\n                if (strength == Collator.TERTIARY) {\r\n                    if (isTailoredNode(node)) {\r\n                        if (DEBUG) {\r\n                            System.out.print(\"    ter+        \");\r\n                        }\r\n                        if (!tIsTailored) {\r\n                            int tCount = countTailoredNodes(nodesArray, nextIndex, Collator.TERTIARY) + 1;\r\n                            int tLimit;\r\n                            if (t == 0) {\r\n                                t = rootElements.getTertiaryBoundary() - 0x100;\r\n                                tLimit = (int) rootElements.getFirstTertiaryCE() & Collation.ONLY_TERTIARY_MASK;\r\n                            } else if (!pIsTailored && !sIsTailored) {\r\n                                tLimit = rootElements.getTertiaryAfter(pIndex, s, t);\r\n                            } else if (t == Collation.BEFORE_WEIGHT16) {\r\n                                tLimit = Collation.COMMON_WEIGHT16;\r\n                            } else {\r\n                                assert (t == Collation.COMMON_WEIGHT16);\r\n                                tLimit = rootElements.getTertiaryBoundary();\r\n                            }\r\n                            assert (tLimit == 0x4000 || (tLimit & ~Collation.ONLY_TERTIARY_MASK) == 0);\r\n                            tertiaries.initForTertiary();\r\n                            if (!tertiaries.allocWeights(t, tLimit, tCount)) {\r\n                                throw new UnsupportedOperationException(\"tertiary tailoring gap too small\");\r\n                            }\r\n                            tIsTailored = true;\r\n                        }\r\n                        t = (int) tertiaries.nextWeight();\r\n                        assert (t != 0xffffffff);\r\n                    } else {\r\n                        t = weight16FromNode(node);\r\n                        tIsTailored = false;\r\n                        if (DEBUG) {\r\n                            System.out.printf(\"    ter     %x\\n\", alignWeightRight(t));\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (strength == Collator.SECONDARY) {\r\n                        if (isTailoredNode(node)) {\r\n                            if (DEBUG) {\r\n                                System.out.print(\"  sec+          \");\r\n                            }\r\n                            if (!sIsTailored) {\r\n                                int sCount = countTailoredNodes(nodesArray, nextIndex, Collator.SECONDARY) + 1;\r\n                                int sLimit;\r\n                                if (s == 0) {\r\n                                    s = rootElements.getSecondaryBoundary() - 0x100;\r\n                                    sLimit = (int) (rootElements.getFirstSecondaryCE() >> 16);\r\n                                } else if (!pIsTailored) {\r\n                                    sLimit = rootElements.getSecondaryAfter(pIndex, s);\r\n                                } else if (s == Collation.BEFORE_WEIGHT16) {\r\n                                    sLimit = Collation.COMMON_WEIGHT16;\r\n                                } else {\r\n                                    assert (s == Collation.COMMON_WEIGHT16);\r\n                                    sLimit = rootElements.getSecondaryBoundary();\r\n                                }\r\n                                if (s == Collation.COMMON_WEIGHT16) {\r\n                                    s = rootElements.getLastCommonSecondary();\r\n                                }\r\n                                secondaries.initForSecondary();\r\n                                if (!secondaries.allocWeights(s, sLimit, sCount)) {\r\n                                    if (DEBUG) {\r\n                                        System.out.printf(\"!secondaries.allocWeights(%x, %x, sCount=%d)\\n\", alignWeightRight(s), alignWeightRight(sLimit), alignWeightRight(sCount));\r\n                                    }\r\n                                    throw new UnsupportedOperationException(\"secondary tailoring gap too small\");\r\n                                }\r\n                                sIsTailored = true;\r\n                            }\r\n                            s = (int) secondaries.nextWeight();\r\n                            assert (s != 0xffffffff);\r\n                        } else {\r\n                            s = weight16FromNode(node);\r\n                            sIsTailored = false;\r\n                            if (DEBUG) {\r\n                                System.out.printf(\"  sec       %x\\n\", alignWeightRight(s));\r\n                            }\r\n                        }\r\n                    } else {\r\n                        assert (isTailoredNode(node));\r\n                        if (DEBUG) {\r\n                            System.out.print(\"pri+            \");\r\n                        }\r\n                        if (!pIsTailored) {\r\n                            int pCount = countTailoredNodes(nodesArray, nextIndex, Collator.PRIMARY) + 1;\r\n                            boolean isCompressible = baseData.isCompressiblePrimary(p);\r\n                            long pLimit = rootElements.getPrimaryAfter(p, pIndex, isCompressible);\r\n                            primaries.initForPrimary(isCompressible);\r\n                            if (!primaries.allocWeights(p, pLimit, pCount)) {\r\n                                throw new UnsupportedOperationException(\"primary tailoring gap too small\");\r\n                            }\r\n                            pIsTailored = true;\r\n                        }\r\n                        p = primaries.nextWeight();\r\n                        assert (p != 0xffffffffL);\r\n                        s = Collation.COMMON_WEIGHT16;\r\n                        sIsTailored = false;\r\n                    }\r\n                    t = s == 0 ? 0 : Collation.COMMON_WEIGHT16;\r\n                    tIsTailored = false;\r\n                }\r\n                q = 0;\r\n            }\r\n            if (isTailoredNode(node)) {\r\n                nodesArray[i] = Collation.makeCE(p, s, t, q);\r\n                if (DEBUG) {\r\n                    System.out.printf(\"6x\\n\", nodesArray[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.getRangeCount",
	"Comment": "iteration method that returns the number of ranges contained inthis set.",
	"Method": "int getRangeCount(){\r\n    return len / 2;\r\n}"
}, {
	"Path": "android.icu.impl.Utility.appendEncodedByte",
	"Comment": "append a byte to the given appendable, packing two bytes into eachcharacter.the state parameter maintains intermediary data betweencalls.",
	"Method": "void appendEncodedByte(T buffer,byte value,byte[] state){\r\n    try {\r\n        if (state[0] != 0) {\r\n            char c = (char) ((state[1] << 8) | ((value) & 0xFF));\r\n            buffer.append(c);\r\n            state[0] = 0;\r\n        } else {\r\n            state[0] = 1;\r\n            state[1] = value;\r\n        }\r\n    } catch (IOException e) {\r\n        throw new IllegalIcuArgumentException(e);\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.coll.CollationRootElements.getLastCommonSecondary",
	"Comment": "returns the last common secondary weight.this is the lower limit for secondaries of primary ces.",
	"Method": "int getLastCommonSecondary(){\r\n    return ((int) elements[IX_SEC_TER_BOUNDARIES] >> 16) & 0xff00;\r\n}"
}, {
	"Path": "android.icu.impl.UPropertyAliases.getPropertyValueEnumNoThrow",
	"Comment": "returns a value enum given a property enum and one of its value names. does not throw.",
	"Method": "int getPropertyValueEnumNoThrow(int property,CharSequence alias){\r\n    int valueMapIndex = findProperty(property);\r\n    if (valueMapIndex == 0) {\r\n        return UProperty.UNDEFINED;\r\n    }\r\n    valueMapIndex = valueMaps[valueMapIndex + 1];\r\n    if (valueMapIndex == 0) {\r\n        return UProperty.UNDEFINED;\r\n    }\r\n    return getPropertyOrValueEnum(valueMaps[valueMapIndex], alias);\r\n}"
}, {
	"Path": "org.apache.harmony.xml.dom.DocumentImpl.getUserDataMap",
	"Comment": "returns a map with the user data objects attached to the specified node.this map is readable and writable.",
	"Method": "Map<String, UserData> getUserDataMap(NodeImpl node){\r\n    if (nodeToUserData == null) {\r\n        nodeToUserData = new WeakHashMap<NodeImpl, Map<String, UserData>>();\r\n    }\r\n    Map<String, UserData> userDataMap = nodeToUserData.get(node);\r\n    if (userDataMap == null) {\r\n        userDataMap = new HashMap<String, UserData>();\r\n        nodeToUserData.put(node, userDataMap);\r\n    }\r\n    return userDataMap;\r\n}"
}, {
	"Path": "android.icu.util.GlobalizationPreferences.setNumberFormat",
	"Comment": "sets a number format explicitly. overrides the general locale settings.",
	"Method": "GlobalizationPreferences setNumberFormat(int style,NumberFormat format){\r\n    if (isFrozen()) {\r\n        throw new UnsupportedOperationException(\"Attempt to modify immutable object\");\r\n    }\r\n    if (numberFormats == null) {\r\n        numberFormats = new NumberFormat[NF_LIMIT];\r\n    }\r\n    numberFormats[style] = (NumberFormat) format.clone();\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.impl.UCharacterNameReader.read",
	"Comment": "read and break up the stream of data passed in as arguments and fills up ucharactername. if unsuccessful false will be returned.",
	"Method": "void read(UCharacterName data){\r\n    m_tokenstringindex_ = m_byteBuffer_.getInt();\r\n    m_groupindex_ = m_byteBuffer_.getInt();\r\n    m_groupstringindex_ = m_byteBuffer_.getInt();\r\n    m_algnamesindex_ = m_byteBuffer_.getInt();\r\n    int count = m_byteBuffer_.getChar();\r\n    char[] token = ICUBinary.getChars(m_byteBuffer_, count, 0);\r\n    int size = m_groupindex_ - m_tokenstringindex_;\r\n    byte[] tokenstr = new byte[size];\r\n    m_byteBuffer_.get(tokenstr);\r\n    data.setToken(token, tokenstr);\r\n    count = m_byteBuffer_.getChar();\r\n    data.setGroupCountSize(count, GROUP_INFO_SIZE_);\r\n    count *= GROUP_INFO_SIZE_;\r\n    char[] group = ICUBinary.getChars(m_byteBuffer_, count, 0);\r\n    size = m_algnamesindex_ - m_groupstringindex_;\r\n    byte[] groupstring = new byte[size];\r\n    m_byteBuffer_.get(groupstring);\r\n    data.setGroup(group, groupstring);\r\n    count = m_byteBuffer_.getInt();\r\n    UCharacterName.AlgorithmName[] alg = new UCharacterName.AlgorithmName[count];\r\n    for (int i = 0; i < count; i++) {\r\n        UCharacterName.AlgorithmName an = readAlg();\r\n        if (an == null) {\r\n            throw new IOException(\"unames.icu read error: Algorithmic names creation error\");\r\n        }\r\n        alg[i] = an;\r\n    }\r\n    data.setAlgorithm(alg);\r\n}"
}, {
	"Path": "android.icu.impl.UCharacterName.setGroupCountSize",
	"Comment": "sets the number of group and size of each group in number of char",
	"Method": "boolean setGroupCountSize(int count,int size){\r\n    if (count <= 0 || size <= 0) {\r\n        return false;\r\n    }\r\n    m_groupcount_ = count;\r\n    m_groupsize_ = size;\r\n    return true;\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.clearCaches",
	"Comment": "clear caches maintained by this service.subclasses canoverride if they implement additional that need to be clearedwhen the service changes. subclasses should generally not callthis method directly, as it must only be called whilesynchronized on this.",
	"Method": "void clearCaches(){\r\n    cache = null;\r\n    idcache = null;\r\n    dnref = null;\r\n}"
}, {
	"Path": "android.icu.impl.LocaleIDParser.getKeywordMap",
	"Comment": "returns a map of the keywords and values, or null if there are none.",
	"Method": "Map<String, String> getKeywordMap(){\r\n    if (keywords == null) {\r\n        TreeMap<String, String> m = null;\r\n        if (setToKeywordStart()) {\r\n            do {\r\n                String key = getKeyword();\r\n                if (key.length() == 0) {\r\n                    break;\r\n                }\r\n                char c = next();\r\n                if (c != KEYWORD_ASSIGN) {\r\n                    if (c == DONE) {\r\n                        break;\r\n                    } else {\r\n                        continue;\r\n                    }\r\n                }\r\n                String value = getValue();\r\n                if (value.length() == 0) {\r\n                    continue;\r\n                }\r\n                if (m == null) {\r\n                    m = new TreeMap<String, String>(getKeyComparator());\r\n                } else if (m.containsKey(key)) {\r\n                    continue;\r\n                }\r\n                m.put(key, value);\r\n            } while (next() == ITEM_SEPARATOR);\r\n        }\r\n        keywords = m != null ? m : Collections.<String, String>emptyMap();\r\n    }\r\n    return keywords;\r\n}"
}, {
	"Path": "android.icu.util.GlobalizationPreferences.getTimeZone",
	"Comment": "get the timezone. it was either explicitly set, or isheuristically computed from other settings.",
	"Method": "TimeZone getTimeZone(){\r\n    if (timezone == null) {\r\n        return guessTimeZone();\r\n    }\r\n    return timezone.cloneAsThawed();\r\n}"
}, {
	"Path": "android.icu.util.TimeZoneRule.toString",
	"Comment": "returns a string representation of this timezonerule object.this method is used for debugging purpose only.the string representation can be changedin future version of icu without any notice.",
	"Method": "String toString(){\r\n    StringBuilder buf = new StringBuilder();\r\n    buf.append(\"name=\" + name);\r\n    buf.append(\", stdOffset=\" + rawOffset);\r\n    buf.append(\", dstSaving=\" + dstSavings);\r\n    return buf.toString();\r\n}"
}, {
	"Path": "java.io.File.setWritable",
	"Comment": "manipulates the write permissions for the abstract path designated by thisfile.",
	"Method": "boolean setWritable(boolean writable,boolean ownerOnly,boolean setWritable,boolean writable){\r\n    return setWritable(writable, true);\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.containsSome",
	"Comment": "returns true if this set contains one or more of the charactersof the given string.",
	"Method": "boolean containsSome(int start,int end,boolean containsSome,UnicodeSet s,boolean containsSome,CharSequence s,boolean containsSome,Iterable<T> collection){\r\n    return !containsNone(collection);\r\n}"
}, {
	"Path": "android.icu.text.PluralRules.unexpected",
	"Comment": "returns a parse exception wrapping the token and context strings.",
	"Method": "ParseException unexpected(String token,String context){\r\n    return new ParseException(\"unexpected token '\" + token + \"' in '\" + context + \"'\", -1);\r\n}"
}, {
	"Path": "android.icu.util.Calendar.newerField",
	"Comment": "returns the field that is newer, either defaultfield, oralternatefield.if neither is newer or neither is set, return defaultfield.",
	"Method": "int newerField(int defaultField,int alternateField){\r\n    if (stamp[alternateField] > stamp[defaultField]) {\r\n        return alternateField;\r\n    }\r\n    return defaultField;\r\n}"
}, {
	"Path": "android.icu.text.StringPrepParseException.equals",
	"Comment": "compare this parseexception to another and evaluate if they are equal.the comparison works only on the type of error and does not comparethe rules strings, if any, for equality.",
	"Method": "boolean equals(Object other){\r\n    if (!(other instanceof StringPrepParseException)) {\r\n        return false;\r\n    }\r\n    return ((StringPrepParseException) other).error == this.error;\r\n}"
}, {
	"Path": "android.icu.util.SimpleTimeZone.useDaylightTime",
	"Comment": "overrides timezonequeries if this time zone uses daylight saving time.",
	"Method": "boolean useDaylightTime(){\r\n    return useDaylight;\r\n}"
}, {
	"Path": "android.icu.impl.duration.BasicPeriodBuilderFactory.getFixedUnitBuilder",
	"Comment": "return a builder that represents relative time in terms of the singlegiven timeunit",
	"Method": "PeriodBuilder getFixedUnitBuilder(TimeUnit unit){\r\n    return FixedUnitBuilder.get(unit, getSettings());\r\n}"
}, {
	"Path": "android.icu.text.CanonicalIterator.reset",
	"Comment": "resets the iterator so that one can start again from the beginning.",
	"Method": "void reset(){\r\n    done = false;\r\n    for (int i = 0; i < current.length; ++i) {\r\n        current[i] = 0;\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.security.tests.java.security.MessageDigest2Test.getDigestAlgorithms",
	"Comment": "returns the digest algorithms that the given provider supports.",
	"Method": "List<String> getDigestAlgorithms(Provider provider){\r\n    if (provider == null) {\r\n        fail(\"No digest algorithms were found\");\r\n    }\r\n    List<String> algs = new ArrayList<String>();\r\n    for (Object key : provider.keySet()) {\r\n        String algorithm = (String) key;\r\n        if (algorithm.startsWith(MESSAGEDIGEST_ID) && !algorithm.contains(\" \")) {\r\n            algs.add(algorithm.substring(MESSAGEDIGEST_ID.length()));\r\n        }\r\n    }\r\n    if (algs.size() == 0) {\r\n        fail(\"No digest algorithms were found\");\r\n    }\r\n    return algs;\r\n}"
}, {
	"Path": "android.icu.text.SearchIterator.setBreakIterator",
	"Comment": "set the breakiterator that will be used to restrict the pointsat which matches are detected.",
	"Method": "void setBreakIterator(BreakIterator breakiter){\r\n    search_.setBreakIter(breakiter);\r\n    if (search_.breakIter() != null) {\r\n        if (search_.text() != null) {\r\n            search_.breakIter().setText((CharacterIterator) search_.text().clone());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.NumberingSystem.getInstanceByName",
	"Comment": "returns a numbering system from one of the predefined numbering systemsknown to icu.numbering system names are based on the numbering systemsdefined in cldr.to get a list of available numbering systems, use thegetavailablenames method.",
	"Method": "NumberingSystem getInstanceByName(String name){\r\n    return cachedStringData.getInstance(name, null);\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedNumberFormat.adjustForContext",
	"Comment": "adjust capitalization of formatted result for display context",
	"Method": "String adjustForContext(String result){\r\n    if (result != null && result.length() > 0 && UCharacter.isLowerCase(result.codePointAt(0))) {\r\n        DisplayContext capitalization = getContext(DisplayContext.Type.CAPITALIZATION);\r\n        if (capitalization == DisplayContext.CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE || (capitalization == DisplayContext.CAPITALIZATION_FOR_UI_LIST_OR_MENU && capitalizationForListOrMenu) || (capitalization == DisplayContext.CAPITALIZATION_FOR_STANDALONE && capitalizationForStandAlone)) {\r\n            if (capitalizationBrkIter == null) {\r\n                capitalizationBrkIter = BreakIterator.getSentenceInstance(locale);\r\n            }\r\n            return UCharacter.toTitleCase(locale, result, capitalizationBrkIter, UCharacter.TITLECASE_NO_LOWERCASE | UCharacter.TITLECASE_NO_BREAK_ADJUSTMENT);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.util.CECalendar.handleGetMonthLength",
	"Comment": "return the number of days in the given month of the given extendedyear of this calendar system.subclasses should override thismethod if they can provide a more correct or more efficientimplementation than the default implementation in calendar.",
	"Method": "int handleGetMonthLength(int extendedYear,int month){\r\n    if ((month + 1) % 13 != 0) {\r\n        return 30;\r\n    } else {\r\n        return ((extendedYear % 4) / 3) + 5;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.zeroPaddingNumber",
	"Comment": "formats a number with the specified minimum and maximum number of digits.",
	"Method": "void zeroPaddingNumber(NumberFormat nf,StringBuffer buf,int value,int minDigits,int maxDigits,String zeroPaddingNumber,long value,int minDigits,int maxDigits){\r\n    numberFormat.setMinimumIntegerDigits(minDigits);\r\n    numberFormat.setMaximumIntegerDigits(maxDigits);\r\n    return numberFormat.format(value);\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.IslamicTest.TestCivilCases",
	"Comment": "a huge list of test cases to make sure that computetime and computefieldswork properly for a wide range of data in the civil calendar.",
	"Method": "void TestCivilCases(){\r\n    final TestCase[] tests = { new TestCase(1507231.5, 0, -1245, 12, 9, SUN, 0, 0, 0), new TestCase(1660037.5, 0, -813, 2, 23, WED, 0, 0, 0), new TestCase(1746893.5, 0, -568, 4, 1, WED, 0, 0, 0), new TestCase(1770641.5, 0, -501, 4, 6, SUN, 0, 0, 0), new TestCase(1892731.5, 0, -157, 10, 17, WED, 0, 0, 0), new TestCase(1931579.5, 0, -47, 6, 3, MON, 0, 0, 0), new TestCase(1974851.5, 0, 75, 7, 13, SAT, 0, 0, 0), new TestCase(2091164.5, 0, 403, 10, 5, SUN, 0, 0, 0), new TestCase(2121509.5, 0, 489, 5, 22, SUN, 0, 0, 0), new TestCase(2155779.5, 0, 586, 2, 7, FRI, 0, 0, 0), new TestCase(2174029.5, 0, 637, 8, 7, SAT, 0, 0, 0), new TestCase(2191584.5, 0, 687, 2, 20, FRI, 0, 0, 0), new TestCase(2195261.5, 0, 697, 7, 7, SUN, 0, 0, 0), new TestCase(2229274.5, 0, 793, 7, 1, SUN, 0, 0, 0), new TestCase(2245580.5, 0, 839, 7, 6, WED, 0, 0, 0), new TestCase(2266100.5, 0, 897, 6, 1, SAT, 0, 0, 0), new TestCase(2288542.5, 0, 960, 9, 30, SAT, 0, 0, 0), new TestCase(2290901.5, 0, 967, 5, 27, SAT, 0, 0, 0), new TestCase(2323140.5, 0, 1058, 5, 18, WED, 0, 0, 0), new TestCase(2334848.5, 0, 1091, 6, 2, SUN, 0, 0, 0), new TestCase(2348020.5, 0, 1128, 8, 4, FRI, 0, 0, 0), new TestCase(2366978.5, 0, 1182, 2, 3, SUN, 0, 0, 0), new TestCase(2385648.5, 0, 1234, 10, 10, MON, 0, 0, 0), new TestCase(2392825.5, 0, 1255, 1, 11, WED, 0, 0, 0), new TestCase(2416223.5, 0, 1321, 1, 21, SUN, 0, 0, 0), new TestCase(2425848.5, 0, 1348, 3, 19, SUN, 0, 0, 0), new TestCase(2430266.5, 0, 1360, 9, 8, MON, 0, 0, 0), new TestCase(2430833.5, 0, 1362, 4, 13, MON, 0, 0, 0), new TestCase(2431004.5, 0, 1362, 10, 7, THU, 0, 0, 0), new TestCase(2448698.5, 0, 1412, 9, 13, TUE, 0, 0, 0), new TestCase(2450138.5, 0, 1416, 10, 5, SUN, 0, 0, 0), new TestCase(2465737.5, 0, 1460, 10, 12, WED, 0, 0, 0), new TestCase(2486076.5, 0, 1518, 3, 5, SUN, 0, 0, 0) };\r\n    IslamicCalendar civilCalendar = newCivil();\r\n    civilCalendar.setLenient(true);\r\n    doTestCases(tests, civilCalendar);\r\n}"
}, {
	"Path": "android.icu.impl.data.ResourceReader.close",
	"Comment": "closes the underlying reader and releases any system resourcesassociated with it. if the stream is already closed then invokingthis method has no effect.",
	"Method": "void close(){\r\n    if (reader != null) {\r\n        reader.close();\r\n        reader = null;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.NFRule.allIgnorable",
	"Comment": "checks to see whether a string consists entirely of ignorablecharacters.",
	"Method": "boolean allIgnorable(String str){\r\n    if (str == null || str.length() == 0) {\r\n        return true;\r\n    }\r\n    RbnfLenientScanner scanner = formatter.getLenientScanner();\r\n    return scanner != null && scanner.allIgnorable(str);\r\n}"
}, {
	"Path": "android.icu.util.LocaleMatcher.processMapping",
	"Comment": "we preprocess the data to get just the possible matches for each desired base language.",
	"Method": "void processMapping(){\r\n    for (Entry<String, Set<String>> desiredToMatchingLanguages : matcherData.matchingLanguages().keyValuesSet()) {\r\n        String desired = desiredToMatchingLanguages.getKey();\r\n        Set<String> supported = desiredToMatchingLanguages.getValue();\r\n        for (R3<ULocale, ULocale, Double> localeToMaxAndWeight : localeToMaxLocaleAndWeight) {\r\n            final ULocale key = localeToMaxAndWeight.get0();\r\n            String lang = key.getLanguage();\r\n            if (supported.contains(lang)) {\r\n                addFiltered(desired, localeToMaxAndWeight);\r\n            }\r\n        }\r\n    }\r\n    for (R3<ULocale, ULocale, Double> localeToMaxAndWeight : localeToMaxLocaleAndWeight) {\r\n        final ULocale key = localeToMaxAndWeight.get0();\r\n        String lang = key.getLanguage();\r\n        addFiltered(lang, localeToMaxAndWeight);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.StringSearch.getCE",
	"Comment": "getting the modified collation elements taking into account the collationattributes.",
	"Method": "int getCE(int sourcece){\r\n    sourcece &= ceMask_;\r\n    if (toShift_) {\r\n        if (variableTop_ > sourcece) {\r\n            if (strength_ >= Collator.QUATERNARY) {\r\n                sourcece &= PRIMARYORDERMASK;\r\n            } else {\r\n                sourcece = CollationElementIterator.IGNORABLE;\r\n            }\r\n        }\r\n    } else if (strength_ >= Collator.QUATERNARY && sourcece == CollationElementIterator.IGNORABLE) {\r\n        sourcece = 0xFFFF;\r\n    }\r\n    return sourcece;\r\n}"
}, {
	"Path": "java.nio.charset.CoderResult.unmappableForLength",
	"Comment": "gets a coderresult object indicating an unmappablecharacter error.",
	"Method": "CoderResult unmappableForLength(int length){\r\n    if (length > 0) {\r\n        Integer key = Integer.valueOf(length);\r\n        synchronized (_unmappableErrors) {\r\n            CoderResult r = _unmappableErrors.get(key);\r\n            if (r == null) {\r\n                r = new CoderResult(TYPE_UNMAPPABLE_CHAR, length);\r\n                _unmappableErrors.put(key, r);\r\n            }\r\n            return r;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"length <= 0: \" + length);\r\n}"
}, {
	"Path": "org.apache.harmony.xml.dom.DOMConfigurationImpl.isValid",
	"Comment": "returns true if all of the characters in the text are permitted for usein xml documents.",
	"Method": "boolean isValid(CharSequence text){\r\n    for (int i = 0; i < text.length(); i++) {\r\n        char c = text.charAt(i);\r\n        boolean valid = c == 0x9 || c == 0xA || c == 0xD || (c >= 0x20 && c <= 0xd7ff) || (c >= 0xe000 && c <= 0xfffd);\r\n        if (!valid) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "android.icu.impl.duration.BasicPeriodFormatterFactory.getSeparatorVariant",
	"Comment": "return the variant indicating how separators will be displayed.",
	"Method": "int getSeparatorVariant(){\r\n    return customizations.separatorVariant;\r\n}"
}, {
	"Path": "android.icu.text.BidiClassifier.classify",
	"Comment": "gets customized bidi class for the code point c.default implementation, to be overridden.",
	"Method": "int classify(int c){\r\n    return Bidi.CLASS_DEFAULT;\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedNumberFormat.getRuleSetDisplayNames",
	"Comment": "return the rule set display names for the current default display locale.",
	"Method": "String[] getRuleSetDisplayNames(ULocale loc,String[] getRuleSetDisplayNames){\r\n    return getRuleSetDisplayNames(ULocale.getDefault(Category.DISPLAY));\r\n}"
}, {
	"Path": "android.icu.impl.CalendarAstronomer.getDate",
	"Comment": "get the current time of this calendarastronomer object,represented as a date object.",
	"Method": "Date getDate(){\r\n    return new Date(time);\r\n}"
}, {
	"Path": "android.icu.impl.IntTrie.unserialize",
	"Comment": "parses the input stream and stores its trie content into a index and data array",
	"Method": "void unserialize(ByteBuffer bytes){\r\n    super.unserialize(bytes);\r\n    m_data_ = ICUBinary.getInts(bytes, m_dataLength_, 0);\r\n    m_initialValue_ = m_data_[0];\r\n}"
}, {
	"Path": "android.icu.impl.duration.Period.equals",
	"Comment": "returns true if rhs extends period andthe two periods are equal.",
	"Method": "boolean equals(Object rhs,boolean equals,Period rhs){\r\n    if (rhs != null && this.timeLimit == rhs.timeLimit && this.inFuture == rhs.inFuture) {\r\n        for (int i = 0; i < counts.length; ++i) {\r\n            if (counts[i] != rhs.counts[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "android.icu.impl.duration.BasicDurationFormatterFactory.setLocale",
	"Comment": "set the name of the locale that will be used whencreating new formatters.",
	"Method": "DurationFormatterFactory setLocale(String localeName){\r\n    if (!localeName.equals(this.localeName)) {\r\n        this.localeName = localeName;\r\n        if (builder != null) {\r\n            builder = builder.withLocale(localeName);\r\n        }\r\n        if (formatter != null) {\r\n            formatter = formatter.withLocale(localeName);\r\n        }\r\n        reset();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationAPITest.TestSubClass",
	"Comment": "simple test to see if collator is subclassable.also test coverage of base class methods that are overridden by rulebasedcollator.",
	"Method": "void TestSubClass(){\r\n    class TestCollator extends Collator {\r\n        @Override\r\n        public boolean equals(Object that) {\r\n            return this == that;\r\n        }\r\n        @Override\r\n        public int hashCode() {\r\n            return 0;\r\n        }\r\n        @Override\r\n        public int compare(String source, String target) {\r\n            return source.compareTo(target);\r\n        }\r\n        @Override\r\n        public CollationKey getCollationKey(String source) {\r\n            return new CollationKey(source, getRawCollationKey(source, new RawCollationKey()));\r\n        }\r\n        @Override\r\n        public RawCollationKey getRawCollationKey(String source, RawCollationKey key) {\r\n            byte[] temp1 = source.getBytes();\r\n            byte[] temp2 = new byte[temp1.length + 1];\r\n            System.arraycopy(temp1, 0, temp2, 0, temp1.length);\r\n            temp2[temp1.length] = 0;\r\n            if (key == null) {\r\n                key = new RawCollationKey();\r\n            }\r\n            key.bytes = temp2;\r\n            key.size = temp2.length;\r\n            return key;\r\n        }\r\n        @Override\r\n        public void setVariableTop(int ce) {\r\n            if (isFrozen()) {\r\n                throw new UnsupportedOperationException(\"Attempt to modify frozen object\");\r\n            }\r\n        }\r\n        @Override\r\n        public int setVariableTop(String str) {\r\n            if (isFrozen()) {\r\n                throw new UnsupportedOperationException(\"Attempt to modify frozen object\");\r\n            }\r\n            return 0;\r\n        }\r\n        @Override\r\n        public int getVariableTop() {\r\n            return 0;\r\n        }\r\n        @Override\r\n        public VersionInfo getVersion() {\r\n            return VersionInfo.getInstance(0);\r\n        }\r\n        @Override\r\n        public VersionInfo getUCAVersion() {\r\n            return VersionInfo.getInstance(0);\r\n        }\r\n    }\r\n    Collator col1 = new TestCollator();\r\n    Collator col2 = new TestCollator();\r\n    if (col1.equals(col2)) {\r\n        errln(\"2 different instance of TestCollator should fail\");\r\n    }\r\n    if (col1.hashCode() != col2.hashCode()) {\r\n        errln(\"Every TestCollator has the same hashcode\");\r\n    }\r\n    String abc = \"abc\";\r\n    String bcd = \"bcd\";\r\n    if (col1.compare(abc, bcd) != abc.compareTo(bcd)) {\r\n        errln(\"TestCollator compare should be the same as the default \" + \"string comparison\");\r\n    }\r\n    CollationKey key = col1.getCollationKey(abc);\r\n    byte[] temp1 = abc.getBytes();\r\n    byte[] temp2 = new byte[temp1.length + 1];\r\n    System.arraycopy(temp1, 0, temp2, 0, temp1.length);\r\n    temp2[temp1.length] = 0;\r\n    if (!java.util.Arrays.equals(key.toByteArray(), temp2) || !key.getSourceString().equals(abc)) {\r\n        errln(\"TestCollator collationkey API is returning wrong values\");\r\n    }\r\n    UnicodeSet set = col1.getTailoredSet();\r\n    if (!set.equals(new UnicodeSet(0, 0x10FFFF))) {\r\n        errln(\"Error getting default tailored set\");\r\n    }\r\n    assertEquals(\"compare(strings as Object)\", 0, col1.compare(new StringBuilder(\"abc\"), new StringBuffer(\"abc\")));\r\n    col1.setStrength(Collator.SECONDARY);\r\n    assertNotEquals(\"getStrength()\", Collator.PRIMARY, col1.getStrength());\r\n    assertNotEquals(\"setStrength2().getStrength()\", Collator.PRIMARY, col1.setStrength2(Collator.IDENTICAL).getStrength());\r\n    try {\r\n        col1.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\r\n    } catch (UnsupportedOperationException expected) {\r\n    }\r\n    assertNotEquals(\"getDecomposition()\", -1, col1.getDecomposition());\r\n    try {\r\n        col1.setMaxVariable(Collator.ReorderCodes.CURRENCY);\r\n    } catch (UnsupportedOperationException expected) {\r\n    }\r\n    assertNotEquals(\"getMaxVariable()\", -1, col1.getMaxVariable());\r\n    try {\r\n        col1.setReorderCodes(0, 1, 2);\r\n    } catch (UnsupportedOperationException expected) {\r\n    }\r\n    try {\r\n        col1.getReorderCodes();\r\n    } catch (UnsupportedOperationException expected) {\r\n    }\r\n    assertFalse(\"getDisplayName()\", Collator.getDisplayName(Locale.GERMAN).isEmpty());\r\n    assertFalse(\"getDisplayName()\", Collator.getDisplayName(Locale.GERMAN, Locale.ITALIAN).isEmpty());\r\n    assertNotEquals(\"getLocale()\", ULocale.GERMAN, col1.getLocale(ULocale.ACTUAL_LOCALE));\r\n    Object token = Collator.registerInstance(new TestCollator(), new ULocale(\"de-Japn-419\"));\r\n    Collator.unregister(token);\r\n    assertFalse(\"not yet frozen\", col2.isFrozen());\r\n    try {\r\n        col2.freeze();\r\n        assertTrue(\"now frozen\", col2.isFrozen());\r\n    } catch (UnsupportedOperationException expected) {\r\n    }\r\n    try {\r\n        col2.setStrength(Collator.PRIMARY);\r\n        if (col2.isFrozen()) {\r\n            fail(\"(frozen Collator).setStrength() should throw an exception\");\r\n        }\r\n    } catch (UnsupportedOperationException expected) {\r\n    }\r\n    try {\r\n        Collator col3 = col2.cloneAsThawed();\r\n        assertFalse(\"!cloneAsThawed().isFrozen()\", col3.isFrozen());\r\n    } catch (UnsupportedOperationException expected) {\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationAPITest.TestSubClass",
	"Comment": "simple test to see if collator is subclassable.also test coverage of base class methods that are overridden by rulebasedcollator.",
	"Method": "void TestSubClass(){\r\n    return this == that;\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationAPITest.TestSubClass",
	"Comment": "simple test to see if collator is subclassable.also test coverage of base class methods that are overridden by rulebasedcollator.",
	"Method": "void TestSubClass(){\r\n    return 0;\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationAPITest.TestSubClass",
	"Comment": "simple test to see if collator is subclassable.also test coverage of base class methods that are overridden by rulebasedcollator.",
	"Method": "void TestSubClass(){\r\n    return source.compareTo(target);\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationAPITest.TestSubClass",
	"Comment": "simple test to see if collator is subclassable.also test coverage of base class methods that are overridden by rulebasedcollator.",
	"Method": "void TestSubClass(){\r\n    return new CollationKey(source, getRawCollationKey(source, new RawCollationKey()));\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationAPITest.TestSubClass",
	"Comment": "simple test to see if collator is subclassable.also test coverage of base class methods that are overridden by rulebasedcollator.",
	"Method": "void TestSubClass(){\r\n    byte[] temp1 = source.getBytes();\r\n    byte[] temp2 = new byte[temp1.length + 1];\r\n    System.arraycopy(temp1, 0, temp2, 0, temp1.length);\r\n    temp2[temp1.length] = 0;\r\n    if (key == null) {\r\n        key = new RawCollationKey();\r\n    }\r\n    key.bytes = temp2;\r\n    key.size = temp2.length;\r\n    return key;\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationAPITest.TestSubClass",
	"Comment": "simple test to see if collator is subclassable.also test coverage of base class methods that are overridden by rulebasedcollator.",
	"Method": "void TestSubClass(){\r\n    if (isFrozen()) {\r\n        throw new UnsupportedOperationException(\"Attempt to modify frozen object\");\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationAPITest.TestSubClass",
	"Comment": "simple test to see if collator is subclassable.also test coverage of base class methods that are overridden by rulebasedcollator.",
	"Method": "void TestSubClass(){\r\n    if (isFrozen()) {\r\n        throw new UnsupportedOperationException(\"Attempt to modify frozen object\");\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationAPITest.TestSubClass",
	"Comment": "simple test to see if collator is subclassable.also test coverage of base class methods that are overridden by rulebasedcollator.",
	"Method": "void TestSubClass(){\r\n    return 0;\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationAPITest.TestSubClass",
	"Comment": "simple test to see if collator is subclassable.also test coverage of base class methods that are overridden by rulebasedcollator.",
	"Method": "void TestSubClass(){\r\n    return VersionInfo.getInstance(0);\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationAPITest.TestSubClass",
	"Comment": "simple test to see if collator is subclassable.also test coverage of base class methods that are overridden by rulebasedcollator.",
	"Method": "void TestSubClass(){\r\n    return VersionInfo.getInstance(0);\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.readCyclicReference",
	"Comment": "reads the next item from the stream assuming it is a cyclic reference toan object previously read. return the actual object previously read.",
	"Method": "Object readCyclicReference(){\r\n    return registeredObjectRead(readNewHandle());\r\n}"
}, {
	"Path": "android.icu.impl.LocaleIDParser.getName",
	"Comment": "returns the normalized full form of the locale id.the fullform includes keywords if they are present.",
	"Method": "String getName(){\r\n    parseBaseName();\r\n    parseKeywords();\r\n    return getString(0);\r\n}"
}, {
	"Path": "android.icu.impl.IDNA2003.isLabelSeparator",
	"Comment": "ascertain if the given code point is a label separator as defined by the idna rfc",
	"Method": "boolean isLabelSeparator(int ch){\r\n    switch(ch) {\r\n        case 0x002e:\r\n        case 0x3002:\r\n        case 0xFF0E:\r\n        case 0xFF61:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.TransliteratorParser.appendVariableDef",
	"Comment": "append the value of the given variable name to the givenstringbuffer.",
	"Method": "void appendVariableDef(String name,StringBuffer buf){\r\n    char[] ch = variableNames.get(name);\r\n    if (ch == null) {\r\n        if (undefinedVariableName == null) {\r\n            undefinedVariableName = name;\r\n            if (variableNext >= variableLimit) {\r\n                throw new RuntimeException(\"Private use variables exhausted\");\r\n            }\r\n            buf.append(--variableLimit);\r\n        } else {\r\n            throw new IllegalIcuArgumentException(\"Undefined variable $\" + name);\r\n        }\r\n    } else {\r\n        buf.append(ch);\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.registerObjectRead",
	"Comment": "associates a read object with the its serialization handle.",
	"Method": "void registerObjectRead(Object obj,int handle,boolean unshared){\r\n    if (unshared) {\r\n        obj = UNSHARED_OBJ;\r\n    }\r\n    int index = handle - ObjectStreamConstants.baseWireHandle;\r\n    int size = objectsRead.size();\r\n    while (index > size) {\r\n        objectsRead.add(null);\r\n        ++size;\r\n    }\r\n    if (index == size) {\r\n        objectsRead.add(obj);\r\n    } else {\r\n        objectsRead.set(index, obj);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.CharsetRecog_2022.match",
	"Comment": "matching function shared among the 2022 detectors jp, cn and krcounts up the number of legal an unrecognized escape sequences inthe sample of text, and computes a score based on the total number &the proportion that fit the encoding.",
	"Method": "int match(byte[] text,int textLen,byte[][] escapeSequences,CharsetMatch match,CharsetDetector det,CharsetMatch match,CharsetDetector det,CharsetMatch match,CharsetDetector det){\r\n    int i, j;\r\n    int escN;\r\n    int hits = 0;\r\n    int misses = 0;\r\n    int shifts = 0;\r\n    int quality;\r\n    scanInput: for (i = 0; i < textLen; i++) {\r\n        if (text[i] == 0x1b) {\r\n            checkEscapes: for (escN = 0; escN < escapeSequences.length; escN++) {\r\n                byte[] seq = escapeSequences[escN];\r\n                if ((textLen - i) < seq.length) {\r\n                    continue checkEscapes;\r\n                }\r\n                for (j = 1; j < seq.length; j++) {\r\n                    if (seq[j] != text[i + j]) {\r\n                        continue checkEscapes;\r\n                    }\r\n                }\r\n                hits++;\r\n                i += seq.length - 1;\r\n                continue scanInput;\r\n            }\r\n            misses++;\r\n        }\r\n        if (text[i] == 0x0e || text[i] == 0x0f) {\r\n            shifts++;\r\n        }\r\n    }\r\n    if (hits == 0) {\r\n        return 0;\r\n    }\r\n    quality = (100 * hits - 100 * misses) / (hits + misses);\r\n    if (hits + shifts < 5) {\r\n        quality -= (5 - (hits + shifts)) * 10;\r\n    }\r\n    if (quality < 0) {\r\n        quality = 0;\r\n    }\r\n    return quality;\r\n}"
}, {
	"Path": "android.icu.util.Calendar.setMinimalDaysInFirstWeek",
	"Comment": "sets what the minimal days required in the first week of the year are.for example, if the first week is defined as one that contains the firstday of the first month of a year, call the method with value 1. if itmust be a full week, use value 7.",
	"Method": "void setMinimalDaysInFirstWeek(int value){\r\n    if (value < 1) {\r\n        value = 1;\r\n    } else if (value > 7) {\r\n        value = 7;\r\n    }\r\n    if (minimalDaysInFirstWeek != value) {\r\n        minimalDaysInFirstWeek = value;\r\n        areFieldsSet = false;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedNumberFormat.init",
	"Comment": "this function parses the description and uses it to build all ofinternal data structures that the formatter uses to do formatting",
	"Method": "void init(String description,String[][] localizations){\r\n    initLocalizations(localizations);\r\n    StringBuilder descBuf = stripWhitespace(description);\r\n    lenientParseRules = extractSpecial(descBuf, \"%%lenient-parse:\");\r\n    postProcessRules = extractSpecial(descBuf, \"%%post-process:\");\r\n    int numRuleSets = 1;\r\n    int p = 0;\r\n    while ((p = descBuf.indexOf(\";%\", p)) != -1) {\r\n        ++numRuleSets;\r\n        p += 2;\r\n    }\r\n    ruleSets = new NFRuleSet[numRuleSets];\r\n    ruleSetsMap = new HashMap<String, NFRuleSet>(numRuleSets * 2 + 1);\r\n    defaultRuleSet = null;\r\n    int publicRuleSetCount = 0;\r\n    String[] ruleSetDescriptions = new String[numRuleSets];\r\n    int curRuleSet = 0;\r\n    int start = 0;\r\n    while (curRuleSet < ruleSets.length) {\r\n        p = descBuf.indexOf(\";%\", start);\r\n        if (p < 0) {\r\n            p = descBuf.length() - 1;\r\n        }\r\n        ruleSetDescriptions[curRuleSet] = descBuf.substring(start, p + 1);\r\n        NFRuleSet ruleSet = new NFRuleSet(this, ruleSetDescriptions, curRuleSet);\r\n        ruleSets[curRuleSet] = ruleSet;\r\n        String currentName = ruleSet.getName();\r\n        ruleSetsMap.put(currentName, ruleSet);\r\n        if (!currentName.startsWith(\"%%\")) {\r\n            ++publicRuleSetCount;\r\n            if (defaultRuleSet == null && currentName.equals(\"%spellout-numbering\") || currentName.equals(\"%digits-ordinal\") || currentName.equals(\"%duration\")) {\r\n                defaultRuleSet = ruleSet;\r\n            }\r\n        }\r\n        ++curRuleSet;\r\n        start = p + 1;\r\n    }\r\n    if (defaultRuleSet == null) {\r\n        for (int i = ruleSets.length - 1; i >= 0; --i) {\r\n            if (!ruleSets[i].getName().startsWith(\"%%\")) {\r\n                defaultRuleSet = ruleSets[i];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (defaultRuleSet == null) {\r\n        defaultRuleSet = ruleSets[ruleSets.length - 1];\r\n    }\r\n    for (int i = 0; i < ruleSets.length; i++) {\r\n        ruleSets[i].parseRules(ruleSetDescriptions[i]);\r\n    }\r\n    String[] publicRuleSetTemp = new String[publicRuleSetCount];\r\n    publicRuleSetCount = 0;\r\n    for (int i = ruleSets.length - 1; i >= 0; i--) {\r\n        if (!ruleSets[i].getName().startsWith(\"%%\")) {\r\n            publicRuleSetTemp[publicRuleSetCount++] = ruleSets[i].getName();\r\n        }\r\n    }\r\n    if (publicRuleSetNames != null) {\r\n        loop: for (int i = 0; i < publicRuleSetNames.length; ++i) {\r\n            String name = publicRuleSetNames[i];\r\n            for (int j = 0; j < publicRuleSetTemp.length; ++j) {\r\n                if (name.equals(publicRuleSetTemp[j])) {\r\n                    continue loop;\r\n                }\r\n            }\r\n            throw new IllegalArgumentException(\"did not find public rule set: \" + name);\r\n        }\r\n        defaultRuleSet = findRuleSet(publicRuleSetNames[0]);\r\n    } else {\r\n        publicRuleSetNames = publicRuleSetTemp;\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.EthiopicTest.TestEraStart",
	"Comment": "eventually should modify to use locale strings and formatter appropriate to coptic calendar",
	"Method": "void TestEraStart(){\r\n    SimpleDateFormat fmt = new SimpleDateFormat(\"EEE MMM dd, yyyy GG\");\r\n    fmt.setCalendar(new EthiopicCalendar());\r\n    EthiopicCalendar cal = new EthiopicCalendar(1, 0, 1);\r\n    assertEquals(\"Ethiopic Date\", \"Wed Jan 01, 0001 AD\", fmt.format(cal));\r\n    cal.set(Calendar.ERA, 0);\r\n    cal.set(Calendar.YEAR, 5500);\r\n    assertEquals(\"Ethiopic Date\", \"Tue Jan 01, 5500 BC\", fmt.format(cal));\r\n    GregorianCalendar gc = new GregorianCalendar();\r\n    gc.setGregorianChange(new Date(Long.MIN_VALUE));\r\n    gc.setTime(cal.getTime());\r\n    fmt.setCalendar(new GregorianCalendar());\r\n    assertEquals(\"Gregorian Date\", \"Tue Aug 28, 0007 AD\", fmt.format(gc));\r\n}"
}, {
	"Path": "android.icu.text.Bidi.invertMap",
	"Comment": "invert an index map.the index mapping of the argument map is inverted and returned asan array of indexes that we will call the inverse map.",
	"Method": "int[] invertMap(int[] srcMap){\r\n    if (srcMap == null) {\r\n        return null;\r\n    } else {\r\n        return BidiLine.invertMap(srcMap);\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.duration.impl.PeriodFormatterData.appendPrefix",
	"Comment": "append the appropriate prefix to the string builder, depending on whether andhow a limit and direction are to be displayed.",
	"Method": "boolean appendPrefix(int tl,int td,StringBuffer sb){\r\n    if (dr.scopeData != null) {\r\n        int ix = tl * 3 + td;\r\n        ScopeData sd = dr.scopeData[ix];\r\n        if (sd != null) {\r\n            String prefix = sd.prefix;\r\n            if (prefix != null) {\r\n                sb.append(prefix);\r\n                return sd.requiresDigitPrefix;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "android.icu.util.LocalePriorityList.add",
	"Comment": "add a language code to the list being built, with specified weight.",
	"Method": "Builder add(ULocale languageCode,Builder add,ULocale languageCode,double weight,Builder add,LocalePriorityList languagePriorityList,Builder add,String acceptLanguageString,Builder add,LocalePriorityList languagePriorityList,Builder add,ULocale languageCode,Builder add,ULocale languageCodes,Builder add,ULocale languageCode,double weight,Builder add,String acceptLanguageList){\r\n    return new Builder().add(acceptLanguageString);\r\n}"
}, {
	"Path": "libcore.util.BasicLruCache.snapshot",
	"Comment": "returns a copy of the current contents of the cache, ordered from leastrecently accessed to most recently accessed.",
	"Method": "Map<K, V> snapshot(){\r\n    return new LinkedHashMap<K, V>(map);\r\n}"
}, {
	"Path": "android.icu.util.ULocale.equals",
	"Comment": "returns true if the other object is another ulocale with thesame full name.note that since names are not canonicalized, two ulocales thatfunction identically might not compare equal.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof ULocale) {\r\n        return localeID.equals(((ULocale) obj).localeID);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.writeEnumDesc",
	"Comment": "write for enum class desc only, which is different from other classes",
	"Method": "ObjectStreamClass writeEnumDesc(ObjectStreamClass classDesc,boolean unshared){\r\n    classDesc.setFlags((byte) (SC_SERIALIZABLE | SC_ENUM));\r\n    int previousHandle = -1;\r\n    if (unshared) {\r\n        previousHandle = objectsWritten.get(classDesc);\r\n    }\r\n    int handle = -1;\r\n    if (!unshared) {\r\n        handle = dumpCycle(classDesc);\r\n    }\r\n    if (handle == -1) {\r\n        Class<?> classToWrite = classDesc.forClass();\r\n        registerObjectWritten(classDesc);\r\n        output.writeByte(TC_CLASSDESC);\r\n        if (protocolVersion == PROTOCOL_VERSION_1) {\r\n            writeNewClassDesc(classDesc);\r\n        } else {\r\n            primitiveTypes = output;\r\n            writeClassDescriptor(classDesc);\r\n            primitiveTypes = null;\r\n        }\r\n        annotateClass(classToWrite);\r\n        drain();\r\n        output.writeByte(TC_ENDBLOCKDATA);\r\n        ObjectStreamClass superClassDesc = classDesc.getSuperclass();\r\n        if (superClassDesc != null) {\r\n            superClassDesc.setFlags((byte) (SC_SERIALIZABLE | SC_ENUM));\r\n            writeEnumDesc(superClassDesc, unshared);\r\n        } else {\r\n            output.writeByte(TC_NULL);\r\n        }\r\n        if (unshared) {\r\n            removeUnsharedReference(classDesc, previousHandle);\r\n        }\r\n    }\r\n    return classDesc;\r\n}"
}, {
	"Path": "android.icu.text.StringSearch.nextBoundaryAfter",
	"Comment": "find the next break boundary after startindex. if the ustringsearch objecthas an external break iterator, use that. otherwise use the internal characterbreak iterator.",
	"Method": "int nextBoundaryAfter(int startIndex){\r\n    BreakIterator breakiterator = search_.breakIter();\r\n    if (breakiterator == null) {\r\n        breakiterator = search_.internalBreakIter_;\r\n    }\r\n    if (breakiterator != null) {\r\n        return breakiterator.following(startIndex);\r\n    }\r\n    return startIndex;\r\n}"
}, {
	"Path": "android.icu.impl.TrieIterator.next",
	"Comment": "returns true if we are not at the end of the iteration, false otherwise. the next set of codepoints with the same value type will be calculated during this call and returned in the arguement element.",
	"Method": "boolean next(Element element){\r\n    if (m_nextCodepoint_ > UCharacter.MAX_VALUE) {\r\n        return false;\r\n    }\r\n    if (m_nextCodepoint_ < UCharacter.SUPPLEMENTARY_MIN_VALUE && calculateNextBMPElement(element)) {\r\n        return true;\r\n    }\r\n    calculateNextSupplementaryElement(element);\r\n    return true;\r\n}"
}, {
	"Path": "android.icu.text.MeasureFormat.loadLocaleData",
	"Comment": "returns formatting data for all measureunits except for currency ones.",
	"Method": "MeasureFormatData loadLocaleData(ULocale locale){\r\n    ICUResourceBundle resource = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_UNIT_BASE_NAME, locale);\r\n    MeasureFormatData cacheData = new MeasureFormatData();\r\n    UnitDataSink sink = new UnitDataSink(cacheData);\r\n    resource.getAllItemsWithFallback(\"\", sink);\r\n    return cacheData;\r\n}"
}, {
	"Path": "android.icu.text.RBBISymbolTable.lookupMatcher",
	"Comment": "and we just need to remember what set to return between these two calls.",
	"Method": "UnicodeMatcher lookupMatcher(int ch){\r\n    UnicodeSet retVal = null;\r\n    if (ch == 0xffff) {\r\n        retVal = fCachedSetLookup;\r\n        fCachedSetLookup = null;\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "android.icu.text.PluralRules.getAllKeywordValues",
	"Comment": "returns all the values that trigger this keyword, or null if the number of suchvalues is unlimited.",
	"Method": "Collection<Double> getAllKeywordValues(String keyword,Collection<Double> getAllKeywordValues,String keyword,SampleType type){\r\n    if (!isLimited(keyword, type)) {\r\n        return null;\r\n    }\r\n    Collection<Double> samples = getSamples(keyword, type);\r\n    return samples == null ? null : Collections.unmodifiableCollection(samples);\r\n}"
}, {
	"Path": "android.icu.util.Calendar.handleGetYearLength",
	"Comment": "returns the number of days in the given extended year of thiscalendar system.subclasses should override this method if they canprovide a more correct or more efficient implementation than thedefault implementation in calendar.",
	"Method": "int handleGetYearLength(int eyear){\r\n    return handleComputeMonthStart(eyear + 1, 0, false) - handleComputeMonthStart(eyear, 0, false);\r\n}"
}, {
	"Path": "libcore.java.io.OldRandomAccessFileTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this methodis called before a test is executed.",
	"Method": "void setUp(){\r\n    super.setUp();\r\n    f = File.createTempFile(\"raf\", \"tst\");\r\n    if (!f.delete()) {\r\n        fail(\"Unable to delete test file : \" + f);\r\n    }\r\n    fileName = f.getAbsolutePath();\r\n}"
}, {
	"Path": "android.icu.impl.UnicodeSetStringSpan.addToSpanNotSet",
	"Comment": "adds a starting or ending string character to the spannotsetso that a character span ends before any string.",
	"Method": "void addToSpanNotSet(int c){\r\n    if (Utility.sameObjects(spanNotSet, null) || Utility.sameObjects(spanNotSet, spanSet)) {\r\n        if (spanSet.contains(c)) {\r\n            return;\r\n        }\r\n        spanNotSet = spanSet.cloneAsThawed();\r\n    }\r\n    spanNotSet.add(c);\r\n}"
}, {
	"Path": "android.icu.text.TimeZoneFormat.getGMTOffsetDigits",
	"Comment": "returns the decimal digit characters used for localized gmt format in a single stringcontaining from 0 to 9 in the ascending order.",
	"Method": "String getGMTOffsetDigits(){\r\n    StringBuilder buf = new StringBuilder(_gmtOffsetDigits.length);\r\n    for (String digit : _gmtOffsetDigits) {\r\n        buf.append(digit);\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.complement",
	"Comment": "complements the specified character in this set.the characterwill be removed if it is in this set, or will be added if it isnot in this set.",
	"Method": "UnicodeSet complement(int start,int end,UnicodeSet complement,int c,UnicodeSet complement,UnicodeSet complement,CharSequence s){\r\n    checkFrozen();\r\n    int cp = getSingleCP(s);\r\n    if (cp < 0) {\r\n        String s2 = s.toString();\r\n        if (strings.contains(s2)) {\r\n            strings.remove(s2);\r\n        } else {\r\n            strings.add(s2);\r\n        }\r\n        pat = null;\r\n    } else {\r\n        complement(cp, cp);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationIteratorTest.TestUnicodeChar",
	"Comment": "test for collationelementiterator previous and next for the whole set ofunicode characters.",
	"Method": "void TestUnicodeChar(){\r\n    RuleBasedCollator en_us = (RuleBasedCollator) Collator.getInstance(Locale.US);\r\n    CollationElementIterator iter;\r\n    char codepoint;\r\n    StringBuffer source = new StringBuffer();\r\n    source.append(\"???\");\r\n    iter = en_us.getCollationElementIterator(source.toString());\r\n    CollationTest.backAndForth(this, iter);\r\n    for (codepoint = 1; codepoint < 0xFFFE; ) {\r\n        source.delete(0, source.length());\r\n        while (codepoint % 0xFF != 0) {\r\n            if (UCharacter.isDefined(codepoint)) {\r\n                source.append(codepoint);\r\n            }\r\n            codepoint++;\r\n        }\r\n        if (UCharacter.isDefined(codepoint)) {\r\n            source.append(codepoint);\r\n        }\r\n        if (codepoint != 0xFFFF) {\r\n            codepoint++;\r\n        }\r\n        iter = en_us.getCollationElementIterator(source.toString());\r\n        CollationTest.backAndForth(this, iter);\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.CopticTest.TestCases",
	"Comment": "a huge list of test cases to make sure that computetime and computefieldswork properly for a wide range of data in the civil calendar.",
	"Method": "void TestCases(){\r\n    final TestCase[] tests = { new TestCase(2401442.5, 1, 1579, 2, 20, WED, 0, 0, 0), new TestCase(2402422.5, 1, 1581, 10, 29, WED, 0, 0, 0), new TestCase(2402630.5, 1, 1582, 5, 22, MON, 0, 0, 0), new TestCase(2402708.5, 1, 1582, 8, 10, TUE, 0, 0, 0), new TestCase(2402971.5, 1, 1583, 4, 28, SAT, 0, 0, 0), new TestCase(2403344.5, 1, 1584, 5, 5, MON, 0, 0, 0), new TestCase(1721059.5, 0, 285, 5, 7, SAT, 0, 0, 0), new TestCase(1721425.5, 0, 284, 5, 8, MON, 0, 0, 0), new TestCase(1824663.5, 0, 2, 13, 6, WED, 0, 0, 0), new TestCase(1824664.5, 0, 1, 1, 1, THU, 0, 0, 0), new TestCase(1825029.5, 1, 1, 1, 1, FRI, 0, 0, 0), new TestCase(1825394.5, 1, 2, 1, 1, SAT, 0, 0, 0), new TestCase(1825759.5, 1, 3, 1, 1, SUN, 0, 0, 0), new TestCase(1826125.5, 1, 4, 1, 1, TUE, 0, 0, 0), new TestCase(1825028.5, 0, 1, 13, 5, THU, 0, 0, 0), new TestCase(1825393.5, 1, 1, 13, 5, FRI, 0, 0, 0), new TestCase(1825758.5, 1, 2, 13, 5, SAT, 0, 0, 0), new TestCase(1826123.5, 1, 3, 13, 5, SUN, 0, 0, 0), new TestCase(1826124.5, 1, 3, 13, 6, MON, 0, 0, 0), new TestCase(1826489.5, 1, 4, 13, 5, TUE, 0, 0, 0), new TestCase(2299158.5, 1, 1299, 2, 6, WED, 0, 0, 0), new TestCase(2299159.5, 1, 1299, 2, 7, THU, 0, 0, 0), new TestCase(2299160.5, 1, 1299, 2, 8, FRI, 0, 0, 0), new TestCase(2299161.5, 1, 1299, 2, 9, SAT, 0, 0, 0), new TestCase(2415020.5, 1, 1616, 4, 23, MON, 0, 0, 0), new TestCase(2453371.5, 1, 1721, 4, 23, SAT, 0, 0, 0), new TestCase(2555528.5, 1, 2000, 13, 5, FRI, 0, 0, 0) };\r\n    CopticCalendar testCalendar = new CopticCalendar();\r\n    testCalendar.setLenient(true);\r\n    doTestCases(tests, testCalendar);\r\n}"
}, {
	"Path": "android.icu.text.PluralRules.nextToken",
	"Comment": "returns the token at x if available, else throws a parse exception.",
	"Method": "String nextToken(String[] tokens,int x,String context){\r\n    if (x < tokens.length) {\r\n        return tokens[x];\r\n    }\r\n    throw new ParseException(\"missing token at end of '\" + context + \"'\", -1);\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.getDecimalFormatSymbols",
	"Comment": "returns a copy of the decimal format symbols used by this format.",
	"Method": "DecimalFormatSymbols getDecimalFormatSymbols(){\r\n    try {\r\n        return (DecimalFormatSymbols) symbols.clone();\r\n    } catch (Exception foo) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedNumberFormat.setLenientParseMode",
	"Comment": "turns lenient parse mode on and off.when in lenient parse mode, the formatter uses an rbnflenientscannerfor parsing the text.lenient parsing is only in effect if a scanneris set.if a provider is not set, and this is used for parsing,a default scanner rbnflenientscannerproviderimpl will be set ifit is available on the classpath.otherwise this will have no effect.",
	"Method": "void setLenientParseMode(boolean enabled){\r\n    lenientParse = enabled;\r\n}"
}, {
	"Path": "android.icu.lang.UCharacter.isJavaLetterOrDigit",
	"Comment": "compatibility override of java deprecated method.thismethod will always remain deprecated.delegates tojava.lang.character.isjavaidentifierpart.",
	"Method": "boolean isJavaLetterOrDigit(int cp){\r\n    return isJavaIdentifierPart(cp);\r\n}"
}, {
	"Path": "android.icu.lang.UCharacter.isJavaIdentifierPart",
	"Comment": "compatibility override of java method, delegates tojava.lang.character.isjavaidentifierpart.",
	"Method": "boolean isJavaIdentifierPart(int cp){\r\n    return java.lang.Character.isJavaIdentifierPart((char) cp);\r\n}"
}, {
	"Path": "android.icu.text.DurationFormat.parseObject",
	"Comment": "durationformat cannot parse, by default. this method will throw an unsupportedoperationexception.",
	"Method": "Object parseObject(String source,ParsePosition pos){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "android.icu.util.TimeZone.getFrozenICUTimeZone",
	"Comment": "returns a frozen icu type timezone object given a time zone id.",
	"Method": "BasicTimeZone getFrozenICUTimeZone(String id,boolean trySystem){\r\n    BasicTimeZone result = null;\r\n    if (trySystem) {\r\n        result = ZoneMeta.getSystemTimeZone(id);\r\n    }\r\n    if (result == null) {\r\n        result = ZoneMeta.getCustomTimeZone(id);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.registerFactory",
	"Comment": "register a factory.returns the factory if the service acceptsthe factory, otherwise returns null.the default implementationaccepts all factories.",
	"Method": "Factory registerFactory(Factory factory){\r\n    if (factory == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    try {\r\n        factoryLock.acquireWrite();\r\n        factories.add(0, factory);\r\n        clearCaches();\r\n    } finally {\r\n        factoryLock.releaseWrite();\r\n    }\r\n    notifyChanged();\r\n    return factory;\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.findPrivateMethod",
	"Comment": "return the java.lang.reflect.method if class cl implementsprivate methodname . return null otherwise.",
	"Method": "Method findPrivateMethod(Class<?> cl,String methodName,Class<?>[] param){\r\n    try {\r\n        Method method = cl.getDeclaredMethod(methodName, param);\r\n        if (Modifier.isPrivate(method.getModifiers()) && method.getReturnType() == void.class) {\r\n            method.setAccessible(true);\r\n            return method;\r\n        }\r\n    } catch (NoSuchMethodException nsm) {\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.text.NumberFormat.getInstance",
	"Comment": "returns a specific style number format for a specific locale.",
	"Method": "NumberFormat getInstance(NumberFormat getInstance,Locale inLocale,NumberFormat getInstance,ULocale inLocale,NumberFormat getInstance,int style,NumberFormat getInstance,Locale inLocale,int style,NumberFormat getInstance,ULocale desiredLocale,int choice){\r\n    if (choice < NUMBERSTYLE || choice > STANDARDCURRENCYSTYLE) {\r\n        throw new IllegalArgumentException(\"choice should be from NUMBERSTYLE to STANDARDCURRENCYSTYLE\");\r\n    }\r\n    return getShim().createInstance(desiredLocale, choice);\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationFinnishTest.doTest",
	"Comment": "main test routine, tests rules specific to the finish locale",
	"Method": "void doTest(char[] source,char[] target,int result){\r\n    String s = new String(source);\r\n    String t = new String(target);\r\n    int compareResult = myCollation.compare(s, t);\r\n    CollationKey sortKey1, sortKey2;\r\n    sortKey1 = myCollation.getCollationKey(s);\r\n    sortKey2 = myCollation.getCollationKey(t);\r\n    int keyResult = sortKey1.compareTo(sortKey2);\r\n    reportCResult(s, t, sortKey1, sortKey2, compareResult, keyResult, compareResult, result);\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.getLoadFields",
	"Comment": "returns the collection of field descriptors for the input fields of thecorresponding class",
	"Method": "ObjectStreamField[] getLoadFields(){\r\n    return loadFields;\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedBreakIterator.setText",
	"Comment": "set the iterator to analyze a new piece of text.this function resetsthe current iteration position to the beginning of the text.",
	"Method": "void setText(CharacterIterator newText){\r\n    fText = newText;\r\n    this.first();\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.resetState",
	"Comment": "reset the receiver. the collection of objects already dumped by thereceiver is reset, and internal structures are also reset so that thereceiver knows it is in a fresh clean state.",
	"Method": "void resetState(){\r\n    resetSeenObjects();\r\n    nestedLevels = 0;\r\n}"
}, {
	"Path": "java.text.Normalizer.isNormalized",
	"Comment": "check whether the given character sequence src is normalizedaccording to the normalization method form.",
	"Method": "boolean isNormalized(CharSequence src,Form form){\r\n    return normalize(src, form).equals(src);\r\n}"
}, {
	"Path": "android.icu.text.DateIntervalInfo.genPatternInfo",
	"Comment": "break interval patterns as 2 part and save them into pattern info.",
	"Method": "PatternInfo genPatternInfo(String intervalPattern,boolean laterDateFirst){\r\n    int splitPoint = splitPatternInto2Part(intervalPattern);\r\n    String firstPart = intervalPattern.substring(0, splitPoint);\r\n    String secondPart = null;\r\n    if (splitPoint < intervalPattern.length()) {\r\n        secondPart = intervalPattern.substring(splitPoint, intervalPattern.length());\r\n    }\r\n    return new PatternInfo(firstPart, secondPart, laterDateFirst);\r\n}"
}, {
	"Path": "android.icu.text.NumberingSystem.getAvailableNames",
	"Comment": "returns a string array containing a list of the names of numbering systemscurrently known to icu.",
	"Method": "String[] getAvailableNames(){\r\n    UResourceBundle numberingSystemsInfo = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, \"numberingSystems\");\r\n    UResourceBundle nsCurrent = numberingSystemsInfo.get(\"numberingSystems\");\r\n    UResourceBundle temp;\r\n    String nsName;\r\n    ArrayList<String> output = new ArrayList<String>();\r\n    UResourceBundleIterator it = nsCurrent.getIterator();\r\n    while (it.hasNext()) {\r\n        temp = it.next();\r\n        nsName = temp.getKey();\r\n        output.add(nsName);\r\n    }\r\n    return output.toArray(new String[output.size()]);\r\n}"
}, {
	"Path": "android.icu.impl.CharTrie.getLeadValue",
	"Comment": "gets the value to the data which this lead surrogate character points to. returned data may contain folding offset information for the next trailing surrogate character. this method does not guarantee correct results for trail surrogates.",
	"Method": "char getLeadValue(char ch){\r\n    return m_data_[getLeadOffset(ch)];\r\n}"
}, {
	"Path": "android.icu.text.MessageFormat.setFormatsByArgumentIndex",
	"Comment": "sets the format objects to use for the values passed intoformat methods or returned from parsemethods. the indices of elements in newformatscorrespond to the argument indices used in the previously setpattern string.the order of formats in newformats thus corresponds tothe order of elements in the arguments array passedto the format methods or the result array returnedby the parse methods.if an argument index is used for more than one format elementin the pattern string, then the corresponding new format is usedfor all such format elements. if an argument index is not usedfor any format element in the pattern string, then thecorresponding new format is ignored. if fewer formats are providedthan needed, then only the formats for argument indices lessthan newformats.length are replaced.this method is only supported if the format does not usenamed arguments, otherwise an illegalargumentexception is thrown.",
	"Method": "void setFormatsByArgumentIndex(Format[] newFormats){\r\n    if (msgPattern.hasNamedArguments()) {\r\n        throw new IllegalArgumentException(\"This method is not available in MessageFormat objects \" + \"that use alphanumeric argument names.\");\r\n    }\r\n    for (int partIndex = 0; (partIndex = nextTopLevelArgStart(partIndex)) >= 0; ) {\r\n        int argNumber = msgPattern.getPart(partIndex + 1).getValue();\r\n        if (argNumber < newFormats.length) {\r\n            setCustomArgStartFormat(partIndex, newFormats[argNumber]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.retain",
	"Comment": "retain the specified string in this set if it is present.upon return this set will be empty if it did not contain s, orwill only contain s if it did contain s.",
	"Method": "UnicodeSet retain(int start,int end,UnicodeSet retain,int c,UnicodeSet retain,CharSequence cs,UnicodeSet retain,int[] other,int otherLen,int polarity){\r\n    ensureBufferCapacity(len + otherLen);\r\n    int i = 0, j = 0, k = 0;\r\n    int a = list[i++];\r\n    int b = other[j++];\r\n    main: while (true) {\r\n        switch(polarity) {\r\n            case 0:\r\n                if (a < b) {\r\n                    a = list[i++];\r\n                    polarity ^= 1;\r\n                } else if (b < a) {\r\n                    b = other[j++];\r\n                    polarity ^= 2;\r\n                } else {\r\n                    if (a == HIGH)\r\n                        break main;\r\n                    buffer[k++] = a;\r\n                    a = list[i++];\r\n                    polarity ^= 1;\r\n                    b = other[j++];\r\n                    polarity ^= 2;\r\n                }\r\n                break;\r\n            case 3:\r\n                if (a < b) {\r\n                    buffer[k++] = a;\r\n                    a = list[i++];\r\n                    polarity ^= 1;\r\n                } else if (b < a) {\r\n                    buffer[k++] = b;\r\n                    b = other[j++];\r\n                    polarity ^= 2;\r\n                } else {\r\n                    if (a == HIGH)\r\n                        break main;\r\n                    buffer[k++] = a;\r\n                    a = list[i++];\r\n                    polarity ^= 1;\r\n                    b = other[j++];\r\n                    polarity ^= 2;\r\n                }\r\n                break;\r\n            case 1:\r\n                if (a < b) {\r\n                    a = list[i++];\r\n                    polarity ^= 1;\r\n                } else if (b < a) {\r\n                    buffer[k++] = b;\r\n                    b = other[j++];\r\n                    polarity ^= 2;\r\n                } else {\r\n                    if (a == HIGH)\r\n                        break main;\r\n                    a = list[i++];\r\n                    polarity ^= 1;\r\n                    b = other[j++];\r\n                    polarity ^= 2;\r\n                }\r\n                break;\r\n            case 2:\r\n                if (b < a) {\r\n                    b = other[j++];\r\n                    polarity ^= 2;\r\n                } else if (a < b) {\r\n                    buffer[k++] = a;\r\n                    a = list[i++];\r\n                    polarity ^= 1;\r\n                } else {\r\n                    if (a == HIGH)\r\n                        break main;\r\n                    a = list[i++];\r\n                    polarity ^= 1;\r\n                    b = other[j++];\r\n                    polarity ^= 2;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    buffer[k++] = HIGH;\r\n    len = k;\r\n    int[] temp = list;\r\n    list = buffer;\r\n    buffer = temp;\r\n    pat = null;\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.impl.RelativeDateFormat.initCapitalizationContextInfo",
	"Comment": "set capitalizationofrelativeunitsforlistormenu, capitalizationofrelativeunitsforstandalone",
	"Method": "void initCapitalizationContextInfo(ULocale locale){\r\n    ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, locale);\r\n    try {\r\n        ICUResourceBundle rdb = rb.getWithFallback(\"contextTransforms/relative\");\r\n        int[] intVector = rdb.getIntVector();\r\n        if (intVector.length >= 2) {\r\n            capitalizationOfRelativeUnitsForListOrMenu = (intVector[0] != 0);\r\n            capitalizationOfRelativeUnitsForStandAlone = (intVector[1] != 0);\r\n        }\r\n    } catch (MissingResourceException e) {\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.VTimeZone.writeFinalRule",
	"Comment": "write the final time zone rule using rrule, with no until attribute",
	"Method": "void writeFinalRule(Writer writer,boolean isDst,AnnualTimeZoneRule rule,int fromRawOffset,int fromDSTSavings,long startTime){\r\n    DateTimeRule dtrule = toWallTimeRule(rule.getRule(), fromRawOffset, fromDSTSavings);\r\n    int timeInDay = dtrule.getRuleMillisInDay();\r\n    if (timeInDay < 0) {\r\n        startTime = startTime + (0 - timeInDay);\r\n    } else if (timeInDay >= Grego.MILLIS_PER_DAY) {\r\n        startTime = startTime - (timeInDay - (Grego.MILLIS_PER_DAY - 1));\r\n    }\r\n    int toOffset = rule.getRawOffset() + rule.getDSTSavings();\r\n    switch(dtrule.getDateRuleType()) {\r\n        case DateTimeRule.DOM:\r\n            writeZonePropsByDOM(writer, isDst, rule.getName(), fromRawOffset + fromDSTSavings, toOffset, dtrule.getRuleMonth(), dtrule.getRuleDayOfMonth(), startTime, MAX_TIME);\r\n            break;\r\n        case DateTimeRule.DOW:\r\n            writeZonePropsByDOW(writer, isDst, rule.getName(), fromRawOffset + fromDSTSavings, toOffset, dtrule.getRuleMonth(), dtrule.getRuleWeekInMonth(), dtrule.getRuleDayOfWeek(), startTime, MAX_TIME);\r\n            break;\r\n        case DateTimeRule.DOW_GEQ_DOM:\r\n            writeZonePropsByDOW_GEQ_DOM(writer, isDst, rule.getName(), fromRawOffset + fromDSTSavings, toOffset, dtrule.getRuleMonth(), dtrule.getRuleDayOfMonth(), dtrule.getRuleDayOfWeek(), startTime, MAX_TIME);\r\n            break;\r\n        case DateTimeRule.DOW_LEQ_DOM:\r\n            writeZonePropsByDOW_LEQ_DOM(writer, isDst, rule.getName(), fromRawOffset + fromDSTSavings, toOffset, dtrule.getRuleMonth(), dtrule.getRuleDayOfMonth(), dtrule.getRuleDayOfWeek(), startTime, MAX_TIME);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.Bidi.getParagraphByIndex",
	"Comment": "get a paragraph, given the index of this paragraph.this method returns information about a paragraph.",
	"Method": "BidiRun getParagraphByIndex(int paraIndex){\r\n    verifyValidParaOrLine();\r\n    verifyRange(paraIndex, 0, paraCount);\r\n    Bidi bidi = paraBidi;\r\n    int paraStart;\r\n    if (paraIndex == 0) {\r\n        paraStart = 0;\r\n    } else {\r\n        paraStart = bidi.paras_limit[paraIndex - 1];\r\n    }\r\n    BidiRun bidiRun = new BidiRun();\r\n    bidiRun.start = paraStart;\r\n    bidiRun.limit = bidi.paras_limit[paraIndex];\r\n    bidiRun.level = GetParaLevelAt(paraStart);\r\n    return bidiRun;\r\n}"
}, {
	"Path": "android.icu.text.DateFormat.getAvailableLocales",
	"Comment": "returns the set of locales for which dateformats are installed.",
	"Method": "Locale[] getAvailableLocales(){\r\n    return ICUResourceBundle.getAvailableLocales();\r\n}"
}, {
	"Path": "android.icu.util.GlobalizationPreferences.guessCurrency",
	"Comment": "this function can be overridden by subclasses to use different heuristics",
	"Method": "Currency guessCurrency(){\r\n    return Currency.getInstance(new ULocale(\"und-\" + getTerritory()));\r\n}"
}, {
	"Path": "android.icu.impl.duration.Period.lessThan",
	"Comment": "constructs a period representing a durationless than count units extending into the past.",
	"Method": "Period lessThan(float count,TimeUnit unit,Period lessThan){\r\n    return setTimeLimit(ETimeLimit.LT);\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.getLocale",
	"Comment": "get the locale of this simple date formatter.it is package accessible. also used in dateintervalformat.",
	"Method": "ULocale getLocale(){\r\n    return locale;\r\n}"
}, {
	"Path": "android.icu.text.NumberFormat.getCurrencyInstance",
	"Comment": "returns a currency format for the current default format locale.",
	"Method": "NumberFormat getCurrencyInstance(NumberFormat getCurrencyInstance,Locale inLocale,NumberFormat getCurrencyInstance,ULocale inLocale){\r\n    return getInstance(inLocale, CURRENCYSTYLE);\r\n}"
}, {
	"Path": "android.icu.util.ByteArrayWrapper.compareTo",
	"Comment": "compare this object to another bytearraywrapper, which must not be null.",
	"Method": "int compareTo(ByteArrayWrapper other){\r\n    if (this == other)\r\n        return 0;\r\n    int minSize = size < other.size ? size : other.size;\r\n    for (int i = 0; i < minSize; ++i) {\r\n        if (bytes[i] != other.bytes[i]) {\r\n            return (bytes[i] & 0xFF) - (other.bytes[i] & 0xFF);\r\n        }\r\n    }\r\n    return size - other.size;\r\n}"
}, {
	"Path": "android.icu.util.VersionInfo.equals",
	"Comment": "checks if this version information is equals to the argument version",
	"Method": "boolean equals(Object other){\r\n    return other == this;\r\n}"
}, {
	"Path": "android.icu.impl.coll.CollationData.getCE32FromContexts",
	"Comment": "returns the ce32 from two contexts words.access to the defaultce32 for contraction and prefix matching.",
	"Method": "int getCE32FromContexts(int index){\r\n    return ((int) contexts.charAt(index) << 16) | contexts.charAt(index + 1);\r\n}"
}, {
	"Path": "android.icu.text.CompactDecimalDataCache.get",
	"Comment": "fetch data for a particular locale. clients must not modify any part of the returned data. portions of returneddata may be shared so modifying it will have unpredictable results.",
	"Method": "DataBundle get(ULocale locale){\r\n    DataBundle result = cache.get(locale);\r\n    if (result == null) {\r\n        result = load(locale);\r\n        cache.put(locale, result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.util.TimeZone.hasSameRules",
	"Comment": "returns true if this zone has the same rule and offset as another zone.that is, if this zone differs only in id, if at all.returns falseif the other zone is null.",
	"Method": "boolean hasSameRules(TimeZone other){\r\n    return other != null && getRawOffset() == other.getRawOffset() && useDaylightTime() == other.useDaylightTime();\r\n}"
}, {
	"Path": "java.text.StringCharacterIterator.previous",
	"Comment": "decrements the current index and returns the character at the new index.",
	"Method": "char previous(){\r\n    if (offset == start) {\r\n        return DONE;\r\n    }\r\n    return string.charAt(--offset);\r\n}"
}, {
	"Path": "android.icu.util.GlobalizationPreferences.setTimeZone",
	"Comment": "sets the timezone id.if this has not been set, uses default for territory.",
	"Method": "GlobalizationPreferences setTimeZone(TimeZone timezone){\r\n    if (isFrozen()) {\r\n        throw new UnsupportedOperationException(\"Attempt to modify immutable object\");\r\n    }\r\n    this.timezone = (TimeZone) timezone.clone();\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.text.DateIntervalFormat.setTimeZone",
	"Comment": "set the timezone for the calendar used by this dateintervalformat object.",
	"Method": "void setTimeZone(TimeZone zone){\r\n    TimeZone zoneToSet = (TimeZone) zone.clone();\r\n    if (fDateFormat != null) {\r\n        fDateFormat.setTimeZone(zoneToSet);\r\n    }\r\n    if (fFromCalendar != null) {\r\n        fFromCalendar.setTimeZone(zoneToSet);\r\n    }\r\n    if (fToCalendar != null) {\r\n        fToCalendar.setTimeZone(zoneToSet);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.DateTimePatternGenerator.getCanonicalSkeletonAllowingDuplicates",
	"Comment": "same as getskeleton, but allows duplicatesand returns a string using canonical pattern chars",
	"Method": "String getCanonicalSkeletonAllowingDuplicates(String pattern){\r\n    synchronized (this) {\r\n        current.set(pattern, fp, true);\r\n        return current.toCanonicalString();\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.PluralRules.parseDescription",
	"Comment": "parses a plural rules description and returns a pluralrules.",
	"Method": "PluralRules parseDescription(String description){\r\n    description = description.trim();\r\n    return description.length() == 0 ? DEFAULT : new PluralRules(parseRuleChain(description));\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.getPercent",
	"Comment": "returns the character used for percent sign. different for arabic, etc.",
	"Method": "char getPercent(){\r\n    return percent;\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.getSerialVersionUID",
	"Comment": "returns the serial version user id of the class represented by thisdescriptor.",
	"Method": "long getSerialVersionUID(){\r\n    return svUID;\r\n}"
}, {
	"Path": "android.icu.text.TransliterationRuleSet.addSourceTargetSet",
	"Comment": "todo merge into r.addsourcetargetset, to avoid duplicate testing",
	"Method": "void addSourceTargetSet(UnicodeSet filter,UnicodeSet sourceSet,UnicodeSet targetSet){\r\n    UnicodeSet currentFilter = new UnicodeSet(filter);\r\n    UnicodeSet revisiting = new UnicodeSet();\r\n    int count = ruleVector.size();\r\n    for (int i = 0; i < count; ++i) {\r\n        TransliterationRule r = ruleVector.get(i);\r\n        r.addSourceTargetSet(currentFilter, sourceSet, targetSet, revisiting.clear());\r\n        currentFilter.addAll(revisiting);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedTransliterator.toRules",
	"Comment": "return a representation of this transliterator as source rules.these rules will produce an equivalent transliterator if usedto construct a new transliterator.",
	"Method": "String toRules(boolean escapeUnprintable){\r\n    return data.ruleSet.toRules(escapeUnprintable);\r\n}"
}, {
	"Path": "android.icu.text.TransliterationRuleSet.freeze",
	"Comment": "close this rule set to further additions, check it for masked rules,and index it to optimize performance.",
	"Method": "void freeze(){\r\n    int n = ruleVector.size();\r\n    index = new int[257];\r\n    List<TransliterationRule> v = new ArrayList<TransliterationRule>(2 * n);\r\n    int[] indexValue = new int[n];\r\n    for (int j = 0; j < n; ++j) {\r\n        TransliterationRule r = ruleVector.get(j);\r\n        indexValue[j] = r.getIndexValue();\r\n    }\r\n    for (int x = 0; x < 256; ++x) {\r\n        index[x] = v.size();\r\n        for (int j = 0; j < n; ++j) {\r\n            if (indexValue[j] >= 0) {\r\n                if (indexValue[j] == x) {\r\n                    v.add(ruleVector.get(j));\r\n                }\r\n            } else {\r\n                TransliterationRule r = ruleVector.get(j);\r\n                if (r.matchesIndexValue(x)) {\r\n                    v.add(r);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    index[256] = v.size();\r\n    rules = new TransliterationRule[v.size()];\r\n    v.toArray(rules);\r\n    StringBuilder errors = null;\r\n    for (int x = 0; x < 256; ++x) {\r\n        for (int j = index[x]; j < index[x + 1] - 1; ++j) {\r\n            TransliterationRule r1 = rules[j];\r\n            for (int k = j + 1; k < index[x + 1]; ++k) {\r\n                TransliterationRule r2 = rules[k];\r\n                if (r1.masks(r2)) {\r\n                    if (errors == null) {\r\n                        errors = new StringBuilder();\r\n                    } else {\r\n                        errors.append(\"\\n\");\r\n                    }\r\n                    errors.append(\"Rule \" + r1 + \" masks \" + r2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (errors != null) {\r\n        throw new IllegalArgumentException(errors.toString());\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.Bidi.getBaseDirection",
	"Comment": "get the base direction of the text provided according to the unicodebidirectional algorithm. the base direction is derived from the firstcharacter in the string with bidirectional character type l, r, or al.if the first such character has type l, ltr is returned. if the firstsuch character has type r or al, rtl is returned. if the string doesnot contain any character of these types, then neutral is returned.this is a lightweight function for use when only the base direction isneeded and no further bidi processing of the text is needed.",
	"Method": "byte getBaseDirection(CharSequence paragraph){\r\n    if (paragraph == null || paragraph.length() == 0) {\r\n        return NEUTRAL;\r\n    }\r\n    int length = paragraph.length();\r\n    int c;\r\n    byte direction;\r\n    for (int i = 0; i < length; ) {\r\n        c = UCharacter.codePointAt(paragraph, i);\r\n        direction = UCharacter.getDirectionality(c);\r\n        if (direction == UCharacterDirection.LEFT_TO_RIGHT) {\r\n            return LTR;\r\n        } else if (direction == UCharacterDirection.RIGHT_TO_LEFT || direction == UCharacterDirection.RIGHT_TO_LEFT_ARABIC) {\r\n            return RTL;\r\n        }\r\n        i = UCharacter.offsetByCodePoints(paragraph, i, 1);\r\n    }\r\n    return NEUTRAL;\r\n}"
}, {
	"Path": "javax.security.cert.Certificate.hashCode",
	"Comment": "returns an integer hash code for the receiver. any two objects whichreturn true when passed to equals must answerthe same value for this method.",
	"Method": "int hashCode(){\r\n    int res = 0;\r\n    try {\r\n        byte[] array = getEncoded();\r\n        for (int i = 0; i < array.length; i++) {\r\n            res += array[i];\r\n        }\r\n    } catch (CertificateEncodingException e) {\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.setMinimumFractionDigits",
	"Comment": "sets the minimum number of digits allowed in the fraction portion of a number. thisoverride limits the fraction digit count to 340.",
	"Method": "void setMinimumFractionDigits(int newValue){\r\n    super.setMinimumFractionDigits(Math.min(newValue, DOUBLE_FRACTION_DIGITS));\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.isPrimitiveType",
	"Comment": "return true if the type codetypecode describes a primitive type",
	"Method": "boolean isPrimitiveType(char typecode){\r\n    return !(typecode == '[' || typecode == 'L');\r\n}"
}, {
	"Path": "android.icu.text.Transliterator.registerFactory",
	"Comment": "register a factory object with the given id.the factorymethod should return a new instance of the given transliterator.because icu may choose to cache transliterator objects internally, this mustbe called at application startup, prior to any calls totransliterator.getinstance to avoid undefined behavior.",
	"Method": "void registerFactory(String ID,Factory factory){\r\n    registry.put(ID, factory, true);\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.setMinusSign",
	"Comment": "sets the character used to represent minus sign. if no explicitnegative format is specified, one is formed by prefixingminussign to the positive format.",
	"Method": "void setMinusSign(char minusSign){\r\n    this.minusSign = minusSign;\r\n    this.minusString = String.valueOf(minusSign);\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.allowNumericFallback",
	"Comment": "return true if the pattern specified by patterncharindex is one that allowsnumeric fallback regardless of actual pattern size.",
	"Method": "boolean allowNumericFallback(int patternCharIndex){\r\n    if (patternCharIndex == 26 || patternCharIndex == 19 || patternCharIndex == 25 || patternCharIndex == 30 || patternCharIndex == 27 || patternCharIndex == 28) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "android.icu.util.Currency.registerInstance",
	"Comment": "registers a new currency for the provided locale.the returned objectis a key that can be used to unregister this currency object.because icu may choose to cache currency objects internally, this mustbe called at application startup, prior to any calls tocurrency.getinstance to avoid undefined behavior.",
	"Method": "Object registerInstance(Currency c,ULocale l,Object registerInstance,Currency currency,ULocale locale){\r\n    return getShim().registerInstance(currency, locale);\r\n}"
}, {
	"Path": "android.icu.impl.duration.BasicPeriodFormatterService.getInstance",
	"Comment": "return the default service instance. this uses the default data service.",
	"Method": "BasicPeriodFormatterService getInstance(){\r\n    if (instance == null) {\r\n        PeriodFormatterDataService ds = ResourceBasedPeriodFormatterDataService.getInstance();\r\n        instance = new BasicPeriodFormatterService(ds);\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationThaiTest.TestDictionary",
	"Comment": "read the external dictionary file, which is already in propersorted order, and confirm that the collator compares each line aspreceding the following line.",
	"Method": "void TestDictionary(){\r\n    RuleBasedCollator coll = null;\r\n    try {\r\n        coll = getThaiCollator();\r\n    } catch (Exception e) {\r\n        warnln(\"could not construct Thai collator\");\r\n        return;\r\n    }\r\n    int line = 0;\r\n    int failed = 0;\r\n    int wordCount = 0;\r\n    BufferedReader in = null;\r\n    try {\r\n        String fileName = \"riwords.txt\";\r\n        in = TestUtil.getDataReader(fileName, \"UTF-8\");\r\n        String lastWord = \"\";\r\n        String word = in.readLine();\r\n        while (word != null) {\r\n            line++;\r\n            if (word.length() == 0 || word.charAt(0) == 0x23) {\r\n                word = in.readLine();\r\n                continue;\r\n            }\r\n            ++wordCount;\r\n            if (wordCount <= 8) {\r\n                logln(\"Word \" + wordCount + \": \" + word);\r\n            }\r\n            if (lastWord.length() > 0) {\r\n                int result = coll.compare(lastWord, word);\r\n                if (result > 0) {\r\n                    failed++;\r\n                    if (MAX_FAILURES_TO_SHOW < 0 || failed <= MAX_FAILURES_TO_SHOW) {\r\n                        String msg = \"--------------------------------------------\\n\" + line + \" compare(\" + lastWord + \", \" + word + \") returned \" + result + \", expected -1\\n\";\r\n                        CollationKey k1, k2;\r\n                        k1 = coll.getCollationKey(lastWord);\r\n                        k2 = coll.getCollationKey(word);\r\n                        msg += \"key1: \" + CollationTest.prettify(k1) + \"\\n\" + \"key2: \" + CollationTest.prettify(k2);\r\n                        errln(msg);\r\n                    }\r\n                }\r\n            }\r\n            lastWord = word;\r\n            word = in.readLine();\r\n        }\r\n    } catch (IOException e) {\r\n        errln(\"IOException \" + e.getMessage());\r\n    } finally {\r\n        if (in == null) {\r\n            errln(\"Error: could not open test file. Aborting test.\");\r\n            return;\r\n        } else {\r\n            try {\r\n                in.close();\r\n            } catch (IOException ignored) {\r\n            }\r\n        }\r\n    }\r\n    if (failed != 0) {\r\n        if (failed > MAX_FAILURES_TO_SHOW) {\r\n            errln(\"Too many failures; only the first \" + MAX_FAILURES_TO_SHOW + \" failures were shown\");\r\n        }\r\n        errln(\"Summary: \" + failed + \" of \" + (line - 1) + \" comparisons failed\");\r\n    }\r\n    logln(\"Words checked: \" + wordCount);\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneNamesImpl.initialize",
	"Comment": "initialize the transient fields, called from the constructor andreadobject.",
	"Method": "void initialize(ULocale locale){\r\n    ICUResourceBundle bundle = (ICUResourceBundle) ICUResourceBundle.getBundleInstance(ICUData.ICU_ZONE_BASE_NAME, locale);\r\n    _zoneStrings = (ICUResourceBundle) bundle.get(ZONE_STRINGS_BUNDLE);\r\n    _tzNamesMap = new ConcurrentHashMap<String, ZNames>();\r\n    _mzNamesMap = new ConcurrentHashMap<String, ZNames>();\r\n    _namesFullyLoaded = false;\r\n    _namesTrie = new TextTrieMap<NameInfo>(true);\r\n    _namesTrieFullyLoaded = false;\r\n    TimeZone tz = TimeZone.getDefault();\r\n    String tzCanonicalID = ZoneMeta.getCanonicalCLDRID(tz);\r\n    if (tzCanonicalID != null) {\r\n        loadStrings(tzCanonicalID);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.Transliterator.getBasicInstance",
	"Comment": "create a transliterator from a basic id.this is an idcontaining only the forward direction source, target, andvariant.",
	"Method": "Transliterator getBasicInstance(String id,String canonID){\r\n    StringBuffer s = new StringBuffer();\r\n    Transliterator t = registry.get(id, s);\r\n    if (s.length() != 0) {\r\n        t = getInstance(s.toString(), FORWARD);\r\n    }\r\n    if (t != null && canonID != null) {\r\n        t.setID(canonID);\r\n    }\r\n    return t;\r\n}"
}, {
	"Path": "android.icu.impl.duration.BasicPeriodBuilderFactory.getSingleUnitBuilder",
	"Comment": "return a builder that represents relative time in terms of thelargest period less than or equal to the duration.",
	"Method": "PeriodBuilder getSingleUnitBuilder(){\r\n    return SingleUnitBuilder.get(getSettings());\r\n}"
}, {
	"Path": "android.icu.text.CurrencyPluralInfo.getCurrencyPluralPattern",
	"Comment": "given a plural count, gets currency plural pattern of this locale,used for currency plural format",
	"Method": "String getCurrencyPluralPattern(String pluralCount){\r\n    String currencyPluralPattern = pluralCountToCurrencyUnitPattern.get(pluralCount);\r\n    if (currencyPluralPattern == null) {\r\n        if (!pluralCount.equals(\"other\")) {\r\n            currencyPluralPattern = pluralCountToCurrencyUnitPattern.get(\"other\");\r\n        }\r\n        if (currencyPluralPattern == null) {\r\n            currencyPluralPattern = defaultCurrencyPluralPattern;\r\n        }\r\n    }\r\n    return currencyPluralPattern;\r\n}"
}, {
	"Path": "android.icu.text.MessageFormat.getLiteralStringUntilNextArgument",
	"Comment": "read as much literal string from the pattern string as possible. this stopsas soon as it finds an argument, or it reaches the end of the string.",
	"Method": "String getLiteralStringUntilNextArgument(int from){\r\n    StringBuilder b = new StringBuilder();\r\n    String msgString = msgPattern.getPatternString();\r\n    int prevIndex = msgPattern.getPart(from).getLimit();\r\n    for (int i = from + 1; ; ++i) {\r\n        Part part = msgPattern.getPart(i);\r\n        Part.Type type = part.getType();\r\n        int index = part.getIndex();\r\n        b.append(msgString, prevIndex, index);\r\n        if (type == Part.Type.ARG_START || type == Part.Type.MSG_LIMIT) {\r\n            return b.toString();\r\n        }\r\n        assert type == Part.Type.SKIP_SYNTAX || type == Part.Type.INSERT_CHAR : \"Unexpected Part \" + part + \" in parsed message.\";\r\n        prevIndex = part.getLimit();\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.SimpleDateRule.isBetween",
	"Comment": "check whether this event occurs at least once between the twodates given.",
	"Method": "boolean isBetween(Date start,Date end){\r\n    return firstBetween(start, end) != null;\r\n}"
}, {
	"Path": "android.icu.util.VTimeZone.writeFooter",
	"Comment": "write the closing section of the vtimezone definition block",
	"Method": "void writeFooter(Writer writer){\r\n    writer.write(ICAL_END);\r\n    writer.write(COLON);\r\n    writer.write(ICAL_VTIMEZONE);\r\n    writer.write(NEWLINE);\r\n}"
}, {
	"Path": "android.icu.text.NFRuleSet.parseRules",
	"Comment": "construct the subordinate data structures used by this object.this function is called by the rulebasednumberformat constructorafter all the rule sets have been created to actually parsethe description and build rules from it.since any rule setcan refer to any other rule set, we have to have created all ofthem before we can create anything else.",
	"Method": "void parseRules(String description){\r\n    List<NFRule> tempRules = new ArrayList<NFRule>();\r\n    NFRule predecessor = null;\r\n    int oldP = 0;\r\n    int descriptionLen = description.length();\r\n    int p;\r\n    do {\r\n        p = description.indexOf(';', oldP);\r\n        if (p < 0) {\r\n            p = descriptionLen;\r\n        }\r\n        NFRule.makeRules(description.substring(oldP, p), this, predecessor, owner, tempRules);\r\n        if (!tempRules.isEmpty()) {\r\n            predecessor = tempRules.get(tempRules.size() - 1);\r\n        }\r\n        oldP = p + 1;\r\n    } while (oldP < descriptionLen);\r\n    long defaultBaseValue = 0;\r\n    for (NFRule rule : tempRules) {\r\n        long baseValue = rule.getBaseValue();\r\n        if (baseValue == 0) {\r\n            rule.setBaseValue(defaultBaseValue);\r\n        } else {\r\n            if (baseValue < defaultBaseValue) {\r\n                throw new IllegalArgumentException(\"Rules are not in order, base: \" + baseValue + \" < \" + defaultBaseValue);\r\n            }\r\n            defaultBaseValue = baseValue;\r\n        }\r\n        if (!isFractionRuleSet) {\r\n            ++defaultBaseValue;\r\n        }\r\n    }\r\n    rules = new NFRule[tempRules.size()];\r\n    tempRules.toArray(rules);\r\n}"
}, {
	"Path": "android.icu.util.DateTimeRule.getRuleDayOfWeek",
	"Comment": "gets the rule day of week.when the date rule typeis dom, the value is always 0.",
	"Method": "int getRuleDayOfWeek(){\r\n    return dayOfWeek;\r\n}"
}, {
	"Path": "java.io.File.canRead",
	"Comment": "indicates whether the current context is allowed to read from this file.",
	"Method": "boolean canRead(){\r\n    return doAccess(R_OK);\r\n}"
}, {
	"Path": "android.icu.impl.OlsonTimeZone.zoneOffsetAt",
	"Comment": "following 3 methods return an offset at the given transition time index.when the index is negative, return the initial offset.",
	"Method": "int zoneOffsetAt(int transIdx){\r\n    int typeIdx = transIdx >= 0 ? getInt(typeMapData[transIdx]) * 2 : 0;\r\n    return typeOffsets[typeIdx] + typeOffsets[typeIdx + 1];\r\n}"
}, {
	"Path": "android.icu.impl.PluralRulesLoader.getAvailableULocales",
	"Comment": "returns the locales for which we have plurals data. utility for testing.",
	"Method": "ULocale[] getAvailableULocales(){\r\n    Set<String> keys = getLocaleIdToRulesIdMap(PluralType.CARDINAL).keySet();\r\n    ULocale[] locales = new ULocale[keys.size()];\r\n    int n = 0;\r\n    for (Iterator<String> iter = keys.iterator(); iter.hasNext(); ) {\r\n        locales[n++] = ULocale.createCanonical(iter.next());\r\n    }\r\n    return locales;\r\n}"
}, {
	"Path": "android.icu.text.NFRuleSet.setBestFractionRule",
	"Comment": "determine the best fraction rule to use. rules matching the decimal point fromdecimalformatsymbols become the main set of rules to use.",
	"Method": "void setBestFractionRule(int originalIndex,NFRule newRule,boolean rememberRule){\r\n    if (rememberRule) {\r\n        if (fractionRules == null) {\r\n            fractionRules = new LinkedList<NFRule>();\r\n        }\r\n        fractionRules.add(newRule);\r\n    }\r\n    NFRule bestResult = nonNumericalRules[originalIndex];\r\n    if (bestResult == null) {\r\n        nonNumericalRules[originalIndex] = newRule;\r\n    } else {\r\n        DecimalFormatSymbols decimalFormatSymbols = owner.getDecimalFormatSymbols();\r\n        if (decimalFormatSymbols.getDecimalSeparator() == newRule.getDecimalPoint()) {\r\n            nonNumericalRules[originalIndex] = newRule;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.applyLocalizedPattern",
	"Comment": "apply the given localized pattern string to this date format.",
	"Method": "void applyLocalizedPattern(String pat){\r\n    this.pattern = translatePattern(pat, formatData.localPatternChars, DateFormatSymbols.patternChars);\r\n    setLocale(null, null);\r\n}"
}, {
	"Path": "android.icu.text.PluralFormat.format",
	"Comment": "formats a plural message for a given number and appends the formattedmessage to the given stringbuffer.",
	"Method": "String format(double number,StringBuffer format,Object number,StringBuffer toAppendTo,FieldPosition pos,String format,Number numberObject,double number){\r\n    if (msgPattern == null || msgPattern.countParts() == 0) {\r\n        return numberFormat.format(numberObject);\r\n    }\r\n    double numberMinusOffset = number - offset;\r\n    String numberString;\r\n    if (offset == 0) {\r\n        numberString = numberFormat.format(numberObject);\r\n    } else {\r\n        numberString = numberFormat.format(numberMinusOffset);\r\n    }\r\n    FixedDecimal dec;\r\n    if (numberFormat instanceof DecimalFormat) {\r\n        dec = ((DecimalFormat) numberFormat).getFixedDecimal(numberMinusOffset);\r\n    } else {\r\n        dec = new FixedDecimal(numberMinusOffset);\r\n    }\r\n    int partIndex = findSubMessage(msgPattern, 0, pluralRulesWrapper, dec, number);\r\n    StringBuilder result = null;\r\n    int prevIndex = msgPattern.getPart(partIndex).getLimit();\r\n    for (; ; ) {\r\n        MessagePattern.Part part = msgPattern.getPart(++partIndex);\r\n        MessagePattern.Part.Type type = part.getType();\r\n        int index = part.getIndex();\r\n        if (type == MessagePattern.Part.Type.MSG_LIMIT) {\r\n            if (result == null) {\r\n                return pattern.substring(prevIndex, index);\r\n            } else {\r\n                return result.append(pattern, prevIndex, index).toString();\r\n            }\r\n        } else if (type == MessagePattern.Part.Type.REPLACE_NUMBER || (type == MessagePattern.Part.Type.SKIP_SYNTAX && msgPattern.jdkAposMode())) {\r\n            if (result == null) {\r\n                result = new StringBuilder();\r\n            }\r\n            result.append(pattern, prevIndex, index);\r\n            if (type == MessagePattern.Part.Type.REPLACE_NUMBER) {\r\n                result.append(numberString);\r\n            }\r\n            prevIndex = part.getLimit();\r\n        } else if (type == MessagePattern.Part.Type.ARG_START) {\r\n            if (result == null) {\r\n                result = new StringBuilder();\r\n            }\r\n            result.append(pattern, prevIndex, index);\r\n            prevIndex = index;\r\n            partIndex = msgPattern.getLimitPartIndex(partIndex);\r\n            index = msgPattern.getPart(partIndex).getLimit();\r\n            MessagePattern.appendReducedApostrophes(pattern, prevIndex, index, result);\r\n            prevIndex = index;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.MessagePattern.skipDouble",
	"Comment": "skips a sequence of characters that could occur in a double value.does not fully parse or validate the value.",
	"Method": "int skipDouble(int index){\r\n    while (index < msg.length()) {\r\n        char c = msg.charAt(index);\r\n        if ((c < '0' && \"+-.\".indexOf(c) < 0) || (c > '9' && c != 'e' && c != 'E' && c != 0x221e)) {\r\n            break;\r\n        }\r\n        ++index;\r\n    }\r\n    return index;\r\n}"
}, {
	"Path": "android.icu.impl.duration.Period.inFuture",
	"Comment": "mark the duration as extending into the future iffuture is true, and into the past otherwise.",
	"Method": "Period inFuture(Period inFuture,boolean future){\r\n    return setFuture(future);\r\n}"
}, {
	"Path": "android.icu.impl.duration.Period.getCount",
	"Comment": "returns the count for the specified unit.if theunit is not set, returns 0.",
	"Method": "float getCount(TimeUnit unit){\r\n    int ord = unit.ordinal;\r\n    if (counts[ord] == 0) {\r\n        return 0;\r\n    }\r\n    return (counts[ord] - 1) / 1000f;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.setSignificantDigit",
	"Comment": "sets the character used to represent a significant digit in a pattern.",
	"Method": "void setSignificantDigit(char sigDigit){\r\n    this.sigDigit = sigDigit;\r\n}"
}, {
	"Path": "android.icu.text.LocaleDisplayNames.scriptDisplayNameInContext",
	"Comment": "returns the display name of the provided script codewhen used in the context of a full locale name.",
	"Method": "String scriptDisplayNameInContext(String script){\r\n    return scriptDisplayName(script);\r\n}"
}, {
	"Path": "android.icu.util.PersianCalendar.isLeapYear",
	"Comment": "determine whether a year is a leap year in the persian calendar",
	"Method": "boolean isLeapYear(int year){\r\n    int[] remainder = new int[1];\r\n    floorDivide(25 * year + 11, 33, remainder);\r\n    return remainder[0] < 8;\r\n}"
}, {
	"Path": "android.icu.text.UnicodeCompressor.compress",
	"Comment": "compress a unicode character array into a byte array.this function will only consume input that can be completelyoutput.",
	"Method": "byte[] compress(String buffer,byte[] compress,char[] buffer,int start,int limit,int compress,char[] charBuffer,int charBufferStart,int charBufferLimit,int[] charsRead,byte[] byteBuffer,int byteBufferStart,int byteBufferLimit){\r\n    int bytePos = byteBufferStart;\r\n    int ucPos = charBufferStart;\r\n    int curUC = INVALIDCHAR;\r\n    int curIndex = -1;\r\n    int nextUC = INVALIDCHAR;\r\n    int forwardUC = INVALIDCHAR;\r\n    int whichWindow = 0;\r\n    int hiByte = 0;\r\n    int loByte = 0;\r\n    if (byteBuffer.length < 4 || (byteBufferLimit - byteBufferStart) < 4)\r\n        throw new IllegalArgumentException(\"byteBuffer.length < 4\");\r\n    mainLoop: while (ucPos < charBufferLimit && bytePos < byteBufferLimit) {\r\n        switch(fMode) {\r\n            case SINGLEBYTEMODE:\r\n                singleByteModeLoop: while (ucPos < charBufferLimit && bytePos < byteBufferLimit) {\r\n                    curUC = charBuffer[ucPos++];\r\n                    if (ucPos < charBufferLimit)\r\n                        nextUC = charBuffer[ucPos];\r\n                    else\r\n                        nextUC = INVALIDCHAR;\r\n                    if (curUC < 0x0080) {\r\n                        loByte = curUC & 0xFF;\r\n                        if (sSingleTagTable[loByte]) {\r\n                            if ((bytePos + 1) >= byteBufferLimit) {\r\n                                --ucPos;\r\n                                break mainLoop;\r\n                            }\r\n                            byteBuffer[bytePos++] = (byte) SQUOTE0;\r\n                        }\r\n                        byteBuffer[bytePos++] = (byte) loByte;\r\n                    } else if (inDynamicWindow(curUC, fCurrentWindow)) {\r\n                        byteBuffer[bytePos++] = (byte) (curUC - fOffsets[fCurrentWindow] + COMPRESSIONOFFSET);\r\n                    } else if (!isCompressible(curUC)) {\r\n                        if (nextUC != INVALIDCHAR && isCompressible(nextUC)) {\r\n                            if ((bytePos + 2) >= byteBufferLimit) {\r\n                                --ucPos;\r\n                                break mainLoop;\r\n                            }\r\n                            byteBuffer[bytePos++] = (byte) SQUOTEU;\r\n                            byteBuffer[bytePos++] = (byte) (curUC >>> 8);\r\n                            byteBuffer[bytePos++] = (byte) (curUC & 0xFF);\r\n                        } else {\r\n                            if ((bytePos + 3) >= byteBufferLimit) {\r\n                                --ucPos;\r\n                                break mainLoop;\r\n                            }\r\n                            byteBuffer[bytePos++] = (byte) SCHANGEU;\r\n                            hiByte = curUC >>> 8;\r\n                            loByte = curUC & 0xFF;\r\n                            if (sUnicodeTagTable[hiByte])\r\n                                byteBuffer[bytePos++] = (byte) UQUOTEU;\r\n                            byteBuffer[bytePos++] = (byte) hiByte;\r\n                            byteBuffer[bytePos++] = (byte) loByte;\r\n                            fMode = UNICODEMODE;\r\n                            break singleByteModeLoop;\r\n                        }\r\n                    } else if ((whichWindow = findDynamicWindow(curUC)) != INVALIDWINDOW) {\r\n                        if ((ucPos + 1) < charBufferLimit)\r\n                            forwardUC = charBuffer[ucPos + 1];\r\n                        else\r\n                            forwardUC = INVALIDCHAR;\r\n                        if (inDynamicWindow(nextUC, whichWindow) && inDynamicWindow(forwardUC, whichWindow)) {\r\n                            if ((bytePos + 1) >= byteBufferLimit) {\r\n                                --ucPos;\r\n                                break mainLoop;\r\n                            }\r\n                            byteBuffer[bytePos++] = (byte) (SCHANGE0 + whichWindow);\r\n                            byteBuffer[bytePos++] = (byte) (curUC - fOffsets[whichWindow] + COMPRESSIONOFFSET);\r\n                            fTimeStamps[whichWindow] = ++fTimeStamp;\r\n                            fCurrentWindow = whichWindow;\r\n                        } else {\r\n                            if ((bytePos + 1) >= byteBufferLimit) {\r\n                                --ucPos;\r\n                                break mainLoop;\r\n                            }\r\n                            byteBuffer[bytePos++] = (byte) (SQUOTE0 + whichWindow);\r\n                            byteBuffer[bytePos++] = (byte) (curUC - fOffsets[whichWindow] + COMPRESSIONOFFSET);\r\n                        }\r\n                    } else if ((whichWindow = findStaticWindow(curUC)) != INVALIDWINDOW && !inStaticWindow(nextUC, whichWindow)) {\r\n                        if ((bytePos + 1) >= byteBufferLimit) {\r\n                            --ucPos;\r\n                            break mainLoop;\r\n                        }\r\n                        byteBuffer[bytePos++] = (byte) (SQUOTE0 + whichWindow);\r\n                        byteBuffer[bytePos++] = (byte) (curUC - sOffsets[whichWindow]);\r\n                    } else {\r\n                        curIndex = makeIndex(curUC);\r\n                        fIndexCount[curIndex]++;\r\n                        if ((ucPos + 1) < charBufferLimit)\r\n                            forwardUC = charBuffer[ucPos + 1];\r\n                        else\r\n                            forwardUC = INVALIDCHAR;\r\n                        if ((fIndexCount[curIndex] > 1) || (curIndex == makeIndex(nextUC) && curIndex == makeIndex(forwardUC))) {\r\n                            if ((bytePos + 2) >= byteBufferLimit) {\r\n                                --ucPos;\r\n                                break mainLoop;\r\n                            }\r\n                            whichWindow = getLRDefinedWindow();\r\n                            byteBuffer[bytePos++] = (byte) (SDEFINE0 + whichWindow);\r\n                            byteBuffer[bytePos++] = (byte) curIndex;\r\n                            byteBuffer[bytePos++] = (byte) (curUC - sOffsetTable[curIndex] + COMPRESSIONOFFSET);\r\n                            fOffsets[whichWindow] = sOffsetTable[curIndex];\r\n                            fCurrentWindow = whichWindow;\r\n                            fTimeStamps[whichWindow] = ++fTimeStamp;\r\n                        } else {\r\n                            if ((bytePos + 3) >= byteBufferLimit) {\r\n                                --ucPos;\r\n                                break mainLoop;\r\n                            }\r\n                            byteBuffer[bytePos++] = (byte) SCHANGEU;\r\n                            hiByte = curUC >>> 8;\r\n                            loByte = curUC & 0xFF;\r\n                            if (sUnicodeTagTable[hiByte])\r\n                                byteBuffer[bytePos++] = (byte) UQUOTEU;\r\n                            byteBuffer[bytePos++] = (byte) hiByte;\r\n                            byteBuffer[bytePos++] = (byte) loByte;\r\n                            fMode = UNICODEMODE;\r\n                            break singleByteModeLoop;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case UNICODEMODE:\r\n                unicodeModeLoop: while (ucPos < charBufferLimit && bytePos < byteBufferLimit) {\r\n                    curUC = charBuffer[ucPos++];\r\n                    if (ucPos < charBufferLimit)\r\n                        nextUC = charBuffer[ucPos];\r\n                    else\r\n                        nextUC = INVALIDCHAR;\r\n                    if (!isCompressible(curUC) || (nextUC != INVALIDCHAR && !isCompressible(nextUC))) {\r\n                        if ((bytePos + 2) >= byteBufferLimit) {\r\n                            --ucPos;\r\n                            break mainLoop;\r\n                        }\r\n                        hiByte = curUC >>> 8;\r\n                        loByte = curUC & 0xFF;\r\n                        if (sUnicodeTagTable[hiByte])\r\n                            byteBuffer[bytePos++] = (byte) UQUOTEU;\r\n                        byteBuffer[bytePos++] = (byte) hiByte;\r\n                        byteBuffer[bytePos++] = (byte) loByte;\r\n                    } else if (curUC < 0x0080) {\r\n                        loByte = curUC & 0xFF;\r\n                        if (nextUC != INVALIDCHAR && nextUC < 0x0080 && !sSingleTagTable[loByte]) {\r\n                            if ((bytePos + 1) >= byteBufferLimit) {\r\n                                --ucPos;\r\n                                break mainLoop;\r\n                            }\r\n                            whichWindow = fCurrentWindow;\r\n                            byteBuffer[bytePos++] = (byte) (UCHANGE0 + whichWindow);\r\n                            byteBuffer[bytePos++] = (byte) loByte;\r\n                            fTimeStamps[whichWindow] = ++fTimeStamp;\r\n                            fMode = SINGLEBYTEMODE;\r\n                            break unicodeModeLoop;\r\n                        } else {\r\n                            if ((bytePos + 1) >= byteBufferLimit) {\r\n                                --ucPos;\r\n                                break mainLoop;\r\n                            }\r\n                            byteBuffer[bytePos++] = (byte) 0x00;\r\n                            byteBuffer[bytePos++] = (byte) loByte;\r\n                        }\r\n                    } else if ((whichWindow = findDynamicWindow(curUC)) != INVALIDWINDOW) {\r\n                        if (inDynamicWindow(nextUC, whichWindow)) {\r\n                            if ((bytePos + 1) >= byteBufferLimit) {\r\n                                --ucPos;\r\n                                break mainLoop;\r\n                            }\r\n                            byteBuffer[bytePos++] = (byte) (UCHANGE0 + whichWindow);\r\n                            byteBuffer[bytePos++] = (byte) (curUC - fOffsets[whichWindow] + COMPRESSIONOFFSET);\r\n                            fTimeStamps[whichWindow] = ++fTimeStamp;\r\n                            fCurrentWindow = whichWindow;\r\n                            fMode = SINGLEBYTEMODE;\r\n                            break unicodeModeLoop;\r\n                        } else {\r\n                            if ((bytePos + 2) >= byteBufferLimit) {\r\n                                --ucPos;\r\n                                break mainLoop;\r\n                            }\r\n                            hiByte = curUC >>> 8;\r\n                            loByte = curUC & 0xFF;\r\n                            if (sUnicodeTagTable[hiByte])\r\n                                byteBuffer[bytePos++] = (byte) UQUOTEU;\r\n                            byteBuffer[bytePos++] = (byte) hiByte;\r\n                            byteBuffer[bytePos++] = (byte) loByte;\r\n                        }\r\n                    } else {\r\n                        curIndex = makeIndex(curUC);\r\n                        fIndexCount[curIndex]++;\r\n                        if ((ucPos + 1) < charBufferLimit)\r\n                            forwardUC = charBuffer[ucPos + 1];\r\n                        else\r\n                            forwardUC = INVALIDCHAR;\r\n                        if ((fIndexCount[curIndex] > 1) || (curIndex == makeIndex(nextUC) && curIndex == makeIndex(forwardUC))) {\r\n                            if ((bytePos + 2) >= byteBufferLimit) {\r\n                                --ucPos;\r\n                                break mainLoop;\r\n                            }\r\n                            whichWindow = getLRDefinedWindow();\r\n                            byteBuffer[bytePos++] = (byte) (UDEFINE0 + whichWindow);\r\n                            byteBuffer[bytePos++] = (byte) curIndex;\r\n                            byteBuffer[bytePos++] = (byte) (curUC - sOffsetTable[curIndex] + COMPRESSIONOFFSET);\r\n                            fOffsets[whichWindow] = sOffsetTable[curIndex];\r\n                            fCurrentWindow = whichWindow;\r\n                            fTimeStamps[whichWindow] = ++fTimeStamp;\r\n                            fMode = SINGLEBYTEMODE;\r\n                            break unicodeModeLoop;\r\n                        } else {\r\n                            if ((bytePos + 2) >= byteBufferLimit) {\r\n                                --ucPos;\r\n                                break mainLoop;\r\n                            }\r\n                            hiByte = curUC >>> 8;\r\n                            loByte = curUC & 0xFF;\r\n                            if (sUnicodeTagTable[hiByte])\r\n                                byteBuffer[bytePos++] = (byte) UQUOTEU;\r\n                            byteBuffer[bytePos++] = (byte) hiByte;\r\n                            byteBuffer[bytePos++] = (byte) loByte;\r\n                        }\r\n                    }\r\n                }\r\n        }\r\n    }\r\n    if (charsRead != null)\r\n        charsRead[0] = (ucPos - charBufferStart);\r\n    return (bytePos - byteBufferStart);\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.CompatibilityTest.TestEpochStartFields",
	"Comment": "note that we adjust for the default timezone to get most things to zero.",
	"Method": "void TestEpochStartFields(){\r\n    TimeZone z = TimeZone.getDefault();\r\n    Calendar c = Calendar.getInstance();\r\n    Date d = new Date(-z.getRawOffset());\r\n    if (z.inDaylightTime(d)) {\r\n        logln(\"Warning: Skipping test because \" + d + \" is in DST.\");\r\n    } else {\r\n        c.setTime(d);\r\n        c.setMinimalDaysInFirstWeek(1);\r\n        for (int i = 0; i < Calendar.ZONE_OFFSET; ++i) {\r\n            if (c.get(i) != EPOCH_FIELDS[i])\r\n                errln(\"Expected field \" + i + \" to have value \" + EPOCH_FIELDS[i] + \"; saw \" + c.get(i) + \" instead\");\r\n        }\r\n        if (c.get(Calendar.ZONE_OFFSET) != z.getRawOffset())\r\n            errln(\"Expected field ZONE_OFFSET to have value \" + z.getRawOffset() + \"; saw \" + c.get(Calendar.ZONE_OFFSET) + \" instead\");\r\n        if (c.get(Calendar.DST_OFFSET) != 0)\r\n            errln(\"Expected field DST_OFFSET to have value 0\" + \"; saw \" + c.get(Calendar.DST_OFFSET) + \" instead\");\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.CurrencyPluralInfo.setPluralRules",
	"Comment": "set plural rules.these are initially set in the constructor based on the locale, and usually do not need to be changed.",
	"Method": "void setPluralRules(String ruleDescription){\r\n    pluralRules = PluralRules.createRules(ruleDescription);\r\n}"
}, {
	"Path": "android.icu.impl.ICUResourceBundleReader.RES_GET_INT",
	"Comment": "get signed and unsigned integer values directly from the resource handle",
	"Method": "int RES_GET_INT(int res){\r\n    return (res << 4) >> 4;\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.formatToCharacterIterator",
	"Comment": "format the object to an attributed string, and return the corresponding iteratoroverrides superclass method.",
	"Method": "AttributedCharacterIterator formatToCharacterIterator(Object obj){\r\n    Calendar cal = calendar;\r\n    if (obj instanceof Calendar) {\r\n        cal = (Calendar) obj;\r\n    } else if (obj instanceof Date) {\r\n        calendar.setTime((Date) obj);\r\n    } else if (obj instanceof Number) {\r\n        calendar.setTimeInMillis(((Number) obj).longValue());\r\n    } else {\r\n        throw new IllegalArgumentException(\"Cannot format given Object as a Date\");\r\n    }\r\n    StringBuffer toAppendTo = new StringBuffer();\r\n    FieldPosition pos = new FieldPosition(0);\r\n    List<FieldPosition> attributes = new ArrayList<FieldPosition>();\r\n    format(cal, getContext(DisplayContext.Type.CAPITALIZATION), toAppendTo, pos, attributes);\r\n    AttributedString as = new AttributedString(toAppendTo.toString());\r\n    for (int i = 0; i < attributes.size(); i++) {\r\n        FieldPosition fp = attributes.get(i);\r\n        Format.Field attribute = fp.getFieldAttribute();\r\n        as.addAttribute(attribute, attribute, fp.getBeginIndex(), fp.getEndIndex());\r\n    }\r\n    return as.getIterator();\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.IBMCalendarTest.TestTaiwan",
	"Comment": "verify that taiwancalendar shifts years to minguo era but otherwisebehaves like gregoriancalendar.",
	"Method": "void TestTaiwan(){\r\n    quasiGregorianTest(new TaiwanCalendar(), new int[] { TaiwanCalendar.BEFORE_MINGUO, 8, 1904, Calendar.FEBRUARY, 29, TaiwanCalendar.MINGUO, 1, 1912, Calendar.JUNE, 4, TaiwanCalendar.MINGUO, 3, 1914, Calendar.FEBRUARY, 12, TaiwanCalendar.MINGUO, 96, 2007, Calendar.FEBRUARY, 12 });\r\n}"
}, {
	"Path": "android.icu.impl.duration.BasicDurationFormatterFactory.setPeriodFormatter",
	"Comment": "set the period formatter used by the factory.new formatters createdwith this factory will use the given period formatter.",
	"Method": "DurationFormatterFactory setPeriodFormatter(PeriodFormatter formatter){\r\n    if (formatter != this.formatter) {\r\n        this.formatter = formatter;\r\n        reset();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.text.NumberFormat.getRoundingMode",
	"Comment": "returns the rounding mode used in this numberformat.the default implementation oftis method in numberformat always throws unsupportedoperationexception.",
	"Method": "int getRoundingMode(){\r\n    throw new UnsupportedOperationException(\"getRoundingMode must be implemented by the subclass implementation.\");\r\n}"
}, {
	"Path": "android.icu.text.CompoundTransliterator.computeMaximumContextLength",
	"Comment": "compute and set the length of the longest context required by this transliterator.this is preceding context.",
	"Method": "void computeMaximumContextLength(){\r\n    int max = 0;\r\n    for (int i = 0; i < trans.length; ++i) {\r\n        int len = trans[i].getMaximumContextLength();\r\n        if (len > max) {\r\n            max = len;\r\n        }\r\n    }\r\n    setMaximumContextLength(max);\r\n}"
}, {
	"Path": "android.icu.impl.ICUNotifier.addListener",
	"Comment": "add a listener to be notified when notifychanged is called.the listener must not be null. acceptslistener must returntrue for the listener.attempts to concurrentlyregister the identical listener more than once will besilently ignored.",
	"Method": "void addListener(EventListener l){\r\n    if (l == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (acceptsListener(l)) {\r\n        synchronized (notifyLock) {\r\n            if (listeners == null) {\r\n                listeners = new ArrayList<EventListener>();\r\n            } else {\r\n                for (EventListener ll : listeners) {\r\n                    if (ll == l) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            listeners.add(l);\r\n        }\r\n    } else {\r\n        throw new IllegalStateException(\"Listener invalid for this notifier.\");\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.data.ResourceReader.readLine",
	"Comment": "read and return the next line of the file or nullif the end of the file has been reached.",
	"Method": "String readLine(){\r\n    if (lineNo == 0) {\r\n        ++lineNo;\r\n        String line = reader.readLine();\r\n        if (line != null && (line.charAt(0) == '?' || line.charAt(0) == '?')) {\r\n            line = line.substring(1);\r\n        }\r\n        return line;\r\n    }\r\n    ++lineNo;\r\n    return reader.readLine();\r\n}"
}, {
	"Path": "android.icu.text.CollationElementIterator.primaryOrder",
	"Comment": "return the primary order of the specified collation element,i.e. the first 16 bits.this value is unsigned.",
	"Method": "int primaryOrder(int ce){\r\n    return (ce >>> 16) & 0xffff;\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.registerObject",
	"Comment": "register an object with the provided id.the id will becanonicalized.the canonicalized id will be returned bygetvisibleids if visible is true.",
	"Method": "Factory registerObject(Object obj,String id,Factory registerObject,Object obj,String id,boolean visible){\r\n    String canonicalID = createKey(id).canonicalID();\r\n    return registerFactory(new SimpleFactory(obj, canonicalID, visible));\r\n}"
}, {
	"Path": "android.icu.text.TimeZoneFormat.parse",
	"Comment": "returns a timezone by parsing the time zone string according tothe parse position, the style and the parse options.",
	"Method": "TimeZone parse(Style style,String text,ParsePosition pos,EnumSet<ParseOption> options,Output<TimeType> timeType,TimeZone parse,Style style,String text,ParsePosition pos,Output<TimeType> timeType,TimeZone parse,String text,ParsePosition pos,TimeZone parse,String text){\r\n    ParsePosition pos = new ParsePosition(0);\r\n    TimeZone tz = parse(text, pos);\r\n    if (pos.getErrorIndex() >= 0) {\r\n        throw new ParseException(\"Unparseable time zone: \\\"\" + text + \"\\\"\", 0);\r\n    }\r\n    assert (tz != null);\r\n    return tz;\r\n}"
}, {
	"Path": "android.icu.util.Calendar.internalGet",
	"Comment": "returns the value for a given time field, or return the given defaultvalue if the field is not set.this is an internal method forsubclasses that does not trigger any calculations.",
	"Method": "int internalGet(int field,int internalGet,int field,int defaultValue){\r\n    return (stamp[field] > UNSET) ? fields[field] : defaultValue;\r\n}"
}, {
	"Path": "java.io.RandomAccessFile.readBoolean",
	"Comment": "reads a boolean from the current position in this file. blocks until onebyte has been read, the end of the file is reached or an exception isthrown.",
	"Method": "boolean readBoolean(){\r\n    int temp = this.read();\r\n    if (temp < 0) {\r\n        throw new EOFException();\r\n    }\r\n    return temp != 0;\r\n}"
}, {
	"Path": "libcore.java.io.OldPushbackReaderTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this methodis called before a test is executed.",
	"Method": "void setUp(){\r\n    pbr = new PushbackReader(new StringReader(pbString), 10);\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.getInternationalCurrencySymbol",
	"Comment": "returns the international string denoting the local currency.",
	"Method": "String getInternationalCurrencySymbol(){\r\n    return intlCurrencySymbol;\r\n}"
}, {
	"Path": "android.icu.text.UTF16.append",
	"Comment": "adds a codepoint to offset16 position of the argument char array.",
	"Method": "StringBuffer append(StringBuffer target,int char32,int append,char[] target,int limit,int char32){\r\n    if (char32 < CODEPOINT_MIN_VALUE || char32 > CODEPOINT_MAX_VALUE) {\r\n        throw new IllegalArgumentException(\"Illegal codepoint\");\r\n    }\r\n    if (char32 >= SUPPLEMENTARY_MIN_VALUE) {\r\n        target[limit++] = getLeadSurrogate(char32);\r\n        target[limit++] = getTrailSurrogate(char32);\r\n    } else {\r\n        target[limit++] = (char) char32;\r\n    }\r\n    return limit;\r\n}"
}, {
	"Path": "android.icu.impl.coll.CollationData.getGroupForPrimary",
	"Comment": "finds the reordering group which contains the primary weight.",
	"Method": "int getGroupForPrimary(long p){\r\n    p >>= 16;\r\n    if (p < scriptStarts[1] || scriptStarts[scriptStarts.length - 1] <= p) {\r\n        return -1;\r\n    }\r\n    int index = 1;\r\n    while (p >= scriptStarts[index + 1]) {\r\n        ++index;\r\n    }\r\n    for (int i = 0; i < numScripts; ++i) {\r\n        if (scriptsIndex[i] == index) {\r\n            return i;\r\n        }\r\n    }\r\n    for (int i = 0; i < MAX_NUM_SPECIAL_REORDER_CODES; ++i) {\r\n        if (scriptsIndex[numScripts + i] == index) {\r\n            return Collator.ReorderCodes.FIRST + i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.CalendarRegressionTest.Test4177484",
	"Comment": "calendar does not update field values when settimezone is called.",
	"Method": "void Test4177484(){\r\n    TimeZone PST = TimeZone.getTimeZone(\"PST\");\r\n    TimeZone EST = TimeZone.getTimeZone(\"EST\");\r\n    Calendar cal = Calendar.getInstance(PST, Locale.US);\r\n    cal.clear();\r\n    cal.set(1999, 3, 21, 15, 5, 0);\r\n    int h1 = cal.get(Calendar.HOUR_OF_DAY);\r\n    cal.setTimeZone(EST);\r\n    int h2 = cal.get(Calendar.HOUR_OF_DAY);\r\n    if (h1 == h2) {\r\n        errln(\"FAIL: Fields not updated after setTimeZone\");\r\n    }\r\n    cal.clear();\r\n    cal.setTimeZone(PST);\r\n    cal.set(Calendar.HOUR_OF_DAY, 10);\r\n    Date pst10 = cal.getTime();\r\n    cal.setTimeZone(EST);\r\n    Date est10 = cal.getTime();\r\n    if (!pst10.equals(est10)) {\r\n        errln(\"FAIL: setTimeZone changed time\");\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.SimpleFormatterImpl.compileToStringMinMaxArguments",
	"Comment": "creates a compiled form of the pattern string, for use with appropriate static methods.the number of arguments checked against the given limits is thehighest argument number plus one, not the number of occurrences of arguments.",
	"Method": "String compileToStringMinMaxArguments(CharSequence pattern,StringBuilder sb,int min,int max){\r\n    if (min <= 2 && 2 <= max) {\r\n        for (String[] pair : COMMON_PATTERNS) {\r\n            if (pair[0].contentEquals(pattern)) {\r\n                assert pair[1].charAt(0) == 2;\r\n                return pair[1];\r\n            }\r\n        }\r\n    }\r\n    int patternLength = pattern.length();\r\n    sb.ensureCapacity(patternLength);\r\n    sb.setLength(1);\r\n    int textLength = 0;\r\n    int maxArg = -1;\r\n    boolean inQuote = false;\r\n    for (int i = 0; i < patternLength; ) {\r\n        char c = pattern.charAt(i++);\r\n        if (c == '\\'') {\r\n            if (i < patternLength && (c = pattern.charAt(i)) == '\\'') {\r\n                ++i;\r\n            } else if (inQuote) {\r\n                inQuote = false;\r\n                continue;\r\n            } else if (c == '{' || c == '}') {\r\n                ++i;\r\n                inQuote = true;\r\n            } else {\r\n                c = '\\'';\r\n            }\r\n        } else if (!inQuote && c == '{') {\r\n            if (textLength > 0) {\r\n                sb.setCharAt(sb.length() - textLength - 1, (char) (ARG_NUM_LIMIT + textLength));\r\n                textLength = 0;\r\n            }\r\n            int argNumber;\r\n            if ((i + 1) < patternLength && 0 <= (argNumber = pattern.charAt(i) - '0') && argNumber <= 9 && pattern.charAt(i + 1) == '}') {\r\n                i += 2;\r\n            } else {\r\n                int argStart = i - 1;\r\n                argNumber = -1;\r\n                if (i < patternLength && '1' <= (c = pattern.charAt(i++)) && c <= '9') {\r\n                    argNumber = c - '0';\r\n                    while (i < patternLength && '0' <= (c = pattern.charAt(i++)) && c <= '9') {\r\n                        argNumber = argNumber * 10 + (c - '0');\r\n                        if (argNumber >= ARG_NUM_LIMIT) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (argNumber < 0 || c != '}') {\r\n                    throw new IllegalArgumentException(\"Argument syntax error in pattern \\\"\" + pattern + \"\\\" at index \" + argStart + \": \" + pattern.subSequence(argStart, i));\r\n                }\r\n            }\r\n            if (argNumber > maxArg) {\r\n                maxArg = argNumber;\r\n            }\r\n            sb.append((char) argNumber);\r\n            continue;\r\n        }\r\n        if (textLength == 0) {\r\n            sb.append(SEGMENT_LENGTH_ARGUMENT_CHAR);\r\n        }\r\n        sb.append(c);\r\n        if (++textLength == MAX_SEGMENT_LENGTH) {\r\n            textLength = 0;\r\n        }\r\n    }\r\n    if (textLength > 0) {\r\n        sb.setCharAt(sb.length() - textLength - 1, (char) (ARG_NUM_LIMIT + textLength));\r\n    }\r\n    int argCount = maxArg + 1;\r\n    if (argCount < min) {\r\n        throw new IllegalArgumentException(\"Fewer than minimum \" + min + \" arguments in pattern \\\"\" + pattern + \"\\\"\");\r\n    }\r\n    if (argCount > max) {\r\n        throw new IllegalArgumentException(\"More than maximum \" + max + \" arguments in pattern \\\"\" + pattern + \"\\\"\");\r\n    }\r\n    sb.setCharAt(0, (char) argCount);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "android.icu.text.TransliteratorIDParser.instantiateList",
	"Comment": "returns the list of transliterator objects for thegiven list of singleid objects.",
	"Method": "List<Transliterator> instantiateList(List<SingleID> ids){\r\n    Transliterator t;\r\n    List<Transliterator> translits = new ArrayList<Transliterator>();\r\n    for (SingleID single : ids) {\r\n        if (single.basicID.length() == 0) {\r\n            continue;\r\n        }\r\n        t = single.getInstance();\r\n        if (t == null) {\r\n            throw new IllegalArgumentException(\"Illegal ID \" + single.canonID);\r\n        }\r\n        translits.add(t);\r\n    }\r\n    if (translits.size() == 0) {\r\n        t = Transliterator.getBasicInstance(\"Any-Null\", null);\r\n        if (t == null) {\r\n            throw new IllegalArgumentException(\"Internal error; cannot instantiate Any-Null\");\r\n        }\r\n        translits.add(t);\r\n    }\r\n    return translits;\r\n}"
}, {
	"Path": "android.icu.util.SimpleTimeZone.getDSTSavings",
	"Comment": "returns the amount of time in ms that the clock is advanced during dst.",
	"Method": "int getDSTSavings(){\r\n    return dst;\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationMiscTest.TestUnknownCollationKeyword",
	"Comment": "unknown collation type should be ignored, without printing stack trace",
	"Method": "void TestUnknownCollationKeyword(){\r\n    Collator coll1 = Collator.getInstance(new ULocale(\"en_US@collation=bogus\"));\r\n    Collator coll2 = Collator.getInstance(new ULocale(\"en_US\"));\r\n    assertEquals(\"Unknown collation keyword 'bogus' should be ignored\", coll1, coll2);\r\n}"
}, {
	"Path": "org.apache.harmony.xml.dom.InnerNodeImpl.normalize",
	"Comment": "normalize the text nodes within this subtree. although named similarly,this method is unrelated to document.normalize.",
	"Method": "void normalize(){\r\n    Node next;\r\n    for (Node node = getFirstChild(); node != null; node = next) {\r\n        next = node.getNextSibling();\r\n        node.normalize();\r\n        if (node.getNodeType() == Node.TEXT_NODE) {\r\n            ((TextImpl) node).minimize();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.UCharacterIterator.getCharacterIterator",
	"Comment": "returns a java.text.characteriterator object for the underlying text of this iterator. the returnediterator is independent of this iterator.",
	"Method": "CharacterIterator getCharacterIterator(){\r\n    return new UCharacterIteratorWrapper(this);\r\n}"
}, {
	"Path": "android.icu.text.MessagePatternUtil.buildMessageNode",
	"Comment": "factory method, builds and returns a messagenode from a messagepattern.",
	"Method": "MessageNode buildMessageNode(String patternString,MessageNode buildMessageNode,MessagePattern pattern,MessageNode buildMessageNode,MessagePattern pattern,int start,int limit){\r\n    int prevPatternIndex = pattern.getPart(start).getLimit();\r\n    MessageNode node = new MessageNode();\r\n    for (int i = start + 1; ; ++i) {\r\n        MessagePattern.Part part = pattern.getPart(i);\r\n        int patternIndex = part.getIndex();\r\n        if (prevPatternIndex < patternIndex) {\r\n            node.addContentsNode(new TextNode(pattern.getPatternString().substring(prevPatternIndex, patternIndex)));\r\n        }\r\n        if (i == limit) {\r\n            break;\r\n        }\r\n        MessagePattern.Part.Type partType = part.getType();\r\n        if (partType == MessagePattern.Part.Type.ARG_START) {\r\n            int argLimit = pattern.getLimitPartIndex(i);\r\n            node.addContentsNode(buildArgNode(pattern, i, argLimit));\r\n            i = argLimit;\r\n            part = pattern.getPart(i);\r\n        } else if (partType == MessagePattern.Part.Type.REPLACE_NUMBER) {\r\n            node.addContentsNode(MessageContentsNode.createReplaceNumberNode());\r\n        }\r\n        prevPatternIndex = part.getLimit();\r\n    }\r\n    return node.freeze();\r\n}"
}, {
	"Path": "android.icu.impl.Punycode.decode",
	"Comment": "converts punycode to unicode.the unicode string will be at most as long as the punycode string.",
	"Method": "StringBuilder decode(CharSequence src,boolean[] caseFlags){\r\n    int srcLength = src.length();\r\n    StringBuilder dest = new StringBuilder(src.length());\r\n    int n, i, bias, basicLength, j, in, oldi, w, k, digit, t, destCPCount, firstSupplementaryIndex, cpLength;\r\n    char b;\r\n    for (j = srcLength; j > 0; ) {\r\n        if (src.charAt(--j) == DELIMITER) {\r\n            break;\r\n        }\r\n    }\r\n    basicLength = destCPCount = j;\r\n    for (j = 0; j < basicLength; ++j) {\r\n        b = src.charAt(j);\r\n        if (!isBasic(b)) {\r\n            throw new StringPrepParseException(\"Illegal char found\", StringPrepParseException.INVALID_CHAR_FOUND);\r\n        }\r\n        dest.append(b);\r\n        if (caseFlags != null && j < caseFlags.length) {\r\n            caseFlags[j] = isBasicUpperCase(b);\r\n        }\r\n    }\r\n    n = INITIAL_N;\r\n    i = 0;\r\n    bias = INITIAL_BIAS;\r\n    firstSupplementaryIndex = 1000000000;\r\n    for (in = basicLength > 0 ? basicLength + 1 : 0; in < srcLength; ) {\r\n        for (oldi = i, w = 1, k = BASE; ; k += BASE) {\r\n            if (in >= srcLength) {\r\n                throw new StringPrepParseException(\"Illegal char found\", StringPrepParseException.ILLEGAL_CHAR_FOUND);\r\n            }\r\n            digit = basicToDigit[src.charAt(in++) & 0xFF];\r\n            if (digit < 0) {\r\n                throw new StringPrepParseException(\"Invalid char found\", StringPrepParseException.INVALID_CHAR_FOUND);\r\n            }\r\n            if (digit > (0x7fffffff - i) / w) {\r\n                throw new StringPrepParseException(\"Illegal char found\", StringPrepParseException.ILLEGAL_CHAR_FOUND);\r\n            }\r\n            i += digit * w;\r\n            t = k - bias;\r\n            if (t < TMIN) {\r\n                t = TMIN;\r\n            } else if (k >= (bias + TMAX)) {\r\n                t = TMAX;\r\n            }\r\n            if (digit < t) {\r\n                break;\r\n            }\r\n            if (w > 0x7fffffff / (BASE - t)) {\r\n                throw new StringPrepParseException(\"Illegal char found\", StringPrepParseException.ILLEGAL_CHAR_FOUND);\r\n            }\r\n            w *= BASE - t;\r\n        }\r\n        ++destCPCount;\r\n        bias = adaptBias(i - oldi, destCPCount, (oldi == 0));\r\n        if (i / destCPCount > (0x7fffffff - n)) {\r\n            throw new StringPrepParseException(\"Illegal char found\", StringPrepParseException.ILLEGAL_CHAR_FOUND);\r\n        }\r\n        n += i / destCPCount;\r\n        i %= destCPCount;\r\n        if (n > 0x10ffff || isSurrogate(n)) {\r\n            throw new StringPrepParseException(\"Illegal char found\", StringPrepParseException.ILLEGAL_CHAR_FOUND);\r\n        }\r\n        cpLength = Character.charCount(n);\r\n        int codeUnitIndex;\r\n        if (i <= firstSupplementaryIndex) {\r\n            codeUnitIndex = i;\r\n            if (cpLength > 1) {\r\n                firstSupplementaryIndex = codeUnitIndex;\r\n            } else {\r\n                ++firstSupplementaryIndex;\r\n            }\r\n        } else {\r\n            codeUnitIndex = dest.offsetByCodePoints(firstSupplementaryIndex, i - firstSupplementaryIndex);\r\n        }\r\n        if (caseFlags != null && (dest.length() + cpLength) <= caseFlags.length) {\r\n            if (codeUnitIndex < dest.length()) {\r\n                System.arraycopy(caseFlags, codeUnitIndex, caseFlags, codeUnitIndex + cpLength, dest.length() - codeUnitIndex);\r\n            }\r\n            caseFlags[codeUnitIndex] = isBasicUpperCase(src.charAt(in - 1));\r\n            if (cpLength == 2) {\r\n                caseFlags[codeUnitIndex + 1] = false;\r\n            }\r\n        }\r\n        if (cpLength == 1) {\r\n            dest.insert(codeUnitIndex, (char) n);\r\n        } else {\r\n            dest.insert(codeUnitIndex, UTF16.getLeadSurrogate(n));\r\n            dest.insert(codeUnitIndex + 1, UTF16.getTrailSurrogate(n));\r\n        }\r\n        ++i;\r\n    }\r\n    return dest;\r\n}"
}, {
	"Path": "android.icu.text.Bidi.getCustomClassifier",
	"Comment": "gets the current custom class classifier used for bidi classdetermination.",
	"Method": "BidiClassifier getCustomClassifier(){\r\n    return this.customClassifier;\r\n}"
}, {
	"Path": "android.icu.impl.UCharacterName.initNameSetsLengths",
	"Comment": "sets up the name sets and the calculation of the maximum lengths.equivalent to calcnamesetslengths.",
	"Method": "boolean initNameSetsLengths(){\r\n    if (m_maxNameLength_ > 0) {\r\n        return true;\r\n    }\r\n    String extra = \"0123456789ABCDEF<>-\";\r\n    for (int i = extra.length() - 1; i >= 0; i--) {\r\n        add(m_nameSet_, extra.charAt(i));\r\n    }\r\n    m_maxNameLength_ = addAlgorithmName(0);\r\n    m_maxNameLength_ = addExtendedName(m_maxNameLength_);\r\n    addGroupName(m_maxNameLength_);\r\n    return true;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.getPerMill",
	"Comment": "returns the character used for mille percent sign. different for arabic, etc.",
	"Method": "char getPerMill(){\r\n    return perMill;\r\n}"
}, {
	"Path": "android.icu.util.Currency.getAllTenderCurrencies",
	"Comment": "returns an unmodifiable string list including all known tender currency codes.",
	"Method": "List<String> getAllTenderCurrencies(){\r\n    List<String> all = (ALL_TENDER_CODES == null) ? null : ALL_TENDER_CODES.get();\r\n    if (all == null) {\r\n        CurrencyFilter filter = CurrencyFilter.all();\r\n        all = Collections.unmodifiableList(getTenderCurrencies(filter));\r\n        ALL_TENDER_CODES = new SoftReference<List<String>>(all);\r\n    }\r\n    return all;\r\n}"
}, {
	"Path": "android.icu.impl.CharTrie.getLatin1LinearValue",
	"Comment": "gets the latin 1 fast path value.note this only works if latin 1 characters have their own lineararray.",
	"Method": "char getLatin1LinearValue(char ch){\r\n    return m_data_[INDEX_STAGE_3_MASK_ + 1 + m_dataOffset_ + ch];\r\n}"
}, {
	"Path": "android.icu.util.Calendar.toString",
	"Comment": "returns a string representation of this calendar. this methodis intended to be used only for debugging purposes, and theformat of the returned string may vary between implementations.the returned string may be empty but may not be null.",
	"Method": "String toString(String toString){\r\n    StringBuilder buffer = new StringBuilder();\r\n    buffer.append(getClass().getName());\r\n    buffer.append(\"[time=\");\r\n    buffer.append(isTimeSet ? String.valueOf(time) : \"?\");\r\n    buffer.append(\",areFieldsSet=\");\r\n    buffer.append(areFieldsSet);\r\n    buffer.append(\",areAllFieldsSet=\");\r\n    buffer.append(areAllFieldsSet);\r\n    buffer.append(\",lenient=\");\r\n    buffer.append(lenient);\r\n    buffer.append(\",zone=\");\r\n    buffer.append(zone);\r\n    buffer.append(\",firstDayOfWeek=\");\r\n    buffer.append(firstDayOfWeek);\r\n    buffer.append(\",minimalDaysInFirstWeek=\");\r\n    buffer.append(minimalDaysInFirstWeek);\r\n    buffer.append(\",repeatedWallTime=\");\r\n    buffer.append(repeatedWallTime);\r\n    buffer.append(\",skippedWallTime=\");\r\n    buffer.append(skippedWallTime);\r\n    for (int i = 0; i < fields.length; ++i) {\r\n        buffer.append(',').append(fieldName(i)).append('=');\r\n        buffer.append(isSet(i) ? String.valueOf(fields[i]) : \"?\");\r\n    }\r\n    buffer.append(']');\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "android.icu.text.StringMatcher.addMatchSetTo",
	"Comment": "implementation of unicodematcher api.union the set of allcharacters that may be matched by this object into the givenset.",
	"Method": "void addMatchSetTo(UnicodeSet toUnionTo){\r\n    int ch;\r\n    for (int i = 0; i < pattern.length(); i += UTF16.getCharCount(ch)) {\r\n        ch = UTF16.charAt(pattern, i);\r\n        UnicodeMatcher matcher = data.lookupMatcher(ch);\r\n        if (matcher == null) {\r\n            toUnionTo.add(ch);\r\n        } else {\r\n            matcher.addMatchSetTo(toUnionTo);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.matchesDigit",
	"Comment": "check if the substring at the specified position matches a decimal digit.if matched, this method sets the decimal value to decval andreturns matched length.",
	"Method": "int matchesDigit(String str,int start,int[] decVal){\r\n    String[] localeDigits = symbols.getDigitStringsLocal();\r\n    for (int i = 0; i < 10; i++) {\r\n        int digitStrLen = localeDigits[i].length();\r\n        if (str.regionMatches(start, localeDigits[i], 0, digitStrLen)) {\r\n            decVal[0] = i;\r\n            return digitStrLen;\r\n        }\r\n    }\r\n    int cp = str.codePointAt(start);\r\n    decVal[0] = UCharacter.digit(cp, 10);\r\n    if (decVal[0] >= 0) {\r\n        return Character.charCount(cp);\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.clearServiceCache",
	"Comment": "clears only the service cache.this can be called by subclasses when a change affects the servicecache but not the id caches, e.g., when the default locale changesthe resolution of ids changes, but not the visible ids themselves.",
	"Method": "void clearServiceCache(){\r\n    cache = null;\r\n}"
}, {
	"Path": "android.icu.text.SearchIterator.setIndex",
	"Comment": "sets the position in the target text at which the next search will start.this method clears any previous match.",
	"Method": "void setIndex(int position){\r\n    if (position < search_.beginIndex() || position > search_.endIndex()) {\r\n        throw new IndexOutOfBoundsException(\"setIndex(int) expected position to be between \" + search_.beginIndex() + \" and \" + search_.endIndex());\r\n    }\r\n    search_.reset_ = false;\r\n    search_.setMatchedLength(0);\r\n    search_.matchedIndex_ = DONE;\r\n}"
}, {
	"Path": "java.io.File.exists",
	"Comment": "returns a boolean indicating whether this file can be found on theunderlying file system.",
	"Method": "boolean exists(){\r\n    return doAccess(F_OK);\r\n}"
}, {
	"Path": "android.icu.text.UTF16.newString",
	"Comment": "cover jdk 1.5 api. create a string from an array of codepoints.",
	"Method": "String newString(int[] codePoints,int offset,int count){\r\n    if (count < 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    char[] chars = new char[count];\r\n    int w = 0;\r\n    for (int r = offset, e = offset + count; r < e; ++r) {\r\n        int cp = codePoints[r];\r\n        if (cp < 0 || cp > 0x10ffff) {\r\n            throw new IllegalArgumentException();\r\n        }\r\n        while (true) {\r\n            try {\r\n                if (cp < 0x010000) {\r\n                    chars[w] = (char) cp;\r\n                    w++;\r\n                } else {\r\n                    chars[w] = (char) (LEAD_SURROGATE_OFFSET_ + (cp >> LEAD_SURROGATE_SHIFT_));\r\n                    chars[w + 1] = (char) (TRAIL_SURROGATE_MIN_VALUE + (cp & TRAIL_SURROGATE_MASK_));\r\n                    w += 2;\r\n                }\r\n                break;\r\n            } catch (IndexOutOfBoundsException ex) {\r\n                int newlen = (int) (Math.ceil((double) codePoints.length * (w + 2) / (r - offset + 1)));\r\n                char[] temp = new char[newlen];\r\n                System.arraycopy(chars, 0, temp, 0, w);\r\n                chars = temp;\r\n            }\r\n        }\r\n    }\r\n    return new String(chars, 0, w);\r\n}"
}, {
	"Path": "android.icu.text.CompoundTransliterator.getTransliterator",
	"Comment": "returns the transliterator at the given index in this chain.",
	"Method": "Transliterator getTransliterator(int index){\r\n    return trans[index];\r\n}"
}, {
	"Path": "android.icu.text.Transliterator.setMaximumContextLength",
	"Comment": "method for subclasses to use to set the maximum context length.",
	"Method": "void setMaximumContextLength(int a){\r\n    if (a < 0) {\r\n        throw new IllegalArgumentException(\"Invalid context length \" + a);\r\n    }\r\n    maximumContextLength = a;\r\n}"
}, {
	"Path": "android.icu.text.PluralFormat.setNumberFormat",
	"Comment": "sets the number format used by this formatter.you only need tocall this if you want a different number format than the defaultformatter for the locale.",
	"Method": "void setNumberFormat(NumberFormat format){\r\n    numberFormat = format;\r\n}"
}, {
	"Path": "java.io.SerializationHandleMap.findIndex",
	"Comment": "returns the index where the key is found at, or the index of the nextempty spot if the key is not found in this table.",
	"Method": "int findIndex(Object key,Object[] array){\r\n    int length = array.length;\r\n    int index = getModuloHash(key, length);\r\n    int last = (index + length - 1) % length;\r\n    while (index != last) {\r\n        if (array[index] == key || array[index] == null) {\r\n            break;\r\n        }\r\n        index = (index + 1) % length;\r\n    }\r\n    return index;\r\n}"
}, {
	"Path": "android.icu.text.RBNFChinesePostProcessor.process",
	"Comment": "work routine.post process the output, which was generated by theruleset with the given name.",
	"Method": "void process(StringBuilder buf,NFRuleSet ruleSet){\r\n    String name = ruleSet.getName();\r\n    for (int i = 0; i < rulesetNames.length; ++i) {\r\n        if (rulesetNames[i].equals(name)) {\r\n            format = i;\r\n            longForm = i == 1 || i == 3;\r\n            break;\r\n        }\r\n    }\r\n    if (longForm) {\r\n        for (int i = buf.indexOf(\"*\"); i != -1; i = buf.indexOf(\"*\", i)) {\r\n            buf.delete(i, i + 1);\r\n        }\r\n        return;\r\n    }\r\n    final String DIAN = \"�c\";\r\n    final String[][] markers = { { \"�f\", \"�|\", \"��\", \"��\" }, { \"��\", \"��\", \"��\", \"��\" }, { \"�f\", \"�|\", \"��\", \"��\" } };\r\n    {\r\n        String[] m = markers[format];\r\n        for (int i = 0; i < m.length - 1; ++i) {\r\n            int n = buf.indexOf(m[i]);\r\n            if (n != -1) {\r\n                buf.insert(n + m[i].length(), '|');\r\n            }\r\n        }\r\n    }\r\n    int x = buf.indexOf(DIAN);\r\n    if (x == -1) {\r\n        x = buf.length();\r\n    }\r\n    int s = 0;\r\n    int n = -1;\r\n    String ling = markers[format][3];\r\n    while (x >= 0) {\r\n        int m = buf.lastIndexOf(\"|\", x);\r\n        int nn = buf.lastIndexOf(ling, x);\r\n        int ns = 0;\r\n        if (nn > m) {\r\n            ns = (nn > 0 && buf.charAt(nn - 1) != '*') ? 2 : 1;\r\n        }\r\n        x = m - 1;\r\n        switch(s * 3 + ns) {\r\n            case 0:\r\n                s = ns;\r\n                n = -1;\r\n                break;\r\n            case 1:\r\n                s = ns;\r\n                n = nn;\r\n                break;\r\n            case 2:\r\n                s = ns;\r\n                n = -1;\r\n                break;\r\n            case 3:\r\n                s = ns;\r\n                n = -1;\r\n                break;\r\n            case 4:\r\n                buf.delete(nn - 1, nn + ling.length());\r\n                s = 0;\r\n                n = -1;\r\n                break;\r\n            case 5:\r\n                buf.delete(n - 1, n + ling.length());\r\n                s = ns;\r\n                n = -1;\r\n                break;\r\n            case 6:\r\n                s = ns;\r\n                n = -1;\r\n                break;\r\n            case 7:\r\n                buf.delete(nn - 1, nn + ling.length());\r\n                s = 0;\r\n                n = -1;\r\n                break;\r\n            case 8:\r\n                s = ns;\r\n                n = -1;\r\n                break;\r\n            default:\r\n                throw new IllegalStateException();\r\n        }\r\n    }\r\n    for (int i = buf.length(); --i >= 0; ) {\r\n        char c = buf.charAt(i);\r\n        if (c == '*' || c == '|') {\r\n            buf.delete(i, i + 1);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.text.StringCharacterIterator.next",
	"Comment": "increments the current index and returns the character at the new index.",
	"Method": "char next(){\r\n    if (offset >= (end - 1)) {\r\n        offset = end;\r\n        return DONE;\r\n    }\r\n    return string.charAt(++offset);\r\n}"
}, {
	"Path": "android.icu.text.Edits.addUnchanged",
	"Comment": "adds a record for an unchanged segment of text.normally called from inside icu string transformation functions, not user code.",
	"Method": "void addUnchanged(int unchangedLength){\r\n    if (unchangedLength < 0) {\r\n        throw new IllegalArgumentException(\"addUnchanged(\" + unchangedLength + \"): length must not be negative\");\r\n    }\r\n    int last = lastUnit();\r\n    if (last < MAX_UNCHANGED) {\r\n        int remaining = MAX_UNCHANGED - last;\r\n        if (remaining >= unchangedLength) {\r\n            setLastUnit(last + unchangedLength);\r\n            return;\r\n        }\r\n        setLastUnit(MAX_UNCHANGED);\r\n        unchangedLength -= remaining;\r\n    }\r\n    while (unchangedLength >= MAX_UNCHANGED_LENGTH) {\r\n        append(MAX_UNCHANGED);\r\n        unchangedLength -= MAX_UNCHANGED_LENGTH;\r\n    }\r\n    if (unchangedLength > 0) {\r\n        append(unchangedLength - 1);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedBreakIterator.compileRules",
	"Comment": "compile a set of source break rules into the binary state tables usedby the break iterator engine.creating a break iterator from precompiledrules is much faster than creating one from source rules.binary break rules are not guaranteed to be compatible between differentversions of icu.",
	"Method": "void compileRules(String rules,OutputStream ruleBinary){\r\n    RBBIRuleBuilder.compileRules(rules, ruleBinary);\r\n}"
}, {
	"Path": "android.icu.text.PluralRules.createRules",
	"Comment": "creates a pluralrules from a description if it is parsable,otherwise returns null.",
	"Method": "PluralRules createRules(String description){\r\n    try {\r\n        return parseDescription(description);\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.Collator.getAvailableLocales",
	"Comment": "returns the set of locales, as locale objects, for which collatorsare installed.note that locale objects do not support rfc 3066.",
	"Method": "Locale[] getAvailableLocales(Locale[] getAvailableLocales){\r\n    if (shim == null) {\r\n        return ICUResourceBundle.getAvailableLocales(ICUData.ICU_COLLATION_BASE_NAME, ICUResourceBundle.ICU_DATA_CLASS_LOADER);\r\n    }\r\n    return shim.getAvailableLocales();\r\n}"
}, {
	"Path": "android.icu.impl.duration.Period.moreThan",
	"Comment": "constructs a period representing a duration more thancount units extending into the past.",
	"Method": "Period moreThan(float count,TimeUnit unit,Period moreThan){\r\n    return setTimeLimit(ETimeLimit.MT);\r\n}"
}, {
	"Path": "android.icu.util.TimeZone.getDisplayName",
	"Comment": "returns a name of this time zone suitable for presentation to the userin the specified locale.this method returns the long name, not including daylight savings.if the display name is not available for the locale,a fallback based on the country, city, or time zone id will be used.",
	"Method": "String getDisplayName(String getDisplayName,Locale locale,String getDisplayName,ULocale locale,String getDisplayName,boolean daylight,int style,String getDisplayName,boolean daylight,int style,Locale locale,String getDisplayName,boolean daylight,int style,ULocale locale){\r\n    if (style < SHORT || style > GENERIC_LOCATION) {\r\n        throw new IllegalArgumentException(\"Illegal style: \" + style);\r\n    }\r\n    return _getDisplayName(style, daylight, locale);\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.removeUnsharedReference",
	"Comment": "remove the unshared object from the table, and restore any previoushandle.",
	"Method": "void removeUnsharedReference(Object obj,int previousHandle){\r\n    if (previousHandle != -1) {\r\n        objectsWritten.put(obj, previousHandle);\r\n    } else {\r\n        objectsWritten.remove(obj);\r\n    }\r\n}"
}, {
	"Path": "libcore.net.url.JarHandler.toExternalForm",
	"Comment": "build and return the externalized string representation of url.",
	"Method": "String toExternalForm(URL url){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"jar:\");\r\n    sb.append(url.getFile());\r\n    String ref = url.getRef();\r\n    if (ref != null) {\r\n        sb.append(ref);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneGenericNames.getDisplayName",
	"Comment": "returns the display name of the time zone for the given name typeat the given date, or null if the display name is not available.",
	"Method": "String getDisplayName(TimeZone tz,GenericNameType type,long date){\r\n    String name = null;\r\n    String tzCanonicalID = null;\r\n    switch(type) {\r\n        case LOCATION:\r\n            tzCanonicalID = ZoneMeta.getCanonicalCLDRID(tz);\r\n            if (tzCanonicalID != null) {\r\n                name = getGenericLocationName(tzCanonicalID);\r\n            }\r\n            break;\r\n        case LONG:\r\n        case SHORT:\r\n            name = formatGenericNonLocationName(tz, type, date);\r\n            if (name == null) {\r\n                tzCanonicalID = ZoneMeta.getCanonicalCLDRID(tz);\r\n                if (tzCanonicalID != null) {\r\n                    name = getGenericLocationName(tzCanonicalID);\r\n                }\r\n            }\r\n            break;\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedCollator.setLowerCaseFirst",
	"Comment": "sets the orders of lower cased characters to sort before upper cased characters, in strength tertiary. thedefault mode is false. if true is set, the rulebasedcollator will sort lower cased characters before the uppercased ones. otherwise, if false is set, the rulebasedcollator will ignore case preferences.",
	"Method": "void setLowerCaseFirst(boolean lowerfirst){\r\n    checkNotFrozen();\r\n    if (lowerfirst == isLowerCaseFirst()) {\r\n        return;\r\n    }\r\n    CollationSettings ownedSettings = getOwnedSettings();\r\n    ownedSettings.setCaseFirst(lowerfirst ? CollationSettings.CASE_FIRST : 0);\r\n    setFastLatinOptions(ownedSettings);\r\n}"
}, {
	"Path": "libcore.java.io.OldPipedOutputStreamTest.tearDown",
	"Comment": "tears down the fixture, for example, close a network connection. thismethod is called after a test is executed.",
	"Method": "void tearDown(){\r\n    if (rt != null)\r\n        rt.interrupt();\r\n    super.tearDown();\r\n}"
}, {
	"Path": "android.icu.text.TransliteratorParser.checkVariableRange",
	"Comment": "assert that the given character is not within the variable range.if it is, signal an error.this is neccesary to ensure that thevariable range does not overlap characters used in a rule.",
	"Method": "void checkVariableRange(int ch,String rule,int start){\r\n    if (ch >= curData.variablesBase && ch < variableLimit) {\r\n        syntaxError(\"Variable range character in rule\", rule, start);\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.CharacterIteratorWrapper.clone",
	"Comment": "creates a clone of this iterator.clones the underlying character iterator.",
	"Method": "Object clone(){\r\n    try {\r\n        CharacterIteratorWrapper result = (CharacterIteratorWrapper) super.clone();\r\n        result.iterator = (CharacterIterator) this.iterator.clone();\r\n        return result;\r\n    } catch (CloneNotSupportedException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.fields",
	"Comment": "returns the collection of field descriptors for the fields of thecorresponding class",
	"Method": "ObjectStreamField[] fields(){\r\n    if (fields == null) {\r\n        Class<?> forCl = forClass();\r\n        if (forCl != null && isSerializable() && !forCl.isArray()) {\r\n            buildFieldDescriptors(forCl.getDeclaredFields());\r\n        } else {\r\n            setFields(NO_FIELDS);\r\n        }\r\n    }\r\n    return fields;\r\n}"
}, {
	"Path": "android.icu.text.CollationElementIterator.secondaryOrder",
	"Comment": "return the secondary order of the specified collation element,i.e. the 16th to 23th bits, inclusive.this value is unsigned.",
	"Method": "int secondaryOrder(int ce){\r\n    return (ce >>> 8) & 0xff;\r\n}"
}, {
	"Path": "android.icu.util.CharsTrie.getUniqueValue",
	"Comment": "determines whether all strings reachable from the current statemap to the same value, and if so, returns that value.",
	"Method": "long getUniqueValue(){\r\n    int pos = pos_;\r\n    if (pos < 0) {\r\n        return 0;\r\n    }\r\n    long uniqueValue = findUniqueValue(chars_, pos + remainingMatchLength_ + 1, 0);\r\n    return (uniqueValue << 31) >> 31;\r\n}"
}, {
	"Path": "android.icu.text.RuleBasedBreakIterator.preceding",
	"Comment": "sets the iterator to refer to the last boundary position before thespecified position.",
	"Method": "int preceding(int offset){\r\n    CharacterIterator text = getText();\r\n    if (fCachedBreakPositions == null || offset <= fCachedBreakPositions[0] || offset > fCachedBreakPositions[fCachedBreakPositions.length - 1]) {\r\n        fCachedBreakPositions = null;\r\n        return rulesPreceding(offset);\r\n    } else {\r\n        fPositionInCache = 0;\r\n        while (fPositionInCache < fCachedBreakPositions.length && offset > fCachedBreakPositions[fPositionInCache]) ++fPositionInCache;\r\n        --fPositionInCache;\r\n        text.setIndex(fCachedBreakPositions[fPositionInCache]);\r\n        return text.getIndex();\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.subformat",
	"Comment": "complete the formatting of a finite number. on entry, thedigitlist must be filled in with the correct digits.",
	"Method": "StringBuffer subformat(int number,StringBuffer result,FieldPosition fieldPosition,boolean isNegative,boolean isInteger,boolean parseAttr,StringBuffer subformat,double number,StringBuffer result,FieldPosition fieldPosition,boolean isNegative,boolean isInteger,boolean parseAttr,StringBuffer subformat,String pluralCount,StringBuffer result,FieldPosition fieldPosition,boolean isNegative,boolean isInteger,boolean parseAttr,StringBuffer subformat,StringBuffer result,FieldPosition fieldPosition,boolean isNegative,boolean isInteger,boolean parseAttr){\r\n    if (digitList.isZero()) {\r\n        digitList.decimalAt = 0;\r\n    }\r\n    int prefixLen = appendAffix(result, isNegative, true, fieldPosition, parseAttr);\r\n    if (useExponentialNotation) {\r\n        subformatExponential(result, fieldPosition, parseAttr);\r\n    } else {\r\n        subformatFixed(result, fieldPosition, isInteger, parseAttr);\r\n    }\r\n    int suffixLen = appendAffix(result, isNegative, false, fieldPosition, parseAttr);\r\n    addPadding(result, fieldPosition, prefixLen, suffixLen);\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.text.TransliteratorParser.syntaxError",
	"Comment": "throw an exception indicating a syntax error.search the rule stringfor the probable end of the rule.of course, if the error is thatthe end of rule marker is missing, then the rule end will not be found.in any case the rule start will be correctly reported.",
	"Method": "void syntaxError(String msg,String rule,int start){\r\n    int end = ruleEnd(rule, start, rule.length());\r\n    throw new IllegalIcuArgumentException(msg + \" in \\\"\" + Utility.escape(rule.substring(start, end)) + '\"');\r\n}"
}, {
	"Path": "android.icu.impl.CharTrie.unserialize",
	"Comment": "parses the byte buffer and stores its trie content into a index anddata array",
	"Method": "void unserialize(ByteBuffer bytes){\r\n    int indexDataLength = m_dataOffset_ + m_dataLength_;\r\n    m_index_ = ICUBinary.getChars(bytes, indexDataLength, 0);\r\n    m_data_ = m_index_;\r\n    m_initialValue_ = m_data_[m_dataOffset_];\r\n}"
}, {
	"Path": "android.icu.impl.RuleCharacterIterator.next",
	"Comment": "returns the next character using the given options, or done if thereare no more characters, and advance the position to the nextcharacter.",
	"Method": "int next(int options){\r\n    int c = DONE;\r\n    isEscaped = false;\r\n    for (; ; ) {\r\n        c = _current();\r\n        _advance(UTF16.getCharCount(c));\r\n        if (c == SymbolTable.SYMBOL_REF && buf == null && (options & PARSE_VARIABLES) != 0 && sym != null) {\r\n            String name = sym.parseReference(text, pos, text.length());\r\n            if (name == null) {\r\n                break;\r\n            }\r\n            bufPos = 0;\r\n            buf = sym.lookup(name);\r\n            if (buf == null) {\r\n                throw new IllegalArgumentException(\"Undefined variable: \" + name);\r\n            }\r\n            if (buf.length == 0) {\r\n                buf = null;\r\n            }\r\n            continue;\r\n        }\r\n        if ((options & SKIP_WHITESPACE) != 0 && PatternProps.isWhiteSpace(c)) {\r\n            continue;\r\n        }\r\n        if (c == '\\\\' && (options & PARSE_ESCAPES) != 0) {\r\n            int[] offset = new int[] { 0 };\r\n            c = Utility.unescapeAt(lookahead(), offset);\r\n            jumpahead(offset[0]);\r\n            isEscaped = true;\r\n            if (c < 0) {\r\n                throw new IllegalArgumentException(\"Invalid escape\");\r\n            }\r\n        }\r\n        break;\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.setMaximumFractionDigits",
	"Comment": "sets the maximum number of digits allowed in the fraction portion of a number. thisoverride limits the fraction digit count to 340.",
	"Method": "void setMaximumFractionDigits(int newValue){\r\n    _setMaximumFractionDigits(newValue);\r\n    resetActualRounding();\r\n}"
}, {
	"Path": "android.icu.util.Calendar.equals",
	"Comment": "compares this calendar to the specified object.the result is true if and only if the argument isnot null and is a calendar object thatrepresents the same calendar as this object.",
	"Method": "boolean equals(Object obj,boolean equals,Object other){\r\n    if (obj == null) {\r\n        return false;\r\n    }\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (this.getClass() != obj.getClass()) {\r\n        return false;\r\n    }\r\n    Calendar that = (Calendar) obj;\r\n    return isEquivalentTo(that) && getTimeInMillis() == that.getTime().getTime();\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.resemblesPropertyPattern",
	"Comment": "return true if the given iterator appears to point at aproperty pattern.regardless of the result, return with theiterator unchanged.",
	"Method": "boolean resemblesPropertyPattern(String pattern,int pos,boolean resemblesPropertyPattern,RuleCharacterIterator chars,int iterOpts){\r\n    boolean result = false;\r\n    iterOpts &= ~RuleCharacterIterator.PARSE_ESCAPES;\r\n    Object pos = chars.getPos(null);\r\n    int c = chars.next(iterOpts);\r\n    if (c == '[' || c == '\\\\') {\r\n        int d = chars.next(iterOpts & ~RuleCharacterIterator.SKIP_WHITESPACE);\r\n        result = (c == '[') ? (d == ':') : (d == 'N' || d == 'p' || d == 'P');\r\n    }\r\n    chars.setPos(pos);\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.text.CharsetDetector.detectAll",
	"Comment": "return an array of all charsets that appear to be plausible matches with the input data.the array is ordered with the best quality match first.raise an exception if no charsets appear to match the input data. no input text has been provided",
	"Method": "CharsetMatch[] detectAll(){\r\n    ArrayList<CharsetMatch> matches = new ArrayList<CharsetMatch>();\r\n    MungeInput();\r\n    for (int i = 0; i < ALL_CS_RECOGNIZERS.size(); i++) {\r\n        CSRecognizerInfo rcinfo = ALL_CS_RECOGNIZERS.get(i);\r\n        boolean active = (fEnabledRecognizers != null) ? fEnabledRecognizers[i] : rcinfo.isDefaultEnabled;\r\n        if (active) {\r\n            CharsetMatch m = rcinfo.recognizer.match(this);\r\n            if (m != null) {\r\n                matches.add(m);\r\n            }\r\n        }\r\n    }\r\n    Collections.sort(matches);\r\n    Collections.reverse(matches);\r\n    CharsetMatch[] resultArray = new CharsetMatch[matches.size()];\r\n    resultArray = matches.toArray(resultArray);\r\n    return resultArray;\r\n}"
}, {
	"Path": "android.icu.text.UnicodeCompressor.findStaticWindow",
	"Comment": "determine if a static window for a certain character is defined",
	"Method": "int findStaticWindow(int c){\r\n    for (int i = NUMSTATICWINDOWS - 1; i >= 0; --i) {\r\n        if (inStaticWindow(c, i)) {\r\n            return i;\r\n        }\r\n    }\r\n    return INVALIDWINDOW;\r\n}"
}, {
	"Path": "android.icu.text.TransliteratorRegistry.getAvailableVariants",
	"Comment": "returns an enumeration over visible variant names for the givensource and target.",
	"Method": "Enumeration<String> getAvailableVariants(String source,String target){\r\n    CaseInsensitiveString cisrc = new CaseInsensitiveString(source);\r\n    CaseInsensitiveString citrg = new CaseInsensitiveString(target);\r\n    Map<CaseInsensitiveString, List<CaseInsensitiveString>> targets = specDAG.get(cisrc);\r\n    if (targets == null) {\r\n        return new IDEnumeration(null);\r\n    }\r\n    List<CaseInsensitiveString> variants = targets.get(citrg);\r\n    if (variants == null) {\r\n        return new IDEnumeration(null);\r\n    }\r\n    return new IDEnumeration(Collections.enumeration(variants));\r\n}"
}, {
	"Path": "android.icu.impl.ICUService.handleDefault",
	"Comment": "default handler for this service if no factory in the listhandled the key.",
	"Method": "Object handleDefault(Key key,String[] actualIDReturn){\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.util.Calendar.fieldName",
	"Comment": "returns a string name for a field, for debugging and exceptions.",
	"Method": "String fieldName(int field){\r\n    try {\r\n        return FIELD_NAME[field];\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        return \"Field \" + field;\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.duration.Period.isMoreThan",
	"Comment": "returns true if this represents a duration inexcess of the defined duration.",
	"Method": "boolean isMoreThan(){\r\n    return timeLimit == ETimeLimit.MT;\r\n}"
}, {
	"Path": "java.util.ResourceBundle.getBundle",
	"Comment": "finds the named resource bundle for the specified base name and control.",
	"Method": "ResourceBundle getBundle(String bundleName,ResourceBundle getBundle,String bundleName,Locale locale,ResourceBundle getBundle,String bundleName,Locale locale,ClassLoader loader,ResourceBundle getBundle,String baseName,ResourceBundle.Control control,ResourceBundle getBundle,String baseName,Locale targetLocale,ResourceBundle.Control control,ResourceBundle getBundle,String baseName,Locale targetLocale,ClassLoader loader,ResourceBundle.Control control){\r\n    boolean expired = false;\r\n    String bundleName = control.toBundleName(baseName, targetLocale);\r\n    Object cacheKey = loader != null ? loader : \"null\";\r\n    Hashtable<String, ResourceBundle> loaderCache = getLoaderCache(cacheKey);\r\n    ResourceBundle result = loaderCache.get(bundleName);\r\n    if (result != null) {\r\n        long time = control.getTimeToLive(baseName, targetLocale);\r\n        if (time == 0 || time == Control.TTL_NO_EXPIRATION_CONTROL || time + result.lastLoadTime < System.currentTimeMillis()) {\r\n            if (MISSING == result) {\r\n                throw new MissingResourceException(null, bundleName + '_' + targetLocale, EMPTY_STRING);\r\n            }\r\n            return result;\r\n        }\r\n        expired = true;\r\n    }\r\n    ResourceBundle ret = processGetBundle(baseName, targetLocale, loader, control, expired, result);\r\n    if (ret != null) {\r\n        loaderCache.put(bundleName, ret);\r\n        ret.lastLoadTime = System.currentTimeMillis();\r\n        return ret;\r\n    }\r\n    loaderCache.put(bundleName, MISSING);\r\n    throw new MissingResourceException(null, bundleName + '_' + targetLocale, EMPTY_STRING);\r\n}"
}, {
	"Path": "android.icu.dev.test.calendar.IBMCalendarTest.TestJapanese",
	"Comment": "verify that japanesecalendar shifts years to japanese eras but otherwisebehaves like gregoriancalendar.",
	"Method": "void TestJapanese(){\r\n    int[] control = { GregorianCalendar.AD, 1868, 1868, Calendar.SEPTEMBER, 8, GregorianCalendar.AD, 1868, 1868, Calendar.SEPTEMBER, 9, GregorianCalendar.AD, 1869, 1869, Calendar.JUNE, 4, GregorianCalendar.AD, 1912, 1912, Calendar.JULY, 29, GregorianCalendar.AD, 1912, 1912, Calendar.JULY, 30, GregorianCalendar.AD, 1912, 1912, Calendar.AUGUST, 1 };\r\n    quasiGregorianTest(new GregorianCalendar(), control);\r\n    int[] data = { JapaneseCalendar.MEIJI, 1, 1868, Calendar.SEPTEMBER, 8, JapaneseCalendar.MEIJI, 1, 1868, Calendar.SEPTEMBER, 9, JapaneseCalendar.MEIJI, 2, 1869, Calendar.JUNE, 4, JapaneseCalendar.MEIJI, 45, 1912, Calendar.JULY, 29, JapaneseCalendar.TAISHO, 1, 1912, Calendar.JULY, 30, JapaneseCalendar.TAISHO, 1, 1912, Calendar.AUGUST, 1 };\r\n    quasiGregorianTest(new JapaneseCalendar(), data);\r\n}"
}, {
	"Path": "android.icu.text.UFormat.setLocale",
	"Comment": "set information about the locales that were used to create thisobject.if the object was not constructed from locale data,both arguments should be set to null.otherwise, neithershould be null.the actual locale must be at the same level orless specific than the valid locale.this method is intendedfor use by factories or other entities that create objects ofthis class.",
	"Method": "void setLocale(ULocale valid,ULocale actual){\r\n    if ((valid == null) != (actual == null)) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    this.validLocale = valid;\r\n    this.actualLocale = actual;\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.resetSeenObjects",
	"Comment": "reset the collection of objects already loaded by the receiver.",
	"Method": "void resetSeenObjects(){\r\n    objectsRead = new ArrayList<Object>();\r\n    nextHandle = baseWireHandle;\r\n    primitiveData = emptyStream;\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.close",
	"Comment": "closes this stream. this implementation closes the source stream.",
	"Method": "void close(){\r\n    input.close();\r\n}"
}, {
	"Path": "libcore.java.io.OldObjectOutputStreamTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this methodis called before a test is executed.",
	"Method": "void setUp(){\r\n    super.setUp();\r\n    oos = new ObjectOutputStream(bao = new ByteArrayOutputStream());\r\n    oos_ioe = new ObjectOutputStream(sos = new Support_OutputStream());\r\n    sos.setThrowsException(true);\r\n}"
}, {
	"Path": "android.icu.util.GlobalizationPreferences.getLocale",
	"Comment": "convenience function for getting the locales in priority order",
	"Method": "ULocale getLocale(int index){\r\n    List<ULocale> lcls = locales;\r\n    if (lcls == null) {\r\n        lcls = guessLocales();\r\n    }\r\n    if (index >= 0 && index < lcls.size()) {\r\n        return lcls.get(index);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.util.GregorianCalendar.isLeapYear",
	"Comment": "determines if the given year is a leap year. returns true if thegiven year is a leap year.",
	"Method": "boolean isLeapYear(int year){\r\n    return year >= gregorianCutoverYear ? ((year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0))) : (year % 4 == 0);\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.checkWritePrimitiveTypes",
	"Comment": "do the necessary work to see if the receiver can be used to writeprimitive types like int, char, etc.",
	"Method": "void checkWritePrimitiveTypes(){\r\n    if (primitiveTypes == null) {\r\n        primitiveTypesBuffer = new ByteArrayOutputStream(128);\r\n        primitiveTypes = new DataOutputStream(primitiveTypesBuffer);\r\n    }\r\n}"
}, {
	"Path": "libcore.java.io.OldRandomAccessFileTest.tearDown",
	"Comment": "tears down the fixture, for example, close a network connection. thismethod is called after a test is executed.",
	"Method": "void tearDown(){\r\n    if (f.exists()) {\r\n        f.delete();\r\n    }\r\n    super.tearDown();\r\n}"
}, {
	"Path": "android.icu.text.LocaleDisplayNames.getUiList",
	"Comment": "return a list of information used to construct a ui list of locale names.",
	"Method": "List<UiListItem> getUiList(Set<ULocale> localeSet,boolean inSelf,Comparator<Object> collator){\r\n    return getUiListCompareWholeItems(localeSet, UiListItem.getComparator(collator, inSelf));\r\n}"
}, {
	"Path": "org.apache.harmony.xml.dom.NodeImpl.getNamespacingElement",
	"Comment": "returns the element whose namespace definitions apply to this node. usethis element when mapping prefixes to uris and vice versa.",
	"Method": "NodeImpl getNamespacingElement(){\r\n    switch(this.getNodeType()) {\r\n        case ELEMENT_NODE:\r\n            return this;\r\n        case DOCUMENT_NODE:\r\n            return (NodeImpl) ((Document) this).getDocumentElement();\r\n        case ENTITY_NODE:\r\n        case NOTATION_NODE:\r\n        case DOCUMENT_FRAGMENT_NODE:\r\n        case DOCUMENT_TYPE_NODE:\r\n            return null;\r\n        case ATTRIBUTE_NODE:\r\n            return (NodeImpl) ((Attr) this).getOwnerElement();\r\n        case TEXT_NODE:\r\n        case CDATA_SECTION_NODE:\r\n        case ENTITY_REFERENCE_NODE:\r\n        case PROCESSING_INSTRUCTION_NODE:\r\n        case COMMENT_NODE:\r\n            return getContainingElement();\r\n        default:\r\n            throw new DOMException(DOMException.NOT_SUPPORTED_ERR, \"Unsupported node type \" + getNodeType());\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.CollationKey.getSourceString",
	"Comment": "return the source string that this collationkey represents.",
	"Method": "String getSourceString(){\r\n    return m_source_;\r\n}"
}, {
	"Path": "android.icu.text.DateIntervalFormat.getConcatenationPattern",
	"Comment": "retrieves the concatenation datetime pattern from the resource bundle.",
	"Method": "String getConcatenationPattern(ULocale locale){\r\n    ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, locale);\r\n    ICUResourceBundle dtPatternsRb = rb.getWithFallback(\"calendar/gregorian/DateTimePatterns\");\r\n    ICUResourceBundle concatenationPatternRb = (ICUResourceBundle) dtPatternsRb.get(8);\r\n    if (concatenationPatternRb.getType() == UResourceBundle.STRING) {\r\n        return concatenationPatternRb.getString();\r\n    } else {\r\n        return concatenationPatternRb.getString(0);\r\n    }\r\n}"
}, {
	"Path": "android.icu.text.Bidi.getReorderingMode",
	"Comment": "what is the requested reordering mode for a given bidi object?",
	"Method": "int getReorderingMode(){\r\n    return this.reorderingMode;\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneGenericNames.getGenericLocationName",
	"Comment": "returns the generic location name for the given canonical time zone id.",
	"Method": "String getGenericLocationName(String canonicalTzID){\r\n    if (canonicalTzID == null || canonicalTzID.length() == 0) {\r\n        return null;\r\n    }\r\n    String name = _genericLocationNamesMap.get(canonicalTzID);\r\n    if (name != null) {\r\n        if (name.length() == 0) {\r\n            return null;\r\n        }\r\n        return name;\r\n    }\r\n    Output<Boolean> isPrimary = new Output<Boolean>();\r\n    String countryCode = ZoneMeta.getCanonicalCountry(canonicalTzID, isPrimary);\r\n    if (countryCode != null) {\r\n        if (isPrimary.value) {\r\n            String country = getLocaleDisplayNames().regionDisplayName(countryCode);\r\n            name = formatPattern(Pattern.REGION_FORMAT, country);\r\n        } else {\r\n            String city = _tznames.getExemplarLocationName(canonicalTzID);\r\n            name = formatPattern(Pattern.REGION_FORMAT, city);\r\n        }\r\n    }\r\n    if (name == null) {\r\n        _genericLocationNamesMap.putIfAbsent(canonicalTzID.intern(), \"\");\r\n    } else {\r\n        synchronized (this) {\r\n            canonicalTzID = canonicalTzID.intern();\r\n            String tmp = _genericLocationNamesMap.putIfAbsent(canonicalTzID, name.intern());\r\n            if (tmp == null) {\r\n                NameInfo info = new NameInfo(canonicalTzID, GenericNameType.LOCATION);\r\n                _gnamesTrie.put(name, info);\r\n            } else {\r\n                name = tmp;\r\n            }\r\n        }\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat.setCurrencyForSymbols",
	"Comment": "update the currency object to match the symbols. this method is used only when thecaller has passed in a symbols object that may not be the default object for itslocale.",
	"Method": "void setCurrencyForSymbols(){\r\n    DecimalFormatSymbols def = new DecimalFormatSymbols(symbols.getULocale());\r\n    if (symbols.getCurrencySymbol().equals(def.getCurrencySymbol()) && symbols.getInternationalCurrencySymbol().equals(def.getInternationalCurrencySymbol())) {\r\n        setCurrency(Currency.getInstance(symbols.getULocale()));\r\n    } else {\r\n        setCurrency(null);\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.GregorianCalendar.isEquivalentTo",
	"Comment": "returns true if the given calendar object is equivalent to thisone.calendar override.",
	"Method": "boolean isEquivalentTo(Calendar other){\r\n    return super.isEquivalentTo(other) && gregorianCutover == ((GregorianCalendar) other).gregorianCutover;\r\n}"
}, {
	"Path": "android.icu.impl.IntTrie.getLeadValue",
	"Comment": "gets the value to the data which this lead surrogate character points to. returned data may contain folding offset information for the next trailing surrogate character. this method does not guarantee correct results for trail surrogates.",
	"Method": "int getLeadValue(char ch){\r\n    return m_data_[getLeadOffset(ch)];\r\n}"
}, {
	"Path": "android.icu.text.SearchIterator.setOverlapping",
	"Comment": "determines whether overlapping matches are returned. see the class documentation for more information about overlapping matches.the default setting of this property is false",
	"Method": "void setOverlapping(boolean allowOverlap){\r\n    search_.isOverlap_ = allowOverlap;\r\n}"
}, {
	"Path": "android.icu.text.Normalizer.normalize",
	"Comment": "convenience method to normalize a codepoint according to the given mode",
	"Method": "String normalize(String str,Mode mode,int options,String normalize,String src,Mode mode,int normalize,char[] source,char[] target,Mode mode,int options,int normalize,char[] src,int srcStart,int srcLimit,char[] dest,int destStart,int destLimit,Mode mode,int options,String normalize,int char32,Mode mode,int options,String normalize,int char32,Mode mode){\r\n    return normalize(char32, mode, 0);\r\n}"
}, {
	"Path": "android.icu.text.BidiClassifier.setContext",
	"Comment": "sets classifier context, which can be used either by a caller orcallee for various purposes.",
	"Method": "void setContext(Object context){\r\n    this.context = context;\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.verifyAndInit",
	"Comment": "verify if the suid & the base name for descriptorloadedstreamclassmatchesthe suid & the base name of the corresponding loaded class andinit private fields.",
	"Method": "void verifyAndInit(ObjectStreamClass loadedStreamClass){\r\n    Class<?> localClass = loadedStreamClass.forClass();\r\n    ObjectStreamClass localStreamClass = ObjectStreamClass.lookupStreamClass(localClass);\r\n    if (loadedStreamClass.getSerialVersionUID() != localStreamClass.getSerialVersionUID()) {\r\n        boolean isArray = loadedStreamClass.getName().startsWith(\"[\");\r\n        if (!isArray) {\r\n            throw new InvalidClassException(loadedStreamClass.getName(), \"Incompatible class (SUID): \" + loadedStreamClass + \" but expected \" + localStreamClass);\r\n        }\r\n    }\r\n    String loadedClassBaseName = getBaseName(loadedStreamClass.getName());\r\n    String localClassBaseName = getBaseName(localStreamClass.getName());\r\n    if (!loadedClassBaseName.equals(localClassBaseName)) {\r\n        throw new InvalidClassException(loadedStreamClass.getName(), String.format(\"Incompatible class (base name): %s but expected %s\", loadedClassBaseName, localClassBaseName));\r\n    }\r\n    loadedStreamClass.initPrivateFields(localStreamClass);\r\n}"
}, {
	"Path": "android.icu.text.NumberFormat.setRoundingMode",
	"Comment": "set the rounding mode used in this numberformat.the default implementation oftis method in numberformat always throws unsupportedoperationexception.",
	"Method": "void setRoundingMode(int roundingMode){\r\n    throw new UnsupportedOperationException(\"setRoundingMode must be implemented by the subclass implementation.\");\r\n}"
}, {
	"Path": "android.icu.util.GlobalizationPreferences.getCurrency",
	"Comment": "get a copy of the currency computed according to the settings.",
	"Method": "Currency getCurrency(){\r\n    if (currency == null) {\r\n        return guessCurrency();\r\n    }\r\n    return currency;\r\n}"
}, {
	"Path": "android.icu.impl.ZoneMeta.getCustomTimeZone",
	"Comment": "parse a custom time zone identifier and return a corresponding zone.",
	"Method": "SimpleTimeZone getCustomTimeZone(String id,SimpleTimeZone getCustomTimeZone,int offset){\r\n    boolean negative = false;\r\n    int tmp = offset;\r\n    if (offset < 0) {\r\n        negative = true;\r\n        tmp = -offset;\r\n    }\r\n    int hour, min, sec;\r\n    if (ASSERT) {\r\n        Assert.assrt(\"millis!=0\", tmp % 1000 != 0);\r\n    }\r\n    tmp /= 1000;\r\n    sec = tmp % 60;\r\n    tmp /= 60;\r\n    min = tmp % 60;\r\n    hour = tmp / 60;\r\n    String zid = formatCustomID(hour, min, sec, negative);\r\n    return new SimpleTimeZone(offset, zid);\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormat._setMaximumFractionDigits",
	"Comment": "internal method for decimalformat, setting maximum fractional digitswithout triggering actual rounding recalculated.",
	"Method": "void _setMaximumFractionDigits(int newValue){\r\n    super.setMaximumFractionDigits(Math.min(newValue, DOUBLE_FRACTION_DIGITS));\r\n}"
}, {
	"Path": "android.icu.text.BreakIterator.getSentenceInstance",
	"Comment": "returns a new instance of breakiterator that locates sentence boundaries.",
	"Method": "BreakIterator getSentenceInstance(BreakIterator getSentenceInstance,Locale where,BreakIterator getSentenceInstance,ULocale where){\r\n    return getBreakInstance(where, KIND_SENTENCE);\r\n}"
}, {
	"Path": "android.icu.text.DecimalFormatSymbols.getSignificantDigit",
	"Comment": "returns the character used to represent a significant digit in a pattern.",
	"Method": "char getSignificantDigit(){\r\n    return sigDigit;\r\n}"
}, {
	"Path": "org.apache.harmony.xml.dom.DocumentImpl.insertChildAt",
	"Comment": "document elements may have at most one root element and at most one dtdelement.",
	"Method": "Node insertChildAt(Node toInsert,int index){\r\n    if (toInsert instanceof Element && getDocumentElement() != null) {\r\n        throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, \"Only one root element allowed\");\r\n    }\r\n    if (toInsert instanceof DocumentType && getDoctype() != null) {\r\n        throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, \"Only one DOCTYPE element allowed\");\r\n    }\r\n    return super.insertChildAt(toInsert, index);\r\n}"
}, {
	"Path": "android.icu.text.TimeZoneFormat.setGMTOffsetDigits",
	"Comment": "sets the decimal digit characters used for localized gmt format.",
	"Method": "TimeZoneFormat setGMTOffsetDigits(String digits){\r\n    if (isFrozen()) {\r\n        throw new UnsupportedOperationException(\"Attempt to modify frozen object\");\r\n    }\r\n    if (digits == null) {\r\n        throw new NullPointerException(\"Null GMT offset digits\");\r\n    }\r\n    String[] digitArray = toCodePoints(digits);\r\n    if (digitArray.length != 10) {\r\n        throw new IllegalArgumentException(\"Length of digits must be 10\");\r\n    }\r\n    _gmtOffsetDigits = digitArray;\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.impl.ReplaceableUCharacterIterator.clone",
	"Comment": "creates a copy of this iterator, does not clone the underlyingreplaceableobject",
	"Method": "Object clone(){\r\n    try {\r\n        return super.clone();\r\n    } catch (CloneNotSupportedException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectStreamField.getTypeString",
	"Comment": "gets the type signature used by the vm to represent the type of thisfield.",
	"Method": "String getTypeString(){\r\n    if (isPrimitive()) {\r\n        return null;\r\n    }\r\n    if (typeString == null) {\r\n        Class<?> t = getTypeInternal();\r\n        String typeName = t.getName().replace('.', '/');\r\n        String str = (t.isArray()) ? typeName : (\"L\" + typeName + ';');\r\n        typeString = str.intern();\r\n    }\r\n    return typeString;\r\n}"
}, {
	"Path": "android.icu.lang.UScript.getScript",
	"Comment": "gets the script code associated with the given codepoint.returns uscript.malayam given 0x0d02",
	"Method": "int getScript(int codepoint){\r\n    if (codepoint >= UCharacter.MIN_VALUE & codepoint <= UCharacter.MAX_VALUE) {\r\n        int scriptX = UCharacterProperty.INSTANCE.getAdditional(codepoint, 0) & UCharacterProperty.SCRIPT_X_MASK;\r\n        if (scriptX < UCharacterProperty.SCRIPT_X_WITH_COMMON) {\r\n            return scriptX;\r\n        } else if (scriptX < UCharacterProperty.SCRIPT_X_WITH_INHERITED) {\r\n            return UScript.COMMON;\r\n        } else if (scriptX < UCharacterProperty.SCRIPT_X_WITH_OTHER) {\r\n            return UScript.INHERITED;\r\n        } else {\r\n            return UCharacterProperty.INSTANCE.m_scriptExtensions_[scriptX & UCharacterProperty.SCRIPT_MASK_];\r\n        }\r\n    } else {\r\n        throw new IllegalArgumentException(Integer.toString(codepoint));\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.CollationMiscTest.TestSpecialCharacters",
	"Comment": "tests the compact range syntax with special characters used as syntax characters in rules.",
	"Method": "void TestSpecialCharacters(){\r\n    String[] rules = new String[] { \"&';'<'+'<','<'-'<'&'<'*'\", \"&';'<*'+,-&*'\", \"&';'<*'+'-'-&*'\", \"&';'<'+'<','<'-'<'&'<'*'\", \"&';'<*'+,-&*'\", \"&';'<*'+,-&*'\", \"&';'<*'+'-'-&*'\", \"&';'<*'+'-'-&*'\" };\r\n    OneTestCase[] testCases = new OneTestCase[] { new OneTestCase(\";\", \"+\", -1), new OneTestCase(\"+\", \",\", -1), new OneTestCase(\",\", \"-\", -1), new OneTestCase(\"-\", \"&\", -1) };\r\n    doTestCollation(testCases, rules);\r\n}"
}, {
	"Path": "android.icu.util.Calendar.after",
	"Comment": "compares the time field records.equivalent to comparing result of conversion to utc.",
	"Method": "boolean after(Object when){\r\n    return compare(when) > 0;\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.setContext",
	"Comment": "here we override the dateformat implementation in order to lazily initialize relevant items",
	"Method": "void setContext(DisplayContext context){\r\n    super.setContext(context);\r\n    if (capitalizationBrkIter == null && (context == DisplayContext.CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE || context == DisplayContext.CAPITALIZATION_FOR_UI_LIST_OR_MENU || context == DisplayContext.CAPITALIZATION_FOR_STANDALONE)) {\r\n        capitalizationBrkIter = BreakIterator.getSentenceInstance(locale);\r\n    }\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneGenericNames.formatPattern",
	"Comment": "private simple pattern formatter used for formatting generic location namesand partial location names. we intentionally use jdk messageformatfor performance reason.",
	"Method": "String formatPattern(Pattern pat,String args){\r\n    if (_patternFormatters == null) {\r\n        _patternFormatters = new MessageFormat[Pattern.values().length];\r\n    }\r\n    int idx = pat.ordinal();\r\n    if (_patternFormatters[idx] == null) {\r\n        String patText;\r\n        try {\r\n            ICUResourceBundle bundle = (ICUResourceBundle) ICUResourceBundle.getBundleInstance(ICUData.ICU_ZONE_BASE_NAME, _locale);\r\n            patText = bundle.getStringWithFallback(\"zoneStrings/\" + pat.key());\r\n        } catch (MissingResourceException e) {\r\n            patText = pat.defaultValue();\r\n        }\r\n        _patternFormatters[idx] = new MessageFormat(patText);\r\n    }\r\n    return _patternFormatters[idx].format(args);\r\n}"
}, {
	"Path": "android.icu.text.UnicodeSet.retainAll",
	"Comment": "retains only the elements in this set that are contained in thespecified set.in other words, removes from this set all ofits elements that are not contained in the specified set.thisoperation effectively modifies this set so that its value isthe intersection of the two sets.",
	"Method": "UnicodeSet retainAll(CharSequence s,UnicodeSet retainAll,UnicodeSet c,UnicodeSet retainAll,Iterable<T> collection){\r\n    checkFrozen();\r\n    UnicodeSet toRetain = new UnicodeSet();\r\n    toRetain.addAll(collection);\r\n    retainAll(toRetain);\r\n    return this;\r\n}"
}, {
	"Path": "android.icu.text.AlphabeticIndex.initLabels",
	"Comment": "determine the best labels to use. this is based on the exemplars, but we also process to make sure that they are unique,and sort differently, and that the overall list is small enough.",
	"Method": "List<String> initLabels(){\r\n    Normalizer2 nfkdNormalizer = Normalizer2.getNFKDInstance();\r\n    List<String> indexCharacters = new ArrayList<String>();\r\n    String firstScriptBoundary = firstCharsInScripts.get(0);\r\n    String overflowBoundary = firstCharsInScripts.get(firstCharsInScripts.size() - 1);\r\n    for (String item : initialLabels) {\r\n        boolean checkDistinct;\r\n        if (!UTF16.hasMoreCodePointsThan(item, 1)) {\r\n            checkDistinct = false;\r\n        } else if (item.charAt(item.length() - 1) == '*' && item.charAt(item.length() - 2) != '*') {\r\n            item = item.substring(0, item.length() - 1);\r\n            checkDistinct = false;\r\n        } else {\r\n            checkDistinct = true;\r\n        }\r\n        if (collatorPrimaryOnly.compare(item, firstScriptBoundary) < 0) {\r\n        } else if (collatorPrimaryOnly.compare(item, overflowBoundary) >= 0) {\r\n        } else if (checkDistinct && collatorPrimaryOnly.compare(item, separated(item)) == 0) {\r\n        } else {\r\n            int insertionPoint = Collections.binarySearch(indexCharacters, item, collatorPrimaryOnly);\r\n            if (insertionPoint < 0) {\r\n                indexCharacters.add(~insertionPoint, item);\r\n            } else {\r\n                String itemAlreadyIn = indexCharacters.get(insertionPoint);\r\n                if (isOneLabelBetterThanOther(nfkdNormalizer, item, itemAlreadyIn)) {\r\n                    indexCharacters.set(insertionPoint, item);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    final int size = indexCharacters.size() - 1;\r\n    if (size > maxLabelCount) {\r\n        int count = 0;\r\n        int old = -1;\r\n        for (Iterator<String> it = indexCharacters.iterator(); it.hasNext(); ) {\r\n            ++count;\r\n            it.next();\r\n            final int bump = count * maxLabelCount / size;\r\n            if (bump == old) {\r\n                it.remove();\r\n            } else {\r\n                old = bump;\r\n            }\r\n        }\r\n    }\r\n    return indexCharacters;\r\n}"
}, {
	"Path": "android.icu.text.TransliteratorParser.parseRules",
	"Comment": "parse an array of zero or more rules.the strings in the array aretreated as if they were concatenated together, with rule terminatorsinserted between array elements if not present already.any previous rules are discarded.typically this method is called exactlyonce, during construction.the member this.data will be set to null if there are no rules.",
	"Method": "void parseRules(RuleBody ruleArray,int dir){\r\n    boolean parsingIDs = true;\r\n    int ruleCount = 0;\r\n    dataVector = new ArrayList<Data>();\r\n    idBlockVector = new ArrayList<String>();\r\n    curData = null;\r\n    direction = dir;\r\n    compoundFilter = null;\r\n    variablesVector = new ArrayList<Object>();\r\n    variableNames = new HashMap<String, char[]>();\r\n    parseData = new ParseData();\r\n    List<RuntimeException> errors = new ArrayList<RuntimeException>();\r\n    int errorCount = 0;\r\n    ruleArray.reset();\r\n    StringBuilder idBlockResult = new StringBuilder();\r\n    this.compoundFilter = null;\r\n    int compoundFilterOffset = -1;\r\n    main: for (; ; ) {\r\n        String rule = ruleArray.nextLine();\r\n        if (rule == null) {\r\n            break;\r\n        }\r\n        int pos = 0;\r\n        int limit = rule.length();\r\n        while (pos < limit) {\r\n            char c = rule.charAt(pos++);\r\n            if (PatternProps.isWhiteSpace(c)) {\r\n                continue;\r\n            }\r\n            if (c == RULE_COMMENT_CHAR) {\r\n                pos = rule.indexOf(\"\\n\", pos) + 1;\r\n                if (pos == 0) {\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (c == END_OF_RULE)\r\n                continue;\r\n            try {\r\n                ++ruleCount;\r\n                --pos;\r\n                if ((pos + ID_TOKEN_LEN + 1) <= limit && rule.regionMatches(pos, ID_TOKEN, 0, ID_TOKEN_LEN)) {\r\n                    pos += ID_TOKEN_LEN;\r\n                    c = rule.charAt(pos);\r\n                    while (PatternProps.isWhiteSpace(c) && pos < limit) {\r\n                        ++pos;\r\n                        c = rule.charAt(pos);\r\n                    }\r\n                    int[] p = new int[] { pos };\r\n                    if (!parsingIDs) {\r\n                        if (curData != null) {\r\n                            if (direction == Transliterator.FORWARD)\r\n                                dataVector.add(curData);\r\n                            else\r\n                                dataVector.add(0, curData);\r\n                            curData = null;\r\n                        }\r\n                        parsingIDs = true;\r\n                    }\r\n                    TransliteratorIDParser.SingleID id = TransliteratorIDParser.parseSingleID(rule, p, direction);\r\n                    if (p[0] != pos && Utility.parseChar(rule, p, END_OF_RULE)) {\r\n                        if (direction == Transliterator.FORWARD) {\r\n                            idBlockResult.append(id.canonID).append(END_OF_RULE);\r\n                        } else {\r\n                            idBlockResult.insert(0, id.canonID + END_OF_RULE);\r\n                        }\r\n                    } else {\r\n                        int[] withParens = new int[] { -1 };\r\n                        UnicodeSet f = TransliteratorIDParser.parseGlobalFilter(rule, p, direction, withParens, null);\r\n                        if (f != null && Utility.parseChar(rule, p, END_OF_RULE)) {\r\n                            if ((direction == Transliterator.FORWARD) == (withParens[0] == 0)) {\r\n                                if (compoundFilter != null) {\r\n                                    syntaxError(\"Multiple global filters\", rule, pos);\r\n                                }\r\n                                compoundFilter = f;\r\n                                compoundFilterOffset = ruleCount;\r\n                            }\r\n                        } else {\r\n                            syntaxError(\"Invalid ::ID\", rule, pos);\r\n                        }\r\n                    }\r\n                    pos = p[0];\r\n                } else {\r\n                    if (parsingIDs) {\r\n                        if (direction == Transliterator.FORWARD)\r\n                            idBlockVector.add(idBlockResult.toString());\r\n                        else\r\n                            idBlockVector.add(0, idBlockResult.toString());\r\n                        idBlockResult.delete(0, idBlockResult.length());\r\n                        parsingIDs = false;\r\n                        curData = new RuleBasedTransliterator.Data();\r\n                        setVariableRange(0xF000, 0xF8FF);\r\n                    }\r\n                    if (resemblesPragma(rule, pos, limit)) {\r\n                        int ppp = parsePragma(rule, pos, limit);\r\n                        if (ppp < 0) {\r\n                            syntaxError(\"Unrecognized pragma\", rule, pos);\r\n                        }\r\n                        pos = ppp;\r\n                    } else {\r\n                        pos = parseRule(rule, pos, limit);\r\n                    }\r\n                }\r\n            } catch (IllegalArgumentException e) {\r\n                if (errorCount == 30) {\r\n                    IllegalIcuArgumentException icuEx = new IllegalIcuArgumentException(\"\\nMore than 30 errors; further messages squelched\");\r\n                    icuEx.initCause(e);\r\n                    errors.add(icuEx);\r\n                    break main;\r\n                }\r\n                e.fillInStackTrace();\r\n                errors.add(e);\r\n                ++errorCount;\r\n                pos = ruleEnd(rule, pos, limit) + 1;\r\n            }\r\n        }\r\n    }\r\n    if (parsingIDs && idBlockResult.length() > 0) {\r\n        if (direction == Transliterator.FORWARD)\r\n            idBlockVector.add(idBlockResult.toString());\r\n        else\r\n            idBlockVector.add(0, idBlockResult.toString());\r\n    } else if (!parsingIDs && curData != null) {\r\n        if (direction == Transliterator.FORWARD)\r\n            dataVector.add(curData);\r\n        else\r\n            dataVector.add(0, curData);\r\n    }\r\n    for (int i = 0; i < dataVector.size(); i++) {\r\n        Data data = dataVector.get(i);\r\n        data.variables = new Object[variablesVector.size()];\r\n        variablesVector.toArray(data.variables);\r\n        data.variableNames = new HashMap<String, char[]>();\r\n        data.variableNames.putAll(variableNames);\r\n    }\r\n    variablesVector = null;\r\n    try {\r\n        if (compoundFilter != null) {\r\n            if ((direction == Transliterator.FORWARD && compoundFilterOffset != 1) || (direction == Transliterator.REVERSE && compoundFilterOffset != ruleCount)) {\r\n                throw new IllegalIcuArgumentException(\"Compound filters misplaced\");\r\n            }\r\n        }\r\n        for (int i = 0; i < dataVector.size(); i++) {\r\n            Data data = dataVector.get(i);\r\n            data.ruleSet.freeze();\r\n        }\r\n        if (idBlockVector.size() == 1 && (idBlockVector.get(0)).length() == 0)\r\n            idBlockVector.remove(0);\r\n    } catch (IllegalArgumentException e) {\r\n        e.fillInStackTrace();\r\n        errors.add(e);\r\n    }\r\n    if (errors.size() != 0) {\r\n        for (int i = errors.size() - 1; i > 0; --i) {\r\n            RuntimeException previous = errors.get(i - 1);\r\n            while (previous.getCause() != null) {\r\n                previous = (RuntimeException) previous.getCause();\r\n            }\r\n            previous.initCause(errors.get(i));\r\n        }\r\n        throw errors.get(0);\r\n    }\r\n}"
}, {
	"Path": "android.icu.util.GregorianCalendar.hashCode",
	"Comment": "override hashcode.generates the hash code for the gregoriancalendar object",
	"Method": "int hashCode(){\r\n    return super.hashCode() ^ (int) gregorianCutover;\r\n}"
}, {
	"Path": "android.icu.text.ScientificNumberFormatter.getSuperscriptInstance",
	"Comment": "gets a scientificnumberformatter instance that usessuperscript characters for exponents.",
	"Method": "ScientificNumberFormatter getSuperscriptInstance(ULocale locale,ScientificNumberFormatter getSuperscriptInstance,DecimalFormat df){\r\n    return getInstance(df, SUPER_SCRIPT);\r\n}"
}, {
	"Path": "android.icu.impl.ICUResourceBundle.getFullLocaleNameSet",
	"Comment": "return a set of all the locale names supported by a collection ofresource bundles.",
	"Method": "Set<String> getFullLocaleNameSet(Set<String> getFullLocaleNameSet,String bundlePrefix,ClassLoader loader,Set<String> getFullLocaleNameSet){\r\n    return getAvailEntry(bundlePrefix, loader).getFullLocaleNameSet();\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneGenericNames.findTimeZoneNames",
	"Comment": "returns a collection of time zone display name matches for the specified types in thegiven text at the given offset. this method only finds matches from the timezonenamesused by this object.",
	"Method": "Collection<MatchInfo> findTimeZoneNames(String text,int start,EnumSet<GenericNameType> types){\r\n    Collection<MatchInfo> tznamesMatches = null;\r\n    EnumSet<NameType> nameTypes = EnumSet.noneOf(NameType.class);\r\n    if (types.contains(GenericNameType.LONG)) {\r\n        nameTypes.add(NameType.LONG_GENERIC);\r\n        nameTypes.add(NameType.LONG_STANDARD);\r\n    }\r\n    if (types.contains(GenericNameType.SHORT)) {\r\n        nameTypes.add(NameType.SHORT_GENERIC);\r\n        nameTypes.add(NameType.SHORT_STANDARD);\r\n    }\r\n    if (!nameTypes.isEmpty()) {\r\n        tznamesMatches = _tznames.find(text, start, nameTypes);\r\n    }\r\n    return tznamesMatches;\r\n}"
}, {
	"Path": "android.icu.impl.duration.impl.PeriodFormatterData.appendSuffix",
	"Comment": "append the appropriate suffix to the string builder, depending on whether andhow a limit and direction are to be displayed.",
	"Method": "void appendSuffix(int tl,int td,StringBuffer sb){\r\n    if (dr.scopeData != null) {\r\n        int ix = tl * 3 + td;\r\n        ScopeData sd = dr.scopeData[ix];\r\n        if (sd != null) {\r\n            String suffix = sd.suffix;\r\n            if (suffix != null) {\r\n                if (trace) {\r\n                    System.out.println(\"appendSuffix '\" + suffix + \"'\");\r\n                }\r\n                sb.append(suffix);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.lang.UCharacter.forDigit",
	"Comment": "provide the java.lang.character fordigit api, for convenience.",
	"Method": "char forDigit(int digit,int radix){\r\n    return java.lang.Character.forDigit(digit, radix);\r\n}"
}, {
	"Path": "java.nio.charset.Charset.compareTo",
	"Comment": "compares this charset with the given charset. this comparison isbased on the case insensitive canonical names of the charsets.",
	"Method": "int compareTo(Charset charset){\r\n    return this.canonicalName.compareToIgnoreCase(charset.canonicalName);\r\n}"
}, {
	"Path": "android.icu.impl.TimeZoneGenericNames.getInstance",
	"Comment": "the factory method of timezonegenericnames. this static methodreturns a frozen instance of cached timezonegenericnames.",
	"Method": "TimeZoneGenericNames getInstance(ULocale locale){\r\n    String key = locale.getBaseName();\r\n    return GENERIC_NAMES_CACHE.getInstance(key, locale);\r\n}"
}, {
	"Path": "android.icu.impl.coll.CollationDataBuilder.copyContractionsFromBaseCE32",
	"Comment": "copies base contractions to a list of conditionalce32.sets cond.next to the index of the first new itemand returns the index of the last new item.",
	"Method": "int copyContractionsFromBaseCE32(StringBuilder context,int c,int ce32,ConditionalCE32 cond){\r\n    int trieIndex = Collation.indexFromCE32(ce32);\r\n    int index;\r\n    if ((ce32 & Collation.CONTRACT_SINGLE_CP_NO_MATCH) != 0) {\r\n        assert (context.length() > 1);\r\n        index = -1;\r\n    } else {\r\n        ce32 = base.getCE32FromContexts(trieIndex);\r\n        assert (!Collation.isContractionCE32(ce32));\r\n        ce32 = copyFromBaseCE32(c, ce32, true);\r\n        cond.next = index = addConditionalCE32(context.toString(), ce32);\r\n        cond = getConditionalCE32(index);\r\n    }\r\n    int suffixStart = context.length();\r\n    CharsTrie.Iterator suffixes = CharsTrie.iterator(base.contexts, trieIndex + 2, 0);\r\n    while (suffixes.hasNext()) {\r\n        CharsTrie.Entry entry = suffixes.next();\r\n        context.append(entry.chars);\r\n        ce32 = copyFromBaseCE32(c, entry.value, true);\r\n        cond.next = index = addConditionalCE32(context.toString(), ce32);\r\n        cond = getConditionalCE32(index);\r\n        context.setLength(suffixStart);\r\n    }\r\n    assert (index >= 0);\r\n    return index;\r\n}"
}, {
	"Path": "android.icu.impl.SimpleFormatterImpl.formatAndAppend",
	"Comment": "formats the given values, appending to the appendto builder.",
	"Method": "StringBuilder formatAndAppend(String compiledPattern,StringBuilder appendTo,int[] offsets,CharSequence values){\r\n    int valuesLength = values != null ? values.length : 0;\r\n    if (valuesLength < getArgumentLimit(compiledPattern)) {\r\n        throw new IllegalArgumentException(\"Too few values.\");\r\n    }\r\n    return format(compiledPattern, values, appendTo, null, true, offsets);\r\n}"
}, {
	"Path": "android.icu.text.Transliterator.unregister",
	"Comment": "unregisters a transliterator or class.this may be eithera system transliterator or a user transliterator or class.",
	"Method": "void unregister(String ID){\r\n    displayNameCache.remove(new CaseInsensitiveString(ID));\r\n    registry.remove(ID);\r\n}"
}, {
	"Path": "android.icu.text.MessageFormat.getFormatsByArgumentIndex",
	"Comment": "returns the format objects used for the values passed intoformat methods or returned from parsemethods. the indices of elements in the returned arraycorrespond to the argument indices used in the previously setpattern string.the order of formats in the returned array thus corresponds tothe order of elements in the arguments array passedto the format methods or the result array returnedby the parse methods.if an argument index is used for more than one format elementin the pattern string, then the format used for the last suchformat element is returned in the array. if an argument indexis not used for any format element in the pattern string, thennull is returned in the array.this method is only supported when exclusively numbers are used forargument names. otherwise an illegalargumentexception is thrown.",
	"Method": "Format[] getFormatsByArgumentIndex(){\r\n    if (msgPattern.hasNamedArguments()) {\r\n        throw new IllegalArgumentException(\"This method is not available in MessageFormat objects \" + \"that use alphanumeric argument names.\");\r\n    }\r\n    ArrayList<Format> list = new ArrayList<Format>();\r\n    for (int partIndex = 0; (partIndex = nextTopLevelArgStart(partIndex)) >= 0; ) {\r\n        int argNumber = msgPattern.getPart(partIndex + 1).getValue();\r\n        while (argNumber >= list.size()) {\r\n            list.add(null);\r\n        }\r\n        list.set(argNumber, cachedFormatters == null ? null : cachedFormatters.get(partIndex));\r\n    }\r\n    return list.toArray(new Format[list.size()]);\r\n}"
}, {
	"Path": "libcore.java.lang.CharacterTest.test_UnicodeScript_aliases",
	"Comment": "verify that the unicodescript.aliases map loads successfully.",
	"Method": "void test_UnicodeScript_aliases(){\r\n    assertEquals(Character.UnicodeScript.BALINESE, Character.UnicodeScript.forName(\"BALI\"));\r\n}"
}, {
	"Path": "android.icu.impl.Trie2.rangeEnd",
	"Comment": "find the last character in a contiguous range of characters with thesame trie2 value as the input character.",
	"Method": "int rangeEnd(int start,int limitp,int val){\r\n    int c;\r\n    int limit = Math.min(highStart, limitp);\r\n    for (c = start + 1; c < limit; c++) {\r\n        if (get(c) != val) {\r\n            break;\r\n        }\r\n    }\r\n    if (c >= highStart) {\r\n        c = limitp;\r\n    }\r\n    return c - 1;\r\n}"
}, {
	"Path": "android.icu.text.SimpleDateFormat.getPatternItems",
	"Comment": "returns parsed pattern items.each item is either string orpatternitem.",
	"Method": "Object[] getPatternItems(){\r\n    if (patternItems != null) {\r\n        return patternItems;\r\n    }\r\n    patternItems = PARSED_PATTERN_CACHE.get(pattern);\r\n    if (patternItems != null) {\r\n        return patternItems;\r\n    }\r\n    boolean isPrevQuote = false;\r\n    boolean inQuote = false;\r\n    StringBuilder text = new StringBuilder();\r\n    char itemType = 0;\r\n    int itemLength = 1;\r\n    List<Object> items = new ArrayList<Object>();\r\n    for (int i = 0; i < pattern.length(); i++) {\r\n        char ch = pattern.charAt(i);\r\n        if (ch == '\\'') {\r\n            if (isPrevQuote) {\r\n                text.append('\\'');\r\n                isPrevQuote = false;\r\n            } else {\r\n                isPrevQuote = true;\r\n                if (itemType != 0) {\r\n                    items.add(new PatternItem(itemType, itemLength));\r\n                    itemType = 0;\r\n                }\r\n            }\r\n            inQuote = !inQuote;\r\n        } else {\r\n            isPrevQuote = false;\r\n            if (inQuote) {\r\n                text.append(ch);\r\n            } else {\r\n                if (isSyntaxChar(ch)) {\r\n                    if (ch == itemType) {\r\n                        itemLength++;\r\n                    } else {\r\n                        if (itemType == 0) {\r\n                            if (text.length() > 0) {\r\n                                items.add(text.toString());\r\n                                text.setLength(0);\r\n                            }\r\n                        } else {\r\n                            items.add(new PatternItem(itemType, itemLength));\r\n                        }\r\n                        itemType = ch;\r\n                        itemLength = 1;\r\n                    }\r\n                } else {\r\n                    if (itemType != 0) {\r\n                        items.add(new PatternItem(itemType, itemLength));\r\n                        itemType = 0;\r\n                    }\r\n                    text.append(ch);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (itemType == 0) {\r\n        if (text.length() > 0) {\r\n            items.add(text.toString());\r\n            text.setLength(0);\r\n        }\r\n    } else {\r\n        items.add(new PatternItem(itemType, itemLength));\r\n    }\r\n    patternItems = items.toArray(new Object[items.size()]);\r\n    PARSED_PATTERN_CACHE.put(pattern, patternItems);\r\n    return patternItems;\r\n}"
}, {
	"Path": "android.icu.text.CharsetDetector.detect",
	"Comment": "return the charset that best matches the supplied input data.note though, that because the detection only looks at the start of the input data,there is a possibility that the returned charset will fail to handlethe full set of input data.raise an exception if no charset appears to match the data. no input text has been provided",
	"Method": "CharsetMatch detect(){\r\n    CharsetMatch[] matches = detectAll();\r\n    if (matches == null || matches.length == 0) {\r\n        return null;\r\n    }\r\n    return matches[0];\r\n}"
}, {
	"Path": "android.icu.util.BytesTrie.clone",
	"Comment": "clones this trie reader object and its state,but not the byte array which will be shared.",
	"Method": "Object clone(){\r\n    return super.clone();\r\n}"
}, {
	"Path": "android.icu.text.TransliteratorRegistry.remove",
	"Comment": "unregister an id.this removes an entry from the dynamic storeif there is one.the static locale resource store isunaffected.",
	"Method": "void remove(String ID){\r\n    String[] stv = TransliteratorIDParser.IDtoSTV(ID);\r\n    String id = TransliteratorIDParser.STVtoID(stv[0], stv[1], stv[2]);\r\n    registry.remove(new CaseInsensitiveString(id));\r\n    removeSTV(stv[0], stv[1], stv[2]);\r\n    availableIDs.remove(new CaseInsensitiveString(id));\r\n}"
}, {
	"Path": "android.icu.text.TimeZoneNames.find",
	"Comment": "finds time zone name prefix matches for the input text at thegiven offset and returns a collection of the matches.",
	"Method": "Collection<MatchInfo> find(CharSequence text,int start,EnumSet<NameType> types,Collection<MatchInfo> find,CharSequence text,int start,EnumSet<NameType> nameTypes){\r\n    throw new UnsupportedOperationException(\"The method is not implemented in TimeZoneNames base class.\");\r\n}"
}, {
	"Path": "android.icu.text.TimeZoneFormat.getTimeZoneNames",
	"Comment": "returns the time zone display name data used by this instance.",
	"Method": "TimeZoneNames getTimeZoneNames(){\r\n    return _tznames;\r\n}"
}]