[{
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.independentsamples.KolmogorovSmirnovIndependentSamplesTest.testTest",
	"Comment": "test of test method, of class kolmogorovsmirnovindependentsamples.",
	"Method": "void testTest(){\r\n    logger.info(\"test\");\r\n    TransposeDataList transposeDataList = new TransposeDataList();\r\n    transposeDataList.put(0, new FlatDataList(Arrays.asList(new Object[] { 15.9, 15.9, 16.0, 16.1, 16.1, 16.2, 16.3, 16.5, 15.5, 15.7, 15.8 })));\r\n    transposeDataList.put(1, new FlatDataList(Arrays.asList(new Object[] { 15.1, 15.2, 15.4, 15.6, 16.6, 16.8, 16.9, 15.7, 16.0, 16.3, 16.4 })));\r\n    boolean expResult = false;\r\n    boolean is_twoTailed = true;\r\n    double aLevel = 0.05;\r\n    boolean result = KolmogorovSmirnovIndependentSamples.test(transposeDataList, is_twoTailed, aLevel);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.BaseSimpleReactStream.of",
	"Comment": "create a sequential synchronous stream that runs on the current thread",
	"Method": "SimpleReactStream<T> of(T value,SimpleReactStream<T> of,T values){\r\n    return simpleReactStream((Stream) Stream.of(values));\r\n}"
}, {
	"Path": "cyclops.futurestream.Pipes.close",
	"Comment": "close the adapter identified by the provided key if it exists",
	"Method": "void close(String key){\r\n    Optional.ofNullable(registered.get(key)).ifPresent(a -> a.close());\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AssociativeArray.toFlatDataCollection",
	"Comment": "returns a flatdatacollection with the values of the internal map. the methoddoes not copy the data.",
	"Method": "FlatDataCollection toFlatDataCollection(){\r\n    return new FlatDataCollection(internalData.values());\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.json.JSONDeserializer.getInitialIdToObjectMap",
	"Comment": "set up the initial mapping from id to object, by adding the id of the toplevel object, if it has an id fieldin json.",
	"Method": "HashMap<CharSequence, Object> getInitialIdToObjectMap(Object objectInstance,Object parsedJSON){\r\n    final HashMap<CharSequence, Object> idToObjectInstance = new HashMap();\r\n    if (parsedJSON instanceof JSONObject) {\r\n        final JSONObject itemJsonObject = (JSONObject) parsedJSON;\r\n        if (itemJsonObject.items.size() > 0) {\r\n            final Entry<String, Object> firstItem = itemJsonObject.items.get(0);\r\n            if (firstItem.getKey().equals(JSONUtils.ID_KEY)) {\r\n                final Object firstItemValue = firstItem.getValue();\r\n                if (firstItemValue == null || !CharSequence.class.isAssignableFrom(firstItemValue.getClass())) {\r\n                    idToObjectInstance.put((CharSequence) firstItemValue, objectInstance);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return idToObjectInstance;\r\n}"
}, {
	"Path": "com.oath.cyclops.util.stream.scheduling.cron.CronExpression.getTimeZone",
	"Comment": "returns the time zone for which this cronexpressionwill be resolved.",
	"Method": "TimeZone getTimeZone(){\r\n    if (timeZone == null) {\r\n        timeZone = TimeZone.getDefault();\r\n    }\r\n    return timeZone;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.anova.Anova.twoWayTestEqualCellsEqualVars",
	"Comment": "wrapper function for twowaytestequalcellsequalvars, without passing the optional output table.",
	"Method": "boolean twoWayTestEqualCellsEqualVars(TransposeDataCollection2D twoFactorDataCollection,double aLevel,AssociativeArray2D outputTable,boolean twoWayTestEqualCellsEqualVars,TransposeDataCollection2D twoFactorDataCollection,double aLevel){\r\n    return twoWayTestEqualCellsEqualVars(twoFactorDataCollection, aLevel, null);\r\n}"
}, {
	"Path": "cyclops.kinds.CompletableFutureKind.narrowK",
	"Comment": "convert the higherkindedtype definition for a completablefuture into",
	"Method": "CompletableFuture<T> narrowK(Higher<DataWitness.completableFuture, T> completableFuture){\r\n    if (completableFuture instanceof CompletionStage) {\r\n        final CompletionStage<T> ft = (CompletionStage<T>) completableFuture;\r\n        return CompletableFuture.completedFuture(1).thenCompose(f -> ft);\r\n    }\r\n    final Box<T> type = (Box<T>) completableFuture;\r\n    final CompletionStage<T> stage = type.narrow();\r\n    return CompletableFuture.completedFuture(1).thenCompose(f -> stage);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.independentsamples.Fisher.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level.",
	"Method": "boolean test(int n11,int n12,int n21,int n22,double aLevel){\r\n    int ndot1 = n11 + n21;\r\n    int ndot2 = n12 + n22;\r\n    int n1dot = n11 + n12;\r\n    int n2dot = n21 + n22;\r\n    double pvalue = getPvalue(n11, ndot1, ndot2, n1dot, n2dot);\r\n    boolean rejectH0 = false;\r\n    if (pvalue <= aLevel) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.topologi.diffx.config.DiffXConfig.setGranularity",
	"Comment": "sets the granularity of text diffing for this configuration.",
	"Method": "void setGranularity(TextGranularity granularity){\r\n    if (granularity == null)\r\n        throw new NullPointerException(\"The granularity cannot be configured to be not be null.\");\r\n    this.granularity = granularity;\r\n}"
}, {
	"Path": "com.oath.cyclops.util.box.LazyImmutable.setOnce",
	"Comment": "set the value of this immutableclosedvalueif it has already been set will throw an exception",
	"Method": "LazyImmutable<T> setOnce(T val){\r\n    this.value.compareAndSet(UNSET, val);\r\n    set.set(true);\r\n    return this;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.ReadabilityStatisticsTest.testFlesch_kincaid_grade_level",
	"Comment": "test of fleschkincaidgradelevel method, of class readabilitystatistics.",
	"Method": "void testFlesch_kincaid_grade_level(){\r\n    logger.info(\"flesch_kincaid_grade_level\");\r\n    String strText = TEST_STRING;\r\n    double expResult = 112.3;\r\n    double result = ReadabilityStatistics.fleschKincaidGradeLevel(strText);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.concurrency.ForkJoinStream.forEach",
	"Comment": "executes foreach on the provided stream. if the stream is parallel, it isexecuted using the custom pool, else it is executed directly from themain thread.",
	"Method": "void forEach(Stream<T> stream,Consumer<? super T> action){\r\n    Runnable runnable = () -> stream.forEach(action);\r\n    ThreadMethods.forkJoinExecution(runnable, concurrencyConfiguration, stream.isParallel());\r\n}"
}, {
	"Path": "cyclops.kinds.OptionalKind.narrow",
	"Comment": "convert the raw higher kinded type for optionalkind types into the optionalkind type definition class",
	"Method": "OptionalKind<T> narrow(Higher<optional, T> future){\r\n    return (OptionalKind<T>) future;\r\n}"
}, {
	"Path": "io.github.classgraph.ClassGraph.whitelistJars",
	"Comment": "whitelist one or more jars. this will cause only the whitelisted jars to be scanned.",
	"Method": "ClassGraph whitelistJars(String jarLeafNames){\r\n    for (final String jarLeafName : jarLeafNames) {\r\n        final String leafName = JarUtils.leafName(jarLeafName);\r\n        if (!leafName.equals(jarLeafName)) {\r\n            throw new IllegalArgumentException(\"Can only whitelist jars by leafname: \" + jarLeafName);\r\n        }\r\n        scanSpec.jarWhiteBlackList.addToWhitelist(leafName);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.datumbox.framework.common.storage.abstracts.AbstractFileStorageEngine.createDirectoryIfNotExists",
	"Comment": "creates the directory in the target location if it does not exist.",
	"Method": "boolean createDirectoryIfNotExists(Path path){\r\n    if (!Files.exists(path)) {\r\n        Files.createDirectories(path);\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.onesample.WaldWolfowitz.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level.",
	"Method": "boolean test(FlatDataCollection flatDataCollection,double aLevel){\r\n    int U = 0;\r\n    Map<Object, Integer> Ni = new HashMap();\r\n    Object previousValue = null;\r\n    for (Object x : flatDataCollection) {\r\n        if (previousValue != null && !previousValue.equals(x)) {\r\n            ++U;\r\n        }\r\n        previousValue = x;\r\n        if (Ni.containsKey(x) == false) {\r\n            Ni.put(x, 1);\r\n        } else {\r\n            Ni.put(x, Ni.get(x) + 1);\r\n        }\r\n    }\r\n    if (Ni.size() != 2) {\r\n        throw new IllegalArgumentException(\"The collection must contain observations from 2 groups.\");\r\n    }\r\n    Object[] keys = Ni.keySet().toArray();\r\n    int n1 = Ni.get(keys[0]);\r\n    int n2 = Ni.get(keys[1]);\r\n    boolean rejectH0 = checkCriticalValue((double) U, n1, n2, aLevel);\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.github.dockerjava.api.model.Event.getStatus",
	"Comment": "status of docker image or container. list of statuses is available in docker api v.1.16",
	"Method": "String getStatus(){\r\n    return status;\r\n}"
}, {
	"Path": "cyclops.monads.transformers.reactor.MonoT.fromAnyM",
	"Comment": "construct an monot from an anym that contains a monad type that contains type other than monothe values in the underlying monad will be mapped to mono",
	"Method": "MonoT<W, A> fromAnyM(AnyM<W, A> anyM){\r\n    return of(anyM.map(Mono::just));\r\n}"
}, {
	"Path": "io.github.classgraph.AnnotationParameterValue.getClassNamesFromTypeDescriptors",
	"Comment": "get the names of any classes referenced in the annotation parameters.",
	"Method": "void getClassNamesFromTypeDescriptors(Set<String> referencedClassNames){\r\n    if (value != null) {\r\n        value.getClassNamesFromTypeDescriptors(referencedClassNames);\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.timeseries.SmoothingTest.testWeightedMovingAverage",
	"Comment": "test of weightedmovingaverage method, of class smoothing.",
	"Method": "void testWeightedMovingAverage(){\r\n    logger.info(\"weightedMovingAverage\");\r\n    FlatDataList flatDataList = generateFlatDataList();\r\n    int N = 3;\r\n    double expResult = 22.0;\r\n    double result = Smoothing.weightedMovingAverage(flatDataList, N);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.TextSimilarityTest.testOliverSimilarity",
	"Comment": "test of oliversimilarity method, of class textsimilarity.",
	"Method": "void testOliverSimilarity(){\r\n    logger.info(\"oliverSimilarity\");\r\n    String text1 = \"This book has been written against a background of both reckless optimism and reckless despair. It holds that Progress and Doom are two sides of the same medal; that both are articles of superstition, not of faith. It was written out of the conviction that it should be possible to discover the hidden mechanics by which all traditional elements of our political and spiritual world were dissolved into a conglomeration where everything seems to have lost specific value, and has become unrecognizable for human comprehension, unusable for human purpose. Hannah Arendt, The Origins of Totalitarianism (New York: Harcourt Brace Jovanovich, Inc., 1973 ed.), p.vii, Preface to the First Edition.\";\r\n    String text2 = \"The first edition of The Origins of Totalitarianism was written in 1950. Soon after the Second World War, this was a time of both reckless optimism and reckless despair. During this time, Dr. Arendt argues, the traditional elements of the political and spiritual world were dissolved into a conglomeration where everything seems to have lost specific value. In particular, the separation between the State and Society seems to have been destroyed. In this book, she seeks to disclose the hidden mechanics by which this transformation occurred.\";\r\n    double expResult = 0.4064777327935223;\r\n    double result = TextSimilarity.oliverSimilarity(text1, text2);\r\n    Assert.assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.SortedSetX.iterate",
	"Comment": "create a sortedsetx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "SortedSetX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).sortedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.storage.mapdb.MapDBEngine.blockedStorageClose",
	"Comment": "closes the provided storage and waits until all changes are written to disk. it should be used whenwe move the storage to a different location. returns true if the storage needed to be closed andfalse if it was not necessary.",
	"Method": "boolean blockedStorageClose(StorageType storageType){\r\n    DB storage = storageRegistry.get(storageType);\r\n    if (isOpenStorage(storage)) {\r\n        storage.commit();\r\n        Engine e = storage.getEngine();\r\n        while (EngineWrapper.class.isAssignableFrom(e.getClass())) {\r\n            e = ((EngineWrapper) e).getWrappedEngine();\r\n        }\r\n        storage.close();\r\n        while (!e.isClosed()) {\r\n            logger.trace(\"Waiting for the engine to close\");\r\n            try {\r\n                TimeUnit.MILLISECONDS.sleep(100);\r\n            } catch (InterruptedException ex) {\r\n                throw new RuntimeException(ex);\r\n            }\r\n        }\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.concurrency.WorkQueue.addWorkUnits",
	"Comment": "add multiple units of work. may be called by workers to add more work units to the tail of the queue.",
	"Method": "void addWorkUnits(Collection<T> workUnits){\r\n    for (final T workUnit : workUnits) {\r\n        addWorkUnit(workUnit);\r\n    }\r\n}"
}, {
	"Path": "com.spotify.docker.client.auth.gcr.ContainerRegistryAuthSupplier.fromStream",
	"Comment": "constructs a containerregistryauthsupplier for the account with the given credentials.",
	"Method": "Builder fromStream(InputStream credentialsStream){\r\n    final GoogleCredentials credentials = GoogleCredentials.fromStream(credentialsStream);\r\n    return new Builder(credentials);\r\n}"
}, {
	"Path": "com.spotify.docker.client.messages.DockerInfoTest.dockerInfoNetworkDesirializerTest_1_23",
	"Comment": "test that when we deserialize the docker info response we properly parse various fields.",
	"Method": "void dockerInfoNetworkDesirializerTest_1_23(){\r\n    Info info = objectMapper.readValue(fixture(\"fixtures/1.23/docker_info.json\"), Info.class);\r\n    assertThat(info.plugins(), is(not(nullValue())));\r\n    assertThat(info.plugins().networks(), is(not(nullValue())));\r\n    assertThat(info.plugins().networks().size(), is(greaterThan(0)));\r\n    assertThat(info.plugins().volumes(), is(not(nullValue())));\r\n    assertThat(info.plugins().volumes().size(), is(greaterThan(0)));\r\n}"
}, {
	"Path": "cyclops.monads.transformers.reactor.MonoT.of",
	"Comment": "construct an monot from an anym that wraps a monad containingmonows",
	"Method": "MonoT<W, A> of(AnyM<W, Mono<A>> monads){\r\n    return new MonoT(monads);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.mathematics.distances.Distance.manhattan",
	"Comment": "estimates the manhattan distance of two associative arrays.",
	"Method": "double manhattan(AssociativeArray a1,AssociativeArray a2){\r\n    Map<Object, Double> columnDistances = columnDistances(a1, a2, null);\r\n    double distance = 0.0;\r\n    for (double columnDistance : columnDistances.values()) {\r\n        distance += Math.abs(columnDistance);\r\n    }\r\n    return distance;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.ReadabilityStatisticsTest.testSpache_score",
	"Comment": "test of spachescore method, of class readabilitystatistics.",
	"Method": "void testSpache_score(){\r\n    logger.info(\"spache_score\");\r\n    String strText = TEST_STRING;\r\n    double expResult = 41.523999999999994;\r\n    double result = ReadabilityStatistics.spacheScore(strText);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.ElementState.matchCurrent",
	"Comment": "indicates whether the specified event is a close element thatmatches the name and uri of the current open element.",
	"Method": "boolean matchCurrent(DiffXEvent e){\r\n    if (isEmpty())\r\n        return false;\r\n    if (!(e instanceof CloseElementEvent))\r\n        return false;\r\n    return ((CloseElementEvent) e).match(current());\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.parsers.HTMLParser.unsafeRemoveAllTags",
	"Comment": "a fast way but unsafe way to remove the tags from an html string. the methoddoes not remove javascript, css and other non text blocks and thus it shouldbe used with caution.",
	"Method": "String unsafeRemoveAllTags(String html){\r\n    return html.replaceAll(\"\\\\<.*?>\", \" \");\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.extractors.AbstractTextExtractor.generateTokenizer",
	"Comment": "generates a new abstracttokenizer object by using the provided tokenizer class.",
	"Method": "AbstractTokenizer generateTokenizer(){\r\n    Class<? extends AbstractTokenizer> tokenizer = parameters.getTokenizer();\r\n    if (tokenizer == null) {\r\n        return null;\r\n    }\r\n    try {\r\n        return tokenizer.newInstance();\r\n    } catch (InstantiationException | IllegalAccessException ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.utilities.PHPMethods.asort",
	"Comment": "sorts an array in ascending order and returns an array with indexes of the original order.",
	"Method": "Integer[] asort(T[] array){\r\n    return _asort(array, false);\r\n}"
}, {
	"Path": "com.github.dcevm.HotSwapTool.toVersion",
	"Comment": "redefines all inner classes of a outer class to a specified version. inner classes who do not have a particularrepresentation for a version remain unchanged.",
	"Method": "void toVersion(Class<?> outerClass,int versionNumber,Class<?> extraClasses){\r\n    assert versionNumber >= 0;\r\n    if (versionNumber == getCurrentVersion(outerClass)) {\r\n        return;\r\n    }\r\n    Map<String, File> files = findClassesWithVersion(outerClass, versionNumber);\r\n    for (Class<?> extra : extraClasses) {\r\n        if (parseClassVersion(extra.getSimpleName()) == versionNumber) {\r\n            String packageName = extra.getPackage().getName().replace('.', '/');\r\n            URL url = extra.getClassLoader().getResource(packageName);\r\n            if (url == null) {\r\n                throw new IllegalArgumentException(\"Cannot find URL corresponding to the package '\" + packageName + \"'\");\r\n            }\r\n            File file = new File(url.getFile(), extra.getSimpleName() + \".class\");\r\n            files.put(extra.getName(), file);\r\n        }\r\n    }\r\n    try {\r\n        Map<Class<?>, byte[]> map = buildRedefinitionMap(files);\r\n        long startTime = System.currentTimeMillis();\r\n        redefiner.redefineClasses(map);\r\n        long curTime = System.currentTimeMillis() - startTime;\r\n        totalTime += curTime;\r\n        redefinitionCount++;\r\n    } catch (UnmodifiableClassException e) {\r\n        throw new UnsupportedOperationException(e);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new RuntimeException(\"Cannot redefine classes\", e);\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(\"Cannot redefine classes\", e);\r\n    }\r\n    setCurrentVersion(outerClass, versionNumber);\r\n}"
}, {
	"Path": "com.oath.cyclops.anym.AnyMSeq.forEach4",
	"Comment": "perform a four level nested internal iteration over this monad and thesupplied monads",
	"Method": "AnyMSeq<W, R> forEach4(Function<? super T, ? extends AnyM<W, R1>> monad1,BiFunction<? super T, ? super R1, ? extends AnyM<W, R2>> monad2,Function3<? super T, ? super R1, ? super R2, ? extends AnyM<W, R3>> monad3,Function4<? super T, ? super R1, ? super R2, ? super R3, ? extends R> yieldingFunction,AnyMSeq<W, R> forEach4,Function<? super T, ? extends AnyM<W, R1>> monad1,BiFunction<? super T, ? super R1, ? extends AnyM<W, R2>> monad2,Function3<? super T, ? super R1, ? super R2, ? extends AnyM<W, R3>> monad3,Function4<? super T, ? super R1, ? super R2, ? super R3, Boolean> filterFunction,Function4<? super T, ? super R1, ? super R2, ? super R3, ? extends R> yieldingFunction){\r\n    return this.flatMapA(in -> {\r\n        AnyM<W, R1> a = monad1.apply(in);\r\n        return a.flatMapA(ina -> {\r\n            AnyM<W, R2> b = monad2.apply(in, ina);\r\n            return b.flatMapA(inb -> {\r\n                AnyM<W, R3> c = monad3.apply(in, ina, inb);\r\n                return c.filter(in2 -> filterFunction.apply(in, ina, inb, in2)).map(in2 -> yieldingFunction.apply(in, ina, inb, in2));\r\n            });\r\n        });\r\n    });\r\n}"
}, {
	"Path": "io.github.classgraph.ClassGraph.blacklistClasspathElementsContainingResourcePath",
	"Comment": "blacklist classpath elements based on resource paths. classpath elements that contain resources with pathsmatching the blacklist will not be scanned.",
	"Method": "ClassGraph blacklistClasspathElementsContainingResourcePath(String resourcePaths){\r\n    for (final String resourcePath : resourcePaths) {\r\n        scanSpec.classpathElementResourcePathWhiteBlackList.addToBlacklist(resourcePath);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.DataframeMatrix.parseRecord",
	"Comment": "parses a single record and converts it to realvector by using an alreadyexisting mapping between feature names and column ids.",
	"Method": "RealVector parseRecord(Record r,Map<Object, Integer> featureIdsReference){\r\n    if (featureIdsReference.isEmpty()) {\r\n        throw new IllegalArgumentException(\"The featureIdsReference map should not be empty.\");\r\n    }\r\n    int d = featureIdsReference.size();\r\n    RealVector v = (storageEngine != null) ? new MapRealVector(d) : new OpenMapRealVector(d);\r\n    boolean addConstantColumn = featureIdsReference.containsKey(Dataframe.COLUMN_NAME_CONSTANT);\r\n    if (addConstantColumn) {\r\n        v.setEntry(0, 1.0);\r\n    }\r\n    for (Map.Entry<Object, Object> entry : r.getX().entrySet()) {\r\n        Object feature = entry.getKey();\r\n        Double value = TypeInference.toDouble(entry.getValue());\r\n        if (value != null) {\r\n            Integer featureId = featureIdsReference.get(feature);\r\n            if (featureId != null) {\r\n                v.setEntry(featureId, value);\r\n            }\r\n        } else {\r\n        }\r\n    }\r\n    return v;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributions.betaCdf",
	"Comment": "calculates the probability from 0 to x under beta distribution",
	"Method": "double betaCdf(double x,double a,double b){\r\n    if (x < 0 || a <= 0 || b <= 0) {\r\n        throw new IllegalArgumentException(\"All the parameters must be positive.\");\r\n    }\r\n    double Bcdf = 0.0;\r\n    if (x == 0) {\r\n        return Bcdf;\r\n    } else if (x >= 1) {\r\n        Bcdf = 1.0;\r\n        return Bcdf;\r\n    }\r\n    double S = a + b;\r\n    double BT = Math.exp(logGamma(S) - logGamma(b) - logGamma(a) + a * Math.log(x) + b * Math.log(1 - x));\r\n    if (x < (a + 1.0) / (S + 2.0)) {\r\n        Bcdf = BT * betinc(x, a, b);\r\n    } else {\r\n        Bcdf = 1.0 - BT * betinc(1.0 - x, b, a);\r\n    }\r\n    return Bcdf;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.BagX.range",
	"Comment": "create a bagx that contains the integers between skip and take",
	"Method": "BagX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).bagX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "org.fourthline.cling.registry.RemoteItems.remove",
	"Comment": "removes the given device from the registry and notifies registry listeners.",
	"Method": "boolean remove(RemoteDevice remoteDevice,boolean remove,RemoteDevice remoteDevice,boolean shuttingDown){\r\n    final RemoteDevice registeredDevice = get(remoteDevice.getIdentity().getUdn(), true);\r\n    if (registeredDevice != null) {\r\n        log.fine(\"Removing remote device from registry: \" + remoteDevice);\r\n        for (Resource deviceResource : getResources(registeredDevice)) {\r\n            if (registry.removeResource(deviceResource)) {\r\n                log.fine(\"Unregistered resource: \" + deviceResource);\r\n            }\r\n        }\r\n        Iterator<RegistryItem<String, RemoteGENASubscription>> it = getSubscriptionItems().iterator();\r\n        while (it.hasNext()) {\r\n            final RegistryItem<String, RemoteGENASubscription> outgoingSubscription = it.next();\r\n            UDN subscriptionForUDN = outgoingSubscription.getItem().getService().getDevice().getIdentity().getUdn();\r\n            if (subscriptionForUDN.equals(registeredDevice.getIdentity().getUdn())) {\r\n                log.fine(\"Removing outgoing subscription: \" + outgoingSubscription.getKey());\r\n                it.remove();\r\n                if (!shuttingDown) {\r\n                    registry.getConfiguration().getRegistryListenerExecutor().execute(new Runnable() {\r\n                        public void run() {\r\n                            outgoingSubscription.getItem().end(CancelReason.DEVICE_WAS_REMOVED, null);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        if (!shuttingDown) {\r\n            for (final RegistryListener listener : registry.getListeners()) {\r\n                registry.getConfiguration().getRegistryListenerExecutor().execute(new Runnable() {\r\n                    public void run() {\r\n                        listener.remoteDeviceRemoved(registry, registeredDevice);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        getDeviceItems().remove(new RegistryItem(registeredDevice.getIdentity().getUdn()));\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.fourthline.cling.registry.RemoteItems.remove",
	"Comment": "removes the given device from the registry and notifies registry listeners.",
	"Method": "boolean remove(RemoteDevice remoteDevice,boolean remove,RemoteDevice remoteDevice,boolean shuttingDown){\r\n    outgoingSubscription.getItem().end(CancelReason.DEVICE_WAS_REMOVED, null);\r\n}"
}, {
	"Path": "org.fourthline.cling.registry.RemoteItems.remove",
	"Comment": "removes the given device from the registry and notifies registry listeners.",
	"Method": "boolean remove(RemoteDevice remoteDevice,boolean remove,RemoteDevice remoteDevice,boolean shuttingDown){\r\n    listener.remoteDeviceRemoved(registry, registeredDevice);\r\n}"
}, {
	"Path": "buildcraft.transport.utils.TransportUtils.getPipeFloorOf",
	"Comment": "right. depending on the item in the pipe. because this function somehow does that with a single line.",
	"Method": "float getPipeFloorOf(ItemStack item){\r\n    return CoreConstants.PIPE_MIN_POS;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentQueueX.widen2",
	"Comment": "widen a persistentqueuex nest inside another hkt encoded type",
	"Method": "Higher<C2, Higher<persistentQueueX, T>> widen2(Higher<C2, PersistentQueueX<T>> list){\r\n    return (Higher) list;\r\n}"
}, {
	"Path": "com.datumbox.framework.applications.nlp.TextClassifierTest.testTrainAndValidateTFIDF",
	"Comment": "test of train and validate method, of class textclassifier using tfidf.",
	"Method": "void testTrainAndValidateTFIDF(){\r\n    logger.info(\"testTrainAndValidateTFIDF\");\r\n    MultinomialNaiveBayes.TrainingParameters mlParams = new MultinomialNaiveBayes.TrainingParameters();\r\n    TFIDF.TrainingParameters fsParams = new TFIDF.TrainingParameters();\r\n    fsParams.setMaxFeatures(1000);\r\n    trainAndValidate(mlParams, fsParams, null, 0.80461962936161, 9);\r\n}"
}, {
	"Path": "cyclops.futurestream.FutureStream.permutations",
	"Comment": "generate the permutations based on values in the futurestreammakes use of streamable to store intermediate stages in a tox",
	"Method": "FutureStream<ReactiveSeq<U>> permutations(){\r\n    return this.fromStream(ReactiveSeq.oneShotStream(stream()).permutations());\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.TransposeDataList.remove",
	"Comment": "removes a particular key from the internal map and returns the value associated with that key if present in the map.",
	"Method": "FlatDataList remove(Object key){\r\n    return internalData.remove(key);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.descriptivestatistics.Descriptives.autocorrelation",
	"Comment": "calculates the autocorrelation of a flatdatacollection for a predifined lag",
	"Method": "double autocorrelation(FlatDataList flatDataList,int lags){\r\n    int n = count(flatDataList);\r\n    if (n <= 0 || lags <= 0 || n < lags) {\r\n        throw new IllegalArgumentException(\"All the parameters must be positive and n larger than lags.\");\r\n    }\r\n    FlatDataCollection flatDataCollection = flatDataList.toFlatDataCollection();\r\n    double mean = mean(flatDataCollection);\r\n    double variance = variance(flatDataCollection, true);\r\n    double Ak = 0.0;\r\n    int maxI = n - lags;\r\n    for (int i = 0; i < maxI; ++i) {\r\n        Ak += (flatDataList.getDouble(i) - mean) * (flatDataList.getDouble(i + lags) - mean);\r\n    }\r\n    Ak /= (n - lags);\r\n    double autocorrelation = Ak / variance;\r\n    return autocorrelation;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.ensemblelearning.FixedCombinationRules.product",
	"Comment": "combines the responses of the classifiers by using estimating the productof the probabilities of their responses.",
	"Method": "AssociativeArray product(DataTable2D classifierClassProbabilityMatrix){\r\n    AssociativeArray combinedClassProbabilities = new AssociativeArray();\r\n    for (Map.Entry<Object, AssociativeArray> entry : classifierClassProbabilityMatrix.entrySet()) {\r\n        AssociativeArray listOfClassProbabilities = entry.getValue();\r\n        for (Map.Entry<Object, Object> entry2 : listOfClassProbabilities.entrySet()) {\r\n            Object theClass = entry2.getKey();\r\n            Double probability = TypeInference.toDouble(entry2.getValue());\r\n            Double previousValue = combinedClassProbabilities.getDouble(theClass);\r\n            if (previousValue == null) {\r\n                previousValue = 1.0;\r\n            }\r\n            combinedClassProbabilities.put(theClass, previousValue * probability);\r\n        }\r\n    }\r\n    return combinedClassProbabilities;\r\n}"
}, {
	"Path": "cyclops.companion.Streamable.permutations",
	"Comment": "generate the permutations based on values in the streamable",
	"Method": "Streamable<ReactiveSeq<T>> permutations(){\r\n    return Streamable.fromStream(stream().permutations());\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.zip",
	"Comment": "zip two streams, zipping against the underlying futures of this stream",
	"Method": "SimpleReactStream<Tuple2<U, R>> zip(Stream<R> other,SimpleReactStream<Tuple2<U, R>> zip,SimpleReactStream<R> other){\r\n    final ReactiveSeq seq = ReactiveSeq.fromStream(getLastActive().stream()).zip(ReactiveSeq.fromStream(other.getLastActive().stream()));\r\n    final ReactiveSeq<Tuple2<CompletableFuture<U>, CompletableFuture<R>>> withType = seq;\r\n    final SimpleReactStream futureStream = fromStreamOfFutures((Stream) withType.map(t -> CompletableFuture.allOf(t._1(), t._2()).thenApply(v -> Tuple.tuple(t._1().join(), t._2().join()))));\r\n    return futureStream;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.independentsamples.MannWhitney.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level.",
	"Method": "boolean test(TransposeDataCollection transposeDataCollection,boolean is_twoTailed,double aLevel){\r\n    double pvalue = getPvalue(transposeDataCollection);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2;\r\n    }\r\n    if (pvalue <= a || pvalue >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.topologi.diffx.Extension.getFactoryClass",
	"Comment": "returns the factory class to use based on the given nodelists.",
	"Method": "String getFactoryClass(Node xml1,Node xml2){\r\n    Package pkg = xml1 != null ? xml1.getClass().getPackage() : xml2 != null ? xml2.getClass().getPackage() : null;\r\n    return BUILDERS.get(pkg.getName());\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentQueueX.narrowK",
	"Comment": "convert the raw higher kinded type for pqueue types into the pqueuetype type definition class",
	"Method": "PersistentQueueX<T> narrowK(Higher<persistentQueueX, T> list){\r\n    return (PersistentQueueX<T>) list;\r\n}"
}, {
	"Path": "com.datumbox.framework.common.Configuration.getConfiguration",
	"Comment": "creates a new configuration object based on the property file.",
	"Method": "Configuration getConfiguration(){\r\n    return ConfigurableFactory.getConfiguration(Configuration.class);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.SortedSetX.generate",
	"Comment": "generate a sortedsetx from the provided supplier up to the provided limit number of times",
	"Method": "SortedSetX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).sortedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.spotify.docker.client.DockerConfigReader.anyRegistryAuth",
	"Comment": "return a single registryauth from the config file.if there are multiple registryauth entries, which entry is returned from this methoddepends on hashing and should not be considered reliable.if there is only one entry, however, that will be the one returned. this is theprimary use of this method, as a useful way to extract a registryauth during testing.in that environment, the contents of the config file are known and controlled. in aproduction environment, the contents of the config file are less predictable.",
	"Method": "RegistryAuth anyRegistryAuth(RegistryAuth anyRegistryAuth,Path configPath){\r\n    final ImmutableCollection<RegistryAuth> registryAuths = authForAllRegistries(configPath).configs().values();\r\n    return registryAuths.isEmpty() ? RegistryAuth.builder().build() : registryAuths.iterator().next();\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.concurrency.SingletonMap.createSingleton",
	"Comment": "initialize a value object for this key and return true, if this is the first time this key has been seen,otherwise return false.",
	"Method": "boolean createSingleton(K key,LogNode log){\r\n    SingletonHolder<V> newSingletonHolder = singletonHolderRecycler.poll();\r\n    if (newSingletonHolder == null) {\r\n        newSingletonHolder = new SingletonHolder();\r\n    }\r\n    final SingletonHolder<V> oldSingletonHolder = map.putIfAbsent(key, newSingletonHolder);\r\n    if (oldSingletonHolder == null) {\r\n        V newInstance = null;\r\n        try {\r\n            newInstance = newInstance(key, log);\r\n            if (newInstance == null) {\r\n                throw new IllegalArgumentException(\"newInstance(key) returned null\");\r\n            }\r\n        } finally {\r\n            newSingletonHolder.set(newInstance);\r\n        }\r\n        return true;\r\n    } else {\r\n        singletonHolderRecycler.add(newSingletonHolder);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.Dataframe.retainAll",
	"Comment": "retains only the elements in this collection that are contained in thespecified collection and updates the meta data.",
	"Method": "boolean retainAll(Collection<?> c){\r\n    boolean modified = false;\r\n    for (Map.Entry<Integer, Record> e : entries()) {\r\n        Integer rId = e.getKey();\r\n        Record r = e.getValue();\r\n        if (!c.contains(r)) {\r\n            remove(rId);\r\n            modified = true;\r\n        }\r\n    }\r\n    if (modified) {\r\n        recalculateMeta();\r\n    }\r\n    return modified;\r\n}"
}, {
	"Path": "cyclops.function.Memoize.memoizeBiFunctionAsync",
	"Comment": "memoize this function and update cached values on a scheduledoes not support null keys",
	"Method": "Function2<T1, T2, R> memoizeBiFunctionAsync(BiFunction<T1, T2, R> fn,ScheduledExecutorService ex,long updateRateInMillis,Function2<T1, T2, R> memoizeBiFunctionAsync,BiFunction<T1, T2, R> fn,ScheduledExecutorService ex,String cron){\r\n    val memoise2 = memoizeFunctionAsync((final Tuple2<T1, T2> pair) -> fn.apply(pair._1(), pair._2()), ex, cron);\r\n    return (t1, t2) -> memoise2.apply(tuple(t1, t2));\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AssociativeArray.copy2Unmodifiable",
	"Comment": "copies the provided associativearray and builds a new which is unmodifiable.",
	"Method": "AssociativeArray copy2Unmodifiable(AssociativeArray original){\r\n    Map<Object, Object> internalData = new LinkedHashMap();\r\n    internalData.putAll(original.internalData);\r\n    internalData = Collections.unmodifiableMap(internalData);\r\n    return new AssociativeArray(internalData);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentSetX.rangeLong",
	"Comment": "create a persistentsetx that contains the longs between skip and take",
	"Method": "PersistentSetX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).persistentSetX(LAZY);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.VectorX.rangeLong",
	"Comment": "create a vectorx that contains the longs between skip and take",
	"Method": "VectorX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).vectorX(LAZY);\r\n}"
}, {
	"Path": "com.oath.cyclops.util.box.LazyImmutable.map",
	"Comment": "map the value stored in this immutable closed value from one value to anotherif this is an unitiatilised immutableclosedvalue, an uninitialised closed value will be returned instead",
	"Method": "LazyImmutable<R> map(Function<? super T, ? extends R> fn){\r\n    final T val = get();\r\n    if (val == UNSET)\r\n        return (LazyImmutable<R>) this;\r\n    else\r\n        return LazyImmutable.of(fn.apply(val));\r\n}"
}, {
	"Path": "io.github.classgraph.ClassfileBinaryParser.getConstantPoolStringOffset",
	"Comment": "get the byte offset within the buffer of a string from the constant pool, or 0 for a null string.",
	"Method": "int getConstantPoolStringOffset(int cpIdx,int subFieldIdx){\r\n    final int t = tag[cpIdx];\r\n    if ((t != 12 && subFieldIdx != 0) || (t == 12 && subFieldIdx != 0 && subFieldIdx != 1)) {\r\n        throw new IOException(\"Bad subfield index \" + subFieldIdx + \" for tag \" + t + \", cannot continue reading class. \" + \"Please report this at https://github.com/classgraph/classgraph/issues\");\r\n    }\r\n    int cpIdxToUse;\r\n    if (t == 0) {\r\n        return 0;\r\n    } else if (t == 1) {\r\n        cpIdxToUse = cpIdx;\r\n    } else if (t == 7 || t == 8) {\r\n        final int indirIdx = indirectStringRefs[cpIdx];\r\n        if (indirIdx == -1) {\r\n            throw new IOException(\"Bad string indirection index, cannot continue reading class. \" + \"Please report this at https://github.com/classgraph/classgraph/issues\");\r\n        }\r\n        if (indirIdx == 0) {\r\n            return 0;\r\n        }\r\n        cpIdxToUse = indirIdx;\r\n    } else if (t == 12) {\r\n        final int compoundIndirIdx = indirectStringRefs[cpIdx];\r\n        final int indirIdx = (subFieldIdx == 0 ? (compoundIndirIdx >> 16) : compoundIndirIdx) & 0xffff;\r\n        if (indirIdx == 0) {\r\n            throw new IOException(\"Bad string indirection index, cannot continue reading class. \" + \"Please report this at https://github.com/classgraph/classgraph/issues\");\r\n        }\r\n        cpIdxToUse = indirIdx;\r\n    } else {\r\n        throw new IOException(\"Wrong tag number \" + t + \" at constant pool index \" + cpIdx + \", \" + \"cannot continue reading class. Please report this at \" + \"https://github.com/classgraph/classgraph/issues\");\r\n    }\r\n    return offset[cpIdxToUse];\r\n}"
}, {
	"Path": "cyclops.monads.transformers.jdk.CompletableFutureT.fromAnyM",
	"Comment": "construct an futuret from an anym that contains a monad type that contains type other than futurethe values in the underlying monad will be mapped to completablefuture",
	"Method": "CompletableFutureT<W, A> fromAnyM(AnyM<W, A> anyM){\r\n    return of(anyM.map(e -> {\r\n        CompletableFuture<A> f = new CompletableFuture<A>();\r\n        f.complete(e);\r\n        return f;\r\n    }));\r\n}"
}, {
	"Path": "cyclops.function.Function1.after",
	"Comment": "apply more advice to this function capturing both the input and the emitted with the provided biconsumer",
	"Method": "Function1<T, R> after(BiConsumer<? super T, ? super R> action){\r\n    return FluentFunctions.of(this).after(action);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.ReadabilityStatisticsTest.testGunning_fog_score",
	"Comment": "test of gunningfogscore method, of class readabilitystatistics.",
	"Method": "void testGunning_fog_score(){\r\n    logger.info(\"gunning_fog_score\");\r\n    String strText = TEST_STRING;\r\n    double expResult = 118.0;\r\n    double result = ReadabilityStatistics.gunningFogScore(strText);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "buildcraft.core.lib.EntityResizableCuboid.makeClient",
	"Comment": "a simple method to initialise all client side only variables if they have not already been initialised.",
	"Method": "void makeClient(){\r\n    if (textures == null) {\r\n        textures = new TextureAtlasSprite[6];\r\n        Arrays.fill(textures, texture);\r\n    }\r\n    if (textureFlips == null) {\r\n        textureFlips = new int[6];\r\n    }\r\n}"
}, {
	"Path": "com.oath.cyclops.async.adapters.Queue.add",
	"Comment": "add a single data point to the queueif the queue is a bounded queue and is full, will return false",
	"Method": "boolean add(T data){\r\n    try {\r\n        final boolean result = queue.add((T) nullSafe(data));\r\n        if (result) {\r\n            if (sizeSignal != null)\r\n                this.sizeSignal.set(queue.size());\r\n        }\r\n        return result;\r\n    } catch (final IllegalStateException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.jak_linux.dns66.vpn.DnsPacketProxy.translateDestinationAdress",
	"Comment": "translates the destination address in the packet to the real one. incase address translation is not used, this just returns the original one.",
	"Method": "InetAddress translateDestinationAdress(IpPacket parsedPacket){\r\n    InetAddress destAddr = null;\r\n    if (upstreamDnsServers.size() > 0) {\r\n        byte[] addr = parsedPacket.getHeader().getDstAddr().getAddress();\r\n        int index = addr[addr.length - 1] - 2;\r\n        try {\r\n            destAddr = upstreamDnsServers.get(index);\r\n        } catch (Exception e) {\r\n            Log.e(TAG, \"handleDnsRequest: Cannot handle packets to\" + parsedPacket.getHeader().getDstAddr().getHostAddress(), e);\r\n            return null;\r\n        }\r\n        Log.d(TAG, String.format(\"handleDnsRequest: Incoming packet to %s AKA %d AKA %s\", parsedPacket.getHeader().getDstAddr().getHostAddress(), index, destAddr));\r\n    } else {\r\n        destAddr = parsedPacket.getHeader().getDstAddr();\r\n        Log.d(TAG, String.format(\"handleDnsRequest: Incoming packet to %s - is upstream\", parsedPacket.getHeader().getDstAddr().getHostAddress()));\r\n    }\r\n    return destAddr;\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.GuanoAlgorithm.setupMatrix",
	"Comment": "determines the most appropriate matrix to use.calculates the maximum length of the shortest weighted path if both sequencesare totally different, which corresponds to the sum of all the events.",
	"Method": "Matrix setupMatrix(EventSequence s1,EventSequence s2){\r\n    int max = 0;\r\n    for (int i = 0; i < s1.size(); i++) {\r\n        max += s1.getEvent(i).getWeight();\r\n    }\r\n    for (int i = 0; i < s2.size(); i++) {\r\n        max += s2.getEvent(i).getWeight();\r\n    }\r\n    if (max > Short.MAX_VALUE)\r\n        return new MatrixInt();\r\n    else\r\n        return new MatrixShort();\r\n}"
}, {
	"Path": "buildcraft.core.lib.utils.Utils.get2dOrientation",
	"Comment": "returns the cardinal direction of the entity depending on its rotationyaw",
	"Method": "EnumFacing get2dOrientation(EntityLivingBase entityliving){\r\n    return entityliving.getHorizontalFacing();\r\n}"
}, {
	"Path": "buildcraft.core.lib.utils.Utils.vec3i",
	"Comment": "factory that returns a new blockpos with the same argument for x, y and z.",
	"Method": "BlockPos vec3i(int value){\r\n    return new BlockPos(value, value, value);\r\n}"
}, {
	"Path": "buildcraft.core.lib.utils.Utils.vec3f",
	"Comment": "factory that returns a new vector3f with the same argument for x, y and z.",
	"Method": "Vector3f vec3f(float value){\r\n    return new Vector3f(value, value, value);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.onesample.ChisquareOneSampleTest.testTestVariance",
	"Comment": "test of testvariance method, of class chisquareonesample.",
	"Method": "void testTestVariance(){\r\n    logger.info(\"testVariance\");\r\n    double stdbar = 0.0063;\r\n    int n = 100;\r\n    double H0std = 0.01;\r\n    boolean is_twoTailed = true;\r\n    double aLevel = 0.05;\r\n    boolean expResult = true;\r\n    boolean result = ChisquareOneSample.testVariance(stdbar, n, H0std, is_twoTailed, aLevel);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.StratifiedSampling.randomSampling",
	"Comment": "samples nh ids from each strata by using stratified sampling",
	"Method": "TransposeDataCollection randomSampling(TransposeDataList strataIdList,AssociativeArray nh,boolean withReplacement){\r\n    TransposeDataCollection sampledIds = new TransposeDataCollection();\r\n    for (Map.Entry<Object, FlatDataList> entry : strataIdList.entrySet()) {\r\n        Object strata = entry.getKey();\r\n        Number sampleN = ((Number) nh.get(strata));\r\n        if (sampleN == null) {\r\n            continue;\r\n        }\r\n        sampledIds.put(strata, SimpleRandomSampling.randomSampling(entry.getValue(), sampleN.intValue(), withReplacement));\r\n    }\r\n    return sampledIds;\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.ElementState.okDelete",
	"Comment": "indicates whether the specified event is a close element thatmatches the name and uri of the current open element.",
	"Method": "boolean okDelete(DiffXEvent e){\r\n    if (!(e instanceof CloseElementEvent))\r\n        return true;\r\n    if (isEmpty())\r\n        return false;\r\n    return ((CloseElementEvent) e).match(current()) && this.openChanges[this.size - 1] == '-';\r\n}"
}, {
	"Path": "buildcraft.core.lib.utils.Utils.vec3",
	"Comment": "factory that returns a new vec3d with the same argument for x, y and z.",
	"Method": "Vec3d vec3(double value){\r\n    return new Vec3d(value, value, value);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.tokenizers.WhitespaceTokenizer.tokenize",
	"Comment": "separates the tokens of a string by splitting it on white space.",
	"Method": "List<String> tokenize(String text){\r\n    List<String> tokens = new ArrayList(Arrays.asList(text.split(\"[\\\\p{Z}\\\\p{C}]+\")));\r\n    return tokens;\r\n}"
}, {
	"Path": "io.github.classgraph.PackageInfo.getAnnotationInfo",
	"Comment": "get a the named annotation on this package, or null if the package does not have the named annotation.",
	"Method": "AnnotationInfo getAnnotationInfo(String annotationName,AnnotationInfoList getAnnotationInfo){\r\n    return annotationInfo == null ? AnnotationInfoList.EMPTY_LIST : annotationInfo;\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.types.Parser.next",
	"Comment": "advance one character without returning the value of the character.",
	"Method": "void next(){\r\n    position++;\r\n}"
}, {
	"Path": "com.github.dockerjava.utils.RegistryUtils.runPrivateRegistry",
	"Comment": "starts a local test registry when it is not already started and returns the auth configuration for itthis method is synchronized so that only the first invocation starts the registry",
	"Method": "AuthConfig runPrivateRegistry(DockerClient dockerClient){\r\n    if (privateRegistryAuthConfig == null) {\r\n        int port = 5050;\r\n        String containerName = \"private-registry\";\r\n        String imageName = \"private-registry-image\";\r\n        File baseDir = new File(DockerRule.class.getResource(\"/privateRegistry\").getFile());\r\n        try {\r\n            dockerClient.removeContainerCmd(containerName).withForce(true).withRemoveVolumes(true).exec();\r\n        } catch (NotFoundException ex) {\r\n        }\r\n        String registryImageId = dockerClient.buildImageCmd(baseDir).withNoCache(true).exec(new BuildImageResultCallback()).awaitImageId();\r\n        InspectImageResponse inspectImageResponse = dockerClient.inspectImageCmd(registryImageId).exec();\r\n        assertThat(inspectImageResponse, not(nullValue()));\r\n        DockerRule.LOG.info(\"Image Inspect: {}\", inspectImageResponse.toString());\r\n        dockerClient.tagImageCmd(registryImageId, imageName, \"2\").withForce().exec();\r\n        CreateContainerResponse testregistry = dockerClient.createContainerCmd(imageName + \":2\").withName(containerName).withHostConfig(newHostConfig().withPortBindings(new PortBinding(Ports.Binding.bindPort(port), ExposedPort.tcp(5000)))).withEnv(\"REGISTRY_AUTH=htpasswd\", \"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm\", \"REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd\", \"REGISTRY_LOG_LEVEL=debug\", \"REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt\", \"REGISTRY_HTTP_TLS_KEY=/certs/domain.key\").exec();\r\n        dockerClient.startContainerCmd(testregistry.getId()).exec();\r\n        Thread.sleep(3000);\r\n        privateRegistryAuthConfig = new AuthConfig().withUsername(\"testuser\").withPassword(\"testpassword\").withEmail(\"foo@bar.de\").withRegistryAddress(\"localhost:\" + port);\r\n    }\r\n    return privateRegistryAuthConfig;\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.json.JSONParser.parseJSON",
	"Comment": "parse a json object, array, string, value or object reference.",
	"Method": "Object parseJSON(Object parseJSON,String str){\r\n    return new JSONParser(str).parseJSON();\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.onesample.WilcoxonOneSample.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level",
	"Method": "boolean test(FlatDataCollection flatDataCollection,double median,boolean is_twoTailed,double aLevel){\r\n    double pvalue = getPvalue(flatDataCollection, median);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2.0;\r\n    }\r\n    if (pvalue <= a || pvalue >= (1.0 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "cyclops.function.PartialApplicator.partial4",
	"Comment": "returns a bifunction with 2 arguments applied to the supplied quadfunction",
	"Method": "Supplier<R> partial4(T1 t1,T2 t2,T3 t3,T4 t4,Function4<T1, T2, T3, T4, R> quadFunc,Function<T4, R> partial4,T1 t1,T2 t2,T3 t3,Function4<T1, T2, T3, T4, R> quadFunc,BiFunction<T3, T4, R> partial4,T1 t1,T2 t2,Function4<T1, T2, T3, T4, R> quadFunc,Function3<T2, T3, T4, R> partial4,T1 t1,Function4<T1, T2, T3, T4, R> quadFunc){\r\n    return (t2, t3, t4) -> quadFunc.apply(t1, t2, t3, t4);\r\n}"
}, {
	"Path": "io.github.classgraph.FieldInfo.getTypeSignature",
	"Comment": "returns the parsed type signature for the field, if available.",
	"Method": "TypeSignature getTypeSignature(){\r\n    if (typeSignatureStr == null) {\r\n        return null;\r\n    }\r\n    if (typeSignature == null) {\r\n        try {\r\n            typeSignature = TypeSignature.parse(typeSignatureStr, declaringClassName);\r\n            typeSignature.setScanResult(scanResult);\r\n        } catch (final ParseException e) {\r\n            throw new IllegalArgumentException(e);\r\n        }\r\n    }\r\n    return typeSignature;\r\n}"
}, {
	"Path": "cyclops.control.Maybe.narrowK",
	"Comment": "convert the raw higher kinded type for maybetype types into the maybetype type definition class",
	"Method": "Maybe<T> narrowK(Higher<option, T> future){\r\n    return Maybe.fromOption(Option.narrowK(future));\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.StratifiedSamplingTest.testOptimumSampleSize",
	"Comment": "test of optimumsamplesize method, of class stratifiedsampling.",
	"Method": "void testOptimumSampleSize(){\r\n    logger.info(\"optimumSampleSize\");\r\n    int n = 0;\r\n    AssociativeArray populationNh = new AssociativeArray();\r\n    populationNh.put(1, 394);\r\n    populationNh.put(2, 461);\r\n    populationNh.put(3, 391);\r\n    populationNh.put(4, 334);\r\n    populationNh.put(5, 169);\r\n    populationNh.put(6, 113);\r\n    populationNh.put(7, 148);\r\n    AssociativeArray populationStdh = new AssociativeArray();\r\n    populationStdh.put(1, 8.3);\r\n    populationStdh.put(2, 13.3);\r\n    populationStdh.put(3, 15.1);\r\n    populationStdh.put(4, 19.8);\r\n    populationStdh.put(5, 24.5);\r\n    populationStdh.put(6, 26.0);\r\n    populationStdh.put(7, 35.0);\r\n    double expResult = n;\r\n    AssociativeArray sampleSizes = StratifiedSampling.optimumSampleSize(n, populationNh, populationStdh);\r\n    double result = Descriptives.sum(sampleSizes.toFlatDataCollection());\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.timeseries.SmoothingTest.testSimpleExponentialSmoothing",
	"Comment": "test of simpleexponentialsmoothing method, of class smoothing.",
	"Method": "void testSimpleExponentialSmoothing(){\r\n    logger.info(\"simpleExponentialSmoothing\");\r\n    FlatDataList flatDataList = generateFlatDataList();\r\n    double a = 0.9;\r\n    double expResult = 23.240433133179;\r\n    double result = Smoothing.simpleExponentialSmoothing(flatDataList, a);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.VectorX.fill",
	"Comment": "generate a vectorx from the provided value up to the provided limit number of times",
	"Method": "VectorX<T> fill(long limit,T s){\r\n    return ReactiveSeq.fill(s).limit(limit).to(ReactiveConvertableSequence::converter).vectorX(LAZY);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.Value.mkString",
	"Comment": "returns the class name and the name of the subclass, if there is any value, the value is showed between square brackets.",
	"Method": "String mkString(){\r\n    return fold(p -> getClass().getSimpleName() + \"[\" + p + \"]\", () -> getClass().getSimpleName() + \"[]\");\r\n}"
}, {
	"Path": "com.oath.cyclops.react.StageWithResults.submit",
	"Comment": "this method allows the simplereact executor to be reused by jdk parallel streams",
	"Method": "R submit(Function<RS, R> fn,T submit,Callable<T> callable){\r\n    if (taskExecutor instanceof ForkJoinPool) {\r\n        try {\r\n            return ((ForkJoinPool) taskExecutor).submit(callable).get();\r\n        } catch (final ExecutionException e) {\r\n            throw ExceptionSoftener.throwSoftenedException(e);\r\n        } catch (final InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n            throw ExceptionSoftener.throwSoftenedException(e);\r\n        }\r\n    }\r\n    try {\r\n        return callable.call();\r\n    } catch (final Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.ReadabilityStatisticsTest.testSmog_index",
	"Comment": "test of smogindex method, of class readabilitystatistics.",
	"Method": "void testSmog_index(){\r\n    logger.info(\"smog_index\");\r\n    String strText = TEST_STRING;\r\n    double expResult = 14.1;\r\n    double result = ReadabilityStatistics.smogIndex(strText);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.github.dockerjava.api.command.InspectImageResponse.getContainerConfig",
	"Comment": "if the image was created from a container, this config contains the configuration of the containerwhich was committed in this image",
	"Method": "ContainerConfig getContainerConfig(){\r\n    return containerConfig;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.StratifiedSamplingTest.testRandomSampling",
	"Comment": "test of randomsampling method, of class stratifiedsampling.",
	"Method": "void testRandomSampling(){\r\n    logger.info(\"randomSampling\");\r\n    TransposeDataList strataIdList = new TransposeDataList();\r\n    strataIdList.put(\"strata1\", new FlatDataList(Arrays.asList(new Object[] { \"1\", \"2\", \"3\", \"4\" })));\r\n    strataIdList.put(\"strata2\", new FlatDataList(Arrays.asList(new Object[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\" })));\r\n    AssociativeArray nh = generateNh();\r\n    boolean withReplacement = true;\r\n    double expResult = Descriptives.sum(nh.toFlatDataCollection());\r\n    TransposeDataCollection sampledIds = StratifiedSampling.randomSampling(strataIdList, nh, withReplacement);\r\n    double result = 0;\r\n    for (Object stata : sampledIds.keySet()) {\r\n        result += sampledIds.get(stata).size();\r\n    }\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.LinkedListX.iterate",
	"Comment": "create a linkedlistx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "LinkedListX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).linkedListX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.json.ClassFieldCache.get",
	"Comment": "for a given resolved type, find the visible and accessible fields, resolve the types of any generically typedfields, and return the resolved fields.",
	"Method": "ClassFields get(Class<?> cls){\r\n    ClassFields classFields = classToClassFields.get(cls);\r\n    if (classFields == null) {\r\n        classToClassFields.put(cls, classFields = new ClassFields(cls, resolveTypes, onlySerializePublicFields, this));\r\n    }\r\n    return classFields;\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.GuanoAlgorithm.printLost",
	"Comment": "print information when the algorithm gets lost in the matrix,ie when it does not know which direction to follow.",
	"Method": "void printLost(int i,int j){\r\n    DiffXEvent e1 = this.sequence1.getEvent(i);\r\n    DiffXEvent e2 = this.sequence2.getEvent(j);\r\n    System.err.println(\"(!) Ambiguous choice in (\" + i + \",\" + j + \")\");\r\n    System.err.println(\" ? +\" + ShortStringFormatter.toShortString(e1));\r\n    System.err.println(\" ? -\" + ShortStringFormatter.toShortString(e2));\r\n    System.err.println(\" current=\" + ShortStringFormatter.toShortString(this.estate.current()));\r\n    System.err.println(\" value in X+1=\" + this.matrix.get(i + 1, j));\r\n    System.err.println(\" value in Y+1=\" + this.matrix.get(i, j + 1));\r\n    System.err.println(\" equals=\" + e1.equals(e2));\r\n    System.err.println(\" greaterX=\" + this.matrix.isGreaterX(i, j));\r\n    System.err.println(\" greaterY=\" + this.matrix.isGreaterY(i, j));\r\n    System.err.println(\" sameXY=\" + this.matrix.isSameXY(i, j));\r\n    System.err.println(\" okFormat1=\" + this.estate.okFormat(e1));\r\n    System.err.println(\" okFormat2=\" + this.estate.okFormat(e2));\r\n    System.err.println(\" okInsert=\" + this.estate.okInsert(e1));\r\n    System.err.println(\" okDelete=\" + this.estate.okDelete(e2));\r\n}"
}, {
	"Path": "org.fourthline.cling.mediarenderer.gstreamer.GstMediaRenderer.runLastChangePushThread",
	"Comment": "to subscribers of the lastchange state variable of each service.",
	"Method": "void runLastChangePushThread(){\r\n    new Thread() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                while (true) {\r\n                    avTransport.fireLastChange();\r\n                    renderingControl.fireLastChange();\r\n                    Thread.sleep(LAST_CHANGE_FIRING_INTERVAL_MILLISECONDS);\r\n                }\r\n            } catch (Exception ex) {\r\n                throw new RuntimeException(ex);\r\n            }\r\n        }\r\n    }.start();\r\n}"
}, {
	"Path": "org.fourthline.cling.mediarenderer.gstreamer.GstMediaRenderer.runLastChangePushThread",
	"Comment": "to subscribers of the lastchange state variable of each service.",
	"Method": "void runLastChangePushThread(){\r\n    try {\r\n        while (true) {\r\n            avTransport.fireLastChange();\r\n            renderingControl.fireLastChange();\r\n            Thread.sleep(LAST_CHANGE_FIRING_INTERVAL_MILLISECONDS);\r\n        }\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.ReadabilityStatisticsTest.testFlesch_kincaid_reading_ease",
	"Comment": "test of fleschkincaidreadingease method, of class readabilitystatistics.",
	"Method": "void testFlesch_kincaid_reading_ease(){\r\n    logger.info(\"flesch_kincaid_reading_ease\");\r\n    String strText = TEST_STRING;\r\n    double expResult = -188.4;\r\n    double result = ReadabilityStatistics.fleschKincaidReadingEase(strText);\r\n    Assert.assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributionsTest.testBernoulli",
	"Comment": "test of bernoulli method, of class discretedistributions.",
	"Method": "void testBernoulli(){\r\n    logger.info(\"Bernoulli\");\r\n    boolean k = true;\r\n    double p = 0.5;\r\n    double expResult = 0.5;\r\n    double result = DiscreteDistributions.bernoulli(k, p);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.applications.nlp.TextClassifierTest.testTrainAndValidateMutualInformation",
	"Comment": "test of train and validate method, of class textclassifier using mutualinformation.",
	"Method": "void testTrainAndValidateMutualInformation(){\r\n    logger.info(\"testTrainAndValidateMutualInformation\");\r\n    MultinomialNaiveBayes.TrainingParameters mlParams = new MultinomialNaiveBayes.TrainingParameters();\r\n    MutualInformation.TrainingParameters fsParams = new MutualInformation.TrainingParameters();\r\n    fsParams.setMaxFeatures(10000);\r\n    fsParams.setRareFeatureThreshold(3);\r\n    trainAndValidate(mlParams, fsParams, null, 0.91926983796055, 8);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.parsers.HTMLParser.extractHyperlinks",
	"Comment": "extracts the hyperlinks from an html string and returns their components in a map.",
	"Method": "Map<HyperlinkPart, List<String>> extractHyperlinks(String html){\r\n    Map<HyperlinkPart, List<String>> hyperlinksMap = new HashMap();\r\n    hyperlinksMap.put(HyperlinkPart.HTMLTAG, new ArrayList());\r\n    hyperlinksMap.put(HyperlinkPart.URL, new ArrayList());\r\n    hyperlinksMap.put(HyperlinkPart.ANCHORTEXT, new ArrayList());\r\n    Matcher m = HYPERLINK_PATTERN.matcher(html);\r\n    while (m.find()) {\r\n        if (m.groupCount() == 2) {\r\n            String tag = m.group(0);\r\n            String url = m.group(1);\r\n            String anchortext = m.group(2);\r\n            hyperlinksMap.get(HyperlinkPart.HTMLTAG).add(tag);\r\n            hyperlinksMap.get(HyperlinkPart.URL).add(url);\r\n            hyperlinksMap.get(HyperlinkPart.ANCHORTEXT).add(anchortext);\r\n        }\r\n    }\r\n    return hyperlinksMap;\r\n}"
}, {
	"Path": "com.github.dockerjava.api.model.PullResponseItem.isPullSuccessIndicated",
	"Comment": "returns whether the status indicates a successful pull operation",
	"Method": "boolean isPullSuccessIndicated(){\r\n    if (isErrorIndicated() || getStatus() == null) {\r\n        return false;\r\n    }\r\n    return (getStatus().contains(DOWNLOAD_COMPLETE) || getStatus().contains(IMAGE_UP_TO_DATE) || getStatus().contains(DOWNLOADED_NEWER_IMAGE) || getStatus().contains(LEGACY_REGISTRY) || getStatus().contains(DOWNLOADED_SWARM));\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.DequeX.fromIterable",
	"Comment": "construct a deque from the provided collector and iterable.",
	"Method": "DequeX<T> fromIterable(Iterable<T> it,DequeX<T> fromIterable,Collector<T, ?, Deque<T>> collector,Iterable<T> it){\r\n    if (it instanceof DequeX)\r\n        return ((DequeX) it).type(collector);\r\n    if (it instanceof Deque)\r\n        return new LazyDequeX<T>((Deque) it, collector, LAZY);\r\n    return new LazyDequeX<T>(Streams.stream(it).collect(collector), collector, LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributions.negativeBinomial",
	"Comment": "returns the probability of requiring n tries to achieve r successes with probability of success p",
	"Method": "double negativeBinomial(int n,int r,double p){\r\n    if (n < 0 || r < 0 || p < 0) {\r\n        throw new IllegalArgumentException(\"All the parameters must be positive.\");\r\n    }\r\n    n = Math.max(n, r);\r\n    double probability = Arithmetics.combination(n - 1, r - 1) * Math.pow(1 - p, n - r) * Math.pow(p, r);\r\n    return probability;\r\n}"
}, {
	"Path": "cyclops.function.Reducer.mapToType",
	"Comment": "map this reducer to the supported type t.default implementation is a simple cast.",
	"Method": "Stream<T> mapToType(Stream<U> stream){\r\n    return stream.map(conversion());\r\n}"
}, {
	"Path": "com.github.dockerjava.core.DefaultDockerClientConfig.createDefaultConfigBuilder",
	"Comment": "allows you to build the config without system environment interfering for more robust testing",
	"Method": "Builder createDefaultConfigBuilder(Builder createDefaultConfigBuilder,Map<String, String> env,Properties systemProperties){\r\n    Properties properties = loadIncludedDockerProperties(systemProperties);\r\n    properties = overrideDockerPropertiesWithSettingsFromUserHome(properties, systemProperties);\r\n    properties = overrideDockerPropertiesWithEnv(properties, env);\r\n    properties = overrideDockerPropertiesWithSystemProperties(properties, systemProperties);\r\n    return new Builder().withProperties(properties);\r\n}"
}, {
	"Path": "cyclops.control.Unrestricted.forEach4",
	"Comment": "perform a for comprehension over a unrestricted, accepting 3 generating function.this results in a four level nested internal iteration over the provided computationss.",
	"Method": "Unrestricted<R3> forEach4(Function<? super T, ? extends Unrestricted<R1>> value2,BiFunction<? super T, ? super R1, ? extends Unrestricted<R2>> value3,Function3<? super T, ? super R1, ? super R2, ? extends Unrestricted<R3>> value4){\r\n    return this.flatMap(in -> {\r\n        Unrestricted<R1> a = value2.apply(in);\r\n        return a.flatMap(ina -> {\r\n            Unrestricted<R2> b = value3.apply(in, ina);\r\n            return b.flatMap(inb -> {\r\n                Unrestricted<R3> c = value4.apply(in, ina, inb);\r\n                return c;\r\n            });\r\n        });\r\n    });\r\n}"
}, {
	"Path": "com.spotify.docker.client.auth.gcr.ContainerRegistryAuthSupplier.forApplicationDefaultCredentials",
	"Comment": "constructs a containerregistryauthsupplier using the application default credentials.",
	"Method": "Builder forApplicationDefaultCredentials(){\r\n    return new Builder(GoogleCredentials.getApplicationDefault());\r\n}"
}, {
	"Path": "cyclops.control.Unrestricted.forEach3",
	"Comment": "perform a for comprehension over a unrestricted, accepting 2 generating function.this results in a three level nested internal iteration over the provided computationss.",
	"Method": "Unrestricted<R2> forEach3(Function<? super T, ? extends Unrestricted<R1>> value2,BiFunction<? super T, ? super R1, ? extends Unrestricted<R2>> value3){\r\n    return this.flatMap(in -> {\r\n        Unrestricted<R1> a = value2.apply(in);\r\n        return a.flatMap(ina -> {\r\n            Unrestricted<R2> b = value3.apply(in, ina);\r\n            return b;\r\n        });\r\n    });\r\n}"
}, {
	"Path": "com.datumbox.framework.applications.nlp.TextClassifier.predict",
	"Comment": "it generates a prediction for a particular string. it returns a recordobject which contains the observation data, the predicted class and probabilities.",
	"Method": "Dataframe predict(URI datasetURI,Record predict,String text){\r\n    TrainingParameters trainingParameters = (TrainingParameters) knowledgeBase.getTrainingParameters();\r\n    Dataframe testDataset = new Dataframe(knowledgeBase.getConfiguration());\r\n    testDataset.add(new Record(new AssociativeArray(AbstractTextExtractor.newInstance(trainingParameters.getTextExtractorParameters()).extract(StringCleaner.clear(text))), null));\r\n    predict(testDataset);\r\n    Record r = testDataset.iterator().next();\r\n    testDataset.close();\r\n    return r;\r\n}"
}, {
	"Path": "cyclops.control.Unrestricted.forEach2",
	"Comment": "perform a for comprehension over a unrestricted, accepting a generating function.this results in a two level nested internal iteration over the provided computationss.",
	"Method": "Unrestricted<R1> forEach2(Function<? super T, Unrestricted<R1>> value2){\r\n    return this.flatMap(in -> {\r\n        Unrestricted<R1> a = value2.apply(in);\r\n        return a;\r\n    });\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributions.dirichletPdf",
	"Comment": "calculates probability pi, ai under dirichlet distribution",
	"Method": "double dirichletPdf(double[] pi,double[] ai,double dirichletPdf,double[] pi,double a){\r\n    double probability = 1.0;\r\n    int piLength = pi.length;\r\n    for (int i = 0; i < piLength; ++i) {\r\n        probability *= Math.pow(pi[i], a - 1);\r\n    }\r\n    double sumAi = piLength * a;\r\n    double productGammaAi = Math.pow(gamma(a), piLength);\r\n    probability *= gamma(sumAi) / productGammaAi;\r\n    return probability;\r\n}"
}, {
	"Path": "buildcraft.transport.PipeTransportItems.groupEntities",
	"Comment": "group all items that are similar, that is to say same dmg, same id, same nbt and no contribution controlling",
	"Method": "void groupEntities(){\r\n    for (TravelingItem item : items) {\r\n        if (item.isCorrupted()) {\r\n            continue;\r\n        }\r\n        for (TravelingItem otherItem : items) {\r\n            if (item.tryMergeInto(otherItem)) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oath.cyclops.matching.Case.or",
	"Comment": "return the test for this user case or for the other. there is no guaranteeone successful result will be produced.",
	"Method": "Case<T, R> or(Case<T, R> orCase){\r\n    return (t) -> {\r\n        Option<R> val = test(t);\r\n        return val.isPresent() ? val : orCase.test(t);\r\n    };\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.Dataframe._unsafe_add",
	"Comment": "adds the record in the dataset without updating the meta. the add methodreturns the id of the new record.",
	"Method": "Integer _unsafe_add(Record r){\r\n    Integer newId = data.atomicNextAvailableRecordId.getAndIncrement();\r\n    data.records.put(newId, r);\r\n    return newId;\r\n}"
}, {
	"Path": "cyclops.control.LazyEither.traverseRight",
	"Comment": "traverseops a collection of either producting an either3 with a seq, applying the transformation function to everyelement in the list",
	"Method": "LazyEither<LT1, ReactiveSeq<R>> traverseRight(Iterable<LazyEither<LT1, PT>> xors,Function<? super PT, ? extends R> fn){\r\n    return sequenceRight(xors).map(l -> l.map(fn));\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.concurrency.InterruptionChecker.executionException",
	"Comment": "stop all threads that share this interruptionchecker due to an exception being thrown in one of them.",
	"Method": "ExecutionException executionException(Exception e){\r\n    executionException = e instanceof ExecutionException ? (ExecutionException) e : new ExecutionException(e);\r\n    return executionException;\r\n}"
}, {
	"Path": "org.fourthline.cling.model.action.AbstractActionExecutor.readOutputArgumentValues",
	"Comment": "reads the output arguments after an action execution using accessors.",
	"Method": "Object readOutputArgumentValues(Action<LocalService> action,Object instance){\r\n    Object[] results = new Object[action.getOutputArguments().length];\r\n    log.fine(\"Attempting to retrieve output argument values using accessor: \" + results.length);\r\n    int i = 0;\r\n    for (ActionArgument outputArgument : action.getOutputArguments()) {\r\n        log.finer(\"Calling acccessor method for: \" + outputArgument);\r\n        StateVariableAccessor accessor = getOutputArgumentAccessors().get(outputArgument);\r\n        if (accessor != null) {\r\n            log.fine(\"Calling accessor to read output argument value: \" + accessor);\r\n            results[i++] = accessor.read(instance);\r\n        } else {\r\n            throw new IllegalStateException(\"No accessor bound for: \" + outputArgument);\r\n        }\r\n    }\r\n    if (results.length == 1) {\r\n        return results[0];\r\n    }\r\n    return results.length > 0 ? results : null;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.onesample.KolmogorovSmirnovOneSample.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level.",
	"Method": "boolean test(FlatDataCollection flatDataCollection,String cdfMethod,AssociativeArray params,boolean is_twoTailed,double aLevel){\r\n    double[] doubleArray = flatDataCollection.stream().filter(x -> x != null).mapToDouble(TypeInference::toDouble).toArray();\r\n    int n = doubleArray.length;\r\n    if (n <= 0) {\r\n        throw new IllegalArgumentException(\"The provided collection can't be empty.\");\r\n    }\r\n    Arrays.sort(doubleArray);\r\n    double observedProbabilityIminus1 = 0;\r\n    double maxDelta = 0;\r\n    int rank = 1;\r\n    try {\r\n        Method method = KolmogorovSmirnovOneSample.class.getMethod(cdfMethod, Double.class, AssociativeArray.class);\r\n        for (int i = 0; i < doubleArray.length; ++i) {\r\n            double x = doubleArray[i];\r\n            double observedProbabilityI = rank / (double) n;\r\n            Object methodResult = method.invoke(null, x, params);\r\n            double expectedProbabilityI = TypeInference.toDouble(methodResult);\r\n            double delta = Math.max(Math.abs(expectedProbabilityI - observedProbabilityI), Math.abs(expectedProbabilityI - observedProbabilityIminus1));\r\n            if (delta >= maxDelta) {\r\n                maxDelta = delta;\r\n            }\r\n            observedProbabilityIminus1 = observedProbabilityI;\r\n            ++rank;\r\n        }\r\n        boolean rejectH0 = checkCriticalValue(maxDelta, is_twoTailed, n, aLevel);\r\n        return rejectH0;\r\n    } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {\r\n        throw new IllegalArgumentException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.TransposeDataCollection.remove",
	"Comment": "removes a particular key from the internal map and returns the value associated with that key if present in the map.",
	"Method": "FlatDataCollection remove(Object key){\r\n    return internalData.remove(key);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.mathematics.distances.Distance.euclidean",
	"Comment": "estimates the euclidean distance of two associative arrays.",
	"Method": "double euclidean(AssociativeArray a1,AssociativeArray a2){\r\n    Map<Object, Double> columnDistances = columnDistances(a1, a2, null);\r\n    double distance = 0.0;\r\n    for (double columnDistance : columnDistances.values()) {\r\n        distance += (columnDistance * columnDistance);\r\n    }\r\n    return Math.sqrt(distance);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.SimpleRandomSamplingTest.testWeightedSampling",
	"Comment": "test of weightedsampling method, of class simplerandomsampling.",
	"Method": "void testWeightedSampling(){\r\n    logger.info(\"weightedSampling\");\r\n    AssociativeArray frequencyTable = new AssociativeArray();\r\n    frequencyTable.put(1, 10);\r\n    frequencyTable.put(2, 20);\r\n    frequencyTable.put(3, 30);\r\n    frequencyTable.put(4, 40);\r\n    int n = 100;\r\n    boolean withReplacement = true;\r\n    double expResult = n;\r\n    FlatDataCollection sampledIds = SimpleRandomSampling.weightedSampling(frequencyTable, n, withReplacement);\r\n    double result = sampledIds.size();\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.SimpleRandomSamplingTest.testWeightedProbabilitySampling",
	"Comment": "test of weightedsampling method, of class simplerandomsampling.",
	"Method": "void testWeightedProbabilitySampling(){\r\n    logger.info(\"weightedProbabilitySampling\");\r\n    AssociativeArray frequencyTable = new AssociativeArray();\r\n    frequencyTable.put(1, 0.20);\r\n    frequencyTable.put(2, 0.30);\r\n    frequencyTable.put(3, 0.25);\r\n    frequencyTable.put(4, 0.25);\r\n    int n = 100;\r\n    boolean withReplacement = true;\r\n    double expResult = n;\r\n    FlatDataCollection sampledIds = SimpleRandomSampling.weightedSampling(frequencyTable, n, withReplacement);\r\n    double result = sampledIds.size();\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.SystematicSamplingTest.testRandomSampling",
	"Comment": "test of randomsampling method, of class systematicsampling.",
	"Method": "void testRandomSampling(){\r\n    logger.info(\"randomSampling\");\r\n    FlatDataList idList = new FlatDataList(Arrays.asList(new Object[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 }));\r\n    int n = 6;\r\n    boolean randomizeRecords = false;\r\n    double expResult = n;\r\n    FlatDataCollection sampledIds = SystematicSampling.randomSampling(idList, n, randomizeRecords);\r\n    double result = sampledIds.size();\r\n    assertTrue(result >= expResult);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.DequeX.iterate",
	"Comment": "create a dequex by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "DequeX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).dequeX(LAZY);\r\n}"
}, {
	"Path": "cyclops.typeclasses.foldable.Foldable.foldRight",
	"Comment": "starting from the right combine each value in turn with an accumulator",
	"Method": "T foldRight(Monoid<T> monoid,Higher<CRE, T> ds,T foldRight,T identity,BinaryOperator<T> semigroup,Higher<CRE, T> ds){\r\n    return foldRight(Monoid.fromBiFunction(identity, semigroup), ds);\r\n}"
}, {
	"Path": "com.github.dockerjava.cmd.EventsCmdIT.generateEvents",
	"Comment": "this method generates some events and returns the number of events being generated",
	"Method": "int generateEvents(){\r\n    String testImage = \"busybox:latest\";\r\n    dockerRule.getClient().pullImageCmd(testImage).exec(new PullImageResultCallback()).awaitSuccess();\r\n    CreateContainerResponse container = dockerRule.getClient().createContainerCmd(testImage).withCmd(\"sleep\", \"9999\").exec();\r\n    dockerRule.getClient().startContainerCmd(container.getId()).exec();\r\n    dockerRule.getClient().stopContainerCmd(container.getId()).withTimeout(1).exec();\r\n    return 5;\r\n}"
}, {
	"Path": "buildcraft.core.lib.block.BlockBuildCraftBase.withProperty",
	"Comment": "generic helper methods, these stop generics from being strange",
	"Method": "IBlockState withProperty(IBlockState state,BuildCraftProperty prop,Comparable value){\r\n    return withProperty0(state, prop, value);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.onesample.NormalOneSample.checkCriticalValue",
	"Comment": "checks the critical value to determine if the hypothesis should be rejected",
	"Method": "boolean checkCriticalValue(double score,boolean is_twoTailed,double aLevel){\r\n    double probability = ContinuousDistributions.gaussCdf(score);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2.0;\r\n    }\r\n    if (probability <= a || probability >= (1.0 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "cyclops.futurestream.SimpleReact.from",
	"Comment": "construct a simplereactstream from an array of completablefutures",
	"Method": "SimpleReactStream<U> from(Stream<U> stream,SimpleReactStream<R> from,Collection<R> collection,SimpleReactStream<U> from,Iterator<U> iterator,SimpleReactStream<Integer> from,IntStream stream,SimpleReactStream<Double> from,DoubleStream stream,SimpleReactStream<Long> from,LongStream stream,SimpleReactStream<U> from,CompletableFuture<U> cf,SimpleReactStream<U> from,CompletableFuture<U> cf){\r\n    return this.construct(Stream.of(cf));\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AssociativeArray.multiplyValues",
	"Comment": "multiplies the values of the object with a particular multiplier. all the columnsof this object should be numeric or boolean or else an exception is thrown.",
	"Method": "void multiplyValues(double multiplier){\r\n    for (Map.Entry<Object, Object> entry : internalData.entrySet()) {\r\n        Double previousValue = TypeInference.toDouble(entry.getValue());\r\n        if (previousValue == null) {\r\n            continue;\r\n        }\r\n        internalData.put(entry.getKey(), previousValue * multiplier);\r\n    }\r\n}"
}, {
	"Path": "org.fourthline.cling.android.AndroidRouter.handleRouterExceptionOnNetworkTypeChange",
	"Comment": "handles errors when network has been switched, during reception ofnetwork switch broadcast. logs a warning by default, override tochange this behavior.",
	"Method": "void handleRouterExceptionOnNetworkTypeChange(RouterException ex){\r\n    Throwable cause = Exceptions.unwrap(ex);\r\n    if (cause instanceof InterruptedException) {\r\n        log.log(Level.INFO, \"Router was interrupted: \" + ex, cause);\r\n    } else {\r\n        log.log(Level.WARNING, \"Router error on network change: \" + ex, ex);\r\n    }\r\n}"
}, {
	"Path": "io.github.classgraph.ClassGraph.whitelistClasspathElementsContainingResourcePath",
	"Comment": "whitelist classpath elements based on resource paths. only classpath elements that contain resources withpaths matching the whitelist will be scanned.",
	"Method": "ClassGraph whitelistClasspathElementsContainingResourcePath(String resourcePaths){\r\n    for (final String resourcePath : resourcePaths) {\r\n        scanSpec.classpathElementResourcePathWhiteBlackList.addToWhitelist(resourcePath);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.QueueX.iterate",
	"Comment": "create a queuex by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "QueueX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).queueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "cyclops.function.Function0.iterate",
	"Comment": "use the value stored in this value to seed a stream generated from the provided function",
	"Method": "ReactiveSeq<R> iterate(UnaryOperator<R> fn){\r\n    return ReactiveSeq.iterate(get(), fn);\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.utils.InputStreamOrByteBufferAdapter.readUnsignedByte",
	"Comment": "read an unsigned byte from the buffer at a specific absolute offset before the current read point.",
	"Method": "int readUnsignedByte(int readUnsignedByte,int offset){\r\n    final int bytesToRead = Math.max(0, offset + 1 - used);\r\n    if (bytesToRead > 0) {\r\n        throw new IllegalArgumentException(\"Can only read from absolute offsets before the current location in the file\");\r\n    }\r\n    return buf[offset] & 0xff;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.DataframeMatrix.parseDataset",
	"Comment": "parses a testing dataset and converts it to dataframematrix by using an already existing mapping between feature names and column ids. typically usedto parse the testing or validation dataset.",
	"Method": "DataframeMatrix parseDataset(Dataframe newData,Map<Integer, Integer> recordIdsReference,Map<Object, Integer> featureIdsReference){\r\n    if (featureIdsReference.isEmpty()) {\r\n        throw new IllegalArgumentException(\"The featureIdsReference map should not be empty.\");\r\n    }\r\n    setStorageEngine(newData);\r\n    int n = newData.size();\r\n    int d = featureIdsReference.size();\r\n    DataframeMatrix m = new DataframeMatrix(new MapRealMatrix(n, d), new MapRealVector(n));\r\n    if (newData.isEmpty()) {\r\n        return m;\r\n    }\r\n    boolean extractY = (newData.getYDataType() == TypeInference.DataType.NUMERICAL);\r\n    boolean addConstantColumn = featureIdsReference.containsKey(Dataframe.COLUMN_NAME_CONSTANT);\r\n    int rowId = 0;\r\n    for (Map.Entry<Integer, Record> e : newData.entries()) {\r\n        Integer rId = e.getKey();\r\n        Record r = e.getValue();\r\n        if (recordIdsReference != null) {\r\n            recordIdsReference.put(rId, rowId);\r\n        }\r\n        if (extractY) {\r\n            m.Y.setEntry(rowId, TypeInference.toDouble(r.getY()));\r\n        }\r\n        if (addConstantColumn) {\r\n            m.X.setEntry(rowId, 0, 1.0);\r\n        }\r\n        for (Map.Entry<Object, Object> entry : r.getX().entrySet()) {\r\n            Object feature = entry.getKey();\r\n            Double value = TypeInference.toDouble(entry.getValue());\r\n            if (value != null) {\r\n                Integer featureId = featureIdsReference.get(feature);\r\n                if (featureId != null) {\r\n                    m.X.setEntry(rowId, featureId, value);\r\n                }\r\n            }\r\n        }\r\n        ++rowId;\r\n    }\r\n    return m;\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.ElementState.indexOf",
	"Comment": "searches for the first occurrence of the given argument, testingfor equality using the equals method.",
	"Method": "int indexOf(OpenElementEvent element){\r\n    if (element == null) {\r\n        for (int i = 0; i < this.size; i++) if (this.openElements[i] == null)\r\n            return i;\r\n    } else {\r\n        for (int i = 0; i < this.size; i++) if (element.equals(this.openElements[i]))\r\n            return i;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AssociativeArray2D.get",
	"Comment": "returns the value which is associated with the provided key.",
	"Method": "AssociativeArray get(Object key){\r\n    return internalData.get(key);\r\n}"
}, {
	"Path": "cyclops.companion.Streamable.range",
	"Comment": "create an efficiently reversable sequence that produces the integers between skipand take",
	"Method": "Streamable<Integer> range(int start,int end){\r\n    return fromStream(ReactiveSeq.range(start, end));\r\n}"
}, {
	"Path": "cyclops.control.Future.of",
	"Comment": "create a future object that asyncrhonously populates using the providedexecutor and supplier",
	"Method": "Future<T> of(CompletableFuture<T> f,Future<T> of,Supplier<T> s,Future<T> of,Supplier<T> s,Executor ex){\r\n    return Future.of(CompletableFuture.supplyAsync(s, ex));\r\n}"
}, {
	"Path": "io.github.classgraph.ClassfileBinaryParser.constantPoolStringEquals",
	"Comment": "compare a string in the constant pool with a given constant, without constructing the string object.",
	"Method": "boolean constantPoolStringEquals(int cpIdx,String otherString){\r\n    final int strOffset = getConstantPoolStringOffset(cpIdx, 0);\r\n    if (strOffset == 0) {\r\n        return otherString == null;\r\n    } else if (otherString == null) {\r\n        return false;\r\n    }\r\n    final int strLen = inputStreamOrByteBuffer.readUnsignedShort(strOffset);\r\n    final int otherLen = otherString.length();\r\n    if (strLen != otherLen) {\r\n        return false;\r\n    }\r\n    final int strStart = strOffset + 2;\r\n    for (int i = 0; i < strLen; i++) {\r\n        if ((char) (inputStreamOrByteBuffer.buf[strStart + i] & 0xff) != otherString.charAt(i)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.utils.ReflectionUtils.getStaticFieldVal",
	"Comment": "get the value of the named static field in the given class or any of its superclasses. if an exception isthrown while trying to read the field value, and throwexception is true, then illegalargumentexception isthrown wrapping the cause, otherwise this will return null. if passed a null class reference, returns nullunless throwexception is true, then throws illegalargumentexception.",
	"Method": "Object getStaticFieldVal(Class<?> cls,String fieldName,boolean throwException){\r\n    if (cls != null) {\r\n        for (Class<?> classOrSuperclass = cls; classOrSuperclass != null; classOrSuperclass = classOrSuperclass.getSuperclass()) {\r\n            try {\r\n                final Field field = classOrSuperclass.getDeclaredField(fieldName);\r\n                try {\r\n                    field.setAccessible(true);\r\n                } catch (final Exception e) {\r\n                }\r\n                return field.get(null);\r\n            } catch (final NoSuchFieldException e) {\r\n            } catch (final Throwable e) {\r\n                if (throwException) {\r\n                    throw new IllegalArgumentException(\"Could not get value of field \\\"\" + fieldName + \"\\\"\", e);\r\n                }\r\n            }\r\n        }\r\n        if (throwException) {\r\n            throw new IllegalArgumentException(\"Field \\\"\" + fieldName + \"\\\" doesn't exist\");\r\n        }\r\n    } else if (throwException) {\r\n        throw new IllegalArgumentException(\"Can't get field value for null class reference\");\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.classpath.ClasspathOrder.filter",
	"Comment": "test to see if a relativepath has been filtered out by the user.",
	"Method": "boolean filter(String classpathElementPath){\r\n    if (scanSpec.classpathElementFilters != null) {\r\n        for (final ClasspathElementFilter filter : scanSpec.classpathElementFilters) {\r\n            if (!filter.includeClasspathElement(classpathElementPath)) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "cyclops.monads.collections.AbstractAnyMSeqTest.prependAppend",
	"Comment": "prepends, append,append,prependall,prependall,insertat,deletebetween,insertats,recover",
	"Method": "void prependAppend(){\r\n    assertThat(of(1).prependStream(Stream.of(2)).append(3).prepend(4).appendAll(5, 6).prependAll(7, 8).insertAt(4, 9).deleteBetween(1, 2).insertStreamAt(5, Stream.of(11, 12)).stream().count(), equalTo(10L));\r\n}"
}, {
	"Path": "cyclops.function.Memoize.memoizeQuadFunctionAsync",
	"Comment": "memoize a function and update the cached values asynchronously using the provided scheduled executor servicedoes not support null keys",
	"Method": "Function4<T1, T2, T3, T4, R> memoizeQuadFunctionAsync(Function4<T1, T2, T3, T4, R> fn,ScheduledExecutorService ex,String cron,Function4<T1, T2, T3, T4, R> memoizeQuadFunctionAsync,Function4<T1, T2, T3, T4, R> fn,ScheduledExecutorService ex,long updateRateInMillis){\r\n    Function1<Tuple4<T1, T2, T3, T4>, R> memoise2 = memoizeFunctionAsync((final Tuple4<T1, T2, T3, T4> quad) -> fn.apply(quad._1(), quad._2(), quad._3(), quad._4()), ex, updateRateInMillis);\r\n    return (t1, t2, t3, t4) -> memoise2.apply(tuple(t1, t2, t3, t4));\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.clustering.HierarchicalAgglomerativeTest.testKFoldCrossValidation",
	"Comment": "test of validate method, of class hierarchicalagglomerative.",
	"Method": "void testKFoldCrossValidation(){\r\n    logger.info(\"testKFoldCrossValidation\");\r\n    Configuration configuration = getConfiguration();\r\n    int k = 5;\r\n    Dataframe[] data = Datasets.heartDiseaseClusters(configuration);\r\n    Dataframe trainingData = data[0];\r\n    data[1].close();\r\n    MinMaxScaler.TrainingParameters nsParams = new MinMaxScaler.TrainingParameters();\r\n    MinMaxScaler numericalScaler = MLBuilder.create(nsParams, configuration);\r\n    numericalScaler.fit_transform(trainingData);\r\n    CornerConstraintsEncoder.TrainingParameters ceParams = new CornerConstraintsEncoder.TrainingParameters();\r\n    CornerConstraintsEncoder categoricalEncoder = MLBuilder.create(ceParams, configuration);\r\n    categoricalEncoder.fit_transform(trainingData);\r\n    HierarchicalAgglomerative.TrainingParameters param = new HierarchicalAgglomerative.TrainingParameters();\r\n    param.setDistanceMethod(HierarchicalAgglomerative.TrainingParameters.Distance.EUCLIDIAN);\r\n    param.setLinkageMethod(HierarchicalAgglomerative.TrainingParameters.Linkage.COMPLETE);\r\n    param.setMinClustersThreshold(2);\r\n    param.setMaxDistanceThreshold(Double.MAX_VALUE);\r\n    ClusteringMetrics vm = new Validator(ClusteringMetrics.class, configuration).validate(new KFoldSplitter(k).split(trainingData), param);\r\n    double expResult = 0.7666666666666667;\r\n    double result = vm.getPurity();\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n    numericalScaler.close();\r\n    categoricalEncoder.close();\r\n    trainingData.close();\r\n}"
}, {
	"Path": "io.github.classgraph.FieldInfo.getAnnotationInfo",
	"Comment": "get a the named annotation on this field, or null if the field does not have the named annotation.",
	"Method": "AnnotationInfoList getAnnotationInfo(AnnotationInfo getAnnotationInfo,String annotationName){\r\n    return getAnnotationInfo().get(annotationName);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.ensemblelearning.FixedCombinationRules.weightedAverage",
	"Comment": "combines the responses of the classifiers by estimating the weightedaverage of the probabilities of their responses.",
	"Method": "AssociativeArray weightedAverage(DataTable2D classifierClassProbabilityMatrix,AssociativeArray classifierWeights){\r\n    AssociativeArray combinedClassProbabilities = new AssociativeArray();\r\n    for (Map.Entry<Object, AssociativeArray> entry : classifierClassProbabilityMatrix.entrySet()) {\r\n        Object classifier = entry.getKey();\r\n        AssociativeArray listOfClassProbabilities = entry.getValue();\r\n        Double classifierWeight = classifierWeights.getDouble(classifier);\r\n        for (Map.Entry<Object, Object> entry2 : listOfClassProbabilities.entrySet()) {\r\n            Object theClass = entry2.getKey();\r\n            Double probability = TypeInference.toDouble(entry2.getValue());\r\n            Double previousValue = combinedClassProbabilities.getDouble(theClass);\r\n            if (previousValue == null) {\r\n                previousValue = 0.0;\r\n            }\r\n            combinedClassProbabilities.put(theClass, previousValue + probability * classifierWeight);\r\n        }\r\n    }\r\n    return combinedClassProbabilities;\r\n}"
}, {
	"Path": "com.spotify.docker.client.auth.gcr.ContainerRegistryAuthSupplier.forCredentials",
	"Comment": "constructs a containerregistryauthsupplier using the specified credentials.",
	"Method": "Builder forCredentials(GoogleCredentials credentials){\r\n    return new Builder(credentials);\r\n}"
}, {
	"Path": "cyclops.function.Memoize.memoizeTriFunctionAsync",
	"Comment": "memoize a function and update the cached values asynchronously using the provided scheduled executor servicedoes not support null keys",
	"Method": "Function3<T1, T2, T3, R> memoizeTriFunctionAsync(Function3<T1, T2, T3, R> fn,ScheduledExecutorService ex,String cron,Function3<T1, T2, T3, R> memoizeTriFunctionAsync,Function3<T1, T2, T3, R> fn,ScheduledExecutorService ex,long updateRateInMillis){\r\n    Function1<Tuple3<T1, T2, T3>, R> memoise2 = memoizeFunctionAsync((final Tuple3<T1, T2, T3> triple) -> fn.apply(triple._1(), triple._2(), triple._3()), ex, updateRateInMillis);\r\n    return (t1, t2, t3) -> memoise2.apply(tuple(t1, t2, t3));\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXEvents",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription,when the entire stream has been processed an oncomplete event will be recieved.",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXEvents(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError,Runnable onComplete){\r\n    final CompletableFuture<Subscription> subscription = new CompletableFuture();\r\n    final CompletableFuture<Boolean> streamCompleted = new CompletableFuture();\r\n    return tuple(subscription, () -> {\r\n        stream.subscribe(new Subscriber<T>() {\r\n            @Override\r\n            public void onSubscribe(final Subscription s) {\r\n                Objects.requireNonNull(s);\r\n                if (x != 0)\r\n                    s.request(x);\r\n                subscription.complete(s);\r\n            }\r\n            @Override\r\n            public void onNext(final T t) {\r\n                consumerElement.accept(t);\r\n            }\r\n            @Override\r\n            public void onError(final Throwable t) {\r\n                consumerError.accept(t);\r\n            }\r\n            @Override\r\n            public void onComplete() {\r\n                streamCompleted.complete(true);\r\n                onComplete.run();\r\n            }\r\n        });\r\n    }, streamCompleted);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXEvents",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription,when the entire stream has been processed an oncomplete event will be recieved.",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXEvents(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError,Runnable onComplete){\r\n    Objects.requireNonNull(s);\r\n    if (x != 0)\r\n        s.request(x);\r\n    subscription.complete(s);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXEvents",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription,when the entire stream has been processed an oncomplete event will be recieved.",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXEvents(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError,Runnable onComplete){\r\n    consumerElement.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXEvents",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription,when the entire stream has been processed an oncomplete event will be recieved.",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXEvents(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError,Runnable onComplete){\r\n    consumerError.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXEvents",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription,when the entire stream has been processed an oncomplete event will be recieved.",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXEvents(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError,Runnable onComplete){\r\n    streamCompleted.complete(true);\r\n    onComplete.run();\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.utilities.PHPMethods.arsort",
	"Comment": "sorts an array in descending order and returns an array with indexes of the original order.",
	"Method": "Integer[] arsort(T[] array){\r\n    return _asort(array, true);\r\n}"
}, {
	"Path": "com.datumbox.framework.applications.nlp.TextClassifierTest.testTrainAndValidateMultinomialNaiveBayes",
	"Comment": "test of train and validate method, of class textclassifier using multinomialnaivebayes.",
	"Method": "void testTrainAndValidateMultinomialNaiveBayes(){\r\n    logger.info(\"testTrainAndValidateMultinomialNaiveBayes\");\r\n    MultinomialNaiveBayes.TrainingParameters mlParams = new MultinomialNaiveBayes.TrainingParameters();\r\n    ChisquareSelect.TrainingParameters fsParams = new ChisquareSelect.TrainingParameters();\r\n    fsParams.setALevel(0.05);\r\n    fsParams.setMaxFeatures(1000);\r\n    fsParams.setRareFeatureThreshold(3);\r\n    trainAndValidate(mlParams, fsParams, null, 0.8685865263692268, 4);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.extractors.WordSequenceExtractor.extract",
	"Comment": "this method gets as input a string and returns as output a numbered sequenceof the tokens. in the returned map as keys we store the position of the wordin the original string and as value the actual token in that position.",
	"Method": "Map<Integer, String> extract(String text){\r\n    List<String> tmpKwd = generateTokenizer().tokenize(text);\r\n    Map<Integer, String> keywordSequence = new LinkedHashMap();\r\n    int position = 0;\r\n    for (String keyword : tmpKwd) {\r\n        keywordSequence.put(position, keyword);\r\n        ++position;\r\n    }\r\n    return keywordSequence;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributionsTest.testChisquareCdf",
	"Comment": "test of chisquarecdf method, of class continuousdistributions.",
	"Method": "void testChisquareCdf(){\r\n    logger.info(\"ChisquareCdf\");\r\n    double x = 3.0;\r\n    int df = 10;\r\n    double expResult = 0.018575928421771;\r\n    double result = ContinuousDistributions.chisquareCdf(x, df);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "cyclops.monads.transformers.FutureT.of",
	"Comment": "construct an futuret from an anym that wraps a monad containingfutures",
	"Method": "FutureT<W, A> of(AnyM<W, Future<A>> monads){\r\n    return new FutureT(monads);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.independentsamples.LevenesIndependentSamplesTest.testTestVariances",
	"Comment": "test of testvariances method, of class levenesindependentsamples.",
	"Method": "void testTestVariances(){\r\n    logger.info(\"testVariances\");\r\n    TransposeDataCollection transposeDataCollection = new TransposeDataCollection();\r\n    transposeDataCollection.put(0, new FlatDataCollection(Arrays.asList(new Object[] { 60.8, 57.0, 65.0, 58.6, 61.7 })));\r\n    transposeDataCollection.put(1, new FlatDataCollection(Arrays.asList(new Object[] { 68.7, 67.7, 74.0, 66.3, 69.8 })));\r\n    transposeDataCollection.put(2, new FlatDataCollection(Arrays.asList(new Object[] { 102.6, 103.1, 100.2, 96.5 })));\r\n    transposeDataCollection.put(3, new FlatDataCollection(Arrays.asList(new Object[] { 87.9, 84.2, 83.1, 85.7, 90.3 })));\r\n    double aLevel = 0.05;\r\n    boolean expResult = true;\r\n    boolean result = LevenesIndependentSamples.testVariances(transposeDataCollection, aLevel);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.filterSync",
	"Comment": "synchronous filtering operationremoves elements that do not fold the supplied predicate from thedataflow",
	"Method": "SimpleReactStream<U> filterSync(Predicate<? super U> p){\r\n    final Function<Stream<CompletableFuture>, Stream<CompletableFuture>> fn = s -> s.map(ft -> ft.thenApply((in) -> {\r\n        if (!p.test((U) in)) {\r\n            throw new FilteredExecutionPathException();\r\n        }\r\n        return in;\r\n    }));\r\n    return this.withLastActive(getLastActive().stream(fn));\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.MapX.toSortedSetX",
	"Comment": "convert this mapx to a sortedsetx via the provided transformation function",
	"Method": "SortedSetX<T> toSortedSetX(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn){\r\n    return SortedSetX.narrow(stream().map(fn).to(ReactiveConvertableSequence::converter).sortedSetX());\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.LinkedListX.generate",
	"Comment": "generate a linkedlistx from the provided supplier up to the provided limit number of times",
	"Method": "LinkedListX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).linkedListX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.dropUntil",
	"Comment": "return a stream with the same values as this stream, but with all values omitted until the provided stream starts emitting values.provided stream ends the stream of values from this stream.",
	"Method": "ReactiveSeq<U> dropUntil(SimpleReactStream<T> s){\r\n    return EagerFutureStreamFunctions.dropUntil(this, s);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributions.binomialCdf",
	"Comment": "returns the cumulative probability of k of a specific number of tries n and probability p",
	"Method": "double binomialCdf(int k,double p,int n){\r\n    if (k < 0 || p < 0 || n < 1) {\r\n        throw new IllegalArgumentException(\"All the parameters must be positive and n larger than 1.\");\r\n    }\r\n    k = Math.min(k, n);\r\n    double probabilitySum = approxBinomialCdf(k, p, n);\r\n    return probabilitySum;\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.concurrency.WorkQueue.runWorkQueue",
	"Comment": "start a work queue on the elements in the provided collection, blocking until all work units have beencompleted.",
	"Method": "void runWorkQueue(Collection<U> elements,ExecutorService executorService,int numParallelTasks,WorkUnitProcessor<U> workUnitProcessor,InterruptionChecker interruptionChecker,LogNode log){\r\n    try (WorkQueue<U> workQueue = new WorkQueue(elements, workUnitProcessor, interruptionChecker, log)) {\r\n        workQueue.startWorkers(executorService, numParallelTasks - 1, log);\r\n        workQueue.runWorkLoop();\r\n    }\r\n}"
}, {
	"Path": "com.github.dcevm.test.util.HotSwapTestHelper.__version__",
	"Comment": "returns the current version of the inner classes of an outer class.caller class is used as an outer class.",
	"Method": "int __version__(){\r\n    return HotSwapTool.getCurrentVersion(determineOuter(0));\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributions.exponentialCdf",
	"Comment": "calculates the probability from 0 to x under exponential distribution",
	"Method": "double exponentialCdf(double x,double lamda){\r\n    if (x < 0 || lamda <= 0) {\r\n        throw new IllegalArgumentException(\"All the parameters must be positive.\");\r\n    }\r\n    double probability = 1.0 - Math.exp(-lamda * x);\r\n    return probability;\r\n}"
}, {
	"Path": "com.topologi.diffx.config.DiffXConfig.setIgnoreWhiteSpace",
	"Comment": "sets whether the differences in white spaces should be ignored or not.",
	"Method": "void setIgnoreWhiteSpace(boolean ignore){\r\n    if (!ignore) {\r\n        this.whitespace = WhiteSpaceProcessing.COMPARE;\r\n    } else {\r\n        this.whitespace = this.preserveWhiteSpace ? WhiteSpaceProcessing.PRESERVE : WhiteSpaceProcessing.IGNORE;\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.PHPSimilarText.similarityPercentage",
	"Comment": "checks the similarity of two strings and returns their similarity percentage.",
	"Method": "double similarityPercentage(String txt1,String txt2){\r\n    double sim = similarityChars(txt1, txt2);\r\n    return sim * 200.0 / (txt1.length() + txt2.length());\r\n}"
}, {
	"Path": "com.spotify.docker.client.exceptions.DockerRequestException.getResponseBody",
	"Comment": "the response body from the http response containing an error, if any.",
	"Method": "String getResponseBody(){\r\n    return responseBody;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.OperationsOnFutures.toStream",
	"Comment": "convert this futurestream to a stream of completablefutures",
	"Method": "ReactiveSeq<CompletableFuture<T>> toStream(){\r\n    return this.getLastActive().injectFuturesSeq().map(f -> f.toCompletableFuture());\r\n}"
}, {
	"Path": "buildcraft.transport.gui.ContainerGateInterface.markDirty",
	"Comment": "marks client side gate container as needing to be synchronized with the server.",
	"Method": "void markDirty(){\r\n    isSynchronized = false;\r\n}"
}, {
	"Path": "com.oath.cyclops.async.adapters.Topic.disconnect",
	"Comment": "topic will maintain a queue for each subscribing streamif a stream is finished with a topic it is good practice to disconnect from the topicso messages will no longer be stored for that stream",
	"Method": "void disconnect(ReactiveSeq<T> stream){\r\n    Option<Queue<T>> o = streamToQueue.get(stream);\r\n    distributor.removeQueue(streamToQueue.getOrElse(stream, new Queue()));\r\n    this.streamToQueue = streamToQueue.remove(stream);\r\n    this.index--;\r\n}"
}, {
	"Path": "org.jak_linux.dns66.vpn.DnsPacketProxy.handleDnsRequest",
	"Comment": "handles a dns request, by either blocking it or forwarding it to the remote location.",
	"Method": "void handleDnsRequest(byte[] packetData){\r\n    IpPacket parsedPacket = null;\r\n    try {\r\n        parsedPacket = (IpPacket) IpSelector.newPacket(packetData, 0, packetData.length);\r\n    } catch (Exception e) {\r\n        Log.i(TAG, \"handleDnsRequest: Discarding invalid IP packet\", e);\r\n        return;\r\n    }\r\n    if (!(parsedPacket.getPayload() instanceof UdpPacket)) {\r\n        Log.i(TAG, \"handleDnsRequest: Discarding unknown packet type \" + parsedPacket.getPayload());\r\n        return;\r\n    }\r\n    InetAddress destAddr = translateDestinationAdress(parsedPacket);\r\n    if (destAddr == null)\r\n        return;\r\n    UdpPacket parsedUdp = (UdpPacket) parsedPacket.getPayload();\r\n    if (parsedUdp.getPayload() == null) {\r\n        Log.i(TAG, \"handleDnsRequest: Sending UDP packet without payload: \" + parsedUdp);\r\n        DatagramPacket outPacket = new DatagramPacket(new byte[0], 0, 0, destAddr, parsedUdp.getHeader().getDstPort().valueAsInt());\r\n        eventLoop.forwardPacket(outPacket, null);\r\n        return;\r\n    }\r\n    byte[] dnsRawData = (parsedUdp).getPayload().getRawData();\r\n    Message dnsMsg;\r\n    try {\r\n        dnsMsg = new Message(dnsRawData);\r\n    } catch (IOException e) {\r\n        Log.i(TAG, \"handleDnsRequest: Discarding non-DNS or invalid packet\", e);\r\n        return;\r\n    }\r\n    if (dnsMsg.getQuestion() == null) {\r\n        Log.i(TAG, \"handleDnsRequest: Discarding DNS packet with no query \" + dnsMsg);\r\n        return;\r\n    }\r\n    String dnsQueryName = dnsMsg.getQuestion().getName().toString(true);\r\n    if (!ruleDatabase.isBlocked(dnsQueryName.toLowerCase(Locale.ENGLISH))) {\r\n        Log.i(TAG, \"handleDnsRequest: DNS Name \" + dnsQueryName + \" Allowed, sending to \" + destAddr);\r\n        DatagramPacket outPacket = new DatagramPacket(dnsRawData, 0, dnsRawData.length, destAddr, parsedUdp.getHeader().getDstPort().valueAsInt());\r\n        eventLoop.forwardPacket(outPacket, parsedPacket);\r\n    } else {\r\n        Log.i(TAG, \"handleDnsRequest: DNS Name \" + dnsQueryName + \" Blocked!\");\r\n        dnsMsg.getHeader().setFlag(Flags.QR);\r\n        dnsMsg.getHeader().setRcode(Rcode.NOERROR);\r\n        dnsMsg.addRecord(NEGATIVE_CACHE_SOA_RECORD, Section.AUTHORITY);\r\n        handleDnsResponse(parsedPacket, dnsMsg.toWire());\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.independentsamples.NormalIndependentSamples.checkCriticalValue",
	"Comment": "checks the critical value to determine if the hypothesis should be rejected",
	"Method": "boolean checkCriticalValue(double score,boolean is_twoTailed,double aLevel){\r\n    double probability = ContinuousDistributions.gaussCdf(score);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2;\r\n    }\r\n    if (probability <= a || probability >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.ListX.iterate",
	"Comment": "create a listx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "ListX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).listX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.independentsamples.Chisquare.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level",
	"Method": "boolean test(DataTable2D dataTable,double aLevel){\r\n    double pvalue = getPvalue(dataTable);\r\n    boolean rejectH0 = false;\r\n    if (pvalue <= aLevel) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "cyclops.monads.transformers.ListT.fromAnyM",
	"Comment": "construct an listt from an anym that contains a monad type that contains type other than listthe values in the underlying monad will be mapped to list",
	"Method": "ListT<W, A> fromAnyM(AnyM<W, A> anyM){\r\n    AnyM<W, ListX<A>> y = anyM.map(i -> ListX.of(i));\r\n    return of(y);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.mathematics.regularization.ElasticNetRegularizer.estimatePenalty",
	"Comment": "estimates the penalty by adding the elasticnet regularization.",
	"Method": "double estimatePenalty(double l1,double l2,Map<K, Double> weights){\r\n    double penalty = 0.0;\r\n    penalty += L2Regularizer.estimatePenalty(l2, weights);\r\n    penalty += L1Regularizer.estimatePenalty(l1, weights);\r\n    return penalty;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.independentsamples.NormalIndependentSamplesTest.testTestMeans",
	"Comment": "test of testmeans method, of class normalindependentsamples.",
	"Method": "void testTestMeans(){\r\n    logger.info(\"testMeans\");\r\n    double xbar = 215.0;\r\n    double ybar = 200.0;\r\n    int n = 60;\r\n    int m = 50;\r\n    double stdx = 55.0;\r\n    double stdy = 50.0;\r\n    boolean is_twoTailed = false;\r\n    double aLevel = 0.05;\r\n    boolean expResult = false;\r\n    boolean result = NormalIndependentSamples.testMeans(xbar, ybar, n, m, stdx, stdy, is_twoTailed, aLevel);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.extractors.NgramsExtractor.extract",
	"Comment": "this method gets as input a string and returns as output a map with theextracted keywords along with the number of their scores in the text. theirscores are a combination of occurrences and proximity metrics.",
	"Method": "Map<String, Double> extract(String text){\r\n    Map<Integer, String> ID2word = new HashMap();\r\n    Map<Integer, Double> ID2occurrences = new HashMap();\r\n    Map<Integer, Integer> position2ID = new LinkedHashMap();\r\n    int numberOfWordsInDoc = buildInternalArrays(text, ID2word, ID2occurrences, position2ID);\r\n    int maxCombinations = parameters.getMaxCombinations();\r\n    Map<String, Double> keywordsMap = new HashMap();\r\n    for (Map.Entry<Integer, Integer> entry : position2ID.entrySet()) {\r\n        Integer wordID = entry.getValue();\r\n        if (!useThisWord(wordID, ID2word, ID2occurrences)) {\r\n            continue;\r\n        }\r\n        Integer position = entry.getKey();\r\n        Map<LinkedList<Integer>, Double> positionCombinationsWithScores = getPositionCombinationsWithinWindow(position, maxCombinations, ID2word, ID2occurrences, position2ID, numberOfWordsInDoc);\r\n        for (Map.Entry<LinkedList<Integer>, Double> entry2 : positionCombinationsWithScores.entrySet()) {\r\n            LinkedList<Integer> positionCombination = entry2.getKey();\r\n            StringBuilder sb = new StringBuilder(positionCombination.size() * 6);\r\n            for (Integer pos : positionCombination) {\r\n                sb.append(ID2word.get(position2ID.get(pos))).append(\" \");\r\n            }\r\n            if (sb.length() > 0) {\r\n                String key = sb.toString().trim();\r\n                double score = entry2.getValue();\r\n                keywordsMap.put(key, keywordsMap.getOrDefault(key, 0.0) + score);\r\n            }\r\n        }\r\n    }\r\n    double minScore = parameters.getMinWordOccurrence();\r\n    Iterator<Map.Entry<String, Double>> it = keywordsMap.entrySet().iterator();\r\n    while (it.hasNext()) {\r\n        Map.Entry<String, Double> entry = it.next();\r\n        if (entry.getValue() < minScore) {\r\n            it.remove();\r\n        }\r\n    }\r\n    return keywordsMap;\r\n}"
}, {
	"Path": "org.jak_linux.dns66.SingleWriterMultipleReaderFile.failWrite",
	"Comment": "atomically replaces the active file with the work file, and closes the stream.",
	"Method": "void failWrite(FileOutputStream stream){\r\n    FileHelper.closeOrWarn(stream, \"SingleWriterMultipleReaderFile\", \"Cannot close working file\");\r\n    if (!workFile.delete())\r\n        throw new IOException(\"Cannot delete working file\");\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.Dataframe.getXDataTypes",
	"Comment": "returns an map with column names as index and datatypes as values.",
	"Method": "Map<Object, TypeInference.DataType> getXDataTypes(){\r\n    return Collections.unmodifiableMap(data.xDataTypes);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.decisiontheory.DecisionCriteriaTest.testMaximumLikelihood",
	"Comment": "test of maximumlikelihood method, of class decisioncriteria.",
	"Method": "void testMaximumLikelihood(){\r\n    logger.info(\"maximumLikelihood\");\r\n    DataTable2D payoffMatrix = generatePayoffMatrix();\r\n    AssociativeArray eventProbabilities = generateEventProbabilities();\r\n    Map.Entry<Object, Object> expResult = new AbstractMap.SimpleEntry(\"A2\", 600.0);\r\n    Map.Entry<Object, Object> result = DecisionCriteria.maximumLikelihood(payoffMatrix, eventProbabilities);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "buildcraft.robotics.EntityRobot.receiveItem",
	"Comment": "tries to receive items in parameters, return items that are left after the operation.",
	"Method": "ItemStack receiveItem(TileEntity tile,ItemStack stack){\r\n    if (currentDockingStation != null && currentDockingStation.index().subtract(tile.getPos()).distanceSq(BlockPos.ORIGIN) == 1 && mainAI != null) {\r\n        return mainAI.getActiveAI().receiveItem(stack);\r\n    } else {\r\n        return stack;\r\n    }\r\n}"
}, {
	"Path": "org.fourthline.cling.model.gena.LocalGENASubscription.moderateStateVariables",
	"Comment": "checks whether a state variable is moderated, and if this change is within the maximum rate and range limits.",
	"Method": "Set<String> moderateStateVariables(long currentTime,Collection<StateVariableValue> values){\r\n    Set<String> excludedVariables = new HashSet();\r\n    for (StateVariableValue stateVariableValue : values) {\r\n        StateVariable stateVariable = stateVariableValue.getStateVariable();\r\n        String stateVariableName = stateVariableValue.getStateVariable().getName();\r\n        if (stateVariable.getEventDetails().getEventMaximumRateMilliseconds() == 0 && stateVariable.getEventDetails().getEventMinimumDelta() == 0) {\r\n            log.finer(\"Variable is not moderated: \" + stateVariable);\r\n            continue;\r\n        }\r\n        if (!lastSentTimestamp.containsKey(stateVariableName)) {\r\n            log.finer(\"Variable is moderated but was never sent before: \" + stateVariable);\r\n            continue;\r\n        }\r\n        if (stateVariable.getEventDetails().getEventMaximumRateMilliseconds() > 0) {\r\n            long timestampLastSent = lastSentTimestamp.get(stateVariableName);\r\n            long timestampNextSend = timestampLastSent + (stateVariable.getEventDetails().getEventMaximumRateMilliseconds());\r\n            if (currentTime <= timestampNextSend) {\r\n                log.finer(\"Excluding state variable with maximum rate: \" + stateVariable);\r\n                excludedVariables.add(stateVariableName);\r\n                continue;\r\n            }\r\n        }\r\n        if (stateVariable.isModeratedNumericType() && lastSentNumericValue.get(stateVariableName) != null) {\r\n            long oldValue = Long.valueOf(lastSentNumericValue.get(stateVariableName));\r\n            long newValue = Long.valueOf(stateVariableValue.toString());\r\n            long minDelta = stateVariable.getEventDetails().getEventMinimumDelta();\r\n            if (newValue > oldValue && newValue - oldValue < minDelta) {\r\n                log.finer(\"Excluding state variable with minimum delta: \" + stateVariable);\r\n                excludedVariables.add(stateVariableName);\r\n                continue;\r\n            }\r\n            if (newValue < oldValue && oldValue - newValue < minDelta) {\r\n                log.finer(\"Excluding state variable with minimum delta: \" + stateVariable);\r\n                excludedVariables.add(stateVariableName);\r\n            }\r\n        }\r\n    }\r\n    return excludedVariables;\r\n}"
}, {
	"Path": "cyclops.kinds.CompletableFutureKind.narrow",
	"Comment": "convert the raw higher kinded type for completablefuturekind types into the completablefuturekind type definition class",
	"Method": "CompletableFutureKind<T> narrow(Higher<DataWitness.completableFuture, T> future,CompletionStage<T> narrow){\r\n    return (CompletableFutureKind<T>) future;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.onesample.Lilliefors.normalDistributionGetParams",
	"Comment": "estimate parameters of normal based on sample. this method is called via reflection.",
	"Method": "AssociativeArray normalDistributionGetParams(FlatDataCollection flatDataCollection){\r\n    AssociativeArray params = new AssociativeArray();\r\n    params.put(\"mean\", Descriptives.mean(flatDataCollection));\r\n    params.put(\"variance\", Descriptives.variance(flatDataCollection, true));\r\n    return params;\r\n}"
}, {
	"Path": "cyclops.monads.transformers.EitherT.of",
	"Comment": "construct an maybewt from an anym that wraps a monad containingmaybews",
	"Method": "EitherT<W, ST, A> of(AnyM<W, Either<ST, A>> monads){\r\n    return new EitherT(monads);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.extractors.AbstractTextExtractor.newInstance",
	"Comment": "generates a new instance of a abstracttextextractor by providing the class of the abstracttextextractor.",
	"Method": "T newInstance(TP parameters){\r\n    try {\r\n        Class<T> tClass = (Class<T>) parameters.getClass().getEnclosingClass();\r\n        return tClass.getConstructor(parameters.getClass()).newInstance(parameters);\r\n    } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | SecurityException | NoSuchMethodException ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.DiffXKumarRangan.getLCSMoreWaste",
	"Comment": "computes the longest common subsequence for the specified boundaries when the wasteis more than 1 character.this method is recursive and will process ech subsequence with the lcs algorithm.",
	"Method": "void getLCSMoreWaste(int start1,int end1,int start2,int end2,int m,int n,int lcs){\r\n    int u, v;\r\n    int r1, r2;\r\n    int waste1 = (int) Math.ceil((m - lcs) / 2.0f);\r\n    this.LL1 = calMid(end1, start1, end2, start2, m, n, -1, waste1);\r\n    r1 = this.R;\r\n    for (int j = 0; j <= r1; j++) {\r\n        this.LL1[j] = n + 1 - this.LL1[j];\r\n    }\r\n    int waste2 = (int) Math.floor((m - lcs) / 2.0f);\r\n    this.LL2 = calMid(start1, end1, start2, end2, m, n, 1, waste2);\r\n    r2 = this.R;\r\n    int k = Math.max(r1, r2);\r\n    while (k > 0) {\r\n        if (k <= r1 && lcs - k <= r2 && this.LL1[k] < this.LL2[lcs - k]) {\r\n            break;\r\n        } else {\r\n            k--;\r\n        }\r\n    }\r\n    u = k + waste1;\r\n    v = this.LL1[k];\r\n    generateLCS(start1, start1 + u - 1, start2, start2 + v - 1, u - 1 + 1, v - 1 + 1, u - waste1);\r\n    generateLCS(start1 + u, end1, start2 + v, end2, end1 - start1 + 1 - u, end2 - start2 + 1 - v, m - u - waste2);\r\n}"
}, {
	"Path": "io.github.classgraph.ClassGraph.blacklistJars",
	"Comment": "blacklist one or more jars, preventing them from being scanned.",
	"Method": "ClassGraph blacklistJars(String jarLeafNames){\r\n    for (final String jarLeafName : jarLeafNames) {\r\n        final String leafName = JarUtils.leafName(jarLeafName);\r\n        if (!leafName.equals(jarLeafName)) {\r\n            throw new IllegalArgumentException(\"Can only blacklist jars by leafname: \" + jarLeafName);\r\n        }\r\n        scanSpec.jarWhiteBlackList.addToBlacklist(leafName);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.fourthline.cling.transport.spi.UpnpStream.responseSent",
	"Comment": "must be called by a subclass after the response has been successfully sent to the client.",
	"Method": "void responseSent(StreamResponseMessage responseMessage){\r\n    if (syncProtocol != null)\r\n        syncProtocol.responseSent(responseMessage);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributionsTest.testGaussInverseCdf",
	"Comment": "test of gaussinversecdf method, of class continuousdistributions.",
	"Method": "void testGaussInverseCdf(){\r\n    logger.info(\"GaussInverseCdf\");\r\n    double p = 0.32;\r\n    double expResult = -0.46769879942903;\r\n    double result = ContinuousDistributions.gaussInverseCdf(p);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "cyclops.companion.Streams.cycle",
	"Comment": "create a stream that infiniteable cycles the provided streamable",
	"Method": "Stream<U> cycle(Stream<U> s,Stream<U> cycle,Streamable<U> s,Stream<U> cycle,long times,Streamable<U> s){\r\n    return Stream.iterate(s.stream(), s1 -> s.stream()).limit(times).flatMap(Function.identity());\r\n}"
}, {
	"Path": "io.github.classgraph.PackageInfo.getChildren",
	"Comment": "the child packages of this package, or the empty list if none.",
	"Method": "List<PackageInfo> getChildren(){\r\n    if (children == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    final List<PackageInfo> childrenSorted = new ArrayList(children);\r\n    Collections.sort(childrenSorted, new Comparator<PackageInfo>() {\r\n        @Override\r\n        public int compare(final PackageInfo o1, final PackageInfo o2) {\r\n            return o1.name.compareTo(o2.name);\r\n        }\r\n    });\r\n    return childrenSorted;\r\n}"
}, {
	"Path": "io.github.classgraph.PackageInfo.getChildren",
	"Comment": "the child packages of this package, or the empty list if none.",
	"Method": "List<PackageInfo> getChildren(){\r\n    return o1.name.compareTo(o2.name);\r\n}"
}, {
	"Path": "org.fourthline.cling.support.contentdirectory.DIDLParser.debugXML",
	"Comment": "sends the given string to the log with level.fine, if that log level is enabled.",
	"Method": "void debugXML(String s){\r\n    if (log.isLoggable(Level.FINE)) {\r\n        log.fine(\"-------------------------------------------------------------------------------------\");\r\n        log.fine(\"\\n\" + s);\r\n        log.fine(\"-------------------------------------------------------------------------------------\");\r\n    }\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.EagerFutureStreamFunctions.firstOf",
	"Comment": "return first stream out of provided streams that starts emitted results",
	"Method": "SimpleReactStream<U> firstOf(SimpleReactStream<U> futureStreams){\r\n    final List<Tuple2<SimpleReactStream<U>, QueueReader>> racers = Stream.of(futureStreams).map(s -> Tuple.tuple(s, new Queue.QueueReader(s.toQueue(), null))).collect(Collectors.toList());\r\n    while (true) {\r\n        for (final Tuple2<SimpleReactStream<U>, Queue.QueueReader> q : racers) {\r\n            if (q._2().notEmpty()) {\r\n                EagerFutureStreamFunctions.closeOthers(q._2().getQueue(), racers.stream().map(t -> t._2().getQueue()).collect(Collectors.toList()));\r\n                closeOthers(q._1(), racers.stream().map(t -> t._1()).collect(Collectors.toList()));\r\n                return q._1().fromStream(q._2().getQueue().stream(q._1().getSubscription()));\r\n            }\r\n        }\r\n        LockSupport.parkNanos(1l);\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.independentsamples.KolmogorovSmirnovIndependentSamples.checkCriticalValue",
	"Comment": "checks the critical value to determine if the hypothesis should be rejected",
	"Method": "boolean checkCriticalValue(double score,boolean is_twoTailed,int n1,int n2,double aLevel){\r\n    boolean rejected = false;\r\n    double criticalValue = calculateCriticalValue(is_twoTailed, n1, n2, aLevel);\r\n    if (score > criticalValue) {\r\n        rejected = true;\r\n    }\r\n    return rejected;\r\n}"
}, {
	"Path": "buildcraft.transport.PipeTransportItems.reverseItem",
	"Comment": "bounces the item back into the pipe without changing the items map.",
	"Method": "void reverseItem(TravelingItem item){\r\n    if (item.isCorrupted()) {\r\n        return;\r\n    }\r\n    item.toCenter = true;\r\n    item.input = item.output.getOpposite();\r\n    readjustSpeed(item);\r\n    readjustPosition(item);\r\n    PipeEventItem.Entered event = new PipeEventItem.Entered(container.pipe, item);\r\n    container.pipe.eventBus.handleEvent(event);\r\n    if (event.cancelled) {\r\n        return;\r\n    }\r\n    if (!container.getWorld().isRemote) {\r\n        item.output = resolveDestination(item);\r\n    }\r\n    items.unscheduleRemoval(item);\r\n    if (!container.getWorld().isRemote) {\r\n        sendTravelerPacket(item, true);\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.common.utilities.ReflectionMethods.getAllFields",
	"Comment": "gets all the fields recursively from all the parent classes.",
	"Method": "List<Field> getAllFields(List<Field> fields,Class<?> type){\r\n    fields.addAll(Arrays.asList(type.getDeclaredFields()));\r\n    if (type.getSuperclass() != null) {\r\n        fields = getAllFields(fields, type.getSuperclass());\r\n    }\r\n    return fields;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentQueueX.rangeLong",
	"Comment": "create a persistentqueuex that contains the longs between skip and take",
	"Method": "PersistentQueueX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).persistentQueueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.onesample.KolmogorovSmirnovOneSampleTest.testTest",
	"Comment": "test of test method, of class kolmogorovsmirnovonesample.",
	"Method": "void testTest(){\r\n    logger.info(\"test\");\r\n    FlatDataCollection flatDataCollection = new FlatDataCollection(Arrays.asList(new Object[] { 33.4, 33.3, 31.0, 31.4, 33.5, 34.4, 33.7, 36.2, 34.9, 37.0 }));\r\n    String cdfMethod = \"normalDistribution\";\r\n    AssociativeArray params = new AssociativeArray();\r\n    params.put(\"mean\", 32.0);\r\n    params.put(\"variance\", 3.24);\r\n    boolean is_twoTailed = true;\r\n    double aLevel = 0.05;\r\n    boolean expResult = true;\r\n    boolean result = KolmogorovSmirnovOneSample.test(flatDataCollection, cdfMethod, params, is_twoTailed, aLevel);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "org.fourthline.cling.transport.spi.UpnpStream.responseException",
	"Comment": "must be called by a subclass if the response was not delivered to the client.",
	"Method": "void responseException(Throwable t){\r\n    if (syncProtocol != null)\r\n        syncProtocol.responseException(t);\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.DiffXFitsy.setupMatrix",
	"Comment": "determines the most appropriate matrix to use.calculates the maximum length of the shortest weighted path if both sequencesare totally different, which corresponds to the sum of all the events.",
	"Method": "Matrix setupMatrix(EventSequence s1,EventSequence s2){\r\n    int max = 0;\r\n    for (int i = 0; i < s1.size(); i++) {\r\n        max += s1.getEvent(i).getWeight();\r\n    }\r\n    for (int i = 0; i < s2.size(); i++) {\r\n        max += s2.getEvent(i).getWeight();\r\n    }\r\n    if (max > Short.MAX_VALUE)\r\n        return new MatrixInt();\r\n    else\r\n        return new MatrixShort();\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.json.JSONSerializer.toJSONGraph",
	"Comment": "turn an object graph into a graph of json objects, arrays, and values.",
	"Method": "Object toJSONGraph(Object obj,Set<ReferenceEqualityKey<Object>> visitedOnPath,Set<ReferenceEqualityKey<Object>> standardObjectVisited,ClassFieldCache classFieldCache,Map<ReferenceEqualityKey<Object>, JSONObject> objToJSONVal,boolean onlySerializePublicFields){\r\n    if (obj == null || obj instanceof String || obj instanceof Integer || obj instanceof Boolean || obj instanceof Long || obj instanceof Float || obj instanceof Double || obj instanceof Short || obj instanceof Byte || obj instanceof Character || obj.getClass().isEnum()) {\r\n        return obj;\r\n    }\r\n    final ReferenceEqualityKey<Object> objKey = new ReferenceEqualityKey(obj);\r\n    if (!visitedOnPath.add(objKey)) {\r\n        if (JSONUtils.isCollectionOrArray(obj)) {\r\n            throw new IllegalArgumentException(\"Cycles involving collections cannot be serialized, since collections are not \" + \"assigned object ids. Reached cycle at: \" + obj);\r\n        } else {\r\n            return new JSONReference(obj);\r\n        }\r\n    }\r\n    Object jsonVal;\r\n    final Class<?> cls = obj.getClass();\r\n    if (Map.class.isAssignableFrom(cls)) {\r\n        final Map<Object, Object> map = (Map<Object, Object>) obj;\r\n        final ArrayList<?> keys = new ArrayList(map.keySet());\r\n        final int n = keys.size();\r\n        boolean keysComparable = false;\r\n        Object firstNonNullKey = null;\r\n        for (int i = 0; i < n && firstNonNullKey == null; i++) {\r\n            firstNonNullKey = keys.get(i);\r\n        }\r\n        if (firstNonNullKey != null) {\r\n            if (Comparable.class.isAssignableFrom(firstNonNullKey.getClass())) {\r\n                Collections.sort((ArrayList<Comparable>) keys);\r\n                keysComparable = true;\r\n            }\r\n        }\r\n        final String[] convertedKeys = new String[n];\r\n        for (int i = 0; i < n; i++) {\r\n            final Object key = keys.get(i);\r\n            if (!JSONUtils.isBasicValueType(key)) {\r\n                throw new IllegalArgumentException(\"Map key of type \" + key.getClass().getName() + \" is not a basic type (String, Integer, etc.), so can't be easily \" + \"serialized as a JSON associative array key\");\r\n            }\r\n            convertedKeys[i] = JSONUtils.escapeJSONString(key.toString());\r\n        }\r\n        if (!keysComparable) {\r\n            Arrays.sort(convertedKeys);\r\n        }\r\n        final Object[] convertedVals = new Object[n];\r\n        for (int i = 0; i < n; i++) {\r\n            convertedVals[i] = map.get(keys.get(i));\r\n        }\r\n        convertVals(convertedVals, visitedOnPath, standardObjectVisited, classFieldCache, objToJSONVal, onlySerializePublicFields);\r\n        final List<Entry<String, Object>> convertedKeyValPairs = new ArrayList(n);\r\n        for (int i = 0; i < n; i++) {\r\n            convertedKeyValPairs.add(new SimpleEntry(convertedKeys[i], convertedVals[i]));\r\n        }\r\n        jsonVal = new JSONObject(convertedKeyValPairs);\r\n    } else if (cls.isArray() || List.class.isAssignableFrom(cls)) {\r\n        final boolean isList = List.class.isAssignableFrom(cls);\r\n        final List<?> list = isList ? (List<?>) obj : null;\r\n        final int n = isList ? list.size() : Array.getLength(obj);\r\n        final Object[] convertedVals = new Object[n];\r\n        for (int i = 0; i < n; i++) {\r\n            convertedVals[i] = isList ? list.get(i) : Array.get(obj, i);\r\n        }\r\n        convertVals(convertedVals, visitedOnPath, standardObjectVisited, classFieldCache, objToJSONVal, onlySerializePublicFields);\r\n        jsonVal = new JSONArray(Arrays.asList(convertedVals));\r\n    } else if (Collection.class.isAssignableFrom(cls)) {\r\n        final Collection<?> collection = (Collection<?>) obj;\r\n        final List<Object> convertedValsList = new ArrayList(collection);\r\n        final Object[] convertedVals = convertedValsList.toArray();\r\n        convertVals(convertedVals, visitedOnPath, standardObjectVisited, classFieldCache, objToJSONVal, onlySerializePublicFields);\r\n        jsonVal = new JSONArray(Arrays.asList(convertedVals));\r\n    } else {\r\n        try {\r\n            final ClassFields resolvedFields = classFieldCache.get(cls);\r\n            final List<FieldTypeInfo> fieldOrder = resolvedFields.fieldOrder;\r\n            final int n = fieldOrder.size();\r\n            final String[] fieldNames = new String[n];\r\n            final Object[] convertedVals = new Object[n];\r\n            for (int i = 0; i < n; i++) {\r\n                final FieldTypeInfo fieldInfo = fieldOrder.get(i);\r\n                final Field field = fieldInfo.field;\r\n                fieldNames[i] = field.getName();\r\n                convertedVals[i] = JSONUtils.getFieldValue(obj, field);\r\n            }\r\n            convertVals(convertedVals, visitedOnPath, standardObjectVisited, classFieldCache, objToJSONVal, onlySerializePublicFields);\r\n            final List<Entry<String, Object>> convertedKeyValPairs = new ArrayList(n);\r\n            for (int i = 0; i < n; i++) {\r\n                convertedKeyValPairs.add(new SimpleEntry(fieldNames[i], convertedVals[i]));\r\n            }\r\n            jsonVal = new JSONObject(convertedKeyValPairs);\r\n        } catch (IllegalArgumentException | IllegalAccessException e) {\r\n            throw new RuntimeException(\"Could not get value of field in object: \" + obj, e);\r\n        }\r\n    }\r\n    visitedOnPath.remove(objKey);\r\n    return jsonVal;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.DequeX.rangeLong",
	"Comment": "create a dequex that contains the longs between skip and take",
	"Method": "DequeX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).dequeX(LAZY);\r\n}"
}, {
	"Path": "com.github.dcevm.HotSwapTool.getCurrentVersion",
	"Comment": "returns the current version of the inner classes of a specified outer class.",
	"Method": "int getCurrentVersion(Class<?> baseClass){\r\n    if (!currentVersion.containsKey(baseClass)) {\r\n        currentVersion.put(baseClass, 0);\r\n    }\r\n    return currentVersion.get(baseClass);\r\n}"
}, {
	"Path": "cyclops.function.Monoid.fromBiFunction",
	"Comment": "construct a monoid from the supplied identity element and combining function",
	"Method": "Monoid<T> fromBiFunction(T zero,BiFunction<T, T, T> combiner){\r\n    return new Monoid<T>() {\r\n        @Override\r\n        public T zero() {\r\n            return zero;\r\n        }\r\n        @Override\r\n        public T apply(final T t, final T u) {\r\n            return combiner.apply(t, u);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "cyclops.function.Monoid.fromBiFunction",
	"Comment": "construct a monoid from the supplied identity element and combining function",
	"Method": "Monoid<T> fromBiFunction(T zero,BiFunction<T, T, T> combiner){\r\n    return zero;\r\n}"
}, {
	"Path": "cyclops.function.Monoid.fromBiFunction",
	"Comment": "construct a monoid from the supplied identity element and combining function",
	"Method": "Monoid<T> fromBiFunction(T zero,BiFunction<T, T, T> combiner){\r\n    return combiner.apply(t, u);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.descriptivestatistics.Descriptives.normalize",
	"Comment": "normalizes the provided associative array by dividing its values with thesum of the observations.",
	"Method": "void normalize(AssociativeArray associativeArray){\r\n    double sum = 0.0;\r\n    for (Map.Entry<Object, Object> entry : associativeArray.entrySet()) {\r\n        Double value = TypeInference.toDouble(entry.getValue());\r\n        associativeArray.put(entry.getKey(), value);\r\n        sum += value;\r\n    }\r\n    if (sum != 0.0) {\r\n        for (Map.Entry<Object, Object> entry : associativeArray.entrySet()) {\r\n            associativeArray.put(entry.getKey(), TypeInference.toDouble(entry.getValue()) / sum);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "cyclops.companion.reactor.Monos.fromIterable",
	"Comment": "construct a mono from iterable by taking the first value from iterable",
	"Method": "Mono<T> fromIterable(Iterable<T> t){\r\n    return Mono.from(Flux.fromIterable(t));\r\n}"
}, {
	"Path": "buildcraft.core.lib.client.render.FluidRenderer.getFluidTexture",
	"Comment": "this will always return a texture object, but it will be the missing icon texture if the fluid is null or atexture does not exist.",
	"Method": "TextureAtlasSprite getFluidTexture(FluidStack stack,FluidType type,TextureAtlasSprite getFluidTexture,Fluid fluid,FluidType type){\r\n    if (fluid == null || type == null) {\r\n        return missingIcon;\r\n    }\r\n    Map<Fluid, TextureAtlasSprite> map = INSTANCE.textureMap.get(type);\r\n    return map.containsKey(fluid) ? map.get(fluid) : missingIcon;\r\n}"
}, {
	"Path": "com.github.dockerjava.api.model.BindingTest.parseInvalidInput",
	"Comment": "strings can be used since it can be a range. let the docker daemon do the validation.",
	"Method": "void parseInvalidInput(){\r\n    expectedEx.expect(IllegalArgumentException.class);\r\n    expectedEx.expectMessage(\"Error parsing Binding 'nonsense'\");\r\n    Binding.parse(\"nonsense\");\r\n}"
}, {
	"Path": "com.datumbox.framework.common.concurrency.ConcurrencyConfiguration.getMaxNumberOfThreadsPerTask",
	"Comment": "returns the maximum number of threads which can be used for a specifictask by the framework.",
	"Method": "Integer getMaxNumberOfThreadsPerTask(){\r\n    return maxNumberOfThreadsPerTask;\r\n}"
}, {
	"Path": "buildcraft.transport.PipeConnectionBans.banConnection",
	"Comment": "will ban connection between any set of pipe types provided.if only one parameter is passed in, it will ban connection to pipes of the same type.",
	"Method": "void banConnection(Class<? extends Pipe<?>> types){\r\n    if (types.length == 0) {\r\n        return;\r\n    }\r\n    if (types.length == 1) {\r\n        connectionBans.put(types[0], types[0]);\r\n        return;\r\n    }\r\n    for (int i = 0; i < types.length; i++) {\r\n        for (int j = 0; j < types.length; j++) {\r\n            if (i == j) {\r\n                continue;\r\n            }\r\n            connectionBans.put(types[i], types[j]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AssociativeArray.addValues",
	"Comment": "adds the provided associative array to the current object. all the columnsof this object should be numeric or boolean or else an exception is thrown.",
	"Method": "void addValues(AssociativeArray array){\r\n    addRemoveValues(array, +1);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXWithError",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXWithError(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    final CompletableFuture<Subscription> subscription = new CompletableFuture();\r\n    final CompletableFuture<Boolean> streamCompleted = new CompletableFuture();\r\n    return tuple(subscription, () -> {\r\n        stream.subscribe(new Subscriber<T>() {\r\n            @Override\r\n            public void onSubscribe(final Subscription s) {\r\n                Objects.requireNonNull(s);\r\n                if (x != 0)\r\n                    s.request(x);\r\n                subscription.complete(s);\r\n            }\r\n            @Override\r\n            public void onNext(final T t) {\r\n                consumerElement.accept(t);\r\n            }\r\n            @Override\r\n            public void onError(final Throwable t) {\r\n                consumerError.accept(t);\r\n            }\r\n            @Override\r\n            public void onComplete() {\r\n                streamCompleted.complete(true);\r\n            }\r\n        });\r\n    }, streamCompleted);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXWithError",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXWithError(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    Objects.requireNonNull(s);\r\n    if (x != 0)\r\n        s.request(x);\r\n    subscription.complete(s);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXWithError",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXWithError(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    consumerElement.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXWithError",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXWithError(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    consumerError.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXWithError",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXWithError(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    streamCompleted.complete(true);\r\n}"
}, {
	"Path": "buildcraft.core.lib.client.render.RenderResizableCuboid.getRenderInfos",
	"Comment": "a way to automatically generate the different positions given the same arguments.",
	"Method": "List<RenderInfo> getRenderInfos(float[] uv,EnumFacing face,Vec3d size,Vec3d texSize,Vec3d texOffset,List<RenderInfo> getRenderInfos,float[] uv,double sizeU,double sizeV,double textureSizeU,double textureSizeV,double textureOffsetU,double textureOffsetV){\r\n    List<RenderInfo> infos = Lists.newArrayList();\r\n    boolean firstU = true;\r\n    for (double u = 0; u < sizeU; u += textureSizeU) {\r\n        float[] uvCu = Arrays.copyOf(uv, 4);\r\n        double addU = textureSizeU;\r\n        boolean lowerU = false;\r\n        if (firstU && textureOffsetU != 0) {\r\n            uvCu[U_MIN] = uvCu[U_MIN] + (uvCu[U_MAX] - uvCu[U_MIN]) * (float) textureOffsetU;\r\n            addU -= textureOffsetU;\r\n            lowerU = true;\r\n        }\r\n        if (u + addU > sizeU) {\r\n            addU = sizeU - u;\r\n            if (firstU && textureOffsetU != 0) {\r\n                uvCu[U_MAX] = uvCu[U_MIN] + (uvCu[U_MAX] - uvCu[U_MIN]) * (float) (addU / (textureSizeU - textureOffsetU));\r\n            } else {\r\n                uvCu[U_MAX] = uvCu[U_MIN] + (uvCu[U_MAX] - uvCu[U_MIN]) * (float) (addU / textureSizeU);\r\n            }\r\n        }\r\n        firstU = false;\r\n        boolean firstV = true;\r\n        for (double v = 0; v < sizeV; v += textureSizeV) {\r\n            float[] uvCv = Arrays.copyOf(uvCu, 4);\r\n            double addV = textureSizeV;\r\n            boolean lowerV = false;\r\n            if (firstV && textureOffsetV != 0) {\r\n                uvCv[V_MIN] = uvCv[V_MIN] + (uvCv[V_MAX] - uvCv[V_MIN]) * (float) textureOffsetV;\r\n                addV -= textureOffsetV;\r\n                lowerV = true;\r\n            }\r\n            if (v + addV > sizeV) {\r\n                addV = sizeV - v;\r\n                if (firstV && textureOffsetV != 0) {\r\n                    uvCv[V_MAX] = uvCv[V_MIN] + (uvCv[V_MAX] - uvCv[V_MIN]) * (float) (addV / (textureSizeV - textureOffsetV));\r\n                } else {\r\n                    uvCv[V_MAX] = uvCv[V_MIN] + (uvCv[V_MAX] - uvCv[V_MIN]) * (float) (addV / textureSizeV);\r\n                }\r\n            }\r\n            double[] xyz = new double[4];\r\n            xyz[U_MIN] = u;\r\n            xyz[U_MAX] = u + addU;\r\n            xyz[V_MIN] = v;\r\n            xyz[V_MAX] = v + addV;\r\n            infos.add(new RenderInfo(uvCv, xyz));\r\n            if (lowerV) {\r\n                v -= textureOffsetV;\r\n            }\r\n            firstV = false;\r\n        }\r\n        if (lowerU) {\r\n            u -= textureOffsetU;\r\n        }\r\n    }\r\n    return infos;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.Dataframe.contains",
	"Comment": "checks if the record exists in the dataframe. note that the record is checked onlyfor its x and y components.",
	"Method": "boolean contains(Object o){\r\n    return data.records.containsValue((Record) o);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributionsTest.testBetaCdf",
	"Comment": "test of betacdf method, of class continuousdistributions.",
	"Method": "void testBetaCdf(){\r\n    logger.info(\"BetaCdf\");\r\n    double x = 0.9;\r\n    double a = 10.0;\r\n    double b = 2.0;\r\n    double expResult = 0.69735688048532;\r\n    double result = ContinuousDistributions.betaCdf(x, a, b);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.descriptivestatistics.Ranks.getRanksFromValues",
	"Comment": "replaces the actual values of the associativearray with their ranks andreturns in the tiecounter the keys that occur more than once and thenumber of occurrences. the tiecounter does not store the list and ranksof the actual ties because we never use them.",
	"Method": "AssociativeArray getRanksFromValues(FlatDataList flatDataCollection,AssociativeArray getRanksFromValues,AssociativeArray associativeArray){\r\n    AssociativeArray tiesCounter = new AssociativeArray();\r\n    Map<Object, Double> key2AvgRank = new LinkedHashMap();\r\n    _buildRankArrays(associativeArray.toFlatDataList(), tiesCounter, key2AvgRank);\r\n    for (Map.Entry<Object, Object> entry : associativeArray.entrySet()) {\r\n        associativeArray.put(entry.getKey(), key2AvgRank.get(entry.getValue()));\r\n    }\r\n    return tiesCounter;\r\n}"
}, {
	"Path": "io.github.classgraph.ClasspathElementDir.scanDirRecursively",
	"Comment": "recursively scan a directory for file path patterns matching the scan spec.",
	"Method": "void scanDirRecursively(File dir,LogNode log){\r\n    if (skipClasspathElement) {\r\n        return;\r\n    }\r\n    String canonicalPath;\r\n    try {\r\n        canonicalPath = dir.getCanonicalPath();\r\n        if (!scannedCanonicalPaths.add(canonicalPath)) {\r\n            if (log != null) {\r\n                log.log(\"Reached symlink cycle, stopping recursion: \" + dir);\r\n            }\r\n            return;\r\n        }\r\n    } catch (final IOException | SecurityException e) {\r\n        if (log != null) {\r\n            log.log(\"Could not canonicalize path: \" + dir, e);\r\n        }\r\n        return;\r\n    }\r\n    final String dirPath = dir.getPath();\r\n    final // \r\n    String dirRelativePath = ignorePrefixLen > dirPath.length() ? \"/\" : dirPath.substring(ignorePrefixLen).replace(File.separatorChar, '/') + \"/\";\r\n    if (nestedClasspathRootPrefixes != null) {\r\n        if (nestedClasspathRootPrefixes.contains(dirRelativePath)) {\r\n            if (log != null) {\r\n                log.log(\"Reached nested classpath root, stopping recursion to avoid duplicate scanning: \" + dirRelativePath);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    if (!scanSpec.classpathElementResourcePathWhiteBlackList.whitelistAndBlacklistAreEmpty()) {\r\n        if (scanSpec.classpathElementResourcePathWhiteBlackList.isBlacklisted(dirRelativePath)) {\r\n            if (log != null) {\r\n                log.log(\"Reached blacklisted classpath element resource path, stopping scanning: \" + dirRelativePath);\r\n            }\r\n            skipClasspathElement = true;\r\n            return;\r\n        }\r\n        if (scanSpec.classpathElementResourcePathWhiteBlackList.isSpecificallyWhitelisted(dirRelativePath)) {\r\n            if (log != null) {\r\n                log.log(\"Reached specifically whitelisted classpath element resource path: \" + dirRelativePath);\r\n            }\r\n            containsSpecificallyWhitelistedClasspathElementResourcePath = true;\r\n        }\r\n    }\r\n    final ScanSpecPathMatch parentMatchStatus = scanSpec.dirWhitelistMatchStatus(dirRelativePath);\r\n    if (parentMatchStatus == ScanSpecPathMatch.HAS_BLACKLISTED_PATH_PREFIX) {\r\n        if (log != null) {\r\n            log.log(\"Reached blacklisted directory, stopping recursive scan: \" + dirRelativePath);\r\n        }\r\n        return;\r\n    }\r\n    if (parentMatchStatus == ScanSpecPathMatch.NOT_WITHIN_WHITELISTED_PATH) {\r\n        return;\r\n    }\r\n    final File[] filesInDir = dir.listFiles();\r\n    Arrays.sort(filesInDir);\r\n    if (filesInDir == null) {\r\n        if (log != null) {\r\n            log.log(\"Invalid directory \" + dir);\r\n        }\r\n        return;\r\n    }\r\n    final LogNode subLog = log == null ? null : log.log(canonicalPath, \"Scanning directory: \" + dir + (dir.getPath().equals(canonicalPath) ? \"\" : \" ; canonical path: \" + canonicalPath));\r\n    if (parentMatchStatus != ScanSpecPathMatch.ANCESTOR_OF_WHITELISTED_PATH) {\r\n        for (final File fileInDir : filesInDir) {\r\n            if (fileInDir.isFile()) {\r\n                final String fileInDirRelativePath = dirRelativePath.isEmpty() || \"/\".equals(dirRelativePath) ? fileInDir.getName() : dirRelativePath + fileInDir.getName();\r\n                if (!scanSpec.classpathElementResourcePathWhiteBlackList.whitelistAndBlacklistAreEmpty()) {\r\n                    if (scanSpec.classpathElementResourcePathWhiteBlackList.isBlacklisted(fileInDirRelativePath)) {\r\n                        if (subLog != null) {\r\n                            subLog.log(\"Reached blacklisted classpath element resource path, stopping scanning: \" + fileInDirRelativePath);\r\n                        }\r\n                        skipClasspathElement = true;\r\n                        return;\r\n                    }\r\n                    if (scanSpec.classpathElementResourcePathWhiteBlackList.isSpecificallyWhitelisted(fileInDirRelativePath)) {\r\n                        if (subLog != null) {\r\n                            subLog.log(\"Reached specifically whitelisted classpath element resource path: \" + fileInDirRelativePath);\r\n                        }\r\n                        containsSpecificallyWhitelistedClasspathElementResourcePath = true;\r\n                    }\r\n                }\r\n                if (parentMatchStatus == ScanSpecPathMatch.HAS_WHITELISTED_PATH_PREFIX || parentMatchStatus == ScanSpecPathMatch.AT_WHITELISTED_PATH || (parentMatchStatus == ScanSpecPathMatch.AT_WHITELISTED_CLASS_PACKAGE && scanSpec.classfileIsSpecificallyWhitelisted(fileInDirRelativePath))) {\r\n                    final Resource resource = newResource(classpathEltDir, fileInDirRelativePath, fileInDir);\r\n                    addWhitelistedResource(resource, parentMatchStatus, subLog);\r\n                    fileToLastModified.put(fileInDir, fileInDir.lastModified());\r\n                } else {\r\n                    if (subLog != null) {\r\n                        subLog.log(\"Skipping non-whitelisted file: \" + fileInDirRelativePath);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (final File fileInDir : filesInDir) {\r\n        if (fileInDir.isDirectory()) {\r\n            scanDirRecursively(fileInDir, subLog);\r\n            if (subLog != null) {\r\n                subLog.addElapsedTime();\r\n            }\r\n            if (skipClasspathElement) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    fileToLastModified.put(dir, dir.lastModified());\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.concurrency.WorkQueue.addWorkUnit",
	"Comment": "add a unit of work. may be called by workers to add more work units to the tail of the queue.",
	"Method": "void addWorkUnit(T workUnit){\r\n    numWorkUnitsRemaining.incrementAndGet();\r\n    workQueue.add(workUnit);\r\n}"
}, {
	"Path": "com.oath.cyclops.util.stream.scheduling.cron.CronExpression.setCalendarHour",
	"Comment": "advance the calendar to the particular hour paying particular attentionto daylight saving problems.",
	"Method": "void setCalendarHour(Calendar cal,int hour){\r\n    cal.set(java.util.Calendar.HOUR_OF_DAY, hour);\r\n    if (cal.get(java.util.Calendar.HOUR_OF_DAY) != hour && hour != 24) {\r\n        cal.set(java.util.Calendar.HOUR_OF_DAY, hour + 1);\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.FlatDataList.getDouble",
	"Comment": "gets an element at the specified position in this list, converts it intodouble and returns its value. the value must be numeric or boolean or elsean exception is thrown.",
	"Method": "Double getDouble(int index){\r\n    return TypeInference.toDouble(internalData.get(index));\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.utils.InputStreamOrByteBufferAdapter.readLong",
	"Comment": "read a long from the buffer at a specific offset before the current read point.",
	"Method": "long readLong(long readLong,int offset){\r\n    final int bytesToRead = Math.max(0, offset + 8 - used);\r\n    if (bytesToRead > 0) {\r\n        throw new IllegalArgumentException(\"Can only read from absolute offsets before the current location in the file\");\r\n    }\r\n    return (((long) (((buf[offset] & 0xff) << 24) | ((buf[offset + 1] & 0xff) << 16) | ((buf[offset + 2] & 0xff) << 8) | (buf[offset + 3] & 0xff))) << 32) | (long) (((buf[offset + 4] & 0xff) << 24) | ((buf[offset + 5] & 0xff) << 16) | ((buf[offset + 6] & 0xff) << 8) | (buf[offset + 7] & 0xff));\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentSetX.iterate",
	"Comment": "create a persistentsetx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "PersistentSetX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).persistentSetX(LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributionsTest.testGammaCdf",
	"Comment": "test of gammacdf method, of class continuousdistributions.",
	"Method": "void testGammaCdf(){\r\n    logger.info(\"GammaCdf\");\r\n    double x = 9.0;\r\n    double a = 10.0;\r\n    double b = 2.0;\r\n    double expResult = 0.017092718679951;\r\n    double result = ContinuousDistributions.gammaCdf(x, a, b);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "cyclops.reactive.ReactiveSeq.permutations",
	"Comment": "generate the permutations based on values in the reactiveseq makes use ofstreamable to store intermediate stages in a tox",
	"Method": "ReactiveSeq<ReactiveSeq<T>> permutations(){\r\n    return Streams.permutations(toArray());\r\n}"
}, {
	"Path": "com.oath.cyclops.types.Value.toEither",
	"Comment": "convert to an xor where the left value will be used if no right value is present",
	"Method": "Either<ST, T> toEither(ST secondary){\r\n    return fold(p -> Either.right(p), () -> Either.left(secondary));\r\n}"
}, {
	"Path": "cyclops.reactive.ReactiveSeq.range",
	"Comment": "create an efficiently reversable sequence that produces the integersbetween skip and take",
	"Method": "ReactiveSeq<Integer> range(int start,int end,ReactiveSeq<Integer> range,int start,int step,int end){\r\n    if (start > end)\r\n        return range(end, step, start);\r\n    final ReversingRangeIntSpliterator range = new ReversingRangeIntSpliterator(start, end, step, false);\r\n    return Streams.reactiveSeq(range, Optional.ofNullable(range));\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.LazySimpleReactStream.filter",
	"Comment": "removes elements that do not fold the supplied predicate from thedataflow",
	"Method": "LazySimpleReactStream<U> filter(Predicate<? super U> p){\r\n    if (!isAsync())\r\n        return filterSync(p);\r\n    final Function<PipelineBuilder, PipelineBuilder> fn = ft -> ft.thenApplyAsync((in) -> {\r\n        if (!p.test((U) in)) {\r\n            throw new FilteredExecutionPathException();\r\n        }\r\n        return in;\r\n    }, getTaskExecutor());\r\n    return this.withLastActive(getLastActive().operation(fn));\r\n}"
}, {
	"Path": "buildcraft.core.lib.utils.MatrixTranformations.mirrorY",
	"Comment": "mirrors the array on the y axis by calculating offsets from 0.5f",
	"Method": "void mirrorY(float[][] targetArray){\r\n    float temp = targetArray[1][0];\r\n    targetArray[1][0] = (targetArray[1][1] - 0.5F) * -1F + 0.5F;\r\n    targetArray[1][1] = (temp - 0.5F) * -1F + 0.5F;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.independentsamples.LevenesIndependentSamples.checkCriticalValue",
	"Comment": "checks the critical value to determine if the hypothesis should be rejected.",
	"Method": "boolean checkCriticalValue(double score,int n,int k,double aLevel){\r\n    double probability = ContinuousDistributions.fCdf(score, k - 1, n - k);\r\n    boolean rejectH0 = false;\r\n    if (probability <= aLevel || probability >= (1 - aLevel)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "cyclops.companion.Streams.foldMap",
	"Comment": "attempt to transform this stream to the same type as the supplied monoid, using supplied function then use monoid to reduce values",
	"Method": "R foldMap(Stream<T> stream,Reducer<R, T> reducer,R foldMap,Stream<T> stream,Function<? super T, ? extends R> mapper,Monoid<R> reducer){\r\n    return reducer.foldLeft(stream.map(mapper));\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.SimpleRandomSampling.pbarStd",
	"Comment": "calculates standard deviation for pbar for finite population size",
	"Method": "double pbarStd(double pbar,int sampleN,double pbarStd,double pbar,int sampleN,int populationN){\r\n    return Math.sqrt(pbarVariance(pbar, sampleN, populationN));\r\n}"
}, {
	"Path": "cyclops.companion.Streams.debounce",
	"Comment": "allow one element through per time period, drop all other elements inthat time period",
	"Method": "Stream<T> debounce(Stream<T> stream,long time,TimeUnit t){\r\n    return new DebounceOperator(stream).debounce(time, t);\r\n}"
}, {
	"Path": "io.github.classgraph.FieldInfo.getClassNamesFromTypeDescriptors",
	"Comment": "get the names of any classes in the type descriptor or type signature.",
	"Method": "void getClassNamesFromTypeDescriptors(Set<String> classNames){\r\n    final TypeSignature methodSig = getTypeSignature();\r\n    if (methodSig != null) {\r\n        methodSig.getClassNamesFromTypeDescriptors(classNames);\r\n    }\r\n    final TypeSignature methodDesc = getTypeDescriptor();\r\n    if (methodDesc != null) {\r\n        methodDesc.getClassNamesFromTypeDescriptors(classNames);\r\n    }\r\n    if (annotationInfo != null) {\r\n        for (final AnnotationInfo annotationInfo : annotationInfo) {\r\n            annotationInfo.getClassNamesFromTypeDescriptors(classNames);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "cyclops.companion.Streamable.rangeLong",
	"Comment": "create an efficiently reversable sequence that produces the integers between skipand take",
	"Method": "Streamable<Long> rangeLong(long start,long end){\r\n    return fromStream(ReactiveSeq.rangeLong(start, end));\r\n}"
}, {
	"Path": "cyclops.control.LazyEither4.traverse",
	"Comment": "traverseops a collection of either3 producing an either4 with a seq, applying the transformation function to everyelement in the list",
	"Method": "LazyEither4<L1, L2, L3, ReactiveSeq<R>> traverse(Function<? super T, ? extends R> fn,ReactiveSeq<LazyEither4<L1, L2, L3, T>> stream,LazyEither4<LT1, LT2, LT3, ReactiveSeq<R>> traverse,Iterable<LazyEither4<LT1, LT2, LT3, PT>> xors,Function<? super PT, ? extends R> fn){\r\n    return sequence(xors).map(l -> l.map(fn));\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.BagX.iterate",
	"Comment": "create a bagx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "BagX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).bagX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.topologi.diffx.event.impl.EventFactory.makeOpenElement",
	"Comment": "returns the open element event from the uri and name given.if the factory is namespace aware, it returns an open element implementationusing the namespace uri and the name.if the factory is not namespace aware, it returns an open element implementationusing the specified name.use this implementation if the name of the element is determined prior to thecall of this method.",
	"Method": "OpenElementEvent makeOpenElement(String uri,String name,OpenElementEvent makeOpenElement,String uri,String localName,String qName){\r\n    if (this.isNamespaceAware)\r\n        return new OpenElementEventNSImpl(uri, localName);\r\n    else\r\n        return new OpenElementEventImpl(qName);\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.classpath.ClasspathOrder.addClasspathElements",
	"Comment": "add all classpath elements in another classpathelementorder after the elements in this order.",
	"Method": "boolean addClasspathElements(String pathStr,ClassLoader[] classLoaders,LogNode log,boolean addClasspathElements,String pathStr,ClassLoader classLoader,LogNode log,boolean addClasspathElements,ClasspathOrder subsequentOrder){\r\n    boolean added = false;\r\n    for (final String classpathElt : subsequentOrder.getOrder()) {\r\n        added |= addClasspathElement(classpathElt, subsequentOrder.classpathEltPathToClassLoaders.get(classpathElt));\r\n    }\r\n    return added;\r\n}"
}, {
	"Path": "cyclops.control.LazyEither3.toIor",
	"Comment": "return an ior that can be this object or a ior.right or ior.left",
	"Method": "Ior<LT1, RT> toIor(){\r\n    return this.fold(l -> Ior.left(l), m -> Ior.left(null), r -> Ior.right(r));\r\n}"
}, {
	"Path": "io.github.classgraph.ScanResult.getClassesWithMethodAnnotation",
	"Comment": "get classes that have a method with an annotation of the named type.",
	"Method": "ClassInfoList getClassesWithMethodAnnotation(String methodAnnotationName){\r\n    if (closed.get()) {\r\n        throw new IllegalArgumentException(\"Cannot use a ScanResult after it has been closed\");\r\n    }\r\n    if (!scanSpec.enableClassInfo || !scanSpec.enableMethodInfo || !scanSpec.enableAnnotationInfo) {\r\n        throw new IllegalArgumentException(\"Please call ClassGraph#enableClassInfo(), #enableMethodInfo(), \" + \"and #enableAnnotationInfo() before #scan()\");\r\n    }\r\n    final ClassInfo classInfo = classNameToClassInfo.get(methodAnnotationName);\r\n    return classInfo == null ? ClassInfoList.EMPTY_LIST : classInfo.getClassesWithMethodAnnotation();\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.ElementState.get",
	"Comment": "returns the open element at the specified position in this list.",
	"Method": "OpenElementEvent get(int index){\r\n    checkRange(index);\r\n    return this.openElements[index];\r\n}"
}, {
	"Path": "com.datumbox.framework.common.concurrency.ForkJoinStream.min",
	"Comment": "executes min on the provided stream using the provided collector. if the stream is parallel, it is executed using the custom pool, else it is executed directly from the main thread.",
	"Method": "Optional<T> min(Stream<T> stream,Comparator<? super T> comparator){\r\n    Callable<Optional<T>> callable = () -> stream.min(comparator);\r\n    return ThreadMethods.forkJoinExecution(callable, concurrencyConfiguration, stream.isParallel());\r\n}"
}, {
	"Path": "com.datumbox.framework.storage.mapdb.MapDBConfiguration.setCompressed",
	"Comment": "setter for the compression option. if turned on the records will be compressed.it is turned on by default.",
	"Method": "void setCompressed(boolean compressed){\r\n    this.compressed = compressed;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.independentsamples.NormalIndependentSamplesTest.testTestOddsRatio",
	"Comment": "test of testoddsratio method, of class normalindependentsamples.",
	"Method": "void testTestOddsRatio(){\r\n    logger.info(\"testOddsRatio\");\r\n    int n11 = 131;\r\n    int n12 = 33;\r\n    int n21 = 251;\r\n    int n22 = 4;\r\n    boolean is_twoTailed = false;\r\n    double aLevel = 0.05;\r\n    boolean expResult = true;\r\n    boolean result = NormalIndependentSamples.testOddsRatio(n11, n12, n21, n22, is_twoTailed, aLevel);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.utils.ReflectionUtils.getFieldVal",
	"Comment": "get the value of the named field in the class of the given object or any of its superclasses. if an exceptionis thrown while trying to read the field, and throwexception is true, then illegalargumentexception is thrownwrapping the cause, otherwise this will return null. if passed a null object, returns null unlessthrowexception is true, then throws illegalargumentexception.",
	"Method": "Object getFieldVal(Object obj,String fieldName,boolean throwException){\r\n    if (obj != null) {\r\n        for (Class<?> classOrSuperclass = obj.getClass(); classOrSuperclass != null; classOrSuperclass = classOrSuperclass.getSuperclass()) {\r\n            try {\r\n                final Field field = classOrSuperclass.getDeclaredField(fieldName);\r\n                try {\r\n                    field.setAccessible(true);\r\n                } catch (final Exception e) {\r\n                }\r\n                return field.get(obj);\r\n            } catch (final NoSuchFieldException e) {\r\n            } catch (final Throwable e) {\r\n                if (throwException) {\r\n                    throw new IllegalArgumentException(\"Could not get value of field \\\"\" + fieldName + \"\\\"\", e);\r\n                }\r\n            }\r\n        }\r\n        if (throwException) {\r\n            throw new IllegalArgumentException(\"Field \\\"\" + fieldName + \"\\\" doesn't exist\");\r\n        }\r\n    } else if (throwException) {\r\n        throw new IllegalArgumentException(\"Can't get field value for null object\");\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.github.classgraph.MethodParameterInfo.getTypeSignatureOrTypeDescriptor",
	"Comment": "method parameter type signature, or if not available, method type descriptor.",
	"Method": "TypeSignature getTypeSignatureOrTypeDescriptor(){\r\n    return typeSignature != null ? typeSignature : typeDescriptor;\r\n}"
}, {
	"Path": "com.datumbox.framework.common.concurrency.ForkJoinStream.sum",
	"Comment": "executes sum on the provided doublestream using the provided collector. if the stream is parallel, it is executed using the custom pool, else it is executed directly from the main thread.",
	"Method": "double sum(DoubleStream stream){\r\n    Callable<Double> callable = () -> stream.sum();\r\n    return ThreadMethods.forkJoinExecution(callable, concurrencyConfiguration, stream.isParallel());\r\n}"
}, {
	"Path": "com.oath.cyclops.async.adapters.Queue.close",
	"Comment": "close this queuepoison pills are used to communicate closure to connected streamsa poison pill is added per connected stream to the queueif a blockingqueue is backing this async.queue it will block untilable to add to the queue.",
	"Method": "boolean close(){\r\n    this.open = false;\r\n    for (int i = 0; i < listeningStreams.get(); i++) {\r\n        try {\r\n            this.queue.offer((T) POISON_PILL);\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "buildcraft.transport.pipe.flow.PipeFlowItems.insertItemEvents",
	"Comment": "used internally to split up manual insertions from controlled extractions.",
	"Method": "void insertItemEvents(ItemStack toInsert,EnumDyeColor colour,double speed,EnumFacing from){\r\n    IPipeHolder holder = pipe.getHolder();\r\n    PipeEventItem.OnInsert onInsert = new PipeEventItem.OnInsert(holder, this, colour, toInsert, from);\r\n    holder.fireEvent(onInsert);\r\n    if (onInsert.getStack().isEmpty()) {\r\n        return;\r\n    }\r\n    World world = pipe.getHolder().getPipeWorld();\r\n    long now = world.getTotalWorldTime();\r\n    TravellingItem item = new TravellingItem(toInsert);\r\n    item.side = from;\r\n    item.toCenter = true;\r\n    item.speed = speed;\r\n    item.colour = onInsert.colour;\r\n    item.stack = onInsert.getStack();\r\n    item.genTimings(now, getPipeLength(from));\r\n    item.tried.add(from);\r\n    addItemTryMerge(item);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.SetX.iterate",
	"Comment": "create a setx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "SetX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).setX(LAZY);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.DequeX.range",
	"Comment": "create a dequex that contains the integers between skip and take",
	"Method": "DequeX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).dequeX(LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.topicmodeling.LatentDirichletAllocationTest.testPredict",
	"Comment": "test of predict method, of class latentdirichletallocation.",
	"Method": "void testPredict(){\r\n    logger.info(\"testPredict\");\r\n    Configuration configuration = getConfiguration();\r\n    String storageName = this.getClass().getSimpleName();\r\n    Map<Object, URI> dataset = Datasets.sentimentAnalysis();\r\n    UniqueWordSequenceExtractor wsExtractor = new UniqueWordSequenceExtractor(new UniqueWordSequenceExtractor.Parameters());\r\n    Dataframe trainingData = Dataframe.Builder.parseTextFiles(dataset, wsExtractor, configuration);\r\n    LatentDirichletAllocation.TrainingParameters trainingParameters = new LatentDirichletAllocation.TrainingParameters();\r\n    trainingParameters.setMaxIterations(15);\r\n    trainingParameters.setAlpha(0.01);\r\n    trainingParameters.setBeta(0.01);\r\n    trainingParameters.setK(25);\r\n    LatentDirichletAllocation lda = MLBuilder.create(trainingParameters, configuration);\r\n    lda.fit(trainingData);\r\n    lda.save(storageName);\r\n    lda.close();\r\n    lda = MLBuilder.load(LatentDirichletAllocation.class, storageName, configuration);\r\n    lda.predict(trainingData);\r\n    Dataframe reducedTrainingData = new Dataframe(configuration);\r\n    for (Record r : trainingData) {\r\n        reducedTrainingData.add(new Record(r.getYPredictedProbabilities(), r.getY()));\r\n    }\r\n    SoftMaxRegression.TrainingParameters tp = new SoftMaxRegression.TrainingParameters();\r\n    tp.setLearningRate(1.0);\r\n    tp.setTotalIterations(50);\r\n    ClassificationMetrics vm = new Validator(ClassificationMetrics.class, configuration).validate(new KFoldSplitter(1).split(reducedTrainingData), tp);\r\n    double expResult = 0.6843125117743629;\r\n    double result = vm.getMacroF1();\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n    lda.delete();\r\n    reducedTrainingData.close();\r\n    trainingData.close();\r\n}"
}, {
	"Path": "cyclops.control.Future.ofResult",
	"Comment": "construct a successfully completed future from the given value",
	"Method": "Future<T> ofResult(T result){\r\n    return Future.of(CompletableFuture.completedFuture(result));\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.SetX.range",
	"Comment": "create a setx that contains the integers between skip and take",
	"Method": "SetX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).setX(LAZY);\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.utils.JarUtils.createURLClassLoaderFromPathString",
	"Comment": "create a custom urlclassloader from a classpath path string.",
	"Method": "ClassLoader createURLClassLoaderFromPathString(String classpathStr){\r\n    final List<URL> urls = new ArrayList();\r\n    for (final String pathEltStr : smartPathSplit(classpathStr)) {\r\n        try {\r\n            final URL url = new URL(pathEltStr);\r\n            urls.add(url);\r\n        } catch (final Exception e) {\r\n        }\r\n    }\r\n    return new URLClassLoader(urls.toArray(new URL[0]));\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.Dataframe.delete",
	"Comment": "deletes the dataframe and removes all internal variables. once you delete adataset, the instance can no longer be used.",
	"Method": "void delete(){\r\n    storageEngine.clear();\r\n    _close();\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.SimpleRandomSamplingTest.testMinimumSampleSizeForGivenDandMaximumRisk_4args",
	"Comment": "test of minimumsamplesizeforgivendandmaximumrisk method, of class simplerandomsampling.",
	"Method": "void testMinimumSampleSizeForGivenDandMaximumRisk_4args(){\r\n    logger.info(\"minimumSampleSizeForGivenDandMaximumRisk\");\r\n    double d = 0.323;\r\n    double aLevel = 0.1;\r\n    double populationStd = 1.7289303051309;\r\n    int populationN = 7000;\r\n    int expResult = 77;\r\n    int result = SimpleRandomSampling.minimumSampleSizeForGivenDandMaximumRisk(d, aLevel, populationStd, populationN);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributions.multinomialGaussianPdf",
	"Comment": "calculates the pdf of multinomial normal distribution for a particular x.",
	"Method": "double multinomialGaussianPdf(double[] mean,double[][] covariance,double[] x){\r\n    MultivariateNormalDistribution gaussian = new MultivariateNormalDistribution(mean, covariance);\r\n    return gaussian.density(x);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.relatedsamples.NormalRelatedSamples.checkCriticalValue",
	"Comment": "checks the critical value to determine if the hypothesis should be rejected",
	"Method": "boolean checkCriticalValue(double score,boolean is_twoTailed,double aLevel){\r\n    double probability = ContinuousDistributions.gaussCdf(score);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2;\r\n    }\r\n    if (probability <= a || probability >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributionsTest.testUniformCdf",
	"Comment": "test of uniformcdf method, of class continuousdistributions.",
	"Method": "void testUniformCdf(){\r\n    logger.info(\"UniformCdf\");\r\n    double x = 3.0;\r\n    double a = 2.0;\r\n    double b = 10.0;\r\n    double expResult = 0.125;\r\n    double result = ContinuousDistributions.uniformCdf(x, a, b);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "cyclops.futurestream.FutureStream.then",
	"Comment": "react to new events with the supplied function on the suppliedexecutor",
	"Method": "FutureStream<R> then(Function<? super U, ? extends R> fn,Executor service,FutureStream<R> then,Function<? super U, ? extends R> fn){\r\n    return (FutureStream) LazySimpleReactStream.super.then(fn);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.ListX.fill",
	"Comment": "generate a listx from the provided value up to the provided limit number of times",
	"Method": "ListX<T> fill(long limit,T s){\r\n    return ReactiveSeq.fill(s).limit(limit).to(ReactiveConvertableSequence::converter).listX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.common.dataobjects.KnowledgeBase.delete",
	"Comment": "deletes the storage of the algorithm and closes the storage engine.",
	"Method": "void delete(){\r\n    storageEngine.clear();\r\n    close();\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.fastzipfilereader.LogicalZipFile.getManifestValue",
	"Comment": "extract a value from the manifest, and return the value as a string, along with the index after theterminating newline.",
	"Method": "Entry<String, Integer> getManifestValue(byte[] manifest,int startIdx){\r\n    final int len = manifest.length;\r\n    final StringBuilder buf = new StringBuilder();\r\n    int curr = startIdx;\r\n    if (curr < len && manifest[curr] == (byte) ' ') {\r\n        curr++;\r\n    }\r\n    for (; curr < len; curr++) {\r\n        final byte b = manifest[curr];\r\n        if (b == (byte) '\\r' && curr < len - 1 && manifest[curr + 1] == (byte) '\\n') {\r\n            curr += 2;\r\n            if (curr >= len - 2 || manifest[curr + 2] != (byte) ' ') {\r\n                break;\r\n            }\r\n        } else if (b == '\\r') {\r\n            curr += 1;\r\n            if (curr >= len - 1 || manifest[curr + 1] != (byte) ' ') {\r\n                break;\r\n            }\r\n        } else if (b == '\\n') {\r\n            curr += 1;\r\n            if (curr >= len - 1 || manifest[curr + 1] != (byte) ' ') {\r\n                break;\r\n            }\r\n        } else {\r\n            buf.append((char) b);\r\n        }\r\n    }\r\n    final String val = buf.toString();\r\n    return new SimpleEntry(val.endsWith(\" \") ? val.trim() : val, curr);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.anova.AnovaTest.testTwoWayTestEqualCellsEqualVars",
	"Comment": "test of twowaytestequalcellsequalvars method, of class anova.",
	"Method": "void testTwoWayTestEqualCellsEqualVars(){\r\n    logger.info(\"twoWayTestEqualCellsEqualVars\");\r\n    TransposeDataCollection transposeDataCollection1 = new TransposeDataCollection();\r\n    transposeDataCollection1.put(\"StrainBright\", new FlatDataCollection(Arrays.asList(new Object[] { 26, 14, 41, 16, 28, 29, 92, 31 })));\r\n    transposeDataCollection1.put(\"StrainMixed\", new FlatDataCollection(Arrays.asList(new Object[] { 41, 82, 26, 86, 19, 45, 59, 37 })));\r\n    transposeDataCollection1.put(\"StrainDull\", new FlatDataCollection(Arrays.asList(new Object[] { 36, 87, 39, 99, 59, 126, 27, 104 })));\r\n    TransposeDataCollection transposeDataCollection2 = new TransposeDataCollection();\r\n    transposeDataCollection2.put(\"StrainBright\", new FlatDataCollection(Arrays.asList(new Object[] { 51, 35, 96, 36, 97, 28, 22, 76 })));\r\n    transposeDataCollection2.put(\"StrainMixed\", new FlatDataCollection(Arrays.asList(new Object[] { 39, 114, 104, 92, 130, 87, 122, 64 })));\r\n    transposeDataCollection2.put(\"StrainDull\", new FlatDataCollection(Arrays.asList(new Object[] { 42, 133, 92, 144, 156, 68, 144, 142 })));\r\n    TransposeDataCollection2D twoFactorDataCollection = new TransposeDataCollection2D();\r\n    twoFactorDataCollection.put(\"EnviromentFree\", transposeDataCollection1);\r\n    twoFactorDataCollection.put(\"EnviromentRestricted\", transposeDataCollection2);\r\n    double aLevel = 0.05;\r\n    AssociativeArray2D outputTable = new AssociativeArray2D();\r\n    boolean expResult = true;\r\n    boolean result = Anova.twoWayTestEqualCellsEqualVars(twoFactorDataCollection, aLevel, outputTable);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "cyclops.function.Memoize.memoizeFunctionAsync",
	"Comment": "memoize this function and update cached values on a scheduledoes not support null keys",
	"Method": "Function1<T, R> memoizeFunctionAsync(Function<T, R> fn,ScheduledExecutorService ex,long updateRateInMillis,Function1<T, R> memoizeFunctionAsync,Function<T, R> fn,ScheduledExecutorService ex,String cron){\r\n    final Map<T, R> lazy = new ConcurrentHashMap();\r\n    ReactiveSeq.generate(() -> {\r\n        lazy.forEach((k, v) -> {\r\n            lazy.put(k, fn.apply(k));\r\n        });\r\n        return null;\r\n    }).schedule(cron, ex);\r\n    return t -> lazy.computeIfAbsent(t, fn);\r\n}"
}, {
	"Path": "com.datumbox.framework.applications.nlp.TextClassifierTest.testTrainAndValidateBernoulliNaiveBayes",
	"Comment": "test of train and validate method, of class textclassifier using bernoullinaivebayes.",
	"Method": "void testTrainAndValidateBernoulliNaiveBayes(){\r\n    logger.info(\"testTrainAndValidateBernoulliNaiveBayes\");\r\n    BernoulliNaiveBayes.TrainingParameters mlParams = new BernoulliNaiveBayes.TrainingParameters();\r\n    ChisquareSelect.TrainingParameters fsParams = new ChisquareSelect.TrainingParameters();\r\n    fsParams.setALevel(0.05);\r\n    fsParams.setMaxFeatures(1000);\r\n    fsParams.setRareFeatureThreshold(3);\r\n    trainAndValidate(mlParams, fsParams, null, 0.8393075950598075, 1);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.common.dataobjects.TrainableBundle.get",
	"Comment": "returns the trainable with the specific key or null if the key is missing.",
	"Method": "Trainable get(String key){\r\n    return bundle.get(key);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.parsers.HTMLParserTest.testRemoveNonTextTagsAndAttributes",
	"Comment": "test of removenontexttagsandattributes method, of class htmlparser.",
	"Method": "void testRemoveNonTextTagsAndAttributes(){\r\n    logger.info(\"testRemoveNonTextTagsAndAttributes\");\r\n    String text = \"<html><head>INVISIBLE<\/head><body>\" + \"<!-- INISIBLE -->\" + \"<style>INVISIBLE<\/style>\" + \"<script>INVISIBLE<\/script>\" + \"<object>INVISIBLE<\/object>\" + \"<embed>INVISIBLE<\/embed>\" + \"<applet>INVISIBLE<\/applet>\" + \"<noframes>INVISIBLE<\/noframes>\" + \"<noscript>INVISIBLE<\/noscript>\" + \"<noembed>INVISIBLE<\/noembed>\" + \"<option>INVISIBLE<\/option>\" + \"<div>visible1&#39;s<\/div>\" + \"<img src=\\\"\\\" />\" + \"<img src=\\\"\\\" />\" + \"<br>\" + \"test!\" + \"<\/body><\/html>\";\r\n    String expResult = \"<html> <body> <div>visible1's<\/div><img/><img/><br>test!<\/body><\/html>\";\r\n    String result = StringCleaner.removeExtraSpaces(HTMLParser.removeNonTextTagsAndAttributes(text));\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.utils.LogNode.flush",
	"Comment": "flush out the log to stderr, and clear the log contents. only call this on the toplevel log node, whenthreads do not have access to references of internal log nodes so that they cannot add more log entriesinside the tree, otherwise log entries may be lost.",
	"Method": "void flush(){\r\n    if (parent != null) {\r\n        throw new IllegalArgumentException(\"Only flush the toplevel LogNode\");\r\n    }\r\n    final String logOutput = this.toString();\r\n    this.children.clear();\r\n    System.out.flush();\r\n    System.err.print(logOutput);\r\n    System.err.flush();\r\n}"
}, {
	"Path": "com.github.dockerjava.api.model.RestartPolicy.alwaysRestart",
	"Comment": "always restart the container no matter what exit code is returned.",
	"Method": "RestartPolicy alwaysRestart(){\r\n    return new RestartPolicy(0, \"always\");\r\n}"
}, {
	"Path": "com.datumbox.framework.applications.nlp.TextClassifierTest.testTrainAndValidateOrdinalRegression",
	"Comment": "test of train and validate method, of class textclassifier using ordinalregression.",
	"Method": "void testTrainAndValidateOrdinalRegression(){\r\n    logger.info(\"testTrainAndValidateOrdinalRegression\");\r\n    OrdinalRegression.TrainingParameters mlParams = new OrdinalRegression.TrainingParameters();\r\n    ChisquareSelect.TrainingParameters fsParams = new ChisquareSelect.TrainingParameters();\r\n    fsParams.setALevel(0.05);\r\n    fsParams.setMaxFeatures(1000);\r\n    fsParams.setRareFeatureThreshold(3);\r\n    BinaryScaler.TrainingParameters nsParams = new BinaryScaler.TrainingParameters();\r\n    nsParams.setScaleResponse(false);\r\n    nsParams.setThreshold(0.0);\r\n    trainAndValidate(mlParams, fsParams, nsParams, 0.9292550977944236, 5);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.Record.getY",
	"Comment": "it returns the real response variable of the record. if unknown it will havea null value.",
	"Method": "Object getY(){\r\n    return y;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributionsTest.testHypergeometricCdf",
	"Comment": "test of hypergeometriccdf method, of class discretedistributions.",
	"Method": "void testHypergeometricCdf(){\r\n    logger.info(\"HypergeometricCdf\");\r\n    int k = 3;\r\n    int n = 10;\r\n    int Kp = 30;\r\n    int Np = 100;\r\n    double expResult = 0.65401998866081;\r\n    double result = DiscreteDistributions.hypergeometricCdf(k, n, Kp, Np);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.LazyStream.run",
	"Comment": "trigger a lazy stream and return the results in the collection created bythe collector",
	"Method": "void run(R run,Collector<U, A, R> collector){\r\n    if (getLastActive().isSequential()) {\r\n        if (collector.supplier().get() == null) {\r\n            forEach(r -> {\r\n            });\r\n            return null;\r\n        }\r\n        final A col = collector.supplier().get();\r\n        forEach(r -> collector.accumulator().accept(col, r));\r\n        return collector.finisher().apply(col);\r\n    }\r\n    final Function<FastFuture<U>, U> safeJoin = (final FastFuture<U> cf) -> (U) BlockingStreamHelper.getSafe(cf, getErrorHandler());\r\n    final LazyResultConsumer<U> batcher = collector.supplier().get() != null ? getLazyCollector().get().withResults(new ArrayList()) : new EmptyCollector(this.getMaxActive(), safeJoin);\r\n    try {\r\n        this.getLastActive().injectFutures().forEach(n -> {\r\n            batcher.accept(n);\r\n        });\r\n    } catch (final SimpleReactProcessingException e) {\r\n    }\r\n    if (collector.supplier().get() == null) {\r\n        batcher.block(safeJoin);\r\n        return null;\r\n    }\r\n    return (R) batcher.getAllResults().stream().map(cf -> BlockingStreamHelper.getSafe(cf, getErrorHandler())).filter(v -> v != MissingValue.MISSING_VALUE).collect((Collector) collector);\r\n}"
}, {
	"Path": "com.github.dockerjava.core.DefaultDockerClientConfig.overrideDockerPropertiesWithSystemProperties",
	"Comment": "creates a new properties object containing values overridden from the system properties",
	"Method": "Properties overrideDockerPropertiesWithSystemProperties(Properties p,Properties systemProperties){\r\n    Properties overriddenProperties = new Properties();\r\n    overriddenProperties.putAll(p);\r\n    for (String key : CONFIG_KEYS) {\r\n        if (systemProperties.containsKey(key)) {\r\n            overriddenProperties.setProperty(key, systemProperties.getProperty(key));\r\n        }\r\n    }\r\n    return overriddenProperties;\r\n}"
}, {
	"Path": "com.datumbox.framework.tests.utilities.TestUtils.assertDoubleDataTable2D",
	"Comment": "assert method for datatable2d data structure which stores double values.",
	"Method": "void assertDoubleDataTable2D(DataTable2D expResult,DataTable2D result){\r\n    for (Object key1 : result.keySet()) {\r\n        for (Object key2 : result.get(key1).keySet()) {\r\n            double v1 = TypeInference.toDouble(expResult.get2d(key1, key2));\r\n            double v2 = TypeInference.toDouble(result.get2d(key1, key2));\r\n            assertEquals(v1, v2, Constants.DOUBLE_ACCURACY_HIGH);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.LazySimpleReactStream.peek",
	"Comment": "peek asynchronously at the results in the current stage. current resultsare passed through to the next stage.",
	"Method": "LazySimpleReactStream<U> peek(Consumer<? super U> consumer){\r\n    if (!isAsync())\r\n        return peekSync(consumer);\r\n    return then((t) -> {\r\n        consumer.accept(t);\r\n        return t;\r\n    });\r\n}"
}, {
	"Path": "com.topologi.diffx.event.impl.CharactersEventBase.equals",
	"Comment": "returns true if the event is a character event and its content is equivalent.",
	"Method": "boolean equals(DiffXEvent e){\r\n    if (this == e)\r\n        return true;\r\n    if (e.getClass() != this.getClass())\r\n        return false;\r\n    CharactersEventBase ce = (CharactersEventBase) e;\r\n    return ce.characters.equals(this.characters);\r\n}"
}, {
	"Path": "cyclops.reactive.Spouts.narrowK",
	"Comment": "convert the raw higher kinded type for reactiveseq types into the reactiveseq type definition class",
	"Method": "ReactiveSeq<T> narrowK(Higher<reactiveSeq, T> future){\r\n    return (ReactiveSeq<T>) future;\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.FlatDataList.set",
	"Comment": "replaces the element at the specified position in the internal list with thespecified element and returns the previous value.",
	"Method": "Object set(int index,Object element){\r\n    return internalData.set(index, element);\r\n}"
}, {
	"Path": "cyclops.companion.Streams.groupedStatefullyUntil",
	"Comment": "group data in a stream using knowledge of the current batch and the next entry to determing grouping limits",
	"Method": "Stream<Seq<T>> groupedStatefullyUntil(Stream<T> stream,BiPredicate<Seq<? super T>, ? super T> predicate){\r\n    return StreamSupport.stream(new GroupedStatefullySpliterator(stream.spliterator(), () -> Seq.of(), Function.identity(), predicate.negate()), stream.isParallel());\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.BaseSimpleReactStream.empty",
	"Comment": "create an zero sequential synchronous stream that runs on the current thread",
	"Method": "SimpleReactStream<T> empty(){\r\n    return simpleReactStream((Stream) Stream.empty());\r\n}"
}, {
	"Path": "cyclops.control.Try.runWithCatch",
	"Comment": "try to execute supplied runnable and will catch specified excpetions or java.lang.exceptionif none specified.",
	"Method": "Try<Void, X> runWithCatch(CheckedRunnable<X> cf,Class<? extends X> classes){\r\n    Objects.requireNonNull(cf);\r\n    try {\r\n        cf.run();\r\n        return Try.success(null);\r\n    } catch (final Throwable t) {\r\n        if (classes.length == 0)\r\n            return Try.failure((X) t);\r\n        val error = Stream.of(classes).filter(c -> c.isAssignableFrom(t.getClass())).findFirst();\r\n        if (error.isPresent())\r\n            return Try.failure((X) t);\r\n        else\r\n            throw ExceptionSoftener.throwSoftenedException(t);\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributionsTest.testHypergeometric",
	"Comment": "test of hypergeometric method, of class discretedistributions.",
	"Method": "void testHypergeometric(){\r\n    logger.info(\"Hypergeometric\");\r\n    int k = 3;\r\n    int n = 10;\r\n    int Kp = 30;\r\n    int Np = 100;\r\n    double expResult = 0.28116339430254;\r\n    double result = DiscreteDistributions.hypergeometric(k, n, Kp, Np);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "cyclops.reactive.ReactiveSeq.narrowK",
	"Comment": "convert the raw higher kinded type for reactiveseq types into the reactiveseq type definition class",
	"Method": "ReactiveSeq<T> narrowK(Higher<reactiveSeq, T> future){\r\n    return (ReactiveSeq<T>) future;\r\n}"
}, {
	"Path": "cyclops.control.LazyEither4.toIor",
	"Comment": "return an ior that can be this object or a ior.right or ior.left",
	"Method": "Ior<LT1, RT> toIor(){\r\n    return this.fold(l -> Ior.left(l), m -> Ior.left(null), m -> Ior.left(null), r -> Ior.right(r));\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.modelselection.Validator.validate",
	"Comment": "estimates the average validation metrics on the provided data splits.",
	"Method": "VM validate(Iterator<Split> dataSplits,TrainingParameters trainingParameters){\r\n    AbstractModeler modeler = MLBuilder.create(trainingParameters, configuration);\r\n    List<VM> validationMetricsList = new LinkedList();\r\n    while (dataSplits.hasNext()) {\r\n        Split s = dataSplits.next();\r\n        Dataframe trainData = s.getTrain();\r\n        Dataframe testData = s.getTest();\r\n        modeler.fit(trainData);\r\n        trainData.close();\r\n        modeler.predict(testData);\r\n        VM entrySample = ValidationMetrics.newInstance(vmClass, testData);\r\n        testData.close();\r\n        validationMetricsList.add(entrySample);\r\n    }\r\n    modeler.close();\r\n    VM avgValidationMetrics = ValidationMetrics.newInstance(vmClass, validationMetricsList);\r\n    return avgValidationMetrics;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributionsTest.testBernoulliCdf",
	"Comment": "test of bernoullicdf method, of class discretedistributions.",
	"Method": "void testBernoulliCdf(){\r\n    logger.info(\"BernoulliCdf\");\r\n    int k = 1;\r\n    double p = 0.5;\r\n    double expResult = 1.0;\r\n    double result = DiscreteDistributions.bernoulliCdf(k, p);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.SimpleRandomSamplingTest.testPbarVariance_3args",
	"Comment": "test of pbarvariance method, of class simplerandomsampling.",
	"Method": "void testPbarVariance_3args(){\r\n    logger.info(\"pbarVariance\");\r\n    double pbar = 0.19;\r\n    int sampleN = 200;\r\n    int populationN = 3042;\r\n    double expResult = 0.00072252088;\r\n    double result = SimpleRandomSampling.pbarVariance(pbar, sampleN, populationN);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "io.github.classgraph.Scanner.call",
	"Comment": "determine the unique ordered classpath elements, and run a scan looking for file or classfile matches ifnecessary.",
	"Method": "ScanResult call(){\r\n    final LogNode classpathFinderLog = topLevelLog == null ? null : topLevelLog.log(\"Finding classpath entries\");\r\n    final NestedJarHandler nestedJarHandler = new NestedJarHandler(scanSpec, classpathFinderLog);\r\n    final Map<String, ClassLoader[]> classpathEltPathToClassLoaders = new ConcurrentHashMap();\r\n    final SingletonMap<String, ClasspathElement> classpathElementSingletonMap = new SingletonMap<String, ClasspathElement>() {\r\n        @Override\r\n        public ClasspathElement newInstance(final String classpathEltPath, final LogNode log) throws IOException {\r\n            return ClasspathElement.newClasspathElementDirOrZip(classpathEltPath, classpathEltPathToClassLoaders.get(classpathEltPath), nestedJarHandler, scanSpec);\r\n        }\r\n    };\r\n    try {\r\n        final long scanStart = System.nanoTime();\r\n        final ClasspathFinder classpathFinder = new ClasspathFinder(scanSpec, classpathEltPathToClassLoaders, nestedJarHandler, classpathFinderLog);\r\n        final ClassLoaderAndModuleFinder classLoaderAndModuleFinder = classpathFinder.getClassLoaderAndModuleFinder();\r\n        final ClassLoader[] contextClassLoaders = classLoaderAndModuleFinder.getContextClassLoaders();\r\n        final List<ClasspathElementModule> moduleClasspathEltOrder = new ArrayList();\r\n        if (scanSpec.overrideClasspath == null && scanSpec.overrideClassLoaders == null && scanSpec.scanModules) {\r\n            final List<ModuleRef> systemModuleRefs = classLoaderAndModuleFinder.getSystemModuleRefs();\r\n            if (systemModuleRefs != null) {\r\n                for (final ModuleRef systemModuleRef : systemModuleRefs) {\r\n                    final String moduleName = systemModuleRef.getName();\r\n                    if ((scanSpec.enableSystemJarsAndModules && scanSpec.moduleWhiteBlackList.whitelistAndBlacklistAreEmpty()) || scanSpec.moduleWhiteBlackList.isSpecificallyWhitelistedAndNotBlacklisted(moduleName)) {\r\n                        final ClasspathElementModule classpathElementModule = new ClasspathElementModule(systemModuleRef, contextClassLoaders, nestedJarHandler, scanSpec);\r\n                        classpathElementModule.checkValid(null, classpathFinderLog);\r\n                        moduleClasspathEltOrder.add(classpathElementModule);\r\n                    } else {\r\n                        if (classpathFinderLog != null) {\r\n                            classpathFinderLog.log(\"Skipping non-whitelisted or blacklisted system module: \" + moduleName);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            final List<ModuleRef> nonSystemModuleRefs = classLoaderAndModuleFinder.getNonSystemModuleRefs();\r\n            if (nonSystemModuleRefs != null) {\r\n                for (final ModuleRef nonSystemModuleRef : nonSystemModuleRefs) {\r\n                    final String moduleName = nonSystemModuleRef.getName();\r\n                    if (scanSpec.moduleWhiteBlackList.isWhitelistedAndNotBlacklisted(moduleName)) {\r\n                        final ClasspathElementModule classpathElementModule = new ClasspathElementModule(nonSystemModuleRef, contextClassLoaders, nestedJarHandler, scanSpec);\r\n                        classpathElementModule.checkValid(null, classpathFinderLog);\r\n                        moduleClasspathEltOrder.add(classpathElementModule);\r\n                    } else {\r\n                        if (classpathFinderLog != null) {\r\n                            classpathFinderLog.log(\"Skipping non-whitelisted or blacklisted module: \" + moduleName);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        final LinkedHashSet<String> rawClasspathEltOrder = classpathFinder.getClasspathOrder().getOrder();\r\n        final LogNode preScanLog = classpathFinderLog == null ? null : classpathFinderLog.log(\"Reading jarfile directories and manifest files\");\r\n        WorkQueue.runWorkQueue(rawClasspathEltOrder, executorService, numParallelTasks, new WorkUnitProcessor<String>() {\r\n            @Override\r\n            public void processWorkUnit(final String classpathEltPath, final WorkQueue<String> workQueue) throws Exception {\r\n                ClasspathElement classpathElt = null;\r\n                try {\r\n                    classpathElt = classpathElementSingletonMap.get(classpathEltPath, classpathFinderLog);\r\n                    classpathElt.checkValid(workQueue, preScanLog);\r\n                } catch (final IOException | IllegalArgumentException e) {\r\n                    if (classpathFinderLog != null) {\r\n                        classpathFinderLog.log(\"Skipping invalid classpath element \" + classpathEltPath + \" : \" + e);\r\n                    }\r\n                }\r\n            }\r\n        }, interruptionChecker, preScanLog);\r\n        final List<ClasspathElement> finalTraditionalClasspathEltOrder = findClasspathOrder(rawClasspathEltOrder, classpathElementSingletonMap);\r\n        final LogNode classpathOrderLog = classpathFinderLog == null ? null : classpathFinderLog.log(\"Final classpath element order:\");\r\n        final int numElts = moduleClasspathEltOrder.size() + finalTraditionalClasspathEltOrder.size();\r\n        final List<ClasspathElement> finalClasspathEltOrder = new ArrayList(numElts);\r\n        final List<String> finalClasspathEltOrderStrs = new ArrayList(numElts);\r\n        for (final ClasspathElementModule classpathElt : moduleClasspathEltOrder) {\r\n            finalClasspathEltOrder.add(classpathElt);\r\n            finalClasspathEltOrderStrs.add(classpathElt.toString());\r\n            if (classpathOrderLog != null) {\r\n                final ModuleRef moduleRef = classpathElt.getModuleRef();\r\n                classpathOrderLog.log(moduleRef.toString());\r\n            }\r\n        }\r\n        for (final ClasspathElement classpathElt : finalTraditionalClasspathEltOrder) {\r\n            finalClasspathEltOrder.add(classpathElt);\r\n            finalClasspathEltOrderStrs.add(classpathElt.toString());\r\n            if (classpathOrderLog != null) {\r\n                classpathOrderLog.log(classpathElt.toString());\r\n            }\r\n        }\r\n        if (!scanSpec.performScan) {\r\n            if (topLevelLog != null) {\r\n                topLevelLog.log(\"Only returning classpath elements (not performing a scan)\");\r\n            }\r\n            final ScanResult scanResult = new ScanResult(scanSpec, finalClasspathEltOrder, finalClasspathEltOrderStrs, contextClassLoaders, null, null, null, null, nestedJarHandler, topLevelLog);\r\n            if (topLevelLog != null) {\r\n                topLevelLog.log(\"Completed\", System.nanoTime() - scanStart);\r\n            }\r\n            return scanResult;\r\n        }\r\n        final List<SimpleEntry<String, ClasspathElement>> classpathEltDirs = new ArrayList();\r\n        final List<SimpleEntry<String, ClasspathElement>> classpathEltZips = new ArrayList();\r\n        for (final ClasspathElement classpathElt : finalClasspathEltOrder) {\r\n            if (classpathElt instanceof ClasspathElementDir) {\r\n                classpathEltDirs.add(new SimpleEntry(((ClasspathElementDir) classpathElt).getDirFile().getPath(), classpathElt));\r\n            } else if (classpathElt instanceof ClasspathElementZip) {\r\n                classpathEltZips.add(new SimpleEntry(((ClasspathElementZip) classpathElt).getZipFilePath(), classpathElt));\r\n            }\r\n        }\r\n        findNestedClasspathElements(classpathEltDirs, classpathFinderLog);\r\n        findNestedClasspathElements(classpathEltZips, classpathFinderLog);\r\n        final LogNode pathScanLog = classpathFinderLog == null ? null : classpathFinderLog.log(\"Scanning filenames within classpath elements\");\r\n        WorkQueue.runWorkQueue(finalClasspathEltOrder, executorService, numParallelTasks, new WorkUnitProcessor<ClasspathElement>() {\r\n            @Override\r\n            public void processWorkUnit(final ClasspathElement classpathElement, final WorkQueue<ClasspathElement> workQueueIgnored) {\r\n                classpathElement.scanPaths(pathScanLog);\r\n                if (preScanLog != null) {\r\n                    preScanLog.addElapsedTime();\r\n                }\r\n            }\r\n        }, interruptionChecker, pathScanLog);\r\n        if (preScanLog != null) {\r\n            preScanLog.addElapsedTime();\r\n        }\r\n        List<ClasspathElement> finalClasspathEltOrderFiltered = finalClasspathEltOrder;\r\n        if (!scanSpec.classpathElementResourcePathWhiteBlackList.whitelistIsEmpty()) {\r\n            finalClasspathEltOrderFiltered = new ArrayList(finalClasspathEltOrder.size());\r\n            for (final ClasspathElement classpathElement : finalClasspathEltOrder) {\r\n                if (classpathElement.containsSpecificallyWhitelistedClasspathElementResourcePath) {\r\n                    finalClasspathEltOrderFiltered.add(classpathElement);\r\n                }\r\n            }\r\n        }\r\n        {\r\n            final LogNode maskLog = topLevelLog == null ? null : topLevelLog.log(\"Masking classfiles\");\r\n            final HashSet<String> nonBlacklistedClasspathRelativePathsFound = new HashSet();\r\n            final HashSet<String> whitelistedClasspathRelativePathsFound = new HashSet();\r\n            for (int classpathIdx = 0; classpathIdx < finalClasspathEltOrderFiltered.size(); classpathIdx++) {\r\n                finalClasspathEltOrderFiltered.get(classpathIdx).maskClassfiles(classpathIdx, whitelistedClasspathRelativePathsFound, nonBlacklistedClasspathRelativePathsFound, maskLog);\r\n            }\r\n        }\r\n        final Map<File, Long> fileToLastModified = new HashMap();\r\n        for (final ClasspathElement classpathElement : finalClasspathEltOrderFiltered) {\r\n            fileToLastModified.putAll(classpathElement.fileToLastModified);\r\n        }\r\n        final Map<String, ClassInfo> classNameToClassInfo = new HashMap();\r\n        final Map<String, PackageInfo> packageNameToPackageInfo = new HashMap();\r\n        final Map<String, ModuleInfo> moduleNameToModuleInfo = new HashMap();\r\n        if (!scanSpec.enableClassInfo) {\r\n            if (topLevelLog != null) {\r\n                topLevelLog.log(\"Classfile scanning is disabled\");\r\n            }\r\n        } else {\r\n            final List<ClassfileScanWorkUnit> classfileScanWorkItems = new ArrayList();\r\n            final Set<String> scannedClassNames = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());\r\n            for (final ClasspathElement classpathElement : finalClasspathEltOrderFiltered) {\r\n                for (final Resource resource : classpathElement.whitelistedClassfileResources) {\r\n                    classfileScanWorkItems.add(new ClassfileScanWorkUnit(classpathElement, resource, false));\r\n                    scannedClassNames.add(JarUtils.classfilePathToClassName(resource.getPath()));\r\n                }\r\n            }\r\n            final ConcurrentLinkedQueue<ClassInfoUnlinked> classInfoUnlinkedQueue = new ConcurrentLinkedQueue();\r\n            final LogNode classfileScanLog = topLevelLog == null ? null : topLevelLog.log(\"Scanning classfiles\");\r\n            WorkQueue.runWorkQueue(classfileScanWorkItems, executorService, numParallelTasks, new ClassfileScannerWorkUnitProcessor(scanSpec, finalClasspathEltOrderFiltered, scannedClassNames, classInfoUnlinkedQueue, classfileScanLog, interruptionChecker), interruptionChecker, classfileScanLog);\r\n            if (classfileScanLog != null) {\r\n                classfileScanLog.addElapsedTime();\r\n            }\r\n            final LogNode classGraphLog = topLevelLog == null ? null : topLevelLog.log(\"Building class graph\");\r\n            for (final ClassInfoUnlinked c : classInfoUnlinkedQueue) {\r\n                c.link(scanSpec, classNameToClassInfo, packageNameToPackageInfo, moduleNameToModuleInfo, classGraphLog);\r\n            }\r\n            if (classGraphLog != null) {\r\n                classGraphLog.addElapsedTime();\r\n            }\r\n        }\r\n        final ScanResult scanResult = new ScanResult(scanSpec, finalClasspathEltOrder, finalClasspathEltOrderStrs, contextClassLoaders, classNameToClassInfo, packageNameToPackageInfo, moduleNameToModuleInfo, fileToLastModified, nestedJarHandler, topLevelLog);\r\n        if (topLevelLog != null) {\r\n            topLevelLog.log(\"Completed\", System.nanoTime() - scanStart);\r\n        }\r\n        if (scanResultProcessor != null) {\r\n            try {\r\n                scanResultProcessor.processScanResult(scanResult);\r\n            } catch (final Throwable e) {\r\n                throw new ExecutionException(\"Exception while calling scan result processor\", e);\r\n            }\r\n        }\r\n        return scanResult;\r\n    } catch (final Throwable e) {\r\n        nestedJarHandler.close(topLevelLog);\r\n        if (topLevelLog != null) {\r\n            topLevelLog.log(\"Exception while scanning\", e);\r\n        }\r\n        if (failureHandler != null) {\r\n            try {\r\n                failureHandler.onFailure(e);\r\n                return null;\r\n            } catch (final Throwable t) {\r\n                throw new ExecutionException(\"Exception while calling failure handler\", t);\r\n            }\r\n        } else {\r\n            throw new ExecutionException(\"Exception while scanning\", e);\r\n        }\r\n    } finally {\r\n        if (scanSpec.removeTemporaryFilesAfterScan) {\r\n            nestedJarHandler.close(topLevelLog);\r\n        }\r\n        if (topLevelLog != null) {\r\n            topLevelLog.flush();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.github.classgraph.Scanner.call",
	"Comment": "determine the unique ordered classpath elements, and run a scan looking for file or classfile matches ifnecessary.",
	"Method": "ScanResult call(){\r\n    return ClasspathElement.newClasspathElementDirOrZip(classpathEltPath, classpathEltPathToClassLoaders.get(classpathEltPath), nestedJarHandler, scanSpec);\r\n}"
}, {
	"Path": "io.github.classgraph.Scanner.call",
	"Comment": "determine the unique ordered classpath elements, and run a scan looking for file or classfile matches ifnecessary.",
	"Method": "ScanResult call(){\r\n    ClasspathElement classpathElt = null;\r\n    try {\r\n        classpathElt = classpathElementSingletonMap.get(classpathEltPath, classpathFinderLog);\r\n        classpathElt.checkValid(workQueue, preScanLog);\r\n    } catch (final IOException | IllegalArgumentException e) {\r\n        if (classpathFinderLog != null) {\r\n            classpathFinderLog.log(\"Skipping invalid classpath element \" + classpathEltPath + \" : \" + e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.github.classgraph.Scanner.call",
	"Comment": "determine the unique ordered classpath elements, and run a scan looking for file or classfile matches ifnecessary.",
	"Method": "ScanResult call(){\r\n    classpathElement.scanPaths(pathScanLog);\r\n    if (preScanLog != null) {\r\n        preScanLog.addElapsedTime();\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AssociativeArray2D.remove",
	"Comment": "removes a particular key from the internal map and returns the value associated with that key if present in the map.",
	"Method": "AssociativeArray remove(Object key){\r\n    return internalData.remove(key);\r\n}"
}, {
	"Path": "org.jak_linux.dns66.FileHelper.openWrite",
	"Comment": "write to the given file in the private files dir, first renaming an old one to .bak",
	"Method": "OutputStream openWrite(Context context,String filename){\r\n    File out = context.getFileStreamPath(filename);\r\n    out.renameTo(context.getFileStreamPath(filename + \".bak\"));\r\n    return context.openFileOutput(filename, Context.MODE_PRIVATE);\r\n}"
}, {
	"Path": "org.fourthline.cling.support.contentdirectory.callback.Search.getDefaultMaxResults",
	"Comment": "some media servers will crash if there is no limit on the maximum number of results.",
	"Method": "Long getDefaultMaxResults(){\r\n    return 999L;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.Dataframe.recalculateMeta",
	"Comment": "it forces the recalculation of meta data using the records of the dataset.",
	"Method": "void recalculateMeta(){\r\n    data.yDataType = null;\r\n    data.xDataTypes.clear();\r\n    for (Record r : values()) {\r\n        updateMeta(r);\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.MapRealMatrix.finalize",
	"Comment": "when we perform matrix operations, we often lose the reference to the original matrix and we are unable toclear its storage. even though the jvm will close the storage before shutdown, by adding a close method in the finalizewe ensure that if the object is gc, we will clear the unnecessary entries of the storage engine sooner.",
	"Method": "void finalize(){\r\n    try {\r\n        DataframeMatrix.storageEngine.dropBigMap(\"tmp_mrmentries\" + id, entries);\r\n    } finally {\r\n        super.finalize();\r\n    }\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.ElementState.lastIndexOf",
	"Comment": "returns the index of the last occurrence of the specified object inthis list.",
	"Method": "int lastIndexOf(OpenElementEvent element){\r\n    if (element == null) {\r\n        for (int i = this.size - 1; i >= 0; i--) if (this.openElements[i] == null)\r\n            return i;\r\n    } else {\r\n        for (int i = this.size - 1; i >= 0; i--) if (element.equals(this.openElements[i]))\r\n            return i;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.foldable.Folds.atPercentile",
	"Comment": "value at percentile denoted by a double value between 0 and 100assumes the data is already sortedreturns an option, option.none is returned when an invalid percentile or empty dataset is used",
	"Method": "Option<T> atPercentile(double percentile){\r\n    List<T> list = stream().collect(Collectors.toList());\r\n    if (list.size() == 0)\r\n        return Option.none();\r\n    Long pos = new Double(Math.ceil((percentile / 100) * list.size())).longValue();\r\n    if (pos < 0 || pos > list.size()) {\r\n        return Option.none();\r\n    }\r\n    return Option.some(list.get(pos.intValue()));\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.regression.MatrixLinearRegressionTest.testKFoldCrossValidation",
	"Comment": "test of validate method, of class matrixlinearregression.",
	"Method": "void testKFoldCrossValidation(){\r\n    logger.info(\"testKFoldCrossValidation\");\r\n    Configuration configuration = getConfiguration();\r\n    int k = 5;\r\n    Dataframe[] data = Datasets.regressionMixed(configuration);\r\n    Dataframe trainingData = data[0];\r\n    data[1].close();\r\n    MaxAbsScaler.TrainingParameters nsParams = new MaxAbsScaler.TrainingParameters();\r\n    MaxAbsScaler numericalScaler = MLBuilder.create(nsParams, configuration);\r\n    numericalScaler.fit_transform(trainingData);\r\n    CornerConstraintsEncoder.TrainingParameters ceParams = new CornerConstraintsEncoder.TrainingParameters();\r\n    CornerConstraintsEncoder categoricalEncoder = MLBuilder.create(ceParams, configuration);\r\n    categoricalEncoder.fit_transform(trainingData);\r\n    MatrixLinearRegression.TrainingParameters param = new MatrixLinearRegression.TrainingParameters();\r\n    LinearRegressionMetrics vm = new Validator(LinearRegressionMetrics.class, configuration).validate(new KFoldSplitter(k).split(trainingData), param);\r\n    System.out.println(vm);\r\n    double expResult = 1;\r\n    double result = vm.getRSquare();\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n    numericalScaler.close();\r\n    categoricalEncoder.close();\r\n    trainingData.close();\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributionsTest.testStudentsCdf",
	"Comment": "test of studentscdf method, of class continuousdistributions.",
	"Method": "void testStudentsCdf(){\r\n    logger.info(\"StudentsCdf\");\r\n    double x = 3.0;\r\n    int df = 10;\r\n    double expResult = 0.99332817273466;\r\n    double result = ContinuousDistributions.studentsCdf(x, df);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "org.fourthline.cling.support.contentdirectory.AbstractContentDirectoryService.search",
	"Comment": "override this method to implement searching of your content.the default implementation returns an empty result.",
	"Method": "BrowseResult search(String containerId,String searchCriteria,String filter,UnsignedIntegerFourBytes firstResult,UnsignedIntegerFourBytes maxResults,String orderBy,BrowseResult search,String containerId,String searchCriteria,String filter,long firstResult,long maxResults,SortCriterion[] orderBy){\r\n    try {\r\n        return new BrowseResult(new DIDLParser().generate(new DIDLContent()), 0, 0);\r\n    } catch (Exception ex) {\r\n        throw new ContentDirectoryException(ErrorCode.ACTION_FAILED, ex.toString());\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.Record.getYPredictedProbabilities",
	"Comment": "if prediction probabilities are available for the particular algorithm, then this method will return these probabilities. this is supported byall the classification and some clustering algorithms.",
	"Method": "AssociativeArray getYPredictedProbabilities(){\r\n    return yPredictedProbabilities;\r\n}"
}, {
	"Path": "buildcraft.transport.PipeTransportFluids.computeFluidUpdate",
	"Comment": "computes the packetfluidupdate packet for transmission to a client",
	"Method": "PacketFluidUpdate computeFluidUpdate(boolean initPacket,boolean persistChange){\r\n    boolean changed = false;\r\n    BitSet delta = new BitSet(8);\r\n    FluidRenderData renderCacheCopy = this.renderCache;\r\n    if (initPacket || (fluidType == null && renderCacheCopy.fluidID != 0) || (fluidType != null && renderCacheCopy.fluidID != fluidType.getFluid().getID())) {\r\n        changed = true;\r\n        renderCache.fluidID = fluidType != null ? fluidType.getFluid().getID() : 0;\r\n        renderCache.color = fluidType != null ? fluidType.getFluid().getColor(fluidType) : -1;\r\n        renderCache.flags = FluidRenderData.getFlags(fluidType);\r\n        delta.set(0);\r\n    }\r\n    for (int dir : orientations) {\r\n        int pamount = renderCache.amount[dir];\r\n        int camount = sections[dir].amount;\r\n        int displayQty = (pamount * 4 + camount) / 5;\r\n        if (displayQty == 0 && camount > 0 || initPacket) {\r\n            displayQty = camount;\r\n        }\r\n        displayQty = Math.min(getCapacity(), displayQty);\r\n        if (pamount != displayQty || initPacket) {\r\n            changed = true;\r\n            renderCache.amount[dir] = displayQty;\r\n            delta.set(dir + 1);\r\n        }\r\n    }\r\n    renderCacheCopy.flow = flow;\r\n    for (int i = 0; i < 6; i++) {\r\n        if (renderCache.flow[i] != renderCacheCopy.flow[i]) {\r\n            changed = true;\r\n        }\r\n    }\r\n    if (persistChange) {\r\n        this.renderCache = renderCacheCopy;\r\n    }\r\n    if (changed || initPacket) {\r\n        PacketFluidUpdate packet = new PacketFluidUpdate(container, initPacket);\r\n        packet.renderCache = renderCacheCopy;\r\n        packet.delta = delta;\r\n        packet.flow = renderCacheCopy.flow;\r\n        return packet;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.topologi.diffx.load.DOMRecorder.process",
	"Comment": "processes the given node list and returns the corresponding event sequence.this method only returns the event sequence from the first node in the node list, if thenode list is empty, this method returns an empty sequence.",
	"Method": "EventSequence process(File file,EventSequence process,String xml,EventSequence process,InputSource is,EventSequence process,Node node,EventSequence process,NodeList node){\r\n    if (node.getLength() == 0)\r\n        return new EventSequence();\r\n    return process(node.item(0));\r\n}"
}, {
	"Path": "com.github.dockerjava.api.model.BuildResponseItem.isBuildSuccessIndicated",
	"Comment": "returns whether the stream field indicates a successful build operation",
	"Method": "boolean isBuildSuccessIndicated(){\r\n    if (isErrorIndicated() || getStream() == null) {\r\n        return false;\r\n    }\r\n    return getStream().contains(BUILD_SUCCESS);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.Datasets.sentimentAnalysisUnlabeled",
	"Comment": "returns the uri of an unlabelled sentiment analysis dataset.",
	"Method": "URI sentimentAnalysisUnlabeled(){\r\n    return inputStreamToURI(Datasets.class.getClassLoader().getResourceAsStream(\"datasets/sentimentAnalysis.unlabelled.txt\"));\r\n}"
}, {
	"Path": "org.jak_linux.dns66.db.RuleDatabaseUpdateTask.releaseGarbagePermissions",
	"Comment": "releases all persisted uri permissions that are no longer referenced",
	"Method": "void releaseGarbagePermissions(){\r\n    ContentResolver contentResolver = context.getContentResolver();\r\n    for (UriPermission permission : contentResolver.getPersistedUriPermissions()) {\r\n        if (isGarbage(permission.getUri())) {\r\n            Log.i(TAG, \"releaseGarbagePermissions: Releasing permission for \" + permission.getUri());\r\n            contentResolver.releasePersistableUriPermission(permission.getUri(), Intent.FLAG_GRANT_READ_URI_PERMISSION);\r\n        } else {\r\n            Log.v(TAG, \"releaseGarbagePermissions: Keeping permission for \" + permission.getUri());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "cyclops.function.Consumer4.apply",
	"Comment": "partially applyhkt the first, second and third input parameters to this c4",
	"Method": "Function<T2, Function<T3, Consumer<T4>>> apply(T1 s,Function<T3, Consumer<T4>> apply,T1 s,T2 s2,Consumer<T4> apply,T1 s,T2 s2,T3 s3){\r\n    return CurryConsumer.curryC4(this).apply(s).apply(s2).apply(s3);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.SortedSetX.rangeLong",
	"Comment": "create a sortedsetx that contains the longs between skip and take",
	"Method": "SortedSetX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).sortedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.descriptivestatistics.CensoredDescriptivesTest.testMeanVariance",
	"Comment": "test of meanvariance method, of class censoreddescriptives.",
	"Method": "void testMeanVariance(){\r\n    logger.info(\"meanVariance\");\r\n    AssociativeArray2D survivalFunction = CensoredDescriptives.survivalFunction(generateFlatDataCollection());\r\n    double expResult = 2.7874113520408;\r\n    double result = CensoredDescriptives.meanVariance(survivalFunction);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.independentsamples.FIndependentSamplesTest.testTestVariances",
	"Comment": "test of testvariances method, of class findependentsamples.",
	"Method": "void testTestVariances(){\r\n    logger.info(\"testVariances\");\r\n    double stdbarx = 65.54909;\r\n    double stdbary = 61.85425;\r\n    int n = 100;\r\n    int m = 240;\r\n    boolean is_twoTailed = true;\r\n    double aLevel = 0.05;\r\n    boolean expResult = false;\r\n    boolean result = FIndependentSamples.testVariances(stdbarx, stdbary, n, m, is_twoTailed, aLevel);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.DequeX.fill",
	"Comment": "generate a dequex from the provided value up to the provided limit number of times",
	"Method": "DequeX<T> fill(long limit,T s){\r\n    return ReactiveSeq.fill(s).limit(limit).to(ReactiveConvertableSequence::converter).dequeX(LAZY);\r\n}"
}, {
	"Path": "cyclops.function.Consumer3.apply",
	"Comment": "partially applyhkt the first and second input parameter to this c3",
	"Method": "Function<S2, Consumer<S3>> apply(S1 s,Consumer<S3> apply,S1 s,S2 s2){\r\n    return CurryConsumer.curryC3(this).apply(s).apply(s2);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.firstOf",
	"Comment": "return first stream out of provided streams that starts emitted results",
	"Method": "SimpleReactStream<U> firstOf(SimpleReactStream<U> futureStreams){\r\n    return EagerFutureStreamFunctions.firstOf(futureStreams);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.OrderedSetX.range",
	"Comment": "create a orderedsetx that contains the integers between skip and take",
	"Method": "OrderedSetX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).orderedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.ensemblelearning.FixedCombinationRules.minimum",
	"Comment": "combines the responses of the classifiers by using selecting the minimumprobability of each class.",
	"Method": "AssociativeArray minimum(DataTable2D classifierClassProbabilityMatrix){\r\n    AssociativeArray combinedClassProbabilities = new AssociativeArray();\r\n    for (Map.Entry<Object, AssociativeArray> entry : classifierClassProbabilityMatrix.entrySet()) {\r\n        AssociativeArray listOfClassProbabilities = entry.getValue();\r\n        for (Map.Entry<Object, Object> entry2 : listOfClassProbabilities.entrySet()) {\r\n            Object theClass = entry2.getKey();\r\n            Double probability = TypeInference.toDouble(entry2.getValue());\r\n            Double previousValue = combinedClassProbabilities.getDouble(theClass);\r\n            if (previousValue == null || probability < previousValue) {\r\n                combinedClassProbabilities.put(theClass, probability);\r\n            }\r\n        }\r\n    }\r\n    return combinedClassProbabilities;\r\n}"
}, {
	"Path": "com.datumbox.framework.common.concurrency.ConcurrencyConfiguration.setParallelized",
	"Comment": "setter for the parallelized flag. this option controls whether parallelexecution of threads is allowed in the framework.",
	"Method": "void setParallelized(boolean parallelized){\r\n    this.parallelized = parallelized;\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.FlatDataList.toFlatDataCollection",
	"Comment": "returns a flatdatacollection with the values of the internal list withoutcoping the data.",
	"Method": "FlatDataCollection toFlatDataCollection(){\r\n    return new FlatDataCollection(internalData);\r\n}"
}, {
	"Path": "cyclops.futurestream.SimpleReact.fromStream",
	"Comment": "start a reactive dataflow from a stream of completablefutures.",
	"Method": "SimpleReactStream<U> fromStream(Stream<CompletableFuture<U>> stream){\r\n    final Stream s = stream;\r\n    return construct(s);\r\n}"
}, {
	"Path": "cyclops.typeclasses.foldable.Foldable.foldLeft",
	"Comment": "starting from the left combine each value in turn with an accumulator",
	"Method": "T foldLeft(Monoid<T> monoid,Higher<CRE, T> ds,T foldLeft,T identity,BinaryOperator<T> semigroup,Higher<CRE, T> ds){\r\n    return foldLeft(Monoid.fromBiFunction(identity, semigroup), ds);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentQueueX.generate",
	"Comment": "generate a persistentqueuex from the provided supplier up to the provided limit number of times",
	"Method": "PersistentQueueX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).persistentQueueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.DataTable2D.isValid",
	"Comment": "returns if the datatable2d is valid. this data structure is consideredvalid it all the datatable cells are set and as a result the datatablehas a rectangular format.",
	"Method": "boolean isValid(){\r\n    int totalNumberOfColumns = 0;\r\n    Set<Object> columns = new HashSet();\r\n    for (Map.Entry<Object, AssociativeArray> entry : internalData.entrySet()) {\r\n        AssociativeArray row = entry.getValue();\r\n        if (columns.isEmpty()) {\r\n            for (Object column : row.internalData.keySet()) {\r\n                columns.add(column);\r\n            }\r\n            totalNumberOfColumns = columns.size();\r\n        } else {\r\n            if (totalNumberOfColumns != row.size()) {\r\n                return false;\r\n            }\r\n            for (Object column : columns) {\r\n                if (row.containsKey(column) == false) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "cyclops.control.LazyEither5.toIor",
	"Comment": "return an ior that can be this object or a ior.right or ior.left",
	"Method": "Ior<LT1, RT> toIor(){\r\n    return this.fold(l -> Ior.left(l), m -> Ior.left(null), m -> Ior.left(null), m -> Ior.left(null), r -> Ior.right(r));\r\n}"
}, {
	"Path": "cyclops.kinds.StreamKind.narrowK",
	"Comment": "convert the raw higher kinded type for stream types into the streamkind type definition class",
	"Method": "StreamKind<T> narrowK(Higher<DataWitness.stream, T> stream){\r\n    return (StreamKind<T>) stream;\r\n}"
}, {
	"Path": "cyclops.futurestream.FutureStream.unboundedWaitFree",
	"Comment": "this is the default setting, internal queues are backed by a concurrentlinkedqueuethis operator will return the next stage to using this queue type if it has been changed",
	"Method": "FutureStream<U> unboundedWaitFree(){\r\n    return this.withQueueFactory(QueueFactories.unboundedNonBlockingQueue());\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.json.JSONSerializer.serializeFromField",
	"Comment": "recursively serialize the named field of an object, skipping transient and final fields.",
	"Method": "String serializeFromField(Object containingObject,String fieldName,int indentWidth,boolean onlySerializePublicFields,ClassFieldCache classFieldCache,String serializeFromField,Object containingObject,String fieldName,int indentWidth,boolean onlySerializePublicFields){\r\n    final ClassFieldCache classFieldCache = new ClassFieldCache(false, onlySerializePublicFields);\r\n    return serializeFromField(containingObject, fieldName, indentWidth, onlySerializePublicFields, classFieldCache);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributionsTest.testChisquareInverseCdf",
	"Comment": "test of chisquareinversecdf method, of class continuousdistributions.",
	"Method": "void testChisquareInverseCdf(){\r\n    logger.info(\"ChisquareInverseCdf\");\r\n    double p = 0.32;\r\n    int df = 10;\r\n    double expResult = 11.498788492223;\r\n    double result = ContinuousDistributions.chisquareInverseCdf(p, df);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "cyclops.stream.StreamSource.of",
	"Comment": "construct a pushable streamsource using the provided queuefactory as a push mechanism",
	"Method": "StreamSource of(QueueFactory<?> q,StreamSource of,int backPressureAfter){\r\n    if (backPressureAfter < 1)\r\n        throw new IllegalArgumentException(\"Can't apply back pressure after less than 1 event\");\r\n    return new StreamSource(backPressureAfter, true);\r\n}"
}, {
	"Path": "cyclops.data.ImmutableMap.toLazySeq",
	"Comment": "convert this immutablemap to a lazyseq via the provided transformation function",
	"Method": "LazySeq<T> toLazySeq(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn){\r\n    return LazySeq.narrow(stream().map(fn).to().lazySeq());\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.ScanSpec.filterClasspathElements",
	"Comment": "add a classpath element filter. the provided classpathelementfilter should return true if the path stringpassed to it is a path you want to scan.",
	"Method": "void filterClasspathElements(ClasspathElementFilter classpathElementFilter){\r\n    if (this.classpathElementFilters == null) {\r\n        this.classpathElementFilters = new ArrayList(2);\r\n    }\r\n    this.classpathElementFilters.add(classpathElementFilter);\r\n}"
}, {
	"Path": "cyclops.monads.transformers.ListT.of",
	"Comment": "construct an listt from an anym that wraps a monad containinglists",
	"Method": "ListT<W, A> of(AnyM<W, ? extends IndexedSequenceX<A>> monads){\r\n    return new ListT(monads);\r\n}"
}, {
	"Path": "com.spotify.docker.client.DockerConfigReader.fromConfig",
	"Comment": "returns the registryauth for the config file for the given registry server name.",
	"Method": "RegistryConfigs fromConfig(Path configPath,RegistryAuth fromConfig,Path configPath,String serverAddress){\r\n    return authForRegistry(configPath, serverAddress);\r\n}"
}, {
	"Path": "buildcraft.core.lib.commands.CommandHelpers.sendChatMessage",
	"Comment": "avoid using this function if at all possible. commands are processed on the server, which has no localizationinformation.",
	"Method": "void sendChatMessage(ICommandSender sender,String message){\r\n    sender.addChatMessage(new TextComponentString(message));\r\n}"
}, {
	"Path": "cyclops.companion.Streams.streamToCompletableFuture",
	"Comment": "create a completablefuture containing a list materialized from a stream",
	"Method": "CompletableFuture<List<T>> streamToCompletableFuture(Stream<T> stream){\r\n    return CompletableFuture.completedFuture(stream.collect(Collectors.toList()));\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.QueueX.rangeLong",
	"Comment": "create a queuex that contains the longs between skip and take",
	"Method": "QueueX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).queueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.topologi.diffx.event.impl.EventFactory.makeAttribute",
	"Comment": "returns the attribute event from the name and value given.if the factory is namespace aware, it returns an attribute implementationusing the namespace uri and the name.if the factory is not namespace aware, it returns an attribute implementationusing the specified name.use this implementation if the name of the element is determined prior to thecall of this method.",
	"Method": "AttributeEvent makeAttribute(String uri,String name,String value,AttributeEvent makeAttribute,String uri,String localName,String qName,String value){\r\n    if (this.isNamespaceAware)\r\n        return new AttributeEventNSImpl(\"\".equals(uri) ? null : uri, localName, value);\r\n    else\r\n        return new AttributeEventImpl(qName, value);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.utilities.PHPMethods.preg_replace",
	"Comment": "matches a string with a pattern and replaces the matched components with a provided string.",
	"Method": "String preg_replace(String regex,String replacement,String subject,String preg_replace,Pattern pattern,String replacement,String subject){\r\n    Matcher m = pattern.matcher(subject);\r\n    StringBuffer sb = new StringBuffer(subject.length());\r\n    while (m.find()) {\r\n        m.appendReplacement(sb, replacement);\r\n    }\r\n    m.appendTail(sb);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.oath.cyclops.types.reactive.ReactiveTask.requestAll",
	"Comment": "request all elements to be processed from the processing stream",
	"Method": "void requestAll(){\r\n    request(Long.MAX_VALUE);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributionsTest.testGaussCdf",
	"Comment": "test of gausscdf method, of class continuousdistributions.",
	"Method": "void testGaussCdf(){\r\n    logger.info(\"GaussCdf\");\r\n    double z = 3.0;\r\n    double expResult = 0.9986501025724;\r\n    double result = ContinuousDistributions.gaussCdf(z);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.applications.nlp.TextClassifierTest.testTrainAndValidateSoftMaxRegression",
	"Comment": "test of train and validate method, of class textclassifier using softmaxregression.",
	"Method": "void testTrainAndValidateSoftMaxRegression(){\r\n    logger.info(\"testTrainAndValidateSoftMaxRegression\");\r\n    SoftMaxRegression.TrainingParameters mlParams = new SoftMaxRegression.TrainingParameters();\r\n    ChisquareSelect.TrainingParameters fsParams = new ChisquareSelect.TrainingParameters();\r\n    fsParams.setALevel(0.05);\r\n    fsParams.setMaxFeatures(1000);\r\n    fsParams.setRareFeatureThreshold(3);\r\n    BinaryScaler.TrainingParameters nsParams = new BinaryScaler.TrainingParameters();\r\n    nsParams.setScaleResponse(false);\r\n    nsParams.setThreshold(0.0);\r\n    trainAndValidate(mlParams, fsParams, nsParams, 0.8979999999999999, 6);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.common.interfaces.ValidationMetrics.newInstance",
	"Comment": "estimates the average validation metrics object from a list of metrics.",
	"Method": "VM newInstance(Class<VM> vmClass,VM newInstance,Class<VM> vmClass,Dataframe predictedData,VM newInstance,Class<VM> vmClass,List<VM> validationMetricsList){\r\n    try {\r\n        return vmClass.getConstructor(List.class).newInstance(validationMetricsList);\r\n    } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.topologi.diffx.Docx4jDriver.formatEventSequence",
	"Comment": "send this entire eventsequence to the formatter.used by docx4jdriver",
	"Method": "void formatEventSequence(EventSequence eventSequence,DiffXFormatter formatter){\r\n    List<DiffXEvent> sequence = eventSequence.events();\r\n    DiffXEvent x = null;\r\n    for (int i = 0; i < sequence.size(); i++) {\r\n        x = (DiffXEvent) sequence.get(i);\r\n        formatter.format(x);\r\n    }\r\n}"
}, {
	"Path": "cyclops.stream.StreamSource.ofMultiple",
	"Comment": "construct a streamsource that supports multiple readers of the same data backed by a queue createdfrom the supplied queuefactory",
	"Method": "MultipleStreamSource<T> ofMultiple(MultipleStreamSource<T> ofMultiple,int backPressureAfter,MultipleStreamSource<T> ofMultiple,QueueFactory<?> q){\r\n    Objects.requireNonNull(q);\r\n    return new MultipleStreamSource<T>(StreamSource.of(q).createQueue());\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.ListX.range",
	"Comment": "create a listx that contains the integers between skip and take",
	"Method": "ListX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).listX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.LinkedListX.fill",
	"Comment": "generate a linkedlistx from the provided value up to the provided limit number of times",
	"Method": "LinkedListX<T> fill(long limit,T s){\r\n    return ReactiveSeq.fill(s).limit(limit).to(ReactiveConvertableSequence::converter).linkedListX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.onesample.KolmogorovSmirnovOneSample.normalDistribution",
	"Comment": "cumulative normal distribution method. this method is called via reflection.",
	"Method": "double normalDistribution(Double x,AssociativeArray params){\r\n    double mean = params.getDouble(\"mean\");\r\n    double variance = params.getDouble(\"variance\");\r\n    double z = (x - mean) / Math.sqrt(variance);\r\n    return ContinuousDistributions.gaussCdf(z);\r\n}"
}, {
	"Path": "com.datumbox.framework.applications.nlp.TextClassifier.validate",
	"Comment": "it validates the modeler using the provided dataset files. the data map should have as index the names of each class and as values the uris of the training files. the data files should contain one example per row.",
	"Method": "ClassificationMetrics validate(Dataframe testDataset,ClassificationMetrics validate,Map<Object, URI> datasets){\r\n    TrainingParameters trainingParameters = (TrainingParameters) knowledgeBase.getTrainingParameters();\r\n    Dataframe testDataset = Dataframe.Builder.parseTextFiles(datasets, AbstractTextExtractor.newInstance(trainingParameters.getTextExtractorParameters()), knowledgeBase.getConfiguration());\r\n    ClassificationMetrics vm = validate(testDataset);\r\n    testDataset.close();\r\n    return vm;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.ReadabilityStatisticsTest.testAutomated_readability_index",
	"Comment": "test of automatedreadabilityindex method, of class readabilitystatistics.",
	"Method": "void testAutomated_readability_index(){\r\n    logger.info(\"automated_readability_index\");\r\n    String strText = TEST_STRING;\r\n    double expResult = 143.2;\r\n    double result = ReadabilityStatistics.automatedReadabilityIndex(strText);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.topologi.diffx.event.impl.EventFactory.makeCloseElement",
	"Comment": "returns the close element event from the corresponding open element event.",
	"Method": "CloseElementEvent makeCloseElement(OpenElementEvent open){\r\n    if (this.isNamespaceAware)\r\n        return new CloseElementEventNSImpl(open);\r\n    else\r\n        return new CloseElementEventImpl(open);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.anova.Anova.oneWayTestNotEqualVars",
	"Comment": "wrapper function for onewaytestnotequalvars, without passing the optionaloutput table.",
	"Method": "boolean oneWayTestNotEqualVars(TransposeDataCollection transposeDataCollection,double aLevel,AssociativeArray2D outputTable,boolean oneWayTestNotEqualVars,TransposeDataCollection transposeDataCollection,double aLevel){\r\n    return oneWayTestNotEqualVars(transposeDataCollection, aLevel, null);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.ReadabilityStatistics.cleanText",
	"Comment": "trims, removes line breaks, multiple spaces and generally cleans text before processing.",
	"Method": "String cleanText(String strText){\r\n    strText = HTMLParser.unsafeRemoveAllTags(strText);\r\n    strText = strText.toLowerCase(Locale.ENGLISH);\r\n    strText = StringCleaner.unifyTerminators(strText);\r\n    strText = strText.replaceAll(\" [0-9]+ \", \" \");\r\n    strText = StringCleaner.removeExtraSpaces(strText);\r\n    return strText;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.independentsamples.KolmogorovSmirnovIndependentSamples.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level",
	"Method": "boolean test(TransposeDataList transposeDataList,boolean is_twoTailed,double aLevel){\r\n    int k = transposeDataList.size();\r\n    if (k != 2) {\r\n        throw new IllegalArgumentException(\"The collection must contain observations from 2 groups.\");\r\n    }\r\n    Object[] keys = transposeDataList.keySet().toArray();\r\n    Set<Double> allUniqueValues = new TreeSet();\r\n    for (int j = 0; j < k; ++j) {\r\n        Iterator<Double> it = transposeDataList.get(keys[j]).iteratorDouble();\r\n        while (it.hasNext()) {\r\n            allUniqueValues.add(it.next());\r\n        }\r\n    }\r\n    DataTable2D distributionAndValue2Probability = new DataTable2D();\r\n    for (int j = 0; j < k; ++j) {\r\n        Object keyj = keys[j];\r\n        int nj = transposeDataList.get(keyj).size();\r\n        if (nj <= 0) {\r\n            throw new IllegalArgumentException(\"The number of observations in each group but be larger than 0.\");\r\n        }\r\n        int rank = 1;\r\n        for (Double value : allUniqueValues) {\r\n            Object objValue = value;\r\n            if (!transposeDataList.get(keyj).contains(objValue)) {\r\n                distributionAndValue2Probability.put2d(keyj, objValue, (rank - 1.0) / nj);\r\n                continue;\r\n            }\r\n            if (distributionAndValue2Probability.get2d(keyj, objValue) == null) {\r\n                distributionAndValue2Probability.put2d(keyj, objValue, (double) rank / nj);\r\n            }\r\n            ++rank;\r\n        }\r\n    }\r\n    double maxDelta = 0.0;\r\n    for (Object key : distributionAndValue2Probability.get(keys[0]).keySet()) {\r\n        double v1 = distributionAndValue2Probability.get(keys[0]).getDouble(key);\r\n        double v2 = distributionAndValue2Probability.get(keys[1]).getDouble(key);\r\n        double delta = Math.abs(v2 - v1);\r\n        if (delta > maxDelta) {\r\n            maxDelta = delta;\r\n        }\r\n    }\r\n    int n1 = transposeDataList.get(keys[0]).size();\r\n    int n2 = transposeDataList.get(keys[1]).size();\r\n    boolean rejectH0 = checkCriticalValue(maxDelta, is_twoTailed, n1, n2, aLevel);\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AssociativeArray.get",
	"Comment": "returns the value which is associated with the provided key.",
	"Method": "Object get(Object key){\r\n    return internalData.get(key);\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.classpath.ClasspathFinder.addClassLoaderHandler",
	"Comment": "add a classloaderhandler, and recurse to parent classloader.",
	"Method": "boolean addClassLoaderHandler(ScanSpec scanSpec,ClassLoader classLoader,ClassLoaderHandlerRegistryEntry classLoaderHandlerRegistryEntry,LinkedHashSet<ClassLoader> foundClassLoaders,List<ClassLoaderHandlerRegistryEntry> allClassLoaderHandlerRegistryEntries,List<SimpleEntry<ClassLoader, ClassLoaderHandler>> classLoaderAndHandlerOrderOut,List<SimpleEntry<ClassLoader, ClassLoaderHandler>> ignoredClassLoaderAndHandlerOrderOut,Set<ClassLoader> visited,LogNode log){\r\n    final ClassLoaderHandler classLoaderHandler = classLoaderHandlerRegistryEntry.instantiate(log);\r\n    if (classLoaderHandler != null) {\r\n        if (log != null) {\r\n            log.log(\"ClassLoader \" + classLoader + \" will be handled by \" + classLoaderHandler);\r\n        }\r\n        final ClassLoader embeddedClassLoader = classLoaderHandler.getEmbeddedClassLoader(classLoader);\r\n        if (embeddedClassLoader != null) {\r\n            if (visited.add(embeddedClassLoader)) {\r\n                if (log != null) {\r\n                    log.log(\"Delegating from \" + classLoader + \" to embedded ClassLoader \" + embeddedClassLoader);\r\n                }\r\n                return addClassLoaderHandler(scanSpec, embeddedClassLoader, classLoaderHandlerRegistryEntry, foundClassLoaders, allClassLoaderHandlerRegistryEntries, classLoaderAndHandlerOrderOut, ignoredClassLoaderAndHandlerOrderOut, visited, log);\r\n            } else {\r\n                if (log != null) {\r\n                    log.log(\"Hit infinite loop when delegating from \" + classLoader + \" to embedded ClassLoader \" + embeddedClassLoader);\r\n                }\r\n                return false;\r\n            }\r\n        } else {\r\n            final DelegationOrder delegationOrder = classLoaderHandler.getDelegationOrder(classLoader);\r\n            final ClassLoader parent = classLoader.getParent();\r\n            if (log != null && parent != null) {\r\n                log.log(classLoader + \" delegates to parent \" + parent + \" with order \" + delegationOrder);\r\n            }\r\n            switch(delegationOrder) {\r\n                case PARENT_FIRST:\r\n                    if (parent != null) {\r\n                        findClassLoaderHandlerForClassLoaderAndParents(scanSpec, parent, foundClassLoaders, allClassLoaderHandlerRegistryEntries, scanSpec.ignoreParentClassLoaders ? ignoredClassLoaderAndHandlerOrderOut : classLoaderAndHandlerOrderOut, ignoredClassLoaderAndHandlerOrderOut, log);\r\n                    }\r\n                    classLoaderAndHandlerOrderOut.add(new SimpleEntry(classLoader, classLoaderHandler));\r\n                    return true;\r\n                case PARENT_LAST:\r\n                    classLoaderAndHandlerOrderOut.add(new SimpleEntry(classLoader, classLoaderHandler));\r\n                    if (parent != null) {\r\n                        findClassLoaderHandlerForClassLoaderAndParents(scanSpec, parent, foundClassLoaders, allClassLoaderHandlerRegistryEntries, scanSpec.ignoreParentClassLoaders ? ignoredClassLoaderAndHandlerOrderOut : classLoaderAndHandlerOrderOut, ignoredClassLoaderAndHandlerOrderOut, log);\r\n                    }\r\n                    return true;\r\n                default:\r\n                    throw new RuntimeException(\"Unknown delegation order\");\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "buildcraft.core.lib.inventory.StackHelper.isCraftingEquivalent",
	"Comment": "determines whether the given itemstack should be considered equivalent for crafting purposes.",
	"Method": "boolean isCraftingEquivalent(ItemStack base,ItemStack comparison,boolean oreDictionary,boolean isCraftingEquivalent,int[] oreIDs,ItemStack comparison){\r\n    return StackUtil.isCraftingEquivalent(oreIDs, comparison);\r\n}"
}, {
	"Path": "org.fourthline.cling.registry.RegistryImpl.shutdown",
	"Comment": "when you call this, make sure you have the router lock before this lock is obtained!",
	"Method": "void shutdown(){\r\n    log.fine(\"Shutting down registry...\");\r\n    if (registryMaintainer != null)\r\n        registryMaintainer.stop();\r\n    log.finest(\"Executing final pending operations on shutdown: \" + pendingExecutions.size());\r\n    runPendingExecutions(false);\r\n    for (RegistryListener listener : registryListeners) {\r\n        listener.beforeShutdown(this);\r\n    }\r\n    RegistryItem<URI, Resource>[] resources = resourceItems.toArray(new RegistryItem[resourceItems.size()]);\r\n    for (RegistryItem<URI, Resource> resourceItem : resources) {\r\n        resourceItem.getItem().shutdown();\r\n    }\r\n    remoteItems.shutdown();\r\n    localItems.shutdown();\r\n    for (RegistryListener listener : registryListeners) {\r\n        listener.afterShutdown();\r\n    }\r\n}"
}, {
	"Path": "cyclops.companion.rx2.Singles.fromIterable",
	"Comment": "construct a single from iterable by taking the first value from iterable",
	"Method": "Single<T> fromIterable(Iterable<T> t){\r\n    return Single.fromPublisher(Future.fromIterable(t));\r\n}"
}, {
	"Path": "com.spotify.docker.client.DefaultLogStream.writeAndFlush",
	"Comment": "write the contents of the given bytebuffer to the outputstream and flush the stream.",
	"Method": "void writeAndFlush(ByteBuffer buffer,OutputStream outputStream){\r\n    if (buffer.hasArray()) {\r\n        outputStream.write(buffer.array(), buffer.position(), buffer.remaining());\r\n    } else {\r\n        while (buffer.hasRemaining()) {\r\n            final int size = Math.min(buffer.remaining(), 8 * 1024);\r\n            final byte[] chunk = new byte[size];\r\n            buffer.get(chunk);\r\n            outputStream.write(chunk);\r\n        }\r\n    }\r\n    outputStream.flush();\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.QueueX.generate",
	"Comment": "generate a queuex from the provided supplier up to the provided limit number of times",
	"Method": "QueueX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).queueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentQueueX.iterate",
	"Comment": "create a persistentqueuex by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "PersistentQueueX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).persistentQueueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.onesample.StudentsOneSample.checkCriticalValue",
	"Comment": "checks the critical value to determine if the hypothesis should be rejected",
	"Method": "boolean checkCriticalValue(double score,int n,boolean is_twoTailed,double aLevel){\r\n    double probability = ContinuousDistributions.studentsCdf(score, n - 1);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2.0;\r\n    }\r\n    if (probability <= a || probability >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributions.chisquareCdf",
	"Comment": "returns the probability from 0 to x of a specific chisquare score and degrees of freedom",
	"Method": "double chisquareCdf(double x,int df){\r\n    if (df <= 0) {\r\n        throw new IllegalArgumentException(\"The degrees of freedom need to be positive.\");\r\n    }\r\n    return ContinuousDistributions.gammaCdf(x / 2.0, df / 2.0);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.PHPSimilarText.similarityChars",
	"Comment": "checks the similarity of two strings and returns the number of matching chars in both strings.",
	"Method": "int similarityChars(String txt1,String txt2){\r\n    int sim = similar_char(txt1, txt1.length(), txt2, txt2.length());\r\n    return sim;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.OrderedSetX.iterate",
	"Comment": "create a orderedsetx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "OrderedSetX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).orderedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.mathematics.distances.Distance.manhattanWeighted",
	"Comment": "estimates the weighted manhattan distance of two associative arrays.",
	"Method": "double manhattanWeighted(AssociativeArray a1,AssociativeArray a2,Map<Object, Double> columnWeights){\r\n    Map<Object, Double> columnDistances = columnDistances(a1, a2, columnWeights.keySet());\r\n    double distance = 0.0;\r\n    for (Map.Entry<Object, Double> entry : columnDistances.entrySet()) {\r\n        distance += Math.abs(entry.getValue()) * columnWeights.get(entry.getKey());\r\n    }\r\n    return distance;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.timeseries.SmoothingTest.testSimpleExponentialSmoothingQuick",
	"Comment": "test of simpleexponentialsmoothingquick method, of class smoothing.",
	"Method": "void testSimpleExponentialSmoothingQuick(){\r\n    logger.info(\"simpleExponentialSmoothingQuick\");\r\n    double Ytminus1 = 23.5;\r\n    double Stminus1 = 23.240433133179;\r\n    double a = 0.9;\r\n    double expResult = 23.474043313318;\r\n    double result = Smoothing.simpleExponentialSmoothingQuick(Ytminus1, Stminus1, a);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "cyclops.futurestream.Pipes.of",
	"Comment": "construct a pipes instance to manage a predefined map of adapaters",
	"Method": "Pipes<K, V> of(Pipes<K, V> of,Map<K, Adapter<V>> registered){\r\n    Objects.requireNonNull(registered);\r\n    final Pipes<K, V> pipes = new Pipes();\r\n    pipes.registered.putAll(registered);\r\n    return pipes;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.MapX.fromMap",
	"Comment": "wrap a transform in a mapx, also supplying a collector for use in operations",
	"Method": "MapX<K, V> fromMap(Map<? extends K, ? extends V> map,MapX<K, V> fromMap,Collector<Tuple2<? extends K, ? extends V>, ?, Map<K, V>> collector,Map<? extends K, ? extends V> map){\r\n    if (map instanceof MapX)\r\n        return (MapX) map;\r\n    if (map instanceof Map)\r\n        return new MapXImpl<K, V>((Map) map, collector);\r\n    return new MapXImpl<K, V>(Streams.stream(map).map(e -> Tuple.tuple(e.getKey(), e.getValue())).collect(collector), collector);\r\n}"
}, {
	"Path": "org.fourthline.cling.transport.impl.SOAPActionProcessorImpl.readArgumentValues",
	"Comment": "the upnp spec says that action arguments must be in the order as declaredby the service. this method however is lenient, the action argument nodesin the xml can be in any order, as long as they are all there everythingis ok.",
	"Method": "ActionArgumentValue[] readArgumentValues(NodeList nodeList,ActionArgument[] args){\r\n    List<Node> nodes = getMatchingNodes(nodeList, args);\r\n    ActionArgumentValue[] values = new ActionArgumentValue[args.length];\r\n    for (int i = 0; i < args.length; i++) {\r\n        ActionArgument arg = args[i];\r\n        Node node = findActionArgumentNode(nodes, arg);\r\n        if (node == null) {\r\n            throw new ActionException(ErrorCode.ARGUMENT_VALUE_INVALID, \"Could not find argument '\" + arg.getName() + \"' node\");\r\n        }\r\n        log.fine(\"Reading action argument: \" + arg.getName());\r\n        String value = XMLUtil.getTextContent(node);\r\n        values[i] = createValue(arg, value);\r\n    }\r\n    return values;\r\n}"
}, {
	"Path": "com.datumbox.framework.applications.nlp.TextClassifier.fit",
	"Comment": "trains a machine learning modeler using the provided dataset files. the data map should have as index the names of each class and as values the uris of the training files. the training files should contain one training example per row.",
	"Method": "void fit(Map<Object, URI> datasets){\r\n    TrainingParameters tp = (TrainingParameters) knowledgeBase.getTrainingParameters();\r\n    Dataframe trainingData = Dataframe.Builder.parseTextFiles(datasets, AbstractTextExtractor.newInstance(tp.getTextExtractorParameters()), knowledgeBase.getConfiguration());\r\n    fit(trainingData);\r\n    trainingData.close();\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.common.abstracts.featureselectors.AbstractScoreBasedFeatureSelector.removeRareFeatures",
	"Comment": "removes any feature with less occurrences than the threshold.",
	"Method": "void removeRareFeatures(Map<Object, Double> featureCounts,int rareFeatureThreshold){\r\n    logger.debug(\"removeRareFeatures()\");\r\n    Iterator<Map.Entry<Object, Double>> it = featureCounts.entrySet().iterator();\r\n    while (it.hasNext()) {\r\n        Map.Entry<Object, Double> entry = it.next();\r\n        if (entry.getValue() < rareFeatureThreshold) {\r\n            it.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.fourthline.cling.support.contentdirectory.callback.Browse.getDefaultMaxResults",
	"Comment": "some media servers will crash if there is no limit on the maximum number of results.",
	"Method": "long getDefaultMaxResults(){\r\n    return 999;\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.utils.InputStreamOrByteBufferAdapter.readInt",
	"Comment": "read an int from the buffer at a specific absolute offset before the current read point.",
	"Method": "int readInt(int readInt,int offset){\r\n    final int bytesToRead = Math.max(0, offset + 4 - used);\r\n    if (bytesToRead > 0) {\r\n        throw new IllegalArgumentException(\"Can only read from absolute offsets before the current location in the file\");\r\n    }\r\n    return ((buf[offset] & 0xff) << 24) | ((buf[offset + 1] & 0xff) << 16) | ((buf[offset + 2] & 0xff) << 8) | (buf[offset + 3] & 0xff);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributions.approxBinomialCdf",
	"Comment": "returns the a good approximation of cumulative probability of k of a specific number of tries n and probability p",
	"Method": "double approxBinomialCdf(int k,double p,int n){\r\n    double Z = p;\r\n    double A = k + 1;\r\n    double B = n - k;\r\n    double S = A + B;\r\n    double BT = Math.exp(ContinuousDistributions.logGamma(S) - ContinuousDistributions.logGamma(B) - ContinuousDistributions.logGamma(A) + A * Math.log(Z) + B * Math.log(1 - Z));\r\n    double probabilitySum;\r\n    if (Z < (A + 1) / (S + 2)) {\r\n        probabilitySum = BT * ContinuousDistributions.betinc(Z, A, B);\r\n    } else {\r\n        probabilitySum = 1.0 - BT * ContinuousDistributions.betinc(1.0 - Z, B, A);\r\n    }\r\n    probabilitySum = 1.0 - probabilitySum;\r\n    return probabilitySum;\r\n}"
}, {
	"Path": "org.jak_linux.dns66.vpn.VpnWatchdog.initialize",
	"Comment": "an initialization method. sleeps the penalty and sends initial packet.",
	"Method": "void initialize(boolean enabled){\r\n    Log.d(TAG, \"initialize: Initializing watchdog\");\r\n    pollTimeout = POLL_TIMEOUT_START;\r\n    lastPacketSent = 0;\r\n    this.enabled = enabled;\r\n    if (!enabled) {\r\n        Log.d(TAG, \"initialize: Disabled.\");\r\n        return;\r\n    }\r\n    if (initPenalty > 0) {\r\n        Log.d(TAG, \"init penalty: Sleeping for \" + initPenalty + \"ms\");\r\n        Thread.sleep(initPenalty);\r\n    }\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.MapX.toQueueX",
	"Comment": "convert this mapx to a queuex via the provided transformation function",
	"Method": "QueueX<T> toQueueX(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn){\r\n    return QueueX.narrow(stream().map(fn).to(ReactiveConvertableSequence::converter).queueX());\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributionsTest.testUniformCdf",
	"Comment": "test of uniformcdf method, of class discretedistributions.",
	"Method": "void testUniformCdf(){\r\n    logger.info(\"UniformCdf\");\r\n    int k = 3;\r\n    int n = 10;\r\n    double expResult = 0.3;\r\n    double result = DiscreteDistributions.uniformCdf(k, n);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.relatedsamples.KendallTauCorrelation.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level",
	"Method": "boolean test(TransposeDataList transposeDataList,boolean is_twoTailed,double aLevel){\r\n    if (transposeDataList.isEmpty()) {\r\n        return false;\r\n    }\r\n    double KendallTauCorrelation = calculateCorrelation(transposeDataList);\r\n    Object firstKey = transposeDataList.keySet().iterator().next();\r\n    int n = transposeDataList.get(firstKey).size();\r\n    double pvalue = scoreToPvalue(KendallTauCorrelation, n);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2;\r\n    }\r\n    if (pvalue <= a || pvalue >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "io.github.classgraph.ScanResult.getClasspathURLs",
	"Comment": "returns the list of unique classpath element paths as urls, in classloader resolution order.",
	"Method": "List<URL> getClasspathURLs(){\r\n    if (closed.get()) {\r\n        throw new IllegalArgumentException(\"Cannot use a ScanResult after it has been closed\");\r\n    }\r\n    final List<URL> classpathElementOrderURLs = new ArrayList();\r\n    for (final ClasspathElement classpathElement : classpathOrder) {\r\n        try {\r\n            if (classpathElement instanceof ClasspathElementModule) {\r\n                final URI location = ((ClasspathElementModule) classpathElement).getModuleRef().getLocation();\r\n                if (location != null) {\r\n                    classpathElementOrderURLs.add(location.toURL());\r\n                }\r\n            } else if (classpathElement instanceof ClasspathElementDir) {\r\n                classpathElementOrderURLs.add(((ClasspathElementDir) classpathElement).getDirFile().toURI().toURL());\r\n            } else if (classpathElement instanceof ClasspathElementZip) {\r\n                classpathElementOrderURLs.add(((ClasspathElementZip) classpathElement).getZipFileURL());\r\n            }\r\n        } catch (final MalformedURLException e) {\r\n        }\r\n    }\r\n    return classpathElementOrderURLs;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.VectorX.iterate",
	"Comment": "create a vectorx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "VectorX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).vectorX(LAZY);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.filter",
	"Comment": "removes elements that do not fold the supplied predicate from thedataflow",
	"Method": "SimpleReactStream<U> filter(Predicate<? super U> p){\r\n    if (!isAsync())\r\n        return filterSync(p);\r\n    final Function<Stream<CompletableFuture>, Stream<CompletableFuture>> fn = s -> s.map(ft -> ft.thenApplyAsync((in) -> {\r\n        if (!p.test((U) in)) {\r\n            throw new FilteredExecutionPathException();\r\n        }\r\n        return in;\r\n    }));\r\n    return this.withLastActive(getLastActive().stream(fn));\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.parsers.URLParser.splitURL",
	"Comment": "this method splits a url into parts and return a map containing them.",
	"Method": "Map<URLParts, String> splitURL(String URLString,Map<URLParts, String> splitURL,URL url){\r\n    Map<URLParts, String> urlParts = new HashMap();\r\n    urlParts.put(URLParts.PROTOCOL, url.getProtocol());\r\n    urlParts.put(URLParts.USERINFO, url.getUserInfo());\r\n    urlParts.put(URLParts.AUTHORITY, url.getAuthority());\r\n    urlParts.put(URLParts.HOST, url.getHost());\r\n    urlParts.put(URLParts.PATH, url.getPath());\r\n    urlParts.put(URLParts.QUERY, url.getQuery());\r\n    urlParts.put(URLParts.FILENAME, url.getFile());\r\n    urlParts.put(URLParts.REF, url.getRef());\r\n    int port = url.getPort();\r\n    if (port != -1) {\r\n        urlParts.put(URLParts.PORT, String.valueOf(port));\r\n    } else {\r\n        urlParts.put(URLParts.PORT, null);\r\n    }\r\n    return urlParts;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.ReadabilityStatisticsTest.testColeman_liau_index",
	"Comment": "test of colemanliauindex method, of class readabilitystatistics.",
	"Method": "void testColeman_liau_index(){\r\n    logger.info(\"coleman_liau_index\");\r\n    String strText = TEST_STRING;\r\n    double expResult = 6.8;\r\n    double result = ReadabilityStatistics.colemanLiauIndex(strText);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "io.github.classgraph.ClassGraph.blacklistModules",
	"Comment": "blacklist one or more modules, preventing them from being scanned.",
	"Method": "ClassGraph blacklistModules(String moduleNames){\r\n    for (final String moduleName : moduleNames) {\r\n        scanSpec.moduleWhiteBlackList.addToBlacklist(moduleName);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.oath.cyclops.util.stream.scheduling.cron.CronExpression.isSatisfiedBy",
	"Comment": "indicates whether the given date satisfies the cron expression. note thatmilliseconds are ignored, so two dates falling on different millisecondsof the same second will always have the same result here.",
	"Method": "boolean isSatisfiedBy(Date date){\r\n    final Calendar testDateCal = Calendar.getInstance(getTimeZone());\r\n    testDateCal.setTime(date);\r\n    testDateCal.set(Calendar.MILLISECOND, 0);\r\n    final Date originalDate = testDateCal.getTime();\r\n    testDateCal.add(Calendar.SECOND, -1);\r\n    final Date timeAfter = getTimeAfter(testDateCal.getTime());\r\n    return timeAfter != null && timeAfter.equals(originalDate);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AbstractDataStructureCollection.contains",
	"Comment": "checks whether the provided object is contained in the internal data.",
	"Method": "boolean contains(Object o){\r\n    return internalData.contains(o);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.survival.nonparametrics.independentsamples.Logrank.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level.",
	"Method": "boolean test(TransposeDataCollection transposeDataCollection,boolean is_twoTailed,double aLevel){\r\n    double pvalue = getPvalue(transposeDataCollection);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2;\r\n    }\r\n    if (pvalue <= a || pvalue >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.spotify.docker.client.auth.gcr.ContainerRegistryAuthSupplier.getAccessToken",
	"Comment": "get an accesstoken to use, possibly refreshing the token if it expires within theminimumexpirymillis.",
	"Method": "AccessToken getAccessToken(){\r\n    synchronized (credentials) {\r\n        if (needsRefresh(credentials.getAccessToken())) {\r\n            credentialRefresher.refresh(credentials);\r\n        }\r\n    }\r\n    return credentials.getAccessToken();\r\n}"
}, {
	"Path": "com.datumbox.framework.applications.nlp.TextClassifierTest.testTrainAndValidateMaximumEntropy",
	"Comment": "test of train and validate method, of class textclassifier using maximumentropy.",
	"Method": "void testTrainAndValidateMaximumEntropy(){\r\n    logger.info(\"testTrainAndValidateMaximumEntropy\");\r\n    MaximumEntropy.TrainingParameters mlParams = new MaximumEntropy.TrainingParameters();\r\n    ChisquareSelect.TrainingParameters fsParams = new ChisquareSelect.TrainingParameters();\r\n    fsParams.setALevel(0.05);\r\n    fsParams.setMaxFeatures(1000);\r\n    fsParams.setRareFeatureThreshold(3);\r\n    trainAndValidate(mlParams, fsParams, null, 0.9411031042128604, 3);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.StratifiedSampling.weightedProbabilitySampling",
	"Comment": "samples nh ids from each strata based on their frequency table",
	"Method": "TransposeDataCollection weightedProbabilitySampling(AssociativeArray2D strataFrequencyTable,AssociativeArray nh,boolean withReplacement){\r\n    TransposeDataCollection sampledIds = new TransposeDataCollection();\r\n    for (Map.Entry<Object, AssociativeArray> entry : strataFrequencyTable.entrySet()) {\r\n        Object strata = entry.getKey();\r\n        Number sampleN = ((Number) nh.get(strata));\r\n        if (sampleN == null) {\r\n            continue;\r\n        }\r\n        sampledIds.put(strata, SimpleRandomSampling.weightedSampling(entry.getValue(), sampleN.intValue(), withReplacement));\r\n    }\r\n    return sampledIds;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.reactive.ReactiveTask.requestAllAsync",
	"Comment": "request all elements to be processed asynchronously in the processing stream",
	"Method": "ReactiveTask requestAllAsync(){\r\n    return requestAsync(Long.MAX_VALUE);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachWithError",
	"Comment": "perform a foreach operation over the streamcapturing any elements and errors in the supplied consumers,",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachWithError(FutureStream<T> stream,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    final CompletableFuture<Subscription> subscription = new CompletableFuture();\r\n    final CompletableFuture<Boolean> streamCompleted = new CompletableFuture();\r\n    return tuple(subscription, () -> {\r\n        stream.subscribe(new Subscriber<T>() {\r\n            @Override\r\n            public void onSubscribe(final Subscription s) {\r\n                Objects.requireNonNull(s);\r\n                subscription.complete(s);\r\n                s.request(Long.MAX_VALUE);\r\n            }\r\n            @Override\r\n            public void onNext(final T t) {\r\n                consumerElement.accept(t);\r\n            }\r\n            @Override\r\n            public void onError(final Throwable t) {\r\n                consumerError.accept(t);\r\n            }\r\n            @Override\r\n            public void onComplete() {\r\n                streamCompleted.complete(true);\r\n            }\r\n        });\r\n    }, streamCompleted);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachWithError",
	"Comment": "perform a foreach operation over the streamcapturing any elements and errors in the supplied consumers,",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachWithError(FutureStream<T> stream,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    Objects.requireNonNull(s);\r\n    subscription.complete(s);\r\n    s.request(Long.MAX_VALUE);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachWithError",
	"Comment": "perform a foreach operation over the streamcapturing any elements and errors in the supplied consumers,",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachWithError(FutureStream<T> stream,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    consumerElement.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachWithError",
	"Comment": "perform a foreach operation over the streamcapturing any elements and errors in the supplied consumers,",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachWithError(FutureStream<T> stream,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    consumerError.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachWithError",
	"Comment": "perform a foreach operation over the streamcapturing any elements and errors in the supplied consumers,",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachWithError(FutureStream<T> stream,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    streamCompleted.complete(true);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributions.hypergeometric",
	"Comment": "returns the probability of finding k successes on a sample of n, from a population with kp successes and size np",
	"Method": "double hypergeometric(int k,int n,int Kp,int Np){\r\n    if (k < 0 || n < 0 || Kp < 0 || Np < 0) {\r\n        throw new IllegalArgumentException(\"All the parameters must be positive.\");\r\n    }\r\n    Kp = Math.max(k, Kp);\r\n    Np = Math.max(n, Np);\r\n    double probability = approxHypergeometricCdf(k, n, Kp, Np);\r\n    if (k > 0) {\r\n        probability -= approxHypergeometricCdf(k - 1, n, Kp, Np);\r\n    }\r\n    return probability;\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.FlatDataList.remove",
	"Comment": "removes an element at the specified position in the internal list and returns it.",
	"Method": "Object remove(int index){\r\n    return internalData.remove(index);\r\n}"
}, {
	"Path": "org.jak_linux.dns66.vpn.DnsPacketProxy.initialize",
	"Comment": "initializes the rules database and the list of upstream servers.",
	"Method": "void initialize(Context context,ArrayList<InetAddress> upstreamDnsServers){\r\n    ruleDatabase.initialize(context);\r\n    this.upstreamDnsServers = upstreamDnsServers;\r\n}"
}, {
	"Path": "io.github.classgraph.FieldInfo.getTypeDescriptor",
	"Comment": "returns the parsed type descriptor for the field, if available.",
	"Method": "TypeSignature getTypeDescriptor(){\r\n    if (typeDescriptorStr == null) {\r\n        return null;\r\n    }\r\n    if (typeDescriptor == null) {\r\n        try {\r\n            typeDescriptor = TypeSignature.parse(typeDescriptorStr, declaringClassName);\r\n            typeDescriptor.setScanResult(scanResult);\r\n        } catch (final ParseException e) {\r\n            throw new IllegalArgumentException(e);\r\n        }\r\n    }\r\n    return typeDescriptor;\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.ElementState.hasPriorityOver",
	"Comment": "indicates whether the first specified event has priority over the second element.it only seem to be the case when the algorithm has the choice between an attribute and anotherelement.",
	"Method": "boolean hasPriorityOver(DiffXEvent e1,DiffXEvent e2){\r\n    if (e1 instanceof AttributeEvent && !(e2 instanceof AttributeEvent) && !isEmpty())\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "com.spotify.docker.client.DockerHost.dockerCertPath",
	"Comment": "get the path to certificate and key for connecting to docker via https.",
	"Method": "String dockerCertPath(){\r\n    return certPath;\r\n}"
}, {
	"Path": "io.github.classgraph.ScanResult.getInterfaces",
	"Comment": "get all interfaces implemented by the named class or by one of its superclasses, if this is a standard class,or the superinterfaces extended by this interface, if this is an interface.",
	"Method": "ClassInfoList getInterfaces(String className){\r\n    if (closed.get()) {\r\n        throw new IllegalArgumentException(\"Cannot use a ScanResult after it has been closed\");\r\n    }\r\n    if (!scanSpec.enableClassInfo) {\r\n        throw new IllegalArgumentException(\"Please call ClassGraph#enableClassInfo() before #scan()\");\r\n    }\r\n    final ClassInfo classInfo = classNameToClassInfo.get(className);\r\n    return classInfo == null ? ClassInfoList.EMPTY_LIST : classInfo.getInterfaces();\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.common.abstracts.transformers.AbstractTransformer.fit_transform",
	"Comment": "fits, transforms and normalizes the data of the provided dataset.",
	"Method": "void fit_transform(Dataframe trainingData){\r\n    fit(trainingData);\r\n    transform(trainingData);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.DequeX.generate",
	"Comment": "generate a dequex from the provided supplier up to the provided limit number of times",
	"Method": "DequeX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).dequeX(LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.clustering.HierarchicalAgglomerativeTest.testPredict",
	"Comment": "test of predict method, of class hierarchicalagglomerative.",
	"Method": "void testPredict(){\r\n    logger.info(\"testPredict\");\r\n    Configuration configuration = getConfiguration();\r\n    Dataframe[] data = Datasets.heartDiseaseClusters(configuration);\r\n    Dataframe trainingData = data[0];\r\n    Dataframe validationData = data[1];\r\n    String storageName = this.getClass().getSimpleName();\r\n    MinMaxScaler.TrainingParameters nsParams = new MinMaxScaler.TrainingParameters();\r\n    MinMaxScaler numericalScaler = MLBuilder.create(nsParams, configuration);\r\n    numericalScaler.fit_transform(trainingData);\r\n    numericalScaler.save(storageName);\r\n    CornerConstraintsEncoder.TrainingParameters ceParams = new CornerConstraintsEncoder.TrainingParameters();\r\n    CornerConstraintsEncoder categoricalEncoder = MLBuilder.create(ceParams, configuration);\r\n    categoricalEncoder.fit_transform(trainingData);\r\n    categoricalEncoder.save(storageName);\r\n    HierarchicalAgglomerative.TrainingParameters param = new HierarchicalAgglomerative.TrainingParameters();\r\n    param.setDistanceMethod(HierarchicalAgglomerative.TrainingParameters.Distance.EUCLIDIAN);\r\n    param.setLinkageMethod(HierarchicalAgglomerative.TrainingParameters.Linkage.COMPLETE);\r\n    param.setMinClustersThreshold(2);\r\n    param.setMaxDistanceThreshold(Double.MAX_VALUE);\r\n    HierarchicalAgglomerative instance = MLBuilder.create(param, configuration);\r\n    instance.fit(trainingData);\r\n    instance.save(storageName);\r\n    trainingData.close();\r\n    instance.close();\r\n    numericalScaler.close();\r\n    categoricalEncoder.close();\r\n    numericalScaler = MLBuilder.load(MinMaxScaler.class, storageName, configuration);\r\n    categoricalEncoder = MLBuilder.load(CornerConstraintsEncoder.class, storageName, configuration);\r\n    instance = MLBuilder.load(HierarchicalAgglomerative.class, storageName, configuration);\r\n    numericalScaler.transform(validationData);\r\n    categoricalEncoder.transform(validationData);\r\n    instance.predict(validationData);\r\n    ClusteringMetrics vm = new ClusteringMetrics(validationData);\r\n    double expResult = 1.0;\r\n    double result = vm.getPurity();\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n    numericalScaler.delete();\r\n    categoricalEncoder.delete();\r\n    instance.delete();\r\n    validationData.close();\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.json.ClassFieldCache.getConcreteType",
	"Comment": "get the concrete type for a map or collection whose raw type is an interface or abstract class.",
	"Method": "Class<?> getConcreteType(Class<?> rawType,boolean returnNullIfNotMapOrCollection){\r\n    if (rawType == Map.class || rawType == AbstractMap.class) {\r\n        return HashMap.class;\r\n    } else if (rawType == ConcurrentMap.class) {\r\n        return ConcurrentHashMap.class;\r\n    } else if (rawType == SortedMap.class || rawType == NavigableMap.class) {\r\n        return TreeMap.class;\r\n    } else if (rawType == ConcurrentNavigableMap.class) {\r\n        return ConcurrentSkipListMap.class;\r\n    } else if (rawType == List.class || rawType == AbstractList.class) {\r\n        return ArrayList.class;\r\n    } else if (rawType == AbstractSequentialList.class) {\r\n        return LinkedList.class;\r\n    } else if (rawType == Set.class || rawType == AbstractSet.class) {\r\n        return HashSet.class;\r\n    } else if (rawType == SortedSet.class) {\r\n        return TreeSet.class;\r\n    } else if (rawType == Queue.class || rawType == AbstractQueue.class || rawType == Deque.class) {\r\n        return ArrayDeque.class;\r\n    } else if (rawType == BlockingQueue.class) {\r\n        return LinkedBlockingQueue.class;\r\n    } else if (rawType == BlockingDeque.class) {\r\n        return LinkedBlockingDeque.class;\r\n    } else if (rawType == TransferQueue.class) {\r\n        return LinkedTransferQueue.class;\r\n    } else {\r\n        return rawType;\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.SimpleRandomSampling.xbarStd",
	"Comment": "calculates standard deviation for xbar for finite population size",
	"Method": "double xbarStd(double std,int sampleN,double xbarStd,double std,int sampleN,int populationN){\r\n    return Math.sqrt(xbarVariance(std * std, sampleN, populationN));\r\n}"
}, {
	"Path": "com.topologi.diffx.load.DOMRecorder.handlePrefixMapping",
	"Comment": "handles the prefix mapping.if the current process is working on a fragment,",
	"Method": "void handlePrefixMapping(String uri,String prefix){\r\n    if (this.isFragment) {\r\n        if (this.mapping.getPrefix(uri) != null)\r\n            return;\r\n        if (prefix == null && !\"\".equals(uri)) {\r\n            this.mapping.add(uri, \"\");\r\n        } else if (prefix != null && !\"xmlns\".equals(prefix)) {\r\n            this.mapping.add(uri, prefix);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.github.classgraph.FieldInfo.getTypeSignatureOrTypeDescriptor",
	"Comment": "returns the type signature for the field, possibly including type parameters. if the type signature is null,indicating that no type signature information is available for this field, returns the type descriptorinstead.",
	"Method": "TypeSignature getTypeSignatureOrTypeDescriptor(){\r\n    final TypeSignature typeSig = getTypeSignature();\r\n    if (typeSig != null) {\r\n        return typeSig;\r\n    } else {\r\n        return getTypeDescriptor();\r\n    }\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.ListX.generate",
	"Comment": "generate a listx from the provided supplier up to the provided limit number of times",
	"Method": "ListX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).listX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.relatedsamples.StudentsRelatedSamples.checkCriticalValue",
	"Comment": "checks the critical value to determine if the hypothesis should be rejected",
	"Method": "boolean checkCriticalValue(double score,int n,boolean is_twoTailed,double aLevel){\r\n    double probability = ContinuousDistributions.studentsCdf(score, n - 1);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2;\r\n    }\r\n    if (probability <= a || probability >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.TransposeDataCollection2D.remove",
	"Comment": "removes a particular key from the internal map and returns the value associated with that key if present in the map.",
	"Method": "TransposeDataCollection remove(Object key){\r\n    return internalData.remove(key);\r\n}"
}, {
	"Path": "org.fourthline.cling.support.contentdirectory.AbstractContentDirectoryService.changeSystemUpdateID",
	"Comment": "call this method after making changes to your content directory.this will notify clients that their view of the content directory is potentiallyoutdated and has to be refreshed.",
	"Method": "void changeSystemUpdateID(){\r\n    Long oldUpdateID = getSystemUpdateID().getValue();\r\n    systemUpdateID.increment(true);\r\n    getPropertyChangeSupport().firePropertyChange(\"SystemUpdateID\", oldUpdateID, getSystemUpdateID().getValue());\r\n}"
}, {
	"Path": "buildcraft.core.lib.gui.GuiBuildCraft.isMouseOverSlot",
	"Comment": "returns if the passed mouse position is over the specified slot.",
	"Method": "boolean isMouseOverSlot(Slot slot,int mouseX,int mouseY){\r\n    int left = this.guiLeft;\r\n    int top = this.guiTop;\r\n    int realMouseX = mouseX - left;\r\n    int realMouseY = mouseY - top;\r\n    return realMouseX >= slot.xDisplayPosition - 1 && realMouseX < slot.xDisplayPosition + 16 + 1 && realMouseY >= slot.yDisplayPosition - 1 && realMouseY < slot.yDisplayPosition + 16 + 1;\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.utils.LogNode.appendLine",
	"Comment": "append a line to the log output, indenting this log entry according to tree structure.",
	"Method": "void appendLine(String timeStampStr,int indentLevel,String line,StringBuilder buf){\r\n    buf.append(timeStampStr);\r\n    buf.append('\\t');\r\n    buf.append(ClassGraph.class.getSimpleName());\r\n    buf.append('\\t');\r\n    final int numDashes = 2 * (indentLevel - 1);\r\n    for (int i = 0; i < numDashes; i++) {\r\n        buf.append('-');\r\n    }\r\n    if (numDashes > 0) {\r\n        buf.append(' ');\r\n    }\r\n    buf.append(line);\r\n    buf.append('\\n');\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.relatedsamples.Friedman.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level.",
	"Method": "boolean test(DataTable2D dataTable,double aLevel){\r\n    double pvalue = getPvalue(dataTable);\r\n    boolean rejectH0 = false;\r\n    if (pvalue <= aLevel) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.DataframeMatrix.getY",
	"Comment": "getter for the y vector with the values of the response variables.",
	"Method": "RealVector getY(){\r\n    return Y;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentQueueX.range",
	"Comment": "create a persistentqueuex that contains the integers between skip and take",
	"Method": "PersistentQueueX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).persistentQueueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributions.binomial",
	"Comment": "returns the probability of k of a specific number of tries n and probability p",
	"Method": "double binomial(int k,double p,int n){\r\n    if (k < 0 || p < 0 || n < 1) {\r\n        throw new IllegalArgumentException(\"All the parameters must be positive and n larger than 1.\");\r\n    }\r\n    k = Math.min(k, n);\r\n    double probability = approxBinomialCdf(k, p, n);\r\n    if (k > 0) {\r\n        probability -= approxBinomialCdf(k - 1, p, n);\r\n    }\r\n    return probability;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.DataframeMatrix.getX",
	"Comment": "getter for the x matrix which contains the data of the dataframe.",
	"Method": "RealMatrix getX(){\r\n    return X;\r\n}"
}, {
	"Path": "org.fourthline.cling.android.AndroidUpnpServiceImpl.onDestroy",
	"Comment": "stops the upnp service, when the last activity unbinds from this service.",
	"Method": "void onDestroy(){\r\n    upnpService.shutdown();\r\n    super.onDestroy();\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.decisiontheory.DecisionCriteria.maxMin",
	"Comment": "returns the best option and the payoff under maxmin strategy",
	"Method": "Map.Entry<Object, Object> maxMin(DataTable2D payoffMatrix){\r\n    if (payoffMatrix.isValid() == false) {\r\n        throw new IllegalArgumentException(\"The payoff matrix does not have a rectangular format.\");\r\n    }\r\n    AssociativeArray minPayoffs = new AssociativeArray();\r\n    for (Map.Entry<Object, AssociativeArray> entry : payoffMatrix.entrySet()) {\r\n        AssociativeArray optionList = entry.getValue();\r\n        for (Map.Entry<Object, Object> entry2 : optionList.entrySet()) {\r\n            Object option = entry2.getKey();\r\n            Double payoff = TypeInference.toDouble(entry2.getValue());\r\n            Double currentMinPayoffOption = minPayoffs.getDouble(option);\r\n            if (currentMinPayoffOption == null || payoff < currentMinPayoffOption) {\r\n                minPayoffs.put(option, payoff);\r\n            }\r\n        }\r\n    }\r\n    Map.Entry<Object, Object> entry = MapMethods.selectMaxKeyValue(minPayoffs);\r\n    return entry;\r\n}"
}, {
	"Path": "com.github.dockerjava.core.DockerClientImpl.authCmd",
	"Comment": "authenticate with the server, useful for checking authentication.",
	"Method": "AuthCmd authCmd(){\r\n    return new AuthCmdImpl(getDockerCmdExecFactory().createAuthCmdExec(), authConfig());\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.onesample.WaldWolfowitz.checkCriticalValue",
	"Comment": "checks the critical value to determine if the hypothesis should be rejected.",
	"Method": "boolean checkCriticalValue(double score,int n1,int n2,double aLevel){\r\n    boolean rejected = false;\r\n    int n = n1 + n2;\r\n    if (n1 <= 20 && n2 <= 20 && aLevel == 0.05) {\r\n        int key1 = Math.max(n1, n2);\r\n        int key2 = Math.min(n1, n2);\r\n        Object value = CRITICAL_VALUES.get2d(key1, key2);\r\n        if (value != null) {\r\n            String[] lowuplimit = String.valueOf(value).split(\",\");\r\n            int low = Integer.parseInt(lowuplimit[0]);\r\n            int high = n;\r\n            if (lowuplimit.length == 2) {\r\n                high = Integer.parseInt(lowuplimit[1]);\r\n            }\r\n            if (score <= low || score >= high) {\r\n                rejected = true;\r\n            }\r\n            return rejected;\r\n        }\r\n    }\r\n    double mean = 2.0 * n1 * n2 / ((double) n1 + n2) + 1.0;\r\n    double variance = 2.0 * n1 * n2 * (2.0 * n1 * n2 - n1 - n2) / (n * n * (n - 1.0));\r\n    double z = (score - mean) / Math.sqrt(variance);\r\n    double pvalue = ContinuousDistributions.gaussCdf(z);\r\n    double a = aLevel / 2;\r\n    if (pvalue <= a || pvalue >= (1 - a)) {\r\n        rejected = true;\r\n    }\r\n    return rejected;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.BagX.generate",
	"Comment": "generate a bagx from the provided supplier up to the provided limit number of times",
	"Method": "BagX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).bagX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.DiffXFitsy.printLost",
	"Comment": "print information when the algorithm gets lost in the matrix,ie when it does not know which direction to follow.",
	"Method": "void printLost(int i,int j){\r\n    DiffXEvent e1 = this.sequence1.getEvent(i);\r\n    DiffXEvent e2 = this.sequence2.getEvent(j);\r\n    System.err.println(\"(!) Ambiguous choice in (\" + i + \",\" + j + \")\");\r\n    System.err.println(\" ? +\" + ShortStringFormatter.toShortString(e1));\r\n    System.err.println(\" ? -\" + ShortStringFormatter.toShortString(e2));\r\n    System.err.println(\" current=\" + ShortStringFormatter.toShortString(this.estate.current()));\r\n    System.err.println(\" value in X+1=\" + this.matrix.get(i + 1, j));\r\n    System.err.println(\" value in Y+1=\" + this.matrix.get(i, j + 1));\r\n    System.err.println(\" equals=\" + e1.equals(e2));\r\n    System.err.println(\" greaterX=\" + this.matrix.isGreaterX(i, j));\r\n    System.err.println(\" greaterY=\" + this.matrix.isGreaterY(i, j));\r\n    System.err.println(\" sameXY=\" + this.matrix.isSameXY(i, j));\r\n    System.err.println(\" okFormat1=\" + this.estate.okFormat(e1));\r\n    System.err.println(\" okFormat2=\" + this.estate.okFormat(e2));\r\n    System.err.println(\" okInsert=\" + this.estate.okInsert(e1));\r\n    System.err.println(\" okDelete=\" + this.estate.okDelete(e2));\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.BaseSimpleReact.fromStream",
	"Comment": "start a reactive dataflow from a stream of completablefutures.",
	"Method": "BaseSimpleReactStream<U> fromStream(Stream<CompletableFuture<U>> stream){\r\n    final Stream s = stream;\r\n    return construct(s);\r\n}"
}, {
	"Path": "cyclops.stream.pushable.MultipleStreamSource.futureStream",
	"Comment": "create a pushable lazyfuturestream using the supplied reactpool",
	"Method": "FutureStream<T> futureStream(LazyReact s){\r\n    return s.fromStream(topic.stream());\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.common.dataobjects.KnowledgeBase.clear",
	"Comment": "clears the knowledgebase object by deleting all its data, while keepingopen the connection to the storage engine.",
	"Method": "void clear(){\r\n    storageEngine.clear();\r\n    modelParameters = ModelParameters.newInstance(trainingParameters.getMPClass(), storageEngine);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.extractors.UniqueWordSequenceExtractorTest.testExtract",
	"Comment": "test of extract method, of class uniquewordsequenceextractor.",
	"Method": "void testExtract(){\r\n    logger.info(\"extract\");\r\n    String text = \"this is a text sequence that is amazing text sequence\";\r\n    UniqueWordSequenceExtractor instance = new UniqueWordSequenceExtractor(new UniqueWordSequenceExtractor.Parameters());\r\n    Map<Integer, String> expResult = new LinkedHashMap();\r\n    expResult.put(0, \"this\");\r\n    expResult.put(1, \"is\");\r\n    expResult.put(2, \"a\");\r\n    expResult.put(3, \"text\");\r\n    expResult.put(4, \"sequence\");\r\n    expResult.put(5, \"that\");\r\n    expResult.put(6, \"amazing\");\r\n    Map<Integer, String> result = instance.extract(text);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "org.fourthline.cling.registry.RegistryItems.get",
	"Comment": "returns root and embedded devices registered under the given udn.",
	"Method": "D get(UDN udn,boolean rootOnly,Collection<D> get,DeviceType deviceType,Collection<D> get,ServiceType serviceType,Collection<D> get){\r\n    Collection<D> devices = new HashSet();\r\n    for (RegistryItem<UDN, D> item : deviceItems) {\r\n        devices.add(item.getItem());\r\n    }\r\n    return devices;\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.ScanSpec.classOrPackageIsSpecificallyWhitelisted",
	"Comment": "returns true if the class is specifically whitelisted, or is within a whitelisted package.",
	"Method": "boolean classOrPackageIsSpecificallyWhitelisted(String className){\r\n    return classWhiteBlackList.isSpecificallyWhitelisted(className) || packagePrefixWhiteBlackList.isSpecificallyWhitelisted(className);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AssociativeArray.remove",
	"Comment": "removes a particular key from the internal map and returns the value associated with that key if present in the map.",
	"Method": "Object remove(Object key){\r\n    return internalData.remove(key);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributions.gammaCdf",
	"Comment": "calculates the probability from 0 to x under gamma distribution",
	"Method": "double gammaCdf(double x,double a,double gammaCdf,double x,double a,double b){\r\n    if (a <= 0 || b <= 0) {\r\n        throw new IllegalArgumentException(\"All the parameters must be positive.\");\r\n    }\r\n    double GammaCdf = ContinuousDistributions.gammaCdf(x / b, a);\r\n    return GammaCdf;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.VectorX.range",
	"Comment": "create a vectorx that contains the integers between skip and take",
	"Method": "VectorX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).vectorX(LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.FlatDataCollection.add",
	"Comment": "it adds an object in the collection. it returns a boolean which indicates whether the collection changed as a result of the call.",
	"Method": "boolean add(Object e){\r\n    return internalData.add(e);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.onesample.Binomial.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level",
	"Method": "boolean test(int k,int n,double p,boolean is_twoTailed,double aLevel){\r\n    if (k < 0 || n <= 0 || p < 0) {\r\n        throw new IllegalArgumentException(\"All the parameters must be positive.\");\r\n    }\r\n    double pvalue = scoreToPvalue((double) k, n, p);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2.0;\r\n    }\r\n    if (pvalue <= a || pvalue >= (1.0 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.ScanSpec.isModuleLayer",
	"Comment": "return true if the argument is a modulelayer or a subclass of modulelayer.",
	"Method": "boolean isModuleLayer(Object moduleLayer){\r\n    if (moduleLayer == null) {\r\n        throw new IllegalArgumentException(\"ModuleLayer references must not be null\");\r\n    }\r\n    for (Class<?> currClass = moduleLayer.getClass(); currClass != null; currClass = currClass.getSuperclass()) {\r\n        if (currClass.getName().equals(\"java.lang.ModuleLayer\")) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "cyclops.reactive.ReactiveSeq.rangeLong",
	"Comment": "create an efficiently reversable sequence that produces the integersbetween skip and take",
	"Method": "ReactiveSeq<Long> rangeLong(long start,long step,long end,ReactiveSeq<Long> rangeLong,long start,long end){\r\n    if (start > end)\r\n        return rangeLong(end, start);\r\n    final ReversingRangeLongSpliterator range = new ReversingRangeLongSpliterator(start, end, 1, false);\r\n    return Streams.reactiveSeq(range, Optional.ofNullable(range));\r\n}"
}, {
	"Path": "com.datumbox.framework.storage.mapdb.MapDBConfiguration.setHybridized",
	"Comment": "setter for the hybridized option. if turned on, it will take into account the storage hints provided during map initialization and it will move more objects out of mapdb and into main memory. this will lead tosignificantly improved speed but also higher memory utilization.",
	"Method": "void setHybridized(boolean hybridized){\r\n    this.hybridized = hybridized;\r\n}"
}, {
	"Path": "org.fourthline.cling.support.contentdirectory.DIDLParser.generate",
	"Comment": "generates an xml representation of the content model.optionally, items inside a container will be represented in the xml,the container elements then have nested item elements. although thisparser can read such a structure, it is unclear whether other didlparsers should and actually do support this xml.",
	"Method": "String generate(DIDLContent content,String generate,DIDLContent content,boolean nestedItems){\r\n    return documentToString(buildDOM(content, nestedItems), true);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.FlatDataCollection.remove",
	"Comment": "removes a particular object from the internal data. it returns a booleanwhich indicates whether the object was found the collection.",
	"Method": "boolean remove(Object o){\r\n    return internalData.remove(o);\r\n}"
}, {
	"Path": "io.github.classgraph.ClasspathElementZip.scanPaths",
	"Comment": "scan for path matches within jarfile, and record zipentry objects of matching files.",
	"Method": "void scanPaths(LogNode log){\r\n    if (logicalZipFile == null) {\r\n        skipClasspathElement = true;\r\n    }\r\n    if (skipClasspathElement) {\r\n        return;\r\n    }\r\n    if (scanned.getAndSet(true)) {\r\n        throw new IllegalArgumentException(\"Already scanned classpath element \" + getZipFilePath());\r\n    }\r\n    final LogNode subLog = log == null ? null : log.log(getZipFilePath(), \"Scanning jarfile classpath element \" + getZipFilePath());\r\n    Set<String> loggedNestedClasspathRootPrefixes = null;\r\n    String prevParentRelativePath = null;\r\n    ScanSpecPathMatch prevParentMatchStatus = null;\r\n    for (final FastZipEntry zipEntry : logicalZipFile.getEntries()) {\r\n        String relativePath = zipEntry.entryNameUnversioned;\r\n        if (nestedClasspathRootPrefixes != null) {\r\n            boolean reachedNestedRoot = false;\r\n            for (final String nestedClasspathRoot : nestedClasspathRootPrefixes) {\r\n                if (relativePath.startsWith(nestedClasspathRoot)) {\r\n                    if (subLog != null) {\r\n                        if (loggedNestedClasspathRootPrefixes == null) {\r\n                            loggedNestedClasspathRootPrefixes = new HashSet();\r\n                        }\r\n                        if (loggedNestedClasspathRootPrefixes.add(nestedClasspathRoot)) {\r\n                            subLog.log(\"Reached nested classpath root, stopping recursion to avoid duplicate \" + \"scanning: \" + nestedClasspathRoot);\r\n                        }\r\n                    }\r\n                    reachedNestedRoot = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (reachedNestedRoot) {\r\n                continue;\r\n            }\r\n        }\r\n        if (!(packageRootPrefix.length() == 0 || relativePath.startsWith(packageRootPrefix))) {\r\n            continue;\r\n        }\r\n        if (packageRootPrefix.length() > 0) {\r\n            relativePath = relativePath.substring(packageRootPrefix.length());\r\n        } else {\r\n            if (relativePath.startsWith(\"BOOT-INF/classes/\")) {\r\n                relativePath = relativePath.substring(\"BOOT-INF/classes/\".length());\r\n            } else if (relativePath.startsWith(\"WEB-INF/classes/\")) {\r\n                relativePath = relativePath.substring(\"WEB-INF/classes/\".length());\r\n            }\r\n        }\r\n        if (!scanSpec.classpathElementResourcePathWhiteBlackList.whitelistAndBlacklistAreEmpty()) {\r\n            if (scanSpec.classpathElementResourcePathWhiteBlackList.isBlacklisted(relativePath)) {\r\n                if (subLog != null) {\r\n                    subLog.log(\"Reached blacklisted classpath element resource path, stopping scanning: \" + relativePath);\r\n                }\r\n                skipClasspathElement = true;\r\n                return;\r\n            }\r\n            if (scanSpec.classpathElementResourcePathWhiteBlackList.isSpecificallyWhitelisted(relativePath)) {\r\n                if (subLog != null) {\r\n                    subLog.log(\"Reached specifically whitelisted classpath element resource path: \" + relativePath);\r\n                }\r\n                containsSpecificallyWhitelistedClasspathElementResourcePath = true;\r\n            }\r\n        }\r\n        final int lastSlashIdx = relativePath.lastIndexOf(\"/\");\r\n        final String parentRelativePath = lastSlashIdx < 0 ? \"/\" : relativePath.substring(0, lastSlashIdx + 1);\r\n        final boolean parentRelativePathChanged = !parentRelativePath.equals(prevParentRelativePath);\r\n        final ScanSpecPathMatch parentMatchStatus = parentRelativePathChanged ? scanSpec.dirWhitelistMatchStatus(parentRelativePath) : prevParentMatchStatus;\r\n        prevParentRelativePath = parentRelativePath;\r\n        prevParentMatchStatus = parentMatchStatus;\r\n        if (parentMatchStatus == ScanSpecPathMatch.HAS_BLACKLISTED_PATH_PREFIX) {\r\n            if (subLog != null) {\r\n                subLog.log(\"Skipping blacklisted path: \" + relativePath);\r\n            }\r\n            continue;\r\n        }\r\n        final Resource resource = newResource(zipEntry, packageRootPrefix, relativePath);\r\n        relativePathToResource.put(relativePath, resource);\r\n        if (parentMatchStatus == ScanSpecPathMatch.HAS_WHITELISTED_PATH_PREFIX || parentMatchStatus == ScanSpecPathMatch.AT_WHITELISTED_PATH || (parentMatchStatus == ScanSpecPathMatch.AT_WHITELISTED_CLASS_PACKAGE && scanSpec.classfileIsSpecificallyWhitelisted(relativePath))) {\r\n            addWhitelistedResource(resource, parentMatchStatus, subLog);\r\n        }\r\n    }\r\n    fileToLastModified.put(getZipFile(), getZipFile().lastModified());\r\n    if (subLog != null) {\r\n        subLog.addElapsedTime();\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.Record.equals",
	"Comment": "checks if the provided object is equal to the current instance. it checksonly x and y.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == null) {\r\n        return false;\r\n    } else if (getClass() != obj.getClass()) {\r\n        return false;\r\n    }\r\n    final Record other = (Record) obj;\r\n    if (!Objects.equals(this.y, other.y)) {\r\n        return false;\r\n    } else if (!Objects.equals(this.x, other.x)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.oath.cyclops.util.stream.scheduling.cron.CronExpression.isValidExpression",
	"Comment": "indicates whether the specified cron expression can be parsed into avalid cron expression",
	"Method": "boolean isValidExpression(String cronExpression){\r\n    try {\r\n        new CronExpression(cronExpression);\r\n    } catch (final ParseException pe) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.github.classgraph.ModuleReaderProxy.open",
	"Comment": "use the proxied modulereader to open the named resource as an inputstream.",
	"Method": "InputStream open(String path){\r\n    final Object optionalInputStream = ReflectionUtils.invokeMethod(moduleReader, \"open\", String.class, path, true);\r\n    if (optionalInputStream == null) {\r\n        throw new IllegalArgumentException(\"Could not call moduleReader.open(name)\");\r\n    }\r\n    final Object inputStream = ReflectionUtils.invokeMethod(optionalInputStream, \"get\", true);\r\n    if (inputStream == null) {\r\n        throw new IllegalArgumentException(\"Could not call moduleReader.open(name).get()\");\r\n    }\r\n    return (InputStream) inputStream;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.MapX.toDequeX",
	"Comment": "convert this mapx to a dequex via the provided transformation function",
	"Method": "DequeX<T> toDequeX(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn){\r\n    return DequeX.narrow(stream().map(fn).to(ReactiveConvertableSequence::converter).dequeX());\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.StratifiedSamplingTest.testWeightedProbabilitySampling",
	"Comment": "test of weightedprobabilitysampling method, of class stratifiedsampling.",
	"Method": "void testWeightedProbabilitySampling(){\r\n    logger.info(\"weightedProbabilitySampling\");\r\n    AssociativeArray2D strataFrequencyTable = new AssociativeArray2D();\r\n    strataFrequencyTable.put2d(\"strata1\", \"1\", 10);\r\n    strataFrequencyTable.put2d(\"strata1\", \"2\", 20);\r\n    strataFrequencyTable.put2d(\"strata1\", \"3\", 30);\r\n    strataFrequencyTable.put2d(\"strata1\", \"4\", 40);\r\n    strataFrequencyTable.put2d(\"strata2\", \"1\", 100);\r\n    strataFrequencyTable.put2d(\"strata2\", \"2\", 200);\r\n    strataFrequencyTable.put2d(\"strata2\", \"3\", 300);\r\n    strataFrequencyTable.put2d(\"strata2\", \"4\", 400);\r\n    strataFrequencyTable.put2d(\"strata2\", \"5\", 500);\r\n    strataFrequencyTable.put2d(\"strata2\", \"6\", 600);\r\n    strataFrequencyTable.put2d(\"strata2\", \"7\", 800);\r\n    AssociativeArray nh = generateNh();\r\n    boolean withReplacement = true;\r\n    double expResult = Descriptives.sum(nh.toFlatDataCollection());\r\n    TransposeDataCollection sampledIds = StratifiedSampling.weightedProbabilitySampling(strataFrequencyTable, nh, withReplacement);\r\n    double result = 0;\r\n    for (Object stata : sampledIds.keySet()) {\r\n        result += sampledIds.get(stata).size();\r\n    }\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "io.github.classgraph.ClassInfo.addRelatedClass",
	"Comment": "add a class with a given relationship type. return whether the collection changed as a result of the call.",
	"Method": "boolean addRelatedClass(RelType relType,ClassInfo classInfo){\r\n    Set<ClassInfo> classInfoSet = relatedClasses.get(relType);\r\n    if (classInfoSet == null) {\r\n        relatedClasses.put(relType, classInfoSet = new LinkedHashSet(4));\r\n    }\r\n    return classInfoSet.add(classInfo);\r\n}"
}, {
	"Path": "cyclops.function.Consumer5.apply",
	"Comment": "partially applyhkt the first, second, third and fourth input parameters to this c5",
	"Method": "Function<T2, Function<T3, Function<T4, Consumer<T5>>>> apply(T1 s,Function<T3, Function<T4, Consumer<T5>>> apply,T1 s,T2 s2,Function<T4, Consumer<T5>> apply,T1 s,T2 s2,T3 s3,Consumer<T5> apply,T1 s,T2 s2,T3 s3,T4 s4){\r\n    return CurryConsumer.curryC5(this).apply(s).apply(s2).apply(s3).apply(s4);\r\n}"
}, {
	"Path": "org.fourthline.cling.protocol.ReceivingAsync.waitBeforeExecution",
	"Comment": "provides an opportunity to pause before executing the protocol.",
	"Method": "boolean waitBeforeExecution(){\r\n    return true;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.VectorX.generate",
	"Comment": "generate a vectorx from the provided supplier up to the provided limit number of times",
	"Method": "VectorX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).vectorX(LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.independentsamples.StudentsIndependentSamplesTest.testTestMeansUnknownEqualVars",
	"Comment": "test of testmeansunknownequalvars method, of class studentsindependentsamples.",
	"Method": "void testTestMeansUnknownEqualVars(){\r\n    logger.info(\"testMeansUnknownEqualVars\");\r\n    double xbar = 14.14;\r\n    double ybar = 12.08;\r\n    int n = 15;\r\n    int m = 15;\r\n    double stdx = 1.020784;\r\n    double stdy = 0.951314;\r\n    boolean is_twoTailed = false;\r\n    double aLevel = 0.05;\r\n    boolean expResult = true;\r\n    boolean result = StudentsIndependentSamples.testMeansUnknownEqualVars(xbar, ybar, n, m, stdx, stdy, is_twoTailed, aLevel);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AssociativeArray.toFlatDataList",
	"Comment": "returns a flatdatalist with the values of the internal map. the methodmight require to copy the data.",
	"Method": "FlatDataList toFlatDataList(){\r\n    Collection<Object> values = internalData.values();\r\n    List<Object> list;\r\n    if (values instanceof List<?>) {\r\n        list = (List<Object>) values;\r\n    } else {\r\n        list = new ArrayList(values);\r\n    }\r\n    return new FlatDataList(list);\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.json.ClassFieldCache.getDefaultConstructorForConcreteTypeOf",
	"Comment": "get the concrete type of the given class, then return the default constructor for that type.",
	"Method": "Constructor<?> getDefaultConstructorForConcreteTypeOf(Class<?> cls){\r\n    final Constructor<?> constructor = defaultConstructorForConcreteType.get(cls);\r\n    if (constructor != null) {\r\n        return constructor;\r\n    }\r\n    final Class<?> concreteType = getConcreteType(cls, false);\r\n    for (Class<?> c = concreteType; c != null && (c != Object.class || cls == Object.class); c = c.getSuperclass()) {\r\n        try {\r\n            final Constructor<?> defaultConstructor = c.getDeclaredConstructor();\r\n            JSONUtils.isAccessibleOrMakeAccessible(defaultConstructor);\r\n            defaultConstructorForConcreteType.put(cls, defaultConstructor);\r\n            return defaultConstructor;\r\n        } catch (final Exception e) {\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"Class \" + cls.getName() + \" does not have an accessible default (no-arg) constructor\");\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.StratifiedSampling.optimumSampleSize",
	"Comment": "returns the optimum sample size per strata under neyman allocation",
	"Method": "AssociativeArray optimumSampleSize(int n,AssociativeArray populationNh,AssociativeArray populationStdh){\r\n    AssociativeArray nh = new AssociativeArray();\r\n    double sumNhSh = 0.0;\r\n    for (Map.Entry<Object, Object> entry : populationNh.entrySet()) {\r\n        Object strata = entry.getKey();\r\n        Integer populationInStrata = ((Number) entry.getValue()).intValue();\r\n        Double populationStd = populationStdh.getDouble(strata);\r\n        if (populationStd == null || populationInStrata <= 0.0) {\r\n            throw new IllegalArgumentException(\"Invalid strata population or strata std.\");\r\n        }\r\n        double NhSh = populationInStrata * populationStd;\r\n        sumNhSh += NhSh;\r\n        nh.put(strata, n * NhSh);\r\n    }\r\n    if (sumNhSh <= 0) {\r\n        throw new IllegalArgumentException(\"Invalid strata populations.\");\r\n    }\r\n    for (Map.Entry<Object, Object> entry : nh.entrySet()) {\r\n        Object strata = entry.getKey();\r\n        nh.put(strata, TypeInference.toDouble(entry.getValue()) / sumNhSh);\r\n    }\r\n    return nh;\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.ElementState.okInsert",
	"Comment": "indicates whether the specified event is a close element thatmatches the name and uri of the current open element.",
	"Method": "boolean okInsert(DiffXEvent e){\r\n    if (!(e instanceof CloseElementEvent))\r\n        return true;\r\n    if (isEmpty())\r\n        return false;\r\n    return ((CloseElementEvent) e).match(current()) && this.openChanges[this.size - 1] == '+';\r\n}"
}, {
	"Path": "io.github.classgraph.ScanResult.getClassesWithFieldAnnotation",
	"Comment": "get classes that have a field with an annotation of the named type.",
	"Method": "ClassInfoList getClassesWithFieldAnnotation(String fieldAnnotationName){\r\n    if (closed.get()) {\r\n        throw new IllegalArgumentException(\"Cannot use a ScanResult after it has been closed\");\r\n    }\r\n    if (!scanSpec.enableClassInfo || !scanSpec.enableFieldInfo || !scanSpec.enableAnnotationInfo) {\r\n        throw new IllegalArgumentException(\"Please call ClassGraph#enableClassInfo(), #enableFieldInfo(), \" + \"and #enableAnnotationInfo() before #scan()\");\r\n    }\r\n    final ClassInfo classInfo = classNameToClassInfo.get(fieldAnnotationName);\r\n    return classInfo == null ? ClassInfoList.EMPTY_LIST : classInfo.getClassesWithFieldAnnotation();\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.OrderedSetX.generate",
	"Comment": "generate a orderedsetx from the provided supplier up to the provided limit number of times",
	"Method": "OrderedSetX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).orderedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.parsers.HTMLParser.safeRemoveAllTags",
	"Comment": "a safe way to remove the tags from an html string. the method removes firstjavascript, css and other non text blocks and then removes all html tags.",
	"Method": "String safeRemoveAllTags(String html){\r\n    html = removeNonTextTags(html);\r\n    html = unsafeRemoveAllTags(html);\r\n    return html;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.ReadabilityStatisticsTest.testDale_chall_grade",
	"Comment": "test of dalechallgrade method, of class readabilitystatistics.",
	"Method": "void testDale_chall_grade(){\r\n    logger.info(\"dale_chall_grade\");\r\n    String strText = TEST_STRING;\r\n    double expResult = 16.0;\r\n    double result = ReadabilityStatistics.daleChallGrade(strText);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.reactive.QueueBasedSubscriber.subscriber",
	"Comment": "create a queuebasedsubscriber, backed by a queue that will be created with the provided queuefactory",
	"Method": "QueueBasedSubscriber<T> subscriber(Counter counter,int maxConcurrency,QueueBasedSubscriber<T> subscriber,Queue<T> q,Counter counter,int maxConcurrency,QueueBasedSubscriber<T> subscriber,QueueFactory<T> factory,Counter counter,int maxConcurrency){\r\n    return new QueueBasedSubscriber(factory, counter, maxConcurrency);\r\n}"
}, {
	"Path": "cyclops.kinds.OptionalKind.narrowK",
	"Comment": "convert the higherkindedtype definition for a optional into",
	"Method": "Optional<T> narrowK(Higher<optional, T> Optional){\r\n    return ((OptionalKind<T>) Optional).boxed;\r\n}"
}, {
	"Path": "com.topologi.diffx.event.impl.SpaceEvent.getInstance",
	"Comment": "returns the white space event corresponding to the given string.",
	"Method": "SpaceEvent getInstance(CharSequence space,SpaceEvent getInstance,char c){\r\n    if (c == ' ')\r\n        return SINGLE_WHITESPACE;\r\n    if (c == '\\n')\r\n        return NEW_LINE;\r\n    if (c == '\\t')\r\n        return TAB;\r\n    return new SpaceEvent(c + \"\");\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.convertToLazyStream",
	"Comment": "convert between an lazy and eager future stream,can be used to take advantages of each approach during a single stream",
	"Method": "FutureStream<U> convertToLazyStream(){\r\n    return new LazyReact(getTaskExecutor()).fromStreamFutures((Stream) getLastActive().stream());\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributions.geometric",
	"Comment": "returns the probability that the first success requires k trials with probability of success p",
	"Method": "double geometric(int k,double p){\r\n    if (k <= 0 || p < 0) {\r\n        throw new IllegalArgumentException(\"All the parameters must be positive.\");\r\n    }\r\n    double probability = Math.pow(1 - p, k - 1) * p;\r\n    return probability;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.ensemblelearning.FixedCombinationRulesTest.testMajorityVote",
	"Comment": "test of majorityvote method, of class fixedcombinationrules.",
	"Method": "void testMajorityVote(){\r\n    logger.info(\"majorityVote\");\r\n    DataTable2D classifierClassProbabilityMatrix = getClassifierClassProbabilityMatrix();\r\n    AssociativeArray expResult = new AssociativeArray();\r\n    expResult.put(\"class1\", 2.0);\r\n    expResult.put(\"class2\", 2.0);\r\n    expResult.put(\"class3\", 0.0);\r\n    AssociativeArray result = FixedCombinationRules.majorityVote(classifierClassProbabilityMatrix);\r\n    for (Object k : expResult.keySet()) {\r\n        assertEquals(TypeInference.toDouble(expResult.get(k)), TypeInference.toDouble(result.get(k)), Constants.DOUBLE_ACCURACY_HIGH);\r\n    }\r\n}"
}, {
	"Path": "io.github.classgraph.ModuleInfo.getAnnotationInfo",
	"Comment": "get a the named annotation on this module, or null if the module does not have the named annotation.",
	"Method": "AnnotationInfo getAnnotationInfo(String annotationName,AnnotationInfoList getAnnotationInfo){\r\n    return annotationInfo == null ? AnnotationInfoList.EMPTY_LIST : annotationInfo;\r\n}"
}, {
	"Path": "org.fourthline.cling.support.connectionmanager.AbstractPeeringConnectionManagerService.createConnectionWithPeer",
	"Comment": "generate a new local connection identifier, prepare the peer, store connection details.",
	"Method": "int createConnectionWithPeer(ServiceReference localServiceReference,ControlPoint controlPoint,Service peerService,ProtocolInfo protInfo,ConnectionInfo.Direction direction){\r\n    final int localConnectionID = getNewConnectionId();\r\n    log.fine(\"Creating new connection ID \" + localConnectionID + \" with peer: \" + peerService);\r\n    final boolean[] failed = new boolean[1];\r\n    new PrepareForConnection(peerService, controlPoint, protInfo, localServiceReference, localConnectionID, direction) {\r\n        @Override\r\n        public void received(ActionInvocation invocation, int peerConnectionID, int rcsID, int avTransportID) {\r\n            ConnectionInfo info = new // If I prepared you for output, then I do input\r\n            ConnectionInfo(// If I prepared you for output, then I do input\r\n            localConnectionID, // If I prepared you for output, then I do input\r\n            rcsID, // If I prepared you for output, then I do input\r\n            avTransportID, // If I prepared you for output, then I do input\r\n            protInfo, // If I prepared you for output, then I do input\r\n            peerService.getReference(), peerConnectionID, direction.getOpposite(), ConnectionInfo.Status.OK);\r\n            storeConnection(info);\r\n        }\r\n        @Override\r\n        public void failure(ActionInvocation invocation, UpnpResponse operation, String defaultMsg) {\r\n            AbstractPeeringConnectionManagerService.this.peerFailure(invocation, operation, defaultMsg);\r\n            failed[0] = true;\r\n        }\r\n    }.run();\r\n    return failed[0] ? -1 : localConnectionID;\r\n}"
}, {
	"Path": "org.fourthline.cling.support.connectionmanager.AbstractPeeringConnectionManagerService.createConnectionWithPeer",
	"Comment": "generate a new local connection identifier, prepare the peer, store connection details.",
	"Method": "int createConnectionWithPeer(ServiceReference localServiceReference,ControlPoint controlPoint,Service peerService,ProtocolInfo protInfo,ConnectionInfo.Direction direction){\r\n    ConnectionInfo info = new // If I prepared you for output, then I do input\r\n    ConnectionInfo(// If I prepared you for output, then I do input\r\n    localConnectionID, // If I prepared you for output, then I do input\r\n    rcsID, // If I prepared you for output, then I do input\r\n    avTransportID, // If I prepared you for output, then I do input\r\n    protInfo, // If I prepared you for output, then I do input\r\n    peerService.getReference(), peerConnectionID, direction.getOpposite(), ConnectionInfo.Status.OK);\r\n    storeConnection(info);\r\n}"
}, {
	"Path": "org.fourthline.cling.support.connectionmanager.AbstractPeeringConnectionManagerService.createConnectionWithPeer",
	"Comment": "generate a new local connection identifier, prepare the peer, store connection details.",
	"Method": "int createConnectionWithPeer(ServiceReference localServiceReference,ControlPoint controlPoint,Service peerService,ProtocolInfo protInfo,ConnectionInfo.Direction direction){\r\n    AbstractPeeringConnectionManagerService.this.peerFailure(invocation, operation, defaultMsg);\r\n    failed[0] = true;\r\n}"
}, {
	"Path": "com.topologi.diffx.config.DiffXConfig.isIgnoreWhiteSpace",
	"Comment": "indicates whether the differences in white spaces should be ignored or not.",
	"Method": "boolean isIgnoreWhiteSpace(){\r\n    return this.whitespace != WhiteSpaceProcessing.COMPARE;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.BaseSimpleReactStream.freeThread",
	"Comment": "create a sequential synchronous stream that runs on the current thread",
	"Method": "SimpleReactStream<T> freeThread(T value,SimpleReactStream<T> freeThread,T values){\r\n    return new SimpleReact(ThreadPools.getSequential(), false).of(values);\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.ElementState.clear",
	"Comment": "removes all of the elements from this list.the list willbe empty after this call returns.",
	"Method": "void clear(){\r\n    for (int i = 0; i < this.size; i++) {\r\n        this.openElements[i] = null;\r\n    }\r\n    this.size = 0;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.LazySimpleReactStream.filterSync",
	"Comment": "synchronous filtering operationremoves elements that do not fold the supplied predicate from thedataflow",
	"Method": "LazySimpleReactStream<U> filterSync(Predicate<? super U> p){\r\n    final Function<PipelineBuilder, PipelineBuilder> fn = ft -> ft.thenApply((in) -> {\r\n        if (!p.test((U) in)) {\r\n            throw new FilteredExecutionPathException();\r\n        }\r\n        return in;\r\n    });\r\n    return this.withLastActive(getLastActive().operation(fn));\r\n}"
}, {
	"Path": "cyclops.control.Try.flatMapOrCatch",
	"Comment": "perform a flatmapping operation that may catch the supplied exception typesthe supplied exception types are only applied during this map operation",
	"Method": "Try<R, X> flatMapOrCatch(CheckedFunction<? super T, ? extends Try<? extends R, X>, X> fn,Class<? extends X> classes){\r\n    return new Try(xor.flatMap(i -> safeApplyM(i, fn.asFunction(), classes).toEither()), classes);\r\n}"
}, {
	"Path": "io.github.classgraph.ObjectTypedValueWrapper.getClassNamesFromTypeDescriptors",
	"Comment": "get the names of any classes referenced in the annotation parameters.",
	"Method": "void getClassNamesFromTypeDescriptors(Set<String> referencedClassNames){\r\n    if (enumValue != null) {\r\n        enumValue.getClassNamesFromTypeDescriptors(referencedClassNames);\r\n    } else if (classRef != null) {\r\n        referencedClassNames.add(classRef.getClassName());\r\n    } else if (annotationInfo != null) {\r\n        annotationInfo.getClassNamesFromTypeDescriptors(referencedClassNames);\r\n    } else if (objectArrayValue != null) {\r\n        for (final ObjectTypedValueWrapper item : objectArrayValue) {\r\n            item.getClassNamesFromTypeDescriptors(referencedClassNames);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AssociativeArray2D.put2d",
	"Comment": "convenience function used to put a value in a particular key positions.",
	"Method": "Object put2d(Object key1,Object key2,Object value){\r\n    AssociativeArray tmp = internalData.get(key1);\r\n    if (tmp == null) {\r\n        internalData.put(key1, new AssociativeArray());\r\n    }\r\n    return internalData.get(key1).internalData.put(key2, value);\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.utils.ReflectionUtils.invokeStaticMethod",
	"Comment": "invoke the named static method. if an exception is thrown while trying to call the method, and throwexceptionis true, then illegalargumentexception is thrown wrapping the cause, otherwise this will return null. ifpassed a null class reference, returns null unless throwexception is true, then throwsillegalargumentexception.",
	"Method": "Object invokeStaticMethod(Class<?> cls,String methodName,boolean throwException,Object invokeStaticMethod,Class<?> cls,String methodName,Class<?> argType,Object arg,boolean throwException){\r\n    if (cls != null) {\r\n        try {\r\n            final Method method = cls.getDeclaredMethod(methodName, argType);\r\n            try {\r\n                method.setAccessible(true);\r\n            } catch (final Exception e) {\r\n            }\r\n            return method.invoke(null, arg);\r\n        } catch (final Throwable e) {\r\n            if (throwException) {\r\n                throw new IllegalArgumentException(\"Could not invoke method \\\"\" + methodName + \"\\\"\", e);\r\n            }\r\n        }\r\n    } else if (throwException) {\r\n        throw new IllegalArgumentException(\"Can't invoke static method on null class reference\");\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.github.classgraph.ClassInfo.getOverrideOrder",
	"Comment": "recurse to interfaces and superclasses to get the order that fields and methods are overridden in.",
	"Method": "List<ClassInfo> getOverrideOrder(Set<ClassInfo> visited,List<ClassInfo> overrideOrderOut,List<ClassInfo> getOverrideOrder){\r\n    if (overrideOrder == null) {\r\n        overrideOrder = getOverrideOrder(new HashSet<ClassInfo>(), new ArrayList<ClassInfo>());\r\n    }\r\n    return overrideOrder;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.survival.nonparametrics.independentsamples.PetoPetoWilcoxon.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level.",
	"Method": "boolean test(TransposeDataCollection transposeDataCollection,boolean is_twoTailed,double aLevel){\r\n    double pvalue = getPvalue(transposeDataCollection);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2;\r\n    }\r\n    if (pvalue <= a || pvalue >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "buildcraft.core.lib.block.BlockBuildCraftBase.getBox",
	"Comment": "override this to easily allow the collision boxes and selected bounding boxes to be calculated",
	"Method": "AxisAlignedBB getBox(IBlockAccess world,BlockPos pos,IBlockState state){\r\n    return new AxisAlignedBB(0, 0, 0, 1, 1, 1);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributionsTest.testNormalQuantile",
	"Comment": "test of normalquantile method, of class continuousdistributions.",
	"Method": "void testNormalQuantile(){\r\n    logger.info(\"normalQuantile\");\r\n    double p = 0.32;\r\n    double mu = 1.0;\r\n    double sigma = 1.0;\r\n    double expResult = 0.53230120088549;\r\n    double result = ContinuousDistributions.normalQuantile(p, mu, sigma);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "cyclops.control.Eval.narrowK",
	"Comment": "convert the raw higher kinded type for evals types into the eval interface",
	"Method": "Eval<T> narrowK(Higher<eval, T> future){\r\n    return (Eval<T>) future;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributionsTest.testNegativeBinomialCdf",
	"Comment": "test of negativebinomialcdf method, of class discretedistributions.",
	"Method": "void testNegativeBinomialCdf(){\r\n    logger.info(\"NegativeBinomialCdf\");\r\n    int n = 10;\r\n    int r = 4;\r\n    double p = 0.5;\r\n    double expResult = 0.1279296875;\r\n    double result = DiscreteDistributions.negativeBinomialCdf(n, r, p);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.concurrency.ConcurrencyConfiguration.setMaxNumberOfThreadsPerTask",
	"Comment": "setter for the maximum number of threads which can be used for a specifictask by the framework. by convention if the value is 0, the max numberof threads is set equal to the available processors.",
	"Method": "void setMaxNumberOfThreadsPerTask(Integer maxNumberOfThreadsPerTask){\r\n    if (maxNumberOfThreadsPerTask < 0) {\r\n        throw new IllegalArgumentException(\"The max number of threads can not be negative.\");\r\n    } else if (maxNumberOfThreadsPerTask == 0) {\r\n        this.maxNumberOfThreadsPerTask = AVAILABLE_PROCESSORS;\r\n    } else {\r\n        this.maxNumberOfThreadsPerTask = Math.min(maxNumberOfThreadsPerTask, 4 * AVAILABLE_PROCESSORS);\r\n    }\r\n}"
}, {
	"Path": "cyclops.futurestream.SimpleReact.parallelBuilder",
	"Comment": "construct a new simplereact builder, with a new task executor and retry executorwith configured number of threads",
	"Method": "SimpleReact parallelBuilder(SimpleReact parallelBuilder,int parallelism){\r\n    return SimpleReact.builder().executor(new ForkJoinPool(parallelism)).async(true).build();\r\n}"
}, {
	"Path": "cyclops.control.Future.complete",
	"Comment": "if not already completed, sets the value of this future to the provided value",
	"Method": "boolean complete(T value){\r\n    return future.complete(value);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.utilities.PHPMethods.arrangeByIndex",
	"Comment": "rearranges the array based on the order of the provided indexes.",
	"Method": "void arrangeByIndex(T[] array,Integer[] indexes){\r\n    if (array.length != indexes.length) {\r\n        throw new IllegalArgumentException(\"The length of the two arrays must match.\");\r\n    }\r\n    for (int i = 0; i < array.length; i++) {\r\n        int index = indexes[i];\r\n        T tmp = array[i];\r\n        array[i] = array[index];\r\n        array[index] = tmp;\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.PHPSimilarTextTest.testSimilarityPercentage",
	"Comment": "test of similaritypercentage method, of class phpsimilartext.",
	"Method": "void testSimilarityPercentage(){\r\n    logger.info(\"similarityPercentage\");\r\n    String txt1 = \"this is a fine text\";\r\n    String txt2 = \"this is a great document\";\r\n    double expResult = 55.813953488372;\r\n    double result = PHPSimilarText.similarityPercentage(txt1, txt2);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.utils.InputStreamOrByteBufferAdapter.readUnsignedShort",
	"Comment": "read an unsigned short from the buffer at a specific absolute offset before the current read point.",
	"Method": "int readUnsignedShort(int readUnsignedShort,int offset){\r\n    final int bytesToRead = Math.max(0, offset + 1 - used);\r\n    if (bytesToRead > 0) {\r\n        throw new IllegalArgumentException(\"Can only read from absolute offsets before the current location in the file\");\r\n    }\r\n    return ((buf[offset] & 0xff) << 8) | (buf[offset + 1] & 0xff);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.DequeX.narrowK",
	"Comment": "convert the raw higher kinded type for deque types into the dequetype type definition class",
	"Method": "DequeX<T> narrowK(Higher<deque, T> list){\r\n    return (DequeX<T>) list;\r\n}"
}, {
	"Path": "com.topologi.diffx.load.AttributeComparator.compare",
	"Comment": "compares two simple attribute events using their name and namespace uri.",
	"Method": "int compare(AttributeEvent o1,AttributeEvent o2,int compare,AttributeEventImpl att1,AttributeEventImpl att2,int compare,AttributeEventNSImpl att1,AttributeEventNSImpl att2){\r\n    return toCName(att1).compareTo(toCName(att2));\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.common.abstracts.algorithms.AbstractDPMM.getFromClusterMap",
	"Comment": "always use this method to get the cluster from the clustermap because it ensures that the featureids are set.the featureids can be unset if we use a data structure which storesstuff in file. since the featureids field of cluster is transient, theinformation gets lost. this function ensures that it sets it back.",
	"Method": "CL getFromClusterMap(int clusterId,Map<Integer, CL> clusterMap){\r\n    CL c = clusterMap.get(clusterId);\r\n    if (c.getFeatureIds() == null) {\r\n        c.setFeatureIds(knowledgeBase.getModelParameters().getFeatureIds());\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.relatedsamples.McNemar.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level",
	"Method": "boolean test(int n11,int n12,int n21,int n22,boolean is_twoTailed,double aLevel){\r\n    double pvalue = getPvalue(n11, n12, n21, n22);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2;\r\n    }\r\n    if (pvalue <= a || pvalue >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "org.jak_linux.dns66.db.RuleDatabaseUpdateJobService.scheduleOrCancel",
	"Comment": "schedules or cancels the job, depending on the configuration",
	"Method": "boolean scheduleOrCancel(Context context,Configuration configuration){\r\n    JobScheduler scheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);\r\n    if (!configuration.hosts.automaticRefresh) {\r\n        Log.d(TAG, \"scheduleOrCancel: Cancelling Job\");\r\n        scheduler.cancel(JOB_ID);\r\n        return true;\r\n    }\r\n    Log.d(TAG, \"scheduleOrCancel: Scheduling Job\");\r\n    ComponentName serviceName = new ComponentName(context, RuleDatabaseUpdateJobService.class);\r\n    JobInfo jobInfo = new JobInfo.Builder(JOB_ID, serviceName).setRequiresCharging(true).setRequiresDeviceIdle(true).setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED).setPersisted(true).setPeriodic(TimeUnit.DAYS.toMillis(1)).build();\r\n    int result = scheduler.schedule(jobInfo);\r\n    if (result == JobScheduler.RESULT_SUCCESS)\r\n        Log.d(TAG, \"Job scheduled\");\r\n    else\r\n        Log.d(TAG, \"Job not scheduled\");\r\n    return result == JobScheduler.RESULT_SUCCESS;\r\n}"
}, {
	"Path": "io.github.classgraph.MethodInfo.getAnnotationInfo",
	"Comment": "get a the named annotation on this method, or null if the method does not have the named annotation.",
	"Method": "AnnotationInfoList getAnnotationInfo(AnnotationInfo getAnnotationInfo,String annotationName){\r\n    return getAnnotationInfo().get(annotationName);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.DataframeTest.testExtractColumnValuesByY",
	"Comment": "test of extractcolumnvaluesbyy method, of class dataframe.",
	"Method": "void testExtractColumnValuesByY(){\r\n    logger.info(\"extractColumnValuesByY\");\r\n    Configuration configuration = getConfiguration();\r\n    Dataframe dataset = new Dataframe(configuration);\r\n    AssociativeArray xData1 = new AssociativeArray();\r\n    xData1.put(\"height\", 188.0);\r\n    xData1.put(\"weight\", 88.0);\r\n    dataset.add(new Record(xData1, \"Class1\"));\r\n    AssociativeArray xData2 = new AssociativeArray();\r\n    xData2.put(\"height\", 189.0);\r\n    xData2.put(\"weight\", 89.0);\r\n    dataset.add(new Record(xData2, \"Class1\"));\r\n    AssociativeArray xData3 = new AssociativeArray();\r\n    xData3.put(\"height\", 190.0);\r\n    xData3.put(\"weight\", null);\r\n    dataset.add(new Record(xData3, \"Class2\"));\r\n    dataset.close();\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.SimpleRandomSamplingTest.testMinimumSampleSizeForMaximumXbarStd_3args",
	"Comment": "test of minimumsamplesizeformaximumxbarstd method, of class simplerandomsampling.",
	"Method": "void testMinimumSampleSizeForMaximumXbarStd_3args(){\r\n    logger.info(\"minimumSampleSizeForMaximumXbarStd\");\r\n    double maximumXbarStd = 1.2;\r\n    double populationStd = 7.25;\r\n    int populationN = 2147483647;\r\n    int expResult = 37;\r\n    int result = SimpleRandomSampling.minimumSampleSizeForMaximumXbarStd(maximumXbarStd, populationStd, populationN);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.independentsamples.FIndependentSamples.checkCriticalValue",
	"Comment": "checks the critical value to determine if the hypothesis should be rejected",
	"Method": "boolean checkCriticalValue(double score,int n,int m,boolean is_twoTailed,double aLevel){\r\n    double probability = ContinuousDistributions.fCdf(score, n - 1, m - 1);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2;\r\n    }\r\n    if (probability <= a || probability >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "cyclops.reactive.Spouts.async",
	"Comment": "create a push based stream with no backpressure fromm the provided stream.the provided stream will be executed on the provided executor and pushed to the returned stream",
	"Method": "ReactiveSeq<T> async(Consumer<? super PushSubscriber<T>> sub,ReactiveSeq<T> async,Stream<T> seq,Executor exec){\r\n    return async(s -> {\r\n        ReactiveSeq.fromStream(seq).foldFuture(exec, t -> {\r\n            PushSubscriber<T> local = s;\r\n            t.forEach(local::onNext, local::onError, local::onComplete);\r\n            return null;\r\n        });\r\n    });\r\n}"
}, {
	"Path": "cyclops.monads.transformers.EvalT.fromAnyM",
	"Comment": "construct an evalwt from an anym that contains a monad type that contains type other than evalthe values in the underlying monad will be mapped to eval",
	"Method": "EvalT<W, A> fromAnyM(AnyM<W, A> anyM){\r\n    return of(anyM.map(Eval::now));\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.stream.publisher.PublisherIterable.complete",
	"Comment": "calls onsubscribe on the target subscriber with the zero instance followed by a call to oncomplete.",
	"Method": "void complete(Subscriber<?> s){\r\n    s.onSubscribe(EmptySubscription.INSTANCE);\r\n    s.onComplete();\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.LinkedListX.range",
	"Comment": "create a linkedlistx that contains the integers between skip and take",
	"Method": "LinkedListX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).linkedListX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "cyclops.function.Function1.before",
	"Comment": "apply before advice to this function, capture the input with the provided consumer",
	"Method": "Function1<T, R> before(Consumer<? super T> action){\r\n    return FluentFunctions.of(this).before(action);\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.MatrixShort.release",
	"Comment": "gets rid of the underlying matrix so that garbage collector can do its work.",
	"Method": "void release(){\r\n    this.matrix = null;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.onesample.KolmogorovSmirnovOneSample.checkCriticalValue",
	"Comment": "checks the critical value to determine if the hypothesis should be rejected",
	"Method": "boolean checkCriticalValue(double score,boolean is_twoTailed,int n,double aLevel){\r\n    boolean rejected = false;\r\n    double criticalValue;\r\n    if (CRITICAL_VALUES.containsKey(aLevel)) {\r\n        if (CRITICAL_VALUES.get(aLevel).containsKey(n)) {\r\n            criticalValue = CRITICAL_VALUES.get(aLevel).getDouble(n);\r\n        } else {\r\n            criticalValue = CRITICAL_VALUES.get(aLevel).getDouble(0);\r\n            criticalValue /= Math.sqrt(n + Math.sqrt(n / 10.0));\r\n        }\r\n    } else {\r\n        criticalValue = calculateCriticalValue(is_twoTailed, n, aLevel);\r\n    }\r\n    if (score > criticalValue) {\r\n        rejected = true;\r\n    }\r\n    return rejected;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.mathematics.regularization.ElasticNetRegularizer.updateWeights",
	"Comment": "updates the weights by applying the elasticnet regularization.",
	"Method": "void updateWeights(double l1,double l2,double learningRate,Map<K, Double> weights,Map<K, Double> newWeights){\r\n    L2Regularizer.updateWeights(l2, learningRate, weights, newWeights);\r\n    L1Regularizer.updateWeights(l1, learningRate, weights, newWeights);\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.DiffXFitopsy.setupMatrix",
	"Comment": "determines the most appropriate matrix to use.calculates the maximum length of the shortest weighted path if both sequencesare totally different, which corresponds to the sum of all the events.",
	"Method": "Matrix setupMatrix(EventSequence s1,EventSequence s2){\r\n    int max = 0;\r\n    for (int i = 0; i < s1.size(); i++) {\r\n        max += s1.getEvent(i).getWeight();\r\n    }\r\n    for (int i = 0; i < s2.size(); i++) {\r\n        max += s2.getEvent(i).getWeight();\r\n    }\r\n    if (max > Short.MAX_VALUE)\r\n        return new MatrixInt();\r\n    else\r\n        return new MatrixShort();\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.ensemblelearning.FixedCombinationRules.median",
	"Comment": "combines the responses of the classifiers by using estimating the medianof the probabilities of their responses.",
	"Method": "AssociativeArray median(DataTable2D classifierClassProbabilityMatrix){\r\n    AssociativeArray combinedClassProbabilities = new AssociativeArray();\r\n    for (Map.Entry<Object, AssociativeArray> entry : classifierClassProbabilityMatrix.entrySet()) {\r\n        AssociativeArray listOfClassProbabilities = entry.getValue();\r\n        for (Map.Entry<Object, Object> entry2 : listOfClassProbabilities.entrySet()) {\r\n            Object theClass = entry2.getKey();\r\n            combinedClassProbabilities.put(theClass, 0.0);\r\n        }\r\n    }\r\n    for (Map.Entry<Object, Object> entry : combinedClassProbabilities.entrySet()) {\r\n        Object theClass = entry.getKey();\r\n        FlatDataCollection listOfProbabilities = new FlatDataCollection(new ArrayList());\r\n        for (Map.Entry<Object, AssociativeArray> entry2 : classifierClassProbabilityMatrix.entrySet()) {\r\n            AssociativeArray listOfClassProbabilities = entry2.getValue();\r\n            Double probability = listOfClassProbabilities.getDouble(theClass);\r\n            if (probability != null) {\r\n                listOfProbabilities.add(probability);\r\n            }\r\n        }\r\n        combinedClassProbabilities.put(theClass, Descriptives.median(listOfProbabilities));\r\n    }\r\n    return combinedClassProbabilities;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.ensemblelearning.FixedCombinationRules.average",
	"Comment": "combines the responses of the classifiers by using estimating the averageof the probabilities of their responses.",
	"Method": "AssociativeArray average(DataTable2D classifierClassProbabilityMatrix){\r\n    AssociativeArray combinedClassProbabilities = new AssociativeArray();\r\n    int numberOfClasses = classifierClassProbabilityMatrix.size();\r\n    for (Map.Entry<Object, AssociativeArray> entry : classifierClassProbabilityMatrix.entrySet()) {\r\n        AssociativeArray listOfClassProbabilities = entry.getValue();\r\n        for (Map.Entry<Object, Object> entry2 : listOfClassProbabilities.entrySet()) {\r\n            Object theClass = entry2.getKey();\r\n            Double probability = TypeInference.toDouble(entry2.getValue());\r\n            Double previousValue = combinedClassProbabilities.getDouble(theClass);\r\n            if (previousValue == null) {\r\n                previousValue = 0.0;\r\n            }\r\n            combinedClassProbabilities.put(theClass, previousValue + probability / numberOfClasses);\r\n        }\r\n    }\r\n    return combinedClassProbabilities;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.ensemblelearning.FixedCombinationRules.maximum",
	"Comment": "combines the responses of the classifiers by using selecting the maximumprobability of each class.",
	"Method": "AssociativeArray maximum(DataTable2D classifierClassProbabilityMatrix){\r\n    AssociativeArray combinedClassProbabilities = new AssociativeArray();\r\n    for (Map.Entry<Object, AssociativeArray> entry : classifierClassProbabilityMatrix.entrySet()) {\r\n        AssociativeArray listOfClassProbabilities = entry.getValue();\r\n        for (Map.Entry<Object, Object> entry2 : listOfClassProbabilities.entrySet()) {\r\n            Object theClass = entry2.getKey();\r\n            Double probability = TypeInference.toDouble(entry2.getValue());\r\n            Double previousValue = combinedClassProbabilities.getDouble(theClass);\r\n            if (previousValue == null || probability > previousValue) {\r\n                combinedClassProbabilities.put(theClass, probability);\r\n            }\r\n        }\r\n    }\r\n    return combinedClassProbabilities;\r\n}"
}, {
	"Path": "com.datumbox.framework.storage.mapdb.MapDBEngine.getStorageTypeFromName",
	"Comment": "returns the storagetype using the name of the map. it assumes that namesare unique across all storagetype. if not found null is returned.",
	"Method": "StorageType getStorageTypeFromName(String name){\r\n    for (Map.Entry<StorageType, DB> entry : storageRegistry.entrySet()) {\r\n        DB storage = entry.getValue();\r\n        if (isOpenStorage(storage) && storage.exists(name)) {\r\n            return entry.getKey();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.datumbox.framework.storage.mapdb.MapDBConfiguration.setAsynchronous",
	"Comment": "setter for the asynchronous option. if turned on, it will write thedata asynchronously leading to speed improvements.",
	"Method": "void setAsynchronous(boolean asynchronous){\r\n    this.asynchronous = asynchronous;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.SimpleRandomSampling.minimumSampleSizeForMaximumXbarStd",
	"Comment": "returns the minimum required sample size when we set a specific maximum xbar std error for finite population size.",
	"Method": "int minimumSampleSizeForMaximumXbarStd(double maximumXbarStd,double populationStd,int minimumSampleSizeForMaximumXbarStd,double maximumXbarStd,double populationStd,int populationN){\r\n    if (populationN <= 0) {\r\n        throw new IllegalArgumentException(\"The populationN parameter must be positive.\");\r\n    }\r\n    double minimumSampleN = 1.0 / (Math.pow(maximumXbarStd / populationStd, 2) + 1.0 / populationN);\r\n    return (int) Math.ceil(minimumSampleN);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.QueueX.narrowK",
	"Comment": "convert the raw higher kinded type for queue types into the queuetype type definition class",
	"Method": "QueueX<T> narrowK(Higher<queue, T> queue){\r\n    return (QueueX<T>) queue;\r\n}"
}, {
	"Path": "cyclops.futurestream.FutureStream.group",
	"Comment": "batch elements into a stream of collections with user defined function",
	"Method": "FutureStream<C> group(Function<Supplier<U>, Supplier<C>> fn){\r\n    final Queue queue = toQueue();\r\n    return fromStream(queue.streamBatchNoTimeout(getSubscription(), fn));\r\n}"
}, {
	"Path": "com.datumbox.framework.common.storage.abstracts.AbstractStorageEngine.postDeserializer",
	"Comment": "this method is called after the object deserialization. it initializes all bigmaps of the serializable object whichhave a null value. the main idea is that once an object is deserialized it will contain nulls in all the bigmap fieldswhich were not serialized. for all of those fields we call their initialization methods.",
	"Method": "void postDeserializer(T serializableObject){\r\n    Method method = null;\r\n    for (Field field : ReflectionMethods.getAllFields(new LinkedList(), serializableObject.getClass())) {\r\n        if (field.isAnnotationPresent(BigMap.class)) {\r\n            field.setAccessible(true);\r\n            try {\r\n                if (field.get(serializableObject) == null) {\r\n                    if (method == null) {\r\n                        method = ReflectionMethods.findMethod(serializableObject, \"initializeBigMapField\", this, field);\r\n                    }\r\n                    ReflectionMethods.invokeMethod(serializableObject, method, this, field);\r\n                }\r\n            } catch (IllegalAccessException ex) {\r\n                throw new RuntimeException(ex);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.peek",
	"Comment": "peek asynchronously at the results in the current stage. current resultsare passed through to the next stage.",
	"Method": "SimpleReactStream<U> peek(Consumer<? super U> consumer){\r\n    if (!isAsync())\r\n        return peekSync(consumer);\r\n    return then((t) -> {\r\n        consumer.accept(t);\r\n        return t;\r\n    });\r\n}"
}, {
	"Path": "buildcraft.transport.pipes.PipeItemsWood.getExtractionTargets",
	"Comment": "return the itemstack that can be if something can be extracted from this inventory, null if none. on certaincases, the extractable slot depends on the position of the pipe.",
	"Method": "int[] getExtractionTargets(IItemHandler handler,int maxItems){\r\n    int result = getExtractionTargetsGeneric(handler, maxItems);\r\n    if (result >= 0) {\r\n        return new int[] { result };\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.github.dockerjava.core.util.CertificateUtils.getPrivateKeyInfoOrNull",
	"Comment": "find a privatekeyinfo in the pem object details. returns null if the pem object type is unknown.",
	"Method": "PrivateKeyInfo getPrivateKeyInfoOrNull(Object pemObject){\r\n    PrivateKeyInfo privateKeyInfo = null;\r\n    if (pemObject instanceof PEMKeyPair) {\r\n        PEMKeyPair pemKeyPair = (PEMKeyPair) pemObject;\r\n        privateKeyInfo = pemKeyPair.getPrivateKeyInfo();\r\n    } else if (pemObject instanceof PrivateKeyInfo) {\r\n        privateKeyInfo = (PrivateKeyInfo) pemObject;\r\n    } else if (pemObject instanceof ASN1ObjectIdentifier) {\r\n        final ASN1ObjectIdentifier asn1ObjectIdentifier = (ASN1ObjectIdentifier) pemObject;\r\n        LOG.trace(\"Ignoring asn1ObjectIdentifier {}\", asn1ObjectIdentifier);\r\n    } else {\r\n        LOG.warn(\"Unknown object '{}' from PEMParser\", pemObject);\r\n    }\r\n    return privateKeyInfo;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.ListX.narrowK",
	"Comment": "convert the raw higher kinded type for listx types into the listx type definition class",
	"Method": "ListX<T> narrowK(Higher<list, T> list){\r\n    return (ListX<T>) list;\r\n}"
}, {
	"Path": "com.datumbox.framework.tests.abstracts.AbstractTest.setUp",
	"Comment": "this method is executed before every test. it resets the seed of thelocal random to the original seed.",
	"Method": "void setUp(){\r\n    RandomGenerator.getThreadLocalRandom().setSeed(Constants.RANDOM_SEED);\r\n}"
}, {
	"Path": "com.oath.cyclops.util.ExceptionSoftener.throwOrHandle",
	"Comment": "throw the exception as upwards if the predicate holds, otherwise pass to the handler",
	"Method": "void throwOrHandle(X e,Predicate<X> p,Consumer<X> handler){\r\n    if (p.test(e))\r\n        throw ExceptionSoftener.<RuntimeException>uncheck(e);\r\n    else\r\n        handler.accept(e);\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.utils.LogNode.log",
	"Comment": "add a series of log entries. returns the last lognode created.",
	"Method": "LogNode log(String sortKey,String msg,long elapsedTimeNanos,Throwable e,LogNode log,String sortKey,String msg,long elapsedTimeNanos,LogNode log,String sortKey,String msg,Throwable e,LogNode log,String sortKey,String msg,LogNode log,String msg,long elapsedTimeNanos,Throwable e,LogNode log,String msg,long elapsedTimeNanos,LogNode log,String msg,Throwable e,LogNode log,String msg,LogNode log,Collection<String> msgs,LogNode log,Throwable e){\r\n    return log(\"Exception thrown\").addChild(e);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.storage.abstracts.AbstractFileStorageEngine.cleanEmptyParentDirectory",
	"Comment": "removes recursively all empty parent directories up to and excluding the storage directory.",
	"Method": "void cleanEmptyParentDirectory(Path path){\r\n    Path normPath = path.normalize();\r\n    if (normPath.equals(Paths.get(getDirectory()).normalize()) || normPath.equals(Paths.get(System.getProperty(\"java.io.tmpdir\")).normalize())) {\r\n        return;\r\n    }\r\n    try {\r\n        Files.deleteIfExists(path);\r\n        cleanEmptyParentDirectory(path.getParent());\r\n    } catch (DirectoryNotEmptyException ex) {\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.independentsamples.KruskalWallis.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level",
	"Method": "boolean test(TransposeDataCollection transposeDataCollection,double aLevel){\r\n    double pvalue = getPvalue(transposeDataCollection);\r\n    boolean rejectH0 = false;\r\n    if (pvalue <= aLevel) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.Dataframe.remove",
	"Comment": "removes a record with a particular id from the dataframe but does not updatethe metadata.",
	"Method": "boolean remove(Object o,Record remove,Integer id){\r\n    return data.records.remove(id);\r\n}"
}, {
	"Path": "cyclops.control.LazyEither5.traverse",
	"Comment": "traverse a collection of either3 producing an either4 with a seq, applying the transformation function to everyelement in the list",
	"Method": "LazyEither5<L1, L2, L3, L4, ReactiveSeq<R>> traverse(Function<? super T, ? extends R> fn,ReactiveSeq<LazyEither5<L1, L2, L3, L4, T>> stream,LazyEither5<LT1, LT2, LT3, LT4, ReactiveSeq<R>> traverse,Iterable<LazyEither5<LT1, LT2, LT3, LT4, PT>> xors,Function<? super PT, ? extends R> fn){\r\n    return sequence(xors).map(l -> l.map(fn));\r\n}"
}, {
	"Path": "com.datumbox.framework.common.utilities.ReflectionMethods.findMethod",
	"Comment": "finds the public, protected, default or private method of the object with the provided name and parameters.",
	"Method": "Method findMethod(Object obj,String methodName,Object params){\r\n    Class<?>[] classArray = new Class<?>[params.length];\r\n    for (int i = 0; i < params.length; i++) {\r\n        classArray[i] = params[i].getClass();\r\n    }\r\n    try {\r\n        Class<?> klass = obj.getClass();\r\n        while (klass != null) {\r\n            for (Method method : klass.getDeclaredMethods()) {\r\n                if (method.getName().equals(methodName) && method.getParameterCount() == classArray.length) {\r\n                    Class<?>[] paramClasses = method.getParameterTypes();\r\n                    boolean parametersMatch = true;\r\n                    for (int i = 0; i < params.length; i++) {\r\n                        if (!paramClasses[i].isAssignableFrom(classArray[i])) {\r\n                            parametersMatch = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (parametersMatch) {\r\n                        return method;\r\n                    }\r\n                }\r\n            }\r\n            klass = klass.getSuperclass();\r\n        }\r\n        throw new NoSuchMethodException();\r\n    } catch (NoSuchMethodException ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n}"
}, {
	"Path": "io.github.classgraph.ScanResult.getAllClasses",
	"Comment": "get all classes, interfaces and annotations found during the scan.",
	"Method": "ClassInfoList getAllClasses(){\r\n    if (closed.get()) {\r\n        throw new IllegalArgumentException(\"Cannot use a ScanResult after it has been closed\");\r\n    }\r\n    if (!scanSpec.enableClassInfo) {\r\n        throw new IllegalArgumentException(\"Please call ClassGraph#enableClassInfo() before #scan()\");\r\n    }\r\n    return ClassInfo.getAllClasses(classNameToClassInfo.values(), scanSpec, this);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.common.interfaces.ModelParameters.newInstance",
	"Comment": "generates a new instance of the model parameters by using the provided class.",
	"Method": "MP newInstance(Class<MP> mpClass,StorageEngine storageEngine){\r\n    try {\r\n        Constructor<MP> c = mpClass.getDeclaredConstructor(StorageEngine.class);\r\n        c.setAccessible(true);\r\n        return c.newInstance(storageEngine);\r\n    } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.jak_linux.dns66.SingleWriterMultipleReaderFile.finishWrite",
	"Comment": "atomically replaces the active file with the work file, and closes the stream.",
	"Method": "void finishWrite(FileOutputStream stream){\r\n    try {\r\n        stream.close();\r\n    } catch (IOException e) {\r\n        failWrite(stream);\r\n        throw e;\r\n    }\r\n    if (!workFile.renameTo(activeFile)) {\r\n        failWrite(stream);\r\n        throw new IOException(\"Cannot commit transaction\");\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.relatedsamples.CochranQ.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level",
	"Method": "boolean test(DataTable2D dataTable,double aLevel){\r\n    double pvalue = getPvalue(dataTable);\r\n    boolean rejectH0 = false;\r\n    if (pvalue <= aLevel) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.EagerFutureStreamFunctions.combineLatest",
	"Comment": "zip two streams into one. uses the latest values from each rather than waiting for both",
	"Method": "ReactiveSeq<Tuple2<T1, T2>> combineLatest(SimpleReactStream<T1> left,SimpleReactStream<T2> right,ReactiveSeq<R> combineLatest,SimpleReactStream<T1> left,SimpleReactStream<T2> right,BiFunction<T1, T2, R> zipper){\r\n    final Queue q = left.then(it -> new Val(Val.Pos.left, it)).merge(right.then(it -> new Val(Val.Pos.right, it))).toQueue();\r\n    final Iterator<Val> it = q.stream(left.getSubscription()).iterator();\r\n    class Zip implements Iterator<R> {\r\n        T1 lastLeft = null;\r\n        T2 lastRight = null;\r\n        @Override\r\n        public boolean hasNext() {\r\n            return it.hasNext();\r\n        }\r\n        @Override\r\n        public R next() {\r\n            final Val v = it.next();\r\n            if (v.pos == Val.Pos.left)\r\n                lastLeft = (T1) v.val;\r\n            else\r\n                lastRight = (T2) v.val;\r\n            return zipper.apply(lastLeft, lastRight);\r\n        }\r\n    }\r\n    return ReactiveSeq.fromIterator(new Zip());\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.EagerFutureStreamFunctions.combineLatest",
	"Comment": "zip two streams into one. uses the latest values from each rather than waiting for both",
	"Method": "ReactiveSeq<Tuple2<T1, T2>> combineLatest(SimpleReactStream<T1> left,SimpleReactStream<T2> right,ReactiveSeq<R> combineLatest,SimpleReactStream<T1> left,SimpleReactStream<T2> right,BiFunction<T1, T2, R> zipper){\r\n    return it.hasNext();\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.EagerFutureStreamFunctions.combineLatest",
	"Comment": "zip two streams into one. uses the latest values from each rather than waiting for both",
	"Method": "ReactiveSeq<Tuple2<T1, T2>> combineLatest(SimpleReactStream<T1> left,SimpleReactStream<T2> right,ReactiveSeq<R> combineLatest,SimpleReactStream<T1> left,SimpleReactStream<T2> right,BiFunction<T1, T2, R> zipper){\r\n    final Val v = it.next();\r\n    if (v.pos == Val.Pos.left)\r\n        lastLeft = (T1) v.val;\r\n    else\r\n        lastRight = (T2) v.val;\r\n    return zipper.apply(lastLeft, lastRight);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.common.abstracts.featureselectors.AbstractScoreBasedFeatureSelector.keepTopFeatures",
	"Comment": "this method keeps the highest scoring features of the provided feature mapand removes all the others.",
	"Method": "void keepTopFeatures(Map<Object, Double> featureScores,int maxFeatures){\r\n    logger.debug(\"keepTopFeatures()\");\r\n    logger.debug(\"Estimating the minPermittedScore\");\r\n    Double minPermittedScore = SelectKth.largest(featureScores.values().iterator(), maxFeatures);\r\n    logger.debug(\"Removing features with scores less than threshold\");\r\n    Iterator<Map.Entry<Object, Double>> it = featureScores.entrySet().iterator();\r\n    while (it.hasNext()) {\r\n        Map.Entry<Object, Double> entry = it.next();\r\n        if (entry.getValue() < minPermittedScore) {\r\n            it.remove();\r\n        }\r\n    }\r\n    int numOfExtraFeatures = featureScores.size() - maxFeatures;\r\n    if (numOfExtraFeatures > 0) {\r\n        logger.debug(\"Removing extra features caused by ties\");\r\n        it = featureScores.entrySet().iterator();\r\n        while (it.hasNext() && numOfExtraFeatures > 0) {\r\n            Map.Entry<Object, Double> entry = it.next();\r\n            if (entry.getValue() - minPermittedScore <= 0.0) {\r\n                it.remove();\r\n                --numOfExtraFeatures;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.common.concurrency.ForkJoinStream.max",
	"Comment": "executes max on the provided stream using the provided collector. if the stream is parallel, it is executed using the custom pool, else it is executed directly from the main thread.",
	"Method": "Optional<T> max(Stream<T> stream,Comparator<? super T> comparator){\r\n    Callable<Optional<T>> callable = () -> stream.max(comparator);\r\n    return ThreadMethods.forkJoinExecution(callable, concurrencyConfiguration, stream.isParallel());\r\n}"
}, {
	"Path": "cyclops.companion.rx2.Maybes.combine",
	"Comment": "lazily combine this maybe with the supplied maybe via the supplied bifunction",
	"Method": "Maybe<R> combine(Maybe<? extends T1> maybe,Value<? extends T2> app,BiFunction<? super T1, ? super T2, ? extends R> fn,Maybe<R> combine,Maybe<? extends T1> maybe,Maybe<? extends T2> app,BiFunction<? super T1, ? super T2, ? extends R> fn){\r\n    return narrow(Single.fromPublisher(Future.fromPublisher(maybe.toFlowable()).zip(Future.fromPublisher(app.toFlowable()), fn)).toMaybe());\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.SimpleRandomSamplingTest.testRandomSampling",
	"Comment": "test of randomsampling method, of class simplerandomsampling.",
	"Method": "void testRandomSampling(){\r\n    logger.info(\"randomSampling\");\r\n    FlatDataList idList = new FlatDataList();\r\n    idList.add(\"a\");\r\n    idList.add(\"0\");\r\n    idList.add(\"c\");\r\n    idList.add(\"1\");\r\n    idList.add(\"5\");\r\n    int n = 100;\r\n    boolean withReplacement = true;\r\n    double expResult = n;\r\n    FlatDataCollection sampledIds = SimpleRandomSampling.randomSampling(idList, n, withReplacement);\r\n    double result = sampledIds.size();\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.concurrency.ForkJoinStream.map",
	"Comment": "executes map on the provided stream. if the stream is parallel, it isexecuted using the custom pool, else it is executed directly from themain thread.",
	"Method": "Stream<R> map(Stream<T> stream,Function<? super T, ? extends R> mapper){\r\n    Callable<Stream<R>> callable = () -> stream.map(mapper);\r\n    return ThreadMethods.forkJoinExecution(callable, concurrencyConfiguration, stream.isParallel());\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.SystematicSamplingTest.testXbarVariance",
	"Comment": "test of xbarvariance method, of class systematicsampling.",
	"Method": "void testXbarVariance(){\r\n    logger.info(\"xbarVariance\");\r\n    FlatDataCollection flatDataCollection = generateFlatDataCollection();\r\n    double expResult = 405.75;\r\n    double result = SystematicSampling.xbarVariance(flatDataCollection);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.SimpleRandomSamplingTest.testXbarVariance_3args",
	"Comment": "test of xbarvariance method, of class simplerandomsampling.",
	"Method": "void testXbarVariance_3args(){\r\n    logger.info(\"xbarVariance\");\r\n    double variance = 52.621426666667;\r\n    int sampleN = 15;\r\n    int populationN = 2147483647;\r\n    double expResult = 3.50809508661;\r\n    double result = SimpleRandomSampling.xbarVariance(variance, sampleN, populationN);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.MapX.toListX",
	"Comment": "convert this mapx to a listx via the provided transformation function",
	"Method": "ListX<T> toListX(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn){\r\n    return ListX.narrow(stream().map(fn).to(ReactiveConvertableSequence::converter).listX());\r\n}"
}, {
	"Path": "cyclops.control.Future.narrowK",
	"Comment": "convert the raw higher kinded type forfuturetype types into the futuretype type definition class",
	"Method": "Future<T> narrowK(Higher<future, T> future){\r\n    return (Future<T>) future;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.relatedsamples.StudentsRelatedSamplesTest.testTestMean",
	"Comment": "test of testmean method, of class studentsrelatedsamples.",
	"Method": "void testTestMean(){\r\n    logger.info(\"testMean\");\r\n    double dbar = 2.2;\r\n    int n = 10;\r\n    double dbarStd = 1.924;\r\n    boolean is_twoTailed = false;\r\n    double aLevel = 0.05;\r\n    boolean expResult = true;\r\n    boolean result = StudentsRelatedSamples.testMean(dbar, n, dbarStd, is_twoTailed, aLevel);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.Dataframe.clear",
	"Comment": "clears all the internal records of the dataframe. the dataframe can be usedafter you clear it.",
	"Method": "void clear(){\r\n    data.yDataType = null;\r\n    data.atomicNextAvailableRecordId.set(0);\r\n    data.xDataTypes.clear();\r\n    data.records.clear();\r\n}"
}, {
	"Path": "io.github.classgraph.ScanResultObject.setScanResult",
	"Comment": "set scanresult backreferences in info objects after scan has completed.",
	"Method": "void setScanResult(ScanResult scanResult){\r\n    this.scanResult = scanResult;\r\n}"
}, {
	"Path": "com.datumbox.framework.common.utilities.RandomGenerator.getGlobalSeed",
	"Comment": "getter for the global seed. the global seed affects the initial seeding ofall the random objects that are generated by this class.",
	"Method": "Long getGlobalSeed(){\r\n    return globalSeed;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.StringCleaner.unifyTerminators",
	"Comment": "replaces all terminators with space or dots. the final string will contain onlyalphanumerics and dots.",
	"Method": "String unifyTerminators(String text){\r\n    text = text.replaceAll(\"[\\\",:;()\\\\-]+\", \" \");\r\n    text = text.replaceAll(\"[\\\\.!?]\", \".\");\r\n    text = text.replaceAll(\"\\\\.[\\\\. ]+\", \".\");\r\n    text = text.replaceAll(\"\\\\s*\\\\.\\\\s*\", \". \");\r\n    return text.trim();\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.ensemblelearning.FixedCombinationRulesTest.testWeightedAverage",
	"Comment": "test of weightedaverage method, of class fixedcombinationrules.",
	"Method": "void testWeightedAverage(){\r\n    logger.info(\"weightedAverage\");\r\n    DataTable2D classifierClassProbabilityMatrix = getClassifierClassProbabilityMatrix();\r\n    AssociativeArray classifierWeights = new AssociativeArray();\r\n    classifierWeights.put(\"Classifier1\", 0.5);\r\n    classifierWeights.put(\"Classifier2\", 0.3);\r\n    classifierWeights.put(\"Classifier3\", 0.1);\r\n    classifierWeights.put(\"Classifier4\", 0.1);\r\n    AssociativeArray expResult = new AssociativeArray();\r\n    expResult.put(\"class1\", 0.1733);\r\n    expResult.put(\"class2\", 0.5033);\r\n    expResult.put(\"class3\", 0.3233);\r\n    AssociativeArray result = FixedCombinationRules.weightedAverage(classifierClassProbabilityMatrix, classifierWeights);\r\n    for (Object k : expResult.keySet()) {\r\n        assertEquals(TypeInference.toDouble(expResult.get(k)), TypeInference.toDouble(result.get(k)), Constants.DOUBLE_ACCURACY_HIGH);\r\n    }\r\n}"
}, {
	"Path": "io.github.classgraph.MethodInfo.getTypeSignatureOrTypeDescriptor",
	"Comment": "returns the parsed type signature for the method, possibly including type parameters. if the parsed typesignature is null, indicating that no type signature information is available for this method, returns theparsed type descriptor instead.",
	"Method": "MethodTypeSignature getTypeSignatureOrTypeDescriptor(){\r\n    final MethodTypeSignature typeSig = getTypeSignature();\r\n    if (typeSig != null) {\r\n        return typeSig;\r\n    } else {\r\n        return getTypeDescriptor();\r\n    }\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.MapX.fromStream",
	"Comment": "construct a new mapx with the same collector from the supplied stream",
	"Method": "MapX<K, V> fromStream(ReactiveSeq<Tuple2<K, V>> stream){\r\n    return new MapXImpl<K, V>(stream.toMap(t -> t._1(), t -> t._2()), getCollector());\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.independentsamples.NormalIndependentSamplesTest.testTestPercentages",
	"Comment": "test of testpercentages method, of class normalindependentsamples.",
	"Method": "void testTestPercentages(){\r\n    logger.info(\"testPercentages\");\r\n    double p1bar = 0.54;\r\n    double p2bar = 0.61;\r\n    int n1 = 1000;\r\n    int n2 = 1000;\r\n    boolean is_twoTailed = false;\r\n    double aLevel = 0.05;\r\n    boolean expResult = true;\r\n    boolean result = NormalIndependentSamples.testPercentages(p1bar, p2bar, n1, n2, is_twoTailed, aLevel);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.VectorX.narrowK",
	"Comment": "convert the raw higher kinded type for pvector types into the pvectortype type definition class",
	"Method": "VectorX<T> narrowK(Higher<vectorX, T> list){\r\n    return (VectorX<T>) list;\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.ElementState.ensureCapacity",
	"Comment": "increases the capacity of this class instance, if necessary, to ensurethat it can hold at least the number of elements specified by theminimum capacity argument.",
	"Method": "void ensureCapacity(int minCapacity){\r\n    int oldCapacity = this.openElements.length;\r\n    if (minCapacity > oldCapacity) {\r\n        OpenElementEvent[] oldElements = this.openElements;\r\n        char[] oldChanges = this.openChanges;\r\n        int newCapacity = oldCapacity * 3 / 2 + 1;\r\n        if (newCapacity < minCapacity) {\r\n            newCapacity = minCapacity;\r\n        }\r\n        this.openElements = new OpenElementEvent[newCapacity];\r\n        this.openChanges = new char[newCapacity];\r\n        System.arraycopy(oldElements, 0, this.openElements, 0, this.size);\r\n        System.arraycopy(oldChanges, 0, this.openChanges, 0, this.size);\r\n    }\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.utils.ReflectionUtils.invokeMethod",
	"Comment": "invoke the named method in the given object or its superclasses. if an exception is thrown while trying tocall the method, and throwexception is true, then illegalargumentexception is thrown wrapping the cause,otherwise this will return null. if passed a null object, returns null unless throwexception is true, thenthrows illegalargumentexception.",
	"Method": "Object invokeMethod(Object obj,String methodName,boolean throwException,Object invokeMethod,Object obj,String methodName,Class<?> argType,Object arg,boolean throwException){\r\n    if (obj != null) {\r\n        final Class<?> cls = obj.getClass();\r\n        final List<Class<?>> reverseAttemptOrder = getReverseMethodAttemptOrder(cls);\r\n        IllegalAccessException illegalAccessException = null;\r\n        for (int i = reverseAttemptOrder.size() - 1; i >= 0; i--) {\r\n            final Class<?> iface = reverseAttemptOrder.get(i);\r\n            try {\r\n                final Method method = iface.getDeclaredMethod(methodName, argType);\r\n                try {\r\n                    method.setAccessible(true);\r\n                } catch (final Exception e) {\r\n                }\r\n                return method.invoke(obj, arg);\r\n            } catch (final NoSuchMethodException e) {\r\n            } catch (final IllegalAccessException e) {\r\n                illegalAccessException = e;\r\n            } catch (final Throwable e) {\r\n                if (throwException) {\r\n                    throw new IllegalArgumentException(\"Exception while invoking method \\\"\" + methodName + \"\\\"\", e);\r\n                }\r\n            }\r\n        }\r\n        if (throwException) {\r\n            if (illegalAccessException != null) {\r\n                throw new IllegalArgumentException(\"Method \\\"\" + methodName + \"\\\" is not accessible\", illegalAccessException);\r\n            } else {\r\n                throw new IllegalArgumentException(\"Method \\\"\" + methodName + \"\\\" doesn't exist\");\r\n            }\r\n        }\r\n    } else if (throwException) {\r\n        throw new IllegalArgumentException(\"Can't invoke method on null object\");\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributionsTest.testGeometric",
	"Comment": "test of geometric method, of class discretedistributions.",
	"Method": "void testGeometric(){\r\n    logger.info(\"Geometric\");\r\n    int k = 3;\r\n    double p = 0.5;\r\n    double expResult = 0.125;\r\n    double result = DiscreteDistributions.geometric(k, p);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.onesample.DurbinWatson.checkCriticalValue",
	"Comment": "checks the critical value to determine if the hypothesis should be rejected",
	"Method": "boolean checkCriticalValue(double score,int n,int k,boolean is_twoTailed,double aLevel){\r\n    double z = (score - 2.0) / Math.sqrt(4.0 / n);\r\n    double probability = ContinuousDistributions.gaussCdf(z);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2.0;\r\n    }\r\n    if (probability <= a || probability >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.oath.cyclops.react.threads.ReactPool.elasticPool",
	"Comment": "if all reactors are in use calling react will create a new reactor to handle the extra demand.generate an elastic pool of reactors",
	"Method": "ReactPool<REACTOR> elasticPool(Supplier<REACTOR> supplier){\r\n    return new ReactPool(supplier);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentQueueX.fill",
	"Comment": "generate a persistentqueuex from the provided value up to the provided limit number of times",
	"Method": "PersistentQueueX<T> fill(long limit,T s){\r\n    return ReactiveSeq.fill(s).limit(limit).to(ReactiveConvertableSequence::converter).persistentQueueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.common.dataobjects.TrainableBundle.put",
	"Comment": "puts the trainable in the bundle using a specific key and returns the previous entry or null.",
	"Method": "Trainable put(String key,Trainable value){\r\n    return bundle.put(key, value);\r\n}"
}, {
	"Path": "com.oath.cyclops.util.box.LazyImmutable.flatMap",
	"Comment": "flatmap the value stored in immutable closed value from one value to another if this is an unitiatilised immutableclosedvalue, an uninitialised closed value will be returned instead",
	"Method": "LazyImmutable<? extends R> flatMap(Function<? super T, ? extends LazyImmutable<? extends R>> fn){\r\n    final T val = get();\r\n    if (val == UNSET)\r\n        return (LazyImmutable<R>) this;\r\n    else\r\n        return fn.apply(val);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.FlatDataList.get",
	"Comment": "gets an element at the specified position in the internal list.",
	"Method": "Object get(int index){\r\n    return internalData.get(index);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.DataframeMatrix.newInstance",
	"Comment": "method used to generate a training dataframe to a dataframematrix and extracts its contents to matrixes. it populates the featureidsreference map with the mappingsbetween the feature names and the column ids of the matrix. typically usedto convert the training dataset.",
	"Method": "DataframeMatrix newInstance(Dataframe dataset,boolean addConstantColumn,Map<Integer, Integer> recordIdsReference,Map<Object, Integer> featureIdsReference){\r\n    if (!featureIdsReference.isEmpty()) {\r\n        throw new IllegalArgumentException(\"The featureIdsReference map should be empty.\");\r\n    }\r\n    setStorageEngine(dataset);\r\n    int n = dataset.size();\r\n    int d = dataset.xColumnSize();\r\n    if (addConstantColumn) {\r\n        ++d;\r\n    }\r\n    DataframeMatrix m = new DataframeMatrix(new MapRealMatrix(n, d), new MapRealVector(n));\r\n    if (dataset.isEmpty()) {\r\n        return m;\r\n    }\r\n    boolean extractY = (dataset.getYDataType() == TypeInference.DataType.NUMERICAL);\r\n    int featureId = 0;\r\n    if (addConstantColumn) {\r\n        for (int row = 0; row < n; ++row) {\r\n            m.X.setEntry(row, featureId, 1.0);\r\n        }\r\n        featureIdsReference.put(Dataframe.COLUMN_NAME_CONSTANT, featureId);\r\n        ++featureId;\r\n    }\r\n    int rowId = 0;\r\n    for (Map.Entry<Integer, Record> e : dataset.entries()) {\r\n        Integer rId = e.getKey();\r\n        Record r = e.getValue();\r\n        if (recordIdsReference != null) {\r\n            recordIdsReference.put(rId, rowId);\r\n        }\r\n        if (extractY) {\r\n            m.Y.setEntry(rowId, TypeInference.toDouble(r.getY()));\r\n        }\r\n        for (Map.Entry<Object, Object> entry : r.getX().entrySet()) {\r\n            Object feature = entry.getKey();\r\n            Integer knownFeatureId = featureIdsReference.get(feature);\r\n            if (knownFeatureId == null) {\r\n                featureIdsReference.put(feature, featureId);\r\n                knownFeatureId = featureId;\r\n                ++featureId;\r\n            }\r\n            Double value = TypeInference.toDouble(entry.getValue());\r\n            if (value != null) {\r\n                m.X.setEntry(rowId, knownFeatureId, value);\r\n            }\r\n        }\r\n        ++rowId;\r\n    }\r\n    return m;\r\n}"
}, {
	"Path": "org.jak_linux.dns66.db.RuleDatabaseItemUpdateRunnable.downloadFile",
	"Comment": "downloads a file from a connection to an singlewritermultiplereaderfile.",
	"Method": "void downloadFile(File file,SingleWriterMultipleReaderFile singleWriterMultipleReaderFile,HttpURLConnection connection){\r\n    InputStream inStream = connection.getInputStream();\r\n    FileOutputStream outStream = singleWriterMultipleReaderFile.startWrite();\r\n    try {\r\n        copyStream(inStream, outStream);\r\n        singleWriterMultipleReaderFile.finishWrite(outStream);\r\n        outStream = null;\r\n        if (connection.getLastModified() == 0 || !file.setLastModified(connection.getLastModified())) {\r\n            Log.d(TAG, \"downloadFile: Could not set last modified\");\r\n        }\r\n    } finally {\r\n        if (outStream != null)\r\n            singleWriterMultipleReaderFile.failWrite(outStream);\r\n    }\r\n}"
}, {
	"Path": "cyclops.futurestream.LazyReact.constructFutures",
	"Comment": "construct a futurestream from a stream of completablefutures",
	"Method": "FutureStream<U> constructFutures(Stream<CompletableFuture<U>> s){\r\n    final LazyReact toUse = withStreamOfFutures(true);\r\n    return toUse.construct((Stream<U>) s);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.timeseries.SmoothingTest.testSimpleMovingAverageQuick",
	"Comment": "test of simplemovingaveragequick method, of class smoothing.",
	"Method": "void testSimpleMovingAverageQuick(){\r\n    logger.info(\"simpleMovingAverageQuick\");\r\n    double Yt = 23.5;\r\n    double YtminusN = 20.0;\r\n    double Ft = 23.0;\r\n    int N = 3;\r\n    double expResult = 24.166666666667;\r\n    double result = Smoothing.simpleMovingAverageQuick(Yt, YtminusN, Ft, N);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AssociativeArray.getDouble",
	"Comment": "gets value of the particular key from the map and converts it into a double.if not found null is returned. the value must be numeric or boolean or elsean exception is thrown.",
	"Method": "Double getDouble(Object key){\r\n    return TypeInference.toDouble(internalData.get(key));\r\n}"
}, {
	"Path": "cyclops.monads.transformers.EvalT.of",
	"Comment": "construct an evalwt from an anym that wraps a monad containingevalws",
	"Method": "EvalT<W, A> of(AnyM<W, Eval<A>> monads){\r\n    return new EvalT(monads);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributions.uniform",
	"Comment": "returns the probability of uniform discrete distribution with parameter n",
	"Method": "double uniform(int n){\r\n    if (n < 1) {\r\n        throw new IllegalArgumentException(\"The n must be larger than 1.\");\r\n    }\r\n    double probability = 1.0 / n;\r\n    return probability;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.decisiontheory.DecisionCriteria.hurwiczAlpha",
	"Comment": "returns the best option and the payoff under hurwiczalpha strategy",
	"Method": "Map.Entry<Object, Object> hurwiczAlpha(DataTable2D payoffMatrix,double alpha){\r\n    if (payoffMatrix.isValid() == false) {\r\n        throw new IllegalArgumentException(\"The payoff matrix does not have a rectangular format.\");\r\n    }\r\n    AssociativeArray minPayoffs = new AssociativeArray();\r\n    AssociativeArray maxPayoffs = new AssociativeArray();\r\n    for (Map.Entry<Object, AssociativeArray> entry : payoffMatrix.entrySet()) {\r\n        AssociativeArray optionList = entry.getValue();\r\n        for (Map.Entry<Object, Object> entry2 : optionList.entrySet()) {\r\n            Object option = entry2.getKey();\r\n            Double payoff = TypeInference.toDouble(entry2.getValue());\r\n            Double currentMinPayoffOption = minPayoffs.getDouble(option);\r\n            if (currentMinPayoffOption == null || payoff < currentMinPayoffOption) {\r\n                minPayoffs.put(option, payoff);\r\n            }\r\n            Double currentMaxPayoffOption = maxPayoffs.getDouble(option);\r\n            if (currentMaxPayoffOption == null || payoff > currentMaxPayoffOption) {\r\n                maxPayoffs.put(option, payoff);\r\n            }\r\n        }\r\n    }\r\n    AssociativeArray combinedPayoffs = new AssociativeArray();\r\n    for (Map.Entry<Object, Object> entry : maxPayoffs.entrySet()) {\r\n        Object option = entry.getKey();\r\n        combinedPayoffs.put(option, TypeInference.toDouble(entry.getValue()) * alpha + minPayoffs.getDouble(option) * (1.0 - alpha));\r\n    }\r\n    Map.Entry<Object, Object> entry = MapMethods.selectMaxKeyValue(combinedPayoffs);\r\n    return entry;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.ReadabilityStatistics.percentageWordsWithThreeSyllables",
	"Comment": "returns the percentage of words with more than three syllables.",
	"Method": "double percentageWordsWithThreeSyllables(String strText){\r\n    int intWordCount = wordCount(strText);\r\n    int intLongWordCount = wordsWithThreeSyllables(strText);\r\n    double percentage = ((intLongWordCount / (double) intWordCount) * 100.0);\r\n    return percentage;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.QueueX.fill",
	"Comment": "generate a queuex from the provided value up to the provided limit number of times",
	"Method": "QueueX<T> fill(long limit,T s){\r\n    return ReactiveSeq.fill(s).limit(limit).to(ReactiveConvertableSequence::converter).queueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.traversable.IterableFilterable.removeAll",
	"Comment": "remove all elements in the supplied iterable from this filterable",
	"Method": "Filters<T> removeAll(Iterable<? extends T> it,Filters<T> removeAll,T values){\r\n    return removeStream(Stream.of(values));\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AbstractDataStructureCollection.iteratorDouble",
	"Comment": "iterator which casts the values of the data structure from object to double.this iterator should be used only when the underling data structure containsnumeric or boolean values. accessing this iterator when other data typesare stored will lead to an exception.",
	"Method": "Iterator<Double> iteratorDouble(){\r\n    return new Iterator<Double>() {\r\n        private final Iterator<Object> objectIterator = (Iterator<Object>) internalData.iterator();\r\n        @Override\r\n        public boolean hasNext() {\r\n            return objectIterator.hasNext();\r\n        }\r\n        @Override\r\n        public Double next() {\r\n            return TypeInference.toDouble(objectIterator.next());\r\n        }\r\n        @Override\r\n        public void remove() {\r\n            objectIterator.remove();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AbstractDataStructureCollection.iteratorDouble",
	"Comment": "iterator which casts the values of the data structure from object to double.this iterator should be used only when the underling data structure containsnumeric or boolean values. accessing this iterator when other data typesare stored will lead to an exception.",
	"Method": "Iterator<Double> iteratorDouble(){\r\n    return objectIterator.hasNext();\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AbstractDataStructureCollection.iteratorDouble",
	"Comment": "iterator which casts the values of the data structure from object to double.this iterator should be used only when the underling data structure containsnumeric or boolean values. accessing this iterator when other data typesare stored will lead to an exception.",
	"Method": "Iterator<Double> iteratorDouble(){\r\n    return TypeInference.toDouble(objectIterator.next());\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AbstractDataStructureCollection.iteratorDouble",
	"Comment": "iterator which casts the values of the data structure from object to double.this iterator should be used only when the underling data structure containsnumeric or boolean values. accessing this iterator when other data typesare stored will lead to an exception.",
	"Method": "Iterator<Double> iteratorDouble(){\r\n    objectIterator.remove();\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.independentsamples.StudentsIndependentSamplesTest.testTestMeansUnknownNotEqualVars",
	"Comment": "test of testmeansunknownnotequalvars method, of class studentsindependentsamples.",
	"Method": "void testTestMeansUnknownNotEqualVars(){\r\n    logger.info(\"testMeansUnknownNotEqualVars\");\r\n    double xbar = 215.0;\r\n    double ybar = 200.0;\r\n    int n = 60;\r\n    int m = 50;\r\n    double stdx = 55.0;\r\n    double stdy = 50.0;\r\n    boolean is_twoTailed = false;\r\n    double aLevel = 0.05;\r\n    boolean expResult = false;\r\n    boolean result = StudentsIndependentSamples.testMeansUnknownNotEqualVars(xbar, ybar, n, m, stdx, stdy, is_twoTailed, aLevel);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.concurrency.ForkJoinStream.collect",
	"Comment": "executes collect on the provided stream using the provided collector. if the stream is parallel, it is executed using the custom pool, else it is executed directly from the main thread.",
	"Method": "R collect(Stream<T> stream,Collector<? super T, A, R> collector){\r\n    Callable<R> callable = () -> stream.collect(collector);\r\n    return ThreadMethods.forkJoinExecution(callable, concurrencyConfiguration, stream.isParallel());\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.MapX.toSetX",
	"Comment": "convert this mapx to a setx via the provided transformation function",
	"Method": "SetX<T> toSetX(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn){\r\n    return SetX.narrow(stream().map(fn).to(ReactiveConvertableSequence::converter).setX());\r\n}"
}, {
	"Path": "com.datumbox.framework.common.ConfigurableFactory.getConfiguration",
	"Comment": "initializes the configuration object using a properties object.",
	"Method": "C getConfiguration(Class<C> klass,C getConfiguration,Class<C> klass,Properties properties){\r\n    C configuration;\r\n    try {\r\n        Constructor<C> constructor = klass.getDeclaredConstructor();\r\n        constructor.setAccessible(true);\r\n        configuration = constructor.newInstance();\r\n    } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n    configuration.load(properties);\r\n    return configuration;\r\n}"
}, {
	"Path": "com.oath.cyclops.util.stream.scheduling.cron.CronExpression.setTimeZone",
	"Comment": "sets the time zone for whichthis cronexpressionwill be resolved.",
	"Method": "void setTimeZone(TimeZone timeZone){\r\n    this.timeZone = timeZone;\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachX",
	"Comment": "perform a foreach operation over the stream, without closing it, consuming only the specified number of elements fromthe stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachX(FutureStream<T> stream,long x,Consumer<? super T> consumerElement){\r\n    final CompletableFuture<Subscription> subscription = new CompletableFuture();\r\n    final CompletableFuture<Boolean> streamCompleted = new CompletableFuture();\r\n    return tuple(subscription, () -> {\r\n        stream.subscribe(new Subscriber<T>() {\r\n            @Override\r\n            public void onSubscribe(final Subscription s) {\r\n                Objects.requireNonNull(s);\r\n                if (x != 0)\r\n                    s.request(x);\r\n                subscription.complete(s);\r\n            }\r\n            @Override\r\n            public void onNext(final T t) {\r\n                consumerElement.accept(t);\r\n            }\r\n            @Override\r\n            public void onError(final Throwable t) {\r\n            }\r\n            @Override\r\n            public void onComplete() {\r\n                streamCompleted.complete(true);\r\n            }\r\n        });\r\n    }, streamCompleted);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachX",
	"Comment": "perform a foreach operation over the stream, without closing it, consuming only the specified number of elements fromthe stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachX(FutureStream<T> stream,long x,Consumer<? super T> consumerElement){\r\n    Objects.requireNonNull(s);\r\n    if (x != 0)\r\n        s.request(x);\r\n    subscription.complete(s);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachX",
	"Comment": "perform a foreach operation over the stream, without closing it, consuming only the specified number of elements fromthe stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachX(FutureStream<T> stream,long x,Consumer<? super T> consumerElement){\r\n    consumerElement.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachX",
	"Comment": "perform a foreach operation over the stream, without closing it, consuming only the specified number of elements fromthe stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachX(FutureStream<T> stream,long x,Consumer<? super T> consumerElement){\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachX",
	"Comment": "perform a foreach operation over the stream, without closing it, consuming only the specified number of elements fromthe stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachX(FutureStream<T> stream,long x,Consumer<? super T> consumerElement){\r\n    streamCompleted.complete(true);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.independentsamples.StudentsIndependentSamples.checkCriticalValue",
	"Comment": "checks the critical value to determine if the hypothesis should be rejected",
	"Method": "boolean checkCriticalValue(double score,int df,boolean is_twoTailed,double aLevel){\r\n    double probability = ContinuousDistributions.studentsCdf(score, df);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2;\r\n    }\r\n    if (probability <= a || probability >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributionsTest.testNegativeBinomial",
	"Comment": "test of negativebinomial method, of class discretedistributions.",
	"Method": "void testNegativeBinomial(){\r\n    logger.info(\"NegativeBinomial\");\r\n    int n = 10;\r\n    int r = 4;\r\n    double p = 0.5;\r\n    double expResult = 0.08203125;\r\n    double result = DiscreteDistributions.negativeBinomial(n, r, p);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.TransposeDataList.get",
	"Comment": "returns the value which is associated with the provided key.",
	"Method": "FlatDataList get(Object key){\r\n    return internalData.get(key);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.onesample.ShapiroWilk.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level",
	"Method": "boolean test(FlatDataCollection flatDataCollection,double aLevel){\r\n    boolean rejectH0 = false;\r\n    double probability = shapiroWilkW(flatDataCollection.stream().filter(x -> x != null).mapToDouble(TypeInference::toDouble).toArray());\r\n    double a = aLevel;\r\n    if (probability <= a || probability >= (1.0 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.Value.toTry",
	"Comment": "convert this value to a try that will catch the provided exception types on subsequent operations",
	"Method": "Try<T, X> toTry(X throwable,Try<T, Throwable> toTry,Try<T, X> toTry,Class<X> classes){\r\n    return Try.fromPublisher(this, classes);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.ReadabilityStatistics.automatedReadabilityIndex",
	"Comment": "returns the automated readability index of text entered rounded to one digit.",
	"Method": "double automatedReadabilityIndex(String strText){\r\n    strText = cleanText(strText);\r\n    int intWordCount = wordCount(strText);\r\n    return PHPMethods.round(((4.71 * (letterCount(strText) / (double) intWordCount)) + (0.5 * (intWordCount / (double) sentenceCount(strText))) - 21.43), 1);\r\n}"
}, {
	"Path": "cyclops.companion.Streams.toConcurrentLazyCollection",
	"Comment": "lazily constructs a collection from specified stream. collections iterator may be safely usedconcurrently by multiple threads.",
	"Method": "Collection<A> toConcurrentLazyCollection(Stream<A> stream,Collection<A> toConcurrentLazyCollection,Iterator<A> iterator){\r\n    return SeqUtils.toConcurrentLazyCollection(iterator);\r\n}"
}, {
	"Path": "org.jak_linux.dns66.db.RuleDatabase.loadItem",
	"Comment": "loads an item. an item can be backed by a file or contain a value in the location field.",
	"Method": "void loadItem(Context context,Configuration.Item item){\r\n    if (item.state == Configuration.Item.STATE_IGNORE)\r\n        return;\r\n    InputStreamReader reader;\r\n    try {\r\n        reader = FileHelper.openItemFile(context, item);\r\n    } catch (FileNotFoundException e) {\r\n        Log.d(TAG, \"loadItem: File not found: \" + item.location);\r\n        return;\r\n    }\r\n    if (reader == null) {\r\n        addHost(item, item.location);\r\n        return;\r\n    } else {\r\n        loadReader(item, reader);\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.onesample.Lilliefors.normalDistribution",
	"Comment": "cumulative normal distribution method. this method is called via reflection.",
	"Method": "double normalDistribution(Double x,AssociativeArray params){\r\n    double mean = params.getDouble(\"mean\");\r\n    double variance = params.getDouble(\"variance\");\r\n    double z = (x - mean) / Math.sqrt(variance);\r\n    return ContinuousDistributions.gaussCdf(z);\r\n}"
}, {
	"Path": "buildcraft.transport.gates.GateExpansionBuildcraft.getPixelExtrusion",
	"Comment": "how far away from the model the expansion item layer model should render. default value is 0.02f",
	"Method": "float getPixelExtrusion(){\r\n    return 0.03f;\r\n}"
}, {
	"Path": "cyclops.function.Memoize.memoizeSupplierAsync",
	"Comment": "memoize a supplier and update the cached values asynchronously using the provided scheduled executor servicedoes not support null keys",
	"Method": "Function0<R> memoizeSupplierAsync(Supplier<R> fn,ScheduledExecutorService ex,long updateRateInMillis,Function0<R> memoizeSupplierAsync,Supplier<R> fn,ScheduledExecutorService ex,String cron){\r\n    return () -> Memoize.memoizeFunctionAsync(a -> fn.get(), ex, cron).apply(\"k\");\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.ScanSpec.classOrPackageIsBlacklisted",
	"Comment": "returns true if the class is specifically blacklisted, or is within a blacklisted package.",
	"Method": "boolean classOrPackageIsBlacklisted(String className){\r\n    return classWhiteBlackList.isBlacklisted(className) || packagePrefixWhiteBlackList.isBlacklisted(className);\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.DiffXFitopsy.printLost",
	"Comment": "print information when the algorithm gets lost in the matrix,ie when it does not know which direction to follow.",
	"Method": "void printLost(int i,int j){\r\n    DiffXEvent e1 = this.sequence1.getEvent(i);\r\n    DiffXEvent e2 = this.sequence2.getEvent(j);\r\n    System.err.println(\"(!) Ambiguous choice in (\" + i + \",\" + j + \")\");\r\n    System.err.println(\" ? +\" + ShortStringFormatter.toShortString(e1));\r\n    System.err.println(\" ? -\" + ShortStringFormatter.toShortString(e2));\r\n    System.err.println(\" current=\" + ShortStringFormatter.toShortString(this.estate.current()));\r\n    System.err.println(\" value in X+1=\" + this.matrix.get(i + 1, j));\r\n    System.err.println(\" value in Y+1=\" + this.matrix.get(i, j + 1));\r\n    System.err.println(\" equals=\" + e1.equals(e2));\r\n    System.err.println(\" greaterX=\" + this.matrix.isGreaterX(i, j));\r\n    System.err.println(\" greaterY=\" + this.matrix.isGreaterY(i, j));\r\n    System.err.println(\" sameXY=\" + this.matrix.isSameXY(i, j));\r\n    System.err.println(\" okFormat1=\" + this.estate.okFormat(e1));\r\n    System.err.println(\" okFormat2=\" + this.estate.okFormat(e2));\r\n    System.err.println(\" okInsert=\" + this.estate.okInsert(e1));\r\n    System.err.println(\" okDelete=\" + this.estate.okDelete(e2));\r\n}"
}, {
	"Path": "cyclops.monads.transformers.ReaderT.of",
	"Comment": "construct an futuret from an anym that wraps a monad containingfutures",
	"Method": "ReaderT<W, T, R> of(AnyM<W, Reader<T, R>> monads){\r\n    return new ReaderT(monads);\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.concurrency.InterruptionChecker.check",
	"Comment": "check if this thread or any other thread that shares this interruptionchecker instance has been interruptedor has thrown an exception, and if so, throw interruptedexception.",
	"Method": "void check(){\r\n    if (checkAndReturn()) {\r\n        if (executionException != null) {\r\n            throw executionException;\r\n        } else {\r\n            throw new InterruptedException();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.relatedsamples.SignRelatedSamples.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level.",
	"Method": "boolean test(TransposeDataList transposeDataList,boolean is_twoTailed,double aLevel){\r\n    if (transposeDataList.size() != 2) {\r\n        throw new IllegalArgumentException(\"The collection must contain observations from 2 groups.\");\r\n    }\r\n    double pvalue = getPvalue(transposeDataList);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2;\r\n    }\r\n    if (pvalue <= a || pvalue >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.MatrixInt.release",
	"Comment": "gets rid of the underlying matrix so that garbage collector can do its work.",
	"Method": "void release(){\r\n    this.matrix = null;\r\n}"
}, {
	"Path": "cyclops.function.Monoid.of",
	"Comment": "construct a monoid from the supplied identity element and combining function",
	"Method": "Monoid<T> of(T zero,Semigroup<T> group,Monoid<T> of,T zero,Function<T, Function<T, T>> combiner){\r\n    return new Monoid<T>() {\r\n        @Override\r\n        public T zero() {\r\n            return zero;\r\n        }\r\n        @Override\r\n        public T apply(final T t, final T u) {\r\n            return combiner.apply(t).apply(u);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "cyclops.function.Monoid.of",
	"Comment": "construct a monoid from the supplied identity element and combining function",
	"Method": "Monoid<T> of(T zero,Semigroup<T> group,Monoid<T> of,T zero,Function<T, Function<T, T>> combiner){\r\n    return zero;\r\n}"
}, {
	"Path": "cyclops.function.Monoid.of",
	"Comment": "construct a monoid from the supplied identity element and combining function",
	"Method": "Monoid<T> of(T zero,Semigroup<T> group,Monoid<T> of,T zero,Function<T, Function<T, T>> combiner){\r\n    return combiner.apply(t).apply(u);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.stream.SpliteratorBasedStream.mergeMap",
	"Comment": "a potentially asynchronous flatmap operation where data from each publisher may arrive out of order",
	"Method": "ReactiveSeq<R> mergeMap(Function<? super T, ? extends Publisher<? extends R>> mapper,ReactiveSeq<R> mergeMap,int maxConcurrency,Function<? super T, ? extends Publisher<? extends R>> mapper){\r\n    return Spouts.fromIterable(this).mergeMap(maxConcurrency, mapper);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.onesample.Lilliefors.checkCriticalValue",
	"Comment": "checks the critical value to determine if the hypothesis should be rejected",
	"Method": "boolean checkCriticalValue(double score,int n,double aLevel){\r\n    boolean rejected = false;\r\n    double criticalValue = Double.MAX_VALUE;\r\n    double aLevelKey = aLevel;\r\n    if (!CRITICAL_VALUES.containsKey(aLevelKey)) {\r\n        double significanceValue = 0.0;\r\n        for (Map.Entry<Object, AssociativeArray> entry : CRITICAL_VALUES.entrySet()) {\r\n            significanceValue = TypeInference.toDouble(entry.getKey());\r\n            if (significanceValue <= aLevel) {\r\n                aLevelKey = significanceValue;\r\n                break;\r\n            }\r\n        }\r\n        if (!CRITICAL_VALUES.containsKey(aLevelKey)) {\r\n            aLevelKey = significanceValue;\r\n        }\r\n    }\r\n    if (CRITICAL_VALUES.containsKey(aLevelKey)) {\r\n        if (CRITICAL_VALUES.get(aLevelKey).containsKey(n)) {\r\n            criticalValue = CRITICAL_VALUES.get(aLevelKey).getDouble(n);\r\n        } else {\r\n            criticalValue = CRITICAL_VALUES.get(aLevelKey).getDouble(0);\r\n            criticalValue /= Math.sqrt(n);\r\n        }\r\n    }\r\n    if (score > criticalValue) {\r\n        rejected = true;\r\n    }\r\n    return rejected;\r\n}"
}, {
	"Path": "io.github.classgraph.ModuleRef.getRawVersion",
	"Comment": "get the raw version string of the module, or null if the module did not provide one.",
	"Method": "String getRawVersion(){\r\n    return rawVersion;\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.utils.LogNode.addElapsedTime",
	"Comment": "call this once the work corresponding with a given log entry has completed if you want to show the time takenafter the log entry.",
	"Method": "void addElapsedTime(){\r\n    elapsedTimeNanos = System.nanoTime() - timeStampNano;\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.TransposeDataCollection.get",
	"Comment": "returns the value which is associated with the provided key.",
	"Method": "FlatDataCollection get(Object key){\r\n    return internalData.get(key);\r\n}"
}, {
	"Path": "com.datumbox.framework.applications.nlp.TextClassifierTest.testTrainAndValidateBinarizedNaiveBayes",
	"Comment": "test of train and validate method, of class textclassifier using binarizednaivebayes.",
	"Method": "void testTrainAndValidateBinarizedNaiveBayes(){\r\n    logger.info(\"testTrainAndValidateBinarizedNaiveBayes\");\r\n    BinarizedNaiveBayes.TrainingParameters mlParams = new BinarizedNaiveBayes.TrainingParameters();\r\n    ChisquareSelect.TrainingParameters fsParams = new ChisquareSelect.TrainingParameters();\r\n    fsParams.setALevel(0.05);\r\n    fsParams.setMaxFeatures(1000);\r\n    fsParams.setRareFeatureThreshold(3);\r\n    trainAndValidate(mlParams, fsParams, null, 0.8413587159387832, 2);\r\n}"
}, {
	"Path": "io.github.classgraph.MethodInfo.hashCode",
	"Comment": "use hash code of class name, method name and type descriptor.",
	"Method": "int hashCode(){\r\n    return name.hashCode() + typeDescriptorStr.hashCode() * 11 + declaringClassName.hashCode() * 57;\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.TransposeDataCollection2D.get",
	"Comment": "returns the value which is associated with the provided key.",
	"Method": "TransposeDataCollection get(Object key){\r\n    return internalData.get(key);\r\n}"
}, {
	"Path": "cyclops.control.Try.mapOrCatch",
	"Comment": "perform a mapping operation that may catch the supplied exception typesthe supplied exception types are only applied during this map operation",
	"Method": "Try<R, X> mapOrCatch(CheckedFunction<? super T, ? extends R, X> fn,Class<? extends X> classes){\r\n    return new Try<R, X>(xor.flatMap(i -> safeApply(i, fn.asFunction(), classes)), this.classes);\r\n}"
}, {
	"Path": "cyclops.reactive.ReactiveSeq.of",
	"Comment": "create an efficiently reversable sequence from the provided elements",
	"Method": "ReactiveSeq<T> of(T value,ReactiveSeq<T> of,T elements){\r\n    final ReversingArraySpliterator<T> array = new ReversingArraySpliterator<T>(elements, 0, elements.length, false);\r\n    return Streams.reactiveSeq(array, Optional.ofNullable(array));\r\n}"
}, {
	"Path": "com.topologi.diffx.event.impl.LineEvent.equals",
	"Comment": "returns true if the event is a character event and the content is equivalent.",
	"Method": "boolean equals(DiffXEvent e){\r\n    if (e == null)\r\n        return false;\r\n    if (this == e)\r\n        return true;\r\n    if (e.getClass() != LineEvent.class)\r\n        return false;\r\n    LineEvent ce = (LineEvent) e;\r\n    return ce.characters.equals(this.characters);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.decisiontheory.DecisionCriteria.maximumLikelihood",
	"Comment": "returns the best option and the payoff under maximumlikelihood strategy",
	"Method": "Map.Entry<Object, Object> maximumLikelihood(DataTable2D payoffMatrix,AssociativeArray eventProbabilities){\r\n    if (payoffMatrix.isValid() == false) {\r\n        throw new IllegalArgumentException(\"The payoff matrix does not have a rectangular format.\");\r\n    }\r\n    Map.Entry<Object, Object> eventEntry = MapMethods.selectMaxKeyValue(eventProbabilities);\r\n    Object mostProbableEvent = eventEntry.getKey();\r\n    return MapMethods.selectMaxKeyValue(payoffMatrix.get(mostProbableEvent));\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.json.JSONDeserializer.deserializeObject",
	"Comment": "deserialize json to a new object graph, with the root object of the specified expected type. does not workfor generic types, since it is not possible to obtain the generic type of a class reference.",
	"Method": "T deserializeObject(Class<T> expectedType,String json,ClassFieldCache classFieldCache,T deserializeObject,Class<T> expectedType,String json){\r\n    final ClassFieldCache classFieldCache = new ClassFieldCache(true, false);\r\n    return deserializeObject(expectedType, json, classFieldCache);\r\n}"
}, {
	"Path": "cyclops.companion.reactor.Monos.combine",
	"Comment": "lazily combine this mono with the supplied mono via the supplied bifunction",
	"Method": "Mono<R> combine(Mono<? extends T1> mono,Value<? extends T2> app,BiFunction<? super T1, ? super T2, ? extends R> fn,Mono<R> combine,Mono<? extends T1> mono,Mono<? extends T2> app,BiFunction<? super T1, ? super T2, ? extends R> fn){\r\n    return Mono.from(Future.of(mono.toFuture()).zip(Future.of(app.toFuture()), fn));\r\n}"
}, {
	"Path": "com.datumbox.framework.common.concurrency.ThreadMethods.throttledExecution",
	"Comment": "takes the items of the stream in a throttled way and provides them to the consumer. it uses as many threads as the available processors and it doesnot start more tasks than 2 times the previous number.",
	"Method": "void throttledExecution(Stream<T> stream,Consumer<T> consumer,ConcurrencyConfiguration concurrencyConfiguration){\r\n    if (concurrencyConfiguration.isParallelized()) {\r\n        int maxThreads = concurrencyConfiguration.getMaxNumberOfThreadsPerTask();\r\n        int maxTasks = 2 * maxThreads;\r\n        ExecutorService executorService = Executors.newFixedThreadPool(maxThreads);\r\n        ThrottledExecutor executor = new ThrottledExecutor(executorService, maxTasks);\r\n        stream.sequential().forEach(i -> {\r\n            executor.execute(() -> {\r\n                consumer.accept(i);\r\n            });\r\n        });\r\n        executorService.shutdown();\r\n        try {\r\n            executorService.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);\r\n        } catch (InterruptedException ex) {\r\n            throw new RuntimeException(ex);\r\n        }\r\n    } else {\r\n        Runnable runnable = () -> stream.forEach(consumer);\r\n        runnable.run();\r\n    }\r\n}"
}, {
	"Path": "cyclops.monads.transformers.jdk.OptionalT.of",
	"Comment": "construct an optionalwt from an anym that wraps a monad containingoptionalws",
	"Method": "OptionalT<W, A> of(AnyM<W, Optional<A>> monads){\r\n    return new OptionalT(monads);\r\n}"
}, {
	"Path": "cyclops.monads.transformers.jdk.CompletableFutureT.of",
	"Comment": "construct an futuret from an anym that wraps a monad containingfutures",
	"Method": "CompletableFutureT<W, A> of(AnyM<W, CompletableFuture<A>> monads){\r\n    return new CompletableFutureT(monads);\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.ElementState.push",
	"Comment": "push the specified open element and flags it with the specified change.",
	"Method": "void push(OpenElementEvent e,char c){\r\n    ensureCapacity(this.size + 1);\r\n    this.openElements[this.size] = e;\r\n    this.openChanges[this.size] = c;\r\n    this.size++;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.fromStreamOfFutures",
	"Comment": "construct a simplereactstream from provided stream of completablefutures",
	"Method": "SimpleReactStream<R> fromStreamOfFutures(Stream<CompletableFuture<R>> stream){\r\n    final Stream noType = stream;\r\n    return (SimpleReactStream<R>) this.withLastActive(getLastActive().withNewStream(noType, this.getSimpleReact()));\r\n}"
}, {
	"Path": "com.oath.cyclops.util.ExceptionSoftener.throwIf",
	"Comment": "throw the exception as upwards if the predicate holds, otherwise do nothing",
	"Method": "void throwIf(X e,Predicate<X> p){\r\n    if (p.test(e))\r\n        throw ExceptionSoftener.<RuntimeException>uncheck(e);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.common.abstracts.transformers.AbstractTransformer.transform",
	"Comment": "applies an irreversible trasformation to the the provided dataset.",
	"Method": "void transform(Dataframe newData){\r\n    logger.info(\"transform()\");\r\n    _transform(newData);\r\n}"
}, {
	"Path": "cyclops.companion.rx2.Maybes.fromIterable",
	"Comment": "construct a maybe from iterable by taking the first value from iterable",
	"Method": "Maybe<T> fromIterable(Iterable<T> t){\r\n    return narrow(Single.fromPublisher(Future.fromIterable(t)).toMaybe());\r\n}"
}, {
	"Path": "com.oath.cyclops.types.traversable.IterableFilterable.removeStream",
	"Comment": "remove all elements in the supplied stream from this filterable",
	"Method": "Filters<T> removeStream(Stream<? extends T> stream){\r\n    final Eval<Set<T>> set = Eval.later(() -> stream.collect(Collectors.toSet()));\r\n    return filterNot(i -> set.get().contains(i));\r\n}"
}, {
	"Path": "com.datumbox.framework.applications.nlp.TextClassifierTest.trainAndValidate",
	"Comment": "trains and validates a model with the provided modeler and feature selector.",
	"Method": "void trainAndValidate(ML.AbstractTrainingParameters modelerTrainingParameters,FS.AbstractTrainingParameters featureSelectorTrainingParameters,NS.AbstractTrainingParameters numericalScalerTrainingParameters,double expectedF1score,int testId){\r\n    Configuration configuration = getConfiguration();\r\n    String storageName = this.getClass().getSimpleName() + testId;\r\n    Map<Object, URI> dataset = Datasets.sentimentAnalysis();\r\n    TextClassifier.TrainingParameters trainingParameters = new TextClassifier.TrainingParameters();\r\n    trainingParameters.setNumericalScalerTrainingParameters(numericalScalerTrainingParameters);\r\n    trainingParameters.setFeatureSelectorTrainingParametersList(Arrays.asList(featureSelectorTrainingParameters));\r\n    trainingParameters.setModelerTrainingParameters(modelerTrainingParameters);\r\n    NgramsExtractor.Parameters exParams = new NgramsExtractor.Parameters();\r\n    exParams.setMaxDistanceBetweenKwds(2);\r\n    exParams.setExaminationWindowLength(6);\r\n    trainingParameters.setTextExtractorParameters(exParams);\r\n    TextClassifier instance = MLBuilder.create(trainingParameters, configuration);\r\n    instance.fit(dataset);\r\n    instance.save(storageName);\r\n    ClassificationMetrics vm = instance.validate(dataset);\r\n    assertEquals(expectedF1score, vm.getMacroF1(), Constants.DOUBLE_ACCURACY_HIGH);\r\n    instance.close();\r\n    instance = MLBuilder.load(TextClassifier.class, storageName, configuration);\r\n    Dataframe validationData = instance.predict(Datasets.sentimentAnalysisUnlabeled());\r\n    List<Object> expResult = Arrays.asList(\"negative\", \"positive\");\r\n    int i = 0;\r\n    for (Record r : validationData.values()) {\r\n        assertEquals(expResult.get(i), r.getYPredicted());\r\n        ++i;\r\n    }\r\n    instance.delete();\r\n    validationData.close();\r\n}"
}, {
	"Path": "cyclops.monads.AnyM.ofNullable",
	"Comment": "generate an anym that wraps an optional from the provided nullable object",
	"Method": "AnyMValue<optional, T> ofNullable(T nullable){\r\n    return AnyMFactory.instance.value(Optional.ofNullable(nullable), Witness.optional.INSTANCE);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.FlatDataList.addAll",
	"Comment": "adds all the elements of the provided collection in the internal list.",
	"Method": "boolean addAll(Collection<Object> c){\r\n    return internalData.addAll(c);\r\n}"
}, {
	"Path": "com.topologi.diffx.event.impl.IgnorableSpaceEvent.equals",
	"Comment": "returns true if the event is an ignorable white space, regardless of thecharacters that it matches.",
	"Method": "boolean equals(Object o,boolean equals,DiffXEvent e){\r\n    if (this == e)\r\n        return true;\r\n    if (e.getClass() != this.getClass())\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.relatedsamples.WilcoxonRelatedSamples.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level",
	"Method": "boolean test(TransposeDataList transposeDataList,boolean is_twoTailed,double aLevel){\r\n    if (transposeDataList.size() != 2) {\r\n        throw new IllegalArgumentException(\"The collection must contain observations from 2 groups.\");\r\n    }\r\n    double pvalue = getPvalue(transposeDataList);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2;\r\n    }\r\n    if (pvalue <= a || pvalue >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.Dataframe.getYColumn",
	"Comment": "it extracts the values of the response variables from all observations andstores them into an flatdatalist.",
	"Method": "FlatDataList getYColumn(){\r\n    FlatDataList flatDataList = new FlatDataList();\r\n    for (Record r : values()) {\r\n        flatDataList.add(r.getY());\r\n    }\r\n    return flatDataList;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentSetX.generate",
	"Comment": "generate a persistentsetx from the provided supplier up to the provided limit number of times",
	"Method": "PersistentSetX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).persistentSetX(LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributionsTest.testKolmogorov",
	"Comment": "test of kolmogorov method, of class continuousdistributions.",
	"Method": "void testKolmogorov(){\r\n    logger.info(\"Kolmogorov\");\r\n    double z = 2.0;\r\n    double expResult = 0.99932907474422;\r\n    double result = ContinuousDistributions.kolmogorov(z);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.ElementState.okFormat",
	"Comment": "indicates whether the specified event is a close element thatmatches the name and uri of the current open element.",
	"Method": "boolean okFormat(DiffXEvent e){\r\n    if (!(e instanceof CloseElementEvent))\r\n        return true;\r\n    if (isEmpty())\r\n        return false;\r\n    return ((CloseElementEvent) e).match(current()) && this.openChanges[this.size - 1] == '=';\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.decisiontheory.DecisionCriteria.laplace",
	"Comment": "returns the best option and the payoff under laplace strategy",
	"Method": "Map.Entry<Object, Object> laplace(DataTable2D payoffMatrix){\r\n    if (payoffMatrix.isValid() == false) {\r\n        throw new IllegalArgumentException(\"The payoff matrix does not have a rectangular format.\");\r\n    }\r\n    AssociativeArray optionAverages = new AssociativeArray();\r\n    int numberOfEvents = payoffMatrix.size();\r\n    for (Map.Entry<Object, AssociativeArray> entry : payoffMatrix.entrySet()) {\r\n        AssociativeArray optionList = entry.getValue();\r\n        for (Map.Entry<Object, Object> entry2 : optionList.entrySet()) {\r\n            Object option = entry2.getKey();\r\n            Double payoff = TypeInference.toDouble(entry2.getValue());\r\n            Double value = optionAverages.getDouble(option);\r\n            if (value == null) {\r\n                value = 0.0;\r\n            }\r\n            optionAverages.put(option, value + payoff / numberOfEvents);\r\n        }\r\n    }\r\n    Map.Entry<Object, Object> entry = MapMethods.selectMaxKeyValue(optionAverages);\r\n    return entry;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributionsTest.testPoissonCdf",
	"Comment": "test of poissoncdf method, of class discretedistributions.",
	"Method": "void testPoissonCdf(){\r\n    logger.info(\"PoissonCdf\");\r\n    int k = 3;\r\n    double lamda = 5.0;\r\n    double expResult = 0.26502591533403;\r\n    double result = DiscreteDistributions.poissonCdf(k, lamda);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.concurrency.InterruptionChecker.interrupt",
	"Comment": "interrupt all threads that share this interruptionchecker.",
	"Method": "void interrupt(){\r\n    interrupted.set(true);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributionsTest.testLogGamma",
	"Comment": "test of loggamma method, of class continuousdistributions.",
	"Method": "void testLogGamma(){\r\n    logger.info(\"LogGamma\");\r\n    double Z = 3.0;\r\n    double expResult = 0.69314718044741;\r\n    double result = ContinuousDistributions.logGamma(Z);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.dataobjects.Dataframe.getXColumn",
	"Comment": "it extracts the values of a particular column from all records andstores them into an flatdatalist.",
	"Method": "FlatDataList getXColumn(Object column){\r\n    FlatDataList flatDataList = new FlatDataList();\r\n    for (Record r : values()) {\r\n        flatDataList.add(r.getX().get(column));\r\n    }\r\n    return flatDataList;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributionsTest.testBinomialCdf",
	"Comment": "test of binomialcdf method, of class discretedistributions.",
	"Method": "void testBinomialCdf(){\r\n    logger.info(\"BinomialCdf\");\r\n    int k = 3;\r\n    double p = 0.5;\r\n    int n = 10;\r\n    double expResult = 0.17187500002003;\r\n    double result = DiscreteDistributions.binomialCdf(k, p, n);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.SortedSetX.range",
	"Comment": "create a sortedsetx that contains the integers between skip and take",
	"Method": "SortedSetX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).sortedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.applications.nlp.TextClassifierTest.testTrainAndValidateSupportVectorMachine",
	"Comment": "test of train and validate method, of class textclassifier using supportvectormachine.",
	"Method": "void testTrainAndValidateSupportVectorMachine(){\r\n    logger.info(\"testTrainAndValidateSupportVectorMachine\");\r\n    SupportVectorMachine.TrainingParameters mlParams = new SupportVectorMachine.TrainingParameters();\r\n    ChisquareSelect.TrainingParameters fsParams = new ChisquareSelect.TrainingParameters();\r\n    fsParams.setALevel(0.05);\r\n    fsParams.setMaxFeatures(1000);\r\n    fsParams.setRareFeatureThreshold(3);\r\n    trainAndValidate(mlParams, fsParams, null, 0.9803846153846154, 7);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.stream.SeqUtils.toConcurrentLazyCollection",
	"Comment": "lazily constructs a collection from specified stream. collections iterator may be safely usedconcurrently by multiple threads.",
	"Method": "Collection<A> toConcurrentLazyCollection(Stream<A> stream,Collection<A> toConcurrentLazyCollection,Iterator<A> iterator){\r\n    return toLazyCollection(iterator, true);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.onesample.Lilliefors.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level.",
	"Method": "boolean test(FlatDataCollection flatDataCollection,String cdfMethod,double aLevel){\r\n    double[] doubleArray = flatDataCollection.stream().filter(x -> x != null).mapToDouble(TypeInference::toDouble).toArray();\r\n    int n = doubleArray.length;\r\n    if (n <= 0) {\r\n        throw new IllegalArgumentException(\"The provided collection can't be empty.\");\r\n    }\r\n    Arrays.sort(doubleArray);\r\n    double observedProbabilityIminus1 = 0;\r\n    double maxDelta = 0;\r\n    int rank = 1;\r\n    try {\r\n        Method method;\r\n        method = Lilliefors.class.getMethod(cdfMethod + \"GetParams\", FlatDataCollection.class);\r\n        AssociativeArray params = (AssociativeArray) method.invoke(null, flatDataCollection);\r\n        method = Lilliefors.class.getMethod(cdfMethod, Double.class, AssociativeArray.class);\r\n        for (int i = 0; i < doubleArray.length; ++i) {\r\n            double x = doubleArray[i];\r\n            double observedProbabilityI = (double) rank / n;\r\n            Object methodResult = method.invoke(null, x, params);\r\n            double expectedProbabilityI = TypeInference.toDouble(methodResult);\r\n            double delta = Math.max(Math.abs(expectedProbabilityI - observedProbabilityI), Math.abs(expectedProbabilityI - observedProbabilityIminus1));\r\n            if (delta >= maxDelta) {\r\n                maxDelta = delta;\r\n            }\r\n            observedProbabilityIminus1 = observedProbabilityI;\r\n            ++rank;\r\n        }\r\n        boolean rejectH0 = checkCriticalValue(maxDelta, n, aLevel);\r\n        return rejectH0;\r\n    } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {\r\n        throw new IllegalArgumentException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.takeUntil",
	"Comment": "return a stream with the same values, but will stop emitting values once the provided stream starts to emit values.e.g. if the provided stream is asynchronously refreshing state from some remote store, this stream can proceed untilthe provided stream succeeds in retrieving data.",
	"Method": "ReactiveSeq<U> takeUntil(SimpleReactStream<T> s){\r\n    return EagerFutureStreamFunctions.takeUntil(this, s);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.LinkedListX.rangeLong",
	"Comment": "create a linkedlistx that contains the longs between skip and take",
	"Method": "LinkedListX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).linkedListX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.extractors.UniqueWordSequenceExtractor.extract",
	"Comment": "this method gets as input a string and returns as output a numbered sequenceof the unique tokens. in the returned map as keys we store the position of the wordin the original string and as value the actual unique token in that position.note that the sequence includes only the position of the first occurrence ofeach word while the next occurrences are ignored.",
	"Method": "Map<Integer, String> extract(String text){\r\n    Set<String> tmpKwd = new LinkedHashSet(generateTokenizer().tokenize(text));\r\n    Map<Integer, String> keywordSequence = new LinkedHashMap();\r\n    int position = 0;\r\n    for (String keyword : tmpKwd) {\r\n        keywordSequence.put(position, keyword);\r\n        ++position;\r\n    }\r\n    return keywordSequence;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.SimpleRandomSampling.minimumSampleSizeForGivenDandMaximumRisk",
	"Comment": "returns the minimum required sample size when we set a predefined limit d and a maximum probability risk a for finite population size",
	"Method": "int minimumSampleSizeForGivenDandMaximumRisk(double d,double aLevel,double populationStd,int minimumSampleSizeForGivenDandMaximumRisk,double d,double aLevel,double populationStd,int populationN){\r\n    if (populationN <= 0 || aLevel <= 0 || d <= 0) {\r\n        throw new IllegalArgumentException(\"All the parameters must be positive.\");\r\n    }\r\n    double a = 1.0 - aLevel / 2.0;\r\n    double Za = ContinuousDistributions.gaussInverseCdf(a);\r\n    double V = Math.pow(d / Za, 2);\r\n    double Ssquare = populationStd * populationStd;\r\n    double minimumSampleN = (Ssquare / V) * (1.0 / (1.0 + Ssquare / (populationN * V)));\r\n    return (int) Math.ceil(minimumSampleN);\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.DiffXFitWesyma.setupMatrix",
	"Comment": "determines the most appropriate matrix to use.calculates the maximum length of the shortest weighted path if both sequencesare totally different, which corresponds to the sum of all the events.",
	"Method": "Matrix setupMatrix(EventSequence s1,EventSequence s2){\r\n    int max = 0;\r\n    for (int i = 0; i < s1.size(); i++) {\r\n        max += s1.getEvent(i).getWeight();\r\n    }\r\n    for (int i = 0; i < s2.size(); i++) {\r\n        max += s2.getEvent(i).getWeight();\r\n    }\r\n    if (max > Short.MAX_VALUE)\r\n        return new MatrixInt();\r\n    else\r\n        return new MatrixShort();\r\n}"
}, {
	"Path": "com.datumbox.framework.tests.utilities.TestUtils.assetDoubleAssociativeArray",
	"Comment": "assert method for associativearray data structure which stores double values.",
	"Method": "void assetDoubleAssociativeArray(AssociativeArray expResult,AssociativeArray result){\r\n    for (Object key : result.keySet()) {\r\n        double v1 = expResult.getDouble(key);\r\n        double v2 = result.getDouble(key);\r\n        assertEquals(v1, v2, Constants.DOUBLE_ACCURACY_HIGH);\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.survival.nonparametrics.independentsamples.CoxMantel.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level.",
	"Method": "boolean test(TransposeDataCollection transposeDataCollection,boolean is_twoTailed,double aLevel){\r\n    double pvalue = getPvalue(transposeDataCollection);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2;\r\n    }\r\n    if (pvalue <= a || pvalue >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "co.paralleluniverse.capsule.Jar.setListAttribute",
	"Comment": "sets an attribute in the main section of the manifest to a list.the list elements will be joined with a single whitespace character.",
	"Method": "Jar setListAttribute(String name,Collection<?> values,Jar setListAttribute,String section,String name,Collection<?> values){\r\n    return setAttribute(section, name, join(values));\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.onesample.LjungBox.checkCriticalValue",
	"Comment": "checks the critical value to determine if the hypothesis should be rejected",
	"Method": "boolean checkCriticalValue(double score,int h,double aLevel,boolean checkCriticalValue,double score,int h,double aLevel,int p,int q){\r\n    double probability = ContinuousDistributions.chisquareCdf(score, h - p - q);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (probability >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "cyclops.futurestream.FutureStream.control",
	"Comment": "allows clients to control the emission of data for the next phase of thestream. the user specified function can delay, drop, or change elements",
	"Method": "FutureStream<U> control(Function<Supplier<U>, Supplier<U>> fn){\r\n    final Queue queue = toQueue();\r\n    return fromStream(queue.streamControl(getSubscription(), fn));\r\n}"
}, {
	"Path": "cyclops.monads.transformers.jdk.OptionalT.fromAnyM",
	"Comment": "construct an optionalwt from an anym that contains a monad type that contains type other than optionalthe values in the underlying monad will be mapped to optional",
	"Method": "OptionalT<W, A> fromAnyM(AnyM<W, A> anyM){\r\n    return of(anyM.map(Optional::ofNullable));\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.parsers.HTMLParser.extractMetatags",
	"Comment": "extracts the meta tags from an html page and returns them in a map.",
	"Method": "Map<String, String> extractMetatags(String html){\r\n    Map<String, String> metatagsMap = new HashMap();\r\n    Matcher m = METATAG_PATTERN.matcher(html);\r\n    while (m.find()) {\r\n        if (m.groupCount() == 2) {\r\n            String name = m.group(1);\r\n            String content = m.group(2);\r\n            metatagsMap.put(clear(name), clear(content));\r\n        }\r\n    }\r\n    return metatagsMap;\r\n}"
}, {
	"Path": "cyclops.monads.transformers.EitherT.fromAnyM",
	"Comment": "construct an maybewt from an anym that contains a monad type that contains type other than maybethe values in the underlying monad will be mapped to maybe",
	"Method": "EitherT<W, ST, A> fromAnyM(AnyM<W, A> anyM){\r\n    return of(anyM.map(Either::right));\r\n}"
}, {
	"Path": "cyclops.companion.rx2.Singles.combine",
	"Comment": "lazily combine this single with the supplied single via the supplied bifunction",
	"Method": "Single<R> combine(Single<? extends T1> single,Value<? extends T2> app,BiFunction<? super T1, ? super T2, ? extends R> fn,Single<R> combine,Single<? extends T1> single,Single<? extends T2> app,BiFunction<? super T1, ? super T2, ? extends R> fn){\r\n    return Single.fromPublisher(Future.fromPublisher(single.toFlowable()).zip(Future.fromPublisher(app.toFlowable()), fn));\r\n}"
}, {
	"Path": "com.datumbox.framework.core.mathematics.linearprogramming.DataEnvelopmentAnalysisTest.testEstimateEfficiency",
	"Comment": "test of estimateefficiency method, of class dataenvelopmentanalysis.",
	"Method": "void testEstimateEfficiency(){\r\n    logger.info(\"estimateEfficiency\");\r\n    Map<Object, DataEnvelopmentAnalysis.DeaRecord> id2DeaRecordMapInput = new LinkedHashMap();\r\n    id2DeaRecordMapInput.put(\"Depot1\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(40.0, 55.0, 30.0)), new FlatDataList(Arrays.asList(3.0, 5.0))));\r\n    id2DeaRecordMapInput.put(\"Depot2\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(45.0, 50.0, 40.0)), new FlatDataList(Arrays.asList(2.5, 4.5))));\r\n    id2DeaRecordMapInput.put(\"Depot3\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(55.0, 45.0, 30.0)), new FlatDataList(Arrays.asList(4.0, 6.0))));\r\n    id2DeaRecordMapInput.put(\"Depot4\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(48.0, 20.0, 60.0)), new FlatDataList(Arrays.asList(6.0, 7.0))));\r\n    id2DeaRecordMapInput.put(\"Depot5\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(28.0, 50.0, 25.0)), new FlatDataList(Arrays.asList(2.3, 3.5))));\r\n    id2DeaRecordMapInput.put(\"Depot6\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(48.0, 20.0, 65.0)), new FlatDataList(Arrays.asList(4.0, 6.5))));\r\n    id2DeaRecordMapInput.put(\"Depot7\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(80.0, 65.0, 57.0)), new FlatDataList(Arrays.asList(7.0, 10.0))));\r\n    id2DeaRecordMapInput.put(\"Depot8\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(25.0, 48.0, 30.0)), new FlatDataList(Arrays.asList(4.4, 6.4))));\r\n    id2DeaRecordMapInput.put(\"Depot9\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(45.0, 64.0, 42.0)), new FlatDataList(Arrays.asList(3.0, 5.0))));\r\n    id2DeaRecordMapInput.put(\"Depot10\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(70.0, 65.0, 48.0)), new FlatDataList(Arrays.asList(5.0, 7.0))));\r\n    id2DeaRecordMapInput.put(\"Depot11\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(45.0, 65.0, 40.0)), new FlatDataList(Arrays.asList(5.0, 7.0))));\r\n    id2DeaRecordMapInput.put(\"Depot12\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(45.0, 40.0, 44.0)), new FlatDataList(Arrays.asList(2.0, 4.0))));\r\n    id2DeaRecordMapInput.put(\"Depot13\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(65.0, 25.0, 35.0)), new FlatDataList(Arrays.asList(5.0, 7.0))));\r\n    id2DeaRecordMapInput.put(\"Depot14\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(38.0, 18.0, 64.0)), new FlatDataList(Arrays.asList(4.0, 4.0))));\r\n    id2DeaRecordMapInput.put(\"Depot15\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(20.0, 50.0, 15.0)), new FlatDataList(Arrays.asList(2.0, 3.0))));\r\n    id2DeaRecordMapInput.put(\"Depot16\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(38.0, 20.0, 60.0)), new FlatDataList(Arrays.asList(3.0, 6.0))));\r\n    id2DeaRecordMapInput.put(\"Depot17\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(68.0, 64.0, 54.0)), new FlatDataList(Arrays.asList(7.0, 11.0))));\r\n    id2DeaRecordMapInput.put(\"Depot18\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(25.0, 38.0, 20.0)), new FlatDataList(Arrays.asList(4.0, 6.0))));\r\n    id2DeaRecordMapInput.put(\"Depot19\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(45.0, 67.0, 32.0)), new FlatDataList(Arrays.asList(3.0, 4.0))));\r\n    id2DeaRecordMapInput.put(\"Depot20\", new DataEnvelopmentAnalysis.DeaRecord(new FlatDataList(Arrays.asList(57.0, 60.0, 40.0)), new FlatDataList(Arrays.asList(5.0, 6.0))));\r\n    Map<Object, DataEnvelopmentAnalysis.DeaRecord> id2DeaRecordMapOutput = new LinkedHashMap(id2DeaRecordMapInput);\r\n    DataEnvelopmentAnalysis instance = new DataEnvelopmentAnalysis();\r\n    AssociativeArray expResult = new AssociativeArray();\r\n    expResult.put(\"Depot1\", 0.82038345105954);\r\n    expResult.put(\"Depot2\", 0.94174174174174);\r\n    expResult.put(\"Depot3\", 0.81481481481481);\r\n    expResult.put(\"Depot4\", 0.65279091769158);\r\n    expResult.put(\"Depot5\", 0.94655825212588);\r\n    expResult.put(\"Depot6\", 0.82278481012658);\r\n    expResult.put(\"Depot7\", 0.71111111111111);\r\n    expResult.put(\"Depot8\", 0.51685181698362);\r\n    expResult.put(\"Depot9\", 0.96344285053216);\r\n    expResult.put(\"Depot10\", 0.88888888888889);\r\n    expResult.put(\"Depot11\", 0.63128611170554);\r\n    expResult.put(\"Depot12\", 1);\r\n    expResult.put(\"Depot13\", 0.82539682539683);\r\n    expResult.put(\"Depot14\", 1);\r\n    expResult.put(\"Depot15\", 1);\r\n    expResult.put(\"Depot16\", 0.90909090909091);\r\n    expResult.put(\"Depot17\", 0.54949494949495);\r\n    expResult.put(\"Depot18\", 0.42007168458781);\r\n    expResult.put(\"Depot19\", 1);\r\n    expResult.put(\"Depot20\", 0.84444444444444);\r\n    AssociativeArray result = instance.estimateEfficiency(id2DeaRecordMapInput, id2DeaRecordMapOutput);\r\n    TestUtils.assetDoubleAssociativeArray(expResult, result);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.onesample.StudentsOneSampleTest.testTestAutocorrelation",
	"Comment": "test of testautocorrelation method, of class studentsonesample.",
	"Method": "void testTestAutocorrelation(){\r\n    logger.info(\"testAutocorrelation\");\r\n    double pk = 0.2;\r\n    int n = 50;\r\n    boolean is_twoTailed = false;\r\n    double aLevel = 0.05;\r\n    boolean expResult = false;\r\n    boolean result = StudentsOneSample.testAutocorrelation(pk, n, is_twoTailed, aLevel);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.storage.abstracts.AbstractFileStorageEngine.deleteDirectory",
	"Comment": "deletes a directory and optionally removes the parent directory if it becomes empty.",
	"Method": "boolean deleteDirectory(Path path,boolean cleanParent){\r\n    boolean pathExists = deleteIfExistsRecursively(path);\r\n    if (pathExists && cleanParent) {\r\n        cleanEmptyParentDirectory(path.getParent());\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.http.impl.io.ChunkedInputStream.close",
	"Comment": "upon close, this reads the remainder of the chunked message,leaving the underlying socket at a position to start reading thenext response without scanning.",
	"Method": "void close(){\r\n    if (!closed) {\r\n        try {\r\n            if (!eof && state != CHUNK_INVALID) {\r\n                final byte[] buff = new byte[BUFFER_SIZE];\r\n                try {\r\n                    while (read(buff) >= 0) {\r\n                        continue;\r\n                    }\r\n                } catch (ConnectionClosedException e) {\r\n                } catch (TruncatedChunkException e) {\r\n                }\r\n            }\r\n        } finally {\r\n            eof = true;\r\n            closed = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.DiscreteDistributionsTest.testGeometricCdf",
	"Comment": "test of geometriccdf method, of class discretedistributions.",
	"Method": "void testGeometricCdf(){\r\n    logger.info(\"GeometricCdf\");\r\n    int k = 3;\r\n    double p = 0.5;\r\n    double expResult = 0.875;\r\n    double result = DiscreteDistributions.geometricCdf(k, p);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "org.jak_linux.dns66.db.RuleDatabaseItemUpdateRunnable.run",
	"Comment": "runs the item download, and marks it as done when finished.getlocalizedmessage",
	"Method": "void run(){\r\n    try {\r\n        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);\r\n    } catch (UnsatisfiedLinkError e) {\r\n    } catch (RuntimeException e) {\r\n        if (!e.toString().contains(\"not mocked\"))\r\n            throw e;\r\n    }\r\n    if (item.location.startsWith(\"content:/\")) {\r\n        try {\r\n            Uri uri = parseUri(item.location);\r\n            context.getContentResolver().takePersistableUriPermission(uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\r\n            context.getContentResolver().openInputStream(uri).close();\r\n            Log.d(TAG, \"run: Permission requested for \" + item.location);\r\n        } catch (SecurityException e) {\r\n            Log.d(TAG, \"doInBackground: Error taking permission: \", e);\r\n            parentTask.addError(item, context.getString(R.string.permission_denied));\r\n        } catch (FileNotFoundException e) {\r\n            parentTask.addError(item, context.getString(R.string.file_not_found));\r\n        } catch (IOException e) {\r\n            parentTask.addError(item, context.getString(R.string.unknown_error_s, e.getLocalizedMessage()));\r\n        }\r\n        return;\r\n    }\r\n    SingleWriterMultipleReaderFile singleWriterMultipleReaderFile = new SingleWriterMultipleReaderFile(file);\r\n    HttpURLConnection connection = null;\r\n    parentTask.addBegin(item);\r\n    try {\r\n        connection = getHttpURLConnection(file, singleWriterMultipleReaderFile, url);\r\n        if (!validateResponse(connection))\r\n            return;\r\n        downloadFile(file, singleWriterMultipleReaderFile, connection);\r\n    } catch (SocketTimeoutException e) {\r\n        parentTask.addError(item, context.getString(R.string.requested_timed_out));\r\n    } catch (IOException e) {\r\n        parentTask.addError(item, context.getString(R.string.unknown_error_s, e.toString()));\r\n    } finally {\r\n        parentTask.addDone(item);\r\n        if (connection != null)\r\n            connection.disconnect();\r\n    }\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.fastzipfilereader.FastZipEntry.load",
	"Comment": "load the content of the zip entry, and return it as a byte array.",
	"Method": "byte[] load(LogNode log){\r\n    try (InputStream is = open()) {\r\n        return FileUtils.readAllBytesAsArray(is, uncompressedSize);\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.FlatDataList.add",
	"Comment": "appends the specified element to the end of the internal list.",
	"Method": "boolean add(Object e){\r\n    return internalData.add(e);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachEvent",
	"Comment": "perform a foreach operation over the streamcapturing any elements and errors in the supplied consumerswhen the entire stream has been processed an oncomplete event will be recieved.",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachEvent(FutureStream<T> stream,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError,Runnable onComplete){\r\n    final CompletableFuture<Subscription> subscription = new CompletableFuture();\r\n    final CompletableFuture<Boolean> streamCompleted = new CompletableFuture();\r\n    return tuple(subscription, () -> {\r\n        stream.subscribe(new Subscriber<T>() {\r\n            @Override\r\n            public void onSubscribe(final Subscription s) {\r\n                Objects.requireNonNull(s);\r\n                subscription.complete(s);\r\n                s.request(Long.MAX_VALUE);\r\n            }\r\n            @Override\r\n            public void onNext(final T t) {\r\n                consumerElement.accept(t);\r\n            }\r\n            @Override\r\n            public void onError(final Throwable t) {\r\n                consumerError.accept(t);\r\n            }\r\n            @Override\r\n            public void onComplete() {\r\n                streamCompleted.complete(true);\r\n                onComplete.run();\r\n            }\r\n        });\r\n    }, streamCompleted);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachEvent",
	"Comment": "perform a foreach operation over the streamcapturing any elements and errors in the supplied consumerswhen the entire stream has been processed an oncomplete event will be recieved.",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachEvent(FutureStream<T> stream,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError,Runnable onComplete){\r\n    Objects.requireNonNull(s);\r\n    subscription.complete(s);\r\n    s.request(Long.MAX_VALUE);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachEvent",
	"Comment": "perform a foreach operation over the streamcapturing any elements and errors in the supplied consumerswhen the entire stream has been processed an oncomplete event will be recieved.",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachEvent(FutureStream<T> stream,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError,Runnable onComplete){\r\n    consumerElement.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachEvent",
	"Comment": "perform a foreach operation over the streamcapturing any elements and errors in the supplied consumerswhen the entire stream has been processed an oncomplete event will be recieved.",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachEvent(FutureStream<T> stream,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError,Runnable onComplete){\r\n    consumerError.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachEvent",
	"Comment": "perform a foreach operation over the streamcapturing any elements and errors in the supplied consumerswhen the entire stream has been processed an oncomplete event will be recieved.",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachEvent(FutureStream<T> stream,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError,Runnable onComplete){\r\n    streamCompleted.complete(true);\r\n    onComplete.run();\r\n}"
}, {
	"Path": "buildcraft.core.lib.utils.Utils.addToRandomInventoryAround",
	"Comment": "tries to add the passed stack to any valid inventories around the given coordinates.",
	"Method": "int addToRandomInventoryAround(World world,BlockPos pos,ItemStack stack){\r\n    Collections.shuffle(directions);\r\n    for (EnumFacing orientation : directions) {\r\n        BlockPos newpos = pos.offset(orientation);\r\n        TileEntity tile = world.getTileEntity(newpos);\r\n        ITransactor transactor = Transactor.getTransactorFor(tile, orientation.getOpposite());\r\n        if (transactor != null && !(tile instanceof IEngine) && transactor.insert(stack, false).stackSize > 0) {\r\n            return transactor.insert(stack, true).stackSize;\r\n        }\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "io.github.classgraph.AnnotationInfo.getClassNamesFromTypeDescriptors",
	"Comment": "get the names of any classes referenced in the type descriptors of annotation parameters.",
	"Method": "void getClassNamesFromTypeDescriptors(Set<String> classNames){\r\n    classNames.add(name);\r\n    if (annotationParamValues != null) {\r\n        for (final AnnotationParameterValue annotationParamValue : annotationParamValues) {\r\n            annotationParamValue.getClassNamesFromTypeDescriptors(classNames);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.github.classgraph.ClassRefTypeSignature.getSuffixTypeArguments",
	"Comment": "get any type arguments for any suffixes of the class, one list per suffix.",
	"Method": "List<List<TypeArgument>> getSuffixTypeArguments(){\r\n    return suffixTypeArguments;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.BagX.fill",
	"Comment": "generate a bagx from the provided value up to the provided limit number of times",
	"Method": "BagX<T> fill(long limit,T s){\r\n    return ReactiveSeq.fill(s).limit(limit).to(ReactiveConvertableSequence::converter).bagX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.mathematics.distances.Distance.euclideanWeighted",
	"Comment": "estimates the weighted euclidean distance of two associative arrays.",
	"Method": "double euclideanWeighted(AssociativeArray a1,AssociativeArray a2,Map<Object, Double> columnWeights){\r\n    Map<Object, Double> columnDistances = columnDistances(a1, a2, columnWeights.keySet());\r\n    double distance = 0.0;\r\n    for (Map.Entry<Object, Double> entry : columnDistances.entrySet()) {\r\n        double columnDistance = entry.getValue();\r\n        distance += (columnDistance * columnDistance) * columnWeights.get(entry.getKey());\r\n    }\r\n    return Math.sqrt(distance);\r\n}"
}, {
	"Path": "buildcraft.core.lib.gui.widgets.FluidTankWidget.withOverlay",
	"Comment": "adds an overlay for the tank from the specified location in the texture.",
	"Method": "FluidTankWidget withOverlay(int x,int y){\r\n    overlay = new GuiIcon(null, x, y, this.rectangle.width, this.rectangle.height);\r\n    return this;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.ensemblelearning.FixedCombinationRules.sum",
	"Comment": "combines the responses of the classifiers by using estimating the sumof the probabilities of their responses.",
	"Method": "AssociativeArray sum(DataTable2D classifierClassProbabilityMatrix){\r\n    AssociativeArray combinedClassProbabilities = new AssociativeArray();\r\n    for (Map.Entry<Object, AssociativeArray> entry : classifierClassProbabilityMatrix.entrySet()) {\r\n        AssociativeArray listOfClassProbabilities = entry.getValue();\r\n        for (Map.Entry<Object, Object> entry2 : listOfClassProbabilities.entrySet()) {\r\n            Object theClass = entry2.getKey();\r\n            Double probability = TypeInference.toDouble(entry2.getValue());\r\n            Double previousValue = combinedClassProbabilities.getDouble(theClass);\r\n            if (previousValue == null) {\r\n                previousValue = 0.0;\r\n            }\r\n            combinedClassProbabilities.put(theClass, previousValue + probability);\r\n        }\r\n    }\r\n    return combinedClassProbabilities;\r\n}"
}, {
	"Path": "co.paralleluniverse.capsule.Jar.setReallyExecutable",
	"Comment": "if set to true true, a header will be added to the jar file when written, that will make the jar an executable file in posix environments.",
	"Method": "Jar setReallyExecutable(boolean value){\r\n    setJarPrefix(value ? \"#!/bin/sh\\n\\nexec java -jar $0 \\\"$@\\\"\\n\" : null);\r\n    return this;\r\n}"
}, {
	"Path": "cyclops.control.LazyEither3.traverse",
	"Comment": "traverse a collection of either3 producing an either3 with a seq, applying the transformation function to everyelement in the list",
	"Method": "LazyEither3<L1, L2, ReactiveSeq<R>> traverse(Function<? super T, ? extends R> fn,ReactiveSeq<LazyEither3<L1, L2, T>> stream,LazyEither3<LT1, LT2, ReactiveSeq<R>> traverse,Iterable<LazyEither3<LT1, LT2, PT>> xors,Function<? super PT, ? extends R> fn){\r\n    return sequence(xors).map(l -> l.map(fn));\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.OrderedSetX.rangeLong",
	"Comment": "create a orderedsetx that contains the longs between skip and take",
	"Method": "OrderedSetX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).orderedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.github.classgraph.Scanner.findNestedClasspathElements",
	"Comment": "find classpath elements whose path is a prefix of another classpath element, and record the nesting.",
	"Method": "void findNestedClasspathElements(List<SimpleEntry<String, ClasspathElement>> classpathElts,LogNode log){\r\n    Collections.sort(classpathElts, new Comparator<SimpleEntry<String, ClasspathElement>>() {\r\n        @Override\r\n        public int compare(final SimpleEntry<String, ClasspathElement> o1, final SimpleEntry<String, ClasspathElement> o2) {\r\n            return o1.getKey().compareTo(o2.getKey());\r\n        }\r\n    });\r\n    LogNode nestedClasspathRootNode = null;\r\n    for (int i = 0; i < classpathElts.size(); i++) {\r\n        final SimpleEntry<String, ClasspathElement> ei = classpathElts.get(i);\r\n        final String basePath = ei.getKey();\r\n        final int basePathLen = basePath.length();\r\n        for (int j = i + 1; j < classpathElts.size(); j++) {\r\n            final SimpleEntry<String, ClasspathElement> ej = classpathElts.get(j);\r\n            final String comparePath = ej.getKey();\r\n            final int comparePathLen = comparePath.length();\r\n            boolean foundNestedClasspathRoot = false;\r\n            if (comparePath.startsWith(basePath) && comparePathLen > basePathLen) {\r\n                final char nextChar = comparePath.charAt(basePathLen);\r\n                if (nextChar == '/' || nextChar == '!') {\r\n                    final String nestedClasspathRelativePath = comparePath.substring(basePathLen + 1);\r\n                    if (nestedClasspathRelativePath.indexOf('!') < 0) {\r\n                        foundNestedClasspathRoot = true;\r\n                        final ClasspathElement baseElement = ei.getValue();\r\n                        if (baseElement.nestedClasspathRootPrefixes == null) {\r\n                            baseElement.nestedClasspathRootPrefixes = new ArrayList();\r\n                        }\r\n                        baseElement.nestedClasspathRootPrefixes.add(nestedClasspathRelativePath + \"/\");\r\n                        if (log != null) {\r\n                            if (nestedClasspathRootNode == null) {\r\n                                nestedClasspathRootNode = log.log(\"Found nested classpath elements\");\r\n                            }\r\n                            nestedClasspathRootNode.log(basePath + \" is a prefix of the nested element \" + comparePath);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!foundNestedClasspathRoot) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.github.classgraph.Scanner.findNestedClasspathElements",
	"Comment": "find classpath elements whose path is a prefix of another classpath element, and record the nesting.",
	"Method": "void findNestedClasspathElements(List<SimpleEntry<String, ClasspathElement>> classpathElts,LogNode log){\r\n    return o1.getKey().compareTo(o2.getKey());\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.parametrics.onesample.ChisquareOneSample.checkCriticalValue",
	"Comment": "checks the critical value to determine if the hypothesis should be rejected",
	"Method": "boolean checkCriticalValue(double score,int n,boolean is_twoTailed,double aLevel){\r\n    double probability = ContinuousDistributions.chisquareCdf(score, n - 1);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2.0;\r\n    }\r\n    if (probability <= a || probability >= (1.0 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "io.github.classgraph.ClassGraph.scan",
	"Comment": "scans the classpath with the requested number of threads, blocking until the scan is complete.",
	"Method": "ScanResult scan(ExecutorService executorService,int numParallelTasks,ScanResult scan,int numThreads,ScanResult scan){\r\n    return scan(DEFAULT_NUM_WORKER_THREADS);\r\n}"
}, {
	"Path": "buildcraft.core.lib.inventory.InvUtils.moveOneItem",
	"Comment": "attempts to move a single item from one inventory to another.",
	"Method": "ItemStack moveOneItem(IInventory source,EnumFacing output,IInventory dest,EnumFacing input,IStackFilter filter){\r\n    ITransactor imSource = Transactor.getTransactorFor(source, output);\r\n    ItemStack stack = imSource.remove(filter, false);\r\n    if (stack != null) {\r\n        ITransactor imDest = Transactor.getTransactorFor(dest, input);\r\n        int moved = imDest.addNew(stack, true).stackSize;\r\n        if (moved > 0) {\r\n            imSource.remove(filter, true);\r\n            return stack;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.decisiontheory.DecisionCriteria.savage",
	"Comment": "returns the best option and the payoff under savage strategy",
	"Method": "Map.Entry<Object, Object> savage(DataTable2D payoffMatrix){\r\n    if (payoffMatrix.isValid() == false) {\r\n        throw new IllegalArgumentException(\"The payoff matrix does not have a rectangular format.\");\r\n    }\r\n    DataTable2D regretMatrix = new DataTable2D();\r\n    for (Map.Entry<Object, AssociativeArray> entry : payoffMatrix.entrySet()) {\r\n        Object event = entry.getKey();\r\n        AssociativeArray optionList = entry.getValue();\r\n        double maxI = Descriptives.max(optionList.toFlatDataCollection());\r\n        for (Map.Entry<Object, Object> entry2 : optionList.entrySet()) {\r\n            Object option = entry2.getKey();\r\n            Double payoff = TypeInference.toDouble(entry2.getValue());\r\n            regretMatrix.put2d(event, option, payoff - maxI);\r\n        }\r\n    }\r\n    return maxMin(regretMatrix);\r\n}"
}, {
	"Path": "io.github.classgraph.MethodInfo.compareTo",
	"Comment": "sort in order of class name, method name, then type descriptor.",
	"Method": "int compareTo(MethodInfo other){\r\n    final int diff0 = declaringClassName.compareTo(other.declaringClassName);\r\n    if (diff0 != 0) {\r\n        return diff0;\r\n    }\r\n    final int diff1 = name.compareTo(other.name);\r\n    if (diff1 != 0) {\r\n        return diff1;\r\n    }\r\n    return typeDescriptorStr.compareTo(other.typeDescriptorStr);\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.fastzipfilereader.FastZipEntry.compareTo",
	"Comment": "sort in decreasing order of version number, then lexicographically increasing order of unversioned entrypath.",
	"Method": "int compareTo(FastZipEntry o){\r\n    final int diff0 = o.version - this.version;\r\n    if (diff0 != 0) {\r\n        return diff0;\r\n    }\r\n    final int diff1 = entryNameUnversioned.compareTo(o.entryNameUnversioned);\r\n    if (diff1 != 0) {\r\n        return diff1;\r\n    }\r\n    final int diff2 = entryName.compareTo(o.entryName);\r\n    if (diff2 != 0) {\r\n        return diff2;\r\n    }\r\n    final long diff3 = locHeaderPos - o.locHeaderPos;\r\n    return diff3 < 0L ? -1 : diff3 > 0L ? 1 : 0;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.decisiontheory.DecisionCriteria.maxMax",
	"Comment": "returns the best option and the payoff under maxmax strategy",
	"Method": "Map.Entry<Object, Object> maxMax(DataTable2D payoffMatrix){\r\n    if (payoffMatrix.isValid() == false) {\r\n        throw new IllegalArgumentException(\"The payoff matrix does not have a rectangular format.\");\r\n    }\r\n    Double maxMaxPayoff = Double.NEGATIVE_INFINITY;\r\n    Object maxMaxPayoffOption = null;\r\n    for (Map.Entry<Object, AssociativeArray> entry : payoffMatrix.entrySet()) {\r\n        AssociativeArray optionList = entry.getValue();\r\n        for (Map.Entry<Object, Object> entry2 : optionList.entrySet()) {\r\n            Double payoff = TypeInference.toDouble(entry2.getValue());\r\n            if (payoff > maxMaxPayoff) {\r\n                maxMaxPayoff = payoff;\r\n                maxMaxPayoffOption = entry2.getKey();\r\n            }\r\n        }\r\n    }\r\n    return new AbstractMap.SimpleEntry(maxMaxPayoffOption, maxMaxPayoff);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentSetX.range",
	"Comment": "create a persistentsetx that contains the integers between skip and take",
	"Method": "PersistentSetX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).persistentSetX(LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.ReadabilityStatisticsTest.testDale_chall_score",
	"Comment": "test of dalechallscore method, of class readabilitystatistics.",
	"Method": "void testDale_chall_score(){\r\n    logger.info(\"dale_chall_score\");\r\n    String strText = TEST_STRING;\r\n    double expResult = 20.486603754266213;\r\n    double result = ReadabilityStatistics.daleChallScore(strText);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "cyclops.futurestream.Pipes.publishTo",
	"Comment": "synchronously publish data to the adapter specified by the provided key, blocking the current thread",
	"Method": "void publishTo(K key,Publisher<V> publisher){\r\n    registered.get(key).fromStream(Spouts.from(publisher));\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AssociativeArray.overwrite",
	"Comment": "overwrites the contents of the internal data of this object with the onesof the provided map.",
	"Method": "void overwrite(Map<Object, Object> data){\r\n    internalData.clear();\r\n    internalData.putAll(data);\r\n}"
}, {
	"Path": "org.jak_linux.dns66.db.RuleDatabaseUpdateTask.isGarbage",
	"Comment": "returns whether uri is no longer referenced in the configuration",
	"Method": "boolean isGarbage(Uri uri){\r\n    for (Configuration.Item item : configuration.hosts.items) {\r\n        if (Uri.parse(item.location).equals(uri))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.anova.Anova.oneWayTestEqualVars",
	"Comment": "wrapper function for onewaytestequalvars, without passing the optionaloutput table.",
	"Method": "boolean oneWayTestEqualVars(TransposeDataCollection transposeDataCollection,double aLevel,AssociativeArray2D outputTable,boolean oneWayTestEqualVars,TransposeDataCollection transposeDataCollection,double aLevel){\r\n    return oneWayTestEqualVars(transposeDataCollection, aLevel, null);\r\n}"
}, {
	"Path": "cyclops.data.ImmutableMap.toSeq",
	"Comment": "convert this mapx to a seq via the provided transformation function",
	"Method": "Seq<T> toSeq(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn){\r\n    return Seq.narrow(stream().map(fn).seq());\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.json.TypeResolutions.resolveTypeVariables",
	"Comment": "resolve the type variables in a type using a type variable resolution list, producing a resolved type.",
	"Method": "Type resolveTypeVariables(Type type){\r\n    if (type instanceof Class<?>) {\r\n        return type;\r\n    } else if (type instanceof ParameterizedType) {\r\n        final ParameterizedType parameterizedType = (ParameterizedType) type;\r\n        final Type[] typeArgs = parameterizedType.getActualTypeArguments();\r\n        Type[] typeArgsResolved = null;\r\n        for (int i = 0; i < typeArgs.length; i++) {\r\n            final Type typeArgResolved = resolveTypeVariables(typeArgs[i]);\r\n            if (typeArgsResolved == null) {\r\n                if (!typeArgResolved.equals(typeArgs[i])) {\r\n                    typeArgsResolved = new Type[typeArgs.length];\r\n                    System.arraycopy(typeArgs, 0, typeArgsResolved, 0, i);\r\n                    typeArgsResolved[i] = typeArgResolved;\r\n                }\r\n            } else {\r\n                typeArgsResolved[i] = typeArgResolved;\r\n            }\r\n        }\r\n        if (typeArgsResolved == null) {\r\n            return type;\r\n        } else {\r\n            return new ParameterizedTypeImpl((Class<?>) parameterizedType.getRawType(), typeArgsResolved, parameterizedType.getOwnerType());\r\n        }\r\n    } else if (type instanceof TypeVariable<?>) {\r\n        final TypeVariable<?> typeVariable = (TypeVariable<?>) type;\r\n        for (int i = 0; i < typeVariables.length; i++) {\r\n            if (typeVariables[i].getName().equals(typeVariable.getName())) {\r\n                return resolvedTypeArguments[i];\r\n            }\r\n        }\r\n        return type;\r\n    } else if (type instanceof GenericArrayType) {\r\n        int numArrayDims = 0;\r\n        Type t = type;\r\n        while (t instanceof GenericArrayType) {\r\n            numArrayDims++;\r\n            t = ((GenericArrayType) t).getGenericComponentType();\r\n        }\r\n        final Type innermostType = t;\r\n        final Type innermostTypeResolved = resolveTypeVariables(innermostType);\r\n        if (!(innermostTypeResolved instanceof Class<?>)) {\r\n            throw new IllegalArgumentException(\"Could not resolve generic array type \" + type);\r\n        }\r\n        final Class<?> innermostTypeResolvedClass = (Class<?>) innermostTypeResolved;\r\n        final int[] dims = (int[]) Array.newInstance(int.class, numArrayDims);\r\n        final Object arrayInstance = Array.newInstance(innermostTypeResolvedClass, dims);\r\n        return arrayInstance.getClass();\r\n    } else if (type instanceof WildcardType) {\r\n        throw new RuntimeException(\"WildcardType not yet supported: \" + type);\r\n    } else {\r\n        throw new RuntimeException(\"Got unexpected type: \" + type);\r\n    }\r\n}"
}, {
	"Path": "io.github.classgraph.ClassGraph.filterClasspathElements",
	"Comment": "add a classpath element filter. the provided classpathelementfilter should return true if the path stringpassed to it is a path you want to scan.",
	"Method": "ClassGraph filterClasspathElements(ClasspathElementFilter classpathElementFilter){\r\n    scanSpec.filterClasspathElements(classpathElementFilter);\r\n    return this;\r\n}"
}, {
	"Path": "org.fourthline.cling.support.contentdirectory.DIDLParser.parse",
	"Comment": "reads and unmarshalls an xml representation into a didl content model.",
	"Method": "DIDLContent parse(String xml){\r\n    if (xml == null || xml.length() == 0) {\r\n        throw new RuntimeException(\"Null or empty XML\");\r\n    }\r\n    DIDLContent content = new DIDLContent();\r\n    createRootHandler(content, this);\r\n    log.fine(\"Parsing DIDL XML content\");\r\n    parse(new InputSource(new StringReader(xml)));\r\n    return content;\r\n}"
}, {
	"Path": "cyclops.futurestream.LazyReact.parallelBuilder",
	"Comment": "construct a new lazyreact builder, with a new task executor and retryexecutor with configured number of threads",
	"Method": "LazyReact parallelBuilder(LazyReact parallelBuilder,int parallelism){\r\n    return LazyReact.builder().executor(Executors.newFixedThreadPool(parallelism)).build();\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.SimpleRandomSampling.weightedSampling",
	"Comment": "samples n ids based on their a table which contains weights, probabilities or frequencies.",
	"Method": "FlatDataCollection weightedSampling(AssociativeArray weightedTable,int n,boolean withReplacement){\r\n    FlatDataList sampledIds = new FlatDataList();\r\n    double sumOfFrequencies = Descriptives.sum(weightedTable.toFlatDataCollection());\r\n    int populationN = weightedTable.size();\r\n    for (int i = 0; i < n; ++i) {\r\n        if (withReplacement == false && populationN <= n) {\r\n            break;\r\n        }\r\n        double randomFrequency = PHPMethods.mt_rand(0.0, sumOfFrequencies);\r\n        double cumulativeFrequency = 0;\r\n        for (Map.Entry<Object, Object> entry : weightedTable.entrySet()) {\r\n            Object pointID = entry.getKey();\r\n            cumulativeFrequency += TypeInference.toDouble(entry.getValue());\r\n            if (cumulativeFrequency >= randomFrequency) {\r\n                if (withReplacement == false && sampledIds.contains(pointID)) {\r\n                    continue;\r\n                }\r\n                sampledIds.add(pointID);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return sampledIds.toFlatDataCollection();\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.sampling.StratifiedSamplingTest.testXbarVariance",
	"Comment": "test of xbarvariance method, of class stratifiedsampling.",
	"Method": "void testXbarVariance(){\r\n    logger.info(\"xbarVariance\");\r\n    TransposeDataCollection sampleDataCollection = generateSampleDataCollection();\r\n    AssociativeArray nh = generateNh2();\r\n    AssociativeArray populationNh = generatePopulationNh();\r\n    double expResult = 0.17901234567;\r\n    double result = StratifiedSampling.xbarVariance(sampleDataCollection, nh, populationNh);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "buildcraft.core.lib.inventory.InvUtils.getInventory",
	"Comment": "ensures that the given inventory is the full inventory, i.e. takes double chests into account.",
	"Method": "IInventory getInventory(IInventory inv){\r\n    if (inv instanceof TileEntityChest) {\r\n        TileEntityChest adjacent = BlockUtil.getOtherDoubleChest((TileEntityChest) inv);\r\n        if (adjacent != null) {\r\n            return new InventoryLargeChest(\"\", (TileEntityChest) inv, adjacent);\r\n        }\r\n        return inv;\r\n    }\r\n    return inv;\r\n}"
}, {
	"Path": "io.github.classgraph.MethodInfo.getClassNamesFromTypeDescriptors",
	"Comment": "get the names of any classes in the type descriptor or type signature.",
	"Method": "void getClassNamesFromTypeDescriptors(Set<String> classNames){\r\n    final MethodTypeSignature methodSig = getTypeSignature();\r\n    if (methodSig != null) {\r\n        methodSig.getClassNamesFromTypeDescriptors(classNames);\r\n    }\r\n    final MethodTypeSignature methodDesc = getTypeDescriptor();\r\n    if (methodDesc != null) {\r\n        methodDesc.getClassNamesFromTypeDescriptors(classNames);\r\n    }\r\n    if (annotationInfo != null) {\r\n        for (final AnnotationInfo annotationInfo : annotationInfo) {\r\n            annotationInfo.getClassNamesFromTypeDescriptors(classNames);\r\n        }\r\n    }\r\n    for (final MethodParameterInfo parameterInfo : getParameterInfo()) {\r\n        final AnnotationInfo[] paramAnnotationInfo = parameterInfo.annotationInfo;\r\n        if (paramAnnotationInfo != null) {\r\n            for (final AnnotationInfo annotationInfo : paramAnnotationInfo) {\r\n                annotationInfo.getClassNamesFromTypeDescriptors(classNames);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.nonparametrics.onesample.SignOneSample.test",
	"Comment": "tests the rejection of null hypothesis for a particular confidence level",
	"Method": "boolean test(FlatDataCollection flatDataCollection,double median,boolean is_twoTailed,double aLevel){\r\n    double pvalue = getPvalue(flatDataCollection, median);\r\n    boolean rejectH0 = false;\r\n    double a = aLevel;\r\n    if (is_twoTailed) {\r\n        a = aLevel / 2.0;\r\n    }\r\n    if (pvalue <= a || pvalue >= (1 - a)) {\r\n        rejectH0 = true;\r\n    }\r\n    return rejectH0;\r\n}"
}, {
	"Path": "com.datumbox.framework.core.common.text.analyzers.TextSimilarityTest.testShinglerSimilarity",
	"Comment": "test of shinglersimilarity method, of class textsimilarity.",
	"Method": "void testShinglerSimilarity(){\r\n    logger.info(\"shinglerSimilarity\");\r\n    String text1 = \"This book has been written against a background of both reckless optimism and reckless despair. It holds that Progress and Doom are two sides of the same medal; that both are articles of superstition, not of faith. It was written out of the conviction that it should be possible to discover the hidden mechanics by which all traditional elements of our political and spiritual world were dissolved into a conglomeration where everything seems to have lost specific value, and has become unrecognizable for human comprehension, unusable for human purpose. Hannah Arendt, The Origins of Totalitarianism (New York: Harcourt Brace Jovanovich, Inc., 1973 ed.), p.vii, Preface to the First Edition.\";\r\n    String text2 = \"The first edition of The Origins of Totalitarianism was written in 1950. Soon after the Second World War, this was a time of both reckless optimism and reckless despair. During this time, Dr. Arendt argues, the traditional elements of the political and spiritual world were dissolved into a conglomeration where everything seems to have lost specific value. In particular, the separation between the State and Society seems to have been destroyed. In this book, she seeks to disclose the hidden mechanics by which this transformation occurred.\";\r\n    int w = 3;\r\n    double expResult = 0.15151515151515152;\r\n    double result = TextSimilarity.shinglerSimilarity(text1, text2, w);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.datumbox.framework.storage.mapdb.MapDBConfiguration.setCacheSize",
	"Comment": "setter for the size of items stored in lru cache by mapdb. set it to 0 toturn off caching.",
	"Method": "void setCacheSize(int cacheSize){\r\n    this.cacheSize = cacheSize;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.self",
	"Comment": "give a function access to the current stage of a simplereact stream",
	"Method": "SimpleReactStream<U> self(Consumer<SimpleReactStream<U>> consumer){\r\n    return peek(n -> consumer.accept(this));\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.common.abstracts.modelers.AbstractModeler.predict",
	"Comment": "calculates the predictions for the newdata and stores them in the provideddataframe.",
	"Method": "void predict(Dataframe newData){\r\n    logger.info(\"predict()\");\r\n    _predict(newData);\r\n}"
}, {
	"Path": "com.github.dcevm.test.util.HotSwapTestHelper.__toVersion__",
	"Comment": "redefines all inner classes of a outer class to a specified version. inner classes who do not have a particularrepresentation for a version remain unchanged.caller class is used as an outer class.",
	"Method": "void __toVersion__(int versionNumber,Class<?> extra){\r\n    HotSwapTool.toVersion(determineOuter(0), versionNumber, extra);\r\n}"
}, {
	"Path": "cyclops.control.Try.withCatch",
	"Comment": "try to execute supplied supplier and will catch specified excpetions or java.lang.exceptionif none specified.",
	"Method": "Try<T, X> withCatch(CheckedSupplier<T, X> cf,Class<? extends X> classes){\r\n    Objects.requireNonNull(cf);\r\n    try {\r\n        return Try.success(cf.get());\r\n    } catch (final Throwable t) {\r\n        if (classes.length == 0)\r\n            return Try.failure((X) t);\r\n        val error = Stream.of(classes).filter(c -> c.isAssignableFrom(t.getClass())).findFirst();\r\n        if (error.isPresent())\r\n            return Try.failure((X) t);\r\n        else\r\n            throw ExceptionSoftener.throwSoftenedException(t);\r\n    }\r\n}"
}, {
	"Path": "com.spotify.docker.client.exceptions.DockerRequestException.message",
	"Comment": "the response body from the http response containing an error, if any.",
	"Method": "String message(){\r\n    return responseBody;\r\n}"
}, {
	"Path": "com.datumbox.framework.common.storage.abstracts.AbstractFileStorageEngine.getDirectory",
	"Comment": "returns the location of the directory from the configuration or the temporary directory if not defined.",
	"Method": "String getDirectory(){\r\n    String directory = storageConfiguration.getDirectory();\r\n    if (directory == null || directory.isEmpty()) {\r\n        directory = System.getProperty(\"java.io.tmpdir\");\r\n    }\r\n    return directory;\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AbstractDataStructureCollection.toArray",
	"Comment": "returns a copy of the internal data as an array. note that this methodcopies the data, so its use must be avoided.",
	"Method": "Object[] toArray(){\r\n    return internalData.toArray();\r\n}"
}, {
	"Path": "com.topologi.diffx.algorithm.DiffXKumarRangan.printState",
	"Comment": "prints the state of this object, that is the values of all of the state variables tosystem.err. this is for debugging purposes only.",
	"Method": "void printState(int f){\r\n    if ((f & 0x0000001) == 0x0000001) {\r\n        System.err.println(\"  R=\" + this.R);\r\n    }\r\n    if ((f & 0x0000010) == 0x0000010) {\r\n        System.err.println(\"  S=\" + this.S);\r\n    }\r\n    if ((f & 0x0000011) > 0) {\r\n        System.err.println();\r\n    }\r\n    if ((f & 0x0000100) == 0x0000100) {\r\n        System.err.print(\" R1={\");\r\n        for (int element : this.R1) {\r\n            System.err.print(\" \" + element);\r\n        }\r\n        System.err.println(\" }\");\r\n    }\r\n    if ((f & 0x0001000) == 0x0001000) {\r\n        System.err.print(\" R2={\");\r\n        for (int element : this.R2) {\r\n            System.err.print(\" \" + element);\r\n        }\r\n        System.err.println(\" }\");\r\n    }\r\n    if ((f & 0x0010000) == 0x0010000) {\r\n        System.err.print(\" LL={\");\r\n        for (int element : this.LL) {\r\n            System.err.print(\" \" + element);\r\n        }\r\n        System.err.println(\" }\");\r\n    }\r\n    if ((f & 0x0100000) == 0x0100000) {\r\n        System.err.print(\" LL1={\");\r\n        for (int element : this.LL1) {\r\n            System.err.print(\" \" + element);\r\n        }\r\n        System.err.println(\" }\");\r\n    }\r\n    if ((f & 0x1000000) == 0x1000000) {\r\n        System.err.print(\" LL2={\");\r\n        for (int element : this.LL2) {\r\n            System.err.print(\" \" + element);\r\n        }\r\n        System.err.println(\" }\");\r\n    }\r\n}"
}, {
	"Path": "com.topologi.diffx.event.impl.CloseElementEventImpl.equals",
	"Comment": "returns true if the event is a close elementand has the same name.",
	"Method": "boolean equals(DiffXEvent e){\r\n    if (e.getClass() != this.getClass())\r\n        return false;\r\n    CloseElementEventImpl ce = (CloseElementEventImpl) e;\r\n    return ce.getName().equals(getName());\r\n}"
}, {
	"Path": "io.github.classgraph.ClasspathElementDir.scanPaths",
	"Comment": "hierarchically scan directory structure for classfiles and matching files.",
	"Method": "void scanPaths(LogNode log){\r\n    if (skipClasspathElement) {\r\n        return;\r\n    }\r\n    if (scanned.getAndSet(true)) {\r\n        throw new IllegalArgumentException(\"Already scanned classpath element \" + toString());\r\n    }\r\n    final LogNode subLog = log == null ? null : log.log(classpathEltDir.getPath(), \"Scanning directory classpath element \" + classpathEltDir);\r\n    scanDirRecursively(classpathEltDir, subLog);\r\n    if (subLog != null) {\r\n        subLog.addElapsedTime();\r\n    }\r\n}"
}, {
	"Path": "com.datumbox.framework.core.machinelearning.ensemblelearning.FixedCombinationRules.majorityVote",
	"Comment": "combines the responses of the classifiers by summing the votes of eachwinner class.",
	"Method": "AssociativeArray majorityVote(DataTable2D classifierClassProbabilityMatrix){\r\n    AssociativeArray combinedClassProbabilities = new AssociativeArray();\r\n    for (Map.Entry<Object, AssociativeArray> entry : classifierClassProbabilityMatrix.entrySet()) {\r\n        AssociativeArray listOfClassProbabilities = entry.getValue();\r\n        for (Map.Entry<Object, Object> entry2 : listOfClassProbabilities.entrySet()) {\r\n            Object theClass = entry2.getKey();\r\n            combinedClassProbabilities.put(theClass, 0.0);\r\n        }\r\n    }\r\n    for (Map.Entry<Object, AssociativeArray> entry : classifierClassProbabilityMatrix.entrySet()) {\r\n        AssociativeArray listOfClassProbabilities = entry.getValue();\r\n        Map.Entry<Object, Object> selectedClassEntry = MapMethods.selectMaxKeyValue(listOfClassProbabilities);\r\n        Object theClass = selectedClassEntry.getKey();\r\n        Double previousValue = combinedClassProbabilities.getDouble(theClass);\r\n        if (previousValue == null) {\r\n            previousValue = 0.0;\r\n        }\r\n        combinedClassProbabilities.put(theClass, previousValue + 1.0);\r\n    }\r\n    return combinedClassProbabilities;\r\n}"
}, {
	"Path": "buildcraft.core.blueprints.BptBuilderBlueprint.internalGetNextBlock",
	"Comment": "gets the next available block. if builder is not null, then building will be verified and performed. otherwise,the next possible building slot is returned, possibly for reservation, with no building.",
	"Method": "BuildingSlot internalGetNextBlock(World world,TileAbstractBuilder builder){\r\n    if (!readyForSlotLookup(builder)) {\r\n        return null;\r\n    }\r\n    if (iterator == null) {\r\n        iterator = new BuildingSlotMapIterator(this, builder);\r\n    }\r\n    iterator.refresh(builder);\r\n    while (readyForSlotLookup(builder)) {\r\n        BuildingSlotBlock slot = iterator.next();\r\n        if (slot == null)\r\n            break;\r\n        if (!world.isBlockLoaded(pos))\r\n            continue;\r\n        boolean skipped = false;\r\n        for (int i = 0; i < slot.buildStage; i++) {\r\n            if (buildStageOccurences[i] > 0) {\r\n                iterator.skipKey();\r\n                skipped = true;\r\n                break;\r\n            }\r\n        }\r\n        if (skipped) {\r\n            continue;\r\n        }\r\n        if (slot.built) {\r\n            iterator.remove();\r\n            markLocationUsed(slot.pos);\r\n            postProcessing.add(slot);\r\n            continue;\r\n        }\r\n        if (slot.reserved) {\r\n            continue;\r\n        }\r\n        try {\r\n            if (slot.isAlreadyBuilt(context)) {\r\n                if (slot.mode == Mode.Build) {\r\n                    requirementMap.remove(slot);\r\n                    postProcessing.add(slot);\r\n                }\r\n                iterator.remove();\r\n                continue;\r\n            }\r\n            if (BlockUtil.isUnbreakableBlock(world, slot.pos)) {\r\n                iterator.remove();\r\n                markLocationUsed(slot.pos);\r\n                requirementMap.remove(slot);\r\n            } else {\r\n                if (slot.mode == Mode.ClearIfInvalid) {\r\n                    if (BuildCraftAPI.isSoftBlock(world, slot.pos) || isBlockBreakCanceled(world, slot.pos)) {\r\n                        iterator.remove();\r\n                        markLocationUsed(slot.pos);\r\n                    } else {\r\n                        if (builder == null) {\r\n                            createDestroyItems(slot);\r\n                            return slot;\r\n                        } else if (canDestroy(builder, context, slot)) {\r\n                            consumeEnergyToDestroy(builder, slot);\r\n                            createDestroyItems(slot);\r\n                            iterator.remove();\r\n                            markLocationUsed(slot.pos);\r\n                            return slot;\r\n                        }\r\n                    }\r\n                } else if (!slot.schematic.doNotBuild()) {\r\n                    if (builder == null) {\r\n                        return slot;\r\n                    } else if (checkRequirements(builder, slot.schematic)) {\r\n                        if (!BuildCraftAPI.isSoftBlock(world, slot.pos) || requirementMap.contains(slot.pos)) {\r\n                            continue;\r\n                        } else if (isBlockPlaceCanceled(world, slot.pos, slot.schematic)) {\r\n                            iterator.remove();\r\n                            requirementMap.remove(slot);\r\n                            markLocationUsed(slot.pos);\r\n                            continue;\r\n                        }\r\n                        builder.consumeEnergy(slot.getEnergyRequirement());\r\n                        useRequirements(builder, slot);\r\n                        iterator.remove();\r\n                        markLocationUsed(slot.pos);\r\n                        postProcessing.add(slot);\r\n                        return slot;\r\n                    }\r\n                } else {\r\n                    postProcessing.add(slot);\r\n                    requirementMap.remove(slot);\r\n                    iterator.remove();\r\n                }\r\n            }\r\n        } catch (Throwable t) {\r\n            t.printStackTrace();\r\n            BCLog.logger.throwing(t);\r\n            iterator.remove();\r\n            requirementMap.remove(slot);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "cyclops.control.Future.flatMapCf",
	"Comment": "a flatmap operation that accepts a completeablefuture completionstage asthe return type",
	"Method": "Future<R> flatMapCf(Function<? super T, ? extends CompletionStage<? extends R>> mapper){\r\n    return Future.<R>of(future.<R>thenCompose(t -> (CompletionStage<R>) mapper.apply(t)));\r\n}"
}, {
	"Path": "nonapi.io.github.classgraph.classpath.ClasspathOrder.addClasspathElement",
	"Comment": "add a classpath element relative to a base file. may be called by a classloaderhandler to add classpathelements that it knows about.",
	"Method": "boolean addClasspathElement(String pathElement,ClassLoader[] classLoaders,boolean addClasspathElement,String pathElement,ClassLoader[] classLoaders,ScanSpec scanSpec,LogNode log,boolean addClasspathElement,String pathElement,ClassLoader classLoader,LogNode log){\r\n    return addClasspathElement(pathElement, new ClassLoader[] { classLoader }, scanSpec, log);\r\n}"
}, {
	"Path": "com.topologi.diffx.config.DiffXConfig.getWhiteSpaceProcessing",
	"Comment": "returns the granularity of text diffing for this configuration.",
	"Method": "WhiteSpaceProcessing getWhiteSpaceProcessing(){\r\n    return this.whitespace;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.SetX.generate",
	"Comment": "generate a setx from the provided supplier up to the provided limit number of times",
	"Method": "SetX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).setX(LAZY);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.storage.abstracts.BigMapHolder.bigMapInitializer",
	"Comment": "initializes all the fields of the class which are marked with the bigmapannotation automatically.",
	"Method": "void bigMapInitializer(StorageEngine storageEngine){\r\n    for (Field field : ReflectionMethods.getAllFields(new LinkedList(), this.getClass())) {\r\n        if (field.isAnnotationPresent(BigMap.class)) {\r\n            initializeBigMapField(storageEngine, field);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.QueueX.range",
	"Comment": "create a queuex that contains the integers between skip and take",
	"Method": "QueueX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).queueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "cyclops.monads.transformers.FutureT.fromAnyM",
	"Comment": "construct an futuret from an anym that contains a monad type that contains type other than futurethe values in the underlying monad will be mapped to future",
	"Method": "FutureT<W, A> fromAnyM(AnyM<W, A> anyM){\r\n    return of(anyM.map(Future::ofResult));\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.EagerFutureStreamFunctions.withLatest",
	"Comment": "zip two streams into one. uses the latest values from each rather than waiting for both",
	"Method": "ReactiveSeq<Tuple2<T1, T2>> withLatest(SimpleReactStream<T1> left,SimpleReactStream<T2> right,ReactiveSeq<R> withLatest,SimpleReactStream<T1> left,SimpleReactStream<T2> right,BiFunction<T1, T2, R> zipper){\r\n    final Queue q = left.then(it -> new Val(Val.Pos.left, it)).merge(right.then(it -> new Val(Val.Pos.right, it))).toQueue();\r\n    final Iterator<Val> it = q.stream(left.getSubscription()).iterator();\r\n    class Zip implements Iterator<R> {\r\n        T1 lastLeft = null;\r\n        T2 lastRight = null;\r\n        @Override\r\n        public boolean hasNext() {\r\n            return it.hasNext();\r\n        }\r\n        @Override\r\n        public R next() {\r\n            final Val v = it.next();\r\n            if (v.pos == Val.Pos.left) {\r\n                lastLeft = (T1) v.val;\r\n                return zipper.apply(lastLeft, lastRight);\r\n            } else\r\n                lastRight = (T2) v.val;\r\n            return (R) Optional.empty();\r\n        }\r\n    }\r\n    return ReactiveSeq.fromIterator(new Zip()).filter(next -> !(next instanceof Optional));\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.EagerFutureStreamFunctions.withLatest",
	"Comment": "zip two streams into one. uses the latest values from each rather than waiting for both",
	"Method": "ReactiveSeq<Tuple2<T1, T2>> withLatest(SimpleReactStream<T1> left,SimpleReactStream<T2> right,ReactiveSeq<R> withLatest,SimpleReactStream<T1> left,SimpleReactStream<T2> right,BiFunction<T1, T2, R> zipper){\r\n    return it.hasNext();\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.EagerFutureStreamFunctions.withLatest",
	"Comment": "zip two streams into one. uses the latest values from each rather than waiting for both",
	"Method": "ReactiveSeq<Tuple2<T1, T2>> withLatest(SimpleReactStream<T1> left,SimpleReactStream<T2> right,ReactiveSeq<R> withLatest,SimpleReactStream<T1> left,SimpleReactStream<T2> right,BiFunction<T1, T2, R> zipper){\r\n    final Val v = it.next();\r\n    if (v.pos == Val.Pos.left) {\r\n        lastLeft = (T1) v.val;\r\n        return zipper.apply(lastLeft, lastRight);\r\n    } else\r\n        lastRight = (T2) v.val;\r\n    return (R) Optional.empty();\r\n}"
}, {
	"Path": "cyclops.control.Reader.flatMap",
	"Comment": "flatmap this reader by applying the prodived function and unnesting to a single reader",
	"Method": "Reader<T, R1> flatMap(Function<? super R, ? extends Reader<T, R1>> f){\r\n    return a -> f.apply(apply(a)).apply(a);\r\n}"
}, {
	"Path": "com.datumbox.framework.common.dataobjects.AssociativeArray.subtractValues",
	"Comment": "subtracts the provided associative array to the current object. all the columnsof this object should be numeric or boolean or else an exception is thrown.",
	"Method": "void subtractValues(AssociativeArray array){\r\n    addRemoveValues(array, -1);\r\n}"
}, {
	"Path": "io.github.classgraph.MethodParameterInfo.getAnnotationInfo",
	"Comment": "get a the named annotation on this method parameter, or null if the method parameter does not have the namedannotation.",
	"Method": "AnnotationInfoList getAnnotationInfo(AnnotationInfo getAnnotationInfo,String annotationName){\r\n    return getAnnotationInfo().get(annotationName);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.Value.iterate",
	"Comment": "use the value stored in this value to seed a stream generated from the provided function",
	"Method": "ReactiveSeq<T> iterate(UnaryOperator<T> fn,T alt){\r\n    return asSupplier(alt).iterate(fn);\r\n}"
}, {
	"Path": "com.datumbox.framework.core.statistics.distributions.ContinuousDistributionsTest.testExponentialCdf",
	"Comment": "test of exponentialcdf method, of class continuousdistributions.",
	"Method": "void testExponentialCdf(){\r\n    logger.info(\"ExponentialCdf\");\r\n    double x = 3.0;\r\n    double lamda = 10.0;\r\n    double expResult = 0.99999999999991;\r\n    double result = ContinuousDistributions.exponentialCdf(x, lamda);\r\n    assertEquals(expResult, result, Constants.DOUBLE_ACCURACY_HIGH);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.async.future.FastFuture.fromCompletableFuture",
	"Comment": "internal conversion method to convert completablefutures to fastfuture.",
	"Method": "FastFuture<T> fromCompletableFuture(CompletableFuture<T> cf){\r\n    final FastFuture<T> f = new FastFuture();\r\n    cf.thenAccept(i -> f.set(i));\r\n    cf.exceptionally(t -> {\r\n        f.completedExceptionally(t);\r\n        return f.join();\r\n    });\r\n    return f;\r\n}"
}, {
	"Path": "io.github.classgraph.PackageInfo.getParent",
	"Comment": "the parent package of this package, or null if this is the root package.",
	"Method": "PackageInfo getParent(){\r\n    return parent;\r\n}"
}]