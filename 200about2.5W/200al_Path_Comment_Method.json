[{
	"Path": "org.xlsx4j.sml.CTChartsheetViews.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPageSetup.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotAreas.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.nustaq.serialization.minbin.MinBin.getBaseType",
	"Comment": "extract base type includin unsignend flag excluding array flag",
	"Method": "byte getBaseType(byte type){\r\n    return (byte) ((type & 0b111) | (type & UNSIGN_MASK));\r\n}"
}, {
	"Path": "org.docx4j.math.CTUnSignedInteger.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTColorScale.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDbPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTChartFormat.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.SmallDocumentBlock.convert",
	"Comment": "factory for creating smalldocumentblocks from documentblocks",
	"Method": "SmallDocumentBlock[] convert(POIFSBigBlockSize bigBlockSize,byte[] array,int size,SmallDocumentBlock[] convert,POIFSBigBlockSize bigBlockSize,BlockWritable[] store,int size){\r\n    ByteArrayOutputStream stream = new ByteArrayOutputStream();\r\n    for (int j = 0; j < store.length; j++) {\r\n        store[j].writeBlocks(stream);\r\n    }\r\n    byte[] data = stream.toByteArray();\r\n    SmallDocumentBlock[] rval = new SmallDocumentBlock[convertToBlockCount(size)];\r\n    for (int index = 0; index < rval.length; index++) {\r\n        rval[index] = new SmallDocumentBlock(bigBlockSize, data, index);\r\n    }\r\n    return rval;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTAltChunkPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.ParentFixTest.testUnmarshalString",
	"Comment": "prior to 3.3.1, unmarshalling a string does set parent properly, except in the known case of jaxbelement,\twhich a traverse fixes\twith 3.3.1, arraylistwml gets this right first time",
	"Method": "void testUnmarshalString(){\r\n    String openXML = \"<w:p xmlns:w=\\\"http://schemas.openxmlformats.org/wordprocessingml/2006/main\\\" xmlns:xml=\\\"http://www.w3.org/XML/1998/namespace\\\">\" + \"<w:r>\" + \"<w:t>some text<\/w:t>\" + \"<\/w:r>\" + \"<w:bookmarkStart w:id=\\\"0\\\" w:name=\\\"mybm\\\"/>\" + \"<w:bookmarkEnd w:id=\\\"0\\\"/>\" + \"<\/w:p>\";\r\n    P p = (P) XmlUtils.unmarshalString(openXML);\r\n    R r = (R) p.getContent().get(0);\r\n    if (r.getParent() == null) {\r\n        System.out.println(\"null parent\");\r\n        Assert.fail(\"null parent\");\r\n    } else {\r\n        System.out.println(r.getParent().getClass());\r\n        Assert.assertEquals(P.class, r.getParent().getClass());\r\n    }\r\n    Child o2 = (Child) XmlUtils.unwrap(p.getContent().get(1));\r\n    if (o2.getParent() == null) {\r\n        System.out.println(\"null parent\");\r\n        Assert.fail(\"null parent\");\r\n    } else if (o2.getParent() instanceof JAXBElement) {\r\n        Assert.assertEquals(JAXBElement.class, o2.getParent().getClass());\r\n        List foo = new ArrayList();\r\n        foo.add(p);\r\n        ClassFinder finder = new ClassFinder(FldChar.class);\r\n        new TraversalUtil(foo, finder);\r\n        o2 = (Child) XmlUtils.unwrap(p.getContent().get(1));\r\n        if (o2.getParent() == null) {\r\n            System.out.println(\"null parent\");\r\n            Assert.fail(\"null parent\");\r\n        } else {\r\n            System.out.println(o2.getClass().getName() + \" has CORRECTED parent \" + o2.getParent().getClass());\r\n            Assert.assertEquals(o2.getParent().getClass(), P.class);\r\n        }\r\n    } else {\r\n        System.out.println(o2.getClass().getName() + \" has parent \" + o2.getParent().getClass());\r\n        Assert.assertEquals(P.class, o2.getParent().getClass());\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.webextension_2010_11.CTOsfWebExtension.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w15.CTSdtRepeatedSection.getDoNotAllowInsertDeleteSection",
	"Comment": "gets the value of the donotallowinsertdeletesection property.",
	"Method": "BooleanDefaultTrue getDoNotAllowInsertDeleteSection(){\r\n    return doNotAllowInsertDeleteSection;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTVbaSuppData.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTChar.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetDimension.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.BoolStack.pop",
	"Comment": "removes the object at the top of this stack and returns thatobject as the value of this function.",
	"Method": "boolean pop(){\r\n    return m_values[m_index--];\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTQueryTableRefresh.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTBorder.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTop10.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.wordprocessingDrawing.CTWrap.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSortCondition.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTLimLowPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.AttributesImplSerializer.getIndex",
	"Comment": "this method gets the index of an attribute given its uri and locanname.",
	"Method": "int getIndex(String qname,int getIndex,String uri,String localName){\r\n    int index;\r\n    if (super.getLength() < MAX) {\r\n        index = super.getIndex(uri, localName);\r\n        return index;\r\n    }\r\n    m_buff.setLength(0);\r\n    m_buff.append('{').append(uri).append('}').append(localName);\r\n    String key = m_buff.toString();\r\n    Integer i = (Integer) m_indexFromQName.get(key);\r\n    if (i == null)\r\n        index = -1;\r\n    else\r\n        index = i.intValue();\r\n    return index;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFtnDocProps.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.SmallDocumentBlock.fill",
	"Comment": "fill out a list of smalldocumentblocks so that it fully occupiesa set of big blocks",
	"Method": "int fill(POIFSBigBlockSize bigBlockSize,List<SmallDocumentBlock> blocks){\r\n    int _blocks_per_big_block = getBlocksPerBigBlock(bigBlockSize);\r\n    int count = blocks.size();\r\n    int big_block_count = (count + _blocks_per_big_block - 1) / _blocks_per_big_block;\r\n    int full_count = big_block_count * _blocks_per_big_block;\r\n    for (; count < full_count; count++) {\r\n        blocks.add(makeEmptySmallDocumentBlock(bigBlockSize));\r\n    }\r\n    return big_block_count;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTIdMap.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTRubyContent.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTServerFormats.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.transformer.TransformerIdentityImpl.setDocumentLocator",
	"Comment": "receive a locator object for document events.by default, do nothing.application writers may override thismethod in a subclass if they wish to store the locator for usewith other document events.",
	"Method": "void setDocumentLocator(Locator locator){\r\n    try {\r\n        if (null == m_resultContentHandler)\r\n            createResultContentHandler(m_result);\r\n    } catch (TransformerException te) {\r\n        throw new org.apache.xml.utils.WrappedRuntimeException(te);\r\n    }\r\n    m_resultContentHandler.setDocumentLocator(locator);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocParts.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.agent.utils.locks.impl.FileLockTests.fileLockClosedOnException",
	"Comment": "make sure close method for a filelock gets called on exception.",
	"Method": "void fileLockClosedOnException(){\r\n    final FileLock mockLock = Mockito.mock(FileLock.class);\r\n    try (final CloseableLock lock = mockLock) {\r\n        lock.lock();\r\n        throw new LockException(\"dummy exception\");\r\n    } catch (LockException e) {\r\n    }\r\n    Mockito.verify(mockLock, Mockito.times(1)).close();\r\n}"
}, {
	"Path": "org.docx4j.wml.CTAltChunk.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.BookViews.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPartName.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPCDKPIs.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTTopBot.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTConsolidation.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTAutoSortScope.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Cols.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.springframework.web.servlet.tags.BindErrorsTag.getErrors",
	"Comment": "retrieve the errors instance that this tag is currently bound to.intended for cooperating nesting tags.",
	"Method": "Errors getErrors(){\r\n    return null;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWebPublishItem.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getDoNotUseHTMLParagraphAutoSpacing",
	"Comment": "gets the value of the donotusehtmlparagraphautospacing property.",
	"Method": "BooleanDefaultTrue getDoNotUseHTMLParagraphAutoSpacing(){\r\n    return doNotUseHTMLParagraphAutoSpacing;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTItems.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRst.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadataBlocks.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.Br.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.DOM3SerializerImpl.getNodeFilter",
	"Comment": "returns a lsserializerfilter set on the dom level 3 serializer to filter nodesduring serialization.this interface is a public api.",
	"Method": "LSSerializerFilter getNodeFilter(){\r\n    return fSerializerFilter;\r\n}"
}, {
	"Path": "org.docx4j.math.CTTopBot.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFtnPos.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPCDSCPage.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.nustaq.offheap.FSTSerializedOffheapMap.getEntryLengthForContentLength",
	"Comment": "default is to let 100% room for later entry growth. avoid fragmentation as hell.",
	"Method": "int getEntryLengthForContentLength(long lengthOfEntry){\r\n    return (int) (lengthOfEntry * 2);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.opendope.ConditionsPart.getConditionById",
	"Comment": "for performance reasons, avoid using this method if you have a lot of conditions",
	"Method": "Condition getConditionById(org.opendope.conditions.Conditions conditions,String id){\r\n    for (Condition c : conditions.getCondition()) {\r\n        if (c.getId().equals(id))\r\n            return c;\r\n    }\r\n    throw new InputIntegrityException(\"No Condition with id \" + id);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExtensionList.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTXmlColumnPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerBase.subPartMatch",
	"Comment": "tell if two strings are equal, without worry if the first string is null.",
	"Method": "boolean subPartMatch(String p,String t){\r\n    return (p == t) || ((null != p) && (p.equals(t)));\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.XMLWriterImpl.deNude",
	"Comment": "writes the angle bracket if the element open tag is not finished.",
	"Method": "void deNude(){\r\n    if (this.isNude) {\r\n        this.writer.write('>');\r\n        if (peekElement().hasChildren && this.indent) {\r\n            this.writer.write('\\n');\r\n        }\r\n        this.isNude = false;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.DOM3SerializerImpl.setNodeFilter",
	"Comment": "sets a lsserializerfilter on the dom level 3 serializer to filter nodesduring serialization.this interface is a public api.",
	"Method": "void setNodeFilter(LSSerializerFilter filter){\r\n    fSerializerFilter = filter;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMRUColors.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTLinearShadeProperties.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotDimension.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalDefinedName.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTNumber.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTNumForm.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.webextension_2010_11.CTOsfWebExtensionReferenceList.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTLineJoinMiterProperties.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtDateMappingType.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTHyperlink.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMeasureGroup.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.FldChar.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.RStyle.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTIntProperty.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.DOMErrorImpl.getType",
	"Comment": "returns a string indicating which related data is expected in relateddata.",
	"Method": "String getType(){\r\n    return fType;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTShapetype.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.anon.AnonymizeResult.getInventoryObjectsByPart",
	"Comment": "return misc interesting objects, by story part, for further consideration",
	"Method": "HashMap<Part, Set<Object>> getInventoryObjectsByPart(){\r\n    return inventoryObjectsByPart;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToUnknownStream.setSourceLocator",
	"Comment": "this method is used to set the source locator, which might be used togenerated an error message.",
	"Method": "void setSourceLocator(SourceLocator locator){\r\n    m_handler.setSourceLocator(locator);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTLineNumber.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTIconFilter.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.hpsf.Util.cat",
	"Comment": "concatenates the contents of several byte arrays into asingle one.",
	"Method": "byte[] cat(byte[][] byteArrays){\r\n    int capacity = 0;\r\n    for (int i = 0; i < byteArrays.length; i++) capacity += byteArrays[i].length;\r\n    final byte[] result = new byte[capacity];\r\n    int r = 0;\r\n    for (int i = 0; i < byteArrays.length; i++) for (int j = 0; j < byteArrays[i].length; j++) result[r++] = byteArrays[i][j];\r\n    return result;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFormat.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.DocumentSettingsPart.setProtectionPassword",
	"Comment": "enforces the protection with the option specified by passed editvalue, password, and hashalgorithm for the password.",
	"Method": "void setProtectionPassword(String password,HashAlgorithm hashAlgo){\r\n    if (password == null) {\r\n        safeGetDocumentProtection().setCryptProviderType(null);\r\n        safeGetDocumentProtection().setCryptAlgorithmClass(null);\r\n        safeGetDocumentProtection().setCryptAlgorithmType(null);\r\n        safeGetDocumentProtection().setCryptAlgorithmSid(null);\r\n        safeGetDocumentProtection().setSalt(null);\r\n        safeGetDocumentProtection().setCryptSpinCount(null);\r\n        safeGetDocumentProtection().setHash(null);\r\n        return;\r\n    } else {\r\n        final STCryptProv providerType;\r\n        final int sid;\r\n        switch(hashAlgo) {\r\n            case md2:\r\n                providerType = STCryptProv.RSA_FULL;\r\n                sid = 1;\r\n                break;\r\n            case md4:\r\n                providerType = STCryptProv.RSA_FULL;\r\n                sid = 2;\r\n                break;\r\n            case md5:\r\n                providerType = STCryptProv.RSA_FULL;\r\n                sid = 3;\r\n                break;\r\n            case sha1:\r\n                providerType = STCryptProv.RSA_FULL;\r\n                sid = 4;\r\n                break;\r\n            case sha256:\r\n                providerType = STCryptProv.RSA_AES;\r\n                sid = 12;\r\n                break;\r\n            case sha384:\r\n                providerType = STCryptProv.RSA_AES;\r\n                sid = 13;\r\n                break;\r\n            case sha512:\r\n                providerType = STCryptProv.RSA_AES;\r\n                sid = 14;\r\n                break;\r\n            default:\r\n                throw new EncryptedDocumentException(\"Hash algorithm '\" + hashAlgo + \"' is not supported for document write protection.\");\r\n        }\r\n        SecureRandom random = new SecureRandom();\r\n        byte[] salt = random.generateSeed(16);\r\n        int spinCount = 100000;\r\n        if (hashAlgo == null)\r\n            hashAlgo = HashAlgorithm.sha512;\r\n        String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);\r\n        byte[] hash = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount, false);\r\n        safeGetDocumentProtection().setSalt(salt);\r\n        safeGetDocumentProtection().setHash(hash);\r\n        safeGetDocumentProtection().setCryptSpinCount(BigInteger.valueOf(spinCount));\r\n        safeGetDocumentProtection().setCryptAlgorithmType(STAlgType.TYPE_ANY);\r\n        safeGetDocumentProtection().setCryptAlgorithmClass(STAlgClass.HASH);\r\n        safeGetDocumentProtection().setCryptProviderType(providerType);\r\n        safeGetDocumentProtection().setCryptAlgorithmSid(BigInteger.valueOf(sid));\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPartBehaviors.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.DocPropsCustomPart.unmarshal",
	"Comment": "unmarshal xml data from the specified inputstream and return the resulting content tree.validation event location information maybe incomplete when using this form of the unmarshal api.implements unmarshal global root element.",
	"Method": "Properties unmarshal(java.io.InputStream is){\r\n    try {\r\n        XMLInputFactory xif = XMLInputFactory.newInstance();\r\n        xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\r\n        xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);\r\n        XMLStreamReader xsr = xif.createXMLStreamReader(is);\r\n        setJAXBContext(org.docx4j.jaxb.Context.jcDocPropsCustom);\r\n        Unmarshaller u = jc.createUnmarshaller();\r\n        u.setEventHandler(new org.docx4j.jaxb.JaxbValidationEventHandler());\r\n        log.info(\"unmarshalling \" + this.getClass().getName());\r\n        jaxbElement = (Properties) u.unmarshal(xsr);\r\n        log.info(\"\\n\\n\" + this.getClass().getName() + \" unmarshalled \\n\\n\");\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n    return jaxbElement;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtComboBox.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.pptx4j.pml.CTControlList.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOleItems.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTWriteProtection.setCryptProviderTypeExtSource",
	"Comment": "sets the value of the cryptprovidertypeextsource property.",
	"Method": "void setCryptProviderTypeExtSource(String value){\r\n    this.cryptProviderTypeExtSource = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalReferences.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMailMergeDocType.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setDoNotSuppressParagraphBorders",
	"Comment": "sets the value of the donotsuppressparagraphborders property.",
	"Method": "void setDoNotSuppressParagraphBorders(BooleanDefaultTrue value){\r\n    this.doNotSuppressParagraphBorders = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPageField.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalReferences.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.BATBlock.calculateStorageRequirements",
	"Comment": "calculate how many batblocks are needed to hold a specifiednumber of bat entries.",
	"Method": "int calculateStorageRequirements(POIFSBigBlockSize bigBlockSize,int entryCount){\r\n    int _entries_per_block = bigBlockSize.getBATEntriesPerBlock();\r\n    return (entryCount + _entries_per_block - 1) / _entries_per_block;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerBase.setNamespaceMappings",
	"Comment": "used only by transformersnapshotimpl to restore the serialization to a previous state.",
	"Method": "void setNamespaceMappings(NamespaceMappings mappings){\r\n    m_prefixMap = mappings;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTDocEvents.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTCurve.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.XmlUtils.neww3cDomDocument",
	"Comment": "use documentbuilderfactory to create and return a new w3c dom document.",
	"Method": "org.w3c.dom.Document neww3cDomDocument(){\r\n    return XmlUtils.getNewDocumentBuilder().newDocument();\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.XMLUtils.createElementInSignatureSpace",
	"Comment": "creates an element in the xml signature specification namespace.",
	"Method": "Element createElementInSignatureSpace(Document doc,String elementName){\r\n    if (doc == null) {\r\n        throw new RuntimeException(\"Document is null\");\r\n    }\r\n    if (dsPrefix == null || dsPrefix.length() == 0) {\r\n        return doc.createElementNS(Constants.SignatureSpecNS, elementName);\r\n    }\r\n    return doc.createElementNS(Constants.SignatureSpecNS, dsPrefix + \":\" + elementName);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.util.FopConfigUtil.declareFonts",
	"Comment": "create a fop font configuration for each font used in the\tdocument.",
	"Method": "void declareFonts(Mapper fontMapper,Set<String> fontsInUse,StringBuilder result){\r\n    for (String fontName : fontsInUse) {\r\n        PhysicalFont pf = fontMapper.get(fontName);\r\n        String subFontAtt = \"\";\r\n        if (pf == null) {\r\n            log.warn(\"Document font \" + fontName + \" is not mapped to a physical font!\");\r\n        } else {\r\n            if (pf.getEmbedFontInfo().getSubFontName() != null)\r\n                subFontAtt = \" sub-font=\\\"\" + pf.getEmbedFontInfo().getSubFontName() + \"\\\"\";\r\n            result.append(\"<font embed-url=\\\"\" + pf.getEmbeddedFile() + \"\\\"\" + subFontAtt + \">\");\r\n            FontTriplet fontTriplet = (FontTriplet) pf.getEmbedFontInfo().getFontTriplets().get(0);\r\n            addFontTriplet(result, fontTriplet);\r\n            result.append(\"<\/font>\");\r\n        }\r\n        PhysicalFont pfVariation = fontMapper.getBoldForm(fontName, pf);\r\n        if (pfVariation == null) {\r\n            log.debug(fontName + \" no bold form\");\r\n        } else {\r\n            result.append(\"<font embed-url=\\\"\" + pfVariation.getEmbeddedFile() + \"\\\"\" + subFontAtt + \">\");\r\n            addFontTriplet(result, pf.getName(), \"normal\", \"bold\");\r\n            result.append(\"<\/font>\");\r\n        }\r\n        pfVariation = fontMapper.getBoldItalicForm(fontName, pf);\r\n        if (pfVariation == null) {\r\n            log.debug(fontName + \" no bold italic form\");\r\n        } else {\r\n            result.append(\"<font embed-url=\\\"\" + pfVariation.getEmbeddedFile() + \"\\\"\" + subFontAtt + \">\");\r\n            addFontTriplet(result, pf.getName(), \"italic\", \"bold\");\r\n            result.append(\"<\/font>\");\r\n        }\r\n        pfVariation = fontMapper.getItalicForm(fontName, pf);\r\n        if (pfVariation == null) {\r\n            log.debug(fontName + \" no italic form\");\r\n        } else {\r\n            result.append(\"<font embed-url=\\\"\" + pfVariation.getEmbeddedFile() + \"\\\"\" + subFontAtt + \">\");\r\n            addFontTriplet(result, pf.getName(), \"italic\", \"normal\");\r\n            result.append(\"<\/font>\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getDrawingGridHorizontalSpacing",
	"Comment": "gets the value of the drawinggridhorizontalspacing property.",
	"Method": "CTTwipsMeasure getDrawingGridHorizontalSpacing(){\r\n    return drawingGridHorizontalSpacing;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.isTainted",
	"Comment": "checks whether values matching this fact are probably untrusted",
	"Method": "boolean isTainted(){\r\n    return state.isTainted;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.c14n.Canonicalizer.setWriter",
	"Comment": "sets the writer where the canonicalization ends.bytearrayoutputstream if none is set.",
	"Method": "void setWriter(OutputStream os){\r\n    canonicalizerSpi.setWriter(os);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalDefinedNames.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.XMLUtils.circumventBug2650",
	"Comment": "this method spreads all namespace attributes in a dom document to theirchildren. this is needed because the xml signature xpath transformmust evaluate the xpath against all nodes in the input, even againstxpath namespace nodes. through a bug in xalanj2, the namespace nodes arenot fully visible in the xalan xpath model, so we have to do this byhand in dom spaces so that the nodes become visible in xpath space.",
	"Method": "void circumventBug2650(Document doc){\r\n    Element documentElement = doc.getDocumentElement();\r\n    Attr xmlnsAttr = documentElement.getAttributeNodeNS(Constants.NamespaceSpecNS, \"xmlns\");\r\n    if (xmlnsAttr == null) {\r\n        documentElement.setAttributeNS(Constants.NamespaceSpecNS, \"xmlns\", \"\");\r\n    }\r\n    XMLUtils.circumventBug2650internal(doc);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGroups.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTColumn.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMissing.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTMathPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPane.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSignedTwipsMeasure.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.NamedCharacter.hasSingleUnicodeValue",
	"Comment": "indicates whether a single unicode value is associated with this character.",
	"Method": "boolean hasSingleUnicodeValue(){\r\n    return (this.unicodeSequence != null && this.unicodeSequence.length() == 1);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToUnknownStream.setDoctypePublic",
	"Comment": "set the doctype in the underlying xml handler. remember that this methodwas called, just in case we need to transfer this doctype to an html handler",
	"Method": "void setDoctypePublic(String doctype){\r\n    m_handler.setDoctypePublic(doctype);\r\n    m_setDoctypePublic_called = true;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTXstringWhitespace.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.PresentationML.SlideMasterPart.marshal",
	"Comment": "marshal the content tree rooted at jaxbelement into an output\tstream",
	"Method": "void marshal(java.io.OutputStream os,Object namespacePrefixMapper){\r\n    String xmlString = XmlUtils.marshaltoString(getJaxbElement(), false, true, jc);\r\n    int pos = xmlString.indexOf(\":sldMaster \");\r\n    int closeTagPos = xmlString.indexOf(\">\", pos);\r\n    if (xmlString.substring(pos, closeTagPos).contains(VML_DECL)) {\r\n    } else {\r\n        xmlString = xmlString.substring(0, pos + 11) + VML_DECL + \" \" + xmlString.substring(pos + 11);\r\n    }\r\n    try {\r\n        IOUtils.write(xmlString, os, \"UTF-8\");\r\n    } catch (IOException e) {\r\n        throw new JAXBException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.w14.CTNumSpacing.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOleObject.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadataRecord.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToStream.getOutputStream",
	"Comment": "get the output stream where the events will be serialized to.",
	"Method": "OutputStream getOutputStream(){\r\n    return m_outputStream;\r\n}"
}, {
	"Path": "org.docx4j.wml.HpsMeasure.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.type1.AFMCharMetrics.hasCharCode",
	"Comment": "indicates whether the character has a character code, i.e. is part of the default encoding.",
	"Method": "boolean hasCharCode(){\r\n    return charCode >= 0;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTAutoCaptions.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.injection.AbstractTaintDetector.shouldAnalyzeClass",
	"Comment": "allow any concrete implementation of taint detector to skip the analysis of certain files.the purpose can be for optimisation or to trigger bug in specific context.the default implementation returns true to all classes visited.",
	"Method": "boolean shouldAnalyzeClass(ClassContext classContext){\r\n    return true;\r\n}"
}, {
	"Path": "org.docx4j.math.CTMathPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetDimension.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTFunc.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.XmlUtils.marshaltoString",
	"Comment": "use the specified jaxbcontext to marshal this object to a string, pretty printed, and without an xml declaration.\tuseful for debugging.",
	"Method": "String marshaltoString(Object o,String marshaltoString,Object o,JAXBContext jc,String marshaltoString,Object o,boolean suppressDeclaration,String marshaltoString,Object o,boolean suppressDeclaration,JAXBContext jc,String marshaltoString,Object o,boolean suppressDeclaration,boolean prettyprint,String marshaltoString,Object o,boolean suppressDeclaration,boolean prettyprint,JAXBContext jc,String marshaltoString,Object o,boolean suppressDeclaration,boolean prettyprint,JAXBContext jc,String uri,String local,Class declaredType){\r\n    try {\r\n        Marshaller m = jc.createMarshaller();\r\n        NamespacePrefixMapperUtils.setProperty(m, NamespacePrefixMapperUtils.getPrefixMapper());\r\n        String ignorables = setMcIgnorable(((McIgnorableNamespaceDeclarator) NamespacePrefixMapperUtils.getPrefixMapper()), o);\r\n        if (prettyprint) {\r\n            m.setProperty(\"jaxb.formatted.output\", true);\r\n        }\r\n        if (suppressDeclaration) {\r\n            m.setProperty(Marshaller.JAXB_FRAGMENT, true);\r\n        }\r\n        if (Docx4jProperties.getProperty(\"docx4j.jaxb.marshal.canonicalize\", false)) {\r\n            org.w3c.dom.Document doc = marshaltoW3CDomDocument(o, jc, uri, local, declaredType);\r\n            byte[] bytes = trimNamespaces(doc, ignorables);\r\n            return new String(bytes, \"UTF-8\");\r\n        } else {\r\n            StringWriter sWriter = new StringWriter();\r\n            m.marshal(new JAXBElement(new QName(uri, local), declaredType, o), sWriter);\r\n            return sWriter.toString();\r\n        }\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.vml.CTF.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCacheHierarchy.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTPhant.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPCDKPIs.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDxf.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGradientFill.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.IdentityPlusMapper.populateFontMappings",
	"Comment": "populate the fontmappings object. we make an entry for each\tof the documentfontnames.",
	"Method": "void populateFontMappings(Set<String> documentFontNames,org.docx4j.wml.Fonts wmlFonts){\r\n    for (String documentFontname : documentFontNames) {\r\n        log.debug(\"Document font: \" + documentFontname);\r\n        PhysicalFont mappedTo = PhysicalFonts.get(documentFontname);\r\n        if (mappedTo != null) {\r\n            put(documentFontname, mappedTo);\r\n            log.debug(\".. mapped to \" + mappedTo.getName());\r\n        } else if (regularForms.get(documentFontname) != null) {\r\n            put(documentFontname, regularForms.get(documentFontname));\r\n            log.debug(\".. mapped to embedded regular form \");\r\n        } else if (boldForms.get(documentFontname) != null) {\r\n            put(documentFontname, boldForms.get(documentFontname));\r\n            log.debug(\".. mapped to embedded bold form \");\r\n        } else if (italicForms.get(documentFontname) != null) {\r\n            put(documentFontname, italicForms.get(documentFontname));\r\n            log.debug(\".. mapped to embedded italic form \");\r\n        } else if (boldItalicForms.get(documentFontname) != null) {\r\n            put(documentFontname, boldItalicForms.get(documentFontname));\r\n            log.debug(\".. mapped to embedded bold italic form \");\r\n        } else {\r\n            log.warn(\"- - No physical font for: \" + documentFontname);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWorkbookProtection.getWorkbookPasswordCharacterSet",
	"Comment": "gets the value of the workbookpasswordcharacterset property.",
	"Method": "String getWorkbookPasswordCharacterSet(){\r\n    return workbookPasswordCharacterSet;\r\n}"
}, {
	"Path": "org.docx4j.wml.TblGridCol.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGroupMember.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTColorMenu.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCalcCell.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.addTag",
	"Comment": "adds the specified taint tag to this fact or marks this tag to addif this fact acts like a derivation of taint transfer behaviour",
	"Method": "boolean addTag(Tag tag){\r\n    return tags.add(tag);\r\n}"
}, {
	"Path": "org.docx4j.math.CTMPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTLigatures.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPartBehavior.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setAutofitToFirstFixedWidthCell",
	"Comment": "sets the value of the autofittofirstfixedwidthcell property.",
	"Method": "void setAutofitToFirstFixedWidthCell(BooleanDefaultTrue value){\r\n    this.autofitToFirstFixedWidthCell = value;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTabStop.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.client.ApplicationClient.getApplications",
	"Comment": "method to get a list of all the applications from genie for the query parameters specified.",
	"Method": "List<Application> getApplications(List<Application> getApplications,String name,String user,List<String> statusList,List<String> tagList,String type){\r\n    final List<Application> applicationList = new ArrayList();\r\n    final JsonNode jNode = this.applicationService.getApplications(name, user, statusList, tagList, type).execute().body().get(\"_embedded\");\r\n    if (jNode != null) {\r\n        for (final JsonNode objNode : jNode.get(\"applicationList\")) {\r\n            final Application application = this.treeToValue(objNode, Application.class);\r\n            applicationList.add(application);\r\n        }\r\n    }\r\n    return applicationList;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMergeCell.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTuples.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTEndnotes.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setUseAltKinsokuLineBreakRules",
	"Comment": "sets the value of the usealtkinsokulinebreakrules property.",
	"Method": "void setUseAltKinsokuLineBreakRules(BooleanDefaultTrue value){\r\n    this.useAltKinsokuLineBreakRules = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDateTime.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFilters.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDivs.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.TblGridCol.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.TTFFile.checkTTC",
	"Comment": "check if this is a truetype collection and that the givenname exists in the collection.if it does, set offset in fontfile to the beginning ofthe table directory for that font.",
	"Method": "boolean checkTTC(FontFileReader in,String name){\r\n    String tag = in.readTTFString(4);\r\n    if (\"ttcf\".equals(tag)) {\r\n        in.skip(4);\r\n        int numDirectories = (int) in.readTTFULong();\r\n        long[] dirOffsets = new long[numDirectories];\r\n        for (int i = 0; i < numDirectories; i++) {\r\n            dirOffsets[i] = in.readTTFULong();\r\n        }\r\n        log.info(\"This is a TrueType collection file with \" + numDirectories + \" fonts\");\r\n        log.info(\"Containing the following fonts: \");\r\n        boolean found = false;\r\n        long dirTabOffset = 0;\r\n        for (int i = 0; (i < numDirectories); i++) {\r\n            in.seekSet(dirOffsets[i]);\r\n            readDirTabs(in);\r\n            readName(in);\r\n            if (fullName.equals(name)) {\r\n                found = true;\r\n                dirTabOffset = dirOffsets[i];\r\n                log.info(fullName + \" <-- selected\");\r\n            } else {\r\n                log.info(fullName);\r\n            }\r\n            notice = \"\";\r\n            fullName = \"\";\r\n            familyNames.clear();\r\n            postScriptName = \"\";\r\n            subFamilyName = \"\";\r\n        }\r\n        in.seekSet(dirTabOffset);\r\n        return found;\r\n    } else {\r\n        in.seekSet(0);\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.vml.wordprocessingDrawing.CTAnchorLock.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.substitute.AttributeValue.valueOf",
	"Comment": "returns an attributevalue object holding thevalue of the specified string.",
	"Method": "AttributeValue valueOf(String valuesString){\r\n    AttributeValue attribute = new AttributeValue();\r\n    StringTokenizer stringTokenizer = new StringTokenizer(valuesString, \",\");\r\n    if (stringTokenizer.countTokens() > 1) {\r\n        while (stringTokenizer.hasMoreTokens()) {\r\n            String token = stringTokenizer.nextToken().trim();\r\n            AttributeValue tokenAttribute = AttributeValue.valueOf(token);\r\n            attribute.addAll(tokenAttribute);\r\n        }\r\n    } else {\r\n        String token = stringTokenizer.nextToken().trim();\r\n        Object value = null;\r\n        try {\r\n            value = Integer.valueOf(token);\r\n        } catch (NumberFormatException ex) {\r\n            value = FontWeightRange.valueOf(token);\r\n            if (value == null) {\r\n                value = token;\r\n            }\r\n        }\r\n        if (value != null) {\r\n            attribute.add(value);\r\n        }\r\n    }\r\n    return attribute;\r\n}"
}, {
	"Path": "org.docx4j.utils.XPathFactoryUtil.setxPathFactory",
	"Comment": "org.apache.xpath.jaxp.xpathfactoryimpl is recommended. use something else at your own risk!",
	"Method": "void setxPathFactory(XPathFactory xPathFactory){\r\n    XPathFactoryUtil.xPathFactory = xPathFactory;\r\n    log.info(\"xpath implementation: \" + XPathFactoryUtil.xPathFactory.getClass().getName());\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.CharInfo.shouldMapAttrChar",
	"Comment": "tell if the character argument that is froman attribute value has a mapping to a string.",
	"Method": "boolean shouldMapAttrChar(int value){\r\n    if (value < ASCII_MAX)\r\n        return shouldMapAttrChar_ASCII[value];\r\n    return get(value);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMemberProperties.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionMove.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTAltChunk.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTGroupChrPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTBorder.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTUsers.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTFunc.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTChar.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.getRealInstanceClassName",
	"Comment": "finds out the real class name of instance matching this fact if possible",
	"Method": "String getRealInstanceClassName(){\r\n    if (realInstanceClass == null) {\r\n        return null;\r\n    }\r\n    return ClassName.toSlashedClassName(realInstanceClass.getClassName());\r\n}"
}, {
	"Path": "org.nustaq.serialization.coders.FSTBytezEncoder.close",
	"Comment": "close and flush to underlying stream if present. the stream is also closed",
	"Method": "void close(){\r\n    conf.returnObject(clnames);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.addLocation",
	"Comment": "adds location for a taint source or path to remember for reporting",
	"Method": "void addLocation(TaintLocation location,boolean isKnownTaintSource){\r\n    Objects.requireNonNull(location, \"location is null\");\r\n    if (isKnownTaintSource) {\r\n        taintLocations.add(location);\r\n    } else {\r\n        unknownLocations.add(location);\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellStyleXfs.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.SingleByteFont.hasAdditionalEncodings",
	"Comment": "indicates whether the encoding has additional encodings besides the primary encoding.",
	"Method": "boolean hasAdditionalEncodings(){\r\n    return (this.additionalEncodings != null) && (this.additionalEncodings.size() > 0);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMeasureDimensionMaps.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.DefinedNames.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ObjectFactory.findJarServiceProviderName",
	"Comment": "find the name of service provider using jar service provider mechanism",
	"Method": "String findJarServiceProviderName(String factoryId){\r\n    String serviceId = SERVICES_PATH + factoryId;\r\n    InputStream is = null;\r\n    ClassLoader cl = findClassLoader();\r\n    is = SecuritySupport.getResourceAsStream(cl, serviceId);\r\n    if (is == null) {\r\n        ClassLoader current = ObjectFactory.class.getClassLoader();\r\n        if (cl != current) {\r\n            cl = current;\r\n            is = SecuritySupport.getResourceAsStream(cl, serviceId);\r\n        }\r\n    }\r\n    if (is == null) {\r\n        return null;\r\n    }\r\n    debugPrintln(\"found jar resource=\" + serviceId + \" using ClassLoader: \" + cl);\r\n    BufferedReader rd;\r\n    try {\r\n        rd = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n    } catch (java.io.UnsupportedEncodingException e) {\r\n        rd = new BufferedReader(new InputStreamReader(is));\r\n    }\r\n    String factoryClassName = null;\r\n    try {\r\n        factoryClassName = rd.readLine();\r\n    } catch (IOException x) {\r\n        return null;\r\n    } finally {\r\n        try {\r\n            rd.close();\r\n        } catch (IOException exc) {\r\n        }\r\n    }\r\n    if (factoryClassName != null && !\"\".equals(factoryClassName)) {\r\n        debugPrintln(\"found in resource, value=\" + factoryClassName);\r\n        return factoryClassName;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTConditionalFormats.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.XMLChar.isSupplemental",
	"Comment": "returns true if the specified character is a supplemental character.",
	"Method": "boolean isSupplemental(int c){\r\n    return (c >= 0x10000 && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.endpoint.TapestryEndpointDetectorTest.detectTapestryPageWithFrameworkReference",
	"Comment": "this first code sample has some annotation and type imports.",
	"Method": "void detectTapestryPageWithFrameworkReference(){\r\n    String[] files = { getClassFilePath(\"testcode/pages/TapestryPage\") };\r\n    EasyBugReporter reporter = spy(new SecurityReporter());\r\n    analyze(files, reporter);\r\n    verify(reporter).doReportBug(bugDefinition().bugType(\"TAPESTRY_ENDPOINT\").inClass(\"TapestryPage\").build());\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTBooleanProperty.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToStream.setWriter",
	"Comment": "specifies a writer to which the document should be serialized.this method should not be called while the serializer is inthe process of serializing a document.",
	"Method": "void setWriter(Writer writer){\r\n    setWriterInternal(writer, true);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTImage.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTDocEvents.getEventDocBuildingBlockAfterInsert",
	"Comment": "gets the value of the eventdocbuildingblockafterinsert property.",
	"Method": "Object getEventDocBuildingBlockAfterInsert(){\r\n    return eventDocBuildingBlockAfterInsert;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTComment.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.jeasy.rules.api.Facts.put",
	"Comment": "put a fact in the working memory.this will replace any fact having the same name.",
	"Method": "Object put(String name,Object fact){\r\n    Objects.requireNonNull(name);\r\n    return facts.put(name, fact);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.injection.InjectionSink.generateBugInstance",
	"Comment": "uses immutable values, updated priority and added lines for reporting",
	"Method": "BugInstance generateBugInstance(boolean taintedInsideMethod){\r\n    BugInstance bug = new BugInstance(detector, bugType, originalPriority);\r\n    bug.addClassAndMethod(classContext.getJavaClass(), method);\r\n    bug.addSourceLine(SourceLineAnnotation.fromVisitedInstruction(classContext, method, instructionHandle));\r\n    addMessage(bug, \"Sink method\", sinkMethod);\r\n    addMessage(bug, \"Sink parameter\", String.valueOf(parameterOffset));\r\n    for (UnknownSource source : sources) {\r\n        if (source.getSourceType() == UnknownSourceType.FIELD) {\r\n            addMessage(bug, \"Unknown source\", source.getSignatureField());\r\n        } else if (source.getSourceType() == UnknownSourceType.RETURN) {\r\n            if (isExclude(source.getSignatureMethod()))\r\n                continue;\r\n            addMessage(bug, \"Unknown source\", source.getSignatureMethod());\r\n        }\r\n    }\r\n    if (sinkPriority != UNKNOWN_SINK_PRIORITY) {\r\n        if (sinkPriority < originalPriority) {\r\n            bug.setPriority(sinkPriority);\r\n            addMessage(bug, \"Method usage\", \"with tainted arguments detected\");\r\n        } else if (sinkPriority > originalPriority) {\r\n            bug.setPriority(Priorities.LOW_PRIORITY);\r\n            addMessage(bug, \"Method usage\", \"detected only with safe arguments\");\r\n        }\r\n    } else if (!taintedInsideMethod) {\r\n        addMessage(bug, \"Method usage\", \"not detected\");\r\n    }\r\n    Collections.sort(lines);\r\n    SourceLineAnnotation annotation = null;\r\n    for (Iterator<SourceLineAnnotation> it = lines.iterator(); it.hasNext(); ) {\r\n        SourceLineAnnotation prev = annotation;\r\n        annotation = it.next();\r\n        if (prev != null && prev.getClassName().equals(annotation.getClassName()) && prev.getStartLine() == annotation.getStartLine()) {\r\n            it.remove();\r\n        }\r\n    }\r\n    for (SourceLineAnnotation sourceLine : lines) {\r\n        bug.addSourceLine(sourceLine);\r\n    }\r\n    return bug;\r\n}"
}, {
	"Path": "org.docx4j.dml.wordprocessingDrawing.Inline.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTBorder.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.webextension_2010_11.CTOsfWebExtensionReference.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.client.BaseGenieClient.addConfigParamsFromConfig",
	"Comment": "private helper method to add network configurations to okhttp builder",
	"Method": "void addConfigParamsFromConfig(OkHttpClient.Builder builder,GenieNetworkConfiguration genieNetworkConfiguration){\r\n    if (genieNetworkConfiguration.getConnectTimeout() != GenieNetworkConfiguration.DEFAULT_TIMEOUT) {\r\n        builder.connectTimeout(genieNetworkConfiguration.getConnectTimeout(), TimeUnit.MILLISECONDS);\r\n    }\r\n    if (genieNetworkConfiguration.getReadTimeout() != GenieNetworkConfiguration.DEFAULT_TIMEOUT) {\r\n        builder.readTimeout(genieNetworkConfiguration.getReadTimeout(), TimeUnit.MILLISECONDS);\r\n    }\r\n    if (genieNetworkConfiguration.getWriteTimeout() != GenieNetworkConfiguration.DEFAULT_TIMEOUT) {\r\n        builder.writeTimeout(genieNetworkConfiguration.getWriteTimeout(), TimeUnit.MILLISECONDS);\r\n    }\r\n    builder.retryOnConnectionFailure(genieNetworkConfiguration.isRetryOnConnectionFailure());\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.util.CodePageUtil.getBytesInCodePage",
	"Comment": "converts a string into bytes, in the equivalent character encoding to the supplied codepage number.",
	"Method": "byte[] getBytesInCodePage(String string,int codepage){\r\n    String encoding = codepageToEncoding(codepage);\r\n    return string.getBytes(encoding);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.hpsf.DocumentSummaryInformation.getScale",
	"Comment": "returns true when scaling of the thumbnail isdesired, false if cropping is desired.",
	"Method": "boolean getScale(){\r\n    return getPropertyBooleanValue(PropertyIDMap.PID_SCALE);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompatSetting.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTOval.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.type1.AFMFile.getChar",
	"Comment": "returns the character metrics associated with the character name.",
	"Method": "AFMCharMetrics getChar(String name){\r\n    return (AFMCharMetrics) this.charNameToMetrics.get(name);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotCacheRecords.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTUcharHexNumber.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTScene3D.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.TaintMethodConfig.setOuputTaint",
	"Comment": "sets the output taint of the method describing the taint transfer,copy of the parameter is made and variable index is invalidated",
	"Method": "void setOuputTaint(Taint taint){\r\n    if (taint == null) {\r\n        this.outputTaint = null;\r\n        return;\r\n    }\r\n    Taint taintCopy = new Taint(taint);\r\n    taintCopy.invalidateVariableIndex();\r\n    this.outputTaint = taintCopy;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalSheetName.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.Version.getMaintenanceVersionNum",
	"Comment": "maintenance drop number.optional identifier used to designate maintenance drop applied to a specific release and contains fixes for defects reported. it maintains compatibility with the release and contains no api changes. when missing, it designates the final and complete development drop for a release.",
	"Method": "int getMaintenanceVersionNum(){\r\n    return 2;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTEmpty.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataFields.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFilter.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSharedUser.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTInk.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.transforms.TransformSpi.enginePerformTransform",
	"Comment": "the mega method which must be implemented by the transformation algorithm.",
	"Method": "XMLSignatureInput enginePerformTransform(XMLSignatureInput input,OutputStream os,Transform transformObject,XMLSignatureInput enginePerformTransform,XMLSignatureInput input,Transform transformObject,XMLSignatureInput enginePerformTransform,XMLSignatureInput input){\r\n    return enginePerformTransform(input, null);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableStyleElement.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTDocEvents.getEventDocContentControlContentUpdate",
	"Comment": "gets the value of the eventdoccontentcontrolcontentupdate property.",
	"Method": "Object getEventDocContentControlContentUpdate(){\r\n    return eventDocContentControlContentUpdate;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWorkbookProtection.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.getPotentialValue",
	"Comment": "returns the constant value that will be set under a specific condition",
	"Method": "String getPotentialValue(){\r\n    return potentialValue;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTSdtCheckboxSymbol.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToHTMLSAXHandler.comment",
	"Comment": "receive notification of a comment anywhere in the document. this callbackwill be used for comments inside or outside the document element.",
	"Method": "void comment(char[] ch,int start,int length){\r\n    flushPending();\r\n    if (m_lexHandler != null)\r\n        m_lexHandler.comment(ch, start, length);\r\n    if (m_tracer != null)\r\n        super.fireCommentEvent(ch, start, length);\r\n    return;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTUsers.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.hasParameters",
	"Comment": "checks if the taint state of this fact depends on the method arguments",
	"Method": "boolean hasParameters(){\r\n    return !parameters.isEmpty();\r\n}"
}, {
	"Path": "org.xlsx4j.schemas.microsoft.com.office.excel_2008_2.main.CTDefinedNameArgumentDescriptions.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTextFields.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "me.weishu.epic.art.method.ArtMethod.compile",
	"Comment": "force compile the method to avoid interpreter mode.this is only used above android n",
	"Method": "boolean compile(){\r\n    if (constructor != null) {\r\n        return EpicNative.compileMethod(constructor);\r\n    } else {\r\n        return EpicNative.compileMethod(method);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.SdtContentBlock.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTParameter.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.CharInfo.setASCIItextDirty",
	"Comment": "if the character is in the ascii range thenmark it as needing replacement witha string on output if it occurs in a text node.",
	"Method": "void setASCIItextDirty(int j){\r\n    if (0 <= j && j < ASCII_MAX) {\r\n        shouldMapTextChar_ASCII[j] = true;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CommentRangeEnd.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTLang.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataFields.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.XMLChar.supplemental",
	"Comment": "returns true the supplemental character corresponding to the givensurrogates.",
	"Method": "int supplemental(char h,char l){\r\n    return (h - 0xD800) * 0x400 + (l - 0xDC00) + 0x10000;\r\n}"
}, {
	"Path": "org.docx4j.math.CTSPre.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTRules.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPageBreak.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getSuppressSpacingAtTopOfPage",
	"Comment": "gets the value of the suppressspacingattopofpage property.",
	"Method": "BooleanDefaultTrue getSuppressSpacingAtTopOfPage(){\r\n    return suppressSpacingAtTopOfPage;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCustomXmlRow.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.BATBlock.createBATBlocks",
	"Comment": "create an array of batblocks from an array of int blockallocation table entries",
	"Method": "BATBlock[] createBATBlocks(POIFSBigBlockSize bigBlockSize,int[] entries){\r\n    int block_count = calculateStorageRequirements(bigBlockSize, entries.length);\r\n    BATBlock[] blocks = new BATBlock[block_count];\r\n    int index = 0;\r\n    int remaining = entries.length;\r\n    int _entries_per_block = bigBlockSize.getBATEntriesPerBlock();\r\n    for (int j = 0; j < entries.length; j += _entries_per_block) {\r\n        blocks[index++] = new BATBlock(bigBlockSize, entries, j, (remaining > _entries_per_block) ? j + _entries_per_block : entries.length);\r\n        remaining -= _entries_per_block;\r\n    }\r\n    return blocks;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDdeItems.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.netflix.genie.agent.execution.statemachine.StateMachineAutoConfiguration.eventDrivenTransitions",
	"Comment": "provide a lazy bean definition for the event driven transitions within the state machine.",
	"Method": "Collection<Triple<States, Events, States>> eventDrivenTransitions(){\r\n    return // Regular execution\r\n    Arrays.asList(// Job cancellation\r\n    Triple.of(States.READY, Events.START, States.INITIALIZE), // Job cancellation\r\n    Triple.of(States.INITIALIZE, Events.INITIALIZE_COMPLETE, States.CONFIGURE_AGENT), // Job cancellation\r\n    Triple.of(States.CONFIGURE_AGENT, Events.CONFIGURE_AGENT_COMPLETE, States.RESOLVE_JOB_SPECIFICATION), // Job cancellation\r\n    Triple.of(States.RESOLVE_JOB_SPECIFICATION, Events.RESOLVE_JOB_SPECIFICATION_COMPLETE, States.SETUP_JOB), // Job cancellation\r\n    Triple.of(States.SETUP_JOB, Events.SETUP_JOB_COMPLETE, States.LAUNCH_JOB), // Job cancellation\r\n    Triple.of(States.LAUNCH_JOB, Events.LAUNCH_JOB_COMPLETE, States.MONITOR_JOB), // Job cancellation\r\n    Triple.of(States.MONITOR_JOB, Events.MONITOR_JOB_COMPLETE, States.CLEANUP_JOB), // Job cancellation\r\n    Triple.of(States.CLEANUP_JOB, Events.CLEANUP_JOB_COMPLETE, States.SHUTDOWN), Triple.of(States.SHUTDOWN, Events.SHUTDOWN_COMPLETE, States.END), Triple.of(States.READY, Events.CANCEL_JOB_LAUNCH, States.CLEANUP_JOB), Triple.of(States.INITIALIZE, Events.CANCEL_JOB_LAUNCH, States.CLEANUP_JOB), Triple.of(States.CONFIGURE_AGENT, Events.CANCEL_JOB_LAUNCH, States.CLEANUP_JOB), Triple.of(States.RESOLVE_JOB_SPECIFICATION, Events.CANCEL_JOB_LAUNCH, States.CLEANUP_JOB), Triple.of(States.SETUP_JOB, Events.CANCEL_JOB_LAUNCH, States.CLEANUP_JOB));\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.DataInputBlock.readIntLE",
	"Comment": "reads an int which spans the end of prevblock and the start of this block.",
	"Method": "int readIntLE(int readIntLE,DataInputBlock prevBlock,int prevBlockAvailable){\r\n    byte[] buf = new byte[4];\r\n    readSpanning(prevBlock, prevBlockAvailable, buf);\r\n    int b0 = buf[0] & 0xFF;\r\n    int b1 = buf[1] & 0xFF;\r\n    int b2 = buf[2] & 0xFF;\r\n    int b3 = buf[3] & 0xFF;\r\n    return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtContentRun.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGroupLevels.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.utils.BufferUtil.readInputStream",
	"Comment": "fully reads the given inputstream, returning its contents as a bytebuffer",
	"Method": "ByteBuffer readInputStream(InputStream in){\r\n    ReadableByteChannel ch = Channels.newChannel(in);\r\n    List list = new LinkedList();\r\n    int sum = 0, read = 0;\r\n    do {\r\n        ByteBuffer b = createByteBuffer(BUFFER_SIZE);\r\n        read = ch.read(b);\r\n        if (read > 0) {\r\n            b.flip();\r\n            list.add(b);\r\n            sum += read;\r\n        }\r\n    } while (read != -1);\r\n    if (list.size() == 1) {\r\n        return (ByteBuffer) list.get(0);\r\n    }\r\n    ByteBuffer bb = createByteBuffer(sum);\r\n    Iterator ite = list.iterator();\r\n    while (ite.hasNext()) {\r\n        bb.put((ByteBuffer) ite.next());\r\n    }\r\n    list.clear();\r\n    return bb;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTLongHexNumber.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTEm.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.Tag.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFonts.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTColor.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTAcc.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setDoNotDisplayPageBoundaries",
	"Comment": "sets the value of the donotdisplaypageboundaries property.",
	"Method": "void setDoNotDisplayPageBoundaries(BooleanDefaultTrue value){\r\n    this.doNotDisplayPageBoundaries = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTablePart.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPartGallery.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFilterColumn.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w16cid.CTCommentsIds.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.nustaq.serialization.FSTClazzLineageInfo.getSpecificity",
	"Comment": "returns the specificity of the specified class as defined above.",
	"Method": "int getSpecificity(Class<?> clazz){\r\n    if (clazz == null)\r\n        return 0;\r\n    final LineageInfo lineageInfo = FSTClazzLineageInfo.getLineageInfo(clazz);\r\n    return lineageInfo == null ? 0 : lineageInfo.specificity;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.webextension_2010_11.CTOsfWebExtensionProperty.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTChartsheetViews.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTSpacingRule.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTDocEvents.getEventDocContentControlBeforeDelete",
	"Comment": "gets the value of the eventdoccontentcontrolbeforedelete property.",
	"Method": "Object getEventDocContentControlBeforeDelete(){\r\n    return eventDocContentControlBeforeDelete;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.JaxbXmlPartXPathAware.unmarshal",
	"Comment": "unmarshalling via dom document can be 4x slower than unmarshalling\tthe inputstream using xmlstreamreader, so we avoid doing that where possible.",
	"Method": "E unmarshal(java.io.InputStream is,E unmarshal,java.io.InputStream is,boolean forceBinder,E unmarshal,org.w3c.dom.Element el){\r\n    try {\r\n        log.debug(\"For \" + this.getClass().getName() + \", unmarshall via binder\");\r\n        if (Context.jaxbImplementation == JAXBImplementation.ECLIPSELINK_MOXy) {\r\n            log.debug(\"MOXy: pre-emptively transforming\");\r\n            try {\r\n                Templates mcPreprocessorXslt = JaxbValidationEventHandler.getMcPreprocessor();\r\n                DOMResult result = new DOMResult();\r\n                XmlUtils.transform(new DOMSource(el), mcPreprocessorXslt, null, result);\r\n                org.w3c.dom.Document doc = (org.w3c.dom.Document) result.getNode();\r\n                el = doc.getDocumentElement();\r\n            } catch (Exception e) {\r\n                throw new JAXBException(\"Preprocessing exception\", e);\r\n            }\r\n        }\r\n        binder = jc.createBinder();\r\n        JaxbValidationEventHandler eventHandler = new JaxbValidationEventHandler();\r\n        eventHandler.setContinue(false);\r\n        binder.setEventHandler(eventHandler);\r\n        try {\r\n            unwrapUsually(binder, el);\r\n        } catch (Exception ue) {\r\n            if (ue instanceof UnmarshalException) {\r\n            } else {\r\n                log.warn(ue.getMessage(), ue);\r\n                log.info(\".. can recover if problem is w:tblW/@w:w\");\r\n            }\r\n            log.info(\"encountered unexpected content; pre-processing\");\r\n            org.w3c.dom.Document doc = null;\r\n            try {\r\n                if (el instanceof org.w3c.dom.Document) {\r\n                    doc = (org.w3c.dom.Document) el;\r\n                } else {\r\n                    doc = el.getOwnerDocument();\r\n                }\r\n                eventHandler.setContinue(true);\r\n                DOMResult result = new DOMResult();\r\n                Templates mcPreprocessorXslt = JaxbValidationEventHandler.getMcPreprocessor();\r\n                XmlUtils.transform(doc, mcPreprocessorXslt, null, result);\r\n                doc = (org.w3c.dom.Document) result.getNode();\r\n                jaxbElement = (E) XmlUtils.unwrap(binder.unmarshal(doc));\r\n            } catch (ClassCastException cce) {\r\n                log.warn(\"Binder not available for this docx\");\r\n                Unmarshaller u = jc.createUnmarshaller();\r\n                eventHandler.setContinue(true);\r\n                u.setEventHandler(eventHandler);\r\n                jaxbElement = (E) XmlUtils.unwrap(u.unmarshal(doc));\r\n            } catch (Exception e) {\r\n                throw new JAXBException(\"Preprocessing exception\", e);\r\n            }\r\n        }\r\n        return jaxbElement;\r\n    } catch (JAXBException e) {\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDivBdr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotHierarchy.setMultipleItemSelectionAllowed",
	"Comment": "sets the value of the multipleitemselectionallowed property.",
	"Method": "void setMultipleItemSelectionAllowed(Boolean value){\r\n    this.multipleItemSelectionAllowed = value;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSMiniStore.getBATBlockAndIndex",
	"Comment": "returns the batblock that handles the specified offset, and the relative index within it",
	"Method": "BATBlockAndIndex getBATBlockAndIndex(int offset){\r\n    return BATBlock.getSBATBlockAndIndex(offset, _header, _sbat_blocks);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTLock.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTBoolean.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOleObjects.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTGroupChr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setDoNotIncludeSubdocsInStats",
	"Comment": "sets the value of the donotincludesubdocsinstats property.",
	"Method": "void setDoNotIncludeSubdocsInStats(BooleanDefaultTrue value){\r\n    this.doNotIncludeSubdocsInStats = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTBookView.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w15.CTSdtRepeatedSection.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.TcPrInner.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFont.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCaption.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotFilters.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTField.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.isSafe",
	"Comment": "checks whether values matching this fact are always trusted",
	"Method": "boolean isSafe(){\r\n    return state.isSafe;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPhoneticPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.XMLIndenter.indentSilent",
	"Comment": "indents the given xml string.this method does not throw any exception out of convenience, instead it returns aboolean value to indicate whether the xml indenting was performed succesfully.",
	"Method": "String indentSilent(String xml,boolean indentSilent,Reader r,Writer w){\r\n    try {\r\n        indent(r, w);\r\n        return true;\r\n    } catch (Exception ex) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTXf.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTFill.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTOnOff.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.URIHelper.createPartName",
	"Comment": "create an opc compliant part name by throwing an exception if the\tspecified name is not valid.",
	"Method": "PartName createPartName(URI partUri,PartName createPartName,String partName){\r\n    URI partNameURI;\r\n    try {\r\n        partNameURI = new URI(partName);\r\n    } catch (URISyntaxException e) {\r\n        throw new InvalidFormatException(e.getMessage());\r\n    }\r\n    return createPartName(partNameURI);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getDrawingGridHorizontalOrigin",
	"Comment": "gets the value of the drawinggridhorizontalorigin property.",
	"Method": "CTTwipsMeasure getDrawingGridHorizontalOrigin(){\r\n    return drawingGridHorizontalOrigin;\r\n}"
}, {
	"Path": "org.docx4j.convert.out.flatOpcXml.FlatOpcXmlCreator.getFlatDomDocument",
	"Comment": "return the wordml package in flat opc format, as a w3c dom document",
	"Method": "Document getFlatDomDocument(WordprocessingMLPackage wordMLPackage){\r\n    FlatOpcXmlCreator worker = new FlatOpcXmlCreator(wordMLPackage);\r\n    org.docx4j.xmlPackage.Package pkg = worker.get();\r\n    org.w3c.dom.Document doc;\r\n    try {\r\n        JAXBContext jc = Context.jcXmlPackage;\r\n        Marshaller marshaller = jc.createMarshaller();\r\n        doc = org.docx4j.XmlUtils.neww3cDomDocument();\r\n        marshaller.marshal(pkg, doc);\r\n    } catch (JAXBException e) {\r\n        throw new Docx4JException(\"Couldn't marshal Flat OPC to DOM\", e);\r\n    }\r\n    return doc;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCalcCell.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToHTMLStream.writeAttrURI",
	"Comment": "write the specified string after substituting non ascii characters,with %hh, where hh is the hex of the byte value.",
	"Method": "void writeAttrURI(java.io.Writer writer,String string,boolean doURLEscaping){\r\n    final int end = string.length();\r\n    if (end > m_attrBuff.length) {\r\n        m_attrBuff = new char[end * 2 + 1];\r\n    }\r\n    string.getChars(0, end, m_attrBuff, 0);\r\n    final char[] chars = m_attrBuff;\r\n    int cleanStart = 0;\r\n    int cleanLength = 0;\r\n    char ch = 0;\r\n    for (int i = 0; i < end; i++) {\r\n        ch = chars[i];\r\n        if ((ch < 32) || (ch > 126)) {\r\n            if (cleanLength > 0) {\r\n                writer.write(chars, cleanStart, cleanLength);\r\n                cleanLength = 0;\r\n            }\r\n            if (doURLEscaping) {\r\n                if (ch <= 0x7F) {\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(ch));\r\n                } else if (ch <= 0x7FF) {\r\n                    int high = (ch >> 6) | 0xC0;\r\n                    int low = (ch & 0x3F) | 0x80;\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(high));\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(low));\r\n                } else if (Encodings.isHighUTF16Surrogate(ch)) {\r\n                    int highSurrogate = ((int) ch) & 0x03FF;\r\n                    int wwww = ((highSurrogate & 0x03C0) >> 6);\r\n                    int uuuuu = wwww + 1;\r\n                    int zzzz = (highSurrogate & 0x003C) >> 2;\r\n                    int yyyyyy = ((highSurrogate & 0x0003) << 4) & 0x30;\r\n                    ch = chars[++i];\r\n                    int lowSurrogate = ((int) ch) & 0x03FF;\r\n                    yyyyyy = yyyyyy | ((lowSurrogate & 0x03C0) >> 6);\r\n                    int xxxxxx = (lowSurrogate & 0x003F);\r\n                    int byte1 = 0xF0 | (uuuuu >> 2);\r\n                    int byte2 = 0x80 | (((uuuuu & 0x03) << 4) & 0x30) | zzzz;\r\n                    int byte3 = 0x80 | yyyyyy;\r\n                    int byte4 = 0x80 | xxxxxx;\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(byte1));\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(byte2));\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(byte3));\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(byte4));\r\n                } else {\r\n                    int high = (ch >> 12) | 0xE0;\r\n                    int middle = ((ch & 0x0FC0) >> 6) | 0x80;\r\n                    int low = (ch & 0x3F) | 0x80;\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(high));\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(middle));\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(low));\r\n                }\r\n            } else if (escapingNotNeeded(ch)) {\r\n                writer.write(ch);\r\n            } else {\r\n                writer.write(\"&#\");\r\n                writer.write(Integer.toString(ch));\r\n                writer.write(';');\r\n            }\r\n            cleanStart = i + 1;\r\n        } else if (ch == '\"') {\r\n            if (cleanLength > 0) {\r\n                writer.write(chars, cleanStart, cleanLength);\r\n                cleanLength = 0;\r\n            }\r\n            if (doURLEscaping)\r\n                writer.write(\""\
	");\r\n            else\r\n                writer.write(\"&quot;\");\r\n            cleanStart = i + 1;\r\n        } else if (ch == '&') {\r\n            if (cleanLength > 0) {\r\n                writer.write(chars, cleanStart, cleanLength);\r\n                cleanLength = 0;\r\n            }\r\n            writer.write(\"&amp;\");\r\n            cleanStart = i + 1;\r\n        } else {\r\n            cleanLength++;\r\n        }\r\n    }\r\n    if (cleanLength > 1) {\r\n        if (cleanStart == 0)\r\n            writer.write(string);\r\n        else\r\n            writer.write(chars, cleanStart, cleanLength);\r\n    } else if (cleanLength == 1) {\r\n        writer.write(ch);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.convert.out.common.writer.AbstractTableWriterModel.getTc",
	"Comment": "the tc could be inside something else, so find it recursively.",
	"Method": "Node getTc(Node wtrNode,int wanted,IntRef current){\r\n    for (int i = 0; i < wtrNode.getChildNodes().getLength(); i++) {\r\n        Node thisChild = wtrNode.getChildNodes().item(i);\r\n        if (thisChild.getNodeType() != 1) {\r\n            continue;\r\n        }\r\n        log.debug(\"Looking at \" + thisChild.getLocalName() + \"; have encountered \" + current.i);\r\n        if (thisChild.getLocalName().equals(\"tc\")) {\r\n            if (current.i == wanted)\r\n                return thisChild;\r\n            current.increment();\r\n        } else {\r\n            Node n = getTc(thisChild, wanted, current);\r\n            if (n != null)\r\n                return n;\r\n        }\r\n    }\r\n    log.error(\"Couldn't find tc in: \" + XmlUtils.w3CDomNodeToString(wtrNode));\r\n    return null;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.SheetData.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.FontFileReader.readTTFUShort",
	"Comment": "read 2 bytes unsigned at position pos without changing current position.",
	"Method": "int readTTFUShort(int readTTFUShort,long pos){\r\n    long cp = getCurrentPos();\r\n    seekSet(pos);\r\n    int ret = readTTFUShort();\r\n    seekSet(cp);\r\n    return ret;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.MainDocumentPart.attachTemplate",
	"Comment": "attach a template to this document.\tthis is just an easy way to access the same method in documentsettingspart",
	"Method": "void attachTemplate(String templatePath){\r\n    DocumentSettingsPart dsp = null;\r\n    try {\r\n        dsp = this.getDocumentSettingsPart(true);\r\n    } catch (InvalidFormatException e) {\r\n        log.error(e.getMessage(), e);\r\n    }\r\n    dsp.attachTemplate(templatePath);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2010.wordprocessingShape.CTWordprocessingShape.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTMR.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToStream.isEscapingDisabled",
	"Comment": "tell if the character escaping should be disabled for the current state.",
	"Method": "boolean isEscapingDisabled(){\r\n    return m_disableOutputEscapingStates.peekOrFalse();\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalReference.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPCDSDTCEntries.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Workbook.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTDocEvents.setEventDocContentControlOnExit",
	"Comment": "sets the value of the eventdoccontentcontrolonexit property.",
	"Method": "void setEventDocContentControlOnExit(Object value){\r\n    this.eventDocContentControlOnExit = value;\r\n}"
}, {
	"Path": "org.nustaq.offheap.BinaryQueue.readInt",
	"Comment": "read an int. throws an exception if not enough data is present",
	"Method": "int readInt(){\r\n    if (available() < 4) {\r\n        throw new RuntimeException(\"not enough data available, check available() > 4 before calling\");\r\n    }\r\n    int ch1 = poll();\r\n    int ch2 = poll();\r\n    int ch3 = poll();\r\n    int ch4 = poll();\r\n    return (ch4 << 24) + (ch3 << 16) + (ch2 << 8) + (ch1 << 0);\r\n}"
}, {
	"Path": "org.docx4j.math.CTMC.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellSmartTags.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTXstringWhitespace.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.hpsf.PropertySet.isPropertySetStream",
	"Comment": "checks whether a byte array is in the horrible property setformat.",
	"Method": "boolean isPropertySetStream(InputStream stream,boolean isPropertySetStream,byte[] src,int offset,int length){\r\n    int o = offset;\r\n    final int byteOrder = LittleEndian.getUShort(src, o);\r\n    o += LittleEndian.SHORT_SIZE;\r\n    byte[] temp = new byte[LittleEndian.SHORT_SIZE];\r\n    LittleEndian.putShort(temp, 0, (short) byteOrder);\r\n    if (!Util.equal(temp, BYTE_ORDER_ASSERTION))\r\n        return false;\r\n    final int format = LittleEndian.getUShort(src, o);\r\n    o += LittleEndian.SHORT_SIZE;\r\n    temp = new byte[LittleEndian.SHORT_SIZE];\r\n    LittleEndian.putShort(temp, 0, (short) format);\r\n    if (!Util.equal(temp, FORMAT_ASSERTION))\r\n        return false;\r\n    o += LittleEndian.INT_SIZE;\r\n    o += ClassID.LENGTH;\r\n    final long sectionCount = LittleEndian.getUInt(src, o);\r\n    o += LittleEndian.INT_SIZE;\r\n    if (sectionCount < 0)\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTRel.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w16cid.CTCommentId.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMemberProperty.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.nustaq.serialization.coders.FSTBytezEncoder.flush",
	"Comment": "writes current buffer to underlying output and resets buffer.",
	"Method": "void flush(){\r\n    if (outStream != null)\r\n        outStream.write(getBuffer(), 0, (int) pos);\r\n    pos = 0;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTColHierarchiesUsage.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.TrPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.eclipse.compare.rangedifferencer.RangeDifference.ancestorStart",
	"Comment": "returns the start index of the entity range on the ancestor side.",
	"Method": "int ancestorStart(){\r\n    return lAncestorStart;\r\n}"
}, {
	"Path": "org.docx4j.wml.SdtContentBlock.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWebPublishObjects.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTWriteProtection.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTBorder.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTRubyPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.BookViews.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWebPublishItems.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTReviewed.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.foray.font.format.Panose.makeInstance",
	"Comment": "creates a new panose instance, first checking it for validity.",
	"Method": "Panose makeInstance(byte[] panoseArray){\r\n    final String panoseValidationMessage = Panose.validPanose(panoseArray);\r\n    if (panoseValidationMessage != null) {\r\n        throw new IllegalArgumentException(\"Illegal Panose Array: \" + panoseValidationMessage);\r\n    }\r\n    return new Panose(panoseArray);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.XMLChar.isValid",
	"Comment": "returns true if the specified character is valid. this methodalso checks the surrogate character range from 0x10000 to 0x10ffff.if the program chooses to apply the mask directly to thechars array, then they are responsible for checkingthe surrogate character range.",
	"Method": "boolean isValid(int c){\r\n    return (c < 0x10000 && (CHARS[c] & MASK_VALID) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.MainDocumentPart.createParagraphOfText",
	"Comment": "create a paragraph containing the string simpletext,\twithout adding it to the document.if passed null, the result\tis an empty p.",
	"Method": "org.docx4j.wml.P createParagraphOfText(String simpleText){\r\n    org.docx4j.wml.ObjectFactory factory = Context.getWmlObjectFactory();\r\n    org.docx4j.wml.P para = factory.createP();\r\n    if (simpleText != null) {\r\n        org.docx4j.wml.Text t = factory.createText();\r\n        t.setValue(simpleText);\r\n        org.docx4j.wml.R run = factory.createR();\r\n        run.getContent().add(t);\r\n        para.getContent().add(run);\r\n    }\r\n    return para;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.TTFSubSetFile.scanGlyphs",
	"Comment": "scan all the original glyphs for composite glyphs and add those glyphsto the glyphmapping also rewrite the composite glyph pointers to the newmapping",
	"Method": "void scanGlyphs(FontFileReader in,Map glyphs){\r\n    TTFDirTabEntry entry = (TTFDirTabEntry) dirTabs.get(\"glyf\");\r\n    Map newComposites = null;\r\n    Map allComposites = new java.util.HashMap();\r\n    int newIndex = glyphs.size();\r\n    if (entry != null) {\r\n        while (newComposites == null || newComposites.size() > 0) {\r\n            newComposites = new java.util.HashMap();\r\n            Iterator e = glyphs.keySet().iterator();\r\n            while (e.hasNext()) {\r\n                Integer origIndex = (Integer) e.next();\r\n                if (in.readTTFShort(entry.getOffset() + mtxTab[origIndex.intValue()].getOffset()) < 0) {\r\n                    allComposites.put(origIndex, glyphs.get(origIndex));\r\n                    List composites = getIncludedGlyphs(in, (int) entry.getOffset(), origIndex);\r\n                    Iterator cps = composites.iterator();\r\n                    while (cps.hasNext()) {\r\n                        Integer cIdx = (Integer) cps.next();\r\n                        if (glyphs.get(cIdx) == null && newComposites.get(cIdx) == null) {\r\n                            newComposites.put(cIdx, new Integer(newIndex));\r\n                            newIndex++;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            Iterator m = newComposites.keySet().iterator();\r\n            while (m.hasNext()) {\r\n                Integer im = (Integer) m.next();\r\n                glyphs.put(im, newComposites.get(im));\r\n            }\r\n        }\r\n        Iterator ce = allComposites.keySet().iterator();\r\n        while (ce.hasNext()) {\r\n            remapComposite(in, glyphs, (int) entry.getOffset(), (Integer) ce.next());\r\n        }\r\n    } else {\r\n        throw new IOException(\"Can't find glyf table\");\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.c14n.implementations.NameSpaceSymbTable.getMapping",
	"Comment": "gets the attribute node that defines the binding for the prefix.",
	"Method": "Attr getMapping(String prefix){\r\n    NameSpaceSymbEntry entry = symb.get(prefix);\r\n    if (entry == null) {\r\n        return null;\r\n    }\r\n    if (entry.rendered) {\r\n        return null;\r\n    }\r\n    entry = (NameSpaceSymbEntry) entry.clone();\r\n    needsClone();\r\n    symb.put(prefix, entry);\r\n    entry.rendered = true;\r\n    entry.lastrendered = entry.uri;\r\n    return entry.n;\r\n}"
}, {
	"Path": "org.docx4j.wml.DelText.getSpace",
	"Comment": "content contains significant whitespace",
	"Method": "String getSpace(){\r\n    return space;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCustomXmlCell.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTPaperSource.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTColorFilter.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.TblGridBase.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMdxMemeberProp.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.relationships.RelationshipsPart.isPackageRelationshipPart",
	"Comment": "this relationship part is the package relationship part\tif its source is the package.",
	"Method": "boolean isPackageRelationshipPart(){\r\n    return (sourceP instanceof OpcPackage);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCalculatedMembers.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.FontInfo.findAdjustWeight",
	"Comment": "find a font with a given family and style by tryingdifferent font weights according to the spec.",
	"Method": "FontTriplet findAdjustWeight(String family,String style,int weight){\r\n    FontTriplet key = null;\r\n    String f = null;\r\n    int newWeight = weight;\r\n    if (newWeight <= 400) {\r\n        while (f == null && newWeight > 100) {\r\n            newWeight -= 100;\r\n            key = createFontKey(family, style, newWeight);\r\n            f = getInternalFontKey(key);\r\n        }\r\n        newWeight = weight;\r\n        while (f == null && newWeight < 400) {\r\n            newWeight += 100;\r\n            key = createFontKey(family, style, newWeight);\r\n            f = getInternalFontKey(key);\r\n        }\r\n    } else if (newWeight == 500) {\r\n        key = createFontKey(family, style, 400);\r\n        f = getInternalFontKey(key);\r\n    } else if (newWeight > 500) {\r\n        while (f == null && newWeight < 1000) {\r\n            newWeight += 100;\r\n            key = createFontKey(family, style, newWeight);\r\n            f = getInternalFontKey(key);\r\n        }\r\n        newWeight = weight;\r\n        while (f == null && newWeight > 400) {\r\n            newWeight -= 100;\r\n            key = createFontKey(family, style, newWeight);\r\n            f = getInternalFontKey(key);\r\n        }\r\n    }\r\n    if (f == null && weight != 400) {\r\n        key = createFontKey(family, style, 400);\r\n        f = getInternalFontKey(key);\r\n    }\r\n    if (f != null) {\r\n        return key;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.DOM3TreeWalker.isValidQName",
	"Comment": "taken from org.apache.xerces.dom.coredocumentimplchecks if the given qualified name is legal with respectto the version of xml to which this document must conform.",
	"Method": "boolean isValidQName(String prefix,String local,boolean xml11Version){\r\n    if (local == null)\r\n        return false;\r\n    boolean validNCName = false;\r\n    if (!xml11Version) {\r\n        validNCName = (prefix == null || XMLChar.isValidNCName(prefix)) && XMLChar.isValidNCName(local);\r\n    } else {\r\n        validNCName = (prefix == null || XML11Char.isXML11ValidNCName(prefix)) && XML11Char.isXML11ValidNCName(local);\r\n    }\r\n    return validNCName;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataRefs.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPages.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.SectPrBase.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getSelectFldWithFirstOrLastChar",
	"Comment": "gets the value of the selectfldwithfirstorlastchar property.",
	"Method": "BooleanDefaultTrue getSelectFldWithFirstOrLastChar(){\r\n    return selectFldWithFirstOrLastChar;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTExtrusion.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.Lvl.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTChartsheetProtection.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDrawing.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPartType.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.SheetViews.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTArc.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRElt.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.Enum.toString",
	"Comment": "human readable description of this enum item. for use when debugging.",
	"Method": "String toString(){\r\n    return getClass().getName() + \"[\" + m_name + \"]\";\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTObjectAnchor.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getDoNotUseMarginsForDrawingGridOrigin",
	"Comment": "gets the value of the donotusemarginsfordrawinggridorigin property.",
	"Method": "BooleanDefaultTrue getDoNotUseMarginsForDrawingGridOrigin(){\r\n    return doNotUseMarginsForDrawingGridOrigin;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMeasureDimensionMap.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTSPre.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableColumn.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPartGallery.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTR.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTStrokeChild.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTStyleSet.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellXfs.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotCache.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTTextbox.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTDocEvents.setEventDocContentControlOnEnter",
	"Comment": "sets the value of the eventdoccontentcontrolonenter property.",
	"Method": "void setEventDocContentControlOnEnter(Object value){\r\n    this.eventDocContentControlOnEnter = value;\r\n}"
}, {
	"Path": "org.docx4j.fonts.BestMatchingMapper.findClosestPanoseMatch",
	"Comment": "logic to search panose space for closest matching physical \t\tfont file. \t\t\t\treturns key of matching font in physicalfontmap.",
	"Method": "String findClosestPanoseMatch(String documentFontName,org.docx4j.fonts.foray.font.format.Panose documentFontPanose,Map<String, PhysicalFont> physicalFontSpace,int matchThreshold){\r\n    String keywordToMatch = documentFontName.toLowerCase();\r\n    if (documentFontName.indexOf(\" \") > -1) {\r\n        keywordToMatch = keywordToMatch.substring(0, keywordToMatch.indexOf(\" \"));\r\n    }\r\n    String physicalFontKey = null;\r\n    String panoseKey = null;\r\n    Iterator it = physicalFontSpace.entrySet().iterator();\r\n    long bestPanoseMatchValue = -1;\r\n    String matchingPanoseString = null;\r\n    while (it.hasNext()) {\r\n        Map.Entry mapPairs = (Map.Entry) it.next();\r\n        physicalFontKey = (String) mapPairs.getKey();\r\n        PhysicalFont physicalFont = (PhysicalFont) mapPairs.getValue();\r\n        if (physicalFont.getPanose() == null) {\r\n            continue;\r\n        }\r\n        org.docx4j.fonts.foray.font.format.Panose physicalFontPanose = null;\r\n        long panoseMatchValue = MATCH_THRESHOLD + 1;\r\n        try {\r\n            physicalFontPanose = org.docx4j.fonts.foray.font.format.Panose.makeInstance(physicalFont.getPanose().getPanoseArray());\r\n            panoseMatchValue = documentFontPanose.difference(physicalFontPanose, null);\r\n        } catch (IllegalArgumentException e) {\r\n            log.error(e.getMessage());\r\n        }\r\n        boolean trump = false;\r\n        if (panoseMatchValue == bestPanoseMatchValue) {\r\n            if (physicalFont.getName().toLowerCase().indexOf(keywordToMatch) > -1) {\r\n                trump = true;\r\n                log.debug(\"trumped previous best (which was \" + panoseKey + \")\");\r\n            }\r\n        }\r\n        if (log.isDebugEnabled()) {\r\n            if ((panoseMatchValue > bestPanoseMatchValue) && (physicalFont.getName().toLowerCase().indexOf(keywordToMatch) > 0)) {\r\n                log.debug(\"Despite name match, \" + physicalFont.getName() + physicalFont.getPanose() + \" is too far from \" + documentFontPanose + \" .. \" + panoseMatchValue + \" > \" + bestPanoseMatchValue);\r\n            }\r\n        }\r\n        if (trump || bestPanoseMatchValue == -1 || panoseMatchValue < bestPanoseMatchValue) {\r\n            bestPanoseMatchValue = panoseMatchValue;\r\n            matchingPanoseString = physicalFont.getPanose().toString();\r\n            panoseKey = physicalFontKey;\r\n        } else {\r\n        }\r\n    }\r\n    if (panoseKey != null && bestPanoseMatchValue < matchThreshold) {\r\n        log.debug(\"MATCHED \" + panoseKey + \" --> \" + matchingPanoseString + \" distance \" + bestPanoseMatchValue);\r\n        return panoseKey;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTOLEObject.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTUndoInfo.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.XMLUtils.createElementInEncryptionSpace",
	"Comment": "creates an element in the xml encryption specification namespace.",
	"Method": "Element createElementInEncryptionSpace(Document doc,String elementName){\r\n    if (doc == null) {\r\n        throw new RuntimeException(\"Document is null\");\r\n    }\r\n    if (xencPrefix == null || xencPrefix.length() == 0) {\r\n        return doc.createElementNS(EncryptionConstants.EncryptionSpecNS, elementName);\r\n    }\r\n    return doc.createElementNS(EncryptionConstants.EncryptionSpecNS, xencPrefix + \":\" + elementName);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMember.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompatSetting.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.util.LocaleUtil.setUserTimeZone",
	"Comment": "as time zone information is not stored in any format, it can beset before any date calculations take place.this setting is specific to the current thread.",
	"Method": "void setUserTimeZone(TimeZone timezone){\r\n    userTimeZone.set(timezone);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRowItems.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocVar.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadataStrings.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionQueryTableField.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerBase.getNamespaceMappings",
	"Comment": "some users of the serializer may need the current namespace mappings",
	"Method": "NamespaceMappings getNamespaceMappings(){\r\n    return m_prefixMap;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTNumber.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.agent.execution.services.impl.FetchingCacheServiceImpl.getCacheResourceVersionLockFile",
	"Comment": "returns a handle to the lock file of a resource version in the cache",
	"Method": "File getCacheResourceVersionLockFile(String resourceCacheId,long lastModifiedTimestamp,File getCacheResourceVersionLockFile,File resourceVersionDir){\r\n    return new File(resourceVersionDir, LOCK_FILE_NAME);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTLocation.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTAcc.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getDoNotBreakConstrainedForcedTable",
	"Comment": "gets the value of the donotbreakconstrainedforcedtable property.",
	"Method": "BooleanDefaultTrue getDoNotBreakConstrainedForcedTable(){\r\n    return doNotBreakConstrainedForcedTable;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWebPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTHandles.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtCell.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTPlaceholder.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTEdnProps.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.apache.ws.commons.serialize.DOMSerializer.isStartingDocument",
	"Comment": "returns, whether startdocument and\tenddocument events are generated for\tdocument nodes.",
	"Method": "boolean isStartingDocument(){\r\n    return startingDocument;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTLongHexNumber.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.TcMar.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalBook.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTIgnoredErrors.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCacheHierarchies.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.nustaq.offheap.FSTBinaryOffheapMap.getEntryLengthForContentLength",
	"Comment": "called upon add, allows to reserve extra space for later growth per entry",
	"Method": "int getEntryLengthForContentLength(long lengthOfEntry){\r\n    return (int) lengthOfEntry;\r\n}"
}, {
	"Path": "org.nustaq.serialization.simpleapi.OnHeapCoder.toByteArray",
	"Comment": "throws fstbuffertoosmallexcpetion in case object does not fit into given rangezero copy method",
	"Method": "int toByteArray(Object o,byte arr,int startIndex,int availableSize,byte[] toByteArray,Object o){\r\n    try {\r\n        out.resetForReUse();\r\n        writeTarget.setBase(buff, 0, buff.length);\r\n        try {\r\n            out.writeObject(o);\r\n        } catch (IOException e) {\r\n            FSTUtil.<RuntimeException>rethrow(e);\r\n        }\r\n        return out.getCopyOfWrittenBuffer();\r\n    } catch (FSTBufferTooSmallException ex) {\r\n        buff = new byte[buff.length * 2];\r\n        return toByteArray(o);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.math.CTMCPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSmartTagType.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblGridChange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.property.Property.setPropertyType",
	"Comment": "set the property type. makes no attempt to validate the value.",
	"Method": "void setPropertyType(byte propertyType){\r\n    _property_type.set(propertyType, _raw_data);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTProof.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerBase.documentIsEmpty",
	"Comment": "return true if nothing has been sent to this result tree yet.this is not a public api.",
	"Method": "boolean documentIsEmpty(){\r\n    return m_docIsEmpty && (m_elemContext.m_currentElemDepth == 0);\r\n}"
}, {
	"Path": "org.docx4j.model.structure.HeaderFooterPolicy.getDefaultHeader",
	"Comment": "if an even header is present this is the odd header \t otherwise it is both, even and odd header",
	"Method": "HeaderPart getDefaultHeader(){\r\n    return defaultHeader;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.hpsf.Section.remove",
	"Comment": "removes a field from a property array. the resulting array iscompactified and returned.",
	"Method": "Property[] remove(Property[] pa,int i){\r\n    final Property[] h = new Property[pa.length - 1];\r\n    if (i > 0)\r\n        System.arraycopy(pa, 0, h, 0, i);\r\n    System.arraycopy(pa, i + 1, h, i, h.length - i);\r\n    return h;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTRelativeRect.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTEdnDocProps.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTBox.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTColorFilter.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMoveToRangeEnd.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMailMerge.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.convert.out.html.XsltHTMLFunctions.appendStyleElement",
	"Comment": "a customised xslt might just want theelement, because it customises\tthe rest of theelement.",
	"Method": "DocumentFragment appendStyleElement(HTMLConversionContext conversionContext){\r\n    Document document = XmlUtils.getNewDocumentBuilder().newDocument();\r\n    StringBuilder buffer = new StringBuilder(10240);\r\n    Element element = createStyleElement(conversionContext, document, buffer);\r\n    if (element == null) {\r\n        return null;\r\n    }\r\n    document.appendChild(element);\r\n    DocumentFragment docfrag = document.createDocumentFragment();\r\n    docfrag.appendChild(document.getDocumentElement());\r\n    return docfrag;\r\n}"
}, {
	"Path": "org.docx4j.jaxb.NamespacePrefixMapperMOXy.getPreferredPrefix",
	"Comment": "returns a preferred prefix for the given namespace uri.this method is intended to be overrided by a derived class.",
	"Method": "String getPreferredPrefix(String namespaceUri,String suggestion,boolean requirePrefix){\r\n    return NamespacePrefixMappings.getPreferredPrefixStatic(namespaceUri, suggestion, requirePrefix);\r\n}"
}, {
	"Path": "org.docx4j.w15.CTSdtAppearance.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2010.wordprocessingShape.CTWordprocessingShape.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.model.datastorage.BindingHandler.xpathGetString",
	"Comment": "used by opendope handler, but not directly by bind.xslt anymore.\t\tnot multiline aware.",
	"Method": "String xpathGetString(WordprocessingMLPackage pkg,Map<String, CustomXmlPart> customXmlDataStorageParts,CTDataBinding db,String xpathGetString,WordprocessingMLPackage pkg,Map<String, CustomXmlPart> customXmlDataStorageParts,String storeItemId,String xpath,String prefixMappings){\r\n    log.debug(xpath + \" with \" + prefixMappings);\r\n    try {\r\n        if (storeItemId.toUpperCase().equals(CORE_PROPERTIES_STOREITEMID)) {\r\n            return pkg.getDocPropsCorePart().xpathGetString(xpath, prefixMappings);\r\n        } else if (storeItemId.toUpperCase().equals(EXTENDED_PROPERTIES_STOREITEMID)) {\r\n            return pkg.getDocPropsExtendedPart().xpathGetString(xpath, prefixMappings);\r\n        }\r\n        CustomXmlPart part = customXmlDataStorageParts.get(storeItemId.toLowerCase());\r\n        if (part == null) {\r\n            throw new InputIntegrityException(\"Couldn't locate part by storeItemId \" + storeItemId);\r\n        }\r\n        String r = part.cachedXPathGetString(xpath, prefixMappings);\r\n        if (r == null) {\r\n            log.error(xpath + \" unexpectedly null!\");\r\n            return r;\r\n        } else if (r.equals(\"\")) {\r\n            log.debug(\"XML element is missing (or empty) for xpath: \" + xpath);\r\n            return r;\r\n        } else if (log.isDebugEnabled()) {\r\n            log.debug(xpath + \" yielded result '\" + r + \"'\");\r\n            return r;\r\n        } else {\r\n            return r;\r\n        }\r\n    } catch (Docx4JException e) {\r\n        log.error(e.getMessage(), e);\r\n        throw new InputIntegrityException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.SectPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.GlossaryDocument.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTcPrChange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.Base64.removeWhiteSpace",
	"Comment": "remove whitespace from mime containing encoded base64 data.",
	"Method": "int removeWhiteSpace(byte[] data){\r\n    if (data == null) {\r\n        return 0;\r\n    }\r\n    int newSize = 0;\r\n    int len = data.length;\r\n    for (int i = 0; i < len; i++) {\r\n        byte dataS = data[i];\r\n        if (!isWhiteSpace(dataS)) {\r\n            data[newSize++] = dataS;\r\n        }\r\n    }\r\n    return newSize;\r\n}"
}, {
	"Path": "com.topologi.diffx.sequence.EventSequence.getPrefixMapping",
	"Comment": "returns the prefix mapping for the namespace uris in this sequence.",
	"Method": "PrefixMapping getPrefixMapping(){\r\n    return this.prefixMapping;\r\n}"
}, {
	"Path": "org.docx4j.math.CTBox.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExtensionList.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.XMLWriterNSImpl.getQName",
	"Comment": "returns the qualified name for this element using the specified namespace uri.",
	"Method": "String getQName(String uri,String name){\r\n    String prefix = this.prefixMapping.get(uri != null ? uri : \"\");\r\n    if (prefix != null) {\r\n        if (!\"\".equals(prefix))\r\n            return this.prefixMapping.get(uri) + \":\" + name;\r\n        else\r\n            return name;\r\n    } else if (uri == null)\r\n        return name;\r\n    else\r\n        throw new UndeclaredNamespaceException(uri);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRPrElt.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotHierarchies.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.Fonts.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCaptions.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTYAlign.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellXfs.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.customxml.SchemaLibrary.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtText.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTQuery.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisions.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTConnections.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadataType.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTOMathArg.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToStream.getWriter",
	"Comment": "get the character stream where the events will be serialized to.",
	"Method": "Writer getWriter(){\r\n    return m_writer;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMember.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.relationships.Relationship.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTIconSet.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetFormatPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTBorderBox.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTChartsheetView.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTItems.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOleItems.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.DefinedNames.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFutureMetadataBlock.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTChartsheetProtection.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.springframework.web.servlet.tags.BindTag.getErrors",
	"Comment": "retrieve the errors instance that this tag is currently bound to.intended for cooperating nesting tags.",
	"Method": "Errors getErrors(){\r\n    return null;\r\n}"
}, {
	"Path": "org.docx4j.wml.U.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalSheetDataSet.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.transformer.TransformerIdentityImpl.setErrorListener",
	"Comment": "set the error event listener in effect for the transformation.",
	"Method": "void setErrorListener(ErrorListener listener){\r\n    if (listener == null)\r\n        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_NULL_ERROR_HANDLER, null));\r\n    else\r\n        m_errorListener = listener;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTQueryTable.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalSheetNames.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.dml.diagram.CTRelIds.getLo",
	"Comment": "explicit relationship to diagram layout definition\t\t\t\t\tpart",
	"Method": "String getLo(){\r\n    if (lo == null) {\r\n        return \"\";\r\n    } else {\r\n        return lo;\r\n    }\r\n}"
}, {
	"Path": "com.netflix.genie.agent.execution.services.impl.FetchingCacheServiceImplTests.fetchAndDeleteResourceConcurrently",
	"Comment": "make one cache download a resource version.while first one is downloading, make another threaddelete the same versionin the end, the previous resource should not exist",
	"Method": "void fetchAndDeleteResourceConcurrently(){\r\n    final ResourceLoader resourceLoader = Mockito.mock(ResourceLoader.class);\r\n    final Resource resource = Mockito.mock(Resource.class);\r\n    final CountDownLatch lockAquisitionAttempted = new CountDownLatch(2);\r\n    final ReentrantLock lockBackingMock = new ReentrantLock();\r\n    final CloseableLock resourceLock = Mockito.mock(CloseableLock.class);\r\n    Mockito.doAnswer(invocation -> {\r\n        lockAquisitionAttempted.countDown();\r\n        lockBackingMock.lock();\r\n        return null;\r\n    }).when(resourceLock).lock();\r\n    Mockito.doAnswer(invocation -> {\r\n        lockBackingMock.unlock();\r\n        return null;\r\n    }).when(resourceLock).close();\r\n    final FileLockFactory fileLockFactory = Mockito.mock(FileLockFactory.class);\r\n    Mockito.when(fileLockFactory.getLock(Mockito.any())).thenReturn(resourceLock);\r\n    final CountDownLatch downloadBegin = new CountDownLatch(1);\r\n    Mockito.when(resourceLoader.getResource(Mockito.anyString())).thenReturn(resource);\r\n    Mockito.when(resource.getInputStream()).thenAnswer((Answer<InputStream>) invocation -> {\r\n        downloadBegin.countDown();\r\n        simulateDownloadWithWait();\r\n        return Mockito.spy(new ByteArrayInputStream(\"\".getBytes(Charset.forName(\"UTF-8\"))));\r\n    });\r\n    final long lastModifiedTimeStamp = System.currentTimeMillis();\r\n    Mockito.when(resource.exists()).thenReturn(true);\r\n    Mockito.when(resource.lastModified()).thenReturn(lastModifiedTimeStamp);\r\n    final FetchingCacheServiceImpl cache1 = new FetchingCacheServiceImpl(resourceLoader, cacheArguments, fileLockFactory, cleanUpTaskExecutor);\r\n    final String resourceCacheId = cache1.getResourceCacheId(uri);\r\n    final ResourceLoader resourceLoader2 = Mockito.mock(ResourceLoader.class);\r\n    final FetchingCacheServiceImpl cache2 = new FetchingCacheServiceImpl(resourceLoader2, cacheArguments, fileLockFactory, cleanUpTaskExecutor);\r\n    final CountDownLatch allFetchesDone = new CountDownLatch(2);\r\n    executorService.submit(() -> {\r\n        try {\r\n            cache1.get(uri, targetFile);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            allFetchesDone.countDown();\r\n        }\r\n    });\r\n    downloadBegin.await();\r\n    executorService.submit(() -> {\r\n        try {\r\n            cache2.cleanUpOlderResourceVersions(resourceCacheId, lastModifiedTimeStamp + 1);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            allFetchesDone.countDown();\r\n        }\r\n    });\r\n    lockAquisitionAttempted.await();\r\n    downloadCompleted.set(true);\r\n    simulateDownloadLock.lock();\r\n    try {\r\n        downloadComplete.signal();\r\n    } finally {\r\n        simulateDownloadLock.unlock();\r\n    }\r\n    allFetchesDone.await();\r\n    assertResourceDeleted(cache1, resourceCacheId, lastModifiedTimeStamp);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTPathShadeProperties.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.webextension_2010_11.CTOsfWebExtensionBinding.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGroupMember.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.CustomFont.getFirstChar",
	"Comment": "returns the index of the first character defined in this font.",
	"Method": "int getFirstChar(){\r\n    return firstChar;\r\n}"
}, {
	"Path": "org.docx4j.vml.wordprocessingDrawing.CTWrap.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.FontInfo.getFontInstanceForAWTFont",
	"Comment": "returns a suitable internal font given an awt font instance.",
	"Method": "Font getFontInstanceForAWTFont(java.awt.Font awtFont){\r\n    String awtFontName = awtFont.getName();\r\n    String awtFontFamily = awtFont.getFamily();\r\n    String awtFontStyle = awtFont.isItalic() ? Font.STYLE_ITALIC : Font.STYLE_NORMAL;\r\n    int awtFontWeight = awtFont.isBold() ? Font.WEIGHT_BOLD : Font.WEIGHT_NORMAL;\r\n    FontTriplet matchedTriplet = null;\r\n    List triplets = getTripletsForName(awtFontName);\r\n    if (!triplets.isEmpty()) {\r\n        Iterator it = triplets.iterator();\r\n        while (it.hasNext()) {\r\n            FontTriplet triplet = (FontTriplet) it.next();\r\n            boolean styleMatched = triplet.getStyle().equals(awtFontStyle);\r\n            boolean weightMatched = triplet.getWeight() == awtFontWeight;\r\n            if (styleMatched && weightMatched) {\r\n                matchedTriplet = triplet;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (matchedTriplet == null) {\r\n        if (awtFontFamily.equals(\"sanserif\")) {\r\n            awtFontFamily = \"sans-serif\";\r\n        }\r\n        matchedTriplet = fontLookup(awtFontFamily, awtFontStyle, awtFontWeight);\r\n    }\r\n    int fontSize = Math.round(awtFont.getSize2D() * 1000);\r\n    return getFontInstance(matchedTriplet, fontSize);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToStream.setOutputFormat",
	"Comment": "specifies an output format for this serializer. it theserializer has already been associated with an output format,it will switch to the new format. this method should not becalled while the serializer is in the process of serializinga document.",
	"Method": "void setOutputFormat(Properties format){\r\n    boolean shouldFlush = m_shouldFlush;\r\n    if (format != null) {\r\n        Enumeration propNames;\r\n        propNames = format.propertyNames();\r\n        while (propNames.hasMoreElements()) {\r\n            String key = (String) propNames.nextElement();\r\n            String value = format.getProperty(key);\r\n            String explicitValue = (String) format.get(key);\r\n            if (explicitValue == null && value != null) {\r\n                this.setOutputPropertyDefault(key, value);\r\n            }\r\n            if (explicitValue != null) {\r\n                this.setOutputProperty(key, explicitValue);\r\n            }\r\n        }\r\n    }\r\n    String entitiesFileName = (String) format.get(OutputPropertiesFactory.S_KEY_ENTITIES);\r\n    if (null != entitiesFileName) {\r\n        String method = (String) format.get(OutputKeys.METHOD);\r\n        m_charInfo = CharInfo.getCharInfo(entitiesFileName, method);\r\n    }\r\n    m_shouldFlush = shouldFlush;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTStrokeChild.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPCDSDTCEntries.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRangePr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTBreakBin.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTStylesheet.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFtnEdnSepRef.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTStyle.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTBookmarkRange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.DataInputBlock.readUShortLE",
	"Comment": "reads a short which spans the end of prevblock and the start of this block.",
	"Method": "int readUShortLE(int readUShortLE,DataInputBlock prevBlock){\r\n    int i = prevBlock._buf.length - 1;\r\n    int b0 = prevBlock._buf[i++] & 0xFF;\r\n    int b1 = _buf[_readIndex++] & 0xFF;\r\n    return (b1 << 8) + (b0 << 0);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.transformer.TransformerIdentityImpl.notationDecl",
	"Comment": "receive notification of a notation declaration.by default, do nothing.application writers may override thismethod in a subclass if they wish to keep track of the notationsdeclared in a document.",
	"Method": "void notationDecl(String name,String publicId,String systemId){\r\n    if (null != m_resultDTDHandler)\r\n        m_resultDTDHandler.notationDecl(name, publicId, systemId);\r\n}"
}, {
	"Path": "org.docx4j.wml.Color.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDxfs.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setBordersDoNotSurroundHeader",
	"Comment": "sets the value of the bordersdonotsurroundheader property.",
	"Method": "void setBordersDoNotSurroundHeader(BooleanDefaultTrue value){\r\n    this.bordersDoNotSurroundHeader = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTIndex.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.TraversalUtil.handleCTNonVisualDrawingProps",
	"Comment": "there can be hyperlinks references in ctnonvisualdrawingprops.",
	"Method": "void handleCTNonVisualDrawingProps(CTNonVisualDrawingProps drawingProps,List<Object> artificialList){\r\n    if (drawingProps != null) {\r\n        CTHyperlink docPrHyperLink = drawingProps.getHlinkClick();\r\n        if (docPrHyperLink != null)\r\n            artificialList.add(docPrHyperLink);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblOverlap.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotFilter.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTControlPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Row.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.getRealInstanceClass",
	"Comment": "finds out the real type of instance matching this fact if possible",
	"Method": "ObjectType getRealInstanceClass(){\r\n    return realInstanceClass;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setDoNotAutofitConstrainedTables",
	"Comment": "sets the value of the donotautofitconstrainedtables property.",
	"Method": "void setDoNotAutofitConstrainedTables(BooleanDefaultTrue value){\r\n    this.doNotAutofitConstrainedTables = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMeasureDimensionMaps.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTR.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocRsids.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.Tc.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPhoneticPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.transforms.Transforms.setSecureValidation",
	"Comment": "set whether secure validation is enabled or not. the default is false.",
	"Method": "void setSecureValidation(boolean secureValidation){\r\n    this.secureValidation = secureValidation;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.c14n.implementations.Canonicalizer20010315.engineCanonicalizeSubTree",
	"Comment": "always throws a canonicalizationexception because this is inclusive c14n.",
	"Method": "byte[] engineCanonicalizeSubTree(Node rootNode,String inclusiveNamespaces,byte[] engineCanonicalizeSubTree,Node rootNode,String inclusiveNamespaces,boolean propagateDefaultNamespace){\r\n    throw new CanonicalizationException(\"c14n.Canonicalizer.UnsupportedOperation\");\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTMcds.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerBase.getNamespaceURI",
	"Comment": "returns the uri of an element or attribute. note that default namespacesdo not apply directly to attributes.",
	"Method": "String getNamespaceURI(String qname,boolean isElement){\r\n    String uri = EMPTYSTRING;\r\n    int col = qname.lastIndexOf(':');\r\n    final String prefix = (col > 0) ? qname.substring(0, col) : EMPTYSTRING;\r\n    if (!EMPTYSTRING.equals(prefix) || isElement) {\r\n        if (m_prefixMap != null) {\r\n            uri = m_prefixMap.lookupNamespace(prefix);\r\n            if (uri == null && !prefix.equals(XMLNS_PREFIX)) {\r\n                throw new RuntimeException(Utils.messages.createMessage(MsgKey.ER_NAMESPACE_PREFIX, new Object[] { qname.substring(0, col) }));\r\n            }\r\n        }\r\n    }\r\n    return uri;\r\n}"
}, {
	"Path": "org.docx4j.wml.TblBorders.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTSolidColorFillProperties.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setRemovePersonalInformation",
	"Comment": "sets the value of the removepersonalinformation property.",
	"Method": "void setRemovePersonalInformation(BooleanDefaultTrue value){\r\n    this.removePersonalInformation = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRowFields.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFunctionGroup.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTControl.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocVars.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTLock.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.XMLWriterBase.indent",
	"Comment": "insert the correct amount of space characterss depending on the depth and ifthe indent flag is set to true.",
	"Method": "void indent(){\r\n    if (this.indent) {\r\n        for (int i = 0; i < this.depth; i++) {\r\n            this.writer.write(this.indentChars);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Col.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTServerFormat.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.DocDefaults.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.PartName.isRelationshipPartURI",
	"Comment": "check if the specified part name is a relationship part name.",
	"Method": "boolean isRelationshipPartURI(URI partUri,boolean isRelationshipPartURI){\r\n    return this.isRelationship;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.LSSerializerImpl.write",
	"Comment": "serializes the specified node to the specified lsoutput and returns true if the node was successfully serialized.",
	"Method": "boolean write(Node nodeArg,LSOutput destination){\r\n    if (destination == null) {\r\n        String msg = Utils.messages.createMessage(MsgKey.ER_NO_OUTPUT_SPECIFIED, null);\r\n        if (fDOMErrorHandler != null) {\r\n            fDOMErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_FATAL_ERROR, msg, MsgKey.ER_NO_OUTPUT_SPECIFIED));\r\n        }\r\n        throw new LSException(LSException.SERIALIZE_ERR, msg);\r\n    }\r\n    if (nodeArg == null) {\r\n        return false;\r\n    }\r\n    Serializer serializer = fXMLSerializer;\r\n    serializer.reset();\r\n    if (nodeArg != fVisitedNode) {\r\n        String xmlVersion = getXMLVersion(nodeArg);\r\n        fEncoding = destination.getEncoding();\r\n        if (fEncoding == null) {\r\n            fEncoding = getInputEncoding(nodeArg);\r\n            fEncoding = fEncoding != null ? fEncoding : getXMLEncoding(nodeArg) == null ? \"UTF-8\" : getXMLEncoding(nodeArg);\r\n        }\r\n        if (!Encodings.isRecognizedEncoding(fEncoding)) {\r\n            String msg = Utils.messages.createMessage(MsgKey.ER_UNSUPPORTED_ENCODING, null);\r\n            if (fDOMErrorHandler != null) {\r\n                fDOMErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_FATAL_ERROR, msg, MsgKey.ER_UNSUPPORTED_ENCODING));\r\n            }\r\n            throw new LSException(LSException.SERIALIZE_ERR, msg);\r\n        }\r\n        serializer.getOutputFormat().setProperty(\"version\", xmlVersion);\r\n        fDOMConfigProperties.setProperty(DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.S_XML_VERSION, xmlVersion);\r\n        fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_ENCODING, fEncoding);\r\n        if ((nodeArg.getNodeType() != Node.DOCUMENT_NODE || nodeArg.getNodeType() != Node.ELEMENT_NODE || nodeArg.getNodeType() != Node.ENTITY_NODE) && ((fFeatures & XMLDECL) != 0)) {\r\n            fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL, DOMConstants.DOM3_DEFAULT_FALSE);\r\n        }\r\n        fVisitedNode = nodeArg;\r\n    }\r\n    fXMLSerializer.setOutputFormat(fDOMConfigProperties);\r\n    try {\r\n        Writer writer = destination.getCharacterStream();\r\n        if (writer == null) {\r\n            OutputStream outputStream = destination.getByteStream();\r\n            if (outputStream == null) {\r\n                String uri = destination.getSystemId();\r\n                if (uri == null) {\r\n                    String msg = Utils.messages.createMessage(MsgKey.ER_NO_OUTPUT_SPECIFIED, null);\r\n                    if (fDOMErrorHandler != null) {\r\n                        fDOMErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_FATAL_ERROR, msg, MsgKey.ER_NO_OUTPUT_SPECIFIED));\r\n                    }\r\n                    throw new LSException(LSException.SERIALIZE_ERR, msg);\r\n                } else {\r\n                    String absoluteURI = SystemIDResolver.getAbsoluteURI(uri);\r\n                    URL url = new URL(absoluteURI);\r\n                    OutputStream urlOutStream = null;\r\n                    String protocol = url.getProtocol();\r\n                    String host = url.getHost();\r\n                    if (protocol.equalsIgnoreCase(\"file\") && (host == null || host.length() == 0 || host.equals(\"localhost\"))) {\r\n                        urlOutStream = new FileOutputStream(getPathWithoutEscapes(url.getPath()));\r\n                    } else {\r\n                        URLConnection urlCon = url.openConnection();\r\n                        urlCon.setDoInput(false);\r\n                        urlCon.setDoOutput(true);\r\n                        urlCon.setUseCaches(false);\r\n                        urlCon.setAllowUserInteraction(false);\r\n                        if (urlCon instanceof HttpURLConnection) {\r\n                            HttpURLConnection httpCon = (HttpURLConnection) urlCon;\r\n                            httpCon.setRequestMethod(\"PUT\");\r\n                        }\r\n                        urlOutStream = urlCon.getOutputStream();\r\n                    }\r\n                    serializer.setOutputStream(urlOutStream);\r\n                }\r\n            } else {\r\n                serializer.setOutputStream(outputStream);\r\n            }\r\n        } else {\r\n            serializer.setWriter(writer);\r\n        }\r\n        if (fDOMSerializer == null) {\r\n            fDOMSerializer = (DOM3Serializer) serializer.asDOM3Serializer();\r\n        }\r\n        if (fDOMErrorHandler != null) {\r\n            fDOMSerializer.setErrorHandler(fDOMErrorHandler);\r\n        }\r\n        if (fSerializerFilter != null) {\r\n            fDOMSerializer.setNodeFilter(fSerializerFilter);\r\n        }\r\n        fDOMSerializer.setNewLine(fEndOfLine.toCharArray());\r\n        fDOMSerializer.serializeDOM3(nodeArg);\r\n    } catch (UnsupportedEncodingException ue) {\r\n        String msg = Utils.messages.createMessage(MsgKey.ER_UNSUPPORTED_ENCODING, null);\r\n        if (fDOMErrorHandler != null) {\r\n            fDOMErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_FATAL_ERROR, msg, MsgKey.ER_UNSUPPORTED_ENCODING, ue));\r\n        }\r\n        throw (LSException) createLSException(LSException.SERIALIZE_ERR, ue).fillInStackTrace();\r\n    } catch (LSException lse) {\r\n        throw lse;\r\n    } catch (RuntimeException e) {\r\n        throw (LSException) createLSException(LSException.SERIALIZE_ERR, e).fillInStackTrace();\r\n    } catch (Exception e) {\r\n        if (fDOMErrorHandler != null) {\r\n            fDOMErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_FATAL_ERROR, e.getMessage(), null, e));\r\n        }\r\n        throw (LSException) createLSException(LSException.SERIALIZE_ERR, e).fillInStackTrace();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTBorders.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTShapeDefaults.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getDoNotUseEastAsianBreakRules",
	"Comment": "gets the value of the donotuseeastasianbreakrules property.",
	"Method": "BooleanDefaultTrue getDoNotUseEastAsianBreakRules(){\r\n    return doNotUseEastAsianBreakRules;\r\n}"
}, {
	"Path": "com.netflix.genie.agent.utils.PathUtils.jobGenieLogsDirectoryPath",
	"Comment": "compose the path to the genie logs directory inside a job directory.",
	"Method": "Path jobGenieLogsDirectoryPath(File jobDirectory){\r\n    return composePath(jobDirectory, JobConstants.GENIE_PATH_VAR, JobConstants.LOGS_PATH_VAR);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionFormatting.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.Jc.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.convert.out.HTMLSettings.setStyleElementHandler",
	"Comment": "how to generate the style element. the default implementation is inline.",
	"Method": "void setStyleElementHandler(ConversionHTMLStyleElementHandler styleElementHandler){\r\n    settings.put(STYLE_ELEMENT_HANDLER, styleElementHandler);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCalculatedItem.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFtnProps.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getDoNotValidateAgainstSchema",
	"Comment": "gets the value of the donotvalidateagainstschema property.",
	"Method": "BooleanDefaultTrue getDoNotValidateAgainstSchema(){\r\n    return doNotValidateAgainstSchema;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.webextension_2010_11.CTOsfWebExtensionReference.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTLightRig.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerBase.setDocumentLocator",
	"Comment": "receive an object for locating the origin of sax document events.",
	"Method": "void setDocumentLocator(Locator locator){\r\n    return;\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.XMLSerializer.serialize",
	"Comment": "serialises the given object using the given name as element name.this implementation is recursive. it calls itself for fields which are not ofprimitive type.",
	"Method": "void serialize(Object o,String name){\r\n    if (o != null) {\r\n        if (name.lastIndexOf('.') != -1) {\r\n            name = name.substring(name.lastIndexOf('.') + 1);\r\n        }\r\n        if (name.lastIndexOf('$') != -1) {\r\n            name = name.substring(name.lastIndexOf('$') + 1);\r\n        }\r\n        name = name.toLowerCase();\r\n        if (o instanceof Number) {\r\n            this.xml.openElement(name, false);\r\n            this.xml.writeText(o.toString());\r\n            this.xml.closeElement();\r\n        } else if (o instanceof String) {\r\n            this.xml.openElement(name, false);\r\n            this.xml.writeText(o.toString());\r\n            this.xml.closeElement();\r\n        } else if (o instanceof Character) {\r\n            this.xml.openElement(name, false);\r\n            this.xml.writeText(((Character) o).charValue());\r\n            this.xml.closeElement();\r\n        } else if (o instanceof Boolean) {\r\n            this.xml.openElement(name, false);\r\n            this.xml.writeText(o.toString());\r\n            this.xml.closeElement();\r\n        } else if (o instanceof Date) {\r\n            this.xml.openElement(name, false);\r\n            this.xml.writeText(DF.format((Date) o));\r\n            this.xml.closeElement();\r\n        } else if (o instanceof Collection<?>) {\r\n            this.xml.openElement(name, ((Collection<?>) o).size() != 0);\r\n            serializeCollection((Collection<?>) o);\r\n            this.xml.closeElement();\r\n        } else if (o instanceof Hashtable<?, ?>) {\r\n            this.xml.openElement(name, ((Hashtable<?, ?>) o).size() != 0);\r\n            serializeHashtable((Hashtable<?, ?>) o);\r\n            this.xml.closeElement();\r\n        } else {\r\n            this.xml.openElement(name, true);\r\n            serializeObject(o);\r\n            this.xml.closeElement();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTColorSchemeMapping.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.sax.XMLWriterSAX.deNude",
	"Comment": "writes the angle bracket if the element open tag is not finished.",
	"Method": "void deNude(){\r\n    if (this.isNude) {\r\n        indent();\r\n        Element elt = peekElement();\r\n        if (elt.mappings != null) {\r\n            for (int i = 0; i < elt.mappings.size(); i++) {\r\n                PrefixMapping pm = elt.mappings.get(i);\r\n                this.handler.startPrefixMapping(pm.prefix, pm.uri);\r\n            }\r\n        }\r\n        this.handler.startElement(elt.uri, elt.name, getQName(elt.uri, elt.name), this.attributes);\r\n        this.attributes = new AttributesImpl();\r\n        if (this.indent && elt.hasChildren) {\r\n            newLine();\r\n        }\r\n        this.isNude = false;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.password.CTPasswordKeyEncryptor.setEncryptedVerifierHashInput",
	"Comment": "sets the value of the encryptedverifierhashinput property.",
	"Method": "void setEncryptedVerifierHashInput(byte[] value){\r\n    this.encryptedVerifierHashInput = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWebPublishing.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.nustaq.serialization.coders.FSTMinBinEncoder.close",
	"Comment": "close and flush to underlying stream if present. the stream is also closed",
	"Method": "void close(){\r\n    if (outputStream != null) {\r\n        outputStream.close();\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.type1.PFMFile.getFirstChar",
	"Comment": "returns the number of the character that definesthe first entry in the widths list.",
	"Method": "short getFirstChar(){\r\n    return dfFirstChar;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTComplex.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTProtectedRange.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDynamicFilter.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.hpsf.Util.pad4",
	"Comment": "pads a string with 0x0000 characters so that its length is amultiple of 4.",
	"Method": "byte[] pad4(byte[] ba,char[] pad4,char[] ca,char[] pad4,String s){\r\n    return pad4(s.toCharArray());\r\n}"
}, {
	"Path": "org.docx4j.math.CTDPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTPictureBase.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTSSubSup.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTProtectedRanges.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTFPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.ParaRPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w15.CTPerson.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellStyle.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTextField.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "testcasesupport.IO.getDBConnection",
	"Comment": "use this method to get a database connection for use in sql injection and other test cases that use a database.",
	"Method": "Connection getDBConnection(){\r\n    return DriverManager.getConnection(dbUrl, dbUsername, dbPassword);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTRect.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTxbxContent.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTPPrChange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTOMathParaPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadataStringIndex.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTCallout.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDecimalNumber.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.pptx4j.pml.CTControlList.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTString.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDateGroupItem.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTMcds.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.XMLUtils.elementIsInEncryption11Space",
	"Comment": "returns true if the element is in xml encryption 1.1 namespace and the localname equals the supplied one.",
	"Method": "boolean elementIsInEncryption11Space(Element element,String localName){\r\n    if (element == null) {\r\n        return false;\r\n    }\r\n    return EncryptionConstants.EncryptionSpec11NS.equals(element.getNamespaceURI()) && element.getLocalName().equals(localName);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMailMergeDest.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTWritingStyle.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.nustaq.serialization.FSTConfiguration.registerCrossPlatformClassMappingUseSimpleName",
	"Comment": "init right after creation of configuration, not during operation as it is not threadsafe regarding mutation",
	"Method": "FSTConfiguration registerCrossPlatformClassMappingUseSimpleName(Class classes,FSTConfiguration registerCrossPlatformClassMappingUseSimpleName,List<Class> classes){\r\n    for (int i = 0; i < classes.size(); i++) {\r\n        Class clz = classes.get(i);\r\n        minbinNames.put(clz.getSimpleName(), clz.getName());\r\n        minbinNamesReverse.put(clz.getName(), clz.getSimpleName());\r\n        try {\r\n            if (!clz.isArray()) {\r\n                Class ac = Class.forName(\"[L\" + clz.getName() + \";\");\r\n                minbinNames.put(clz.getSimpleName() + \"[]\", ac.getName());\r\n                minbinNamesReverse.put(ac.getName(), clz.getSimpleName() + \"[]\");\r\n            }\r\n        } catch (ClassNotFoundException e) {\r\n            FSTUtil.<RuntimeException>rethrow(e);\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.nustaq.serialization.simpleapi.OnHeapCoder.toObject",
	"Comment": "throws fstbuffertoosmallexcpetion in case object does not fit into given range",
	"Method": "Object toObject(byte arr,int startIndex,int availableSize,Object toObject,byte[] arr){\r\n    return toObject(arr, 0, arr.length);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPhoneticRun.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.autodetect.FontInfoFinder.find",
	"Comment": "attempts to determine embedfontinfo from a given font file.",
	"Method": "EmbedFontInfo[] find(URL fontUrl,FontResolver resolver,FontCache fontCache){\r\n    String embedUrl = null;\r\n    embedUrl = fontUrl.toExternalForm();\r\n    long fileLastModified = -1;\r\n    if (fontCache != null) {\r\n        fileLastModified = FontCache.getLastModified(fontUrl);\r\n        if (fontCache.containsFont(embedUrl)) {\r\n            EmbedFontInfo[] fontInfos = fontCache.getFontInfos(embedUrl, fileLastModified);\r\n            if (fontInfos != null) {\r\n                return fontInfos;\r\n            }\r\n        } else if (fontCache.isFailedFont(embedUrl, fileLastModified)) {\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(\"Skipping font file that failed to load previously: \" + embedUrl);\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n    CustomFont customFont = null;\r\n    if (fontUrl.toExternalForm().endsWith(\".ttc\")) {\r\n        List ttcNames = null;\r\n        String fontFileURI = fontUrl.toExternalForm().trim();\r\n        InputStream in = null;\r\n        try {\r\n            in = FontLoader.openFontUri(resolver, fontFileURI);\r\n            TTFFile ttf = new TTFFile();\r\n            FontFileReader reader = new FontFileReader(in);\r\n            ttcNames = ttf.getTTCnames(reader);\r\n        } catch (Exception e) {\r\n            if (this.eventListener != null) {\r\n                this.eventListener.fontLoadingErrorAtAutoDetection(this, fontFileURI, e);\r\n            }\r\n            return null;\r\n        } finally {\r\n            IOUtils.closeQuietly(in);\r\n        }\r\n        List embedFontInfoList = new java.util.ArrayList();\r\n        Iterator ttcNamesIterator = ttcNames.iterator();\r\n        while (ttcNamesIterator.hasNext()) {\r\n            String fontName = (String) ttcNamesIterator.next();\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(\"Loading \" + fontName);\r\n            }\r\n            try {\r\n                TTFFontLoader ttfLoader = new TTFFontLoader(fontFileURI, fontName, true, EncodingMode.AUTO, true, resolver);\r\n                customFont = ttfLoader.getFont();\r\n                if (this.eventListener != null) {\r\n                    customFont.setEventListener(this.eventListener);\r\n                }\r\n            } catch (Exception e) {\r\n                if (fontCache != null) {\r\n                    fontCache.registerFailedFont(embedUrl, fileLastModified);\r\n                }\r\n                if (this.eventListener != null) {\r\n                    this.eventListener.fontLoadingErrorAtAutoDetection(this, embedUrl, e);\r\n                }\r\n                continue;\r\n            }\r\n            EmbedFontInfo fi = getFontInfoFromCustomFont(fontUrl, customFont, fontCache);\r\n            if (fi != null) {\r\n                embedFontInfoList.add(fi);\r\n            }\r\n        }\r\n        return (EmbedFontInfo[]) embedFontInfoList.toArray(new EmbedFontInfo[embedFontInfoList.size()]);\r\n    } else {\r\n        try {\r\n            customFont = FontLoader.loadFont(fontUrl, null, true, EncodingMode.AUTO, resolver);\r\n            if (this.eventListener != null) {\r\n                customFont.setEventListener(this.eventListener);\r\n            }\r\n        } catch (Exception e) {\r\n            if (fontCache != null) {\r\n                fontCache.registerFailedFont(embedUrl, fileLastModified);\r\n            }\r\n            if (this.eventListener != null) {\r\n                this.eventListener.fontLoadingErrorAtAutoDetection(this, embedUrl, e);\r\n            }\r\n            return null;\r\n        }\r\n        EmbedFontInfo fi = getFontInfoFromCustomFont(fontUrl, customFont, fontCache);\r\n        if (fi != null) {\r\n            return new EmbedFontInfo[] { fi };\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.SingleByteFont.getAdditionalWidths",
	"Comment": "returns an array with the widths for an additional encoding.",
	"Method": "int[] getAdditionalWidths(int index){\r\n    SimpleSingleByteEncoding enc = getAdditionalEncoding(index);\r\n    int[] arr = new int[enc.getLastChar() - enc.getFirstChar() + 1];\r\n    for (int i = 0, c = arr.length; i < c; i++) {\r\n        NamedCharacter nc = enc.getCharacterForIndex(enc.getFirstChar() + i);\r\n        UnencodedCharacter uc = (UnencodedCharacter) this.unencodedCharacters.get(new Character(nc.getSingleUnicodeValue()));\r\n        arr[i] = uc.getWidth();\r\n    }\r\n    return arr;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCalendarType.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.BATBlock.getBATBlockAndIndex",
	"Comment": "returns the batblock that handles the specified offset, and the relative index within it.the list of batblocks must be in sequential order",
	"Method": "BATBlockAndIndex getBATBlockAndIndex(int offset,HeaderBlock header,List<BATBlock> bats){\r\n    POIFSBigBlockSize bigBlockSize = header.getBigBlockSize();\r\n    int whichBAT = (int) Math.floor(offset / bigBlockSize.getBATEntriesPerBlock());\r\n    int index = offset % bigBlockSize.getBATEntriesPerBlock();\r\n    return new BATBlockAndIndex(index, bats.get(whichBAT));\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.FontInfo.getUsedFonts",
	"Comment": "this is used by the renderers to retrieve all thefonts used in the document.this is for embedded font or creating a list of used fonts.",
	"Method": "Map getUsedFonts(){\r\n    return this.usedFonts;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFootnotes.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblLayoutType.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.substitute.FontSubstitutions.adjustFontInfo",
	"Comment": "adjusts a given fontinfo using this font substitution catalog",
	"Method": "void adjustFontInfo(FontInfo fontInfo){\r\n    for (Iterator subsIt = super.iterator(); subsIt.hasNext(); ) {\r\n        FontSubstitution substitution = (FontSubstitution) subsIt.next();\r\n        FontQualifier toQualifier = substitution.getToQualifier();\r\n        FontTriplet fontTriplet = toQualifier.bestMatch(fontInfo);\r\n        if (fontTriplet == null) {\r\n            log.error(\"Unable to match font substitution for destination qualifier \" + toQualifier);\r\n            continue;\r\n        }\r\n        String internalFontKey = fontInfo.getInternalFontKey(fontTriplet);\r\n        FontQualifier fromQualifier = substitution.getFromQualifier();\r\n        List tripletList = fromQualifier.getTriplets();\r\n        for (Iterator tripletit = tripletList.iterator(); tripletit.hasNext(); ) {\r\n            FontTriplet triplet = (FontTriplet) tripletit.next();\r\n            fontInfo.addFontProperties(internalFontKey, triplet);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.TTFSubSetFile.createMaxp",
	"Comment": "copy the maxp table as is from original font to subset fontand set num glyphs to size",
	"Method": "void createMaxp(FontFileReader in,int size){\r\n    TTFDirTabEntry entry = (TTFDirTabEntry) dirTabs.get(\"maxp\");\r\n    if (entry != null) {\r\n        pad4();\r\n        seekTab(in, \"maxp\", 0);\r\n        System.arraycopy(in.getBytes((int) entry.getOffset(), (int) entry.getLength()), 0, output, currentPos, (int) entry.getLength());\r\n        writeUShort(currentPos + 4, size);\r\n        int checksum = getCheckSum(currentPos, (int) entry.getLength());\r\n        writeULong(maxpDirOffset, checksum);\r\n        writeULong(maxpDirOffset + 4, currentPos);\r\n        writeULong(maxpDirOffset + 8, (int) entry.getLength());\r\n        currentPos += (int) entry.getLength();\r\n        realSize += (int) entry.getLength();\r\n    } else {\r\n        throw new IOException(\"Can't find maxp table\");\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCustomXmlRow.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTBreakBin.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTColor.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMoveFromRangeEnd.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotHierarchy.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGroupLevel.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.model.fields.merge.MailMergerWithNext.performLabelMerge",
	"Comment": "similar to performmerge method but better to merge labels template because of using the next instruction to go to the next item.the contents of the input pkg are replaced with the results of the merge.",
	"Method": "void performLabelMerge(WordprocessingMLPackage input,List<Map<DataFieldName, String>> data){\r\n    FormTextFieldNames formTextFieldNames = new FormTextFieldNames();\r\n    FieldsPreprocessor.complexifyFields(input.getMainDocumentPart());\r\n    List<Object> mdpResults = perform(input, input.getMainDocumentPart().getContent(), data, formTextFieldNames);\r\n    input.getMainDocumentPart().getContent().clear();\r\n    input.getMainDocumentPart().getContent().addAll(mdpResults);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTDiagram.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSFileSystem.getBATBlockAndIndex",
	"Comment": "returns the batblock that handles the specified offset, and the relative index within it",
	"Method": "BATBlockAndIndex getBATBlockAndIndex(int offset){\r\n    return BATBlock.getBATBlockAndIndex(offset, _header, _bat_blocks);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.property.Property.getViewableArray",
	"Comment": "get an array of objects, some of which may implementpoifsviewable",
	"Method": "Object[] getViewableArray(){\r\n    Object[] results = new Object[5];\r\n    results[0] = \"Name          = \\\"\" + getName() + \"\\\"\";\r\n    results[1] = \"Property Type = \" + _property_type.get();\r\n    results[2] = \"Node Color    = \" + _node_color.get();\r\n    long time = _days_1.get();\r\n    time <<= 32;\r\n    time += _seconds_1.get() & 0x0000FFFFL;\r\n    results[3] = \"Time 1        = \" + time;\r\n    time = _days_2.get();\r\n    time <<= 32;\r\n    time += _seconds_2.get() & 0x0000FFFFL;\r\n    results[4] = \"Time 2        = \" + time;\r\n    return results;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFFDDList.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadataBlock.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMarkup.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Col.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTShadow.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMailMergeDataType.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOleLink.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTChartsheetPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTReadingModeInkLockDown.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFormat.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTIgnoredError.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTFType.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTPixelsMeasure.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotSelection.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.FontPitch.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.transformer.TransformerIdentityImpl.processingInstruction",
	"Comment": "receive notification of a processing instruction.by default, do nothing.application writers may override thismethod in a subclass to take specific actions for eachprocessing instruction, such as setting status variables orinvoking other methods.",
	"Method": "void processingInstruction(String target,String data){\r\n    flushStartDoc();\r\n    m_resultContentHandler.processingInstruction(target, data);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setBordersDoNotSurroundFooter",
	"Comment": "sets the value of the bordersdonotsurroundfooter property.",
	"Method": "void setBordersDoNotSurroundFooter(BooleanDefaultTrue value){\r\n    this.bordersDoNotSurroundFooter = value;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblStylePr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTError.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.LSSerializerImpl.canSetParameter",
	"Comment": "checks if setting a parameter to a specific value is supported.",
	"Method": "boolean canSetParameter(String name,Object value){\r\n    if (value instanceof Boolean) {\r\n        if (name.equalsIgnoreCase(DOMConstants.DOM_CDATA_SECTIONS) || name.equalsIgnoreCase(DOMConstants.DOM_COMMENTS) || name.equalsIgnoreCase(DOMConstants.DOM_ENTITIES) || name.equalsIgnoreCase(DOMConstants.DOM_INFOSET) || name.equalsIgnoreCase(DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE) || name.equalsIgnoreCase(DOMConstants.DOM_NAMESPACES) || name.equalsIgnoreCase(DOMConstants.DOM_NAMESPACE_DECLARATIONS) || name.equalsIgnoreCase(DOMConstants.DOM_SPLIT_CDATA) || name.equalsIgnoreCase(DOMConstants.DOM_WELLFORMED) || name.equalsIgnoreCase(DOMConstants.DOM_DISCARD_DEFAULT_CONTENT) || name.equalsIgnoreCase(DOMConstants.DOM_FORMAT_PRETTY_PRINT) || name.equalsIgnoreCase(DOMConstants.DOM_XMLDECL)) {\r\n            return true;\r\n        } else if (name.equalsIgnoreCase(DOMConstants.DOM_CANONICAL_FORM) || name.equalsIgnoreCase(DOMConstants.DOM_CHECK_CHAR_NORMALIZATION) || name.equalsIgnoreCase(DOMConstants.DOM_DATATYPE_NORMALIZATION) || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE_IF_SCHEMA) || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE)) {\r\n            return !((Boolean) value).booleanValue();\r\n        } else if (name.equalsIgnoreCase(DOMConstants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS)) {\r\n            return ((Boolean) value).booleanValue();\r\n        }\r\n    } else if (name.equalsIgnoreCase(DOMConstants.DOM_ERROR_HANDLER) && value == null || value instanceof DOMErrorHandler) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.transforms.Transforms.performTransforms",
	"Comment": "applies all included transforms to xmlsignatureinput and returns the result of these transformations.",
	"Method": "XMLSignatureInput performTransforms(XMLSignatureInput xmlSignatureInput,XMLSignatureInput performTransforms,XMLSignatureInput xmlSignatureInput,OutputStream os){\r\n    try {\r\n        int last = this.getLength() - 1;\r\n        for (int i = 0; i < last; i++) {\r\n            Transform t = this.item(i);\r\n            if (log.isDebugEnabled()) {\r\n                String uri = t.getURI();\r\n                log.debug(\"Perform the (\" + i + \")th \" + uri + \" transform\");\r\n            }\r\n            checkSecureValidation(t);\r\n            xmlSignatureInput = t.performTransform(xmlSignatureInput);\r\n        }\r\n        if (last >= 0) {\r\n            Transform t = this.item(last);\r\n            if (log.isDebugEnabled()) {\r\n                String uri = t.getURI();\r\n                log.debug(\"Perform the (\" + last + \")th \" + uri + \" transform\");\r\n            }\r\n            checkSecureValidation(t);\r\n            xmlSignatureInput = t.performTransform(xmlSignatureInput, os);\r\n        }\r\n        return xmlSignatureInput;\r\n    } catch (IOException ex) {\r\n        throw new TransformationException(ex);\r\n    } catch (CanonicalizationException ex) {\r\n        throw new TransformationException(ex);\r\n    } catch (InvalidCanonicalizerException ex) {\r\n        throw new TransformationException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTuple.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w15.CTPeople.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTVerticalAlignRun.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTargetScreenSz.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCalculatedMember.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parentObj;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWorksheetSource.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTColorMru.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMissing.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.OleObjectBinaryPart.writePOIFSFileSystem",
	"Comment": "write any changes which have been made to poifsfilesystem,\tto the underlying bytebuffer.this is necessary if the changes\tare to be persisted.",
	"Method": "void writePOIFSFileSystem(){\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    getFs().writeFilesystem(baos);\r\n    byte[] bytes = baos.toByteArray();\r\n    setBinaryData(ByteBuffer.wrap(bytes));\r\n}"
}, {
	"Path": "org.docx4j.vml.CTImage.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToXMLSAXHandler.namespaceAfterStartElement",
	"Comment": "send a namespace declaration in the output document. the namespacedeclaration will not be include if the namespace is already in scopewith the same prefix.",
	"Method": "void namespaceAfterStartElement(String prefix,String uri){\r\n    startPrefixMapping(prefix, uri, false);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRElt.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFtnProps.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTExtrusion.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTConsolidation.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTBackground.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTNumRestart.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFFCheckBox.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.convert.out.FOSettings.setLayoutMasterSetCalculationInProgress",
	"Comment": "the flag layoutmastersetcalculationinprogress is used by layoutmastersetbuilder, to record\twhether for this conversion run, the correct extents have been calculated yet.\tuser code should not alter this flag.",
	"Method": "void setLayoutMasterSetCalculationInProgress(boolean layoutMasterSetCalculationInProgress){\r\n    this.layoutMasterSetCalculationInProgress = layoutMasterSetCalculationInProgress;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTwipsMeasure.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToUnknownStream.isFirstElemHTML",
	"Comment": "determine if the firts element in the document isor this uses the cached first element name, first element prefix and thecached namespaces from previous method calls",
	"Method": "boolean isFirstElemHTML(){\r\n    boolean isHTML;\r\n    isHTML = getLocalNameUnknown(m_firstElementName).equalsIgnoreCase(\"html\");\r\n    if (isHTML && m_firstElementURI != null && !EMPTYSTRING.equals(m_firstElementURI)) {\r\n        isHTML = false;\r\n    }\r\n    if (isHTML && m_namespacePrefix != null) {\r\n        final int max = m_namespacePrefix.size();\r\n        for (int i = 0; i < max; i++) {\r\n            final String prefix = (String) m_namespacePrefix.elementAt(i);\r\n            final String uri = (String) m_namespaceURI.elementAt(i);\r\n            if (m_firstElementPrefix != null && m_firstElementPrefix.equals(prefix) && !EMPTYSTRING.equals(uri)) {\r\n                isHTML = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return isHTML;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionHeader.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTF.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTRelation.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFunctionGroups.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGradientStop.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.DocPropsExtendedPart.unmarshal",
	"Comment": "unmarshal xml data from the specified inputstream and return the resulting content tree.validation event location information maybe incomplete when using this form of the unmarshal api.implements unmarshal global root element.",
	"Method": "Properties unmarshal(java.io.InputStream is){\r\n    try {\r\n        XMLInputFactory xif = XMLInputFactory.newInstance();\r\n        xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\r\n        xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);\r\n        XMLStreamReader xsr = xif.createXMLStreamReader(is);\r\n        setJAXBContext(org.docx4j.jaxb.Context.jcDocPropsExtended);\r\n        Unmarshaller u = jc.createUnmarshaller();\r\n        u.setEventHandler(new org.docx4j.jaxb.JaxbValidationEventHandler());\r\n        log.info(\"unmarshalling \" + this.getClass().getName());\r\n        jaxbElement = (Properties) u.unmarshal(xsr);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n    return jaxbElement;\r\n}"
}, {
	"Path": "org.docx4j.wml.TblGridBase.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.hpsf.PropertySet.equals",
	"Comment": "returns true if the propertyset is equalto the specified parameter, else false.",
	"Method": "boolean equals(Object o){\r\n    if (o == null || !(o instanceof PropertySet))\r\n        return false;\r\n    final PropertySet ps = (PropertySet) o;\r\n    int byteOrder1 = ps.getByteOrder();\r\n    int byteOrder2 = getByteOrder();\r\n    ClassID classID1 = ps.getClassID();\r\n    ClassID classID2 = getClassID();\r\n    int format1 = ps.getFormat();\r\n    int format2 = getFormat();\r\n    int osVersion1 = ps.getOSVersion();\r\n    int osVersion2 = getOSVersion();\r\n    int sectionCount1 = ps.getSectionCount();\r\n    int sectionCount2 = getSectionCount();\r\n    if (byteOrder1 != byteOrder2 || !classID1.equals(classID2) || format1 != format2 || osVersion1 != osVersion2 || sectionCount1 != sectionCount2)\r\n        return false;\r\n    return Util.equals(getSections(), ps.getSections());\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDrawingHF.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomChartsheetView.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.FontTablePart.unmarshalDefaultFonts",
	"Comment": "unmarshal a default font table, useful when creating thispart from scratch.",
	"Method": "Object unmarshalDefaultFonts(){\r\n    java.io.InputStream is = null;\r\n    try {\r\n        is = ResourceUtils.getResourceViaProperty(\"docx4j.openpackaging.parts.WordprocessingML.FontTablePart.DefaultFonts\", \"org/docx4j/openpackaging/parts/WordprocessingML/fontTable.xml\");\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    return unmarshal(is);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTIntProperty.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getPrintFractionalCharacterWidth",
	"Comment": "gets the value of the printfractionalcharacterwidth property.",
	"Method": "BooleanDefaultTrue getPrintFractionalCharacterWidth(){\r\n    return printFractionalCharacterWidth;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerBase.setSourceLocator",
	"Comment": "this method is used to set the source locator, which might be used togenerated an error message.",
	"Method": "void setSourceLocator(SourceLocator locator){\r\n    m_sourceLocator = locator;\r\n}"
}, {
	"Path": "ser.Git64.main",
	"Comment": "workarounded solution to fst eager input buffer reading issue",
	"Method": "void main(String[] args){\r\n    File temp = File.createTempFile(\"test\", \"dat\");\r\n    final int BUFFER_SIZE_IN_BYTES = 10 * 1024 * 1024;\r\n    final int MAX_ITEMS_BEFORE_FLUSH = 10000;\r\n    final int NUMBER_OF_ITEMS = 1000000;\r\n    try {\r\n        FSTConfiguration config = FSTConfiguration.getDefaultConfiguration();\r\n        int numberOfObjects = 0;\r\n        try (FileOutputStream fileOutputStream = new FileOutputStream(temp)) {\r\n            try (BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream, BUFFER_SIZE_IN_BYTES)) {\r\n                for (int i = 0; i < NUMBER_OF_ITEMS; i++) {\r\n                    Object[] arr = new Object[100];\r\n                    for (int objIdx = 0; objIdx < arr.length; objIdx++) {\r\n                        arr[objIdx] = \"row \" + i + \" - \" + \"my object\" + objIdx;\r\n                    }\r\n                    config.encodeToStream(bufferedOutputStream, arr);\r\n                    numberOfObjects++;\r\n                    if (i % MAX_ITEMS_BEFORE_FLUSH == 0) {\r\n                        System.out.println(\"writing \" + i);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.out.println(\"done with write\");\r\n        try (FileInputStream fileInputStream = new FileInputStream(temp)) {\r\n            try (BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream, BUFFER_SIZE_IN_BYTES)) {\r\n                for (int idx = 0; idx < numberOfObjects; idx++) {\r\n                    Object[] row = (Object[]) config.decodeFromStream(bufferedInputStream);\r\n                    if (idx % MAX_ITEMS_BEFORE_FLUSH == 0) {\r\n                        System.out.println(\"reading \" + idx);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.out.println(\"done with read\");\r\n    } finally {\r\n        temp.delete();\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart.getIDForStyleName",
	"Comment": "given the name of a style known in this part, return the corresponding style id.",
	"Method": "String getIDForStyleName(String name){\r\n    if (styleIdToName == null) {\r\n        refreshNameIdBiMaps();\r\n    }\r\n    return styleNameToId.get(name);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTIdMap.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionRowColumn.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToStream.processDirty",
	"Comment": "process a dirty character and any preeceding clean charactersthat were not yet processed.",
	"Method": "int processDirty(char[] chars,int end,int i,char ch,int lastDirty,boolean fromTextNode){\r\n    int startClean = lastDirty + 1;\r\n    if (i > startClean) {\r\n        int lengthClean = i - startClean;\r\n        m_writer.write(chars, startClean, lengthClean);\r\n    }\r\n    if (CharInfo.S_LINEFEED == ch && fromTextNode) {\r\n        m_writer.write(m_lineSep, 0, m_lineSepLen);\r\n    } else {\r\n        startClean = accumDefaultEscape(m_writer, (char) ch, i, chars, end, fromTextNode, false);\r\n        i = startClean - 1;\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGroupMembers.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRowHierarchiesUsage.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.TTFSubSetFile.writeByte",
	"Comment": "appends a byte to the output array,updates currentpost but not realsize",
	"Method": "void writeByte(byte b){\r\n    output[currentPos++] = b;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTString.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w15.CTSdtRepeatedSection.setDoNotAllowInsertDeleteSection",
	"Comment": "sets the value of the donotallowinsertdeletesection property.",
	"Method": "void setDoNotAllowInsertDeleteSection(BooleanDefaultTrue value){\r\n    this.doNotAllowInsertDeleteSection = value;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTShd.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadata.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMdxMetadata.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotAreas.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.DOM3TreeWalker.initProperties",
	"Comment": "initializes ffeatures based on the domconfiguration parameters set.",
	"Method": "void initProperties(Properties properties){\r\n    for (Enumeration keys = properties.keys(); keys.hasMoreElements(); ) {\r\n        final String key = (String) keys.nextElement();\r\n        final Object iobj = s_propKeys.get(key);\r\n        if (iobj != null) {\r\n            if (iobj instanceof Integer) {\r\n                final int BITFLAG = ((Integer) iobj).intValue();\r\n                if ((properties.getProperty(key).endsWith(\"yes\"))) {\r\n                    fFeatures = fFeatures | BITFLAG;\r\n                } else {\r\n                    fFeatures = fFeatures & ~BITFLAG;\r\n                }\r\n            } else {\r\n                if ((DOMConstants.S_DOM3_PROPERTIES_NS + DOMConstants.DOM_FORMAT_PRETTY_PRINT).equals(key)) {\r\n                    if ((properties.getProperty(key).endsWith(\"yes\"))) {\r\n                        fSerializer.setIndent(true);\r\n                        fSerializer.setIndentAmount(3);\r\n                    } else {\r\n                        fSerializer.setIndent(false);\r\n                    }\r\n                } else if ((DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL).equals(key)) {\r\n                    if ((properties.getProperty(key).endsWith(\"yes\"))) {\r\n                        fSerializer.setOmitXMLDeclaration(true);\r\n                    } else {\r\n                        fSerializer.setOmitXMLDeclaration(false);\r\n                    }\r\n                } else if ((DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.S_XML_VERSION).equals(key)) {\r\n                    String version = properties.getProperty(key);\r\n                    if (\"1.1\".equals(version)) {\r\n                        fIsXMLVersion11 = true;\r\n                        fSerializer.setVersion(version);\r\n                    } else {\r\n                        fSerializer.setVersion(\"1.0\");\r\n                    }\r\n                } else if ((DOMConstants.S_XSL_OUTPUT_ENCODING).equals(key)) {\r\n                    String encoding = properties.getProperty(key);\r\n                    if (encoding != null) {\r\n                        fSerializer.setEncoding(encoding);\r\n                    }\r\n                } else if ((DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.DOM_ENTITIES).equals(key)) {\r\n                    if ((properties.getProperty(key).endsWith(\"yes\"))) {\r\n                        fSerializer.setDTDEntityExpansion(false);\r\n                    } else {\r\n                        fSerializer.setDTDEntityExpansion(true);\r\n                    }\r\n                } else {\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (fNewLine != null) {\r\n        fSerializer.setOutputProperty(OutputPropertiesFactory.S_KEY_LINE_SEPARATOR, fNewLine);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.XML11Char.isXML11InternalEntityContent",
	"Comment": "returns true if the specified character can be considered content in an internal parsed entity.",
	"Method": "boolean isXML11InternalEntityContent(int c){\r\n    return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_CONTENT_INTERNAL) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "org.docx4j.wml.SdtBlock.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.BooleanDefaultTrue.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTOdso.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.schemas.microsoft.com.office.excel_2006.main.CTWorksheet.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTString.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.injection.AbstractInjectionDetector.report",
	"Comment": "once the analysis is completed, all the collected sinks are reported as bugs.",
	"Method": "void report(){\r\n    Set<InjectionSink> injectionSinksToReport = new HashSet<InjectionSink>();\r\n    for (Set<InjectionSink> injectionSinkSet : injectionSinks.values()) {\r\n        for (InjectionSink injectionSink : injectionSinkSet) {\r\n            injectionSinksToReport.add(injectionSink);\r\n        }\r\n    }\r\n    for (InjectionSink injectionSink : injectionSinksToReport) {\r\n        bugReporter.reportBug(injectionSink.generateBugInstance(false));\r\n    }\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.dom.DOMWriterImpl.writeCDATA",
	"Comment": "writes the cdata section to the dom.does nothing if the object is null.",
	"Method": "void writeCDATA(String data){\r\n    if (data == null)\r\n        return;\r\n    this.document.createCDATASection(data);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTVolTopic.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.convert.out.html.XsltHTMLFunctions.getNumberXmlNode",
	"Comment": "the method used by the xslt extension function during html export.\tif there is no number, it returns an empty span element.",
	"Method": "String getNumberXmlNode(HTMLConversionContext context,NodeIterator pPrNodeIt,String pStyleVal,String numId,String levelId){\r\n    context.getLog().debug(\"numbering, using style '\" + pStyleVal + \"'; numId=\" + numId + \"; ilvl \" + levelId);\r\n    try {\r\n        ResultTriple triple = org.docx4j.model.listnumbering.Emulator.getNumber(context.getWmlPackage(), pStyleVal, numId, levelId);\r\n        if (triple == null) {\r\n            context.getLog().debug(\"computed number ResultTriple was null\");\r\n            return null;\r\n        }\r\n        String styleVal = \"\";\r\n        if (triple.getBullet() != null) {\r\n            return \"?  \";\r\n        } else if (triple.getNumString() == null) {\r\n            context.getLog().debug(\"computed NumString was null (which may be ok)\");\r\n            return \" \";\r\n        } else {\r\n            return triple.getNumString() + \" \";\r\n        }\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        context.getLog().error(e.getMessage(), e);\r\n    }\r\n    return \"?  \";\r\n}"
}, {
	"Path": "org.nustaq.serialization.simpleapi.DefaultCoder.toByteArray",
	"Comment": "will throw an fstbuffertoosmallexception if buffer is too small.",
	"Method": "int toByteArray(Object obj,byte result,int resultOffset,int avaiableSize,byte[] toByteArray,Object o){\r\n    output.resetForReUse();\r\n    try {\r\n        output.writeObject(o);\r\n    } catch (IOException e) {\r\n        FSTUtil.<RuntimeException>rethrow(e);\r\n    }\r\n    return output.getCopyOfWrittenBuffer();\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomWorkbookView.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDxfs.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setDoNotUseEastAsianBreakRules",
	"Comment": "sets the value of the donotuseeastasianbreakrules property.",
	"Method": "void setDoNotUseEastAsianBreakRules(BooleanDefaultTrue value){\r\n    this.doNotUseEastAsianBreakRules = value;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDiv.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTGuid.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalSheetData.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTPresetLineDashProperties.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTIgnoredError.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.convert.out.ConversionFeatures.checkParams",
	"Comment": "check the package and requested features and append defaults if necessary",
	"Method": "void checkParams(OpcPackage opcPackage,Set<String> features){\r\n    if (opcPackage == null) {\r\n        throw new IllegalArgumentException(\"The passed opcPackage is null.\");\r\n    }\r\n    if (features == null) {\r\n        throw new IllegalArgumentException(\"The set of the features is null.\");\r\n    }\r\n    if (features.contains(PP_COMMON_PAGE_NUMBERING)) {\r\n        features.add(PP_COMMON_COMBINE_FIELDS);\r\n    }\r\n    if (!features.contains(PP_COMMON_PAGE_NUMBERING)) {\r\n        features.add(PP_COMMON_DUMMY_PAGE_NUMBERING);\r\n    }\r\n    if (!features.contains(PP_COMMON_CREATE_SECTIONS)) {\r\n        features.add(PP_COMMON_DUMMY_CREATE_SECTIONS);\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFills.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.DOM3SerializerImpl.getErrorHandler",
	"Comment": "returns a domerrorhandler set on the dom level 3 serializer.this interface is a public api.",
	"Method": "DOMErrorHandler getErrorHandler(){\r\n    return fErrorHandler;\r\n}"
}, {
	"Path": "org.nustaq.serialization.FSTObjectRegistry.registerObjectForWrite",
	"Comment": "add an object to the register, return handle if already present. called during write only",
	"Method": "int registerObjectForWrite(Object o,int streamPosition,FSTClazzInfo clzInfo,int reUseType){\r\n    if (disabled) {\r\n        return Integer.MIN_VALUE;\r\n    }\r\n    if (clzInfo == null) {\r\n    } else if (clzInfo.isFlat()) {\r\n        return Integer.MIN_VALUE;\r\n    }\r\n    int handle = objects.putOrGet(o, streamPosition);\r\n    if (handle >= 0) {\r\n        reUseType[0] = 0;\r\n        return handle;\r\n    }\r\n    return Integer.MIN_VALUE;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblLayoutType.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTupleCache.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTextEffect.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataValidation.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.getNonParametricState",
	"Comment": "gets the state influencing the state of this fact if dependant on methodarguments, final state is given by merge of that state and arguments",
	"Method": "State getNonParametricState(){\r\n    return nonParametricState;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFilters.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.schemas.microsoft.com.office.excel_2006.main.CTWorksheet.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.taskpanes_2010_11.CTOsfTaskpane.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTGradientStopList.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.agent.execution.services.impl.FetchingCacheServiceImplTests.cacheConcurrentFetchFailOne",
	"Comment": "start two concurrent resource fetches.make the first one to start download failmake sure a cache files exist because the other fetch succeeds",
	"Method": "void cacheConcurrentFetchFailOne(){\r\n    final AtomicInteger numOfCacheMisses = new AtomicInteger(0);\r\n    final ResourceLoader resourceLoader = Mockito.mock(ResourceLoader.class);\r\n    final Resource resource = Mockito.mock(Resource.class);\r\n    final CountDownLatch lockAquisitionAttempted = new CountDownLatch(2);\r\n    final ReentrantLock lockBackingMock = new ReentrantLock();\r\n    final CloseableLock resourceLock = Mockito.mock(CloseableLock.class);\r\n    Mockito.doAnswer(invocation -> {\r\n        lockAquisitionAttempted.countDown();\r\n        lockBackingMock.lock();\r\n        return null;\r\n    }).when(resourceLock).lock();\r\n    Mockito.doAnswer(invocation -> {\r\n        lockBackingMock.unlock();\r\n        return null;\r\n    }).when(resourceLock).close();\r\n    final FileLockFactory fileLockFactory = Mockito.mock(FileLockFactory.class);\r\n    Mockito.when(fileLockFactory.getLock(Mockito.any())).thenReturn(resourceLock);\r\n    final ResourceLoader resourceLoader2 = Mockito.mock(ResourceLoader.class);\r\n    final Resource resource2 = Mockito.mock(Resource.class);\r\n    Mockito.when(resourceLoader.getResource(Mockito.anyString())).thenReturn(resource);\r\n    Mockito.when(resource.getInputStream()).thenAnswer((Answer<InputStream>) invocation -> {\r\n        if (numOfCacheMisses.incrementAndGet() == 1) {\r\n            return simulateDownloadFailureWithWait();\r\n        } else {\r\n            return Mockito.spy(new ByteArrayInputStream(\"\".getBytes(Charset.forName(\"UTF-8\"))));\r\n        }\r\n    });\r\n    final long lastModifiedTimeStamp = System.currentTimeMillis();\r\n    Mockito.when(resource.exists()).thenReturn(true);\r\n    Mockito.when(resource.lastModified()).thenReturn(lastModifiedTimeStamp);\r\n    final FetchingCacheServiceImpl cache1 = new FetchingCacheServiceImpl(resourceLoader, cacheArguments, fileLockFactory, cleanUpTaskExecutor);\r\n    Mockito.when(resourceLoader2.getResource(Mockito.anyString())).thenReturn(resource2);\r\n    Mockito.when(resource2.getInputStream()).thenAnswer((Answer<InputStream>) invocation -> {\r\n        if (numOfCacheMisses.incrementAndGet() == 1) {\r\n            return simulateDownloadFailureWithWait();\r\n        } else {\r\n            return Mockito.spy(new ByteArrayInputStream(\"\".getBytes(Charset.forName(\"UTF-8\"))));\r\n        }\r\n    });\r\n    Mockito.when(resource2.exists()).thenReturn(true);\r\n    Mockito.when(resource2.lastModified()).thenReturn(lastModifiedTimeStamp);\r\n    final FetchingCacheServiceImpl cache2 = new FetchingCacheServiceImpl(resourceLoader2, cacheArguments, fileLockFactory, cleanUpTaskExecutor);\r\n    downloadCompleted.set(false);\r\n    numOfCacheMisses.set(0);\r\n    final CountDownLatch allFetchesDone = new CountDownLatch(2);\r\n    executorService.submit(() -> {\r\n        try {\r\n            cache1.get(uri, targetFile);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            allFetchesDone.countDown();\r\n        }\r\n    });\r\n    executorService.submit(() -> {\r\n        try {\r\n            cache2.get(uri, targetFile);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            allFetchesDone.countDown();\r\n        }\r\n    });\r\n    lockAquisitionAttempted.await();\r\n    downloadCompleted.set(true);\r\n    simulateDownloadLock.lock();\r\n    try {\r\n        downloadComplete.signal();\r\n    } finally {\r\n        simulateDownloadLock.unlock();\r\n    }\r\n    allFetchesDone.await();\r\n    Assert.assertTrue(numOfCacheMisses.get() == 2);\r\n    Assert.assertTrue(directoryStructureExists(cache1.getResourceCacheId(uri), lastModifiedTimeStamp, cache1));\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getUseAltKinsokuLineBreakRules",
	"Comment": "gets the value of the usealtkinsokulinebreakrules property.",
	"Method": "BooleanDefaultTrue getUseAltKinsokuLineBreakRules(){\r\n    return useAltKinsokuLineBreakRules;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellProtection.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableColumn.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSFileSystem.close",
	"Comment": "closes the filesystem, freeing any underlying files, streams and buffers. after this, you will be unable to read orwrite from the filesystem.",
	"Method": "void close(){\r\n    _data.close();\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCustomXmlBlock.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionInsertSheet.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTEastAsianLayout.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.convert.out.common.Preprocess.createRelationshipTypes",
	"Comment": "check what parts might be changed by the preprocessing, \t those parts need to be deep copied.",
	"Method": "Set<String> createRelationshipTypes(Set<String> features){\r\n    Set<String> relationshipTypes = new TreeSet<String>();\r\n    if (features.contains(PP_COMMON_MOVE_BOOKMARKS) || features.contains(PP_COMMON_CONTAINERIZATION) || features.contains(PP_COMMON_COMBINE_FIELDS)) {\r\n        relationshipTypes.add(Namespaces.DOCUMENT);\r\n        relationshipTypes.add(Namespaces.HEADER);\r\n        relationshipTypes.add(Namespaces.FOOTER);\r\n        relationshipTypes.add(Namespaces.ENDNOTES);\r\n        relationshipTypes.add(Namespaces.FOOTNOTES);\r\n        relationshipTypes.add(Namespaces.COMMENTS);\r\n    }\r\n    if (features.contains(PP_COMMON_MOVE_PAGEBREAK)) {\r\n        relationshipTypes.add(Namespaces.DOCUMENT);\r\n    }\r\n    return relationshipTypes;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTUndoInfo.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGradientStop.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotField.isMultipleItemSelectionAllowed",
	"Comment": "gets the value of the multipleitemselectionallowed property.",
	"Method": "boolean isMultipleItemSelectionAllowed(){\r\n    if (multipleItemSelectionAllowed == null) {\r\n        return false;\r\n    } else {\r\n        return multipleItemSelectionAllowed;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.dml.wordprocessingDrawing.Anchor.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSFileSystem.getMiniStore",
	"Comment": "returns the ministore, which performs a similar low level function to this, except for the small blocks.",
	"Method": "NPOIFSMiniStore getMiniStore(){\r\n    return _mini_store;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTVerticalJc.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTGroup.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataField.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTBevel.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPane.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTChartsheetPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerBase.addAttributes",
	"Comment": "add the given attributes to the currently collected ones. theseattributes are always added, regardless of whether on not an elementis currently open.",
	"Method": "void addAttributes(Attributes atts){\r\n    int nAtts = atts.getLength();\r\n    for (int i = 0; i < nAtts; i++) {\r\n        String uri = atts.getURI(i);\r\n        if (null == uri)\r\n            uri = \"\";\r\n        addAttributeAlways(uri, atts.getLocalName(i), atts.getQName(i), atts.getType(i), atts.getValue(i), false);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.vml.CTArc.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w15.CTGuid.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.RunTrackChange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTShadow.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTextEffect.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTHeaderFooter.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTDiagram.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTBorderBox.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToStream.ignorableWhitespace",
	"Comment": "receive notification of ignorable whitespace in element content.not sure how to get this invoked quite yet.",
	"Method": "void ignorableWhitespace(char ch,int start,int length){\r\n    if (0 == length)\r\n        return;\r\n    characters(ch, start, length);\r\n}"
}, {
	"Path": "org.docx4j.model.datastorage.BindingTraverserTableHelper.setupMaxWidthAndStyleForTc",
	"Comment": "get table cell width from tc and table style from tbl and set it to xhtmlimporter.",
	"Method": "void setupMaxWidthAndStyleForTc(Tbl tbl,Tc tc,XHTMLImporter xHTMLImporter){\r\n    if (tc.getTcPr() != null && tc.getTcPr().getTcW() != null) {\r\n        TblWidth tcW = tc.getTcPr().getTcW();\r\n        if (tcW.getW() != null && tcW.getType().equals(TblWidth.TYPE_DXA)) {\r\n            int maxWidth = tcW.getW().intValue();\r\n            String styleVal = null;\r\n            if (tbl != null && tbl.getTblPr() != null && tbl.getTblPr().getTblStyle() != null) {\r\n                styleVal = tbl.getTblPr().getTblStyle().getVal();\r\n            }\r\n            log.debug(\"inserting in a tc, with maxwidth: \" + maxWidth + \", and table style: \" + styleVal);\r\n            xHTMLImporter.setMaxWidth(maxWidth, styleVal);\r\n        } else {\r\n            log.debug(\"w:tcPr/w:tcW present, but width not in dxa units \");\r\n        }\r\n    } else {\r\n        log.debug(\"w:tcPr/w:tcW not present\");\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.schemas.microsoft.com.office.excel_2008_2.main.CTDefinedNameArgumentDescription.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTEntry.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.HeaderReference.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.c14n.helper.C14nHelper.checkTraversability",
	"Comment": "this method throws a canonicalizationexception if the supplied documentis not able to be traversed using a treewalker.",
	"Method": "void checkTraversability(Document document){\r\n    if (!document.isSupported(\"Traversal\", \"2.0\")) {\r\n        Object[] exArgs = { document.getImplementation().getClass().getName() };\r\n        throw new CanonicalizationException(\"c14n.Canonicalizer.TraversalNotSupported\", exArgs);\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDrawingHF.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTField.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTConnections.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTChartFormats.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.taskpanes_2010_11.CTOsfTaskpane.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotArea.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTConditionalFormatting.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTShapeDefaults.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.org.apache.poi.ss.usermodel.DateUtil.isInternalDateFormat",
	"Comment": "given a format id this will check whether the format represents an internal excel date format or not.",
	"Method": "boolean isInternalDateFormat(int format){\r\n    switch(format) {\r\n        case 0x0e:\r\n        case 0x0f:\r\n        case 0x10:\r\n        case 0x11:\r\n        case 0x12:\r\n        case 0x13:\r\n        case 0x14:\r\n        case 0x15:\r\n        case 0x16:\r\n        case 0x2d:\r\n        case 0x2e:\r\n        case 0x2f:\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.docx4j.math.CTNaryPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "testcode.xxe.DocumentBuilderSafeProperty.safeManualConfiguration",
	"Comment": "this implementation allow dtd but disable all its dangerous features.not sure it can still do something useful with dtd ...",
	"Method": "void safeManualConfiguration(){\r\n    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\r\n    dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\r\n    dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);\r\n    dbf.setXIncludeAware(false);\r\n    dbf.setExpandEntityReferences(false);\r\n    DocumentBuilder db = dbf.newDocumentBuilder();\r\n    Document doc = db.parse(getInputFile());\r\n    print(doc);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFontName.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.model.listnumbering.ListLevel.IsBullet",
	"Comment": "returns whether the enumeration type is a bulleted list or not",
	"Method": "boolean IsBullet(){\r\n    return this.isBullet;\r\n}"
}, {
	"Path": "org.docx4j.model.structure.HeaderFooterPolicy.getDefaultFooter",
	"Comment": "if an even footer is present this is the odd footer \t otherwise it is both, even and odd footer",
	"Method": "FooterPart getDefaultFooter(){\r\n    return defaultFooter;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTTextPath.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTLimUppPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.taskpanes_2010_11.CTOsfTaskpanes.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.XMLUtils.createElementInSignature11Space",
	"Comment": "creates an element in the xml signature 1.1 specification namespace.",
	"Method": "Element createElementInSignature11Space(Document doc,String elementName){\r\n    if (doc == null) {\r\n        throw new RuntimeException(\"Document is null\");\r\n    }\r\n    if (ds11Prefix == null || ds11Prefix.length() == 0) {\r\n        return doc.createElementNS(Constants.SignatureSpec11NS, elementName);\r\n    }\r\n    return doc.createElementNS(Constants.SignatureSpec11NS, ds11Prefix + \":\" + elementName);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTX.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.topologi.diffx.sequence.PrefixMapping.add",
	"Comment": "add the specified mapping if the namespace uri has not been mapped before.this method will ensure that the mapping is actually unique, that is thatthe namespace uri correspond to one and only one prefix and that the prefix onlycorresponds to one and only one namespace uri.",
	"Method": "void add(String uri,String prefix){\r\n    if (!this.mappings.containsKey(uri)) {\r\n        int count = 0;\r\n        String actualPrefix = prefix;\r\n        while (this.mappings.containsValue(actualPrefix)) {\r\n            actualPrefix = prefix + count++;\r\n        }\r\n        this.mappings.put(uri, actualPrefix);\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Dialogsheet.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTChartFormat.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.topologi.diffx.sequence.NaiveSequenceSlicer.formatStart",
	"Comment": "formats the start subsequence that has been buffered by this class.this method will clear the buffer, but will do nothing if the start buffer isnull.",
	"Method": "void formatStart(DiffXFormatter formatter){\r\n    if (this.start == null)\r\n        return;\r\n    for (int i = 0; i < this.start.size(); i++) {\r\n        formatter.format(this.start.getEvent(i));\r\n    }\r\n    this.start = null;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTLevelGroup.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionCellChange.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode.getNFileSystem",
	"Comment": "if this is npoifs based, return the npoifsfilesystem that this belong to, otherwise null if opoifs based",
	"Method": "NPOIFSFileSystem getNFileSystem(){\r\n    return _nfilesystem;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.c14n.helper.C14nHelper.checkForRelativeNamespace",
	"Comment": "this method throws a canonicalizationexception if the supplied elementcontains any relative namespaces.",
	"Method": "void checkForRelativeNamespace(Element ctxNode){\r\n    if (ctxNode != null) {\r\n        NamedNodeMap attributes = ctxNode.getAttributes();\r\n        for (int i = 0; i < attributes.getLength(); i++) {\r\n            C14nHelper.assertNotRelativeNS((Attr) attributes.item(i));\r\n        }\r\n    } else {\r\n        throw new CanonicalizationException(\"Called checkForRelativeNamespace() on null\");\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.vml.CTH.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRangeSets.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.model.fields.merge.MailMergerWithNext.perform",
	"Comment": "perform the merge. recognize the next instruction to go to the next data.",
	"Method": "List<Object> perform(WordprocessingMLPackage input,List<Object> contentList,List<Map<DataFieldName, String>> data,FormTextFieldNames formTextFieldNames){\r\n    Body shell = Context.getWmlObjectFactory().createBody();\r\n    shell.getContent().addAll(contentList);\r\n    Body shellClone = (Body) XmlUtils.deepCopy(shell);\r\n    ComplexFieldLocator fl = new ComplexFieldLocator();\r\n    new TraversalUtil(shellClone, fl);\r\n    log.info(\"Found \" + fl.getStarts().size() + \" fields \");\r\n    List<FieldRef> fieldRefs = new ArrayList<FieldRef>();\r\n    canonicaliseStarts(fl, fieldRefs);\r\n    int datamapIndex = 0;\r\n    Map<DataFieldName, String> datamap = data.get(datamapIndex);\r\n    for (FieldRef fr : fieldRefs) {\r\n        if (fr.getFldName().equals(\"MERGEFIELD\")) {\r\n            String instr = extractInstr(fr.getInstructions());\r\n            String datafieldName = getDatafieldNameFromInstr(instr);\r\n            String val = datamap.get(new DataFieldName(datafieldName));\r\n            String gFormat = null;\r\n            if (val == null || val.length() == 0) {\r\n                if (fieldFate.equals(OutputField.REMOVED)) {\r\n                    removeSimpleField(fr);\r\n                    String text = getTextInsideContent(fr.getParent());\r\n                    if (StringUtils.isBlank(text)) {\r\n                        if (data.size() > datamapIndex) {\r\n                            recursiveRemove(shellClone, fr.getParent());\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                FldSimpleModel fsm = new FldSimpleModel();\r\n                try {\r\n                    fsm.build(instr);\r\n                    val = FormattingSwitchHelper.applyFormattingSwitch(input, fsm, val);\r\n                    gFormat = FormattingSwitchHelper.findFirstSwitchValue(\"\\\\*\", fsm.getFldParameters(), true);\r\n                } catch (TransformerException e) {\r\n                    log.warn(\"Can't format the field\", e);\r\n                }\r\n                fr.setResult(val);\r\n            }\r\n            if (fieldFate.equals(OutputField.AS_FORMTEXT_REGULAR)) {\r\n                log.debug(gFormat);\r\n                List<Object> instructions = fr.getInstructions();\r\n                if (instructions.size() != 1) {\r\n                    log.error(\"TODO MERGEFIELD field contained complex instruction\");\r\n                    continue;\r\n                }\r\n                Object o = XmlUtils.unwrap(instructions.get(0));\r\n                if (o instanceof Text) {\r\n                    ((Text) o).setValue(\"FORMTEXT\");\r\n                } else {\r\n                    if (log.isErrorEnabled()) {\r\n                        log.error(\"TODO: set FORMTEXT in\" + o.getClass().getName());\r\n                        log.error(XmlUtils.marshaltoString(instructions.get(0), true, true));\r\n                    }\r\n                    continue;\r\n                }\r\n                String fieldName = formTextFieldNames.generateName(datafieldName);\r\n                log.debug(\"Field name normalisation: \" + datafieldName + \" -> \" + fieldName);\r\n                setFormFieldProperties(fr, fieldName, null);\r\n                R resultR = fr.getResultsSlot();\r\n                if (resultR.getRPr() != null && resultR.getRPr().getHighlight() != null) {\r\n                    resultR.getRPr().setHighlight(null);\r\n                }\r\n            } else if (!fieldFate.equals(OutputField.KEEP_MERGEFIELD)) {\r\n                fr.getParent().getContent().remove(fr.getBeginRun());\r\n                fr.getParent().getContent().remove(fr.getEndRun());\r\n            }\r\n        } else if (fr.getFldName().equals(\"NEXT\")) {\r\n            removeSimpleField(fr);\r\n            datamapIndex++;\r\n            if (datamapIndex >= data.size()) {\r\n                datamap = new HashMap<DataFieldName, String>();\r\n            } else {\r\n                datamap = data.get(datamapIndex);\r\n            }\r\n        }\r\n    }\r\n    return shellClone.getContent();\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMdxKPI.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableMissing.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtEndPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTProxy.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getDisplayHorizontalDrawingGridEvery",
	"Comment": "gets the value of the displayhorizontaldrawinggridevery property.",
	"Method": "CTSettings.DisplayHorizontalDrawingGridEvery getDisplayHorizontalDrawingGridEvery(){\r\n    return displayHorizontalDrawingGridEvery;\r\n}"
}, {
	"Path": "org.docx4j.convert.out.HTMLSettings.setScriptElementHandler",
	"Comment": "how to generate the script element. the default implementation is inline.",
	"Method": "void setScriptElementHandler(ConversionHTMLScriptElementHandler scriptElementHandler){\r\n    settings.put(SCRIPT_ELEMENT_HANDLER, scriptElementHandler);\r\n}"
}, {
	"Path": "org.docx4j.w15.CTCommentsEx.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTRuby.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRecord.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTBar.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.DocumentSettingsPart.protectRestrictEditing",
	"Comment": "enforces the protection with the option specified by passed editvalue, password, and hashalgorithm for the password.",
	"Method": "void protectRestrictEditing(org.docx4j.wml.STDocProtect editValue,String password,HashAlgorithm hashAlgo){\r\n    safeGetDocumentProtection().setEnforcement(true);\r\n    safeGetDocumentProtection().setEdit(editValue);\r\n    if (editValue == STDocProtect.TRACKED_CHANGES) {\r\n        if (this.jaxbElement.getTrackRevisions() == null) {\r\n            this.jaxbElement.setTrackRevisions(new BooleanDefaultTrue());\r\n        }\r\n    }\r\n    setProtectionPassword(password, hashAlgo);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setDoNotValidateAgainstSchema",
	"Comment": "sets the value of the donotvalidateagainstschema property.",
	"Method": "void setDoNotValidateAgainstSchema(BooleanDefaultTrue value){\r\n    this.doNotValidateAgainstSchema = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomSheetViews.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.webextension_2010_11.CTWebExtensionPartRef.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTRubyAlign.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTReviewedRevisions.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToXMLStream.getXMLVersion",
	"Comment": "this method checks for the xml version of output document.if xml version of output document is not specified, then output document is of version xml 1.0.if xml version of output doucment is specified, but it is not either xml 1.0 or xml 1.1, a warning message is generated, the xml version ofoutput document is set to xml 1.0 and processing continues.",
	"Method": "String getXMLVersion(){\r\n    String xmlVersion = getVersion();\r\n    if (xmlVersion == null || xmlVersion.equals(XMLVERSION10)) {\r\n        xmlVersion = XMLVERSION10;\r\n    } else if (xmlVersion.equals(XMLVERSION11)) {\r\n        xmlVersion = XMLVERSION11;\r\n    } else {\r\n        String msg = Utils.messages.createMessage(MsgKey.ER_XML_VERSION_NOT_SUPPORTED, new Object[] { xmlVersion });\r\n        try {\r\n            Transformer tran = super.getTransformer();\r\n            ErrorListener errHandler = tran.getErrorListener();\r\n            if (null != errHandler && m_sourceLocator != null)\r\n                errHandler.warning(new TransformerException(msg, m_sourceLocator));\r\n            else\r\n                System.out.println(msg);\r\n        } catch (Exception e) {\r\n        }\r\n        xmlVersion = XMLVERSION10;\r\n    }\r\n    return xmlVersion;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.BoolStack.popAndTop",
	"Comment": "removes the object at the top of this stack and returns thenext object at the top as the value of this function.",
	"Method": "boolean popAndTop(){\r\n    m_index--;\r\n    return (m_index >= 0) ? m_values[m_index] : false;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.MainDocumentPart.addParagraphOfText",
	"Comment": "create a paragraph containing the string simpletext,\tand add it to the document.if passed null, the result\tis an empty p.",
	"Method": "org.docx4j.wml.P addParagraphOfText(String simpleText){\r\n    org.docx4j.wml.P para = createParagraphOfText(simpleText);\r\n    addObject(para);\r\n    return para;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToStream.startDTD",
	"Comment": "report the start of dtd declarations, if any.any declarations are assumed to be in the internal subset unlessotherwise indicated.",
	"Method": "void startDTD(String name,String publicId,String systemId){\r\n    setDoctypeSystem(systemId);\r\n    setDoctypePublic(publicId);\r\n    m_elemContext.m_elementName = name;\r\n    m_inDoctype = true;\r\n}"
}, {
	"Path": "org.docx4j.toc.TocGenerator.generateToc",
	"Comment": "generate table of contents using default toc instruction, adding it at the beginning of the documentto alter the toc heading, use toc.settocheadingtext",
	"Method": "SdtBlock generateToc(WordprocessingMLPackage wordMLPackage,boolean skipPageNumbering,SdtBlock generateToc,WordprocessingMLPackage wordMLPackage,int index,String instruction,boolean skipPageNumbering,SdtBlock generateToc,boolean skipPageNumbering,SdtBlock generateToc,int index,String instruction,boolean skipPageNumbering,SdtBlock generateToc,int index,String instruction,STTabTlc leader,boolean skipPageNumbering,SdtBlock generateToc,SdtBlock sdt,String instruction,STTabTlc leader,boolean skipPageNumbering,SdtBlock generateToc,SdtBlock sdt,List<P> tocHeadingP,String instruction,STTabTlc leader,boolean skipPageNumbering){\r\n    MainDocumentPart documentPart = wordMLPackage.getMainDocumentPart();\r\n    Document wmlDocumentEl = (Document) documentPart.getJaxbElement();\r\n    Body body = wmlDocumentEl.getBody();\r\n    SdtContentBlock sdtContent = (SdtContentBlock) sdt.getSdtContent();\r\n    if (sdtContent == null) {\r\n        sdtContent = createSdtContent();\r\n        sdt.setSdtContent(sdtContent);\r\n    }\r\n    if (tocHeadingP == null || tocHeadingP.size() == 0) {\r\n        log.warn(\"No ToC header paragraph provided!\");\r\n    } else {\r\n        sdtContent.getContent().addAll(tocHeadingP);\r\n    }\r\n    populateToc(sdtContent, instruction, leader, skipPageNumbering);\r\n    return sdt;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTConditionalFormat.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.TblGrid.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.Encodings.isRecognizedEncoding",
	"Comment": "determines if the encoding specified was recognized by theserializer or not.",
	"Method": "boolean isRecognizedEncoding(String encoding){\r\n    EncodingInfo ei;\r\n    String normalizedEncoding = encoding.toUpperCase();\r\n    ei = (EncodingInfo) _encodingTableKeyJava.get(normalizedEncoding);\r\n    if (ei == null)\r\n        ei = (EncodingInfo) _encodingTableKeyMime.get(normalizedEncoding);\r\n    if (ei != null)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCfRule.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalLink.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.Typeface.notifyMapOperation",
	"Comment": "used for keeping track of character mapping operations in order to determine if a fontwas used at all or not.",
	"Method": "void notifyMapOperation(){\r\n    this.charMapOps++;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTCurve.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.BinaryPartAbstractImage.createLinkedImagePart",
	"Comment": "create a linked image part, and attach it as a rel of the docx main document part",
	"Method": "BinaryPartAbstractImage createLinkedImagePart(WordprocessingMLPackage wordMLPackage,URL fileurl,BinaryPartAbstractImage createLinkedImagePart,OpcPackage opcPackage,Part sourcePart,URL url){\r\n    log.debug(\"Incoming url for linked image: \" + url.toString());\r\n    ImageInfo info = ensureFormatIsSupported(url, null, null, false);\r\n    ContentTypeManager ctm = opcPackage.getContentTypeManager();\r\n    String proposedRelId = sourcePart.getRelationshipsPart().getNextId();\r\n    String ext = info.getMimeType().substring(info.getMimeType().indexOf(\"/\") + 1);\r\n    BinaryPartAbstractImage imagePart = (BinaryPartAbstractImage) ctm.newPartForContentType(info.getMimeType(), createImageName(opcPackage, sourcePart, proposedRelId, ext), null);\r\n    log.debug(\"created part \" + imagePart.getClass().getName() + \" with name \" + imagePart.getPartName().toString());\r\n    imagePart.rels.add(sourcePart.addTargetPart(imagePart));\r\n    imagePart.getRelLast().setTargetMode(\"External\");\r\n    opcPackage.getExternalResources().put(imagePart.getExternalTarget(), imagePart);\r\n    imagePart.getRelLast().setTarget(url.toString());\r\n    imagePart.setImageInfo(info);\r\n    return imagePart;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTShapeLayout.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.util.CharUtilities.isAdjustableSpace",
	"Comment": "method to determine if the character is an adjustablespace.",
	"Method": "boolean isAdjustableSpace(char c){\r\n    return (c == ' ' || c == NBSPACE);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalDefinedNames.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOleLink.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCsPageSetup.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotField.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getDoNotAutofitConstrainedTables",
	"Comment": "gets the value of the donotautofitconstrainedtables property.",
	"Method": "BooleanDefaultTrue getDoNotAutofitConstrainedTables(){\r\n    return doNotAutofitConstrainedTables;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTPositiveFixedPercentage.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadata.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotHierarchy.isMultipleItemSelectionAllowed",
	"Comment": "gets the value of the multipleitemselectionallowed property.",
	"Method": "boolean isMultipleItemSelectionAllowed(){\r\n    if (multipleItemSelectionAllowed == null) {\r\n        return false;\r\n    } else {\r\n        return multipleItemSelectionAllowed;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.relationships.Relationship.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFutureMetadata.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTGroup.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRgbColor.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDynamicFilter.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTBreakBinSub.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.transformer.TransformerIdentityImpl.getErrorListener",
	"Comment": "get the error event handler in effect for the transformation.",
	"Method": "ErrorListener getErrorListener(){\r\n    return m_errorListener;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataRefs.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotFilter.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.LSSerializerImpl.createLSException",
	"Comment": "creates an lsexception. on j2se 1.4 and above the cause for the exception will be set.",
	"Method": "LSException createLSException(short code,Throwable cause){\r\n    LSException lse = new LSException(code, cause != null ? cause.getMessage() : null);\r\n    if (cause != null && ThrowableMethods.fgThrowableMethodsAvailable) {\r\n        try {\r\n            ThrowableMethods.fgThrowableInitCauseMethod.invoke(lse, new Object[] { cause });\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return lse;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomProperties.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTMCS.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblLook.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadataStringIndex.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTPictureBase.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.autodetect.FontInfoFinder.generateTripletsFromFont",
	"Comment": "attempts to determine fonttriplets from a given customfont.it seems to be fairly accurate but will probably require some tweaking over time",
	"Method": "void generateTripletsFromFont(CustomFont customFont,Collection triplets){\r\n    if (log.isTraceEnabled()) {\r\n        log.trace(\"Font: \" + customFont.getFullName() + \", family: \" + customFont.getFamilyNames() + \", PS: \" + customFont.getFontName() + \", EmbedName: \" + customFont.getEmbedFontName());\r\n    }\r\n    String strippedName = stripQuotes(customFont.getStrippedFontName());\r\n    String fullName = stripQuotes(customFont.getFullName());\r\n    String searchName = fullName.toLowerCase();\r\n    String style = guessStyle(customFont, searchName);\r\n    int weight;\r\n    int guessedWeight = FontUtil.guessWeight(searchName);\r\n    weight = guessedWeight;\r\n    triplets.add(new FontTriplet(fullName, Font.STYLE_NORMAL, Font.WEIGHT_NORMAL));\r\n    if (!fullName.equals(strippedName)) {\r\n        triplets.add(new FontTriplet(strippedName, Font.STYLE_NORMAL, Font.WEIGHT_NORMAL));\r\n    }\r\n    Set familyNames = customFont.getFamilyNames();\r\n    Iterator iter = familyNames.iterator();\r\n    while (iter.hasNext()) {\r\n        String familyName = stripQuotes((String) iter.next());\r\n        if (!fullName.equals(familyName)) {\r\n            int priority = fullName.startsWith(familyName) ? fullName.length() - familyName.length() : fullName.length();\r\n            triplets.add(new FontTriplet(familyName, style, weight, priority));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellAlignment.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.Body.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGroupLevel.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTScenarios.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.NumFmt.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionMove.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.XMLUtils.elementIsInSignatureSpace",
	"Comment": "returns true if the element is in xml signature namespace and the localname equals the supplied one.",
	"Method": "boolean elementIsInSignatureSpace(Element element,String localName){\r\n    if (element == null) {\r\n        return false;\r\n    }\r\n    return Constants.SignatureSpecNS.equals(element.getNamespaceURI()) && element.getLocalName().equals(localName);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart.getNameForStyleID",
	"Comment": "given the id of a style known in this part, return the corresponding style name.",
	"Method": "String getNameForStyleID(String id){\r\n    if (styleIdToName == null) {\r\n        refreshNameIdBiMaps();\r\n    }\r\n    return styleIdToName.get(id);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPCDKPI.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtRow.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadataStrings.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getBordersDoNotSurroundFooter",
	"Comment": "gets the value of the bordersdonotsurroundfooter property.",
	"Method": "BooleanDefaultTrue getBordersDoNotSurroundFooter(){\r\n    return bordersDoNotSurroundFooter;\r\n}"
}, {
	"Path": "org.docx4j.math.CTCtrlPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSmartTagRun.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTComments.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTHierarchyUsage.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.XMLWriterBase.doNothing",
	"Comment": "does nothing.this method exists so that we can explicitly say that we should do nothingin certain conditions.",
	"Method": "void doNothing(){\r\n    return;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setDrawingGridHorizontalOrigin",
	"Comment": "sets the value of the drawinggridhorizontalorigin property.",
	"Method": "void setDrawingGridHorizontalOrigin(CTTwipsMeasure value){\r\n    this.drawingGridHorizontalOrigin = value;\r\n}"
}, {
	"Path": "org.eclipse.compare.rangedifferencer.RangeDifference.maxLength",
	"Comment": "returns the maximum number of entities in the left, right, and ancestorsides of this range.",
	"Method": "int maxLength(){\r\n    return Math.max(fRightLength, Math.max(fLeftLength, lAncestorLength));\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFilterColumn.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableColumns.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTrackChangeNumbering.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtDateMappingType.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTIconSet.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.GenieAgentApplicationIntegrationTests.smokeTestCommands",
	"Comment": "test to ensure the agent app can start up using the default configuration and run smoke tests against each ofthe available top level commands.",
	"Method": "void smokeTestCommands(){\r\n    final GenieAgentRunner runner = this.context.getBean(GenieAgentRunner.class);\r\n    runner.run(\"help\");\r\n    Assert.assertThat(runner.getExitCode(), Matchers.is(ExitCode.SUCCESS.getCode()));\r\n    runner.run(\"download\", \"--destinationDirectory\", this.temporaryFolder.newFolder().getAbsolutePath());\r\n    Assert.assertThat(runner.getExitCode(), Matchers.is(ExitCode.SUCCESS.getCode()));\r\n    runner.run(\"exec\", \"--clusterCriterion\", \"TAGS=type:presto\", \"--commandCriterion\", \"TAGS=type:presto\", \"--jobName\", \"Dummy Job\", \"--serverHost\", \"www.genie.com\", \"--serverPort\", \"9090\", \"--interactive\");\r\n    Assert.assertThat(runner.getExitCode(), Matchers.is(ExitCode.EXEC_FAIL.getCode()));\r\n    runner.run(\"heartbeat\", \"--duration\", \"1\", \"--serverHost\", \"www.genie.com\", \"--serverPort\", \"9090\");\r\n    Assert.assertThat(runner.getExitCode(), Matchers.is(ExitCode.SUCCESS.getCode()));\r\n    runner.run(\"info\");\r\n    Assert.assertThat(runner.getExitCode(), Matchers.is(ExitCode.SUCCESS.getCode()));\r\n    runner.run(\"ping\", \"--serverHost\", \"www.genie.com\", \"--serverPort\", \"9090\");\r\n    Assert.assertThat(runner.getExitCode(), Matchers.is(ExitCode.EXEC_FAIL.getCode()));\r\n    runner.run(\"resolve\");\r\n    Assert.assertThat(runner.getExitCode(), Matchers.is(ExitCode.EXEC_FAIL.getCode()));\r\n}"
}, {
	"Path": "org.docx4j.wml.FontSig.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableColumns.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTAttr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w15.CTPresenceInfo.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionComment.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOleItem.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTextField.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblPrChange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.P.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTSSubPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDateTime.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFrameLayout.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ObjectFactory.newInstance",
	"Comment": "create an instance of a class using the specified classloader",
	"Method": "Object newInstance(String className,ClassLoader cl,boolean doFallback){\r\n    try {\r\n        Class providerClass = findProviderClass(className, cl, doFallback);\r\n        Object instance = providerClass.newInstance();\r\n        debugPrintln(\"created new instance of \" + providerClass + \" using ClassLoader: \" + cl);\r\n        return instance;\r\n    } catch (ClassNotFoundException x) {\r\n        throw new ConfigurationError(\"Provider \" + className + \" not found\", x);\r\n    } catch (Exception x) {\r\n        throw new ConfigurationError(\"Provider \" + className + \" could not be instantiated: \" + x, x);\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.schemas.microsoft.com.office.excel_2008_2.main.CTDefinedNameArgumentDescriptions.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.WorkbookPr.isShowBorderUnselectedTables",
	"Comment": "gets the value of the showborderunselectedtables property.",
	"Method": "boolean isShowBorderUnselectedTables(){\r\n    if (showBorderUnselectedTables == null) {\r\n        return true;\r\n    } else {\r\n        return showBorderUnselectedTables;\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSmartTags.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTPageNumber.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.GlossaryDocument.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPageFields.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.property.Property.shouldUseSmallBlocks",
	"Comment": "based on the currently defined size, should this property usesmall blocks?",
	"Method": "boolean shouldUseSmallBlocks(){\r\n    return Property.isSmall(_size.get());\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTControl.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTEqArrPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomWorkbookView.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTDocEvents.getEventDocContentControlOnEnter",
	"Comment": "gets the value of the eventdoccontentcontrolonenter property.",
	"Method": "Object getEventDocContentControlOnEnter(){\r\n    return eventDocContentControlOnEnter;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.BlockListImpl.get",
	"Comment": "unit testing method. gets, without sanity checks or removing.",
	"Method": "ListManagedBlock get(int index){\r\n    return _blocks[index];\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.JavaUtils.getBytesFromStream",
	"Comment": "this method reads all bytes from the given inputstream till eof and returns them as a byte array.",
	"Method": "byte[] getBytesFromStream(InputStream inputStream){\r\n    UnsyncByteArrayOutputStream baos = new UnsyncByteArrayOutputStream();\r\n    try {\r\n        byte[] buf = new byte[4 * 1024];\r\n        int len;\r\n        while ((len = inputStream.read(buf)) > 0) {\r\n            baos.write(buf, 0, len);\r\n        }\r\n        return baos.toByteArray();\r\n    } finally {\r\n        baos.close();\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionHeader.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTString.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFtnEdnRef.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPageMargins.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.transformer.TransformerIdentityImpl.skippedEntity",
	"Comment": "receive notification of a skipped entity.by default, do nothing.application writers may override thismethod in a subclass to take specific actions for eachprocessing instruction, such as setting status variables orinvoking other methods.",
	"Method": "void skippedEntity(String name){\r\n    flushStartDoc();\r\n    m_resultContentHandler.skippedEntity(name);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExtension.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTable.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTBoxPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w15.CTGuid.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.Comments.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.Highlight.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDataBinding.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTrPrChange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTChartsheet.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.packages.OpcPackage.setName",
	"Comment": "allocate a name to this package, for the purposes of docx4jevent,\tand logging.",
	"Method": "void setName(String name){\r\n    this.name = name;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTKinsoku.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMacroName.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.schemas.microsoft.com.office.excel_2008_2.main.CTDefinedNameArgumentDescription.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTupleCache.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTConditionalFormatting.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTNumFmt.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.util.IOUtils.toByteArray",
	"Comment": "reads all the data from the input stream, and returns the bytes read.",
	"Method": "byte[] toByteArray(InputStream stream,byte[] toByteArray,ByteBuffer buffer,int length){\r\n    if (buffer.hasArray() && buffer.arrayOffset() == 0) {\r\n        return buffer.array();\r\n    }\r\n    byte[] data = new byte[length];\r\n    buffer.get(data);\r\n    return data;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.CharInfo.arrayIndex",
	"Comment": "returns the array element holding the bit value for thegiven integer",
	"Method": "int arrayIndex(int i){\r\n    return (i >> SHIFT_PER_WORD);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.Messages.createMsg",
	"Comment": "creates a message from the specified key and replacementarguments, localized to the given locale.",
	"Method": "String createMsg(ListResourceBundle fResourceBundle,String msgKey,Object args){\r\n    String fmsg = null;\r\n    boolean throwex = false;\r\n    String msg = null;\r\n    if (msgKey != null)\r\n        msg = fResourceBundle.getString(msgKey);\r\n    else\r\n        msgKey = \"\";\r\n    if (msg == null) {\r\n        throwex = true;\r\n        try {\r\n            msg = java.text.MessageFormat.format(MsgKey.BAD_MSGKEY, new Object[] { msgKey, m_resourceBundleName });\r\n        } catch (Exception e) {\r\n            msg = \"The message key '\" + msgKey + \"' is not in the message class '\" + m_resourceBundleName + \"'\";\r\n        }\r\n    } else if (args != null) {\r\n        try {\r\n            int n = args.length;\r\n            for (int i = 0; i < n; i++) {\r\n                if (null == args[i])\r\n                    args[i] = \"\";\r\n            }\r\n            fmsg = java.text.MessageFormat.format(msg, args);\r\n        } catch (Exception e) {\r\n            throwex = true;\r\n            try {\r\n                fmsg = java.text.MessageFormat.format(MsgKey.BAD_MSGFORMAT, new Object[] { msgKey, m_resourceBundleName });\r\n                fmsg += \" \" + msg;\r\n            } catch (Exception formatfailed) {\r\n                fmsg = \"The format of message '\" + msgKey + \"' in message class '\" + m_resourceBundleName + \"' failed.\";\r\n            }\r\n        }\r\n    } else\r\n        fmsg = msg;\r\n    if (throwex) {\r\n        throw new RuntimeException(fmsg);\r\n    }\r\n    return fmsg;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDdeValue.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTYAlign.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTError.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTSPrePr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataConsolidate.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.topologi.diffx.load.text.TokenizerByWord.getSpaceEvent",
	"Comment": "returns the space event corresponding to the specified characters.",
	"Method": "TextEvent getSpaceEvent(String space){\r\n    TextEvent e = this.recycling.get(space);\r\n    if (e == null) {\r\n        if (this.whitespace == WhiteSpaceProcessing.PRESERVE) {\r\n            e = new IgnorableSpaceEvent(space);\r\n        } else {\r\n            e = SpaceEvent.getInstance(space);\r\n        }\r\n        this.recycling.put(space, e);\r\n    }\r\n    return e;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotField.setDefaultAttributeDrillState",
	"Comment": "sets the value of the defaultattributedrillstate property.",
	"Method": "void setDefaultAttributeDrillState(Boolean value){\r\n    this.defaultAttributeDrillState = value;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.BATBlock.getSBATBlockAndIndex",
	"Comment": "returns the batblock that handles the specified offset, and the relative index within it, for the mini stream.the list of batblocks must be in sequential order",
	"Method": "BATBlockAndIndex getSBATBlockAndIndex(int offset,HeaderBlock header,List<BATBlock> sbats){\r\n    POIFSBigBlockSize bigBlockSize = header.getBigBlockSize();\r\n    int whichSBAT = (int) Math.floor(offset / bigBlockSize.getBATEntriesPerBlock());\r\n    int index = offset % bigBlockSize.getBATEntriesPerBlock();\r\n    return new BATBlockAndIndex(index, sbats.get(whichSBAT));\r\n}"
}, {
	"Path": "org.docx4j.math.CTGroupChrPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.BATBlock.calculateXBATStorageRequirements",
	"Comment": "calculate how many xbatblocks are needed to hold a specifiednumber of bat entries.",
	"Method": "int calculateXBATStorageRequirements(POIFSBigBlockSize bigBlockSize,int entryCount){\r\n    int _entries_per_xbat_block = bigBlockSize.getXBATEntriesPerBlock();\r\n    return (entryCount + _entries_per_xbat_block - 1) / _entries_per_xbat_block;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTCamera.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDdeLink.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMdxMetadata.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.CharInfo.bit",
	"Comment": "for a given integer in the set it returns the single bitvalue used within a given word that represents whetherthe integer is in the set or not.",
	"Method": "int bit(int i){\r\n    int ret = (1 << (i & LOW_ORDER_BITMASK));\r\n    return ret;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTVolTypes.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTFType.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomChartsheetViews.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCalcPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMRUColors.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.OPOIFSDocument.getShortDescription",
	"Comment": "provides a short description of the object, to be used when a\tpoifsviewable object has not provided its contents.",
	"Method": "String getShortDescription(){\r\n    StringBuffer buffer = new StringBuffer();\r\n    buffer.append(\"Document: \\\"\").append(_property.getName()).append(\"\\\"\");\r\n    buffer.append(\" size = \").append(getSize());\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "org.docx4j.math.CTSpacingRule.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.spreadsheetDrawing.CTClientData.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToStream.setNewLine",
	"Comment": "sets the end of line characters to be used during serialization",
	"Method": "void setNewLine(char[] eolChars){\r\n    m_lineSep = eolChars;\r\n    m_lineSepLen = eolChars.length;\r\n}"
}, {
	"Path": "org.docx4j.model.fields.DateFormatInferencer.determineDateFormat",
	"Comment": "determine simpledateformat pattern matching with the given date string. returns null if\tformat is unknown. you can simply extend dateutil with more formats if needed.",
	"Method": "String determineDateFormat(String dateString){\r\n    for (String regexp : DATE_FORMAT_REGEXPS.keySet()) {\r\n        if (dateString.toLowerCase().matches(regexp)) {\r\n            return DATE_FORMAT_REGEXPS.get(regexp);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPageSetUpPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.autodetect.FontFileFinder.getFileFilter",
	"Comment": "font file filter.currently searches for files with .ttf, .ttc, .otf, and .pfb extensions.",
	"Method": "IOFileFilter getFileFilter(){\r\n    return FileFilterUtils.andFileFilter(FileFilterUtils.fileFileFilter(), new WildcardFileFilter(new String[] { \"*.ttf\", \"*.otf\", \"*.pfb\", \"*.ttc\" }, IOCase.INSENSITIVE));\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.templates.OutputProperties.clone",
	"Comment": "clone this outputproperties, including a clone of the wrapped propertiesreference.",
	"Method": "Object clone(){\r\n    try {\r\n        OutputProperties cloned = (OutputProperties) super.clone();\r\n        cloned.m_properties = (Properties) cloned.m_properties.clone();\r\n        return cloned;\r\n    } catch (CloneNotSupportedException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.ParaRPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getRemovePersonalInformation",
	"Comment": "gets the value of the removepersonalinformation property.",
	"Method": "BooleanDefaultTrue getRemovePersonalInformation(){\r\n    return removePersonalInformation;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCacheSource.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTLimUpp.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToXMLStream.pushNamespace",
	"Comment": "from xsltcdeclare a prefix to point to a namespace uri. inform sax handlerif this is a new prefix mapping.",
	"Method": "boolean pushNamespace(String prefix,String uri){\r\n    try {\r\n        if (m_prefixMap.pushNamespace(prefix, uri, m_elemContext.m_currentElemDepth)) {\r\n            startPrefixMapping(prefix, uri);\r\n            return true;\r\n        }\r\n    } catch (SAXException e) {\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTBoolean.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableMissing.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTVerticalJc.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.nustaq.serialization.minbin.MBOut.writeRaw",
	"Comment": "allow write through to underlying byte for performance reasons",
	"Method": "void writeRaw(byte[] bufferedName,int i,int length){\r\n    if (pos + length >= bytez.length - 1) {\r\n        resize();\r\n    }\r\n    System.arraycopy(bufferedName, i, bytez, pos, length);\r\n    pos += length;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTColors.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFutureMetadataBlock.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCalcChain.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCharacterSpacing.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableFormula.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.TTFFile.readKerning",
	"Comment": "read the kerning table, create a table for both cids andwinansiencoding.",
	"Method": "void readKerning(FontFileReader in){\r\n    kerningTab = new java.util.HashMap();\r\n    ansiKerningTab = new java.util.HashMap();\r\n    TTFDirTabEntry dirTab = (TTFDirTabEntry) dirTabs.get(\"kern\");\r\n    if (dirTab != null) {\r\n        seekTab(in, \"kern\", 2);\r\n        for (int n = in.readTTFUShort(); n > 0; n--) {\r\n            in.skip(2 * 2);\r\n            int k = in.readTTFUShort();\r\n            if (!((k & 1) != 0) || (k & 2) != 0 || (k & 4) != 0) {\r\n                return;\r\n            }\r\n            if ((k >> 8) != 0) {\r\n                continue;\r\n            }\r\n            k = in.readTTFUShort();\r\n            in.skip(3 * 2);\r\n            while (k-- > 0) {\r\n                int i = in.readTTFUShort();\r\n                int j = in.readTTFUShort();\r\n                int kpx = in.readTTFShort();\r\n                if (kpx != 0) {\r\n                    final Integer iObj = glyphToUnicode(i);\r\n                    final Integer u2 = glyphToUnicode(j);\r\n                    if (iObj == null) {\r\n                        log.debug(\"Ignoring kerning pair because no Unicode index was\" + \" found for the first glyph \" + i);\r\n                    } else if (u2 == null) {\r\n                        log.debug(\"Ignoring kerning pair because Unicode index was\" + \" found for the second glyph \" + i);\r\n                    } else {\r\n                        Map adjTab = (Map) kerningTab.get(iObj);\r\n                        if (adjTab == null) {\r\n                            adjTab = new java.util.HashMap();\r\n                        }\r\n                        adjTab.put(u2, new Integer((int) convertTTFUnit2PDFUnit(kpx)));\r\n                        kerningTab.put(iObj, adjTab);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        Iterator ae = kerningTab.keySet().iterator();\r\n        while (ae.hasNext()) {\r\n            Integer unicodeKey1 = (Integer) ae.next();\r\n            Integer cidKey1 = unicodeToGlyph(unicodeKey1.intValue());\r\n            Map akpx = new java.util.HashMap();\r\n            Map ckpx = (Map) kerningTab.get(unicodeKey1);\r\n            Iterator aee = ckpx.keySet().iterator();\r\n            while (aee.hasNext()) {\r\n                Integer unicodeKey2 = (Integer) aee.next();\r\n                Integer cidKey2 = unicodeToGlyph(unicodeKey2.intValue());\r\n                Integer kern = (Integer) ckpx.get(unicodeKey2);\r\n                Iterator uniMap = mtxTab[cidKey2.intValue()].getUnicodeIndex().listIterator();\r\n                while (uniMap.hasNext()) {\r\n                    Integer unicodeKey = (Integer) uniMap.next();\r\n                    Integer[] ansiKeys = unicodeToWinAnsi(unicodeKey.intValue());\r\n                    for (int u = 0; u < ansiKeys.length; u++) {\r\n                        akpx.put(ansiKeys[u], kern);\r\n                    }\r\n                }\r\n            }\r\n            if (akpx.size() > 0) {\r\n                Iterator uniMap = mtxTab[cidKey1.intValue()].getUnicodeIndex().listIterator();\r\n                while (uniMap.hasNext()) {\r\n                    Integer unicodeKey = (Integer) uniMap.next();\r\n                    Integer[] ansiKeys = unicodeToWinAnsi(unicodeKey.intValue());\r\n                    for (int u = 0; u < ansiKeys.length; u++) {\r\n                        ansiKerningTab.put(ansiKeys[u], akpx);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDeletedField.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTShadow.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMdxSet.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTStyleSet.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTPerm.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotHierarchies.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.packages.ProtectionSettings.getSignatureHelper",
	"Comment": "get the signaturehelper object, so you can sign the package using custom settings.",
	"Method": "Object getSignatureHelper(){\r\n    try {\r\n        Class<?> signingClass = Class.forName(\"com.plutext.dsig.SignatureHelper\");\r\n        Constructor<?> ctor = signingClass.getConstructor(OpcPackage.class);\r\n        return ctor.newInstance(this.pkg);\r\n    } catch (Exception e) {\r\n        log.warn(\"Docx4j Enterprise jar v3.3 or greater not found. Required for Digital Signatures.\");\r\n        throw new Docx4JException(\"missing Enterprise version required for Digital Signature functionality\");\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.math.CTSSubSup.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Row.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.taobao.android.dexposed.XposedHelpers.assetAsByteArray",
	"Comment": "load an asset from a resource and return the content as byte array.",
	"Method": "byte[] assetAsByteArray(Resources res,String path){\r\n    InputStream is = res.getAssets().open(path);\r\n    ByteArrayOutputStream buf = new ByteArrayOutputStream();\r\n    byte[] temp = new byte[1024];\r\n    int read;\r\n    while ((read = is.read(temp)) > 0) {\r\n        buf.write(temp, 0, read);\r\n    }\r\n    is.close();\r\n    return buf.toByteArray();\r\n}"
}, {
	"Path": "org.docx4j.math.CTSSub.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.taobao.android.dexposed.XposedHelpers.callStaticMethod",
	"Comment": "call static method methodname for class clazz with the arguments\targs. the types for the arguments will be taken from parametertypes.\tthis array can have items that are null. in this case, the type for this parameter\tis determined from args.",
	"Method": "Object callStaticMethod(Class<?> clazz,String methodName,Object args,Object callStaticMethod,Class<?> clazz,String methodName,Class<?>[] parameterTypes,Object args){\r\n    try {\r\n        return findMethodBestMatch(clazz, methodName, parameterTypes, args).invoke(null, args);\r\n    } catch (IllegalAccessException e) {\r\n        DexposedBridge.log(e);\r\n        throw new IllegalAccessError(e.getMessage());\r\n    } catch (IllegalArgumentException e) {\r\n        throw e;\r\n    } catch (InvocationTargetException e) {\r\n        throw new InvocationTargetError(e.getCause());\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.math.CTM.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.BoolStack.peekOrTrue",
	"Comment": "looks at the object at the top of this stack without removing itfrom the stack.if the stack is empty, it returns true.",
	"Method": "boolean peekOrTrue(){\r\n    return (m_index > -1) ? m_values[m_index] : true;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTPolyLine.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.LSSerializerImpl.isHexDigit",
	"Comment": "returns true if the given character is a valid hex character.",
	"Method": "boolean isHexDigit(char c){\r\n    return (c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F');\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setDoNotUseIndentAsNumberingTabStop",
	"Comment": "sets the value of the donotuseindentasnumberingtabstop property.",
	"Method": "void setDoNotUseIndentAsNumberingTabStop(BooleanDefaultTrue value){\r\n    this.doNotUseIndentAsNumberingTabStop = value;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTLock.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellSmartTagPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTConnection.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.eclipse.compare.rangedifferencer.DifferencesIterator.next",
	"Comment": "appends the edit to its list and moves to the next rangedifference.",
	"Method": "void next(){\r\n    fRange.add(fDifference);\r\n    if (fDifference != null) {\r\n        if (fIndex < fArray.length)\r\n            fDifference = fArray[fIndex++];\r\n        else\r\n            fDifference = null;\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOleObject.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGroupMembers.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtCell.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCaptions.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataValidations.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.property.Property.getViewableIterator",
	"Comment": "get an iterator of objects, some of which may implementpoifsviewable",
	"Method": "Iterator<Object> getViewableIterator(){\r\n    return Collections.emptyList().iterator();\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSaveThroughXslt.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTrackChangeRange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.crypto.WeakTrustManagerDetector.isEmptyImplementation",
	"Comment": "currently the detection is pretty weak.it will catch dummy implementation that have empty method implementation",
	"Method": "boolean isEmptyImplementation(MethodGen methodGen){\r\n    boolean invokeInst = false;\r\n    boolean loadField = false;\r\n    for (Iterator itIns = methodGen.getInstructionList().iterator(); itIns.hasNext(); ) {\r\n        Instruction inst = ((InstructionHandle) itIns.next()).getInstruction();\r\n        if (DEBUG)\r\n            System.out.println(inst.toString(true));\r\n        if (inst instanceof InvokeInstruction) {\r\n            invokeInst = true;\r\n        }\r\n        if (inst instanceof GETFIELD) {\r\n            loadField = true;\r\n        }\r\n    }\r\n    return !invokeInst && !loadField;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDdeLink.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.schemas.microsoft.com.office.excel_2008_2.main.CTDefinedNames.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.netflix.genie.GenieAgentApplication.main",
	"Comment": "main method, actual execution is delegated to genieagentrunner.",
	"Method": "void main(String[] args){\r\n    System.err.println(\"Starting Genie Agent\");\r\n    System.exit(new GenieAgentApplication().run(args));\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setUseSingleBorderforContiguousCells",
	"Comment": "sets the value of the usesingleborderforcontiguouscells property.",
	"Method": "void setUseSingleBorderforContiguousCells(BooleanDefaultTrue value){\r\n    this.useSingleBorderforContiguousCells = value;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.DocumentOutputStream.flush",
	"Comment": "flushes this output stream and forces any buffered output bytesto be written out.",
	"Method": "void flush(){\r\n    _stream.flush();\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTextboxTightWrap.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Dialogsheet.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTQueryTableDeletedFields.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSMiniStore.getFreeBlock",
	"Comment": "finds a free block, and returns its offset.this method will extend the file if needed, and if doing so, allocate new fat blocks to address the extra space.",
	"Method": "int getFreeBlock(){\r\n    int sectorsPerSBAT = _filesystem.getBigBlockSizeDetails().getBATEntriesPerBlock();\r\n    int offset = 0;\r\n    for (int i = 0; i < _sbat_blocks.size(); i++) {\r\n        BATBlock sbat = _sbat_blocks.get(i);\r\n        if (sbat.hasFreeSectors()) {\r\n            for (int j = 0; j < sectorsPerSBAT; j++) {\r\n                int sbatValue = sbat.getValueAt(j);\r\n                if (sbatValue == POIFSConstants.UNUSED_BLOCK) {\r\n                    return offset + j;\r\n                }\r\n            }\r\n        }\r\n        offset += sectorsPerSBAT;\r\n    }\r\n    BATBlock newSBAT = BATBlock.createEmptyBATBlock(_filesystem.getBigBlockSizeDetails(), false);\r\n    int batForSBAT = _filesystem.getFreeBlock();\r\n    newSBAT.setOurBlockIndex(batForSBAT);\r\n    if (_header.getSBATCount() == 0) {\r\n        _header.setSBATStart(batForSBAT);\r\n        _header.setSBATBlockCount(1);\r\n    } else {\r\n        ChainLoopDetector loopDetector = _filesystem.getChainLoopDetector();\r\n        int batOffset = _header.getSBATStart();\r\n        while (true) {\r\n            loopDetector.claim(batOffset);\r\n            int nextBat = _filesystem.getNextBlock(batOffset);\r\n            if (nextBat == POIFSConstants.END_OF_CHAIN) {\r\n                break;\r\n            }\r\n            batOffset = nextBat;\r\n        }\r\n        _filesystem.setNextBlock(batOffset, batForSBAT);\r\n        _header.setSBATBlockCount(_header.getSBATCount() + 1);\r\n    }\r\n    _filesystem.setNextBlock(batForSBAT, POIFSConstants.END_OF_CHAIN);\r\n    _sbat_blocks.add(newSBAT);\r\n    return offset;\r\n}"
}, {
	"Path": "org.docx4j.convert.out.FOSettings.setFoDumpFile",
	"Comment": "for testing and debugging you can pass here a file object. the intermediate fo document \twill be outputted here. the outputted fo may contain placeholder for the 2 pass conversion.",
	"Method": "void setFoDumpFile(File foFile){\r\n    settings.put(FO_DUMP_FILE, foFile);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDivs.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTHierarchyUsage.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTEqArr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTSchemeColor.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setDoNotUseHTMLParagraphAutoSpacing",
	"Comment": "sets the value of the donotusehtmlparagraphautospacing property.",
	"Method": "void setDoNotUseHTMLParagraphAutoSpacing(BooleanDefaultTrue value){\r\n    this.doNotUseHTMLParagraphAutoSpacing = value;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTRuby.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.SdtBlock.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Worksheet.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.SdtRun.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.FontSetup.addConfiguredFonts",
	"Comment": "add fonts from configuration file starting with internal name f.",
	"Method": "void addConfiguredFonts(FontInfo fontInfo,List embedFontInfoList,int num,FontResolver resolver){\r\n    if (embedFontInfoList == null) {\r\n        return;\r\n    }\r\n    if (resolver == null) {\r\n        resolver = createMinimalFontResolver();\r\n    }\r\n    String internalName = null;\r\n    for (int i = 0; i < embedFontInfoList.size(); i++) {\r\n        EmbedFontInfo embedFontInfo = (EmbedFontInfo) embedFontInfoList.get(i);\r\n        internalName = \"F\" + num;\r\n        num++;\r\n        LazyFont font = new LazyFont(embedFontInfo, resolver);\r\n        fontInfo.addMetrics(internalName, font);\r\n        List triplets = embedFontInfo.getFontTriplets();\r\n        for (int tripletIndex = 0; tripletIndex < triplets.size(); tripletIndex++) {\r\n            FontTriplet triplet = (FontTriplet) triplets.get(tripletIndex);\r\n            fontInfo.addFontProperties(internalName, triplet);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ObjectFactory.findClassLoader",
	"Comment": "figure out which classloader to use.for jdk 1.2 and later usethe context classloader.",
	"Method": "ClassLoader findClassLoader(){\r\n    ClassLoader context = SecuritySupport.getContextClassLoader();\r\n    ClassLoader system = SecuritySupport.getSystemClassLoader();\r\n    ClassLoader chain = system;\r\n    while (true) {\r\n        if (context == chain) {\r\n            ClassLoader current = ObjectFactory.class.getClassLoader();\r\n            chain = system;\r\n            while (true) {\r\n                if (current == chain) {\r\n                    return system;\r\n                }\r\n                if (chain == null) {\r\n                    break;\r\n                }\r\n                chain = SecuritySupport.getParentClassLoader(chain);\r\n            }\r\n            return current;\r\n        }\r\n        if (chain == null) {\r\n            break;\r\n        }\r\n        chain = SecuritySupport.getParentClassLoader(chain);\r\n    }\r\n    ;\r\n    return context;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTFill.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.ElementProxy.setDocument",
	"Comment": "set a new value for the wrapped document that this object is a proxy for.",
	"Method": "void setDocument(Document doc){\r\n    wrappedDoc = doc;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocProtect.setCryptProviderTypeExtSource",
	"Comment": "sets the value of the cryptprovidertypeextsource property.",
	"Method": "void setCryptProviderTypeExtSource(String value){\r\n    this.cryptProviderTypeExtSource = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalSheetDataSet.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTPageNumber.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.dom.DOMWriterImpl.deNude",
	"Comment": "writes the angle bracket if the element open tag is not finished.",
	"Method": "void deNude(){\r\n    if (this.isNude) {\r\n        if (this.indent) {\r\n            newLine();\r\n        }\r\n        this.isNude = false;\r\n    }\r\n}"
}, {
	"Path": "com.topologi.diffx.util.CommandLine.hasSwitch",
	"Comment": "return true if the specified switch exists in the arguments.this method will go through every argument to check whether the switch existsor not.returns false if any of the parameters is null.",
	"Method": "boolean hasSwitch(String name,String[] args){\r\n    if (args == null || name == null)\r\n        return false;\r\n    for (String arg : args) {\r\n        if (name.equals(arg))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.property.Property.preferArray",
	"Comment": "give viewers a hint as to whether to call getviewablearray orgetviewableiterator",
	"Method": "boolean preferArray(){\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.compare.rangedifferencer.RangeDifferencer.createRangeDifference3",
	"Comment": "creates a rangedifference3 given the state of twodifferenceiterators.",
	"Method": "RangeDifference createRangeDifference3(DifferencesIterator myIter,DifferencesIterator yourIter,List diff3,IRangeComparator right,IRangeComparator left,int changeRangeStart,int changeRangeEnd){\r\n    int rightStart, rightEnd;\r\n    int leftStart, leftEnd;\r\n    int kind = RangeDifference.ERROR;\r\n    RangeDifference last = (RangeDifference) diff3.get(diff3.size() - 1);\r\n    if (myIter.getCount() == 0) {\r\n        rightStart = changeRangeStart - last.ancestorEnd() + last.rightEnd();\r\n        rightEnd = changeRangeEnd - last.ancestorEnd() + last.rightEnd();\r\n        kind = RangeDifference.LEFT;\r\n    } else {\r\n        RangeDifference f = (RangeDifference) myIter.fRange.get(0);\r\n        RangeDifference l = (RangeDifference) myIter.fRange.get(myIter.fRange.size() - 1);\r\n        rightStart = changeRangeStart - f.fLeftStart + f.fRightStart;\r\n        rightEnd = changeRangeEnd - l.leftEnd() + l.rightEnd();\r\n    }\r\n    if (yourIter.getCount() == 0) {\r\n        leftStart = changeRangeStart - last.ancestorEnd() + last.leftEnd();\r\n        leftEnd = changeRangeEnd - last.ancestorEnd() + last.leftEnd();\r\n        kind = RangeDifference.RIGHT;\r\n    } else {\r\n        RangeDifference f = (RangeDifference) yourIter.fRange.get(0);\r\n        RangeDifference l = (RangeDifference) yourIter.fRange.get(yourIter.fRange.size() - 1);\r\n        leftStart = changeRangeStart - f.fLeftStart + f.fRightStart;\r\n        leftEnd = changeRangeEnd - l.leftEnd() + l.rightEnd();\r\n    }\r\n    if (kind == RangeDifference.ERROR) {\r\n        if (rangeSpansEqual(right, rightStart, rightEnd - rightStart, left, leftStart, leftEnd - leftStart))\r\n            kind = RangeDifference.ANCESTOR;\r\n        else\r\n            kind = RangeDifference.CONFLICT;\r\n    }\r\n    return new RangeDifference(kind, rightStart, rightEnd - rightStart, leftStart, leftEnd - leftStart, changeRangeStart, changeRangeEnd - changeRangeStart);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotArea.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotAreaReferences.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.TcPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.Pict.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.convert.out.FOSettings.setCustomFoRenderer",
	"Comment": "if the rendering should be done with a different fo renderer, then you need to \tpass here your custom implementation of the forenderer interface.",
	"Method": "void setCustomFoRenderer(FORenderer customFoRenderer){\r\n    settings.put(CUSTOM_FO_RENDERER, customFoRenderer);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRecord.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotTableStyle.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.DataInputBlock.readLongLE",
	"Comment": "reads a long which spans the end of prevblock and the start of this block.",
	"Method": "long readLongLE(long readLongLE,DataInputBlock prevBlock,int prevBlockAvailable){\r\n    byte[] buf = new byte[8];\r\n    readSpanning(prevBlock, prevBlockAvailable, buf);\r\n    int b0 = buf[0] & 0xFF;\r\n    int b1 = buf[1] & 0xFF;\r\n    int b2 = buf[2] & 0xFF;\r\n    int b3 = buf[3] & 0xFF;\r\n    int b4 = buf[4] & 0xFF;\r\n    int b5 = buf[5] & 0xFF;\r\n    int b6 = buf[6] & 0xFF;\r\n    int b7 = buf[7] & 0xFF;\r\n    return (((long) b7 << 56) + ((long) b6 << 48) + ((long) b5 << 40) + ((long) b4 << 32) + ((long) b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));\r\n}"
}, {
	"Path": "testcode.script.ScriptEngineSample.scriptingSafe",
	"Comment": "the potential injection will require manual review of the code flow but some false positive can be avoid.",
	"Method": "void scriptingSafe(){\r\n    ScriptEngineManager scriptEngineManager = new ScriptEngineManager();\r\n    ScriptEngine scriptEngine = scriptEngineManager.getEngineByExtension(\"js\");\r\n    String code = \"var test=3;test=test*2;\";\r\n    Object result = scriptEngine.eval(code);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTAuthors.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTBarPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPartName.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.templates.OutputProperties.getQNameProperty",
	"Comment": "searches for the qname property with the specified key in the property list.if the key is not found in this property list, the default property list,and its defaults, recursively, are then checked. the method returnsnull if the property is not found.",
	"Method": "QName getQNameProperty(QName key,QName getQNameProperty,String key,QName getQNameProperty,String key,Properties props){\r\n    String s = props.getProperty(key);\r\n    if (null != s)\r\n        return QName.getQNameFromString(s);\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.DOMLocatorImpl.getUri",
	"Comment": "the uri where the error occured, or null if there is no uri available.",
	"Method": "String getUri(){\r\n    return fUri;\r\n}"
}, {
	"Path": "org.docx4j.wml.Color.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.WorkbookPr.setShowBorderUnselectedTables",
	"Comment": "sets the value of the showborderunselectedtables property.",
	"Method": "void setShowBorderUnselectedTables(Boolean value){\r\n    this.showBorderUnselectedTables = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellSmartTagPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.CustomFont.getLastChar",
	"Comment": "returns the index of the last character defined in this font.",
	"Method": "int getLastChar(){\r\n    return lastChar;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCnf.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDdeItem.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.graph.GraphBuilder.createNode",
	"Comment": "this function is creating a node if does not exist already.it use an map to keep track of previously loaded node rather communicating with neo4j.",
	"Method": "Node createNode(Label lbl,String properties){\r\n    Map<String, Node> cache = graphDb.getNodesCache();\r\n    Map<String, String> props = build(properties);\r\n    String name = props.get(\"name\");\r\n    Node node = cache.get(name);\r\n    if (node == null) {\r\n        node = graphDb.getDb().createNode(lbl);\r\n        for (Map.Entry<String, String> prop : props.entrySet()) {\r\n            node.setProperty(prop.getKey(), prop.getValue());\r\n        }\r\n        cache.put(name, node);\r\n    }\r\n    return node;\r\n}"
}, {
	"Path": "org.docx4j.math.CTLimLow.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTLineNumber.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMembers.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTAutoCaption.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.Id.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTColumns.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.BlockAllocationTableReader.fetchBlocks",
	"Comment": "walk the entries from a specified point and return theassociated blocks. the associated blocks are removed from theblock list",
	"Method": "ListManagedBlock[] fetchBlocks(int startBlock,int headerPropertiesStartBlock,BlockList blockList){\r\n    List<ListManagedBlock> blocks = new ArrayList<ListManagedBlock>();\r\n    int currentBlock = startBlock;\r\n    boolean firstPass = true;\r\n    ListManagedBlock dataBlock = null;\r\n    while (currentBlock != POIFSConstants.END_OF_CHAIN) {\r\n        try {\r\n            dataBlock = blockList.remove(currentBlock);\r\n            blocks.add(dataBlock);\r\n            currentBlock = _entries.get(currentBlock);\r\n            firstPass = false;\r\n        } catch (IOException e) {\r\n            if (currentBlock == headerPropertiesStartBlock) {\r\n                _logger.warn(\"Warning, header block comes after data blocks in POIFS block listing\");\r\n                currentBlock = POIFSConstants.END_OF_CHAIN;\r\n            } else if (currentBlock == 0 && firstPass) {\r\n                _logger.warn(\"Warning, incorrectly terminated empty data blocks in POIFS block listing (should end at -2, ended at 0)\");\r\n                currentBlock = POIFSConstants.END_OF_CHAIN;\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    return blocks.toArray(new ListManagedBlock[blocks.size()]);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFrameScrollbar.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTReflection.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSmartTagRun.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.model.CellUtils.getNumberFormatString",
	"Comment": "get the contents of the format string, by looking up\t the stylessource",
	"Method": "String getNumberFormatString(Cell _cell){\r\n    long idx = getNumberFormatIndex(_cell);\r\n    return getFormat((int) idx);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCommentPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTColorMenu.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSmartTagType.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTObject.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTShape.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getAutofitToFirstFixedWidthCell",
	"Comment": "gets the value of the autofittofirstfixedwidthcell property.",
	"Method": "BooleanDefaultTrue getAutofitToFirstFixedWidthCell(){\r\n    return autofitToFirstFixedWidthCell;\r\n}"
}, {
	"Path": "org.docx4j.model.listnumbering.ListNumberingDefinition.GetCurrentNumberString",
	"Comment": "returns a string containing the current state of the counters, up to the indicated level",
	"Method": "String GetCurrentNumberString(String level){\r\n    ListLevel controllingLvl = this.levels.get(level);\r\n    boolean isLegal = level.equals(\"1\") && controllingLvl.getJaxbAbstractLvl().getIsLgl() != null && controllingLvl.getJaxbAbstractLvl().getIsLgl().isVal();\r\n    String formatString = controllingLvl.getLevelText();\r\n    log.debug(\"levelText: \" + formatString);\r\n    StringBuilder result = new StringBuilder();\r\n    String temp = \"\";\r\n    for (int i = 0; i < formatString.length(); i++) {\r\n        temp = formatString.substring(i, i + 1);\r\n        if (temp.equals(\"%\")) {\r\n            if (i < formatString.length() - 1) {\r\n                String formatStringLevel = formatString.substring(i + 1, i + 2);\r\n                int levelId = Integer.parseInt(formatStringLevel) - 1;\r\n                ListLevel lvl = this.levels.get(Integer.toString(levelId));\r\n                if (levelId == 0 && isLegal) {\r\n                    result.append(lvl.getCurrentValueUnformatted());\r\n                } else {\r\n                    result.append(lvl.getCurrentValueFormatted());\r\n                }\r\n                i++;\r\n            }\r\n        } else {\r\n            result.append(temp);\r\n        }\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.SimpleSingleByteEncoding.getCharacterForIndex",
	"Comment": "returns the named character at a given code point in the encoding.",
	"Method": "NamedCharacter getCharacterForIndex(int codePoint){\r\n    if (codePoint < 0 || codePoint > 255) {\r\n        throw new IllegalArgumentException(\"codePoint must be between 0 and 255\");\r\n    }\r\n    if (codePoint <= getLastChar()) {\r\n        return (NamedCharacter) this.mapping.get(codePoint - 1);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFramePr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Cell.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableStyles.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTMR.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getDoNotIncludeSubdocsInStats",
	"Comment": "gets the value of the donotincludesubdocsinstats property.",
	"Method": "BooleanDefaultTrue getDoNotIncludeSubdocsInStats(){\r\n    return doNotIncludeSubdocsInStats;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMdx.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTXmlCellPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCalculatedItems.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions.getCipher",
	"Comment": "initialize a new cipher object with the given cipher propertiesif the given algorithm is not implemented in the jce, it will try to load it from the bouncy castleprovider.",
	"Method": "Cipher getCipher(SecretKey key,CipherAlgorithm cipherAlgorithm,ChainingMode chain,byte[] vec,int cipherMode,Cipher getCipher,Key key,CipherAlgorithm cipherAlgorithm,ChainingMode chain,byte[] vec,int cipherMode,String padding){\r\n    int keySizeInBytes = key.getEncoded().length;\r\n    if (padding == null)\r\n        padding = \"NoPadding\";\r\n    try {\r\n        if (Cipher.getMaxAllowedKeyLength(cipherAlgorithm.jceId) < keySizeInBytes * 8) {\r\n            throw new EncryptedDocumentException(\"Export Restrictions in place - please install JCE Unlimited Strength Jurisdiction Policy files\");\r\n        }\r\n        Cipher cipher;\r\n        if (cipherAlgorithm == CipherAlgorithm.rc4) {\r\n            cipher = Cipher.getInstance(cipherAlgorithm.jceId);\r\n        } else if (cipherAlgorithm.needsBouncyCastle) {\r\n            registerBouncyCastle();\r\n            cipher = Cipher.getInstance(cipherAlgorithm.jceId + \"/\" + chain.jceId + \"/\" + padding, \"BC\");\r\n        } else {\r\n            cipher = Cipher.getInstance(cipherAlgorithm.jceId + \"/\" + chain.jceId + \"/\" + padding);\r\n        }\r\n        if (vec == null) {\r\n            cipher.init(cipherMode, key);\r\n        } else {\r\n            AlgorithmParameterSpec aps;\r\n            if (cipherAlgorithm == CipherAlgorithm.rc2) {\r\n                aps = new RC2ParameterSpec(key.getEncoded().length * 8, vec);\r\n            } else {\r\n                aps = new IvParameterSpec(vec);\r\n            }\r\n            cipher.init(cipherMode, key, aps);\r\n        }\r\n        return cipher;\r\n    } catch (GeneralSecurityException e) {\r\n        throw new EncryptedDocumentException(e);\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDateGroupItem.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionConflict.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTEm.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.schemas.microsoft.com.office.excel_2008_2.main.CTDefinedName.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToSAXHandler.setTransformState",
	"Comment": "pass in a reference to a transformstate object, whichcan be used during sax contenthandler events to obtaininformation about he state of the transformation. thismethod will be calledbefore each startdocument event.",
	"Method": "void setTransformState(org.apache.xml.serializer.TransformStateSetter ts){\r\n    this.m_state = ts;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.BaseConfigValidation.validateClass",
	"Comment": "validate if the class name exists.it is expecting that api will be in the classpath. the class are either part of the dependencies or in mostcases the stubs",
	"Method": "void validateClass(String className,String origfileName){\r\n    if (classesDeprecatedInJava8.contains(className))\r\n        return;\r\n    if (classesDeprecatedInJava9.contains(className))\r\n        return;\r\n    if (className.endsWith(\"$\"))\r\n        return;\r\n    if (className.startsWith(\"play.\"))\r\n        return;\r\n    if (className.startsWith(\"anorm\"))\r\n        return;\r\n    if (className.startsWith(\"slick\"))\r\n        return;\r\n    if (className.contains(\".log\"))\r\n        return;\r\n    if (className.contains(\".Log\"))\r\n        return;\r\n    if (className.equals(\"javax.naming.directory.Context\"))\r\n        return;\r\n    try {\r\n        Class.forName(className);\r\n    } catch (ClassNotFoundException e) {\r\n        String classNotFound = String.format(\"[!] Class not found %s (%s)\", className, origfileName);\r\n        fail(\"Configurations were added for a class that does not exist. It is likely a typographical error or because the API was not tested. \" + classNotFound);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTControl.getId",
	"Comment": "embedded control properties relationship\t\t\t\t\treference",
	"Method": "String getId(){\r\n    return id;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionComment.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTFuncPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTBar.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToStream.unparsedEntityDecl",
	"Comment": "if this method is called, the serializer is used as adtdhandler, which changes behavior how the serializer handles document entities.",
	"Method": "void unparsedEntityDecl(String name,String pubID,String sysID,String notationName){\r\n    try {\r\n        DTDprolog();\r\n        m_writer.write(\"<!ENTITY \");\r\n        m_writer.write(name);\r\n        if (pubID != null) {\r\n            m_writer.write(\" PUBLIC \\\"\");\r\n            m_writer.write(pubID);\r\n        } else {\r\n            m_writer.write(\" SYSTEM \\\"\");\r\n            m_writer.write(sysID);\r\n        }\r\n        m_writer.write(\"\\\" NDATA \");\r\n        m_writer.write(notationName);\r\n        m_writer.write(\" >\");\r\n        m_writer.write(m_lineSep, 0, m_lineSepLen);\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtListItem.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotField.isDefaultAttributeDrillState",
	"Comment": "gets the value of the defaultattributedrillstate property.",
	"Method": "boolean isDefaultAttributeDrillState(){\r\n    if (defaultAttributeDrillState == null) {\r\n        return false;\r\n    } else {\r\n        return defaultAttributeDrillState;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.math.CTSSubSupPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.dml.CTBlip.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.contenttype.ContentTypeManager.removeOverrideContentType",
	"Comment": "delete an override content type based on the specified part name.",
	"Method": "void removeOverrideContentType(PartName partName){\r\n    if (partName == null)\r\n        throw new IllegalArgumentException(\"partName\");\r\n    if (this.overrideContentType != null && (this.overrideContentType.get(partName.getURI()) != null)) {\r\n        this.overrideContentType.remove(partName.getURI());\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.vml.CTRoundRect.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSets.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.type1.AFMFile.getLastChar",
	"Comment": "returns the last character index in the encoding that has a glyph.",
	"Method": "int getLastChar(){\r\n    return this.lastChar;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTRules.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTextPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.nustaq.offheap.structs.unsafeimpl.FSTStructFactory.getStructPointer",
	"Comment": "returns a struct wrapper for given structured object from the thread local wrapper cache.",
	"Method": "FSTStruct getStructPointer(Bytez b,long index){\r\n    return getStructPointerByOffset(b, index);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTReviewed.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTLock.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.model.fields.merge.MailMerger.removeSimpleField",
	"Comment": "remove the field but preserve the paragraph and content around it",
	"Method": "void removeSimpleField(FieldRef fr){\r\n    int end = fr.getParent().getContent().indexOf(fr.getEndRun());\r\n    int begin = fr.getParent().getContent().indexOf(fr.getBeginRun());\r\n    for (int i = end; i >= begin; i--) {\r\n        fr.getParent().getContent().remove(i);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.DOM3SerializerImpl.setErrorHandler",
	"Comment": "sets a domerrorhandler on the dom level 3 serializer.this interface is a public api.",
	"Method": "void setErrorHandler(DOMErrorHandler handler){\r\n    fErrorHandler = handler;\r\n}"
}, {
	"Path": "org.nustaq.serialization.FSTObjectOutput.objectWillBeWritten",
	"Comment": "hook for debugging profiling. register a fstserialisationlistener to use",
	"Method": "void objectWillBeWritten(Object obj,int streamPosition){\r\n    if (listener != null) {\r\n        listener.objectWillBeWritten(obj, streamPosition);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPart.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCalculatedItem.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellSmartTag.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.model.datastorage.BindingHyperlinkResolver.getIndexOfURL",
	"Comment": "return the index of the position you wish to treat as a hyperlink.\tthe characters from there to the first whitespace following will be treated as \tthe url",
	"Method": "int getIndexOfURL(String text){\r\n    log.debug(\"processing \" + text);\r\n    int NOT_FOUND = 99999;\r\n    int pos1 = text.indexOf(\"http://\") == -1 ? NOT_FOUND : text.indexOf(\"http://\");\r\n    int pos2 = text.indexOf(\"https://\") == -1 ? NOT_FOUND : text.indexOf(\"https://\");\r\n    int pos3 = text.indexOf(\"mailto:\") == -1 ? NOT_FOUND : text.indexOf(\"mailto:\");\r\n    int pos = Math.min(pos1, Math.min(pos2, pos3));\r\n    if (pos == NOT_FOUND)\r\n        return -1;\r\n    return pos;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFontScheme.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomSheetViews.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSignedHpsMeasure.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTGradientStop.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTInputCells.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTColor.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTLimLow.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.webextension_2010_11.CTOsfWebExtension.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocProtect.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTReflection.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.model.datastorage.BindingHandler.setValueInserterPlainText",
	"Comment": "allow user to customise what is inserted into the document when the\tbind is performed.",
	"Method": "void setValueInserterPlainText(ValueInserterPlainText valueInserterPlainText){\r\n    BindingHandler.valueInserterPlainText = valueInserterPlainText;\r\n}"
}, {
	"Path": "org.docx4j.vml.wordprocessingDrawing.CTBorder.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFills.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTHeight.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTSPrePr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.model.datastorage.BindingTraverserXSLT.convertFlatOPC",
	"Comment": "convert the flatopc into an altchunk, which xalan \tcan insert into xslt output.",
	"Method": "DocumentFragment convertFlatOPC(WordprocessingMLPackage pkg,JaxbXmlPart sourcePart,Map<String, CustomXmlPart> customXmlDataStorageParts,Map<String, org.opendope.xpaths.Xpaths.Xpath> xpathsMap,String sdtParent,String contentChild,NodeIterator rPrNodeIt,String tag){\r\n    try {\r\n        log.debug(\"convertFlatOPC extension function for: \" + sdtParent + \"/w:sdt/w:sdtContent/\" + contentChild);\r\n        QueryString qs = new QueryString();\r\n        HashMap<String, String> map = qs.parseQueryString(tag, true);\r\n        String xpathId = map.get(OpenDoPEHandler.BINDING_ROLE_XPATH);\r\n        log.info(\"Looking for xpath by id: \" + xpathId);\r\n        Xpath xpath = xpathsMap.get(xpathId);\r\n        if (xpath == null) {\r\n            log.warn(\"Couldn't find xpath with id: \" + xpathId);\r\n            return null;\r\n        }\r\n        String storeItemId = xpath.getDataBinding().getStoreItemID();\r\n        String xpathExp = xpath.getDataBinding().getXpath();\r\n        String prefixMappings = xpath.getDataBinding().getPrefixMappings();\r\n        String r = BindingHandler.xpathGetString(pkg, customXmlDataStorageParts, storeItemId, xpathExp, prefixMappings);\r\n        if (r == null)\r\n            return nullResultParagraph(sdtParent, \"[missing!]\");\r\n        if (!r.startsWith(\"<?xml\")) {\r\n            r = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" standalone=\\\"yes\\\"?>\\n\" + r;\r\n        }\r\n        AlternativeFormatInputPart afiPart = new AlternativeFormatInputPart(getNewPartName(\"/chunk\", \".xml\", sourcePart.getRelationshipsPart()));\r\n        afiPart.setBinaryData(r.getBytes(\"UTF-8\"));\r\n        afiPart.setAltChunkType(AltChunkType.Xml);\r\n        Relationship altChunkRel = sourcePart.addTargetPart(afiPart);\r\n        afiPart.registerInContentTypeManager();\r\n        CTAltChunk ac = Context.getWmlObjectFactory().createCTAltChunk();\r\n        ac.setId(altChunkRel.getId());\r\n        org.w3c.dom.Document docContainer = XmlUtils.marshaltoW3CDomDocument(ac);\r\n        DocumentFragment docfrag = docContainer.createDocumentFragment();\r\n        docfrag.appendChild(docContainer.getDocumentElement());\r\n        return docfrag;\r\n    } catch (Exception e) {\r\n        log.error(e.getMessage(), e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.templates.OutputProperties.getProperty",
	"Comment": "searches for the property with the specified key in the property list.if the key is not found in this property list, the default property list,and its defaults, recursively, are then checked. the method returnsnull if the property is not found.",
	"Method": "String getProperty(QName key,String getProperty,String key){\r\n    if (key.startsWith(OutputPropertiesFactory.S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL))\r\n        key = OutputPropertiesFactory.S_BUILTIN_EXTENSIONS_UNIVERSAL + key.substring(OutputPropertiesFactory.S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL_LEN);\r\n    return m_properties.getProperty(key);\r\n}"
}, {
	"Path": "org.docx4j.wml.Tbl.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "me.weishu.epic.art.method.ArtMethod.ensureResolved",
	"Comment": "the static method is lazy resolved, when not resolved, the entry point is a trampoline ofa bridge, we can not hook these entry. this method force the static method to be resolved.",
	"Method": "void ensureResolved(){\r\n    if (!Modifier.isStatic(getModifiers())) {\r\n        Logger.d(TAG, \"not static, ignore.\");\r\n        return;\r\n    }\r\n    try {\r\n        invoke(null);\r\n        Logger.d(TAG, \"ensure resolved\");\r\n    } catch (Exception ignored) {\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.BlockListImpl.fetchBlocks",
	"Comment": "get the blocks making up a particular stream in the list. theblocks are removed from the list.",
	"Method": "ListManagedBlock[] fetchBlocks(int startBlock,int headerPropertiesStartBlock){\r\n    if (_bat == null) {\r\n        throw new IOException(\"Improperly initialized list: no block allocation table provided\");\r\n    }\r\n    return _bat.fetchBlocks(startBlock, headerPropertiesStartBlock, this);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.FontInfo.dumpAllTripletsToSystemOut",
	"Comment": "diagnostic method for logging all registered fonts to system.out.",
	"Method": "void dumpAllTripletsToSystemOut(){\r\n    System.out.print(toString());\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPageField.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTControls.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTLineJoinMiterProperties.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.JaxbXmlPart.unmarshal",
	"Comment": "unmarshal xml data from the specified inputstream and return the\tresulting content tree. validation event location information may be\tincomplete when using this form of the unmarshal api.\timplements unmarshal global root element.",
	"Method": "E unmarshal(java.io.InputStream is,E unmarshal,org.w3c.dom.Element el){\r\n    try {\r\n        Unmarshaller u = jc.createUnmarshaller();\r\n        JaxbValidationEventHandler eventHandler = new JaxbValidationEventHandler();\r\n        eventHandler.setContinue(false);\r\n        u.setEventHandler(eventHandler);\r\n        Unmarshaller.Listener docx4jUnmarshallerListener = new Docx4jUnmarshallerListener(this);\r\n        u.setListener(docx4jUnmarshallerListener);\r\n        try {\r\n            jaxbElement = (E) XmlUtils.unwrap(u.unmarshal(el));\r\n        } catch (UnmarshalException ue) {\r\n            log.info(\"encountered unexpected content; pre-processing\");\r\n            try {\r\n                org.w3c.dom.Document doc;\r\n                if (el instanceof org.w3c.dom.Document) {\r\n                    doc = (org.w3c.dom.Document) el;\r\n                } else {\r\n                    doc = el.getOwnerDocument();\r\n                }\r\n                eventHandler.setContinue(true);\r\n                JAXBResult result = XmlUtils.prepareJAXBResult(jc);\r\n                Templates mcPreprocessorXslt = JaxbValidationEventHandler.getMcPreprocessor();\r\n                XmlUtils.transform(doc, mcPreprocessorXslt, null, result);\r\n                jaxbElement = (E) XmlUtils.unwrap(result.getResult());\r\n            } catch (Exception e) {\r\n                throw new JAXBException(\"Preprocessing exception\", e);\r\n            }\r\n        }\r\n        return jaxbElement;\r\n    } catch (JAXBException e) {\r\n        log.error(e.getMessage(), e);\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPartPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTNumFmt.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionInsertSheet.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setPrintFractionalCharacterWidth",
	"Comment": "sets the value of the printfractionalcharacterwidth property.",
	"Method": "void setPrintFractionalCharacterWidth(BooleanDefaultTrue value){\r\n    this.printFractionalCharacterWidth = value;\r\n}"
}, {
	"Path": "org.docx4j.math.CTMCPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.samples.CompareDocuments.handleRels",
	"Comment": "in the general case, you need to handle relationships.\t\t although not necessary in this simple example, \t\t we do it anyway for the purposes of illustration.",
	"Method": "void handleRels(Differencer pd,MainDocumentPart newMDP){\r\n    RelationshipsPart rp = newMDP.getRelationshipsPart();\r\n    System.out.println(\"before: \\n\" + rp.getXML());\r\n    List<Relationship> relsToRemove = new ArrayList<Relationship>();\r\n    for (Relationship r : rp.getRelationships().getRelationship()) {\r\n        if (r.getType().equals(Namespaces.IMAGE)) {\r\n            relsToRemove.add(r);\r\n        }\r\n    }\r\n    for (Relationship r : relsToRemove) {\r\n        rp.removeRelationship(r);\r\n    }\r\n    Map<Relationship, Part> newRels = pd.getComposedRels();\r\n    for (Relationship nr : newRels.keySet()) {\r\n        if (nr.getTargetMode() != null && nr.getTargetMode().equals(\"External\")) {\r\n            newMDP.getRelationshipsPart().getRelationships().getRelationship().add(nr);\r\n        } else {\r\n            Part part = newRels.get(nr);\r\n            if (part == null) {\r\n                System.out.println(\"ERROR! Couldn't find part for rel \" + nr.getId() + \"  \" + nr.getTargetMode());\r\n            } else {\r\n                if (part instanceof BinaryPart) {\r\n                    ((BinaryPart) part).getBuffer();\r\n                }\r\n                newMDP.addTargetPart(part, AddPartBehaviour.RENAME_IF_NAME_EXISTS, nr.getId());\r\n            }\r\n        }\r\n    }\r\n    System.out.println(\"after: \\n\" + rp.getXML());\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.property.Property.getStorageClsid",
	"Comment": "sets the storage clsid, which is the class id of a com object whichreads and writes this stream",
	"Method": "ClassID getStorageClsid(){\r\n    return _storage_clsid;\r\n}"
}, {
	"Path": "org.docx4j.math.CTD.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTNumFmts.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPageSetUpPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPartTypes.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTImageData.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.templates.OutputProperties.getQNameProperties",
	"Comment": "searches for the list of qname properties with the specified key inthe property list.if the key is not found in this property list, the default property list,and its defaults, recursively, are then checked. the method returnsnull if the property is not found.",
	"Method": "Vector getQNameProperties(QName key,Vector getQNameProperties,String key,Vector getQNameProperties,String key,Properties props){\r\n    String s = props.getProperty(key);\r\n    if (null != s) {\r\n        Vector v = new Vector();\r\n        int l = s.length();\r\n        boolean inCurly = false;\r\n        FastStringBuffer buf = new FastStringBuffer();\r\n        for (int i = 0; i < l; i++) {\r\n            char c = s.charAt(i);\r\n            if (Character.isWhitespace(c)) {\r\n                if (!inCurly) {\r\n                    if (buf.length() > 0) {\r\n                        QName qname = QName.getQNameFromString(buf.toString());\r\n                        v.addElement(qname);\r\n                        buf.reset();\r\n                    }\r\n                    continue;\r\n                }\r\n            } else if ('{' == c)\r\n                inCurly = true;\r\n            else if ('}' == c)\r\n                inCurly = false;\r\n            buf.append(c);\r\n        }\r\n        if (buf.length() > 0) {\r\n            QName qname = QName.getQNameFromString(buf.toString());\r\n            v.addElement(qname);\r\n            buf.reset();\r\n        }\r\n        return v;\r\n    } else\r\n        return null;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPCDKPI.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parentObj;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTClipPath.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerBase.fireStartElem",
	"Comment": "report the start element trace event. this trace method needs to becalled just before the attributes are cleared.",
	"Method": "void fireStartElem(String elemName){\r\n    if (m_tracer != null) {\r\n        flushMyWriter();\r\n        m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_STARTELEMENT, elemName, m_attributes);\r\n    }\r\n}"
}, {
	"Path": "testcasesupport.AbstractTestCaseServlet.runTest",
	"Comment": "this method runs the tests, but assumes that the html document has alreadybeen started.it is called by runtestsolo and by servletmain",
	"Method": "void runTest(HttpServletRequest request,HttpServletResponse response){\r\n    String className = this.getClass().getName();\r\n    int lastDotInClassName = className.lastIndexOf('.');\r\n    String servletName = className.substring(lastDotInClassName + 1);\r\n    response.getWriter().println(\"<br><br>Starting tests for Servlet \" + servletName);\r\n    try {\r\n        good(request, response);\r\n        response.getWriter().println(\"<br>Completed good() without Throwable for Servlet \" + servletName);\r\n    } catch (Throwable throwableException) {\r\n        response.getWriter().println(\"<br>Caught thowable from good() in Servlet \" + servletName);\r\n        response.getWriter().println(\"<br>Throwable's message = \" + throwableException.getMessage());\r\n        response.getWriter().println(\"<br><br>Stack trace below\");\r\n        StackTraceElement[] stackTraceElements = throwableException.getStackTrace();\r\n        for (StackTraceElement stackTraceElement : stackTraceElements) {\r\n            response.getWriter().println(\"<br>\" + stackTraceElement.toString());\r\n        }\r\n    }\r\n    try {\r\n        bad(request, response);\r\n        response.getWriter().println(\"<br>Completed bad() without Throwable in Servlet \" + servletName);\r\n    } catch (Throwable throwableException) {\r\n        response.getWriter().println(\"<br>Caught thowable from bad() in Servlet \" + servletName);\r\n        response.getWriter().println(\"<br>Throwable's message = \" + throwableException.getMessage());\r\n        response.getWriter().println(\"<br><br>Stack trace below\");\r\n        StackTraceElement[] stackTraceElements = throwableException.getStackTrace();\r\n        for (StackTraceElement stackTraceElement : stackTraceElements) {\r\n            response.getWriter().println(\"<br>\" + stackTraceElement.toString());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMeasureGroups.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFonts.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisions.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTBookView.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions.hashPassword",
	"Comment": "generalized method for read and write protection hash generation.the difference is, read protection uses the order iterator then hash in the hash loop, whereas write protectionuses first the last hash value and then the current iterator value",
	"Method": "byte[] hashPassword(String password,HashAlgorithm hashAlgorithm,byte salt,int spinCount,byte[] hashPassword,String password,HashAlgorithm hashAlgorithm,byte salt,int spinCount,boolean iteratorFirst){\r\n    if (password == null) {\r\n        password = Decryptor.DEFAULT_PASSWORD;\r\n    }\r\n    MessageDigest hashAlg = getMessageDigest(hashAlgorithm);\r\n    hashAlg.update(salt);\r\n    byte[] hash = hashAlg.digest(StringUtil.getToUnicodeLE(password));\r\n    byte[] iterator = new byte[LittleEndianConsts.INT_SIZE];\r\n    byte[] first = (iteratorFirst ? iterator : hash);\r\n    byte[] second = (iteratorFirst ? hash : iterator);\r\n    try {\r\n        for (int i = 0; i < spinCount; i++) {\r\n            LittleEndian.putInt(iterator, 0, i);\r\n            hashAlg.reset();\r\n            hashAlg.update(first);\r\n            hashAlg.update(second);\r\n            hashAlg.digest(hash, 0, hash.length);\r\n        }\r\n    } catch (DigestException e) {\r\n        throw new EncryptedDocumentException(\"error in password hashing\");\r\n    }\r\n    return hash;\r\n}"
}, {
	"Path": "org.docx4j.math.CTOMathParaPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableFormula.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerBase.getEncoding",
	"Comment": "returns the character encoding to be used in the output document.",
	"Method": "String getEncoding(){\r\n    return getOutputProperty(OutputKeys.ENCODING);\r\n}"
}, {
	"Path": "org.docx4j.vml.root.Xml.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerBase.getOutputProperty",
	"Comment": "get the value of an output property,the explicit value, if any, otherwise thedefault value, if any, otherwise null.",
	"Method": "String getOutputProperty(String name){\r\n    String val = getOutputPropertyNonDefault(name);\r\n    if (val == null)\r\n        val = getOutputPropertyDefault(name);\r\n    return val;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFFTextInput.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadataTypes.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTuple.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionAutoFormatting.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.BooleanDefaultTrue.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.FontCache.getFontInfos",
	"Comment": "returns the embedfontinfo instances belonging to a font file. if the font file wasmodified since it was cached the entry is removed and null is returned.",
	"Method": "EmbedFontInfo[] getFontInfos(String embedUrl,long lastModified){\r\n    CachedFontFile cff = getFontFile(embedUrl);\r\n    if (cff.lastModified() == lastModified) {\r\n        return cff.getEmbedFontInfos();\r\n    } else {\r\n        removeFont(embedUrl);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTRPrDefault.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.org.apache.poi.ss.format.SimpleFraction.buildFractionMaxDenominator",
	"Comment": "create a fraction given the double value and either the maximum errorallowed or the maximum number of denominator digits.",
	"Method": "SimpleFraction buildFractionMaxDenominator(double value,int maxDenominator,SimpleFraction buildFractionMaxDenominator,double value,double epsilon,int maxDenominator,int maxIterations){\r\n    long overflow = Integer.MAX_VALUE;\r\n    double r0 = value;\r\n    long a0 = (long) Math.floor(r0);\r\n    if (a0 > overflow) {\r\n        throw new IllegalArgumentException(\"Overflow trying to convert \" + value + \" to fraction (\" + a0 + \"/\" + 1l + \")\");\r\n    }\r\n    if (Math.abs(a0 - value) < epsilon) {\r\n        return new SimpleFraction((int) a0, 1);\r\n    }\r\n    long p0 = 1;\r\n    long q0 = 0;\r\n    long p1 = a0;\r\n    long q1 = 1;\r\n    long p2;\r\n    long q2;\r\n    int n = 0;\r\n    boolean stop = false;\r\n    do {\r\n        ++n;\r\n        double r1 = 1.0 / (r0 - a0);\r\n        long a1 = (long) Math.floor(r1);\r\n        p2 = (a1 * p1) + p0;\r\n        q2 = (a1 * q1) + q0;\r\n        if (epsilon == 0.0f && maxDenominator > 0 && Math.abs(q2) > maxDenominator && Math.abs(q1) < maxDenominator) {\r\n            return new SimpleFraction((int) p1, (int) q1);\r\n        }\r\n        if ((p2 > overflow) || (q2 > overflow)) {\r\n            throw new RuntimeException(\"Overflow trying to convert \" + value + \" to fraction (\" + p2 + \"/\" + q2 + \")\");\r\n        }\r\n        double convergent = (double) p2 / (double) q2;\r\n        if (n < maxIterations && Math.abs(convergent - value) > epsilon && q2 < maxDenominator) {\r\n            p0 = p1;\r\n            p1 = p2;\r\n            q0 = q1;\r\n            q1 = q2;\r\n            a0 = a1;\r\n            r0 = r1;\r\n        } else {\r\n            stop = true;\r\n        }\r\n    } while (!stop);\r\n    if (n >= maxIterations) {\r\n        throw new RuntimeException(\"Unable to convert \" + value + \" to fraction after \" + maxIterations + \" iterations\");\r\n    }\r\n    if (q2 < maxDenominator) {\r\n        return new SimpleFraction((int) p2, (int) q2);\r\n    } else {\r\n        return new SimpleFraction((int) p1, (int) q1);\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotDimension.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCustomXmlCell.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTLanguage.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTLongHexNumber.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTNumSpacing.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.FldChar.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.password.CTPasswordKeyEncryptor.getEncryptedVerifierHashValue",
	"Comment": "gets the value of the encryptedverifierhashvalue property.",
	"Method": "byte[] getEncryptedVerifierHashValue(){\r\n    return encryptedVerifierHashValue;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMapInfo.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDiscretePr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTrPrBase.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTXmlPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTRecipients.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTop10.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTObjectPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.type1.AFMFile.getCharMetrics",
	"Comment": "returns the list of afmcharmetrics instances representing all the available characters.",
	"Method": "List getCharMetrics(){\r\n    return Collections.unmodifiableList(this.charMetrics);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTChartsheetView.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToUnknownStream.setDoctypeSystem",
	"Comment": "set the doctype in the underlying xml handler. remember that this methodwas called, just in case we need to transfer this doctype to an html handler",
	"Method": "void setDoctypeSystem(String doctype){\r\n    m_handler.setDoctypeSystem(doctype);\r\n    m_setDoctypeSystem_called = true;\r\n}"
}, {
	"Path": "org.docx4j.wml.TextDirection.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.TblPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.apache.ws.commons.serialize.DOMSerializer.setStartingDocument",
	"Comment": "sets, whether startdocument and\tenddocument events are generated for\tdocument nodes.",
	"Method": "void setStartingDocument(boolean pStartingDocument){\r\n    startingDocument = pStartingDocument;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.LSSerializerImpl.setFilter",
	"Comment": "set a lsserilizerfilter on the lsserializer.when set, the filter iscalled before each node is serialized which depending on its implementiondetermines if the node is to be serialized or not.",
	"Method": "void setFilter(LSSerializerFilter filter){\r\n    fSerializerFilter = filter;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRangePr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetPr.setEnableFormatConditionsCalculation",
	"Comment": "sets the value of the enableformatconditionscalculation property.",
	"Method": "void setEnableFormatConditionsCalculation(Boolean value){\r\n    this.enableFormatConditionsCalculation = value;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTAttr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetBackgroundPicture.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTShape.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.autodetect.FontFileFinder.getDirectoryFilter",
	"Comment": "font directory filter.currently ignores hidden directories.",
	"Method": "IOFileFilter getDirectoryFilter(){\r\n    return FileFilterUtils.andFileFilter(FileFilterUtils.directoryFileFilter(), FileFilterUtils.notFileFilter(FileFilterUtils.prefixFileFilter(\".\")));\r\n}"
}, {
	"Path": "org.docx4j.XmlUtils.trimNamespaces",
	"Comment": "removes superflouous namespaces.\tit makes things neater, at the cost of some extra processing.",
	"Method": "byte[] trimNamespaces(org.w3c.dom.Document doc,String ignorables){\r\n    log.debug(\"Input to Canonicalizer: \" + XmlUtils.w3CDomNodeToString(doc));\r\n    Init.init();\r\n    Canonicalizer c = Canonicalizer.getInstance(CanonicalizationMethod.EXCLUSIVE);\r\n    return c.canonicalizeSubtree(doc, ignorables);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWorkbookProtection.setWorkbookPasswordCharacterSet",
	"Comment": "sets the value of the workbookpasswordcharacterset property.",
	"Method": "void setWorkbookPasswordCharacterSet(String value){\r\n    this.workbookPasswordCharacterSet = value;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTPositivePercentage.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSortState.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMdxMemeberProp.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMemberProperties.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.DelText.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalCell.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetBackgroundPicture.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getUseSingleBorderforContiguousCells",
	"Comment": "gets the value of the usesingleborderforcontiguouscells property.",
	"Method": "BooleanDefaultTrue getUseSingleBorderforContiguousCells(){\r\n    return useSingleBorderforContiguousCells;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataConsolidate.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTables.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.TaintFrameModelingVisitor.finishAnalysis",
	"Comment": "this method must be called from outside at the end of the method analysis",
	"Method": "void finishAnalysis(){\r\n    assert analyzedMethodConfig != null;\r\n    Taint outputTaint = analyzedMethodConfig.getOutputTaint();\r\n    if (outputTaint == null) {\r\n        return;\r\n    }\r\n    String returnType = getReturnType(methodDescriptor.getSignature());\r\n    if (taintConfig.isClassTaintSafe(returnType) && outputTaint.getState() != Taint.State.NULL) {\r\n        return;\r\n    }\r\n    String realInstanceClassName = outputTaint.getRealInstanceClassName();\r\n    if (returnType.equals(\"L\" + realInstanceClassName + \";\")) {\r\n        outputTaint.setRealInstanceClass(null);\r\n        analyzedMethodConfig.setOuputTaint(outputTaint);\r\n    }\r\n    String className = methodDescriptor.getSlashedClassName();\r\n    String methodId = \".\" + methodDescriptor.getName() + methodDescriptor.getSignature();\r\n    if (analyzedMethodConfig.isInformative() || taintConfig.getSuperMethodConfig(className, methodId) != null) {\r\n        String fullMethodName = className.concat(methodId);\r\n        if (!taintConfig.containsKey(fullMethodName)) {\r\n            taintConfig.put(fullMethodName, analyzedMethodConfig);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableStyleElement.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.Part.rename",
	"Comment": "rename this part.useful when merging documents, if you need to \ttake action to avoid name collisions.",
	"Method": "void rename(PartName newName){\r\n    log.info(\"Renaming part \" + this.getPartName().getName() + \" to \" + newName.getName());\r\n    this.getPackage().getParts().remove(this.getPartName());\r\n    URI tobeRelativized = newName.getURI();\r\n    URI relativizeAgainst = this.getOwningRelationshipPart().getSourceURI();\r\n    log.debug(\"Relativising target \" + tobeRelativized + \" against source \" + relativizeAgainst);\r\n    String result = org.docx4j.openpackaging.URIHelper.relativizeURI(relativizeAgainst, tobeRelativized).toString();\r\n    if (relativizeAgainst.getPath().equals(\"/\") && result.startsWith(\"/\")) {\r\n        result = result.substring(1);\r\n    }\r\n    log.debug(\"Result \" + result);\r\n    for (Relationship rel : sourceRelationships) {\r\n        rel.setTarget(result);\r\n    }\r\n    this.setPartName(newName);\r\n    this.getPackage().getParts().put(this);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.relationships.RelationshipsPart.differingContent",
	"Comment": "identify rels common to both parts, but where rels have differentcontent.",
	"Method": "List<Relationship> differingContent(RelationshipsPart otherRP){\r\n    List<Relationship> results = new ArrayList<Relationship>();\r\n    for (Relationship r : jaxbElement.getRelationship()) {\r\n        Relationship otherR = getRelationshipByTarget(otherRP, r.getTarget());\r\n        if (otherR != null) {\r\n            if (r.getTargetMode() != null && r.getTargetMode().equals(\"External\")) {\r\n                if (otherR.getTargetMode() != null && otherR.getTargetMode().equals(\"External\")) {\r\n                    if (!r.getTarget().equals(otherR.getTarget())) {\r\n                        throw new Docx4JException(\"broken logic!\");\r\n                    }\r\n                } else {\r\n                    results.add(r);\r\n                    log.debug(\"External: \" + r.getTarget());\r\n                }\r\n                continue;\r\n            }\r\n            Part thisPart = this.getPart(r);\r\n            Part otherPart = otherRP.getPart(otherR);\r\n            if (!thisPart.isContentEqual(otherPart)) {\r\n                results.add(r);\r\n                log.debug(\"Different: \" + r.getTarget());\r\n            }\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.docx4j.math.CTOMathArgPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.CIDSubset.setupFirstThreeGlyphs",
	"Comment": "adds the initial 3 glyphs which are the same for all cid subsets.",
	"Method": "void setupFirstThreeGlyphs(){\r\n    usedGlyphs.put(new Integer(0), new Integer(0));\r\n    usedGlyphsIndex.put(new Integer(0), new Integer(0));\r\n    usedGlyphsCount++;\r\n    usedGlyphs.put(new Integer(1), new Integer(1));\r\n    usedGlyphsIndex.put(new Integer(1), new Integer(1));\r\n    usedGlyphsCount++;\r\n    usedGlyphs.put(new Integer(2), new Integer(2));\r\n    usedGlyphsIndex.put(new Integer(2), new Integer(2));\r\n    usedGlyphsCount++;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setSuppressSpacingAtTopOfPage",
	"Comment": "sets the value of the suppressspacingattopofpage property.",
	"Method": "void setSuppressSpacingAtTopOfPage(BooleanDefaultTrue value){\r\n    this.suppressSpacingAtTopOfPage = value;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMailMergeOdsoFMDFieldType.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.RPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTuples.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTabStop.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRowFields.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTSchemeColor.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.ProofErr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPageFields.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.c14n.implementations.Canonicalizer11.engineCanonicalizeSubTree",
	"Comment": "always throws a canonicalizationexception because this is inclusive c14n.",
	"Method": "byte[] engineCanonicalizeSubTree(Node rootNode,String inclusiveNamespaces,byte[] engineCanonicalizeSubTree,Node rootNode,String inclusiveNamespaces,boolean propagateDefaultNamespace){\r\n    throw new CanonicalizationException(\"c14n.Canonicalizer.UnsupportedOperation\");\r\n}"
}, {
	"Path": "org.nustaq.offheap.structs.structtypes.StructByteString.setString",
	"Comment": "modify content of this structstring. the length of the new string must not exceedthe length of internal char array",
	"Method": "void setString(String s){\r\n    if (s == null) {\r\n        setLen(0);\r\n        return;\r\n    }\r\n    if (s.length() > charsLen()) {\r\n        throw new RuntimeException(\"String length exceeds buffer size. String len \" + s.length() + \" charsLen:\" + charsLen());\r\n    }\r\n    for (int i = 0; i < s.length(); i++) {\r\n        chars(i, (byte) (s.charAt(i) & 0xff));\r\n    }\r\n    len = s.length();\r\n}"
}, {
	"Path": "org.docx4j.convert.out.common.writer.AbstractHyperlinkWriter.getName",
	"Comment": "abstractfldsimplewriter.fldsimplenodewriterhandler",
	"Method": "String getName(){\r\n    return HYPERLINK_NAME;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.transforms.Transform.getURI",
	"Comment": "returns the uri representation of transformation algorithm",
	"Method": "String getURI(){\r\n    return getLocalAttribute(Constants._ATT_ALGORITHM);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataValidation.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.FontRel.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTIgnoredErrors.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.SdtPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.packages.ProtectWorkbook.setSheetProtection",
	"Comment": "enforces the protection passed in sheetprotection, with the specified password, and hashalgorithm for the password.",
	"Method": "void setSheetProtection(CTSheetProtection sheetProtection,String password,HashAlgorithm hashAlgo){\r\n    if (sheetProtection == null)\r\n        throw new Xlsx4jException(\"Passed null sheetProtection object\");\r\n    sheetProtection.setAlgorithmName(null);\r\n    sheetProtection.setSaltValue(null);\r\n    sheetProtection.setSpinCount(null);\r\n    sheetProtection.setHashValue(null);\r\n    sheetProtection.setPassword(null);\r\n    if (hashAlgo == null)\r\n        hashAlgo = HashAlgorithm.sha512;\r\n    if (password == null) {\r\n        return;\r\n    } else if (hashAlgo == HashAlgorithm.none) {\r\n        int hash = CryptoFunctions.createXorVerifier1(password);\r\n        sheetProtection.setPassword(DatatypeConverter.parseHexBinary(Integer.toHexString(hash)));\r\n        return;\r\n    }\r\n    SecureRandom random = new SecureRandom();\r\n    byte[] salt = random.generateSeed(16);\r\n    int spinCount = 100000;\r\n    byte[] hash = CryptoFunctions.hashPassword(password, hashAlgo, salt, spinCount, false);\r\n    if (hashAlgo.jceId.startsWith(\"SHA\")) {\r\n        sheetProtection.setAlgorithmName(hashAlgo.jceId);\r\n    } else {\r\n        sheetProtection.setAlgorithmName(hashAlgo.ecmaString);\r\n    }\r\n    sheetProtection.setSaltValue(salt);\r\n    sheetProtection.setSpinCount((long) spinCount);\r\n    sheetProtection.setHashValue(hash);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTLightRig.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTRoundRect.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.model.fields.merge.MailMerger.extractLang",
	"Comment": "extract language information from run parameters to be able to \tformat month, day, week, etc. in its abbreviated form according to the \tlanguage specified by the lang element on the run containing the field instructions.\talso it will be used to use language specific decimalformatsymbols for number formating",
	"Method": "String extractLang(R resultsSlot){\r\n    RPr rPr = resultsSlot.getRPr();\r\n    if (rPr != null) {\r\n        CTLanguage lang = rPr.getLang();\r\n        if (lang != null) {\r\n            return lang.getVal();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.c14n.implementations.NameSpaceSymbTable.getMappingWithoutRendered",
	"Comment": "gets a definition without mark it as render. for render in exclusive c14n the namespaces in the include prefixes.",
	"Method": "Attr getMappingWithoutRendered(String prefix){\r\n    NameSpaceSymbEntry entry = symb.get(prefix);\r\n    if (entry == null) {\r\n        return null;\r\n    }\r\n    if (entry.rendered) {\r\n        return null;\r\n    }\r\n    return entry.n;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setTruncateFontHeightsLikeWP6",
	"Comment": "sets the value of the truncatefontheightslikewp6 property.",
	"Method": "void setTruncateFontHeightsLikeWP6(BooleanDefaultTrue value){\r\n    this.truncateFontHeightsLikeWP6 = value;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.XMLChar.isValidJavaEncoding",
	"Comment": "returns true if the encoding name is a valid java encoding.this method does not verify that there is a decoder availablefor this encoding, only that the characters are valid for anjava encoding name.",
	"Method": "boolean isValidJavaEncoding(String javaEncoding){\r\n    if (javaEncoding != null) {\r\n        int length = javaEncoding.length();\r\n        if (length > 0) {\r\n            for (int i = 1; i < length; i++) {\r\n                char c = javaEncoding.charAt(i);\r\n                if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') && (c < '0' || c > '9') && c != '.' && c != '_' && c != '-') {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.docx4j.math.CTSSupPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.model.structure.PageDimensions.getFooterMargin",
	"Comment": "get the distance from the bottom edge of the paper to the bottom edge of the footer",
	"Method": "int getFooterMargin(){\r\n    if (pgMar.getFooter() == null) {\r\n        return 720;\r\n    } else {\r\n        return pgMar.getFooter().intValue();\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFill.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMeasureGroup.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.topologi.diffx.sequence.EventSequence.equals",
	"Comment": "returns true if the specified event sequence is the same as this one.",
	"Method": "boolean equals(EventSequence seq,boolean equals,Object o){\r\n    if (!(o instanceof EventSequence))\r\n        return false;\r\n    return this.equals((EventSequence) o);\r\n}"
}, {
	"Path": "org.docx4j.wml.FontPanose.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMapInfo.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTDocEvents.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.dml.wordprocessingDrawing.Inline.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTClipPath.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPageItem.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTHyperlinks.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionDefinedName.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTSdtCheckbox.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.FontSig.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDdeValue.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.util.LittleEndian.getUShort",
	"Comment": "get an unsigned short value from the beginning of a byte array",
	"Method": "int getUShort(byte[] data,int getUShort,byte[] data,int offset){\r\n    int b0 = data[offset] & 0xFF;\r\n    int b1 = data[offset + 1] & 0xFF;\r\n    return (b1 << 8) + (b0 << 0);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRowHierarchiesUsage.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.taobao.android.dexposed.XposedHelpers.callMethod",
	"Comment": "call instance or static method methodname for object obj with the arguments\targs. the types for the arguments will be taken from parametertypes.\tthis array can have items that are null. in this case, the type for this parameter\tis determined from args.",
	"Method": "Object callMethod(Object obj,String methodName,Object args,Object callMethod,Object obj,String methodName,Class<?>[] parameterTypes,Object args){\r\n    try {\r\n        return findMethodBestMatch(obj.getClass(), methodName, parameterTypes, args).invoke(obj, args);\r\n    } catch (IllegalAccessException e) {\r\n        DexposedBridge.log(e);\r\n        throw new IllegalAccessError(e.getMessage());\r\n    } catch (IllegalArgumentException e) {\r\n        throw e;\r\n    } catch (InvocationTargetException e) {\r\n        throw new InvocationTargetError(e.getCause());\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.FooterReference.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionCellChange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMdxTuple.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSingleXmlCell.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCfvo.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.AbstractCodePointMapping.buildFromTable",
	"Comment": "builds the internal lookup structures based on a given table.",
	"Method": "void buildFromTable(int[] table){\r\n    int nonLatin1 = 0;\r\n    latin1Map = new char[256];\r\n    unicodeMap = new char[256];\r\n    Arrays.fill(unicodeMap, CharUtilities.NOT_A_CHARACTER);\r\n    for (int i = 0; i < table.length; i += 2) {\r\n        char unicode = (char) table[i + 1];\r\n        if (unicode < 256) {\r\n            if (latin1Map[unicode] == 0) {\r\n                latin1Map[unicode] = (char) table[i];\r\n            }\r\n        } else {\r\n            ++nonLatin1;\r\n        }\r\n        if (unicodeMap[table[i]] == CharUtilities.NOT_A_CHARACTER) {\r\n            unicodeMap[table[i]] = unicode;\r\n        }\r\n    }\r\n    characters = new char[nonLatin1];\r\n    codepoints = new char[nonLatin1];\r\n    int top = 0;\r\n    for (int i = 0; i < table.length; i += 2) {\r\n        char c = (char) table[i + 1];\r\n        if (c >= 256) {\r\n            ++top;\r\n            for (int j = top - 1; j >= 0; --j) {\r\n                if (j > 0 && characters[j - 1] >= c) {\r\n                    characters[j] = characters[j - 1];\r\n                    codepoints[j] = codepoints[j - 1];\r\n                } else {\r\n                    characters[j] = c;\r\n                    codepoints[j] = (char) table[i];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.LSSerializerImpl.getInputEncoding",
	"Comment": "determines the input encoding of the document node to serialize.if the document nodeis not a dom level 3 node, then null is returned.",
	"Method": "String getInputEncoding(Node nodeArg){\r\n    Document doc = null;\r\n    if (nodeArg != null) {\r\n        if (nodeArg.getNodeType() == Node.DOCUMENT_NODE) {\r\n            doc = (Document) nodeArg;\r\n        } else {\r\n            doc = nodeArg.getOwnerDocument();\r\n        }\r\n        if (doc != null && doc.getImplementation().hasFeature(\"Core\", \"3.0\")) {\r\n            return doc.getInputEncoding();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalSheetName.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetCalcPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataValidations.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCacheFields.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.JaxbXmlPart.getXML",
	"Comment": "see your content as xml.an easy way to invoke xmlutils.marshaltostring",
	"Method": "String getXML(){\r\n    return XmlUtils.marshaltoString(getJaxbElement(), true, true, jc);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFontScheme.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellFormula.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTQuery.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTI.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTQueryTable.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setDrawingGridHorizontalSpacing",
	"Comment": "sets the value of the drawinggridhorizontalspacing property.",
	"Method": "void setDrawingGridHorizontalSpacing(CTTwipsMeasure value){\r\n    this.drawingGridHorizontalSpacing = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTXmlCellPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.hpsf.CustomProperty.equalsContents",
	"Comment": "compares two custom properties for equality. the method returnstrue if all attributes of the two custom properties areequal.",
	"Method": "boolean equalsContents(Object o){\r\n    final CustomProperty c = (CustomProperty) o;\r\n    final String name1 = c.getName();\r\n    final String name2 = this.getName();\r\n    boolean equalNames = true;\r\n    if (name1 == null)\r\n        equalNames = name2 == null;\r\n    else\r\n        equalNames = name1.equals(name2);\r\n    return equalNames && c.getID() == this.getID() && c.getType() == this.getType() && c.getValue().equals(this.getValue());\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetFormatPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSelection.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerBase.setOutputPropertyDefault",
	"Comment": "set the default value for an output property, but this doesnot impact any explicitly set value.",
	"Method": "void setOutputPropertyDefault(String name,String val){\r\n    setProp(name, val, true);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalReference.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Workbook.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.c14n.implementations.Canonicalizer20010315.engineCanonicalizeXPathNodeSet",
	"Comment": "always throws a canonicalizationexception because this is inclusive c14n.",
	"Method": "byte[] engineCanonicalizeXPathNodeSet(Set<Node> xpathNodeSet,String inclusiveNamespaces){\r\n    throw new CanonicalizationException(\"c14n.Canonicalizer.UnsupportedOperation\");\r\n}"
}, {
	"Path": "org.docx4j.w14.CTFillTextEffect.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtRow.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCalendarType.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.FontInfo.useFont",
	"Comment": "tells this class that the font with the given internal name has been used.",
	"Method": "void useFont(String internalName){\r\n    usedFonts.put(internalName, fonts.get(internalName));\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMailMergeSourceType.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellWatch.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSmartTagPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2010.wordprocessingShape.CTLinkedTextboxInformation.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.transformer.TransformerIdentityImpl.endPrefixMapping",
	"Comment": "receive notification of the end of a namespace mapping.by default, do nothing.application writers may override thismethod in a subclass to take specific actions at the end ofeach prefix mapping.",
	"Method": "void endPrefixMapping(String prefix){\r\n    flushStartDoc();\r\n    m_resultContentHandler.endPrefixMapping(prefix);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTDefaultImageDpi.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFunctionGroup.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.transformer.TransformerIdentityImpl.createResultContentHandler",
	"Comment": "create a result contenthandler from a result object, basedon the current outputproperties.",
	"Method": "void createResultContentHandler(Result outputTarget){\r\n    if (outputTarget instanceof SAXResult) {\r\n        SAXResult saxResult = (SAXResult) outputTarget;\r\n        m_resultContentHandler = saxResult.getHandler();\r\n        m_resultLexicalHandler = saxResult.getLexicalHandler();\r\n        if (m_resultContentHandler instanceof Serializer) {\r\n            m_serializer = (Serializer) m_resultContentHandler;\r\n        }\r\n    } else if (outputTarget instanceof DOMResult) {\r\n        DOMResult domResult = (DOMResult) outputTarget;\r\n        Node outputNode = domResult.getNode();\r\n        Node nextSibling = domResult.getNextSibling();\r\n        Document doc;\r\n        short type;\r\n        if (null != outputNode) {\r\n            type = outputNode.getNodeType();\r\n            doc = (Node.DOCUMENT_NODE == type) ? (Document) outputNode : outputNode.getOwnerDocument();\r\n        } else {\r\n            try {\r\n                DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\r\n                dbf.setNamespaceAware(true);\r\n                if (m_isSecureProcessing) {\r\n                    try {\r\n                        dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\r\n                    } catch (ParserConfigurationException pce) {\r\n                    }\r\n                }\r\n                DocumentBuilder db = dbf.newDocumentBuilder();\r\n                doc = db.newDocument();\r\n            } catch (ParserConfigurationException pce) {\r\n                throw new TransformerException(pce);\r\n            }\r\n            outputNode = doc;\r\n            type = outputNode.getNodeType();\r\n            ((DOMResult) outputTarget).setNode(outputNode);\r\n        }\r\n        DOMBuilder domBuilder = (Node.DOCUMENT_FRAGMENT_NODE == type) ? new DOMBuilder(doc, (DocumentFragment) outputNode) : new DOMBuilder(doc, outputNode);\r\n        if (nextSibling != null)\r\n            domBuilder.setNextSibling(nextSibling);\r\n        m_resultContentHandler = domBuilder;\r\n        m_resultLexicalHandler = domBuilder;\r\n    } else if (outputTarget instanceof StreamResult) {\r\n        StreamResult sresult = (StreamResult) outputTarget;\r\n        try {\r\n            Serializer serializer = SerializerFactory.getSerializer(m_outputFormat.getProperties());\r\n            log.debug(serializer.getClass().getName());\r\n            m_serializer = serializer;\r\n            if (null != sresult.getWriter())\r\n                serializer.setWriter(sresult.getWriter());\r\n            else if (null != sresult.getOutputStream())\r\n                serializer.setOutputStream(sresult.getOutputStream());\r\n            else if (null != sresult.getSystemId()) {\r\n                String fileURL = sresult.getSystemId();\r\n                if (fileURL.startsWith(\"file:///\")) {\r\n                    if (fileURL.substring(8).indexOf(\":\") > 0) {\r\n                        fileURL = fileURL.substring(8);\r\n                    } else {\r\n                        fileURL = fileURL.substring(7);\r\n                    }\r\n                } else if (fileURL.startsWith(\"file:/\")) {\r\n                    if (fileURL.substring(6).indexOf(\":\") > 0) {\r\n                        fileURL = fileURL.substring(6);\r\n                    } else {\r\n                        fileURL = fileURL.substring(5);\r\n                    }\r\n                }\r\n                m_outputStream = new java.io.FileOutputStream(fileURL);\r\n                serializer.setOutputStream(m_outputStream);\r\n            } else\r\n                throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_OUTPUT_SPECIFIED, null));\r\n            m_resultContentHandler = serializer.asContentHandler();\r\n        } catch (IOException ioe) {\r\n            throw new TransformerException(ioe);\r\n        }\r\n    } else {\r\n        throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_TRANSFORM_TO_RESULT_TYPE, new Object[] { outputTarget.getClass().getName() }));\r\n    }\r\n    if (m_resultContentHandler instanceof DTDHandler)\r\n        m_resultDTDHandler = (DTDHandler) m_resultContentHandler;\r\n    if (m_resultContentHandler instanceof DeclHandler)\r\n        m_resultDeclHandler = (DeclHandler) m_resultContentHandler;\r\n    if (m_resultContentHandler instanceof LexicalHandler)\r\n        m_resultLexicalHandler = (LexicalHandler) m_resultContentHandler;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTComplex.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setPrintBodyTextBeforeHeader",
	"Comment": "sets the value of the printbodytextbeforeheader property.",
	"Method": "void setPrintBodyTextBeforeHeader(BooleanDefaultTrue value){\r\n    this.printBodyTextBeforeHeader = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Cols.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.ValuedEnum.isGreaterThanOrEqual",
	"Comment": "test if enum item is greater than or equal in value to other enum.",
	"Method": "boolean isGreaterThanOrEqual(ValuedEnum other){\r\n    return m_value >= other.m_value;\r\n}"
}, {
	"Path": "org.docx4j.wml.CommentRangeStart.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2010.wordprocessingShape.CTTextboxInfo.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTControls.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.spreadsheetDrawing.CTClientData.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w15.CTPerson.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTWebSettings.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTChartsheet.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableStyleInfo.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerBase.characters",
	"Comment": "this method gets the nodes value as a string and uses that string as ifit were an input character notification.",
	"Method": "void characters(org.w3c.dom.Node node){\r\n    flushPending();\r\n    String data = node.getNodeValue();\r\n    if (data != null) {\r\n        final int length = data.length();\r\n        if (length > m_charsBuff.length) {\r\n            m_charsBuff = new char[length * 2 + 1];\r\n        }\r\n        data.getChars(0, length, m_charsBuff, 0);\r\n        characters(m_charsBuff, 0, length);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTBookmark.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getDoNotUseIndentAsNumberingTabStop",
	"Comment": "gets the value of the donotuseindentasnumberingtabstop property.",
	"Method": "BooleanDefaultTrue getDoNotUseIndentAsNumberingTabStop(){\r\n    return doNotUseIndentAsNumberingTabStop;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDefinedName.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.presentationDrawing.CTEmpty.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRowItems.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.model.styles.StyleUtil.isEmpty",
	"Comment": "isempty returns true if rpr is null, or each of its\tproperties is in turn, empty",
	"Method": "boolean isEmpty(Style style,boolean isEmpty,PPr pPr,boolean isEmpty,PPrBase pPrBase,boolean isEmpty,RPr rPr,boolean isEmpty,ParaRPr rPr,boolean isEmpty,CTTblPrBase tblPr,boolean isEmpty,TcPr tcPr,boolean isEmpty,List<CTTblStylePr> tblStylePrList,boolean isEmpty,CTTblStylePr ctTblStylePr,boolean isEmpty,OutlineLvl outlineLvl,boolean isEmpty,CTTextboxTightWrap textboxTightWrap,boolean isEmpty,TextAlignment textAlignment,boolean isEmpty,TextDirection textDirection,boolean isEmpty,Jc jc,boolean isEmpty,Ind ind,boolean isEmpty,Spacing spacing,boolean isEmpty,Tabs tabs,boolean isEmpty,CTTabStop ctTabStop,boolean isEmpty,CTShd shd,boolean isEmpty,PBdr pBdr,boolean isEmpty,CTBorder border,boolean isEmpty,NumPr numPr,boolean isEmpty,CTFramePr framePr,boolean isEmpty,CTCnf cnfStyle,boolean isEmpty,PStyle pStyle,boolean isEmpty,RFonts rFonts,boolean isEmpty,STHint stHint,boolean isEmpty,STTheme stTheme,boolean isEmpty,RStyle rStyle,boolean isEmpty,CTEm em,boolean isEmpty,CTVerticalAlignRun vertAlign,boolean isEmpty,CTTextEffect effect,boolean isEmpty,U u,boolean isEmpty,Highlight highlight,boolean isEmpty,CTSignedHpsMeasure measure,boolean isEmpty,HpsMeasure measure,boolean isEmpty,CTTextScale scale,boolean isEmpty,CTSignedTwipsMeasure measure,boolean isEmpty,Color color,boolean isEmpty,CTTblLook tblLook,boolean isEmpty,CTTblLayoutType tblLayout,boolean isEmpty,CTTblCellMar margin,boolean isEmpty,TblBorders borders,boolean isEmpty,TblStyleColBandSize bandSize,boolean isEmpty,TblStyleRowBandSize bandSize,boolean isEmpty,CTTblOverlap overlap,boolean isEmpty,CTTblPPr tblpPr,boolean isEmpty,TblStyle style,boolean isEmpty,CTVerticalJc vAlign,boolean isEmpty,TcMar margin,boolean isEmpty,TcBorders borders,boolean isEmpty,VMerge merge,boolean isEmpty,HMerge merge,boolean isEmpty,GridSpan gridSpan,boolean isEmpty,TrPr trPr,boolean isEmpty,CTHeight height,boolean isEmpty,TblWidth width,boolean isEmpty,CTShortHexNumber number,boolean isEmpty,BooleanDefaultTrue booleanDefaultTrue,boolean isEmpty,Boolean bool,boolean isEmpty,BigInteger val,boolean isEmpty,Integer val,boolean isEmpty,String val,boolean isEmpty,STThemeColor val,boolean isEmpty,SectPr val){\r\n    if (val == null)\r\n        return true;\r\n    log.debug(\"TODO: isEmpty(SectPr) implementation is quite basic\");\r\n    return false;\r\n}"
}, {
	"Path": "org.docx4j.wml.TblWidth.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.Drawing.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTSkew.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.transformer.TransformerIdentityImpl.unparsedEntityDecl",
	"Comment": "receive notification of an unparsed entity declaration.by default, do nothing.application writers may override thismethod in a subclass to keep track of the unparsed entitiesdeclared in a document.",
	"Method": "void unparsedEntityDecl(String name,String publicId,String systemId,String notationName){\r\n    if (null != m_resultDTDHandler)\r\n        m_resultDTDHandler.unparsedEntityDecl(name, publicId, systemId, notationName);\r\n}"
}, {
	"Path": "org.docx4j.math.CTText.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.FontInfo.getFontWeightFor",
	"Comment": "returns the font weight for a particular font.there may be multiple font weights matching this font. only the firstfound is returned. searching is done on a sorted list to guarantee consistentresults.",
	"Method": "int getFontWeightFor(String fontName){\r\n    FontTriplet triplet = getTripletFor(fontName);\r\n    if (triplet != null) {\r\n        return triplet.getWeight();\r\n    } else {\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.substitute.FontWeightRange.valueOf",
	"Comment": "returns an fontweightrange object holding therange values of the specified string.",
	"Method": "FontWeightRange valueOf(String weightRangeString){\r\n    StringTokenizer rangeToken = new StringTokenizer(weightRangeString, \"..\");\r\n    FontWeightRange weightRange = null;\r\n    if (rangeToken.countTokens() == 2) {\r\n        String weightString = rangeToken.nextToken().trim();\r\n        try {\r\n            int start = Integer.parseInt(weightString);\r\n            if (start % 100 != 0) {\r\n                log.error(\"font-weight start range is not a multiple of 100\");\r\n            }\r\n            int end = Integer.parseInt(rangeToken.nextToken());\r\n            if (end % 100 != 0) {\r\n                log.error(\"font-weight end range is not a multiple of 100\");\r\n            }\r\n            if (start <= end) {\r\n                weightRange = new FontWeightRange(start, end);\r\n            } else {\r\n                log.error(\"font-weight start range is greater than end range\");\r\n            }\r\n        } catch (NumberFormatException e) {\r\n            log.error(\"invalid font-weight value \" + weightString);\r\n        }\r\n    }\r\n    return weightRange;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTDocEvents.getEventDocContentControlAfterInsert",
	"Comment": "gets the value of the eventdoccontentcontrolafterinsert property.",
	"Method": "Object getEventDocContentControlAfterInsert(){\r\n    return eventDocContentControlAfterInsert;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGroupItems.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellAlignment.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTLegacyDrawing.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTAutoCaption.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMailMergeOdsoFMDFieldType.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDdeItem.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFileSharing.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTStylisticSets.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.topologi.diffx.sequence.SequenceSlicer.formatEnd",
	"Comment": "formats the end subsequence that has been buffered by this class.this method will clear the buffer, but will do nothing if the end buffer isnull.",
	"Method": "void formatEnd(DiffXFormatter formatter){\r\n    if (this.end == null)\r\n        return;\r\n    for (int i = 0; i < this.end.size(); i++) {\r\n        formatter.format(this.end.getEvent(i));\r\n    }\r\n    this.end = null;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocRsids.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.model.PropertyResolver.getEffectiveRPr",
	"Comment": "apply the rpr in the stack of styles, including documentdefaultrpr",
	"Method": "RPr getEffectiveRPr(RPr expressRPr,PPr pPr,RPr getEffectiveRPr,String styleId){\r\n    RPr resolvedRPr = resolvedStyleRPrComponent.get(styleId);\r\n    if (resolvedRPr != null) {\r\n        return resolvedRPr;\r\n    }\r\n    Style s = liveStyles.get(styleId);\r\n    if (s == null) {\r\n        log.error(\"Couldn't find style: \" + styleId);\r\n        log.debug(\"Couldn't find style: \" + styleId, new Throwable());\r\n        return null;\r\n    }\r\n    Stack<RPr> rPrStack = new Stack<RPr>();\r\n    fillRPrStack(styleId, rPrStack);\r\n    rPrStack.push(documentDefaultRPr);\r\n    resolvedRPr = factory.createRPr();\r\n    while (!rPrStack.empty()) {\r\n        RPr rPr = rPrStack.pop();\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"applying \" + XmlUtils.marshaltoString(rPr));\r\n        }\r\n        applyRPr(rPr, resolvedRPr);\r\n    }\r\n    resolvedStyleRPrComponent.put(styleId, resolvedRPr);\r\n    return resolvedRPr;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.TTFMtxEntry.isIndexReserved",
	"Comment": "determines whether this index represents a reserved character.",
	"Method": "boolean isIndexReserved(){\r\n    return (getIndex() >= 32768) && (getIndex() <= 65535);\r\n}"
}, {
	"Path": "org.docx4j.math.CTPhant.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTSSub.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.substitute.FontQualifier.bestMatch",
	"Comment": "returns the highest priority matching font triplet found in a given font info",
	"Method": "FontTriplet bestMatch(FontInfo fontInfo){\r\n    List matchingTriplets = match(fontInfo);\r\n    FontTriplet bestTriplet = null;\r\n    if (matchingTriplets.size() == 1) {\r\n        bestTriplet = (FontTriplet) matchingTriplets.get(0);\r\n    } else {\r\n        for (Iterator iterator = matchingTriplets.iterator(); iterator.hasNext(); ) {\r\n            FontTriplet triplet = (FontTriplet) iterator.next();\r\n            if (bestTriplet == null) {\r\n                bestTriplet = triplet;\r\n            } else {\r\n                int priority = triplet.getPriority();\r\n                if (priority < bestTriplet.getPriority()) {\r\n                    bestTriplet = triplet;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return bestTriplet;\r\n}"
}, {
	"Path": "org.docx4j.wml.R.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTPolyLine.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPartTypes.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.transformer.TransformerIdentityImpl.getOutputProperty",
	"Comment": "get an output property that is in effect for thetransformation.the property specified may be a propertythat was set with setoutputproperty, or it may be aproperty specified in the stylesheet.",
	"Method": "String getOutputProperty(String name){\r\n    String value = null;\r\n    OutputProperties props = m_outputFormat;\r\n    value = props.getProperty(name);\r\n    if (null == value) {\r\n        if (!OutputProperties.isLegalPropertyKey(name))\r\n            throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[] { name }));\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtContentRow.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTStyle.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFieldGroup.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTOnOff.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWebPublishObjects.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.graph.GraphBuilder.hasRelationship",
	"Comment": "look at the cache relationship. this method assume relationship were created using the createrelationship method.",
	"Method": "boolean hasRelationship(Node fromNode,Node toNode,RelationshipType rt,String sourceCall){\r\n    Set<String> relationshipCache = graphDb.getRelationshipCache();\r\n    String key = getKey(fromNode, toNode, rt, sourceCall);\r\n    return relationshipCache.contains(key);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTShadow.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.FontPanose.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTOMathPara.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMarkup.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataBar.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFitText.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotAreaReference.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTVbaSuppData.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTDocEvents.setEventDocContentControlContentUpdate",
	"Comment": "sets the value of the eventdoccontentcontrolcontentupdate property.",
	"Method": "void setEventDocContentControlContentUpdate(Object value){\r\n    this.eventDocContentControlContentUpdate = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionRowColumn.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTSphereCoords.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMoveBookmark.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.apache.commons.io.input.ClassLoaderObjectInputStream.resolveProxyClass",
	"Comment": "create a proxy class that implements the specified interfaces usingthe specified classloader or the super classloader.",
	"Method": "Class<?> resolveProxyClass(String[] interfaces){\r\n    final Class<?>[] interfaceClasses = new Class[interfaces.length];\r\n    for (int i = 0; i < interfaces.length; i++) {\r\n        interfaceClasses[i] = Class.forName(interfaces[i], false, classLoader);\r\n    }\r\n    try {\r\n        return Proxy.getProxyClass(classLoader, interfaceClasses);\r\n    } catch (final IllegalArgumentException e) {\r\n        return super.resolveProxyClass(interfaces);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.crypt.cryptoapi.CryptoAPIEncryptor.initCipherForBlock",
	"Comment": "initializes a cipher object for a given block index for encryption",
	"Method": "Cipher initCipherForBlock(Cipher cipher,int block){\r\n    return CryptoAPIDecryptor.initCipherForBlock(cipher, block, builder, getSecretKey(), Cipher.ENCRYPT_MODE);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.valueOf",
	"Comment": "constructs a new instance of taint from the specified state name",
	"Method": "Taint valueOf(String stateName,Taint valueOf,State state){\r\n    Objects.requireNonNull(state, \"state is null\");\r\n    if (state == State.INVALID) {\r\n        return null;\r\n    }\r\n    return new Taint(state);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSharedItems.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.DocumentSettingsPart.overrideTableStyleFontSizeAndJustification",
	"Comment": "get the value of compatsetting overridetablestylefontsizeandjustification",
	"Method": "boolean overrideTableStyleFontSizeAndJustification(){\r\n    CTCompatSetting overrideTableStyleFontSizeAndJustification = this.getWordCompatSetting(\"overrideTableStyleFontSizeAndJustification\");\r\n    if (overrideTableStyleFontSizeAndJustification == null || overrideTableStyleFontSizeAndJustification.getVal() == null)\r\n        return false;\r\n    return (overrideTableStyleFontSizeAndJustification.getVal().equals(\"1\") || overrideTableStyleFontSizeAndJustification.getVal().toLowerCase().equals(\"true\") || overrideTableStyleFontSizeAndJustification.getVal().toLowerCase().equals(\"yes\"));\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtContentCell.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.agent.aws.s3.BucketProperties.setRoleARN",
	"Comment": "set the arn of the role to assume from this instance when working with the given bucket.",
	"Method": "void setRoleARN(String roleARN){\r\n    if (roleARN != null) {\r\n        final AmazonResourceName arn = AmazonResourceName.fromString(roleARN);\r\n        final String awsService = arn.getService();\r\n        if (awsService.equals(IAM_SERVICE_NAMESPACE)) {\r\n            this.roleARN = arn;\r\n        } else {\r\n            throw new IllegalArgumentException(\"ARN (\" + roleARN + \") is valid format but incorrect service. Expected \" + IAM_SERVICE_NAMESPACE + \" but got \" + awsService);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.math.CTShp.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToStream.accumDefaultEntity",
	"Comment": "handle one of the default entities, return false if itis not a default entity.",
	"Method": "int accumDefaultEntity(java.io.Writer writer,char ch,int i,char[] chars,int len,boolean fromTextNode,boolean escLF){\r\n    if (!escLF && CharInfo.S_LINEFEED == ch) {\r\n        writer.write(m_lineSep, 0, m_lineSepLen);\r\n    } else {\r\n        if ((fromTextNode && m_charInfo.shouldMapTextChar(ch)) || (!fromTextNode && m_charInfo.shouldMapAttrChar(ch))) {\r\n            String outputStringForChar = m_charInfo.getOutputStringForChar(ch);\r\n            if (null != outputStringForChar) {\r\n                writer.write(outputStringForChar);\r\n            } else\r\n                return i;\r\n        } else\r\n            return i;\r\n    }\r\n    return i + 1;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTTextPath.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.CharInfo.setASCIIattrDirty",
	"Comment": "if the character is in the ascii range thenmark it as needing replacement witha string on output if it occurs in a attribute value.",
	"Method": "void setASCIIattrDirty(int j){\r\n    if (0 <= j && j < ASCII_MAX) {\r\n        shouldMapAttrChar_ASCII[j] = true;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMailMergeDocType.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.password.CTPasswordKeyEncryptor.getEncryptedVerifierHashInput",
	"Comment": "gets the value of the encryptedverifierhashinput property.",
	"Method": "byte[] getEncryptedVerifierHashInput(){\r\n    return encryptedVerifierHashInput;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionDefinedName.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTParameters.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setUseWord2002TableStyleRules",
	"Comment": "sets the value of the useword2002tablestylerules property.",
	"Method": "void setUseWord2002TableStyleRules(BooleanDefaultTrue value){\r\n    this.useWord2002TableStyleRules = value;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setDoNotUseMarginsForDrawingGridOrigin",
	"Comment": "sets the value of the donotusemarginsfordrawinggridorigin property.",
	"Method": "void setDoNotUseMarginsForDrawingGridOrigin(BooleanDefaultTrue value){\r\n    this.doNotUseMarginsForDrawingGridOrigin = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGroupItems.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFFStatusText.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getBalanceSingleByteDoubleByteWidth",
	"Comment": "gets the value of the balancesinglebytedoublebytewidth property.",
	"Method": "BooleanDefaultTrue getBalanceSingleByteDoubleByteWidth(){\r\n    return balanceSingleByteDoubleByteWidth;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTLevelGroup.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCacheHierarchies.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTXAlign.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.LSSerializerImpl.writeToURI",
	"Comment": "serializes the specified node to the specified uri and returns true if the node was successfully serialized.",
	"Method": "boolean writeToURI(Node nodeArg,String uri){\r\n    if (nodeArg == null) {\r\n        return false;\r\n    }\r\n    Serializer serializer = fXMLSerializer;\r\n    serializer.reset();\r\n    if (nodeArg != fVisitedNode) {\r\n        String xmlVersion = getXMLVersion(nodeArg);\r\n        fEncoding = getInputEncoding(nodeArg);\r\n        if (fEncoding == null) {\r\n            fEncoding = fEncoding != null ? fEncoding : getXMLEncoding(nodeArg) == null ? \"UTF-8\" : getXMLEncoding(nodeArg);\r\n        }\r\n        serializer.getOutputFormat().setProperty(\"version\", xmlVersion);\r\n        fDOMConfigProperties.setProperty(DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.S_XML_VERSION, xmlVersion);\r\n        fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_ENCODING, fEncoding);\r\n        if ((nodeArg.getNodeType() != Node.DOCUMENT_NODE || nodeArg.getNodeType() != Node.ELEMENT_NODE || nodeArg.getNodeType() != Node.ENTITY_NODE) && ((fFeatures & XMLDECL) != 0)) {\r\n            fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL, DOMConstants.DOM3_DEFAULT_FALSE);\r\n        }\r\n        fVisitedNode = nodeArg;\r\n    }\r\n    fXMLSerializer.setOutputFormat(fDOMConfigProperties);\r\n    try {\r\n        if (uri == null) {\r\n            String msg = Utils.messages.createMessage(MsgKey.ER_NO_OUTPUT_SPECIFIED, null);\r\n            if (fDOMErrorHandler != null) {\r\n                fDOMErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_FATAL_ERROR, msg, MsgKey.ER_NO_OUTPUT_SPECIFIED));\r\n            }\r\n            throw new LSException(LSException.SERIALIZE_ERR, msg);\r\n        } else {\r\n            String absoluteURI = SystemIDResolver.getAbsoluteURI(uri);\r\n            URL url = new URL(absoluteURI);\r\n            OutputStream urlOutStream = null;\r\n            String protocol = url.getProtocol();\r\n            String host = url.getHost();\r\n            if (protocol.equalsIgnoreCase(\"file\") && (host == null || host.length() == 0 || host.equals(\"localhost\"))) {\r\n                urlOutStream = new FileOutputStream(getPathWithoutEscapes(url.getPath()));\r\n            } else {\r\n                URLConnection urlCon = url.openConnection();\r\n                urlCon.setDoInput(false);\r\n                urlCon.setDoOutput(true);\r\n                urlCon.setUseCaches(false);\r\n                urlCon.setAllowUserInteraction(false);\r\n                if (urlCon instanceof HttpURLConnection) {\r\n                    HttpURLConnection httpCon = (HttpURLConnection) urlCon;\r\n                    httpCon.setRequestMethod(\"PUT\");\r\n                }\r\n                urlOutStream = urlCon.getOutputStream();\r\n            }\r\n            serializer.setOutputStream(urlOutStream);\r\n        }\r\n        if (fDOMSerializer == null) {\r\n            fDOMSerializer = (DOM3Serializer) serializer.asDOM3Serializer();\r\n        }\r\n        if (fDOMErrorHandler != null) {\r\n            fDOMSerializer.setErrorHandler(fDOMErrorHandler);\r\n        }\r\n        if (fSerializerFilter != null) {\r\n            fDOMSerializer.setNodeFilter(fSerializerFilter);\r\n        }\r\n        fDOMSerializer.setNewLine(fEndOfLine.toCharArray());\r\n        fDOMSerializer.serializeDOM3(nodeArg);\r\n    } catch (LSException lse) {\r\n        throw lse;\r\n    } catch (RuntimeException e) {\r\n        throw (LSException) createLSException(LSException.SERIALIZE_ERR, e).fillInStackTrace();\r\n    } catch (Exception e) {\r\n        if (fDOMErrorHandler != null) {\r\n            fDOMErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_FATAL_ERROR, e.getMessage(), null, e));\r\n        }\r\n        throw (LSException) createLSException(LSException.SERIALIZE_ERR, e).fillInStackTrace();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTRPrDefault.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotCaches.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTRad.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTRPR.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTRecipients.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerBase.setStandaloneInternal",
	"Comment": "sets the xsl standalone attribute, but does not remember if this is adefault or explicite setting.",
	"Method": "void setStandaloneInternal(String standalone){\r\n    if (\"yes\".equals(standalone))\r\n        m_standalone = \"yes\";\r\n    else\r\n        m_standalone = \"no\";\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblPPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTGradientStop.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtEndPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.c14n.implementations.Canonicalizer11.engineCanonicalizeXPathNodeSet",
	"Comment": "always throws a canonicalizationexception because this is inclusive c14n.",
	"Method": "byte[] engineCanonicalizeXPathNodeSet(Set<Node> xpathNodeSet,String inclusiveNamespaces){\r\n    throw new CanonicalizationException(\"c14n.Canonicalizer.UnsupportedOperation\");\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCaption.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotHierarchy.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTShapeLayout.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMailMergeSourceType.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFitText.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomChartsheetViews.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTBackground.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.Id.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTVolTopicRef.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.WriterToUTF8Buffered.getOutputStream",
	"Comment": "get the output stream where the events will be serialized to.",
	"Method": "OutputStream getOutputStream(){\r\n    return m_os;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTFormulas.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFieldUsage.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.c14n.implementations.CanonicalizerBase.canonicalizeSubTree",
	"Comment": "method canonicalizesubtree, this function is a recursive one.",
	"Method": "void canonicalizeSubTree(Node currentNode,NameSpaceSymbTable ns,Node endnode,int documentLevel){\r\n    if (currentNode == null || isVisibleInt(currentNode) == -1) {\r\n        return;\r\n    }\r\n    Node sibling = null;\r\n    Node parentNode = null;\r\n    final OutputStream writer = this.writer;\r\n    final Node excludeNode = this.excludeNode;\r\n    final boolean includeComments = this.includeComments;\r\n    Map<String, byte[]> cache = new HashMap<String, byte[]>();\r\n    do {\r\n        switch(currentNode.getNodeType()) {\r\n            case Node.ENTITY_NODE:\r\n            case Node.NOTATION_NODE:\r\n            case Node.ATTRIBUTE_NODE:\r\n                throw new CanonicalizationException(\"empty\", new Object[] { \"illegal node type during traversal\" });\r\n            case Node.DOCUMENT_FRAGMENT_NODE:\r\n            case Node.DOCUMENT_NODE:\r\n                ns.outputNodePush();\r\n                sibling = currentNode.getFirstChild();\r\n                break;\r\n            case Node.COMMENT_NODE:\r\n                if (includeComments) {\r\n                    outputCommentToWriter((Comment) currentNode, writer, documentLevel);\r\n                }\r\n                break;\r\n            case Node.PROCESSING_INSTRUCTION_NODE:\r\n                outputPItoWriter((ProcessingInstruction) currentNode, writer, documentLevel);\r\n                break;\r\n            case Node.TEXT_NODE:\r\n            case Node.CDATA_SECTION_NODE:\r\n                outputTextToWriter(currentNode.getNodeValue(), writer);\r\n                break;\r\n            case Node.ELEMENT_NODE:\r\n                documentLevel = NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;\r\n                if (currentNode == excludeNode) {\r\n                    break;\r\n                }\r\n                Element currentElement = (Element) currentNode;\r\n                ns.outputNodePush();\r\n                writer.write('<');\r\n                String name = currentElement.getTagName();\r\n                UtfHelpper.writeByte(name, writer, cache);\r\n                Iterator<Attr> attrs = this.handleAttributesSubtree(currentElement, ns);\r\n                if (attrs != null) {\r\n                    while (attrs.hasNext()) {\r\n                        Attr attr = attrs.next();\r\n                        outputAttrToWriter(attr.getNodeName(), attr.getNodeValue(), writer, cache);\r\n                    }\r\n                }\r\n                writer.write('>');\r\n                sibling = currentNode.getFirstChild();\r\n                if (sibling == null) {\r\n                    writer.write(END_TAG.clone());\r\n                    UtfHelpper.writeStringToUtf8(name, writer);\r\n                    writer.write('>');\r\n                    ns.outputNodePop();\r\n                    if (parentNode != null) {\r\n                        sibling = currentNode.getNextSibling();\r\n                    }\r\n                } else {\r\n                    parentNode = currentElement;\r\n                }\r\n                break;\r\n            case Node.DOCUMENT_TYPE_NODE:\r\n            default:\r\n                break;\r\n        }\r\n        while (sibling == null && parentNode != null) {\r\n            writer.write(END_TAG.clone());\r\n            UtfHelpper.writeByte(((Element) parentNode).getTagName(), writer, cache);\r\n            writer.write('>');\r\n            ns.outputNodePop();\r\n            if (parentNode == endnode) {\r\n                return;\r\n            }\r\n            sibling = parentNode.getNextSibling();\r\n            parentNode = parentNode.getParentNode();\r\n            if (parentNode == null || Node.ELEMENT_NODE != parentNode.getNodeType()) {\r\n                documentLevel = NODE_AFTER_DOCUMENT_ELEMENT;\r\n                parentNode = null;\r\n            }\r\n        }\r\n        if (sibling == null) {\r\n            return;\r\n        }\r\n        currentNode = sibling;\r\n        sibling = currentNode.getNextSibling();\r\n    } while (true);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotFields.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.BoolStack.peek",
	"Comment": "looks at the object at the top of this stack without removing itfrom the stack.",
	"Method": "boolean peek(){\r\n    return m_values[m_index];\r\n}"
}, {
	"Path": "org.docx4j.math.CTNary.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.anon.Anonymize.filterMDPRels",
	"Comment": "remove customxml, glossarydocument, and styleswitheffects",
	"Method": "void filterMDPRels(){\r\n    if (pkg.getMainDocumentPart().getRelationshipsPart() == null)\r\n        return;\r\n    if (log.isDebugEnabled()) {\r\n        for (Relationship r : pkg.getMainDocumentPart().getRelationshipsPart().getRelationships().getRelationship()) {\r\n            System.out.println(r.getType());\r\n        }\r\n    }\r\n    pkg.getMainDocumentPart().getRelationshipsPart().removeRelationshipsByType(\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml\");\r\n    pkg.getMainDocumentPart().getRelationshipsPart().removeRelationshipsByType(\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/glossaryDocument\");\r\n    pkg.getMainDocumentPart().getRelationshipsPart().removeRelationshipsByType(\"http://schemas.microsoft.com/office/2007/relationships/stylesWithEffects\");\r\n}"
}, {
	"Path": "org.docx4j.wml.CTZoom.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPartBehaviors.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setDisplayHorizontalDrawingGridEvery",
	"Comment": "sets the value of the displayhorizontaldrawinggridevery property.",
	"Method": "void setDisplayHorizontalDrawingGridEvery(CTSettings.DisplayHorizontalDrawingGridEvery value){\r\n    this.displayHorizontalDrawingGridEvery = value;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.property.Property.setStorageClsid",
	"Comment": "sets the storage class id for this property stream. this is the class idof the com object which can read and write this property stream",
	"Method": "void setStorageClsid(ClassID clsidStorage){\r\n    _storage_clsid = clsidStorage;\r\n    if (clsidStorage == null) {\r\n        Arrays.fill(_raw_data, _storage_clsid_offset, _storage_clsid_offset + ClassID.LENGTH, (byte) 0);\r\n    } else {\r\n        clsidStorage.write(_raw_data, _storage_clsid_offset);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.Style.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.schemas.microsoft.com.office.excel_2008_2.main.CTDefinedName.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPatternFill.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTRPR.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFFStatusText.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionAutoFormatting.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setDoNotBreakConstrainedForcedTable",
	"Comment": "sets the value of the donotbreakconstrainedforcedtable property.",
	"Method": "void setDoNotBreakConstrainedForcedTable(BooleanDefaultTrue value){\r\n    this.doNotBreakConstrainedForcedTable = value;\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.dom.DOMWriterImpl.indent",
	"Comment": "insert the correct amount of space characterss depending on the depth and ifthe indent flag is set to true.",
	"Method": "void indent(){\r\n    if (this.indent) {\r\n        StringBuffer out = new StringBuffer(this.depth * this.indentChars.length());\r\n        for (int i = 0; i < this.depth; i++) {\r\n            out.append(this.indentChars);\r\n        }\r\n        Node node = this.document.createTextNode(out.toString());\r\n        this.currentElement.appendChild(node);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.FontInfo.getFontStyleFor",
	"Comment": "returns the font style for a particular font.there may be multiple font styles matching this font. only the firstfound is returned. searching is done on a sorted list to guarantee consistentresults.",
	"Method": "String getFontStyleFor(String fontName){\r\n    FontTriplet triplet = getTripletFor(fontName);\r\n    if (triplet != null) {\r\n        return triplet.getStyle();\r\n    } else {\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.w15.CTPeople.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomFilter.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotCacheDefinition.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ElemDesc.is",
	"Comment": "tell if this element type has the basic bit properties that are passedas an argument.",
	"Method": "boolean is(int flags){\r\n    return (m_flags & flags) != 0;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.password.CTPasswordKeyEncryptor.setEncryptedVerifierHashValue",
	"Comment": "sets the value of the encryptedverifierhashvalue property.",
	"Method": "void setEncryptedVerifierHashValue(byte[] value){\r\n    this.encryptedVerifierHashValue = value;\r\n}"
}, {
	"Path": "org.docx4j.wml.BooleanDefaultFalse.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.netflix.genie.client.ApplicationClient.patchApplication",
	"Comment": "method to patch a application using json patch instructions.",
	"Method": "void patchApplication(String applicationId,JsonPatch patch){\r\n    if (StringUtils.isEmpty(applicationId)) {\r\n        throw new IllegalArgumentException(\"Missing required parameter: applicationId.\");\r\n    }\r\n    if (patch == null) {\r\n        throw new IllegalArgumentException(\"Patch cannot be null\");\r\n    }\r\n    this.applicationService.patchApplication(applicationId, patch).execute();\r\n}"
}, {
	"Path": "org.docx4j.w14.CTSdtCheckbox.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.TTFSubSetFile.createHead",
	"Comment": "copy the head table as is from original font to subset fontand set indextolocaformat to long and setchecksumadjustment to 0, store offset to checksumadjustmentin checksumadjustmentoffset",
	"Method": "void createHead(FontFileReader in){\r\n    TTFDirTabEntry entry = (TTFDirTabEntry) dirTabs.get(\"head\");\r\n    if (entry != null) {\r\n        pad4();\r\n        seekTab(in, \"head\", 0);\r\n        System.arraycopy(in.getBytes((int) entry.getOffset(), (int) entry.getLength()), 0, output, currentPos, (int) entry.getLength());\r\n        checkSumAdjustmentOffset = currentPos + 8;\r\n        output[currentPos + 8] = 0;\r\n        output[currentPos + 9] = 0;\r\n        output[currentPos + 10] = 0;\r\n        output[currentPos + 11] = 0;\r\n        output[currentPos + 50] = 0;\r\n        output[currentPos + 51] = 1;\r\n        int checksum = getCheckSum(currentPos, (int) entry.getLength());\r\n        writeULong(headDirOffset, checksum);\r\n        writeULong(headDirOffset + 4, currentPos);\r\n        writeULong(headDirOffset + 8, (int) entry.getLength());\r\n        currentPos += (int) entry.getLength();\r\n        realSize += (int) entry.getLength();\r\n    } else {\r\n        throw new IOException(\"Can't find head table\");\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDataBinding.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWorkbookProtection.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTQueryTableDeletedFields.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCalcChain.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTX.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTInteger2.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTControl.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDdeValues.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTAccPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.JaxbXmlPartXPathAware.createBinderAndJaxbElement",
	"Comment": "set the jaxbelement for this part, and a corresponding\tbinder, based on the object provided.returns the new\tjaxbelement, so calling code can manipulate it.beware\tthat this object is different to the one passed in!",
	"Method": "E createBinderAndJaxbElement(E source){\r\n    log.debug(\"creating binder\");\r\n    org.w3c.dom.Document doc = XmlUtils.marshaltoW3CDomDocument(source);\r\n    unmarshal(doc.getDocumentElement());\r\n    return jaxbElement;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTOLEObject.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTextPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionFormatting.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTNaryPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMeasureDimensionMap.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.agent.utils.EnvUtils.expandShellVariables",
	"Comment": "performs shell environment variables expansion on the given string.",
	"Method": "String expandShellVariables(String inputString,Map<String, String> environmentVariablesMap){\r\n    String outputString = inputString;\r\n    boolean variableSubstituted = true;\r\n    while (variableSubstituted) {\r\n        variableSubstituted = false;\r\n        Matcher matcher;\r\n        matcher = SHELL_VARIABLE_REGEX.matcher(outputString);\r\n        if (matcher.matches()) {\r\n            final String variableName = matcher.group(1);\r\n            final String variableValue = environmentVariablesMap.get(variableName);\r\n            if (variableValue == null) {\r\n                throw new VariableSubstitutionException(variableName, environmentVariablesMap);\r\n            }\r\n            outputString = outputString.replaceAll(\"\\\\$\" + variableName, variableValue);\r\n            variableSubstituted = true;\r\n        }\r\n        matcher = SHELL_VARIABLE_WITH_BRACES_REGEX.matcher(outputString);\r\n        if (matcher.matches()) {\r\n            final String variableName = matcher.group(1);\r\n            final String variableValue = environmentVariablesMap.get(variableName);\r\n            if (variableValue == null) {\r\n                throw new VariableSubstitutionException(variableName, environmentVariablesMap);\r\n            }\r\n            outputString = outputString.replaceAll(\"\\\\$\\\\{\" + variableName + \"}\", variableValue);\r\n            variableSubstituted = true;\r\n        }\r\n    }\r\n    return outputString;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.contenttype.ContentTypeManager.getPartNameOverridenByContentType",
	"Comment": "given a content type, return the part name uri is it\toverridden by.",
	"Method": "URI getPartNameOverridenByContentType(String contentType){\r\n    Iterator i = overrideContentType.entrySet().iterator();\r\n    while (i.hasNext()) {\r\n        Map.Entry e = (Map.Entry) i.next();\r\n        if (e != null) {\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(\"Inspecting \" + e.getValue());\r\n            }\r\n            if (((CTOverride) e.getValue()).getContentType().equals(contentType)) {\r\n                return (URI) e.getKey();\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataRef.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCacheField.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTGlow.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomFilters.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTPositiveFixedPercentage.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.FileVersion.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataBinding.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.Jc.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTInputCells.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.jaxb.NamespacePrefixMapperUtils.declareNamespaces",
	"Comment": "word requires all mcignorable prefixes to be declared at the document level.",
	"Method": "void declareNamespaces(String mcIgnorable,Document doc){\r\n    if (mcIgnorable == null)\r\n        return;\r\n    StringTokenizer st = new StringTokenizer(mcIgnorable, \" \");\r\n    while (st.hasMoreTokens()) {\r\n        String prefix = (String) st.nextToken();\r\n        String uri = NamespacePrefixMappings.getNamespaceURIStatic(prefix);\r\n        if (uri == null) {\r\n            log.warn(\"No mapping for prefix '\" + prefix + \"'\");\r\n        } else {\r\n            doc.getDocumentElement().setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:\" + prefix, uri);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTPerm.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWebPublishItem.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTPercentage.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.Tabs.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.Tbl.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getBordersDoNotSurroundHeader",
	"Comment": "gets the value of the bordersdonotsurroundheader property.",
	"Method": "BooleanDefaultTrue getBordersDoNotSurroundHeader(){\r\n    return bordersDoNotSurroundHeader;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.CustomFont.getEmbedFileName",
	"Comment": "returns an uri representing an embeddable font file. the uri will oftenbe a filename or an url.",
	"Method": "String getEmbedFileName(){\r\n    return embedFileName;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotTableStyle.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.nustaq.offheap.structs.structtypes.StructString.setString",
	"Comment": "modify content of this structstring. the length of the new string must not exceedthe length of internal char array",
	"Method": "void setString(String s){\r\n    if (s == null) {\r\n        setLen(0);\r\n        return;\r\n    }\r\n    if (s.length() > charsLen()) {\r\n        throw new RuntimeException(\"String length exceeds buffer size. String len \" + s.length() + \" charsLen:\" + charsLen());\r\n    }\r\n    for (int i = 0; i < s.length(); i++) {\r\n        chars(i, s.charAt(i));\r\n    }\r\n    len = s.length();\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTMcd.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFFName.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTwipsMeasure.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.presentationDrawing.CTRel.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.FontInfo.fontLookup",
	"Comment": "lookup a font.locate the font name for a given family, style and weight.the font name can then be used as a key as it is unique forthe associated document.this also adds the font to the list of used fonts.",
	"Method": "FontTriplet fontLookup(String family,String style,int weight,boolean substitutable,FontTriplet fontLookup,String family,String style,int weight,List fontLookup,String[] families,String style,int weight,boolean substitutable,FontTriplet[] fontLookup,String[] families,String style,int weight){\r\n    if (families.length == 0) {\r\n        throw new IllegalArgumentException(\"Specify at least one font family\");\r\n    }\r\n    List matchedTriplets = fontLookup(families, style, weight, false);\r\n    if (matchedTriplets.size() == 0) {\r\n        matchedTriplets = fontLookup(families, style, weight, true);\r\n    }\r\n    if (matchedTriplets.size() == 0) {\r\n        StringBuffer sb = new StringBuffer();\r\n        for (int i = 0, c = families.length; i < c; i++) {\r\n            if (i > 0) {\r\n                sb.append(\", \");\r\n            }\r\n            sb.append(families[i]);\r\n        }\r\n        throw new IllegalStateException(\"fontLookup must return an array with at least one \" + \"FontTriplet on the last call. Lookup: \" + sb.toString());\r\n    }\r\n    FontTriplet[] fontTriplets = new FontTriplet[matchedTriplets.size()];\r\n    matchedTriplets.toArray(fontTriplets);\r\n    return fontTriplets;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTLegacyDrawing.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.TTFFile.getLastChar",
	"Comment": "returns the index of the last character, but this is for winansiencodingonly, so the last char is256.",
	"Method": "short getLastChar(){\r\n    return lastChar;\r\n}"
}, {
	"Path": "org.nustaq.serialization.FSTObjectOutput.getFstClazzInfo",
	"Comment": "if class is same as last referenced, returned cached clzinfo, else do a lookup",
	"Method": "FSTClazzInfo getFstClazzInfo(FSTClazzInfo.FSTFieldInfo referencee,Class clazz){\r\n    FSTClazzInfo serializationInfo = null;\r\n    FSTClazzInfo lastInfo = referencee.lastInfo;\r\n    if (lastInfo != null && lastInfo.getClazz() == clazz && lastInfo.conf == conf) {\r\n        serializationInfo = lastInfo;\r\n    } else {\r\n        serializationInfo = getClassInfoRegistry().getCLInfo(clazz, conf);\r\n        referencee.lastInfo = serializationInfo;\r\n    }\r\n    return serializationInfo;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPageItem.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.webextension_2010_11.CTOsfWebExtensionBindingList.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTBorderBoxPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFtnEdnRef.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTH.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTPaperSource.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart.unmarshalDefaultStyles",
	"Comment": "unmarshal a default set of styles, useful when creating thispart from scratch.",
	"Method": "Object unmarshalDefaultStyles(){\r\n    java.io.InputStream is = null;\r\n    try {\r\n        is = ResourceUtils.getResourceViaProperty(\"docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart.DefaultStyles\", \"org/docx4j/openpackaging/parts/WordprocessingML/styles.xml\");\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    return unmarshal(is);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.FontFileReader.readTTFShort",
	"Comment": "read 2 bytes signed at position pos without changing current position.",
	"Method": "short readTTFShort(short readTTFShort,long pos){\r\n    final long cp = getCurrentPos();\r\n    seekSet(pos);\r\n    final short ret = readTTFShort();\r\n    seekSet(cp);\r\n    return ret;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTSRgbColor.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTRubyPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.topologi.diffx.load.SAXRecorder.setXMLReaderClass",
	"Comment": "sets the name of the xml reader class to use.use null to reset the xml reader class and use the default xml reader.a new reader will be created only if the specified class is different from the current one.",
	"Method": "void setXMLReaderClass(String className){\r\n    if (className == null) {\r\n        className = DEFAULT_XML_READER;\r\n    }\r\n    newReader = !className.equals(readerClassName);\r\n    readerClassName = className;\r\n}"
}, {
	"Path": "org.docx4j.math.CTInteger2.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.io3.stores.ZipPartStore.getByteArray",
	"Comment": "this method is to facilitate updating the part without\tjaxb unmarshalling then marshalling.not intended for direct\tuse by user code.",
	"Method": "ByteArray getByteArray(String partName){\r\n    return partByteArrays.get(partName);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOleSize.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDivBdr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTFill.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.TaintMethodConfig.isInformative",
	"Comment": "checks if the summary needs to be saved or has no information value",
	"Method": "boolean isInformative(){\r\n    if (this == SAFE_CONFIG) {\r\n        return false;\r\n    }\r\n    if (outputTaint == null) {\r\n        return false;\r\n    }\r\n    if (!outputTaint.isUnknown()) {\r\n        return true;\r\n    }\r\n    if (outputTaint.hasParameters()) {\r\n        return true;\r\n    }\r\n    if (outputTaint.getRealInstanceClass() != null) {\r\n        return true;\r\n    }\r\n    if (outputTaint.hasTags() || outputTaint.isRemovingTags()) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOleObjects.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.anon.DmlVmlAnalyzer.handleCTNonVisualDrawingProps",
	"Comment": "there can be hyperlinks references in ctnonvisualdrawingprops.",
	"Method": "void handleCTNonVisualDrawingProps(CTNonVisualDrawingProps drawingProps,List<Object> artificialList){\r\n    if (drawingProps != null) {\r\n        if (drawingProps.getDescr() != null) {\r\n            drawingProps.setDescr(null);\r\n        }\r\n        CTHyperlink docPrHyperLink = drawingProps.getHlinkClick();\r\n        if (docPrHyperLink != null)\r\n            artificialList.add(docPrHyperLink);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.WeakObjectPool.repool",
	"Comment": "adds the given object to the pool, provided that the objectwas created by this pool.",
	"Method": "boolean repool(T obj){\r\n    if (obj != null && onLoan.containsKey(obj)) {\r\n        synchronized (obj) {\r\n            if (onLoan.remove(obj) != null) {\r\n                return available.offer(new WeakReference<T>(obj));\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ElemContext.push",
	"Comment": "push an element context on the stack. this context keeps track ofinformation gathered about the element.",
	"Method": "ElemContext push(ElemContext push,String uri,String localName,String qName){\r\n    ElemContext frame = this.m_next;\r\n    if (frame == null) {\r\n        frame = new ElemContext(this);\r\n        this.m_next = frame;\r\n    }\r\n    frame.m_elementName = qName;\r\n    frame.m_elementLocalName = localName;\r\n    frame.m_elementURI = uri;\r\n    frame.m_isCdataSection = false;\r\n    frame.m_startTagOpen = true;\r\n    return frame;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTKinsoku.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotField.setMultipleItemSelectionAllowed",
	"Comment": "sets the value of the multipleitemselectionallowed property.",
	"Method": "void setMultipleItemSelectionAllowed(Boolean value){\r\n    this.multipleItemSelectionAllowed = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTVolTopicRef.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtComboBox.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTDocEvents.getEventDocContentControlOnExit",
	"Comment": "gets the value of the eventdoccontentcontrolonexit property.",
	"Method": "Object getEventDocContentControlOnExit(){\r\n    return eventDocContentControlOnExit;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.XmlPart.setNodeValueAtXPath",
	"Comment": "set the value of the node referenced in the xpath expression.",
	"Method": "boolean setNodeValueAtXPath(String xpath,String value,String prefixMappings){\r\n    try {\r\n        Node n;\r\n        synchronized (xPath) {\r\n            getNamespaceContext().registerPrefixMappings(prefixMappings);\r\n            n = (Node) xPath.evaluate(xpath, doc, XPathConstants.NODE);\r\n        }\r\n        if (n == null) {\r\n            log.debug(\"xpath returned null\");\r\n            return false;\r\n        }\r\n        log.debug(n.getClass().getName());\r\n        if (n.getChildNodes() != null && n.getChildNodes().getLength() > 0) {\r\n            NodeList nodes = n.getChildNodes();\r\n            for (int i = nodes.getLength(); i > 0; i--) {\r\n                n.removeChild(nodes.item(i - 1));\r\n            }\r\n        }\r\n        Text t = n.getOwnerDocument().createTextNode(value);\r\n        n.appendChild(t);\r\n        return true;\r\n    } catch (Exception e) {\r\n        throw new Docx4JException(\"Problem setting value at xpath \" + xpath);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocGrid.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSFileSystem.getFreeBlock",
	"Comment": "finds a free block, and returns its offset.this method will extend the file if needed, and if doing so, allocate new fat blocks to address the extra space.",
	"Method": "int getFreeBlock(){\r\n    int numSectors = bigBlockSize.getBATEntriesPerBlock();\r\n    int offset = 0;\r\n    for (BATBlock bat : _bat_blocks) {\r\n        if (bat.hasFreeSectors()) {\r\n            for (int j = 0; j < numSectors; j++) {\r\n                int batValue = bat.getValueAt(j);\r\n                if (batValue == POIFSConstants.UNUSED_BLOCK) {\r\n                    return offset + j;\r\n                }\r\n            }\r\n        }\r\n        offset += numSectors;\r\n    }\r\n    BATBlock bat = createBAT(offset, true);\r\n    bat.setValueAt(0, POIFSConstants.FAT_SECTOR_BLOCK);\r\n    _bat_blocks.add(bat);\r\n    if (_header.getBATCount() >= 109) {\r\n        BATBlock xbat = null;\r\n        for (BATBlock x : _xbat_blocks) {\r\n            if (x.hasFreeSectors()) {\r\n                xbat = x;\r\n                break;\r\n            }\r\n        }\r\n        if (xbat == null) {\r\n            xbat = createBAT(offset + 1, false);\r\n            xbat.setValueAt(0, offset);\r\n            bat.setValueAt(1, POIFSConstants.DIFAT_SECTOR_BLOCK);\r\n            offset++;\r\n            if (_xbat_blocks.size() == 0) {\r\n                _header.setXBATStart(offset);\r\n            } else {\r\n                _xbat_blocks.get(_xbat_blocks.size() - 1).setValueAt(bigBlockSize.getXBATEntriesPerBlock(), offset);\r\n            }\r\n            _xbat_blocks.add(xbat);\r\n            _header.setXBATCount(_xbat_blocks.size());\r\n        } else {\r\n            for (int i = 0; i < bigBlockSize.getXBATEntriesPerBlock(); i++) {\r\n                if (xbat.getValueAt(i) == POIFSConstants.UNUSED_BLOCK) {\r\n                    xbat.setValueAt(i, offset);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        int[] newBATs = new int[_header.getBATCount() + 1];\r\n        System.arraycopy(_header.getBATArray(), 0, newBATs, 0, newBATs.length - 1);\r\n        newBATs[newBATs.length - 1] = offset;\r\n        _header.setBATArray(newBATs);\r\n    }\r\n    _header.setBATCount(_bat_blocks.size());\r\n    return offset + 1;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCustomXmlBlock.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.TblBorders.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.netflix.genie.agent.utils.PathUtils.jobGenieDirectoryPath",
	"Comment": "compose the path to the genie directory inside a job directory.",
	"Method": "Path jobGenieDirectoryPath(File jobDirectory){\r\n    return composePath(jobDirectory, JobConstants.GENIE_PATH_VAR);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.webextension_2010_11.CTOsfWebExtensionReferenceList.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.RangePermissionStart.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.DocumentPart.hasEndnotesPart",
	"Comment": "does this package contain an endnotes part, with real endnotes\tin it?",
	"Method": "boolean hasEndnotesPart(){\r\n    if (getEndNotesPart() == null) {\r\n        return false;\r\n    } else {\r\n        CTEndnotes endnotes = getEndNotesPart().getJaxbElement();\r\n        if (endnotes.getEndnote().size() < 3) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFilter.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Macrosheet.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerBase.inTemporaryOutputState",
	"Comment": "returns true if the serializer is used for temporary output rather thanfinal output.this concept is made clear in the xslt 2.0 draft.",
	"Method": "boolean inTemporaryOutputState(){\r\n    return (getEncoding() == null);\r\n}"
}, {
	"Path": "org.docx4j.wml.Ftr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTOMathArg.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w16cid.CTCommentId.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Cell.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWorkbookProtection.setRevisionsPasswordCharacterSet",
	"Comment": "sets the value of the revisionspasswordcharacterset property.",
	"Method": "void setRevisionsPasswordCharacterSet(String value){\r\n    this.revisionsPasswordCharacterSet = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSortCondition.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblPrExChange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.h3xstream.findbugs.test.BaseDetectorTest.getPluginDepsJarPath",
	"Comment": "the test dependencies are added by default to avoid classnotfoundexception when analyzing the test sample.those classes are required if the inheritance hierarchy is analyzed.",
	"Method": "String getPluginDepsJarPath(){\r\n    ClassLoader cl = getClass().getClassLoader();\r\n    String url = cl.getResource(\"PluginDepsClassPathFinder.class\").toExternalForm();\r\n    String separateFile = \"/target/classes/PluginDepsClassPathFinder.class\";\r\n    String insideJar = \"!/PluginDepsClassPathFinder.class\";\r\n    for (String suffix : Arrays.asList(separateFile, insideJar)) {\r\n        if (url.endsWith(suffix)) {\r\n            String filename = url.substring(0, url.length() - suffix.length());\r\n            if (suffix == separateFile) {\r\n                filename += \"/target/classes/\";\r\n            }\r\n            for (String prefix : Arrays.asList(\"file:\", \"jar:file:\")) {\r\n                if (filename.startsWith(prefix)) {\r\n                    filename = filename.substring(prefix.length());\r\n                }\r\n            }\r\n            return filename;\r\n        }\r\n    }\r\n    throw new RuntimeException(\"Unable to locate the dependencies for test in the classpath.\");\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellWatches.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.URIHelper.decodeURI",
	"Comment": "decode a uri by converting all percent encoded character into a string\tcharacter.",
	"Method": "String decodeURI(URI uri){\r\n    StringBuffer retVal = new StringBuffer();\r\n    String uriStr = uri.toASCIIString();\r\n    char c;\r\n    for (int i = 0; i < uriStr.length(); ++i) {\r\n        c = uriStr.charAt(i);\r\n        if (c == '%') {\r\n            if (((uriStr.length() - i) < 2)) {\r\n                throw new IllegalArgumentException(\"The uri \" + uriStr + \" contain invalid encoded character !\");\r\n            }\r\n            char decodedChar = (char) Integer.parseInt(uriStr.substring(i + 1, i + 3), 16);\r\n            retVal.append(decodedChar);\r\n            i += 2;\r\n            continue;\r\n        }\r\n        retVal.append(c);\r\n    }\r\n    return retVal.toString();\r\n}"
}, {
	"Path": "org.docx4j.math.CTPhantPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.hpsf.VariantSupport.isLogUnsupportedTypes",
	"Comment": "checks whether logging of unsupported variant types warning is turnedon or off.",
	"Method": "boolean isLogUnsupportedTypes(){\r\n    return logUnsupportedTypes;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.Part.setSourceRelationship",
	"Comment": "nb a media part could be referenced from multiple\tsource parts, but this method can only record one!",
	"Method": "void setSourceRelationship(Relationship sourceRelationship){\r\n    sourceRelationships.clear();\r\n    sourceRelationships.add(sourceRelationship);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.hasValidVariableIndex",
	"Comment": "checks if the index of the local variable matching this fact is known",
	"Method": "boolean hasValidVariableIndex(){\r\n    return variableIndex != INVALID_INDEX;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSharedUser.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTManualBreak.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTFill.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTProtectedRanges.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.nustaq.offheap.structs.FSTStruct.createCopy",
	"Comment": "returns a complete copy of this object allocating a new bytez capable of holding the data.",
	"Method": "FSTStruct createCopy(){\r\n    if (!isOffHeap()) {\r\n        throw new RuntimeException(\"must be offheap to call this\");\r\n    }\r\n    byte[] b = new byte[getByteSize()];\r\n    HeapBytez res = new HeapBytez(b);\r\n    getBytes(res, 0);\r\n    return ___fac.createStructWrapper(res, 0);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSignedTwipsMeasure.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSmartTags.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.CIDSubset.getSubsetChars",
	"Comment": "returns a char array containing all unicode characters that are in the subset.",
	"Method": "char[] getSubsetChars(){\r\n    char[] charArray = new char[usedGlyphsCount];\r\n    for (int i = 0; i < usedGlyphsCount; i++) {\r\n        charArray[i] = getUnicodeForSubsetIndex(i);\r\n    }\r\n    return charArray;\r\n}"
}, {
	"Path": "org.docx4j.math.CTRad.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPageBreak.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRangeSet.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w15.CTPresenceInfo.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTInk.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFieldUsage.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTLigatures.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCalculatedItems.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTQueryCache.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getDrawingGridVerticalSpacing",
	"Comment": "gets the value of the drawinggridverticalspacing property.",
	"Method": "CTTwipsMeasure getDrawingGridVerticalSpacing(){\r\n    return drawingGridVerticalSpacing;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPCDSCPage.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTOMath.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSelection.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetProtection.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTXStringElement.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToXMLSAXHandler.popNamespace",
	"Comment": "undeclare the namespace that is currently pointed to by a givenprefix. inform sax handler if prefix was previously mapped.",
	"Method": "boolean popNamespace(String prefix){\r\n    try {\r\n        if (NamespaceMappingsAccessor.popNamespace(m_prefixMap, prefix)) {\r\n            m_saxHandler.endPrefixMapping(prefix);\r\n            return true;\r\n        }\r\n    } catch (Exception e) {\r\n        log.error(e.getMessage(), e);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTControlPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTDocEvents.setEventDocContentControlAfterInsert",
	"Comment": "sets the value of the eventdoccontentcontrolafterinsert property.",
	"Method": "void setEventDocContentControlAfterInsert(Object value){\r\n    this.eventDocContentControlAfterInsert = value;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTPath.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "ser.FloatBench.main0",
	"Comment": "as originally submitted. problematic as gc dominates runtime",
	"Method": "void main0(String[] args){\r\n    while (true) {\r\n        CountingOutputStream count;\r\n        long start, elapsed;\r\n        Object obj = new double[100_000_000];\r\n        FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();\r\n        count = new CountingOutputStream();\r\n        start = System.nanoTime();\r\n        try (ObjectOutputStream oos = new ObjectOutputStream(count)) {\r\n            oos.writeObject(obj);\r\n        }\r\n        elapsed = System.nanoTime() - start;\r\n        System.out.println(\"STD \" + count.count + \" bytes written in \" + (elapsed) / 1000000L + \"ms\");\r\n        count = new CountingOutputStream();\r\n        start = System.nanoTime();\r\n        try (FSTObjectOutput fos = new FSTObjectOutput(count, conf)) {\r\n            fos.writeObject(obj);\r\n        }\r\n        elapsed = System.nanoTime() - start;\r\n        System.out.println(\"FST \" + count.count + \" bytes written in \" + (elapsed) / 1000000L + \"ms\");\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.w14.CTSphereCoords.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.agent.execution.services.impl.FetchingCacheServiceImpl.touchCacheResourceVersionLockFile",
	"Comment": "touch the lock file of a resource version and return a handle to it",
	"Method": "File touchCacheResourceVersionLockFile(String resourceCacheId,long lastModifiedTimestamp,File touchCacheResourceVersionLockFile,File resourceVersionDir){\r\n    final File lockFile = getCacheResourceVersionLockFile(resourceVersionDir);\r\n    Files.touch(lockFile);\r\n    return lockFile;\r\n}"
}, {
	"Path": "org.docx4j.math.CTSSubPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTShortHexNumber.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblPrExBase.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMergeCells.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.hpsf.VariantSupport.writeUnsupportedTypeMessage",
	"Comment": "writes a warning to system.err that a variant type isunsupported by hpsf. such a warning is written only once for each varianttype. log messages can be turned on or off by",
	"Method": "void writeUnsupportedTypeMessage(UnsupportedVariantTypeException ex){\r\n    if (isLogUnsupportedTypes()) {\r\n        if (unsupportedMessage == null)\r\n            unsupportedMessage = new LinkedList<Long>();\r\n        Long vt = Long.valueOf(ex.getVariantType());\r\n        if (!unsupportedMessage.contains(vt)) {\r\n            logger.error(ex.getMessage());\r\n            unsupportedMessage.add(vt);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellFormula.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTXAlign.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.Ftr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.agent.cli.UserConsole.getLogger",
	"Comment": "get the logger visible to user on the console.all other logger messages are logged on file only to avoid interfering with the job console output.",
	"Method": "Logger getLogger(){\r\n    return LOGGER;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.OPOIFSDocument.getViewableIterator",
	"Comment": "get an iterator of objects, some of which may implement poifsviewable",
	"Method": "Iterator<Object> getViewableIterator(){\r\n    return Collections.emptyList().iterator();\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableStyle.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTHeight.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtDropDownList.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFtnEdn.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.Tag.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTChartFormats.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTColorMru.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTRecipientData.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.hasOneTag",
	"Comment": "checks whether one of the specified taint tag is present for this fact",
	"Method": "boolean hasOneTag(Tag tags){\r\n    for (Tag t : tags) {\r\n        if (this.tags.contains(t))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFFData.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.topologi.diffx.sequence.SequenceSlicer.formatStart",
	"Comment": "formats the start subsequence that has been buffered by this class.this method will clear the buffer, but will do nothing if the start buffer isnull.",
	"Method": "void formatStart(DiffXFormatter formatter){\r\n    if (this.start == null)\r\n        return;\r\n    for (int i = 0; i < this.start.size(); i++) {\r\n        formatter.format(this.start.getEvent(i));\r\n    }\r\n    this.start = null;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSaveThroughXslt.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2010.wordprocessingShape.CTLinkedTextboxInformation.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.SystemIDResolver.getAbsoluteURI",
	"Comment": "take a systemid string and try to turn it into a good absolute uri.",
	"Method": "String getAbsoluteURI(String systemId,String getAbsoluteURI,String urlString,String base){\r\n    if (base == null)\r\n        return getAbsoluteURI(urlString);\r\n    String absoluteBase = getAbsoluteURI(base);\r\n    URI uri = null;\r\n    try {\r\n        URI baseURI = new URI(absoluteBase);\r\n        uri = new URI(baseURI, urlString);\r\n    } catch (MalformedURIException mue) {\r\n        throw new TransformerException(mue);\r\n    }\r\n    return replaceChars(uri.toString());\r\n}"
}, {
	"Path": "org.docx4j.wml.CTShapeDefaults.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.FontFileReader.init",
	"Comment": "initializes class and reads stream. init does not close stream.",
	"Method": "void init(InputStream in){\r\n    this.file = IOUtils.toByteArray(in);\r\n    this.fsize = this.file.length;\r\n    this.current = 0;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.property.Property.getShortDescription",
	"Comment": "provides a short description of the object, to be used when apoifsviewable object has not provided its contents.",
	"Method": "String getShortDescription(){\r\n    StringBuffer buffer = new StringBuffer();\r\n    buffer.append(\"Property: \\\"\").append(getName()).append(\"\\\"\");\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTNumFmts.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTrackChange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.eclipse.compare.rangedifferencer.RangeDifferencer.findDifferences",
	"Comment": "finds the differences between two irangecomparators. thedifferences are returned as an array of rangedifferences.if no differences are detected an empty array is returned.",
	"Method": "RangeDifference[] findDifferences(IRangeComparator left,IRangeComparator right,RangeDifference[] findDifferences,LCSSettings settings,IRangeComparator left,IRangeComparator right,RangeDifference[] findDifferences,LCSSettings settings,IRangeComparator ancestor,IRangeComparator left,IRangeComparator right){\r\n    if (ancestor == null)\r\n        return findDifferences(settings, left, right);\r\n    RangeDifference[] leftAncestorScript = null;\r\n    RangeDifference[] rightAncestorScript = findDifferences(settings, ancestor, right);\r\n    if (rightAncestorScript != null) {\r\n        leftAncestorScript = findDifferences(settings, ancestor, left);\r\n    }\r\n    if (rightAncestorScript == null || leftAncestorScript == null)\r\n        return null;\r\n    DifferencesIterator myIter = new DifferencesIterator(rightAncestorScript);\r\n    DifferencesIterator yourIter = new DifferencesIterator(leftAncestorScript);\r\n    List diff3 = new ArrayList();\r\n    diff3.add(new RangeDifference(RangeDifference.ERROR));\r\n    int changeRangeStart = 0;\r\n    int changeRangeEnd = 0;\r\n    while (myIter.fDifference != null || yourIter.fDifference != null) {\r\n        DifferencesIterator startThread;\r\n        myIter.removeAll();\r\n        yourIter.removeAll();\r\n        if (myIter.fDifference == null)\r\n            startThread = yourIter;\r\n        else if (yourIter.fDifference == null)\r\n            startThread = myIter;\r\n        else {\r\n            if (myIter.fDifference.fLeftStart <= yourIter.fDifference.fLeftStart)\r\n                startThread = myIter;\r\n            else\r\n                startThread = yourIter;\r\n        }\r\n        changeRangeStart = startThread.fDifference.fLeftStart;\r\n        changeRangeEnd = startThread.fDifference.leftEnd();\r\n        startThread.next();\r\n        DifferencesIterator other = startThread.other(myIter, yourIter);\r\n        while (other.fDifference != null && other.fDifference.fLeftStart <= changeRangeEnd) {\r\n            int newMax = other.fDifference.leftEnd();\r\n            other.next();\r\n            if (newMax >= changeRangeEnd) {\r\n                changeRangeEnd = newMax;\r\n                other = other.other(myIter, yourIter);\r\n            }\r\n        }\r\n        diff3.add(createRangeDifference3(myIter, yourIter, diff3, right, left, changeRangeStart, changeRangeEnd));\r\n    }\r\n    diff3.remove(0);\r\n    return (RangeDifference[]) diff3.toArray(EMPTY_RESULT);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTColorScale.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellSmartTag.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTLanguage.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTOMathArgPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTRubyContent.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblPrExBase.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTWriteProtection.getCryptProviderTypeExtSource",
	"Comment": "gets the value of the cryptprovidertypeextsource property.",
	"Method": "String getCryptProviderTypeExtSource(){\r\n    return cryptProviderTypeExtSource;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPatternFill.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.SheetView.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.topologi.diffx.sequence.NaiveSequenceSlicer.formatEnd",
	"Comment": "formats the end subsequence that has been buffered by this class.this method will clear the buffer, but will do nothing if the end buffer isnull.",
	"Method": "void formatEnd(DiffXFormatter formatter){\r\n    if (this.end == null)\r\n        return;\r\n    for (int i = 0; i < this.end.size(); i++) {\r\n        formatter.format(this.end.getEvent(i));\r\n    }\r\n    this.end = null;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTF.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Macrosheet.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.webextension_2010_11.CTOsfWebExtensionBinding.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.XMLUtils.createElementInEncryption11Space",
	"Comment": "creates an element in the xml encryption 1.1 specification namespace.",
	"Method": "Element createElementInEncryption11Space(Document doc,String elementName){\r\n    if (doc == null) {\r\n        throw new RuntimeException(\"Document is null\");\r\n    }\r\n    if (xenc11Prefix == null || xenc11Prefix.length() == 0) {\r\n        return doc.createElementNS(EncryptionConstants.EncryptionSpec11NS, elementName);\r\n    }\r\n    return doc.createElementNS(EncryptionConstants.EncryptionSpec11NS, xenc11Prefix + \":\" + elementName);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTColFields.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTM.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellStyleXfs.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExtension.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTHyperlinks.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWorkbookProtection.getRevisionsPasswordCharacterSet",
	"Comment": "gets the value of the revisionspasswordcharacterset property.",
	"Method": "String getRevisionsPasswordCharacterSet(){\r\n    return revisionsPasswordCharacterSet;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGradientFill.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTShortHexNumber.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionHeaders.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.DOM3SerializerImpl.setSerializationHandler",
	"Comment": "sets a serializationhandler on the dom serializer.this interface is a public api.",
	"Method": "void setSerializationHandler(SerializationHandler handler){\r\n    fSerializationHandler = handler;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFtnEdnSepRef.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFtnEdn.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotCacheDefinition.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTColItems.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSet.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CommentRangeEnd.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtDate.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblPrEx.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTVerticalAlignFontProperty.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTUnSignedInteger.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.hpsf.VariantSupport.setLogUnsupportedTypes",
	"Comment": "specifies whether warnings about unsupported variant types are to bewritten to system.err or not.",
	"Method": "void setLogUnsupportedTypes(boolean logUnsupportedTypes){\r\n    VariantSupport.logUnsupportedTypes = logUnsupportedTypes;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.hpsf.Variant.getVariantName",
	"Comment": "returns the variant type name associated with a variant typenumber.",
	"Method": "String getVariantName(long variantType){\r\n    final String name = numberToName.get(Long.valueOf(variantType));\r\n    return name != null ? name : \"unknown variant type\";\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTBorderPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataRef.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.templates.OutputProperties.recompose",
	"Comment": "this function is called to recompose all of the output format extended elements.",
	"Method": "void recompose(StylesheetRoot root){\r\n    throw new TransformerException(\"Not implemented!\");\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPageMargins.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTOMath.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getPrintBodyTextBeforeHeader",
	"Comment": "gets the value of the printbodytextbeforeheader property.",
	"Method": "BooleanDefaultTrue getPrintBodyTextBeforeHeader(){\r\n    return printBodyTextBeforeHeader;\r\n}"
}, {
	"Path": "org.docx4j.jaxb.NamespacePrefixMapper.getPreferredPrefix",
	"Comment": "returns a preferred prefix for the given namespace uri.this method is intended to be overrided by a derived class.",
	"Method": "String getPreferredPrefix(String namespaceUri,String suggestion,boolean requirePrefix){\r\n    return NamespacePrefixMappings.getPreferredPrefixStatic(namespaceUri, suggestion, requirePrefix);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTable.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTOdsoFieldMapData.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMailMergeDest.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDdeValues.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTShapeDefaults.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTEastAsianLayout.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToUnknownStream.getNamespaceMappings",
	"Comment": "get the current namespace mappings.simply returns the mappings of the wrapped handler.",
	"Method": "NamespaceMappings getNamespaceMappings(){\r\n    NamespaceMappings mappings = null;\r\n    if (m_handler != null) {\r\n        mappings = m_handler.getNamespaceMappings();\r\n    }\r\n    return mappings;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSst.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.nustaq.serialization.coders.FSTStreamEncoder.close",
	"Comment": "close and flush to underlying stream if present. the stream is also closed",
	"Method": "void close(){\r\n    buffout.close();\r\n    conf.returnObject(clnames);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTColHierarchiesUsage.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTRect.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.hpsf.wellknown.PropertyIDMap.getDocumentSummaryInformationProperties",
	"Comment": "returns the document summary information propertiessingleton.",
	"Method": "PropertyIDMap getDocumentSummaryInformationProperties(){\r\n    if (documentSummaryInformationProperties == null) {\r\n        PropertyIDMap m = new PropertyIDMap(17, (float) 1.0);\r\n        m.put(PID_DICTIONARY, \"PID_DICTIONARY\");\r\n        m.put(PID_CODEPAGE, \"PID_CODEPAGE\");\r\n        m.put(PID_CATEGORY, \"PID_CATEGORY\");\r\n        m.put(PID_PRESFORMAT, \"PID_PRESFORMAT\");\r\n        m.put(PID_BYTECOUNT, \"PID_BYTECOUNT\");\r\n        m.put(PID_LINECOUNT, \"PID_LINECOUNT\");\r\n        m.put(PID_PARCOUNT, \"PID_PARCOUNT\");\r\n        m.put(PID_SLIDECOUNT, \"PID_SLIDECOUNT\");\r\n        m.put(PID_NOTECOUNT, \"PID_NOTECOUNT\");\r\n        m.put(PID_HIDDENCOUNT, \"PID_HIDDENCOUNT\");\r\n        m.put(PID_MMCLIPCOUNT, \"PID_MMCLIPCOUNT\");\r\n        m.put(PID_SCALE, \"PID_SCALE\");\r\n        m.put(PID_HEADINGPAIR, \"PID_HEADINGPAIR\");\r\n        m.put(PID_DOCPARTS, \"PID_DOCPARTS\");\r\n        m.put(PID_MANAGER, \"PID_MANAGER\");\r\n        m.put(PID_COMPANY, \"PID_COMPANY\");\r\n        m.put(PID_LINKSDIRTY, \"PID_LINKSDIRTY\");\r\n        documentSummaryInformationProperties = new PropertyIDMap(Collections.unmodifiableMap(m));\r\n    }\r\n    return documentSummaryInformationProperties;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFramesetSplitbar.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w15symex.CTSymEx.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtListItem.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTPPrDefault.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTEntry.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTComments.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetProtection.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w15.CTSdtAppearance.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getAlwaysShowPlaceholderText",
	"Comment": "gets the value of the alwaysshowplaceholdertext property.",
	"Method": "BooleanDefaultTrue getAlwaysShowPlaceholderText(){\r\n    return alwaysShowPlaceholderText;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.util.LocaleUtil.setUserLocale",
	"Comment": "sets default user locale.this setting is specific to the current thread.",
	"Method": "void setUserLocale(Locale locale){\r\n    userLocale.set(locale);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTColItems.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTVolMain.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTD.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFrameset.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTInteger255.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTOMathPara.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtContentRow.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCommentPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.client.CommandClient.getCommands",
	"Comment": "method to get a list of all the commands from genie for the query parameters specified.",
	"Method": "List<Command> getCommands(List<Command> getCommands,String name,String user,List<String> statusList,List<String> tagList){\r\n    final List<Command> commandList = new ArrayList();\r\n    final JsonNode jNode = commandService.getCommands(name, user, statusList, tagList).execute().body().get(\"_embedded\");\r\n    if (jNode != null) {\r\n        for (final JsonNode objNode : jNode.get(\"commandList\")) {\r\n            final Command command = this.treeToValue(objNode, Command.class);\r\n            commandList.add(command);\r\n        }\r\n    }\r\n    return commandList;\r\n}"
}, {
	"Path": "org.docx4j.wml.Hdr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTConditionalFormats.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDefinedName.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTFormulas.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.org.apache.poi.ss.usermodel.ExcelStyleDateFormatter.setDateToBeFormatted",
	"Comment": "used to let us know what the date beingformatted is, in excel terms, which wemay wish to use when handling elapsedtimes.",
	"Method": "void setDateToBeFormatted(double date){\r\n    this.dateToBeFormatted = date;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOutlinePr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalRow.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTSignatureLine.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.nustaq.serialization.simpleapi.OffHeapCoder.toMemory",
	"Comment": "throws fstbuffertoosmallexception in case object does not fit into given range",
	"Method": "int toMemory(Object o,long address,int availableSize){\r\n    out.resetForReUse();\r\n    writeTarget.setBase(address, availableSize);\r\n    out.writeObject(o);\r\n    int written = out.getWritten();\r\n    return written;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotFields.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFileRecoveryPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.Messages.createMessage",
	"Comment": "creates a message from the specified key and replacementarguments, localized to the given locale.",
	"Method": "String createMessage(String msgKey,Object args){\r\n    if (m_resourceBundle == null)\r\n        m_resourceBundle = loadResourceBundle(m_resourceBundleName);\r\n    if (m_resourceBundle != null) {\r\n        return createMsg(m_resourceBundle, msgKey, args);\r\n    } else\r\n        return \"Could not load the resource bundles: \" + m_resourceBundleName;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.relationships.RelationshipsPart.unmarshal",
	"Comment": "unmarshal xml data from the specified inputstream and return the resulting content tree.validation event location information maybe incomplete when using this form of the unmarshal api.implements unmarshal global root element.",
	"Method": "Relationships unmarshal(java.io.InputStream is,Relationships unmarshal,org.w3c.dom.Element el){\r\n    try {\r\n        Unmarshaller u = jc.createUnmarshaller();\r\n        u.setEventHandler(new org.docx4j.jaxb.JaxbValidationEventHandler());\r\n        jaxbElement = (Relationships) u.unmarshal(el);\r\n    } catch (JAXBException e) {\r\n        log.error(e.getMessage(), e);\r\n        throw e;\r\n    }\r\n    resetIdAllocator();\r\n    return jaxbElement;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.Typeface.setEventListener",
	"Comment": "sets the font event listener that can be used to receive events about particular eventsin this class.",
	"Method": "void setEventListener(FontEventListener listener){\r\n    this.eventListener = listener;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOleSize.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTOnOff.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.URIHelper.relativizeURI",
	"Comment": "fully relativize the target part uri against the source part uri.",
	"Method": "URI relativizeURI(URI sourceURI,URI targetURI){\r\n    StringBuilder retVal = new StringBuilder();\r\n    String[] segmentsSource = sourceURI.getPath().split(\"/\", -1);\r\n    String[] segmentsTarget = targetURI.getPath().split(\"/\", -1);\r\n    if (segmentsSource.length == 0) {\r\n        throw new IllegalArgumentException(\"Can't relativize an empty source URI !\");\r\n    }\r\n    if (segmentsTarget.length == 0) {\r\n        throw new IllegalArgumentException(\"Can't relativize an empty target URI !\");\r\n    }\r\n    if (sourceURI.toString().equals(\"/\")) {\r\n        return targetURI;\r\n    }\r\n    int segmentsTheSame = 0;\r\n    for (int i = 0; i < segmentsSource.length && i < segmentsTarget.length; i++) {\r\n        if (segmentsSource[i].equals(segmentsTarget[i])) {\r\n            segmentsTheSame++;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    if ((segmentsTheSame == 0 || segmentsTheSame == 1) && segmentsSource[0].equals(\"\") && segmentsTarget[0].equals(\"\")) {\r\n        for (int i = 0; i < segmentsSource.length - 2; i++) {\r\n            retVal.append(\"../\");\r\n        }\r\n        for (int i = 0; i < segmentsTarget.length; i++) {\r\n            if (segmentsTarget[i].equals(\"\"))\r\n                continue;\r\n            retVal.append(segmentsTarget[i]);\r\n            if (i != segmentsTarget.length - 1)\r\n                retVal.append(\"/\");\r\n        }\r\n        try {\r\n            return new URI(retVal.toString());\r\n        } catch (Exception e) {\r\n            System.err.println(e);\r\n            return null;\r\n        }\r\n    }\r\n    if (segmentsTheSame == segmentsSource.length && segmentsTheSame == segmentsTarget.length) {\r\n        retVal.append(\"\");\r\n    } else {\r\n        if (segmentsTheSame == 1) {\r\n            retVal.append(\"/\");\r\n        } else {\r\n            for (int j = segmentsTheSame; j < segmentsSource.length - 1; j++) {\r\n                retVal.append(\"../\");\r\n            }\r\n        }\r\n        for (int j = segmentsTheSame; j < segmentsTarget.length; j++) {\r\n            if (retVal.length() > 0 && retVal.charAt(retVal.length() - 1) != '/') {\r\n                retVal.append(\"/\");\r\n            }\r\n            retVal.append(segmentsTarget[j]);\r\n        }\r\n    }\r\n    try {\r\n        return new URI(retVal.toString());\r\n    } catch (Exception e) {\r\n        System.err.println(e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomProperty.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTColor.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.topologi.diffx.Main.equivalent",
	"Comment": "returns true if the two specified readers are equivalent by looking at thesequence sax events reported an xml reader.",
	"Method": "boolean equivalent(File xml1,File xml2,boolean equivalent,InputStream xml1,InputStream xml2,boolean equivalent,Reader xml1,Reader xml2){\r\n    SAXRecorder recorder = new SAXRecorder();\r\n    EventSequence seq0 = recorder.process(new InputSource(xml1));\r\n    EventSequence seq1 = recorder.process(new InputSource(xml2));\r\n    return seq0.equals(seq1);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.util.IOUtils.copy",
	"Comment": "copies all the data from the given inputstream to the outputstream. itleaves both streams open, so you will still need to close them once done.",
	"Method": "void copy(InputStream inp,OutputStream out){\r\n    byte[] buff = new byte[4096];\r\n    int count;\r\n    while ((count = inp.read(buff)) != -1) {\r\n        if (count > 0) {\r\n            out.write(buff, 0, count);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTLang.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.BATBlock.createBATBlock",
	"Comment": "create a single batblock from the byte buffer, which must hold at least one big block of data to be read.",
	"Method": "BATBlock createBATBlock(POIFSBigBlockSize bigBlockSize,ByteBuffer data){\r\n    BATBlock block = new BATBlock(bigBlockSize);\r\n    byte[] buffer = new byte[LittleEndian.INT_SIZE];\r\n    for (int i = 0; i < block._values.length; i++) {\r\n        data.get(buffer);\r\n        block._values[i] = LittleEndian.getInt(buffer);\r\n    }\r\n    block.recomputeFree();\r\n    return block;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTQueryTableRefresh.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalSheetData.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalRow.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCommentList.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.model.fields.FormattingSwitchHelper.getFoPageNumberFormat",
	"Comment": "conversion of the word page number format to the fo page number format.",
	"Method": "String getFoPageNumberFormat(String wordName){\r\n    String ret = null;\r\n    if ((wordName != null) && (wordName.length() > 0)) {\r\n        ret = FORMAT_PAGE_TO_FO.get(wordName);\r\n        if (ret == null) {\r\n            ret = DEFAULT_FORMAT_PAGE_TO_FO;\r\n        } else if (ret == NONE_STRING) {\r\n            ret = null;\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getDoNotDisplayPageBoundaries",
	"Comment": "gets the value of the donotdisplaypageboundaries property.",
	"Method": "BooleanDefaultTrue getDoNotDisplayPageBoundaries(){\r\n    return doNotDisplayPageBoundaries;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTRel.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtDocPart.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableParts.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFFName.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.nustaq.serialization.FSTConfiguration.calcObjectSizeBytesNotAUtility",
	"Comment": "for optimization purposes, do not use to benchmark processing time or in a regular program asthis methods creates a temporary binaryoutputstream and serializes the object in order to measure thesize.",
	"Method": "int calcObjectSizeBytesNotAUtility(Object obj){\r\n    ByteArrayOutputStream bout = new ByteArrayOutputStream(10000);\r\n    FSTObjectOutput ou = new FSTObjectOutput(bout, this);\r\n    ou.writeObject(obj, obj.getClass());\r\n    ou.close();\r\n    return bout.toByteArray().length;\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.esc.XMLEscapeWriterASCII.doNothing",
	"Comment": "does nothing.this method exists so that we can explicitly say that we should do nothingin certain conditions.",
	"Method": "void doNothing(){\r\n    return;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.webextension_2010_11.CTWebExtensionPartRef.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTVolType.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDxf.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.NamedCharacter.getUnicodeSequence",
	"Comment": "returns the unicode sequence associated with this character.",
	"Method": "String getUnicodeSequence(){\r\n    return this.unicodeSequence;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalSheetNames.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSchema.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOutlinePr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTLine.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTView.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTProxy.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDdeItems.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode.getViewableIterator",
	"Comment": "get an iterator of objects, some of which may implementpoifsviewable",
	"Method": "Iterator<Object> getViewableIterator(){\r\n    List<Object> components = new ArrayList<Object>();\r\n    components.add(getProperty());\r\n    Iterator<Entry> iter = _entries.iterator();\r\n    while (iter.hasNext()) {\r\n        components.add(iter.next());\r\n    }\r\n    return components.iterator();\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.PresentationML.SlideLayoutPart.marshal",
	"Comment": "marshal the content tree rooted at jaxbelement into an output\tstream",
	"Method": "void marshal(java.io.OutputStream os,Object namespacePrefixMapper){\r\n    String xmlString = XmlUtils.marshaltoString(getJaxbElement(), false, true, jc);\r\n    int pos = xmlString.indexOf(\":sldLayout \");\r\n    int closeTagPos = xmlString.indexOf(\">\", pos);\r\n    if (xmlString.substring(pos, closeTagPos).contains(VML_DECL)) {\r\n    } else {\r\n        xmlString = xmlString.substring(0, pos + 11) + VML_DECL + \" \" + xmlString.substring(pos + 11);\r\n    }\r\n    try {\r\n        IOUtils.write(xmlString, os, \"UTF-8\");\r\n    } catch (IOException e) {\r\n        throw new JAXBException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalDefinedName.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetIdMap.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTIconFilter.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTString.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTRegroupTable.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocType.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTTwipsMeasure.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTXStringElement.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFormats.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTargetScreenSz.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSmartTagPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getDrawingGridVerticalOrigin",
	"Comment": "gets the value of the drawinggridverticalorigin property.",
	"Method": "CTTwipsMeasure getDrawingGridVerticalOrigin(){\r\n    return drawingGridVerticalOrigin;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadataBlock.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTQueryTableFields.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.agent.execution.services.impl.FetchingCacheServiceImplTests.directoryStructureExists",
	"Comment": "verify that all the files exist after a successful download.",
	"Method": "boolean directoryStructureExists(String resourceCacheId,long lastModifiedTimeStamp,FetchingCacheServiceImpl cacheService){\r\n    return cacheService.getCacheResourceVersionDataFile(resourceCacheId, lastModifiedTimeStamp).exists() && cacheService.getCacheResourceVersionLockFile(resourceCacheId, lastModifiedTimeStamp).exists() && !cacheService.getCacheResourceVersionDownloadFile(resourceCacheId, lastModifiedTimeStamp).exists();\r\n}"
}, {
	"Path": "org.docx4j.wml.ParaRPrChange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTShp.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMergeCells.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadataBlocks.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableStyle.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionQueryTableField.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.convert.out.common.writer.AbstractTableWriterModel.addCell",
	"Comment": "add a new cell to this table and copy processed content of\ttc to it.",
	"Method": "void addCell(Tc tc,Node content){\r\n    log.debug(\"Add tc row \" + row + \" col 1+\" + col);\r\n    addRow(new AbstractTableWriterModelCell(this, row, ++col, tc, content));\r\n    if (tc.getTcPr() != null && tc.getTcPr().getGridSpan() != null && tc.getTcPr().getGridSpan().getVal() != null) {\r\n        int gridSpan = tc.getTcPr().getGridSpan().getVal().intValue();\r\n        addDummyCell(gridSpan, false, false);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.relationships.RelationshipsPart.removePart",
	"Comment": "remove a part from this package, including its relationships\tpart and all target parts. do so recursively. \tif this part is relationship part, then\tdelete all relationships in the source part.",
	"Method": "List<PartName> removePart(PartName partName){\r\n    log.info(\"trying to removePart \" + partName.getName());\r\n    List<PartName> removedParts = new ArrayList<PartName>();\r\n    if (partName == null)\r\n        throw new IllegalArgumentException(\"partName was null\");\r\n    Part part = getPackage().getParts().get(partName);\r\n    if (part != null) {\r\n        removeRelationship(partName);\r\n        if (part.getRelationshipsPart() != null) {\r\n            // the recursive bit\r\n            removedParts.addAll(part.getRelationshipsPart().removeParts());\r\n        }\r\n        getPackage().getParts().remove(partName);\r\n        removedParts.add(partName);\r\n    }\r\n    return removedParts;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.DocumentInputStream.markSupported",
	"Comment": "tests if this input stream supports the mark and reset methods.",
	"Method": "boolean markSupported(){\r\n    return true;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataField.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.XMLUtils.getPoolsIndex",
	"Comment": "maps the two boolean configuration options for the factories to the array index for the weakobjectpool",
	"Method": "int getPoolsIndex(boolean validating,boolean disAllowDocTypeDeclarations){\r\n    return (validating ? 2 : 0) + (disAllowDocTypeDeclarations ? 1 : 0);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDimensions.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFieldsUsage.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFieldsUsage.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocParts.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.TTFFile.getWeightClass",
	"Comment": "returns the weight class of this font. valid values are 100, 200....,800, 900.",
	"Method": "int getWeightClass(){\r\n    return this.usWeightClass;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTUnderlineProperty.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotCacheRecords.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWebPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFunctionGroups.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPrintOptions.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTPPrDefault.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.Tr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.transformer.TransformerIdentityImpl.getParameter",
	"Comment": "get a parameter that was explicitly set with setparameteror setparameters.this method does not return a default parameter value, whichcannot be determined until the node context is evaluated duringthe transformation process.",
	"Method": "Object getParameter(String name){\r\n    if (null == m_params)\r\n        return null;\r\n    return m_params.get(name);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.DOM3TreeWalker.recordLocalNSDecl",
	"Comment": "records local namespace declarations, to be used for normalization later",
	"Method": "void recordLocalNSDecl(Node node){\r\n    NamedNodeMap atts = ((Element) node).getAttributes();\r\n    int length = atts.getLength();\r\n    for (int i = 0; i < length; i++) {\r\n        Node attr = atts.item(i);\r\n        String localName = attr.getLocalName();\r\n        String attrPrefix = attr.getPrefix();\r\n        String attrValue = attr.getNodeValue();\r\n        String attrNS = attr.getNamespaceURI();\r\n        localName = localName == null || XMLNS_PREFIX.equals(localName) ? \"\" : localName;\r\n        attrPrefix = attrPrefix == null ? \"\" : attrPrefix;\r\n        attrValue = attrValue == null ? \"\" : attrValue;\r\n        attrNS = attrNS == null ? \"\" : attrNS;\r\n        if (XMLNS_URI.equals(attrNS)) {\r\n            if (XMLNS_URI.equals(attrValue)) {\r\n                String msg = Utils.messages.createMessage(MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND, new Object[] { attrPrefix, XMLNS_URI });\r\n                if (fErrorHandler != null) {\r\n                    fErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_ERROR, msg, MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND, null, null, null));\r\n                }\r\n            } else {\r\n                if (XMLNS_PREFIX.equals(attrPrefix)) {\r\n                    if (attrValue.length() != 0) {\r\n                        fNSBinder.declarePrefix(localName, attrValue);\r\n                    } else {\r\n                    }\r\n                } else {\r\n                    fNSBinder.declarePrefix(\"\", attrValue);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomWorkbookViews.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.Br.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTStylisticSets.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtContentRun.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.model.datastorage.BindingTraverserXSLT.createPlaceholder",
	"Comment": "used from convertxhtml, since bind.xslt leaves it to extension function\tto insert correct element structure.",
	"Method": "DocumentFragment createPlaceholder(RPr rPr,DocumentFragment createPlaceholder,RPr rPr,String sdtParent){\r\n    if (placeholderFragment == null) {\r\n        createPlaceholderFragment();\r\n    }\r\n    if (placeholderBytes == null) {\r\n        createPlaceholderBytes();\r\n    }\r\n    if (sdtParent.equals(\"p\")) {\r\n        if (rPr == null) {\r\n            return placeholderFragment;\r\n        } else {\r\n            R run = (R) XmlUtils.unmarshal(new ByteArrayInputStream(placeholderBytes));\r\n            if (run.getRPr() == null) {\r\n                run.setRPr(new RPr());\r\n            }\r\n            StyleUtil.apply(rPr, run.getRPr());\r\n            Document tmpDoc = XmlUtils.marshaltoW3CDomDocument(run);\r\n            DocumentFragment docfrag = tmpDoc.createDocumentFragment();\r\n            XmlUtils.treeCopy(tmpDoc.getDocumentElement(), docfrag);\r\n            return docfrag;\r\n        }\r\n    } else {\r\n        R run = (R) XmlUtils.unmarshal(new ByteArrayInputStream(placeholderBytes));\r\n        run.setRPr(rPr);\r\n        Document tmpDoc = XmlUtils.marshaltoW3CDomDocument(run);\r\n        DocumentFragment docfrag = tmpDoc.createDocumentFragment();\r\n        if (sdtParent.equals(\"tbl\")) {\r\n            org.w3c.dom.Element wtr = tmpDoc.createElementNS(Namespaces.NS_WORD12, \"tr\");\r\n            docfrag.appendChild(wtr);\r\n            org.w3c.dom.Element wtc = tmpDoc.createElementNS(Namespaces.NS_WORD12, \"tc\");\r\n            wtr.appendChild(wtc);\r\n            org.w3c.dom.Element wp = tmpDoc.createElementNS(Namespaces.NS_WORD12, \"p\");\r\n            wtc.appendChild(wp);\r\n            wp.appendChild(tmpDoc.getDocumentElement());\r\n            return docfrag;\r\n        } else if (sdtParent.equals(\"tr\")) {\r\n            org.w3c.dom.Element wtc = tmpDoc.createElementNS(Namespaces.NS_WORD12, \"tc\");\r\n            docfrag.appendChild(wtc);\r\n            org.w3c.dom.Element wp = tmpDoc.createElementNS(Namespaces.NS_WORD12, \"p\");\r\n            wtc.appendChild(wp);\r\n            wp.appendChild(tmpDoc.getDocumentElement());\r\n            return docfrag;\r\n        } else if (sdtParent.equals(\"tc\") || sdtParent.equals(\"body\")) {\r\n            org.w3c.dom.Element wp = tmpDoc.createElementNS(Namespaces.NS_WORD12, \"p\");\r\n            docfrag.appendChild(wp);\r\n            wp.appendChild(tmpDoc.getDocumentElement());\r\n            return docfrag;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTAltChunkPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellProtection.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTSSup.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSimpleField.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableParts.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.HeaderBlock.setBATCount",
	"Comment": "sets the number of bat blocks that are used. this is the number used in both the bat and xbat.",
	"Method": "void setBATCount(int count){\r\n    _bat_count = count;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.BinaryPartAbstractImage.createImagePart",
	"Comment": "possibility to put directly an image filepath instead of giving an image byte array",
	"Method": "BinaryPartAbstractImage createImagePart(WordprocessingMLPackage wordMLPackage,byte[] bytes,BinaryPartAbstractImage createImagePart,WordprocessingMLPackage wordMLPackage,File imageFile,BinaryPartAbstractImage createImagePart,OpcPackage opcPackage,Part sourcePart,byte[] bytes,BinaryPartAbstractImage createImagePart,OpcPackage opcPackage,Part sourcePart,byte[] bytes,String mime,String ext,BinaryPartAbstractImage createImagePart,OpcPackage opcPackage,Part sourcePart,byte[] bytes,String mime,BinaryPartAbstractImage createImagePart,OpcPackage opcPackage,Part sourcePart,File imageFile){\r\n    final byte[] locByte = new byte[1];\r\n    ImageInfo info = ensureFormatIsSupported(imageFile, locByte, false);\r\n    ContentTypeManager ctm = opcPackage.getContentTypeManager();\r\n    if (sourcePart.getRelationshipsPart() == null) {\r\n        RelationshipsPart.createRelationshipsPartForPart(sourcePart);\r\n    }\r\n    String proposedRelId = sourcePart.getRelationshipsPart().getNextId();\r\n    String ext = info.getMimeType().substring(info.getMimeType().indexOf(\"/\") + 1);\r\n    BinaryPartAbstractImage imagePart = (BinaryPartAbstractImage) ctm.newPartForContentType(info.getMimeType(), createImageName(opcPackage, sourcePart, proposedRelId, ext), null);\r\n    log.debug(\"created part \" + imagePart.getClass().getName() + \" with name \" + imagePart.getPartName().toString());\r\n    FileInputStream fis = new FileInputStream(imageFile);\r\n    imagePart.setBinaryData(fis);\r\n    imagePart.rels.add(sourcePart.addTargetPart(imagePart, proposedRelId));\r\n    imagePart.setImageInfo(info);\r\n    return imagePart;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTCallout.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionCustomView.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTScene3D.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomWorkbookViews.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMap.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTRelation.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomSheetView.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTEndnotes.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTColFields.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblPrBase.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTColor.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTScript.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "me.weishu.epic.art.entry.Entry.constructArguments",
	"Comment": "construct the method arguments from register r1, r2, r3 and stack",
	"Method": "Pair<Object, Object[]> constructArguments(Epic.MethodInfo originMethodInfo,int self,byte[] r1,byte[] r2,byte[] r3,int sp){\r\n    boolean isStatic = originMethodInfo.isStatic;\r\n    int numberOfArgs;\r\n    Class<?>[] typeOfArgs;\r\n    if (isStatic) {\r\n        numberOfArgs = originMethodInfo.paramNumber;\r\n        typeOfArgs = originMethodInfo.paramTypes;\r\n    } else {\r\n        numberOfArgs = 1 + originMethodInfo.paramNumber;\r\n        typeOfArgs = new Class<?>[numberOfArgs];\r\n        typeOfArgs[0] = Object.class;\r\n        System.arraycopy(originMethodInfo.paramTypes, 0, typeOfArgs, 1, originMethodInfo.paramTypes.length);\r\n    }\r\n    Object[] arguments = new Object[numberOfArgs];\r\n    int currentStackPosition = 4;\r\n    final int argumentStackBegin = 16;\r\n    int[] argStartPos = new int[numberOfArgs];\r\n    for (int i = 0; i < numberOfArgs; i++) {\r\n        Class<?> typeOfArg = typeOfArgs[i];\r\n        int typeLength = getTypeLength(typeOfArg);\r\n        argStartPos[i] = currentStackPosition;\r\n        currentStackPosition += typeLength;\r\n    }\r\n    int argTotalLength = currentStackPosition;\r\n    byte[] argBytes = new byte[argTotalLength];\r\n    do {\r\n        if (argTotalLength <= 4)\r\n            break;\r\n        boolean align = Build.VERSION.SDK_INT >= 23 && numberOfArgs > 0 && getTypeLength(typeOfArgs[0]) == 8;\r\n        if (align) {\r\n            System.arraycopy(r2, 0, argBytes, 4, 4);\r\n            System.arraycopy(r3, 0, argBytes, 8, 4);\r\n            if (argTotalLength <= 12)\r\n                break;\r\n            System.arraycopy(EpicNative.get(sp + 12, 4), 0, argBytes, 12, 4);\r\n        } else {\r\n            System.arraycopy(r1, 0, argBytes, 4, 4);\r\n            if (argTotalLength <= 8)\r\n                break;\r\n            System.arraycopy(r2, 0, argBytes, 8, 4);\r\n            if (argTotalLength <= 12)\r\n                break;\r\n            System.arraycopy(r3, 0, argBytes, 12, 4);\r\n        }\r\n        if (argTotalLength <= 16)\r\n            break;\r\n        byte[] argInStack = EpicNative.get(sp + 16, argTotalLength - 16);\r\n        System.arraycopy(argInStack, 0, argBytes, 16, argTotalLength - 16);\r\n    } while (false);\r\n    if (Build.VERSION.SDK_INT == 23) {\r\n        if (argTotalLength <= 12) {\r\n        } else {\r\n            if (argTotalLength <= 16) {\r\n                if (getTypeLength(typeOfArgs[0]) == 8) {\r\n                    System.arraycopy(EpicNative.get(sp + 44, 4), 0, argBytes, 12, 4);\r\n                } else {\r\n                }\r\n            } else {\r\n                boolean isR3Grabbed = true;\r\n                if (numberOfArgs >= 2) {\r\n                    int arg1TypeLength = getTypeLength(typeOfArgs[0]);\r\n                    int arg2TypeLength = getTypeLength(typeOfArgs[1]);\r\n                    if (arg1TypeLength == 4 && arg2TypeLength == 8) {\r\n                        isR3Grabbed = false;\r\n                    }\r\n                    if (numberOfArgs == 2 && arg1TypeLength == 8 && arg2TypeLength == 8) {\r\n                        System.arraycopy(EpicNative.get(sp + 44, 4), 0, argBytes, 12, 4);\r\n                        isR3Grabbed = false;\r\n                    }\r\n                }\r\n                if (numberOfArgs >= 3) {\r\n                    int arg1TypeLength = getTypeLength(typeOfArgs[0]);\r\n                    int arg2TypeLength = getTypeLength(typeOfArgs[1]);\r\n                    int arg3TypeLength = getTypeLength(typeOfArgs[2]);\r\n                    if (arg1TypeLength == 4 && arg2TypeLength == 4 && arg3TypeLength == 4) {\r\n                        isR3Grabbed = false;\r\n                    }\r\n                    if (numberOfArgs == 3 && arg1TypeLength == 8 && arg2TypeLength == 4 && arg3TypeLength == 8) {\r\n                        System.arraycopy(EpicNative.get(sp + 52, 4), 0, argBytes, 12, 4);\r\n                        isR3Grabbed = false;\r\n                    }\r\n                }\r\n                if (isR3Grabbed) {\r\n                    byte[] otherStoreInStack = Arrays.copyOfRange(argBytes, argumentStackBegin, argBytes.length);\r\n                    int otherStoreInStackLength = otherStoreInStack.length;\r\n                    int searchRegion = 0;\r\n                    for (int i = argumentStackBegin + otherStoreInStackLength; ; i = i + 4) {\r\n                        final byte[] bytes = EpicNative.get(sp + i, otherStoreInStackLength);\r\n                        searchRegion += otherStoreInStackLength;\r\n                        if (Arrays.equals(bytes, otherStoreInStack)) {\r\n                            int originR3Index = sp + i - 4;\r\n                            final byte[] originR3 = EpicNative.get(originR3Index, 4);\r\n                            Logger.d(TAG, \"found other arguments in stack, index:\" + i + \", origin r3:\" + Arrays.toString(originR3));\r\n                            System.arraycopy(originR3, 0, argBytes, 12, 4);\r\n                            break;\r\n                        }\r\n                        if (searchRegion > (1 << 10)) {\r\n                            throw new RuntimeException(\"can not found the modify r3 register!!!\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Logger.d(TAG, \"argBytes: \" + Debug.hexdump(argBytes, 0));\r\n    for (int i = 0; i < numberOfArgs; i++) {\r\n        final Class<?> typeOfArg = typeOfArgs[i];\r\n        final int startPos = argStartPos[i];\r\n        final int typeLength = getTypeLength(typeOfArg);\r\n        byte[] argWithBytes = Arrays.copyOfRange(argBytes, startPos, startPos + typeLength);\r\n        arguments[i] = wrapArgument(typeOfArg, self, argWithBytes);\r\n    }\r\n    Object thiz = null;\r\n    Object[] parameters = EMPTY_OBJECT_ARRAY;\r\n    if (isStatic) {\r\n        parameters = arguments;\r\n    } else {\r\n        thiz = arguments[0];\r\n        int argumentLength = arguments.length;\r\n        if (argumentLength > 1) {\r\n            parameters = Arrays.copyOfRange(arguments, 1, argumentLength);\r\n        }\r\n    }\r\n    return Pair.create(thiz, parameters);\r\n}"
}, {
	"Path": "org.docx4j.wml.RunDel.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGroupLevels.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Sheet.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.wordprocessingDrawing.CTBorder.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.nustaq.offheap.structs.FSTStructAllocator.newStruct",
	"Comment": "allocate a struct instance from an arbitrary template instance.",
	"Method": "S newStruct(S aTemplate,S newStruct,S aTemplate,BytezAllocator alloc){\r\n    aTemplate = getFactory().toStruct(aTemplate);\r\n    if (aTemplate.getByteSize() >= chunkSize)\r\n        return (S) aTemplate.createCopy();\r\n    int byteSize = aTemplate.getByteSize();\r\n    synchronized (this) {\r\n        if (chunk == null || chunkIndex + byteSize >= chunk.length()) {\r\n            chunk = alloc.alloc(chunkSize);\r\n            if (DUMP_ALLOC)\r\n                System.out.println(\"[Allocator] sum allocated \" + MallocBytezAllocator.alloced.get() / 1024 / 1024 + \" MB\");\r\n            chunkIndex = 0;\r\n            chunkObjCount = 0;\r\n        }\r\n        aTemplate.___bytes.copyTo(chunk, chunkIndex, aTemplate.___offset, byteSize);\r\n        S res = (S) getFactory().createStructWrapper(chunk, chunkIndex);\r\n        chunkIndex += byteSize;\r\n        chunkObjCount++;\r\n        return res;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.MainDocumentPart.fontsInUse",
	"Comment": "traverse the document, looking for fonts which have been applied, eitherdirectly, or via a style.",
	"Method": "Set<String> fontsInUse(){\r\n    log.debug(\"fontsInUse..\");\r\n    getPropertyResolver();\r\n    Set<String> fontsDiscovered = new java.util.HashSet<String>();\r\n    org.docx4j.wml.Document wmlDocumentEl = (org.docx4j.wml.Document) this.getJaxbElement();\r\n    Body body = wmlDocumentEl.getBody();\r\n    List<Object> bodyChildren = body.getContent();\r\n    FontDiscoveryCharacterVisitor visitor = new FontDiscoveryCharacterVisitor(fontsDiscovered);\r\n    RunFontSelector runFontSelector = new RunFontSelector((WordprocessingMLPackage) this.pack, visitor, RunFontActionType.DISCOVERY);\r\n    FontAndStyleFinder finder = new FontAndStyleFinder(runFontSelector, fontsDiscovered, null);\r\n    finder.defaultCharacterStyle = this.getStyleDefinitionsPart().getDefaultCharacterStyle();\r\n    finder.defaultParagraphStyle = this.getStyleDefinitionsPart().getDefaultParagraphStyle();\r\n    finder.styleDefinitionsPart = this.getStyleDefinitionsPart();\r\n    new TraversalUtil(bodyChildren, finder);\r\n    fontsDiscovered.add(runFontSelector.getDefaultFont());\r\n    RelationshipsPart rp = this.getRelationshipsPart();\r\n    if (rp != null) {\r\n        for (Relationship r : rp.getRelationships().getRelationship()) {\r\n            Part part = rp.getPart(r);\r\n            if (part instanceof FooterPart) {\r\n                Ftr ftr = ((FooterPart) part).getJaxbElement();\r\n                finder.walkJAXBElements(ftr);\r\n            } else if (part instanceof HeaderPart) {\r\n                Hdr hdr = ((HeaderPart) part).getJaxbElement();\r\n                finder.walkJAXBElements(hdr);\r\n            }\r\n        }\r\n    }\r\n    if (this.getEndNotesPart() != null) {\r\n        log.debug(\"Looking at endnotes\");\r\n        CTEndnotes endnotes = this.getEndNotesPart().getJaxbElement();\r\n        finder.walkJAXBElements(endnotes);\r\n    }\r\n    if (this.getFootnotesPart() != null) {\r\n        log.debug(\"Looking at footnotes\");\r\n        CTFootnotes footnotes = this.getFootnotesPart().getJaxbElement();\r\n        finder.walkJAXBElements(footnotes);\r\n    }\r\n    if (this.getCommentsPart() != null) {\r\n        log.debug(\"Looking at comments\");\r\n        Comments comments = this.getCommentsPart().getJaxbElement();\r\n        finder.walkJAXBElements(comments);\r\n    }\r\n    if (getNumberingDefinitionsPart() != null) {\r\n        Numbering numbering = getNumberingDefinitionsPart().getJaxbElement();\r\n        for (Numbering.AbstractNum abstractNumNode : numbering.getAbstractNum()) {\r\n            for (Lvl lvl : abstractNumNode.getLvl()) {\r\n                if (lvl.getRPr() != null && lvl.getRPr().getRFonts() != null) {\r\n                    String fontName = lvl.getRPr().getRFonts().getAscii();\r\n                    if (fontName != null) {\r\n                        fontsDiscovered.add(fontName);\r\n                        log.debug(\"Registered \" + fontName + \" for abstract list \" + abstractNumNode.getAbstractNumId() + \" lvl \" + lvl.getIlvl());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        for (String fontName : fontsDiscovered) {\r\n            log.debug(fontName);\r\n        }\r\n    }\r\n    return fontsDiscovered;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTLinearShadeProperties.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOleItem.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.netflix.genie.agent.cli.JobRequestConverter.agentJobRequestArgsToDTO",
	"Comment": "convert job request arguments into an agentjobrequest object.",
	"Method": "AgentJobRequest agentJobRequestArgsToDTO(ArgumentDelegates.JobRequestArguments jobRequestArguments){\r\n    final ExecutionResourceCriteria criteria = new ExecutionResourceCriteria(jobRequestArguments.getClusterCriteria(), jobRequestArguments.getCommandCriterion(), jobRequestArguments.getApplicationIds());\r\n    final String jobVersion = jobRequestArguments.getJobVersion();\r\n    final JobMetadata.Builder jobMetadataBuilder;\r\n    if (StringUtils.isBlank(jobVersion)) {\r\n        jobMetadataBuilder = new JobMetadata.Builder(jobRequestArguments.getJobName(), jobRequestArguments.getUser());\r\n    } else {\r\n        jobMetadataBuilder = new JobMetadata.Builder(jobRequestArguments.getJobName(), jobRequestArguments.getUser(), jobVersion);\r\n    }\r\n    jobMetadataBuilder.withEmail(jobRequestArguments.getEmail()).withGrouping(jobRequestArguments.getGrouping()).withGroupingInstance(jobRequestArguments.getGroupingInstance()).withMetadata(jobRequestArguments.getJobMetadata()).withDescription(jobRequestArguments.getJobDescription()).withTags(jobRequestArguments.getJobTags()).build();\r\n    final AgentConfigRequest requestedAgentConfig = new AgentConfigRequest.Builder().withRequestedJobDirectoryLocation(jobRequestArguments.getJobDirectoryLocation()).withTimeoutRequested(jobRequestArguments.getTimeout()).withInteractive(jobRequestArguments.isInteractive()).build();\r\n    final JobArchivalDataRequest jobArchivalDataRequest = new JobArchivalDataRequest.Builder().withRequestedArchiveLocationPrefix(jobRequestArguments.getArchiveLocationPrefix()).build();\r\n    final AgentJobRequest agentJobRequest = new AgentJobRequest.Builder(jobMetadataBuilder.build(), criteria, requestedAgentConfig, jobArchivalDataRequest).withCommandArgs(jobRequestArguments.getCommandArguments()).withRequestedId(jobRequestArguments.getJobId()).build();\r\n    final Set<ConstraintViolation<AgentJobRequest>> violations = this.validator.validate(agentJobRequest);\r\n    if (!violations.isEmpty()) {\r\n        throw new ConversionException(violations);\r\n    }\r\n    return agentJobRequest;\r\n}"
}, {
	"Path": "com.topologi.diffx.sequence.EventSequence.setEvent",
	"Comment": "replaces an event of this sequence at the specified position.",
	"Method": "DiffXEvent setEvent(int index,DiffXEvent e){\r\n    return (DiffXEvent) this.sequence.set(index, e);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTShd.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.topologi.diffx.load.text.TokenizerUtils.getTrailingWhiteSpace",
	"Comment": "returns the length in characters of the trailing white spaces in the given char sequence.",
	"Method": "int getTrailingWhiteSpace(CharSequence s){\r\n    int i = 0;\r\n    if (s.length() == 0)\r\n        return 0;\r\n    char c = s.charAt(s.length() - 1 - i);\r\n    while (c == ' ' || c == '\\t' || c == '\\n') {\r\n        i++;\r\n        if (i == s.length()) {\r\n            break;\r\n        }\r\n        c = s.charAt(s.length() - 1 - i);\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSFileSystem.createBlockIfNeeded",
	"Comment": "load the block at the given offset,extending the file if needed",
	"Method": "ByteBuffer createBlockIfNeeded(int offset){\r\n    try {\r\n        return getBlockAt(offset);\r\n    } catch (IndexOutOfBoundsException e) {\r\n        long startAt = (offset + 1) * bigBlockSize.getBigBlockSize();\r\n        ByteBuffer buffer = ByteBuffer.allocate(getBigBlockSize());\r\n        _data.write(buffer, startAt);\r\n        return getBlockAt(offset);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.vml.CTImageData.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.Tabs.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTMcd.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getAllowSpaceOfSameStyleInTable",
	"Comment": "gets the value of the allowspaceofsamestyleintable property.",
	"Method": "BooleanDefaultTrue getAllowSpaceOfSameStyleInTable(){\r\n    return allowSpaceOfSameStyleInTable;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataBinding.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToStream.setOutputStream",
	"Comment": "specifies an output stream to which the document should beserialized. this method should not be called while theserializer is in the process of serializing a document.the encoding specified in the output properties is used, orif no encoding was specified, the default for the selectedoutput method.",
	"Method": "void setOutputStream(OutputStream output){\r\n    setOutputStreamInternal(output, true);\r\n}"
}, {
	"Path": "org.eclipse.compare.rangedifferencer.DifferencesIterator.other",
	"Comment": "difference iterators are used in pairs. this method returns the otheriterator.",
	"Method": "DifferencesIterator other(DifferencesIterator right,DifferencesIterator left){\r\n    if (this == right)\r\n        return left;\r\n    return right;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSmartTagType.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTGlow.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTVolTypes.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTextFields.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToHTMLStream.makeHHString",
	"Comment": "make an integer into an hh hex value.does no checking on the size of the input, since this is only meant to be used locally by writeattruri.",
	"Method": "String makeHHString(int i){\r\n    String s = Integer.toHexString(i).toUpperCase();\r\n    if (s.length() == 1) {\r\n        s = \"0\" + s;\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTProps3D.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.transformer.TransformerIdentityImpl.setResult",
	"Comment": "enables the user of the transformerhandler to set theto set the result for the transformation.",
	"Method": "void setResult(Result result){\r\n    if (null == result)\r\n        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_RESULT_NULL, null));\r\n    m_result = result;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTBevel.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setAllowSpaceOfSameStyleInTable",
	"Comment": "sets the value of the allowspaceofsamestyleintable property.",
	"Method": "void setAllowSpaceOfSameStyleInTable(BooleanDefaultTrue value){\r\n    this.allowSpaceOfSameStyleInTable = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCfRule.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.Text.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.FontReader.setFontEmbedPath",
	"Comment": "sets the path to embed a font. a null value disables font embedding.",
	"Method": "void setFontEmbedPath(String path){\r\n    returnFont.setEmbedFileName(path);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTAutoFilter.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCalculatedMember.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.client.BaseGenieClient.getIdFromLocation",
	"Comment": "helper method to parse the id out of the location string in the header.",
	"Method": "String getIdFromLocation(String location){\r\n    return location.substring(location.lastIndexOf(\"/\") + 1);\r\n}"
}, {
	"Path": "org.docx4j.dml.CTBlip.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTObjectPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setDrawingGridVerticalSpacing",
	"Comment": "sets the value of the drawinggridverticalspacing property.",
	"Method": "void setDrawingGridVerticalSpacing(CTTwipsMeasure value){\r\n    this.drawingGridVerticalSpacing = value;\r\n}"
}, {
	"Path": "com.netflix.genie.agent.execution.services.impl.FetchingCacheServiceImpl.cleanUpOlderResourceVersions",
	"Comment": "clean up all resources older than the latest version of a resource.",
	"Method": "void cleanUpOlderResourceVersions(String resourceCacheId,long lastDownloadedResourceModifiedTimestamp){\r\n    final File[] files = getCacheResourceDir(resourceCacheId).listFiles();\r\n    if (files != null) {\r\n        for (File file : files) {\r\n            long resourceLastModified = 0;\r\n            try {\r\n                resourceLastModified = getResourceLastModified(file);\r\n                if (resourceLastModified < lastDownloadedResourceModifiedTimestamp) {\r\n                    cleanUpResourceVersion(file);\r\n                }\r\n            } catch (NumberFormatException e) {\r\n                log.warn(\"Encountered a dir name which is not long. Ignoring dir - {}\", resourceLastModified, e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetPr.isEnableFormatConditionsCalculation",
	"Comment": "gets the value of the enableformatconditionscalculation property.",
	"Method": "boolean isEnableFormatConditionsCalculation(){\r\n    if (enableFormatConditionsCalculation == null) {\r\n        return true;\r\n    } else {\r\n        return enableFormatConditionsCalculation;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPartCategory.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerTraceWriter.setBufferSize",
	"Comment": "creates or replaces the internal buffer, and makes sure it has a fewextra bytes slight overflow of the last utf8 encoded character.",
	"Method": "void setBufferSize(int size){\r\n    buf = new byte[size + 3];\r\n    buf_length = size;\r\n    count = 0;\r\n}"
}, {
	"Path": "org.apache.ws.commons.serialize.DOMSerializer.serialize",
	"Comment": "converts the given node pnode into a\tstream of sax events, which are fired into the\tcontent handler phandler.",
	"Method": "void serialize(Node pNode,ContentHandler pHandler){\r\n    if (!isNamespaceDeclarationAttribute() && !isParentsNamespaceDeclarationDisabled()) {\r\n        parentsStartPrefixMappingEvents(pNode.getParentNode(), pHandler);\r\n    }\r\n    doSerialize(pNode, pHandler);\r\n    if (!isNamespaceDeclarationAttribute() && !isParentsNamespaceDeclarationDisabled()) {\r\n        parentsEndPrefixMappingEvents(pNode.getParentNode(), pHandler);\r\n    }\r\n}"
}, {
	"Path": "com.topologi.diffx.sequence.PrefixMapping.getURIs",
	"Comment": "returns an enumeration of the namespace uris used in this mapping.",
	"Method": "Enumeration<String> getURIs(){\r\n    return Collections.enumeration(this.mappings.keySet());\r\n}"
}, {
	"Path": "org.docx4j.model.listnumbering.Emulator.getNumber",
	"Comment": "get the computed list number for the given list at this point in thedocument.",
	"Method": "ResultTriple getNumber(WordprocessingMLPackage wmlPackage,PPr pPr,ResultTriple getNumber,WordprocessingMLPackage wmlPackage,String pStyleVal,String numId,String levelId){\r\n    org.docx4j.openpackaging.parts.WordprocessingML.NumberingDefinitionsPart numberingPart = wmlPackage.getMainDocumentPart().getNumberingDefinitionsPart();\r\n    if (numberingPart == null) {\r\n        return null;\r\n    }\r\n    Emulator em = numberingPart.getEmulator();\r\n    ResultTriple triple = em.new ResultTriple();\r\n    org.docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart stylesPart = wmlPackage.getMainDocumentPart().getStyleDefinitionsPart();\r\n    PropertyResolver propertyResolver = wmlPackage.getMainDocumentPart().getPropertyResolver();\r\n    if (numId == null || numId.equals(\"\")) {\r\n        org.docx4j.wml.Style style = null;\r\n        if (pStyleVal == null || pStyleVal.equals(\"\")) {\r\n            log.debug(\"no explicit numId; no style either\");\r\n            return null;\r\n        }\r\n        log.debug(\"no explicit numId; looking in styles\");\r\n        PPr ppr = propertyResolver.getEffectivePPr(pStyleVal);\r\n        if (ppr == null) {\r\n            log.debug(\"Style '\" + pStyleVal + \"' has no pPr\");\r\n            return null;\r\n        }\r\n        NumPr numPr = ppr.getNumPr();\r\n        if (numPr == null) {\r\n            log.debug(\"Couldn't get NumPr from \" + pStyleVal);\r\n            return null;\r\n        }\r\n        if (numPr.getNumId() == null) {\r\n            log.error(\"numId was null!\");\r\n            return null;\r\n        }\r\n        numId = numPr.getNumId().getVal().toString();\r\n        if (numId.equals(\"\")) {\r\n            log.error(\"numId was empty!\");\r\n            return null;\r\n        }\r\n        if (levelId == null || levelId.equals(\"\")) {\r\n            if (numPr.getIlvl() != null) {\r\n                levelId = numPr.getIlvl().getVal().toString();\r\n                log.info(\"levelId=\" + levelId + \" (from style)\");\r\n            } else {\r\n                levelId = \"0\";\r\n            }\r\n        }\r\n    }\r\n    log.debug(\"Using numId: \" + numId);\r\n    if (levelId == null || levelId.equals(\"\")) {\r\n        log.warn(\"No level id?! Default to 0.\");\r\n        levelId = \"0\";\r\n    }\r\n    if (numberingPart.getInstanceListDefinitions().containsKey(numId) && numberingPart.getInstanceListDefinitions().get(numId).LevelExists(levelId)) {\r\n        numberingPart.getInstanceListDefinitions().get(numId).IncrementCounter(levelId);\r\n        triple.numString = numberingPart.getInstanceListDefinitions().get(numId).GetCurrentNumberString(levelId);\r\n        log.debug(\"Got number: \" + triple.numString);\r\n        String font = numberingPart.getInstanceListDefinitions().get(numId).GetFont(levelId);\r\n        if (font != null && !font.equals(\"\")) {\r\n            triple.numFont = font;\r\n        }\r\n        if (numberingPart.getInstanceListDefinitions().get(numId).IsBullet(levelId)) {\r\n            triple.bullet = numberingPart.getInstanceListDefinitions().get(numId).getLevel(levelId).getLevelText();\r\n        }\r\n        triple.lvl = numberingPart.getInstanceListDefinitions().get(numId).getLevel(levelId).getJaxbAbstractLvl();\r\n        PPr ppr = triple.getLvl().getPPr();\r\n        if (ppr != null) {\r\n            triple.ind = ppr.getInd();\r\n        }\r\n        triple.rPr = triple.getLvl().getRPr();\r\n    } else if (!numberingPart.getInstanceListDefinitions().containsKey(numId)) {\r\n        if (numId.equals(\"0\")) {\r\n            log.debug(\"Couldn't find list \" + numId);\r\n        } else {\r\n            log.warn(\"Couldn't find list \" + numId);\r\n        }\r\n    } else if (!numberingPart.getInstanceListDefinitions().get(numId).LevelExists(levelId)) {\r\n        log.error(\"Couldn't find level \" + levelId + \" in list \" + numId);\r\n    }\r\n    return triple;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.type1.PFMFile.getLastChar",
	"Comment": "returns the number of the character that definesthe last entry in the widths list.",
	"Method": "short getLastChar(){\r\n    return dfLastChar;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getDoNotSuppressParagraphBorders",
	"Comment": "gets the value of the donotsuppressparagraphborders property.",
	"Method": "BooleanDefaultTrue getDoNotSuppressParagraphBorders(){\r\n    return doNotSuppressParagraphBorders;\r\n}"
}, {
	"Path": "com.netflix.genie.agent.execution.services.impl.FetchingCacheServiceImpl.cleanUpResourceVersion",
	"Comment": "delete a resource version directory after taking appropriate lock.",
	"Method": "void cleanUpResourceVersion(File resourceVersionDir){\r\n    try (final CloseableLock lock = fileLockFactory.getLock(touchCacheResourceVersionLockFile(resourceVersionDir))) {\r\n        lock.lock();\r\n        FileSystemUtils.deleteRecursively(getCacheResourceVersionDataFile(resourceVersionDir));\r\n        FileSystemUtils.deleteRecursively(getCacheResourceVersionDownloadFile(resourceVersionDir));\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.w14.CTPercentage.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRangeSet.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTSdtCheckboxSymbol.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.graph.util.GraphQueryUtil.getNodeCount",
	"Comment": "execute a query with the number of nodes group matching the query.with the option to specify bind parameters.",
	"Method": "int getNodeCount(String query,GraphDatabaseService db,int getNodeCount,String query,Map<String, Object> params,GraphDatabaseService db){\r\n    Result resNodes = db.execute(query, params);\r\n    int count = 0;\r\n    for (Map<String, Object> node : iterable(resNodes)) {\r\n        count++;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.SerializerTraceWriter.getOutputStream",
	"Comment": "get the outputstream that is the at the end of thechain of writers.",
	"Method": "OutputStream getOutputStream(){\r\n    OutputStream retval = null;\r\n    if (m_writer instanceof WriterChain)\r\n        retval = ((WriterChain) m_writer).getOutputStream();\r\n    return retval;\r\n}"
}, {
	"Path": "org.xlsx4j.schemas.microsoft.com.office.excel_2008_2.main.CTDefinedNames.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomFilter.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.FontInfo.setEventListener",
	"Comment": "sets the font event listener that can be used to receive events about particular eventsin this class.",
	"Method": "void setEventListener(FontEventListener listener){\r\n    this.eventListener = listener;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtContentCell.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.LSSerializerImpl.getPathWithoutEscapes",
	"Comment": "replaces all escape sequences in the given path with their literal characters.",
	"Method": "String getPathWithoutEscapes(String origPath){\r\n    if (origPath != null && origPath.length() != 0 && origPath.indexOf('%') != -1) {\r\n        StringTokenizer tokenizer = new StringTokenizer(origPath, \"%\");\r\n        StringBuffer result = new StringBuffer(origPath.length());\r\n        int size = tokenizer.countTokens();\r\n        result.append(tokenizer.nextToken());\r\n        for (int i = 1; i < size; ++i) {\r\n            String token = tokenizer.nextToken();\r\n            if (token.length() >= 2 && isHexDigit(token.charAt(0)) && isHexDigit(token.charAt(1))) {\r\n                result.append((char) Integer.valueOf(token.substring(0, 2), 16).intValue());\r\n                token = token.substring(2);\r\n            }\r\n            result.append(token);\r\n        }\r\n        return result.toString();\r\n    }\r\n    return origPath;\r\n}"
}, {
	"Path": "com.topologi.diffx.sequence.PrefixMapping.getPrefix",
	"Comment": "returns the prefix corresponding to the given namespace uri.",
	"Method": "String getPrefix(String uri){\r\n    return uri == null ? \"\" : this.mappings.get(uri);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.webextension_2010_11.CTOsfWebExtensionBindingList.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.SdtRun.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMdxKPI.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.convert.out.common.AbstractWriterRegistry.createTransformStates",
	"Comment": "factory method to create the required transform states for the context",
	"Method": "Map<String, Writer.TransformState> createTransformStates(){\r\n    Map<String, Writer.TransformState> ret = new HashMap<String, Writer.TransformState>();\r\n    Writer.TransformState state = null;\r\n    for (Map.Entry<String, Writer> item : writerInstances.entrySet()) {\r\n        state = item.getValue().createTransformState();\r\n        if (state != null) {\r\n            ret.put(item.getKey(), state);\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCnf.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.Encodings.getHighChar",
	"Comment": "characters with values at or below the high code point arein the encoding. code point values above this one may or maynot be in the encoding, but lower ones certainly are.this is for performance.",
	"Method": "char getHighChar(String encoding){\r\n    final char highCodePoint;\r\n    EncodingInfo ei;\r\n    String normalizedEncoding = toUpperCaseFast(encoding);\r\n    ei = (EncodingInfo) _encodingTableKeyJava.get(normalizedEncoding);\r\n    if (ei == null)\r\n        ei = (EncodingInfo) _encodingTableKeyMime.get(normalizedEncoding);\r\n    if (ei != null)\r\n        highCodePoint = ei.getHighChar();\r\n    else\r\n        highCodePoint = 0;\r\n    return highCodePoint;\r\n}"
}, {
	"Path": "org.docx4j.fonts.BestMatchingMapper.populateFontMappings",
	"Comment": "populate the fontmappings object. we make an entry for each\tof the documentfontnames.",
	"Method": "void populateFontMappings(Set<String> documentFontNames,org.docx4j.wml.Fonts wmlFonts){\r\n    List<Fonts.Font> fontList = wmlFonts.getFont();\r\n    Map<String, Fonts.Font> fontsInFontTable = new HashMap<String, Fonts.Font>();\r\n    for (Fonts.Font font : fontList) {\r\n        fontsInFontTable.put((font.getName()), font);\r\n    }\r\n    log.info(\"\\n\\n Populating font mappings.\");\r\n    for (String documentFontName : documentFontNames) {\r\n        PhysicalFont fontMatched = null;\r\n        log.debug(\"\\n\\n\" + documentFontName);\r\n        if (get(documentFontName) != null) {\r\n            log.info(documentFontName + \" already mapped.\");\r\n            if (lastSeenNumberOfPhysicalFonts == PhysicalFonts.getPhysicalFonts().size()) {\r\n                log.info(\".. and no need to check again.\");\r\n                continue;\r\n            } else {\r\n                log.info(\".. but checking again, since physical fonts have changed.\");\r\n            }\r\n        }\r\n        if (regularForms.get(documentFontName) != null) {\r\n            put(documentFontName, regularForms.get(documentFontName));\r\n            log.debug(\".. mapped to embedded regular form \");\r\n            continue;\r\n        } else if (boldForms.get(documentFontName) != null) {\r\n            put(documentFontName, boldForms.get(documentFontName));\r\n            log.debug(\".. mapped to embedded bold form \");\r\n            continue;\r\n        } else if (italicForms.get(documentFontName) != null) {\r\n            put(documentFontName, italicForms.get(documentFontName));\r\n            log.debug(\".. mapped to embedded italic form \");\r\n            continue;\r\n        } else if (boldItalicForms.get(documentFontName) != null) {\r\n            put(documentFontName, boldItalicForms.get(documentFontName));\r\n            log.debug(\".. mapped to embedded bold italic form \");\r\n            continue;\r\n        }\r\n        org.docx4j.wml.FontPanose wmlFontPanoseForDocumentFont = null;\r\n        Fonts.Font font = fontsInFontTable.get(documentFontName);\r\n        if (font == null) {\r\n            log.error(\"Font \" + documentFontName + \"not found in font table!\");\r\n        } else {\r\n            wmlFontPanoseForDocumentFont = font.getPanose1();\r\n        }\r\n        org.docx4j.fonts.foray.font.format.Panose documentFontPanose = null;\r\n        if (wmlFontPanoseForDocumentFont != null && wmlFontPanoseForDocumentFont.getVal() != null) {\r\n            try {\r\n                documentFontPanose = org.docx4j.fonts.foray.font.format.Panose.makeInstance(wmlFontPanoseForDocumentFont.getVal());\r\n            } catch (IllegalArgumentException e) {\r\n                log.error(e.getMessage());\r\n            }\r\n            if (documentFontPanose != null) {\r\n                log.debug(\".. \" + documentFontPanose.toString());\r\n            }\r\n        } else {\r\n            log.debug(\".. no panose info!!!\");\r\n        }\r\n        if (documentFontPanose == null) {\r\n            log.debug(\" --> null Panose\");\r\n        } else {\r\n            if (log.isDebugEnabled() && org.docx4j.fonts.foray.font.format.Panose.validPanose(documentFontPanose.getPanoseArray()) != null) {\r\n                log.debug(documentFontName + \" : \" + org.docx4j.fonts.foray.font.format.Panose.validPanose(documentFontPanose.getPanoseArray()));\r\n            }\r\n            String panoseKey = findClosestPanoseMatch(documentFontName, documentFontPanose, PhysicalFonts.getPhysicalFonts(), MATCH_THRESHOLD);\r\n            if (panoseKey == null) {\r\n                log.debug(documentFontName + \" -->  no panose match\");\r\n            } else {\r\n                fontMatched = PhysicalFonts.getPhysicalFonts().get(panoseKey);\r\n                if (fontMatched != null) {\r\n                    put(documentFontName, PhysicalFonts.getPhysicalFonts().get(panoseKey));\r\n                    log.debug(\"Mapped \" + documentFontName + \" -->  \" + panoseKey + \"( \" + PhysicalFonts.getPhysicalFonts().get(panoseKey).getEmbeddedFile());\r\n                } else {\r\n                    log.debug(\"font with key \" + panoseKey + \" doesn't exist!\");\r\n                }\r\n                FontSubstitutions.Replace rtmp = (FontSubstitutions.Replace) explicitSubstitutionsMap.get(documentFontName);\r\n                if (rtmp != null && rtmp.getSubstFonts() != null) {\r\n                    if (rtmp.getSubstFonts().contains(panoseKey)) {\r\n                        log.debug(\"(consistent with explicit substitutes)\");\r\n                    } else {\r\n                        log.debug(\"(lucky, since this is missing from explicit substitutes)\");\r\n                    }\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n        log.debug(\"So try explicit font substitutions table\");\r\n        FontSubstitutions.Replace replacement = (FontSubstitutions.Replace) explicitSubstitutionsMap.get((generateFontKey(documentFontName)));\r\n        if (replacement != null) {\r\n            String[] tokens = StringUtils.stripAll(replacement.getSubstFonts().split(\";\"));\r\n            boolean foundMapping = false;\r\n            for (int x = 0; x < tokens.length; x++) {\r\n                fontMatched = getPhysicalFontByKey(tokens[x]);\r\n                if (fontMatched != null) {\r\n                    String physicalFontFile = fontMatched.getEmbeddedFile();\r\n                    log.debug(\"PDF: \" + documentFontName + \" --> \" + physicalFontFile);\r\n                    foundMapping = true;\r\n                    if (fontMatched.getPanose() == null) {\r\n                        log.debug(\".. as expected, lacking Panose\");\r\n                    } else if (documentFontPanose != null) {\r\n                        org.docx4j.fonts.foray.font.format.Panose physicalFontPanose = null;\r\n                        try {\r\n                            physicalFontPanose = org.docx4j.fonts.foray.font.format.Panose.makeInstance(fontMatched.getPanose().getPanoseArray());\r\n                        } catch (IllegalArgumentException e) {\r\n                            log.error(e.getMessage());\r\n                        }\r\n                        if (physicalFontPanose != null) {\r\n                            long pd = documentFontPanose.difference(physicalFontPanose, null);\r\n                            if (pd >= MATCH_THRESHOLD) {\r\n                                log.debug(\".. with a panose distance exceeding threshold: \" + pd);\r\n                            } else {\r\n                                log.error(\".. with a low panose distance (! How did we get here?) : \" + pd);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                } else {\r\n                }\r\n            }\r\n            if (!foundMapping) {\r\n                log.debug(documentFontName + \" -->  Couldn't find any of \" + replacement.getSubstFonts());\r\n            }\r\n        } else {\r\n            log.debug(\"Nothing in FontSubstitutions.xml for: \" + documentFontName);\r\n        }\r\n        if (fontMatched != null) {\r\n            put(documentFontName, fontMatched);\r\n            log.warn(\"Mapped \" + documentFontName + \" -->  \" + fontMatched.getName() + \"( \" + fontMatched.getEmbeddedFile());\r\n        } else {\r\n            log.debug(\"Nothing added for: \" + documentFontName);\r\n        }\r\n    }\r\n    lastSeenNumberOfPhysicalFonts = PhysicalFonts.getPhysicalFonts().size();\r\n}"
}, {
	"Path": "org.docx4j.wml.CTParaRPrOriginal.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.ValuedEnum.toString",
	"Comment": "override tostring method to produce human readable description.",
	"Method": "String toString(){\r\n    return getClass().getName() + \"[\" + getName() + \"=\" + m_value + \"]\";\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setBalanceSingleByteDoubleByteWidth",
	"Comment": "sets the value of the balancesinglebytedoublebytewidth property.",
	"Method": "void setBalanceSingleByteDoubleByteWidth(BooleanDefaultTrue value){\r\n    this.balanceSingleByteDoubleByteWidth = value;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTFillTextEffect.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFramePr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.property.Property.setStartBlock",
	"Comment": "set the start block for the document referred to by thisproperty.",
	"Method": "void setStartBlock(int startBlock){\r\n    _start_block.set(startBlock, _raw_data);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotArea.isCollapsedLevelsAreSubtotals",
	"Comment": "gets the value of the collapsedlevelsaresubtotals property.",
	"Method": "boolean isCollapsedLevelsAreSubtotals(){\r\n    if (collapsedLevelsAreSubtotals == null) {\r\n        return false;\r\n    } else {\r\n        return collapsedLevelsAreSubtotals;\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTVerticalAlignFontProperty.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.util.HexDump.toHex",
	"Comment": "converts the parameter to a hex value breaking the results intolines.",
	"Method": "String toHex(byte[] value,String toHex,short[] value,String toHex,byte[] value,int bytesPerLine,String toHex,short value,String toHex,byte value,String toHex,int value,String toHex,long value,String toHex,long value,int digits){\r\n    StringBuffer result = new StringBuffer(digits);\r\n    for (int j = 0; j < digits; j++) {\r\n        result.append(_hexcodes[(int) ((value >> _shifts[j + (16 - digits)]) & 15)]);\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFFData.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTMC.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFootnotes.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTOnOff.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTManualBreak.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTPositivePercentage.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOlapPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTGuid.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDbPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTNumForm.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalCell.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTI.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.presentationDrawing.CTRel.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTCamera.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSchema.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTProof.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblOverlap.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDiv.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.agent.execution.services.impl.FetchingCacheServiceImpl.getResourceLastModified",
	"Comment": "helper to extract the resource last modified timestamp from the resourceversion directory handle.",
	"Method": "long getResourceLastModified(File resourceVersionDir){\r\n    return Long.parseLong(resourceVersionDir.getName());\r\n}"
}, {
	"Path": "org.docx4j.wml.TextDirection.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSmartTagType.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMap.setShowImportExportValidationErrors",
	"Comment": "sets the value of the showimportexportvalidationerrors property.",
	"Method": "void setShowImportExportValidationErrors(boolean value){\r\n    this.showImportExportValidationErrors = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTScenario.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTParaRPrOriginal.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTAutoSortScope.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWebPublishItems.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Sheets.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCacheHierarchy.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getDisplayVerticalDrawingGridEvery",
	"Comment": "gets the value of the displayverticaldrawinggridevery property.",
	"Method": "CTSettings.DisplayVerticalDrawingGridEvery getDisplayVerticalDrawingGridEvery(){\r\n    return displayVerticalDrawingGridEvery;\r\n}"
}, {
	"Path": "org.docx4j.wml.Text.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFileSharing.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomChartsheetView.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFrameScrollbar.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionConflict.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTRelationTable.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTextScale.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellStyles.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTScenarios.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTAutoCaptions.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionCustomView.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocProtect.getCryptProviderTypeExtSource",
	"Comment": "gets the value of the cryptprovidertypeextsource property.",
	"Method": "String getCryptProviderTypeExtSource(){\r\n    return cryptProviderTypeExtSource;\r\n}"
}, {
	"Path": "org.docx4j.wml.Document.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFormats.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.agent.execution.services.impl.FetchingCacheServiceImpl.getCacheResourceVersionDataFile",
	"Comment": "returns a handle to the data file of a resource version in the cache",
	"Method": "File getCacheResourceVersionDataFile(String resourceCacheId,long lastModifiedTimestamp,File getCacheResourceVersionDataFile,File resourceVersionDir){\r\n    return new File(resourceVersionDir, DATA_FILE_NAME);\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.DocPropsCorePart.unmarshal",
	"Comment": "unmarshal xml data from the specified inputstream and return the resulting content tree.validation event location information maybe incomplete when using this form of the unmarshal api.implements unmarshal global root element.",
	"Method": "CoreProperties unmarshal(java.io.InputStream is){\r\n    try {\r\n        XMLInputFactory xif = XMLInputFactory.newInstance();\r\n        xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\r\n        xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);\r\n        XMLStreamReader xsr = xif.createXMLStreamReader(is);\r\n        setJAXBContext(org.docx4j.jaxb.Context.jcDocPropsCore);\r\n        Unmarshaller u = jc.createUnmarshaller();\r\n        u.setEventHandler(new org.docx4j.jaxb.JaxbValidationEventHandler());\r\n        log.info(\"unmarshalling \" + this.getClass().getName());\r\n        jaxbElement = (CoreProperties) u.unmarshal(xsr);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n    return jaxbElement;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotFilters.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.webextension_2010_11.CTOsfWebExtensionProperty.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTF.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRgbColor.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblStylePr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCommentList.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTxbxContent.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableStyleInfo.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToHTMLStream.processAttributes",
	"Comment": "process the attributes, which means to write out the currentlycollected attributes to the writer. the attributes are notcleared by this method",
	"Method": "void processAttributes(java.io.Writer writer,int nAttrs){\r\n    for (int i = 0; i < nAttrs; i++) {\r\n        processAttribute(writer, m_attributes.getQName(i), m_attributes.getValue(i), m_elemContext.m_elementDesc);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.XML11Char.isXML11Content",
	"Comment": "returns true if the specified character can be considered content in an external parsed entity.",
	"Method": "boolean isXML11Content(int c){\r\n    return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_CONTENT) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "com.netflix.genie.agent.execution.statemachine.StateMachineAutoConfiguration.statesWithErrorTransition",
	"Comment": "provide a bean with a collection of states which should have transitions to an error action when an error occurs.",
	"Method": "Collection<States> statesWithErrorTransition(){\r\n    return EnumSet.of(States.INITIALIZE, States.CONFIGURE_AGENT, States.RESOLVE_JOB_SPECIFICATION, States.SETUP_JOB, States.LAUNCH_JOB, States.MONITOR_JOB, States.CLEANUP_JOB, States.SHUTDOWN);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocType.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "testcode.sqli.stringbuilder.StringBuilderSuspicious.queryUnknownTransformation",
	"Comment": "i think this should be reported with low priority only, everything visible is constant",
	"Method": "UserEntity queryUnknownTransformation(String username,String onlyActive){\r\n    StringBuilder sql = new StringBuilder(\"select * from Users where name = usernameParam\");\r\n    sql.append(\" and active = true\");\r\n    modifyMe(sql);\r\n    return em.createQuery(sql.toString(), UserEntity.class).setParameter(\"usernameParam\", username).getSingleResult();\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.transformer.SerializerSwitcher.getOutputPropertyNoDefault",
	"Comment": "get the value of a property, without using the default properties.this can be used to test if a property has been explicitly set by the stylesheet or user.",
	"Method": "String getOutputPropertyNoDefault(String qnameString,Properties props){\r\n    String value = (String) props.get(qnameString);\r\n    return value;\r\n}"
}, {
	"Path": "org.docx4j.wml.RStyle.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTWriteProtection.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.EncodingInfo.isInEncoding",
	"Comment": "this is not a public api. it returns true if thechar in question is in the encoding.",
	"Method": "boolean isInEncoding(char ch,boolean isInEncoding,char high,char low,boolean isInEncoding,char ch,boolean isInEncoding,char high,char low,boolean isInEncoding,char ch1,boolean isInEncoding,char high,char low){\r\n    if (m_encoding == null) {\r\n        m_encoding = new EncodingImpl();\r\n    }\r\n    return m_encoding.isInEncoding(high, low);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTBorders.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "testcasesupport.AbstractTestCaseServletBase.runTestSolo",
	"Comment": "this method runs a test on its own, creating a full html documentit is called from doget and dopost in this file",
	"Method": "void runTestSolo(HttpServletRequest request,HttpServletResponse response){\r\n    response.getWriter().println(\"<html><body>\");\r\n    runTest(request, response);\r\n    response.getWriter().println(\"<\/body><\/html>\");\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.Encodings.isLowUTF16Surrogate",
	"Comment": "return true if the character is the low member of a surrogate pair.this is not a public api.",
	"Method": "boolean isLowUTF16Surrogate(char ch){\r\n    return ('?' <= ch && ch <= '?');\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.WordprocessingML.OleObjectBinaryPart.displayDirectory",
	"Comment": "adapted from org.docx4j.org.apache.poi.poifs.dev.poifslister",
	"Method": "void displayDirectory(DirectoryNode dir,OutputStream os,String indent,boolean withSizes){\r\n    System.out.println(indent + dir.getName() + \" -\");\r\n    String newIndent = indent + \"  \";\r\n    boolean hadChildren = false;\r\n    for (Iterator<Entry> it = dir.getEntries(); it.hasNext(); ) {\r\n        hadChildren = true;\r\n        Entry entry = it.next();\r\n        if (entry instanceof DirectoryNode) {\r\n            displayDirectory((DirectoryNode) entry, os, newIndent, withSizes);\r\n        } else {\r\n            DocumentNode doc = (DocumentNode) entry;\r\n            String name = doc.getName();\r\n            String size = \"\";\r\n            if (name.charAt(0) < 10) {\r\n                String altname = \"(0x0\" + (int) name.charAt(0) + \")\" + name.substring(1);\r\n                name = name.substring(1) + \" <\" + altname + \">\";\r\n            }\r\n            if (withSizes) {\r\n                size = \" [\" + doc.getSize() + \" / 0x\" + Integer.toHexString(doc.getSize()) + \"]\";\r\n            }\r\n            os.write((newIndent + name + size + \"\\n\").getBytes());\r\n        }\r\n    }\r\n    if (!hadChildren) {\r\n        os.write((newIndent + \"(no children)\").getBytes());\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.Body.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTReviewedRevisions.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalBook.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.DOMErrorHandlerImpl.handleError",
	"Comment": "implementation of domerrorhandler.handleerror thatadds copy of error to list for later retrieval.",
	"Method": "boolean handleError(DOMError error){\r\n    boolean fail = true;\r\n    String severity = null;\r\n    if (error.getSeverity() == DOMError.SEVERITY_WARNING) {\r\n        fail = false;\r\n        severity = \"[Warning]\";\r\n    } else if (error.getSeverity() == DOMError.SEVERITY_ERROR) {\r\n        severity = \"[Error]\";\r\n    } else if (error.getSeverity() == DOMError.SEVERITY_FATAL_ERROR) {\r\n        severity = \"[Fatal Error]\";\r\n    }\r\n    System.err.println(severity + \": \" + error.getMessage() + \"\\t\");\r\n    System.err.println(\"Type : \" + error.getType() + \"\\t\" + \"Related Data: \" + error.getRelatedData() + \"\\t\" + \"Related Exception: \" + error.getRelatedException());\r\n    return fail;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTRegroupTable.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFFHelpText.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTShapetype.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.FontInfo.getTripletFor",
	"Comment": "returns the first triplet matching the given font name.as there may be multiple triplets matching the font namethe result set is sorted first to guarantee consistent results.",
	"Method": "FontTriplet getTripletFor(String fontName){\r\n    List foundTriplets = getTripletsFor(fontName);\r\n    if (foundTriplets.size() > 0) {\r\n        Collections.sort(foundTriplets);\r\n        return (FontTriplet) foundTriplets.get(0);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.util.CodePageUtil.getStringFromCodePage",
	"Comment": "converts the bytes into a string, based on the equivalent character encoding to the supplied codepage number.",
	"Method": "String getStringFromCodePage(byte[] string,int codepage,String getStringFromCodePage,byte[] string,int offset,int length,int codepage){\r\n    String encoding = codepageToEncoding(codepage);\r\n    return new String(string, offset, length, encoding);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCalcPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTItem.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTEqArr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w15.CTCommentEx.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.TaintMethodConfig.getOutputTaint",
	"Comment": "returns the output taint of the method describing the taint transfer",
	"Method": "Taint getOutputTaint(){\r\n    if (outputTaint == null) {\r\n        return null;\r\n    }\r\n    return new Taint(outputTaint);\r\n}"
}, {
	"Path": "org.docx4j.wml.Styles.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.Base64.encode",
	"Comment": "encode a byte array in base64 format and return an optionallywrapped line.",
	"Method": "String encode(BigInteger big,byte[] encode,BigInteger big,int bitlen,String encode,byte[] binaryData,String encode,byte[] binaryData,int length){\r\n    if (length < 4) {\r\n        length = Integer.MAX_VALUE;\r\n    }\r\n    if (binaryData == null) {\r\n        return null;\r\n    }\r\n    int lengthDataBits = binaryData.length * EIGHTBIT;\r\n    if (lengthDataBits == 0) {\r\n        return \"\";\r\n    }\r\n    int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\r\n    int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;\r\n    int numberQuartet = fewerThan24bits != 0 ? numberTriplets + 1 : numberTriplets;\r\n    int quartesPerLine = length / 4;\r\n    int numberLines = (numberQuartet - 1) / quartesPerLine;\r\n    char[] encodedData = null;\r\n    encodedData = new char[numberQuartet * 4 + numberLines];\r\n    byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\r\n    int encodedIndex = 0;\r\n    int dataIndex = 0;\r\n    int i = 0;\r\n    for (int line = 0; line < numberLines; line++) {\r\n        for (int quartet = 0; quartet < 19; quartet++) {\r\n            b1 = binaryData[dataIndex++];\r\n            b2 = binaryData[dataIndex++];\r\n            b3 = binaryData[dataIndex++];\r\n            l = (byte) (b2 & 0x0f);\r\n            k = (byte) (b1 & 0x03);\r\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\r\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\r\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\r\n            encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];\r\n            encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | (k << 4)];\r\n            encodedData[encodedIndex++] = lookUpBase64Alphabet[(l << 2) | val3];\r\n            encodedData[encodedIndex++] = lookUpBase64Alphabet[b3 & 0x3f];\r\n            i++;\r\n        }\r\n        encodedData[encodedIndex++] = 0xa;\r\n    }\r\n    for (; i < numberTriplets; i++) {\r\n        b1 = binaryData[dataIndex++];\r\n        b2 = binaryData[dataIndex++];\r\n        b3 = binaryData[dataIndex++];\r\n        l = (byte) (b2 & 0x0f);\r\n        k = (byte) (b1 & 0x03);\r\n        byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\r\n        byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\r\n        byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\r\n        encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];\r\n        encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | (k << 4)];\r\n        encodedData[encodedIndex++] = lookUpBase64Alphabet[(l << 2) | val3];\r\n        encodedData[encodedIndex++] = lookUpBase64Alphabet[b3 & 0x3f];\r\n    }\r\n    if (fewerThan24bits == EIGHTBIT) {\r\n        b1 = binaryData[dataIndex];\r\n        k = (byte) (b1 & 0x03);\r\n        byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\r\n        encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];\r\n        encodedData[encodedIndex++] = lookUpBase64Alphabet[k << 4];\r\n        encodedData[encodedIndex++] = PAD;\r\n        encodedData[encodedIndex++] = PAD;\r\n    } else if (fewerThan24bits == SIXTEENBIT) {\r\n        b1 = binaryData[dataIndex];\r\n        b2 = binaryData[dataIndex + 1];\r\n        l = (byte) (b2 & 0x0f);\r\n        k = (byte) (b1 & 0x03);\r\n        byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\r\n        byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\r\n        encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];\r\n        encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | (k << 4)];\r\n        encodedData[encodedIndex++] = lookUpBase64Alphabet[l << 2];\r\n        encodedData[encodedIndex++] = PAD;\r\n    }\r\n    return new String(encodedData);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTStroke.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.netflix.genie.client.ClusterClient.getClusters",
	"Comment": "method to get a list of all the clusters from genie for the query parameters specified.",
	"Method": "List<Cluster> getClusters(List<Cluster> getClusters,String name,List<String> statusList,List<String> tagList,Long minUpdateTime,Long maxUpdateTime){\r\n    final List<Cluster> clusterList = new ArrayList();\r\n    final JsonNode jnode = clusterService.getClusters(name, statusList, tagList, minUpdateTime, maxUpdateTime).execute().body().get(\"_embedded\");\r\n    if (jnode != null) {\r\n        for (final JsonNode objNode : jnode.get(\"clusterList\")) {\r\n            final Cluster cluster = this.treeToValue(objNode, Cluster.class);\r\n            clusterList.add(cluster);\r\n        }\r\n    }\r\n    return clusterList;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomSheetView.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPartBehavior.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRst.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotSelection.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getAlwaysMergeEmptyNamespace",
	"Comment": "gets the value of the alwaysmergeemptynamespace property.",
	"Method": "BooleanDefaultTrue getAlwaysMergeEmptyNamespace(){\r\n    return alwaysMergeEmptyNamespace;\r\n}"
}, {
	"Path": "org.docx4j.wml.PPrBase.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTBorderPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTR.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.anon.AnonymizeResult.getUnsafeObjectsByPart",
	"Comment": "return objects which are potentially unsafe, by story part",
	"Method": "HashMap<Part, Set<Object>> getUnsafeObjectsByPart(){\r\n    return unsafeObjectsByPart;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFFHelpText.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.sax.XMLWriterSAX.getQName",
	"Comment": "returns the qualified name for this element using the specified namespace uri.",
	"Method": "String getQName(String uri,String name,String getQName,int i){\r\n    String prefix = this.prefixMapping.get(uri != null ? uri : \"\");\r\n    if (prefix != null) {\r\n        if (!\"\".equals(prefix))\r\n            return this.prefixMapping.get(uri) + \":\" + name;\r\n        else\r\n            return name;\r\n    } else\r\n        throw new UndeclaredNamespaceException(uri);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.Messages.getResourceSuffix",
	"Comment": "return the resource file suffic for the indicated localefor most locales, this will be based the language code.howeverfor chinese, we do distinguish between taiwan and prc",
	"Method": "String getResourceSuffix(Locale locale){\r\n    String suffix = \"_\" + locale.getLanguage();\r\n    String country = locale.getCountry();\r\n    if (country.equals(\"TW\"))\r\n        suffix += \"_\" + country;\r\n    return suffix;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMap.isShowImportExportValidationErrors",
	"Comment": "gets the value of the showimportexportvalidationerrors property.",
	"Method": "boolean isShowImportExportValidationErrors(){\r\n    return showImportExportValidationErrors;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTSolidColorFillProperties.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.agent.utils.PathUtils.jobEntityDependenciesPath",
	"Comment": "compose the path to the dependencies directory for a given entity.",
	"Method": "Path jobEntityDependenciesPath(Path entityDirectory){\r\n    return composePath(new File(entityDirectory.toUri()), JobConstants.DEPENDENCY_FILE_PATH_PREFIX);\r\n}"
}, {
	"Path": "org.docx4j.math.CTBoxPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSFileSystem._get_property_table",
	"Comment": "for unit testing only! returns the underlying properties table",
	"Method": "NPropertyTable _get_property_table(){\r\n    return _property_table;\r\n}"
}, {
	"Path": "org.docx4j.math.CTRadPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWorksheetSource.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotAreaReference.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTXmlPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTGradientFillProperties.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTablePart.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.agent.aws.s3.BucketProperties.getRoleARN",
	"Comment": "get the arn of the role to assume from this instance when working with the given bucket.",
	"Method": "Optional<String> getRoleARN(){\r\n    if (this.roleARN == null) {\r\n        return Optional.empty();\r\n    } else {\r\n        return Optional.of(this.roleARN.toString());\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.w14.CTTextOutlineEffect.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFFTextType.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.FileVersion.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTEdnPos.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadataType.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTPathShadeProperties.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTOval.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTQueryTableField.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTLimUppPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotTableDefinition.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTParameter.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFFCheckBox.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMemberProperty.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTColor.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMacroName.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.serial.DeserializationGadgetDetector.hasCustomReadObject",
	"Comment": "check if the readobject is doing multiple external call beyond the basic readbyte, readboolean, etc..",
	"Method": "boolean hasCustomReadObject(Method m,ClassContext classContext,List<String> classesToIgnore){\r\n    ConstantPoolGen cpg = classContext.getConstantPoolGen();\r\n    CFG cfg = classContext.getCFG(m);\r\n    int count = 0;\r\n    for (Iterator<Location> i = cfg.locationIterator(); i.hasNext(); ) {\r\n        Location location = i.next();\r\n        Instruction inst = location.getHandle().getInstruction();\r\n        if (inst instanceof InvokeInstruction) {\r\n            InvokeInstruction invoke = (InvokeInstruction) inst;\r\n            if (!READ_DESERIALIZATION_METHODS.contains(invoke.getMethodName(cpg)) && !classesToIgnore.contains(invoke.getClassName(cpg))) {\r\n                count += 1;\r\n            }\r\n        }\r\n    }\r\n    return count > 3;\r\n}"
}, {
	"Path": "org.nustaq.offheap.BinaryQueue.readByteArray",
	"Comment": "convenience method to read len byte array. throws an excpetion if not enough data is present",
	"Method": "byte[] readByteArray(int len){\r\n    if (available() < len) {\r\n        throw new RuntimeException(\"not enough data available, check available() > len before calling\");\r\n    }\r\n    byte[] b = new byte[len];\r\n    int count = 0;\r\n    while (pollIndex != addIndex && count < len) {\r\n        b[count++] = storage.get(pollIndex++);\r\n        if (pollIndex >= storage.length()) {\r\n            pollIndex = 0;\r\n        }\r\n    }\r\n    return b;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomFilters.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.model.fields.merge.MailMerger.getTextInsideContent",
	"Comment": "parse through all content inside the paragraph to concatenate all values inside a text",
	"Method": "String getTextInsideContent(ContentAccessor paragraph){\r\n    StringBuilder result = new StringBuilder();\r\n    for (Object content : paragraph.getContent()) {\r\n        if (content instanceof org.docx4j.wml.R) {\r\n            org.docx4j.wml.R run = (org.docx4j.wml.R) content;\r\n            List<Object> runContent = run.getContent();\r\n            for (Object o2 : runContent) {\r\n                if (o2 instanceof javax.xml.bind.JAXBElement) {\r\n                    if (((JAXBElement<?>) o2).getDeclaredType().getName().equals(\"org.docx4j.wml.Text\")) {\r\n                        org.docx4j.wml.Text t = (org.docx4j.wml.Text) ((JAXBElement) o2).getValue();\r\n                        result.append(t.getValue());\r\n                    }\r\n                } else if (o2 instanceof org.docx4j.wml.Text) {\r\n                    org.docx4j.wml.Text t = (org.docx4j.wml.Text) o2;\r\n                    result.append(t.getValue());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "org.docx4j.math.CTFuncPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTLimLoc.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTReadingModeInkLockDown.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDeletedField.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTGradientFillProperties.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTEmpty.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFutureMetadata.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTOMathJc.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotCaches.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.eclipse.compare.rangedifferencer.RangeDifference.rightStart",
	"Comment": "returns the start index of the entity range on the right side.",
	"Method": "int rightStart(){\r\n    return fRightStart;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellWatch.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPart.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.ElementProxy.getElementPlusReturns",
	"Comment": "returns the element plus a leading and a trailing carriagereturn text node.",
	"Method": "NodeList getElementPlusReturns(){\r\n    HelperNodeList nl = new HelperNodeList();\r\n    nl.appendChild(createText(\"\\n\"));\r\n    nl.appendChild(getElement());\r\n    nl.appendChild(createText(\"\\n\"));\r\n    return nl;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCfvo.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w15.CTSdtRepeatedSection.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetCalcPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTGroupChr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSet.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWebPublishObject.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTInteger255.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTGroups.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.hpsf.SpecialPropertySet.getPropertyStringValue",
	"Comment": "fetches the property with the given id, then does its best to return it as a string",
	"Method": "String getPropertyStringValue(int propertyId,String getPropertyStringValue,Object propertyValue){\r\n    if (propertyValue == null)\r\n        return null;\r\n    if (propertyValue instanceof String)\r\n        return (String) propertyValue;\r\n    if (propertyValue instanceof byte[]) {\r\n        byte[] b = (byte[]) propertyValue;\r\n        if (b.length == 0) {\r\n            return \"\";\r\n        }\r\n        if (b.length == 1) {\r\n            return Byte.toString(b[0]);\r\n        }\r\n        if (b.length == 2) {\r\n            return Integer.toString(LittleEndian.getUShort(b));\r\n        }\r\n        if (b.length == 4) {\r\n            return Long.toString(LittleEndian.getUInt(b));\r\n        }\r\n        return new String(b);\r\n    }\r\n    return propertyValue.toString();\r\n}"
}, {
	"Path": "org.docx4j.relationships.Relationships.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTConditionalFormat.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTables.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.XMLWriterNSImpl.handleNamespaceDeclaration",
	"Comment": "handles the namespace declaration and updates the prefix mappings.",
	"Method": "void handleNamespaceDeclaration(){\r\n    if (this.tempMapping != null) {\r\n        PrefixMapping pm = null;\r\n        for (int i = 0; i < this.tempMapping.size(); i++) {\r\n            pm = this.tempMapping.get(i);\r\n            if (!XMLConstants.XML_NS_PREFIX.equals(pm.prefix)) {\r\n                this.writer.write(\" xmlns\");\r\n                if (!\"\".equals(pm.prefix)) {\r\n                    this.writer.write(':');\r\n                    this.writer.write(pm.prefix);\r\n                }\r\n                this.writer.write(\"=\\\"\");\r\n                this.writer.write(pm.uri);\r\n                this.writer.write(\"\\\"\");\r\n            }\r\n        }\r\n        this.tempMapping = null;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.parts.opendope.XPathsPart.getXPathById",
	"Comment": "for performance reasons, avoid using this if you have a lot of xpaths",
	"Method": "Xpath getXPathById(String id,Xpath getXPathById,org.opendope.xpaths.Xpaths xpaths,String id){\r\n    for (Xpath x : xpaths.getXpath()) {\r\n        if (x.getId().equals(id))\r\n            return x;\r\n    }\r\n    throw new InputIntegrityException(\"Couldn't find xpath \" + id);\r\n}"
}, {
	"Path": "org.docx4j.math.CTScript.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDimensions.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTLongHexNumber.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTSkew.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMergeCell.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2010.wordprocessingShape.CTTextboxInfo.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTMCS.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTrackChangesView.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTBreak.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSortState.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.Numbering.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.HpsMeasure.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFieldGroup.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.hasTag",
	"Comment": "checks whether the specified taint tag is present for this fact",
	"Method": "boolean hasTag(Tag tag){\r\n    return tags.contains(tag);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.FontLoader.getFont",
	"Comment": "returns the custom font that was read using this instance of fontloader.",
	"Method": "CustomFont getFont(){\r\n    if (!loaded) {\r\n        read();\r\n    }\r\n    return this.returnFont;\r\n}"
}, {
	"Path": "org.docx4j.wml.RFonts.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTFPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTPath.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTColorSchemeMapping.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.nustaq.serialization.FSTConfiguration.registerCrossPlatformClassMapping",
	"Comment": "init right after creation of configuration, not during operation as it is not threadsafe regarding mutationcurrently only for minbin serialization",
	"Method": "FSTConfiguration registerCrossPlatformClassMapping(String[][] keysAndVals,FSTConfiguration registerCrossPlatformClassMapping,String shortName,String fqName){\r\n    minbinNames.put(shortName, fqName);\r\n    minbinNamesReverse.put(fqName, shortName);\r\n    return this;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTDefaultImageDpi.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.type1.AFMFile.getFirstChar",
	"Comment": "returns the first character index in the encoding that has a glyph.",
	"Method": "int getFirstChar(){\r\n    return this.firstChar;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadataRecord.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.getDoNotAutoCompressPictures",
	"Comment": "gets the value of the donotautocompresspictures property.",
	"Method": "BooleanDefaultTrue getDoNotAutoCompressPictures(){\r\n    return doNotAutoCompressPictures;\r\n}"
}, {
	"Path": "org.nustaq.serialization.FSTConfiguration.createStructConfiguration",
	"Comment": "special configuration used internally for struct emulation",
	"Method": "FSTConfiguration createStructConfiguration(){\r\n    FSTConfiguration conf = new FSTConfiguration(null);\r\n    conf.setStructMode(true);\r\n    return conf;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCharacterSpacing.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMembers.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTLimUpp.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.convert.out.common.writer.AbstractTableWriterModel.build",
	"Comment": "build a table representation from a tbl instance.\tremember to set wordmlpackage before using this method!",
	"Method": "void build(AbstractWmlConversionContext conversionContext,Object node,Node content){\r\n    Tbl tbl = null;\r\n    try {\r\n        tbl = (Tbl) node;\r\n    } catch (ClassCastException e) {\r\n        throw new TransformerException(\"Node is not of the type Tbl it is \" + node.getClass().getName());\r\n    }\r\n    if (tbl.getTblPr() != null && tbl.getTblPr().getTblStyle() != null) {\r\n        styleId = tbl.getTblPr().getTblStyle().getVal();\r\n    }\r\n    this.tblGrid = tbl.getTblGrid();\r\n    this.tblPr = tbl.getTblPr();\r\n    PropertyResolver pr = conversionContext.getPropertyResolver();\r\n    effectiveTableStyle = pr.getEffectiveTableStyle(tbl.getTblPr());\r\n    NodeList cellContents = content.getChildNodes();\r\n    TrFinder trFinder = new TrFinder();\r\n    new TraversalUtil(tbl, trFinder);\r\n    ensureFoTableBody(trFinder.getTrList());\r\n    int r = 0;\r\n    for (Tr tr : trFinder.getTrList()) {\r\n        startRow(tr);\r\n        handleRow(cellContents, tr, r);\r\n        r++;\r\n        if (rows.get(row).getRowContents().isEmpty()) {\r\n            rows.remove(row);\r\n            row--;\r\n            r--;\r\n        }\r\n    }\r\n    CTTblPrBase tblPr = effectiveTableStyle.getTblPr();\r\n    if (tblPr != null) {\r\n        if (tblPr.getTblCellSpacing() != null) {\r\n            setBorderConflictResolutionRequired(false);\r\n        }\r\n    }\r\n    width = calcTableWidth();\r\n}"
}, {
	"Path": "org.docx4j.math.CTBarPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSingleXmlCells.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.type1.PFMFile.getKerning",
	"Comment": "return the kerning table. the kerning table is a map withstrings with glyphnames as keys, containing maps as value.the value map contains a glyph name string key and an integer value",
	"Method": "Map getKerning(){\r\n    return kerningTab;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTProtectedRange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.nustaq.serialization.FSTObjectOutput.objectHasBeenWritten",
	"Comment": "hook for debugging profiling. empty impl, you need to subclass to make use of this hook",
	"Method": "void objectHasBeenWritten(Object obj,int oldStreamPosition,int streamPosition){\r\n    if (listener != null) {\r\n        listener.objectHasBeenWritten(obj, oldStreamPosition, streamPosition);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.TTFSubSetFile.createHhea",
	"Comment": "copy the hhea table as is from original font to subset fontand fill in size of hmtx table",
	"Method": "void createHhea(FontFileReader in,int size){\r\n    TTFDirTabEntry entry = (TTFDirTabEntry) dirTabs.get(\"hhea\");\r\n    if (entry != null) {\r\n        pad4();\r\n        seekTab(in, \"hhea\", 0);\r\n        System.arraycopy(in.getBytes((int) entry.getOffset(), (int) entry.getLength()), 0, output, currentPos, (int) entry.getLength());\r\n        writeUShort((int) entry.getLength() + currentPos - 2, size);\r\n        int checksum = getCheckSum(currentPos, (int) entry.getLength());\r\n        writeULong(hheaDirOffset, checksum);\r\n        writeULong(hheaDirOffset + 4, currentPos);\r\n        writeULong(hheaDirOffset + 8, (int) entry.getLength());\r\n        currentPos += (int) entry.getLength();\r\n        realSize += (int) entry.getLength();\r\n    } else {\r\n        throw new IOException(\"Can't find hhea table\");\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTOlapPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTOMathJc.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTRelativeRect.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.EmbedFontInfo.isEmbedded",
	"Comment": "indicates whether the font is only referenced rather than embedded.",
	"Method": "boolean isEmbedded(){\r\n    if (metricsFile != null && embedFile == null) {\r\n        return false;\r\n    } else {\r\n        return this.embedded;\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomProperty.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTCtrlPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellStyles.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.wordprocessingDrawing.CTAnchorLock.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocVar.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPageSetup.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTAuthors.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTDocEvents.setEventDocBuildingBlockAfterInsert",
	"Comment": "sets the value of the eventdocbuildingblockafterinsert property.",
	"Method": "void setEventDocBuildingBlockAfterInsert(Object value){\r\n    this.eventDocBuildingBlockAfterInsert = value;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.XML11Char.isXML11Space",
	"Comment": "returns true if the specified character is a space characteras amdended in the xml 1.1 specification.",
	"Method": "boolean isXML11Space(int c){\r\n    return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_SPACE) != 0);\r\n}"
}, {
	"Path": "org.docx4j.model.datastorage.BindingHyperlinkResolverForOpenAPI3.getIndexOfURL",
	"Comment": "return the index of the position you wish to treat as a hyperlink.\tthe characters from there to the first whitespace following will be treated as \tthe url",
	"Method": "int getIndexOfURL(String text){\r\n    if (text.startsWith(COMPONENT_REF))\r\n        return 0;\r\n    return super.getIndexOfURL(text);\r\n}"
}, {
	"Path": "com.topologi.diffx.load.text.TokenizerUtils.getLeadingWhiteSpace",
	"Comment": "returns the length in characters of the leading white space in the given char sequence.",
	"Method": "int getLeadingWhiteSpace(CharSequence s){\r\n    int i = 0;\r\n    if (0 == s.length())\r\n        return 0;\r\n    char c = s.charAt(0);\r\n    while (c == ' ' || c == '\\t' || c == '\\n') {\r\n        i++;\r\n        if (i == s.length()) {\r\n            break;\r\n        }\r\n        c = s.charAt(i);\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.packages.ProtectWorkbook.getSheetProtection",
	"Comment": "use this method to get the ctsheetprotection object for the specified worksheet, so you can set its\tparameters as you see fit.",
	"Method": "CTSheetProtection getSheetProtection(WorksheetPart worksheetPart){\r\n    if (worksheetPart == null)\r\n        throw new Xlsx4jException(\"Passed null WorksheetPart\");\r\n    if (worksheetPart.getJaxbElement() == null) {\r\n        worksheetPart.setJaxbElement(new Worksheet());\r\n    }\r\n    CTSheetProtection sheetProtection = worksheetPart.getJaxbElement().getSheetProtection();\r\n    if (sheetProtection == null) {\r\n        sheetProtection = new CTSheetProtection();\r\n        worksheetPart.getJaxbElement().setSheetProtection(sheetProtection);\r\n    }\r\n    sheetProtection.setSheet(true);\r\n    sheetProtection.setSelectLockedCells(true);\r\n    sheetProtection.setSelectUnlockedCells(true);\r\n    return sheetProtection;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTMarkupRange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.hpsf.CustomProperties.getDictionary",
	"Comment": "gets the dictionary which contains ids and names of the named customproperties.",
	"Method": "Map<Long, String> getDictionary(){\r\n    return dictionaryIDToName;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblCellMar.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.OPOIFSDocument.preferArray",
	"Comment": "give viewers a hint as to whether to call getviewablearray or\tgetviewableiterator",
	"Method": "boolean preferArray(){\r\n    return true;\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.XMLWriterNSImpl.deNude",
	"Comment": "writes the angle bracket if the element open tag is not finished.",
	"Method": "void deNude(){\r\n    if (this.isNude) {\r\n        this.writer.write('>');\r\n        if (super.indent && peekElement().hasChildren) {\r\n            this.writer.write('\\n');\r\n        }\r\n        this.isNude = false;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToHTMLStream.addUniqueAttribute",
	"Comment": "this method is used to add an attribute to the currently open element. the caller has guaranted that this attribute is unique, which means that itnot been seen before and will not be seen again.",
	"Method": "void addUniqueAttribute(String name,String value,int flags){\r\n    try {\r\n        final java.io.Writer writer = m_writer;\r\n        if ((flags & NO_BAD_CHARS) > 0 && m_htmlcharInfo.onlyQuotAmpLtGt) {\r\n            writer.write(' ');\r\n            writer.write(name);\r\n            writer.write(\"=\\\"\");\r\n            writer.write(value);\r\n            writer.write('\"');\r\n        } else if ((flags & HTML_ATTREMPTY) > 0 && (value.length() == 0 || value.equalsIgnoreCase(name))) {\r\n            writer.write(' ');\r\n            writer.write(name);\r\n        } else {\r\n            writer.write(' ');\r\n            writer.write(name);\r\n            writer.write(\"=\\\"\");\r\n            if ((flags & HTML_ATTRURL) > 0) {\r\n                writeAttrURI(writer, value, m_specialEscapeURLs);\r\n            } else {\r\n                writeAttrString(writer, value, this.getEncoding());\r\n            }\r\n            writer.write('\"');\r\n        }\r\n    } catch (IOException e) {\r\n        throw new SAXException(e);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.taskpanes_2010_11.CTOsfTaskpanes.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.model.styles.Node.addChild",
	"Comment": "adds a child to the list of children for this node. the addition ofthe first child will create a new list.",
	"Method": "void addChild(Node<T> child){\r\n    if (children == null) {\r\n        children = new ArrayList<Node<T>>();\r\n    }\r\n    if (!children.contains(child)) {\r\n        children.add(child);\r\n        tree.nodes.put(child.name, child);\r\n        child.setParent(this);\r\n    }\r\n}"
}, {
	"Path": "com.topologi.diffx.sequence.EventSequence.removeEvent",
	"Comment": "removes an event from this sequence at the specified position.",
	"Method": "DiffXEvent removeEvent(int index){\r\n    return (DiffXEvent) this.sequence.remove(index);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotTableDefinition.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.endpoint.TapestryEndpointDetectorTest.detectTapestryPagePojo",
	"Comment": "this code sample is a plain pojo. the package name will trigger the pointer.",
	"Method": "void detectTapestryPagePojo(){\r\n    String[] files = { getClassFilePath(\"testcode/pages/Index\") };\r\n    EasyBugReporter reporter = spy(new SecurityReporter());\r\n    analyze(files, reporter);\r\n    verify(reporter, never()).doReportBug(bugDefinition().bugType(\"TAPESTRY_ENDPOINT\").inClass(\"Index\").build());\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCustomProperties.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionHeaders.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFont.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTIndexedColors.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTIndexedColors.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTBreakBinSub.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.XML11Char.isXML11Valid",
	"Comment": "returns true if the specified character is valid. this methodalso checks the surrogate character range from 0x10000 to 0x10ffff.if the program chooses to apply the mask directly to thexml11chars array, then they are responsible for checkingthe surrogate character range.",
	"Method": "boolean isXML11Valid(int c){\r\n    return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_VALID) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "org.docx4j.wml.Tc.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.nustaq.serialization.coders.FSTStreamEncoder.flush",
	"Comment": "writes current buffer to underlying output and resets buffer.",
	"Method": "void flush(){\r\n    buffout.flush();\r\n}"
}, {
	"Path": "org.docx4j.wml.CTWritingStyle.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPhoneticRun.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Worksheet.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocPartType.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.root.Xml.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w14.CTPresetLineDashProperties.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.XMLChar.isValidIANAEncoding",
	"Comment": "returns true if the encoding name is a valid iana encoding.this method does not verify that there is a decoder availablefor this encoding, only that the characters are valid for aniana encoding name.",
	"Method": "boolean isValidIANAEncoding(String ianaEncoding){\r\n    if (ianaEncoding != null) {\r\n        int length = ianaEncoding.length();\r\n        if (length > 0) {\r\n            char c = ianaEncoding.charAt(0);\r\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\r\n                for (int i = 1; i < length; i++) {\r\n                    c = ianaEncoding.charAt(i);\r\n                    if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') && (c < '0' || c > '9') && c != '.' && c != '_' && c != '-') {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.XMLChar.isContent",
	"Comment": "returns true if the specified character can be considered content.",
	"Method": "boolean isContent(int c){\r\n    return (c < 0x10000 && (CHARS[c] & MASK_CONTENT) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "org.docx4j.wml.Tr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.Encodings.toCodePoint",
	"Comment": "return the unicode code point represented by the char.a bit of a dummy method, since all it does is return the char,but as an int value.this is not a public api.",
	"Method": "int toCodePoint(char highSurrogate,char lowSurrogate,int toCodePoint,char ch){\r\n    int codePoint = ch;\r\n    return codePoint;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.storage.BlockAllocationTableReader.isUsed",
	"Comment": "determine whether the block specified by index is used or not",
	"Method": "boolean isUsed(int index){\r\n    try {\r\n        return _entries.get(index) != -1;\r\n    } catch (IndexOutOfBoundsException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTControl.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.substitute.FontWeightRange.isWithinRange",
	"Comment": "returns true if the given integer value is within this integer range",
	"Method": "boolean isWithinRange(int value){\r\n    return (value >= start && value <= end);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.SheetData.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.model.fields.FieldRef.setLock",
	"Comment": "specifies that the parent complex field shall not have its field result recalculated, even if \tan application attempts to recalculate the results of all fields in the document or a \trecalculation is explicitly requested.",
	"Method": "void setLock(boolean lock){\r\n    this.lock = lock;\r\n    fldCharBegin.setFldLock(lock);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTBackground.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setDoNotAutoCompressPictures",
	"Comment": "sets the value of the donotautocompresspictures property.",
	"Method": "void setDoNotAutoCompressPictures(BooleanDefaultTrue value){\r\n    this.doNotAutoCompressPictures = value;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTColumn.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSdtDropDownList.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTColors.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellStyle.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocGrid.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSingleXmlCells.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.agent.execution.services.impl.FetchingCacheServiceImplTests.deleteAndFetchResourceConcurrently",
	"Comment": "make one cache delete a resource version.while first one is deleting, make another threaddownload the same versionin the end, the resource should exist",
	"Method": "void deleteAndFetchResourceConcurrently(){\r\n    final ResourceLoader resourceLoader = Mockito.mock(ResourceLoader.class);\r\n    final Resource resource = Mockito.mock(Resource.class);\r\n    final AtomicInteger numJobsInLockMethod = new AtomicInteger(0);\r\n    final ReentrantLock lockBackingMock = new ReentrantLock();\r\n    final CountDownLatch downLoadJobEnteredLockMethod = new CountDownLatch(1);\r\n    final CountDownLatch deletionDone = new CountDownLatch(1);\r\n    final CountDownLatch deletionJObEnteredLockMethod = new CountDownLatch(1);\r\n    final CountDownLatch deletionSuccessVerified = new CountDownLatch(1);\r\n    final CloseableLock resourceLock = Mockito.mock(CloseableLock.class);\r\n    Mockito.doAnswer(invocation -> {\r\n        if (numJobsInLockMethod.incrementAndGet() == 1) {\r\n            deletionJObEnteredLockMethod.countDown();\r\n            downLoadJobEnteredLockMethod.await();\r\n        } else {\r\n            downLoadJobEnteredLockMethod.countDown();\r\n            deletionSuccessVerified.await();\r\n        }\r\n        lockBackingMock.lock();\r\n        return null;\r\n    }).when(resourceLock).lock();\r\n    Mockito.doAnswer(invocation -> {\r\n        lockBackingMock.unlock();\r\n        return null;\r\n    }).when(resourceLock).close();\r\n    final FileLockFactory fileLockFactory = Mockito.mock(FileLockFactory.class);\r\n    Mockito.when(fileLockFactory.getLock(Mockito.any())).thenReturn(resourceLock);\r\n    Mockito.when(resourceLoader.getResource(Mockito.anyString())).thenReturn(resource);\r\n    Mockito.when(resource.getInputStream()).thenAnswer((Answer<InputStream>) invocation -> {\r\n        return Mockito.spy(new ByteArrayInputStream(\"\".getBytes(Charset.forName(\"UTF-8\"))));\r\n    });\r\n    final long lastModifiedTimeStamp = System.currentTimeMillis();\r\n    Mockito.when(resource.exists()).thenReturn(true);\r\n    Mockito.when(resource.lastModified()).thenReturn(lastModifiedTimeStamp);\r\n    final FetchingCacheServiceImpl cache1 = new FetchingCacheServiceImpl(resourceLoader, cacheArguments, fileLockFactory, cleanUpTaskExecutor);\r\n    final String resourceCacheId = cache1.getResourceCacheId(uri);\r\n    final ResourceLoader resourceLoader2 = Mockito.mock(ResourceLoader.class);\r\n    final FetchingCacheServiceImpl cache2 = new FetchingCacheServiceImpl(resourceLoader2, cacheArguments, fileLockFactory, cleanUpTaskExecutor);\r\n    final ResourceLoader resourceLoader3 = Mockito.mock(ResourceLoader.class);\r\n    final Resource resource3 = Mockito.mock(Resource.class);\r\n    Mockito.when(resource3.exists()).thenReturn(true);\r\n    Mockito.when(resource3.lastModified()).thenReturn(lastModifiedTimeStamp);\r\n    Mockito.when(resource3.getInputStream()).thenAnswer((Answer<InputStream>) invocation -> {\r\n        return Mockito.spy(new ByteArrayInputStream(\"\".getBytes(Charset.forName(\"UTF-8\"))));\r\n    });\r\n    Mockito.when(resourceLoader3.getResource(Mockito.anyString())).thenReturn(resource3);\r\n    final FetchingCacheServiceImpl cache3 = new FetchingCacheServiceImpl(resourceLoader3, cacheArguments, new FileLockFactory(), cleanUpTaskExecutor);\r\n    cache3.get(uri, targetFile);\r\n    assertResourceDownloaded(cache3, resourceCacheId, lastModifiedTimeStamp);\r\n    final CountDownLatch allFetchesDone = new CountDownLatch(2);\r\n    executorService.submit(() -> {\r\n        try {\r\n            cache2.cleanUpOlderResourceVersions(resourceCacheId, lastModifiedTimeStamp + 1);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            deletionDone.countDown();\r\n            allFetchesDone.countDown();\r\n        }\r\n    });\r\n    deletionJObEnteredLockMethod.await();\r\n    executorService.submit(() -> {\r\n        try {\r\n            cache1.get(uri, targetFile);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            allFetchesDone.countDown();\r\n        }\r\n    });\r\n    deletionDone.await();\r\n    assertResourceDeleted(cache1, resourceCacheId, lastModifiedTimeStamp);\r\n    deletionSuccessVerified.countDown();\r\n    allFetchesDone.await();\r\n    assertResourceDownloaded(cache2, resourceCacheId, lastModifiedTimeStamp);\r\n}"
}, {
	"Path": "org.docx4j.w15symex.CTSymEx.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.Encodings.toUpperCaseFast",
	"Comment": "a fast and cheap way to uppercase a string that isonly made of printable ascii characters.this is not a public api.",
	"Method": "String toUpperCaseFast(String s){\r\n    boolean different = false;\r\n    final int mx = s.length();\r\n    char[] chars = new char[mx];\r\n    for (int i = 0; i < mx; i++) {\r\n        char ch = s.charAt(i);\r\n        if ('a' <= ch && ch <= 'z') {\r\n            ch = (char) (ch + ('A' - 'a'));\r\n            different = true;\r\n        }\r\n        chars[i] = ch;\r\n    }\r\n    final String upper;\r\n    if (different)\r\n        upper = String.valueOf(chars);\r\n    else\r\n        upper = s;\r\n    return upper;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTObjectAnchor.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFontSize.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.com.microsoft.schemas.office.webextensions.webextension_2010_11.CTOsfWebExtensionPropertyBag.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTTextOutlineEffect.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSmartTagTypes.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CommentRangeStart.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTText.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTIndex.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDrawing.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.Document.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.org.apache.poi.ss.usermodel.ExcelStyleDateFormatter.processFormatPattern",
	"Comment": "takes a format string, and replaces excel specific bitswith our detection sequences",
	"Method": "String processFormatPattern(String f){\r\n    String t = f.replaceAll(\"MMMMM\", MMMMM_START_SYMBOL + \"MMM\" + MMMMM_TRUNCATE_SYMBOL);\r\n    t = t.replaceAll(\"\\\\[H]\", String.valueOf(H_BRACKET_SYMBOL));\r\n    t = t.replaceAll(\"\\\\[HH]\", String.valueOf(HH_BRACKET_SYMBOL));\r\n    t = t.replaceAll(\"\\\\[m]\", String.valueOf(M_BRACKET_SYMBOL));\r\n    t = t.replaceAll(\"\\\\[mm]\", String.valueOf(MM_BRACKET_SYMBOL));\r\n    t = t.replaceAll(\"\\\\[s]\", String.valueOf(S_BRACKET_SYMBOL));\r\n    t = t.replaceAll(\"\\\\[ss]\", String.valueOf(SS_BRACKET_SYMBOL));\r\n    t = t.replaceAll(\"s.000\", \"s.SSS\");\r\n    t = t.replaceAll(\"s.00\", \"s.\" + LL_BRACKET_SYMBOL);\r\n    t = t.replaceAll(\"s.0\", \"s.\" + L_BRACKET_SYMBOL);\r\n    return t;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblLook.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.topologi.diffx.load.SAXRecorder.process",
	"Comment": "runs the recorder on the specified string.this method is provided for convenience. it is best to only use this method forshort strings.",
	"Method": "EventSequence process(File file,EventSequence process,String xml,EventSequence process,InputSource is){\r\n    if (reader == null || newReader) {\r\n        init();\r\n    }\r\n    reader.setContentHandler(new RecorderHandler());\r\n    reader.setErrorHandler(new RecorderErrorHandler());\r\n    try {\r\n        reader.setFeature(\"http://xml.org/sax/features/namespaces\", this.config.isNamespaceAware());\r\n        reader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", this.config.isReportPrefixDifferences());\r\n        reader.parse(is);\r\n    } catch (SAXException ex) {\r\n        throw new LoadingException(ex);\r\n    }\r\n    return this.sequence;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setDrawingGridVerticalOrigin",
	"Comment": "sets the value of the drawinggridverticalorigin property.",
	"Method": "void setDrawingGridVerticalOrigin(CTTwipsMeasure value){\r\n    this.drawingGridVerticalOrigin = value;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTSignatureLine.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.transformer.TransformerIdentityImpl.getTransformer",
	"Comment": "get the transformer associated with this handler, whichis needed in order to set parameters and output properties.",
	"Method": "Transformer getTransformer(){\r\n    return this;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToStream.shouldIndent",
	"Comment": "tell if, based on space preservation constraints and the doindent property,if an indent should occur.",
	"Method": "boolean shouldIndent(){\r\n    return m_doIndent && (!m_ispreserve && !m_isprevtext) && m_elemContext.m_currentElemDepth > 0;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTVolType.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.packages.ProtectWorkbook.validateSheetProtectionPassword",
	"Comment": "validates the password, i.e.calculates the hash of the given password and compares it against the stored hash",
	"Method": "boolean validateSheetProtectionPassword(CTSheetProtection sheetProtection,String password){\r\n    if (password == null)\r\n        return false;\r\n    byte[] xorHashVal = sheetProtection.getPassword();\r\n    if (xorHashVal != null) {\r\n        int hash1 = Integer.parseInt(DatatypeConverter.printHexBinary(xorHashVal), 16);\r\n        int hash2 = CryptoFunctions.createXorVerifier1(password);\r\n        return hash1 == hash2;\r\n    } else {\r\n        byte[] hash1 = sheetProtection.getHashValue();\r\n        byte[] salt = sheetProtection.getSaltValue();\r\n        String algoName = sheetProtection.getAlgorithmName();\r\n        Long spinCount = sheetProtection.getSpinCount();\r\n        if (hash1 == null || algoName == null || salt == null || spinCount == null) {\r\n            return false;\r\n        }\r\n        HashAlgorithm hashAlgo = HashAlgorithm.fromString(algoName);\r\n        byte[] hash2 = CryptoFunctions.hashPassword(password, hashAlgo, salt, spinCount.intValue(), false);\r\n        return Arrays.equals(hash1, hash2);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.c14n.Canonicalizer.canonicalizeXPathNodeSet",
	"Comment": "canonicalizes an xpath node set. the xpathnodeset is treatedas a list of xpath nodes, not as a list of subtrees.",
	"Method": "byte[] canonicalizeXPathNodeSet(NodeList xpathNodeSet,byte[] canonicalizeXPathNodeSet,NodeList xpathNodeSet,String inclusiveNamespaces,byte[] canonicalizeXPathNodeSet,Set<Node> xpathNodeSet,byte[] canonicalizeXPathNodeSet,Set<Node> xpathNodeSet,String inclusiveNamespaces){\r\n    canonicalizerSpi.secureValidation = secureValidation;\r\n    return canonicalizerSpi.engineCanonicalizeXPathNodeSet(xpathNodeSet, inclusiveNamespaces);\r\n}"
}, {
	"Path": "org.docx4j.vml.presentationDrawing.CTEmpty.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.CIDSubset.getGlyphIndexBitSet",
	"Comment": "returns a bitset with bits set for each available glyph index.",
	"Method": "BitSet getGlyphIndexBitSet(){\r\n    BitSet bitset = new BitSet();\r\n    Iterator iter = usedGlyphs.keySet().iterator();\r\n    while (iter.hasNext()) {\r\n        Integer cid = (Integer) iter.next();\r\n        bitset.set(cid.intValue());\r\n    }\r\n    return bitset;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSmartTagPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCustomXmlPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTSSup.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSectPrChange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.topologi.diffx.util.CommandLine.getParameter",
	"Comment": "returns the value corresponding to the given switch.returns null if any of the parameters is null.",
	"Method": "String getParameter(String name,String[] args){\r\n    if (args == null || args.length < 2 || name == null)\r\n        return null;\r\n    for (int i = 0; i < args.length; i++) {\r\n        if (name.equals(args[i]) && i + 1 < args.length)\r\n            return args[i + 1];\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTParameters.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPrintOptions.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.math.CTPhantPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToStream.notationDecl",
	"Comment": "if this method is called, the serializer is used as adtdhandler, which changes behavior how the serializer handles document entities.",
	"Method": "void notationDecl(String name,String pubID,String sysID){\r\n    try {\r\n        DTDprolog();\r\n        m_writer.write(\"<!NOTATION \");\r\n        m_writer.write(name);\r\n        if (pubID != null) {\r\n            m_writer.write(\" PUBLIC \\\"\");\r\n            m_writer.write(pubID);\r\n        } else {\r\n            m_writer.write(\" SYSTEM \\\"\");\r\n            m_writer.write(sysID);\r\n        }\r\n        m_writer.write(\"\\\" >\");\r\n        m_writer.write(m_lineSep, 0, m_lineSepLen);\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.FontFamily.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.sax.XMLWriterSAX.indent",
	"Comment": "insert the correct amount of space characters depending on the depth and ifthe indent flag is set to true.",
	"Method": "void indent(){\r\n    if (this.indent) {\r\n        char[] ch = new char[this.depth * this.indentChars.length];\r\n        for (int i = 0; i < this.depth; i++) {\r\n            for (int j = 0; j < this.indentChars.length; j++) {\r\n                ch[i * this.indentChars.length + j] = this.indentChars[j];\r\n            }\r\n        }\r\n        this.handler.ignorableWhitespace(ch, 0, ch.length);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTextboxTightWrap.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.model.structure.PageDimensions.getHeaderMargin",
	"Comment": "get the distance from the top edge of the paper to the top edge of the header",
	"Method": "int getHeaderMargin(){\r\n    if (pgMar.getHeader() == null) {\r\n        return 720;\r\n    } else {\r\n        return pgMar.getHeader().intValue();\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFontFamily.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.setSelectFldWithFirstOrLastChar",
	"Comment": "sets the value of the selectfldwithfirstorlastchar property.",
	"Method": "void setSelectFldWithFirstOrLastChar(BooleanDefaultTrue value){\r\n    this.selectFldWithFirstOrLastChar = value;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTHandles.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTEdnPos.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.officedrawing.CTRelationTable.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCustomXmlRun.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.Drawing.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTXf.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xalan.templates.OutputProperties.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.Encodings.isHighUTF16Surrogate",
	"Comment": "return true if the character is the high member of a surrogate pair.this is not a public api.",
	"Method": "boolean isHighUTF16Surrogate(char ch){\r\n    return ('?' <= ch && ch <= '?');\r\n}"
}, {
	"Path": "org.docx4j.wml.TcMar.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTView.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTMPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.utils.BoolStack.peekOrFalse",
	"Comment": "looks at the object at the top of this stack without removing itfrom the stack.if the stack is empty, it returns false.",
	"Method": "boolean peekOrFalse(){\r\n    return (m_index > -1) ? m_values[m_index] : false;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTZoom.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.XMLUtils.elementIsInEncryptionSpace",
	"Comment": "returns true if the element is in xml encryption namespace and the localname equals the supplied one.",
	"Method": "boolean elementIsInEncryptionSpace(Element element,String localName){\r\n    if (element == null) {\r\n        return false;\r\n    }\r\n    return EncryptionConstants.EncryptionSpecNS.equals(element.getNamespaceURI()) && element.getLocalName().equals(localName);\r\n}"
}, {
	"Path": "org.docx4j.wml.RPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.openpackaging.io.Load.setCustomXmlDataStorageClass",
	"Comment": "set your preferred implementation of the customxmldatastorage\tinterface.its factory method will be used to create new instances.",
	"Method": "void setCustomXmlDataStorageClass(CustomXmlDataStorage customXmlDataStorageClassVal){\r\n    customXmlDataStorageClass = customXmlDataStorageClassVal;\r\n}"
}, {
	"Path": "org.docx4j.math.CTDPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTXmlColumnPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDataBar.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.nustaq.serialization.FSTConfiguration.setForceSerializable",
	"Comment": "treat unserializable classes same as if they would be serializable.",
	"Method": "FSTConfiguration setForceSerializable(boolean forceSerializable){\r\n    this.forceSerializable = forceSerializable;\r\n    return this;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTTextbox.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.w16cid.CTCommentsIds.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.netflix.genie.agent.utils.PathUtils.jobApplicationDirectoryPath",
	"Comment": "compose the path to an application directory inside a job directory.",
	"Method": "Path jobApplicationDirectoryPath(File jobDirectory,String appId){\r\n    return composePath(jobApplicationsDirectoryPath(jobDirectory), appId);\r\n}"
}, {
	"Path": "org.docx4j.math.CTAccPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotCache.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotAreaReferences.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xerces.util.EncodingMap.getJava2IANAMapping",
	"Comment": "returns the iana encoding name for the specified java encoding name.",
	"Method": "String getJava2IANAMapping(String javaEncoding){\r\n    return (String) fJava2IANAMap.get(javaEncoding);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Sheets.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.SheetView.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTQueryCache.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w15.CTCommentEx.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.TTFMtxEntry.getIndexAsString",
	"Comment": "returns a string representation of the index taking into account ifthe index is in the reserved range.",
	"Method": "String getIndexAsString(){\r\n    if (isIndexReserved()) {\r\n        return Integer.toString(getIndex()) + \" (reserved)\";\r\n    } else {\r\n        return Integer.toString(getIndex());\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTLocation.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.Sheet.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.EncodingInfo.inEncoding",
	"Comment": "this is heart of the code that determines if a given characteris in the given encoding. this method is probably expensive,and the answer should be cached.this method is not a public api,and should only be used internally within the serializer.",
	"Method": "boolean inEncoding(char ch,String encoding,boolean inEncoding,char high,char low,String encoding,boolean inEncoding,char ch,byte[] data){\r\n    final boolean isInEncoding;\r\n    if (data == null || data.length == 0) {\r\n        isInEncoding = false;\r\n    } else {\r\n        if (data[0] == 0)\r\n            isInEncoding = false;\r\n        else if (data[0] == '?' && ch != '?')\r\n            isInEncoding = false;\r\n        else {\r\n            isInEncoding = true;\r\n        }\r\n    }\r\n    return isInEncoding;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFill.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSingleXmlCell.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRangeSets.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTSRgbColor.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTHyperlink.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.c14n.implementations.NameSpaceSymbTable.getUnrenderedNodes",
	"Comment": "get all the unrendered nodes in the name space.for inclusive rendering",
	"Method": "void getUnrenderedNodes(Collection<Attr> result){\r\n    Iterator<NameSpaceSymbEntry> it = symb.entrySet().iterator();\r\n    while (it.hasNext()) {\r\n        NameSpaceSymbEntry n = it.next();\r\n        if (!n.rendered && n.n != null) {\r\n            n = (NameSpaceSymbEntry) n.clone();\r\n            needsClone();\r\n            symb.put(n.prefix, n);\r\n            n.lastrendered = n.uri;\r\n            n.rendered = true;\r\n            result.add(n.n);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMdxSet.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellWatches.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ElemDesc.isAttrFlagSet",
	"Comment": "tell if any of the bits of interest are set for a named attribute type.",
	"Method": "boolean isAttrFlagSet(String name,int flags){\r\n    return (null != m_attrs) ? ((m_attrs.getIgnoreCase(name) & flags) != 0) : false;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.TTFSubSetFile.getIncludedGlyphs",
	"Comment": "returns a list containing the glyph itself plus all glyphsthat this composite glyph uses",
	"Method": "List getIncludedGlyphs(FontFileReader in,int glyphOffset,Integer glyphIdx){\r\n    List ret = new java.util.ArrayList();\r\n    ret.add(glyphIdx);\r\n    int offset = glyphOffset + (int) mtxTab[glyphIdx.intValue()].getOffset() + 10;\r\n    Integer compositeIdx = null;\r\n    int flags = 0;\r\n    boolean moreComposites = true;\r\n    while (moreComposites) {\r\n        flags = in.readTTFUShort(offset);\r\n        compositeIdx = new Integer(in.readTTFUShort(offset + 2));\r\n        ret.add(compositeIdx);\r\n        offset += 4;\r\n        if ((flags & 1) > 0) {\r\n            offset += 4;\r\n        } else {\r\n            offset += 2;\r\n        }\r\n        if ((flags & 8) > 0) {\r\n            offset += 2;\r\n        } else if ((flags & 64) > 0) {\r\n            offset += 4;\r\n        } else if ((flags & 128) > 0) {\r\n            offset += 8;\r\n        }\r\n        if ((flags & 32) > 0) {\r\n            moreComposites = true;\r\n        } else {\r\n            moreComposites = false;\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.docx4j.jaxb.NamespacePrefixMapperSunInternal.getPreferredPrefix",
	"Comment": "returns a preferred prefix for the given namespace uri.this method is intended to be overrided by a derived class.",
	"Method": "String getPreferredPrefix(String namespaceUri,String suggestion,boolean requirePrefix){\r\n    return NamespacePrefixMappings.getPreferredPrefixStatic(namespaceUri, suggestion, requirePrefix);\r\n}"
}, {
	"Path": "org.docx4j.math.CTNary.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.Encodings.getWriter",
	"Comment": "returns a writer for the specified encoding based onan output stream.this is not a public api.",
	"Method": "Writer getWriter(OutputStream output,String encoding){\r\n    for (int i = 0; i < _encodings.length; ++i) {\r\n        if (_encodings[i].name.equalsIgnoreCase(encoding)) {\r\n            try {\r\n                String javaName = _encodings[i].javaName;\r\n                OutputStreamWriter osw = new OutputStreamWriter(output, javaName);\r\n                return osw;\r\n            } catch (java.lang.IllegalArgumentException iae) {\r\n            } catch (UnsupportedEncodingException usee) {\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        return new OutputStreamWriter(output, encoding);\r\n    } catch (java.lang.IllegalArgumentException iae) {\r\n        throw new UnsupportedEncodingException(encoding);\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.math.CTSSubSupPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTLimLowPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.vml.CTStroke.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setAlwaysShowPlaceholderText",
	"Comment": "sets the value of the alwaysshowplaceholdertext property.",
	"Method": "void setAlwaysShowPlaceholderText(BooleanDefaultTrue value){\r\n    this.alwaysShowPlaceholderText = value;\r\n}"
}, {
	"Path": "org.docx4j.wml.RunIns.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCsPageSetup.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.WorkbookPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMap.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.esc.XMLEscapeFactory.getInstance",
	"Comment": "returns an instance of a xml escape based on the given encoding.this method returns null if the encoding is not supported.",
	"Method": "XMLEscape getInstance(String encoding){\r\n    if (\"utf-8\".equals(encoding))\r\n        return XMLEscapeUTF8.UTF8_ESCAPE;\r\n    if (\"UTF-8\".equals(encoding))\r\n        return XMLEscapeUTF8.UTF8_ESCAPE;\r\n    if (\"ASCII\".equals(encoding))\r\n        return XMLEscapeASCII.ASCII_ESCAPE;\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "org.docx4j.services.client.MyRetryHandler.retryRequest",
	"Comment": "used retrycount and requestsentretryenabled to determine\tif the given method should be retried.",
	"Method": "boolean retryRequest(IOException exception,int executionCount,HttpContext context){\r\n    Args.notNull(exception, \"Exception parameter\");\r\n    Args.notNull(context, \"HTTP context\");\r\n    if (executionCount > this.retryCount) {\r\n        return false;\r\n    }\r\n    if (this.nonRetriableClasses.contains(exception.getClass())) {\r\n        return false;\r\n    } else {\r\n        for (final Class<? extends IOException> rejectException : this.nonRetriableClasses) {\r\n            if (rejectException.isInstance(exception)) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    final HttpClientContext clientContext = HttpClientContext.adapt(context);\r\n    final HttpRequest request = clientContext.getRequest();\r\n    if (requestIsAborted(request)) {\r\n        return false;\r\n    }\r\n    try {\r\n        System.out.println(\"sleeping  \" + executionCount);\r\n        Thread.sleep(RETRY_SLEEP_TIME * executionCount);\r\n    } catch (InterruptedException e) {\r\n        e.printStackTrace();\r\n    }\r\n    if (handleAsIdempotent(request)) {\r\n        System.out.println(\"retry handleAsIdempotent \" + executionCount);\r\n        return true;\r\n    }\r\n    if (!clientContext.isRequestSent() || this.requestSentRetryEnabled) {\r\n        System.out.println(\"retry  \" + executionCount);\r\n        return true;\r\n    }\r\n    System.out.println(\"do not retry  \" + exception.getClass().getName() + exception.getMessage());\r\n    return false;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTHeaderFooter.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPages.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTBorderBoxPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotArea.setCollapsedLevelsAreSubtotals",
	"Comment": "sets the value of the collapsedlevelsaresubtotals property.",
	"Method": "void setCollapsedLevelsAreSubtotals(Boolean value){\r\n    this.collapsedLevelsAreSubtotals = value;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSst.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.type1.PFMFile.getIsProportional",
	"Comment": "tells whether the font has proportional character spacing.",
	"Method": "boolean getIsProportional(){\r\n    return ((dfPitchAndFamily & 1) == 1);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.c14n.helper.C14nHelper.assertNotRelativeNS",
	"Comment": "this method throws an exception if the attribute value containsa relative uri.",
	"Method": "void assertNotRelativeNS(Attr attr){\r\n    if (attr == null) {\r\n        return;\r\n    }\r\n    String nodeAttrName = attr.getNodeName();\r\n    boolean definesDefaultNS = nodeAttrName.equals(\"xmlns\");\r\n    boolean definesNonDefaultNS = nodeAttrName.startsWith(\"xmlns:\");\r\n    if ((definesDefaultNS || definesNonDefaultNS) && namespaceIsRelative(attr)) {\r\n        String parentName = attr.getOwnerElement().getTagName();\r\n        String attrValue = attr.getValue();\r\n        Object[] exArgs = { parentName, nodeAttrName, attrValue };\r\n        throw new CanonicalizationException(\"c14n.Canonicalizer.RelativeNamespace\", exArgs);\r\n    }\r\n}"
}, {
	"Path": "com.topologi.diffx.load.text.TokenizerByWord.getWordEvent",
	"Comment": "returns the word event corresponding to the specified characters.",
	"Method": "TextEvent getWordEvent(String word){\r\n    TextEvent e = this.recycling.get(word);\r\n    if (e == null) {\r\n        e = new WordEvent(word);\r\n        this.recycling.put(word, e);\r\n    }\r\n    return e;\r\n}"
}, {
	"Path": "com.netflix.genie.agent.utils.PathUtils.jobEntityConfigPath",
	"Comment": "compose the path to the configurations directory for a given entity.",
	"Method": "Path jobEntityConfigPath(Path entityDirectory){\r\n    return composePath(new File(entityDirectory.toUri()), JobConstants.CONFIG_FILE_PATH_PREFIX);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.WriterToASCI.getOutputStream",
	"Comment": "get the output stream where the events will be serialized to.",
	"Method": "OutputStream getOutputStream(){\r\n    return m_os;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTrackChangesView.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.merge",
	"Comment": "returns the merge of the facts such that it can represent any of them",
	"Method": "Taint merge(Taint a,Taint b){\r\n    if (a == null) {\r\n        if (b == null) {\r\n            return null;\r\n        } else {\r\n            return new Taint(b);\r\n        }\r\n    } else if (b == null) {\r\n        return new Taint(a);\r\n    }\r\n    assert a != null && b != null;\r\n    Taint result = new Taint(State.merge(a.getState(), b.getState()));\r\n    if (a.variableIndex == b.variableIndex) {\r\n        result.variableIndex = a.variableIndex;\r\n    }\r\n    result.taintLocations.addAll(a.taintLocations);\r\n    result.taintLocations.addAll(b.taintLocations);\r\n    result.unknownLocations.addAll(a.unknownLocations);\r\n    result.unknownLocations.addAll(b.unknownLocations);\r\n    if (!result.isTainted()) {\r\n        mergeParameters(a, b, result);\r\n    }\r\n    mergeRealInstanceClass(a, b, result);\r\n    mergeTags(a, b, result);\r\n    if (a.constantValue != null && a.constantValue.equals(b.constantValue)) {\r\n        result.constantValue = a.constantValue;\r\n    }\r\n    if (FindSecBugsGlobalConfig.getInstance().isDebugTaintState()) {\r\n        result.setDebugInfo(\"[\" + a.getDebugInfo() + \"]+[\" + b.getDebugInfo() + \"]\");\r\n    }\r\n    assert !result.hasParameters() || result.isUnknown();\r\n    if (a.potentialValue != null) {\r\n        result.potentialValue = a.potentialValue;\r\n    } else if (b.potentialValue != null) {\r\n        result.potentialValue = b.potentialValue;\r\n    }\r\n    result.addAllSources(a.sources);\r\n    result.addAllSources(b.sources);\r\n    return result;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.getParameters",
	"Comment": "returns the method arguments influencing the taint state of this fact",
	"Method": "Set<Integer> getParameters(){\r\n    return Collections.unmodifiableSet(parameters);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCacheField.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMdxTuple.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTWebPublishing.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCellMergeTrackChange.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCacheSource.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTAutoFilter.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMetadataTypes.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.XMLWriterBase.setEncoding",
	"Comment": "sets the encoding to use.the encoding must match the encoding used if there is an underlyingoutputstreamwriter.",
	"Method": "void setEncoding(String encoding){\r\n    if (this.depth != 0)\r\n        throw new IllegalStateException(\"To late to set the encoding!\");\r\n    this.encoding = encoding;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.dom3.LSSerializerImpl.getParameterNames",
	"Comment": "this method returns a of the parameters supported by this domconfiguration object and for which at least one value can be set by the application",
	"Method": "DOMStringList getParameterNames(){\r\n    return new DOMStringListImpl(fRecognizedParameters);\r\n}"
}, {
	"Path": "org.docx4j.math.CTTwipsMeasure.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMeasureGroups.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTServerFormats.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSignedHpsMeasure.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToXMLStream.addUniqueAttribute",
	"Comment": "this method is used to add an attribute to the currently open element. the caller has guaranted that this attribute is unique, which means that itnot been seen before and will not be seen again.",
	"Method": "void addUniqueAttribute(String name,String value,int flags){\r\n    if (m_elemContext.m_startTagOpen) {\r\n        try {\r\n            final String patchedName = patchName(name);\r\n            final java.io.Writer writer = m_writer;\r\n            if ((flags & NO_BAD_CHARS) > 0 && m_xmlcharInfo.onlyQuotAmpLtGt) {\r\n                writer.write(' ');\r\n                writer.write(patchedName);\r\n                writer.write(\"=\\\"\");\r\n                writer.write(value);\r\n                writer.write('\"');\r\n            } else {\r\n                writer.write(' ');\r\n                writer.write(patchedName);\r\n                writer.write(\"=\\\"\");\r\n                writeAttrString(writer, value, this.getEncoding());\r\n                writer.write('\"');\r\n            }\r\n        } catch (IOException e) {\r\n            throw new SAXException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTServerFormat.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.ProofErr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFtnPos.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.vml.CTLine.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.dml.wordprocessingDrawing.Anchor.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.utils.XMLUtils.elementIsInSignature11Space",
	"Comment": "returns true if the element is in xml signature 1.1 namespace and the localname equals the supplied one.",
	"Method": "boolean elementIsInSignature11Space(Element element,String localName){\r\n    if (element == null) {\r\n        return false;\r\n    }\r\n    return Constants.SignatureSpec11NS.equals(element.getNamespaceURI()) && element.getLocalName().equals(localName);\r\n}"
}, {
	"Path": "org.docx4j.relationships.Relationships.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTUnderlineProperty.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.topologi.diffx.xml.sax.XMLWriterSAX.close",
	"Comment": "closes the writer.this method only checks that it is possible to close the writer.",
	"Method": "void close(){\r\n    Element open = peekElement();\r\n    if (open != ROOT)\r\n        throw new UnclosedElementException(open.name);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTQueryTableField.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTItem.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.Taint.isUnknown",
	"Comment": "checks whether values matching this fact can be untrusted but also safe",
	"Method": "boolean isUnknown(){\r\n    return state.isUnknown;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblPPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode.getOFileSystem",
	"Comment": "if this is opoifs based, return the npoifsfilesystem that this belong to, otherwise null if npoifs based",
	"Method": "OPOIFSFileSystem getOFileSystem(){\r\n    return _ofilesystem;\r\n}"
}, {
	"Path": "org.docx4j.wml.FontFamily.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.SectPrBase.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTVerticalAlignRun.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFontFamily.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocVars.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTMdx.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetIdMap.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.WorkbookPr.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTBooleanProperty.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.c14n.implementations.NameSpaceSymbTable.outputNodePush",
	"Comment": "push a frame for visible namespace. for inclusive rendering.",
	"Method": "void outputNodePush(){\r\n    push();\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.util.CharUtilities.classOf",
	"Comment": "return the appropriate charclass constant for the typeof the passed character.",
	"Method": "int classOf(char c){\r\n    switch(c) {\r\n        case CODE_EOT:\r\n            return EOT;\r\n        case LINEFEED_CHAR:\r\n            return LINEFEED;\r\n        case SPACE:\r\n        case CARRIAGE_RETURN:\r\n        case TAB:\r\n            return XMLWHITESPACE;\r\n        default:\r\n            return isAnySpace(c) ? UCWHITESPACE : NONWHITESPACE;\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.truetype.TTFFile.readCMAP",
	"Comment": "read the cmap table,return false if the table is not present or only unsupportedtables are present. currently only unicode cmaps are supported.set the unicodeindex in the ttfmtxentries and fills in thecmaps vector.",
	"Method": "boolean readCMAP(FontFileReader in){\r\n    unicodeMapping = new java.util.ArrayList();\r\n    seekTab(in, \"cmap\", 2);\r\n    int numCMap = in.readTTFUShort();\r\n    long cmapUniOffset = 0;\r\n    long symbolMapOffset = 0;\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(numCMap + \" cmap tables\");\r\n    }\r\n    for (int i = 0; i < numCMap; i++) {\r\n        int cmapPID = in.readTTFUShort();\r\n        int cmapEID = in.readTTFUShort();\r\n        long cmapOffset = in.readTTFULong();\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Platform ID: \" + cmapPID + \" Encoding: \" + cmapEID);\r\n        }\r\n        if (cmapPID == 3 && cmapEID == 1) {\r\n            cmapUniOffset = cmapOffset;\r\n        }\r\n        if (cmapPID == 3 && cmapEID == 0) {\r\n            symbolMapOffset = cmapOffset;\r\n        }\r\n    }\r\n    if (cmapUniOffset > 0) {\r\n        return readUnicodeCmap(in, cmapUniOffset, 1);\r\n    } else if (symbolMapOffset > 0) {\r\n        return readUnicodeCmap(in, symbolMapOffset, 0);\r\n    } else {\r\n        log.error(\"Unsupported TrueType font: No Unicode or Symbol cmap table\" + \" not present. Aborting\");\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTDiscretePr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.DelText.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCustomXmlRun.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFrameLayout.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTPivotField.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.TaintMethodConfig.getMutableStackIndices",
	"Comment": "returns all stack indices modified by method if there are any",
	"Method": "Collection<Integer> getMutableStackIndices(){\r\n    if (!hasMutableStackIndices()) {\r\n        throw new IllegalStateException(\"stack indices not set\");\r\n    }\r\n    return Collections.unmodifiableCollection(mutableStackIndices);\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.EmbedFontInfo.getFontTriplets",
	"Comment": "returns the list of font triplets associated with this font.",
	"Method": "List getFontTriplets(){\r\n    return fontTriplets;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTBreak.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFileRecoveryPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTExternalLink.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTFontSize.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTextScale.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSmartTagTypes.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTComment.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getUseWord2002TableStyleRules",
	"Comment": "gets the value of the useword2002tablestylerules property.",
	"Method": "BooleanDefaultTrue getUseWord2002TableStyleRules(){\r\n    return useWord2002TableStyleRules;\r\n}"
}, {
	"Path": "com.netflix.genie.agent.utils.PathUtils.jobCommandDirectoryPath",
	"Comment": "compose the path to the command directory inside a job directory.",
	"Method": "Path jobCommandDirectoryPath(File jobDirectory,String commandId){\r\n    return composePath(jobDirectory, JobConstants.GENIE_PATH_VAR, JobConstants.COMMAND_PATH_VAR, commandId);\r\n}"
}, {
	"Path": "org.docx4j.math.CTEqArrPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionSheetRename.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetId.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.wml.CTRubyAlign.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.SheetViews.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.w14.CTProps3D.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.fop.fonts.autodetect.FontInfoFinder.setEventListener",
	"Comment": "sets the font event listener that can be used to receive events about particular eventsin this class.",
	"Method": "void setEventListener(FontEventListener listener){\r\n    this.eventListener = listener;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.poi.hpsf.MutableSection.setPropertyBooleanValue",
	"Comment": "sets the value of the boolean property with the specifiedid.",
	"Method": "void setPropertyBooleanValue(int id,boolean value){\r\n    setProperty(id, Variant.VT_BOOL, Boolean.valueOf(value));\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFFTextType.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.fonts.foray.font.format.Panose.validateWeights",
	"Comment": "examines an array of weights, throwing various unchecked exceptions if the data is not valid.",
	"Method": "void validateWeights(byte[] weights){\r\n    if (weights == null) {\r\n        throw new NullPointerException(\"Weights may not be null\");\r\n    }\r\n    if (weights.length != Panose.Field.values().length) {\r\n        throw new IllegalArgumentException(\"Weights size expected: \" + Panose.Field.values().length + \", actual: \" + weights.length);\r\n    }\r\n    for (int i = 0; i < weights.length; i++) {\r\n        final byte weight = weights[i];\r\n        if (weight < 0 || weight > Byte.MAX_VALUE) {\r\n            throw new IllegalArgumentException(\"Weight element \" + i + \" is outside the range \" + \"of 0 thru 127.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCacheFields.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.serializer.ToStream.processAttributes",
	"Comment": "process the attributes, which means to write out the currentlycollected attributes to the writer. the attributes are notcleared by this method",
	"Method": "void processAttributes(java.io.Writer writer,int nAttrs){\r\n    String encoding = getEncoding();\r\n    for (int i = 0; i < nAttrs; i++) {\r\n        final String name = m_attributes.getQName(i);\r\n        final String value = m_attributes.getValue(i);\r\n        writer.write(' ');\r\n        writer.write(name);\r\n        writer.write(\"=\\\"\");\r\n        writeAttrString(writer, value, encoding);\r\n        writer.write('\\\"');\r\n    }\r\n}"
}, {
	"Path": "org.docx4j.wml.Highlight.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSharedItems.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.docx4j.math.CTSSupPr.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.model.fields.FieldRef.getFormFieldProperties",
	"Comment": "properties specific to formcheckbox, formdropdown, formtext",
	"Method": "CTFFData getFormFieldProperties(){\r\n    return formFieldProperties;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTFrame.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(Object getParent,Object getParent){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTTblCellMar.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTRevisionSheetRename.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTCellSmartTags.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTTableStyles.afterUnmarshal",
	"Comment": "this method is invoked by the jaxb implementation on each instance when unmarshalling completes.",
	"Method": "void afterUnmarshal(Unmarshaller unmarshaller,Object parent){\r\n    setParent(parent);\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTVolTopic.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTCompat.getTruncateFontHeightsLikeWP6",
	"Comment": "gets the value of the truncatefontheightslikewp6 property.",
	"Method": "BooleanDefaultTrue getTruncateFontHeightsLikeWP6(){\r\n    return truncateFontHeightsLikeWP6;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xerces.util.EncodingMap.getIANA2JavaMapping",
	"Comment": "returns the java encoding name for the specified iana encoding name.",
	"Method": "String getIANA2JavaMapping(String ianaEncoding){\r\n    return (String) fIANA2JavaMap.get(ianaEncoding);\r\n}"
}, {
	"Path": "org.docx4j.math.CTLimLoc.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTDocProtect.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}, {
	"Path": "org.docx4j.XmlUtils.prepareJAXBResult",
	"Comment": "prepare a jaxb transformation result for some given context.",
	"Method": "JAXBResult prepareJAXBResult(JAXBContext context){\r\n    final JAXBResult result;\r\n    try {\r\n        final Unmarshaller unmarshaller = context.createUnmarshaller();\r\n        unmarshaller.setEventHandler(new JaxbValidationEventHandler());\r\n        result = new JAXBResult(unmarshaller);\r\n    } catch (JAXBException e) {\r\n        throw new Docx4JException(\"Error preparing empty JAXB result\", e);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.docx4j.wml.CTSettings.setDisplayVerticalDrawingGridEvery",
	"Comment": "sets the value of the displayverticaldrawinggridevery property.",
	"Method": "void setDisplayVerticalDrawingGridEvery(CTSettings.DisplayVerticalDrawingGridEvery value){\r\n    this.displayVerticalDrawingGridEvery = value;\r\n}"
}, {
	"Path": "org.docx4j.org.apache.xml.security.c14n.implementations.CanonicalizerBase.canonicalizeXPathNodeSet",
	"Comment": "canonicalizes all the nodes included in the currentnode and contained in the xpathnodeset field.",
	"Method": "void canonicalizeXPathNodeSet(Node currentNode,Node endnode){\r\n    if (isVisibleInt(currentNode) == -1) {\r\n        return;\r\n    }\r\n    boolean currentNodeIsVisible = false;\r\n    NameSpaceSymbTable ns = new NameSpaceSymbTable();\r\n    if (currentNode != null && Node.ELEMENT_NODE == currentNode.getNodeType()) {\r\n        getParentNameSpaces((Element) currentNode, ns);\r\n    }\r\n    if (currentNode == null) {\r\n        return;\r\n    }\r\n    Node sibling = null;\r\n    Node parentNode = null;\r\n    OutputStream writer = this.writer;\r\n    int documentLevel = NODE_BEFORE_DOCUMENT_ELEMENT;\r\n    Map<String, byte[]> cache = new HashMap<String, byte[]>();\r\n    do {\r\n        switch(currentNode.getNodeType()) {\r\n            case Node.ENTITY_NODE:\r\n            case Node.NOTATION_NODE:\r\n            case Node.ATTRIBUTE_NODE:\r\n                throw new CanonicalizationException(\"empty\", new Object[] { \"illegal node type during traversal\" });\r\n            case Node.DOCUMENT_FRAGMENT_NODE:\r\n            case Node.DOCUMENT_NODE:\r\n                ns.outputNodePush();\r\n                sibling = currentNode.getFirstChild();\r\n                break;\r\n            case Node.COMMENT_NODE:\r\n                if (this.includeComments && isVisibleDO(currentNode, ns.getLevel()) == 1) {\r\n                    outputCommentToWriter((Comment) currentNode, writer, documentLevel);\r\n                }\r\n                break;\r\n            case Node.PROCESSING_INSTRUCTION_NODE:\r\n                if (isVisible(currentNode)) {\r\n                    outputPItoWriter((ProcessingInstruction) currentNode, writer, documentLevel);\r\n                }\r\n                break;\r\n            case Node.TEXT_NODE:\r\n            case Node.CDATA_SECTION_NODE:\r\n                if (isVisible(currentNode)) {\r\n                    outputTextToWriter(currentNode.getNodeValue(), writer);\r\n                    for (Node nextSibling = currentNode.getNextSibling(); nextSibling != null && (nextSibling.getNodeType() == Node.TEXT_NODE || nextSibling.getNodeType() == Node.CDATA_SECTION_NODE); nextSibling = nextSibling.getNextSibling()) {\r\n                        outputTextToWriter(nextSibling.getNodeValue(), writer);\r\n                        currentNode = nextSibling;\r\n                        sibling = currentNode.getNextSibling();\r\n                    }\r\n                }\r\n                break;\r\n            case Node.ELEMENT_NODE:\r\n                documentLevel = NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;\r\n                Element currentElement = (Element) currentNode;\r\n                String name = null;\r\n                int i = isVisibleDO(currentNode, ns.getLevel());\r\n                if (i == -1) {\r\n                    sibling = currentNode.getNextSibling();\r\n                    break;\r\n                }\r\n                currentNodeIsVisible = i == 1;\r\n                if (currentNodeIsVisible) {\r\n                    ns.outputNodePush();\r\n                    writer.write('<');\r\n                    name = currentElement.getTagName();\r\n                    UtfHelpper.writeByte(name, writer, cache);\r\n                } else {\r\n                    ns.push();\r\n                }\r\n                Iterator<Attr> attrs = handleAttributes(currentElement, ns);\r\n                if (attrs != null) {\r\n                    while (attrs.hasNext()) {\r\n                        Attr attr = attrs.next();\r\n                        outputAttrToWriter(attr.getNodeName(), attr.getNodeValue(), writer, cache);\r\n                    }\r\n                }\r\n                if (currentNodeIsVisible) {\r\n                    writer.write('>');\r\n                }\r\n                sibling = currentNode.getFirstChild();\r\n                if (sibling == null) {\r\n                    if (currentNodeIsVisible) {\r\n                        writer.write(END_TAG.clone());\r\n                        UtfHelpper.writeByte(name, writer, cache);\r\n                        writer.write('>');\r\n                        ns.outputNodePop();\r\n                    } else {\r\n                        ns.pop();\r\n                    }\r\n                    if (parentNode != null) {\r\n                        sibling = currentNode.getNextSibling();\r\n                    }\r\n                } else {\r\n                    parentNode = currentElement;\r\n                }\r\n                break;\r\n            case Node.DOCUMENT_TYPE_NODE:\r\n            default:\r\n                break;\r\n        }\r\n        while (sibling == null && parentNode != null) {\r\n            if (isVisible(parentNode)) {\r\n                writer.write(END_TAG.clone());\r\n                UtfHelpper.writeByte(((Element) parentNode).getTagName(), writer, cache);\r\n                writer.write('>');\r\n                ns.outputNodePop();\r\n            } else {\r\n                ns.pop();\r\n            }\r\n            if (parentNode == endnode) {\r\n                return;\r\n            }\r\n            sibling = parentNode.getNextSibling();\r\n            parentNode = parentNode.getParentNode();\r\n            if (parentNode == null || Node.ELEMENT_NODE != parentNode.getNodeType()) {\r\n                parentNode = null;\r\n                documentLevel = NODE_AFTER_DOCUMENT_ELEMENT;\r\n            }\r\n        }\r\n        if (sibling == null) {\r\n            return;\r\n        }\r\n        currentNode = sibling;\r\n        sibling = currentNode.getNextSibling();\r\n    } while (true);\r\n}"
}, {
	"Path": "org.eclipse.compare.rangedifferencer.RangeDifference.ancestorEnd",
	"Comment": "returns the end index of the entity range on the ancestor side.",
	"Method": "int ancestorEnd(){\r\n    return lAncestorStart + lAncestorLength;\r\n}"
}, {
	"Path": "org.xlsx4j.sml.CTSheetId.getParent",
	"Comment": "gets the parent object in the object tree representing the unmarshalled xml document.",
	"Method": "Object getParent(){\r\n    return this.parent;\r\n}"
}]