[{
	"Path": "org.hotswap.agent.javassist.CtNewMethod.getter",
	"Comment": "creates a public getter method.the getter method returns the valueof the specified field in the class to which this method is added.the created method is initially not static even if the field isstatic.change the modifiers if the method should be static.",
	"Method": "CtMethod getter(String methodName,CtField field){\r\n    FieldInfo finfo = field.getFieldInfo2();\r\n    String fieldType = finfo.getDescriptor();\r\n    String desc = \"()\" + fieldType;\r\n    ConstPool cp = finfo.getConstPool();\r\n    MethodInfo minfo = new MethodInfo(cp, methodName, desc);\r\n    minfo.setAccessFlags(AccessFlag.PUBLIC);\r\n    Bytecode code = new Bytecode(cp, 2, 1);\r\n    try {\r\n        String fieldName = finfo.getName();\r\n        if ((finfo.getAccessFlags() & AccessFlag.STATIC) == 0) {\r\n            code.addAload(0);\r\n            code.addGetfield(Bytecode.THIS, fieldName, fieldType);\r\n        } else\r\n            code.addGetstatic(Bytecode.THIS, fieldName, fieldType);\r\n        code.addReturn(field.getType());\r\n    } catch (NotFoundException e) {\r\n        throw new CannotCompileException(e);\r\n    }\r\n    minfo.setCodeAttribute(code.toCodeAttribute());\r\n    CtClass cc = field.getDeclaringClass();\r\n    return new CtMethod(minfo, cc);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.NewArray.getLineNumber",
	"Comment": "returns the line number of the source line containing thearray creation.",
	"Method": "int getLineNumber(){\r\n    return super.getLineNumber();\r\n}"
}, {
	"Path": "com.hazelcast.query.impl.predicates.PredicateTestUtils.createMockNegatablePredicate",
	"Comment": "create a negatable mock predicate. the created mock predicate returns passed the predicatepassed as negation argument",
	"Method": "Predicate createMockNegatablePredicate(Predicate negation){\r\n    NegatablePredicate negatablePredicate = mock(NegatablePredicate.class, withSettings().extraInterfaces(Predicate.class));\r\n    when(negatablePredicate.negate()).thenReturn(negation);\r\n    return (Predicate) negatablePredicate;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.ClassPool.getCached",
	"Comment": "provide a hook so that subclasses can do their owncaching of classes.",
	"Method": "CtClass getCached(String classname){\r\n    return (CtClass) classes.get(classname);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.makeUniqueName",
	"Comment": "makes a unique member name.this method guarantees thatthe returned name is not used as a prefix of any methodsor fields visible in this class.if the returned name is xyz, then any method or field namesin this class do not start with xyz.",
	"Method": "String makeUniqueName(String prefix){\r\n    throw new RuntimeException(\"not available in \" + getName());\r\n}"
}, {
	"Path": "com.hazelcast.query.impl.extractor.AbstractExtractionTest.setup",
	"Comment": "sets up the hz configuration for the given query specification",
	"Method": "void setup(Query query){\r\n    Config config = setupMap(getInstanceConfigurator());\r\n    setupIndexes(config, query);\r\n    setupInstance(config);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.ClassPool.checkNotExists",
	"Comment": "this method returns null if this or its parent class pool doesnot contain a ctclass object with the class name.",
	"Method": "CtClass checkNotExists(String classname){\r\n    CtClass clazz = getCached(classname);\r\n    if (clazz == null)\r\n        if (!childFirstLookup && parent != null) {\r\n            try {\r\n                clazz = parent.get0(classname, true);\r\n            } catch (NotFoundException e) {\r\n            }\r\n        }\r\n    return clazz;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.FieldAccess.getSignature",
	"Comment": "returns the signature of the field type.the signature is represented by a character stringcalled field descriptor, which is defined in the jvm specification.",
	"Method": "String getSignature(){\r\n    int index = iterator.u16bitAt(currentPos + 1);\r\n    return getConstPool().getFieldrefType(index);\r\n}"
}, {
	"Path": "org.hotswap.agent.command.impl.SchedulerImpl.processCommands",
	"Comment": "one cycle of the scheduler agent. process all commands which are not currentlyrunning and time lower than current milliseconds.",
	"Method": "boolean processCommands(){\r\n    Long currentTime = System.currentTimeMillis();\r\n    synchronized (scheduledCommands) {\r\n        for (Iterator<Map.Entry<Command, DuplicateScheduleConfig>> it = scheduledCommands.entrySet().iterator(); it.hasNext(); ) {\r\n            Map.Entry<Command, DuplicateScheduleConfig> entry = it.next();\r\n            DuplicateScheduleConfig config = entry.getValue();\r\n            Command command = entry.getKey();\r\n            if (config.getTime() < currentTime) {\r\n                if (runningCommands.contains(command)) {\r\n                    if (config.getBehaviour().equals(DuplicateSheduleBehaviour.SKIP)) {\r\n                        LOGGER.debug(\"Skipping duplicate running command {}\", command);\r\n                        it.remove();\r\n                    } else if (config.getBehaviour().equals(DuplicateSheduleBehaviour.RUN_DUPLICATE)) {\r\n                        executeCommand(command);\r\n                        it.remove();\r\n                    }\r\n                } else {\r\n                    executeCommand(command);\r\n                    it.remove();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.hazelcast.transaction.impl.TransactionImpl_TwoPhaseTest.commit_whenOneTransactionLogRecord_thenCommit",
	"Comment": "there is an optimization for single item transactions so they can commit without preparing",
	"Method": "void commit_whenOneTransactionLogRecord_thenCommit(){\r\n    TransactionOptions options = new TransactionOptions().setTransactionType(TWO_PHASE).setDurability(0);\r\n    TransactionImpl tx = new TransactionImpl(txManagerService, nodeEngine, options, \"dummy-uuid\");\r\n    tx.begin();\r\n    tx.add(new MockTransactionLogRecord());\r\n    tx.commit();\r\n    assertEquals(COMMITTED, tx.getState());\r\n}"
}, {
	"Path": "com.hazelcast.test.HazelcastTestSupport.assertEqualsStringFormat",
	"Comment": "this method executes the normal assertequals with expected and actual values.in addition it formats the given string with those values to provide a good assert message.",
	"Method": "void assertEqualsStringFormat(String message,Object expected,Object actual){\r\n    assertEquals(format(message, expected, actual), expected, actual);\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientFlakeIdGeneratorConfig.getName",
	"Comment": "returns the configuration name. this can be actual object name or pattern.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "com.hazelcast.test.bounce.BounceMemberRule.setup",
	"Comment": "start cluster with configured number of members and member configuration",
	"Method": "void setup(){\r\n    assert (bounceTestConfig.getClusterSize() > 1) : \"Cluster size must be at least 2.\";\r\n    if (bounceTestConfig.getDriverType() == CLIENT) {\r\n        factory = newTestHazelcastFactory();\r\n    } else {\r\n        factory = new TestHazelcastInstanceFactory();\r\n    }\r\n    Config memberConfig = bounceTestConfig.getMemberConfig();\r\n    for (int i = 0; i < bounceTestConfig.getClusterSize(); i++) {\r\n        members.set(i, factory.newHazelcastInstance(memberConfig));\r\n    }\r\n    HazelcastInstance[] drivers = bounceTestConfig.getDriverFactory().createTestDrivers(this);\r\n    assert drivers.length == bounceTestConfig.getDriverCount() : \"Driver factory should return \" + bounceTestConfig.getDriverCount() + \" test drivers.\";\r\n    for (int i = 0; i < drivers.length; i++) {\r\n        testDrivers.set(i, drivers[i]);\r\n    }\r\n    testRunning.set(true);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtBehavior.getGenericSignature",
	"Comment": "returns the generic signature of the method.it represents parameter types including type variables.",
	"Method": "String getGenericSignature(){\r\n    SignatureAttribute sa = (SignatureAttribute) methodInfo.getAttribute(SignatureAttribute.tag);\r\n    return sa == null ? null : sa.getSignature();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtBehavior.getAvailableParameterAnnotations",
	"Comment": "returns the parameter annotations associated with this method or constructor.if any annotations are not on the classpath, they are not included in thereturned array.",
	"Method": "Object[][] getAvailableParameterAnnotations(){\r\n    try {\r\n        return getParameterAnnotations(true);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new RuntimeException(\"Unexpected exception\", e);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.distribution.markdown.MarkdownProcessor.resolveMarkdownDoc",
	"Comment": "resolve readme.md file from plugin package and from main plugin directory.",
	"Method": "String resolveMarkdownDoc(Class plugin){\r\n    InputStream is = resolveSamePackageReadme(plugin);\r\n    if (is == null) {\r\n        is = resolveMavenMainDirectoryReadme(plugin);\r\n    }\r\n    if (is != null)\r\n        return IOUtils.streamToString(is);\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.Type.getComponent",
	"Comment": "returns the array component if this type is an array. if the typeis not an array null is returned.",
	"Method": "Type getComponent(){\r\n    if (this.clazz == null || !this.clazz.isArray())\r\n        return null;\r\n    CtClass component;\r\n    try {\r\n        component = this.clazz.getComponentType();\r\n    } catch (NotFoundException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    Type type = (Type) prims.get(component);\r\n    return (type != null) ? type : new Type(component);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtBehavior.insertAt",
	"Comment": "inserts bytecode at the specified line in the body.if there is nota statement at the specified line, the bytecode might be insertedat the line including the first statement after that line specified.for example, if there is only a closing brace at that line, thebytecode would be inserted at another line below.to know exactly where the bytecode will be inserted, call withmodify set to false.",
	"Method": "int insertAt(int lineNum,String src,int insertAt,int lineNum,boolean modify,String src){\r\n    CodeAttribute ca = methodInfo.getCodeAttribute();\r\n    if (ca == null)\r\n        throw new CannotCompileException(\"no method body\");\r\n    LineNumberAttribute ainfo = (LineNumberAttribute) ca.getAttribute(LineNumberAttribute.tag);\r\n    if (ainfo == null)\r\n        throw new CannotCompileException(\"no line number info\");\r\n    LineNumberAttribute.Pc pc = ainfo.toNearPc(lineNum);\r\n    lineNum = pc.line;\r\n    int index = pc.index;\r\n    if (!modify)\r\n        return lineNum;\r\n    CtClass cc = declaringClass;\r\n    cc.checkModify();\r\n    CodeIterator iterator = ca.iterator();\r\n    Javac jv = new Javac(cc);\r\n    try {\r\n        jv.recordLocalVariables(ca, index);\r\n        jv.recordParams(getParameterTypes(), Modifier.isStatic(getModifiers()));\r\n        jv.setMaxLocals(ca.getMaxLocals());\r\n        jv.compileStmnt(src);\r\n        Bytecode b = jv.getBytecode();\r\n        int locals = b.getMaxLocals();\r\n        int stack = b.getMaxStack();\r\n        ca.setMaxLocals(locals);\r\n        if (stack > ca.getMaxStack())\r\n            ca.setMaxStack(stack);\r\n        index = iterator.insertAt(index, b.get());\r\n        iterator.insert(b.getExceptionTable(), index);\r\n        methodInfo.rebuildStackMapIf6(cc.getClassPool(), cc.getClassFile2());\r\n        return lineNum;\r\n    } catch (NotFoundException e) {\r\n        throw new CannotCompileException(e);\r\n    } catch (CompileError e) {\r\n        throw new CannotCompileException(e);\r\n    } catch (BadBytecode e) {\r\n        throw new CannotCompileException(e);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.compiler.MemberCodeGen.getMajorVersion",
	"Comment": "returns the major version of the class filetargeted by this compilation.",
	"Method": "int getMajorVersion(){\r\n    ClassFile cf = thisClass.getClassFile2();\r\n    if (cf == null)\r\n        return ClassFile.MAJOR_VERSION;\r\n    return cf.getMajorVersion();\r\n}"
}, {
	"Path": "com.hazelcast.test.HazelcastTestSupport.sleepAndStop",
	"Comment": "sleeps for the given amount of time and after that, sets stop to true.if stop is changed to true while sleeping, the calls returns before waiting the full sleeping period.this method is very useful for stress tests that run for a certain amount of time. but if one of the stress testsruns into a failure, the test should be aborted immediately. this is done by letting the thread set stop to true.",
	"Method": "void sleepAndStop(AtomicBoolean stop,long durationSeconds){\r\n    final long startMillis = System.currentTimeMillis();\r\n    for (int i = 0; i < durationSeconds; i++) {\r\n        if (stop.get()) {\r\n            return;\r\n        }\r\n        sleepSeconds(1);\r\n        if (System.currentTimeMillis() - startMillis > SECONDS.toMillis(durationSeconds)) {\r\n            break;\r\n        }\r\n    }\r\n    stop.set(true);\r\n}"
}, {
	"Path": "org.hotswap.agent.config.PluginManager.init",
	"Comment": "initialize the singleton plugin manager.create new resource watcher using watcherfactory and start it in separate thread.create new scheduler and start it in separate thread.scan for pluginsregister hotswaptransformer with the javaagent instrumentation class",
	"Method": "void init(Instrumentation instrumentation){\r\n    this.instrumentation = instrumentation;\r\n    ClassLoader classLoader = getClass().getClassLoader();\r\n    classLoaderConfigurations.put(classLoader, new PluginConfiguration(classLoader));\r\n    if (watcher == null) {\r\n        try {\r\n            watcher = new WatcherFactory().getWatcher();\r\n        } catch (IOException e) {\r\n            LOGGER.debug(\"Unable to create default watcher.\", e);\r\n        }\r\n    }\r\n    watcher.run();\r\n    if (scheduler == null) {\r\n        scheduler = new SchedulerImpl();\r\n    }\r\n    scheduler.run();\r\n    pluginRegistry.scanPlugins(getClass().getClassLoader(), PLUGIN_PACKAGE);\r\n    LOGGER.debug(\"Registering transformer \");\r\n    instrumentation.addTransformer(hotswapTransformer);\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientSecurityConfig.setCredentialsFactoryConfig",
	"Comment": "credentials factory config allows user to pass custom properties and use group config when instantiatinga credentials object.",
	"Method": "ClientSecurityConfig setCredentialsFactoryConfig(CredentialsFactoryConfig credentialsFactoryConfig){\r\n    this.credentialsFactoryConfig = credentialsFactoryConfig;\r\n    return this;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getDeclaredMethods",
	"Comment": "gets all methods declared in the class.the inherited methodsare not included.",
	"Method": "CtMethod[] getDeclaredMethods(CtMethod[] getDeclaredMethods,String name){\r\n    throw new NotFoundException(name);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.compiler.Javac.recordLocalVariables",
	"Comment": "records local variables available at the specified program counter.if the localvariableattribute is not available, this method does notrecord any local variable.it only returns false.",
	"Method": "boolean recordLocalVariables(CodeAttribute ca,int pc){\r\n    LocalVariableAttribute va = (LocalVariableAttribute) ca.getAttribute(LocalVariableAttribute.tag);\r\n    if (va == null)\r\n        return false;\r\n    int n = va.tableLength();\r\n    for (int i = 0; i < n; ++i) {\r\n        int start = va.startPc(i);\r\n        int len = va.codeLength(i);\r\n        if (start <= pc && pc < start + len)\r\n            gen.recordVariable(va.descriptor(i), va.variableName(i), va.index(i), stable);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.MethodInfo.addAttribute",
	"Comment": "appends an attribute. if there is already an attribute with the samename, the new one substitutes for it.",
	"Method": "void addAttribute(AttributeInfo info){\r\n    if (attribute == null)\r\n        attribute = new ArrayList<AttributeInfo>();\r\n    AttributeInfo.remove(attribute, info.getName());\r\n    attribute.add(info);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.scopedpool.SoftValueHashMap.get",
	"Comment": "returns the value to which this map maps the specified key.if this map does not contain a value for this key, then returnnull.",
	"Method": "V get(Object key){\r\n    processQueue();\r\n    return valueOrNull(hash.get(key));\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.compiler.MemberResolver.compareSignature",
	"Comment": "returns yes if actual parameter types matches the given signature.argtypes, argdims, and argclassnames represent actual parameters.this method does not correctly implement the java method dispatchalgorithm.if some of the parameter types exactly match but others are subtypes ofthe corresponding type in the signature, this method returns the numberof parameter types that do not exactly match.",
	"Method": "int compareSignature(String desc,int[] argTypes,int[] argDims,String[] argClassNames){\r\n    int result = YES;\r\n    int i = 1;\r\n    int nArgs = argTypes.length;\r\n    if (nArgs != Descriptor.numOfParameters(desc))\r\n        return NO;\r\n    int len = desc.length();\r\n    for (int n = 0; i < len; ++n) {\r\n        char c = desc.charAt(i++);\r\n        if (c == ')')\r\n            return (n == nArgs ? result : NO);\r\n        else if (n >= nArgs)\r\n            return NO;\r\n        int dim = 0;\r\n        while (c == '[') {\r\n            ++dim;\r\n            c = desc.charAt(i++);\r\n        }\r\n        if (argTypes[n] == NULL) {\r\n            if (dim == 0 && c != 'L')\r\n                return NO;\r\n            if (c == 'L')\r\n                i = desc.indexOf(';', i) + 1;\r\n        } else if (argDims[n] != dim) {\r\n            if (!(dim == 0 && c == 'L' && desc.startsWith(\"java/lang/Object;\", i)))\r\n                return NO;\r\n            i = desc.indexOf(';', i) + 1;\r\n            result++;\r\n            if (i <= 0)\r\n                return NO;\r\n        } else if (c == 'L') {\r\n            int j = desc.indexOf(';', i);\r\n            if (j < 0 || argTypes[n] != CLASS)\r\n                return NO;\r\n            String cname = desc.substring(i, j);\r\n            if (!cname.equals(argClassNames[n])) {\r\n                CtClass clazz = lookupClassByJvmName(argClassNames[n]);\r\n                try {\r\n                    if (clazz.subtypeOf(lookupClassByJvmName(cname)))\r\n                        result++;\r\n                    else\r\n                        return NO;\r\n                } catch (NotFoundException e) {\r\n                    result++;\r\n                }\r\n            }\r\n            i = j + 1;\r\n        } else {\r\n            int t = descToType(c);\r\n            int at = argTypes[n];\r\n            if (t != at)\r\n                if (t == INT && (at == SHORT || at == BYTE || at == CHAR))\r\n                    result++;\r\n                else\r\n                    return NO;\r\n        }\r\n    }\r\n    return NO;\r\n}"
}, {
	"Path": "com.hazelcast.test.SplitBrainTestSupport.config",
	"Comment": "override this method to create a custom hazelcast configuration.",
	"Method": "Config config(){\r\n    return smallInstanceConfig().setProperty(GroupProperty.MERGE_FIRST_RUN_DELAY_SECONDS.getName(), \"5\").setProperty(GroupProperty.MERGE_NEXT_RUN_DELAY_SECONDS.getName(), \"5\");\r\n}"
}, {
	"Path": "org.hotswap.agent.distribution.markdown.MarkdownProcessor.resolveSamePackageReadme",
	"Comment": "find readme.md in a same package as the plugin. if found, it has precedence before main plugin documentation",
	"Method": "InputStream resolveSamePackageReadme(Class plugin){\r\n    return plugin.getResourceAsStream(\"README.md\");\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.Instanceof.where",
	"Comment": "returns the method or constructor containing the instanceofexpression represented by this object.",
	"Method": "CtBehavior where(){\r\n    return super.where();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.Frame.isJsrMerged",
	"Comment": "whether or not state from the source jsr instruction has been merged",
	"Method": "boolean isJsrMerged(){\r\n    return jsrMerged;\r\n}"
}, {
	"Path": "com.hazelcast.test.starter.HazelcastVersionLocator.locateMember",
	"Comment": "attempts to locate member artifact in local maven repository, then downloads",
	"Method": "File locateMember(String version,File target,boolean enterprise){\r\n    File artifact = new File(LOCAL_M2_REPOSITORY_PREFIX + constructPathForMember(version, enterprise));\r\n    if (artifact.exists()) {\r\n        return artifact;\r\n    } else {\r\n        return downloadMember(version, target, enterprise);\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientNetworkConfig.getDiscoveryConfig",
	"Comment": "returns the configuration of the hazelcast discovery spi and configured discovery providers",
	"Method": "DiscoveryConfig getDiscoveryConfig(){\r\n    if (discoveryConfig == null) {\r\n        discoveryConfig = new DiscoveryConfig();\r\n    }\r\n    return discoveryConfig;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ClassFile.getInterfaces",
	"Comment": "returns the names of the interfaces implemented by the class.the returned array is read only.",
	"Method": "String[] getInterfaces(){\r\n    if (cachedInterfaces != null)\r\n        return cachedInterfaces;\r\n    String[] rtn = null;\r\n    if (interfaces == null)\r\n        rtn = new String[0];\r\n    else {\r\n        String[] list = new String[interfaces.length];\r\n        for (int i = 0; i < interfaces.length; ++i) list[i] = constPool.getClassInfo(interfaces[i]);\r\n        rtn = list;\r\n    }\r\n    cachedInterfaces = rtn;\r\n    return rtn;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtConstructor.isClassInitializer",
	"Comment": "returns true if this object represents a static initializer.",
	"Method": "boolean isClassInitializer(){\r\n    return methodInfo.isStaticInitializer();\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientNetworkConfig.setClientIcmpPingConfig",
	"Comment": "icmp ping is used to detect if machine that a remote hazelcast member runs on alive or not",
	"Method": "ClientNetworkConfig setClientIcmpPingConfig(ClientIcmpPingConfig clientIcmpPingConfig){\r\n    this.clientIcmpPingConfig = clientIcmpPingConfig;\r\n    return this;\r\n}"
}, {
	"Path": "org.hotswap.agent.annotation.handler.WatchEventCommand.createCtClass",
	"Comment": "creats javaassist ctclass for bytecode manipulation. add default classloader.",
	"Method": "CtClass createCtClass(URI uri,ClassLoader classLoader){\r\n    ClassPool cp = new ClassPool();\r\n    cp.appendClassPath(new LoaderClassPath(classLoader));\r\n    return cp.makeClass(new ByteArrayInputStream(IOUtils.toByteArray(uri)));\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.Expr.where",
	"Comment": "returns the constructor or method containing the expression.",
	"Method": "CtBehavior where(){\r\n    MethodInfo mi = thisMethod;\r\n    CtBehavior[] cb = thisClass.getDeclaredBehaviors();\r\n    for (int i = cb.length - 1; i >= 0; --i) if (cb[i].getMethodInfo2() == mi)\r\n        return cb[i];\r\n    CtConstructor init = thisClass.getClassInitializer();\r\n    if (init != null && init.getMethodInfo2() == mi)\r\n        return init;\r\n    for (int i = cb.length - 1; i >= 0; --i) {\r\n        if (thisMethod.getName().equals(cb[i].getMethodInfo2().getName()) && thisMethod.getDescriptor().equals(cb[i].getMethodInfo2().getDescriptor())) {\r\n            return cb[i];\r\n        }\r\n    }\r\n    throw new RuntimeException(\"fatal: not found\");\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.Handler.where",
	"Comment": "returns the method or constructor containing the catch clause.",
	"Method": "CtBehavior where(){\r\n    return super.where();\r\n}"
}, {
	"Path": "com.hazelcast.spi.impl.operationservice.impl.OperationServiceImpl_timeoutTest.testTimeoutWithMultiMemberCluster",
	"Comment": "there was a memory leak caused by the invocation not releasing the backup registration when there is a timeout.",
	"Method": "void testTimeoutWithMultiMemberCluster(){\r\n    TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\r\n    HazelcastInstance hz1 = factory.newHazelcastInstance();\r\n    HazelcastInstance hz2 = factory.newHazelcastInstance();\r\n    final IQueue<Object> q = hz1.getQueue(\"queue\");\r\n    for (int k = 0; k < 1000; k++) {\r\n        Object response = q.poll(1, TimeUnit.MILLISECONDS);\r\n        assertNull(response);\r\n    }\r\n    OperationServiceImpl_BasicTest.assertNoLitterInOpService(hz1);\r\n    OperationServiceImpl_BasicTest.assertNoLitterInOpService(hz2);\r\n}"
}, {
	"Path": "org.hotswap.agent.config.PluginManager.closeClassLoader",
	"Comment": "remove any classloader reference and close all plugin instances associated with classloader.this method is called typically after webapp undeploy.",
	"Method": "void closeClassLoader(ClassLoader classLoader){\r\n    pluginRegistry.closeClassLoader(classLoader);\r\n    classLoaderConfigurations.remove(classLoader);\r\n    hotswapTransformer.closeClassLoader(classLoader);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.ClassPool.cacheCtClass",
	"Comment": "provides a hook so that subclasses can do their owncaching of classes.",
	"Method": "void cacheCtClass(String classname,CtClass c,boolean dynamic){\r\n    classes.put(classname, c);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.compiler.JvstCodeGen.atCastToRtype",
	"Comment": "inserts a cast operator to the return type.if the return type is void, this does nothing.",
	"Method": "void atCastToRtype(CastExpr expr){\r\n    expr.getOprand().accept(this);\r\n    if (exprType == VOID || isRefType(exprType) || arrayDim > 0)\r\n        compileUnwrapValue(returnType, bytecode);\r\n    else if (returnType instanceof CtPrimitiveType) {\r\n        CtPrimitiveType pt = (CtPrimitiveType) returnType;\r\n        int destType = MemberResolver.descToType(pt.getDescriptor());\r\n        atNumCastExpr(exprType, destType);\r\n        exprType = destType;\r\n        arrayDim = 0;\r\n        className = null;\r\n    } else\r\n        throw new CompileError(\"invalid cast\");\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.Descriptor.ofMethod",
	"Comment": "returns the descriptor representing a method that receivesthe given parameter types and returns the given type.",
	"Method": "String ofMethod(CtClass returnType,CtClass[] paramTypes){\r\n    StringBuffer desc = new StringBuffer();\r\n    desc.append('(');\r\n    if (paramTypes != null) {\r\n        int n = paramTypes.length;\r\n        for (int i = 0; i < n; ++i) toDescriptor(desc, paramTypes[i]);\r\n    }\r\n    desc.append(')');\r\n    if (returnType != null)\r\n        toDescriptor(desc, returnType);\r\n    return desc.toString();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.FieldAccess.getLineNumber",
	"Comment": "returns the line number of the source line containing thefield access.",
	"Method": "int getLineNumber(){\r\n    return super.getLineNumber();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ClassFile.addMethod",
	"Comment": "appends a method to the class.if there is a bridge method with the same name and signature,then the bridge method is removed before a new method is added.",
	"Method": "void addMethod(MethodInfo minfo){\r\n    testExistingMethod(minfo);\r\n    methods.add(minfo);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ConstPool.getClassName",
	"Comment": "returns the name of the class using this constant pool table.",
	"Method": "String getClassName(String getClassName,ConstPool cp,String getClassName,ConstPool cp){\r\n    return getClassInfo(thisClassInfo);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtMember.visibleFrom",
	"Comment": "returns true if this member is accessible from the given class.",
	"Method": "boolean visibleFrom(CtClass clazz){\r\n    int mod = getModifiers();\r\n    if (Modifier.isPublic(mod))\r\n        return true;\r\n    else if (Modifier.isPrivate(mod))\r\n        return clazz == declaringClass;\r\n    else {\r\n        String declName = declaringClass.getPackageName();\r\n        String fromName = clazz.getPackageName();\r\n        boolean visible;\r\n        if (declName == null)\r\n            visible = fromName == null;\r\n        else\r\n            visible = declName.equals(fromName);\r\n        if (!visible && Modifier.isProtected(mod))\r\n            return clazz.subclassOf(declaringClass);\r\n        return visible;\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ClassFile.setSuperclass",
	"Comment": "sets the super class.the new super class should inherit from the old super class.this method modifies constructors so that they call constructors declaredin the new super class.",
	"Method": "void setSuperclass(String superclass){\r\n    if (superclass == null)\r\n        superclass = \"java.lang.Object\";\r\n    try {\r\n        this.superClass = constPool.addClassInfo(superclass);\r\n        for (MethodInfo minfo : methods) minfo.setSuperclass(superclass);\r\n    } catch (BadBytecode e) {\r\n        throw new CannotCompileException(e);\r\n    }\r\n    cachedSuperclass = superclass;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.stackmap.TypeData.commonSuperClassEx",
	"Comment": "finds the most specific common super class of the given classesby considering array types.",
	"Method": "CtClass commonSuperClassEx(CtClass one,CtClass two){\r\n    if (one == two)\r\n        return one;\r\n    else if (one.isArray() && two.isArray()) {\r\n        CtClass ele1 = one.getComponentType();\r\n        CtClass ele2 = two.getComponentType();\r\n        CtClass element = commonSuperClassEx(ele1, ele2);\r\n        if (element == ele1)\r\n            return one;\r\n        else if (element == ele2)\r\n            return two;\r\n        else\r\n            return one.getClassPool().get(element == null ? \"java.lang.Object\" : element.getName() + \"[]\");\r\n    } else if (one.isPrimitive() || two.isPrimitive())\r\n        return null;\r\n    else if (one.isArray() || two.isArray())\r\n        return one.getClassPool().get(\"java.lang.Object\");\r\n    else\r\n        return commonSuperClass(one, two);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.SignatureAttribute.toFieldSignature",
	"Comment": "parses the given signature string as a field type signature.",
	"Method": "ObjectType toFieldSignature(String sig){\r\n    try {\r\n        return parseObjectType(sig, new Cursor(), false);\r\n    } catch (IndexOutOfBoundsException e) {\r\n        throw error(sig);\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.query.impl.extractor.AbstractExtractionSpecification.axes",
	"Comment": "generates combinations of parameters and outputs them in thejunit format",
	"Method": "Collection<Object[]> axes(List<InMemoryFormat> formats,List<Index> indexes,List<Multivalue> multivalues){\r\n    List<Object[]> combinations = new ArrayList<Object[]>();\r\n    for (InMemoryFormat inMemoryFormat : formats) {\r\n        for (Index index : indexes) {\r\n            for (Multivalue multivalue : multivalues) {\r\n                combinations.add(new Object[] { inMemoryFormat, index, multivalue });\r\n            }\r\n        }\r\n    }\r\n    return combinations;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.isInterface",
	"Comment": "determines whether this object represents a class or an interface.it returns true if this object represents an interface.",
	"Method": "boolean isInterface(){\r\n    return false;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.Modifier.isPackage",
	"Comment": "returns true if the modifiers do not include eitherpublic, protected, or private.",
	"Method": "boolean isPackage(int mod){\r\n    return (mod & (PUBLIC | PRIVATE | PROTECTED)) == 0;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.AnnotationsAttribute.addAnnotation",
	"Comment": "adds an annotation.if there is an annotation with the same type,it is removed before the new annotation is added.",
	"Method": "void addAnnotation(Annotation annotation){\r\n    String type = annotation.getTypeName();\r\n    Annotation[] annotations = getAnnotations();\r\n    for (int i = 0; i < annotations.length; i++) {\r\n        if (annotations[i].getTypeName().equals(type)) {\r\n            annotations[i] = annotation;\r\n            setAnnotations(annotations);\r\n            return;\r\n        }\r\n    }\r\n    Annotation[] newlist = new Annotation[annotations.length + 1];\r\n    System.arraycopy(annotations, 0, newlist, 0, annotations.length);\r\n    newlist[annotations.length] = annotation;\r\n    setAnnotations(newlist);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.Handler.mayThrow",
	"Comment": "returns the list of exceptions that the catch clause may throw.",
	"Method": "CtClass[] mayThrow(){\r\n    return super.mayThrow();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.Instanceof.getFileName",
	"Comment": "returns the source file containing theinstanceof expression.",
	"Method": "String getFileName(){\r\n    return super.getFileName();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.ControlFlow.frameAt",
	"Comment": "returns the types of the local variables and stack frame entriesavailable at the given position.if the byte at the position isnot the first byte of an instruction, then this method returnsnull.",
	"Method": "Frame frameAt(int pos){\r\n    if (frames == null)\r\n        frames = new Analyzer().analyze(clazz, methodInfo);\r\n    return frames[pos];\r\n}"
}, {
	"Path": "com.hazelcast.client.HazelcastClient.shutdownAll",
	"Comment": "shuts down all the client hazelcastinstance created in this jvm.to be more precise it shuts down the hazelcastinstances loaded using the same classloader this hazelcastclient has beenloaded with.this method is mostly used for testing purposes.",
	"Method": "void shutdownAll(){\r\n    HazelcastClientManager.shutdownAll();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtConstructor.insertBeforeBody",
	"Comment": "inserts bytecode just after another constructor in the super classor this class is called.it does not work if this object represents a class initializer.",
	"Method": "void insertBeforeBody(String src){\r\n    CtClass cc = declaringClass;\r\n    cc.checkModify();\r\n    if (isClassInitializer())\r\n        throw new CannotCompileException(\"class initializer\");\r\n    CodeAttribute ca = methodInfo.getCodeAttribute();\r\n    CodeIterator iterator = ca.iterator();\r\n    Bytecode b = new Bytecode(methodInfo.getConstPool(), ca.getMaxStack(), ca.getMaxLocals());\r\n    b.setStackDepth(ca.getMaxStack());\r\n    Javac jv = new Javac(b, cc);\r\n    try {\r\n        jv.recordParams(getParameterTypes(), false);\r\n        jv.compileStmnt(src);\r\n        ca.setMaxStack(b.getMaxStack());\r\n        ca.setMaxLocals(b.getMaxLocals());\r\n        iterator.skipConstructor();\r\n        int pos = iterator.insertEx(b.get());\r\n        iterator.insert(b.getExceptionTable(), pos);\r\n        methodInfo.rebuildStackMapIf6(cc.getClassPool(), cc.getClassFile2());\r\n    } catch (NotFoundException e) {\r\n        throw new CannotCompileException(e);\r\n    } catch (CompileError e) {\r\n        throw new CannotCompileException(e);\r\n    } catch (BadBytecode e) {\r\n        throw new CannotCompileException(e);\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.topic.TopicTest.testTopicCluster",
	"Comment": "testing if topic can properly listen messages and if topic has any issue after a shutdown.",
	"Method": "void testTopicCluster(){\r\n    String topicName = \"TestMessages\" + generateRandomString(5);\r\n    Config cfg = new Config();\r\n    TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\r\n    HazelcastInstance[] instances = factory.newInstances(cfg);\r\n    HazelcastInstance instance1 = instances[0];\r\n    HazelcastInstance instance2 = instances[1];\r\n    ITopic<String> topic1 = instance1.getTopic(topicName);\r\n    final CountDownLatch latch1 = new CountDownLatch(1);\r\n    final String message = \"Test\" + randomString();\r\n    topic1.addMessageListener(new MessageListener<String>() {\r\n        public void onMessage(Message msg) {\r\n            assertEquals(message, msg.getMessageObject());\r\n            latch1.countDown();\r\n        }\r\n    });\r\n    ITopic<String> topic2 = instance2.getTopic(topicName);\r\n    final CountDownLatch latch2 = new CountDownLatch(2);\r\n    topic2.addMessageListener(new MessageListener<String>() {\r\n        public void onMessage(Message msg) {\r\n            assertEquals(message, msg.getMessageObject());\r\n            latch2.countDown();\r\n        }\r\n    });\r\n    topic1.publish(message);\r\n    assertOpenEventually(latch1);\r\n    instance1.shutdown();\r\n    topic2.publish(message);\r\n    assertOpenEventually(latch2);\r\n}"
}, {
	"Path": "com.hazelcast.topic.TopicTest.testTopicCluster",
	"Comment": "testing if topic can properly listen messages and if topic has any issue after a shutdown.",
	"Method": "void testTopicCluster(){\r\n    assertEquals(message, msg.getMessageObject());\r\n    latch1.countDown();\r\n}"
}, {
	"Path": "com.hazelcast.topic.TopicTest.testTopicCluster",
	"Comment": "testing if topic can properly listen messages and if topic has any issue after a shutdown.",
	"Method": "void testTopicCluster(){\r\n    assertEquals(message, msg.getMessageObject());\r\n    latch2.countDown();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.ClassMap.toJvmName",
	"Comment": "converts a class name into the internal representation used inthe jvm.",
	"Method": "String toJvmName(String classname){\r\n    return Descriptor.toJvmName(classname);\r\n}"
}, {
	"Path": "com.hazelcast.nio.serialization.EnumTest.test4",
	"Comment": "so when this test runs without error, it indicates that we can safely deal with subclasses of an enumeration",
	"Method": "void test4(){\r\n    test(TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "com.hazelcast.spring.transaction.TestSpringManagedHazelcastTransaction.transactionalServiceBeanInvocation_rollback",
	"Comment": "tests that transaction will be rollbacked if there is an exception.",
	"Method": "void transactionalServiceBeanInvocation_rollback(){\r\n    RuntimeException expectedEx = null;\r\n    try {\r\n        service.putWithException(new DummyObject(1L, \"magic\"));\r\n    } catch (RuntimeException ex) {\r\n        expectedEx = ex;\r\n    } finally {\r\n        assertNotNull(expectedEx);\r\n        assertEquals(0L, instance.getMap(\"dummyObjectMap\").size());\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.spring.cache.HazelcastCacheManager.getDefaultReadTimeout",
	"Comment": "return default cache value retrieval timeout in milliseconds.",
	"Method": "long getDefaultReadTimeout(){\r\n    return defaultReadTimeout;\r\n}"
}, {
	"Path": "com.hazelcast.spi.impl.operationexecutor.impl.OperationQueueImplTest.take_whenLowPriority_andManyPrecedingTriggerTasks",
	"Comment": "it could be that in the low priority query there are a bunch of useless trigger tasks preceding a regular tasks.",
	"Method": "void take_whenLowPriority_andManyPrecedingTriggerTasks(){\r\n    Object task1 = \"task1\";\r\n    Object task2 = \"task2\";\r\n    Object task3 = \"task3\";\r\n    Object task4 = \"task4\";\r\n    operationQueue.add(task1, true);\r\n    operationQueue.add(task2, true);\r\n    operationQueue.add(task3, true);\r\n    operationQueue.add(task4, false);\r\n    assertSame(task1, operationQueue.take(false));\r\n    assertSame(task2, operationQueue.take(false));\r\n    assertSame(task3, operationQueue.take(false));\r\n    assertEquals(4, operationQueue.size());\r\n    assertSame(task4, operationQueue.take(false));\r\n    assertEquals(0, operationQueue.size());\r\n    assertEquals(0, operationQueue.prioritySize());\r\n    assertEquals(0, operationQueue.normalSize());\r\n}"
}, {
	"Path": "com.hazelcast.nio.tcp.TcpIpConnection_AbstractBasicTest.lastReadTimeMillis",
	"Comment": "on the remote side we check the if the lastreadtime is updated",
	"Method": "void lastReadTimeMillis(){\r\n    TcpIpConnection connAB = connect(connManagerA, addressB);\r\n    TcpIpConnection connBA = connect(connManagerB, addressA);\r\n    sleepSeconds(LAST_READ_WRITE_SLEEP_SECONDS);\r\n    Packet packet = new Packet(serializationService.toBytes(\"foo\"));\r\n    connAB.write(packet);\r\n    assertTrueEventually(new AssertTask() {\r\n        @Override\r\n        public void run() {\r\n            assertEquals(1, packetsB.size());\r\n            System.out.println(\"Packet processed\");\r\n        }\r\n    });\r\n    long lastReadTimeMs = connBA.lastReadTimeMillis();\r\n    long nowMs = currentTimeMillis();\r\n    assertTrue(\"nowMs = \" + nowMs + \", lastReadTimeMs = \" + lastReadTimeMs, lastReadTimeMs <= nowMs);\r\n    assertTrue(\"nowMs = \" + nowMs + \", lastReadTimeMs = \" + lastReadTimeMs, lastReadTimeMs >= nowMs - MARGIN_OF_ERROR_MS);\r\n}"
}, {
	"Path": "com.hazelcast.nio.tcp.TcpIpConnection_AbstractBasicTest.lastReadTimeMillis",
	"Comment": "on the remote side we check the if the lastreadtime is updated",
	"Method": "void lastReadTimeMillis(){\r\n    assertEquals(1, packetsB.size());\r\n    System.out.println(\"Packet processed\");\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtBehavior.getAnnotations",
	"Comment": "returns the annotations associated with this method or constructor.",
	"Method": "Object[] getAnnotations(Object[] getAnnotations,boolean ignoreNotFound){\r\n    MethodInfo mi = getMethodInfo2();\r\n    AnnotationsAttribute ainfo = (AnnotationsAttribute) mi.getAttribute(AnnotationsAttribute.invisibleTag);\r\n    AnnotationsAttribute ainfo2 = (AnnotationsAttribute) mi.getAttribute(AnnotationsAttribute.visibleTag);\r\n    return CtClassType.toAnnotationType(ignoreNotFound, getDeclaringClass().getClassPool(), ainfo, ainfo2);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.Descriptor.getParameterTypes",
	"Comment": "returns the ctclass objects representing the parametertypes specified by the given descriptor.",
	"Method": "CtClass[] getParameterTypes(String desc,ClassPool cp){\r\n    if (desc.charAt(0) != '(')\r\n        return null;\r\n    int num = numOfParameters(desc);\r\n    CtClass[] args = new CtClass[num];\r\n    int n = 0;\r\n    int i = 1;\r\n    do {\r\n        i = toCtClass(cp, desc, i, args, n++);\r\n    } while (i > 0);\r\n    return args;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.Frame.setJsrMerged",
	"Comment": "sets whether of not the state from the source jsr instruction has been merged",
	"Method": "void setJsrMerged(boolean jsrMerged){\r\n    this.jsrMerged = jsrMerged;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ClassFile.addAttribute",
	"Comment": "appends an attribute. if there is already an attribute with the samename, the new one substitutes for it.",
	"Method": "void addAttribute(AttributeInfo info){\r\n    AttributeInfo.remove(attributes, info.getName());\r\n    attributes.add(info);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtBehavior.getParameterAnnotations",
	"Comment": "returns the parameter annotations associated with this method or constructor.",
	"Method": "Object[][] getParameterAnnotations(Object[][] getParameterAnnotations,boolean ignoreNotFound){\r\n    MethodInfo mi = getMethodInfo2();\r\n    ParameterAnnotationsAttribute ainfo = (ParameterAnnotationsAttribute) mi.getAttribute(ParameterAnnotationsAttribute.invisibleTag);\r\n    ParameterAnnotationsAttribute ainfo2 = (ParameterAnnotationsAttribute) mi.getAttribute(ParameterAnnotationsAttribute.visibleTag);\r\n    return CtClassType.toAnnotationType(ignoreNotFound, getDeclaringClass().getClassPool(), ainfo, ainfo2, mi);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.NewExpr.getSignature",
	"Comment": "get the signature of the constructorthe signature is represented by a character stringcalled method descriptor, which is defined in the jvm specification.",
	"Method": "String getSignature(){\r\n    ConstPool constPool = getConstPool();\r\n    int methodIndex = iterator.u16bitAt(currentPos + 1);\r\n    return constPool.getMethodrefType(methodIndex);\r\n}"
}, {
	"Path": "com.hazelcast.client.spi.ClientProxy.preDestroy",
	"Comment": "called before proxy is destroyed and determines whether destroy should be done.",
	"Method": "boolean preDestroy(){\r\n    return true;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtPrimitiveType.getModifiers",
	"Comment": "returns the modifiers for this type.for decoding, use javassist.modifier.",
	"Method": "int getModifiers(){\r\n    return Modifier.PUBLIC | Modifier.FINAL;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.LineNumberAttribute.toStartPc",
	"Comment": "returns the index into the code array at which the code forthe specified line begins.",
	"Method": "int toStartPc(int line){\r\n    int n = tableLength();\r\n    for (int i = 0; i < n; ++i) if (line == lineNumber(i))\r\n        return startPc(i);\r\n    return -1;\r\n}"
}, {
	"Path": "com.hazelcast.test.HazelcastTestSupport.assertNotEqualsStringFormat",
	"Comment": "this method executes the normal assertnotequals with expected and actual values.in addition it formats the given string with those values to provide a good assert message.",
	"Method": "void assertNotEqualsStringFormat(String message,Object expected,Object actual){\r\n    assertNotEquals(format(message, expected, actual), expected, actual);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.MethodInfo.compact",
	"Comment": "copies all constant pool items to a given new constant pooland replaces the original items with the new ones.this is used for garbage collecting the items of removed fieldsand methods.",
	"Method": "void compact(ConstPool cp){\r\n    name = cp.addUtf8Info(getName());\r\n    descriptor = cp.addUtf8Info(getDescriptor());\r\n    attribute = AttributeInfo.copyAll(attribute, cp);\r\n    constPool = cp;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.CodeAttribute.copy",
	"Comment": "makes a copy.class names are replaced according to thegiven map object.",
	"Method": "AttributeInfo copy(ConstPool newCp,Map<String, String> classnames){\r\n    try {\r\n        return new CodeAttribute(newCp, this, classnames);\r\n    } catch (BadBytecode e) {\r\n        throw new RuntimeCopyException(\"bad bytecode. fatal?\");\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.test.TestHazelcastInstanceFactory.cleanup",
	"Comment": "removes hazelcast instance address mappings for shut down hazelcastinstances. this allows an address to be reused.",
	"Method": "void cleanup(){\r\n    final TestNodeRegistry registry = getRegistry();\r\n    synchronized (addressMap) {\r\n        final Iterator<Entry<Integer, Address>> addressIterator = addressMap.entrySet().iterator();\r\n        while (addressIterator.hasNext()) {\r\n            final Entry<Integer, Address> entry = addressIterator.next();\r\n            if (registry.getInstance(entry.getValue()) == null) {\r\n                addressIterator.remove();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.ringbuffer.impl.RingbufferAbstractTest.remainingCapacity",
	"Comment": "to do some basic tests to see if the operation itself is set up correctly",
	"Method": "void remainingCapacity(){\r\n    assertEquals(ringbuffer.capacity(), ringbuffer.remainingCapacity());\r\n    ringbuffer.add(\"first\");\r\n    assertEquals(ringbuffer.capacity() - 1, ringbuffer.remainingCapacity());\r\n    ringbuffer.add(\"second\");\r\n    assertEquals(ringbuffer.capacity() - 2, ringbuffer.remainingCapacity());\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.compiler.TypeChecker.typeToString",
	"Comment": "converts a tuple of exprtype, arraydim, and classnameinto a string object.",
	"Method": "StringBuffer typeToString(StringBuffer sbuf,int type,int dim,String cname){\r\n    String s;\r\n    if (type == CLASS)\r\n        s = MemberResolver.jvmToJavaName(cname);\r\n    else if (type == NULL)\r\n        s = \"Object\";\r\n    else\r\n        try {\r\n            s = MemberResolver.getTypeName(type);\r\n        } catch (CompileError e) {\r\n            s = \"?\";\r\n        }\r\n    sbuf.append(s);\r\n    while (dim-- > 0) sbuf.append(\"[]\");\r\n    return sbuf;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.Expr.indexOfBytecode",
	"Comment": "returns the index of the bytecode corresponding to the expression. it isthe index into the byte array containing the java bytecode thatimplements the method.",
	"Method": "int indexOfBytecode(){\r\n    return currentPos;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.Instanceof.getType",
	"Comment": "returns the ctclass object representingthe type name on the right hand sideof the instanceof operator.",
	"Method": "CtClass getType(){\r\n    ConstPool cp = getConstPool();\r\n    int pos = currentPos;\r\n    int index = iterator.u16bitAt(pos + 1);\r\n    String name = cp.getClassInfo(index);\r\n    return thisClass.getClassPool().getCtClass(name);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.ClassMap.toJavaName",
	"Comment": "converts a class name from the internal representation used inthe jvm to the normal one used in java.",
	"Method": "String toJavaName(String classname){\r\n    return Descriptor.toJavaName(classname);\r\n}"
}, {
	"Path": "com.hazelcast.multimap.MultiMapTest.testAggregateMultiMap_differentDataTypes",
	"Comment": "it must throw classcastexception wrapped by hazelcastexception",
	"Method": "void testAggregateMultiMap_differentDataTypes(){\r\n    TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(1);\r\n    MultiMap<Object, Object> multiMap = getMultiMap(factory.newInstances(), randomString());\r\n    multiMap.put(1, \"fail\");\r\n    multiMap.put(2, 75);\r\n    Integer aggregate = multiMap.aggregate(Supplier.all(), Aggregations.integerAvg());\r\n    assertEquals(50, aggregate.intValue());\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtField.getFieldInfo",
	"Comment": "returns the fieldinfo representing the field in the class file.",
	"Method": "FieldInfo getFieldInfo(){\r\n    declaringClass.checkModify();\r\n    return fieldInfo;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getEnclosingMethod",
	"Comment": "returns the immediately enclosing method of this class.this method works only with jdk 1.5 or later.",
	"Method": "CtMethod getEnclosingMethod(){\r\n    CtBehavior b = getEnclosingBehavior();\r\n    if (b == null)\r\n        return null;\r\n    else if (b instanceof CtMethod)\r\n        return (CtMethod) b;\r\n    else\r\n        throw new NotFoundException(b.getLongName() + \" is enclosing \" + getName());\r\n}"
}, {
	"Path": "com.hazelcast.client.proxy.ClientPNCounterProxy.toVectorClock",
	"Comment": "transforms the list of replica logical timestamps to a vector clock instance.",
	"Method": "VectorClock toVectorClock(List<Entry<String, Long>> replicaLogicalTimestamps){\r\n    final VectorClock timestamps = new VectorClock();\r\n    for (Entry<String, Long> replicaTimestamp : replicaLogicalTimestamps) {\r\n        timestamps.setReplicaTimestamp(replicaTimestamp.getKey(), replicaTimestamp.getValue());\r\n    }\r\n    return timestamps;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.ClassPool.find",
	"Comment": "searches the class path to obtain the url of the class filespecified by classname.it is also used to determine whetherthe class file exists.",
	"Method": "URL find(String classname){\r\n    return source.find(classname);\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientConnectionStrategyConfig.getConnectionRetryConfig",
	"Comment": "connection retry config is controls the period among the retries and when should a client gave upretrying. exponential behaviour can be chosen or jitter can be added to wait periods.",
	"Method": "ConnectionRetryConfig getConnectionRetryConfig(){\r\n    return connectionRetryConfig;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.NestHostAttribute.copy",
	"Comment": "makes a copy.class names are replaced according to thegiven map object.",
	"Method": "AttributeInfo copy(ConstPool newCp,Map<String, String> classnames){\r\n    int hostIndex = ByteArray.readU16bit(get(), 0);\r\n    int newHostIndex = getConstPool().copy(hostIndex, newCp, classnames);\r\n    return new NestHostAttribute(newCp, newHostIndex);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ExceptionsAttribute.copyFrom",
	"Comment": "copies the contents from a source attribute.specified class names are replaced during the copy.",
	"Method": "void copyFrom(ExceptionsAttribute srcAttr,Map<String, String> classnames){\r\n    ConstPool srcCp = srcAttr.constPool;\r\n    ConstPool destCp = this.constPool;\r\n    byte[] src = srcAttr.info;\r\n    int num = src.length;\r\n    byte[] dest = new byte[num];\r\n    dest[0] = src[0];\r\n    dest[1] = src[1];\r\n    for (int i = 2; i < num; i += 2) {\r\n        int index = ByteArray.readU16bit(src, i);\r\n        ByteArray.write16bit(srcCp.copy(index, destCp, classnames), dest, i);\r\n    }\r\n    this.info = dest;\r\n}"
}, {
	"Path": "com.hazelcast.test.ReflectionsHelper.filterNonConcreteClasses",
	"Comment": "removes abstract classes and interfaces from the given set.",
	"Method": "void filterNonConcreteClasses(Set<? extends Class> classes){\r\n    Iterator<? extends Class> iterator = classes.iterator();\r\n    while (iterator.hasNext()) {\r\n        Class<?> klass = iterator.next();\r\n        if (klass.isInterface() || Modifier.isAbstract(klass.getModifiers())) {\r\n            iterator.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.Frame.isRetMerged",
	"Comment": "whether or not state from the ret instruction, of the subroutine that was jumpedto has been merged.",
	"Method": "boolean isRetMerged(){\r\n    return retMerged;\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientReliableTopicConfig.setExecutor",
	"Comment": "sets the executor that is going to process the event.in some cases it is desirable to set a specific executor. for example, you may want to isolate a certain topic from othertopics because it contains long running messages or very high priority messages.a single executor can be shared between multiple reliable topics, although it could take more time to process a message.if a single executor is not shared with other reliable topics, then the executor only needs to have a single thread.",
	"Method": "ClientReliableTopicConfig setExecutor(Executor executor){\r\n    this.executor = executor;\r\n    return this;\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientNetworkConfig.getClientIcmpPingConfig",
	"Comment": "icmp ping is used to detect if machine that a remote hazelcast member runs on alive or not",
	"Method": "ClientIcmpPingConfig getClientIcmpPingConfig(){\r\n    return clientIcmpPingConfig;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.Loader.addTranslator",
	"Comment": "adds a translator, which is called whenever a class is loaded.",
	"Method": "void addTranslator(ClassPool cp,Translator t){\r\n    source = cp;\r\n    translator = t;\r\n    t.start(cp);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtField.hasAnnotation",
	"Comment": "returns true if the class has the specified annotation type.",
	"Method": "boolean hasAnnotation(String typeName){\r\n    FieldInfo fi = getFieldInfo2();\r\n    AnnotationsAttribute ainfo = (AnnotationsAttribute) fi.getAttribute(AnnotationsAttribute.invisibleTag);\r\n    AnnotationsAttribute ainfo2 = (AnnotationsAttribute) fi.getAttribute(AnnotationsAttribute.visibleTag);\r\n    return CtClassType.hasAnnotationType(typeName, getDeclaringClass().getClassPool(), ainfo, ainfo2);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClassType.saveClassFile",
	"Comment": "converts a classfile object into a byte arrayfor saving memory space.",
	"Method": "void saveClassFile(){\r\n    if (classfile == null || hasMemberCache() != null)\r\n        return;\r\n    ByteArrayOutputStream barray = new ByteArrayOutputStream();\r\n    DataOutputStream out = new DataOutputStream(barray);\r\n    try {\r\n        classfile.write(out);\r\n        barray.close();\r\n        rawClassfile = barray.toByteArray();\r\n        classfile = null;\r\n    } catch (IOException e) {\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.Loader.findClass",
	"Comment": "finds the specified class using classpath.if the source throws an exception, this returns null.this method can be overridden by a subclass ofloader.note that the overridden method must not throwan exception when it just fails to find a class file.",
	"Method": "Class<?> findClass(String name){\r\n    byte[] classfile;\r\n    try {\r\n        if (source != null) {\r\n            if (translator != null)\r\n                translator.onLoad(source, name);\r\n            try {\r\n                classfile = source.get(name).toBytecode();\r\n            } catch (NotFoundException e) {\r\n                return null;\r\n            }\r\n        } else {\r\n            String jarname = \"/\" + name.replace('.', '/') + \".class\";\r\n            InputStream in = this.getClass().getResourceAsStream(jarname);\r\n            if (in == null)\r\n                return null;\r\n            classfile = ClassPoolTail.readStream(in);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new ClassNotFoundException(\"caught an exception while obtaining a class file for \" + name, e);\r\n    }\r\n    int i = name.lastIndexOf('.');\r\n    if (i != -1) {\r\n        String pname = name.substring(0, i);\r\n        if (isDefinedPackage(pname))\r\n            try {\r\n                definePackage(pname, null, null, null, null, null, null, null);\r\n            } catch (IllegalArgumentException e) {\r\n            }\r\n    }\r\n    if (domain == null)\r\n        return defineClass(name, classfile, 0, classfile.length);\r\n    return defineClass(name, classfile, 0, classfile.length, domain);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.compiler.CodeGen.getTempVar",
	"Comment": "returns a local variable that single or double words can bestored in.",
	"Method": "int getTempVar(){\r\n    if (tempVar < 0) {\r\n        tempVar = getMaxLocals();\r\n        incMaxLocals(2);\r\n    }\r\n    return tempVar;\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientNetworkConfig.getOutboundPortDefinitions",
	"Comment": "returns the outbound port definitions. it is possible that null is returned if not defined.",
	"Method": "Collection<String> getOutboundPortDefinitions(){\r\n    return outboundPortDefinitions;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtNewWrappedMethod.makeBody0",
	"Comment": "the generated method body does not need a stack map tablebecause it does not contain a branch instruction.",
	"Method": "int makeBody0(CtClass clazz,ClassFile classfile,CtMethod wrappedBody,boolean isStatic,CtClass[] parameters,CtClass returnType,ConstParameter cparam,Bytecode code){\r\n    if (!(clazz instanceof CtClassType))\r\n        throw new CannotCompileException(\"bad declaring class\" + clazz.getName());\r\n    if (!isStatic)\r\n        code.addAload(0);\r\n    int stacksize = compileParameterList(code, parameters, (isStatic ? 0 : 1));\r\n    int stacksize2;\r\n    String desc;\r\n    if (cparam == null) {\r\n        stacksize2 = 0;\r\n        desc = ConstParameter.defaultDescriptor();\r\n    } else {\r\n        stacksize2 = cparam.compile(code);\r\n        desc = cparam.descriptor();\r\n    }\r\n    checkSignature(wrappedBody, desc);\r\n    String bodyname;\r\n    try {\r\n        bodyname = addBodyMethod((CtClassType) clazz, classfile, wrappedBody);\r\n    } catch (BadBytecode e) {\r\n        throw new CannotCompileException(e);\r\n    }\r\n    if (isStatic)\r\n        code.addInvokestatic(Bytecode.THIS, bodyname, desc);\r\n    else\r\n        code.addInvokespecial(Bytecode.THIS, bodyname, desc);\r\n    compileReturn(code, returnType);\r\n    if (stacksize < stacksize2 + 2)\r\n        stacksize = stacksize2 + 2;\r\n    return stacksize;\r\n}"
}, {
	"Path": "com.hazelcast.spring.transaction.TestSpringManagedHazelcastTransaction.noExceptionWhenTransaction",
	"Comment": "tests that transactioncontext is accessible when there is a transaction.",
	"Method": "void noExceptionWhenTransaction(){\r\n    TransactionalMap<Object, Object> magic = transactionalContext.getMap(\"magic\");\r\n    assertNotNull(magic);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtPrimitiveType.getDescriptor",
	"Comment": "returns the descriptor representing this type.for example, if the type is int, then the descriptor is i.",
	"Method": "char getDescriptor(){\r\n    return descriptor;\r\n}"
}, {
	"Path": "com.hazelcast.test.TestThread.assertTerminates",
	"Comment": "asserts that the thread eventually completes, no matter if there is an error or not.",
	"Method": "void assertTerminates(){\r\n    assertTrueEventually(new AssertTask() {\r\n        @Override\r\n        public void run() throws Exception {\r\n            assertFalse(format(\"Thread %s is still alive\", getName()), isAlive());\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.hazelcast.test.TestThread.assertTerminates",
	"Comment": "asserts that the thread eventually completes, no matter if there is an error or not.",
	"Method": "void assertTerminates(){\r\n    assertFalse(format(\"Thread %s is still alive\", getName()), isAlive());\r\n}"
}, {
	"Path": "com.hazelcast.spi.impl.merge.AbstractContainerMergerTest.testMergerRun_whenMergeOperationBlocks_thenMergerFinishesEventually",
	"Comment": "tests that the merger finishes eventually, when the merge operation blocks.",
	"Method": "void testMergerRun_whenMergeOperationBlocks_thenMergerFinishesEventually(){\r\n    TestMergeOperation operation = new TestMergeOperation(BLOCKS);\r\n    TestContainerMerger merger = new TestContainerMerger(collector, nodeEngine, operation);\r\n    merger.run();\r\n    operation.unblock();\r\n    assertTrue(\"Expected the merge operation to be invoked\", operation.hasBeenInvoked);\r\n    assertTrue(\"Expected collected containers to be destroyed\", collector.onDestroyHasBeenCalled);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.Instanceof.getLineNumber",
	"Comment": "returns the line number of the source line containing theinstanceof expression.",
	"Method": "int getLineNumber(){\r\n    return super.getLineNumber();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.AccessFlag.toModifier",
	"Comment": "converts a javassist.bytecode.accessflaginto a javassist.modifier.",
	"Method": "int toModifier(int accflags){\r\n    return accflags;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.FieldInfo.compact",
	"Comment": "copies all constant pool items to a given new constant pooland replaces the original items with the new ones.this is used for garbage collecting the items of removed fieldsand methods.",
	"Method": "void compact(ConstPool cp){\r\n    name = cp.addUtf8Info(getName());\r\n    descriptor = cp.addUtf8Info(getDescriptor());\r\n    attribute = AttributeInfo.copyAll(attribute, cp);\r\n    constPool = cp;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.Type.getCtClass",
	"Comment": "returns the class this type represents. if the type is special, null will be returned.",
	"Method": "CtClass getCtClass(){\r\n    return clazz;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.convert.TransformNew.transform",
	"Comment": "replace a sequence of new classname dup ... invokespecialwith nop nop ... invokestatic trapmethod in trapclass",
	"Method": "int transform(CtClass clazz,int pos,CodeIterator iterator,ConstPool cp){\r\n    int index;\r\n    int c = iterator.byteAt(pos);\r\n    if (c == NEW) {\r\n        index = iterator.u16bitAt(pos + 1);\r\n        if (cp.getClassInfo(index).equals(classname)) {\r\n            if (iterator.byteAt(pos + 3) != DUP)\r\n                throw new CannotCompileException(\"NEW followed by no DUP was found\");\r\n            iterator.writeByte(NOP, pos);\r\n            iterator.writeByte(NOP, pos + 1);\r\n            iterator.writeByte(NOP, pos + 2);\r\n            iterator.writeByte(NOP, pos + 3);\r\n            ++nested;\r\n            StackMapTable smt = (StackMapTable) iterator.get().getAttribute(StackMapTable.tag);\r\n            if (smt != null)\r\n                smt.removeNew(pos);\r\n            StackMap sm = (StackMap) iterator.get().getAttribute(StackMap.tag);\r\n            if (sm != null)\r\n                sm.removeNew(pos);\r\n        }\r\n    } else if (c == INVOKESPECIAL) {\r\n        index = iterator.u16bitAt(pos + 1);\r\n        int typedesc = cp.isConstructor(classname, index);\r\n        if (typedesc != 0 && nested > 0) {\r\n            int methodref = computeMethodref(typedesc, cp);\r\n            iterator.writeByte(INVOKESTATIC, pos);\r\n            iterator.write16bit(methodref, pos + 1);\r\n            --nested;\r\n        }\r\n    }\r\n    return pos;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.Modifier.isAnnotation",
	"Comment": "returns true if the modifiers include the annotationmodifier.",
	"Method": "boolean isAnnotation(int mod){\r\n    return (mod & ANNOTATION) != 0;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.Expr.getEnclosingClass",
	"Comment": "returns the class that declares the method enclosingthis expression.",
	"Method": "CtClass getEnclosingClass(){\r\n    return thisClass;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.Frame.copy",
	"Comment": "makes a shallow copy of this frame, i.e. the type instances willremain the same.",
	"Method": "Frame copy(){\r\n    Frame frame = new Frame(locals.length, stack.length);\r\n    System.arraycopy(locals, 0, frame.locals, 0, locals.length);\r\n    System.arraycopy(stack, 0, frame.stack, 0, stack.length);\r\n    frame.top = top;\r\n    return frame;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.EnclosingMethodAttribute.copy",
	"Comment": "makes a copy.class names are replaced according to thegiven map object.",
	"Method": "AttributeInfo copy(ConstPool newCp,Map<String, String> classnames){\r\n    if (methodIndex() == 0)\r\n        return new EnclosingMethodAttribute(newCp, className());\r\n    return new EnclosingMethodAttribute(newCp, className(), methodName(), methodDescriptor());\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.scopedpool.SoftValueHashMap.processQueue",
	"Comment": "remove all invalidated entries from the map, that is, remove all entrieswhose values have been discarded.",
	"Method": "void processQueue(){\r\n    Object ref;\r\n    if (!hash.isEmpty())\r\n        while ((ref = queue.poll()) != null) if (ref instanceof SoftValueRef) {\r\n            @SuppressWarnings(\"rawtypes\")\r\n            SoftValueRef que = (SoftValueRef) ref;\r\n            if (ref == hash.get(que.key))\r\n                hash.remove(que.key);\r\n        }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtMethod.setWrappedBody",
	"Comment": "replace a method body with a new method body wrapping thegiven method.",
	"Method": "void setWrappedBody(CtMethod mbody,ConstParameter constParam){\r\n    declaringClass.checkModify();\r\n    CtClass clazz = getDeclaringClass();\r\n    CtClass[] params;\r\n    CtClass retType;\r\n    try {\r\n        params = getParameterTypes();\r\n        retType = getReturnType();\r\n    } catch (NotFoundException e) {\r\n        throw new CannotCompileException(e);\r\n    }\r\n    Bytecode code = CtNewWrappedMethod.makeBody(clazz, clazz.getClassFile2(), mbody, params, retType, constParam);\r\n    CodeAttribute cattr = code.toCodeAttribute();\r\n    methodInfo.setCodeAttribute(cattr);\r\n    methodInfo.setAccessFlags(methodInfo.getAccessFlags() & ~AccessFlag.ABSTRACT);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.Handler.getType",
	"Comment": "returns the type handled by the catch clause.if this is a finally block, null is returned.",
	"Method": "CtClass getType(){\r\n    int type = etable.catchType(index);\r\n    if (type == 0)\r\n        return null;\r\n    ConstPool cp = getConstPool();\r\n    String name = cp.getClassInfo(type);\r\n    return thisClass.getClassPool().getCtClass(name);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.Executor.execute",
	"Comment": "execute the instruction, modeling the effects on the specified frame and subroutine.if a subroutine is passed, the access flags will be modified if this instruction accessesthe local variable table.",
	"Method": "void execute(MethodInfo method,int pos,CodeIterator iter,Frame frame,Subroutine subroutine){\r\n    this.lastPos = pos;\r\n    int opcode = iter.byteAt(pos);\r\n    switch(opcode) {\r\n        case NOP:\r\n            break;\r\n        case ACONST_NULL:\r\n            frame.push(Type.UNINIT);\r\n            break;\r\n        case ICONST_M1:\r\n        case ICONST_0:\r\n        case ICONST_1:\r\n        case ICONST_2:\r\n        case ICONST_3:\r\n        case ICONST_4:\r\n        case ICONST_5:\r\n            frame.push(Type.INTEGER);\r\n            break;\r\n        case LCONST_0:\r\n        case LCONST_1:\r\n            frame.push(Type.LONG);\r\n            frame.push(Type.TOP);\r\n            break;\r\n        case FCONST_0:\r\n        case FCONST_1:\r\n        case FCONST_2:\r\n            frame.push(Type.FLOAT);\r\n            break;\r\n        case DCONST_0:\r\n        case DCONST_1:\r\n            frame.push(Type.DOUBLE);\r\n            frame.push(Type.TOP);\r\n            break;\r\n        case BIPUSH:\r\n        case SIPUSH:\r\n            frame.push(Type.INTEGER);\r\n            break;\r\n        case LDC:\r\n            evalLDC(iter.byteAt(pos + 1), frame);\r\n            break;\r\n        case LDC_W:\r\n        case LDC2_W:\r\n            evalLDC(iter.u16bitAt(pos + 1), frame);\r\n            break;\r\n        case ILOAD:\r\n            evalLoad(Type.INTEGER, iter.byteAt(pos + 1), frame, subroutine);\r\n            break;\r\n        case LLOAD:\r\n            evalLoad(Type.LONG, iter.byteAt(pos + 1), frame, subroutine);\r\n            break;\r\n        case FLOAD:\r\n            evalLoad(Type.FLOAT, iter.byteAt(pos + 1), frame, subroutine);\r\n            break;\r\n        case DLOAD:\r\n            evalLoad(Type.DOUBLE, iter.byteAt(pos + 1), frame, subroutine);\r\n            break;\r\n        case ALOAD:\r\n            evalLoad(Type.OBJECT, iter.byteAt(pos + 1), frame, subroutine);\r\n            break;\r\n        case ILOAD_0:\r\n        case ILOAD_1:\r\n        case ILOAD_2:\r\n        case ILOAD_3:\r\n            evalLoad(Type.INTEGER, opcode - ILOAD_0, frame, subroutine);\r\n            break;\r\n        case LLOAD_0:\r\n        case LLOAD_1:\r\n        case LLOAD_2:\r\n        case LLOAD_3:\r\n            evalLoad(Type.LONG, opcode - LLOAD_0, frame, subroutine);\r\n            break;\r\n        case FLOAD_0:\r\n        case FLOAD_1:\r\n        case FLOAD_2:\r\n        case FLOAD_3:\r\n            evalLoad(Type.FLOAT, opcode - FLOAD_0, frame, subroutine);\r\n            break;\r\n        case DLOAD_0:\r\n        case DLOAD_1:\r\n        case DLOAD_2:\r\n        case DLOAD_3:\r\n            evalLoad(Type.DOUBLE, opcode - DLOAD_0, frame, subroutine);\r\n            break;\r\n        case ALOAD_0:\r\n        case ALOAD_1:\r\n        case ALOAD_2:\r\n        case ALOAD_3:\r\n            evalLoad(Type.OBJECT, opcode - ALOAD_0, frame, subroutine);\r\n            break;\r\n        case IALOAD:\r\n            evalArrayLoad(Type.INTEGER, frame);\r\n            break;\r\n        case LALOAD:\r\n            evalArrayLoad(Type.LONG, frame);\r\n            break;\r\n        case FALOAD:\r\n            evalArrayLoad(Type.FLOAT, frame);\r\n            break;\r\n        case DALOAD:\r\n            evalArrayLoad(Type.DOUBLE, frame);\r\n            break;\r\n        case AALOAD:\r\n            evalArrayLoad(Type.OBJECT, frame);\r\n            break;\r\n        case BALOAD:\r\n        case CALOAD:\r\n        case SALOAD:\r\n            evalArrayLoad(Type.INTEGER, frame);\r\n            break;\r\n        case ISTORE:\r\n            evalStore(Type.INTEGER, iter.byteAt(pos + 1), frame, subroutine);\r\n            break;\r\n        case LSTORE:\r\n            evalStore(Type.LONG, iter.byteAt(pos + 1), frame, subroutine);\r\n            break;\r\n        case FSTORE:\r\n            evalStore(Type.FLOAT, iter.byteAt(pos + 1), frame, subroutine);\r\n            break;\r\n        case DSTORE:\r\n            evalStore(Type.DOUBLE, iter.byteAt(pos + 1), frame, subroutine);\r\n            break;\r\n        case ASTORE:\r\n            evalStore(Type.OBJECT, iter.byteAt(pos + 1), frame, subroutine);\r\n            break;\r\n        case ISTORE_0:\r\n        case ISTORE_1:\r\n        case ISTORE_2:\r\n        case ISTORE_3:\r\n            evalStore(Type.INTEGER, opcode - ISTORE_0, frame, subroutine);\r\n            break;\r\n        case LSTORE_0:\r\n        case LSTORE_1:\r\n        case LSTORE_2:\r\n        case LSTORE_3:\r\n            evalStore(Type.LONG, opcode - LSTORE_0, frame, subroutine);\r\n            break;\r\n        case FSTORE_0:\r\n        case FSTORE_1:\r\n        case FSTORE_2:\r\n        case FSTORE_3:\r\n            evalStore(Type.FLOAT, opcode - FSTORE_0, frame, subroutine);\r\n            break;\r\n        case DSTORE_0:\r\n        case DSTORE_1:\r\n        case DSTORE_2:\r\n        case DSTORE_3:\r\n            evalStore(Type.DOUBLE, opcode - DSTORE_0, frame, subroutine);\r\n            break;\r\n        case ASTORE_0:\r\n        case ASTORE_1:\r\n        case ASTORE_2:\r\n        case ASTORE_3:\r\n            evalStore(Type.OBJECT, opcode - ASTORE_0, frame, subroutine);\r\n            break;\r\n        case IASTORE:\r\n            evalArrayStore(Type.INTEGER, frame);\r\n            break;\r\n        case LASTORE:\r\n            evalArrayStore(Type.LONG, frame);\r\n            break;\r\n        case FASTORE:\r\n            evalArrayStore(Type.FLOAT, frame);\r\n            break;\r\n        case DASTORE:\r\n            evalArrayStore(Type.DOUBLE, frame);\r\n            break;\r\n        case AASTORE:\r\n            evalArrayStore(Type.OBJECT, frame);\r\n            break;\r\n        case BASTORE:\r\n        case CASTORE:\r\n        case SASTORE:\r\n            evalArrayStore(Type.INTEGER, frame);\r\n            break;\r\n        case POP:\r\n            if (frame.pop() == Type.TOP)\r\n                throw new BadBytecode(\"POP can not be used with a category 2 value, pos = \" + pos);\r\n            break;\r\n        case POP2:\r\n            frame.pop();\r\n            frame.pop();\r\n            break;\r\n        case DUP:\r\n            {\r\n                Type type = frame.peek();\r\n                if (type == Type.TOP)\r\n                    throw new BadBytecode(\"DUP can not be used with a category 2 value, pos = \" + pos);\r\n                frame.push(frame.peek());\r\n                break;\r\n            }\r\n        case DUP_X1:\r\n        case DUP_X2:\r\n            {\r\n                Type type = frame.peek();\r\n                if (type == Type.TOP)\r\n                    throw new BadBytecode(\"DUP can not be used with a category 2 value, pos = \" + pos);\r\n                int end = frame.getTopIndex();\r\n                int insert = end - (opcode - DUP_X1) - 1;\r\n                frame.push(type);\r\n                while (end > insert) {\r\n                    frame.setStack(end, frame.getStack(end - 1));\r\n                    end--;\r\n                }\r\n                frame.setStack(insert, type);\r\n                break;\r\n            }\r\n        case DUP2:\r\n            frame.push(frame.getStack(frame.getTopIndex() - 1));\r\n            frame.push(frame.getStack(frame.getTopIndex() - 1));\r\n            break;\r\n        case DUP2_X1:\r\n        case DUP2_X2:\r\n            {\r\n                int end = frame.getTopIndex();\r\n                int insert = end - (opcode - DUP2_X1) - 1;\r\n                Type type1 = frame.getStack(frame.getTopIndex() - 1);\r\n                Type type2 = frame.peek();\r\n                frame.push(type1);\r\n                frame.push(type2);\r\n                while (end > insert) {\r\n                    frame.setStack(end, frame.getStack(end - 2));\r\n                    end--;\r\n                }\r\n                frame.setStack(insert, type2);\r\n                frame.setStack(insert - 1, type1);\r\n                break;\r\n            }\r\n        case SWAP:\r\n            {\r\n                Type type1 = frame.pop();\r\n                Type type2 = frame.pop();\r\n                if (type1.getSize() == 2 || type2.getSize() == 2)\r\n                    throw new BadBytecode(\"Swap can not be used with category 2 values, pos = \" + pos);\r\n                frame.push(type1);\r\n                frame.push(type2);\r\n                break;\r\n            }\r\n        case IADD:\r\n            evalBinaryMath(Type.INTEGER, frame);\r\n            break;\r\n        case LADD:\r\n            evalBinaryMath(Type.LONG, frame);\r\n            break;\r\n        case FADD:\r\n            evalBinaryMath(Type.FLOAT, frame);\r\n            break;\r\n        case DADD:\r\n            evalBinaryMath(Type.DOUBLE, frame);\r\n            break;\r\n        case ISUB:\r\n            evalBinaryMath(Type.INTEGER, frame);\r\n            break;\r\n        case LSUB:\r\n            evalBinaryMath(Type.LONG, frame);\r\n            break;\r\n        case FSUB:\r\n            evalBinaryMath(Type.FLOAT, frame);\r\n            break;\r\n        case DSUB:\r\n            evalBinaryMath(Type.DOUBLE, frame);\r\n            break;\r\n        case IMUL:\r\n            evalBinaryMath(Type.INTEGER, frame);\r\n            break;\r\n        case LMUL:\r\n            evalBinaryMath(Type.LONG, frame);\r\n            break;\r\n        case FMUL:\r\n            evalBinaryMath(Type.FLOAT, frame);\r\n            break;\r\n        case DMUL:\r\n            evalBinaryMath(Type.DOUBLE, frame);\r\n            break;\r\n        case IDIV:\r\n            evalBinaryMath(Type.INTEGER, frame);\r\n            break;\r\n        case LDIV:\r\n            evalBinaryMath(Type.LONG, frame);\r\n            break;\r\n        case FDIV:\r\n            evalBinaryMath(Type.FLOAT, frame);\r\n            break;\r\n        case DDIV:\r\n            evalBinaryMath(Type.DOUBLE, frame);\r\n            break;\r\n        case IREM:\r\n            evalBinaryMath(Type.INTEGER, frame);\r\n            break;\r\n        case LREM:\r\n            evalBinaryMath(Type.LONG, frame);\r\n            break;\r\n        case FREM:\r\n            evalBinaryMath(Type.FLOAT, frame);\r\n            break;\r\n        case DREM:\r\n            evalBinaryMath(Type.DOUBLE, frame);\r\n            break;\r\n        case INEG:\r\n            verifyAssignable(Type.INTEGER, simplePeek(frame));\r\n            break;\r\n        case LNEG:\r\n            verifyAssignable(Type.LONG, simplePeek(frame));\r\n            break;\r\n        case FNEG:\r\n            verifyAssignable(Type.FLOAT, simplePeek(frame));\r\n            break;\r\n        case DNEG:\r\n            verifyAssignable(Type.DOUBLE, simplePeek(frame));\r\n            break;\r\n        case ISHL:\r\n            evalShift(Type.INTEGER, frame);\r\n            break;\r\n        case LSHL:\r\n            evalShift(Type.LONG, frame);\r\n            break;\r\n        case ISHR:\r\n            evalShift(Type.INTEGER, frame);\r\n            break;\r\n        case LSHR:\r\n            evalShift(Type.LONG, frame);\r\n            break;\r\n        case IUSHR:\r\n            evalShift(Type.INTEGER, frame);\r\n            break;\r\n        case LUSHR:\r\n            evalShift(Type.LONG, frame);\r\n            break;\r\n        case IAND:\r\n            evalBinaryMath(Type.INTEGER, frame);\r\n            break;\r\n        case LAND:\r\n            evalBinaryMath(Type.LONG, frame);\r\n            break;\r\n        case IOR:\r\n            evalBinaryMath(Type.INTEGER, frame);\r\n            break;\r\n        case LOR:\r\n            evalBinaryMath(Type.LONG, frame);\r\n            break;\r\n        case IXOR:\r\n            evalBinaryMath(Type.INTEGER, frame);\r\n            break;\r\n        case LXOR:\r\n            evalBinaryMath(Type.LONG, frame);\r\n            break;\r\n        case IINC:\r\n            {\r\n                int index = iter.byteAt(pos + 1);\r\n                verifyAssignable(Type.INTEGER, frame.getLocal(index));\r\n                access(index, Type.INTEGER, subroutine);\r\n                break;\r\n            }\r\n        case I2L:\r\n            verifyAssignable(Type.INTEGER, simplePop(frame));\r\n            simplePush(Type.LONG, frame);\r\n            break;\r\n        case I2F:\r\n            verifyAssignable(Type.INTEGER, simplePop(frame));\r\n            simplePush(Type.FLOAT, frame);\r\n            break;\r\n        case I2D:\r\n            verifyAssignable(Type.INTEGER, simplePop(frame));\r\n            simplePush(Type.DOUBLE, frame);\r\n            break;\r\n        case L2I:\r\n            verifyAssignable(Type.LONG, simplePop(frame));\r\n            simplePush(Type.INTEGER, frame);\r\n            break;\r\n        case L2F:\r\n            verifyAssignable(Type.LONG, simplePop(frame));\r\n            simplePush(Type.FLOAT, frame);\r\n            break;\r\n        case L2D:\r\n            verifyAssignable(Type.LONG, simplePop(frame));\r\n            simplePush(Type.DOUBLE, frame);\r\n            break;\r\n        case F2I:\r\n            verifyAssignable(Type.FLOAT, simplePop(frame));\r\n            simplePush(Type.INTEGER, frame);\r\n            break;\r\n        case F2L:\r\n            verifyAssignable(Type.FLOAT, simplePop(frame));\r\n            simplePush(Type.LONG, frame);\r\n            break;\r\n        case F2D:\r\n            verifyAssignable(Type.FLOAT, simplePop(frame));\r\n            simplePush(Type.DOUBLE, frame);\r\n            break;\r\n        case D2I:\r\n            verifyAssignable(Type.DOUBLE, simplePop(frame));\r\n            simplePush(Type.INTEGER, frame);\r\n            break;\r\n        case D2L:\r\n            verifyAssignable(Type.DOUBLE, simplePop(frame));\r\n            simplePush(Type.LONG, frame);\r\n            break;\r\n        case D2F:\r\n            verifyAssignable(Type.DOUBLE, simplePop(frame));\r\n            simplePush(Type.FLOAT, frame);\r\n            break;\r\n        case I2B:\r\n        case I2C:\r\n        case I2S:\r\n            verifyAssignable(Type.INTEGER, frame.peek());\r\n            break;\r\n        case LCMP:\r\n            verifyAssignable(Type.LONG, simplePop(frame));\r\n            verifyAssignable(Type.LONG, simplePop(frame));\r\n            frame.push(Type.INTEGER);\r\n            break;\r\n        case FCMPL:\r\n        case FCMPG:\r\n            verifyAssignable(Type.FLOAT, simplePop(frame));\r\n            verifyAssignable(Type.FLOAT, simplePop(frame));\r\n            frame.push(Type.INTEGER);\r\n            break;\r\n        case DCMPL:\r\n        case DCMPG:\r\n            verifyAssignable(Type.DOUBLE, simplePop(frame));\r\n            verifyAssignable(Type.DOUBLE, simplePop(frame));\r\n            frame.push(Type.INTEGER);\r\n            break;\r\n        case IFEQ:\r\n        case IFNE:\r\n        case IFLT:\r\n        case IFGE:\r\n        case IFGT:\r\n        case IFLE:\r\n            verifyAssignable(Type.INTEGER, simplePop(frame));\r\n            break;\r\n        case IF_ICMPEQ:\r\n        case IF_ICMPNE:\r\n        case IF_ICMPLT:\r\n        case IF_ICMPGE:\r\n        case IF_ICMPGT:\r\n        case IF_ICMPLE:\r\n            verifyAssignable(Type.INTEGER, simplePop(frame));\r\n            verifyAssignable(Type.INTEGER, simplePop(frame));\r\n            break;\r\n        case IF_ACMPEQ:\r\n        case IF_ACMPNE:\r\n            verifyAssignable(Type.OBJECT, simplePop(frame));\r\n            verifyAssignable(Type.OBJECT, simplePop(frame));\r\n            break;\r\n        case GOTO:\r\n            break;\r\n        case JSR:\r\n            frame.push(Type.RETURN_ADDRESS);\r\n            break;\r\n        case RET:\r\n            verifyAssignable(Type.RETURN_ADDRESS, frame.getLocal(iter.byteAt(pos + 1)));\r\n            break;\r\n        case TABLESWITCH:\r\n        case LOOKUPSWITCH:\r\n        case IRETURN:\r\n            verifyAssignable(Type.INTEGER, simplePop(frame));\r\n            break;\r\n        case LRETURN:\r\n            verifyAssignable(Type.LONG, simplePop(frame));\r\n            break;\r\n        case FRETURN:\r\n            verifyAssignable(Type.FLOAT, simplePop(frame));\r\n            break;\r\n        case DRETURN:\r\n            verifyAssignable(Type.DOUBLE, simplePop(frame));\r\n            break;\r\n        case ARETURN:\r\n            try {\r\n                CtClass returnType = Descriptor.getReturnType(method.getDescriptor(), classPool);\r\n                verifyAssignable(Type.get(returnType), simplePop(frame));\r\n            } catch (NotFoundException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n            break;\r\n        case RETURN:\r\n            break;\r\n        case GETSTATIC:\r\n            evalGetField(opcode, iter.u16bitAt(pos + 1), frame);\r\n            break;\r\n        case PUTSTATIC:\r\n            evalPutField(opcode, iter.u16bitAt(pos + 1), frame);\r\n            break;\r\n        case GETFIELD:\r\n            evalGetField(opcode, iter.u16bitAt(pos + 1), frame);\r\n            break;\r\n        case PUTFIELD:\r\n            evalPutField(opcode, iter.u16bitAt(pos + 1), frame);\r\n            break;\r\n        case INVOKEVIRTUAL:\r\n        case INVOKESPECIAL:\r\n        case INVOKESTATIC:\r\n            evalInvokeMethod(opcode, iter.u16bitAt(pos + 1), frame);\r\n            break;\r\n        case INVOKEINTERFACE:\r\n            evalInvokeIntfMethod(opcode, iter.u16bitAt(pos + 1), frame);\r\n            break;\r\n        case INVOKEDYNAMIC:\r\n            evalInvokeDynamic(opcode, iter.u16bitAt(pos + 1), frame);\r\n            break;\r\n        case NEW:\r\n            frame.push(resolveClassInfo(constPool.getClassInfo(iter.u16bitAt(pos + 1))));\r\n            break;\r\n        case NEWARRAY:\r\n            evalNewArray(pos, iter, frame);\r\n            break;\r\n        case ANEWARRAY:\r\n            evalNewObjectArray(pos, iter, frame);\r\n            break;\r\n        case ARRAYLENGTH:\r\n            {\r\n                Type array = simplePop(frame);\r\n                if (!array.isArray() && array != Type.UNINIT)\r\n                    throw new BadBytecode(\"Array length passed a non-array [pos = \" + pos + \"]: \" + array);\r\n                frame.push(Type.INTEGER);\r\n                break;\r\n            }\r\n        case ATHROW:\r\n            verifyAssignable(THROWABLE_TYPE, simplePop(frame));\r\n            break;\r\n        case CHECKCAST:\r\n            verifyAssignable(Type.OBJECT, simplePop(frame));\r\n            frame.push(typeFromDesc(constPool.getClassInfoByDescriptor(iter.u16bitAt(pos + 1))));\r\n            break;\r\n        case INSTANCEOF:\r\n            verifyAssignable(Type.OBJECT, simplePop(frame));\r\n            frame.push(Type.INTEGER);\r\n            break;\r\n        case MONITORENTER:\r\n        case MONITOREXIT:\r\n            verifyAssignable(Type.OBJECT, simplePop(frame));\r\n            break;\r\n        case WIDE:\r\n            evalWide(pos, iter, frame, subroutine);\r\n            break;\r\n        case MULTIANEWARRAY:\r\n            evalNewObjectArray(pos, iter, frame);\r\n            break;\r\n        case IFNULL:\r\n        case IFNONNULL:\r\n            verifyAssignable(Type.OBJECT, simplePop(frame));\r\n            break;\r\n        case GOTO_W:\r\n            break;\r\n        case JSR_W:\r\n            frame.push(Type.RETURN_ADDRESS);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.config.PluginConfiguration.getBasePackagePrefixes",
	"Comment": "converts watchresources property to url array. invalid urls will be skipped and logged as error.",
	"Method": "String[] getBasePackagePrefixes(){\r\n    String basePackagePrefix = getProperty(\"spring.basePackagePrefix\");\r\n    if (basePackagePrefix != null) {\r\n        return basePackagePrefix.split(\",\");\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ClassFile.getSuperclassId",
	"Comment": "returns the index of the constant pool entry representing the superclass.",
	"Method": "int getSuperclassId(){\r\n    return superClass;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtMethod.hashCode",
	"Comment": "returns a hash code value for the method.if two methods have the same name and signature, thenthe hash codes for the two methods are equal.",
	"Method": "int hashCode(){\r\n    return getStringRep().hashCode();\r\n}"
}, {
	"Path": "com.hazelcast.multimap.MultiMapSplitBrainTest.afterSplitLatestAccessMergePolicy",
	"Comment": "the lastaccesstime is measured per multimapcontainer, so we cannot test it with multiple keys on the same map.",
	"Method": "void afterSplitLatestAccessMergePolicy(){\r\n    multiMapA1.put(\"key\", \"value\");\r\n    sleepAtLeastMillis(100);\r\n    multiMapA2.put(\"key\", \"LatestAccessedValue\");\r\n    multiMapB2.put(\"key\", \"LatestAccessedValue\");\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.compiler.TypeChecker.argTypesToString",
	"Comment": "converts an array of tuples of exprtype, arraydim, and classnameinto a string object.",
	"Method": "String argTypesToString(int[] types,int[] dims,String[] cnames){\r\n    StringBuffer sbuf = new StringBuffer();\r\n    sbuf.append('(');\r\n    int n = types.length;\r\n    if (n > 0) {\r\n        int i = 0;\r\n        while (true) {\r\n            typeToString(sbuf, types[i], dims[i], cnames[i]);\r\n            if (++i < n)\r\n                sbuf.append(',');\r\n            else\r\n                break;\r\n        }\r\n    }\r\n    sbuf.append(')');\r\n    return sbuf.toString();\r\n}"
}, {
	"Path": "com.hazelcast.query.impl.extractor.AbstractExtractionTest.setupIndexes",
	"Comment": "configures the hz indexing according to the test parameters",
	"Method": "void setupIndexes(Config config,Query query){\r\n    if (index != Index.NO_INDEX) {\r\n        MapIndexConfig mapIndexConfig = new MapIndexConfig();\r\n        mapIndexConfig.setAttribute(query.expression);\r\n        mapIndexConfig.setOrdered(index == Index.ORDERED);\r\n        config.getMapConfig(\"map\").addMapIndexConfig(mapIndexConfig);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.makeNestedClass",
	"Comment": "makes a new public nested class.if this method is called,the ctclass, which encloses the nested class, is modifiedsince a class file includes a list of nested classes.the current implementation only supports a static nested class.isstatic must be true.",
	"Method": "CtClass makeNestedClass(String name,boolean isStatic){\r\n    throw new RuntimeException(getName() + \" is not a class\");\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ExceptionsAttribute.copy",
	"Comment": "makes a copy.class names are replaced according to thegiven map object.",
	"Method": "AttributeInfo copy(ConstPool newCp,Map<String, String> classnames){\r\n    return new ExceptionsAttribute(newCp, this, classnames);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.Modifier.isSynchronized",
	"Comment": "returns true if the modifiers include the synchronizedmodifier.",
	"Method": "boolean isSynchronized(int mod){\r\n    return (mod & SYNCHRONIZED) != 0;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.CodeAttribute.getAttribute",
	"Comment": "returns the attribute with the specified name.if it is not found, this method returns null.",
	"Method": "AttributeInfo getAttribute(String name){\r\n    return AttributeInfo.lookup(attributes, name);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.scopedpool.SoftValueHashMap.put",
	"Comment": "updates this map so that the given key maps to the givenvalue. if the map previously contained a mapping forkey then that mapping is replaced and the previous valueis returned.",
	"Method": "V put(K key,V value){\r\n    processQueue();\r\n    return valueOrNull(hash.put(key, SoftValueRef.create(key, value, queue)));\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.ClassPool.getOrNull",
	"Comment": "reads a class file from the source and returns a referenceto the ctclassobject representing that class file.this method is equivalent to get exceptthat it returns null when a class file isnot found and it never throws an exception.",
	"Method": "CtClass getOrNull(String classname){\r\n    CtClass clazz = null;\r\n    if (classname == null)\r\n        clazz = null;\r\n    else\r\n        try {\r\n            clazz = get0(classname, true);\r\n        } catch (NotFoundException e) {\r\n        }\r\n    if (clazz != null)\r\n        clazz.incGetCounter();\r\n    return clazz;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.setInterfaces",
	"Comment": "sets implemented interfaces.if this object represents an interface,this method sets the interfaces extended by that interface.",
	"Method": "void setInterfaces(CtClass[] list){\r\n    checkModify();\r\n}"
}, {
	"Path": "com.hazelcast.client.ringbuffer.RingbufferTest.readManyAsync_maxCount",
	"Comment": "checks if the max count works. so if more results are available than needed, the surplus results should not be read.",
	"Method": "void readManyAsync_maxCount(){\r\n    serverRingbuffer.add(\"1\");\r\n    serverRingbuffer.add(\"2\");\r\n    serverRingbuffer.add(\"3\");\r\n    serverRingbuffer.add(\"4\");\r\n    serverRingbuffer.add(\"5\");\r\n    serverRingbuffer.add(\"6\");\r\n    ICompletableFuture<ReadResultSet<String>> f = clientRingbuffer.readManyAsync(0, 3, 3, null);\r\n    ReadResultSet rs = f.get();\r\n    assertInstanceOf(PortableReadResultSet.class, rs);\r\n    assertEquals(3, rs.readCount());\r\n    assertEquals(\"1\", rs.get(0));\r\n    assertEquals(\"2\", rs.get(1));\r\n    assertEquals(\"3\", rs.get(2));\r\n}"
}, {
	"Path": "com.hazelcast.client.util.ClientStateListener.awaitDisconnected",
	"Comment": "waits until the client is disconnected from the cluster.does not wait if the client is already shutting down or shutdown.",
	"Method": "boolean awaitDisconnected(long timeout,TimeUnit unit,boolean awaitDisconnected){\r\n    return awaitDisconnected(Long.MAX_VALUE, MILLISECONDS);\r\n}"
}, {
	"Path": "com.hazelcast.spring.transaction.TestSpringManagedHazelcastTransaction.transactionalServiceBeanInvocation_withNestedBeanThrowingException_rollback",
	"Comment": "tests that transaction will be rollbacked when putting one object eachvia two beans, one nested within the other,if there is an exception in the nested bean, but no exception in our own bean.",
	"Method": "void transactionalServiceBeanInvocation_withNestedBeanThrowingException_rollback(){\r\n    RuntimeException expectedEx = null;\r\n    try {\r\n        service.putUsingSameBean_thenOtherBeanThrowingException_sameTransaction(new DummyObject(1L, \"magic\"), new DummyObject(2L, \"magic2\"));\r\n    } catch (RuntimeException ex) {\r\n        expectedEx = ex;\r\n    } finally {\r\n        assertNotNull(expectedEx);\r\n        assertEquals(0L, instance.getMap(\"dummyObjectMap\").size());\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.test.bounce.BounceMemberRule.waitForFutures",
	"Comment": "wait until all test tasks complete or one of them throws an exception",
	"Method": "void waitForFutures(Future[] futures){\r\n    long deadline = currentTimeMillis() + SECONDS.toMillis(TEST_TASK_TIMEOUT_SECONDS);\r\n    LOGGER.info(\"Waiting until \" + timeToString(deadline) + \" for test tasks to complete gracefully.\");\r\n    List<Future> futuresToWaitFor = new ArrayList<Future>(Arrays.asList(futures));\r\n    while (!futuresToWaitFor.isEmpty() && currentTimeMillis() < deadline) {\r\n        Iterator<Future> iterator = futuresToWaitFor.iterator();\r\n        while (iterator.hasNext()) {\r\n            boolean hasTestFailed = testFailed.get();\r\n            Future future = iterator.next();\r\n            try {\r\n                if ((hasTestFailed && future.isDone()) || !hasTestFailed) {\r\n                    future.get(1, SECONDS);\r\n                    iterator.remove();\r\n                }\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            } catch (ExecutionException e) {\r\n                throw rethrow(e.getCause());\r\n            } catch (TimeoutException e) {\r\n            }\r\n        }\r\n    }\r\n    if (!futuresToWaitFor.isEmpty()) {\r\n        LOGGER.warning(\"Test tasks did not complete within \" + TEST_TASK_TIMEOUT_SECONDS + \" seconds, there are still \" + futuresToWaitFor.size() + \" unfinished test tasks.\");\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.multimap.MultiMapSplitBrainTest.afterSplitHigherHitsMergePolicy",
	"Comment": "the hits are measured per multimapvalue, so we can test it with multiple keys on the same map.",
	"Method": "void afterSplitHigherHitsMergePolicy(){\r\n    multiMapA1.put(\"key1\", \"higherHitsValue1\");\r\n    multiMapA1.put(\"key2\", \"value2\");\r\n    multiMapA1.get(\"key1\");\r\n    multiMapA1.get(\"key1\");\r\n    multiMapA2.put(\"key1\", \"value1\");\r\n    multiMapA2.put(\"key2\", \"higherHitsValue2\");\r\n    multiMapA2.get(\"key2\");\r\n    multiMapA2.get(\"key2\");\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.isModified",
	"Comment": "returns true if the definition of the class has been modified.",
	"Method": "boolean isModified(){\r\n    return false;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtField.getConstantValue",
	"Comment": "returns the value of this field if it is a constant field.this method works only if the field type is a primitive typeor string type.otherwise, it returns null.a constant field is static and final.",
	"Method": "Object getConstantValue(int getConstantValue,ConstPool cp,CtClass type,int getConstantValue,ConstPool cp,CtClass type,int getConstantValue,ConstPool cp,CtClass type,int getConstantValue,ConstPool cp,CtClass type,int getConstantValue,ConstPool cp,CtClass type,int getConstantValue,ConstPool cp,CtClass type,int getConstantValue,ConstPool cp,CtClass type,int getConstantValue,ConstPool cp,CtClass type){\r\n    int index = fieldInfo.getConstantValue();\r\n    if (index == 0)\r\n        return null;\r\n    ConstPool cp = fieldInfo.getConstPool();\r\n    switch(cp.getTag(index)) {\r\n        case ConstPool.CONST_Long:\r\n            return Long.valueOf(cp.getLongInfo(index));\r\n        case ConstPool.CONST_Float:\r\n            return Float.valueOf(cp.getFloatInfo(index));\r\n        case ConstPool.CONST_Double:\r\n            return Double.valueOf(cp.getDoubleInfo(index));\r\n        case ConstPool.CONST_Integer:\r\n            int value = cp.getIntegerInfo(index);\r\n            if (\"Z\".equals(fieldInfo.getDescriptor()))\r\n                return Boolean.valueOf(value != 0);\r\n            return Integer.valueOf(value);\r\n        case ConstPool.CONST_String:\r\n            return cp.getStringInfo(index);\r\n        default:\r\n            throw new RuntimeException(\"bad tag: \" + cp.getTag(index) + \" at \" + index);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtField.getGenericSignature",
	"Comment": "returns the generic signature of the field.it represents a type including type variables.",
	"Method": "String getGenericSignature(){\r\n    SignatureAttribute sa = (SignatureAttribute) fieldInfo.getAttribute(SignatureAttribute.tag);\r\n    return sa == null ? null : sa.getSignature();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.stackmap.TypeData.commonSuperClass",
	"Comment": "finds the most specific common super class of the given classes.this method is a copy from javassist.bytecode.analysis.type.",
	"Method": "CtClass commonSuperClass(CtClass one,CtClass two){\r\n    CtClass deep = one;\r\n    CtClass shallow = two;\r\n    CtClass backupShallow = shallow;\r\n    CtClass backupDeep = deep;\r\n    for (; ; ) {\r\n        if (eq(deep, shallow) && deep.getSuperclass() != null)\r\n            return deep;\r\n        CtClass deepSuper = deep.getSuperclass();\r\n        CtClass shallowSuper = shallow.getSuperclass();\r\n        if (shallowSuper == null) {\r\n            shallow = backupShallow;\r\n            break;\r\n        }\r\n        if (deepSuper == null) {\r\n            deep = backupDeep;\r\n            backupDeep = backupShallow;\r\n            backupShallow = deep;\r\n            deep = shallow;\r\n            shallow = backupShallow;\r\n            break;\r\n        }\r\n        deep = deepSuper;\r\n        shallow = shallowSuper;\r\n    }\r\n    for (; ; ) {\r\n        deep = deep.getSuperclass();\r\n        if (deep == null)\r\n            break;\r\n        backupDeep = backupDeep.getSuperclass();\r\n    }\r\n    deep = backupDeep;\r\n    while (!eq(deep, shallow)) {\r\n        deep = deep.getSuperclass();\r\n        shallow = shallow.getSuperclass();\r\n    }\r\n    return deep;\r\n}"
}, {
	"Path": "com.hazelcast.spring.transaction.HazelcastTransactionManager.getTransactionContext",
	"Comment": "returns the transaction context for the given hazelcast instance bounded to the current thread.",
	"Method": "TransactionContext getTransactionContext(HazelcastInstance hazelcastInstance,TransactionContext getTransactionContext){\r\n    return getTransactionContext(this.hazelcastInstance);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtField.getAvailableAnnotations",
	"Comment": "returns the annotations associated with this field.if any annotations are not on the classpath, they are not includedin the returned array.",
	"Method": "Object[] getAvailableAnnotations(){\r\n    try {\r\n        return getAnnotations(true);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new RuntimeException(\"Unexpected exception\", e);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getInterfaces",
	"Comment": "obtains the class objects representing the interfaces implementedby the class or, if this object represents an interface, the interfacesextended by that interface.",
	"Method": "CtClass[] getInterfaces(){\r\n    return new CtClass[0];\r\n}"
}, {
	"Path": "com.hazelcast.test.starter.HazelcastStarterUtils.transferToClassloader",
	"Comment": "transfers the given object to the given target classloader.",
	"Method": "T transferToClassloader(T object,ClassLoader targetClassloader){\r\n    if (object.getClass().getClassLoader() == targetClassloader) {\r\n        return object;\r\n    }\r\n    Class<?> byteArrayInputStreamClass = targetClassloader.loadClass(ByteArrayInputStream.class.getName());\r\n    Class<?> objectInputStreamClass = targetClassloader.loadClass(ObjectInputStream.class.getName());\r\n    Class<?> inputStreamClass = targetClassloader.loadClass(InputStream.class.getName());\r\n    Constructor<?> byteArrayInputStreamConstructor = byteArrayInputStreamClass.getConstructor(byte[].class);\r\n    Constructor<?> objectInputStreamConstructor = objectInputStreamClass.getConstructor(inputStreamClass);\r\n    Method byteArrayInputStreamCloseMethod = byteArrayInputStreamClass.getMethod(\"close\");\r\n    Method objectInputStreamCloseMethod = objectInputStreamClass.getMethod(\"close\");\r\n    Method objectInputStreamReadObjectMethod = objectInputStreamClass.getMethod(\"readObject\");\r\n    ByteArrayOutputStream byteArrayOutputStream = null;\r\n    ObjectOutputStream objectOutputStream = null;\r\n    Object byteArrayInputStream = null;\r\n    Object objectInputStream = null;\r\n    try {\r\n        byteArrayOutputStream = new ByteArrayOutputStream();\r\n        objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);\r\n        objectOutputStream.writeObject(object);\r\n        byte[] serializedObject = byteArrayOutputStream.toByteArray();\r\n        byteArrayInputStream = byteArrayInputStreamConstructor.newInstance(new Object[] { serializedObject });\r\n        objectInputStream = objectInputStreamConstructor.newInstance(byteArrayInputStream);\r\n        return (T) objectInputStreamReadObjectMethod.invoke(objectInputStream);\r\n    } catch (Exception e) {\r\n        throw new GuardianException(\"Object transfer via serialization failed for: \" + object, e);\r\n    } finally {\r\n        if (objectInputStream != null) {\r\n            objectInputStreamCloseMethod.invoke(objectInputStream);\r\n        }\r\n        if (byteArrayInputStream != null) {\r\n            byteArrayInputStreamCloseMethod.invoke(byteArrayInputStream);\r\n        }\r\n        closeResource(objectOutputStream);\r\n        closeResource(byteArrayOutputStream);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.compiler.CodeGen.convertOprandTypes",
	"Comment": "do implicit type conversion.arraydim values of the two oprands must be zero.",
	"Method": "void convertOprandTypes(int type1,int type2,Expr expr){\r\n    boolean rightStrong;\r\n    int type1_p = typePrecedence(type1);\r\n    int type2_p = typePrecedence(type2);\r\n    if (type2_p < 0 && type1_p < 0)\r\n        return;\r\n    if (type2_p < 0 || type1_p < 0)\r\n        badTypes(expr);\r\n    int op, result_type;\r\n    if (type1_p <= type2_p) {\r\n        rightStrong = false;\r\n        exprType = type1;\r\n        op = castOp[type2_p * 4 + type1_p];\r\n        result_type = type1_p;\r\n    } else {\r\n        rightStrong = true;\r\n        op = castOp[type1_p * 4 + type2_p];\r\n        result_type = type2_p;\r\n    }\r\n    if (rightStrong) {\r\n        if (result_type == P_DOUBLE || result_type == P_LONG) {\r\n            if (type1_p == P_DOUBLE || type1_p == P_LONG)\r\n                bytecode.addOpcode(DUP2_X2);\r\n            else\r\n                bytecode.addOpcode(DUP2_X1);\r\n            bytecode.addOpcode(POP2);\r\n            bytecode.addOpcode(op);\r\n            bytecode.addOpcode(DUP2_X2);\r\n            bytecode.addOpcode(POP2);\r\n        } else if (result_type == P_FLOAT) {\r\n            if (type1_p == P_LONG) {\r\n                bytecode.addOpcode(DUP_X2);\r\n                bytecode.addOpcode(POP);\r\n            } else\r\n                bytecode.addOpcode(SWAP);\r\n            bytecode.addOpcode(op);\r\n            bytecode.addOpcode(SWAP);\r\n        } else\r\n            fatal();\r\n    } else if (op != NOP)\r\n        bytecode.addOpcode(op);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.annotation.Annotation.equals",
	"Comment": "returns true if the given object represents the same annotationas this object.the equality test checks the member values.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == this)\r\n        return true;\r\n    if (obj == null || obj instanceof Annotation == false)\r\n        return false;\r\n    Annotation other = (Annotation) obj;\r\n    if (getTypeName().equals(other.getTypeName()) == false)\r\n        return false;\r\n    Map<String, Pair> otherMembers = other.members;\r\n    if (members == otherMembers)\r\n        return true;\r\n    else if (members == null)\r\n        return otherMembers == null;\r\n    else if (otherMembers == null)\r\n        return false;\r\n    else\r\n        return members.equals(otherMembers);\r\n}"
}, {
	"Path": "com.hazelcast.client.map.impl.querycache.ClientQueryCacheBasicTest.setup",
	"Comment": "setup a map with 2 query caches, same predicate, one includes values, the other excludes values",
	"Method": "void setup(){\r\n    Config config = getConfig();\r\n    ClientConfig clientConfig = new ClientConfig();\r\n    clientConfig.addQueryCacheConfig(TEST_MAP_NAME, new QueryCacheConfig(QUERY_CACHE_NAME).setPredicateConfig(new PredicateConfig(predicate)).setIncludeValue(includeValues));\r\n    clientConfig.getNetworkConfig().setConnectionAttemptLimit(Integer.MAX_VALUE);\r\n    if (useNearCache) {\r\n        clientConfig.addNearCacheConfig(new NearCacheConfig().setName(TEST_MAP_NAME).setInvalidateOnChange(true));\r\n    }\r\n    clientConfig.setProperty(MapEventPublisherImpl.LISTENER_WITH_PREDICATE_PRODUCES_NATURAL_EVENT_TYPES.getName(), Boolean.toString(useQueryCacheNaturalFilteringStrategy));\r\n    factory = new TestHazelcastFactory();\r\n    factory.newHazelcastInstance(config);\r\n    HazelcastInstance client = factory.newHazelcastClient(clientConfig);\r\n    map = client.getMap(TEST_MAP_NAME);\r\n    queryCache = map.getQueryCache(QUERY_CACHE_NAME);\r\n}"
}, {
	"Path": "com.hazelcast.client.test.TestAwareClientFactory.terminateAll",
	"Comment": "terminates all client and member instances created by this factory for current test method name.",
	"Method": "void terminateAll(){\r\n    shutdownInstances(perMethodClients.remove(getTestMethodName()));\r\n    super.terminateAll();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getField",
	"Comment": "returns the field with the specified name and type.the returned fieldmay be a private field declared in a super class or interface.unlike java, the jvm allows a class to havemultiple fields with the same name but different types.",
	"Method": "CtField getField(String name,CtField getField,String name,String desc){\r\n    throw new NotFoundException(name);\r\n}"
}, {
	"Path": "com.hazelcast.client.proxy.ClientPNCounterProxy.getMaxConfiguredReplicaCount",
	"Comment": "returns the max configured replica count.when invoked for the first time, this method will fetch theconfiguration from a cluster member.",
	"Method": "int getMaxConfiguredReplicaCount(){\r\n    if (maxConfiguredReplicaCount > 0) {\r\n        return maxConfiguredReplicaCount;\r\n    } else {\r\n        final ClientMessage request = PNCounterGetConfiguredReplicaCountCodec.encodeRequest(name);\r\n        final ClientMessage response = invoke(request);\r\n        final PNCounterGetConfiguredReplicaCountCodec.ResponseParameters resultParameters = PNCounterGetConfiguredReplicaCountCodec.decodeResponse(response);\r\n        maxConfiguredReplicaCount = resultParameters.response;\r\n    }\r\n    return maxConfiguredReplicaCount;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.FieldInfo.getAttributes",
	"Comment": "returns all the attributes.the returned list objectis shared with this object.if you add a new attribute to the list,the attribute is also added to the field represented by thisobject.if you remove an attribute from the list, it is also removedfrom the field.",
	"Method": "List<AttributeInfo> getAttributes(){\r\n    if (attribute == null)\r\n        attribute = new ArrayList<AttributeInfo>();\r\n    return attribute;\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientReliableTopicConfig.getReadBatchSize",
	"Comment": "gets the maximum number of items to read in a batch. returned value will always be equal or larger than 1.",
	"Method": "int getReadBatchSize(){\r\n    return readBatchSize;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getConstructor",
	"Comment": "returns the constructor with the given signature,which is represented by a character stringcalled method descriptor.for details of the method descriptor, see the jvm specificationor javassist.bytecode.descriptor.",
	"Method": "CtConstructor getConstructor(String desc){\r\n    throw new NotFoundException(\"no such constructor\");\r\n}"
}, {
	"Path": "com.hazelcast.test.TestHazelcastInstanceFactory.terminate",
	"Comment": "terminates supplied instance by releasing internal resources.",
	"Method": "void terminate(HazelcastInstance instance){\r\n    Address address = getNode(instance).address;\r\n    terminateInstance(instance);\r\n    registry.removeInstance(address);\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientAwsConfig.setInsideAws",
	"Comment": "set to true if client is inside aws environmentdefault value is false.",
	"Method": "ClientAwsConfig setInsideAws(boolean insideAws){\r\n    setUsePublicIp(!insideAws);\r\n    return this;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ClassFile.setName",
	"Comment": "sets the class name. this method substitutes the new name for alloccurrences of the old class name in the class file.",
	"Method": "void setName(String name){\r\n    renameClass(thisclassname, name);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.Frame.getTopIndex",
	"Comment": "gets the index of the type sitting at the top of the stack.this is not to be confused with a length operation whichwould return the number of elements, not the position ofthe last element.",
	"Method": "int getTopIndex(){\r\n    return top - 1;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ClassFile.getAttributes",
	"Comment": "returns all the attributes.the returned list objectis shared with this object.if you add a new attribute to the list,the attribute is also added to the classs file represented by thisobject.if you remove an attribute from the list, it is also removedfrom the class file.",
	"Method": "List<AttributeInfo> getAttributes(){\r\n    return attributes;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.Modifier.isTransient",
	"Comment": "returns true if the modifiers include the transientmodifier.",
	"Method": "boolean isTransient(int mod){\r\n    return (mod & TRANSIENT) != 0;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.convert.TransformCall.transform",
	"Comment": "modify invokeinterface, invokespecial, invokestatic and invokevirtualso that a different method is invoked.the class name in the operandof these instructions might be a subclass of the target class specifiedby classname. this method transforms the instructionin that case unless the subclass overrides the target method.",
	"Method": "int transform(CtClass clazz,int pos,CodeIterator iterator,ConstPool cp){\r\n    int c = iterator.byteAt(pos);\r\n    if (c == INVOKEINTERFACE || c == INVOKESPECIAL || c == INVOKESTATIC || c == INVOKEVIRTUAL) {\r\n        int index = iterator.u16bitAt(pos + 1);\r\n        String cname = cp.eqMember(methodname, methodDescriptor, index);\r\n        if (cname != null && matchClass(cname, clazz.getClassPool())) {\r\n            int ntinfo = cp.getMemberNameAndType(index);\r\n            pos = match(c, pos, iterator, cp.getNameAndTypeDescriptor(ntinfo), cp);\r\n        }\r\n    }\r\n    return pos;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.Expr.getLineNumber",
	"Comment": "returns the line number of the source line containing the expression.",
	"Method": "int getLineNumber(){\r\n    return thisMethod.getLineNumber(currentPos);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtBehavior.insertParameter",
	"Comment": "inserts a new parameter, which becomes the first parameter.",
	"Method": "void insertParameter(CtClass type){\r\n    declaringClass.checkModify();\r\n    String desc = methodInfo.getDescriptor();\r\n    String desc2 = Descriptor.insertParameter(type, desc);\r\n    try {\r\n        addParameter2(Modifier.isStatic(getModifiers()) ? 0 : 1, type, desc);\r\n    } catch (BadBytecode e) {\r\n        throw new CannotCompileException(e);\r\n    }\r\n    methodInfo.setDescriptor(desc2);\r\n}"
}, {
	"Path": "com.hazelcast.spring.transaction.TestSpringManagedHazelcastTransaction.transactionalServiceBeanInvocation_commit",
	"Comment": "tests that transaction will be committed if everything works fine.",
	"Method": "void transactionalServiceBeanInvocation_commit(){\r\n    service.put(new DummyObject(1L, \"magic\"));\r\n    assertEquals(1L, instance.getMap(\"dummyObjectMap\").size());\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.ClassPool.makeClass",
	"Comment": "creates a new public class.if there already exists a class with the same name, the new classoverwrites that previous class.if no constructor is explicitly added to the created newclass, javassist generates constructors and adds it whenthe class file is generated.it generates a new constructorfor each constructor of the super class.the new constructortakes the same set of parameters and invokes thecorresponding constructor of the super class.all the receivedparameters are passed to it.",
	"Method": "CtClass makeClass(InputStream classfile,CtClass makeClass,InputStream classfile,boolean ifNotFrozen,CtClass makeClass,ClassFile classfile,CtClass makeClass,ClassFile classfile,boolean ifNotFrozen,CtClass makeClass,String classname,CtClass makeClass,String classname,CtClass superclass){\r\n    checkNotFrozen(classname);\r\n    CtClass clazz = new CtNewClass(classname, this, false, superclass);\r\n    cacheCtClass(classname, clazz, true);\r\n    return clazz;\r\n}"
}, {
	"Path": "com.hazelcast.client.console.ClientConsoleApp.main",
	"Comment": "starts the test application. loads the config from classpath hazelcast.xml,if it fails to load, will use default config.",
	"Method": "void main(String[] args){\r\n    ClientConfig clientConfig;\r\n    try {\r\n        clientConfig = new XmlClientConfigBuilder().build();\r\n    } catch (IllegalArgumentException e) {\r\n        clientConfig = new ClientConfig();\r\n    }\r\n    final HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);\r\n    ClientConsoleApp clientConsoleApp = new ClientConsoleApp(client);\r\n    clientConsoleApp.start(args);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.Type.getDimensions",
	"Comment": "returns the number of dimensions of this array. if the type is not anarray zero is returned.",
	"Method": "int getDimensions(){\r\n    if (!isArray())\r\n        return 0;\r\n    String name = clazz.getName();\r\n    int pos = name.length() - 1;\r\n    int count = 0;\r\n    while (name.charAt(pos) == ']') {\r\n        pos -= 2;\r\n        count++;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.SignatureAttribute.toMethodSignature",
	"Comment": "parses the given signature string as a method type signature.",
	"Method": "MethodSignature toMethodSignature(String sig){\r\n    try {\r\n        return parseMethodSig(sig);\r\n    } catch (IndexOutOfBoundsException e) {\r\n        throw error(sig);\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientNetworkConfig.addAddress",
	"Comment": "adds given addresses to candidate address list that client will use to establish initial connection",
	"Method": "ClientNetworkConfig addAddress(String addresses){\r\n    isNotNull(addresses, \"addresses\");\r\n    for (String address : addresses) {\r\n        isNotNull(address, \"address\");\r\n        checkHasText(address.trim(), \"member must contain text\");\r\n    }\r\n    Collections.addAll(addressList, addresses);\r\n    return this;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.Descriptor.rename",
	"Comment": "substitutes class names in the given descriptor stringaccording to the given map.",
	"Method": "String rename(String desc,String oldname,String newname,String rename,String desc,Map<String, String> map){\r\n    if (map == null)\r\n        return desc;\r\n    StringBuffer newdesc = new StringBuffer();\r\n    int head = 0;\r\n    int i = 0;\r\n    for (; ; ) {\r\n        int j = desc.indexOf('L', i);\r\n        if (j < 0)\r\n            break;\r\n        int k = desc.indexOf(';', j);\r\n        if (k < 0)\r\n            break;\r\n        i = k + 1;\r\n        String name = desc.substring(j + 1, k);\r\n        String name2 = map.get(name);\r\n        if (name2 != null) {\r\n            newdesc.append(desc.substring(head, j));\r\n            newdesc.append('L');\r\n            newdesc.append(name2);\r\n            newdesc.append(';');\r\n            head = i;\r\n        }\r\n    }\r\n    if (head == 0)\r\n        return desc;\r\n    int len = desc.length();\r\n    if (head < len)\r\n        newdesc.append(desc.substring(head, len));\r\n    return newdesc.toString();\r\n}"
}, {
	"Path": "com.hazelcast.test.TestClusterUpgradeUtils.assertNodesVersion",
	"Comment": "assert all nodes in the cluster have the given codebase version",
	"Method": "void assertNodesVersion(HazelcastInstance[] instances,MemberVersion version){\r\n    for (HazelcastInstance instance : instances) {\r\n        assertEquals(version, getNode(instance).getVersion());\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.CodeAttribute.insertLocalVar",
	"Comment": "changes the index numbers of the local variablesto append a new parameter.this method does not update localvariableattribute,localvariabletypeattribute,stackmaptable, or stackmap.these attributes must be explicitly updated.",
	"Method": "void insertLocalVar(int where,int size){\r\n    CodeIterator ci = iterator();\r\n    while (ci.hasNext()) shiftIndex(ci, where, size);\r\n    setMaxLocals(getMaxLocals() + size);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.AccessFlag.setPublic",
	"Comment": "turns the public bit on.the protected and private bits arecleared.",
	"Method": "int setPublic(int accflags){\r\n    return (accflags & ~(PRIVATE | PROTECTED)) | PUBLIC;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.LineNumberAttribute.toLineNumber",
	"Comment": "returns the line number corresponding to the specified bytecode.",
	"Method": "int toLineNumber(int pc){\r\n    int n = tableLength();\r\n    int i = 0;\r\n    for (; i < n; ++i) if (pc < startPc(i))\r\n        if (i == 0)\r\n            return lineNumber(0);\r\n        else\r\n            break;\r\n    return lineNumber(i - 1);\r\n}"
}, {
	"Path": "com.hazelcast.spi.impl.merge.AbstractContainerMergerTest.testMergerRun_whenEmptyCollector_thenMergerDoesNotRun",
	"Comment": "tests that the merger finishes without invoking merge operations, if no containers have been collected.",
	"Method": "void testMergerRun_whenEmptyCollector_thenMergerDoesNotRun(){\r\n    TestMergeOperation operation = new TestMergeOperation();\r\n    TestContainerMerger merger = new TestContainerMerger(emptyCollector, nodeEngine, operation);\r\n    merger.run();\r\n    assertFalse(\"Expected the merge operation not to be invoked\", operation.hasBeenInvoked);\r\n    assertFalse(\"Expected collected containers not to be destroyed\", collector.onDestroyHasBeenCalled);\r\n}"
}, {
	"Path": "com.hazelcast.ringbuffer.impl.RingbufferTTLTest.whenTTLEnabled_thenEventuallyRingbufferEmpties",
	"Comment": "10 seconds, then we expect that within 12 seconds the buffer is empty.",
	"Method": "void whenTTLEnabled_thenEventuallyRingbufferEmpties(){\r\n    int ttl = 10;\r\n    int maximumVisibleTTL = ttl + 2;\r\n    setup(new RingbufferConfig(\"foo\").setTimeToLiveSeconds(ttl));\r\n    for (int k = 0; k < ringbuffer.capacity(); k++) {\r\n        ringbuffer.add(\"item\" + k);\r\n    }\r\n    final long tail = ringbuffer.tailSequence();\r\n    assertTrueEventually(new AssertTask() {\r\n        @Override\r\n        public void run() throws Exception {\r\n            assertEquals(tail, ringbuffer.tailSequence());\r\n            assertEquals(tail + 1, ringbuffer.headSequence());\r\n            assertEquals(0, ringbuffer.size());\r\n            assertEquals(ringbuffer.capacity(), ringbuffer.remainingCapacity());\r\n        }\r\n    }, maximumVisibleTTL);\r\n    for (int k = 0; k < ringbuffer.capacity(); k++) {\r\n        assertNull(arrayRingbuffer.getItems()[k]);\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.ringbuffer.impl.RingbufferTTLTest.whenTTLEnabled_thenEventuallyRingbufferEmpties",
	"Comment": "10 seconds, then we expect that within 12 seconds the buffer is empty.",
	"Method": "void whenTTLEnabled_thenEventuallyRingbufferEmpties(){\r\n    assertEquals(tail, ringbuffer.tailSequence());\r\n    assertEquals(tail + 1, ringbuffer.headSequence());\r\n    assertEquals(0, ringbuffer.size());\r\n    assertEquals(ringbuffer.capacity(), ringbuffer.remainingCapacity());\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.annotation.AnnotationImpl.getAnnotation",
	"Comment": "obtains the internal data structure representing the annotation.",
	"Method": "Annotation getAnnotation(){\r\n    return annotation;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtPrimitiveType.getGetMethodName",
	"Comment": "returns the name of the method for retrieving the valuefrom the wrapper object.for example, if the type is int, then the method name isintvalue.",
	"Method": "String getGetMethodName(){\r\n    return getMethodName;\r\n}"
}, {
	"Path": "com.hazelcast.buildutils.ElementParser.parseDelimitedString",
	"Comment": "parses delimited string and returns an array containing the tokens. this parser obeys quotes, so the delimiter characterwill be ignored if it is inside of a quote. this method assumes that the quote character is not included in the set ofdelimiter characters.",
	"Method": "List<String> parseDelimitedString(String value,char delimiter,List<String> parseDelimitedString,String value,char delimiter,boolean trim){\r\n    if (value == null) {\r\n        value = \"\";\r\n    }\r\n    List<String> list = new ArrayList<String>();\r\n    StringBuilder sb = new StringBuilder();\r\n    int expecting = (CHAR | DELIMITER | START_QUOTE);\r\n    for (int i = 0; i < value.length(); i++) {\r\n        char character = value.charAt(i);\r\n        boolean isEscaped = isEscaped(value, i);\r\n        boolean isDelimiter = isDelimiter(delimiter, character, isEscaped);\r\n        boolean isQuote = isQuote(character, isEscaped);\r\n        if (isDelimiter && ((expecting & DELIMITER) > 0)) {\r\n            addPart(list, sb, trim);\r\n            sb.delete(0, sb.length());\r\n            expecting = (CHAR | DELIMITER | START_QUOTE);\r\n        } else if (isQuote && ((expecting & START_QUOTE) > 0)) {\r\n            sb.append(character);\r\n            expecting = CHAR | END_QUOTE;\r\n        } else if (isQuote && ((expecting & END_QUOTE) > 0)) {\r\n            sb.append(character);\r\n            expecting = (CHAR | START_QUOTE | DELIMITER);\r\n        } else if ((expecting & CHAR) > 0) {\r\n            sb.append(character);\r\n        } else {\r\n            String message = String.format(\"Invalid delimited string [%s] for delimiter: %s\", value, delimiter);\r\n            throw new IllegalArgumentException(message);\r\n        }\r\n    }\r\n    if (sb.length() > 0) {\r\n        addPart(list, sb, trim);\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "com.hazelcast.ringbuffer.impl.RingbufferAbstractTest.add_manyTimesRoundTheRing",
	"Comment": "this test verifies that the add works correctly if we go round the ringbuffer many times.",
	"Method": "void add_manyTimesRoundTheRing(){\r\n    RingbufferConfig c = config.getRingbufferConfig(ringbuffer.getName());\r\n    for (int iteration = 0; iteration < c.getCapacity() * 100; iteration++) {\r\n        long oldTail = ringbuffer.tailSequence();\r\n        String item = \"\" + iteration;\r\n        long sequence = ringbuffer.add(item);\r\n        long expectedSequence = oldTail + 1;\r\n        assertEquals(expectedSequence, sequence);\r\n        assertEquals(expectedSequence, ringbuffer.tailSequence());\r\n        if (ringbuffer.tailSequence() < c.getCapacity()) {\r\n            assertEquals(0, ringbuffer.headSequence());\r\n        } else {\r\n            assertEquals(ringbuffer.tailSequence() - c.getCapacity() + 1, ringbuffer.headSequence());\r\n        }\r\n        assertEquals(item, ringbuffer.readOne(expectedSequence));\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientNetworkConfig.addOutboundPortDefinition",
	"Comment": "add outbound port definition to the outbound port definition list",
	"Method": "ClientNetworkConfig addOutboundPortDefinition(String portDef){\r\n    if (outboundPortDefinitions == null) {\r\n        outboundPortDefinitions = new HashSet<String>();\r\n    }\r\n    outboundPortDefinitions.add(portDef);\r\n    return this;\r\n}"
}, {
	"Path": "com.hazelcast.client.impl.clientside.ClientLoggerConfigurationTest.testLoggingWithConfiguration",
	"Comment": "test its loggingservice produce instances of the expected logger impl",
	"Method": "void testLoggingWithConfiguration(boolean programmaticConfiguration){\r\n    hazelcastFactory = new TestHazelcastFactory();\r\n    Config cg = new Config();\r\n    cg.setProperty(LOGGING_TYPE_PROPERTY, LOGGING_TYPE_JDK);\r\n    hazelcastFactory.newHazelcastInstance(cg);\r\n    ClientConfig config = new ClientConfig();\r\n    if (programmaticConfiguration) {\r\n        config.setProperty(LOGGING_TYPE_PROPERTY, LOGGING_TYPE_LOG4J2);\r\n    } else {\r\n        isolatedLoggingRule.setLoggingType(LOGGING_TYPE_LOG4J2);\r\n    }\r\n    HazelcastInstance client = hazelcastFactory.newHazelcastClient(config);\r\n    ILogger clientLogger = client.getLoggingService().getLogger(\"loggerName\");\r\n    ILogger actualLogger = (ILogger) getFromField(clientLogger, \"logger\");\r\n    Class<?> clientLoggerClass = actualLogger.getClass();\r\n    ILogger expectedLogger = new Log4j2Factory().getLogger(\"expectedLogger\");\r\n    Class<?> expectedLoggerClass = expectedLogger.getClass();\r\n    assertSame(expectedLoggerClass, clientLoggerClass);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.Cast.getType",
	"Comment": "returns the ctclass object representingthe type specified by the cast.",
	"Method": "CtClass getType(){\r\n    ConstPool cp = getConstPool();\r\n    int pos = currentPos;\r\n    int index = iterator.u16bitAt(pos + 1);\r\n    String name = cp.getClassInfo(index);\r\n    return thisClass.getClassPool().getCtClass(name);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.Descriptor.toJvmName",
	"Comment": "returns the internal representation of the class name in thejvm.",
	"Method": "String toJvmName(String classname,String toJvmName,CtClass clazz){\r\n    if (clazz.isArray())\r\n        return of(clazz);\r\n    return toJvmName(clazz.getName());\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.Descriptor.insertParameter",
	"Comment": "inserts a parameter type at the beginning of the parameterlist representedby the given descriptor.",
	"Method": "String insertParameter(String classname,String desc,String insertParameter,CtClass type,String descriptor){\r\n    if (descriptor.charAt(0) != '(')\r\n        return descriptor;\r\n    return \"(\" + of(type) + descriptor.substring(1);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.MethodInfo.getLineNumber",
	"Comment": "returns the line number of the source line corresponding to the specifiedbytecode contained in this method.",
	"Method": "int getLineNumber(int pos){\r\n    CodeAttribute ca = getCodeAttribute();\r\n    if (ca == null)\r\n        return -1;\r\n    LineNumberAttribute ainfo = (LineNumberAttribute) ca.getAttribute(LineNumberAttribute.tag);\r\n    if (ainfo == null)\r\n        return -1;\r\n    return ainfo.toLineNumber(pos);\r\n}"
}, {
	"Path": "com.hazelcast.xa.HazelcastXATest.testRecovery_singleInstanceRemaining",
	"Comment": "start two nodes.one node in a new thread prepares tx and shutdowns. check if remaining node can recover tx or not.",
	"Method": "void testRecovery_singleInstanceRemaining(){\r\n    final CountDownLatch nodeShutdownLatch = new CountDownLatch(1);\r\n    TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\r\n    HazelcastInstance instance1 = factory.newHazelcastInstance();\r\n    HazelcastInstance instance2 = factory.newHazelcastInstance();\r\n    startTX(instance1, nodeShutdownLatch);\r\n    waitNodeToShutDown(nodeShutdownLatch);\r\n    recoverTX(instance2);\r\n    IMap<String, String> map = instance2.getMap(\"map\");\r\n    String actualValue = map.get(\"key\");\r\n    assertEquals(\"value\", actualValue);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CannotCompileException.initCause",
	"Comment": "initializes the cause of this throwable.it is for jdk 1.3 compatibility.",
	"Method": "Throwable initCause(Throwable cause){\r\n    myCause = cause;\r\n    return this;\r\n}"
}, {
	"Path": "com.hazelcast.test.HazelcastParametersRunnerFactory.getSerialClassRunner",
	"Comment": "needs to be protected for hazelcast enterprise hazelcastparametersrunnerfactory",
	"Method": "HazelcastSerialClassRunner getSerialClassRunner(Class<?> testClass,Object[] parameters,String testName){\r\n    return new HazelcastSerialClassRunner(testClass, parameters, testName);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.AttributeInfo.copy",
	"Comment": "makes a copy.class names are replaced according to thegiven map object.",
	"Method": "AttributeInfo copy(ConstPool newCp,Map<String, String> classnames){\r\n    return new AttributeInfo(newCp, getName(), Arrays.copyOf(info, info.length));\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getComponentType",
	"Comment": "if this object represents an array, this method returns the componenttype of the array.otherwise, it returns null.",
	"Method": "CtClass getComponentType(){\r\n    return null;\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientNetworkConfig.setKubernetesConfig",
	"Comment": "sets configuration to connect nodes in kubernetes environment.",
	"Method": "ClientNetworkConfig setKubernetesConfig(KubernetesConfig kubernetesConfig){\r\n    this.kubernetesConfig = kubernetesConfig;\r\n    return this;\r\n}"
}, {
	"Path": "com.hazelcast.spring.transaction.TestSpringManagedHazelcastTransaction.noTransactionContextWhenNoTransaction",
	"Comment": "tests that transactionalcontext cannot be accessed when there is no transaction.",
	"Method": "void noTransactionContextWhenNoTransaction(){\r\n    expectedException.expect(NoTransactionException.class);\r\n    transactionalContext.getMap(\"magic\");\r\n}"
}, {
	"Path": "com.hazelcast.client.spi.ClientProxy.destroyRemotely",
	"Comment": "destroys the remote distributed object counterpart of this proxy byissuing the destruction request to the cluster.",
	"Method": "void destroyRemotely(){\r\n    ClientMessage clientMessage = ClientDestroyProxyCodec.encodeRequest(getDistributedObjectName(), getServiceName());\r\n    try {\r\n        new ClientInvocation(getClient(), clientMessage, getName()).invoke().get();\r\n    } catch (Exception e) {\r\n        throw rethrow(e);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.FieldInfo.addAttribute",
	"Comment": "appends an attribute.if there is already an attribute withthe same name, the new one substitutes for it.",
	"Method": "void addAttribute(AttributeInfo info){\r\n    if (attribute == null)\r\n        attribute = new ArrayList<AttributeInfo>();\r\n    AttributeInfo.remove(attribute, info.getName());\r\n    attribute.add(info);\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientSecurityConfig.setCredentialsClassname",
	"Comment": "credentials class will be instantiated from class name when setcredentialsfactoryconfig andsetcredentialsare not used. the class will be instantiated with empty constructor.",
	"Method": "ClientSecurityConfig setCredentialsClassname(String credentialsClassname){\r\n    this.credentialsClassname = credentialsClassname;\r\n    return this;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.Modifier.setProtected",
	"Comment": "truns the protected bit on.the protected and public bits arecleared.",
	"Method": "int setProtected(int mod){\r\n    return (mod & ~(PRIVATE | PUBLIC)) | PROTECTED;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.stackmap.MapMaker.make2",
	"Comment": "computes the stack map table for j2me.it returns null if the given method does not have to have astack map table or it includes jsr.",
	"Method": "StackMap make2(ClassPool classes,MethodInfo minfo){\r\n    CodeAttribute ca = minfo.getCodeAttribute();\r\n    if (ca == null)\r\n        return null;\r\n    TypedBlock[] blocks;\r\n    try {\r\n        blocks = TypedBlock.makeBlocks(minfo, ca, true);\r\n    } catch (BasicBlock.JsrBytecode e) {\r\n        return null;\r\n    }\r\n    if (blocks == null)\r\n        return null;\r\n    MapMaker mm = new MapMaker(classes, minfo, ca);\r\n    try {\r\n        mm.make(blocks, ca.getCode());\r\n    } catch (BadBytecode bb) {\r\n        throw new BadBytecode(minfo, bb);\r\n    }\r\n    return mm.toStackMap2(minfo.getConstPool(), blocks);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtBehavior.getAvailableAnnotations",
	"Comment": "returns the annotations associated with this method or constructor.if any annotations are not on the classpath, they are not includedin the returned array.",
	"Method": "Object[] getAvailableAnnotations(){\r\n    try {\r\n        return getAnnotations(true);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new RuntimeException(\"Unexpected exception\", e);\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.spi.impl.operationservice.impl.OperationServiceImpl_timeoutTest.testTimeoutSingleMember",
	"Comment": "there was a memory leak caused by the invocation not releasing the backup registration when there is a timeout.",
	"Method": "void testTimeoutSingleMember(){\r\n    HazelcastInstance hz = createHazelcastInstance();\r\n    final IQueue<Object> q = hz.getQueue(\"queue\");\r\n    for (int k = 0; k < 1000; k++) {\r\n        Object response = q.poll(1, TimeUnit.MILLISECONDS);\r\n        assertNull(response);\r\n    }\r\n    OperationServiceImpl_BasicTest.assertNoLitterInOpService(hz);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.MethodCall.getLineNumber",
	"Comment": "returns the line number of the source line containing themethod call.",
	"Method": "int getLineNumber(){\r\n    return super.getLineNumber();\r\n}"
}, {
	"Path": "com.hazelcast.spi.impl.packetdispatcher.impl.PacketDispatcherTest.whenProblemHandlingPacket_thenSwallowed",
	"Comment": "when one of the handlers throws an exception, the exception is logged but not rethrown",
	"Method": "void whenProblemHandlingPacket_thenSwallowed(){\r\n    Packet packet = new Packet().setPacketType(Packet.Type.OPERATION);\r\n    Mockito.doThrow(new ExpectedRuntimeException()).when(operationExecutor).accept(packet);\r\n    dispatcher.accept(packet);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.Loader.setDomain",
	"Comment": "sets the protection domain for the classes handled by this classloader.without registering an appropriate protection domain,the program loaded by this loader will not work with a securitymanager or a signed jar file.",
	"Method": "void setDomain(ProtectionDomain d){\r\n    domain = d;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.hasAnnotation",
	"Comment": "returns true if the class has the specified annotation type.",
	"Method": "boolean hasAnnotation(Class<?> annotationType,boolean hasAnnotation,String annotationTypeName){\r\n    return false;\r\n}"
}, {
	"Path": "com.hazelcast.test.mocknetwork.MockConnectionManager.transmit",
	"Comment": "retries sending packet maximum 5 times until connection to target becomes available.",
	"Method": "boolean transmit(Packet packet,Connection connection,boolean transmit,Packet packet,Address target){\r\n    return send(packet, target, null);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtBehavior.hasAnnotation",
	"Comment": "returns true if the class has the specified annotation type.",
	"Method": "boolean hasAnnotation(String typeName){\r\n    MethodInfo mi = getMethodInfo2();\r\n    AnnotationsAttribute ainfo = (AnnotationsAttribute) mi.getAttribute(AnnotationsAttribute.invisibleTag);\r\n    AnnotationsAttribute ainfo2 = (AnnotationsAttribute) mi.getAttribute(AnnotationsAttribute.visibleTag);\r\n    return CtClassType.hasAnnotationType(typeName, getDeclaringClass().getClassPool(), ainfo, ainfo2);\r\n}"
}, {
	"Path": "com.hazelcast.query.impl.extractor.AbstractExtractionTest.setupMap",
	"Comment": "configures the map according to the test parameters and executes the custom configurator",
	"Method": "Config setupMap(Configurator configurator){\r\n    MapConfig mapConfig = new MapConfig();\r\n    mapConfig.setName(\"map\");\r\n    mapConfig.setInMemoryFormat(inMemoryFormat);\r\n    Config config = new Config();\r\n    config.addMapConfig(mapConfig);\r\n    if (configurator != null) {\r\n        configurator.doWithConfig(config, mv);\r\n    }\r\n    return config;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.compiler.Javac.recordParamNames",
	"Comment": "records parameter names if the localvariableattribute is available.it returns false unless the localvariableattribute is available.",
	"Method": "boolean recordParamNames(CodeAttribute ca,int numOfLocalVars){\r\n    LocalVariableAttribute va = (LocalVariableAttribute) ca.getAttribute(LocalVariableAttribute.tag);\r\n    if (va == null)\r\n        return false;\r\n    int n = va.tableLength();\r\n    for (int i = 0; i < n; ++i) {\r\n        int index = va.index(i);\r\n        if (index < numOfLocalVars)\r\n            gen.recordVariable(va.descriptor(i), va.variableName(i), index, stable);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientConfig.getReliableTopicConfigMap",
	"Comment": "returns the map of reliable topic configurations,mapped by config name. the config name may be a pattern with which theconfiguration was initially obtained.",
	"Method": "Map<String, ClientReliableTopicConfig> getReliableTopicConfigMap(){\r\n    return reliableTopicConfigMap;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.CodeAttribute.getDeclaringClass",
	"Comment": "returns the name of the class declaring the method includingthis code attribute.",
	"Method": "String getDeclaringClass(){\r\n    ConstPool cp = getConstPool();\r\n    return cp.getClassName();\r\n}"
}, {
	"Path": "com.hazelcast.test.TestThread.assertFailsEventually",
	"Comment": "asserts that the thread eventually completes with the expected error.",
	"Method": "void assertFailsEventually(Class<? extends Throwable> cause){\r\n    assertTerminates();\r\n    assertNotNull(\"an error should have been thrown, but \" + getName() + \" completed without error\", error);\r\n    assertTrue(\"error instanceof \" + error, error.getClass().isAssignableFrom(cause));\r\n}"
}, {
	"Path": "com.hazelcast.multimap.MultiMapSplitBrainTest.afterSplitLatestUpdateMergePolicy",
	"Comment": "the lastupdatetime is measured per multimapcontainer, so we cannot test it with multiple keys on the same map.",
	"Method": "void afterSplitLatestUpdateMergePolicy(){\r\n    multiMapA1.put(\"key\", \"value\");\r\n    sleepAtLeastMillis(100);\r\n    multiMapA2.put(\"key\", \"LatestUpdatedValue\");\r\n    multiMapB2.put(\"key\", \"LatestUpdatedValue\");\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.convert.TransformFieldAccess.transform",
	"Comment": "modify getfield, getstatic, putfield, and putstatic so thata different field is accessed.the new field must be declaredin a superclass of the class in which the original field isdeclared.",
	"Method": "int transform(CtClass clazz,int pos,CodeIterator iterator,ConstPool cp){\r\n    int c = iterator.byteAt(pos);\r\n    if (c == GETFIELD || c == GETSTATIC || c == PUTFIELD || c == PUTSTATIC) {\r\n        int index = iterator.u16bitAt(pos + 1);\r\n        String typedesc = TransformReadField.isField(clazz.getClassPool(), cp, fieldClass, fieldname, isPrivate, index);\r\n        if (typedesc != null) {\r\n            if (newIndex == 0) {\r\n                int nt = cp.addNameAndTypeInfo(newFieldname, typedesc);\r\n                newIndex = cp.addFieldrefInfo(cp.addClassInfo(newClassname), nt);\r\n                constPool = cp;\r\n            }\r\n            iterator.write16bit(newIndex, pos + 1);\r\n        }\r\n    }\r\n    return pos;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.MultiType.getCtClass",
	"Comment": "gets the class that corresponds with this type. if this informationis not yet known, java.lang.object will be returned.",
	"Method": "CtClass getCtClass(){\r\n    if (resolved != null)\r\n        return resolved.getCtClass();\r\n    return Type.OBJECT.getCtClass();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.SignatureAttribute.toTypeSignature",
	"Comment": "parses the given signature string as a type signature.the type signature is either the field type signature or a base typedescriptor including void type.",
	"Method": "Type toTypeSignature(String sig){\r\n    try {\r\n        return parseType(sig, new Cursor());\r\n    } catch (IndexOutOfBoundsException e) {\r\n        throw error(sig);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.compiler.MemberCodeGen.isAccessibleField",
	"Comment": "returns null if the field is accessible.otherwise, it throwsan exception or it returns accessormaker if the field is a privateone declared in an enclosing class.",
	"Method": "AccessorMaker isAccessibleField(CtField f,FieldInfo finfo){\r\n    if (AccessFlag.isPrivate(finfo.getAccessFlags()) && f.getDeclaringClass() != thisClass) {\r\n        CtClass declClass = f.getDeclaringClass();\r\n        if (isEnclosing(declClass, thisClass)) {\r\n            AccessorMaker maker = declClass.getAccessorMaker();\r\n            if (maker != null)\r\n                return maker;\r\n        }\r\n        throw new CompileError(\"Field \" + f.getName() + \" in \" + declClass.getName() + \" is private.\");\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.compiler.AccessorMaker.getMethodAccessor",
	"Comment": "returns the name of the method for accessing a private method.",
	"Method": "String getMethodAccessor(String name,String desc,String accDesc,MethodInfo orig){\r\n    String key = name + \":\" + desc;\r\n    String accName = (String) accessors.get(key);\r\n    if (accName != null)\r\n        return accName;\r\n    ClassFile cf = clazz.getClassFile();\r\n    accName = findAccessorName(cf);\r\n    try {\r\n        ConstPool cp = cf.getConstPool();\r\n        ClassPool pool = clazz.getClassPool();\r\n        MethodInfo minfo = new MethodInfo(cp, accName, accDesc);\r\n        minfo.setAccessFlags(AccessFlag.STATIC);\r\n        minfo.addAttribute(new SyntheticAttribute(cp));\r\n        ExceptionsAttribute ea = orig.getExceptionsAttribute();\r\n        if (ea != null)\r\n            minfo.addAttribute(ea.copy(cp, null));\r\n        CtClass[] params = Descriptor.getParameterTypes(accDesc, pool);\r\n        int regno = 0;\r\n        Bytecode code = new Bytecode(cp);\r\n        for (int i = 0; i < params.length; ++i) regno += code.addLoad(regno, params[i]);\r\n        code.setMaxLocals(regno);\r\n        if (desc == accDesc)\r\n            code.addInvokestatic(clazz, name, desc);\r\n        else\r\n            code.addInvokevirtual(clazz, name, desc);\r\n        code.addReturn(Descriptor.getReturnType(desc, pool));\r\n        minfo.setCodeAttribute(code.toCodeAttribute());\r\n        cf.addMethod(minfo);\r\n    } catch (CannotCompileException e) {\r\n        throw new CompileError(e);\r\n    } catch (NotFoundException e) {\r\n        throw new CompileError(e);\r\n    }\r\n    accessors.put(key, accName);\r\n    return accName;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.Descriptor.appendParameter",
	"Comment": "appends a parameter type to the parameter list representedby the given descriptor.the appended parameter becomesthe last parameter.",
	"Method": "String appendParameter(String classname,String desc,String appendParameter,CtClass type,String descriptor){\r\n    int i = descriptor.indexOf(')');\r\n    if (i < 0)\r\n        return descriptor;\r\n    StringBuffer newdesc = new StringBuffer();\r\n    newdesc.append(descriptor.substring(0, i));\r\n    toDescriptor(newdesc, type);\r\n    newdesc.append(descriptor.substring(i));\r\n    return newdesc.toString();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtPrimitiveType.getWrapperName",
	"Comment": "returns the name of the wrapper class.for example, if the type is int, then the wrapper class isjava.lang.integer.",
	"Method": "String getWrapperName(){\r\n    return wrapperName;\r\n}"
}, {
	"Path": "com.hazelcast.ringbuffer.impl.RingbufferAbstractTest.addAllAsync_manyTimesRoundTheRing",
	"Comment": "this test verifies that the addallasync works correctly if we go round the ringbuffer many times.",
	"Method": "void addAllAsync_manyTimesRoundTheRing(){\r\n    RingbufferConfig c = config.getRingbufferConfig(ringbuffer.getName());\r\n    Random random = new Random();\r\n    for (int iteration = 0; iteration < 1000; iteration++) {\r\n        List<String> items = randomList(max(1, random.nextInt(c.getCapacity())));\r\n        long previousTailSeq = ringbuffer.tailSequence();\r\n        long result = ringbuffer.addAllAsync(items, OVERWRITE).get();\r\n        assertEquals(previousTailSeq + items.size(), ringbuffer.tailSequence());\r\n        if (ringbuffer.tailSequence() < c.getCapacity()) {\r\n            assertEquals(0, ringbuffer.headSequence());\r\n        } else {\r\n            assertEquals(ringbuffer.tailSequence() - c.getCapacity() + 1, ringbuffer.headSequence());\r\n        }\r\n        assertEquals(ringbuffer.tailSequence(), result);\r\n        long startSequence = previousTailSeq + 1;\r\n        for (int k = 0; k < items.size(); k++) {\r\n            assertEquals(items.get(k), ringbuffer.readOne(startSequence + k));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.client.util.ClientStateListener.awaitConnected",
	"Comment": "waits until the client is connected to cluster.does not wait if the client is already shutting down or shutdown.",
	"Method": "boolean awaitConnected(long timeout,TimeUnit unit,boolean awaitConnected){\r\n    return awaitConnected(Long.MAX_VALUE, MILLISECONDS);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.Modifier.setPublic",
	"Comment": "truns the public bit on.the protected and private bits arecleared.",
	"Method": "int setPublic(int mod){\r\n    return (mod & ~(PRIVATE | PROTECTED)) | PUBLIC;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getRefClasses",
	"Comment": "returns a collection of the names of all the classesreferenced in this class.that collection includes the name of this class.this method may return null.",
	"Method": "Collection<String> getRefClasses(){\r\n    ClassFile cf = getClassFile2();\r\n    if (cf != null) {\r\n        ClassMap cm = new ClassMap() {\r\n            private static final long serialVersionUID = 1L;\r\n            @Override\r\n            public String put(String oldname, String newname) {\r\n                return put0(oldname, newname);\r\n            }\r\n            @Override\r\n            public String get(Object jvmClassName) {\r\n                String n = toJavaName((String) jvmClassName);\r\n                put0(n, n);\r\n                return null;\r\n            }\r\n            @Override\r\n            public void fix(String name) {\r\n            }\r\n        };\r\n        cf.getRefClasses(cm);\r\n        return cm.values();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getRefClasses",
	"Comment": "returns a collection of the names of all the classesreferenced in this class.that collection includes the name of this class.this method may return null.",
	"Method": "Collection<String> getRefClasses(){\r\n    return put0(oldname, newname);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getRefClasses",
	"Comment": "returns a collection of the names of all the classesreferenced in this class.that collection includes the name of this class.this method may return null.",
	"Method": "Collection<String> getRefClasses(){\r\n    String n = toJavaName((String) jvmClassName);\r\n    put0(n, n);\r\n    return null;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getRefClasses",
	"Comment": "returns a collection of the names of all the classesreferenced in this class.that collection includes the name of this class.this method may return null.",
	"Method": "Collection<String> getRefClasses(){\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.Descriptor.getReturnType",
	"Comment": "returns the ctclass object representing the returntype specified by the given descriptor.",
	"Method": "CtClass getReturnType(String desc,ClassPool cp){\r\n    int i = desc.indexOf(')');\r\n    if (i < 0)\r\n        return null;\r\n    CtClass[] type = new CtClass[1];\r\n    toCtClass(cp, desc, i + 1, type, 0);\r\n    return type[0];\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.Modifier.isAbstract",
	"Comment": "returns true if the modifiers include the abstractmodifier.",
	"Method": "boolean isAbstract(int mod){\r\n    return (mod & ABSTRACT) != 0;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.Descriptor.numOfParameters",
	"Comment": "returns the number of the prameters included in the givendescriptor.",
	"Method": "int numOfParameters(String desc){\r\n    int n = 0;\r\n    int i = 1;\r\n    for (; ; ) {\r\n        char c = desc.charAt(i);\r\n        if (c == ')')\r\n            break;\r\n        while (c == '[') c = desc.charAt(++i);\r\n        if (c == 'L') {\r\n            i = desc.indexOf(';', i) + 1;\r\n            if (i <= 0)\r\n                throw new IndexOutOfBoundsException(\"bad descriptor\");\r\n        } else\r\n            ++i;\r\n        ++n;\r\n    }\r\n    return n;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ClassFile.setVersionToJava5",
	"Comment": "sets the major and minor version to java 5.if the major version is older than 49, java 5extensions such as annotations are ignoredby the jvm.",
	"Method": "void setVersionToJava5(){\r\n    this.major = 49;\r\n    this.minor = 0;\r\n}"
}, {
	"Path": "com.hazelcast.test.starter.HazelcastStarterUtils.transferToCurrentClassloader",
	"Comment": "transfers the given object to the classloader hosting the compatibilitytests.",
	"Method": "T transferToCurrentClassloader(T object){\r\n    if (object.getClass().getClassLoader() == HazelcastStarterUtils.class.getClassLoader()) {\r\n        return object;\r\n    }\r\n    ByteArrayOutputStream byteArrayOutputStream = null;\r\n    ObjectOutputStream objectOutputStream = null;\r\n    ByteArrayInputStream byteArrayInputStream = null;\r\n    ObjectInputStream objectInputStream = null;\r\n    try {\r\n        byteArrayOutputStream = new ByteArrayOutputStream();\r\n        objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);\r\n        objectOutputStream.writeObject(object);\r\n        byte[] serializedObject = byteArrayOutputStream.toByteArray();\r\n        byteArrayInputStream = new ByteArrayInputStream(serializedObject);\r\n        objectInputStream = new ObjectInputStream(byteArrayInputStream);\r\n        return (T) objectInputStream.readObject();\r\n    } catch (Exception e) {\r\n        throw new GuardianException(\"Object transfer via serialization failed for: \" + object, e);\r\n    } finally {\r\n        closeResource(objectInputStream);\r\n        closeResource(byteArrayInputStream);\r\n        closeResource(objectOutputStream);\r\n        closeResource(byteArrayOutputStream);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.ClassPool.removeCached",
	"Comment": "provide a hook so that subclasses can do their owncaching of classes.",
	"Method": "CtClass removeCached(String classname){\r\n    return (CtClass) classes.remove(classname);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.Frame.setRetMerged",
	"Comment": "sets whether or not state from the ret instruction, of the subroutine that was jumpedto has been merged.",
	"Method": "void setRetMerged(boolean retMerged){\r\n    this.retMerged = retMerged;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.Type.isSpecial",
	"Comment": "returns whether or not the type is special. a special type is one that is either usedfor internal tracking, or is only used internally by the jvm.",
	"Method": "boolean isSpecial(){\r\n    return special;\r\n}"
}, {
	"Path": "com.hazelcast.spi.impl.merge.AbstractContainerMergerTest.testMergerRun_whenMergeOperationThrowsException_thenMergerFinishesNormally",
	"Comment": "tests that the merger finishes, even if the merge operation throws an exception.",
	"Method": "void testMergerRun_whenMergeOperationThrowsException_thenMergerFinishesNormally(){\r\n    TestMergeOperation operation = new TestMergeOperation(THROWS_EXCEPTION);\r\n    TestContainerMerger merger = new TestContainerMerger(collector, nodeEngine, operation);\r\n    merger.run();\r\n    assertTrue(\"Expected the merge operation to be invoked\", operation.hasBeenInvoked);\r\n    assertTrue(\"Expected collected containers to be destroyed\", collector.onDestroyHasBeenCalled);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.MultiType.getComponent",
	"Comment": "always returns null since this type is never used for an array.",
	"Method": "Type getComponent(){\r\n    return null;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getMethod",
	"Comment": "returns the method with the given name and signature.the returned method may be declared in a super class.the method signature is represented by a character stringcalled method descriptor,which is defined in the jvm specification.",
	"Method": "CtMethod getMethod(String name,String desc){\r\n    throw new NotFoundException(name);\r\n}"
}, {
	"Path": "com.hazelcast.spring.cache.HazelcastCacheTest.testCacheGetSynchronized",
	"Comment": "tests that a call to get with a callable concurrently properly synchronize the invocations.",
	"Method": "void testCacheGetSynchronized(){\r\n    final AtomicInteger counter = new AtomicInteger();\r\n    final List<Object> results = new CopyOnWriteArrayList<Object>();\r\n    final CountDownLatch latch = new CountDownLatch(10);\r\n    final String key = createRandomKey();\r\n    Runnable run = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                Integer value = cache.get(key, new Callable<Integer>() {\r\n                    @Override\r\n                    public Integer call() {\r\n                        sleepMillis(50);\r\n                        return counter.incrementAndGet();\r\n                    }\r\n                });\r\n                results.add(value);\r\n            } finally {\r\n                latch.countDown();\r\n            }\r\n        }\r\n    };\r\n    for (int i = 0; i < 10; i++) {\r\n        new Thread(run).start();\r\n    }\r\n    latch.await();\r\n    assertEquals(10, results.size());\r\n    for (Object result : results) {\r\n        assertThat((Integer) result, is(1));\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.spring.cache.HazelcastCacheTest.testCacheGetSynchronized",
	"Comment": "tests that a call to get with a callable concurrently properly synchronize the invocations.",
	"Method": "void testCacheGetSynchronized(){\r\n    try {\r\n        Integer value = cache.get(key, new Callable<Integer>() {\r\n            @Override\r\n            public Integer call() {\r\n                sleepMillis(50);\r\n                return counter.incrementAndGet();\r\n            }\r\n        });\r\n        results.add(value);\r\n    } finally {\r\n        latch.countDown();\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.spring.cache.HazelcastCacheTest.testCacheGetSynchronized",
	"Comment": "tests that a call to get with a callable concurrently properly synchronize the invocations.",
	"Method": "void testCacheGetSynchronized(){\r\n    sleepMillis(50);\r\n    return counter.incrementAndGet();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.NewArray.getCreatedDimensions",
	"Comment": "returns the number of dimensions of arrays to be created.if the opcode is multianewarray, this method returns the secondoperand.otherwise, it returns 1.",
	"Method": "int getCreatedDimensions(){\r\n    if (opcode == Opcode.MULTIANEWARRAY)\r\n        return iterator.byteAt(currentPos + 3);\r\n    return 1;\r\n}"
}, {
	"Path": "com.hazelcast.map.standalone.SimpleFunctionalMapTest.main",
	"Comment": "this test runs continuously until an exception is thrown.no args",
	"Method": "void main(String[] args){\r\n    int threadCount = 40;\r\n    final Stats stats = new Stats();\r\n    final HazelcastInstance hazelcast = Hazelcast.newHazelcastInstance(null);\r\n    ExecutorService es = Executors.newFixedThreadPool(threadCount);\r\n    for (int i = 0; i < threadCount; i++) {\r\n        es.submit(new Runnable() {\r\n            public void run() {\r\n                IMap map = hazelcast.getMap(\"default\");\r\n                while (true) {\r\n                    int keyInt = (int) (RANDOM.nextFloat() * ENTRY_COUNT);\r\n                    int operation = ((int) (RANDOM.nextFloat() * 1000)) % 20;\r\n                    Object key = String.valueOf(keyInt);\r\n                    if (operation < 1) {\r\n                        map.size();\r\n                        stats.increment(\"size\");\r\n                    } else if (operation < 2) {\r\n                        map.get(key);\r\n                        stats.increment(\"get\");\r\n                    } else if (operation < 3) {\r\n                        map.remove(key);\r\n                        stats.increment(\"remove\");\r\n                    } else if (operation < 4) {\r\n                        map.containsKey(key);\r\n                        stats.increment(\"containsKey\");\r\n                    } else if (operation < 5) {\r\n                        Object value = String.valueOf(key);\r\n                        map.containsValue(value);\r\n                        stats.increment(\"containsValue\");\r\n                    } else if (operation < 6) {\r\n                        map.putIfAbsent(key, createValue());\r\n                        stats.increment(\"putIfAbsent\");\r\n                    } else if (operation < 7) {\r\n                        Collection col = map.values();\r\n                        for (Object o : col) {\r\n                            int i = 0;\r\n                        }\r\n                        stats.increment(\"values\");\r\n                    } else if (operation < 8) {\r\n                        Collection col = map.keySet();\r\n                        for (Object o : col) {\r\n                            int i = 0;\r\n                        }\r\n                        stats.increment(\"keySet\");\r\n                    } else if (operation < 9) {\r\n                        Collection col = map.entrySet();\r\n                        for (Object o : col) {\r\n                            int i = 0;\r\n                        }\r\n                        stats.increment(\"entrySet\");\r\n                    } else {\r\n                        map.put(key, createValue());\r\n                        stats.increment(\"put\");\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    Executors.newSingleThreadExecutor().submit(new Runnable() {\r\n        public void run() {\r\n            while (true) {\r\n                try {\r\n                    Thread.sleep(STATS_SECONDS * 1000);\r\n                    System.out.println(\"cluster size:\" + hazelcast.getCluster().getMembers().size());\r\n                    Stats currentStats = stats.getAndReset();\r\n                    System.out.println(currentStats);\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.hazelcast.map.standalone.SimpleFunctionalMapTest.main",
	"Comment": "this test runs continuously until an exception is thrown.no args",
	"Method": "void main(String[] args){\r\n    IMap map = hazelcast.getMap(\"default\");\r\n    while (true) {\r\n        int keyInt = (int) (RANDOM.nextFloat() * ENTRY_COUNT);\r\n        int operation = ((int) (RANDOM.nextFloat() * 1000)) % 20;\r\n        Object key = String.valueOf(keyInt);\r\n        if (operation < 1) {\r\n            map.size();\r\n            stats.increment(\"size\");\r\n        } else if (operation < 2) {\r\n            map.get(key);\r\n            stats.increment(\"get\");\r\n        } else if (operation < 3) {\r\n            map.remove(key);\r\n            stats.increment(\"remove\");\r\n        } else if (operation < 4) {\r\n            map.containsKey(key);\r\n            stats.increment(\"containsKey\");\r\n        } else if (operation < 5) {\r\n            Object value = String.valueOf(key);\r\n            map.containsValue(value);\r\n            stats.increment(\"containsValue\");\r\n        } else if (operation < 6) {\r\n            map.putIfAbsent(key, createValue());\r\n            stats.increment(\"putIfAbsent\");\r\n        } else if (operation < 7) {\r\n            Collection col = map.values();\r\n            for (Object o : col) {\r\n                int i = 0;\r\n            }\r\n            stats.increment(\"values\");\r\n        } else if (operation < 8) {\r\n            Collection col = map.keySet();\r\n            for (Object o : col) {\r\n                int i = 0;\r\n            }\r\n            stats.increment(\"keySet\");\r\n        } else if (operation < 9) {\r\n            Collection col = map.entrySet();\r\n            for (Object o : col) {\r\n                int i = 0;\r\n            }\r\n            stats.increment(\"entrySet\");\r\n        } else {\r\n            map.put(key, createValue());\r\n            stats.increment(\"put\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.map.standalone.SimpleFunctionalMapTest.main",
	"Comment": "this test runs continuously until an exception is thrown.no args",
	"Method": "void main(String[] args){\r\n    while (true) {\r\n        try {\r\n            Thread.sleep(STATS_SECONDS * 1000);\r\n            System.out.println(\"cluster size:\" + hazelcast.getCluster().getMembers().size());\r\n            Stats currentStats = stats.getAndReset();\r\n            System.out.println(currentStats);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.test.modulepath.SmokeModulePathTest.testCluster",
	"Comment": "verify hazelcast members are able to start and form cluster. it also verifies the client is able to join and work withthe cluster.",
	"Method": "void testCluster(){\r\n    Config config = new Config();\r\n    NetworkConfig networkConfig = config.getNetworkConfig();\r\n    networkConfig.getInterfaces().addInterface(\"127.0.0.1\");\r\n    networkConfig.getJoin().getMulticastConfig().setEnabled(false);\r\n    networkConfig.getJoin().getTcpIpConfig().setEnabled(true).addMember(\"127.0.0.1\");\r\n    HazelcastInstance hz1 = Hazelcast.newHazelcastInstance(config);\r\n    HazelcastInstance hz2 = Hazelcast.newHazelcastInstance(config);\r\n    hz1.getMap(\"test\").put(\"a\", \"b\");\r\n    assertClusterSize(2, hz1, hz2);\r\n    HazelcastInstance client = HazelcastClient.newHazelcastClient();\r\n    assertEquals(\"b\", client.getMap(\"test\").get(\"a\"));\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.Modifier.toString",
	"Comment": "return a string describing the access modifier flags inthe specified modifier.",
	"Method": "String toString(int mod){\r\n    return java.lang.reflect.Modifier.toString(mod);\r\n}"
}, {
	"Path": "com.hazelcast.quorum.impl.AbstractQuorumFunctionTest.cleanupClockOffsetTest",
	"Comment": "cleanup usage of separate classloader in test involving clock offset.",
	"Method": "void cleanupClockOffsetTest(){\r\n    if (tccl != null) {\r\n        currentThread().setContextClassLoader(tccl);\r\n    }\r\n    System.clearProperty(ClockProperties.HAZELCAST_CLOCK_OFFSET);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.CodeIterator.insertExGap",
	"Comment": "inserts an exclusive gap in front of the instruction at the givenindex pos.branch offsets and the exception table are also updated.the inserted gap is filled with nop.the gap length may beextended to a multiple of 4.if the instruction at the given index is at the beginningof a block statement,then the gap is excluded from that block.",
	"Method": "int insertExGap(int length,int insertExGap,int pos,int length){\r\n    return insertGapAt(pos, length, true).length;\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientConfig.addFlakeIdGeneratorConfig",
	"Comment": "adds a flake id generator configuration. the configuration is saved under the configname, which may be a pattern with which the configuration will beobtained in the future.",
	"Method": "ClientConfig addFlakeIdGeneratorConfig(ClientFlakeIdGeneratorConfig config){\r\n    flakeIdGeneratorConfigMap.put(config.getName(), config);\r\n    return this;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getDeclaredBehaviors",
	"Comment": "gets all the constructors and methods declared in the class.",
	"Method": "CtBehavior[] getDeclaredBehaviors(){\r\n    return new CtBehavior[0];\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientConfig.getExecutorPoolSize",
	"Comment": "pool size for internal executorservice which handles responses etc.",
	"Method": "int getExecutorPoolSize(){\r\n    return executorPoolSize;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.NewArray.where",
	"Comment": "returns the method or constructor containing the array creationrepresented by this object.",
	"Method": "CtBehavior where(){\r\n    return super.where();\r\n}"
}, {
	"Path": "com.hazelcast.test.starter.HazelcastVersionLocator.locateMemberTests",
	"Comment": "attempts to locate member tests artifact in local maven repository, then downloads",
	"Method": "File locateMemberTests(String version,File target,boolean enterprise){\r\n    File artifact = new File(LOCAL_M2_REPOSITORY_PREFIX + constructPathForMemberTests(version, enterprise));\r\n    if (artifact.exists()) {\r\n        return artifact;\r\n    } else {\r\n        return downloadMemberTests(version, target, enterprise);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.Frame.copyStack",
	"Comment": "makes a shallow copy of the stack portion of this frame. the localvariable table size will be copied, but its contents will be empty.",
	"Method": "Frame copyStack(){\r\n    Frame frame = new Frame(locals.length, stack.length);\r\n    System.arraycopy(stack, 0, frame.stack, 0, stack.length);\r\n    frame.top = top;\r\n    return frame;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.StackMap.insertLocal",
	"Comment": "updates this stack map table when a new local variable is insertedfor a new parameter.",
	"Method": "void insertLocal(int index,int tag,int classInfo){\r\n    byte[] data = new InsertLocal(this, index, tag, classInfo).doit();\r\n    this.set(data);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.stackmap.TypedBlock.initFirstBlock",
	"Comment": "initializes the first block by the given method descriptor.",
	"Method": "void initFirstBlock(int maxStack,int maxLocals,String className,String methodDesc,boolean isStatic,boolean isConstructor){\r\n    if (methodDesc.charAt(0) != '(')\r\n        throw new BadBytecode(\"no method descriptor: \" + methodDesc);\r\n    stackTop = 0;\r\n    stackTypes = TypeData.make(maxStack);\r\n    TypeData[] locals = TypeData.make(maxLocals);\r\n    if (isConstructor)\r\n        locals[0] = new TypeData.UninitThis(className);\r\n    else if (!isStatic)\r\n        locals[0] = new TypeData.ClassName(className);\r\n    int n = isStatic ? -1 : 0;\r\n    int i = 1;\r\n    try {\r\n        while ((i = descToTag(methodDesc, i, ++n, locals)) > 0) if (locals[n].is2WordType())\r\n            locals[++n] = TypeTag.TOP;\r\n    } catch (StringIndexOutOfBoundsException e) {\r\n        throw new BadBytecode(\"bad method descriptor: \" + methodDesc);\r\n    }\r\n    numLocals = n;\r\n    localsTypes = locals;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.AccessFlag.setPrivate",
	"Comment": "truns the private bit on.the protected and private bits arecleared.",
	"Method": "int setPrivate(int accflags){\r\n    return (accflags & ~(PROTECTED | PUBLIC)) | PRIVATE;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.InstructionPrinter.instructionString",
	"Comment": "gets a string representation of the bytecode instruction at the specifiedposition.",
	"Method": "String instructionString(CodeIterator iter,int pos,ConstPool pool){\r\n    int opcode = iter.byteAt(pos);\r\n    if (opcode > opcodes.length || opcode < 0)\r\n        throw new IllegalArgumentException(\"Invalid opcode, opcode: \" + opcode + \" pos: \" + pos);\r\n    String opstring = opcodes[opcode];\r\n    switch(opcode) {\r\n        case BIPUSH:\r\n            return opstring + \" \" + iter.byteAt(pos + 1);\r\n        case SIPUSH:\r\n            return opstring + \" \" + iter.s16bitAt(pos + 1);\r\n        case LDC:\r\n            return opstring + \" \" + ldc(pool, iter.byteAt(pos + 1));\r\n        case LDC_W:\r\n        case LDC2_W:\r\n            return opstring + \" \" + ldc(pool, iter.u16bitAt(pos + 1));\r\n        case ILOAD:\r\n        case LLOAD:\r\n        case FLOAD:\r\n        case DLOAD:\r\n        case ALOAD:\r\n        case ISTORE:\r\n        case LSTORE:\r\n        case FSTORE:\r\n        case DSTORE:\r\n        case ASTORE:\r\n            return opstring + \" \" + iter.byteAt(pos + 1);\r\n        case IFEQ:\r\n        case IFGE:\r\n        case IFGT:\r\n        case IFLE:\r\n        case IFLT:\r\n        case IFNE:\r\n        case IFNONNULL:\r\n        case IFNULL:\r\n        case IF_ACMPEQ:\r\n        case IF_ACMPNE:\r\n        case IF_ICMPEQ:\r\n        case IF_ICMPGE:\r\n        case IF_ICMPGT:\r\n        case IF_ICMPLE:\r\n        case IF_ICMPLT:\r\n        case IF_ICMPNE:\r\n            return opstring + \" \" + (iter.s16bitAt(pos + 1) + pos);\r\n        case IINC:\r\n            return opstring + \" \" + iter.byteAt(pos + 1) + \", \" + iter.signedByteAt(pos + 2);\r\n        case GOTO:\r\n        case JSR:\r\n            return opstring + \" \" + (iter.s16bitAt(pos + 1) + pos);\r\n        case RET:\r\n            return opstring + \" \" + iter.byteAt(pos + 1);\r\n        case TABLESWITCH:\r\n            return tableSwitch(iter, pos);\r\n        case LOOKUPSWITCH:\r\n            return lookupSwitch(iter, pos);\r\n        case GETSTATIC:\r\n        case PUTSTATIC:\r\n        case GETFIELD:\r\n        case PUTFIELD:\r\n            return opstring + \" \" + fieldInfo(pool, iter.u16bitAt(pos + 1));\r\n        case INVOKEVIRTUAL:\r\n        case INVOKESPECIAL:\r\n        case INVOKESTATIC:\r\n            return opstring + \" \" + methodInfo(pool, iter.u16bitAt(pos + 1));\r\n        case INVOKEINTERFACE:\r\n            return opstring + \" \" + interfaceMethodInfo(pool, iter.u16bitAt(pos + 1));\r\n        case INVOKEDYNAMIC:\r\n            return opstring + \" \" + iter.u16bitAt(pos + 1);\r\n        case NEW:\r\n            return opstring + \" \" + classInfo(pool, iter.u16bitAt(pos + 1));\r\n        case NEWARRAY:\r\n            return opstring + \" \" + arrayInfo(iter.byteAt(pos + 1));\r\n        case ANEWARRAY:\r\n        case CHECKCAST:\r\n            return opstring + \" \" + classInfo(pool, iter.u16bitAt(pos + 1));\r\n        case WIDE:\r\n            return wide(iter, pos);\r\n        case MULTIANEWARRAY:\r\n            return opstring + \" \" + classInfo(pool, iter.u16bitAt(pos + 1));\r\n        case GOTO_W:\r\n        case JSR_W:\r\n            return opstring + \" \" + (iter.s32bitAt(pos + 1) + pos);\r\n        default:\r\n            return opstring;\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ClassFile.addInterface",
	"Comment": "appends an interface to the interfaces implemented by the class.",
	"Method": "void addInterface(String name){\r\n    cachedInterfaces = null;\r\n    int info = constPool.addClassInfo(name);\r\n    if (interfaces == null) {\r\n        interfaces = new int[1];\r\n        interfaces[0] = info;\r\n    } else {\r\n        int n = interfaces.length;\r\n        int[] newarray = new int[n + 1];\r\n        System.arraycopy(interfaces, 0, newarray, 0, n);\r\n        newarray[n] = info;\r\n        interfaces = newarray;\r\n    }\r\n}"
}, {
	"Path": "com.hazelcast.test.TestThread.assertSucceedsEventually",
	"Comment": "assert that the thread eventually completes without an error.",
	"Method": "void assertSucceedsEventually(){\r\n    assertTerminates();\r\n    assertNull(\"No error should have been thrown, but \" + getName() + \" completed error\", error);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.stackmap.Tracer.constructorCalled",
	"Comment": "this is a constructor call on an uninitialized object.sets flags of other references to that object.",
	"Method": "void constructorCalled(TypeData target,int offset){\r\n    target.constructorCalled(offset);\r\n    for (int i = 0; i < stackTop; i++) stackTypes[i].constructorCalled(offset);\r\n    for (int i = 0; i < localsTypes.length; i++) localsTypes[i].constructorCalled(offset);\r\n}"
}, {
	"Path": "com.hazelcast.test.starter.HazelcastVersionLocator.locateClient",
	"Comment": "first attempt to locate artifact in local maven repository, then download",
	"Method": "File locateClient(String version,File target,boolean enterprise){\r\n    File artifact = new File(LOCAL_M2_REPOSITORY_PREFIX + constructPathForClient(version, enterprise));\r\n    if (artifact.exists()) {\r\n        return artifact;\r\n    } else {\r\n        return downloadClient(version, target, enterprise);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.CodeIterator.setMark",
	"Comment": "sets a mark to the bytecode at the given index.the mark can be used to track the position of that bytecodewhen code blocks are inserted.if a code block is inclusively inserted at the position of thebytecode, the mark is set to the inserted code block.",
	"Method": "void setMark(int index){\r\n    mark = index;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtMember.hasAnnotation",
	"Comment": "returns true if the class has the specified annotation type.",
	"Method": "boolean hasAnnotation(String clz,boolean hasAnnotation,Class<?> clz,boolean hasAnnotation,String annotationTypeName){\r\n    return hasAnnotation(clz.getName());\r\n}"
}, {
	"Path": "com.hazelcast.client.cache.impl.HazelcastClientCachingProvider.createCachingProvider",
	"Comment": "helper method for creating caching provider for testing etc.",
	"Method": "HazelcastClientCachingProvider createCachingProvider(HazelcastInstance hazelcastInstance){\r\n    HazelcastClientCachingProvider cachingProvider = new HazelcastClientCachingProvider();\r\n    cachingProvider.hazelcastInstance = hazelcastInstance;\r\n    return cachingProvider;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.Modifier.isVolatile",
	"Comment": "returns true if the modifiers include the volatilemodifier.",
	"Method": "boolean isVolatile(int mod){\r\n    return (mod & VOLATILE) != 0;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.compiler.TypeChecker.getConstantFieldValue",
	"Comment": "if mem is a static final field, this method returns a constantexpression representing the value of that field.",
	"Method": "ASTree getConstantFieldValue(Member mem,ASTree getConstantFieldValue,CtField f){\r\n    if (f == null)\r\n        return null;\r\n    Object value = f.getConstantValue();\r\n    if (value == null)\r\n        return null;\r\n    if (value instanceof String)\r\n        return new StringL((String) value);\r\n    else if (value instanceof Double || value instanceof Float) {\r\n        int token = (value instanceof Double) ? DoubleConstant : FloatConstant;\r\n        return new DoubleConst(((Number) value).doubleValue(), token);\r\n    } else if (value instanceof Number) {\r\n        int token = (value instanceof Long) ? LongConstant : IntConstant;\r\n        return new IntConst(((Number) value).longValue(), token);\r\n    } else if (value instanceof Boolean)\r\n        return new Keyword(((Boolean) value).booleanValue() ? TokenId.TRUE : TokenId.FALSE);\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "com.hazelcast.test.starter.constructor.AbstractConfigConstructor.cloneStoreInstance",
	"Comment": "creates a proxy class for a store implementation from the currentclassloader for the proxied classloader.",
	"Method": "void cloneStoreInstance(ClassLoader classloader,Method method,Method setter,Object thisConfigObject,Object otherConfigObject,String targetStoreClass){\r\n    Object thisStoreObject = method.invoke(thisConfigObject);\r\n    if (thisStoreObject == null) {\r\n        return;\r\n    }\r\n    Class<?> thisStoreClass = thisStoreObject.getClass();\r\n    if (isProxyClass(thisStoreClass) || classloader.equals(thisStoreClass.getClassLoader())) {\r\n        updateConfig(setter, otherConfigObject, thisStoreObject);\r\n    } else {\r\n        Class<?> otherStoreClass = classloader.loadClass(targetStoreClass);\r\n        Object otherStoreObject = generateProxyForInterface(thisStoreObject, classloader, otherStoreClass);\r\n        updateConfig(setter, otherConfigObject, otherStoreObject);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.Modifier.setPrivate",
	"Comment": "truns the private bit on.the protected and private bits arecleared.",
	"Method": "int setPrivate(int mod){\r\n    return (mod & ~(PROTECTED | PUBLIC)) | PRIVATE;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.MethodCall.getCtClass",
	"Comment": "returns the class of the target object,which the method is called on.",
	"Method": "CtClass getCtClass(){\r\n    return thisClass.getClassPool().get(getClassName());\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.AccessFlag.setProtected",
	"Comment": "turns the protected bit on.the protected and public bits arecleared.",
	"Method": "int setProtected(int accflags){\r\n    return (accflags & ~(PRIVATE | PUBLIC)) | PROTECTED;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.ClassPool.compress",
	"Comment": "this method is periodically invoked so that memoryfootprint will be minimized.",
	"Method": "void compress(){\r\n    if (compressCount++ > COMPRESS_THRESHOLD) {\r\n        compressCount = 0;\r\n        Enumeration e = classes.elements();\r\n        while (e.hasMoreElements()) ((CtClass) e.nextElement()).compress();\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getDeclaredConstructor",
	"Comment": "returns a constructor receiving the specified parameters.",
	"Method": "CtConstructor getDeclaredConstructor(CtClass[] params){\r\n    String desc = Descriptor.ofConstructor(params);\r\n    return getConstructor(desc);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getDeclaringClass",
	"Comment": "if this class is a member class or interface of another class,then the class enclosing this class is returned.",
	"Method": "CtClass getDeclaringClass(){\r\n    return null;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ClassFile.write",
	"Comment": "writes a class file represented by this object into an output stream.",
	"Method": "void write(DataOutputStream out){\r\n    int i, n;\r\n    out.writeInt(0xCAFEBABE);\r\n    out.writeShort(minor);\r\n    out.writeShort(major);\r\n    constPool.write(out);\r\n    out.writeShort(accessFlags);\r\n    out.writeShort(thisClass);\r\n    out.writeShort(superClass);\r\n    if (interfaces == null)\r\n        n = 0;\r\n    else\r\n        n = interfaces.length;\r\n    out.writeShort(n);\r\n    for (i = 0; i < n; ++i) out.writeShort(interfaces[i]);\r\n    n = fields.size();\r\n    out.writeShort(n);\r\n    for (i = 0; i < n; ++i) {\r\n        FieldInfo finfo = fields.get(i);\r\n        finfo.write(out);\r\n    }\r\n    out.writeShort(methods.size());\r\n    for (MethodInfo minfo : methods) minfo.write(out);\r\n    out.writeShort(attributes.size());\r\n    AttributeInfo.writeAll(attributes, out);\r\n}"
}, {
	"Path": "com.hazelcast.client.ringbuffer.RingbufferTest.readManyAsync_withFilter_andMaxCount",
	"Comment": "so if more results are available than needed, the surplus results should not be read.",
	"Method": "void readManyAsync_withFilter_andMaxCount(){\r\n    serverRingbuffer.add(\"good1\");\r\n    serverRingbuffer.add(\"bad1\");\r\n    serverRingbuffer.add(\"good2\");\r\n    serverRingbuffer.add(\"bad2\");\r\n    serverRingbuffer.add(\"good3\");\r\n    serverRingbuffer.add(\"bad3\");\r\n    serverRingbuffer.add(\"good4\");\r\n    serverRingbuffer.add(\"bad4\");\r\n    ICompletableFuture<ReadResultSet<String>> f = clientRingbuffer.readManyAsync(0, 3, 3, new Filter());\r\n    ReadResultSet rs = f.get();\r\n    assertInstanceOf(PortableReadResultSet.class, rs);\r\n    assertEquals(5, rs.readCount());\r\n    assertEquals(\"good1\", rs.get(0));\r\n    assertEquals(\"good2\", rs.get(1));\r\n    assertEquals(\"good3\", rs.get(2));\r\n}"
}, {
	"Path": "org.hotswap.agent.annotation.handler.InitHandler.initMethod",
	"Comment": "if static, just register callback, otherwise the method is immediately invoked.",
	"Method": "boolean initMethod(PluginAnnotation pluginAnnotation){\r\n    Object plugin = pluginAnnotation.getPlugin();\r\n    if (plugin == null) {\r\n        if (Modifier.isStatic(pluginAnnotation.getMethod().getModifiers()))\r\n            return registerClassLoaderInit(pluginAnnotation);\r\n        else\r\n            return true;\r\n    } else {\r\n        if (!Modifier.isStatic(pluginAnnotation.getMethod().getModifiers())) {\r\n            ClassLoader appClassLoader = pluginManager.getPluginRegistry().getAppClassLoader(plugin);\r\n            return invokeInitMethod(pluginAnnotation, plugin, appClassLoader);\r\n        } else\r\n            return true;\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.subtypeOf",
	"Comment": "returns true if this class extends or implementsclazz.it also returns true ifthis class is the same as clazz.",
	"Method": "boolean subtypeOf(CtClass clazz){\r\n    return this == clazz || getName().equals(clazz.getName());\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtPrimitiveType.getReturnOp",
	"Comment": "returns the opcode for returning a value of the type.for example, if the type is int, then the returned opcode isjavassit.bytecode.opcode.ireturn.",
	"Method": "int getReturnOp(){\r\n    return returnOp;\r\n}"
}, {
	"Path": "com.hazelcast.test.starter.HazelcastAPIDelegatingClassloader.shouldDelegate",
	"Comment": "delegate to parent if class is not under com.hazelcast package or if class is proxyinvocationhandler itself.",
	"Method": "boolean shouldDelegate(String name){\r\n    if (name.startsWith(\"usercodedeployment\")) {\r\n        return false;\r\n    }\r\n    if (!name.startsWith(\"com.hazelcast\")) {\r\n        return true;\r\n    }\r\n    return DELEGATION_WHITE_LIST.contains(name);\r\n}"
}, {
	"Path": "com.hazelcast.spi.impl.operationservice.impl.Invocation_BlockingTest.sync_whenGetTimeout",
	"Comment": "checks if a get with a timeout is called, and the timeout expires, that we get a timeoutexception.",
	"Method": "void sync_whenGetTimeout(){\r\n    Config config = new Config();\r\n    TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\r\n    HazelcastInstance local = factory.newHazelcastInstance(config);\r\n    HazelcastInstance remote = factory.newHazelcastInstance(config);\r\n    warmUpPartitions(factory.getAllHazelcastInstances());\r\n    NodeEngineImpl nodeEngine = getNodeEngineImpl(local);\r\n    String key = generateKeyOwnedBy(remote);\r\n    int partitionId = nodeEngine.getPartitionService().getPartitionId(key);\r\n    InternalOperationService opService = nodeEngine.getOperationService();\r\n    opService.invokeOnPartition(null, new SlowOperation(SECONDS.toMillis(5)), partitionId);\r\n    LockOperation op = new LockOperation(new InternalLockNamespace(key), nodeEngine.toData(key), 1, -1, -1);\r\n    InternalCompletableFuture<Object> future = opService.createInvocationBuilder(null, op, partitionId).invoke();\r\n    try {\r\n        future.get(1, SECONDS);\r\n        fail();\r\n    } catch (TimeoutException expected) {\r\n        ignore(expected);\r\n    }\r\n    Object result = future.get(60, SECONDS);\r\n    assertEquals(Boolean.TRUE, result);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CannotCompileException.getCause",
	"Comment": "gets the cause of this throwable.it is for jdk 1.3 compatibility.",
	"Method": "Throwable getCause(){\r\n    return (myCause == this ? null : myCause);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.CodeIterator.insertGap",
	"Comment": "inserts a gap in front of the instruction at the givenindex pos.branch offsets and the exception table are also updated.the inserted gap is filled with nop.the gap length may beextended to a multiple of 4.if the instruction at the given index is at the beginningof a block statement,then the gap is inserted within that block.",
	"Method": "int insertGap(int length,int insertGap,int pos,int length){\r\n    return insertGapAt(pos, length, false).length;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.NestMembersAttribute.copy",
	"Comment": "makes a copy.class names are replaced according to thegiven map object.",
	"Method": "AttributeInfo copy(ConstPool newCp,Map<String, String> classnames){\r\n    byte[] src = get();\r\n    byte[] dest = new byte[src.length];\r\n    ConstPool cp = getConstPool();\r\n    int n = ByteArray.readU16bit(src, 0);\r\n    ByteArray.write16bit(n, dest, 0);\r\n    for (int i = 0, j = 2; i < n; ++i, j += 2) {\r\n        int index = ByteArray.readU16bit(src, j);\r\n        int newIndex = cp.copy(index, newCp, classnames);\r\n        ByteArray.write16bit(newIndex, dest, j);\r\n    }\r\n    return new NestMembersAttribute(newCp, dest);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.MethodInfo.getAttributes",
	"Comment": "returns all the attributes.the returned list objectis shared with this object.if you add a new attribute to the list,the attribute is also added to the method represented by thisobject.if you remove an attribute from the list, it is also removedfrom the method.",
	"Method": "List<AttributeInfo> getAttributes(){\r\n    if (attribute == null)\r\n        attribute = new ArrayList<AttributeInfo>();\r\n    return attribute;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtMethod.equals",
	"Comment": "indicates whether obj has the same name and thesame signature as this method.",
	"Method": "boolean equals(Object obj){\r\n    return obj != null && obj instanceof CtMethod && ((CtMethod) obj).getStringRep().equals(getStringRep());\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientConfig.setClassLoader",
	"Comment": "sets the classloader which is used by serialization and listener configuration",
	"Method": "ClientConfig setClassLoader(ClassLoader classLoader){\r\n    this.classLoader = classLoader;\r\n    return this;\r\n}"
}, {
	"Path": "com.hazelcast.test.starter.HazelcastProxyFactory.generateProxyForInterface",
	"Comment": "generates a jdk dynamic proxy implementing the expected interfaces.",
	"Method": "T generateProxyForInterface(Object delegate,ClassLoader proxyTargetClassloader,Class<?> expectedInterfaces){\r\n    InvocationHandler myInvocationHandler = new ProxyInvocationHandler(delegate);\r\n    return (T) Proxy.newProxyInstance(proxyTargetClassloader, expectedInterfaces, myInvocationHandler);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.ClassPool.getContextClassLoader",
	"Comment": "obtains a class loader that seems appropriate to look up a classby name.",
	"Method": "ClassLoader getContextClassLoader(){\r\n    return Thread.currentThread().getContextClassLoader();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.StackMapTable.insertLocal",
	"Comment": "updates this stack map table when a new local variable is insertedfor a new parameter.",
	"Method": "void insertLocal(int index,int tag,int classInfo){\r\n    byte[] data = new InsertLocal(this.get(), index, tag, classInfo).doit();\r\n    this.set(data);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.isEnum",
	"Comment": "determines whether this object represents an enum.it returns true if this object represents an enum.",
	"Method": "boolean isEnum(){\r\n    return false;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ClassFile.addField2",
	"Comment": "just appends a field to the class.it does not check field duplication.use this method only when minimizing performance overheadsis seriously required.",
	"Method": "void addField2(FieldInfo finfo){\r\n    fields.add(finfo);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.ClassPool.removeClassPath",
	"Comment": "detatches the classpath object from the search path.the detached classpath object cannot be addedto the path again.",
	"Method": "void removeClassPath(ClassPath cp){\r\n    source.removeClassPath(cp);\r\n}"
}, {
	"Path": "com.hazelcast.query.impl.IndexesTest.shouldNotThrowException_withNullValues_whenIndexAddedForValueField",
	"Comment": "imagine we have only keys and nullable values. and we add index for a field of that nullable object.when we execute a query on keys, there should be no returned value from indexing service and it does notthrow exception.",
	"Method": "void shouldNotThrowException_withNullValues_whenIndexAddedForValueField(){\r\n    Indexes indexes = Indexes.newBuilder(serializationService, copyBehavior).build();\r\n    indexes.addOrGetIndex(\"name\", false);\r\n    shouldReturnNull_whenQueryingOnKeys(indexes);\r\n}"
}, {
	"Path": "org.hotswap.agent.config.PluginConfiguration.getWatchResources",
	"Comment": "converts watchresources property to url array. invalid urls will be skipped and logged as error.",
	"Method": "URL[] getWatchResources(){\r\n    return convertToURL(getProperty(\"watchResources\"));\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientNetworkConfig.getConnectionTimeout",
	"Comment": "timeout value in millis for nodes to accept client connection requests.",
	"Method": "int getConnectionTimeout(){\r\n    return connectionTimeout;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.stackmap.TypedBlock.makeBlocks",
	"Comment": "divides the method body into basic blocks.the type information of the first block is initialized.",
	"Method": "TypedBlock[] makeBlocks(MethodInfo minfo,CodeAttribute ca,boolean optimize){\r\n    TypedBlock[] blocks = (TypedBlock[]) new Maker().make(minfo);\r\n    if (optimize && blocks.length < 2)\r\n        if (blocks.length == 0 || blocks[0].incoming == 0)\r\n            return null;\r\n    ConstPool pool = minfo.getConstPool();\r\n    boolean isStatic = (minfo.getAccessFlags() & AccessFlag.STATIC) != 0;\r\n    blocks[0].initFirstBlock(ca.getMaxStack(), ca.getMaxLocals(), pool.getClassName(), minfo.getDescriptor(), isStatic, minfo.isConstructor());\r\n    return blocks;\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientNetworkConfig.setEurekaConfig",
	"Comment": "sets configuration to connect nodes in eureka environment.",
	"Method": "ClientNetworkConfig setEurekaConfig(EurekaConfig eurekaConfig){\r\n    this.eurekaConfig = eurekaConfig;\r\n    return this;\r\n}"
}, {
	"Path": "org.hotswap.agent.config.PluginRegistry.getAppClassLoader",
	"Comment": "search for the plugin in the registry and return associated classloader.",
	"Method": "ClassLoader getAppClassLoader(Object plugin){\r\n    Class<Object> clazz = getPluginClass(plugin.getClass().getName());\r\n    Map<ClassLoader, Object> pluginInstances = registeredPlugins.get(clazz);\r\n    if (pluginInstances != null) {\r\n        synchronized (pluginInstances) {\r\n            for (Map.Entry<ClassLoader, Object> entry : pluginInstances.entrySet()) {\r\n                if (entry.getValue().equals(plugin))\r\n                    return entry.getKey();\r\n            }\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"Plugin not found in the registry \" + plugin);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ConstPool.getTag",
	"Comment": "returns the tag field of the constant pool tableentry at the given index.",
	"Method": "int getTag(int index,int getTag,int getTag,int getTag,int getTag,int getTag,int getTag,int getTag,int getTag,int getTag,int getTag,int getTag,int getTag,int getTag,int getTag,int getTag,int getTag,int getTag,int getTag){\r\n    return getItem(index).getTag();\r\n}"
}, {
	"Path": "com.hazelcast.test.SplitBrainTestSupport.shouldAssertAllNodesRejoined",
	"Comment": "indicates whether test should fail when cluster does not include all original members after communications are unblocked.override this method when it is expected that after communications are unblocked some members will not rejoin the cluster.when overriding this method, it may be desirable to add some wait time to allow the split brain handler to execute.",
	"Method": "boolean shouldAssertAllNodesRejoined(){\r\n    return true;\r\n}"
}, {
	"Path": "com.hazelcast.client.proxy.txn.ClientTransactionUtil.invoke",
	"Comment": "handles the invocation exception for transactions so that users will not see internal exceptions.more specifically ioexception, because in case of a io problem in clientinvocation that send to a connectionsends ioexception to user. this wraps that exception into a transactionexception.",
	"Method": "ClientMessage invoke(ClientMessage request,String objectName,HazelcastClientInstanceImpl client,Connection connection){\r\n    try {\r\n        final ClientInvocation clientInvocation = new ClientInvocation(client, request, objectName, connection);\r\n        final Future<ClientMessage> future = clientInvocation.invoke();\r\n        return future.get();\r\n    } catch (Exception e) {\r\n        throw rethrow(e, TRANSACTION_EXCEPTION_FACTORY);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.SourceFileAttribute.copy",
	"Comment": "makes a copy.class names are replaced according to thegiven map object.",
	"Method": "AttributeInfo copy(ConstPool newCp,Map<String, String> classnames){\r\n    return new SourceFileAttribute(newCp, getFileName());\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.SerialVersionUID.setSerialVersionUID",
	"Comment": "adds serialversionuid if one does not already exist. call this beforemodifying a class to maintain serialization compatability.",
	"Method": "void setSerialVersionUID(CtClass clazz){\r\n    try {\r\n        clazz.getDeclaredField(\"serialVersionUID\");\r\n        return;\r\n    } catch (NotFoundException e) {\r\n    }\r\n    if (!isSerializable(clazz))\r\n        return;\r\n    CtField field = new CtField(CtClass.longType, \"serialVersionUID\", clazz);\r\n    field.setModifiers(Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL);\r\n    clazz.addField(field, calculateDefault(clazz) + \"L\");\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtMethod.setBody",
	"Comment": "copies a method body from another method.if this method is abstract, the abstract modifier is removedafter the method body is copied.all occurrences of the class names in the copied method bodyare replaced with the names specified bymap if map is not null.",
	"Method": "void setBody(CtMethod src,ClassMap map){\r\n    setBody0(src.declaringClass, src.methodInfo, declaringClass, methodInfo, map);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.SignatureAttribute.copy",
	"Comment": "makes a copy.class names are replaced according to thegiven map object.",
	"Method": "AttributeInfo copy(ConstPool newCp,Map<String, String> classnames){\r\n    return new SignatureAttribute(newCp, getSignature());\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.Frame.merge",
	"Comment": "merges all types on the stack and local variable table of this frame with that of the specifiedtype.",
	"Method": "boolean merge(Frame frame){\r\n    boolean changed = false;\r\n    for (int i = 0; i < locals.length; i++) {\r\n        if (locals[i] != null) {\r\n            Type prev = locals[i];\r\n            Type merged = prev.merge(frame.locals[i]);\r\n            locals[i] = merged;\r\n            if (!merged.equals(prev) || merged.popChanged()) {\r\n                changed = true;\r\n            }\r\n        } else if (frame.locals[i] != null) {\r\n            locals[i] = frame.locals[i];\r\n            changed = true;\r\n        }\r\n    }\r\n    changed |= mergeStack(frame);\r\n    return changed;\r\n}"
}, {
	"Path": "com.hazelcast.test.HazelcastTestSupport.generateKeyOwnedBy",
	"Comment": "generates a key according to given reference instance by checking partition ownership for it.",
	"Method": "String generateKeyOwnedBy(HazelcastInstance instance,String generateKeyOwnedBy,HazelcastInstance instance,boolean generateOwnedKey){\r\n    Cluster cluster = instance.getCluster();\r\n    checkMemberCount(generateOwnedKey, cluster);\r\n    checkPartitionCountGreaterOrEqualMemberCount(instance);\r\n    Member localMember = cluster.getLocalMember();\r\n    PartitionService partitionService = instance.getPartitionService();\r\n    while (true) {\r\n        String id = randomString();\r\n        Partition partition = partitionService.getPartition(id);\r\n        if (comparePartitionOwnership(generateOwnedKey, localMember, partition)) {\r\n            return id;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.ParameterAnnotationsAttribute.setAnnotations",
	"Comment": "changes the annotations represented by this object according tothe given array of annotation objects.",
	"Method": "void setAnnotations(Annotation[][] params){\r\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\r\n    AnnotationsWriter writer = new AnnotationsWriter(output, constPool);\r\n    try {\r\n        writer.numParameters(params.length);\r\n        for (Annotation[] anno : params) {\r\n            writer.numAnnotations(anno.length);\r\n            for (int j = 0; j < anno.length; ++j) anno[j].write(writer);\r\n        }\r\n        writer.close();\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    set(output.toByteArray());\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.Modifier.isStrict",
	"Comment": "returns true if the modifiers include the strictfpmodifier.",
	"Method": "boolean isStrict(int mod){\r\n    return (mod & STRICT) != 0;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.Frame.localsLength",
	"Comment": "returns the number of local variable table entries, specifiedat construction.",
	"Method": "int localsLength(){\r\n    return locals.length;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getGenericSignature",
	"Comment": "returns the generic signature of the class.the generics of java is implemented by the erasure technique.after compilation, all type parameters are dropped off from themain part of a class file.however, for reflection, the typeparameters are encoded into generic signatures and attachedto a class file.",
	"Method": "String getGenericSignature(){\r\n    return null;\r\n}"
}, {
	"Path": "com.hazelcast.nio.serialization.impl.DefaultPortableReaderSpecTest.list",
	"Comment": "unwraps input objects if they are arrays or lists and adds all to an output list.",
	"Method": "List<T> list(T objects){\r\n    List<T> result = new ArrayList<T>();\r\n    for (T object : objects) {\r\n        if (object == null) {\r\n            result.add(object);\r\n        } else if (object.getClass().isArray()) {\r\n            int length = Array.getLength(object);\r\n            for (int i = 0; i < length; i++) {\r\n                result.add((T) Array.get(object, i));\r\n            }\r\n        } else if (object instanceof Collection) {\r\n            result.addAll((Collection<T>) object);\r\n        } else {\r\n            result.add(object);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.isFrozen",
	"Comment": "returns true if the class has been loaded or written outand thus it cannot be modified any more.",
	"Method": "boolean isFrozen(){\r\n    return true;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.ClassMap.get",
	"Comment": "returns the class name to wihch the given jvmclassnameis mapped.a subclass of this class should override this method.this method receives and returns the internal representation ofclass name used in the jvm.",
	"Method": "String get(Object jvmClassName){\r\n    String found = super.get(jvmClassName);\r\n    if (found == null && parent != null)\r\n        return parent.get(jvmClassName);\r\n    return found;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.expr.NewExpr.where",
	"Comment": "returns the method or constructor containing the newexpression represented by this object.",
	"Method": "CtBehavior where(){\r\n    return super.where();\r\n}"
}, {
	"Path": "com.hazelcast.test.TestAwareInstanceFactory.terminateAll",
	"Comment": "terminates all member instances created by this factory for current test method name.",
	"Method": "void terminateAll(){\r\n    shutdownInstances(perMethodMembers.remove(getTestMethodName()));\r\n}"
}, {
	"Path": "com.hazelcast.spring.cache.HazelcastCacheManager.setDefaultReadTimeout",
	"Comment": "set default cache value retrieval timeout. applies to all caches, if not defined a cache specific timeout.",
	"Method": "void setDefaultReadTimeout(long defaultReadTimeout){\r\n    this.defaultReadTimeout = defaultReadTimeout;\r\n}"
}, {
	"Path": "org.hotswap.agent.config.PluginConfiguration.containsPropertyFile",
	"Comment": "does this classloader contain the property file directly, or is it acquired through parent classloader.",
	"Method": "boolean containsPropertyFile(){\r\n    return containsPropertyFileDirectly;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.scopedpool.SoftValueHashMap.remove",
	"Comment": "removes the mapping for the given key from this map, ifpresent.",
	"Method": "V remove(Object key){\r\n    processQueue();\r\n    return valueOrNull(hash.remove(key));\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.Descriptor.changeReturnType",
	"Comment": "changes the return type included in the given descriptor.classname must not be an array type.",
	"Method": "String changeReturnType(String classname,String desc){\r\n    int i = desc.indexOf(')');\r\n    if (i < 0)\r\n        return desc;\r\n    StringBuffer newdesc = new StringBuffer();\r\n    newdesc.append(desc.substring(0, i + 1));\r\n    newdesc.append('L');\r\n    newdesc.append(classname.replace('.', '/'));\r\n    newdesc.append(';');\r\n    return newdesc.toString();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.InnerClassesAttribute.copy",
	"Comment": "makes a copy.class names are replaced according to thegiven map object.",
	"Method": "AttributeInfo copy(ConstPool newCp,Map<String, String> classnames){\r\n    byte[] src = get();\r\n    byte[] dest = new byte[src.length];\r\n    ConstPool cp = getConstPool();\r\n    InnerClassesAttribute attr = new InnerClassesAttribute(newCp, dest);\r\n    int n = ByteArray.readU16bit(src, 0);\r\n    ByteArray.write16bit(n, dest, 0);\r\n    int j = 2;\r\n    for (int i = 0; i < n; ++i) {\r\n        int innerClass = ByteArray.readU16bit(src, j);\r\n        int outerClass = ByteArray.readU16bit(src, j + 2);\r\n        int innerName = ByteArray.readU16bit(src, j + 4);\r\n        int innerAccess = ByteArray.readU16bit(src, j + 6);\r\n        if (innerClass != 0)\r\n            innerClass = cp.copy(innerClass, newCp, classnames);\r\n        ByteArray.write16bit(innerClass, dest, j);\r\n        if (outerClass != 0)\r\n            outerClass = cp.copy(outerClass, newCp, classnames);\r\n        ByteArray.write16bit(outerClass, dest, j + 2);\r\n        if (innerName != 0)\r\n            innerName = cp.copy(innerName, newCp, classnames);\r\n        ByteArray.write16bit(innerName, dest, j + 4);\r\n        ByteArray.write16bit(innerAccess, dest, j + 6);\r\n        j += 8;\r\n    }\r\n    return attr;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.SerialVersionUID.calculateDefault",
	"Comment": "calculate default value. see java serialization specification, streamunique identifiers.",
	"Method": "long calculateDefault(CtClass clazz){\r\n    try {\r\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\r\n        DataOutputStream out = new DataOutputStream(bout);\r\n        ClassFile classFile = clazz.getClassFile();\r\n        String javaName = javaName(clazz);\r\n        out.writeUTF(javaName);\r\n        CtMethod[] methods = clazz.getDeclaredMethods();\r\n        int classMods = clazz.getModifiers();\r\n        if ((classMods & Modifier.INTERFACE) != 0)\r\n            if (methods.length > 0)\r\n                classMods = classMods | Modifier.ABSTRACT;\r\n            else\r\n                classMods = classMods & ~Modifier.ABSTRACT;\r\n        out.writeInt(classMods);\r\n        String[] interfaces = classFile.getInterfaces();\r\n        for (int i = 0; i < interfaces.length; i++) interfaces[i] = javaName(interfaces[i]);\r\n        Arrays.sort(interfaces);\r\n        for (int i = 0; i < interfaces.length; i++) out.writeUTF(interfaces[i]);\r\n        CtField[] fields = clazz.getDeclaredFields();\r\n        Arrays.sort(fields, new Comparator<CtField>() {\r\n            @Override\r\n            public int compare(CtField field1, CtField field2) {\r\n                return field1.getName().compareTo(field2.getName());\r\n            }\r\n        });\r\n        for (int i = 0; i < fields.length; i++) {\r\n            CtField field = fields[i];\r\n            int mods = field.getModifiers();\r\n            if (((mods & Modifier.PRIVATE) == 0) || ((mods & (Modifier.STATIC | Modifier.TRANSIENT)) == 0)) {\r\n                out.writeUTF(field.getName());\r\n                out.writeInt(mods);\r\n                out.writeUTF(field.getFieldInfo2().getDescriptor());\r\n            }\r\n        }\r\n        if (classFile.getStaticInitializer() != null) {\r\n            out.writeUTF(\"<clinit>\");\r\n            out.writeInt(Modifier.STATIC);\r\n            out.writeUTF(\"()V\");\r\n        }\r\n        CtConstructor[] constructors = clazz.getDeclaredConstructors();\r\n        Arrays.sort(constructors, new Comparator<CtConstructor>() {\r\n            @Override\r\n            public int compare(CtConstructor c1, CtConstructor c2) {\r\n                return c1.getMethodInfo2().getDescriptor().compareTo(c2.getMethodInfo2().getDescriptor());\r\n            }\r\n        });\r\n        for (int i = 0; i < constructors.length; i++) {\r\n            CtConstructor constructor = constructors[i];\r\n            int mods = constructor.getModifiers();\r\n            if ((mods & Modifier.PRIVATE) == 0) {\r\n                out.writeUTF(\"<init>\");\r\n                out.writeInt(mods);\r\n                out.writeUTF(constructor.getMethodInfo2().getDescriptor().replace('/', '.'));\r\n            }\r\n        }\r\n        Arrays.sort(methods, new Comparator<CtMethod>() {\r\n            @Override\r\n            public int compare(CtMethod m1, CtMethod m2) {\r\n                int value = m1.getName().compareTo(m2.getName());\r\n                if (value == 0)\r\n                    value = m1.getMethodInfo2().getDescriptor().compareTo(m2.getMethodInfo2().getDescriptor());\r\n                return value;\r\n            }\r\n        });\r\n        for (int i = 0; i < methods.length; i++) {\r\n            CtMethod method = methods[i];\r\n            int mods = method.getModifiers() & (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.STATIC | Modifier.FINAL | Modifier.SYNCHRONIZED | Modifier.NATIVE | Modifier.ABSTRACT | Modifier.STRICT);\r\n            if ((mods & Modifier.PRIVATE) == 0) {\r\n                out.writeUTF(method.getName());\r\n                out.writeInt(mods);\r\n                out.writeUTF(method.getMethodInfo2().getDescriptor().replace('/', '.'));\r\n            }\r\n        }\r\n        out.flush();\r\n        MessageDigest digest = MessageDigest.getInstance(\"SHA\");\r\n        byte[] digested = digest.digest(bout.toByteArray());\r\n        long hash = 0;\r\n        for (int i = Math.min(digested.length, 8) - 1; i >= 0; i--) hash = (hash << 8) | (digested[i] & 0xFF);\r\n        return hash;\r\n    } catch (IOException e) {\r\n        throw new CannotCompileException(e);\r\n    } catch (NoSuchAlgorithmException e) {\r\n        throw new CannotCompileException(e);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.SerialVersionUID.calculateDefault",
	"Comment": "calculate default value. see java serialization specification, streamunique identifiers.",
	"Method": "long calculateDefault(CtClass clazz){\r\n    return field1.getName().compareTo(field2.getName());\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.SerialVersionUID.calculateDefault",
	"Comment": "calculate default value. see java serialization specification, streamunique identifiers.",
	"Method": "long calculateDefault(CtClass clazz){\r\n    return c1.getMethodInfo2().getDescriptor().compareTo(c2.getMethodInfo2().getDescriptor());\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.SerialVersionUID.calculateDefault",
	"Comment": "calculate default value. see java serialization specification, streamunique identifiers.",
	"Method": "long calculateDefault(CtClass clazz){\r\n    int value = m1.getName().compareTo(m2.getName());\r\n    if (value == 0)\r\n        value = m1.getMethodInfo2().getDescriptor().compareTo(m2.getMethodInfo2().getDescriptor());\r\n    return value;\r\n}"
}, {
	"Path": "com.hazelcast.spi.impl.packetdispatcher.impl.PacketDispatcherTest.whenUnrecognizedPacket_thenSwallowed",
	"Comment": "unrecognized packets are logged. no handlers is contacted.",
	"Method": "void whenUnrecognizedPacket_thenSwallowed(){\r\n    Packet packet = new Packet().setPacketType(Packet.Type.NULL);\r\n    dispatcher.accept(packet);\r\n    verifyZeroInteractions(responseHandler, operationExecutor, eventService, connectionManager, invocationMonitor, jetService);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.scopedpool.SoftValueHashMap.containsKey",
	"Comment": "returns true if this map contains a mapping for thespecified key.",
	"Method": "boolean containsKey(Object key){\r\n    processQueue();\r\n    return hash.containsKey(key);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.AccessFlag.of",
	"Comment": "converts a javassist.modifier intoa javassist.bytecode.accessflag.",
	"Method": "int of(int modifier){\r\n    return modifier;\r\n}"
}, {
	"Path": "org.hotswap.agent.annotation.handler.PluginClassFileTransformer.createCtClass",
	"Comment": "creats javaassist ctclass for bytecode manipulation. add defaultclassloader.",
	"Method": "CtClass createCtClass(byte[] bytes,ClassLoader classLoader){\r\n    ClassPool cp = new ClassPool();\r\n    cp.appendSystemPath();\r\n    cp.appendClassPath(new LoaderClassPath(classLoader));\r\n    return cp.makeClass(new ByteArrayInputStream(bytes));\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.CtClass.getEnclosingBehavior",
	"Comment": "returns the immediately enclosing method of this class.it might be not a method but a constructor.this method works only with jdk 1.5 or later.",
	"Method": "CtBehavior getEnclosingBehavior(){\r\n    return null;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.bytecode.analysis.Type.get",
	"Comment": "obtain the type for a given class. if the class is a primitive,the the unique type instance for the primitive will be returned.otherwise a new type instance representing the class is returned.",
	"Method": "Type get(CtClass clazz){\r\n    Type type = (Type) prims.get(clazz);\r\n    return type != null ? type : new Type(clazz);\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientNetworkConfig.getAddresses",
	"Comment": "returns the list of candidate addresses that client will use to establish initial connection",
	"Method": "List<String> getAddresses(){\r\n    return addressList;\r\n}"
}, {
	"Path": "com.hazelcast.client.config.ClientNetworkConfig.getOutboundPorts",
	"Comment": "returns the outbound ports. it is possible that null is returned if not defined.",
	"Method": "Collection<Integer> getOutboundPorts(){\r\n    return outboundPorts;\r\n}"
}]