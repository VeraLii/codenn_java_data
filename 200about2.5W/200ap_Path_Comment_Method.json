[{
	"Path": "com.datastax.driver.core.ProtocolV1Test.should_execute_prepared_statement_with_variables",
	"Comment": "validates that a prepared statement with variables is correctly prepared and executed.",
	"Method": "void should_execute_prepared_statement_with_variables(){\r\n    PreparedStatement ps = session().prepare(\"select * from system.local where key=?\");\r\n    session().execute(ps.bind(\"local\"));\r\n}"
}, {
	"Path": "org.jabref.model.TreeNode.getRoot",
	"Comment": "returns the root of the tree that contains this node. the root is the ancestor with an empty parent.thus a node without a parent is considered its own root.",
	"Method": "T getRoot(){\r\n    if (parent == null) {\r\n        return (T) this;\r\n    } else {\r\n        return parent.getRoot();\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.VIntCoding.computeVIntSize",
	"Comment": "compute the number of bytes that would be needed to encode a varint.",
	"Method": "int computeVIntSize(long param){\r\n    return computeUnsignedVIntSize(encodeZigZag64(param));\r\n}"
}, {
	"Path": "com.datastax.driver.core.HeapCompressionTest.should_function_with_snappy_compression",
	"Comment": "validates that snappy compression still works when using heap buffers.",
	"Method": "void should_function_with_snappy_compression(){\r\n    compressionTest(ProtocolOptions.Compression.SNAPPY);\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fetcher.DOAJFetcher.parseBibJSONtoBibtex",
	"Comment": "convert a jsonobject containing a bibjson entry to a bibentry",
	"Method": "BibEntry parseBibJSONtoBibtex(JSONObject bibJsonEntry,Character keywordSeparator){\r\n    String[] singleFieldStrings = { FieldName.YEAR, FieldName.TITLE, FieldName.ABSTRACT, FieldName.MONTH };\r\n    String[] journalSingleFieldStrings = { FieldName.PUBLISHER, FieldName.NUMBER, FieldName.VOLUME };\r\n    BibEntry entry = new BibEntry();\r\n    entry.setType(\"article\");\r\n    if (bibJsonEntry.has(\"author\")) {\r\n        JSONArray authors = bibJsonEntry.getJSONArray(\"author\");\r\n        List<String> authorList = new ArrayList();\r\n        for (int i = 0; i < authors.length(); i++) {\r\n            if (authors.getJSONObject(i).has(\"name\")) {\r\n                authorList.add(authors.getJSONObject(i).getString(\"name\"));\r\n            } else {\r\n                LOGGER.info(\"Empty author name.\");\r\n            }\r\n        }\r\n        entry.setField(FieldName.AUTHOR, String.join(\" and \", authorList));\r\n    } else {\r\n        LOGGER.info(\"No author found.\");\r\n    }\r\n    for (String field : singleFieldStrings) {\r\n        if (bibJsonEntry.has(field)) {\r\n            entry.setField(field, bibJsonEntry.getString(field));\r\n        }\r\n    }\r\n    if (bibJsonEntry.has(\"start_page\")) {\r\n        if (bibJsonEntry.has(\"end_page\")) {\r\n            entry.setField(FieldName.PAGES, bibJsonEntry.getString(\"start_page\") + \"--\" + bibJsonEntry.getString(\"end_page\"));\r\n        } else {\r\n            entry.setField(FieldName.PAGES, bibJsonEntry.getString(\"start_page\"));\r\n        }\r\n    }\r\n    if (bibJsonEntry.has(\"journal\")) {\r\n        JSONObject journal = bibJsonEntry.getJSONObject(\"journal\");\r\n        if (journal.has(\"title\")) {\r\n            entry.setField(FieldName.JOURNAL, journal.getString(\"title\").trim());\r\n        } else {\r\n            LOGGER.info(\"No journal title found.\");\r\n        }\r\n        for (String field : journalSingleFieldStrings) {\r\n            if (journal.has(field)) {\r\n                entry.setField(field, journal.getString(field));\r\n            }\r\n        }\r\n    } else {\r\n        LOGGER.info(\"No journal information found.\");\r\n    }\r\n    if (bibJsonEntry.has(\"keywords\")) {\r\n        JSONArray keywords = bibJsonEntry.getJSONArray(\"keywords\");\r\n        for (int i = 0; i < keywords.length(); i++) {\r\n            if (!keywords.isNull(i)) {\r\n                entry.addKeyword(keywords.getString(i).trim(), keywordSeparator);\r\n            }\r\n        }\r\n    }\r\n    if (bibJsonEntry.has(\"identifier\")) {\r\n        JSONArray identifiers = bibJsonEntry.getJSONArray(\"identifier\");\r\n        for (int i = 0; i < identifiers.length(); i++) {\r\n            String type = identifiers.getJSONObject(i).getString(\"type\");\r\n            if (\"doi\".equals(type)) {\r\n                entry.setField(FieldName.DOI, identifiers.getJSONObject(i).getString(\"id\"));\r\n            } else if (\"pissn\".equals(type)) {\r\n                entry.setField(FieldName.ISSN, identifiers.getJSONObject(i).getString(\"id\"));\r\n            } else if (\"eissn\".equals(type)) {\r\n                entry.setField(FieldName.ISSN, identifiers.getJSONObject(i).getString(\"id\"));\r\n            }\r\n        }\r\n    }\r\n    if (bibJsonEntry.has(\"link\")) {\r\n        JSONArray links = bibJsonEntry.getJSONArray(\"link\");\r\n        for (int i = 0; i < links.length(); i++) {\r\n            if (links.getJSONObject(i).has(\"type\")) {\r\n                String type = links.getJSONObject(i).getString(\"type\");\r\n                if (\"fulltext\".equals(type) && links.getJSONObject(i).has(\"url\")) {\r\n                    entry.setField(FieldName.URL, links.getJSONObject(i).getString(\"url\"));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return entry;\r\n}"
}, {
	"Path": "org.jabref.logic.openoffice.OOBibStyle.isUpToDate",
	"Comment": "if this style was initialized from a file on disk, check whether the fileis unmodified since initialization.",
	"Method": "boolean isUpToDate(){\r\n    if (styleFile == null) {\r\n        return true;\r\n    } else {\r\n        return styleFile.lastModified() == this.styleFileModificationTime;\r\n    }\r\n}"
}, {
	"Path": "org.jabref.model.bibtexkeypattern.AbstractBibtexKeyPattern.isDefaultValue",
	"Comment": "checks whether this pattern is customized or the default value.",
	"Method": "boolean isDefaultValue(String key){\r\n    return data.get(key) == null;\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiletype.ExternalFileTypes.getExternalFileTypeByExt",
	"Comment": "look up the external file type registered for this extension, if any.",
	"Method": "Optional<ExternalFileType> getExternalFileTypeByExt(String extension){\r\n    return externalFileTypes.stream().filter(type -> type.getExtension().equalsIgnoreCase(extension)).findFirst();\r\n}"
}, {
	"Path": "com.datastax.driver.core.ClusterInitTest.should_be_able_to_close_cluster_that_never_successfully_connected",
	"Comment": "validates that a cluster that was never able to successfully establish connection a session canbe closed properly.",
	"Method": "void should_be_able_to_close_cluster_that_never_successfully_connected(){\r\n    Cluster cluster = Cluster.builder().addContactPointsWithPorts(new InetSocketAddress(\"127.0.0.1\", 65534)).withNettyOptions(nonQuietClusterCloseOptions).build();\r\n    try {\r\n        cluster.connect();\r\n        fail(\"Should not have been able to connect.\");\r\n    } catch (NoHostAvailableException e) {\r\n        CloseFuture closeFuture = cluster.closeAsync();\r\n        try {\r\n            closeFuture.get(1, TimeUnit.SECONDS);\r\n        } catch (TimeoutException e1) {\r\n            fail(\"Close Future did not complete quickly.\");\r\n        }\r\n    } finally {\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.autosaveandbackup.BackupManager.restoreBackup",
	"Comment": "restores the backup file by copying and overwriting the original one.",
	"Method": "void restoreBackup(Path originalPath){\r\n    Path backupPath = getBackupPath(originalPath);\r\n    try {\r\n        Files.copy(backupPath, originalPath, StandardCopyOption.REPLACE_EXISTING);\r\n    } catch (IOException e) {\r\n        LOGGER.error(\"Error while restoring the backup file.\", e);\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.Connection.release",
	"Comment": "if the connection is part of a pool, return it to the pool. the connection should generally notbe reused after that.",
	"Method": "void release(){\r\n    Owner owner = ownerRef.get();\r\n    if (owner instanceof HostConnectionPool)\r\n        ((HostConnectionPool) owner).returnConnection(this);\r\n}"
}, {
	"Path": "me.ramswaroop.jbot.core.slack.Bot.nextConversation",
	"Comment": "call this method to jump to the next method in a conversation.",
	"Method": "void nextConversation(Event event){\r\n    nextConversation(event.getChannelId());\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.weld.WeldPluginTest.hotswapPrototypeTestNotFailWhenHoldingInstanceBecauseSingletonInjectionPointWasReinitialize",
	"Comment": "plugin is currently unable to reload prototype bean instance.",
	"Method": "void hotswapPrototypeTestNotFailWhenHoldingInstanceBecauseSingletonInjectionPointWasReinitialize(){\r\n    DependentHello1 dependentBeanInstance = getBeanInstance(DependentHello1.class);\r\n    assertEquals(\"DependentHello1.hello():HelloServiceImpl1.hello():HelloProducer1.hello()\", dependentBeanInstance.hello());\r\n    swapClasses(HelloServiceImpl1.class, HelloServiceImpl2.class.getName());\r\n    ReflectionHelper.invoke(getBeanInstance(HelloService.class), HelloServiceImpl1.class, \"initName\", new Class[] {});\r\n    assertEquals(\"DependentHello1.hello():HelloServiceImpl2.hello(initialized):HelloProducer2.hello()\", dependentBeanInstance.hello());\r\n    swapClasses(HelloServiceImpl1.class, HelloServiceImpl1.class.getName());\r\n    assertEquals(\"DependentHello1.hello():HelloServiceImpl1.hello():HelloProducer1.hello()\", getBeanInstance(DependentHello1.class).hello());\r\n}"
}, {
	"Path": "org.jabref.gui.entryeditor.RelatedArticlesTab.getRelatedArticleInfo",
	"Comment": "creates a vbox of the related article information to be used in the stackpane displayed in the related articles tab",
	"Method": "VBox getRelatedArticleInfo(List<BibEntry> list){\r\n    VBox vBox = new VBox();\r\n    vBox.setSpacing(20.0);\r\n    for (BibEntry entry : list) {\r\n        HBox hBox = new HBox();\r\n        hBox.setSpacing(5.0);\r\n        String title = entry.getTitle().orElse(\"\");\r\n        String journal = entry.getField(FieldName.JOURNAL).orElse(\"\");\r\n        String authors = entry.getField(FieldName.AUTHOR).orElse(\"\");\r\n        String year = entry.getField(FieldName.YEAR).orElse(\"\");\r\n        Hyperlink titleLink = new Hyperlink(title);\r\n        Text journalText = new Text(journal);\r\n        journalText.setFont(Font.font(Font.getDefault().getFamily(), FontPosture.ITALIC, Font.getDefault().getSize()));\r\n        Text authorsText = new Text(authors);\r\n        Text yearText = new Text(\"(\" + year + \")\");\r\n        titleLink.setOnAction(event -> {\r\n            if (entry.getField(FieldName.URL).isPresent()) {\r\n                try {\r\n                    JabRefDesktop.openBrowser(entry.getField(FieldName.URL).get());\r\n                } catch (IOException e) {\r\n                    LOGGER.error(\"Error opening the browser to: \" + entry.getField(FieldName.URL).get(), e);\r\n                    dialogService.showErrorDialogAndWait(e);\r\n                }\r\n            }\r\n        });\r\n        hBox.getChildren().addAll(titleLink, journalText, authorsText, yearText);\r\n        vBox.getChildren().add(hBox);\r\n    }\r\n    return vBox;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.owb.command.BeanClassRefreshAgent.reloadBean",
	"Comment": "reload bean in existing bean manager. called by a reflection command from beanrefreshcommand transformer.",
	"Method": "void reloadBean(ClassLoader appClassLoader,String beanClassName,Map<String, String> oldFullSignatures,Map<String, String> oldSignatures,String strReloadStrategy,URL beanArchiveUrl){\r\n    try {\r\n        BeanReloadStrategy reloadStrategy;\r\n        try {\r\n            reloadStrategy = BeanReloadStrategy.valueOf(strReloadStrategy);\r\n        } catch (Exception e) {\r\n            reloadStrategy = BeanReloadStrategy.NEVER;\r\n        }\r\n        Class<?> beanClass = appClassLoader.loadClass(beanClassName);\r\n        doReloadBean(appClassLoader, beanClass, oldFullSignatures, oldSignatures, reloadStrategy, beanArchiveUrl);\r\n    } catch (ClassNotFoundException e) {\r\n        LOGGER.error(\"Bean class '{}' not found.\", e, beanClassName);\r\n    } finally {\r\n        reloadFlag = false;\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.AbstractTableMetadata.getOptions",
	"Comment": "returns the options for this table.this value will be null for virtual tables.",
	"Method": "TableOptionsMetadata getOptions(){\r\n    return options;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.reflect.ClassMetaobject.getReturnType",
	"Comment": "returns a class objects representing thereturn type of the method specified by identifier.",
	"Method": "Class<?> getReturnType(int identifier){\r\n    return getReflectiveMethods()[identifier].getReturnType();\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.CollectionUtils.hasUniqueObject",
	"Comment": "determine whether the given collection only contains a single uniqueobject.",
	"Method": "boolean hasUniqueObject(Collection<?> collection){\r\n    if (isEmpty(collection)) {\r\n        return false;\r\n    }\r\n    boolean hasCandidate = false;\r\n    Object candidate = null;\r\n    for (Object elem : collection) {\r\n        if (!hasCandidate) {\r\n            hasCandidate = true;\r\n            candidate = elem;\r\n        } else if (candidate != elem) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.datastax.driver.core.querybuilder.Delete.where",
	"Comment": "returns a where statement for this query without adding clause.",
	"Method": "Where where(Clause clause,Where where,Where where,Clause clause,Where where,Clause clause){\r\n    return where;\r\n}"
}, {
	"Path": "org.elixir_lang.navigation.item_presentation.modular.Unknown.getPresentableText",
	"Comment": "returns the name of the object to be presented in most renderers across the program.",
	"Method": "String getPresentableText(){\r\n    PsiElement[] primaryArguments = getCall().primaryArguments();\r\n    String presentableText;\r\n    if (primaryArguments != null && primaryArguments.length > 0) {\r\n        presentableText = primaryArguments[0].getText();\r\n    } else {\r\n        presentableText = getCall().functionName();\r\n        if (presentableText == null) {\r\n            presentableText = \"?\";\r\n        }\r\n    }\r\n    return presentableText;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.owb.command.ProxyRefreshAgent.recreateProxy",
	"Comment": "recreate proxy classes, called from beanclassrefreshcommand.",
	"Method": "void recreateProxy(ClassLoader appClassLoader,String beanClassName,String oldSignatureForProxyCheck){\r\n    try {\r\n        Class<?> beanClass = appClassLoader.loadClass(beanClassName);\r\n        if (oldSignatureForProxyCheck != null) {\r\n            String newClassSignature = OwbClassSignatureHelper.getSignatureForProxyClass(beanClass);\r\n            if (newClassSignature != null && !newClassSignature.equals(oldSignatureForProxyCheck)) {\r\n                doRecreateProxy(appClassLoader, beanClass);\r\n            }\r\n        }\r\n    } catch (ClassNotFoundException e) {\r\n        LOGGER.error(\"Bean class '{}' not found.\", beanClassName, e);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.ClassPathResource.hashCode",
	"Comment": "this implementation returns the hash code of the underlying class pathlocation.",
	"Method": "int hashCode(){\r\n    return this.path.hashCode();\r\n}"
}, {
	"Path": "org.elixir_lang.structure_view.sorter.Time.getComparator",
	"Comment": "returns the comparator used for comparing nodes in the tree.",
	"Method": "Comparator getComparator(){\r\n    return new Comparator() {\r\n        @Override\r\n        public int compare(Object o1, Object o2) {\r\n            int comparison;\r\n            if (o1 instanceof Timed && o2 instanceof Timed) {\r\n                Timed timed1 = (Timed) o1;\r\n                Timed timed2 = (Timed) o2;\r\n                Timed.Time time1 = timed1.time();\r\n                Timed.Time time2 = timed2.time();\r\n                if (time1 == time2) {\r\n                    comparison = 0;\r\n                } else if (time1 == Timed.Time.COMPILE && time2 == Timed.Time.RUN) {\r\n                    comparison = -1;\r\n                } else if (time1 == Timed.Time.RUN && time2 == Timed.Time.COMPILE) {\r\n                    comparison = 1;\r\n                } else {\r\n                    throw new NotImplementedException(\"Only COMPILE and RUN time are expected\");\r\n                }\r\n            } else if (o1 instanceof Timed && !(o2 instanceof Timed)) {\r\n                Timed timed1 = (Timed) o1;\r\n                Timed.Time time1 = timed1.time();\r\n                switch(time1) {\r\n                    case COMPILE:\r\n                        comparison = -1;\r\n                        break;\r\n                    case RUN:\r\n                        comparison = 1;\r\n                        break;\r\n                    default:\r\n                        throw new NotImplementedException(\"Only COMPILE and RUN time are expected\");\r\n                }\r\n            } else if (!(o1 instanceof Timed) && o2 instanceof Timed) {\r\n                Timed timed2 = (Timed) o2;\r\n                Timed.Time time2 = timed2.time();\r\n                switch(time2) {\r\n                    case COMPILE:\r\n                        comparison = 1;\r\n                        break;\r\n                    case RUN:\r\n                        comparison = -1;\r\n                        break;\r\n                    default:\r\n                        throw new NotImplementedException(\"Only COMPILE and RUN time are expected\");\r\n                }\r\n            } else {\r\n                assert !(o1 instanceof Timed) && !(o2 instanceof Timed);\r\n                comparison = 0;\r\n            }\r\n            return comparison;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.elixir_lang.structure_view.sorter.Time.getComparator",
	"Comment": "returns the comparator used for comparing nodes in the tree.",
	"Method": "Comparator getComparator(){\r\n    int comparison;\r\n    if (o1 instanceof Timed && o2 instanceof Timed) {\r\n        Timed timed1 = (Timed) o1;\r\n        Timed timed2 = (Timed) o2;\r\n        Timed.Time time1 = timed1.time();\r\n        Timed.Time time2 = timed2.time();\r\n        if (time1 == time2) {\r\n            comparison = 0;\r\n        } else if (time1 == Timed.Time.COMPILE && time2 == Timed.Time.RUN) {\r\n            comparison = -1;\r\n        } else if (time1 == Timed.Time.RUN && time2 == Timed.Time.COMPILE) {\r\n            comparison = 1;\r\n        } else {\r\n            throw new NotImplementedException(\"Only COMPILE and RUN time are expected\");\r\n        }\r\n    } else if (o1 instanceof Timed && !(o2 instanceof Timed)) {\r\n        Timed timed1 = (Timed) o1;\r\n        Timed.Time time1 = timed1.time();\r\n        switch(time1) {\r\n            case COMPILE:\r\n                comparison = -1;\r\n                break;\r\n            case RUN:\r\n                comparison = 1;\r\n                break;\r\n            default:\r\n                throw new NotImplementedException(\"Only COMPILE and RUN time are expected\");\r\n        }\r\n    } else if (!(o1 instanceof Timed) && o2 instanceof Timed) {\r\n        Timed timed2 = (Timed) o2;\r\n        Timed.Time time2 = timed2.time();\r\n        switch(time2) {\r\n            case COMPILE:\r\n                comparison = 1;\r\n                break;\r\n            case RUN:\r\n                comparison = -1;\r\n                break;\r\n            default:\r\n                throw new NotImplementedException(\"Only COMPILE and RUN time are expected\");\r\n        }\r\n    } else {\r\n        assert !(o1 instanceof Timed) && !(o2 instanceof Timed);\r\n        comparison = 0;\r\n    }\r\n    return comparison;\r\n}"
}, {
	"Path": "org.jabref.gui.DefaultInjector.createDependency",
	"Comment": "this method takes care of creating dependencies.by default, it just creates a new instance of the class.dependencies without default constructor are constructed by hand.",
	"Method": "Object createDependency(Class<?> clazz){\r\n    if (clazz == DialogService.class) {\r\n        return new FXDialogService();\r\n    } else if (clazz == TaskExecutor.class) {\r\n        return Globals.TASK_EXECUTOR;\r\n    } else if (clazz == PreferencesService.class) {\r\n        return Globals.prefs;\r\n    } else if (clazz == KeyBindingRepository.class) {\r\n        return Globals.getKeyPrefs();\r\n    } else if (clazz == JournalAbbreviationLoader.class) {\r\n        return Globals.journalAbbreviationLoader;\r\n    } else if (clazz == StateManager.class) {\r\n        return Globals.stateManager;\r\n    } else if (clazz == FileUpdateMonitor.class) {\r\n        return Globals.getFileUpdateMonitor();\r\n    } else if (clazz == ClipBoardManager.class) {\r\n        return Globals.clipboardManager;\r\n    } else {\r\n        try {\r\n            return clazz.newInstance();\r\n        } catch (InstantiationException | IllegalAccessException ex) {\r\n            LOGGER.error(\"Cannot instantiate dependency: \" + clazz, ex);\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.WeakReferenceMonitor.keepMonitoringThreadAlive",
	"Comment": "check whether to keep the monitoring thread alive, i.e. whether there arestill entries being tracked.",
	"Method": "boolean keepMonitoringThreadAlive(){\r\n    synchronized (WeakReferenceMonitor.class) {\r\n        if (!trackedEntries.isEmpty()) {\r\n            return true;\r\n        } else {\r\n            logger.debug(\"No entries left to track - stopping reference monitor thread\");\r\n            monitoringThread = null;\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.preferences.TablePrefsTab.storeSettings",
	"Comment": "store changes to table preferences. this method is called when the userclicks ok.",
	"Method": "void storeSettings(){\r\n    prefs.putBoolean(JabRefPreferences.NAMES_AS_IS, namesAsIs.isSelected());\r\n    prefs.putBoolean(JabRefPreferences.NAMES_FIRST_LAST, namesFf.isSelected());\r\n    prefs.putBoolean(JabRefPreferences.NAMES_NATBIB, namesNatbib.isSelected());\r\n    prefs.putBoolean(JabRefPreferences.NAMES_LAST_ONLY, lastNamesOnly.isSelected());\r\n    prefs.putBoolean(JabRefPreferences.ABBR_AUTHOR_NAMES, abbrNames.isSelected());\r\n    prefs.putBoolean(JabRefPreferences.AUTO_RESIZE_MODE, autoResizeMode.isSelected());\r\n}"
}, {
	"Path": "org.jabref.logic.shared.DBMSSynchronizer.removeNotSharedEntries",
	"Comment": "removes all local entries which are not present on shared database.",
	"Method": "void removeNotSharedEntries(List<BibEntry> localEntries,Set<Integer> sharedIDs){\r\n    for (int i = 0; i < localEntries.size(); i++) {\r\n        BibEntry localEntry = localEntries.get(i);\r\n        boolean match = false;\r\n        for (int sharedID : sharedIDs) {\r\n            if (localEntry.getSharedBibEntryData().getSharedID() == sharedID) {\r\n                match = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!match) {\r\n            eventBus.post(new SharedEntryNotPresentEvent(localEntry));\r\n            bibDatabase.removeEntry(localEntry, EntryEventSource.SHARED);\r\n            i--;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.SchemaChangesTest.verifyNoMoreInteractionsWithListener",
	"Comment": "ensures that a listener registered on a cluster that has schema metadata disabled is neverinvoked with schema change events.",
	"Method": "void verifyNoMoreInteractionsWithListener(){\r\n    verifyNoMoreInteractions(schemaDisabledListener);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.logback.LogbackPlugin.registerConfigurator",
	"Comment": "transform configurator class to register logback config url.",
	"Method": "void registerConfigurator(ClassPool classPool,CtClass ctClass){\r\n    CtMethod m = ctClass.getDeclaredMethod(\"doConfigure\", new CtClass[] { classPool.get(\"java.net.URL\") });\r\n    m.insertAfter(PluginManagerInvoker.buildInitializePlugin(LogbackPlugin.class));\r\n    m.insertAfter(PluginManagerInvoker.buildCallPluginMethod(LogbackPlugin.class, \"initLogback\", \"this\", \"java.lang.Object\", \"url\", \"java.net.URL\"));\r\n}"
}, {
	"Path": "org.jabref.logic.util.io.XMLUtil.printDocument",
	"Comment": "prints out the document to standard out. used to generate files for test cases.",
	"Method": "void printDocument(Document doc){\r\n    try {\r\n        DOMSource domSource = new DOMSource(doc);\r\n        StringWriter writer = new StringWriter();\r\n        StreamResult result = new StreamResult(writer);\r\n        TransformerFactory tf = TransformerFactory.newInstance();\r\n        Transformer transformer = tf.newTransformer();\r\n        transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\r\n        transformer.transform(domSource, result);\r\n        System.out.println(writer);\r\n    } catch (TransformerException ex) {\r\n        LOGGER.error(\"\", ex);\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.exceptions.QueryConsistencyException.getHost",
	"Comment": "the coordinator host that caused this exception to be thrown. note that this is the querycoordinator host, not the host which timed out.",
	"Method": "InetAddress getHost(){\r\n    return address != null ? address.getAddress() : null;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.StatementContext.setReturningGeneratedKeys",
	"Comment": "sets whether the current statement returns generated keys.",
	"Method": "void setReturningGeneratedKeys(boolean b){\r\n    if (isConcurrentUpdatable() && b) {\r\n        throw new IllegalArgumentException(\"Cannot create a result set that is concurrent \" + \"updatable and is returning generated keys.\");\r\n    }\r\n    this.returningGeneratedKeys = b;\r\n}"
}, {
	"Path": "com.datastax.driver.core.exceptions.AlreadyExistsException.wasTableCreation",
	"Comment": "returns whether the query yielding this exception was a table creation attempt.",
	"Method": "boolean wasTableCreation(){\r\n    return !table.isEmpty();\r\n}"
}, {
	"Path": "com.datastax.driver.core.ProtocolOptions.getMaxSchemaAgreementWaitSeconds",
	"Comment": "returns the maximum time to wait for schema agreement before returning from a ddl query.",
	"Method": "int getMaxSchemaAgreementWaitSeconds(){\r\n    return maxSchemaAgreementWaitSeconds;\r\n}"
}, {
	"Path": "me.ramswaroop.jbot.core.slack.Bot.handleTransportError",
	"Comment": "handle an error from the underlying websocket message transport.",
	"Method": "void handleTransportError(WebSocketSession session,Throwable exception){\r\n    logger.error(\"Transport Error: \", exception);\r\n}"
}, {
	"Path": "org.elixir_lang.beam.psi.BeamFileImpl.processDeclarations",
	"Comment": "passes the declarations contained in this psi element and its childrenfor processing to the specified scope processor.",
	"Method": "boolean processDeclarations(PsiScopeProcessor processor,ResolveState state,PsiElement lastParent,PsiElement place){\r\n    processor.handleEvent(PsiScopeProcessor.Event.SET_DECLARATION_HOLDER, this);\r\n    final ElementClassHint classHint = processor.getHint(ElementClassHint.KEY);\r\n    boolean keepProcessing = true;\r\n    if (classHint == null || classHint.shouldProcess(ElementClassHint.DeclarationKind.CLASS)) {\r\n        for (CanonicallyNamed modular : modulars()) {\r\n            if (!processor.execute(modular, state)) {\r\n                keepProcessing = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return keepProcessing;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.tomcat.WebappLoaderTransformer.patchStandardRoot",
	"Comment": "resource lookup for tomcat 8x.before the resource is handled by tomcat, try to get extraresource handled by the plugin.",
	"Method": "void patchStandardRoot(ClassPool classPool,CtClass ctClass){\r\n    CtClass ctFileResource = classPool.get(\"org.apache.catalina.webresources.FileResource\");\r\n    CtConstructor ctFileResourceConstructor = ctFileResource.getConstructors()[0];\r\n    CtClass[] constructorTypes = ctFileResourceConstructor.getParameterTypes();\r\n    String constrParams;\r\n    if (constructorTypes.length == 4)\r\n        constrParams = \"this, path, file, false\";\r\n    else if (constructorTypes.length == 5)\r\n        constrParams = \"this, path, file, false, null\";\r\n    else {\r\n        LOGGER.warning(\"org.apache.catalina.webresources.FileResource unknown constructor. Tomcat plugin will not work properly.\");\r\n        return;\r\n    }\r\n    try {\r\n        ctClass.getDeclaredMethod(\"getResourceInternal\", new CtClass[] { classPool.get(String.class.getName()), CtPrimitiveType.booleanType }).insertBefore(\"java.io.File file = \" + TomcatPlugin.class.getName() + \".getExtraResourceFile(this, path);\" + \"if (file != null) return new org.apache.catalina.webresources.FileResource(\" + constrParams + \");\");\r\n    } catch (NotFoundException e) {\r\n        LOGGER.warning(\"org.apache.catalina.webresources.StandardRoot does not contain getResourceInternal method. Tomcat plugin will not work properly.\");\r\n        return;\r\n    }\r\n    try {\r\n        ctClass.getDeclaredMethod(\"getResources\", new CtClass[] { classPool.get(String.class.getName()), CtPrimitiveType.booleanType }).insertAfter(\"java.io.File file = \" + TomcatPlugin.class.getName() + \".getExtraResourceFile(this, path);\" + \"if (file != null) {\" + \"org.apache.catalina.WebResource[] ret = new org.apache.catalina.WebResource[$_.length + 1];\" + \"ret[0] = new org.apache.catalina.webresources.FileResource(\" + constrParams + \");\" + \"java.lang.System.arraycopy($_, 0, ret, 1, $_.length);\" + \"return ret;\" + \"} else {return $_;}\");\r\n    } catch (NotFoundException e) {\r\n        LOGGER.warning(\"org.apache.catalina.webresources.StandardRoot does not contain getResourceInternal method. Tomcat plugin will not work properly.\");\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fetcher.MrDLibFetcher.constructQuery",
	"Comment": "constructs the query based on title of the bibentry. adds statistical stuff to the url.",
	"Method": "String constructQuery(String queryWithTitle){\r\n    queryWithTitle = queryWithTitle.replaceAll(\"/\", \" \");\r\n    URIBuilder builder = new URIBuilder();\r\n    builder.setScheme(\"http\");\r\n    builder.setHost(getMdlUrl());\r\n    builder.setPath(\"/v2/items/\" + queryWithTitle + \"/related_items\");\r\n    builder.addParameter(\"partner_id\", \"jabref\");\r\n    builder.addParameter(\"app_id\", \"jabref_desktop\");\r\n    builder.addParameter(\"app_version\", VERSION.getFullVersion());\r\n    builder.addParameter(\"app_lang\", LANGUAGE);\r\n    try {\r\n        URI uri = builder.build();\r\n        LOGGER.trace(\"Request: \" + uri.toString());\r\n        return uri.toString();\r\n    } catch (URISyntaxException e) {\r\n        LOGGER.error(e.getMessage(), e);\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "org.elixir_lang.parser.ElixirParser.maxDotCall",
	"Comment": "dotinfixoperator parenthesesarguments parenthesesarguments?",
	"Method": "boolean maxDotCall(PsiBuilder b,int l){\r\n    if (!recursion_guard_(b, l, \"maxDotCall\"))\r\n        return false;\r\n    if (!nextTokenIs(b, DOT_OPERATOR))\r\n        return false;\r\n    boolean r;\r\n    Marker m = enter_section_(b, l, _LEFT_, MATCHED_DOT_CALL, null);\r\n    r = dotInfixOperator(b, l + 1);\r\n    r = r && parenthesesArguments(b, l + 1);\r\n    r = r && maxDotCall_2(b, l + 1);\r\n    exit_section_(b, l, m, r, false, null);\r\n    return r;\r\n}"
}, {
	"Path": "org.jabref.model.groups.GroupTreeNode.calculateNumberOfMatches",
	"Comment": "determines the number of entries in the specified database which are matched by this group.",
	"Method": "int calculateNumberOfMatches(List<BibEntry> entries,int calculateNumberOfMatches,BibDatabase database){\r\n    return calculateNumberOfMatches(database.getEntries());\r\n}"
}, {
	"Path": "org.jdbi.v3.core.Jdbi.withExtension",
	"Comment": "a convenience method which opens an extension of the given type, yields it to a callback, and returns the resultof the callback. a handle is opened if needed by the extension, and closed before returning to the caller.",
	"Method": "R withExtension(Class<E> extensionType,ExtensionCallback<R, E, X> callback){\r\n    try (LazyHandleSupplier handle = new LazyHandleSupplier(this, config)) {\r\n        E extension = getConfig(Extensions.class).findFor(extensionType, handle).orElseThrow(() -> new NoSuchExtensionException(\"Extension not found: \" + extensionType));\r\n        return callback.withExtension(extension);\r\n    }\r\n}"
}, {
	"Path": "com.github.javafaker.Lorem.sentence",
	"Comment": "create a sentence with a random number of words within the range 4..10.",
	"Method": "String sentence(String sentence,int wordCount,String sentence,int wordCount,int randomWordsToAdd){\r\n    int numberOfWordsToAdd = randomWordsToAdd == 0 ? 0 : faker.random().nextInt(randomWordsToAdd);\r\n    return capitalize(join(words(wordCount + numberOfWordsToAdd), \" \") + \".\");\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolTest.should_fail_in_dequeue_when_setting_keyspace_and_another_set_keyspace_attempt_is_in_flight",
	"Comment": "ensures that while dequeuing borrow connection requests that if a set keyspace attempt is inprogress on that connection for a difference keyspace than the pool state that the future forthat borrow attempt is failed.",
	"Method": "void should_fail_in_dequeue_when_setting_keyspace_and_another_set_keyspace_attempt_is_in_flight(){\r\n    Cluster cluster = createClusterBuilder().build();\r\n    List<MockRequest> requests = newArrayList();\r\n    try {\r\n        HostConnectionPool pool = createPool(cluster, 1, 1);\r\n        cluster.getConfiguration().getPoolingOptions().setMaxRequestsPerConnection(HostDistance.LOCAL, 100);\r\n        int maxQueueSize = 256;\r\n        assertThat(pool.connections.size()).isEqualTo(1);\r\n        List<Connection> coreConnections = newArrayList(pool.connections);\r\n        requests = MockRequest.sendMany(100, pool);\r\n        assertBorrowedConnections(requests, coreConnections);\r\n        MockRequest queuedRequest = MockRequest.send(pool, maxQueueSize);\r\n        for (MockRequest request : requests) {\r\n            Uninterruptibles.getUninterruptibly(request.connectionFuture, 5, TimeUnit.SECONDS);\r\n        }\r\n        primingClient.prime(PrimingRequest.queryBuilder().withQuery(\"USE \\\"slowks\\\"\").withThen(PrimingRequest.then().withFixedDelay(5000L)));\r\n        Connection connection = pool.connections.get(0);\r\n        connection.setKeyspaceAsync(\"slowks\");\r\n        pool.manager.poolsState.setKeyspace(\"newkeyspace\");\r\n        MockRequest.completeAll(requests);\r\n        try {\r\n            Uninterruptibles.getUninterruptibly(queuedRequest.connectionFuture, 5, TimeUnit.SECONDS);\r\n            fail(\"Should have thrown exception\");\r\n        } catch (ExecutionException e) {\r\n            assertThat(e.getCause()).isInstanceOf(DriverException.class);\r\n            assertThat(e.getCause().getMessage()).contains(\"Aborting attempt to set keyspace to 'newkeyspace' since there is already an in flight attempt to set keyspace to 'slowks'.\");\r\n        }\r\n    } finally {\r\n        MockRequest.completeAll(requests);\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.ClusterInitTest.session_should_detect_cluster_close",
	"Comment": "ensures that if a cluster is closed, subsequent attempts to the use the session will throw auseful error.",
	"Method": "void session_should_detect_cluster_close(){\r\n    ScassandraCluster scassandraCluster = ScassandraCluster.builder().withIpPrefix(TestUtils.IP_PREFIX).build();\r\n    Cluster cluster = Cluster.builder().addContactPoints(scassandraCluster.address(1).getAddress()).withPort(scassandraCluster.getBinaryPort()).withNettyOptions(nonQuietClusterCloseOptions).build();\r\n    try {\r\n        scassandraCluster.init();\r\n        Session session = cluster.connect();\r\n        cluster.close();\r\n        try {\r\n            session.execute(\"SELECTS * FROM system.peers\");\r\n            fail(\"Should have failed when session.execute was called on cluster that was closed\");\r\n        } catch (DriverInternalError e) {\r\n            assertThat(e.getCause()).isInstanceOf(IllegalStateException.class);\r\n            assertThat(e.getCause()).hasMessage(\"Could not send request, session is closed\");\r\n        }\r\n    } finally {\r\n        scassandraCluster.stop();\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.PreparedStatementTest.should_not_allow_unbound_value_on_batch_statement_when_protocol_lesser_than_v4",
	"Comment": "tests that, under protocol versions lesser that v4, it is not possible to execute a preparedstatement with unbound values. note that we have to force protocol version to less than v4because higher protocol versions would allow such unbound values to be sent.",
	"Method": "void should_not_allow_unbound_value_on_batch_statement_when_protocol_lesser_than_v4(){\r\n    Cluster cluster = register(Cluster.builder().addContactPoints(getContactPoints()).withPort(ccm().getBinaryPort()).withProtocolVersion(ccm().getProtocolVersion(ProtocolVersion.V3)).build());\r\n    Session session = cluster.connect();\r\n    try {\r\n        PreparedStatement ps = session.prepare(\"INSERT INTO \" + keyspace + \".\" + SIMPLE_TABLE + \" (k, i) VALUES (?, ?)\");\r\n        BatchStatement batch = new BatchStatement();\r\n        batch.add(ps.bind(\"foo\"));\r\n        session.execute(batch);\r\n        fail(\"Should not have executed statement with UNSET values in protocol V3\");\r\n    } catch (IllegalStateException e) {\r\n        assertThat(e.getMessage()).contains(\"Unset value at index 1\");\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.edit.ReplaceStringViewModel.replaceItem",
	"Comment": "does the actual operation on a bibtex entry based on the settings specified in this same dialog. returns thenumber of occurrences replaced.",
	"Method": "int replaceItem(BibEntry entry,NamedCompound compound){\r\n    int counter = 0;\r\n    if (this.allFieldReplace) {\r\n        for (String fieldName : entry.getFieldNames()) {\r\n            counter += replaceField(entry, fieldName, compound);\r\n        }\r\n    } else {\r\n        for (String espFieldName : fieldStrings) {\r\n            counter += replaceField(entry, espFieldName, compound);\r\n        }\r\n    }\r\n    return counter;\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.isCollapsedByDefault",
	"Comment": "returns the default collapsed state for the folding region related to the specified node.",
	"Method": "boolean isCollapsedByDefault(ASTNode node){\r\n    PsiElement element = node.getPsi();\r\n    boolean isCollapsedByDefault = false;\r\n    if (element instanceof AtNonNumericOperation) {\r\n        isCollapsedByDefault = ElixirFoldingSettings.getInstance().isReplaceModuleAttributesWithValues();\r\n    } else {\r\n        PsiElement[] children = element.getChildren();\r\n        for (PsiElement child : children) {\r\n            if (child instanceof Call) {\r\n                Call call = (Call) child;\r\n                for (String resolvedFunctionName : RESOLVED_FUNCTION_NAMES) {\r\n                    if (call.isCalling(KERNEL, resolvedFunctionName)) {\r\n                        isCollapsedByDefault = ElixirFoldingSettings.getInstance().isCollapseElixirModuleDirectiveGroups();\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return isCollapsedByDefault;\r\n}"
}, {
	"Path": "org.jabref.gui.fieldeditors.MapBasedEditorViewModel.getValueFromString",
	"Comment": "converts a string value to the type t. if the type cannot be directly casted to t, this method must be overriden in a subclass",
	"Method": "T getValueFromString(String string){\r\n    try {\r\n        return (T) string;\r\n    } catch (ClassCastException ex) {\r\n        LOGGER.error(String.format(\"Could not cast string to type %1$s. Try overriding the method in a subclass and provide a conversion from string to the concrete type %1$s\", string.getClass()), ex);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jabref.logic.auxparser.DefaultAuxParser.insertEntry",
	"Comment": "insert a clone of the given entry. the clone is given a new unique id.",
	"Method": "void insertEntry(BibEntry entry,AuxParserResult result){\r\n    BibEntry clonedEntry = (BibEntry) entry.clone();\r\n    result.getGeneratedBibDatabase().insertEntry(clonedEntry);\r\n}"
}, {
	"Path": "org.jabref.model.cleanup.FieldFormatterCleanup.cleanupSingleField",
	"Comment": "runs the formatter on the specified field in the given entry.if the formatter returns an empty string, then the field is removed.",
	"Method": "List<FieldChange> cleanupSingleField(String fieldKey,BibEntry entry){\r\n    if (!entry.hasField(fieldKey)) {\r\n        return new ArrayList();\r\n    }\r\n    String oldValue = entry.getField(fieldKey).orElse(null);\r\n    String newValue = formatter.format(oldValue);\r\n    if (oldValue.equals(newValue)) {\r\n        return new ArrayList();\r\n    } else {\r\n        if (newValue.isEmpty()) {\r\n            entry.clearField(fieldKey);\r\n            newValue = null;\r\n        } else {\r\n            entry.setField(fieldKey, newValue, EntryEventSource.SAVE_ACTION);\r\n        }\r\n        FieldChange change = new FieldChange(entry, fieldKey, oldValue, newValue);\r\n        return Collections.singletonList(change);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.FileSystemResource.hashCode",
	"Comment": "this implementation returns the hash code of the underlying filereference.",
	"Method": "int hashCode(){\r\n    return this.path.hashCode();\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.Query.concurrentUpdatable",
	"Comment": "specify that the result set should be concurrent updatable.this will allow the update methods to be called on the result set produced by thisquery.",
	"Method": "Query concurrentUpdatable(){\r\n    getContext().setConcurrentUpdatable(true);\r\n    return this;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.collections.ConcurrentReferenceHashMap.purgeUnreferencedEntries",
	"Comment": "remove any entries that have been garbage collected and are no longerreferenced. under normal circumstances garbage collected entries areautomatically purged as items are added or removed from the map. thismethod can be used to force a purge, and is useful when the map is readfrequently but updated less often.",
	"Method": "void purgeUnreferencedEntries(){\r\n    for (Segment segment : this.segments) {\r\n        segment.restructureIfNecessary(false);\r\n    }\r\n}"
}, {
	"Path": "org.jdbi.v3.core.config.Configurable.getConfig",
	"Comment": "gets the configuration object of the given type, associated with this object.",
	"Method": "ConfigRegistry getConfig(C getConfig,Class<C> configClass){\r\n    return getConfig().get(configClass);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.spring.getbean.DetachableBeanHolder.getBean",
	"Comment": "returns an existing bean instance or retrieves and stores new bean from the spring beanfactory",
	"Method": "Object getBean(){\r\n    Object beanCopy = bean;\r\n    if (beanCopy == null) {\r\n        Method[] methods = beanFactory.getClass().getMethods();\r\n        for (Method factoryMethod : methods) {\r\n            if (ProxyReplacer.FACTORY_METHOD_NAME.equals(factoryMethod.getName()) && Arrays.equals(factoryMethod.getParameterTypes(), paramClasses)) {\r\n                Object freshBean = factoryMethod.invoke(beanFactory, paramValues);\r\n                if (freshBean instanceof SpringHotswapAgentProxy) {\r\n                    freshBean = ((SpringHotswapAgentProxy) freshBean).$$ha$getTarget();\r\n                }\r\n                bean = freshBean;\r\n                beanCopy = bean;\r\n                LOGGER.info(\"Bean '{}' loaded\", bean.getClass().getName());\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return beanCopy;\r\n}"
}, {
	"Path": "org.jabref.logic.util.io.FileHistory.newFile",
	"Comment": "adds the file to the top of the list. if it already is in the list, it is merely moved to the top.",
	"Method": "void newFile(Path file){\r\n    removeItem(file);\r\n    history.addFirst(file);\r\n    while (size() > HISTORY_SIZE) {\r\n        history.removeLast();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.collab.ChangeScanner.bestFit",
	"Comment": "finds the entry in the list best fitting the specified entry. even if no entries get a score above zero, an entryis still returned.",
	"Method": "BibEntry bestFit(BibEntry targetEntry,List<BibEntry> entries){\r\n    return entries.stream().max(Comparator.comparingDouble(candidate -> DuplicateCheck.compareEntriesStrictly(targetEntry, candidate))).orElse(null);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.jvm.AnonymousClassInfos.mapPreviousState",
	"Comment": "set previous class info state and calculate compatible transitions.usually new state is created from classpool, while old state from classloader.",
	"Method": "void mapPreviousState(AnonymousClassInfos previousAnonymousClassInfos){\r\n    this.previous = previousAnonymousClassInfos;\r\n    previousAnonymousClassInfos.previous = null;\r\n    calculateCompatibleTransitions();\r\n}"
}, {
	"Path": "com.beust.jcommander.JCommander.initMainParameterValue",
	"Comment": "init the main parameter with the given arg. note that the main parameter can be either a listor a single value.",
	"Method": "void initMainParameterValue(String arg){\r\n    if (mainParameter == null) {\r\n        throw new ParameterException(\"Was passed main parameter '\" + arg + \"' but no main parameter was defined in your arg class\");\r\n    }\r\n    Object object = mainParameter.parameterized.get(mainParameter.object);\r\n    Class<?> type = mainParameter.parameterized.getType();\r\n    if (List.class.isAssignableFrom(type)) {\r\n        List result;\r\n        if (object == null) {\r\n            result = Lists.newArrayList();\r\n        } else {\r\n            result = (List) object;\r\n        }\r\n        if (mainParameter.firstTimeMainParameter) {\r\n            result.clear();\r\n            mainParameter.firstTimeMainParameter = false;\r\n        }\r\n        mainParameter.multipleValue = result;\r\n        mainParameter.parameterized.set(mainParameter.object, result);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ReflectionUtils.handleInvocationTargetException",
	"Comment": "handle the given invocation target exception. should only be called if nochecked exception is expected to be thrown by the target method.throws the underlying runtimeexception or error in case of such a rootcause. throws an illegalstateexception else.",
	"Method": "void handleInvocationTargetException(InvocationTargetException ex){\r\n    rethrowRuntimeException(ex.getTargetException());\r\n}"
}, {
	"Path": "org.jabref.gui.openoffice.StyleSelectDialog.updateStyles",
	"Comment": "read all style files or directories of style files indicated by the currentsettings, and add the styles to the list of styles.",
	"Method": "void updateStyles(){\r\n    table.clearSelection();\r\n    styles.getReadWriteLock().writeLock().lock();\r\n    styles.clear();\r\n    styles.addAll(loader.getStyles());\r\n    styles.getReadWriteLock().writeLock().unlock();\r\n    selectLastUsed();\r\n}"
}, {
	"Path": "com.datastax.driver.core.SchemaChangesTest.should_not_refresh_schema_on_schema_change_response",
	"Comment": "ensures that executing a query causing a schema change with a cluster that has schema metadatadisabled will still wait on schema agreement, but not refresh the schema.",
	"Method": "void should_not_refresh_schema_on_schema_change_response(String keyspace){\r\n    ResultSet rs = schemaDisabledSession.execute(String.format(CREATE_TABLE, keyspace));\r\n    assertThat(rs.getExecutionInfo().isSchemaInAgreement()).isTrue();\r\n    assertThat(schemaDisabledCluster.getMetadata().checkSchemaAgreement()).isTrue();\r\n    verify(schemaDisabledControlConnection, after(1000).never()).refreshSchema(any(SchemaElement.class), any(String.class), any(String.class), anyListOf(String.class));\r\n}"
}, {
	"Path": "org.jabref.logic.util.io.CiteKeyBasedFileFinder.findFilesByExtension",
	"Comment": "returns a list of all files in the given directories which have one of the given extension.",
	"Method": "Set<Path> findFilesByExtension(List<Path> directories,List<String> extensions){\r\n    Objects.requireNonNull(extensions, \"Extensions must not be null!\");\r\n    BiPredicate<Path, BasicFileAttributes> isFileWithCorrectExtension = (path, attributes) -> !Files.isDirectory(path) && extensions.contains(FileHelper.getFileExtension(path).orElse(\"\"));\r\n    Set<Path> result = new HashSet();\r\n    for (Path directory : directories) {\r\n        if (Files.exists(directory)) {\r\n            try (Stream<Path> pathStream = Files.find(directory, Integer.MAX_VALUE, isFileWithCorrectExtension)) {\r\n                result.addAll(pathStream.collect(Collectors.toSet()));\r\n            } catch (UncheckedIOException e) {\r\n                throw new IOException(\"Problem in finding files\", e);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.Jdbi.useExtension",
	"Comment": "a convenience method which opens an extension of the given type, and yields it to a callback. a handle is openedif needed by the extention, and closed before returning to the caller.",
	"Method": "void useExtension(Class<E> extensionType,ExtensionConsumer<E, X> callback){\r\n    withExtension(extensionType, extension -> {\r\n        callback.useExtension(extension);\r\n        return null;\r\n    });\r\n}"
}, {
	"Path": "org.jabref.logic.importer.ParserResult.addDuplicateKey",
	"Comment": "add a key to the list of duplicated bibtex keys found in the database.",
	"Method": "void addDuplicateKey(String key){\r\n    if (!duplicateKeys.contains(key)) {\r\n        duplicateKeys.add(key);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.classloader.WatchResourcesClassLoader.getResource",
	"Comment": "returns url only if the resource is found in changedurl and was actually changed afterinstantiation of this classloader.",
	"Method": "URL getResource(String name,URL getResource,String name){\r\n    if (watchResourcesClassLoader != null) {\r\n        URL resource = watchResourcesClassLoader.getResource(name);\r\n        if (resource != null && isResourceChanged(resource)) {\r\n            LOGGER.trace(\"watchResources - using changed resource {}\", name);\r\n            return resource;\r\n        }\r\n    }\r\n    URL resource = findResource(name);\r\n    if (resource != null)\r\n        return resource;\r\n    if (searchParent)\r\n        return super.getResource(name);\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "com.datastax.driver.core.PreparedStatementTest.should_create_tombstone_when_null_value_on_bound_statement",
	"Comment": "tests that a tombstone is created when binding a null value to a column in a preparedstatement.",
	"Method": "void should_create_tombstone_when_null_value_on_bound_statement(){\r\n    PreparedStatement prepared = session().prepare(\"INSERT INTO \" + SIMPLE_TABLE + \" (k, i) VALUES (?, ?)\");\r\n    BoundStatement st1 = prepared.bind();\r\n    st1.setString(0, \"foo\");\r\n    st1.setToNull(1);\r\n    session().execute(st1);\r\n    Statement st2 = new SimpleStatement(\"SELECT i from \" + SIMPLE_TABLE + \" where k = 'foo'\");\r\n    st2.enableTracing();\r\n    ResultSet rows = session().execute(st2);\r\n    assertThat(rows.one().isNull(0)).isTrue();\r\n    Uninterruptibles.sleepUninterruptibly(10, TimeUnit.SECONDS);\r\n    QueryTrace queryTrace = rows.getExecutionInfo().getQueryTrace();\r\n    assertEventsContain(queryTrace, \"1 tombstone\");\r\n}"
}, {
	"Path": "org.jabref.gui.journals.ManageJournalAbbreviationsViewModel.editAbbreviation",
	"Comment": "method to change the currentabbrevaition property to a new abbreviation.",
	"Method": "void editAbbreviation(String name,String abbreviation){\r\n    if (isAbbreviationEditableAndRemovable.get()) {\r\n        Abbreviation abbreviationObject = new Abbreviation(name, abbreviation);\r\n        AbbreviationViewModel abbViewModel = new AbbreviationViewModel(abbreviationObject);\r\n        if (abbreviations.contains(abbViewModel)) {\r\n            if (!abbViewModel.equals(currentAbbreviation.get())) {\r\n                dialogService.showErrorDialogAndWait(Localization.lang(\"Duplicated Journal Abbreviation\"), Localization.lang(\"Abbreviation %s for journal %s already defined.\", abbreviation, name));\r\n            } else {\r\n                setCurrentAbbreviationNameAndAbbreviationIfValid(name, abbreviation);\r\n            }\r\n        } else {\r\n            setCurrentAbbreviationNameAndAbbreviationIfValid(name, abbreviation);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.beust.jcommander.JCommander.parseWithoutValidation",
	"Comment": "parse the command line parameters without validating them.",
	"Method": "void parseWithoutValidation(String args){\r\n    parse(false, args);\r\n}"
}, {
	"Path": "org.jabref.gui.icon.IconTheme.getIconUrl",
	"Comment": "looks up the url for the image representing the given function, in the resourcefile listing images.",
	"Method": "URL getIconUrl(String name){\r\n    String key = Objects.requireNonNull(name, \"icon name\");\r\n    if (!KEY_TO_ICON.containsKey(key)) {\r\n        LOGGER.warn(\"Could not find icon url by name \" + name + \", so falling back on default icon \" + DEFAULT_ICON_PATH);\r\n    }\r\n    String path = KEY_TO_ICON.getOrDefault(key, DEFAULT_ICON_PATH);\r\n    return Objects.requireNonNull(IconTheme.class.getResource(path), \"Path must not be null for key \" + key);\r\n}"
}, {
	"Path": "org.jabref.model.entry.EntryType.getRequiredFieldsFlat",
	"Comment": "returns all required field names.no or relationships are captured here.",
	"Method": "Set<String> getRequiredFieldsFlat(){\r\n    List<String> requiredFlat = getRequiredFields().stream().map(field -> field.split(FieldName.FIELD_SEPARATOR)).flatMap(Arrays::stream).collect(Collectors.toList());\r\n    return Collections.unmodifiableSet(new LinkedHashSet(requiredFlat));\r\n}"
}, {
	"Path": "com.datastax.driver.core.AbstractTableMetadata.getPartitionKey",
	"Comment": "returns the list of columns composing the partition key for this table.a table always has a partition key so the returned list has at least one element.",
	"Method": "List<ColumnMetadata> getPartitionKey(){\r\n    return Collections.unmodifiableList(partitionKey);\r\n}"
}, {
	"Path": "org.elixir_lang.parser.ElixirParser.matchedQualifiedNoParenthesesCall_0",
	"Comment": "dotinfixoperator relativeidentifier noparenthesesoneargument",
	"Method": "boolean matchedQualifiedNoParenthesesCall_0(PsiBuilder b,int l){\r\n    if (!recursion_guard_(b, l, \"matchedQualifiedNoParenthesesCall_0\"))\r\n        return false;\r\n    boolean r;\r\n    Marker m = enter_section_(b);\r\n    r = dotInfixOperator(b, l + 1);\r\n    r = r && relativeIdentifier(b, l + 1);\r\n    r = r && noParenthesesOneArgument(b, l + 1);\r\n    exit_section_(b, m, null, r);\r\n    return r;\r\n}"
}, {
	"Path": "org.jabref.logic.shared.DBMSProcessor.checkForBibEntryExistence",
	"Comment": "checks whether the given bibentry already exists on shared database.",
	"Method": "boolean checkForBibEntryExistence(BibEntry bibEntry){\r\n    try {\r\n        int sharedID = bibEntry.getSharedBibEntryData().getSharedID();\r\n        if (sharedID != -1) {\r\n            StringBuilder selectQuery = new StringBuilder().append(\"SELECT * FROM \").append(escape(\"ENTRY\")).append(\" WHERE \").append(escape(\"SHARED_ID\")).append(\" = ?\");\r\n            try (PreparedStatement preparedSelectStatement = connection.prepareStatement(selectQuery.toString())) {\r\n                preparedSelectStatement.setInt(1, sharedID);\r\n                try (ResultSet resultSet = preparedSelectStatement.executeQuery()) {\r\n                    if (resultSet.next()) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch (SQLException e) {\r\n        LOGGER.error(\"SQL Error: \", e);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.InputStreamResource.getInputStream",
	"Comment": "this implementation throws illegalstateexception if attempting to readthe underlying stream multiple times.",
	"Method": "InputStream getInputStream(){\r\n    if (this.read) {\r\n        throw new IllegalStateException(\"InputStream has already been read - \" + \"do not use InputStreamResource if a stream needs to be read multiple times\");\r\n    }\r\n    this.read = true;\r\n    return this.inputStream;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ClassUtils.getAllInterfacesForClass",
	"Comment": "return all interfaces that the given class implements as array, includingones implemented by superclasses.if the class itself is an interface, it gets returned as sole interface.",
	"Method": "Class<?>[] getAllInterfacesForClass(Class<?> clazz,Class<?>[] getAllInterfacesForClass,Class<?> clazz,ClassLoader classLoader){\r\n    Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);\r\n    return ifcs.toArray(new Class<?>[ifcs.size()]);\r\n}"
}, {
	"Path": "com.datastax.driver.core.Duration.append",
	"Comment": "appends the result of the division to the specified builder if the dividend is not zero.",
	"Method": "long append(StringBuilder builder,long dividend,long divisor,String unit){\r\n    if (dividend == 0 || dividend < divisor)\r\n        return dividend;\r\n    builder.append(dividend / divisor).append(unit);\r\n    return dividend % divisor;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.hscglib.GeneratorParametersTransformer.isGeneratorStrategy",
	"Comment": "determines if a class is a cglib generatorstrategy subclass",
	"Method": "boolean isGeneratorStrategy(CtClass cc){\r\n    String[] interfaces = cc.getClassFile2().getInterfaces();\r\n    for (String interfaceName : interfaces) {\r\n        if (interfaceName.endsWith(\".GeneratorStrategy\")) {\r\n            @SuppressWarnings(\"unchecked\")\r\n            List<MethodInfo> methodInfos = cc.getClassFile2().getMethods();\r\n            for (MethodInfo method : methodInfos) {\r\n                if (method.getName().equals(\"generate\") && method.getDescriptor().endsWith(\"[B\")) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jabref.gui.fieldeditors.contextmenu.EditorMenus.getDefaultMenu",
	"Comment": "the default menu that contains functions for changing the case of text and doing several conversions.",
	"Method": "Supplier<List<MenuItem>> getDefaultMenu(TextInputControl textInput){\r\n    return () -> {\r\n        List<MenuItem> menuItems = new ArrayList(6);\r\n        menuItems.add(new CaseChangeMenu(textInput.textProperty()));\r\n        menuItems.add(new ConversionMenu(textInput.textProperty()));\r\n        menuItems.add(new SeparatorMenuItem());\r\n        menuItems.add(new ProtectedTermsMenu(textInput));\r\n        menuItems.add(new SeparatorMenuItem());\r\n        menuItems.add(new ClearField(textInput));\r\n        return menuItems;\r\n    };\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.CollectionUtils.findCommonElementType",
	"Comment": "find the common element type of the given collection, if any.",
	"Method": "Class<?> findCommonElementType(Collection<?> collection){\r\n    if (isEmpty(collection)) {\r\n        return null;\r\n    }\r\n    Class<?> candidate = null;\r\n    for (Object val : collection) {\r\n        if (val != null) {\r\n            if (candidate == null) {\r\n                candidate = val.getClass();\r\n            } else if (candidate != val.getClass()) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    return candidate;\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolTest.should_resurrect_trashed_connection_within_idle_timeout",
	"Comment": "ensures that a trashed connection that has not been timed out should be resurrected into theconnection pool if borrowconnection is called and a new connection is needed.",
	"Method": "void should_resurrect_trashed_connection_within_idle_timeout(){\r\n    Cluster cluster = createClusterBuilder().withPoolingOptions(new PoolingOptions().setIdleTimeoutSeconds(20)).build();\r\n    List<MockRequest> allRequests = newArrayList();\r\n    try {\r\n        HostConnectionPool pool = createPool(cluster, 1, 2);\r\n        Connection.Factory factory = spy(cluster.manager.connectionFactory);\r\n        cluster.manager.connectionFactory = factory;\r\n        Connection connection1 = pool.connections.get(0);\r\n        List<MockRequest> requests = MockRequest.sendMany(NEW_CONNECTION_THRESHOLD, pool);\r\n        assertBorrowedConnections(requests, Collections.singletonList(connection1));\r\n        allRequests.addAll(requests);\r\n        allRequests.add(MockRequest.send(pool));\r\n        verify(factory, after(2000).times(1)).open(any(HostConnectionPool.class));\r\n        assertPoolSize(pool, 2);\r\n        Connection connection2 = pool.connections.get(1);\r\n        assertThat(connection1.inFlight.get()).isEqualTo(101);\r\n        assertThat(connection2.inFlight.get()).isEqualTo(0);\r\n        MockRequest.completeMany(51, allRequests);\r\n        assertThat(connection1.inFlight.get()).isEqualTo(50);\r\n        assertThat(connection2.inFlight.get()).isEqualTo(0);\r\n        Uninterruptibles.sleepUninterruptibly(20, TimeUnit.SECONDS);\r\n        assertThat(pool.connections).containsExactly(connection2);\r\n        assertThat(pool.trash).containsExactly(connection1);\r\n        allRequests.addAll(MockRequest.sendMany(50, pool));\r\n        assertThat(pool.connections).containsExactly(connection2);\r\n        assertThat(pool.trash).containsExactly(connection1);\r\n        assertThat(connection1.inFlight.get()).isEqualTo(50);\r\n        assertThat(connection2.inFlight.get()).isEqualTo(50);\r\n        allRequests.addAll(MockRequest.sendMany(1, pool));\r\n        verify(factory, after(2000).times(1)).open(any(HostConnectionPool.class));\r\n        assertPoolSize(pool, 2);\r\n        assertThat(pool.connections).containsExactly(connection2, connection1);\r\n        assertThat(pool.trash).isEmpty();\r\n        assertThat(connection1.inFlight.get()).isEqualTo(50);\r\n        assertThat(connection2.inFlight.get()).isEqualTo(51);\r\n    } finally {\r\n        MockRequest.completeAll(allRequests);\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.jdbi.v3.core.Handle.setReadOnly",
	"Comment": "set the handle readonly.this acts as a hint to the database to improve performance or concurrency.may not be called in an active transaction!",
	"Method": "Handle setReadOnly(boolean readOnly){\r\n    try {\r\n        connection.setReadOnly(readOnly);\r\n    } catch (SQLException e) {\r\n        throw new UnableToManipulateTransactionIsolationLevelException(\"Could not setReadOnly\", e);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.signature.ClassSignatureBase.addSignatureElements",
	"Comment": "adds the signature elements to set of used signature elements",
	"Method": "void addSignatureElements(ClassSignatureElement elems){\r\n    for (ClassSignatureElement element : elems) {\r\n        elements.add(element);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.openoffice.OOBibStyle.reload",
	"Comment": "if this style was initialized from a file on disk, reload the styleinformation.",
	"Method": "void reload(){\r\n    if (styleFile != null) {\r\n        this.styleFileModificationTime = styleFile.lastModified();\r\n        try (InputStream stream = new FileInputStream(styleFile)) {\r\n            initialize(stream);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.UrlResource.hashCode",
	"Comment": "this implementation returns the hash code of the underlying urlreference.",
	"Method": "int hashCode(){\r\n    return this.cleanedUrl.hashCode();\r\n}"
}, {
	"Path": "org.jabref.gui.groups.GroupDialog.getContext",
	"Comment": "returns the int representing the selected hierarchical group context.",
	"Method": "GroupHierarchyType getContext(){\r\n    if (independentButton.isSelected()) {\r\n        return GroupHierarchyType.INDEPENDENT;\r\n    }\r\n    if (intersectionButton.isSelected()) {\r\n        return GroupHierarchyType.REFINING;\r\n    }\r\n    if (unionButton.isSelected()) {\r\n        return GroupHierarchyType.INCLUDING;\r\n    }\r\n    return GroupHierarchyType.INDEPENDENT;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.array.SqlArrayTypes.register",
	"Comment": "register an array element type that is supported by the jdbc vendor.",
	"Method": "SqlArrayTypes register(Class<?> elementType,String sqlTypeName,SqlArrayTypes register,SqlArrayType<?> arrayType,SqlArrayTypes register,SqlArrayTypeFactory factory){\r\n    factories.add(0, factory);\r\n    return this;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ClassUtils.isAssignableValue",
	"Comment": "determine if the given type is assignable from the given value, assumingsetting by reflection. considers primitive wrapper classes as assignableto the corresponding primitive types.",
	"Method": "boolean isAssignableValue(Class<?> type,Object value){\r\n    Assert.notNull(type, \"Type must not be null\");\r\n    return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\r\n}"
}, {
	"Path": "com.datastax.driver.core.ColumnDefinitions.asList",
	"Comment": "returns a list containing all the definitions of this metadata in order.",
	"Method": "List<Definition> asList(){\r\n    return Arrays.asList(byIdx);\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiletype.ExternalFileTypeEditor.getAction",
	"Comment": "get an abstractaction for opening the external file types editor.",
	"Method": "AbstractAction getAction(){\r\n    return new EditExternalFileTypesAction();\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ObjectUtils.isCompatibleWithThrowsClause",
	"Comment": "check whether the given exception is compatible with the specifiedexception types, as declared in a throws clause.",
	"Method": "boolean isCompatibleWithThrowsClause(Throwable ex,Class<?> declaredExceptions){\r\n    if (!isCheckedException(ex)) {\r\n        return true;\r\n    }\r\n    if (declaredExceptions != null) {\r\n        for (Class<?> declaredException : declaredExceptions) {\r\n            if (declaredException.isInstance(ex)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.AbstractProxyBytecodeTransformer.addStaticInitStateField",
	"Comment": "adds a static boolean field to the class indicating the state of initialization",
	"Method": "void addStaticInitStateField(CtClass cc,String clinitFieldName){\r\n    CtField f = new CtField(CtClass.booleanType, clinitFieldName, cc);\r\n    f.setModifiers(Modifier.PRIVATE | Modifier.STATIC);\r\n    cc.addField(f, \"true\");\r\n}"
}, {
	"Path": "org.jabref.model.TreeNode.getPositionInParent",
	"Comment": "get the child index of this node in its parent.if this node is a root, then an unsupportedoperationexception is thrown.use the isroot method to check for this case.",
	"Method": "int getPositionInParent(){\r\n    return getParent().orElseThrow(() -> new UnsupportedOperationException(\"Roots have no position in parent\")).getIndexOfChild((T) this).get();\r\n}"
}, {
	"Path": "com.datastax.driver.core.ThreadingOptions.createReaperExecutor",
	"Comment": "builds the executor for an internal maintenance task used to clean up closed connections.a single scheduled task runs on this executor, so there is no reason to use more than onethread.",
	"Method": "ScheduledExecutorService createReaperExecutor(String clusterName){\r\n    return new ScheduledThreadPoolExecutor(1, createThreadFactory(clusterName, \"connection-reaper\"));\r\n}"
}, {
	"Path": "com.datastax.driver.core.querybuilder.Update.where",
	"Comment": "returns a where statement for this query without adding clause.",
	"Method": "Where where(Clause clause,Where where,Where where,Clause clause,Where where,Clause clause,Where where,Clause clause){\r\n    return where;\r\n}"
}, {
	"Path": "com.datastax.driver.core.exceptions.ExceptionsTest.driverInternalError",
	"Comment": "tests driverinternalerror. tests basic message, rethrow, and copy abilities.",
	"Method": "void driverInternalError(){\r\n    String errorMessage = \"Test Message\";\r\n    try {\r\n        throw new DriverInternalError(errorMessage);\r\n    } catch (DriverInternalError e1) {\r\n        try {\r\n            throw new DriverInternalError(e1);\r\n        } catch (DriverInternalError e2) {\r\n            assertTrue(e2.getMessage().contains(errorMessage));\r\n            DriverInternalError copy = (DriverInternalError) e2.copy();\r\n            assertEquals(copy.getMessage(), e2.getMessage());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.PoolingOptions.getMaxQueueSize",
	"Comment": "returns the maximum number of requests that get enqueued if no connection is available.",
	"Method": "int getMaxQueueSize(){\r\n    return maxQueueSize;\r\n}"
}, {
	"Path": "com.datastax.driver.core.querybuilder.QueryBuilder.token",
	"Comment": "the token of column names.this variant is most useful when the partition key is composite.",
	"Method": "String token(String columnName,String token,String columnNames,Object token,Object values){\r\n    return new Utils.FCall(\"token\", values);\r\n}"
}, {
	"Path": "org.elixir_lang.parser.ElixirParser.unmatchedDotCall_0",
	"Comment": "dotinfixoperator parenthesesarguments parenthesesarguments? doblockmaybe",
	"Method": "boolean unmatchedDotCall_0(PsiBuilder b,int l){\r\n    if (!recursion_guard_(b, l, \"unmatchedDotCall_0\"))\r\n        return false;\r\n    boolean r;\r\n    Marker m = enter_section_(b);\r\n    r = dotInfixOperator(b, l + 1);\r\n    r = r && parenthesesArguments(b, l + 1);\r\n    r = r && unmatchedDotCall_0_2(b, l + 1);\r\n    r = r && doBlockMaybe(b, l + 1);\r\n    exit_section_(b, m, null, r);\r\n    return r;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.jersey1.Jersey1Plugin.invalidate",
	"Comment": "call reload on the jersey application when any class changes that is either involved in configuringthe jersey application, or if was newly annotated and will be involved in configuring the application.",
	"Method": "void invalidate(CtClass ctClass,Class original){\r\n    if (allRegisteredClasses.contains(original)) {\r\n        scheduler.scheduleCommand(reloadJerseyContainers);\r\n    } else {\r\n        if (AnnotationHelper.hasAnnotation(original, \"javax.ws.rs.Path\") || AnnotationHelper.hasAnnotation(ctClass, \"javax.ws.rs.Path\")) {\r\n            allRegisteredClasses.add(original);\r\n            scheduler.scheduleCommand(reloadJerseyContainers);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.FileSystemResource.getDescription",
	"Comment": "this implementation returns a description that includes the absolute pathof the file.",
	"Method": "String getDescription(){\r\n    return \"file [\" + this.file.getAbsolutePath() + \"]\";\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.deltaspike.transformer.ViewConfigTransformer.patchViewConfigExtension",
	"Comment": "register deltaspikeplugin and add reinitialization method to repositorycomponent",
	"Method": "void patchViewConfigExtension(CtClass ctClass,ClassPool classPool){\r\n    CtMethod init = ctClass.getDeclaredMethod(\"init\");\r\n    init.insertAfter(\"{\" + \"if (this.isActivated) {\" + PluginManagerInvoker.buildInitializePlugin(DeltaSpikePlugin.class) + \"}\" + \"}\");\r\n    LOGGER.debug(\"org.apache.deltaspike.jsf.impl.config.view.ViewConfigExtension enhanced with plugin initialization.\");\r\n    CtClass viewConfigResProxyClass = classPool.get(\"org.hotswap.agent.plugin.deltaspike.jsf.ViewConfigResolverProxy\");\r\n    CtField viewConfigResProxyField = new CtField(viewConfigResProxyClass, VIEW_CONFIG_RESOLVER_PROXY_FIELD, ctClass);\r\n    ctClass.addField(viewConfigResProxyField);\r\n    CtMethod generateProxyClassMethod = ctClass.getDeclaredMethod(\"transformMetaDataTree\");\r\n    generateProxyClassMethod.instrument(new ExprEditor() {\r\n        public void edit(NewExpr e) throws CannotCompileException {\r\n            if (e.getClassName().equals(\"org.apache.deltaspike.jsf.impl.config.view.DefaultViewConfigResolver\"))\r\n                e.replace(\"{ \" + \"java.lang.Object _resolver = new org.apache.deltaspike.jsf.impl.config.view.DefaultViewConfigResolver($$); \" + \"if (this.\" + VIEW_CONFIG_RESOLVER_PROXY_FIELD + \"==null) {\" + \"this.\" + VIEW_CONFIG_RESOLVER_PROXY_FIELD + \"=new org.hotswap.agent.plugin.deltaspike.jsf.ViewConfigResolverProxy();\" + \"}\" + \"this.\" + VIEW_CONFIG_RESOLVER_PROXY_FIELD + \".setViewConfigResolver(_resolver);\" + \"java.util.List _list = org.hotswap.agent.plugin.deltaspike.jsf.ViewConfigResolverUtils.findViewConfigRootClasses(this.rootViewConfigNode);\" + PluginManagerInvoker.buildCallPluginMethod(DeltaSpikePlugin.class, \"registerViewConfigRootClasses\", \"this\", \"java.lang.Object\", \"_list\", \"java.util.List\") + \"   $_ = this.\" + VIEW_CONFIG_RESOLVER_PROXY_FIELD + \";\" + \"}\");\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.deltaspike.transformer.ViewConfigTransformer.patchViewConfigExtension",
	"Comment": "register deltaspikeplugin and add reinitialization method to repositorycomponent",
	"Method": "void patchViewConfigExtension(CtClass ctClass,ClassPool classPool){\r\n    if (e.getClassName().equals(\"org.apache.deltaspike.jsf.impl.config.view.DefaultViewConfigResolver\"))\r\n        e.replace(\"{ \" + \"java.lang.Object _resolver = new org.apache.deltaspike.jsf.impl.config.view.DefaultViewConfigResolver($$); \" + \"if (this.\" + VIEW_CONFIG_RESOLVER_PROXY_FIELD + \"==null) {\" + \"this.\" + VIEW_CONFIG_RESOLVER_PROXY_FIELD + \"=new org.hotswap.agent.plugin.deltaspike.jsf.ViewConfigResolverProxy();\" + \"}\" + \"this.\" + VIEW_CONFIG_RESOLVER_PROXY_FIELD + \".setViewConfigResolver(_resolver);\" + \"java.util.List _list = org.hotswap.agent.plugin.deltaspike.jsf.ViewConfigResolverUtils.findViewConfigRootClasses(this.rootViewConfigNode);\" + PluginManagerInvoker.buildCallPluginMethod(DeltaSpikePlugin.class, \"registerViewConfigRootClasses\", \"this\", \"java.lang.Object\", \"_list\", \"java.util.List\") + \"   $_ = this.\" + VIEW_CONFIG_RESOLVER_PROXY_FIELD + \";\" + \"}\");\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiletype.ExternalFileTypes.setExternalFileTypes",
	"Comment": "reset the list of external file types after user customization.",
	"Method": "void setExternalFileTypes(List<ExternalFileType> types){\r\n    List<ExternalFileType> defTypes = new ArrayList(getDefaultExternalFileTypes());\r\n    List<ExternalFileType> unchanged = new ArrayList();\r\n    externalFileTypes.clear();\r\n    for (ExternalFileType type : types) {\r\n        externalFileTypes.add(type);\r\n        ExternalFileType found = null;\r\n        for (ExternalFileType defType : defTypes) {\r\n            if (defType.getName().equals(type.getName())) {\r\n                found = defType;\r\n                break;\r\n            }\r\n        }\r\n        if (found != null) {\r\n            if (found.equals(type)) {\r\n                unchanged.add(type);\r\n            } else {\r\n                defTypes.remove(found);\r\n            }\r\n        }\r\n    }\r\n    for (ExternalFileType type : unchanged) {\r\n        defTypes.remove(type);\r\n        types.remove(type);\r\n    }\r\n    String[][] array = new String[types.size() + defTypes.size()][];\r\n    int i = 0;\r\n    for (ExternalFileType type : types) {\r\n        array[i] = getStringArrayRepresentation(type);\r\n        i++;\r\n    }\r\n    for (ExternalFileType type : defTypes) {\r\n        array[i] = new String[] { type.getName(), FILE_TYPE_REMOVED_FLAG };\r\n        i++;\r\n    }\r\n    Globals.prefs.put(JabRefPreferences.EXTERNAL_FILE_TYPES, FileFieldWriter.encodeStringArray(array));\r\n}"
}, {
	"Path": "org.jabref.logic.bst.BibtexNameFormatter.formatName",
	"Comment": "formats the nth author of the author name list by a given format string",
	"Method": "String formatName(String authorsNameList,int whichName,String formatString,Warn warn,String formatName,Author author,String format,Warn warn){\r\n    StringBuilder sb = new StringBuilder();\r\n    char[] c = format.toCharArray();\r\n    int n = c.length;\r\n    int braceLevel = 0;\r\n    int group = 0;\r\n    int i = 0;\r\n    while (i < n) {\r\n        if (c[i] == '{') {\r\n            group++;\r\n            i++;\r\n            braceLevel++;\r\n            StringBuilder level1Chars = new StringBuilder();\r\n            StringBuilder wholeChar = new StringBuilder();\r\n            while ((i < n) && (braceLevel > 0)) {\r\n                wholeChar.append(c[i]);\r\n                if (c[i] == '{') {\r\n                    braceLevel++;\r\n                    i++;\r\n                    continue;\r\n                }\r\n                if (c[i] == '}') {\r\n                    braceLevel--;\r\n                    i++;\r\n                    continue;\r\n                }\r\n                if ((braceLevel == 1) && Character.isLetter(c[i])) {\r\n                    if (\"fvlj\".indexOf(c[i]) == -1) {\r\n                        if (warn != null) {\r\n                            warn.warn(\"Format string in format.name$ may only contain fvlj on brace level 1 in group \" + group + \": \" + format);\r\n                        }\r\n                    } else {\r\n                        level1Chars.append(c[i]);\r\n                    }\r\n                }\r\n                i++;\r\n            }\r\n            i--;\r\n            String control = level1Chars.toString().toLowerCase(Locale.ROOT);\r\n            if (control.isEmpty()) {\r\n                continue;\r\n            }\r\n            if ((control.length() > 2) && (warn != null)) {\r\n                warn.warn(\"Format string in format.name$ may only be one or two character long on brace level 1 in group \" + group + \": \" + format);\r\n            }\r\n            char type = control.charAt(0);\r\n            Optional<String> tokenS;\r\n            switch(type) {\r\n                case 'f':\r\n                    tokenS = author.getFirst();\r\n                    break;\r\n                case 'v':\r\n                    tokenS = author.getVon();\r\n                    break;\r\n                case 'l':\r\n                    tokenS = author.getLast();\r\n                    break;\r\n                case 'j':\r\n                    tokenS = author.getJr();\r\n                    break;\r\n                default:\r\n                    throw new VMException(\"Internal error\");\r\n            }\r\n            if (!tokenS.isPresent()) {\r\n                i++;\r\n                continue;\r\n            }\r\n            String[] tokens = tokenS.get().split(\" \");\r\n            boolean abbreviateThatIsSingleLetter = true;\r\n            if (control.length() == 2) {\r\n                if (control.charAt(1) == control.charAt(0)) {\r\n                    abbreviateThatIsSingleLetter = false;\r\n                } else {\r\n                    if (warn != null) {\r\n                        warn.warn(\"Format string in format.name$ may only contain one type of vlfj on brace level 1 in group \" + group + \": \" + format);\r\n                    }\r\n                }\r\n            }\r\n            if ((braceLevel == 0) && (wholeChar.charAt(wholeChar.length() - 1) == '}')) {\r\n                wholeChar.deleteCharAt(wholeChar.length() - 1);\r\n            }\r\n            char[] d = wholeChar.toString().toCharArray();\r\n            int bLevel = 1;\r\n            String interToken = null;\r\n            int groupStart = sb.length();\r\n            for (int j = 0; j < d.length; j++) {\r\n                if (Character.isLetter(d[j]) && (bLevel == 1)) {\r\n                    groupStart = sb.length();\r\n                    if (!abbreviateThatIsSingleLetter) {\r\n                        j++;\r\n                    }\r\n                    if (((j + 1) < d.length) && (d[j + 1] == '{')) {\r\n                        StringBuilder interTokenSb = new StringBuilder();\r\n                        j = BibtexNameFormatter.consumeToMatchingBrace(interTokenSb, d, j + 1);\r\n                        interToken = interTokenSb.substring(1, interTokenSb.length() - 1);\r\n                    }\r\n                    for (int k = 0; k < tokens.length; k++) {\r\n                        String token = tokens[k];\r\n                        if (abbreviateThatIsSingleLetter) {\r\n                            String[] dashes = token.split(\"-\");\r\n                            token = Arrays.asList(dashes).stream().map(BibtexNameFormatter::getFirstCharOfString).collect(Collectors.joining(\".-\"));\r\n                        }\r\n                        sb.append(token);\r\n                        if (k < (tokens.length - 1)) {\r\n                            if (interToken == null) {\r\n                                if (abbreviateThatIsSingleLetter) {\r\n                                    sb.append('.');\r\n                                }\r\n                                if ((k == (tokens.length - 2)) || (BibtexNameFormatter.numberOfChars(sb.substring(groupStart, sb.length()), 3) < 3)) {\r\n                                    sb.append('~');\r\n                                } else {\r\n                                    sb.append(' ');\r\n                                }\r\n                            } else {\r\n                                sb.append(interToken);\r\n                            }\r\n                        }\r\n                    }\r\n                } else if (d[j] == '}') {\r\n                    bLevel--;\r\n                    if (bLevel > 0) {\r\n                        sb.append('}');\r\n                    }\r\n                } else if (d[j] == '{') {\r\n                    bLevel++;\r\n                    sb.append('{');\r\n                } else {\r\n                    sb.append(d[j]);\r\n                }\r\n            }\r\n            if (sb.length() > 0) {\r\n                boolean noDisTie = false;\r\n                if ((sb.charAt(sb.length() - 1) == '~') && ((BibtexNameFormatter.numberOfChars(sb.substring(groupStart, sb.length()), 4) >= 4) || ((sb.length() > 1) && (noDisTie = sb.charAt(sb.length() - 2) == '~')))) {\r\n                    sb.deleteCharAt(sb.length() - 1);\r\n                    if (!noDisTie) {\r\n                        sb.append(' ');\r\n                    }\r\n                }\r\n            }\r\n        } else if (c[i] == '}') {\r\n            if (warn != null) {\r\n                warn.warn(\"Unmatched brace in format string: \" + format);\r\n            }\r\n        } else {\r\n            sb.append(c[i]);\r\n        }\r\n        i++;\r\n    }\r\n    if ((braceLevel != 0) && (warn != null)) {\r\n        warn.warn(\"Unbalanced brace in format string for nameFormat: \" + format);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.hotswap.agent.util.classloader.WatchResourcesClassLoader.isResourceChanged",
	"Comment": "check if the resource was changed after this classloader instantiaton.",
	"Method": "boolean isResourceChanged(URL url){\r\n    return changedUrls.contains(url);\r\n}"
}, {
	"Path": "org.menacheri.jetclient.app.impl.DefaultSession.isUDPEnabled",
	"Comment": "not synchronized because default implementation does not care whether a\tduplicated message sender is created.",
	"Method": "SessionBuilder isUDPEnabled(boolean isUDPEnabled,boolean isUDPEnabled){\r\n    return isUDPEnabled;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.web.Viewer.findClass",
	"Comment": "finds the specified class.the implementation in this classfetches the class from the http server.if the class iseither java., javax., orviewer, then it is loaded by the parent classloader.this method can be overridden by a subclass ofviewer.",
	"Method": "Class<?> findClass(String name){\r\n    Class<?> c = null;\r\n    if (name.startsWith(\"java.\") || name.startsWith(\"javax.\") || name.equals(\"javassist.tools.web.Viewer\"))\r\n        c = findSystemClass(name);\r\n    if (c == null)\r\n        try {\r\n            byte[] b = fetchClass(name);\r\n            if (b != null)\r\n                c = defineClass(name, b, 0, b.length);\r\n        } catch (Exception e) {\r\n        }\r\n    return c;\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.AbstractCreateStatement.addUDTSetColumn",
	"Comment": "shorthand to add a column definition to this create statement, when the type is a set of udt.",
	"Method": "T addUDTSetColumn(String columnName,UDTType udtType){\r\n    validateNotEmpty(columnName, \"Column name\");\r\n    validateNotNull(udtType, \"Column element type\");\r\n    validateNotKeyWord(columnName, String.format(\"The column name '%s' is not allowed because it is a reserved keyword\", columnName));\r\n    simpleColumns.put(columnName, UDTType.set(udtType));\r\n    return self;\r\n}"
}, {
	"Path": "org.elixir_lang.parser.ElixirParser.maxExpression_2",
	"Comment": "matchedqualifiednoargumentscall maxqualifiedparenthesescall",
	"Method": "boolean maxExpression_2(PsiBuilder b,int l){\r\n    if (!recursion_guard_(b, l, \"maxExpression_2\"))\r\n        return false;\r\n    boolean r;\r\n    Marker m = enter_section_(b);\r\n    r = matchedExpression(b, l + 1, 30);\r\n    r = r && maxQualifiedParenthesesCall(b, l + 1);\r\n    exit_section_(b, m, null, r);\r\n    return r;\r\n}"
}, {
	"Path": "org.jabref.logic.pdf.EntryAnnotationImporter.importAnnotationsFromFiles",
	"Comment": "reads the annotations from the files that are attached to a bibentry.",
	"Method": "Map<Path, List<FileAnnotation>> importAnnotationsFromFiles(BibDatabaseContext databaseContext,FilePreferences filePreferences){\r\n    Map<Path, List<FileAnnotation>> annotations = new HashMap();\r\n    AnnotationImporter importer = new PdfAnnotationImporter();\r\n    for (LinkedFile linkedFile : this.getFilteredFileList()) {\r\n        linkedFile.findIn(databaseContext, filePreferences).ifPresent(file -> annotations.put(file, importer.importAnnotations(file)));\r\n    }\r\n    return annotations;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.CollectionUtils.toArray",
	"Comment": "marshal the elements from the given enumeration into an array of thegiven type. enumeration elements must be assignable to the type of thegiven array. the array returned will be a different instance than thearray given.",
	"Method": "A[] toArray(Enumeration<E> enumeration,A[] array){\r\n    ArrayList<A> elements = new ArrayList<A>();\r\n    while (enumeration.hasMoreElements()) {\r\n        elements.add(enumeration.nextElement());\r\n    }\r\n    return elements.toArray(array);\r\n}"
}, {
	"Path": "com.datastax.driver.core.BoundStatement.preparedStatement",
	"Comment": "returns the prepared statement on which this boundstatement is based.",
	"Method": "PreparedStatement preparedStatement(){\r\n    return statement;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.UrlResource.equals",
	"Comment": "this implementation compares the underlying url references.",
	"Method": "boolean equals(Object obj){\r\n    return (obj == this || (obj instanceof UrlResource && this.cleanedUrl.equals(((UrlResource) obj).cleanedUrl)));\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.AbstractResource.createRelative",
	"Comment": "this implementation throws a filenotfoundexception, assuming thatrelative resources cannot be created for this resource.",
	"Method": "Resource createRelative(String relativePath){\r\n    throw new FileNotFoundException(\"Cannot create a relative resource for \" + getDescription());\r\n}"
}, {
	"Path": "org.elixir_lang.parser.ElixirParser.matchedDotCall_0",
	"Comment": "dotinfixoperator parenthesesarguments parenthesesarguments?",
	"Method": "boolean matchedDotCall_0(PsiBuilder b,int l){\r\n    if (!recursion_guard_(b, l, \"matchedDotCall_0\"))\r\n        return false;\r\n    boolean r;\r\n    Marker m = enter_section_(b);\r\n    r = dotInfixOperator(b, l + 1);\r\n    r = r && parenthesesArguments(b, l + 1);\r\n    r = r && matchedDotCall_0_2(b, l + 1);\r\n    exit_section_(b, m, null, r);\r\n    return r;\r\n}"
}, {
	"Path": "com.datastax.driver.core.DataType.custom",
	"Comment": "returns a custom type.a custom type is defined by the name of the class used on the cassandra side to implementit. note that the support for custom types by the driver is limited.the use of custom types is rarely useful and is thus not encouraged.",
	"Method": "DataType.CustomType custom(String typeClassName){\r\n    if (typeClassName == null)\r\n        throw new NullPointerException();\r\n    return new DataType.CustomType(Name.CUSTOM, typeClassName);\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiletype.ExternalFileTypes.isExternalFileTypeByExt",
	"Comment": "returns true if there is an external file type registered for this extension.",
	"Method": "boolean isExternalFileTypeByExt(String extension){\r\n    return externalFileTypes.stream().anyMatch(type -> type.getExtension().equalsIgnoreCase(extension));\r\n}"
}, {
	"Path": "com.datastax.driver.core.Metrics.getRequestQueueDepth",
	"Comment": "returns the total number of enqueued requests on all cassandra hosts.",
	"Method": "Gauge<Integer> getRequestQueueDepth(){\r\n    return requestQueueDepth;\r\n}"
}, {
	"Path": "me.ramswaroop.jbot.core.common.BaseBot.formConversationQueue",
	"Comment": "form a queue with all the methods responsible for a particular conversation.",
	"Method": "Queue<MethodWrapper> formConversationQueue(Queue<MethodWrapper> queue,String methodName){\r\n    MethodWrapper methodWrapper = methodNameMap.get(methodName);\r\n    queue.add(methodWrapper);\r\n    if (StringUtils.isEmpty(methodName)) {\r\n        return queue;\r\n    } else {\r\n        return formConversationQueue(queue, methodWrapper.getNext());\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.java.ProxyGenerator.codeClassForName",
	"Comment": "generate code to invoke the class.forname with the name of the given class to get its class object at runtime.the code is written to the supplied stream. note that the code generated by this method may caused the checkedclassnotfoundexception to be thrown.",
	"Method": "void codeClassForName(Class<?> cl,DataOutputStream out){\r\n    code_ldc(cp.getString(cl.getName()), out);\r\n    out.writeByte(opc_invokestatic);\r\n    out.writeShort(cp.getMethodRef(\"java/lang/Class\", \"forName\", \"(Ljava/lang/String;)Ljava/lang/Class;\"));\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.FileSystemResource.exists",
	"Comment": "this implementation returns whether the underlying file exists.",
	"Method": "boolean exists(){\r\n    return this.file.exists();\r\n}"
}, {
	"Path": "org.jabref.gui.util.TooltipTextUtil.formatToTexts",
	"Comment": "formats a string to multiple texts by replacing some parts and adding font characteristics.",
	"Method": "List<Text> formatToTexts(String original,TextReplacement replacements){\r\n    List<Text> textList = new ArrayList();\r\n    textList.add(new Text(original));\r\n    for (TextReplacement replacement : replacements) {\r\n        splitReplace(textList, replacement);\r\n    }\r\n    return textList;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.java.ProxyGenerator.checkReturnTypes",
	"Comment": "for a given set of proxy methods with the same signature, check that their return types are compatible accordingto the proxy specification.specifically, if there is more than one such method, then all of the return types must be reference types, andthere must be one return type that is assignable to each of the rest of them.",
	"Method": "void checkReturnTypes(List<ProxyMethod> methods){\r\n    if (methods.size() < 2) {\r\n        return;\r\n    }\r\n    LinkedList<Class<?>> uncoveredReturnTypes = new LinkedList();\r\n    nextNewReturnType: for (ProxyMethod pm : methods) {\r\n        Class<?> newReturnType = pm.returnType;\r\n        if (newReturnType.isPrimitive()) {\r\n            throw new IllegalArgumentException(\"methods with same signature \" + getFriendlyMethodSignature(pm.methodName, pm.parameterTypes) + \" but incompatible return types: \" + newReturnType.getName() + \" and others\");\r\n        }\r\n        boolean added = false;\r\n        ListIterator<Class<?>> liter = uncoveredReturnTypes.listIterator();\r\n        while (liter.hasNext()) {\r\n            Class<?> uncoveredReturnType = liter.next();\r\n            if (newReturnType.isAssignableFrom(uncoveredReturnType)) {\r\n                assert !added;\r\n                continue nextNewReturnType;\r\n            }\r\n            if (uncoveredReturnType.isAssignableFrom(newReturnType)) {\r\n                if (!added) {\r\n                    liter.set(newReturnType);\r\n                    added = true;\r\n                } else {\r\n                    liter.remove();\r\n                }\r\n            }\r\n        }\r\n        if (!added) {\r\n            uncoveredReturnTypes.add(newReturnType);\r\n        }\r\n    }\r\n    if (uncoveredReturnTypes.size() > 1) {\r\n        ProxyMethod pm = methods.get(0);\r\n        throw new IllegalArgumentException(\"methods with same signature \" + getFriendlyMethodSignature(pm.methodName, pm.parameterTypes) + \" but incompatible return types: \" + uncoveredReturnTypes);\r\n    }\r\n}"
}, {
	"Path": "org.menacheri.jetclient.util.NettyUtils.readString",
	"Comment": "read a string from a channel buffer with the specified length. it resets\tthe reader index of the buffer to the end of the string.",
	"Method": "String readString(ChannelBuffer buffer,String readString,ChannelBuffer buffer,Charset charset,String readString,ChannelBuffer buffer,int length,String readString,ChannelBuffer buffer,int length,Charset charset){\r\n    String str = null;\r\n    if (null == charset) {\r\n        charset = CharsetUtil.UTF_8;\r\n    }\r\n    try {\r\n        ChannelBuffer stringBuffer = buffer.readSlice(length);\r\n        str = stringBuffer.toString(charset);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    return str;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.Jdbi.useHandle",
	"Comment": "a convenience function which manages the lifecycle of a handle and yields it to a callbackfor use by clients.",
	"Method": "void useHandle(HandleConsumer<X> callback){\r\n    withHandle(h -> {\r\n        callback.useHandle(h);\r\n        return null;\r\n    });\r\n}"
}, {
	"Path": "org.jabref.logic.bibtex.BibEntryWriter.writeRequiredFieldsFirstRemainingFieldsSecond",
	"Comment": "write fields in the order of requiredfields, optionalfields and other fields, but does not sort the fields.",
	"Method": "void writeRequiredFieldsFirstRemainingFieldsSecond(BibEntry entry,Writer out,BibDatabaseMode bibDatabaseMode){\r\n    TypedBibEntry typedEntry = new TypedBibEntry(entry, bibDatabaseMode);\r\n    out.write('@' + typedEntry.getTypeForDisplay() + '{');\r\n    writeKeyField(entry, out);\r\n    Set<String> written = new HashSet();\r\n    written.add(BibEntry.KEY_FIELD);\r\n    int indentation = getLengthOfLongestFieldName(entry);\r\n    EntryType type = EntryTypes.getTypeOrDefault(entry.getType(), bibDatabaseMode);\r\n    Collection<String> fields = type.getRequiredFieldsFlat();\r\n    if (fields != null) {\r\n        for (String value : fields) {\r\n            writeField(entry, out, value, indentation);\r\n            written.add(value);\r\n        }\r\n    }\r\n    fields = type.getOptionalFields();\r\n    if (fields != null) {\r\n        for (String value : fields) {\r\n            if (!written.contains(value)) {\r\n                writeField(entry, out, value, indentation);\r\n                written.add(value);\r\n            }\r\n        }\r\n    }\r\n    Set<String> remainingFields = new TreeSet();\r\n    for (String key : entry.getFieldNames()) {\r\n        boolean writeIt = write ? InternalBibtexFields.isWriteableField(key) : InternalBibtexFields.isDisplayableField(key);\r\n        if (!written.contains(key) && writeIt) {\r\n            remainingFields.add(key);\r\n        }\r\n    }\r\n    for (String field : remainingFields) {\r\n        writeField(entry, out, field, indentation);\r\n    }\r\n    out.write('}');\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.weld.beans.ContextualReloadHelper.addToReloadSet",
	"Comment": "tries to add the bean in the context so it is reloaded in the next activation of the context.",
	"Method": "boolean addToReloadSet(Context ctx,Contextual<Object> managedBean){\r\n    try {\r\n        LOGGER.debug(\"Adding bean in '{}' : {}\", ctx.getClass(), managedBean);\r\n        Field toRedefine = ctx.getClass().getDeclaredField(\"$$ha$toReloadWeld\");\r\n        Set toReload = Set.class.cast(toRedefine.get(ctx));\r\n        if (toReload == null) {\r\n            toReload = new HashSet();\r\n            toRedefine.set(ctx, toReload);\r\n        }\r\n        toReload.add(managedBean);\r\n        return true;\r\n    } catch (Exception e) {\r\n        LOGGER.warning(\"Context {} is not patched. Can not add {} to reload set\", e, ctx, managedBean);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.elixir_lang.errorreport.Submitter.submit",
	"Comment": "this method is called whenever an exception in a plugin code had happened and a user decided to report a problemto the plugin vendor.",
	"Method": "boolean submit(IdeaLoggingEvent[] events,String additionalInfo,Component parentComponent,Consumer<SubmittedReportInfo> consumer){\r\n    final Project project = project(parentComponent);\r\n    ErrorBean errorBean = errorBean(events, additionalInfo);\r\n    Consumer<Boolean> successCallback = successCallback(project, consumer);\r\n    Consumer<Exception> errorCallback = errorCallback(project);\r\n    Task task = new Task(project, errorBean, successCallback, errorCallback);\r\n    run(task, project == null);\r\n    return true;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.Jdbi.withHandle",
	"Comment": "a convenience function which manages the lifecycle of a handle and yields it to a callbackfor use by clients.",
	"Method": "R withHandle(HandleCallback<R, X> callback){\r\n    try (Handle h = this.open()) {\r\n        return callback.withHandle(h);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.tutorial.plugin.PrinterHAPlugin.reloadClass",
	"Comment": "call framework class helloworldservice, typical usage is invalidate caches.",
	"Method": "void reloadClass(CtClass clazz){\r\n    if (isPrintSource(clazz)) {\r\n        scheduler.scheduleCommand(() -> printerService.refresh());\r\n    }\r\n}"
}, {
	"Path": "org.jabref.migrations.PreferencesMigrations.upgradeFaultyEncodingStrings",
	"Comment": "added from jabref 2.11 beta 4 onwards to fix wrong encoding names",
	"Method": "void upgradeFaultyEncodingStrings(JabRefPreferences prefs){\r\n    String defaultEncoding = prefs.get(JabRefPreferences.DEFAULT_ENCODING);\r\n    if (defaultEncoding == null) {\r\n        return;\r\n    }\r\n    Map<String, String> encodingMap = new HashMap();\r\n    encodingMap.put(\"UTF8\", \"UTF-8\");\r\n    encodingMap.put(\"Cp1250\", \"CP1250\");\r\n    encodingMap.put(\"Cp1251\", \"CP1251\");\r\n    encodingMap.put(\"Cp1252\", \"CP1252\");\r\n    encodingMap.put(\"Cp1253\", \"CP1253\");\r\n    encodingMap.put(\"Cp1254\", \"CP1254\");\r\n    encodingMap.put(\"Cp1257\", \"CP1257\");\r\n    encodingMap.put(\"ISO8859_1\", \"ISO8859-1\");\r\n    encodingMap.put(\"ISO8859_2\", \"ISO8859-2\");\r\n    encodingMap.put(\"ISO8859_3\", \"ISO8859-3\");\r\n    encodingMap.put(\"ISO8859_4\", \"ISO8859-4\");\r\n    encodingMap.put(\"ISO8859_5\", \"ISO8859-5\");\r\n    encodingMap.put(\"ISO8859_6\", \"ISO8859-6\");\r\n    encodingMap.put(\"ISO8859_7\", \"ISO8859-7\");\r\n    encodingMap.put(\"ISO8859_8\", \"ISO8859-8\");\r\n    encodingMap.put(\"ISO8859_9\", \"ISO8859-9\");\r\n    encodingMap.put(\"ISO8859_13\", \"ISO8859-13\");\r\n    encodingMap.put(\"ISO8859_15\", \"ISO8859-15\");\r\n    encodingMap.put(\"KOI8_R\", \"KOI8-R\");\r\n    encodingMap.put(\"Big5_HKSCS\", \"Big5-HKSCS\");\r\n    encodingMap.put(\"EUC_JP\", \"EUC-JP\");\r\n    if (encodingMap.containsKey(defaultEncoding)) {\r\n        prefs.put(JabRefPreferences.DEFAULT_ENCODING, encodingMap.get(defaultEncoding));\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.TableOptionsMetadata.getReplicateOnWrite",
	"Comment": "returns whether replicateonwrite is set for this table.this is only meaningful for tables holding counters.",
	"Method": "boolean getReplicateOnWrite(){\r\n    return replicateOnWrite;\r\n}"
}, {
	"Path": "com.datastax.driver.mapping.MapperMaterializedViewTest.should_access_mapped_result",
	"Comment": "validates that an accessor properly maps to a result from a materialized view.",
	"Method": "void should_access_mapped_result(){\r\n    Result<Score> scores = accessor.dailyHigh(\"Coup\", 2015, 6, 2);\r\n    Iterator<Score> iterator = scores.iterator();\r\n    assertThat(iterator.next()).isEqualTo(new Score(\"pcmanus\", \"Coup\", 2015, 6, 2, 2000));\r\n    assertThat(iterator.next()).isEqualTo(new Score(\"tjake\", \"Coup\", 2015, 6, 2, 1000));\r\n    assertThat(scores.isExhausted());\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.StatementContext.findColumnMapperFor",
	"Comment": "obtain a column mapper for the given qualified type in this context.",
	"Method": "Optional<ColumnMapper<T>> findColumnMapperFor(Class<T> type,Optional<ColumnMapper<T>> findColumnMapperFor,GenericType<T> type,Optional<ColumnMapper<?>> findColumnMapperFor,Type type,Optional<ColumnMapper<?>> findColumnMapperFor,QualifiedType type){\r\n    return getConfig(ColumnMappers.class).findFor(type);\r\n}"
}, {
	"Path": "org.jabref.logic.exporter.TemplateExporter.readFormatterFile",
	"Comment": "see if there is a name formatter file bundled with this export format. if so, readall the name formatters so they can be used by the filter layouts.",
	"Method": "void readFormatterFile(){\r\n    File formatterFile = new File(lfFileName + \".formatters\");\r\n    if (formatterFile.exists()) {\r\n        try (Reader in = new FileReader(formatterFile)) {\r\n            StringBuilder sb = new StringBuilder();\r\n            int c;\r\n            while ((c = in.read()) != -1) {\r\n                sb.append((char) c);\r\n            }\r\n            String[] lines = sb.toString().split(\"\\n\");\r\n            for (String line1 : lines) {\r\n                String line = line1.trim();\r\n                if (line.isEmpty()) {\r\n                    continue;\r\n                }\r\n                int index = line.indexOf(':');\r\n                if ((index > 0) && ((index + 1) < line.length())) {\r\n                    String formatterName = line.substring(0, index);\r\n                    String contents = line.substring(index + 1);\r\n                    layoutPreferences.putCustomExportNameFormatter(formatterName, contents);\r\n                }\r\n            }\r\n        } catch (IOException ex) {\r\n            LOGGER.warn(\"Problem opening formatter file.\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.citationstyle.CitationStyleCache.getCitationFor",
	"Comment": "returns the citation for the given bibentry and the set citationstyle",
	"Method": "String getCitationFor(BibEntry entry){\r\n    return citationStyleCache.getUnchecked(entry);\r\n}"
}, {
	"Path": "org.elixir_lang.parser.ElixirParser.unmatchedQualifiedParenthesesCall_0",
	"Comment": "dotinfixoperator relativeidentifier matchedparenthesesarguments doblockmaybe",
	"Method": "boolean unmatchedQualifiedParenthesesCall_0(PsiBuilder b,int l){\r\n    if (!recursion_guard_(b, l, \"unmatchedQualifiedParenthesesCall_0\"))\r\n        return false;\r\n    boolean r;\r\n    Marker m = enter_section_(b);\r\n    r = dotInfixOperator(b, l + 1);\r\n    r = r && relativeIdentifier(b, l + 1);\r\n    r = r && matchedParenthesesArguments(b, l + 1);\r\n    r = r && doBlockMaybe(b, l + 1);\r\n    exit_section_(b, m, null, r);\r\n    return r;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.scanner.ClassPathScanner.scanJar",
	"Comment": "scan jar file for all entries.resolve the jar file itself and than iterate all entries and call visitor.",
	"Method": "void scanJar(String urlFile,ScannerVisitor visitor){\r\n    LOGGER.trace(\"Scanning JAR file '{}'\", urlFile);\r\n    int separatorIndex = urlFile.indexOf(JAR_URL_SEPARATOR);\r\n    JarFile jarFile = null;\r\n    String rootEntryPath;\r\n    try {\r\n        if (separatorIndex != -1) {\r\n            String jarFileUrl = urlFile.substring(0, separatorIndex);\r\n            rootEntryPath = urlFile.substring(separatorIndex + JAR_URL_SEPARATOR.length());\r\n            jarFile = getJarFile(jarFileUrl);\r\n        } else {\r\n            rootEntryPath = \"\";\r\n            jarFile = new JarFile(urlFile);\r\n        }\r\n        if (!\"\".equals(rootEntryPath) && !rootEntryPath.endsWith(\"/\")) {\r\n            rootEntryPath = rootEntryPath + \"/\";\r\n        }\r\n        for (Enumeration<JarEntry> entries = jarFile.entries(); entries.hasMoreElements(); ) {\r\n            JarEntry entry = entries.nextElement();\r\n            String entryPath = entry.getName();\r\n            if (entryPath.startsWith(rootEntryPath) && entryPath.endsWith(\".class\")) {\r\n                LOGGER.trace(\"Visiting JAR entry {}\", entryPath);\r\n                visitor.visit(jarFile.getInputStream(entry));\r\n            }\r\n        }\r\n    } finally {\r\n        if (jarFile != null) {\r\n            jarFile.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.Metrics.getOpenConnections",
	"Comment": "returns the total number of currently opened connections to cassandra hosts.",
	"Method": "Gauge<Integer> getOpenConnections(){\r\n    return openConnections;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.util.proxy.RuntimeSupport.findSuperMethod",
	"Comment": "finds a method that has the given name and descriptor and is declaredin the super class.",
	"Method": "Method findSuperMethod(Object self,String name,String desc){\r\n    Class<?> clazz = self.getClass();\r\n    return findSuperClassMethod(clazz, name, desc);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.web.Webserver.addTranslator",
	"Comment": "adds a translator, which is called whenever a client requestsa class file.",
	"Method": "void addTranslator(ClassPool cp,Translator t){\r\n    classPool = cp;\r\n    translator = t;\r\n    t.start(classPool);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.ProxyClassSignatureHelper.isPoolClassOrParentDifferent",
	"Comment": "checks if the class or one of its parents signature differs from the one in the classloader.",
	"Method": "boolean isPoolClassOrParentDifferent(Class<?> clazz,ClassPool cp,boolean isPoolClassOrParentDifferent,Class<?> clazz,CtClass cc,boolean isPoolClassOrParentDifferent,Class<?> clazz,ClassLoader cp){\r\n    if (isPoolClassDifferent(clazz, cp))\r\n        return true;\r\n    Class<?> superclass = clazz.getSuperclass();\r\n    if (superclass != null) {\r\n        if (isPoolClassOrParentDifferent(superclass, cp)) {\r\n            return true;\r\n        }\r\n    }\r\n    Class<?>[] interfaces = clazz.getInterfaces();\r\n    for (Class<?> interfaceClazz : interfaces) {\r\n        if (isPoolClassOrParentDifferent(interfaceClazz, cp)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.hotswap.agent.tutorial.plugin.PrinterHAPlugin.setAutoDiscoveredPrintSources",
	"Comment": "called from modified printersourcescanner.scanprintsources method to store autodiscovered printsources",
	"Method": "void setAutoDiscoveredPrintSources(List<PrintSource> autoDiscoveredPrintSources){\r\n    this.autoDiscoveredPrintSources = autoDiscoveredPrintSources;\r\n}"
}, {
	"Path": "com.datastax.driver.core.exceptions.UnavailableException.getConsistencyLevel",
	"Comment": "the consistency level of the operation triggering this unavailable exception.",
	"Method": "ConsistencyLevel getConsistencyLevel(){\r\n    return consistency;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.web.Viewer.fetchClass",
	"Comment": "fetches the class file of the specified class from the httpserver.",
	"Method": "byte[] fetchClass(String classname){\r\n    byte[] b;\r\n    URL url = new URL(\"http\", server, port, \"/\" + classname.replace('.', '/') + \".class\");\r\n    URLConnection con = url.openConnection();\r\n    con.connect();\r\n    int size = con.getContentLength();\r\n    InputStream s = con.getInputStream();\r\n    if (size <= 0)\r\n        b = readStream(s);\r\n    else {\r\n        b = new byte[size];\r\n        int len = 0;\r\n        do {\r\n            int n = s.read(b, len, size - len);\r\n            if (n < 0) {\r\n                s.close();\r\n                throw new IOException(\"the stream was closed: \" + classname);\r\n            }\r\n            len += n;\r\n        } while (len < size);\r\n    }\r\n    s.close();\r\n    return b;\r\n}"
}, {
	"Path": "com.datastax.driver.core.ExecutionInfo.getPagingState",
	"Comment": "the paging state of the query.this object represents the next page to be fetched if this query is multi page. it can besaved and reused later on the same statement.",
	"Method": "PagingState getPagingState(){\r\n    if (this.pagingState == null)\r\n        return null;\r\n    return new PagingState(this.pagingState, this.statement, this.protocolVersion, this.codecRegistry);\r\n}"
}, {
	"Path": "org.jabref.gui.collab.FileUpdatePanel.getPanel",
	"Comment": "we include a getter for the basepanel this component refers to, because thiscomponent needs to be closed if the basepanel is closed.",
	"Method": "BasePanel getPanel(){\r\n    return panel;\r\n}"
}, {
	"Path": "com.datastax.driver.examples.basic.CreateAndPopulateKeyspace.connect",
	"Comment": "initiates a connection to the cluster specified by the given contact point.",
	"Method": "void connect(String[] contactPoints,int port){\r\n    cluster = Cluster.builder().addContactPoints(contactPoints).withPort(port).build();\r\n    System.out.printf(\"Connected to cluster: %s%n\", cluster.getMetadata().getClusterName());\r\n    session = cluster.connect();\r\n}"
}, {
	"Path": "org.jabref.gui.edit.MassSetFieldsDialog.massRenameField",
	"Comment": "move contents from one field to another for a collection of entries.",
	"Method": "UndoableEdit massRenameField(Collection<BibEntry> entries,String field,String newField,boolean overwriteValues){\r\n    NamedCompound compoundEdit = new NamedCompound(Localization.lang(\"Rename field\"));\r\n    for (BibEntry entry : entries) {\r\n        Optional<String> valToMove = entry.getField(field);\r\n        if ((!valToMove.isPresent()) || valToMove.get().isEmpty()) {\r\n            continue;\r\n        }\r\n        Optional<String> valInNewField = entry.getField(newField);\r\n        if (!overwriteValues && (valInNewField.isPresent()) && !valInNewField.get().isEmpty()) {\r\n            continue;\r\n        }\r\n        entry.setField(newField, valToMove.get());\r\n        compoundEdit.addEdit(new UndoableFieldChange(entry, newField, valInNewField.orElse(null), valToMove.get()));\r\n        entry.clearField(field);\r\n        compoundEdit.addEdit(new UndoableFieldChange(entry, field, valToMove.get(), null));\r\n    }\r\n    compoundEdit.end();\r\n    return compoundEdit;\r\n}"
}, {
	"Path": "org.jabref.logic.citationstyle.CitationStyle.getDefault",
	"Comment": "provides the default citation style which is currently ieee",
	"Method": "CitationStyle getDefault(){\r\n    return createCitationStyleFromFile(DEFAULT).orElse(new CitationStyle(\"\", \"Empty\", \"\"));\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.SqlStatement.bindFields",
	"Comment": "binds public fields of the specified object as arguments for the query.",
	"Method": "This bindFields(Object object,This bindFields,String prefix,Object object){\r\n    return bindNamedArgumentFinder(new ObjectFieldArguments(prefix, object));\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolTest.requests_with_enqueued_borrow_requests_should_be_failed_when_pool_closes",
	"Comment": "ensures that any enqueued connection borrow requests are failed when their associatedconnection pool closes.",
	"Method": "void requests_with_enqueued_borrow_requests_should_be_failed_when_pool_closes(){\r\n    Cluster cluster = createClusterBuilder().build();\r\n    List<MockRequest> requests = newArrayList();\r\n    try {\r\n        HostConnectionPool pool = createPool(cluster, 2, 2);\r\n        int maxQueueSize = 256;\r\n        assertThat(pool.connections.size()).isEqualTo(2);\r\n        List<Connection> coreConnections = newArrayList(pool.connections);\r\n        requests = MockRequest.sendMany(2 * 128, pool);\r\n        assertBorrowedConnections(requests, coreConnections);\r\n        List<MockRequest> queuedRequests = MockRequest.sendMany(maxQueueSize, pool, maxQueueSize);\r\n        pool.closeAsync();\r\n        for (MockRequest queuedRequest : queuedRequests) {\r\n            assertThat(queuedRequest.connectionFuture.isDone()).isTrue();\r\n            try {\r\n                queuedRequest.getConnection();\r\n                fail(\"Expected a ConnectionException\");\r\n            } catch (ConnectionException e) {\r\n            }\r\n        }\r\n    } finally {\r\n        MockRequest.completeAll(requests);\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.java.CtClassJavaProxyGenerator.checkReturnTypes",
	"Comment": "for a given set of proxy methods with the same signature, check thattheir return types are compatible according to the proxy specification.specifically, if there is more than one such method, then all of thereturn types must be reference types, and there must be one return typethat is assignable to each of the rest of them.",
	"Method": "void checkReturnTypes(List<ProxyMethod> methods){\r\n    if (methods.size() < 2) {\r\n        return;\r\n    }\r\n    LinkedList<CtClass> uncoveredReturnTypes = new LinkedList();\r\n    nextNewReturnType: for (ProxyMethod pm : methods) {\r\n        CtClass newReturnType = pm.returnType;\r\n        if (newReturnType.isPrimitive()) {\r\n            throw new IllegalArgumentException(\"methods with same signature \" + getFriendlyMethodSignature(pm.methodName, pm.parameterTypes) + \" but incompatible return types: \" + newReturnType.getName() + \" and others\");\r\n        }\r\n        boolean added = false;\r\n        ListIterator<CtClass> liter = uncoveredReturnTypes.listIterator();\r\n        while (liter.hasNext()) {\r\n            CtClass uncoveredReturnType = liter.next();\r\n            if (isAssignableFrom(newReturnType, uncoveredReturnType)) {\r\n                assert !added;\r\n                continue nextNewReturnType;\r\n            }\r\n            if (isAssignableFrom(uncoveredReturnType, newReturnType)) {\r\n                if (!added) {\r\n                    liter.set(newReturnType);\r\n                    added = true;\r\n                } else {\r\n                    liter.remove();\r\n                }\r\n            }\r\n        }\r\n        if (!added) {\r\n            uncoveredReturnTypes.add(newReturnType);\r\n        }\r\n    }\r\n    if (uncoveredReturnTypes.size() > 1) {\r\n        ProxyMethod pm = methods.get(0);\r\n        throw new IllegalArgumentException(\"methods with same signature \" + getFriendlyMethodSignature(pm.methodName, pm.parameterTypes) + \" but incompatible return types: \" + uncoveredReturnTypes);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.openoffice.OOBibStyle.isValid",
	"Comment": "after initializing this style from a file, this method can be used to checkwhether the file appeared to be a proper style file.",
	"Method": "boolean isValid(){\r\n    return valid;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.path.PathMatchingResourcePatternResolver.getResourceLoader",
	"Comment": "return the resourceloader that this pattern resolver works with.",
	"Method": "ResourceLoader getResourceLoader(){\r\n    return this.resourceLoader;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.hotswapper.HotswapperPlugin.init",
	"Comment": "for each classloader check for autohotswap configuration instance with hotswapper.",
	"Method": "void init(PluginConfiguration pluginConfiguration,ClassLoader appClassLoader){\r\n    if (appClassLoader == null) {\r\n        LOGGER.debug(\"Bootstrap class loader is null, hotswapper skipped.\");\r\n        return;\r\n    }\r\n    LOGGER.debug(\"Init plugin at classLoader {}\", appClassLoader);\r\n    if (!HotswapAgent.isAutoHotswap() && !pluginConfiguration.containsPropertyFile()) {\r\n        LOGGER.debug(\"ClassLoader {} does not contain hotswap-agent.properties file, hotswapper skipped.\", appClassLoader);\r\n        return;\r\n    }\r\n    if (!HotswapAgent.isAutoHotswap() && !pluginConfiguration.getPropertyBoolean(\"autoHotswap\")) {\r\n        LOGGER.debug(\"ClassLoader {} has autoHotswap disabled, hotswapper skipped.\", appClassLoader);\r\n        return;\r\n    }\r\n    String port = pluginConfiguration.getProperty(\"autoHotswap.port\");\r\n    HotswapperPlugin plugin = PluginManagerInvoker.callInitializePlugin(HotswapperPlugin.class, appClassLoader);\r\n    if (plugin != null) {\r\n        plugin.initHotswapCommand(appClassLoader, port);\r\n    } else {\r\n        LOGGER.debug(\"Hotswapper is disabled in {}\", appClassLoader);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.journals.AbbreviationWriter.writeOrCreate",
	"Comment": "this method will write the list of abbreviations to a file on the file system specified by the given path.if the file already exists its content will be overridden, otherwise a new file will be created.",
	"Method": "void writeOrCreate(Path path,List<Abbreviation> abbreviations,Charset encoding){\r\n    try (OutputStream outStream = Files.newOutputStream(path);\r\n        OutputStreamWriter writer = new OutputStreamWriter(outStream, encoding)) {\r\n        for (Abbreviation entry : abbreviations) {\r\n            writer.write(entry.getName());\r\n            writer.write(\" = \");\r\n            writer.write(entry.getAbbreviation());\r\n            writer.write(OS.NEWLINE);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.exporter.AtomicFileOutputStream.abort",
	"Comment": "closes the write process to the temporary file but does not commit to the target file.",
	"Method": "void abort(){\r\n    try {\r\n        super.close();\r\n        Files.deleteIfExists(temporaryFile);\r\n        Files.deleteIfExists(backupFile);\r\n    } catch (IOException exception) {\r\n        LOGGER.debug(\"Unable to abort writing to file \" + temporaryFile, exception);\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolTest.should_trash_on_returning_connection_with_insufficient_streams",
	"Comment": "ensures that if a connection that has less than the minimum available stream ids is returned tothe pool that the connection is put in the trash.",
	"Method": "void should_trash_on_returning_connection_with_insufficient_streams(){\r\n    Cluster cluster = createClusterBuilder().build();\r\n    List<MockRequest> allRequests = newArrayList();\r\n    try {\r\n        HostConnectionPool pool = createPool(cluster, 1, 2);\r\n        Connection.Factory factory = spy(cluster.manager.connectionFactory);\r\n        cluster.manager.connectionFactory = factory;\r\n        Connection core = pool.connections.get(0);\r\n        List<MockRequest> requests = MockRequest.sendMany(NEW_CONNECTION_THRESHOLD, pool);\r\n        assertBorrowedConnections(requests, Collections.singletonList(core));\r\n        allRequests.addAll(requests);\r\n        allRequests.add(MockRequest.send(pool));\r\n        verify(factory, after(2000).times(1)).open(any(HostConnectionPool.class));\r\n        assertThat(pool.connections).hasSize(2);\r\n        Connection extra1 = spy(pool.connections.get(1));\r\n        pool.connections.set(1, extra1);\r\n        allRequests.addAll(MockRequest.sendMany(10, pool));\r\n        assertThat(pool.connections).hasSize(2);\r\n        doReturn(0).when(extra1).maxAvailableStreams();\r\n        assertThat(pool.trash).hasSize(0);\r\n        pool.returnConnection(extra1);\r\n        assertThat(pool.trash).hasSize(1);\r\n    } finally {\r\n        MockRequest.completeAll(allRequests);\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ClassUtils.isOverridable",
	"Comment": "determine whether the given method is overridable in the given targetclass.",
	"Method": "boolean isOverridable(Method method,Class<?> targetClass){\r\n    if (Modifier.isPrivate(method.getModifiers())) {\r\n        return false;\r\n    }\r\n    if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {\r\n        return true;\r\n    }\r\n    return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));\r\n}"
}, {
	"Path": "org.menacheri.jetserver.concurrent.DataFlowVariable.bind",
	"Comment": "the method will bind the incoming value to the value in the class and\tthen do a countdown on the latch.",
	"Method": "void bind(Object val){\r\n    this.val = val;\r\n    latch.countDown();\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fileformat.MrDLibImporter.convertToString",
	"Comment": "convert buffered reader response to string for json parsing.",
	"Method": "String convertToString(BufferedReader input){\r\n    String line;\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    try {\r\n        while ((line = input.readLine()) != null) {\r\n            stringBuilder.append(line);\r\n        }\r\n    } catch (Exception e) {\r\n        LOGGER.error(e.getMessage());\r\n    }\r\n    return stringBuilder.toString();\r\n}"
}, {
	"Path": "com.datastax.driver.core.CustomPayloadTest.should_echo_custom_payload_when_paginating",
	"Comment": "ensures that a custom payload is propagated throughout pages.",
	"Method": "void should_echo_custom_payload_when_paginating(){\r\n    session().execute(\"INSERT INTO t1 (c1, c2) VALUES (1, 'a')\");\r\n    session().execute(\"INSERT INTO t1 (c1, c2) VALUES (1, 'b')\");\r\n    Statement statement = new SimpleStatement(\"SELECT c2 FROM t1 where c1 = 1\");\r\n    statement.setFetchSize(1);\r\n    statement.setOutgoingPayload(payload1);\r\n    ResultSet rows = session().execute(statement);\r\n    rows.all();\r\n    assertThat(rows.getAllExecutionInfo()).extracting(\"incomingPayload\").containsOnly(payload1);\r\n}"
}, {
	"Path": "org.jabref.gui.customentrytypes.FieldSetComponent.addAdditionActionListener",
	"Comment": "adds an actionlistener that will receive events each time a field is added. the actioneventwill specify this component as source, and the added field as action command.",
	"Method": "void addAdditionActionListener(ActionListener l){\r\n    additionListeners.add(l);\r\n}"
}, {
	"Path": "org.jabref.logic.xmp.XmpUtilReader.readRawXmp",
	"Comment": "will read the xmpmetadata from the given pdf file, closing the fileafterwards.",
	"Method": "List<XMPMetadata> readRawXmp(Path path){\r\n    try (PDDocument document = XmpUtilReader.loadWithAutomaticDecryption(path)) {\r\n        return XmpUtilReader.getXmpMetadata(document);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.openoffice.OpenOfficePreferences.getJarsPath",
	"Comment": "directory that contains juh.jar, jurt.jar, ridl.jar, unoil.jar",
	"Method": "String getJarsPath(){\r\n    return jarsPath;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.InputStreamResource.equals",
	"Comment": "this implementation compares the underlying inputstream.",
	"Method": "boolean equals(Object obj){\r\n    return (obj == this || (obj instanceof InputStreamResource && ((InputStreamResource) obj).inputStream.equals(this.inputStream)));\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.Alter.dropColumn",
	"Comment": "add a new drop column clause to this alter table statement.note that you cannot drop a column that is part of the primary key.",
	"Method": "SchemaStatement dropColumn(String columnName){\r\n    validateNotEmpty(columnName, \"Column to be dropped\");\r\n    validateNotKeyWord(columnName, String.format(\"The dropped column name '%s' is not allowed because it is a reserved keyword\", columnName));\r\n    return SchemaStatement.fromQueryString(buildInternal() + \" DROP \" + columnName);\r\n}"
}, {
	"Path": "org.jabref.gui.WrapLayout.minimumLayoutSize",
	"Comment": "returns the minimum dimensions needed to layout the visiblecomponents contained in the specified target container.",
	"Method": "Dimension minimumLayoutSize(Container target){\r\n    Dimension minimum = layoutSize(target, false);\r\n    minimum.width -= (getHgap() + 1);\r\n    return minimum;\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolTest.should_not_resurrect_trashed_connection_after_idle_timeout",
	"Comment": "ensures that a trashed connection that has been timed out should not be resurrected into theconnection pool if borrowconnection is called and a new connection is needed.",
	"Method": "void should_not_resurrect_trashed_connection_after_idle_timeout(){\r\n    Cluster cluster = createClusterBuilder().withPoolingOptions(new PoolingOptions().setIdleTimeoutSeconds(20)).build();\r\n    List<MockRequest> allRequests = newArrayList();\r\n    try {\r\n        HostConnectionPool pool = createPool(cluster, 1, 2);\r\n        Connection.Factory factory = spy(cluster.manager.connectionFactory);\r\n        cluster.manager.connectionFactory = factory;\r\n        Connection connection1 = pool.connections.get(0);\r\n        List<MockRequest> requests = MockRequest.sendMany(NEW_CONNECTION_THRESHOLD, pool);\r\n        assertBorrowedConnection(requests, connection1);\r\n        allRequests.addAll(requests);\r\n        allRequests.add(MockRequest.send(pool));\r\n        verify(factory, after(2000).times(1)).open(any(HostConnectionPool.class));\r\n        assertPoolSize(pool, 2);\r\n        reset(factory);\r\n        Connection connection2 = pool.connections.get(1);\r\n        assertThat(connection1.inFlight.get()).isEqualTo(101);\r\n        assertThat(connection2.inFlight.get()).isEqualTo(0);\r\n        MockRequest.completeMany(51, allRequests);\r\n        assertThat(connection1.inFlight.get()).isEqualTo(50);\r\n        assertThat(connection2.inFlight.get()).isEqualTo(0);\r\n        Uninterruptibles.sleepUninterruptibly(20, TimeUnit.SECONDS);\r\n        assertThat(pool.connections).containsExactly(connection2);\r\n        assertThat(pool.trash).containsExactly(connection1);\r\n        MockRequest.completeMany(50, allRequests);\r\n        assertThat(connection1.inFlight.get()).isEqualTo(0);\r\n        Uninterruptibles.sleepUninterruptibly(30, TimeUnit.SECONDS);\r\n        assertThat(pool.connections).containsExactly(connection2);\r\n        assertThat(pool.trash).isEmpty();\r\n        assertThat(connection1.isClosed()).isTrue();\r\n        requests = MockRequest.sendMany(NEW_CONNECTION_THRESHOLD, pool);\r\n        assertBorrowedConnection(requests, connection2);\r\n        allRequests.addAll(requests);\r\n        allRequests.add(MockRequest.send(pool));\r\n        assertThat(connection2.inFlight.get()).isEqualTo(101);\r\n        verify(factory, after(2000).times(1)).open(any(HostConnectionPool.class));\r\n        assertPoolSize(pool, 2);\r\n        MockRequest request = MockRequest.send(pool);\r\n        allRequests.add(request);\r\n        // should not be the full connection\r\n        assertThat(request.getConnection()).isNotEqualTo(// should not be the previously trashed one\r\n        connection2).isNotEqualTo(connection1);\r\n    } finally {\r\n        MockRequest.completeAll(allRequests);\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiletype.ExternalFileTypes.getExternalFileTypeByMimeType",
	"Comment": "look up the external file type registered for this mime type, if any.",
	"Method": "Optional<ExternalFileType> getExternalFileTypeByMimeType(String mimeType){\r\n    for (ExternalFileType type : externalFileTypes) {\r\n        if (type.getMimeType().equalsIgnoreCase(mimeType)) {\r\n            return Optional.of(type);\r\n        }\r\n    }\r\n    if (\"text/html\".equalsIgnoreCase(mimeType)) {\r\n        return Optional.of(HTML_FALLBACK_TYPE);\r\n    } else {\r\n        return Optional.empty();\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.AbstractReplicationStrategyTest.assertReplicasForToken",
	"Comment": "checks if a given ordered set of replicas matches the expected list of replica hosts",
	"Method": "void assertReplicasForToken(Set<Host> replicaSet,InetSocketAddress expected){\r\n    final String message = \"Contents of replica set: \" + replicaSet + \" do not match expected hosts: \" + Arrays.toString(expected);\r\n    assertEquals(replicaSet.size(), expected.length, message);\r\n    int i = 0;\r\n    for (Host hostReturned : replicaSet) {\r\n        boolean match = true;\r\n        if (!expected[i++].equals(mockAddress(hostReturned))) {\r\n            match = false;\r\n        }\r\n        assertTrue(match, message);\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.TableOptionsMetadata.getBloomFilterFalsePositiveChance",
	"Comment": "returns the false positive chance for the bloom filter of this table.",
	"Method": "double getBloomFilterFalsePositiveChance(){\r\n    return bfFpChance;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.SqlStatement.setQueryTimeout",
	"Comment": "set the query timeout, in seconds, on the prepared statement",
	"Method": "This setQueryTimeout(int seconds){\r\n    return addCustomizer(StatementCustomizers.statementTimeout(seconds));\r\n}"
}, {
	"Path": "org.menacheri.jetserver.server.netty.FlashPolicyServerPipelineFactory.getFlashPolicyServerHandler",
	"Comment": "spring will return the actual prototype bean from its context here. it\tuses method lookup here.",
	"Method": "FlashPolicyServerHandler getFlashPolicyServerHandler(){\r\n    return null;\r\n}"
}, {
	"Path": "com.datastax.driver.core.HeartbeatTest.assertLineMatches",
	"Comment": "verifies that there exists a line in logs that matches pattern.",
	"Method": "void assertLineMatches(String logs,Pattern pattern){\r\n    String[] lines = logs.split(\"\\\\r?\\\\n\");\r\n    for (String line : lines) {\r\n        if (pattern.matcher(line).matches()) {\r\n            return;\r\n        }\r\n    }\r\n    fail(\"Expecting: [\" + logs + \"] to contain \" + pattern);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ClassUtils.getAllInterfacesAsSet",
	"Comment": "return all interfaces that the given instance implements as set,including ones implemented by superclasses.",
	"Method": "Set<Class<?>> getAllInterfacesAsSet(Object instance){\r\n    Assert.notNull(instance, \"Instance must not be null\");\r\n    return getAllInterfacesForClassAsSet(instance.getClass());\r\n}"
}, {
	"Path": "com.datastax.driver.core.HeapCompressionTest.should_function_with_lz4_compression",
	"Comment": "validates that lz4 compression still works when using heap buffers.",
	"Method": "void should_function_with_lz4_compression(){\r\n    compressionTest(ProtocolOptions.Compression.LZ4);\r\n}"
}, {
	"Path": "org.jabref.model.TreeNode.removeFromParent",
	"Comment": "removes the subtree rooted at this node from the tree, giving this node an empty parent.does nothing if this node is the root of it tree.",
	"Method": "void removeFromParent(){\r\n    if (parent != null) {\r\n        parent.removeChild((T) this);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.citationstyle.CitationStyleGenerator.generateCitation",
	"Comment": "generates a citation based on the given entry, style, and output format",
	"Method": "String generateCitation(BibEntry entry,CitationStyle style,String generateCitation,BibEntry entry,String style,String generateCitation,BibEntry entry,String style,CitationStyleOutputFormat outputFormat){\r\n    return generateCitations(Collections.singletonList(entry), style, outputFormat).stream().findFirst().orElse(\"\");\r\n}"
}, {
	"Path": "org.jabref.logic.bibtex.comparator.GroupDiff.compare",
	"Comment": "this method only detects whether a change took place or not. it does not determine the type of change. this wouldbe possible, but difficult to do properly, so we rather only report the change.",
	"Method": "Optional<GroupDiff> compare(MetaData originalMetaData,MetaData newMetaData){\r\n    final Optional<GroupTreeNode> originalGroups = originalMetaData.getGroups();\r\n    final Optional<GroupTreeNode> newGroups = newMetaData.getGroups();\r\n    if (!originalGroups.equals(newGroups)) {\r\n        return Optional.of(new GroupDiff(newGroups.orElse(null), originalGroups.orElse(null)));\r\n    } else {\r\n        return Optional.empty();\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.AbstractResource.getFile",
	"Comment": "this implementation throws a filenotfoundexception, assuming that theresource cannot be resolved to an absolute file path.",
	"Method": "File getFile(){\r\n    throw new FileNotFoundException(getDescription() + \" cannot be resolved to absolute file path\");\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiletype.CustomExternalFileType.equals",
	"Comment": "we define two file type objects as equal if their name, extension, openwith andiconname are equal.",
	"Method": "boolean equals(Object object){\r\n    if (this == object) {\r\n        return true;\r\n    }\r\n    if (object instanceof CustomExternalFileType) {\r\n        CustomExternalFileType other = (CustomExternalFileType) object;\r\n        return Objects.equals(name, other.name) && Objects.equals(extension, other.extension) && Objects.equals(mimeType, other.mimeType) && Objects.equals(openWith, other.openWith) && Objects.equals(iconName, other.iconName);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.SchemaBuilder.percentile",
	"Comment": "create the speculative retry strategy that retries based on the effect on throughput andlatency, to use in a create or alter table statement.",
	"Method": "TableOptions.SpeculativeRetryValue percentile(int percentile){\r\n    if (percentile < 0 || percentile > 100) {\r\n        throw new IllegalArgumentException(\"Percentile value for speculative retry should be between 0 and 100\");\r\n    }\r\n    return new TableOptions.SpeculativeRetryValue(\"'\" + percentile + \"percentile'\");\r\n}"
}, {
	"Path": "com.datastax.driver.core.SocketOptions.getConnectTimeoutMillis",
	"Comment": "the connection timeout in milliseconds.as the name implies, the connection timeout defines how long the driver waits to establish anew connection to a cassandra node before giving up.",
	"Method": "int getConnectTimeoutMillis(){\r\n    return connectTimeoutMillis;\r\n}"
}, {
	"Path": "org.jabref.model.entry.Author.equals",
	"Comment": "compare this object with the given one.will return true iff the other object is an author and all fields are identical on a string comparison.",
	"Method": "boolean equals(Object other){\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other instanceof Author) {\r\n        Author that = (Author) other;\r\n        return Objects.equals(firstPart, that.firstPart) && Objects.equals(firstAbbr, that.firstAbbr) && Objects.equals(vonPart, that.vonPart) && Objects.equals(lastPart, that.lastPart) && Objects.equals(jrPart, that.jrPart);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiles.FindUnlinkedFilesDialog.startSearch",
	"Comment": "starts the search of unlinked files according chosen directory and the file type selection. the search willprocess in a separate thread and a progress indicator will be displayed.",
	"Method": "void startSearch(){\r\n    Path directory = getSearchDirectory();\r\n    FileFilter selectedFileFilter = comboBoxFileTypeSelection.getValue();\r\n    findUnlinkedFilesTask = new UnlinkedFilesCrawler(directory, selectedFileFilter, databaseContext).onRunning(() -> {\r\n        panelSearchProgress.setVisible(true);\r\n        buttonScan.setDisable(true);\r\n        tree.setRoot(null);\r\n    }).onFinished(() -> {\r\n        panelSearchProgress.setVisible(false);\r\n        buttonScan.setDisable(false);\r\n    }).onSuccess(root -> {\r\n        tree.setRoot(root);\r\n        root.setSelected(true);\r\n        root.setExpanded(true);\r\n        buttonApply.setDisable(false);\r\n        buttonExport.setDisable(false);\r\n        buttonScan.setDefaultButton(false);\r\n    });\r\n    findUnlinkedFilesTask.executeWith(Globals.TASK_EXECUTOR);\r\n}"
}, {
	"Path": "org.jabref.logic.layout.AbstractParamLayoutFormatter.parseArgument",
	"Comment": "parse an argument string and return the parts of the argument. the parts areseparated by commas, and escaped commas are reduced to literal commas.",
	"Method": "List<String> parseArgument(String arg){\r\n    List<String> parts = new ArrayList();\r\n    StringBuilder current = new StringBuilder();\r\n    boolean escaped = false;\r\n    for (int i = 0; i < arg.length(); i++) {\r\n        if ((arg.charAt(i) == AbstractParamLayoutFormatter.SEPARATOR) && !escaped) {\r\n            parts.add(current.toString());\r\n            current = new StringBuilder();\r\n        } else if (arg.charAt(i) == '\\\\') {\r\n            if (escaped) {\r\n                escaped = false;\r\n                current.append(arg.charAt(i));\r\n            } else {\r\n                escaped = true;\r\n            }\r\n        } else if (escaped) {\r\n            if (arg.charAt(i) == 'n') {\r\n                current.append('\\n');\r\n            } else if (arg.charAt(i) == 't') {\r\n                current.append('\\t');\r\n            } else {\r\n                if ((arg.charAt(i) != ',') && (arg.charAt(i) != '\"')) {\r\n                    current.append('\\\\');\r\n                }\r\n                current.append(arg.charAt(i));\r\n            }\r\n            escaped = false;\r\n        } else {\r\n            current.append(arg.charAt(i));\r\n        }\r\n    }\r\n    parts.add(current.toString());\r\n    return parts;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.UrlResource.getURI",
	"Comment": "this implementation returns the underlying uri directly, if possible.",
	"Method": "URI getURI(){\r\n    if (this.uri != null) {\r\n        return this.uri;\r\n    } else {\r\n        return super.getURI();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.edit.MassSetFieldsDialog.massAppendField",
	"Comment": "append a given value to a given field for all entries in a collection. this method does not update any undomanager,but returns a relevant compoundedit that should be registered by the caller.",
	"Method": "UndoableEdit massAppendField(Collection<BibEntry> entries,String field,String textToAppend){\r\n    String newValue = \"\";\r\n    if (textToAppend != null) {\r\n        newValue = textToAppend;\r\n    }\r\n    NamedCompound compoundEdit = new NamedCompound(Localization.lang(\"Append field\"));\r\n    for (BibEntry entry : entries) {\r\n        Optional<String> oldValue = entry.getField(field);\r\n        entry.setField(field, oldValue.orElse(\"\") + newValue);\r\n        compoundEdit.addEdit(new UndoableFieldChange(entry, field, oldValue.orElse(null), newValue));\r\n    }\r\n    compoundEdit.end();\r\n    return compoundEdit;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.Callback.insertBefore",
	"Comment": "utility method to insert callback at the beginning of the body.",
	"Method": "void insertBefore(CtBehavior behavior,Callback callback){\r\n    behavior.insertBefore(callback.toString());\r\n}"
}, {
	"Path": "org.jabref.model.auxparser.AuxParserResult.getCrossRefEntriesCount",
	"Comment": "query the number of extra entries pulled in due to crossrefs from other entries.",
	"Method": "int getCrossRefEntriesCount(){\r\n    return crossRefEntriesCount;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.UrlResource.getURL",
	"Comment": "this implementation returns the underlying url reference.",
	"Method": "URL getURL(){\r\n    return this.url;\r\n}"
}, {
	"Path": "org.elixir_lang.sdk.elixir.Type.homePathByVersion",
	"Comment": "map of home paths to versions in descending version order so that newer versions are favored.",
	"Method": "Map<Version, String> homePathByVersion(){\r\n    Map<Version, String> homePathByVersion = new TreeMap((version1, version2) -> {\r\n        return version2.compareTo(version1);\r\n    });\r\n    if (SystemInfo.isMac) {\r\n        mergeHomebrew(homePathByVersion, \"elixir\", java.util.function.Function.identity());\r\n        mergeNixStore(homePathByVersion, NIX_PATTERN, Function.identity());\r\n    } else {\r\n        String sdkPath;\r\n        if (SystemInfo.isWindows) {\r\n            if (SystemInfo.is32Bit) {\r\n                sdkPath = WINDOWS_32BIT_DEFAULT_HOME_PATH;\r\n            } else {\r\n                sdkPath = WINDOWS_64BIT_DEFAULT_HOME_PATH;\r\n            }\r\n            homePathByVersion.put(UNKNOWN_VERSION, sdkPath);\r\n        } else if (SystemInfo.isLinux) {\r\n            homePathByVersion.put(UNKNOWN_VERSION, LINUX_DEFAULT_HOME_PATH);\r\n            mergeNixStore(homePathByVersion, NIX_PATTERN, Function.identity());\r\n        }\r\n    }\r\n    return homePathByVersion;\r\n}"
}, {
	"Path": "com.datastax.driver.core.ConsistencyTest.should_use_statement_serial_cl",
	"Comment": "exhaustively tests all serial consistency levels when they are set at the statement level.",
	"Method": "void should_use_statement_serial_cl(ConsistencyLevel cl){\r\n    Cluster cluster = builder().build();\r\n    try {\r\n        Session session = cluster.connect();\r\n        String queryString = \"statement_serial_cl\";\r\n        Query clQuery = executeSimple(session, queryString, null, cl);\r\n        checkSerialCLMatch(cl, clQuery.getSerialConsistency());\r\n        String prepareString = \"preapred_statement_serial_cl\";\r\n        PreparedStatementExecution pse = executePrepared(session, prepareString, null, cl);\r\n        checkSerialCLMatch(cl, pse.getSerialConsistency());\r\n        String batchStateString = \"batch_statement_serial_cl\";\r\n        BatchExecution batch = executeBatch(session, batchStateString, null, cl);\r\n        checkSerialCLMatch(cl, batch.getSerialConsistency());\r\n    } finally {\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.shared.SharedDatabaseLoginDialogViewModel.applyPreferences",
	"Comment": "fetches possibly saved data and configures the control elements respectively.",
	"Method": "void applyPreferences(){\r\n    Optional<String> sharedDatabaseType = prefs.getType();\r\n    Optional<String> sharedDatabaseHost = prefs.getHost();\r\n    Optional<String> sharedDatabasePort = prefs.getPort();\r\n    Optional<String> sharedDatabaseName = prefs.getName();\r\n    Optional<String> sharedDatabaseUser = prefs.getUser();\r\n    Optional<String> sharedDatabasePassword = prefs.getPassword();\r\n    boolean sharedDatabaseRememberPassword = prefs.getRememberPassword();\r\n    Optional<String> sharedDatabaseKeystoreFile = prefs.getKeyStoreFile();\r\n    if (sharedDatabaseType.isPresent()) {\r\n        Optional<DBMSType> dbmsType = DBMSType.fromString(sharedDatabaseType.get());\r\n        dbmsType.ifPresent(selectedDBMSType::set);\r\n    }\r\n    sharedDatabaseHost.ifPresent(host::set);\r\n    sharedDatabasePort.ifPresent(port::set);\r\n    sharedDatabaseName.ifPresent(database::set);\r\n    sharedDatabaseUser.ifPresent(user::set);\r\n    sharedDatabaseKeystoreFile.ifPresent(keystore::set);\r\n    useSSL.setValue(prefs.isUseSSL());\r\n    if (sharedDatabasePassword.isPresent() && sharedDatabaseUser.isPresent()) {\r\n        try {\r\n            password.setValue(new Password(sharedDatabasePassword.get().toCharArray(), sharedDatabaseUser.get()).decrypt());\r\n        } catch (GeneralSecurityException | UnsupportedEncodingException e) {\r\n            LOGGER.error(\"Could not read the password due to decryption problems.\", e);\r\n        }\r\n    }\r\n    rememberPassword.set(sharedDatabaseRememberPassword);\r\n}"
}, {
	"Path": "org.jabref.migrations.PreferencesMigrations.upgradeSortOrder",
	"Comment": "upgrade the sort order preferences for the current versionthe old preference is kept in case an old version of jabref is used withthese preferences, but it is only used when the new preference does notexist",
	"Method": "void upgradeSortOrder(JabRefPreferences prefs){\r\n    if (prefs.get(JabRefPreferences.EXPORT_IN_SPECIFIED_ORDER, null) == null) {\r\n        if (prefs.getBoolean(\"exportInStandardOrder\", false)) {\r\n            prefs.putBoolean(JabRefPreferences.EXPORT_IN_SPECIFIED_ORDER, true);\r\n            prefs.put(JabRefPreferences.EXPORT_PRIMARY_SORT_FIELD, FieldName.AUTHOR);\r\n            prefs.put(JabRefPreferences.EXPORT_SECONDARY_SORT_FIELD, FieldName.EDITOR);\r\n            prefs.put(JabRefPreferences.EXPORT_TERTIARY_SORT_FIELD, FieldName.YEAR);\r\n            prefs.putBoolean(JabRefPreferences.EXPORT_PRIMARY_SORT_DESCENDING, false);\r\n            prefs.putBoolean(JabRefPreferences.EXPORT_SECONDARY_SORT_DESCENDING, false);\r\n            prefs.putBoolean(JabRefPreferences.EXPORT_TERTIARY_SORT_DESCENDING, false);\r\n        } else if (prefs.getBoolean(\"exportInTitleOrder\", false)) {\r\n            prefs.putBoolean(JabRefPreferences.EXPORT_IN_SPECIFIED_ORDER, true);\r\n            prefs.put(JabRefPreferences.EXPORT_PRIMARY_SORT_FIELD, FieldName.TITLE);\r\n            prefs.put(JabRefPreferences.EXPORT_SECONDARY_SORT_FIELD, FieldName.AUTHOR);\r\n            prefs.put(JabRefPreferences.EXPORT_TERTIARY_SORT_FIELD, FieldName.EDITOR);\r\n            prefs.putBoolean(JabRefPreferences.EXPORT_PRIMARY_SORT_DESCENDING, false);\r\n            prefs.putBoolean(JabRefPreferences.EXPORT_SECONDARY_SORT_DESCENDING, false);\r\n            prefs.putBoolean(JabRefPreferences.EXPORT_TERTIARY_SORT_DESCENDING, false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.DefaultStatementBuilder.create",
	"Comment": "create a new defaultstatementbuilder which will always create a new preparedstatement fromthe connection",
	"Method": "Statement create(Connection conn,StatementContext ctx,PreparedStatement create,Connection conn,String sql,StatementContext ctx){\r\n    if (ctx.isReturningGeneratedKeys()) {\r\n        String[] columnNames = ctx.getGeneratedKeysColumnNames();\r\n        if (columnNames != null && columnNames.length > 0) {\r\n            return conn.prepareStatement(sql, columnNames);\r\n        }\r\n        return conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);\r\n    } else if (ctx.isConcurrentUpdatable()) {\r\n        return conn.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);\r\n    } else {\r\n        return conn.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);\r\n    }\r\n}"
}, {
	"Path": "org.elixir_lang.code_insight.highlighting.brace_matcher.Paired.getPairs",
	"Comment": "returns the array of definitions for brace pairs that need to be matched whenediting code in the language.",
	"Method": "BracePair[] getPairs(){\r\n    return BRACE_PAIRS;\r\n}"
}, {
	"Path": "com.datastax.driver.core.TableOptionsMetadata.isCDC",
	"Comment": "returns whether or not change data capture is enabled for this table.for cassandra versions prior to 3.8.0, this method always returns false.",
	"Method": "boolean isCDC(){\r\n    return cdc;\r\n}"
}, {
	"Path": "com.datastax.driver.mapping.MapperUDTTest.should_parse_mapped_udt",
	"Comment": "ensures that mappedudtcodec is able to properly parse udts.",
	"Method": "void should_parse_mapped_udt(){\r\n    MappingManager manager = new MappingManager(session());\r\n    TypeCodec<Address> codec = manager.udtCodec(Address.class);\r\n    Address actual = codec.parse(\"{street:'12 4th Street',city:'Springfield',\\\"ZIP_code\\\":12345,phones:{'435423245','12341343'}}\");\r\n    assertThat(actual).isEqualTo(new Address(\"12 4th Street\", \"Springfield\", 12345, \"12341343\", \"435423245\"));\r\n}"
}, {
	"Path": "org.elixir_lang.parser.ElixirParser.unmatchedQualifiedNoArgumentsCall_0",
	"Comment": "dotinfixoperator relativeidentifier !call doblockmaybe",
	"Method": "boolean unmatchedQualifiedNoArgumentsCall_0(PsiBuilder b,int l){\r\n    if (!recursion_guard_(b, l, \"unmatchedQualifiedNoArgumentsCall_0\"))\r\n        return false;\r\n    boolean r;\r\n    Marker m = enter_section_(b);\r\n    r = dotInfixOperator(b, l + 1);\r\n    r = r && relativeIdentifier(b, l + 1);\r\n    r = r && unmatchedQualifiedNoArgumentsCall_0_2(b, l + 1);\r\n    r = r && doBlockMaybe(b, l + 1);\r\n    exit_section_(b, m, null, r);\r\n    return r;\r\n}"
}, {
	"Path": "com.datastax.driver.core.PlainTextAuthProvider.setUsername",
	"Comment": "changes the user name.the new credentials will be used for all connections initiated after this method was called.",
	"Method": "void setUsername(String username){\r\n    this.username = username;\r\n}"
}, {
	"Path": "org.jabref.gui.util.CustomLocalDragboard.putValue",
	"Comment": "puts the value of the concrete class in a map. all previous content stored in the map is removed",
	"Method": "void putValue(Class<T> type,T value){\r\n    clearAll();\r\n    contents.put(type, type.cast(value));\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolTest.should_add_extra_connection_when_core_full",
	"Comment": "ensures that if the core connection pool is full that borrowconnection will create and use anew connection.",
	"Method": "void should_add_extra_connection_when_core_full(){\r\n    Cluster cluster = createClusterBuilder().build();\r\n    List<MockRequest> allRequests = newArrayList();\r\n    try {\r\n        HostConnectionPool pool = createPool(cluster, 1, 2);\r\n        Connection.Factory factory = spy(cluster.manager.connectionFactory);\r\n        cluster.manager.connectionFactory = factory;\r\n        Connection core = pool.connections.get(0);\r\n        List<MockRequest> requests = MockRequest.sendMany(NEW_CONNECTION_THRESHOLD, pool);\r\n        assertBorrowedConnection(requests, core);\r\n        allRequests.addAll(requests);\r\n        allRequests.add(MockRequest.send(pool));\r\n        verify(factory, after(2000).times(1)).open(any(HostConnectionPool.class));\r\n        assertPoolSize(pool, 2);\r\n    } finally {\r\n        MockRequest.completeAll(allRequests);\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.AbstractResource.toString",
	"Comment": "this implementation returns the description of this resource.",
	"Method": "String toString(){\r\n    return getDescription();\r\n}"
}, {
	"Path": "com.datastax.driver.core.Metrics.getInFlightRequests",
	"Comment": "returns the total number of in flight requests to cassandra hosts.",
	"Method": "Gauge<Integer> getInFlightRequests(){\r\n    return inFlightRequests;\r\n}"
}, {
	"Path": "org.jabref.gui.worker.CitationStyleToClipboardWorker.processHtml",
	"Comment": "inserts each citation into a html body and copies it to the clipboard",
	"Method": "ClipboardContent processHtml(List<String> citations){\r\n    String result = \"<!DOCTYPE html>\" + OS.NEWLINE + \"<html>\" + OS.NEWLINE + \"   <head>\" + OS.NEWLINE + \"      <meta charset=\\\"utf-8\\\">\" + OS.NEWLINE + \"   <\/head>\" + OS.NEWLINE + \"   <body>\" + OS.NEWLINE + OS.NEWLINE;\r\n    result += String.join(CitationStyleOutputFormat.HTML.getLineSeparator(), citations);\r\n    result += OS.NEWLINE + \"   <\/body>\" + OS.NEWLINE + \"<\/html>\" + OS.NEWLINE;\r\n    ClipboardContent content = new ClipboardContent();\r\n    content.putHtml(result);\r\n    return content;\r\n}"
}, {
	"Path": "org.bytedeco.javacpp.samples.tensorflow.CarPricePredictionExample.checkStatus",
	"Comment": "checks the status and throws an exception in case any error occurred",
	"Method": "void checkStatus(Status s){\r\n    if (!s.ok())\r\n        throw new Exception(s.error_message().getString());\r\n    s.close();\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.tomcat.WebappLoaderTransformer.patchProxyDirContext",
	"Comment": "resource lookup for tomcat 6x, 7x.before the resource is handled by tomcat, try to get extraresource handled by the plugin.",
	"Method": "void patchProxyDirContext(ClassPool classPool,CtClass ctClass){\r\n    try {\r\n        ctClass.getDeclaredMethod(\"lookup\", new CtClass[] { classPool.get(String.class.getName()) }).insertBefore(\"java.io.InputStream is = \" + TomcatPlugin.class.getName() + \".getExtraResource(this, name);\" + \"if (is != null) return new org.apache.naming.resources.Resource(is);\");\r\n        ctClass.getDeclaredMethod(\"getAttributes\", new CtClass[] { classPool.get(String.class.getName()) }).insertBefore(\"long length = \" + TomcatPlugin.class.getName() + \".getExtraResourceLength(this, name);\" + \"if (length > 0) {\" + \"  org.apache.naming.resources.ResourceAttributes a = new org.apache.naming.resources.ResourceAttributes();\" + \"  a.setContentLength(length); return a;\" + \"}\");\r\n    } catch (NotFoundException e) {\r\n        LOGGER.warning(\"org.apache.naming.resources.ProxyDirContext does not contain lookup method. Tomcat plugin will not work properly.\");\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "org.elixir_lang.parser.ElixirParser.containerAssociationOperation",
	"Comment": "containerexpression associationinfixoperator containerexpression",
	"Method": "boolean containerAssociationOperation(PsiBuilder b,int l){\r\n    if (!recursion_guard_(b, l, \"containerAssociationOperation\"))\r\n        return false;\r\n    boolean r;\r\n    Marker m = enter_section_(b, l, _NONE_, CONTAINER_ASSOCIATION_OPERATION, \"<container association operation>\");\r\n    r = containerExpression(b, l + 1);\r\n    r = r && associationInfixOperator(b, l + 1);\r\n    r = r && containerExpression(b, l + 1);\r\n    exit_section_(b, l, m, r, false, null);\r\n    return r;\r\n}"
}, {
	"Path": "org.elixir_lang.navigation.item_presentation.modular.Use.getPresentableText",
	"Comment": "returns the name of the object to be presented in most renderers across the program.",
	"Method": "String getPresentableText(){\r\n    return use.call().getText();\r\n}"
}, {
	"Path": "com.datastax.driver.mapping.MapperMaterializedViewTest.should_access_single_entity",
	"Comment": "validates that an accessor properly maps a single entity over a result from a materializedview.",
	"Method": "void should_access_single_entity(){\r\n    Score score = accessor.allTimeHigh(\"Coup\");\r\n    assertThat(score).isEqualTo(new Score(\"pcmanus\", \"Coup\", 2015, 5, 1, 4000));\r\n}"
}, {
	"Path": "org.jabref.logic.formatter.casechanger.Word.toUpperCase",
	"Comment": "only change letters of the word that are unprotected to upper case.",
	"Method": "void toUpperCase(){\r\n    for (int i = 0; i < chars.length; i++) {\r\n        if (protectedChars[i]) {\r\n            continue;\r\n        }\r\n        chars[i] = Character.toUpperCase(chars[i]);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.path.PathMatchingResourcePatternResolver.getPathMatcher",
	"Comment": "return the pathmatcher that this resource pattern resolver uses.",
	"Method": "PathMatcher getPathMatcher(){\r\n    return this.pathMatcher;\r\n}"
}, {
	"Path": "com.datastax.driver.mapping.MapperNestedUDTTest.should_be_able_to_create_entity_from_table_having_udt_with_nested_udt",
	"Comment": "validates that tables having a udt column that itself has a udt field can be handled by theobject mapper.",
	"Method": "void should_be_able_to_create_entity_from_table_having_udt_with_nested_udt(){\r\n    MappingManager manager = new MappingManager(session());\r\n    Mapper<User> mapper = manager.mapper(User.class);\r\n    Rectangle r = new Rectangle(new Point(10, 0), new Point(10, 10), new Point(0, 10), new Point(0, 0));\r\n    User user = new User();\r\n    user.setId(UUID.randomUUID());\r\n    user.setName(\"Bob\");\r\n    user.setArea(r);\r\n    mapper.save(user);\r\n    User retrieved = mapper.get(user.getId());\r\n    assertThat(retrieved).isEqualTo(user);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.ClassPathResource.createRelative",
	"Comment": "this implementation creates a classpathresource, applying the given pathrelative to the path of the underlying resource of this descriptor.",
	"Method": "Resource createRelative(String relativePath){\r\n    String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\r\n    return new ClassPathResource(pathToUse, this.classLoader, this.clazz);\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fileformat.ModsImporter.getElement",
	"Comment": "returns an optional which contains an instance of the given class, if the given element can be cast to this class.if the element cannot be cast to the given class, then an empty optional will be returned.",
	"Method": "Optional<T> getElement(Object groupElement,Class<T> clazz){\r\n    if (clazz.isAssignableFrom(groupElement.getClass())) {\r\n        return Optional.of(clazz.cast(groupElement));\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "org.elixir_lang.beam.psi.impl.ModuleElementImpl.getTextRange",
	"Comment": "returns the text range in the document occupied by the psi element.",
	"Method": "TextRange getTextRange(){\r\n    PsiElement mirror = getMirror();\r\n    TextRange textRange = TextRange.EMPTY_RANGE;\r\n    if (mirror != null) {\r\n        textRange = mirror.getTextRange();\r\n    }\r\n    return textRange;\r\n}"
}, {
	"Path": "org.jabref.model.database.BibDatabase.resolveForStrings",
	"Comment": "take the given collection of bibentry and resolve any stringreferences.",
	"Method": "String resolveForStrings(String content,List<BibEntry> resolveForStrings,Collection<BibEntry> entriesToResolve,boolean inPlace,BibEntry resolveForStrings,BibEntry entry,boolean inPlace){\r\n    BibEntry resultingEntry;\r\n    if (inPlace) {\r\n        resultingEntry = entry;\r\n    } else {\r\n        resultingEntry = (BibEntry) entry.clone();\r\n    }\r\n    for (Map.Entry<String, String> field : resultingEntry.getFieldMap().entrySet()) {\r\n        resultingEntry.setField(field.getKey(), this.resolveForStrings(field.getValue()));\r\n    }\r\n    return resultingEntry;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.UrlResource.getFilename",
	"Comment": "this implementation returns the name of the file that this url refers to.",
	"Method": "String getFilename(){\r\n    return new File(this.url.getFile()).getName();\r\n}"
}, {
	"Path": "org.jabref.gui.importer.ImportInspectionDialog.internalDuplicate",
	"Comment": "checks if there are duplicates to the given entry in the collection. doesnot report the entry as duplicate of itself if it is in the collection.",
	"Method": "Optional<BibEntry> internalDuplicate(Collection<BibEntry> entriesDupe,BibEntry entry){\r\n    for (BibEntry othEntry : entriesDupe) {\r\n        if (othEntry.equals(entry)) {\r\n            continue;\r\n        }\r\n        if (DuplicateCheck.isDuplicate(entry, othEntry, panel.getBibDatabaseContext().getMode())) {\r\n            return Optional.of(othEntry);\r\n        }\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fileformat.MsBibImporter.makeSafeDocBuilderFactory",
	"Comment": "documentbuilderfactory makes a xxe safe builder factory from dbuild. if not supported by currentxml then returns original builder given and logs error.",
	"Method": "DocumentBuilderFactory makeSafeDocBuilderFactory(DocumentBuilderFactory dBuild){\r\n    String feature = null;\r\n    try {\r\n        feature = DISABLEDTD;\r\n        dBuild.setFeature(feature, true);\r\n        feature = DISABLEEXTERNALDTD;\r\n        dBuild.setFeature(feature, false);\r\n        dBuild.setXIncludeAware(false);\r\n        dBuild.setExpandEntityReferences(false);\r\n    } catch (ParserConfigurationException e) {\r\n        LOGGER.warn(\"Builder not fully configured. Feature:'{}' is probably not supported by current XML processor. {}\", feature, e);\r\n    }\r\n    return dBuild;\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.SchemaBuilder.lz4",
	"Comment": "create options for the lz4 compression strategy, to use in a create or alter table statement.",
	"Method": "TableOptions.CompressionOptions lz4(){\r\n    return new TableOptions.CompressionOptions(TableOptions.CompressionOptions.Algorithm.LZ4);\r\n}"
}, {
	"Path": "org.elixir_lang.beam.assembly.FlexLexer.yypushback",
	"Comment": "pushes the specified amount of characters back into the input stream.they will be read again by then next call of the scanning method",
	"Method": "void yypushback(int number){\r\n    if (number > yylength())\r\n        zzScanError(ZZ_PUSHBACK_2BIG);\r\n    zzMarkedPos -= number;\r\n}"
}, {
	"Path": "org.elixir_lang.reference.module.ResolvableName.resolvableName",
	"Comment": "the full name of the qualifiable alias, with any multiple aliases expanded",
	"Method": "String resolvableName(QualifiableAlias qualifiableAlias){\r\n    String resolvableName = qualifiableAlias.fullyQualifiedName();\r\n    List<String> tail = null;\r\n    if (resolvableName != null) {\r\n        tail = new ArrayList<String>();\r\n        tail.add(resolvableName);\r\n    }\r\n    return up(qualifiableAlias.getParent(), tail);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ObjectUtils.containsConstant",
	"Comment": "check whether the given array of enum constants contains a constant withthe given name.",
	"Method": "boolean containsConstant(Enum<?>[] enumValues,String constant,boolean containsConstant,Enum<?>[] enumValues,String constant,boolean caseSensitive){\r\n    for (Enum<?> candidate : enumValues) {\r\n        if (caseSensitive ? candidate.toString().equals(constant) : candidate.toString().equalsIgnoreCase(constant)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.Handle.prepareBatch",
	"Comment": "prepare a batch to execute. this is for efficiently executing more than oneof the same statements with different parameters bound.",
	"Method": "PreparedBatch prepareBatch(String sql){\r\n    return new PreparedBatch(this, sql);\r\n}"
}, {
	"Path": "org.jdbi.v3.core.Jdbi.setTransactionHandler",
	"Comment": "specify the transactionhandler instance to use. this allows overridingtransaction semantics, or mapping into different transactionmanagement systems.the default version uses local transactions on the database connectioninstances obtained.",
	"Method": "Jdbi setTransactionHandler(TransactionHandler handler){\r\n    Objects.requireNonNull(handler, \"null transaction handler\");\r\n    this.transactionhandler.set(handler);\r\n    return this;\r\n}"
}, {
	"Path": "org.elixir_lang.navigation.item_presentation.CallDefinitionSpecification.getPresentableText",
	"Comment": "returns the name of the object to be presented in most renderers across the program.",
	"Method": "String getPresentableText(){\r\n    String presentableText = null;\r\n    if (specification != null) {\r\n        presentableText = specification.getText();\r\n    }\r\n    return presentableText;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.rmi.StubGenerator.start",
	"Comment": "initializes the object.this is a method declared in javassist.translator.",
	"Method": "void start(ClassPool pool){\r\n    classPool = pool;\r\n    CtClass c = pool.get(sampleClass);\r\n    forwardMethod = c.getDeclaredMethod(\"forward\");\r\n    forwardStaticMethod = c.getDeclaredMethod(\"forwardStatic\");\r\n    proxyConstructorParamTypes = pool.get(new String[] { \"javassist.tools.rmi.ObjectImporter\", \"int\" });\r\n    interfacesForProxy = pool.get(new String[] { \"java.io.Serializable\", \"javassist.tools.rmi.Proxy\" });\r\n    exceptionForProxy = new CtClass[] { pool.get(\"javassist.tools.rmi.RemoteException\") };\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiles.DroppedFileHandler.doMove",
	"Comment": "move the given file to the base directory for its file type, and renameit to the given filename.",
	"Method": "boolean doMove(String fileName,String destFilename,NamedCompound edits){\r\n    Optional<Path> dir = panel.getBibDatabaseContext().getFirstExistingFileDir(Globals.prefs.getFilePreferences());\r\n    if (dir.isPresent()) {\r\n        Path destFile = dir.get().resolve(destFilename);\r\n        if (Files.exists(destFile)) {\r\n            int answer = JOptionPane.showConfirmDialog(null, Localization.lang(\"'%0' exists. Overwrite file?\", destFile.toString()), Localization.lang(\"Overwrite file?\"), JOptionPane.YES_NO_OPTION);\r\n            if (answer == JOptionPane.NO_OPTION) {\r\n                return false;\r\n            }\r\n        }\r\n        Path fromFile = Paths.get(fileName);\r\n        try {\r\n            if (!Files.exists(destFile)) {\r\n                Files.createDirectories(destFile);\r\n            }\r\n        } catch (IOException e) {\r\n            LOGGER.error(\"Problem creating target directories\", e);\r\n        }\r\n        if (FileUtil.renameFile(fromFile, destFile, true)) {\r\n            return true;\r\n        } else {\r\n            dialogService.showErrorDialogAndWait(Localization.lang(\"Move file failed\"), Localization.lang(\"Could not move file '%0'.\", destFile.toString()) + Localization.lang(\"Please move the file manually and link in place.\"));\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.menacheri.jetserver.convert.flex.AMFDeSerializer.fromAmf",
	"Comment": "this method takes an amf3 object in byte array form and converts it to a\tcorresponding java object.",
	"Method": "T fromAmf(ByteArrayInputStream amf){\r\n    Amf3Input amf3Input = new Amf3Input(context);\r\n    amf3Input.setInputStream(amf);\r\n    return (T) amf3Input.readObject();\r\n}"
}, {
	"Path": "org.jabref.gui.groups.GroupTreeViewModel.onActiveDatabaseChanged",
	"Comment": "gets invoked if the user changes the active database.we need to get the new group tree and update the view",
	"Method": "void onActiveDatabaseChanged(Optional<BibDatabaseContext> newDatabase){\r\n    if (newDatabase.isPresent()) {\r\n        GroupNodeViewModel newRoot = newDatabase.map(BibDatabaseContext::getMetaData).flatMap(MetaData::getGroups).map(root -> new GroupNodeViewModel(newDatabase.get(), stateManager, taskExecutor, root, localDragboard)).orElse(GroupNodeViewModel.getAllEntriesGroup(newDatabase.get(), stateManager, taskExecutor, localDragboard));\r\n        rootGroup.setValue(newRoot);\r\n        this.selectedGroups.setAll(stateManager.getSelectedGroup(newDatabase.get()).stream().map(selectedGroup -> new GroupNodeViewModel(newDatabase.get(), stateManager, taskExecutor, selectedGroup, localDragboard)).collect(Collectors.toList()));\r\n    } else {\r\n        rootGroup.setValue(GroupNodeViewModel.getAllEntriesGroup(new BibDatabaseContext(), stateManager, taskExecutor, localDragboard));\r\n    }\r\n    currentDatabase = newDatabase;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.reflect.ClassMetaobject.getReflectiveMethods",
	"Comment": "returns an array of the methods defined on the given reflectiveobject.this method is for the internal use only.",
	"Method": "Method[] getReflectiveMethods(){\r\n    if (methods != null)\r\n        return methods;\r\n    Class<?> baseclass = getJavaClass();\r\n    Method[] allmethods = baseclass.getDeclaredMethods();\r\n    int n = allmethods.length;\r\n    int[] index = new int[n];\r\n    int max = 0;\r\n    for (int i = 0; i < n; ++i) {\r\n        Method m = allmethods[i];\r\n        String mname = m.getName();\r\n        if (mname.startsWith(methodPrefix)) {\r\n            int k = 0;\r\n            for (int j = methodPrefixLen; ; ++j) {\r\n                char c = mname.charAt(j);\r\n                if ('0' <= c && c <= '9')\r\n                    k = k * 10 + c - '0';\r\n                else\r\n                    break;\r\n            }\r\n            index[i] = ++k;\r\n            if (k > max)\r\n                max = k;\r\n        }\r\n    }\r\n    methods = new Method[max];\r\n    for (int i = 0; i < n; ++i) if (index[i] > 0)\r\n        methods[index[i] - 1] = allmethods[i];\r\n    return methods;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.ProxyPlugin.transformDefinitions",
	"Comment": "modifies cglib bytecode generators to store the parameters for this plugin",
	"Method": "CtClass transformDefinitions(CtClass cc){\r\n    try {\r\n        return GeneratorParametersTransformer.transform(cc);\r\n    } catch (Exception e) {\r\n        LOGGER.error(\"Error modifying class for cglib proxy creation parameter recording\", e);\r\n    }\r\n    return cc;\r\n}"
}, {
	"Path": "org.jabref.gui.filelist.FileListTableModel.setContent",
	"Comment": "set up the table contents based on the flat string representation of the file list",
	"Method": "void setContent(String value,FileListEntry setContent,String val,boolean firstOnly,boolean deduceUnknownTypes){\r\n    String value = val;\r\n    if (value == null) {\r\n        value = \"\";\r\n    }\r\n    List<LinkedFile> fields = FileFieldParser.parse(value);\r\n    List<FileListEntry> files = new ArrayList();\r\n    for (LinkedFile entry : fields) {\r\n        if (entry.isEmpty()) {\r\n            continue;\r\n        }\r\n        if (firstOnly) {\r\n            return decodeEntry(entry, deduceUnknownTypes);\r\n        } else {\r\n            files.add(decodeEntry(entry, deduceUnknownTypes));\r\n        }\r\n    }\r\n    synchronized (list) {\r\n        list.clear();\r\n        list.addAll(files);\r\n    }\r\n    fireTableChanged(new TableModelEvent(this));\r\n    return null;\r\n}"
}, {
	"Path": "org.jabref.gui.collab.FileUpdatePanel.scanResultsResolved",
	"Comment": "callback method for signalling that the change scanner has displayed thescan results to the user.",
	"Method": "void scanResultsResolved(boolean resolved){\r\n    if (resolved) {\r\n        manager.hide(this.getType());\r\n        panel.markExternalChangesAsResolved();\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.SchemaBuilder.millisecs",
	"Comment": "create the speculative retry strategy that retries after a given delay, to use in a create oralter table statement.",
	"Method": "TableOptions.SpeculativeRetryValue millisecs(int millisecs){\r\n    if (millisecs < 0) {\r\n        throw new IllegalArgumentException(\"Millisecond value for speculative retry should be positive\");\r\n    }\r\n    return new TableOptions.SpeculativeRetryValue(\"'\" + millisecs + \"ms'\");\r\n}"
}, {
	"Path": "org.hotswap.agent.tutorial.framework.PrinterService.startWorkingThread",
	"Comment": "do the printing.it will just write to printtarget in infinite loop list of all print contents.",
	"Method": "void startWorkingThread(){\r\n    new Thread(() -> {\r\n        while (true) {\r\n            try {\r\n                if (stopped) {\r\n                    break;\r\n                }\r\n                print();\r\n                Thread.sleep(100);\r\n            } catch (InterruptedException e) {\r\n                break;\r\n            }\r\n        }\r\n    }).start();\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.SchemaBuilder.deflate",
	"Comment": "create options for the deflate compression strategy, to use in a create or alter tablestatement.",
	"Method": "TableOptions.CompressionOptions deflate(){\r\n    return new TableOptions.CompressionOptions(TableOptions.CompressionOptions.Algorithm.DEFLATE);\r\n}"
}, {
	"Path": "com.datastax.driver.core.SessionManager.replacePool",
	"Comment": "this returns a future if the replacement was successful, or null if we raced.",
	"Method": "ListenableFuture<Void> replacePool(Host host,HostDistance distance,HostConnectionPool previous,Connection reusedConnection){\r\n    if (isClosing)\r\n        return MoreFutures.VOID_SUCCESS;\r\n    final HostConnectionPool newPool = new HostConnectionPool(host, distance, this);\r\n    if (previous == null) {\r\n        if (pools.putIfAbsent(host, newPool) != null) {\r\n            return null;\r\n        }\r\n    } else {\r\n        if (!pools.replace(host, previous, newPool)) {\r\n            return null;\r\n        }\r\n        if (!previous.isClosed()) {\r\n            logger.warn(\"Replacing a pool that wasn't closed. Closing it now, but this was not expected.\");\r\n            previous.closeAsync();\r\n        }\r\n    }\r\n    ListenableFuture<Void> poolInitFuture = newPool.initAsync(reusedConnection);\r\n    GuavaCompatibility.INSTANCE.addCallback(poolInitFuture, new FutureCallback<Void>() {\r\n        @Override\r\n        public void onSuccess(Void result) {\r\n            if (isClosing) {\r\n                newPool.closeAsync();\r\n                pools.remove(host);\r\n            }\r\n        }\r\n        @Override\r\n        public void onFailure(Throwable t) {\r\n            pools.remove(host);\r\n        }\r\n    });\r\n    return poolInitFuture;\r\n}"
}, {
	"Path": "com.datastax.driver.core.SessionManager.replacePool",
	"Comment": "this returns a future if the replacement was successful, or null if we raced.",
	"Method": "ListenableFuture<Void> replacePool(Host host,HostDistance distance,HostConnectionPool previous,Connection reusedConnection){\r\n    if (isClosing) {\r\n        newPool.closeAsync();\r\n        pools.remove(host);\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.SessionManager.replacePool",
	"Comment": "this returns a future if the replacement was successful, or null if we raced.",
	"Method": "ListenableFuture<Void> replacePool(Host host,HostDistance distance,HostConnectionPool previous,Connection reusedConnection){\r\n    pools.remove(host);\r\n}"
}, {
	"Path": "com.datastax.driver.core.TableOptionsMetadata.getExtensions",
	"Comment": "returns the extension options for this table.for cassandra versions prior to 3.0.0, this method always returns an empty map.",
	"Method": "Map<String, ByteBuffer> getExtensions(){\r\n    return extensions;\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fetcher.BibsonomyScraper.getEntry",
	"Comment": "return a bibentry by looking up the given url from the bibsonomy scraper.",
	"Method": "Optional<BibEntry> getEntry(String entryUrl,ImportFormatPreferences importFormatPreferences){\r\n    try {\r\n        String cleanURL = entryUrl.replace(\"%\", \"%\").replace(\":\", \":\").replace(\"/\", \"/\").replace(\"?\", \"?\").replace(\"&\", \"&\").replace(\"=\", \"=\");\r\n        URL url = new URL(BibsonomyScraper.BIBSONOMY_SCRAPER + cleanURL + BibsonomyScraper.BIBSONOMY_SCRAPER_POST);\r\n        String bibtex = new URLDownload(url).asString();\r\n        return BibtexParser.singleFromString(bibtex, importFormatPreferences, new DummyFileUpdateMonitor());\r\n    } catch (IOException ex) {\r\n        LOGGER.warn(\"Could not download entry\", ex);\r\n        return Optional.empty();\r\n    } catch (ParseException ex) {\r\n        LOGGER.warn(\"Could not parse entry\", ex);\r\n        return Optional.empty();\r\n    } catch (RuntimeException ex) {\r\n        LOGGER.warn(\"Could not get entry\", ex);\r\n        return Optional.empty();\r\n    }\r\n}"
}, {
	"Path": "com.beust.jcommander.UnixStyleUsageFormatterTest.usageWithRequiredArgsAndResourceBundle",
	"Comment": "test a use case where there are required parameters, but you still wantto interrogate the options which are specified.",
	"Method": "void usageWithRequiredArgsAndResourceBundle(){\r\n    ArgsHelp argsHelp = new ArgsHelp();\r\n    JCommander jc = JCommander.newBuilder().addObject(new Object[] { argsHelp, new ArgsRequired() }).resourceBundle(DefaultUsageFormatterTest.getResourceBundle()).build();\r\n    jc.setUsageFormatter(new UnixStyleUsageFormatter(jc));\r\n    jc.getUsageFormatter().usage(new StringBuilder());\r\n    try {\r\n        jc.parse(\"-h\");\r\n        Assert.fail(\"Should have thrown a required parameter exception\");\r\n    } catch (ParameterException e) {\r\n        Assert.assertTrue(e.getMessage().contains(\"are required\"));\r\n    }\r\n    Assert.assertTrue(argsHelp.help);\r\n}"
}, {
	"Path": "org.jabref.gui.BasePanel.getSuggestionProviders",
	"Comment": "returns a collection of suggestion providers, which are populated from the current library.",
	"Method": "SuggestionProviders getSuggestionProviders(){\r\n    return suggestionProviders;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.jersey2.Jersey2Plugin.registerJerseyContainer",
	"Comment": "register the jersey container and the classes involved in configuring the jersey application",
	"Method": "void registerJerseyContainer(Object jerseyContainer,Object resourceConfig){\r\n    try {\r\n        Class<?> resourceConfigClass = resolveClass(\"org.glassfish.jersey.server.ResourceConfig\");\r\n        LOGGER.info(\"registerJerseyContainer : \" + jerseyContainer.getClass().getName());\r\n        Set<Class<?>> containerClasses = getContainerClasses(resourceConfigClass, resourceConfig);\r\n        registeredJerseyContainers.add(jerseyContainer);\r\n        allRegisteredClasses.addAll(containerClasses);\r\n        LOGGER.debug(\"registerJerseyContainer : finished\");\r\n    } catch (Exception e) {\r\n        LOGGER.error(\"Error registering Jersey Container.\", e);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.test.util.HotSwapTestHelper.__toVersion__",
	"Comment": "redefines all inner classes of a outer class to a specified version. inner classes who do not have a particularrepresentation for a version remain unchanged.caller class is used as an outer class.",
	"Method": "void __toVersion__(int versionNumber,Class<?> extra){\r\n    HotSwapTool.toVersion(determineOuter(0), versionNumber, extra);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.reflect.Metaobject.getClassMetaobject",
	"Comment": "obtains the class metaobject associated with this metaobject.",
	"Method": "ClassMetaobject getClassMetaobject(){\r\n    return classmetaobject;\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.KeyspaceOptions.durableWrites",
	"Comment": "define the durable writes option for the statement. if set to false, data written to thekeyspace will bypass the commit log.",
	"Method": "KeyspaceOptions durableWrites(Boolean durableWrites){\r\n    this.durableWrites = Optional.fromNullable(durableWrites);\r\n    return this;\r\n}"
}, {
	"Path": "org.jabref.logic.l10n.LocalizationParser.getLanguageKeysInFxmlFile",
	"Comment": "loads the fxml file and returns all used language resources.",
	"Method": "List<LocalizationEntry> getLanguageKeysInFxmlFile(Path path,LocalizationBundleForTest type){\r\n    List<String> result = new ArrayList();\r\n    ResourceBundle registerUsageResourceBundle = new ResourceBundle() {\r\n        @Override\r\n        protected Object handleGetObject(String key) {\r\n            result.add(key);\r\n            return \"test\";\r\n        }\r\n        @Override\r\n        public Enumeration<String> getKeys() {\r\n            return null;\r\n        }\r\n        @Override\r\n        public boolean containsKey(String key) {\r\n            return true;\r\n        }\r\n    };\r\n    PlatformImpl.startup(() -> {\r\n    });\r\n    try {\r\n        FXMLLoader loader = new FXMLLoader(path.toUri().toURL(), registerUsageResourceBundle);\r\n        loader.setControllerFactory(controllerType -> null);\r\n        loader.impl_setStaticLoad(true);\r\n        loader.load();\r\n    } catch (IOException exception) {\r\n        throw new RuntimeException(exception);\r\n    }\r\n    return result.stream().map(key -> new LocalizationEntry(path, new LocalizationKey(key).getPropertiesKey(), type)).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.jabref.logic.l10n.LocalizationParser.getLanguageKeysInFxmlFile",
	"Comment": "loads the fxml file and returns all used language resources.",
	"Method": "List<LocalizationEntry> getLanguageKeysInFxmlFile(Path path,LocalizationBundleForTest type){\r\n    result.add(key);\r\n    return \"test\";\r\n}"
}, {
	"Path": "org.jabref.logic.l10n.LocalizationParser.getLanguageKeysInFxmlFile",
	"Comment": "loads the fxml file and returns all used language resources.",
	"Method": "List<LocalizationEntry> getLanguageKeysInFxmlFile(Path path,LocalizationBundleForTest type){\r\n    return null;\r\n}"
}, {
	"Path": "org.jabref.logic.l10n.LocalizationParser.getLanguageKeysInFxmlFile",
	"Comment": "loads the fxml file and returns all used language resources.",
	"Method": "List<LocalizationEntry> getLanguageKeysInFxmlFile(Path path,LocalizationBundleForTest type){\r\n    return true;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.transaction.CMTTransactionHandler.rollback",
	"Comment": "called when a transaction is rolled backwill throw a runtimeexception to force transactional rollback",
	"Method": "void rollback(Handle handle){\r\n    throw new TransactionException(\"Rollback called, this runtime exception thrown to halt the transaction\");\r\n}"
}, {
	"Path": "org.jdbi.v3.core.Handle.createQuery",
	"Comment": "return a query instance that executes a statementwith bound parameters and maps the result set into java types.",
	"Method": "Query createQuery(String sql){\r\n    return new Query(this, sql);\r\n}"
}, {
	"Path": "org.jabref.model.cleanup.Formatter.hashCode",
	"Comment": "returns a default hashcode of the formatter based on its key.",
	"Method": "int hashCode(){\r\n    return getKey().hashCode();\r\n}"
}, {
	"Path": "org.elixir_lang.run.TerminalExecutionConsole.clear",
	"Comment": "clears history and screen buffers, positions the cursor at the top left corner.",
	"Method": "void clear(){\r\n    myLastCR = false;\r\n    ((MyJBTerminalPanel) myTerminalWidget.getTerminalPanel()).clearBuffer();\r\n}"
}, {
	"Path": "com.beust.jcommander.JCommander.readFile",
	"Comment": "reads the file specified by filename and returns the file content as a string.end of lines are replaced by a space.",
	"Method": "List<String> readFile(String fileName){\r\n    List<String> result = Lists.newArrayList();\r\n    try (BufferedReader bufRead = Files.newBufferedReader(Paths.get(fileName), options.atFileCharset)) {\r\n        String line;\r\n        while ((line = bufRead.readLine()) != null) {\r\n            if (line.length() > 0 && !line.trim().startsWith(\"#\")) {\r\n                result.add(line);\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        throw new ParameterException(\"Could not read file \" + fileName + \": \" + e);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jabref.logic.formatter.bibtexfields.ClearFormatterTest.formatReturnsEmptyForSomeString",
	"Comment": "check whether the clear formatter really returns the empty string for some string",
	"Method": "void formatReturnsEmptyForSomeString(){\r\n    assertEquals(\"\", formatter.format(\"test\"));\r\n}"
}, {
	"Path": "com.datastax.driver.core.QueryLogger.setMaxQueryStringLength",
	"Comment": "set the maximum length of a cql query string that can be logged verbatim by the driver. querystrings longer than this value will be truncated when logged.",
	"Method": "void setMaxQueryStringLength(int maxQueryStringLength){\r\n    if (maxQueryStringLength <= 0 && maxQueryStringLength != -1)\r\n        throw new IllegalArgumentException(\"Invalid maxQueryStringLength, should be > 0 or -1, got \" + maxQueryStringLength);\r\n    this.maxQueryStringLength = maxQueryStringLength;\r\n}"
}, {
	"Path": "org.elixir_lang.navigation.item_presentation.FunctionDelegation.getPresentableText",
	"Comment": "returns the name of the object to be presented in most renderers across the program.",
	"Method": "String getPresentableText(){\r\n    StringBuilder presentableText = new StringBuilder(name());\r\n    presentableText.append('(');\r\n    presentableText.append(StringUtil.join(argumentNames, \", \"));\r\n    presentableText.append(\"), do: \");\r\n    presentableText.append(delegation.to());\r\n    presentableText.append('.');\r\n    presentableText.append(as());\r\n    presentableText.append('(');\r\n    int start;\r\n    if (delegation.appendFirst()) {\r\n        start = 1;\r\n    } else {\r\n        start = 0;\r\n    }\r\n    for (int i = 0; i < argumentNames.length; i++) {\r\n        if (i > 0) {\r\n            presentableText.append(\", \");\r\n        }\r\n        int index = (start + i) % argumentNames.length;\r\n        presentableText.append(argumentNames[index]);\r\n    }\r\n    presentableText.append(')');\r\n    return presentableText.toString();\r\n}"
}, {
	"Path": "org.jabref.logic.shared.DBMSSynchronizer.initializeDatabases",
	"Comment": "sets the table structure of shared database if needed and pulls all shared entriesto the new local database.",
	"Method": "void initializeDatabases(){\r\n    try {\r\n        if (!dbmsProcessor.checkBaseIntegrity()) {\r\n            LOGGER.info(\"Integrity check failed. Fixing...\");\r\n            dbmsProcessor.setupSharedDatabase();\r\n            if (dbmsProcessor.checkForPre3Dot6Intergrity()) {\r\n                throw new DatabaseNotSupportedException();\r\n            }\r\n        }\r\n    } catch (SQLException e) {\r\n        throw new IllegalStateException(e);\r\n    }\r\n    dbmsProcessor.startNotificationListener(this);\r\n    synchronizeLocalMetaData();\r\n    synchronizeLocalDatabase();\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.Create.addStaticColumn",
	"Comment": "add a static column definition to this create table statement.",
	"Method": "Create addStaticColumn(String columnName,DataType dataType){\r\n    validateNotEmpty(columnName, \"Column name\");\r\n    validateNotNull(dataType, \"Column type\");\r\n    validateNotKeyWord(columnName, String.format(\"The static column name '%s' is not allowed because it is a reserved keyword\", columnName));\r\n    staticColumns.put(columnName, new NativeColumnType(dataType));\r\n    return this;\r\n}"
}, {
	"Path": "org.elixir_lang.beam.psi.BeamFileImpl.getModificationStamp",
	"Comment": "gets the modification stamp value. modification stamp is a value changed by any modificationof the content of the file. note that it is not related to the file modification time.",
	"Method": "long getModificationStamp(){\r\n    return getVirtualFile().getModificationStamp();\r\n}"
}, {
	"Path": "com.datastax.driver.core.PreparedStatementTest.should_unset_value_by_name",
	"Comment": "tests that a value that was previously set on a bound statement can be unset by name. this onlyworks from protocol v4 onwards.",
	"Method": "void should_unset_value_by_name(){\r\n    PreparedStatement prepared = session().prepare(\"INSERT INTO \" + SIMPLE_TABLE + \" (k, i) VALUES (:k, :i)\");\r\n    BoundStatement bound = prepared.bind();\r\n    bound.setString(\"k\", \"foo\");\r\n    bound.setInt(\"i\", 1234);\r\n    bound.unset(\"i\");\r\n    assertThat(bound.isSet(\"i\")).isFalse();\r\n    session().execute(bound);\r\n    ResultSet rows = session().execute(new SimpleStatement(\"SELECT i from \" + SIMPLE_TABLE + \" where k = 'foo'\").enableTracing());\r\n    assertThat(rows.one().isNull(\"i\"));\r\n    Uninterruptibles.sleepUninterruptibly(10, TimeUnit.SECONDS);\r\n    QueryTrace queryTrace = rows.getExecutionInfo().getQueryTrace();\r\n    assertEventsContain(queryTrace, \"0 tombstone\");\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.weld.command.BeanClassRefreshAgent.recreateProxy",
	"Comment": "recreate proxy classes, called from beanclassrefreshcommand.",
	"Method": "void recreateProxy(ClassLoader classLoader,String archivePath,Map registeredProxiedBeans,String beanClassName,String oldSignatureForProxyCheck){\r\n    BeanClassRefreshAgent bdaAgent = BdaAgentRegistry.get(archivePath);\r\n    if (bdaAgent == null) {\r\n        LOGGER.error(\"Archive path '{}' is not associated with any BeanClassRefreshAgent\", archivePath);\r\n        return;\r\n    }\r\n    try {\r\n        Class<?> beanClass = bdaAgent.getClass().getClassLoader().loadClass(beanClassName);\r\n        bdaAgent.doRecreateProxy(classLoader, registeredProxiedBeans, beanClass, oldSignatureForProxyCheck);\r\n    } catch (ClassNotFoundException e) {\r\n        LOGGER.error(\"Bean class not found.\", e);\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.TracingTest.should_preserve_tracing_status_across_retries",
	"Comment": "validates that if a query gets retried, the second internal query will still have tracingenabled.to force a retry, we use the downgrading policy with an impossible cl.",
	"Method": "void should_preserve_tracing_status_across_retries(){\r\n    SimpleStatement st = new SimpleStatement(String.format(\"SELECT v FROM test WHERE k='%s'\", KEY));\r\n    st.setConsistencyLevel(ConsistencyLevel.THREE).enableTracing();\r\n    ResultSet result = session().execute(st);\r\n    Uninterruptibles.sleepUninterruptibly(10, TimeUnit.SECONDS);\r\n    assertThat(result.getExecutionInfo().getQueryTrace()).isNotNull();\r\n}"
}, {
	"Path": "org.jabref.logic.util.io.FileUtil.getListOfLinkedFiles",
	"Comment": "returns the list of linked files. the files have the absolute filename",
	"Method": "List<Path> getListOfLinkedFiles(List<BibEntry> bes,List<Path> fileDirs){\r\n    Objects.requireNonNull(bes);\r\n    Objects.requireNonNull(fileDirs);\r\n    return bes.stream().flatMap(entry -> entry.getFiles().stream()).flatMap(file -> OptionalUtil.toStream(file.findIn(fileDirs))).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.jabref.gui.journals.ManageJournalAbbreviationsViewModel.addBuiltInLists",
	"Comment": "this will wrap the built in and ieee abbreviations in pseudo abbreviation filesand add them to the list of journal abbreviation files.",
	"Method": "void addBuiltInLists(){\r\n    BackgroundTask.wrap(JournalAbbreviationLoader::getBuiltInAbbreviations).onRunning(() -> isLoadingBuiltIn.setValue(true)).onSuccess(result -> {\r\n        isLoadingBuiltIn.setValue(false);\r\n        addList(Localization.lang(\"JabRef built in list\"), result);\r\n        selectLastJournalFile();\r\n    }).onFailure(dialogService::showErrorDialogAndWait).executeWith(taskExecutor);\r\n    BackgroundTask.wrap(() -> {\r\n        if (abbreviationsPreferences.useIEEEAbbreviations()) {\r\n            return JournalAbbreviationLoader.getOfficialIEEEAbbreviations();\r\n        } else {\r\n            return JournalAbbreviationLoader.getStandardIEEEAbbreviations();\r\n        }\r\n    }).onRunning(() -> isLoadingIeee.setValue(true)).onSuccess(result -> {\r\n        isLoadingIeee.setValue(false);\r\n        addList(Localization.lang(\"IEEE built in list\"), result);\r\n    }).onFailure(dialogService::showErrorDialogAndWait).executeWith(taskExecutor);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.hibernate3.session.Hibernate3Transformers.proxyHibernatePersistence",
	"Comment": "if org.hibernate.ejb.hibernatepersistence is loaded then we live in a jpaenvironment. disable the hibernate3plugin reload command",
	"Method": "void proxyHibernatePersistence(CtClass clazz){\r\n    CtConstructor con = clazz.getDeclaredConstructor(new CtClass[] {});\r\n    LOGGER.debug(\"org.hibernate.ejb.HibernatePersistence.<init>\");\r\n    // \r\n    con.insertAfter(\"java.lang.ClassLoader $$cl = Thread.currentThread().getContextClassLoader();\" + PluginManagerInvoker.buildInitializePlugin(Hibernate3Plugin.class, \"$$cl\") + PluginManagerInvoker.buildCallPluginMethod(\"$$cl\", Hibernate3Plugin.class, \"disable\"));\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.spring.scanner.ClassPathBeanDefinitionScannerAgent.resetCachingMetadataReaderFactoryCache",
	"Comment": "metadatareader contains cache of loaded classes, reset this cache before beandefinition is resolved",
	"Method": "void resetCachingMetadataReaderFactoryCache(){\r\n    if (getMetadataReaderFactory() instanceof CachingMetadataReaderFactory) {\r\n        Map metadataReaderCache = (Map) ReflectionHelper.getNoException(getMetadataReaderFactory(), CachingMetadataReaderFactory.class, \"metadataReaderCache\");\r\n        if (metadataReaderCache == null)\r\n            metadataReaderCache = (Map) ReflectionHelper.getNoException(getMetadataReaderFactory(), CachingMetadataReaderFactory.class, \"classReaderCache\");\r\n        if (metadataReaderCache != null) {\r\n            metadataReaderCache.clear();\r\n            LOGGER.debug(\"Cache cleared: CachingMetadataReaderFactory.clearCache()\");\r\n        } else {\r\n            LOGGER.warning(\"Cache NOT cleared: neither CachingMetadataReaderFactory.metadataReaderCache nor clearCache does not exist.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.ProxyClassSignatureHelper.isNonSyntheticPoolClassOrParentDifferent",
	"Comment": "checks if the ctclass or one of its parents signature differs from the one already loaded by java. ignoressynthetic classes",
	"Method": "boolean isNonSyntheticPoolClassOrParentDifferent(Class<?> classBeingRedefined,ClassPool cp){\r\n    Class<?> clazz = classBeingRedefined.getSuperclass();\r\n    while (clazz.isSynthetic() || clazz.getName().contains(\"$Enhancer\")) {\r\n        clazz = clazz.getSuperclass();\r\n    }\r\n    if (isPoolClassOrParentDifferent(clazz, cp))\r\n        return true;\r\n    Class<?>[] interfaces = classBeingRedefined.getInterfaces();\r\n    for (Class<?> intr : interfaces) {\r\n        if (isPoolClassOrParentDifferent(intr, cp))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.elixir_lang.parser.ElixirParser.unmatchedQualifiedBracketOperation_0",
	"Comment": "dotinfixoperator relativeidentifier call bracketarguments",
	"Method": "boolean unmatchedQualifiedBracketOperation_0(PsiBuilder b,int l){\r\n    if (!recursion_guard_(b, l, \"unmatchedQualifiedBracketOperation_0\"))\r\n        return false;\r\n    boolean r;\r\n    Marker m = enter_section_(b);\r\n    r = dotInfixOperator(b, l + 1);\r\n    r = r && relativeIdentifier(b, l + 1);\r\n    r = r && consumeToken(b, CALL);\r\n    r = r && bracketArguments(b, l + 1);\r\n    exit_section_(b, m, null, r);\r\n    return r;\r\n}"
}, {
	"Path": "org.jabref.gui.edit.MassSetFieldsDialog.massSetField",
	"Comment": "set a given field to a given value for all entries in a collection. this method does not update any undomanager,but returns a relevant compoundedit that should be registered by the caller.",
	"Method": "UndoableEdit massSetField(Collection<BibEntry> entries,String field,String textToSet,boolean overwriteValues){\r\n    NamedCompound compoundEdit = new NamedCompound(Localization.lang(\"Set field\"));\r\n    for (BibEntry entry : entries) {\r\n        Optional<String> oldValue = entry.getField(field);\r\n        if (!overwriteValues && (oldValue.isPresent()) && !oldValue.get().isEmpty()) {\r\n            continue;\r\n        }\r\n        if (textToSet == null) {\r\n            entry.clearField(field);\r\n        } else {\r\n            entry.setField(field, textToSet);\r\n        }\r\n        compoundEdit.addEdit(new UndoableFieldChange(entry, field, oldValue.orElse(null), textToSet));\r\n    }\r\n    compoundEdit.end();\r\n    return compoundEdit;\r\n}"
}, {
	"Path": "com.datastax.driver.core.policies.Policies.getLoadBalancingPolicy",
	"Comment": "the load balancing policy in use.the load balancing policy defines how cassandra hosts are picked for queries.",
	"Method": "LoadBalancingPolicy getLoadBalancingPolicy(){\r\n    return loadBalancingPolicy;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.ReflectionHelper.get",
	"Comment": "convenience wrapper to reflection method invoke api. get field value and hide checked exceptions.",
	"Method": "Object get(Object target,String fieldName,Object get,Object target,Class<?> clazz,String fieldName){\r\n    try {\r\n        Field field = clazz.getDeclaredField(fieldName);\r\n        field.setAccessible(true);\r\n        return field.get(target);\r\n    } catch (NoSuchFieldException e) {\r\n        throw new IllegalArgumentException(String.format(\"No such field %s.%s on %s\", clazz.getName(), fieldName, target), e);\r\n    } catch (IllegalAccessException e) {\r\n        throw new IllegalArgumentException(String.format(\"Illegal access field %s.%s on %s\", clazz.getName(), fieldName, target), e);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.migrations.FileLinksUpgradeWarning.linksFound",
	"Comment": "check the database to find out whether any of a set of fields are usedfor any of the entries.",
	"Method": "boolean linksFound(BibDatabase database,String[] fields){\r\n    for (BibEntry entry : database.getEntries()) {\r\n        for (String field : fields) {\r\n            if (entry.hasField(field)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.elixir_lang.parser.ElixirParser.maxQualifiedParenthesesCall",
	"Comment": "dotinfixoperator relativeidentifier matchedparenthesesarguments",
	"Method": "boolean maxQualifiedParenthesesCall(PsiBuilder b,int l){\r\n    if (!recursion_guard_(b, l, \"maxQualifiedParenthesesCall\"))\r\n        return false;\r\n    if (!nextTokenIs(b, DOT_OPERATOR))\r\n        return false;\r\n    boolean r;\r\n    Marker m = enter_section_(b, l, _LEFT_, MATCHED_QUALIFIED_PARENTHESES_CALL, null);\r\n    r = dotInfixOperator(b, l + 1);\r\n    r = r && relativeIdentifier(b, l + 1);\r\n    r = r && matchedParenthesesArguments(b, l + 1);\r\n    exit_section_(b, l, m, r, false, null);\r\n    return r;\r\n}"
}, {
	"Path": "com.datastax.driver.core.CodecUtils.writeValue",
	"Comment": "utility method that writes a value. mainly intended for collection codecs when deserializingcql collections.",
	"Method": "void writeValue(ByteBuffer output,ByteBuffer value,ProtocolVersion version){\r\n    switch(version) {\r\n        case V1:\r\n        case V2:\r\n            assert value != null;\r\n            output.putShort((short) value.remaining());\r\n            output.put(value.duplicate());\r\n            break;\r\n        case V3:\r\n        case V4:\r\n        case V5:\r\n            if (value == null) {\r\n                output.putInt(-1);\r\n            } else {\r\n                output.putInt(value.remaining());\r\n                output.put(value.duplicate());\r\n            }\r\n            break;\r\n        default:\r\n            throw version.unsupported();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.push.PushToApplicationSettings.initSettingsPanel",
	"Comment": "create a formbuilder, fill it with a textbox for the path and store the jpanel in settings",
	"Method": "void initSettingsPanel(){\r\n    builder = FormBuilder.create();\r\n    builder.layout(new FormLayout(\"left:pref, 4dlu, fill:pref:grow, 4dlu, fill:pref\", \"p\"));\r\n    StringBuilder label = new StringBuilder(Localization.lang(\"Path to %0\", application.commandPathPreferenceKey));\r\n    if (application.getCommandName() == null) {\r\n        label.append(':');\r\n    } else {\r\n        label.append(\" (\").append(application.getCommandName()).append(\"):\");\r\n    }\r\n    builder.add(label.toString()).xy(1, 1);\r\n    builder.add(path).xy(3, 1);\r\n    JButton browse = new JButton(Localization.lang(\"Browse\"));\r\n    FileDialogConfiguration fileDialogConfiguration = new FileDialogConfiguration.Builder().withInitialDirectory(Globals.prefs.get(JabRefPreferences.WORKING_DIRECTORY)).build();\r\n    browse.addActionListener(e -> DefaultTaskExecutor.runInJavaFXThread(() -> dialogService.showFileOpenDialog(fileDialogConfiguration)).ifPresent(f -> path.setText(f.toAbsolutePath().toString())));\r\n    builder.add(browse).xy(5, 1);\r\n    settings = builder.build();\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.util.HotSwapAgent.startAgent",
	"Comment": "ensures that the agent is ready.it attempts to dynamically start the agent if necessary.",
	"Method": "void startAgent(){\r\n    if (instrumentation != null)\r\n        return;\r\n    try {\r\n        File agentJar = createJarFile();\r\n        String nameOfRunningVM = ManagementFactory.getRuntimeMXBean().getName();\r\n        String pid = nameOfRunningVM.substring(0, nameOfRunningVM.indexOf('@'));\r\n        VirtualMachine vm = VirtualMachine.attach(pid);\r\n        vm.loadAgent(agentJar.getAbsolutePath(), null);\r\n        vm.detach();\r\n    } catch (Exception e) {\r\n        throw new NotFoundException(\"hotswap agent\", e);\r\n    }\r\n    for (int sec = 0; sec < 10; sec++) {\r\n        if (instrumentation != null)\r\n            return;\r\n        try {\r\n            Thread.sleep(1000);\r\n        } catch (InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n            break;\r\n        }\r\n    }\r\n    throw new NotFoundException(\"hotswap agent (timeout)\");\r\n}"
}, {
	"Path": "com.datastax.driver.core.policies.Policies.getRetryPolicy",
	"Comment": "the retry policy in use.the retry policy defines in which conditions a query should be automatically retries by thedriver.",
	"Method": "RetryPolicy getRetryPolicy(){\r\n    return retryPolicy;\r\n}"
}, {
	"Path": "org.jabref.logic.formatter.bibtexfields.EscapeUnderscoresFormatterTest.formatReturnsSameTextIfNoUnderscoresPresent",
	"Comment": "check whether the clear formatter really returns the empty string for the empty string",
	"Method": "void formatReturnsSameTextIfNoUnderscoresPresent(){\r\n    assertEquals(\"Lorem ipsum\", formatter.format(\"Lorem ipsum\"));\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.SqlStatement.bindMethods",
	"Comment": "binds methods with no parameters on the argument, with the given prefix.",
	"Method": "This bindMethods(Object object,This bindMethods,String prefix,Object object){\r\n    return bindNamedArgumentFinder(new ObjectMethodArguments(prefix, object));\r\n}"
}, {
	"Path": "com.datastax.driver.examples.json.Jsr353JsonRow.selectJsonRow",
	"Comment": "retrieving user instances from table rows using select json",
	"Method": "void selectJsonRow(Session session){\r\n    Statement stmt = select().json().from(\"examples\", \"json_jsr353_row\").where(in(\"id\", 1, 2));\r\n    ResultSet rows = session.execute(stmt);\r\n    for (Row row : rows) {\r\n        JsonObject user = (JsonObject) row.get(0, JsonStructure.class);\r\n        System.out.printf(\"Retrieved user: %s%n\", user);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.jvm.AnonymousClassPatchPlugin.patchMainClass",
	"Comment": "if class contains anonymous classes, rename class references to compatible transition classes.if the transitioned class is not loaded by hotswap replace, catch class define event to dothe replacement.define new synthetic classes for not compatible changes.",
	"Method": "byte[] patchMainClass(String className,ClassPool classPool,CtClass ctClass,ClassLoader classLoader,ProtectionDomain protectionDomain){\r\n    String javaClassName = className.replaceAll(\"/\", \".\");\r\n    if (!ClassLoaderHelper.isClassLoaded(classLoader, javaClassName + \"$1\"))\r\n        return null;\r\n    AnonymousClassInfos stateInfo = getStateInfo(classLoader, classPool, javaClassName);\r\n    Map<AnonymousClassInfo, AnonymousClassInfo> transitions = stateInfo.getCompatibleTransitions();\r\n    ClassMap replaceClassNameMap = new ClassMap();\r\n    for (Map.Entry<AnonymousClassInfo, AnonymousClassInfo> entry : transitions.entrySet()) {\r\n        String compatibleName = entry.getKey().getClassName();\r\n        String newName = entry.getValue().getClassName();\r\n        if (!newName.equals(compatibleName)) {\r\n            replaceClassNameMap.put(newName, compatibleName);\r\n            LOGGER.trace(\"Class '{}' replacing '{}' for '{}'\", javaClassName, newName, compatibleName);\r\n        }\r\n        if (isHotswapAgentSyntheticClass(compatibleName)) {\r\n            LOGGER.debug(\"Anonymous class '{}' not comatible and is replaced with synthetic class '{}'\", newName, compatibleName);\r\n            CtClass anonymous = classPool.get(newName);\r\n            anonymous.replaceClassName(newName, compatibleName);\r\n            anonymous.toClass(classLoader, protectionDomain);\r\n        } else if (!ClassLoaderHelper.isClassLoaded(classLoader, newName)) {\r\n            CtClass anonymous = classPool.get(compatibleName);\r\n            anonymous.replaceClassName(compatibleName, newName);\r\n            LOGGER.debug(\"Anonymous class '{}' - will be replaced from class file {}.\", newName, compatibleName);\r\n            registerReplaceOnLoad(newName, anonymous);\r\n        }\r\n    }\r\n    ctClass.replaceClassName(replaceClassNameMap);\r\n    LOGGER.reload(\"Class '{}' has been enhanced with anonymous classes for hotswap.\", className);\r\n    return ctClass.toBytecode();\r\n}"
}, {
	"Path": "org.jabref.logic.xmp.XmpUtilWriterTest.testWriteXmp",
	"Comment": "test for writing a pdf file with a single dublincore metadata entry.",
	"Method": "void testWriteXmp(Path tempDir){\r\n    Path pdfFile = this.createDefaultFile(\"JabRef_writeSingle.pdf\", tempDir);\r\n    BibEntry entry = vapnik2000;\r\n    entry.setCiteKey(\"WriteXMPTest\");\r\n    entry.setId(\"ID4711\");\r\n    XmpUtilWriter.writeXmp(pdfFile.toAbsolutePath().toString(), entry, null, xmpPreferences);\r\n    List<BibEntry> entriesWritten = XmpUtilReader.readXmp(pdfFile.toAbsolutePath().toString(), xmpPreferences);\r\n    BibEntry entryWritten = entriesWritten.get(0);\r\n    assertEquals(entry, entryWritten);\r\n}"
}, {
	"Path": "org.jabref.logic.util.io.FileUtil.uniquePathSubstrings",
	"Comment": "creates the minimal unique path substring for each file among multiple file paths.",
	"Method": "List<String> uniquePathSubstrings(List<String> paths){\r\n    List<Stack<String>> stackList = new ArrayList(paths.size());\r\n    for (String path : paths) {\r\n        List<String> directories = Arrays.asList(path.split(Pattern.quote(File.separator)));\r\n        Stack<String> stack = new Stack();\r\n        stack.addAll(directories);\r\n        stackList.add(stack);\r\n    }\r\n    List<String> pathSubstrings = new ArrayList(Collections.nCopies(paths.size(), \"\"));\r\n    while (!stackList.stream().allMatch(Vector::isEmpty)) {\r\n        for (int i = 0; i < stackList.size(); i++) {\r\n            String tempString = pathSubstrings.get(i);\r\n            if (tempString.isEmpty() && !stackList.get(i).isEmpty()) {\r\n                pathSubstrings.set(i, stackList.get(i).pop());\r\n            } else if (!stackList.get(i).isEmpty()) {\r\n                pathSubstrings.set(i, stackList.get(i).pop() + File.separator + tempString);\r\n            }\r\n        }\r\n        for (int i = 0; i < stackList.size(); i++) {\r\n            String tempString = pathSubstrings.get(i);\r\n            if (Collections.frequency(pathSubstrings, tempString) == 1) {\r\n                stackList.get(i).clear();\r\n            }\r\n        }\r\n    }\r\n    return pathSubstrings;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.hibernate3.session.Hibernate3Transformers.removeSessionFactoryImplFinalFlag",
	"Comment": "ensure org.hibernate.impl.sessionfactoryimpl is proxyable",
	"Method": "void removeSessionFactoryImplFinalFlag(CtClass clazz,ClassPool classPool,ClassLoader classLoader){\r\n    ProxyUtil.ensureProxyable(clazz);\r\n    LOGGER.info(\"Override org.hibernate.impl.SessionFactoryImpl {}\", classLoader);\r\n}"
}, {
	"Path": "com.datastax.driver.mapping.MapperMaterializedViewTest.should_access_mapped_result_range",
	"Comment": "validates that an accessor properly maps to a result from a materialized view given a rangecriteria query.",
	"Method": "void should_access_mapped_result_range(){\r\n    Result<Score> scores = accessor.monthlyHighRange(\"Coup\", 2015, 6, 2500, 3500);\r\n    Iterator<Score> iterator = scores.iterator();\r\n    assertThat(iterator.next()).isEqualTo(new Score(\"jbellis\", \"Coup\", 2015, 6, 20, 3500));\r\n    assertThat(iterator.next()).isEqualTo(new Score(\"jmckenzie\", \"Coup\", 2015, 6, 9, 2700));\r\n    assertThat(iterator.next()).isEqualTo(new Score(\"iamaleksey\", \"Coup\", 2015, 6, 1, 2500));\r\n    assertThat(scores.isExhausted());\r\n}"
}, {
	"Path": "org.jabref.logic.journals.JournalAbbreviationRepository.getAbbreviation",
	"Comment": "attempts to get the abbreviated name of the journal given. may contain dots.",
	"Method": "Optional<Abbreviation> getAbbreviation(String journalName){\r\n    return abbreviations.stream().filter(abbreviation -> isMatched(journalName.trim(), abbreviation)).findFirst();\r\n}"
}, {
	"Path": "org.menacheri.zombie.UDPClient.createDatagramChannel",
	"Comment": "method used to create a datagram channel from the bootstrap instance.",
	"Method": "DatagramChannel createDatagramChannel(){\r\n    String localHost = InetAddress.getLocalHost().getHostAddress();\r\n    DatagramChannel c = (DatagramChannel) b.bind(new InetSocketAddress(localHost, 0));\r\n    return c;\r\n}"
}, {
	"Path": "org.jabref.gui.importer.actions.OpenDatabaseAction.openFiles",
	"Comment": "opens the given files. if one of it is null or 404, nothing happens",
	"Method": "void openFiles(List<Path> filesToOpen,boolean raisePanel){\r\n    BasePanel toRaise = null;\r\n    int initialCount = filesToOpen.size();\r\n    int removed = 0;\r\n    for (Iterator<Path> iterator = filesToOpen.iterator(); iterator.hasNext(); ) {\r\n        Path file = iterator.next();\r\n        for (int i = 0; i < frame.getTabbedPane().getTabs().size(); i++) {\r\n            BasePanel basePanel = frame.getBasePanelAt(i);\r\n            if ((basePanel.getBibDatabaseContext().getDatabasePath().isPresent()) && basePanel.getBibDatabaseContext().getDatabasePath().get().equals(file)) {\r\n                iterator.remove();\r\n                removed++;\r\n                if (removed == initialCount) {\r\n                    toRaise = basePanel;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (!filesToOpen.isEmpty()) {\r\n        final List<Path> theFiles = Collections.unmodifiableList(filesToOpen);\r\n        JabRefExecutorService.INSTANCE.execute(() -> {\r\n            for (Path theFile : theFiles) {\r\n                openTheFile(theFile, raisePanel);\r\n            }\r\n        });\r\n        for (Path theFile : theFiles) {\r\n            frame.getFileHistory().newFile(theFile);\r\n        }\r\n    } else if (toRaise != null) {\r\n        frame.output(Localization.lang(\"File '%0' is already open.\", toRaise.getBibDatabaseContext().getDatabaseFile().get().getPath()));\r\n        frame.showBasePanel(toRaise);\r\n    }\r\n    frame.output(Localization.lang(\"Files opened\") + \": \" + (filesToOpen.size()));\r\n}"
}, {
	"Path": "org.jabref.model.search.rules.SearchRules.getSearchRuleByQuery",
	"Comment": "returns the appropriate search rule that fits best to the given parameter.",
	"Method": "SearchRule getSearchRuleByQuery(String query,boolean caseSensitive,boolean regex){\r\n    if (isSimpleQuery(query)) {\r\n        return new ContainBasedSearchRule(caseSensitive);\r\n    }\r\n    SearchRule searchExpression = new GrammarBasedSearchRule(caseSensitive, regex);\r\n    if (searchExpression.validateSearchStrings(query)) {\r\n        return searchExpression;\r\n    } else {\r\n        return getSearchRule(caseSensitive, regex);\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.examples.json.JacksonJsonRow.selectJsonRow",
	"Comment": "retrieving user instances from table rows using select json",
	"Method": "void selectJsonRow(Session session){\r\n    Statement stmt = select().json().from(\"examples\", \"json_jackson_row\").where(in(\"id\", 1, 2));\r\n    ResultSet rows = session.execute(stmt);\r\n    for (Row row : rows) {\r\n        User user = row.get(0, User.class);\r\n        System.out.printf(\"Retrieved user: %s%n\", user);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ReflectionUtils.getUniqueDeclaredMethods",
	"Comment": "get the unique set of declared methods on the leaf class and allsuperclasses. leaf class methods are included first and while traversingthe superclass hierarchy any methods found with signatures matching amethod already included are filtered out.",
	"Method": "Method[] getUniqueDeclaredMethods(Class<?> leafClass){\r\n    final List<Method> methods = new ArrayList<Method>(32);\r\n    doWithMethods(leafClass, new MethodCallback() {\r\n        @Override\r\n        public void doWith(Method method) {\r\n            boolean knownSignature = false;\r\n            Method methodBeingOverriddenWithCovariantReturnType = null;\r\n            for (Method existingMethod : methods) {\r\n                if (method.getName().equals(existingMethod.getName()) && Arrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {\r\n                    if (existingMethod.getReturnType() != method.getReturnType() && existingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {\r\n                        methodBeingOverriddenWithCovariantReturnType = existingMethod;\r\n                    } else {\r\n                        knownSignature = true;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            if (methodBeingOverriddenWithCovariantReturnType != null) {\r\n                methods.remove(methodBeingOverriddenWithCovariantReturnType);\r\n            }\r\n            if (!knownSignature && !isCglibRenamedMethod(method)) {\r\n                methods.add(method);\r\n            }\r\n        }\r\n    });\r\n    return methods.toArray(new Method[methods.size()]);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ReflectionUtils.getUniqueDeclaredMethods",
	"Comment": "get the unique set of declared methods on the leaf class and allsuperclasses. leaf class methods are included first and while traversingthe superclass hierarchy any methods found with signatures matching amethod already included are filtered out.",
	"Method": "Method[] getUniqueDeclaredMethods(Class<?> leafClass){\r\n    boolean knownSignature = false;\r\n    Method methodBeingOverriddenWithCovariantReturnType = null;\r\n    for (Method existingMethod : methods) {\r\n        if (method.getName().equals(existingMethod.getName()) && Arrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {\r\n            if (existingMethod.getReturnType() != method.getReturnType() && existingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {\r\n                methodBeingOverriddenWithCovariantReturnType = existingMethod;\r\n            } else {\r\n                knownSignature = true;\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    if (methodBeingOverriddenWithCovariantReturnType != null) {\r\n        methods.remove(methodBeingOverriddenWithCovariantReturnType);\r\n    }\r\n    if (!knownSignature && !isCglibRenamedMethod(method)) {\r\n        methods.add(method);\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.Assertions.assertThat",
	"Comment": "this method is here only to disambiguate calls to assertthat with a usertype instance, becauseusertype also implements iterable.",
	"Method": "ClusterAssert assertThat(Cluster cluster,HostAssert assertThat,Host host,SessionAssert assertThat,Session session,TokenRangeAssert assertThat,TokenRange range,DataTypeAssert assertThat,DataType type,DataTypeAssert assertThat,UserType type,LocalDateAssert assertThat,LocalDate localDate,KeyspaceMetadataAssert assertThat,KeyspaceMetadata metadata,TableMetadataAssert assertThat,TableMetadata table,ColumnMetadataAssert assertThat,ColumnMetadata column,FunctionMetadataAssert assertThat,FunctionMetadata function,AggregateMetadataAssert assertThat,AggregateMetadata aggregate,IndexMetadataAssert assertThat,IndexMetadata index,TypeCodecAssert<T> assertThat,TypeCodec<T> codec,MaterializedViewMetadataAssert assertThat,MaterializedViewMetadata view,VersionNumberAssert assertThat,VersionNumber actual,ResultSetAssert assertThat,ResultSet rows,ColumnDefinitionsAssert assertThat,ColumnDefinitions variables){\r\n    return new ColumnDefinitionsAssert(variables);\r\n}"
}, {
	"Path": "com.beust.jcommander.JCommanderTest.requiredFields1Fail",
	"Comment": "not specifying a required option should throw an exception.",
	"Method": "void requiredFields1Fail(){\r\n    Args1 args = new Args1();\r\n    String[] argv = { \"-debug\" };\r\n    JCommander.newBuilder().addObject(args).build().parse(argv);\r\n}"
}, {
	"Path": "org.jabref.logic.integrity.HTMLCharacterChecker.check",
	"Comment": "checks, if there are any html encoded characters in nonverbatim fields.",
	"Method": "List<IntegrityMessage> check(BibEntry entry){\r\n    List<IntegrityMessage> results = new ArrayList();\r\n    for (Map.Entry<String, String> field : entry.getFieldMap().entrySet()) {\r\n        if (InternalBibtexFields.getFieldProperties(field.getKey()).contains(FieldProperty.VERBATIM)) {\r\n            continue;\r\n        }\r\n        Matcher characterMatcher = HTML_CHARACTER_PATTERN.matcher(field.getValue());\r\n        if (characterMatcher.find()) {\r\n            results.add(new IntegrityMessage(Localization.lang(\"HTML encoded character found\"), entry, field.getKey()));\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.jabref.logic.integrity.BibTeXEntryTypeChecker.check",
	"Comment": "will check if the current library uses any entry types from another mode.for example it will warn the user if he uses entry types defined for biblatex inside a bibtex library.",
	"Method": "List<IntegrityMessage> check(BibEntry entry){\r\n    if (EntryTypes.isExclusiveBiblatex(entry.getType())) {\r\n        return Collections.singletonList(new IntegrityMessage(Localization.lang(\"Entry type %0 is only defined for Biblatex but not for BibTeX\", entry.getType()), entry, \"bibtexkey\"));\r\n    }\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "org.elixir_lang.beam.psi.impl.ModuleElementImpl.getMirror",
	"Comment": "returns the corresponding psi element in a decompiled file created by idea fromthe library element.",
	"Method": "PsiElement getMirror(){\r\n    TreeElement nonVolatileMirror = mirror;\r\n    if (nonVolatileMirror == null) {\r\n        ((BeamFileImpl) getContainingFile()).getMirror();\r\n        nonVolatileMirror = mirror;\r\n    }\r\n    return SourceTreeToPsiMap.treeElementToPsi(nonVolatileMirror);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.web.Webserver.setClassPool",
	"Comment": "requests the web server to use the specifiedclasspool object for obtaining a class file.",
	"Method": "void setClassPool(ClassPool loader){\r\n    classPool = loader;\r\n}"
}, {
	"Path": "com.datastax.driver.core.ClusterInitTest.should_not_schedule_reconnections_before_init_complete",
	"Comment": "validates that if hosts are unreachable during cluster initialization, no backgroundreconnection to them is scheduled before the initialization is complete.",
	"Method": "void should_not_schedule_reconnections_before_init_complete(){\r\n    List<FakeHost> hosts = Lists.newArrayList(new FakeHost(TestUtils.ipOfNode(0), 9042, THROWING_CONNECT_TIMEOUTS), new FakeHost(TestUtils.ipOfNode(1), 9042, THROWING_CONNECT_TIMEOUTS));\r\n    CountingReconnectionPolicy reconnectionPolicy = new CountingReconnectionPolicy(new ConstantReconnectionPolicy(100));\r\n    Cluster cluster = Cluster.builder().addContactPoints(hosts.get(0).address, hosts.get(1).address).withReconnectionPolicy(reconnectionPolicy).build();\r\n    try {\r\n        cluster.init();\r\n    } finally {\r\n        assertThat(reconnectionPolicy.count.get()).isEqualTo(2);\r\n        for (FakeHost fakeHost : hosts) {\r\n            fakeHost.stop();\r\n        }\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "me.ramswaroop.jbot.core.facebook.Bot.nextConversation",
	"Comment": "call this method to jump to the next method in a conversation.",
	"Method": "void nextConversation(Event event){\r\n    nextConversation(event.getSender().getId());\r\n}"
}, {
	"Path": "org.jabref.logic.search.SearchQueryHighlightObservable.addSearchListener",
	"Comment": "adds a searchqueryhighlightlistener to the search bar. the added listener is immediately informed about the current search.subscribers will be notified about searches.",
	"Method": "void addSearchListener(SearchQueryHighlightListener newListener){\r\n    Objects.requireNonNull(newListener);\r\n    eventBus.register(newListener);\r\n    newListener.highlightPattern(pattern);\r\n}"
}, {
	"Path": "org.jabref.logic.bibtexkeypattern.BracketedPattern.expand",
	"Comment": "expands the current pattern using the given bibentry, keyword delimiter, and database.",
	"Method": "String expand(BibEntry bibentry,String expand,BibEntry bibentry,BibDatabase database,String expand,BibEntry bibentry,Character keywordDelimiter,BibDatabase database){\r\n    Objects.requireNonNull(bibentry);\r\n    return expandBrackets(this.pattern, keywordDelimiter, bibentry, database);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.spring.scanner.ClassPathBeanDefinitionScannerAgent.resolveBeanDefinition",
	"Comment": "resolve bean definition from class definition if applicable.",
	"Method": "BeanDefinition resolveBeanDefinition(byte[] bytes){\r\n    Resource resource = new ByteArrayResource(bytes);\r\n    resetCachingMetadataReaderFactoryCache();\r\n    MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);\r\n    if (isCandidateComponent(metadataReader)) {\r\n        ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);\r\n        sbd.setResource(resource);\r\n        sbd.setSource(resource);\r\n        if (isCandidateComponent(sbd)) {\r\n            LOGGER.debug(\"Identified candidate component class '{}'\", metadataReader.getClassMetadata().getClassName());\r\n            return sbd;\r\n        } else {\r\n            LOGGER.debug(\"Ignored because not a concrete top-level class '{}'\", metadataReader.getClassMetadata().getClassName());\r\n            return null;\r\n        }\r\n    } else {\r\n        LOGGER.trace(\"Ignored because not matching any filter '{}' \", metadataReader.getClassMetadata().getClassName());\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.SqlStatement.bindByType",
	"Comment": "bind an argument dynamically by the qualified type passed in.",
	"Method": "This bindByType(int position,Object value,Type argumentType,This bindByType,int position,Object value,GenericType<?> argumentType,This bindByType,int position,Object value,QualifiedType argumentType,This bindByType,String name,Object value,Type argumentType,This bindByType,String name,Object value,GenericType<?> argumentType,This bindByType,String name,Object value,QualifiedType argumentType){\r\n    return bind(name, toArgument(argumentType, value));\r\n}"
}, {
	"Path": "com.datastax.driver.core.LocalDate.fromMillisSinceEpoch",
	"Comment": "builds a new instance from a number of milliseconds since january 1st, 1970 gmt. note that ifthe given number does not correspond to a whole number of days, it will be rounded towards 0.",
	"Method": "LocalDate fromMillisSinceEpoch(long millisSinceEpoch){\r\n    long daysSinceEpoch = TimeUnit.MILLISECONDS.toDays(millisSinceEpoch);\r\n    checkArgument(daysSinceEpoch >= Integer.MIN_VALUE && daysSinceEpoch <= Integer.MAX_VALUE, \"Date should be in the range [-5877641-06-23; 5881580-07-11]\");\r\n    return new LocalDate((int) daysSinceEpoch);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.jvm.AnonymousClassPatchPlugin.getClassInfosMapForClassLoader",
	"Comment": "return classinfos for a classloader. hold known classloaders in weak hash map.",
	"Method": "Map<String, AnonymousClassInfos> getClassInfosMapForClassLoader(ClassLoader classLoader){\r\n    Map<String, AnonymousClassInfos> classInfosMap = anonymousClassInfosMap.get(classLoader);\r\n    if (classInfosMap == null) {\r\n        synchronized (classLoader) {\r\n            classInfosMap = anonymousClassInfosMap.get(classLoader);\r\n            if (classInfosMap == null) {\r\n                classInfosMap = new HashMap<String, AnonymousClassInfos>();\r\n                anonymousClassInfosMap.put(classLoader, classInfosMap);\r\n            }\r\n        }\r\n    }\r\n    return classInfosMap;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.PathResource.equals",
	"Comment": "this implementation compares the underlying path references.",
	"Method": "boolean equals(Object obj){\r\n    return (this == obj || (obj instanceof PathResource && this.path.equals(((PathResource) obj).path)));\r\n}"
}, {
	"Path": "com.beust.jcommander.JCommander.readPassword",
	"Comment": "invoke console.readpassword through reflection to avoid dependingon java 6.",
	"Method": "char[] readPassword(String description,boolean echoInput){\r\n    getConsole().print(description + \": \");\r\n    return getConsole().readPassword(echoInput);\r\n}"
}, {
	"Path": "org.jabref.gui.desktop.JabRefDesktop.openBrowserShowPopup",
	"Comment": "opens the url with the users standard browser.if that fails a popup will be shown to instruct the user to open the link manuallyand the link gets copied to the clipboard",
	"Method": "void openBrowserShowPopup(String url){\r\n    try {\r\n        openBrowser(url);\r\n    } catch (IOException exception) {\r\n        Globals.clipboardManager.setContent(url);\r\n        LOGGER.error(\"Could not open browser\", exception);\r\n        String couldNotOpenBrowser = Localization.lang(\"Could not open browser.\");\r\n        String openManually = Localization.lang(\"Please open %0 manually.\", url);\r\n        String copiedToClipboard = Localization.lang(\"The link has been copied to the clipboard.\");\r\n        JabRefGUI.getMainFrame().output(couldNotOpenBrowser);\r\n        JOptionPane.showMessageDialog(null, couldNotOpenBrowser + \"\\n\" + openManually + \"\\n\" + copiedToClipboard, couldNotOpenBrowser, JOptionPane.ERROR_MESSAGE);\r\n    }\r\n}"
}, {
	"Path": "com.beust.jcommander.JCommander.validateOptions",
	"Comment": "make sure that all the required parameters have received a value.",
	"Method": "void validateOptions(){\r\n    if (helpWasSpecified) {\r\n        return;\r\n    }\r\n    if (!requiredFields.isEmpty()) {\r\n        List<String> missingFields = new ArrayList();\r\n        for (ParameterDescription pd : requiredFields.values()) {\r\n            missingFields.add(\"[\" + Strings.join(\" | \", pd.getParameter().names()) + \"]\");\r\n        }\r\n        String message = Strings.join(\", \", missingFields);\r\n        throw new ParameterException(\"The following \" + pluralize(requiredFields.size(), \"option is required: \", \"options are required: \") + message);\r\n    }\r\n    if (mainParameter != null && mainParameter.description != null) {\r\n        ParameterDescription mainParameterDescription = mainParameter.description;\r\n        if (mainParameterDescription.getParameter().required() && !mainParameterDescription.isAssigned()) {\r\n            throw new ParameterException(\"Main parameters are required (\\\"\" + mainParameterDescription.getDescription() + \"\\\")\");\r\n        }\r\n        int arity = mainParameterDescription.getParameter().arity();\r\n        if (arity != Parameter.DEFAULT_ARITY) {\r\n            Object value = mainParameterDescription.getParameterized().get(mainParameter.object);\r\n            if (List.class.isAssignableFrom(value.getClass())) {\r\n                int size = ((List<?>) value).size();\r\n                if (size != arity) {\r\n                    throw new ParameterException(\"There should be exactly \" + arity + \" main parameters but \" + size + \" were found\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jabref.model.TreeNode.moveAllChildrenTo",
	"Comment": "removes all children from this node and makes them a child of the specified nodeby adding it to the specified position in the children list.",
	"Method": "void moveAllChildrenTo(T target,int targetIndex){\r\n    while (getNumberOfChildren() > 0) {\r\n        getLastChild().get().moveTo(target, targetIndex);\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.ConsistencyTest.should_use_appropriate_cl_when_multiple_defined",
	"Comment": "tests that order of precedence is followed when defining cls. statement level cl should behonored above queryoptions. queryoptions should be honored above default cl.",
	"Method": "void should_use_appropriate_cl_when_multiple_defined(){\r\n    ConsistencyLevel cl_one = ConsistencyLevel.ONE;\r\n    Cluster cluster = builder().withQueryOptions(new QueryOptions().setConsistencyLevel(cl_one)).build();\r\n    try {\r\n        Session session = cluster.connect();\r\n        String queryString = \"opts_cl\";\r\n        Query clQuery = executeSimple(session, queryString, null, null);\r\n        assertTrue(clQuery.getConsistency().equals(cl_one.toString()));\r\n        ConsistencyLevel cl_all = ConsistencyLevel.ALL;\r\n        queryString = \"stm_cl\";\r\n        clQuery = executeSimple(session, queryString, cl_all, null);\r\n        assertTrue(clQuery.getConsistency().equals(cl_all.toString()));\r\n        String prepareString = \"prep_opts_cl\";\r\n        PreparedStatementExecution pse = executePrepared(session, prepareString, null, null);\r\n        assertTrue(pse.getConsistency().equals(cl_one.toString()));\r\n        clearActivityLog();\r\n        prepareString = \"prep_stm_cl\";\r\n        pse = executePrepared(session, prepareString, cl_all, null);\r\n        assertTrue(pse.getConsistency().equals(cl_all.toString()));\r\n        String batchString = \"batch_opts_cl\";\r\n        BatchExecution batch = executeBatch(session, batchString, null, null);\r\n        assertTrue(batch.getConsistency().equals(cl_one.toString()));\r\n        clearActivityLog();\r\n        batchString = \"prep_stm_cl\";\r\n        batch = executeBatch(session, batchString, cl_all, null);\r\n        assertTrue(batch.getConsistency().equals(cl_all.toString()));\r\n    } finally {\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.mapping.AnnotationChecks.getTypeAnnotation",
	"Comment": "checks that a class is decorated with the given annotation, and return the annotation instance.also validates that no other mapping annotation is present.",
	"Method": "T getTypeAnnotation(Class<T> annotation,Class<?> annotatedClass){\r\n    T instance = annotatedClass.getAnnotation(annotation);\r\n    if (instance == null)\r\n        throw new IllegalArgumentException(String.format(\"@%s annotation was not found on %s\", annotation.getSimpleName(), annotatedClass));\r\n    validateAnnotations(annotatedClass, annotation);\r\n    return instance;\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiletype.ExternalFileTypes.getExternalFileTypeByName",
	"Comment": "look up the external file type registered with this name, if any.",
	"Method": "Optional<ExternalFileType> getExternalFileTypeByName(String name){\r\n    Optional<ExternalFileType> externalFileType = externalFileTypes.stream().filter(type -> type.getExtension().equals(name)).findFirst();\r\n    if (externalFileType.isPresent()) {\r\n        return externalFileType;\r\n    }\r\n    return Optional.of(new UnknownExternalFileType(name));\r\n}"
}, {
	"Path": "org.elixir_lang.eex.lexer.Flex.yytext",
	"Comment": "returns the text matched by the current regular expression.",
	"Method": "CharSequence yytext(){\r\n    return zzBuffer.subSequence(zzStartRead, zzMarkedPos);\r\n}"
}, {
	"Path": "com.datastax.driver.core.ThreadingOptions.createBlockingExecutor",
	"Comment": "builds the executor used to block on new connections before they are added to a pool.the default implementation uses 2 threads.",
	"Method": "ExecutorService createBlockingExecutor(String clusterName){\r\n    ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 2, DEFAULT_THREAD_KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), createThreadFactory(clusterName, \"blocking-task-worker\"));\r\n    executor.allowCoreThreadTimeOut(true);\r\n    return executor;\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolTest.should_keep_host_up_when_one_connection_lost",
	"Comment": "ensures that if a connection on a host is lost but other connections remain intact in the poolthat the host is not marked down.",
	"Method": "void should_keep_host_up_when_one_connection_lost(){\r\n    Cluster cluster = createClusterBuilder().build();\r\n    try {\r\n        HostConnectionPool pool = createPool(cluster, 2, 2);\r\n        Connection core0 = pool.connections.get(0);\r\n        Connection core1 = pool.connections.get(1);\r\n        currentClient.disableListener();\r\n        currentClient.closeConnection(CLOSE, ((InetSocketAddress) core0.channel.localAddress()));\r\n        Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\r\n        assertThat(core0.isClosed()).isTrue();\r\n        assertThat(core1.isClosed()).isFalse();\r\n        assertThat(pool.connections).doesNotContain(core0);\r\n        assertThat(cluster).host(1).hasState(Host.State.UP);\r\n        assertThat(cluster).hasOpenControlConnection();\r\n    } finally {\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.SSLAuthenticatedEncryptionTest.should_use_system_properties_with_default_ssl_options",
	"Comment": "validates that ssl connectivity can be configured via the standard javax.net.ssl systemproperties.",
	"Method": "void should_use_system_properties_with_default_ssl_options(){\r\n    System.setProperty(\"javax.net.ssl.keyStore\", DEFAULT_CLIENT_KEYSTORE_FILE.getAbsolutePath());\r\n    System.setProperty(\"javax.net.ssl.keyStorePassword\", DEFAULT_CLIENT_KEYSTORE_PASSWORD);\r\n    System.setProperty(\"javax.net.ssl.trustStore\", DEFAULT_CLIENT_TRUSTSTORE_FILE.getAbsolutePath());\r\n    System.setProperty(\"javax.net.ssl.trustStorePassword\", DEFAULT_CLIENT_TRUSTSTORE_PASSWORD);\r\n    try {\r\n        connectWithSSL();\r\n    } finally {\r\n        try {\r\n            System.clearProperty(\"javax.net.ssl.keyStore\");\r\n            System.clearProperty(\"javax.net.ssl.keyStorePassword\");\r\n            System.clearProperty(\"javax.net.ssl.trustStore\");\r\n            System.clearProperty(\"javax.net.ssl.trustStorePassword\");\r\n        } catch (SecurityException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.Metrics.getErrorMetrics",
	"Comment": "returns an object grouping metrics related to the errors encountered.",
	"Method": "Errors getErrorMetrics(){\r\n    return errors;\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolMultiTest.should_mark_host_down_if_all_connections_fail_on_init",
	"Comment": "ensures that if all connections fail to a host on pool init that the host is marked down.",
	"Method": "void should_mark_host_down_if_all_connections_fail_on_init(){\r\n    scassandra.node(2).currentClient().disableListener();\r\n    createCluster(8, 8);\r\n    assertThat(cluster).host(2).goesDownWithin(10, SECONDS);\r\n    assertThat(cluster).host(1).isUp();\r\n    scassandra.node(2).currentClient().enableListener();\r\n    assertThat(cluster).host(2).comesUpWithin(2, SECONDS);\r\n}"
}, {
	"Path": "com.datastax.driver.core.utils.Bytes.toRawHexString",
	"Comment": "converts a blob to its cql hex string representation.a cql blob string representation consist of the hexadecimal representation of the blobbytes.",
	"Method": "String toRawHexString(ByteBuffer bytes,String toRawHexString,ByteBuffer bytes,char[] array,int offset){\r\n    int size = bytes.remaining();\r\n    int bytesOffset = bytes.position();\r\n    assert array.length >= offset + 2 * size;\r\n    for (int i = 0; i < size; i++) {\r\n        int bint = bytes.get(i + bytesOffset);\r\n        array[offset + i * 2] = byteToChar[(bint & 0xf0) >> 4];\r\n        array[offset + 1 + i * 2] = byteToChar[bint & 0x0f];\r\n    }\r\n    return wrapCharArray(array);\r\n}"
}, {
	"Path": "org.jabref.gui.WrapLayout.preferredLayoutSize",
	"Comment": "returns the preferred dimensions for this layout given thevisible components in the specified target container.",
	"Method": "Dimension preferredLayoutSize(Container target){\r\n    return layoutSize(target, true);\r\n}"
}, {
	"Path": "com.datastax.driver.core.ProtocolOptions.setCompression",
	"Comment": "sets the compression to use.note that while this setting can be changed at any time, it will only apply to newly createdconnections.",
	"Method": "ProtocolOptions setCompression(Compression compression){\r\n    if (compression != Compression.NONE && compression.compressor() == null)\r\n        throw new IllegalStateException(\"The requested compression is not available (some compression require a JAR to be found in the classpath)\");\r\n    this.compression = compression;\r\n    return this;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.IOUtils.isDirectoryURL",
	"Comment": "determine whether the given url points to a directory in the file system",
	"Method": "boolean isDirectoryURL(URL url){\r\n    try {\r\n        File f = new File(url.toURI());\r\n        if (f.exists() && f.isDirectory()) {\r\n            return true;\r\n        }\r\n    } catch (Exception e) {\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.MultistepProxyTransformer.scheduleRedefinition",
	"Comment": "generate new redefinition event for current classbeingredefined",
	"Method": "void scheduleRedefinition(){\r\n    RedefinitionScheduler.schedule(this);\r\n}"
}, {
	"Path": "com.github.javafaker.Name.suffix",
	"Comment": "returns a name suffix such as jr., sr., i, ii, iii, iv, v, md, dds, phd or dvm",
	"Method": "String suffix(){\r\n    return faker.fakeValuesService().resolve(\"name.suffix\", this, faker);\r\n}"
}, {
	"Path": "org.jabref.gui.autocompleter.SuggestionProviders.indexEntry",
	"Comment": "this methods assures all information in the given entry is included as suggestions.",
	"Method": "void indexEntry(BibEntry bibEntry){\r\n    for (AutoCompleteSuggestionProvider<?> autoCompleter : providers.values()) {\r\n        autoCompleter.indexEntry(bibEntry);\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.QueryOptions.getRefreshNodeListIntervalMillis",
	"Comment": "the default window size in milliseconds used to debounce node list refresh requests.",
	"Method": "int getRefreshNodeListIntervalMillis(){\r\n    return refreshNodeListIntervalMillis;\r\n}"
}, {
	"Path": "org.menacheri.jetserver.concurrent.DataFlowVariable.getVal",
	"Comment": "this method blocks for a specified amount of time to retrieve the value\tbound in bind method.",
	"Method": "Object getVal(Object getVal,long waitTime,TimeUnit timeUnit){\r\n    if (latch.await(waitTime, timeUnit)) {\r\n        return val;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.LocalDate.getMillisSinceEpoch",
	"Comment": "returns the number of milliseconds since january 1st, 1970 gmt.",
	"Method": "long getMillisSinceEpoch(){\r\n    return millisSinceEpoch;\r\n}"
}, {
	"Path": "com.github.javafaker.Faker.regexify",
	"Comment": "generates a string that matches the given regular expression.",
	"Method": "String regexify(String regex){\r\n    return fakeValuesService.regexify(regex);\r\n}"
}, {
	"Path": "com.datastax.driver.core.VIntCoding.computeUnsignedVIntSize",
	"Comment": "compute the number of bytes that would be needed to encode an unsigned varint.",
	"Method": "int computeUnsignedVIntSize(long value){\r\n    int magnitude = // | with 1 to ensure magntiude <= 63, so (63 - 1) / 7 <= 8\r\n    Long.numberOfLeadingZeros(value | 1);\r\n    return (639 - magnitude * 9) >> 6;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.test.WaitHelper.waitForCommand",
	"Comment": "wait for custom command to return true. default timeout 1000ms.",
	"Method": "boolean waitForCommand(Command command,boolean waitForCommand,Command command,int timeout){\r\n    for (int i = 0; i < timeout / 10; i++) {\r\n        try {\r\n            if (command.result())\r\n                return true;\r\n        } catch (Exception e) {\r\n        }\r\n        try {\r\n            Thread.sleep(10);\r\n        } catch (InterruptedException e) {\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.datastax.driver.core.ProtocolV1Test.should_execute_prepared_statement_with_no_variables",
	"Comment": "validates that a prepared statement with no variables is correctly prepared and executed.",
	"Method": "void should_execute_prepared_statement_with_no_variables(){\r\n    PreparedStatement ps = session().prepare(\"select * from system.local\");\r\n    session().execute(ps.bind());\r\n}"
}, {
	"Path": "org.jdbi.v3.core.result.ResultIterable.of",
	"Comment": "returns a resultiterable backed by the given result set supplier, mapper, and context.",
	"Method": "ResultIterable<T> of(Supplier<ResultSet> supplier,RowMapper<T> mapper,StatementContext ctx,ResultIterable<T> of,ResultIterator<T> iterator){\r\n    return () -> iterator;\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.Alter.addStaticColumn",
	"Comment": "add a new add column clause to this alter table statement, to add a static column.",
	"Method": "AddColumn addStaticColumn(String columnName){\r\n    validateNotEmpty(columnName, \"Added static column\");\r\n    validateNotKeyWord(columnName, String.format(\"The new static column name '%s' is not allowed because it is a reserved keyword\", columnName));\r\n    return new AddColumn(this, columnName, true);\r\n}"
}, {
	"Path": "com.datastax.driver.examples.retry.DowngradingRetry.downgrade",
	"Comment": "downgrades the current consistency level to the highest level that is likely to succeed, giventhe number of acknowledgements received. rethrows the original exception if the currentconsistency level cannot be downgraded any further.",
	"Method": "ConsistencyLevel downgrade(ConsistencyLevel current,int acknowledgements,DriverException original){\r\n    if (acknowledgements >= 3) {\r\n        return ConsistencyLevel.THREE;\r\n    }\r\n    if (acknowledgements == 2) {\r\n        return ConsistencyLevel.TWO;\r\n    }\r\n    if (acknowledgements == 1) {\r\n        return ConsistencyLevel.ONE;\r\n    }\r\n    if (current == ConsistencyLevel.EACH_QUORUM) {\r\n        return ConsistencyLevel.ONE;\r\n    }\r\n    throw original;\r\n}"
}, {
	"Path": "org.elixir_lang.parser.ElixirParser.unmatchedQualifiedNoParenthesesCall_0",
	"Comment": "dotinfixoperator relativeidentifier noparenthesesoneargument doblockmaybe",
	"Method": "boolean unmatchedQualifiedNoParenthesesCall_0(PsiBuilder b,int l){\r\n    if (!recursion_guard_(b, l, \"unmatchedQualifiedNoParenthesesCall_0\"))\r\n        return false;\r\n    boolean r;\r\n    Marker m = enter_section_(b);\r\n    r = dotInfixOperator(b, l + 1);\r\n    r = r && relativeIdentifier(b, l + 1);\r\n    r = r && noParenthesesOneArgument(b, l + 1);\r\n    r = r && doBlockMaybe(b, l + 1);\r\n    exit_section_(b, m, null, r);\r\n    return r;\r\n}"
}, {
	"Path": "org.elixir_lang.parser_definition.GeneralParsingTestCase.testPygmentWithoutErrors",
	"Comment": "the pygment example text contains intentional errors to ensure that pygment can handle errors, but to check completeness of the parser, the text needs to be error free so the quoting can be checked",
	"Method": "void testPygmentWithoutErrors(){\r\n    assertParsedAndQuotedCorrectly(false);\r\n}"
}, {
	"Path": "org.jdbi.v3.core.argument.ObjectArgumentFactory.create",
	"Comment": "match the given type and bind as an object with the given sql type information",
	"Method": "ArgumentFactory create(Class<?> type,ArgumentFactory create,Class<?> type,Integer sqlType){\r\n    return new ObjectArgumentFactory(type, sqlType);\r\n}"
}, {
	"Path": "com.datastax.driver.core.PlainTextAuthProvider.newAuthenticator",
	"Comment": "uses the supplied credentials and the sasl plain mechanism to login to the server.",
	"Method": "Authenticator newAuthenticator(InetSocketAddress host,String authenticator){\r\n    return new PlainTextAuthenticator(username, password);\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiletype.ExternalFileTypes.getExternalFileTypeForName",
	"Comment": "look up the external file type registered for this filename, if any.",
	"Method": "Optional<ExternalFileType> getExternalFileTypeForName(String filename){\r\n    int longestFound = -1;\r\n    ExternalFileType foundType = null;\r\n    for (ExternalFileType type : externalFileTypes) {\r\n        if (!type.getExtension().isEmpty() && filename.toLowerCase(Locale.ROOT).endsWith(type.getExtension().toLowerCase(Locale.ROOT)) && (type.getExtension().length() > longestFound)) {\r\n            longestFound = type.getExtension().length();\r\n            foundType = type;\r\n        }\r\n    }\r\n    return Optional.ofNullable(foundType);\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolTest.should_wait_on_connection_if_not_convicted_and_no_connections_available",
	"Comment": "ensures that if all connections fail on pool init that the host and subsequently the controlconnection is not marked down. the test also ensures that when making requests on the poolafter the conviction period that all core connections are created.",
	"Method": "void should_wait_on_connection_if_not_convicted_and_no_connections_available(){\r\n    int readTimeout = 1000;\r\n    int reconnectInterval = 1000;\r\n    Cluster cluster = this.createClusterBuilder().withSocketOptions(new SocketOptions().setConnectTimeoutMillis(readTimeout).setReadTimeoutMillis(reconnectInterval)).withReconnectionPolicy(new ConstantReconnectionPolicy(1000)).build();\r\n    try {\r\n        cluster.init();\r\n        assertThat(cluster).hasOpenControlConnection();\r\n        Connection.Factory factory = spy(cluster.manager.connectionFactory);\r\n        cluster.manager.connectionFactory = factory;\r\n        currentClient.disableListener();\r\n        HostConnectionPool pool = createPool(cluster, 8, 8);\r\n        assertThat(pool.connections).hasSize(0);\r\n        assertThat(cluster).host(1).hasState(Host.State.UP);\r\n        assertThat(cluster).hasOpenControlConnection();\r\n        currentClient.enableListener();\r\n        Uninterruptibles.sleepUninterruptibly(reconnectInterval, TimeUnit.MILLISECONDS);\r\n        reset(factory);\r\n        MockRequest request = MockRequest.send(pool, 1);\r\n        verify(factory, timeout(readTimeout * 8).times(8)).open(any(HostConnectionPool.class));\r\n        assertPoolSize(pool, 8);\r\n        request.simulateSuccessResponse();\r\n    } finally {\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.model.entry.AuthorList.equals",
	"Comment": "compare this object with the given one.will return true iff the other object is an author and all fields are identical on a string comparison.",
	"Method": "boolean equals(Object o){\r\n    if (!(o instanceof AuthorList)) {\r\n        return false;\r\n    }\r\n    AuthorList a = (AuthorList) o;\r\n    return this.authors.equals(a.authors);\r\n}"
}, {
	"Path": "org.jdbi.v3.core.config.Configurable.configure",
	"Comment": "passes the configuration object of the given type to the configurer, then returns this object.",
	"Method": "This configure(Class<C> configClass,Consumer<C> configurer){\r\n    configurer.accept(getConfig(configClass));\r\n    return (This) this;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ClassUtils.toClassArray",
	"Comment": "copy the given collection into a class array. the collection must containclass elements only.",
	"Method": "Class<?>[] toClassArray(Collection<Class<?>> collection){\r\n    if (collection == null) {\r\n        return null;\r\n    }\r\n    return collection.toArray(new Class<?>[collection.size()]);\r\n}"
}, {
	"Path": "org.jabref.gui.fieldeditors.contextmenu.EditorMenus.getDOIMenu",
	"Comment": "the default context menu with a specific menu copying a doi url.",
	"Method": "Supplier<List<MenuItem>> getDOIMenu(TextArea textArea){\r\n    return () -> {\r\n        AbstractAction copyDoiUrlAction = new CopyDoiUrlAction(textArea);\r\n        MenuItem copyDoiUrlMenuItem = new MenuItem((String) copyDoiUrlAction.getValue(Action.NAME));\r\n        copyDoiUrlMenuItem.setOnAction(event -> copyDoiUrlAction.actionPerformed(null));\r\n        List<MenuItem> menuItems = new ArrayList();\r\n        menuItems.add(copyDoiUrlMenuItem);\r\n        menuItems.add(new SeparatorMenuItem());\r\n        menuItems.addAll(getDefaultMenu(textArea).get());\r\n        return menuItems;\r\n    };\r\n}"
}, {
	"Path": "com.datastax.driver.core.AuthenticationTest.should_not_create_pool_with_wrong_credentials",
	"Comment": "ensures that when a host replies with authenticationexception during connection poolinitialization the pool creation is aborted.",
	"Method": "void should_not_create_pool_with_wrong_credentials(){\r\n    PlainTextAuthProvider authProvider = new PlainTextAuthProvider(\"cassandra\", \"cassandra\");\r\n    Cluster cluster = register(Cluster.builder().addContactPoints(getContactPoints()).withPort(ccm().getBinaryPort()).withAuthProvider(authProvider).build());\r\n    cluster.init();\r\n    authProvider.setPassword(\"wrong\");\r\n    Level previous = TestUtils.setLogLevel(Session.class, Level.WARN);\r\n    MemoryAppender logs = new MemoryAppender().enableFor(Session.class);\r\n    Session session;\r\n    try {\r\n        session = cluster.connect();\r\n    } finally {\r\n        TestUtils.setLogLevel(Session.class, previous);\r\n        logs.disableFor(Session.class);\r\n    }\r\n    assertThat(session.getState().getConnectedHosts()).isEmpty();\r\n    InetSocketAddress host = ccm().addressOfNode(1);\r\n    assertThat(logs.get()).contains(\"Error creating pool to \" + host, \"Authentication error on host \" + host, AuthenticationException.class.getSimpleName());\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.owb.command.BeanClassRefreshCommand.isDeleteEvent",
	"Comment": "check all merged events with same classname for delete and create events. if delete without create is found, than assumefile was deleted.",
	"Method": "boolean isDeleteEvent(List<Command> mergedCommands){\r\n    boolean createFound = false;\r\n    boolean deleteFound = false;\r\n    for (Command cmd : mergedCommands) {\r\n        BeanClassRefreshCommand refreshCommand = (BeanClassRefreshCommand) cmd;\r\n        if (className.equals(refreshCommand.className)) {\r\n            if (refreshCommand.event != null) {\r\n                if (refreshCommand.event.getEventType().equals(FileEvent.DELETE))\r\n                    deleteFound = true;\r\n                if (refreshCommand.event.getEventType().equals(FileEvent.CREATE))\r\n                    createFound = true;\r\n            }\r\n        }\r\n    }\r\n    LOGGER.trace(\"isDeleteEvent result {}: createFound={}, deleteFound={}\", createFound, deleteFound);\r\n    return !createFound && deleteFound;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.util.HotSwapAgent.agentmain",
	"Comment": "the entry point invoked when this agent is started after the jvm starts.",
	"Method": "void agentmain(String agentArgs,Instrumentation inst){\r\n    if (!inst.isRedefineClassesSupported())\r\n        throw new RuntimeException(\"this JVM does not support redefinition of classes\");\r\n    instrumentation = inst;\r\n}"
}, {
	"Path": "me.ramswaroop.jbot.core.slack.Bot.startRTMAndWebSocketConnection",
	"Comment": "entry point where the web socket connection startsand after which your bot becomes live.",
	"Method": "void startRTMAndWebSocketConnection(){\r\n    slackService.connectRTM(getSlackToken());\r\n    if (slackService.getWebSocketUrl() != null) {\r\n        WebSocketConnectionManager manager = new WebSocketConnectionManager(client(), handler(), slackService.getWebSocketUrl());\r\n        manager.start();\r\n    } else {\r\n        logger.error(\"No web socket url returned by Slack.\");\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.ThreadingOptions.createScheduledTasksExecutor",
	"Comment": "builds the executor to handle host state notifications from cassandra.this executor must have exactly one thread so that notifications are processed inorder.",
	"Method": "ScheduledExecutorService createScheduledTasksExecutor(String clusterName){\r\n    return new ScheduledThreadPoolExecutor(1, createThreadFactory(clusterName, \"scheduled-task-worker\"));\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.deltaspike.transformer.RepositoryTransformer.patchRepositoryComponent",
	"Comment": "register deltaspikeplugin and add reinitialization method to repositorycomponent",
	"Method": "void patchRepositoryComponent(CtClass ctClass){\r\n    StringBuilder src = new StringBuilder(\"{\");\r\n    src.append(PluginManagerInvoker.buildInitializePlugin(DeltaSpikePlugin.class));\r\n    src.append(PluginManagerInvoker.buildCallPluginMethod(DeltaSpikePlugin.class, \"registerRepoComponent\", \"this\", \"java.lang.Object\", \"this.repoClass\", \"java.lang.Class\"));\r\n    src.append(\"}\");\r\n    for (CtConstructor constructor : ctClass.getDeclaredConstructors()) {\r\n        constructor.insertAfter(src.toString());\r\n    }\r\n    ctClass.addMethod(CtNewMethod.make(\"public void \" + REINITIALIZE_METHOD + \"() {\" + \"   this.methods.clear(); \" + \"   initialize();\" + \"}\", ctClass));\r\n    LOGGER.debug(\"org.apache.deltaspike.data.impl.meta.RepositoryComponent - registration hook and reinitialization method added.\");\r\n}"
}, {
	"Path": "org.jabref.JabRefGUI.setMainFrame",
	"Comment": "only used for testing, other than that do not set the mainframe...",
	"Method": "void setMainFrame(JabRefFrame mainFrame){\r\n    JabRefGUI.mainFrame = mainFrame;\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.Create.addUDTStaticColumn",
	"Comment": "add a static column definition to this create table statement, when its type contains a udt.",
	"Method": "Create addUDTStaticColumn(String columnName,UDTType udtType){\r\n    validateNotEmpty(tableName, \"Column name\");\r\n    validateNotNull(udtType, \"Column UDT type\");\r\n    validateNotKeyWord(columnName, String.format(\"The static column name '%s' is not allowed because it is a reserved keyword\", columnName));\r\n    staticColumns.put(columnName, udtType);\r\n    return this;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.tomcat.WebappLoaderTransformer.patchWebappLoader",
	"Comment": "init the plugin from start method.hook into main init method of the loader. init method name and resources type changes betweentomcat versions.",
	"Method": "void patchWebappLoader(CtClass ctClass){\r\n    boolean startHandled = false;\r\n    boolean stopHandled = false;\r\n    if (!startHandled) {\r\n        try {\r\n            ctClass.getDeclaredMethod(\"getContext\");\r\n            ctClass.getDeclaredMethod(\"startInternal\").insertAfter(TomcatPlugin.class.getName() + \".init(getClassLoader(), getContext().getResources());\");\r\n            startHandled = true;\r\n        } catch (NotFoundException e) {\r\n            LOGGER.trace(\"WebappLoader does not contain getContext() method, trying older Tomcat version.\");\r\n        }\r\n    }\r\n    if (!startHandled) {\r\n        try {\r\n            ctClass.getDeclaredMethod(\"startInternal\").insertAfter(TomcatPlugin.class.getName() + \".init(getClassLoader(), container.getResources());\");\r\n            startHandled = true;\r\n        } catch (NotFoundException e) {\r\n            LOGGER.trace(\"WebappLoader does not contain startInternal() method, trying older Tomcat version.\");\r\n        }\r\n    }\r\n    if (!startHandled) {\r\n        try {\r\n            ctClass.getDeclaredMethod(\"start\").insertAfter(TomcatPlugin.class.getName() + \".init(getClassLoader(), container.getResources());\");\r\n            startHandled = true;\r\n        } catch (NotFoundException e) {\r\n        }\r\n    }\r\n    if (!startHandled) {\r\n        LOGGER.warning(\"org.apache.catalina.loader.WebappLoader does not contain neither start nor startInternal method. Tomcat plugin will be disabled.\\n\" + \"*** Some properties (extraClasspath, watchResources) will NOT be supported on Tomcat level. They might be handled by another plugin though. ***\");\r\n    }\r\n    if (!stopHandled) {\r\n        try {\r\n            ctClass.getDeclaredMethod(\"stopInternal\").insertBefore(PluginManagerInvoker.buildCallCloseClassLoader(\"getClassLoader()\") + TomcatPlugin.class.getName() + \".close(getClassLoader());\");\r\n            stopHandled = true;\r\n        } catch (NotFoundException e) {\r\n            LOGGER.debug(\"org.apache.catalina.core.StandardContext does not contain stopInternal() method, trying older stop() method.\");\r\n        }\r\n    }\r\n    if (!stopHandled) {\r\n        try {\r\n            ctClass.getDeclaredMethod(\"stop\").insertBefore(PluginManagerInvoker.buildCallCloseClassLoader(\"getClassLoader()\") + TomcatPlugin.class.getName() + \".close(getClassLoader());\");\r\n            stopHandled = true;\r\n        } catch (NotFoundException e) {\r\n            LOGGER.debug(\"org.apache.catalina.core.StandardContext does not contain neither stop() nor stopInternal() method. Hotswap agent will not be able to free Tomcat plugin resources.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.Duration.newInstance",
	"Comment": "creates a duration with the given number of months, days and nanoseconds.a duration can be negative. in this case, all the non zero values must be negative.",
	"Method": "Duration newInstance(int months,int days,long nanoseconds){\r\n    return new Duration(months, days, nanoseconds);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.reflect.Loader.makeReflective",
	"Comment": "produces a reflective class.if the super class is also made reflective, it must be donebefore the sub class.",
	"Method": "boolean makeReflective(String clazz,String metaobject,String metaclass){\r\n    return reflection.makeReflective(clazz, metaobject, metaclass);\r\n}"
}, {
	"Path": "org.jabref.logic.openoffice.OOBibStyle.isSortByPosition",
	"Comment": "convenience method for checking the property for whether we sort the bibliographyaccording to their order of appearance in the text.",
	"Method": "boolean isSortByPosition(){\r\n    return (Boolean) getProperty(IS_SORT_BY_POSITION);\r\n}"
}, {
	"Path": "org.jabref.logic.util.io.XMLUtil.getNode",
	"Comment": "gets a the first subnode with the specified tag name.for example,hitsecond hit, but not returned",
	"Method": "Optional<Node> getNode(Node item,String nodeName){\r\n    return getNodesByName(item, nodeName).stream().findFirst();\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fileformat.ModsImporter.parseRelatedModsGroup",
	"Comment": "puts the information from the relatedmodsgroup. it has the same elements like the modsgroup.but informations like volume, issue and the pages appear here instead of in the modsgroup.also if there appears a title field, then this indicates that is the name of journal which the article belongs to.",
	"Method": "void parseRelatedModsGroup(Map<String, String> fields,List<Object> relatedModsGroup){\r\n    for (Object groupElement : relatedModsGroup) {\r\n        if (groupElement instanceof PartDefinition) {\r\n            PartDefinition part = (PartDefinition) groupElement;\r\n            List<Object> detailOrExtentOrDate = part.getDetailOrExtentOrDate();\r\n            for (Object object : detailOrExtentOrDate) {\r\n                if (object instanceof DetailDefinition) {\r\n                    DetailDefinition detail = (DetailDefinition) object;\r\n                    List<JAXBElement<StringPlusLanguage>> numberOrCaptionOrTitle = detail.getNumberOrCaptionOrTitle();\r\n                    for (JAXBElement<StringPlusLanguage> jaxbElement : numberOrCaptionOrTitle) {\r\n                        StringPlusLanguage value = jaxbElement.getValue();\r\n                        putIfValueNotNull(fields, detail.getType(), value.getValue());\r\n                    }\r\n                } else if (object instanceof ExtentDefinition) {\r\n                    ExtentDefinition extentDefinition = (ExtentDefinition) object;\r\n                    putPageInformation(extentDefinition, fields);\r\n                }\r\n            }\r\n        } else if (groupElement instanceof TitleInfoDefinition) {\r\n            TitleInfoDefinition titleInfo = (TitleInfoDefinition) groupElement;\r\n            List<Object> titleOrSubTitleOrPartNumber = titleInfo.getTitleOrSubTitleOrPartNumber();\r\n            for (Object object : titleOrSubTitleOrPartNumber) {\r\n                if (object instanceof JAXBElement) {\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    JAXBElement<StringPlusLanguage> element = (JAXBElement<StringPlusLanguage>) object;\r\n                    if (\"title\".equals(element.getName().getLocalPart())) {\r\n                        StringPlusLanguage journal = element.getValue();\r\n                        fields.put(FieldName.JOURNAL, journal.getValue());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jabref.model.database.BibDatabase.getStringKeySet",
	"Comment": "returns a set of keys to all bibtexstring objects in the database.these are in no sorted order.",
	"Method": "Set<String> getStringKeySet(){\r\n    return bibtexStrings.keySet();\r\n}"
}, {
	"Path": "org.menacheri.jetserver.util.NettyUtils.writeStrings",
	"Comment": "writes multiple strings to a channelbuffer with the length of the string\tpreceding its content. so if there are two string hello and\tworld then the channel buffer returned would contain",
	"Method": "ChannelBuffer writeStrings(String msgs,ChannelBuffer writeStrings,Charset charset,String msgs){\r\n    ChannelBuffer buffer = null;\r\n    for (String msg : msgs) {\r\n        if (null == buffer) {\r\n            buffer = writeString(msg, charset);\r\n        } else {\r\n            ChannelBuffer theBuffer = writeString(msg, charset);\r\n            if (null != theBuffer) {\r\n                buffer = ChannelBuffers.wrappedBuffer(buffer, theBuffer);\r\n            }\r\n        }\r\n    }\r\n    return buffer;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.jersey2.Jersey2Plugin.invalidate",
	"Comment": "call reload on the jersey application when any class changes that is either involved in configuringthe jersey application, or if was newly annotated and will be involved in configuring the application.",
	"Method": "void invalidate(CtClass ctClass,Class original){\r\n    boolean reloaded = false;\r\n    if (allRegisteredClasses.contains(original)) {\r\n        scheduler.scheduleCommand(reloadJerseyContainers);\r\n        reloaded = true;\r\n    } else {\r\n        if (AnnotationHelper.hasAnnotation(original, \"javax.ws.rs.Path\") || AnnotationHelper.hasAnnotation(ctClass, \"javax.ws.rs.Path\")) {\r\n            allRegisteredClasses.add(original);\r\n            scheduler.scheduleCommand(reloadJerseyContainers);\r\n            reloaded = true;\r\n        }\r\n    }\r\n    if (!reloaded) {\r\n        if (AnnotationHelper.hasAnnotation(original, \"org.jvnet.hk2.annotations.Service\") || AnnotationHelper.hasAnnotation(ctClass, \"org.jvnet.hk2.annotations.Service\")) {\r\n            scheduler.scheduleCommand(reloadJerseyContainers);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.util.io.FileUtil.toPortableString",
	"Comment": "creates a string representation of the given path that should work on all systems.this method should be used when a path needs to be stored in the bib file or preferences.",
	"Method": "String toPortableString(Path path){\r\n    return path.toString().replace('\\\\', '/');\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.SqlStatement.bindMap",
	"Comment": "binds named parameters from a map of string to object instances",
	"Method": "This bindMap(Map<String, ?> map){\r\n    return map == null ? typedThis : bindNamedArgumentFinder(new MapArguments(map));\r\n}"
}, {
	"Path": "org.menacheri.jetclient.util.LoginHelper.getLoginBuffer",
	"Comment": "creates the appropriate login buffer using username, password,\tconnectionkey and the local address to which the udp channel is bound.",
	"Method": "MessageBuffer<ChannelBuffer> getLoginBuffer(InetSocketAddress localUDPAddress){\r\n    ChannelBuffer loginBuffer;\r\n    ChannelBuffer credentials = NettyUtils.writeStrings(username, password, connectionKey);\r\n    if (null != localUDPAddress) {\r\n        ChannelBuffer udpAddressBuffer = NettyUtils.writeSocketAddress(localUDPAddress);\r\n        loginBuffer = ChannelBuffers.wrappedBuffer(credentials, udpAddressBuffer);\r\n    } else {\r\n        loginBuffer = credentials;\r\n    }\r\n    return new NettyMessageBuffer(loginBuffer);\r\n}"
}, {
	"Path": "org.jabref.gui.preferences.TableColumnsTab.storeSettings",
	"Comment": "store changes to table preferences. this method is called whenthe user clicks ok.",
	"Method": "void storeSettings(){\r\n    prefs.putBoolean(JabRefPreferences.FILE_COLUMN, fileColumn.isSelected());\r\n    prefs.putBoolean(JabRefPreferences.URL_COLUMN, urlColumn.isSelected());\r\n    prefs.putBoolean(JabRefPreferences.PREFER_URL_DOI, preferDoi.isSelected());\r\n    prefs.putBoolean(JabRefPreferences.ARXIV_COLUMN, arxivColumn.isSelected());\r\n    prefs.putBoolean(JabRefPreferences.EXTRA_FILE_COLUMNS, extraFileColumns.isSelected());\r\n    if (extraFileColumns.isSelected() && !listOfFileColumns.getSelectionModel().isEmpty()) {\r\n        ObservableList selections = listOfFileColumns.getSelectionModel().getSelectedItems();\r\n        prefs.putStringList(JabRefPreferences.LIST_OF_FILE_COLUMNS, selections);\r\n    } else {\r\n        prefs.putStringList(JabRefPreferences.LIST_OF_FILE_COLUMNS, new ArrayList());\r\n    }\r\n    boolean newSpecialFieldsEnabled = specialFieldsEnabled.isSelected();\r\n    boolean newRankingColumn = rankingColumn.isSelected();\r\n    boolean newQualityColumn = qualityColumn.isSelected();\r\n    boolean newPriorityColumn = priorityColumn.isSelected();\r\n    boolean newRelevanceColumn = relevanceColumn.isSelected();\r\n    boolean newPrintedColumn = printedColumn.isSelected();\r\n    boolean newReadStatusColumn = readStatusColumn.isSelected();\r\n    boolean newSyncKeyWords = syncKeywords.isSelected();\r\n    boolean newWriteSpecialFields = writeSpecialFields.isSelected();\r\n    boolean restartRequired;\r\n    restartRequired = (oldSpecialFieldsEnabled != newSpecialFieldsEnabled) || (oldRankingColumn != newRankingColumn) || (oldQualityColumn != newQualityColumn) || (oldPriorityColumn != newPriorityColumn) || (oldRelevanceColumn != newRelevanceColumn) || (oldPrintedColumn != newPrintedColumn) || (oldReadStatusColumn != newReadStatusColumn) || (oldSyncKeyWords != newSyncKeyWords) || (oldWriteSpecialFields != newWriteSpecialFields);\r\n    if (restartRequired) {\r\n        DefaultTaskExecutor.runInJavaFXThread(() -> frame.getDialogService().showWarningDialogAndWait(Localization.lang(\"Changed special field settings\"), Localization.lang(\"You have changed settings for special fields.\").concat(\" \").concat(Localization.lang(\"You must restart JabRef for this to come into effect.\"))));\r\n    }\r\n    if (restartRequired) {\r\n        prefs.putBoolean(JabRefPreferences.SPECIALFIELDSENABLED, newSpecialFieldsEnabled);\r\n        prefs.putBoolean(JabRefPreferences.SHOWCOLUMN_RANKING, newRankingColumn);\r\n        prefs.putBoolean(JabRefPreferences.SHOWCOLUMN_PRIORITY, newPriorityColumn);\r\n        prefs.putBoolean(JabRefPreferences.SHOWCOLUMN_QUALITY, newQualityColumn);\r\n        prefs.putBoolean(JabRefPreferences.SHOWCOLUMN_RELEVANCE, newRelevanceColumn);\r\n        prefs.putBoolean(JabRefPreferences.SHOWCOLUMN_PRINTED, newPrintedColumn);\r\n        prefs.putBoolean(JabRefPreferences.SHOWCOLUMN_READ, newReadStatusColumn);\r\n        prefs.putBoolean(JabRefPreferences.AUTOSYNCSPECIALFIELDSTOKEYWORDS, newSyncKeyWords);\r\n        prefs.putBoolean(JabRefPreferences.SERIALIZESPECIALFIELDS, newWriteSpecialFields);\r\n    }\r\n    if (tableChanged) {\r\n        int i = 0;\r\n        while (i < tableRows.size()) {\r\n            if (tableRows.get(i).getName().isEmpty()) {\r\n                tableRows.remove(i);\r\n            } else {\r\n                i++;\r\n            }\r\n        }\r\n        List<String> names = new ArrayList(tableRows.size());\r\n        List<String> widths = new ArrayList(tableRows.size());\r\n        for (TableRow tr : tableRows) {\r\n            names.add(tr.getName().toLowerCase(Locale.ROOT));\r\n            widths.add(String.valueOf(tr.getLength()));\r\n        }\r\n        prefs.putStringList(JabRefPreferences.COLUMN_NAMES, names);\r\n        prefs.putStringList(JabRefPreferences.COLUMN_WIDTHS, widths);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.customentrytypes.FieldSetComponent.addListSelectionListener",
	"Comment": "add a listselectionlistener to the jlist component displayed as part of this component.",
	"Method": "void addListSelectionListener(ListSelectionListener l){\r\n    list.addListSelectionListener(l);\r\n}"
}, {
	"Path": "com.datastax.driver.core.exceptions.UnavailableException.getAliveReplicas",
	"Comment": "the number of replicas that were known to be alive by the cassandra coordinator node when ittried to execute the operation.",
	"Method": "int getAliveReplicas(){\r\n    return alive;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ClassUtils.getAllInterfaces",
	"Comment": "return all interfaces that the given instance implements as array,including ones implemented by superclasses.",
	"Method": "Class<?>[] getAllInterfaces(Object instance){\r\n    Assert.notNull(instance, \"Instance must not be null\");\r\n    return getAllInterfacesForClass(instance.getClass());\r\n}"
}, {
	"Path": "org.jabref.logic.pdf.TextExtractor.extractMarkedText",
	"Comment": "extracts the text of a marked annotation such as highlights, underlines, strikeouts etc.",
	"Method": "String extractMarkedText(){\r\n    PDFTextStripperByArea stripperByArea = new PDFTextStripperByArea();\r\n    String markedText = \"\";\r\n    int totalSegments = boundingBoxes.size() / 8;\r\n    for (int currentSegment = 1, segmentPointer = 0; currentSegment <= totalSegments; currentSegment++, segmentPointer += 8) {\r\n        try {\r\n            stripperByArea.addRegion(\"markedRegion\", calculateSegmentBoundingBox(boundingBoxes, segmentPointer));\r\n            stripperByArea.extractRegions(page);\r\n            markedText = markedText.concat(stripperByArea.getTextForRegion(\"markedRegion\"));\r\n        } catch (IllegalArgumentException e) {\r\n            throw new IOException(\"Cannot read annotation coordinates!\", e);\r\n        }\r\n    }\r\n    return markedText.trim();\r\n}"
}, {
	"Path": "org.hotswap.agent.util.PluginManagerInvoker.callCloseClassLoader",
	"Comment": "free all classloader references and close any associated plugin instance.typical use is after webapp undeploy.",
	"Method": "void callCloseClassLoader(ClassLoader appClassLoader){\r\n    PluginManager.getInstance().closeClassLoader(appClassLoader);\r\n}"
}, {
	"Path": "com.datastax.driver.core.PlainTextAuthProvider.setPassword",
	"Comment": "changes the password.the new credentials will be used for all connections initiated after this method was called.",
	"Method": "void setPassword(String password){\r\n    this.password = password;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.FileSystemResource.getInputStream",
	"Comment": "this implementation opens a fileinputstream for the underlying file.",
	"Method": "InputStream getInputStream(){\r\n    return new FileInputStream(this.file);\r\n}"
}, {
	"Path": "org.jabref.gui.keyboard.KeyBindingRepository.getKey",
	"Comment": "returns the keystroke for this binding, as defined by the defaults, or in the preferences.",
	"Method": "KeyStroke getKey(KeyBinding bindName){\r\n    String s = get(bindName.getConstant());\r\n    s = s.replace(\"+\", \" \");\r\n    if (OS.OS_X) {\r\n        return getKeyForMac(KeyStroke.getKeyStroke(s));\r\n    } else {\r\n        return KeyStroke.getKeyStroke(s);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.PathResource.getOutputStream",
	"Comment": "this implementation opens a outputstream for the underlying file.",
	"Method": "OutputStream getOutputStream(){\r\n    if (Files.isDirectory(this.path)) {\r\n        throw new FileNotFoundException(getPath() + \" (is a directory)\");\r\n    }\r\n    return Files.newOutputStream(this.path);\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.TableOptions.minIndexInterval",
	"Comment": "define the minimum index interval for cassandra 2.1.if no call is made to this method, the default value set by cassandra is 128.",
	"Method": "T minIndexInterval(Integer minIndexInterval){\r\n    this.minIndexInterval = Optional.fromNullable(minIndexInterval);\r\n    return self;\r\n}"
}, {
	"Path": "org.elixir_lang.beam.psi.impl.ModuleElementImpl.findReferenceAt",
	"Comment": "finds a reference at the specified offset from the start of the text range of this node.",
	"Method": "PsiReference findReferenceAt(int offset){\r\n    PsiElement mirror = getMirror();\r\n    PsiReference referenceAt = null;\r\n    if (mirror != null) {\r\n        PsiReference mirrorRef = mirror.findReferenceAt(offset);\r\n        if (mirrorRef != null) {\r\n            PsiElement mirrorElement = mirrorRef.getElement();\r\n            PsiElement element = mirrorToElement(mirrorElement);\r\n            if (element != null) {\r\n                referenceAt = element.getReference();\r\n            }\r\n        }\r\n    }\r\n    return referenceAt;\r\n}"
}, {
	"Path": "com.datastax.driver.examples.paging.ForwardPagingRestUi.createSchema",
	"Comment": "creates a table storing videos by users, in a typically denormalized way",
	"Method": "void createSchema(Session session){\r\n    session.execute(\"CREATE KEYSPACE IF NOT EXISTS examples \" + \"WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1}\");\r\n    session.execute(\"CREATE TABLE IF NOT EXISTS examples.forward_paging_rest_ui(\" + \"userid int, username text, \" + \"added timestamp, \" + \"videoid int, title text, \" + \"PRIMARY KEY (userid, added, videoid)\" + \") WITH CLUSTERING ORDER BY (added DESC, videoid ASC)\");\r\n}"
}, {
	"Path": "org.jabref.logic.util.io.XMLUtil.getNodesByName",
	"Comment": "gets a list of subnodes with the specified tag name.for example,first hitsecond hit",
	"Method": "List<Node> getNodesByName(Node item,String nodeName){\r\n    if (item.getNodeType() != Node.ELEMENT_NODE) {\r\n        return Collections.emptyList();\r\n    }\r\n    NodeList nodes = ((Element) item).getElementsByTagName(nodeName);\r\n    return asList(nodes);\r\n}"
}, {
	"Path": "org.jabref.gui.importer.ImportInspectionDialog.generateKeys",
	"Comment": "generate keys for all entries. all keys will be unique with respect toone another, and, if they are destined for an existing database, withrespect to existing keys in the database.",
	"Method": "void generateKeys(){\r\n    entries.getReadWriteLock().writeLock().lock();\r\n    try {\r\n        BibDatabase database;\r\n        MetaData localMetaData;\r\n        if (panel == null) {\r\n            database = new BibDatabase();\r\n            localMetaData = new MetaData();\r\n        } else {\r\n            database = panel.getDatabase();\r\n            localMetaData = panel.getBibDatabaseContext().getMetaData();\r\n        }\r\n        List<Optional<String>> keys = new ArrayList(entries.size());\r\n        for (BibEntry entry : entries) {\r\n            entry.setId(IdGenerator.next());\r\n            database.insertEntry(entry);\r\n            new BibtexKeyGenerator(localMetaData.getCiteKeyPattern(Globals.prefs.getBibtexKeyPatternPreferences().getKeyPattern()), database, Globals.prefs.getBibtexKeyPatternPreferences()).generateAndSetKey(entry);\r\n            keys.add(entry.getCiteKeyOptional());\r\n        }\r\n        preview.update();\r\n        for (BibEntry entry : entries) {\r\n            database.removeEntry(entry);\r\n        }\r\n    } finally {\r\n        entries.getReadWriteLock().writeLock().unlock();\r\n    }\r\n    glTable.repaint();\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.owb.OwbPlugin.init",
	"Comment": "plugin initialization, called from archive registration,",
	"Method": "void init(){\r\n    if (!initialized) {\r\n        LOGGER.info(\"CDI/Owb plugin initialized.\");\r\n        initialized = true;\r\n        beanReloadStrategy = setBeanReloadStrategy(pluginConfiguration.getProperty(\"owb.beanReloadStrategy\"));\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.fieldeditors.FieldEditorFX.getWeight",
	"Comment": "returns relative size of the field editor in terms of display space.a value of 1 means that the editor gets exactly as much space as all other regular editors.a value of 2 means that the editor gets twice as much space as regular editors.",
	"Method": "double getWeight(){\r\n    return 1;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.ProxyClassSignatureHelper.isDifferent",
	"Comment": "class arrays need to be in the same order. check if a signature of class differs from aonther. useful forchecking difference in different classloaders.",
	"Method": "boolean isDifferent(Class<?>[] classesA,Class<?>[] classesB){\r\n    for (int i = 0; i < classesB.length; i++) {\r\n        Class<?> class1 = classesA[i];\r\n        Class<?> class2 = classesB[i];\r\n        if (ClassSignatureComparerHelper.isDifferent(class1, class2, SIGNATURE_ELEMENTS)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.loader.DefaultResourceLoader.getResourceByPath",
	"Comment": "return a resource handle for the resource at the given path.the default implementation supports class path locations. this should beappropriate for standalone implementations but can be overridden, e.g.for implementations targeted at a servlet container.",
	"Method": "Resource getResourceByPath(String path){\r\n    return new ClassPathContextResource(path, getClassLoader());\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.weld.transformer.CdiContextsTransformer.transformReloadingWeldContexts",
	"Comment": "add context reloading functionality to base contexts classes.",
	"Method": "void transformReloadingWeldContexts(CtClass ctClass,ClassPool classPool){\r\n    LOGGER.debug(\"Adding interface {} to {}.\", WeldHotswapContext.class.getName(), ctClass.getName());\r\n    ctClass.addInterface(classPool.get(WeldHotswapContext.class.getName()));\r\n    CtField toReloadFld = CtField.make(\"public transient java.util.Set $$ha$toReloadWeld = null;\", ctClass);\r\n    ctClass.addField(toReloadFld);\r\n    CtField reloadingFld = CtField.make(\"public transient boolean $$ha$reloadingWeld = false;\", ctClass);\r\n    ctClass.addField(reloadingFld);\r\n    CtMethod addBeanToReload = CtMethod.make(\"public void $$ha$addBeanToReloadWeld(javax.enterprise.context.spi.Contextual bean) {\" + \"if ($$ha$toReloadWeld == null)\" + \"$$ha$toReloadWeld = new java.util.HashSet();\" + \"$$ha$toReloadWeld.add(bean);\" + \"}\", ctClass);\r\n    ctClass.addMethod(addBeanToReload);\r\n    CtMethod getBeansToReload = CtMethod.make(\"public java.util.Set $$ha$getBeansToReloadWeld(){return $$ha$toReloadWeld;}\", ctClass);\r\n    ctClass.addMethod(getBeansToReload);\r\n    CtMethod reload = CtMethod.make(\"public void $$ha$reloadWeld() {\" + ContextualReloadHelper.class.getName() + \".reload(this);}\", ctClass);\r\n    ctClass.addMethod(reload);\r\n    CtMethod isActive = ctClass.getDeclaredMethod(\"isActive\");\r\n    isActive.insertAfter(\"{\" + \"if($_ && !$$ha$reloadingWeld ) { \" + \"$$ha$reloadingWeld = true;\" + \"$$ha$reloadWeld();\" + \"$$ha$reloadingWeld = false;\" + \"}\" + \"return $_;\" + \"}\");\r\n    LOGGER.debug(\"Class '{}' patched with hot-swapping support\", ctClass.getName());\r\n}"
}, {
	"Path": "com.datastax.driver.core.TableOptionsMetadata.getReadRepairChance",
	"Comment": "returns the chance with which a read repair is triggered for this table.",
	"Method": "double getReadRepairChance(){\r\n    return readRepair;\r\n}"
}, {
	"Path": "com.beust.jcommander.ParameterDescription.init",
	"Comment": "initializes the state of this parameter description. this will set an appropriate bundle if it is null.if its the description in is empty and it refers to an enum type, then the description will be set to its possiblevalues. it will also attempt to validate the default value of the parameter.",
	"Method": "void init(Object object,Parameterized parameterized,ResourceBundle bundle,JCommander jCommander){\r\n    this.object = object;\r\n    this.parameterized = parameterized;\r\n    this.bundle = bundle;\r\n    if (this.bundle == null) {\r\n        this.bundle = findResourceBundle(object);\r\n    }\r\n    this.jCommander = jCommander;\r\n    if (parameterAnnotation != null) {\r\n        String description;\r\n        if (Enum.class.isAssignableFrom(parameterized.getType()) && parameterAnnotation.description().isEmpty()) {\r\n            description = \"Options: \" + EnumSet.allOf((Class<? extends Enum>) parameterized.getType());\r\n        } else {\r\n            description = parameterAnnotation.description();\r\n        }\r\n        initDescription(description, parameterAnnotation.descriptionKey(), parameterAnnotation.names());\r\n    } else if (dynamicParameterAnnotation != null) {\r\n        initDescription(dynamicParameterAnnotation.description(), dynamicParameterAnnotation.descriptionKey(), dynamicParameterAnnotation.names());\r\n    } else {\r\n        throw new AssertionError(\"Shound never happen\");\r\n    }\r\n    try {\r\n        defaultObject = parameterized.get(object);\r\n    } catch (Exception e) {\r\n    }\r\n    if (defaultObject != null) {\r\n        if (parameterAnnotation != null) {\r\n            validateDefaultValues(parameterAnnotation.names());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.CodecUtils.readValue",
	"Comment": "utility method that reads a value. mainly intended for collection codecs when deserializing cqlcollections.",
	"Method": "ByteBuffer readValue(ByteBuffer input,ProtocolVersion version){\r\n    int size = readSize(input, version);\r\n    return size < 0 ? null : readBytes(input, size);\r\n}"
}, {
	"Path": "com.datastax.driver.core.AuthenticationTest.should_connect_with_slow_server",
	"Comment": "ensures that authentication is possible even if the server is busy during sasl handshake.",
	"Method": "void should_connect_with_slow_server(){\r\n    Cluster cluster = Cluster.builder().addContactPoints(getContactPoints()).withPort(ccm().getBinaryPort()).withAuthProvider(new SlowAuthProvider()).withPoolingOptions(new PoolingOptions().setHeartbeatIntervalSeconds(1)).build();\r\n    cluster.connect();\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.java.ProxyGenerator.generateClassFile",
	"Comment": "generate a class file for the proxy class. this method drives the class file generation process.",
	"Method": "byte[] generateClassFile(){\r\n    addProxyMethod(hashCodeMethod, Object.class);\r\n    addProxyMethod(equalsMethod, Object.class);\r\n    addProxyMethod(toStringMethod, Object.class);\r\n    for (Class<?> intf : interfaces) {\r\n        for (Method m : intf.getMethods()) {\r\n            addProxyMethod(m, intf);\r\n        }\r\n    }\r\n    for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\r\n        checkReturnTypes(sigmethods);\r\n    }\r\n    try {\r\n        methods.add(generateConstructor());\r\n        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\r\n            for (ProxyMethod pm : sigmethods) {\r\n                fields.add(new FieldInfo(pm.methodFieldName, \"Ljava/lang/reflect/Method;\", ACC_PRIVATE | ACC_STATIC));\r\n            }\r\n        }\r\n        fields.add(new FieldInfo(initFieldName, \"Z\", ACC_PRIVATE | ACC_STATIC));\r\n        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\r\n            for (ProxyMethod pm : sigmethods) {\r\n                methods.add(pm.generateMethod());\r\n            }\r\n        }\r\n        methods.add(generateStaticInitializer());\r\n        methods.add(generateStaticInitializerCaller());\r\n    } catch (IOException e) {\r\n        throw new InternalError(\"unexpected I/O Exception\" + e);\r\n    }\r\n    if (methods.size() > 65535) {\r\n        throw new IllegalArgumentException(\"method limit exceeded\");\r\n    }\r\n    if (fields.size() > 65535) {\r\n        throw new IllegalArgumentException(\"field limit exceeded\");\r\n    }\r\n    cp.getClass(dotToSlash(className));\r\n    cp.getClass(superclassName);\r\n    for (Class<?> intf : interfaces) {\r\n        cp.getClass(dotToSlash(intf.getName()));\r\n    }\r\n    cp.setReadOnly();\r\n    ByteArrayOutputStream bout = new ByteArrayOutputStream();\r\n    DataOutputStream dout = new DataOutputStream(bout);\r\n    try {\r\n        dout.writeInt(0xCAFEBABE);\r\n        dout.writeShort(CLASSFILE_MINOR_VERSION);\r\n        dout.writeShort(CLASSFILE_MAJOR_VERSION);\r\n        cp.write(dout);\r\n        dout.writeShort(accessFlags);\r\n        dout.writeShort(cp.getClass(dotToSlash(className)));\r\n        dout.writeShort(cp.getClass(superclassName));\r\n        dout.writeShort(interfaces.length);\r\n        for (Class<?> intf : interfaces) {\r\n            dout.writeShort(cp.getClass(dotToSlash(intf.getName())));\r\n        }\r\n        dout.writeShort(fields.size());\r\n        for (FieldInfo f : fields) {\r\n            f.write(dout);\r\n        }\r\n        dout.writeShort(methods.size());\r\n        for (MethodInfo m : methods) {\r\n            m.write(dout);\r\n        }\r\n        dout.writeShort(0);\r\n    } catch (IOException e) {\r\n        throw new InternalError(\"unexpected I/O Exception\" + e);\r\n    }\r\n    return bout.toByteArray();\r\n}"
}, {
	"Path": "org.jabref.logic.shared.DBMSSynchronizer.pullChanges",
	"Comment": "synchronizes the local bibentries and applies the fetched metadata on them.",
	"Method": "void pullChanges(){\r\n    if (!checkCurrentConnection()) {\r\n        return;\r\n    }\r\n    synchronizeLocalDatabase();\r\n    synchronizeLocalMetaData();\r\n}"
}, {
	"Path": "com.datastax.driver.core.CodecUtils.writeSize",
	"Comment": "utility method that writes a size value. mainly intended for collection codecs when serializingcql collections.",
	"Method": "void writeSize(ByteBuffer output,int size,ProtocolVersion version){\r\n    switch(version) {\r\n        case V1:\r\n        case V2:\r\n            if (size > 65535)\r\n                throw new IllegalArgumentException(String.format(\"Native protocol version %d supports up to 65535 elements in any collection - but collection contains %d elements\", version.toInt(), size));\r\n            output.putShort((short) size);\r\n            break;\r\n        case V3:\r\n        case V4:\r\n        case V5:\r\n            output.putInt(size);\r\n            break;\r\n        default:\r\n            throw version.unsupported();\r\n    }\r\n}"
}, {
	"Path": "org.menacheri.jetserver.server.netty.UDPChannelPipelineFactory.init",
	"Comment": "this method creates a single pipeline object that will be shared for all\tthe channels.",
	"Method": "void init(){\r\n    pipeline = pipeline();\r\n    pipeline.addLast(\"messageBufferEventDecoder\", messageBufferEventDecoder);\r\n    pipeline.addLast(\"upstream\", upstream);\r\n    pipeline.addLast(\"messageBufferEventEncoder\", messageBufferEventEncoder);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.ClassPathResource.equals",
	"Comment": "this implementation compares the underlying class path locations.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == this) {\r\n        return true;\r\n    }\r\n    if (obj instanceof ClassPathResource) {\r\n        ClassPathResource otherRes = (ClassPathResource) obj;\r\n        return (this.path.equals(otherRes.path) && ObjectUtils.nullSafeEquals(this.classLoader, otherRes.classLoader) && ObjectUtils.nullSafeEquals(this.clazz, otherRes.clazz));\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.datastax.driver.core.PoolingOptions.getNewConnectionThreshold",
	"Comment": "returns the threshold that triggers the creation of a new connection to a host.",
	"Method": "int getNewConnectionThreshold(HostDistance distance){\r\n    return newConnectionThreshold[distance.ordinal()];\r\n}"
}, {
	"Path": "com.datastax.driver.core.TableOptionsMetadata.getGcGraceInSeconds",
	"Comment": "returns the tombstone garbage collection grace time in seconds for this table.",
	"Method": "int getGcGraceInSeconds(){\r\n    return gcGrace;\r\n}"
}, {
	"Path": "org.jabref.gui.collab.DatabaseChangeMonitor.hasBeenModified",
	"Comment": "forces a check on the file, and returns the result. check if time stamp or the file size has changed.",
	"Method": "boolean hasBeenModified(){\r\n    Optional<Path> file = database.getDatabasePath();\r\n    if (file.isPresent()) {\r\n        try {\r\n            long modified = Files.getLastModifiedTime(file.get()).toMillis();\r\n            if (modified == 0L) {\r\n                return false;\r\n            }\r\n            long fileSizeNow = Files.size(file.get());\r\n            return (timeStamp != modified) || (fileSize != fileSizeNow);\r\n        } catch (IOException ex) {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jabref.model.TreeNode.getPathFromRoot",
	"Comment": "returns the path from the root, to get to this node. the last element in the path is this node.",
	"Method": "List<T> getPathFromRoot(){\r\n    if (parent == null) {\r\n        List<T> pathToMe = new ArrayList();\r\n        pathToMe.add((T) this);\r\n        return pathToMe;\r\n    }\r\n    List<T> path = parent.getPathFromRoot();\r\n    path.add((T) this);\r\n    return path;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.StatementContext.getParsedSql",
	"Comment": "obtain the parsed sql statementnot available until until statement execution time",
	"Method": "ParsedSql getParsedSql(){\r\n    return parsedSql;\r\n}"
}, {
	"Path": "org.jabref.gui.importer.EntryFromFileCreator.extractPathesToKeyWordsfield",
	"Comment": "splits the path to the file and builds a keywords string in the formatthat is used by jabref.",
	"Method": "String extractPathesToKeyWordsfield(String absolutePath){\r\n    StringBuilder sb = new StringBuilder();\r\n    StringTokenizer st = new StringTokenizer(absolutePath, String.valueOf(File.separatorChar));\r\n    while (st.hasMoreTokens()) {\r\n        String token = st.nextToken();\r\n        if (!st.hasMoreTokens()) {\r\n            break;\r\n        }\r\n        if (token.length() >= MIN_PATH_TOKEN_LENGTH) {\r\n            if (sb.length() > 0) {\r\n                sb.append(',');\r\n            }\r\n            sb.append(token);\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ClassUtils.isPrimitiveWrapper",
	"Comment": "check if the given class represents a primitive wrapper, i.e. boolean,byte, character, short, integer, long, float, or double.",
	"Method": "boolean isPrimitiveWrapper(Class<?> clazz){\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return primitiveWrapperTypeMap.containsKey(clazz);\r\n}"
}, {
	"Path": "org.jabref.model.TreeNode.notifyAboutDescendantChange",
	"Comment": "helper method which notifies all subscribers about a change in the subtree and bubbles the event to all parents.",
	"Method": "void notifyAboutDescendantChange(T source){\r\n    onDescendantChanged.accept(source);\r\n    if (!isRoot()) {\r\n        parent.notifyAboutDescendantChange(source);\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.CustomPayloadTest.should_propagate_incoming_payload_to_bound_statement",
	"Comment": "ensures that an incoming payload is propagated from prepared to bound statements.",
	"Method": "void should_propagate_incoming_payload_to_bound_statement(){\r\n    RegularStatement statement = new SimpleStatement(\"SELECT c2 as col1 FROM t1 where c1 = ?\");\r\n    statement.setOutgoingPayload(payload1);\r\n    PreparedStatement ps = session().prepare(statement);\r\n    assertThat(ps.getOutgoingPayload()).isEqualTo(payload1);\r\n    assertThat(ps.getIncomingPayload()).isEqualTo(payload1);\r\n    ps.setOutgoingPayload(null);\r\n    BoundStatement bs = ps.bind(1);\r\n    ResultSet rows = session().execute(bs);\r\n    Map<String, ByteBuffer> actual = rows.getExecutionInfo().getIncomingPayload();\r\n    assertThat(actual).isEqualTo(payload1);\r\n    bs = ps.bind();\r\n    bs.setInt(0, 1);\r\n    rows = session().execute(bs);\r\n    actual = rows.getExecutionInfo().getIncomingPayload();\r\n    assertThat(actual).isEqualTo(payload1);\r\n}"
}, {
	"Path": "org.menacheri.jetserver.util.NettyUtils.clearPipeline",
	"Comment": "a utility method to clear the netty pipeline of all handlers.",
	"Method": "void clearPipeline(ChannelPipeline pipeline){\r\n    if (null == pipeline) {\r\n        return;\r\n    }\r\n    try {\r\n        int counter = 0;\r\n        while (pipeline.getFirst() != null) {\r\n            pipeline.removeFirst();\r\n            counter++;\r\n        }\r\n        LOG.trace(\"Removed {} handlers from pipeline\", counter);\r\n    } catch (NoSuchElementException e) {\r\n    }\r\n}"
}, {
	"Path": "org.elixir_lang.TypedHandler.charTyped",
	"Comment": "called after the specified character typed by the user has been inserted in the editor.",
	"Method": "Result charTyped(char charTyped,Project project,Editor editor,PsiFile file){\r\n    Result result = Result.CONTINUE;\r\n    if (file instanceof ElixirFile) {\r\n        if (charTyped == ' ') {\r\n            int caret = editor.getCaretModel().getOffset();\r\n            if (caret > 2) {\r\n                final EditorHighlighter highlighter = ((EditorEx) editor).getHighlighter();\r\n                HighlighterIterator iterator = highlighter.createIterator(caret - 2);\r\n                IElementType tokenType = iterator.getTokenType();\r\n                if (tokenType == ElixirTypes.DO || tokenType == ElixirTypes.FN) {\r\n                    editor.getDocument().insertString(caret, \" end\");\r\n                    result = Result.STOP;\r\n                }\r\n            }\r\n        } else if (charTyped == '<') {\r\n            int caret = editor.getCaretModel().getOffset();\r\n            if (caret > 2) {\r\n                final EditorHighlighter highlighter = ((EditorEx) editor).getHighlighter();\r\n                HighlighterIterator iterator = highlighter.createIterator(caret - 1);\r\n                IElementType tokenType = iterator.getTokenType();\r\n                if (SIGIL_PROMOTERS.contains(tokenType)) {\r\n                    editor.getDocument().insertString(caret, \">\");\r\n                    result = Result.STOP;\r\n                }\r\n            }\r\n            if (result == Result.CONTINUE && caret > 1) {\r\n                final EditorHighlighter highlighter = ((EditorEx) editor).getHighlighter();\r\n                HighlighterIterator iterator = highlighter.createIterator(caret - 2);\r\n                if (iterator.getTokenType() == ElixirTypes.OPENING_BIT) {\r\n                    editor.getDocument().insertString(caret, \">>\");\r\n                    result = Result.STOP;\r\n                }\r\n            }\r\n        } else if (charTyped == '/' || charTyped == '|') {\r\n            int caret = editor.getCaretModel().getOffset();\r\n            if (caret > 2) {\r\n                final EditorHighlighter highlighter = ((EditorEx) editor).getHighlighter();\r\n                HighlighterIterator iterator = highlighter.createIterator(caret - 1);\r\n                IElementType tokenType = iterator.getTokenType();\r\n                if (SIGIL_PROMOTERS.contains(tokenType)) {\r\n                    editor.getDocument().insertString(caret, String.valueOf(charTyped));\r\n                    result = Result.STOP;\r\n                }\r\n            }\r\n        } else if (charTyped == '{') {\r\n            int caret = editor.getCaretModel().getOffset();\r\n            if (caret > 1) {\r\n                final EditorHighlighter highlighter = ((EditorEx) editor).getHighlighter();\r\n                HighlighterIterator iterator = highlighter.createIterator(caret - 1);\r\n                IElementType tokenType = iterator.getTokenType();\r\n                if (tokenType == ElixirTypes.INTERPOLATION_START) {\r\n                    editor.getDocument().insertString(caret, \"}\");\r\n                    result = Result.STOP;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.TableOptions.dcLocalReadRepairChance",
	"Comment": "define the probability of read repairs being invoked over all replicas in the current datacenter.if no call is made to this method, the default value set by cassandra is 0.0.",
	"Method": "T dcLocalReadRepairChance(Double dcLocalReadRepairChance){\r\n    validateRateValue(dcLocalReadRepairChance, \"DC local read repair chance\");\r\n    this.dcLocalReadRepairChance = Optional.fromNullable(dcLocalReadRepairChance);\r\n    return self;\r\n}"
}, {
	"Path": "com.datastax.driver.examples.paging.RandomPagingRestUi.createSchema",
	"Comment": "creates a table storing videos by users, in a typically denormalized way",
	"Method": "void createSchema(Session session){\r\n    session.execute(\"CREATE KEYSPACE IF NOT EXISTS examples \" + \"WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1}\");\r\n    session.execute(\"CREATE TABLE IF NOT EXISTS examples.random_paging_rest_ui(\" + \"userid int, username text, \" + \"added timestamp, \" + \"videoid int, title text, \" + \"PRIMARY KEY (userid, added, videoid)\" + \") WITH CLUSTERING ORDER BY (added DESC, videoid ASC)\");\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fileformat.BibtexParser.dumpTextReadSoFarToString",
	"Comment": "puts all text that has been read from the reader, including newlines, etc., since the last call of this method into a string.removes the jabref file header, if it is found",
	"Method": "String dumpTextReadSoFarToString(){\r\n    String result = getPureTextFromFile();\r\n    int indexOfAt = result.indexOf(\"@\");\r\n    if (indexOfAt == -1) {\r\n        return purgeEOFCharacters(result);\r\n    } else if (result.contains(BibtexDatabaseWriter.DATABASE_ID_PREFIX)) {\r\n        return purge(result, BibtexDatabaseWriter.DATABASE_ID_PREFIX);\r\n    } else if (result.contains(SavePreferences.ENCODING_PREFIX)) {\r\n        return purge(result, SavePreferences.ENCODING_PREFIX);\r\n    } else {\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.bytedeco.javacpp.samples.tensorflow.EigenvalueExample.buildAndRun",
	"Comment": "constructs a graph and a new tensorflow session.runs the graph inside the session multiple times.",
	"Method": "void buildAndRun(Options opts){\r\n    try (GraphDef def = CreateGraphDef()) {\r\n        SessionOptions options = new SessionOptions();\r\n        try (final Session session = new Session(options)) {\r\n            if (options.target() == null)\r\n                SetDefaultDevice(opts.use_gpu ? \"/gpu:0\" : \"/cpu:0\", def);\r\n            checkStatus(session.Create(def));\r\n            Tensor x = new Tensor(DT_FLOAT, new TensorShape(2, 1));\r\n            FloatBuffer x_flat = x.createBuffer();\r\n            x_flat.put(0, (float) Math.random());\r\n            x_flat.put(1, (float) Math.random());\r\n            float inv_norm = 1 / (float) Math.sqrt(x_flat.get(0) * x_flat.get(0) + x_flat.get(1) * x_flat.get(1));\r\n            x_flat.put(0, x_flat.get(0) * inv_norm);\r\n            x_flat.put(1, x_flat.get(1) * inv_norm);\r\n            for (int iter = 0; iter < opts.num_iterations; iter++) {\r\n                StringTensorPairVector input_feed = new StringTensorPairVector(new String[] { \"x\" }, new Tensor[] { x });\r\n                StringVector output_tensor_name = new StringVector(\"y:0\", \"y_normalized:0\");\r\n                StringVector target_tensor_name = new StringVector();\r\n                TensorVector outputs = new TensorVector();\r\n                checkStatus(session.Run(input_feed, output_tensor_name, target_tensor_name, outputs));\r\n                assert outputs.size() == 2;\r\n                Tensor y = outputs.get(0);\r\n                Tensor y_norm = outputs.get(1);\r\n                System.out.println(DebugString(x, y));\r\n                x.put(y_norm);\r\n            }\r\n            checkStatus(session.Close());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.CollectionUtils.contains",
	"Comment": "check whether the given enumeration contains the given element.",
	"Method": "boolean contains(Iterator<?> iterator,Object element,boolean contains,Enumeration<?> enumeration,Object element){\r\n    if (enumeration != null) {\r\n        while (enumeration.hasMoreElements()) {\r\n            Object candidate = enumeration.nextElement();\r\n            if (ObjectUtils.nullSafeEquals(candidate, element)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jabref.model.database.BibDatabase.hasStringLabel",
	"Comment": "returns true if a string with the given label already exists.",
	"Method": "boolean hasStringLabel(String label){\r\n    for (BibtexString value : bibtexStrings.values()) {\r\n        if (value.getName().equals(label)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.TableOptions.maxIndexInterval",
	"Comment": "define the maximum index interval for cassandra 2.1.if no call is made to this method, the default value set by cassandra is 2048.",
	"Method": "T maxIndexInterval(Integer maxIndexInterval){\r\n    this.maxIndexInterval = Optional.fromNullable(maxIndexInterval);\r\n    return self;\r\n}"
}, {
	"Path": "com.datastax.driver.core.CCMBridge.createTempStore",
	"Comment": "extracts a keystore from the classpath into a temporary file.this is needed as the keystore could be part of a built test jar used by other projects, andthey need to be extracted to a file system so cassandra may use them.",
	"Method": "File createTempStore(String storePath){\r\n    File f = null;\r\n    Closer closer = Closer.create();\r\n    try {\r\n        InputStream trustStoreIs = CCMBridge.class.getResourceAsStream(storePath);\r\n        closer.register(trustStoreIs);\r\n        f = File.createTempFile(\"server\", \".store\");\r\n        logger.debug(\"Created store file {} for {}.\", f, storePath);\r\n        OutputStream trustStoreOs = new FileOutputStream(f);\r\n        closer.register(trustStoreOs);\r\n        ByteStreams.copy(trustStoreIs, trustStoreOs);\r\n    } catch (IOException e) {\r\n        logger.warn(\"Failure to write keystore, SSL-enabled servers may fail to start.\", e);\r\n    } finally {\r\n        try {\r\n            closer.close();\r\n        } catch (IOException e) {\r\n            logger.warn(\"Failure closing streams.\", e);\r\n        }\r\n    }\r\n    return f;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.SqlStatement.bindBean",
	"Comment": "binds named parameters from javabean properties on the argument.",
	"Method": "This bindBean(Object bean,This bindBean,String prefix,Object bean){\r\n    return bindNamedArgumentFinder(new BeanPropertyArguments(prefix, bean));\r\n}"
}, {
	"Path": "org.jabref.model.entry.BibtexSingleField.getProperties",
	"Comment": "properties contains mappings to tell the entryeditor to add a specific function to this field,for instance a dropdown for selecting the month for the month field.",
	"Method": "Set<FieldProperty> getProperties(){\r\n    return properties;\r\n}"
}, {
	"Path": "com.datastax.driver.core.policies.ErrorAwarePolicy.builder",
	"Comment": "creates a new error aware policy builder given the child policy that the resulting policyshould wrap.",
	"Method": "Builder builder(LoadBalancingPolicy childPolicy){\r\n    return new Builder(childPolicy);\r\n}"
}, {
	"Path": "org.jabref.gui.BasePanel.copyCitationToClipboard",
	"Comment": "generates and copies citations based on the selected entries to the clipboard",
	"Method": "void copyCitationToClipboard(CitationStyleOutputFormat outputFormat){\r\n    new CitationStyleToClipboardWorker(this, outputFormat).execute();\r\n}"
}, {
	"Path": "org.jabref.logic.xmp.DublinCoreExtractor.extractBibTexFields",
	"Comment": "this method sets all fields, which are custom in bibtext and therefore supported by jabref, but which are not included in the dublincore format.the relation attribute of dublincore is abused to insert these custom fields.",
	"Method": "void extractBibTexFields(){\r\n    List<String> relationships = dcSchema.getRelations();\r\n    Predicate<String> isBibTeXElement = s -> s.startsWith(\"bibtex/\");\r\n    Consumer<String> splitBibTeXElement = s -> {\r\n        String temp = s.substring(\"bibtex/\".length());\r\n        int i = temp.indexOf('/');\r\n        if (i != -1) {\r\n            String key = temp.substring(0, i);\r\n            String value = temp.substring(i + 1);\r\n            bibEntry.setField(key, value);\r\n            if (\"month\".equals(key)) {\r\n                Optional<Month> parsedMonth = Month.parse(value);\r\n                if (parsedMonth.isPresent()) {\r\n                    bibEntry.setField(key, parsedMonth.get().getShortName());\r\n                }\r\n            }\r\n        }\r\n    };\r\n    if (relationships != null) {\r\n        relationships.stream().filter(isBibTeXElement).forEach(splitBibTeXElement);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.externalfiles.LinkedFileHandler.findExistingFile",
	"Comment": "check to see if a file already exists in the target directory.search is not case sensitive.",
	"Method": "Optional<Path> findExistingFile(LinkedFile flEntry,BibEntry entry){\r\n    String targetFileName = getSuggestedFileName();\r\n    Path targetFilePath = flEntry.findIn(databaseContext, filePreferences).get().getParent().resolve(targetFileName);\r\n    Path oldFilePath = flEntry.findIn(databaseContext, filePreferences).get();\r\n    Optional<Path> matchedByDiffCase = Optional.empty();\r\n    try (Stream<Path> stream = Files.list(oldFilePath.getParent())) {\r\n        matchedByDiffCase = stream.filter(name -> name.toString().equalsIgnoreCase(targetFilePath.toString())).findFirst();\r\n    } catch (IOException e) {\r\n        LOGGER.error(\"Could not get the list of files in target directory\", e);\r\n    }\r\n    return matchedByDiffCase;\r\n}"
}, {
	"Path": "com.datastax.driver.core.AbstractReplicationStrategyTest.asMock",
	"Comment": "convenience method to cast a host object into a mockhost. returns null if parameter host is nota mock",
	"Method": "HostMock asMock(Host host){\r\n    return (host instanceof HostMock ? (HostMock) host : null);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.java.CtClassJavaProxyGenerator.generateStaticInitializer",
	"Comment": "generate the static initializer method for the proxy class.",
	"Method": "MethodInfo generateStaticInitializer(){\r\n    MethodInfo minfo = new MethodInfo(initMethodName, \"()V\", ACC_STATIC);\r\n    int localSlot0 = 1;\r\n    short pc, tryBegin = 0, tryEnd;\r\n    DataOutputStream out = new DataOutputStream(minfo.code);\r\n    for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\r\n        for (ProxyMethod pm : sigmethods) {\r\n            pm.codeFieldInitialization(out);\r\n        }\r\n    }\r\n    out.writeByte(opc_iconst_1);\r\n    out.writeByte(opc_putstatic);\r\n    out.writeShort(cp.getFieldRef(dotToSlash(className), initFieldName, \"Z\"));\r\n    out.writeByte(opc_return);\r\n    tryEnd = pc = (short) minfo.code.size();\r\n    minfo.exceptionTable.add(new ExceptionTableEntry(tryBegin, tryEnd, pc, cp.getClass(\"java/lang/NoSuchMethodException\")));\r\n    code_astore(localSlot0, out);\r\n    out.writeByte(opc_new);\r\n    out.writeShort(cp.getClass(\"java/lang/NoSuchMethodError\"));\r\n    out.writeByte(opc_dup);\r\n    code_aload(localSlot0, out);\r\n    out.writeByte(opc_invokevirtual);\r\n    out.writeShort(cp.getMethodRef(\"java/lang/Throwable\", \"getMessage\", \"()Ljava/lang/String;\"));\r\n    out.writeByte(opc_invokespecial);\r\n    out.writeShort(cp.getMethodRef(\"java/lang/NoSuchMethodError\", \"<init>\", \"(Ljava/lang/String;)V\"));\r\n    out.writeByte(opc_athrow);\r\n    pc = (short) minfo.code.size();\r\n    minfo.exceptionTable.add(new ExceptionTableEntry(tryBegin, tryEnd, pc, cp.getClass(\"java/lang/ClassNotFoundException\")));\r\n    code_astore(localSlot0, out);\r\n    out.writeByte(opc_new);\r\n    out.writeShort(cp.getClass(\"java/lang/NoClassDefFoundError\"));\r\n    out.writeByte(opc_dup);\r\n    code_aload(localSlot0, out);\r\n    out.writeByte(opc_invokevirtual);\r\n    out.writeShort(cp.getMethodRef(\"java/lang/Throwable\", \"getMessage\", \"()Ljava/lang/String;\"));\r\n    out.writeByte(opc_invokespecial);\r\n    out.writeShort(cp.getMethodRef(\"java/lang/NoClassDefFoundError\", \"<init>\", \"(Ljava/lang/String;)V\"));\r\n    out.writeByte(opc_athrow);\r\n    if (minfo.code.size() > 65535) {\r\n        throw new IllegalArgumentException(\"code size limit exceeded\");\r\n    }\r\n    minfo.maxStack = 10;\r\n    minfo.maxLocals = (short) (localSlot0 + 1);\r\n    minfo.declaredExceptions = new short[0];\r\n    return minfo;\r\n}"
}, {
	"Path": "org.jabref.logic.shared.DBMSProcessorTest.insertMetaData",
	"Comment": "therefore this function was defined to improve the readability and to keep the code short.",
	"Method": "void insertMetaData(String key,String value,DBMSConnection dbmsConnection,DBMSProcessor dbmsProcessor){\r\n    try {\r\n        dbmsConnection.getConnection().createStatement().executeUpdate(\"INSERT INTO \" + escape(\"METADATA\", dbmsProcessor) + \"(\" + escape(\"KEY\", dbmsProcessor) + \", \" + escape(\"VALUE\", dbmsProcessor) + \") VALUES(\" + escapeValue(key) + \", \" + escapeValue(value) + \")\");\r\n    } catch (SQLException e) {\r\n        fail(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolTest.should_not_create_connections_if_zero_core_connections_and_reused_connection_on_reconnect",
	"Comment": "ensures that on a a host is bring up with a reused connection and zero core connections thedriver do not try to create any connections.",
	"Method": "void should_not_create_connections_if_zero_core_connections_and_reused_connection_on_reconnect(){\r\n    int reconnectInterval = 1000;\r\n    Cluster cluster = this.createClusterBuilder().withReconnectionPolicy(new ConstantReconnectionPolicy(1000)).build();\r\n    Host.StateListener stateListener = mock(Host.StateListener.class);\r\n    try {\r\n        cluster.init();\r\n        assertThat(cluster).hasOpenControlConnection();\r\n        Connection.Factory factory = spy(cluster.manager.connectionFactory);\r\n        cluster.manager.connectionFactory = factory;\r\n        HostConnectionPool pool = createPool(cluster, 0, 2);\r\n        cluster.register(stateListener);\r\n        cluster.manager.triggerOnDown(pool.host, true);\r\n        Thread.sleep(reconnectInterval * 3);\r\n        verify(stateListener, times(1)).onUp(pool.host);\r\n        assertThat(pool.connections).hasSize(0);\r\n        assertThat(cluster).host(1).hasState(Host.State.UP);\r\n        assertThat(cluster).hasOpenControlConnection();\r\n    } finally {\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.model.groups.GroupTreeNode.getMatchingGroups",
	"Comment": "determines all groups in the subtree starting at this node which contain at least one of the given entries.",
	"Method": "List<GroupTreeNode> getMatchingGroups(BibEntry entry,List<GroupTreeNode> getMatchingGroups,List<BibEntry> entries){\r\n    List<GroupTreeNode> groups = new ArrayList();\r\n    SearchMatcher matcher = getSearchMatcher();\r\n    for (BibEntry entry : entries) {\r\n        if (matcher.isMatch(entry)) {\r\n            groups.add(this);\r\n            break;\r\n        }\r\n    }\r\n    for (GroupTreeNode child : getChildren()) {\r\n        groups.addAll(child.getMatchingGroups(entries));\r\n    }\r\n    return groups;\r\n}"
}, {
	"Path": "org.jabref.gui.util.ThemeLoader.installCss",
	"Comment": "installs the base css file as a stylesheet in the given scene. changes in the css file lead to a redraw of thescene using the new css file.",
	"Method": "void installCss(Scene scene,JabRefPreferences preferences){\r\n    addAndWatchForChanges(scene, JabRefFrame.class.getResource(MAIN_CSS), 0);\r\n    additionalCssToLoad.ifPresent(file -> addAndWatchForChanges(scene, file, 1));\r\n    preferences.getFontSize().ifPresent(size -> scene.getRoot().setStyle(\"-fx-font-size: \" + size + \"pt;\"));\r\n}"
}, {
	"Path": "org.jabref.model.entry.BibEntry.getFieldNames",
	"Comment": "returns an set containing the names of all fields that areset for this particular entry.",
	"Method": "Set<String> getFieldNames(){\r\n    return new TreeSet(fields.keySet());\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.spring.getbean.EnhancerProxyCreater.buildProxyCallbackClass",
	"Comment": "creates a cglib callback which is a subclass of detachablebeanholder",
	"Method": "Class<?> buildProxyCallbackClass(String cglibPackage,ClassPool cp){\r\n    String proxyPackage = cglibPackage + \"proxy.\";\r\n    CtClass ct = cp.makeClass(\"HotswapSpringCallback\" + getClassSuffix(cglibPackage));\r\n    ct.setSuperclass(cp.get(DetachableBeanHolder.class.getName()));\r\n    ct.addInterface(cp.get(proxyPackage + \"MethodInterceptor\"));\r\n    String rawBody = \"public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args, {0}MethodProxy proxy) throws Throwable {\" + \"if(method != null && method.getName().equals(\\\"finalize\\\") && method.getParameterTypes().length == 0) {\" + \"return null;\" + \"}\" + \"if(method != null && method.getName().equals(\\\"$$ha$getTarget\\\")) {\" + \"return getTarget();\" + \"}\" + \"if(method != null && method.getName().equals(\\\"$$ha$setTarget\\\")) {\" + \"setTarget(args[0]); return null;\" + \"}\" + \"return proxy.invoke(getBean(), args);\" + \"}\";\r\n    String body = rawBody.replaceAll(\"\\\\{0\\\\}\", proxyPackage);\r\n    CtMethod m = CtNewMethod.make(body, ct);\r\n    ct.addMethod(m);\r\n    return ct.toClass(loader, pd);\r\n}"
}, {
	"Path": "org.elixir_lang.eex.lexer.Flex.yypushback",
	"Comment": "pushes the specified amount of characters back into the input stream.they will be read again by then next call of the scanning method",
	"Method": "void yypushback(int number){\r\n    if (number > yylength())\r\n        zzScanError(ZZ_PUSHBACK_2BIG);\r\n    zzMarkedPos -= number;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ClassUtils.isPrimitiveWrapperArray",
	"Comment": "check if the given class represents an array of primitive wrappers, i.e.boolean, byte, character, short, integer, long, float, or double.",
	"Method": "boolean isPrimitiveWrapperArray(Class<?> clazz){\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));\r\n}"
}, {
	"Path": "org.jabref.logic.autosaveandbackup.BackupManager.checkForBackupFile",
	"Comment": "checks whether a backup file exists for the given database file.",
	"Method": "boolean checkForBackupFile(Path originalPath){\r\n    Path backupPath = getBackupPath(originalPath);\r\n    return Files.exists(backupPath) && !Files.isDirectory(backupPath);\r\n}"
}, {
	"Path": "com.datastax.driver.core.MemoryAppender.waitAndGet",
	"Comment": "wait until at least one log event is appended to the current appender, or a timeout occurs,whichever happens first, then return the appender contents. not thread safe. useful whenasynchronous code needs to wait until the appender is actually invoked at least once.",
	"Method": "String waitAndGet(long timeoutMillis){\r\n    long nanos = MILLISECONDS.toNanos(timeoutMillis);\r\n    appendLock.lock();\r\n    try {\r\n        while (get().isEmpty()) {\r\n            if (nanos <= 0L)\r\n                break;\r\n            nanos = append.awaitNanos(nanos);\r\n        }\r\n        return get();\r\n    } finally {\r\n        appendLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.entryeditor.RelatedArticlesTab.getPrivacyDialog",
	"Comment": "returns a consent dialog used to ask permission to send data to mr. dlib.",
	"Method": "ScrollPane getPrivacyDialog(BibEntry entry){\r\n    ScrollPane root = new ScrollPane();\r\n    root.getStyleClass().add(\"related-articles-tab\");\r\n    VBox vbox = new VBox();\r\n    vbox.getStyleClass().add(\"gdpr-dialog\");\r\n    vbox.setSpacing(20.0);\r\n    Button button = new Button(Localization.lang(\"I Agree\"));\r\n    button.setDefaultButton(true);\r\n    Text line1 = new Text(Localization.lang(\"Mr. DLib is an external service which provides article recommendations based on the currently selected entry. Data about the selected entry must be sent to Mr. DLib in order to provide these recommendations. Do you agree that this data may be sent?\"));\r\n    line1.setWrappingWidth(1300.0);\r\n    Text line2 = new Text(Localization.lang(\"This setting may be changed in preferences at any time.\"));\r\n    Hyperlink mdlLink = new Hyperlink(Localization.lang(\"Further information about Mr DLib. for JabRef users.\"));\r\n    mdlLink.setOnAction(event -> {\r\n        try {\r\n            JabRefDesktop.openBrowser(\"http://mr-dlib.org/information-for-users/information-about-mr-dlib-for-jabref-users/\");\r\n        } catch (IOException e) {\r\n            LOGGER.error(\"Error opening the browser to Mr. DLib information page.\", e);\r\n            dialogService.showErrorDialogAndWait(e);\r\n        }\r\n    });\r\n    button.setOnAction(event -> {\r\n        JabRefPreferences prefs = JabRefPreferences.getInstance();\r\n        prefs.putBoolean(JabRefPreferences.ACCEPT_RECOMMENDATIONS, true);\r\n        dialogService.showWarningDialogAndWait(Localization.lang(\"Restart\"), Localization.lang(\"Please restart JabRef for preferences to take effect.\"));\r\n        setContent(getRelatedArticlesPane(entry));\r\n    });\r\n    vbox.getChildren().addAll(line1, mdlLink, line2, button);\r\n    root.setContent(vbox);\r\n    return root;\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiles.DownloadExternalFile.downloadFinished",
	"Comment": "this is called by the download thread when download is completed.",
	"Method": "void downloadFinished(){\r\n    downloadFinished = true;\r\n    editor.getProgressBar().setVisible(false);\r\n    editor.getProgressBarLabel().setVisible(false);\r\n    editor.setOkEnabled(true);\r\n    editor.getProgressBar().setValue(editor.getProgressBar().getMaximum());\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.SchemaBuilder.rows",
	"Comment": "return the row caching strategy that caches a given number of rows, to use in a create or altertable statement.",
	"Method": "TableOptions.CachingRowsPerPartition rows(int rowNumber){\r\n    if (rowNumber <= 0) {\r\n        throw new IllegalArgumentException(\"rows number for caching should be strictly positive\");\r\n    }\r\n    return new TableOptions.CachingRowsPerPartition(Integer.toString(rowNumber));\r\n}"
}, {
	"Path": "org.jdbi.v3.core.Handle.select",
	"Comment": "convenience method which creates a query with the given positional arguments",
	"Method": "Query select(String sql,Object args){\r\n    Query query = this.createQuery(sql);\r\n    int position = 0;\r\n    for (Object arg : args) {\r\n        query.bind(position++, arg);\r\n    }\r\n    return query;\r\n}"
}, {
	"Path": "com.datastax.driver.mapping.MapperAccessorParamsTest.should_fail_if_wrong_parameter_type",
	"Comment": "ensures that a wrong parameter type is detected when the accessor is called with a wrong datatype.",
	"Method": "void should_fail_if_wrong_parameter_type(){\r\n    UserPhoneAccessor_WrongParameterTypes accessor = new MappingManager(session()).createAccessor(UserPhoneAccessor_WrongParameterTypes.class);\r\n    accessor.findUsersBykeys(Lists.newArrayList(1, 2, 3));\r\n}"
}, {
	"Path": "org.jdbi.v3.core.result.ResultIterable.useStream",
	"Comment": "passes the stream of results to the consumer. database resources owned by the query arereleased before this method returns.",
	"Method": "void useStream(StreamConsumer<T, X> consumer){\r\n    withStream(stream -> {\r\n        consumer.useStream(stream);\r\n        return null;\r\n    });\r\n}"
}, {
	"Path": "org.jabref.gui.importer.ImportInspectionDialog.showErrorMessage",
	"Comment": "displays a dialog which tells the user that an error occurred while fetching entries",
	"Method": "void showErrorMessage(String fetcherTitle,String localizedException){\r\n    showMessage(Localization.lang(\"Error while fetching from %0\", fetcherTitle) + \"\\n\" + Localization.lang(\"Please try again later and/or check your network connection.\") + \"\\n\" + localizedException, Localization.lang(\"Search %0\", fetcherTitle), JOptionPane.ERROR_MESSAGE);\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fileformat.MrDLibImporter.getResponseErrorMessage",
	"Comment": "gets the error message to be returned if there has been an error in returning recommendations.returns default error message if there is no message from mr. dlib.",
	"Method": "String getResponseErrorMessage(String response){\r\n    try {\r\n        JSONObject jsonObject = new JSONObject(response);\r\n        if (!jsonObject.has(\"message\")) {\r\n            return jsonObject.getString(\"message\");\r\n        }\r\n    } catch (JSONException ex) {\r\n        return DEFAULT_MRDLIB_ERROR_MESSAGE;\r\n    }\r\n    return DEFAULT_MRDLIB_ERROR_MESSAGE;\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiletype.ExternalFileTypeEditor.setValues",
	"Comment": "update the editor to show the current settings in preferences.",
	"Method": "void setValues(){\r\n    fileTypes.clear();\r\n    Collection<ExternalFileType> types = ExternalFileTypes.getInstance().getExternalFileTypeSelection();\r\n    fileTypes.addAll(types);\r\n    fileTypes.sort(Comparator.comparing(ExternalFileType::getName));\r\n}"
}, {
	"Path": "org.jabref.model.TreeNode.getLevel",
	"Comment": "gets the number of levels above this node, i.e. the distance from the root to this node.if this node is the root, returns 0.",
	"Method": "int getLevel(){\r\n    if (parent == null) {\r\n        return 0;\r\n    }\r\n    return parent.getLevel() + 1;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.jersey2.Jersey2Plugin.getContainerClasses",
	"Comment": "gets a list of classes used in configure the jersey application",
	"Method": "Set<Class<?>> getContainerClasses(Class<?> resourceConfigClass,Object resourceConfig){\r\n    Method scanClassesMethod = resourceConfigClass.getDeclaredMethod(\"scanClasses\");\r\n    scanClassesMethod.setAccessible(true);\r\n    @SuppressWarnings(\"unchecked\")\r\n    Set<Class<?>> scannedClasses = (Set<Class<?>>) scanClassesMethod.invoke(resourceConfig);\r\n    Method getRegisteredClassesMethod = resourceConfigClass.getDeclaredMethod(\"getRegisteredClasses\");\r\n    getRegisteredClassesMethod.setAccessible(true);\r\n    @SuppressWarnings(\"unchecked\")\r\n    Set<Class<?>> registeredClasses = (Set<Class<?>>) getRegisteredClassesMethod.invoke(resourceConfig);\r\n    Set<Class<?>> containerClasses = Collections.newSetFromMap(new WeakHashMap<Class<?>, Boolean>());\r\n    containerClasses.addAll(scannedClasses);\r\n    containerClasses.addAll(registeredClasses);\r\n    return containerClasses;\r\n}"
}, {
	"Path": "org.menacheri.jetserver.convert.flex.AMFSerializer.toAmf",
	"Comment": "method used to convert the java object to amf3 format. this method in\tturn delegates this conversion to the blazeds class amf3 output.",
	"Method": "ByteArrayOutputStream toAmf(T source){\r\n    final ByteArrayOutputStream bout = new ByteArrayOutputStream();\r\n    final Amf3Output amf3Output = new Amf3Output(context);\r\n    amf3Output.setOutputStream(bout);\r\n    amf3Output.writeObject(source);\r\n    amf3Output.flush();\r\n    amf3Output.close();\r\n    return bout;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.InputStreamResource.hashCode",
	"Comment": "this implementation returns the hash code of the underlying inputstream.",
	"Method": "int hashCode(){\r\n    return this.inputStream.hashCode();\r\n}"
}, {
	"Path": "org.jabref.gui.search.SearchResultFrame.setupComparatorChooser",
	"Comment": "set up the comparators for each column, so the user can modify sort orderby clicking the column labels.",
	"Method": "void setupComparatorChooser(TableComparatorChooser<BibEntry> comparatorChooser){\r\n    List<Comparator> comparators;\r\n    for (int i = 0; i < PAD; i++) {\r\n        comparators = comparatorChooser.getComparatorsForColumn(i);\r\n        comparators.clear();\r\n        if (i == FILE_COL) {\r\n            comparators.add(new IconComparator(Collections.singletonList(FieldName.FILE)));\r\n        } else if (i == URL_COL) {\r\n            comparators.add(new IconComparator(Collections.singletonList(FieldName.URL)));\r\n        } else if (i == DATABASE_COL) {\r\n            comparators.add((entry1, entry2) -> {\r\n                String databaseTitle1 = entryHome.get(entry1).getTabTitle();\r\n                String databaseTitle2 = entryHome.get(entry2).getTabTitle();\r\n                return databaseTitle1.compareTo(databaseTitle2);\r\n            });\r\n        }\r\n    }\r\n    for (int i = PAD; i < (PAD + FIELDS.length); i++) {\r\n        comparators = comparatorChooser.getComparatorsForColumn(i);\r\n        comparators.clear();\r\n        comparators.add(new FieldComparator(FIELDS[i - PAD]));\r\n    }\r\n    sortedEntries.getReadWriteLock().writeLock().lock();\r\n    comparatorChooser.appendComparator(PAD, 0, false);\r\n    sortedEntries.getReadWriteLock().writeLock().unlock();\r\n}"
}, {
	"Path": "org.jabref.logic.util.UpdateField.updateField",
	"Comment": "updating a field will result in the entry being reformatted on save",
	"Method": "Optional<FieldChange> updateField(BibEntry be,String field,String newValue,Optional<FieldChange> updateField,BibEntry be,String field,String newValue,Boolean nullFieldIfValueIsTheSame){\r\n    String writtenValue = null;\r\n    String oldValue = null;\r\n    if (be.hasField(field)) {\r\n        oldValue = be.getField(field).get();\r\n        if ((newValue == null) || (oldValue.equals(newValue) && nullFieldIfValueIsTheSame)) {\r\n            be.clearField(field);\r\n        } else if (!oldValue.equals(newValue)) {\r\n            writtenValue = newValue;\r\n            be.setField(field, newValue);\r\n        } else {\r\n            return Optional.empty();\r\n        }\r\n    } else {\r\n        if (newValue == null) {\r\n            return Optional.empty();\r\n        } else {\r\n            writtenValue = newValue;\r\n            be.setField(field, newValue);\r\n        }\r\n    }\r\n    return Optional.of(new FieldChange(be, field, oldValue, writtenValue));\r\n}"
}, {
	"Path": "org.menacheri.jetclient.util.NettyUtils.readSocketAddress",
	"Comment": "read a socket address from a buffer. the socket address will be provided\tas two strings containing host and port.",
	"Method": "InetSocketAddress readSocketAddress(ChannelBuffer buffer){\r\n    String remoteHost = NettyUtils.readString(buffer);\r\n    int remotePort = 0;\r\n    if (buffer.readableBytes() >= 4) {\r\n        remotePort = buffer.readInt();\r\n    } else {\r\n        return null;\r\n    }\r\n    InetSocketAddress remoteAddress = null;\r\n    if (null != remoteHost) {\r\n        remoteAddress = new InetSocketAddress(remoteHost, remotePort);\r\n    }\r\n    return remoteAddress;\r\n}"
}, {
	"Path": "com.datastax.driver.core.ProtocolBetaVersionTest.should_not_initialize_when_version_explicitly_required_and_beta_flag_is_set",
	"Comment": "verifies that the cluster builder fails when version is explicitly set and user attempts to setbeta flag.",
	"Method": "void should_not_initialize_when_version_explicitly_required_and_beta_flag_is_set(){\r\n    try {\r\n        Cluster.builder().addContactPoints(getContactPoints()).withPort(ccm().getBinaryPort()).withProtocolVersion(V4).allowBetaProtocolVersion().build();\r\n        fail(\"Expected IllegalArgumentException\");\r\n    } catch (IllegalArgumentException e) {\r\n        assertThat(e.getMessage()).isEqualTo(\"Can't use beta flag with initial protocol version of V4\");\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.IndexMetadata.getOptionsAsCql",
	"Comment": "builds a string representation of the custom index options.",
	"Method": "String getOptionsAsCql(){\r\n    Iterable<Map.Entry<String, String>> filtered = Iterables.filter(options.entrySet(), new Predicate<Map.Entry<String, String>>() {\r\n        @Override\r\n        public boolean apply(Map.Entry<String, String> input) {\r\n            return !input.getKey().equals(TARGET_OPTION_NAME) && !input.getKey().equals(CUSTOM_INDEX_OPTION_NAME);\r\n        }\r\n    });\r\n    if (Iterables.isEmpty(filtered))\r\n        return \"\";\r\n    StringBuilder builder = new StringBuilder();\r\n    builder.append(\"WITH OPTIONS = {\");\r\n    Iterator<Map.Entry<String, String>> it = filtered.iterator();\r\n    while (it.hasNext()) {\r\n        Map.Entry<String, String> option = it.next();\r\n        builder.append(String.format(\"'%s' : '%s'\", option.getKey(), option.getValue()));\r\n        if (it.hasNext())\r\n            builder.append(\", \");\r\n    }\r\n    builder.append(\"}\");\r\n    return builder.toString();\r\n}"
}, {
	"Path": "com.datastax.driver.core.IndexMetadata.getOptionsAsCql",
	"Comment": "builds a string representation of the custom index options.",
	"Method": "String getOptionsAsCql(){\r\n    return !input.getKey().equals(TARGET_OPTION_NAME) && !input.getKey().equals(CUSTOM_INDEX_OPTION_NAME);\r\n}"
}, {
	"Path": "com.datastax.driver.core.HeartbeatTest.triggerRequestOnControlConnection",
	"Comment": "simulates activity on the control connection via the internal api",
	"Method": "void triggerRequestOnControlConnection(Cluster cluster){\r\n    cluster.manager.controlConnection.refreshNodeInfo(TestUtils.findHost(cluster, 1));\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.jvm.AnonymousClassInfos.isCurrent",
	"Comment": "return true, if last modification timestamp is same as current timestamp of classname.",
	"Method": "boolean isCurrent(ClassPool classPool){\r\n    return lastModifiedTimestamp >= lastModified(classPool, className) - ALLOWED_MODIFICATION_DELTA;\r\n}"
}, {
	"Path": "org.jabref.logic.importer.Importer.isRecognizedFormat",
	"Comment": "check whether the source is in the correct format for this importer.",
	"Method": "boolean isRecognizedFormat(BufferedReader input,boolean isRecognizedFormat,Path filePath,Charset encoding,boolean isRecognizedFormat,String data){\r\n    try (StringReader stringReader = new StringReader(data);\r\n        BufferedReader bufferedReader = new BufferedReader(stringReader)) {\r\n        return isRecognizedFormat(bufferedReader);\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.QueryOptions.getMaxPendingRefreshNodeRequests",
	"Comment": "the maximum number of node refresh requests that the control connection can accumulate beforeexecuting them.",
	"Method": "int getMaxPendingRefreshNodeRequests(){\r\n    return maxPendingRefreshNodeRequests;\r\n}"
}, {
	"Path": "org.jabref.gui.BasePanel.insertEntry",
	"Comment": "this method is called from jabrefframe when the user wants to create a new entry.",
	"Method": "void insertEntry(BibEntry bibEntry){\r\n    if (bibEntry != null) {\r\n        try {\r\n            bibDatabaseContext.getDatabase().insertEntry(bibEntry);\r\n            UpdateField.setAutomaticFields(bibEntry, true, true, Globals.prefs.getUpdateFieldPreferences());\r\n            getUndoManager().addEdit(new UndoableInsertEntry(bibDatabaseContext.getDatabase(), bibEntry));\r\n            output(Localization.lang(\"Added new '%0' entry.\", bibEntry.getType()));\r\n            markBaseChanged();\r\n            if (Globals.prefs.getBoolean(JabRefPreferences.AUTO_OPEN_FORM)) {\r\n                showAndEdit(bibEntry);\r\n            }\r\n            clearAndSelect(bibEntry);\r\n        } catch (KeyCollisionException ex) {\r\n            LOGGER.info(\"Collision for bibtex key\" + bibEntry.getId(), ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.test.WaitHelper.waitForResult",
	"Comment": "wait for result set to true by another thread in resultholder.",
	"Method": "boolean waitForResult(WaitHelper.ResultHolder resultHolder,boolean waitForResult,WaitHelper.ResultHolder resultHolder,int timeout){\r\n    for (int i = 0; i < timeout / 10; i++) {\r\n        if (resultHolder.result)\r\n            return true;\r\n        try {\r\n            Thread.sleep(10);\r\n        } catch (InterruptedException e) {\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.Jdbi.open",
	"Comment": "convenience method used to obtain a handle from a specific data source",
	"Method": "Handle open(DataSource dataSource,Handle open,ConnectionFactory connectionFactory,Handle open,Connection connection,Handle open,String url,Handle open,String url,String username,String password,Handle open,String url,Properties props,Handle open){\r\n    try {\r\n        final long start = System.nanoTime();\r\n        @SuppressWarnings(\"PMD.CloseResource\")\r\n        Connection conn = connectionFactory.openConnection();\r\n        final long stop = System.nanoTime();\r\n        for (JdbiPlugin p : plugins) {\r\n            conn = p.customizeConnection(conn);\r\n        }\r\n        StatementBuilder cache = statementBuilderFactory.get().createStatementBuilder(conn);\r\n        Handle h = new Handle(config.createCopy(), connectionFactory::closeConnection, transactionhandler.get(), cache, conn);\r\n        for (JdbiPlugin p : plugins) {\r\n            h = p.customizeHandle(h);\r\n        }\r\n        LOG.trace(\"Jdbi [{}] obtain handle [{}] in {}ms\", this, h, (stop - start) / 1000000L);\r\n        return h;\r\n    } catch (SQLException e) {\r\n        throw new ConnectionException(e);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiles.DroppedFileHandler.doCopy",
	"Comment": "copy the given file to the base directory for its file type, and give itthe given name.",
	"Method": "boolean doCopy(String fileName,String toFile,NamedCompound edits){\r\n    List<String> dirs = panel.getBibDatabaseContext().getFileDirectories(Globals.prefs.getFilePreferences());\r\n    int found = -1;\r\n    for (int i = 0; i < dirs.size(); i++) {\r\n        if (new File(dirs.get(i)).exists()) {\r\n            found = i;\r\n            break;\r\n        }\r\n    }\r\n    if (found < 0) {\r\n        LOGGER.warn(\"Cannot determine destination directory or destination directory does not exist\");\r\n        return false;\r\n    }\r\n    Path destFile = Paths.get(dirs.get(found)).resolve(toFile);\r\n    if (destFile.toString().equals(fileName)) {\r\n        return true;\r\n    }\r\n    if (Files.exists(destFile)) {\r\n        int answer = JOptionPane.showConfirmDialog(null, Localization.lang(\"'%0' exists. Overwrite file?\", destFile.toString()), Localization.lang(\"File exists\"), JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);\r\n        if (answer == JOptionPane.NO_OPTION) {\r\n            return false;\r\n        }\r\n    }\r\n    try {\r\n        if (!Files.exists(destFile)) {\r\n            Files.createDirectories(destFile);\r\n        }\r\n        FileUtil.copyFile(Paths.get(fileName), destFile, true);\r\n    } catch (IOException e) {\r\n        LOGGER.error(\"Problem copying file\", e);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.datastax.driver.core.CustomPayloadTest.should_not_set_any_payload_on_bound_statement",
	"Comment": "ensures that payloads can still be set individually on bound statements if the preparedstatement does not have a default payload.",
	"Method": "void should_not_set_any_payload_on_bound_statement(){\r\n    RegularStatement statement = new SimpleStatement(\"SELECT c2 as col3 FROM t1 where c1 = ?\");\r\n    PreparedStatement ps = session().prepare(statement);\r\n    assertThat(ps.getOutgoingPayload()).isNull();\r\n    assertThat(ps.getIncomingPayload()).isNull();\r\n    BoundStatement bs = ps.bind(1);\r\n    assertThat(bs.getOutgoingPayload()).isNull();\r\n    bs.setOutgoingPayload(payload1);\r\n    ResultSet rows = session().execute(bs);\r\n    Map<String, ByteBuffer> actual = rows.getExecutionInfo().getIncomingPayload();\r\n    assertThat(actual).isEqualTo(payload1);\r\n    bs = ps.bind();\r\n    assertThat(bs.getOutgoingPayload()).isNull();\r\n    bs.setInt(0, 1);\r\n    rows = session().execute(bs);\r\n    actual = rows.getExecutionInfo().getIncomingPayload();\r\n    assertThat(actual).isNull();\r\n}"
}, {
	"Path": "org.jabref.gui.PreviewPanel.setFixedLayout",
	"Comment": "this fixes the layout, the user cannot change it anymore. useful for testing the styles in the settings",
	"Method": "void setFixedLayout(String layout){\r\n    this.fixedLayout = true;\r\n    updatePreviewLayout(layout, Globals.prefs.getLayoutFormatterPreferences(Globals.journalAbbreviationLoader));\r\n}"
}, {
	"Path": "org.jabref.gui.SidePaneManager.toggle",
	"Comment": "if the given component is visible it will be hidden and the other way around.",
	"Method": "void toggle(SidePaneType type){\r\n    if (isComponentVisible(type)) {\r\n        hide(type);\r\n    } else {\r\n        show(type);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ClassUtils.createCompositeInterface",
	"Comment": "create a composite interface class for the given interfaces, implementingthe given interfaces in one single class.this implementation builds a jdk proxy class for the given interfaces.",
	"Method": "Class<?> createCompositeInterface(Class<?>[] interfaces,ClassLoader classLoader){\r\n    Assert.notEmpty(interfaces, \"Interfaces must not be empty\");\r\n    Assert.notNull(classLoader, \"ClassLoader must not be null\");\r\n    return Proxy.getProxyClass(classLoader, interfaces);\r\n}"
}, {
	"Path": "com.datastax.driver.core.LargeDataTest.mixedDurationTest",
	"Comment": "tests 10 random tests consisting of the other methods in this class",
	"Method": "void mixedDurationTest(){\r\n    session().execute(String.format(CREATE_KEYSPACE_SIMPLE_FORMAT, \"large_data\", 3));\r\n    session().execute(\"USE large_data\");\r\n    session().execute(String.format(\"CREATE TABLE %s (k INT, i INT, PRIMARY KEY(k, i))\", \"wide_rows\"));\r\n    session().execute(String.format(\"CREATE TABLE %s (k INT, i INT, PRIMARY KEY(k, i))\", \"wide_batch_rows\"));\r\n    session().execute(String.format(\"CREATE TABLE %s (k INT, i BLOB, PRIMARY KEY(k, i))\", \"wide_byte_rows\"));\r\n    session().execute(String.format(\"CREATE TABLE %s (k int PRIMARY KEY, txt text)\", \"large_text\"));\r\n    StringBuilder tableDeclaration = new StringBuilder();\r\n    tableDeclaration.append(\"CREATE TABLE wide_table (\");\r\n    tableDeclaration.append(\"k INT PRIMARY KEY\");\r\n    for (int i = 0; i < 330; ++i) {\r\n        tableDeclaration.append(String.format(\", %s INT\", createColumnName(i)));\r\n    }\r\n    tableDeclaration.append(')');\r\n    session().execute(tableDeclaration.toString());\r\n    for (int i = 0; i < 10; ++i) {\r\n        switch((int) (Math.random() * 5)) {\r\n            case 0:\r\n                testWideRows(0);\r\n                break;\r\n            case 1:\r\n                testWideBatchRows(0);\r\n                break;\r\n            case 2:\r\n                testByteRows(0);\r\n                break;\r\n            case 3:\r\n                testLargeText(0);\r\n                break;\r\n            case 4:\r\n                testWideTable(0);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.java.CtClassJavaProxyGenerator.generateStaticInitializerCaller",
	"Comment": "generate the static initializer method for the proxy class.",
	"Method": "MethodInfo generateStaticInitializerCaller(){\r\n    MethodInfo minfo = new MethodInfo(\"<clinit>\", \"()V\", ACC_STATIC);\r\n    DataOutputStream out = new DataOutputStream(minfo.code);\r\n    out.writeByte(opc_invokestatic);\r\n    out.writeShort(cp.getMethodRef(dotToSlash(className), initMethodName, \"()V\"));\r\n    out.writeByte(opc_return);\r\n    minfo.declaredExceptions = new short[0];\r\n    return minfo;\r\n}"
}, {
	"Path": "org.elixir_lang.beam.assembly.FlexLexer.yytext",
	"Comment": "returns the text matched by the current regular expression.",
	"Method": "CharSequence yytext(){\r\n    return zzBuffer.subSequence(zzStartRead, zzMarkedPos);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.ClassPathResource.getDescription",
	"Comment": "this implementation returns a description that includes the class pathlocation.",
	"Method": "String getDescription(){\r\n    StringBuilder builder = new StringBuilder(\"class path resource [\");\r\n    String pathToUse = path;\r\n    if (this.clazz != null && !pathToUse.startsWith(\"/\")) {\r\n        builder.append(ClassUtils.classPackageAsResourcePath(this.clazz));\r\n        builder.append('/');\r\n    }\r\n    if (pathToUse.startsWith(\"/\")) {\r\n        pathToUse = pathToUse.substring(1);\r\n    }\r\n    builder.append(pathToUse);\r\n    builder.append(']');\r\n    return builder.toString();\r\n}"
}, {
	"Path": "me.ramswaroop.jbot.core.slack.SlackService.getImChannels",
	"Comment": "fetch all im channels to determine direct message to the bot.",
	"Method": "void getImChannels(String slackToken,int limit,String nextCursor){\r\n    try {\r\n        Event event = restTemplate.getForEntity(slackApiEndpoints.getImListApi(), Event.class, slackToken, limit, nextCursor).getBody();\r\n        imChannelIds.addAll(Arrays.stream(event.getIms()).map(Channel::getId).collect(Collectors.toList()));\r\n        if (event.getResponseMetadata() != null && !StringUtils.isEmpty(event.getResponseMetadata().getNextCursor())) {\r\n            Thread.sleep(5000L);\r\n            getImChannels(slackToken, limit, event.getResponseMetadata().getNextCursor());\r\n        }\r\n    } catch (Exception e) {\r\n        logger.error(\"Error fetching im channels for the bot: \", e);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.model.TreeNode.getRelativeSibling",
	"Comment": "returns the sibling which is shiftindex away from this node.",
	"Method": "Optional<T> getRelativeSibling(int shiftIndex){\r\n    if (parent == null) {\r\n        return Optional.empty();\r\n    } else {\r\n        int indexInParent = getPositionInParent();\r\n        int indexTarget = indexInParent + shiftIndex;\r\n        if (parent.childIndexExists(indexTarget)) {\r\n            return parent.getChildAt(indexTarget);\r\n        } else {\r\n            return Optional.empty();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.ParseUtils.skipCQLValue",
	"Comment": "assuming that idx points to the beginning of a cql value in toparse, returns the index of thefirst character after this value.",
	"Method": "int skipCQLValue(String toParse,int idx){\r\n    if (idx >= toParse.length())\r\n        throw new IllegalArgumentException();\r\n    if (isBlank(toParse.charAt(idx)))\r\n        throw new IllegalArgumentException();\r\n    int cbrackets = 0;\r\n    int sbrackets = 0;\r\n    int parens = 0;\r\n    boolean inString = false;\r\n    do {\r\n        char c = toParse.charAt(idx);\r\n        if (inString) {\r\n            if (c == '\\'') {\r\n                if (idx + 1 < toParse.length() && toParse.charAt(idx + 1) == '\\'') {\r\n                    ++idx;\r\n                } else {\r\n                    inString = false;\r\n                    if (cbrackets == 0 && sbrackets == 0 && parens == 0)\r\n                        return idx + 1;\r\n                }\r\n            }\r\n        } else if (c == '\\'') {\r\n            inString = true;\r\n        } else if (c == '{') {\r\n            ++cbrackets;\r\n        } else if (c == '[') {\r\n            ++sbrackets;\r\n        } else if (c == '(') {\r\n            ++parens;\r\n        } else if (c == '}') {\r\n            if (cbrackets == 0)\r\n                return idx;\r\n            --cbrackets;\r\n            if (cbrackets == 0 && sbrackets == 0 && parens == 0)\r\n                return idx + 1;\r\n        } else if (c == ']') {\r\n            if (sbrackets == 0)\r\n                return idx;\r\n            --sbrackets;\r\n            if (cbrackets == 0 && sbrackets == 0 && parens == 0)\r\n                return idx + 1;\r\n        } else if (c == ')') {\r\n            if (parens == 0)\r\n                return idx;\r\n            --parens;\r\n            if (cbrackets == 0 && sbrackets == 0 && parens == 0)\r\n                return idx + 1;\r\n        } else if (isBlank(c) || !isIdentifierChar(c)) {\r\n            if (cbrackets == 0 && sbrackets == 0 && parens == 0)\r\n                return idx;\r\n        }\r\n    } while (++idx < toParse.length());\r\n    if (inString || cbrackets != 0 || sbrackets != 0 || parens != 0)\r\n        throw new IllegalArgumentException();\r\n    return idx;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ReflectionUtils.handleReflectionException",
	"Comment": "handle the given reflection exception. should only be called if nochecked exception is expected to be thrown by the target method.throws the underlying runtimeexception or error in case of aninvocationtargetexception with such a root cause. throws anillegalstateexception with an appropriate message else.",
	"Method": "void handleReflectionException(Exception ex){\r\n    if (ex instanceof NoSuchMethodException) {\r\n        throw new IllegalStateException(\"Method not found: \" + ex.getMessage());\r\n    }\r\n    if (ex instanceof IllegalAccessException) {\r\n        throw new IllegalStateException(\"Could not access method: \" + ex.getMessage());\r\n    }\r\n    if (ex instanceof InvocationTargetException) {\r\n        handleInvocationTargetException((InvocationTargetException) ex);\r\n    }\r\n    if (ex instanceof RuntimeException) {\r\n        throw (RuntimeException) ex;\r\n    }\r\n    throw new UndeclaredThrowableException(ex);\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.StatementContext.getRawSql",
	"Comment": "obtain the initial sql for the statement used to create the statement",
	"Method": "String getRawSql(){\r\n    return rawSql;\r\n}"
}, {
	"Path": "com.datastax.driver.core.SimpleStatement.setKeyspace",
	"Comment": "sets the keyspace this query operates on.this method allows you to manually provide a keyspace for this query. it is thus optionalsince the value returned by this method is only an hint for token aware load balancing policybut is never mandatory.do note that if the query does not use a fully qualified keyspace, then you do not need toset the keyspace through that method as the currently logged in keyspace will be used.",
	"Method": "SimpleStatement setKeyspace(String keyspace){\r\n    this.keyspace = keyspace;\r\n    return this;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.WeakReferenceMonitor.addEntry",
	"Comment": "add entry to internal map of tracked entries. internal monitoring threadis started if not already running.",
	"Method": "void addEntry(Reference<?> ref,ReleaseListener entry){\r\n    synchronized (WeakReferenceMonitor.class) {\r\n        trackedEntries.put(ref, entry);\r\n        if (monitoringThread == null) {\r\n            monitoringThread = new Thread(new MonitoringProcess(), WeakReferenceMonitor.class.getName());\r\n            monitoringThread.setDaemon(true);\r\n            monitoringThread.start();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.exceptions.NoHostAvailableException.getErrors",
	"Comment": "return the hosts tried along with the error encountered while trying them.",
	"Method": "Map<InetSocketAddress, Throwable> getErrors(){\r\n    return new HashMap<InetSocketAddress, Throwable>(errors);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.spring.scanner.ClassPathBeanRefreshCommand.isDeleteEvent",
	"Comment": "check all merged events for delete and create events. if delete without create is found, than assumefile was deleted.",
	"Method": "boolean isDeleteEvent(){\r\n    List<ClassPathBeanRefreshCommand> mergedCommands = new ArrayList<ClassPathBeanRefreshCommand>();\r\n    for (Command command : getMergedCommands()) {\r\n        mergedCommands.add((ClassPathBeanRefreshCommand) command);\r\n    }\r\n    mergedCommands.add(this);\r\n    boolean createFound = false;\r\n    boolean deleteFound = false;\r\n    for (ClassPathBeanRefreshCommand command : mergedCommands) {\r\n        if (command.event != null) {\r\n            if (command.event.getEventType().equals(FileEvent.DELETE))\r\n                deleteFound = true;\r\n            if (command.event.getEventType().equals(FileEvent.CREATE))\r\n                createFound = true;\r\n        }\r\n    }\r\n    LOGGER.trace(\"isDeleteEvent result {}: createFound={}, deleteFound={}\", createFound, deleteFound);\r\n    return !createFound && deleteFound;\r\n}"
}, {
	"Path": "org.jabref.model.metadata.SaveOrderConfig.getAsStringList",
	"Comment": "outputs the current configuration to be consumed later by the constructor",
	"Method": "List<String> getAsStringList(){\r\n    List<String> res = new ArrayList(7);\r\n    if (saveInOriginalOrder) {\r\n        res.add(ORIGINAL);\r\n    } else {\r\n        res.add(SPECIFIED);\r\n    }\r\n    for (SortCriterion sortCriterion : sortCriteria) {\r\n        res.add(sortCriterion.field);\r\n        res.add(Boolean.toString(sortCriterion.descending));\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "org.jabref.model.entry.BibEntry.clearField",
	"Comment": "remove the mapping for the field name, and notify listeners aboutthe change.",
	"Method": "Optional<FieldChange> clearField(String name,Optional<FieldChange> clearField,String name,EntryEventSource eventSource){\r\n    String fieldName = toLowerCase(name);\r\n    if (BibEntry.ID_FIELD.equals(fieldName)) {\r\n        throw new IllegalArgumentException(\"The field name '\" + name + \"' is reserved\");\r\n    }\r\n    Optional<String> oldValue = getField(fieldName);\r\n    if (!oldValue.isPresent()) {\r\n        return Optional.empty();\r\n    }\r\n    changed = true;\r\n    fields.remove(fieldName);\r\n    invalidateFieldCache(fieldName);\r\n    FieldChange change = new FieldChange(this, fieldName, oldValue.get(), null);\r\n    eventBus.post(new FieldAddedOrRemovedEvent(change, eventSource));\r\n    return Optional.of(change);\r\n}"
}, {
	"Path": "org.jabref.gui.keyboard.KeyBindingViewModel.setNewBinding",
	"Comment": "sets a a new key bind to this objects key binding object ifthe given key event is a valid combination of keys.",
	"Method": "boolean setNewBinding(KeyEvent evt){\r\n    KeyCode code = evt.getCode();\r\n    if (code.isModifierKey() || (code == KeyCode.BACK_SPACE) || (code == KeyCode.SPACE) || (code == KeyCode.TAB) || (code == KeyCode.ENTER) || (code == KeyCode.UNDEFINED)) {\r\n        return false;\r\n    }\r\n    String modifiers = \"\";\r\n    if (evt.isControlDown()) {\r\n        modifiers = \"ctrl+\";\r\n    }\r\n    if (evt.isShiftDown()) {\r\n        modifiers += \"shift+\";\r\n    }\r\n    if (evt.isAltDown()) {\r\n        modifiers += \"alt+\";\r\n    }\r\n    if (modifiers.isEmpty()) {\r\n        if (!(code.isFunctionKey() || (code == KeyCode.ESCAPE) || (code == KeyCode.DELETE))) {\r\n            return false;\r\n        }\r\n    }\r\n    String newShortcut = modifiers + code;\r\n    setBinding(newShortcut);\r\n    return true;\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fetcher.ACS.findFullText",
	"Comment": "tries to find a fulltext url for a given bibtex entry.currently only uses the doi if found.",
	"Method": "Optional<URL> findFullText(BibEntry entry){\r\n    Objects.requireNonNull(entry);\r\n    Optional<URL> pdfLink = Optional.empty();\r\n    Optional<DOI> doi = entry.getField(FieldName.DOI).flatMap(DOI::parse);\r\n    if (doi.isPresent()) {\r\n        String source = String.format(SOURCE, doi.get().getDOI());\r\n        Document html = Jsoup.connect(source).ignoreHttpErrors(true).get();\r\n        Element link = html.select(\".pdf-high-res a\").first();\r\n        if (link != null) {\r\n            LOGGER.info(\"Fulltext PDF found @ ACS.\");\r\n            pdfLink = Optional.of(new URL(source.replaceFirst(\"/abs/\", \"/pdf/\")));\r\n        }\r\n    }\r\n    return pdfLink;\r\n}"
}, {
	"Path": "org.jabref.gui.entryeditor.fileannotationtab.FileAnnotationTabViewModel.copyCurrentAnnotation",
	"Comment": "copies the meta and content information of the pdf annotation to the clipboard",
	"Method": "void copyCurrentAnnotation(){\r\n    if (null == getCurrentAnnotation()) {\r\n        return;\r\n    }\r\n    StringJoiner sj = new StringJoiner(\",\" + OS.NEWLINE);\r\n    sj.add(Localization.lang(\"Author\") + \": \" + getCurrentAnnotation().getAuthor());\r\n    sj.add(Localization.lang(\"Date\") + \": \" + getCurrentAnnotation().getDate());\r\n    sj.add(Localization.lang(\"Page\") + \": \" + getCurrentAnnotation().getPage());\r\n    sj.add(Localization.lang(\"Content\") + \": \" + getCurrentAnnotation().getContent());\r\n    sj.add(Localization.lang(\"Marking\") + \": \" + getCurrentAnnotation().markingProperty().get());\r\n    Globals.clipboardManager.setContent(sj.toString());\r\n}"
}, {
	"Path": "com.datastax.driver.core.QueryOptionsTest.should_reprepare_on_up_by_default",
	"Comment": "validates that statements are reprepared when a node comes back up with the defaultconfiguration.",
	"Method": "void should_reprepare_on_up_by_default(){\r\n    valideReprepareOnUp(true);\r\n}"
}, {
	"Path": "org.jabref.JabRefExecutorService.execute",
	"Comment": "executes a callable task that provides a return value after the calculation is done.",
	"Method": "void execute(Runnable command,Future<T> execute,Callable<T> command){\r\n    Objects.requireNonNull(command);\r\n    return executorService.submit(command);\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.Query.setFetchSize",
	"Comment": "specify the fetch size for the query. this should cause the results to befetched from the underlying rdbms in groups of rows equal to the number passed.this is useful for doing chunked streaming of results when exhausting memorycould be a problem.",
	"Method": "Query setFetchSize(int fetchSize){\r\n    return addCustomizer(StatementCustomizers.fetchSize(fetchSize));\r\n}"
}, {
	"Path": "com.github.javafaker.NumberTest.calculateNumbersToGet",
	"Comment": "given a range, what is the number of values to get within that range for the randomization quality tests.",
	"Method": "long calculateNumbersToGet(long min,long max){\r\n    long numbersToGet = Math.min((max - min) / 4, RANDOMIZATION_TESTS_MAX_NUMBERS_TO_GET);\r\n    if (numbersToGet == 0)\r\n        numbersToGet = RANDOMIZATION_TESTS_MAX_NUMBERS_TO_GET;\r\n    return numbersToGet;\r\n}"
}, {
	"Path": "org.jabref.model.TreeNode.getIndexedPathFromRoot",
	"Comment": "get the path from the root node to this node.the elements in the returned list represent the child index of each node in the path, starting at the root.if this node is the root node, the returned list has zero elements.",
	"Method": "List<Integer> getIndexedPathFromRoot(){\r\n    if (parent == null) {\r\n        return new ArrayList();\r\n    }\r\n    List<Integer> path = parent.getIndexedPathFromRoot();\r\n    path.add(getPositionInParent());\r\n    return path;\r\n}"
}, {
	"Path": "org.jabref.logic.l10n.Localization.getMessages",
	"Comment": "returns the messages bundle, e.g. to load fxml files correctly translated.",
	"Method": "LocalizationBundle getMessages(){\r\n    if (locale == null) {\r\n        setLanguage(Language.English);\r\n    }\r\n    return localizedMessages;\r\n}"
}, {
	"Path": "com.datastax.driver.core.AbstractReplicationStrategyTest.assertReplicaPlacement",
	"Comment": "asserts that the replica map for a given token contains the expected list of replica hosts.hosts are checked in order, replica placement should be an ordered set",
	"Method": "void assertReplicaPlacement(Map<Token, Set<Host>> replicaMap,Token token,InetSocketAddress expected){\r\n    Set<Host> replicaSet = replicaMap.get(token);\r\n    assertNotNull(replicaSet);\r\n    assertReplicasForToken(replicaSet, expected);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.rmi.AppletServer.exportObject",
	"Comment": "exports an object.this method produces the bytecode of the proxy class usedto access the exported object.a remote applet can loadthe proxy class and call a method on the exported object.",
	"Method": "int exportObject(String name,Object obj){\r\n    Class<?> clazz = obj.getClass();\r\n    ExportedObject eo = new ExportedObject();\r\n    eo.object = obj;\r\n    eo.methods = clazz.getMethods();\r\n    exportedObjects.add(eo);\r\n    eo.identifier = exportedObjects.size() - 1;\r\n    if (name != null)\r\n        exportedNames.put(name, eo);\r\n    try {\r\n        stubGen.makeProxyClass(clazz);\r\n    } catch (NotFoundException e) {\r\n        throw new CannotCompileException(e);\r\n    }\r\n    return eo.identifier;\r\n}"
}, {
	"Path": "org.jabref.logic.xmp.XmpUtilWriter.generateXmpStringWithXmpDeclaration",
	"Comment": "this method generates an xmp metadata string in dublin core format.",
	"Method": "String generateXmpStringWithXmpDeclaration(List<BibEntry> entries,XmpPreferences xmpPreferences){\r\n    XMPMetadata meta = XMPMetadata.createXMPMetadata();\r\n    for (BibEntry entry : entries) {\r\n        DublinCoreSchema dcSchema = meta.createAndAddDublinCoreSchema();\r\n        XmpUtilWriter.writeToDCSchema(dcSchema, entry, xmpPreferences);\r\n    }\r\n    try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {\r\n        XmpSerializer serializer = new XmpSerializer();\r\n        serializer.serialize(meta, os, true);\r\n        return os.toString(StandardCharsets.UTF_8.name());\r\n    } catch (TransformerException e) {\r\n        LOGGER.warn(\"Tranformation into xmp not possible: \" + e.getMessage(), e);\r\n        return \"\";\r\n    } catch (UnsupportedEncodingException e) {\r\n        LOGGER.warn(\"Unsupported encoding to UTF-8 of bib entries in xmp metadata.\", e);\r\n        return \"\";\r\n    } catch (IOException e) {\r\n        LOGGER.warn(\"IO Exception thrown by closing the output stream.\", e);\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "org.jabref.model.entry.BibEntry.getObservables",
	"Comment": "returns a list of observables that represent the data of the entry.",
	"Method": "Observable[] getObservables(){\r\n    return new Observable[] { fields };\r\n}"
}, {
	"Path": "com.datastax.driver.core.SSLAuthenticatedEncryptionTest.should_not_connect_without_client_auth_but_node_requires_auth",
	"Comment": "validates that an ssl connection can not be established with if the target cassandra cluster isusing ssl, requires client auth, but the client does not provide sufficient certificateauthentication.",
	"Method": "void should_not_connect_without_client_auth_but_node_requires_auth(SslImplementation sslImplementation){\r\n    connectWithSSLOptions(getSSLOptions(sslImplementation, false, true));\r\n}"
}, {
	"Path": "org.jabref.logic.integrity.ASCIICharacterChecker.check",
	"Comment": "detect any non ascii encoded characters, e.g., umlauts or unicode in the fields",
	"Method": "List<IntegrityMessage> check(BibEntry entry){\r\n    List<IntegrityMessage> results = new ArrayList();\r\n    for (Map.Entry<String, String> field : entry.getFieldMap().entrySet()) {\r\n        boolean asciiOnly = CharMatcher.ascii().matchesAllOf(field.getValue());\r\n        if (!asciiOnly) {\r\n            results.add(new IntegrityMessage(Localization.lang(\"Non-ASCII encoded character found\"), entry, field.getKey()));\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.jabref.logic.util.io.RegExpBasedFileFinder.expandBrackets",
	"Comment": "takes a string that contains bracketed expression and expands each of these using getfieldandformat.unknown bracket expressions are silently dropped.",
	"Method": "String expandBrackets(String bracketString,BibEntry entry,BibDatabase database,Character keywordDelimiter){\r\n    Matcher matcher = SQUARE_BRACKETS_PATTERN.matcher(bracketString);\r\n    StringBuffer expandedStringBuffer = new StringBuffer();\r\n    while (matcher.find()) {\r\n        String replacement = BracketedPattern.expandBrackets(matcher.group(), keywordDelimiter, entry, database);\r\n        matcher.appendReplacement(expandedStringBuffer, replacement);\r\n    }\r\n    matcher.appendTail(expandedStringBuffer);\r\n    return expandedStringBuffer.toString();\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolTest.should_not_mark_host_down_if_some_connections_fail_on_init",
	"Comment": "ensures that if some connections fail on pool init that the host and subsequently the controlconnection is not marked down. the test also ensures that when making requests on the pool thatconnections are brought up to core.",
	"Method": "void should_not_mark_host_down_if_some_connections_fail_on_init(){\r\n    int readTimeout = 1000;\r\n    int reconnectInterval = 1000;\r\n    Cluster cluster = this.createClusterBuilder().withSocketOptions(new SocketOptions().setConnectTimeoutMillis(readTimeout).setReadTimeoutMillis(reconnectInterval)).withReconnectionPolicy(new ConstantReconnectionPolicy(1000)).build();\r\n    List<MockRequest> allRequests = newArrayList();\r\n    try {\r\n        cluster.init();\r\n        Connection.Factory factory = spy(cluster.manager.connectionFactory);\r\n        cluster.manager.connectionFactory = factory;\r\n        currentClient.disableListener(4);\r\n        HostConnectionPool pool = createPool(cluster, 8, 8);\r\n        reset(factory);\r\n        assertThat(pool.connections).hasSize(4);\r\n        assertThat(cluster).host(1).hasState(Host.State.UP);\r\n        assertThat(cluster).hasOpenControlConnection();\r\n        currentClient.enableListener();\r\n        Uninterruptibles.sleepUninterruptibly(reconnectInterval, TimeUnit.MILLISECONDS);\r\n        for (int i = 5; i <= 8; i++) {\r\n            allRequests.add(MockRequest.send(pool));\r\n            verify(factory, timeout(readTimeout)).open(any(HostConnectionPool.class));\r\n            reset(factory);\r\n            assertPoolSize(pool, i);\r\n        }\r\n    } finally {\r\n        MockRequest.completeAll(allRequests);\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.jdbi.v3.core.result.ResultIterable.collect",
	"Comment": "collect the results into a container specified by a collector.",
	"Method": "R collect(Collector<T, ?, R> collector){\r\n    try (Stream<T> stream = stream()) {\r\n        return stream.collect(collector);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.ReflectionHelper.invoke",
	"Comment": "convenience wrapper to reflection method invoke api. invoke the method and hide checked exceptions.",
	"Method": "Object invoke(Object target,Class<?> clazz,String methodName,Class[] parameterTypes,Object args){\r\n    try {\r\n        Method method = null;\r\n        try {\r\n            method = clazz.getMethod(methodName, parameterTypes);\r\n        } catch (NoSuchMethodException e) {\r\n            method = clazz.getDeclaredMethod(methodName, parameterTypes);\r\n        }\r\n        method.setAccessible(true);\r\n        return method.invoke(target, args);\r\n    } catch (IllegalArgumentException e) {\r\n        throw new IllegalArgumentException(String.format(\"Illegal arguments method %s.%s(%s) on %s, params %s\", clazz.getName(), methodName, Arrays.toString(parameterTypes), target, Arrays.toString(args)), e);\r\n    } catch (InvocationTargetException e) {\r\n        throw new IllegalStateException(String.format(\"Error invoking method %s.%s(%s) on %s, params %s\", clazz.getName(), methodName, Arrays.toString(parameterTypes), target, Arrays.toString(args)), e);\r\n    } catch (NoSuchMethodException e) {\r\n        throw new IllegalArgumentException(String.format(\"No such method %s.%s(%s) on %s, params %s\", clazz.getName(), methodName, Arrays.toString(parameterTypes), target, Arrays.toString(args)), e);\r\n    } catch (IllegalAccessException e) {\r\n        throw new IllegalArgumentException(String.format(\"No such method %s.%s(%s) on %s, params %s\", clazz.getName(), methodName, Arrays.toString(parameterTypes), target, Arrays.toString(args)), e);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.rmi.StubGenerator.makeProxyClass",
	"Comment": "makes a proxy class.the produced class is substitutedfor the original class.",
	"Method": "boolean makeProxyClass(Class<?> clazz){\r\n    String classname = clazz.getName();\r\n    if (proxyClasses.get(classname) != null)\r\n        return false;\r\n    CtClass ctclazz = produceProxyClass(classPool.get(classname), clazz);\r\n    proxyClasses.put(classname, ctclazz);\r\n    modifySuperclass(ctclazz);\r\n    return true;\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiles.FindUnlinkedFilesDialog.startExport",
	"Comment": "this starts the export of all files of all selected nodes in the file tree view.",
	"Method": "void startExport(){\r\n    CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot();\r\n    final List<Path> fileList = getFileListFromNode(root);\r\n    if (fileList.isEmpty()) {\r\n        return;\r\n    }\r\n    buttonExport.setVisible(false);\r\n    buttonApply.setVisible(false);\r\n    FileDialogConfiguration fileDialogConfiguration = new FileDialogConfiguration.Builder().withInitialDirectory(preferences.get(JabRefPreferences.WORKING_DIRECTORY)).build();\r\n    Optional<Path> exportPath = dialogService.showFileSaveDialog(fileDialogConfiguration);\r\n    if (!exportPath.isPresent()) {\r\n        buttonExport.setVisible(true);\r\n        buttonApply.setVisible(true);\r\n        return;\r\n    }\r\n    try (BufferedWriter writer = Files.newBufferedWriter(exportPath.get(), StandardCharsets.UTF_8, StandardOpenOption.CREATE)) {\r\n        for (Path file : fileList) {\r\n            writer.write(file.toString() + \"\\n\");\r\n        }\r\n    } catch (IOException e) {\r\n        LOGGER.warn(\"IO Error.\", e);\r\n    }\r\n    buttonExport.setVisible(true);\r\n    buttonApply.setVisible(true);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.util.proxy.ProxyFactory.setFilter",
	"Comment": "sets a filter that selects the methods that will be controlled by a handler.",
	"Method": "void setFilter(MethodFilter mf){\r\n    methodFilter = mf;\r\n    signature = null;\r\n}"
}, {
	"Path": "org.jabref.gui.bibtexkeypattern.ResolveDuplicateLabelDialog.getCheckBoxes",
	"Comment": "get the list of checkboxes where the user has selected which entries to generatenew keys for.",
	"Method": "List<JCheckBox> getCheckBoxes(){\r\n    return cbs;\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fileformat.BibtexParser.parseTextToken",
	"Comment": "this method is used to parse string labels, field names, entry type andnumbers outside brackets.",
	"Method": "String parseTextToken(){\r\n    StringBuilder token = new StringBuilder(20);\r\n    while (true) {\r\n        int character = read();\r\n        if (character == -1) {\r\n            eof = true;\r\n            return token.toString();\r\n        }\r\n        if (Character.isLetterOrDigit((char) character) || (\":-_*+./'\".indexOf(character) >= 0)) {\r\n            token.append((char) character);\r\n        } else {\r\n            unread(character);\r\n            return token.toString();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ClassUtils.resolvePrimitiveIfNecessary",
	"Comment": "resolve the given class if it is a primitive class, returning thecorresponding primitive wrapper type instead.",
	"Method": "Class<?> resolvePrimitiveIfNecessary(Class<?> clazz){\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.zk.ZkPlugin.defaultDisableCaches",
	"Comment": "default values of caches in development mode.note, that this is a little bit aggressive, but the user may override this by providing explicit value in zk.xml",
	"Method": "void defaultDisableCaches(ClassPool classPool,CtClass ctClass){\r\n    LOGGER.debug(\"org.zkoss.lang.Library enhanced to replace property '*.cache' default value to 'false'.\");\r\n    CtMethod m = ctClass.getDeclaredMethod(\"getProperty\", new CtClass[] { classPool.get(\"java.lang.String\") });\r\n    defaultLibraryPropertyFalse(m, \"org.zkoss.web.classWebResource.cache\");\r\n    defaultLibraryPropertyFalse(m, \"org.zkoss.zk.WPD.cache\");\r\n    defaultLibraryPropertyFalse(m, \"org.zkoss.zk.WCS.cache\");\r\n    defaultLibraryPropertyFalse(m, \"zk-dl.annotation.cache\");\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.PreparedBatch.add",
	"Comment": "bind arguments from a map, add the binding as a saved batch,then clear the current binding.",
	"Method": "PreparedBatch add(PreparedBatch add,Object args,PreparedBatch add,Map<String, ?> args){\r\n    bindMap(args);\r\n    add();\r\n    return this;\r\n}"
}, {
	"Path": "org.jabref.logic.xmp.XmpUtilWriterTest.testWriteMultipleBibEntries",
	"Comment": "test, which writes multiple metadata entries to a pdf and reads them again to test the size.",
	"Method": "void testWriteMultipleBibEntries(Path tempDir){\r\n    Path pdfFile = this.createDefaultFile(\"JabRef_writeMultiple.pdf\", tempDir);\r\n    List<BibEntry> entries = Arrays.asList(olly2018, vapnik2000, toral2006);\r\n    XmpUtilWriter.writeXmp(Paths.get(pdfFile.toAbsolutePath().toString()), entries, null, xmpPreferences);\r\n    List<BibEntry> entryList = XmpUtilReader.readXmp(Paths.get(pdfFile.toAbsolutePath().toString()), xmpPreferences);\r\n    assertEquals(3, entryList.size());\r\n}"
}, {
	"Path": "org.jabref.logic.shared.MySQLProcessor.setUp",
	"Comment": "creates and sets up the needed tables and columns according to the database type.",
	"Method": "void setUp(){\r\n    connection.createStatement().executeUpdate(\"CREATE TABLE IF NOT EXISTS `ENTRY` (\" + \"`SHARED_ID` INT(11) NOT NULL PRIMARY KEY AUTO_INCREMENT, \" + \"`TYPE` VARCHAR(255) NOT NULL, \" + \"`VERSION` INT(11) DEFAULT 1)\");\r\n    connection.createStatement().executeUpdate(\"CREATE TABLE IF NOT EXISTS `FIELD` (\" + \"`ENTRY_SHARED_ID` INT(11) NOT NULL, \" + \"`NAME` VARCHAR(255) NOT NULL, \" + \"`VALUE` TEXT DEFAULT NULL, \" + \"FOREIGN KEY (`ENTRY_SHARED_ID`) REFERENCES `ENTRY`(`SHARED_ID`) ON DELETE CASCADE)\");\r\n    connection.createStatement().executeUpdate(\"CREATE TABLE IF NOT EXISTS `METADATA` (\" + \"`KEY` varchar(255) NOT NULL,\" + \"`VALUE` text NOT NULL)\");\r\n}"
}, {
	"Path": "org.hotswap.agent.util.ReflectionHelper.getNoException",
	"Comment": "convenience wrapper to reflection method invoke api. get field value and swallow exceptions.use this method if you have multiple framework support and the field may not exist in current version.",
	"Method": "Object getNoException(Object target,Class<?> clazz,String fieldName){\r\n    try {\r\n        return get(target, clazz, fieldName);\r\n    } catch (Exception e) {\r\n        LOGGER.trace(\"Error getting field {}.{} on object {}\", e, clazz, fieldName, target);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiletype.CustomExternalFileType.buildFromArgs",
	"Comment": "construct an externalfiletype from a string array. this is used whenreading file type definitions from preferences, where the available data types arelimited. we assume that the array contains the same values as the main constructor,in the same order.",
	"Method": "ExternalFileType buildFromArgs(String[] val){\r\n    if ((val == null) || (val.length < 4) || (val.length > 5)) {\r\n        throw new IllegalArgumentException(\"Cannot construct ExternalFileType without four elements in String[] argument.\");\r\n    }\r\n    String name = val[0];\r\n    String extension = val[1];\r\n    String openWith;\r\n    String mimeType;\r\n    String iconName;\r\n    if (val.length == 4) {\r\n        mimeType = \"\";\r\n        openWith = val[2];\r\n        iconName = val[3];\r\n    } else {\r\n        mimeType = val[2];\r\n        openWith = val[3];\r\n        iconName = val[4];\r\n    }\r\n    JabRefIcon icon = IconTheme.JabRefIcons.FILE;\r\n    for (ExternalFileType fileType : ExternalFileTypes.getDefaultExternalFileTypes()) {\r\n        if (fileType.getName().equals(name)) {\r\n            icon = fileType.getIcon();\r\n            break;\r\n        }\r\n    }\r\n    return new CustomExternalFileType(name, extension, mimeType, openWith, iconName, icon);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.path.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles",
	"Comment": "recursively retrieve files that match the given pattern, adding them tothe given result list.",
	"Method": "void doRetrieveMatchingFiles(String fullPattern,File dir,Set<File> result){\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Searching directory [\" + dir.getAbsolutePath() + \"] for files matching pattern [\" + fullPattern + \"]\");\r\n    }\r\n    File[] dirContents = dir.listFiles();\r\n    if (dirContents == null) {\r\n        if (logger.isWarnEnabled()) {\r\n            logger.warning(\"Could not retrieve contents of directory [\" + dir.getAbsolutePath() + \"]\");\r\n        }\r\n        return;\r\n    }\r\n    for (File content : dirContents) {\r\n        String currPath = StringUtils.replace(content.getAbsolutePath(), File.separator, \"/\");\r\n        if (content.isDirectory() && getPathMatcher().matchStart(fullPattern, currPath + \"/\")) {\r\n            if (!content.canRead()) {\r\n                if (logger.isDebugEnabled()) {\r\n                    logger.debug(\"Skipping subdirectory [\" + dir.getAbsolutePath() + \"] because the application is not allowed to read the directory\");\r\n                }\r\n            } else {\r\n                doRetrieveMatchingFiles(fullPattern, content, result);\r\n            }\r\n        }\r\n        if (getPathMatcher().match(fullPattern, currPath)) {\r\n            result.add(content);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.util.io.FileUtil.find",
	"Comment": "finds a file inside a list of directory structures. will also look for the file inside nested directories.",
	"Method": "Optional<Path> find(String filename,Path rootDirectory,List<Path> find,String filename,List<Path> directories){\r\n    List<Path> files = new ArrayList();\r\n    for (Path dir : directories) {\r\n        FileUtil.find(filename, dir).ifPresent(files::add);\r\n    }\r\n    return files;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.result.ResultProducers.returningUpdateCount",
	"Comment": "result producer that eagerly executes the statement, returning the update count",
	"Method": "ResultProducer<Integer> returningUpdateCount(){\r\n    return (statementSupplier, ctx) -> {\r\n        try {\r\n            return statementSupplier.get().getUpdateCount();\r\n        } finally {\r\n            ctx.close();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.jabref.gui.help.VersionWorker.showConnectionError",
	"Comment": "prints the connection problem to the status bar and shows a dialog if it was executed manually",
	"Method": "void showConnectionError(Exception exception,boolean manualExecution){\r\n    String couldNotConnect = Localization.lang(\"Could not connect to the update server.\");\r\n    String tryLater = Localization.lang(\"Please try again later and/or check your network connection.\");\r\n    if (manualExecution) {\r\n        dialogService.showErrorDialogAndWait(Localization.lang(\"Error\"), couldNotConnect + \"\\n\" + tryLater, exception);\r\n    }\r\n    LOGGER.warn(couldNotConnect + \" \" + tryLater, exception);\r\n}"
}, {
	"Path": "org.elixir_lang.beam.psi.BeamFileImpl.copy",
	"Comment": "creates a copy of the file containing the psi element and returns the correspondingelement in the created copy. resolve operations performed on elements in the copyof the file will resolve to elements in the copy, not in the original file.",
	"Method": "PsiElement copy(){\r\n    return this;\r\n}"
}, {
	"Path": "com.datastax.driver.core.QueryTrace.getTraceId",
	"Comment": "returns the identifier of this trace.note that contrary to the other methods in this class, this does not entail fetching querytrace details from cassandra.",
	"Method": "UUID getTraceId(){\r\n    return traceId;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.PathResource.hashCode",
	"Comment": "this implementation returns the hash code of the underlying pathreference.",
	"Method": "int hashCode(){\r\n    return this.path.hashCode();\r\n}"
}, {
	"Path": "org.jabref.gui.desktop.JabRefDesktop.openExternalFileAnyFormat",
	"Comment": "open an external file, attempting to use the correct viewer for it.",
	"Method": "boolean openExternalFileAnyFormat(BibDatabaseContext databaseContext,String link,Optional<ExternalFileType> type,boolean openExternalFileAnyFormat,Path file,BibDatabaseContext databaseContext,Optional<ExternalFileType> type){\r\n    return openExternalFileAnyFormat(databaseContext, file.toString(), type);\r\n}"
}, {
	"Path": "org.jabref.gui.BasePanel.getSelectedEntries",
	"Comment": "get an array containing the currently selected entries. the array is stable and not changed if the selectionchanges",
	"Method": "List<BibEntry> getSelectedEntries(){\r\n    return mainTable.getSelectedEntries();\r\n}"
}, {
	"Path": "com.datastax.driver.core.ExecutionInfo.getSuccessfulExecutionIndex",
	"Comment": "the index of the execution that completed this query.0 represents the initial, normal execution of the query, 1 represents the first speculativeexecution, etc.",
	"Method": "int getSuccessfulExecutionIndex(){\r\n    return successfulExecutionIndex;\r\n}"
}, {
	"Path": "org.jabref.model.entry.EntryType.getOptionalFieldsAndAliases",
	"Comment": "get list of all optional fields of this entry and their aliases.",
	"Method": "Set<String> getOptionalFieldsAndAliases(){\r\n    Set<String> optionalFieldsAndAliases = new LinkedHashSet();\r\n    for (String field : getOptionalFields()) {\r\n        optionalFieldsAndAliases.add(field);\r\n        if (EntryConverter.FIELD_ALIASES_LTX_TO_TEX.containsKey(field)) {\r\n            optionalFieldsAndAliases.add(EntryConverter.FIELD_ALIASES_LTX_TO_TEX.get(field));\r\n        }\r\n    }\r\n    return optionalFieldsAndAliases;\r\n}"
}, {
	"Path": "com.beust.jcommander.ConverterFactoryTest.mainWithHostPortParameters",
	"Comment": "test that main parameters can be used with string converters,either with a factory or from the annotation.",
	"Method": "void mainWithHostPortParameters(IStringConverterFactory f,IStringConverterInstanceFactory f2,IHostPorts a){\r\n    JCommander jc = new JCommander(a);\r\n    if (f != null)\r\n        jc.addConverterFactory(f);\r\n    if (f2 != null)\r\n        jc.addConverterInstanceFactory(f2);\r\n    jc.parse(\"a.com:10\", \"b.com:20\");\r\n    Assert.assertEquals(a.getHostPorts().get(0).host, \"a.com\");\r\n    Assert.assertEquals(a.getHostPorts().get(0).port.intValue(), 10);\r\n    Assert.assertEquals(a.getHostPorts().get(1).host, \"b.com\");\r\n    Assert.assertEquals(a.getHostPorts().get(1).port.intValue(), 20);\r\n}"
}, {
	"Path": "com.datastax.driver.core.exceptions.ExceptionsTest.alreadyExistsException",
	"Comment": "tests the alreadyexistsexception. create a keyspace twice and a table twice. catch and test allthe exception methods.",
	"Method": "void alreadyExistsException(){\r\n    String keyspace = \"TestKeyspace\";\r\n    String table = \"TestTable\";\r\n    String[] cqlCommands = new String[] { String.format(TestUtils.CREATE_KEYSPACE_SIMPLE_FORMAT, keyspace, 1), \"USE \" + keyspace, String.format(\"CREATE TABLE %s (k text PRIMARY KEY, t text, i int, f float)\", table) };\r\n    session().execute(cqlCommands[0]);\r\n    session().execute(cqlCommands[1]);\r\n    session().execute(cqlCommands[2]);\r\n    try {\r\n        session().execute(cqlCommands[0]);\r\n    } catch (AlreadyExistsException e) {\r\n        String expected = String.format(\"Keyspace %s already exists\", keyspace.toLowerCase());\r\n        assertEquals(e.getMessage(), expected);\r\n        assertEquals(e.getKeyspace(), keyspace.toLowerCase());\r\n        assertEquals(e.getTable(), null);\r\n        assertEquals(e.wasTableCreation(), false);\r\n        assertEquals(e.getHost(), ccm().addressOfNode(1).getAddress());\r\n        assertEquals(e.getAddress(), ccm().addressOfNode(1));\r\n    }\r\n    session().execute(cqlCommands[1]);\r\n    try {\r\n        session().execute(cqlCommands[2]);\r\n    } catch (AlreadyExistsException e) {\r\n        assertEquals(e.getKeyspace(), keyspace.toLowerCase());\r\n        assertEquals(e.getTable(), table.toLowerCase());\r\n        assertEquals(e.wasTableCreation(), true);\r\n        assertEquals(e.getHost(), ccm().addressOfNode(1).getAddress());\r\n        assertEquals(e.getAddress(), ccm().addressOfNode(1));\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.AuthenticationTest.should_fail_to_connect_with_wrong_credentials",
	"Comment": "validates that if cluster initialization fails, it should fail with an authenticationexception.in addition, a repeated attempt to initialize raises an error indicating that it hadpreviously failed.",
	"Method": "void should_fail_to_connect_with_wrong_credentials(){\r\n    Cluster cluster = register(Cluster.builder().addContactPoints(getContactPoints()).withPort(ccm().getBinaryPort()).withCredentials(\"bogus\", \"bogus\").build());\r\n    try {\r\n        cluster.connect();\r\n        fail(\"Should throw AuthenticationException when attempting to connect\");\r\n    } catch (AuthenticationException e) {\r\n        try {\r\n            cluster.connect();\r\n            fail(\"Should throw IllegalStateException when attempting to connect again.\");\r\n        } catch (IllegalStateException e1) {\r\n            assertThat(e1.getCause()).isSameAs(e);\r\n            assertThat(e1).hasMessage(\"Can't use this cluster instance because it encountered an error in its initialization\");\r\n        }\r\n    } finally {\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.TypedBibEntry.hasAllRequiredFields",
	"Comment": "returns true if this entry contains the fields it needs to becomplete.",
	"Method": "boolean hasAllRequiredFields(){\r\n    Optional<EntryType> type = EntryTypes.getType(entry.getType(), this.mode);\r\n    if (type.isPresent()) {\r\n        return entry.allFieldsPresent(type.get().getRequiredFields(), database.orElse(null));\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.StatementContext.getRenderedSql",
	"Comment": "obtain the rendered sql statementnot available until until statement execution time",
	"Method": "String getRenderedSql(){\r\n    return renderedSql;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.util.proxy.ProxyFactory.setUseWriteReplace",
	"Comment": "configure whether this factory should add a writereplace method to created classes",
	"Method": "void setUseWriteReplace(boolean useWriteReplace){\r\n    factoryWriteReplace = useWriteReplace;\r\n}"
}, {
	"Path": "com.datastax.driver.core.ParseUtils.skipCQLId",
	"Comment": "assuming that idx points to the beginning of a cql identifier in toparse, returns the index ofthe first character after this identifier.",
	"Method": "int skipCQLId(String toParse,int idx){\r\n    if (idx >= toParse.length())\r\n        throw new IllegalArgumentException();\r\n    char c = toParse.charAt(idx);\r\n    if (isIdentifierChar(c)) {\r\n        while (idx < toParse.length() && isIdentifierChar(toParse.charAt(idx))) idx++;\r\n        return idx;\r\n    }\r\n    if (c != '\"')\r\n        throw new IllegalArgumentException();\r\n    while (++idx < toParse.length()) {\r\n        c = toParse.charAt(idx);\r\n        if (c != '\"')\r\n            continue;\r\n        if (idx + 1 < toParse.length() && toParse.charAt(idx + 1) == '\\\"')\r\n            ++idx;\r\n        else\r\n            return idx + 1;\r\n    }\r\n    throw new IllegalArgumentException();\r\n}"
}, {
	"Path": "org.jabref.gui.bibtexkeypattern.BibtexKeyPatternPanel.fillPatternUsingPanelData",
	"Comment": "fill the given labelpattern by values generated from the text fields",
	"Method": "void fillPatternUsingPanelData(AbstractBibtexKeyPattern keypatterns){\r\n    for (Map.Entry<String, TextField> entry : textFields.entrySet()) {\r\n        String text = entry.getValue().getText();\r\n        if (!text.trim().isEmpty()) {\r\n            keypatterns.addBibtexKeyPattern(entry.getKey(), text);\r\n        }\r\n    }\r\n    String text = defaultPat.getText();\r\n    if (!text.trim().isEmpty()) {\r\n        keypatterns.setDefaultValue(text);\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.PagingState.toBytes",
	"Comment": "return a representation of the paging state object as a byte array.",
	"Method": "byte[] toBytes(){\r\n    return generateCompleteOutput().array();\r\n}"
}, {
	"Path": "me.ramswaroop.jbot.core.slack.Bot.encode",
	"Comment": "encode the text before sending to slack.learn more on message formatting in slack",
	"Method": "String encode(String message){\r\n    return message == null ? null : message.replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\");\r\n}"
}, {
	"Path": "org.hotswap.agent.util.classloader.ClassLoaderHelper.isClassLoderStarted",
	"Comment": "some class loader has activity state. e.g. webappclassloader must be started before it can be used",
	"Method": "boolean isClassLoderStarted(ClassLoader classLoader){\r\n    if (\"org.glassfish.web.loader.WebappClassLoader\".equals(classLoader.getClass().getName()) || \"org.apache.catalina.loader.WebappClassLoader\".equals(classLoader.getClass().getName())) {\r\n        try {\r\n            Class<?> clazz = classLoader.getClass();\r\n            boolean isStarted;\r\n            if (\"org.apache.catalina.loader.WebappClassLoaderBase\".equals(clazz.getSuperclass().getName())) {\r\n                clazz = clazz.getSuperclass();\r\n                isStarted = \"STARTED\".equals((String) ReflectionHelper.invoke(classLoader, clazz, \"getStateName\", new Class[] {}, null));\r\n            } else {\r\n                isStarted = (boolean) ReflectionHelper.invoke(classLoader, clazz, \"isStarted\", new Class[] {}, null);\r\n            }\r\n            return isStarted;\r\n        } catch (Exception e) {\r\n            LOGGER.warning(\"isClassLoderStarted() : {}\", e.getMessage());\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jabref.model.database.BibDatabaseContext.getDatabaseFile",
	"Comment": "get the file where this database was last saved to or loaded from, if any.",
	"Method": "Optional<File> getDatabaseFile(){\r\n    return file.map(Path::toFile);\r\n}"
}, {
	"Path": "org.jabref.gui.push.AbstractPushToApplication.getCommandLine",
	"Comment": "function to get the command to be executed for pushing keys to be cited",
	"Method": "String[] getCommandLine(String keyString){\r\n    return new String[0];\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.jersey1.Jersey1Plugin.getContainerClasses",
	"Comment": "gets a list of classes used in configure the jersey application",
	"Method": "Set<Class<?>> getContainerClasses(Class<?> resourceConfigClass,Object resourceConfig){\r\n    Set<Class<?>> containerClasses = Collections.newSetFromMap(new WeakHashMap<Class<?>, Boolean>());\r\n    Set<Class<?>> providerClasses = (Set<Class<?>>) ReflectionHelper.invoke(resourceConfig, resourceConfigClass, \"getProviderClasses\", new Class[] {});\r\n    if (providerClasses != null) {\r\n        containerClasses.addAll(providerClasses);\r\n    }\r\n    Set<Class<?>> rootResourceClasses = (Set<Class<?>>) ReflectionHelper.invoke(resourceConfig, resourceConfigClass, \"getRootResourceClasses\", new Class[] {});\r\n    if (rootResourceClasses != null) {\r\n        containerClasses.addAll(rootResourceClasses);\r\n    }\r\n    return containerClasses;\r\n}"
}, {
	"Path": "com.datastax.driver.core.MaterializedViewMetadataTest.should_create_view_metadata_with_quoted_identifiers",
	"Comment": "validates that a materialized view is properly retrieved and parsed when using quotedidentifiers.",
	"Method": "void should_create_view_metadata_with_quoted_identifiers(){\r\n    String createTable = String.format(\"CREATE TABLE %s.\\\"T1\\\" (\" + \"\\\"theKey\\\" int, \" + \"\\\"the;Clustering\\\" int, \" + \"\\\"the Value\\\" int, \" + \"PRIMARY KEY (\\\"theKey\\\", \\\"the;Clustering\\\"))\", keyspace);\r\n    String createMV = String.format(\"CREATE MATERIALIZED VIEW %s.\\\"Mv1\\\" AS \" + \"SELECT \\\"theKey\\\", \\\"the;Clustering\\\", \\\"the Value\\\" \" + \"FROM %s.\\\"T1\\\" \" + \"WHERE \\\"theKey\\\" IS NOT NULL AND \\\"the;Clustering\\\" IS NOT NULL AND \\\"the Value\\\" IS NOT NULL \" + \"PRIMARY KEY (\\\"theKey\\\", \\\"the;Clustering\\\")\", keyspace, keyspace);\r\n    session().execute(createTable);\r\n    session().execute(createMV);\r\n    TableMetadata table = cluster().getMetadata().getKeyspace(keyspace).getTable(\"\\\"T1\\\"\");\r\n    MaterializedViewMetadata mv = cluster().getMetadata().getKeyspace(keyspace).getMaterializedView(\"\\\"Mv1\\\"\");\r\n    assertThat(table).isNotNull().hasName(\"T1\").hasMaterializedView(mv).hasNumberOfColumns(3);\r\n    assertThat(table.getViews()).hasSize(1).containsOnly(mv);\r\n    assertThat(table.getColumns().get(0)).isNotNull().hasName(\"theKey\").isPartitionKey().hasType(cint());\r\n    assertThat(table.getColumns().get(1)).isNotNull().hasName(\"the;Clustering\").isClusteringColumn().hasType(cint());\r\n    assertThat(table.getColumns().get(2)).isNotNull().hasName(\"the Value\").isRegularColumn().hasType(cint());\r\n    assertThat(mv).isNotNull().hasName(\"Mv1\").hasBaseTable(table).hasNumberOfColumns(3);\r\n    assertThat(mv.getColumns().get(0)).isNotNull().hasName(\"theKey\").isPartitionKey().hasType(cint());\r\n    assertThat(mv.getColumns().get(1)).isNotNull().hasName(\"the;Clustering\").isClusteringColumn().hasType(cint());\r\n    assertThat(mv.getColumns().get(2)).isNotNull().hasName(\"the Value\").isRegularColumn().hasType(cint());\r\n    assertThat(mv.asCQLQuery(false)).contains(createMV);\r\n}"
}, {
	"Path": "org.jdbi.v3.core.Handle.inTransaction",
	"Comment": "executes callback in a transaction, and returns the result of the callback.this form accepts a transaction isolation level which will be applied to the connectionfor the scope of this transaction, after which the original isolation level will be restored.",
	"Method": "R inTransaction(HandleCallback<R, X> callback,R inTransaction,TransactionIsolationLevel level,HandleCallback<R, X> callback){\r\n    try (TransactionResetter tr = new TransactionResetter(getTransactionIsolationLevel())) {\r\n        setTransactionIsolation(level);\r\n        return transactions.inTransaction(this, level, callback);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ClassUtils.getShortNameAsProperty",
	"Comment": "return the short string name of a java class in uncapitalized javabeansproperty format. strips the outer class name in case of an inner class.",
	"Method": "String getShortNameAsProperty(Class<?> clazz){\r\n    String shortName = ClassUtils.getShortName(clazz);\r\n    int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\r\n    shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\r\n    return Introspector.decapitalize(shortName);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.util.proxy.RuntimeSupport.findMethod",
	"Comment": "finds a method with the given name and descriptor.it searches only the class of self.",
	"Method": "Method findMethod(Object self,String name,String desc,Method findMethod,Class<?> clazz,String name,String desc){\r\n    Method m = findMethod2(clazz, name, desc);\r\n    if (m == null)\r\n        error(clazz, name, desc);\r\n    return m;\r\n}"
}, {
	"Path": "org.jabref.gui.keyboard.KeyBindingsDialogViewModel.populateTable",
	"Comment": "read all keybindings from the keybinding repository and create table keybinding models for them",
	"Method": "void populateTable(){\r\n    KeyBindingViewModel root = new KeyBindingViewModel(keyBindingRepository, KeyBindingCategory.FILE);\r\n    for (KeyBindingCategory category : KeyBindingCategory.values()) {\r\n        KeyBindingViewModel categoryItem = new KeyBindingViewModel(keyBindingRepository, category);\r\n        keyBindingRepository.getKeyBindings().forEach((keyBinding, bind) -> {\r\n            if (keyBinding.getCategory() == category) {\r\n                KeyBindingViewModel keyBindViewModel = new KeyBindingViewModel(keyBindingRepository, keyBinding, bind);\r\n                categoryItem.getChildren().add(keyBindViewModel);\r\n            }\r\n        });\r\n        root.getChildren().add(categoryItem);\r\n    }\r\n    rootKeyBinding.set(root);\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fileformat.BibTeXMLImporter.isMethodToIgnore",
	"Comment": "returns whether the value of the given method name should be mapped or whether the method can be ignored.",
	"Method": "boolean isMethodToIgnore(String methodName){\r\n    return IGNORED_METHODS.contains(methodName);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.PathResource.exists",
	"Comment": "this implementation returns whether the underlying file exists.",
	"Method": "boolean exists(){\r\n    return Files.exists(this.path);\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolTest.should_fail_in_borrowConnection_when_setting_keyspace_and_another_set_keyspace_attempt_is_in_flight",
	"Comment": "ensures that on borrowconnection if a set keyspace attempt is in progress on that connectionfor a different keyspace than the pool state that the borrowconnection future returned isfailed.",
	"Method": "void should_fail_in_borrowConnection_when_setting_keyspace_and_another_set_keyspace_attempt_is_in_flight(){\r\n    Cluster cluster = createClusterBuilder().build();\r\n    try {\r\n        HostConnectionPool pool = createPool(cluster, 1, 1);\r\n        primingClient.prime(PrimingRequest.queryBuilder().withQuery(\"USE \\\"slowks\\\"\").withThen(PrimingRequest.then().withFixedDelay(5000L)));\r\n        Connection connection = pool.connections.get(0);\r\n        connection.setKeyspaceAsync(\"slowks\");\r\n        pool.manager.poolsState.setKeyspace(\"newks\");\r\n        MockRequest request = MockRequest.send(pool);\r\n        try {\r\n            Uninterruptibles.getUninterruptibly(request.connectionFuture, 5, TimeUnit.SECONDS);\r\n            fail(\"Should have thrown exception\");\r\n        } catch (ExecutionException e) {\r\n            assertThat(e.getCause()).isInstanceOf(DriverException.class);\r\n            assertThat(e.getCause().getMessage()).contains(\"Aborting attempt to set keyspace to 'newks' since there is already an in flight attempt to set keyspace to 'slowks'.\");\r\n        }\r\n    } finally {\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.web.Webserver.main",
	"Comment": "starts a web server.the port number is specified by the first argument.",
	"Method": "void main(String[] args){\r\n    if (args.length == 1) {\r\n        Webserver web = new Webserver(args[0]);\r\n        web.run();\r\n    } else\r\n        System.err.println(\"Usage: java javassist.tools.web.Webserver <port number>\");\r\n}"
}, {
	"Path": "org.elixir_lang.application.options.CodeStyleConfigurable.getHelpTopic",
	"Comment": "returns the topic in the help file which is shown when help for the configurableis requested.",
	"Method": "String getHelpTopic(){\r\n    return null;\r\n}"
}, {
	"Path": "com.datastax.driver.core.exceptions.ReadFailureException.getFailures",
	"Comment": "returns the number of replicas that experienced a failure while executing the request.",
	"Method": "int getFailures(){\r\n    return failed;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.UrlResource.getDescription",
	"Comment": "this implementation returns a description that includes the url.",
	"Method": "String getDescription(){\r\n    return \"URL [\" + this.url + \"]\";\r\n}"
}, {
	"Path": "org.jabref.model.TreeNode.findChildrenSatisfying",
	"Comment": "returns the group and any of its children in the tree satisfying the given condition.",
	"Method": "List<T> findChildrenSatisfying(Predicate<T> matcher){\r\n    List<T> hits = new ArrayList();\r\n    if (matcher.test((T) this)) {\r\n        hits.add((T) this);\r\n    }\r\n    for (T child : getChildren()) {\r\n        hits.addAll(child.findChildrenSatisfying(matcher));\r\n    }\r\n    return hits;\r\n}"
}, {
	"Path": "com.datastax.driver.core.CustomPayloadTest.should_print_log_message_when_level_trace",
	"Comment": "ensures that when debugging custom payloads, the driver will print appropriate log messages.",
	"Method": "void should_print_log_message_when_level_trace(){\r\n    Logger logger = Logger.getLogger(Message.logger.getName());\r\n    MemoryAppender appender = new MemoryAppender();\r\n    try {\r\n        logger.setLevel(TRACE);\r\n        logger.addAppender(appender);\r\n        Statement statement = new SimpleStatement(\"SELECT c2 FROM t1 where c1 = ?\", 1);\r\n        statement.setOutgoingPayload(payload1);\r\n        session().execute(statement);\r\n        String logs = appender.waitAndGet(10000);\r\n        assertThat(logs).contains(\"Sending payload: {k1:0x010203, k2:0x040506} (24 bytes total)\").contains(\"Received payload: {k1:0x010203, k2:0x040506} (24 bytes total)\");\r\n    } finally {\r\n        logger.setLevel(null);\r\n        logger.removeAppender(appender);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.openoffice.OOBibStyle.getCitationMarkerField",
	"Comment": "this method looks up a field for an entry in a database. any number of backup fields can be usedif the primary field is empty.",
	"Method": "String getCitationMarkerField(BibEntry entry,BibDatabase database,String field){\r\n    String authorField = getStringCitProperty(AUTHOR_FIELD);\r\n    String[] fields = field.split(FieldName.FIELD_SEPARATOR);\r\n    for (String s : fields) {\r\n        Optional<String> content = entry.getResolvedFieldOrAlias(s, database);\r\n        if ((content.isPresent()) && !content.get().trim().isEmpty()) {\r\n            if (field.equals(authorField) && StringUtil.isInCurlyBrackets(content.get())) {\r\n                return \"{\" + fieldFormatter.format(content.get()) + \"}\";\r\n            }\r\n            return fieldFormatter.format(content.get());\r\n        }\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.weld.WeldPlugin.classReload",
	"Comment": "if bda archive is defined for given class than new beanclassrefreshcommand is created",
	"Method": "void classReload(ClassLoader classLoader,CtClass ctClass,Class<?> original){\r\n    if (original != null && !isSyntheticCdiClass(ctClass.getName()) && !isInnerNonPublicStaticClass(ctClass)) {\r\n        try {\r\n            String archivePath = getArchivePath(classLoader, ctClass, original.getName());\r\n            if (isBdaRegistered(classLoader, archivePath)) {\r\n                LOGGER.debug(\"Class '{}' redefined for archive {} \", original.getName(), archivePath);\r\n                String oldSignatureForProxyCheck = WeldClassSignatureHelper.getSignatureForProxyClass(original);\r\n                String oldSignatureByStrategy = WeldClassSignatureHelper.getSignatureByStrategy(beanReloadStrategy, original);\r\n                String oldFullSignature = ClassSignatureComparerHelper.getJavaClassSignature(original, ClassSignatureElement.values());\r\n                scheduler.scheduleCommand(new BeanClassRefreshCommand(classLoader, archivePath, registeredProxiedBeans, original.getName(), oldFullSignature, oldSignatureForProxyCheck, oldSignatureByStrategy, beanReloadStrategy), WAIT_ON_REDEFINE);\r\n            }\r\n        } catch (Exception e) {\r\n            LOGGER.error(\"classReload() exception {}.\", e, e.getMessage());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.AbstractResource.lastModified",
	"Comment": "this implementation checks the timestamp of the underlying file, ifavailable.",
	"Method": "long lastModified(){\r\n    long lastModified = getFileForLastModifiedCheck().lastModified();\r\n    if (lastModified == 0L) {\r\n        throw new FileNotFoundException(getDescription() + \" cannot be resolved in the file system for resolving its last-modified timestamp\");\r\n    }\r\n    return lastModified;\r\n}"
}, {
	"Path": "com.datastax.driver.core.KeyspaceMetadata.getMaterializedView",
	"Comment": "returns the metadata for a materialized view contained in this keyspace.",
	"Method": "MaterializedViewMetadata getMaterializedView(String name){\r\n    return views.get(Metadata.handleId(name));\r\n}"
}, {
	"Path": "com.datastax.driver.core.ClusterInitTest.should_detect_cluster_init_failure_and_close_cluster",
	"Comment": "ensures that if an error occurs doing initialization that subsequent attempts to use thecluster result in an appropriate error.",
	"Method": "void should_detect_cluster_init_failure_and_close_cluster(){\r\n    Cluster cluster = Cluster.builder().addContactPointsWithPorts(new InetSocketAddress(\"127.0.0.1\", 65534)).withNettyOptions(nonQuietClusterCloseOptions).build();\r\n    try {\r\n        cluster.connect();\r\n        fail(\"Should not have been able to connect.\");\r\n    } catch (NoHostAvailableException e) {\r\n        try {\r\n            cluster.connect();\r\n            fail(\"Should error when connect is called.\");\r\n        } catch (IllegalStateException e1) {\r\n            assertThat(e1.getCause()).isSameAs(e);\r\n            assertThat(e1).hasMessage(\"Can't use this cluster instance because it encountered an error in its initialization\");\r\n        }\r\n    } finally {\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.elixir_lang.structure_view.element.modular.Implementation.derivedForName",
	"Comment": "the name of the module the protocol is for as derived from the psi tree",
	"Method": "String derivedForName(){\r\n    String forName;\r\n    PsiElement[] finalArguments = finalArguments(navigationItem);\r\n    assert finalArguments != null;\r\n    if (finalArguments.length > 1) {\r\n        PsiElement finalArgument = finalArguments[finalArguments.length - 1];\r\n        if (finalArgument instanceof QuotableKeywordList) {\r\n            QuotableKeywordList quotableKeywordList = (QuotableKeywordList) finalArgument;\r\n            PsiElement keywordValue = keywordValue(quotableKeywordList, FOR);\r\n            if (keywordValue != null) {\r\n                forName = keywordValue.getText();\r\n            } else {\r\n                forName = \"?\";\r\n            }\r\n        } else {\r\n            forName = \"?\";\r\n        }\r\n    } else if (getParent() != null) {\r\n        org.elixir_lang.navigation.item_presentation.Parent parentPresentation = (org.elixir_lang.navigation.item_presentation.Parent) getParent().getPresentation();\r\n        forName = parentPresentation.getLocatedPresentableText();\r\n    } else {\r\n        forName = \"?\";\r\n    }\r\n    return forName;\r\n}"
}, {
	"Path": "org.jabref.logic.openoffice.OOBibStyle.group",
	"Comment": "modify entry and uniquefier arrays to facilitate a grouped presentation of uniquefied entries.",
	"Method": "void group(List<BibEntry> entries,String[] uniquefiers,int from,int to){\r\n    String separator = getStringCitProperty(UNIQUEFIER_SEPARATOR);\r\n    StringBuilder sb = new StringBuilder(uniquefiers[from]);\r\n    for (int i = from + 1; i <= to; i++) {\r\n        sb.append(separator);\r\n        sb.append(uniquefiers[i]);\r\n        entries.set(i, null);\r\n    }\r\n    uniquefiers[from] = sb.toString();\r\n}"
}, {
	"Path": "com.datastax.driver.core.ExecutionInfo.getQueryTrace",
	"Comment": "return the query trace if tracing was enabled on this query.note that accessing the fields of the the returned object will trigger a blockingbackground query.",
	"Method": "QueryTrace getQueryTrace(){\r\n    return trace;\r\n}"
}, {
	"Path": "org.jabref.logic.exporter.TemplateExporter.getReader",
	"Comment": "this method should return a reader from which the given layout file canbe read.subclasses of templateexporter are free to override and provide their ownimplementation.",
	"Method": "Reader getReader(String filename){\r\n    String dir;\r\n    if (customExport) {\r\n        dir = \"\";\r\n    } else {\r\n        dir = LAYOUT_PREFIX + (directory == null ? \"\" : directory + '/');\r\n    }\r\n    String name = dir + filename;\r\n    Reader reader;\r\n    URL reso = TemplateExporter.class.getResource(name);\r\n    try {\r\n        if (reso == null) {\r\n            File f = new File(name);\r\n            reader = new FileReader(f);\r\n        } else {\r\n            reader = new InputStreamReader(reso.openStream());\r\n        }\r\n    } catch (FileNotFoundException ex) {\r\n        throw new IOException(\"Cannot find layout file: '\" + name + \"'.\");\r\n    }\r\n    return reader;\r\n}"
}, {
	"Path": "com.datastax.driver.core.DefaultResultSetFuture.setResult",
	"Comment": "however, no particular reason to give users rope to hang themselves.",
	"Method": "void setResult(ResultSet rs){\r\n    set(rs);\r\n}"
}, {
	"Path": "com.datastax.driver.core.TokenIntegrationTest.should_expose_tokens_per_host",
	"Comment": "ensures that tokens are exposed for each host and that the match those in the system tables.also validates that tokens are not present for multiple hosts.",
	"Method": "void should_expose_tokens_per_host(){\r\n    for (Host host : cluster().getMetadata().allHosts()) {\r\n        assertThat(host.getTokens()).hasSize(numTokens);\r\n        boolean isControlHost = host.getSocketAddress().equals(cluster().manager.controlConnection.connectionRef.get().address);\r\n        Row row;\r\n        if (isControlHost) {\r\n            row = session().execute(\"select tokens from system.local\").one();\r\n        } else {\r\n            assertThat(host.getBroadcastSocketAddress()).isNotNull();\r\n            row = session().execute(\"select tokens from system.peers where peer = '\" + host.getBroadcastSocketAddress().getAddress().getHostAddress() + \"'\").one();\r\n        }\r\n        Set<String> tokenStrings = row.getSet(\"tokens\", String.class);\r\n        assertThat(tokenStrings).hasSize(numTokens);\r\n        Iterable<Token> tokensFromSystemTable = Iterables.transform(tokenStrings, new Function<String, Token>() {\r\n            @Override\r\n            public Token apply(String input) {\r\n                return tokenFactory().fromString(input);\r\n            }\r\n        });\r\n        assertThat(host.getTokens()).containsOnlyOnce(Iterables.toArray(tokensFromSystemTable, Token.class));\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.TokenIntegrationTest.should_expose_tokens_per_host",
	"Comment": "ensures that tokens are exposed for each host and that the match those in the system tables.also validates that tokens are not present for multiple hosts.",
	"Method": "void should_expose_tokens_per_host(){\r\n    return tokenFactory().fromString(input);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.AbstractResource.exists",
	"Comment": "this implementation checks whether a file can be opened, falling back towhether an inputstream can be opened. this will cover both directoriesand content resources.",
	"Method": "boolean exists(){\r\n    try {\r\n        return getFile().exists();\r\n    } catch (IOException ex) {\r\n        try (InputStream is = getInputStream()) {\r\n            return true;\r\n        } catch (Throwable isEx) {\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.openoffice.OOBibStyle.ensureUpToDate",
	"Comment": "if this style was initialized from a file on disk, reload the styleif the file has been modified since it was read.",
	"Method": "void ensureUpToDate(){\r\n    if (!isUpToDate()) {\r\n        reload();\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.TypeCodec.getCqlType",
	"Comment": "return the cql type that this codec deserializes from and serializes to.",
	"Method": "DataType getCqlType(){\r\n    return cqlType;\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.SchemaBuilder.leveledStrategy",
	"Comment": "create options for the leveled compaction strategy, to use in a create or alter tablestatement.",
	"Method": "TableOptions.CompactionOptions.LeveledCompactionStrategyOptions leveledStrategy(){\r\n    return new TableOptions.CompactionOptions.LeveledCompactionStrategyOptions();\r\n}"
}, {
	"Path": "org.elixir_lang.formatting.ModelBuilder.getRangeAffectingIndent",
	"Comment": "returns the textrange which should be processed by the formatter in order to calculate theindent for a new line when a line break is inserted at the specified offset.",
	"Method": "TextRange getRangeAffectingIndent(PsiFile file,int offset,ASTNode elementAtOffset){\r\n    return null;\r\n}"
}, {
	"Path": "com.datastax.driver.core.AbstractReplicationStrategyTest.host",
	"Comment": "convenience method to quickly create a mock host by a given address. specified address must beaccessible, otherwise a runtimeexception is thrown",
	"Method": "HostMock host(InetSocketAddress address,HostMock host,InetSocketAddress address,String dc,String rack){\r\n    return new HostMock(address, dc, rack, mockManager);\r\n}"
}, {
	"Path": "com.datastax.driver.core.TypeCodec.getJavaType",
	"Comment": "return the java type that this codec deserializes to and serializes from.",
	"Method": "TypeToken<T> getJavaType(){\r\n    return javaType;\r\n}"
}, {
	"Path": "org.jabref.gui.openoffice.OOBibBase.insertEntry",
	"Comment": "this method inserts a cite marker in the text for the given bibentry,and may refresh the bibliography.",
	"Method": "void insertEntry(List<BibEntry> entries,BibDatabase database,List<BibDatabase> allBases,OOBibStyle style,boolean inParenthesis,boolean withText,String pageInfo,boolean sync){\r\n    try {\r\n        XTextViewCursor xViewCursor = xViewCursorSupplier.getViewCursor();\r\n        if (entries.size() > 1) {\r\n            if (style.getBooleanCitProperty(OOBibStyle.MULTI_CITE_CHRONOLOGICAL)) {\r\n                entries.sort(yearAuthorTitleComparator);\r\n            } else {\r\n                entries.sort(entryComparator);\r\n            }\r\n        }\r\n        String keyString = String.join(\",\", entries.stream().map(entry -> entry.getCiteKeyOptional().orElse(\"\")).collect(Collectors.toList()));\r\n        String bName = getUniqueReferenceMarkName(keyString, withText ? inParenthesis ? OOBibBase.AUTHORYEAR_PAR : OOBibBase.AUTHORYEAR_INTEXT : OOBibBase.INVISIBLE_CIT);\r\n        if (pageInfo != null) {\r\n            LOGGER.info(\"Storing page info: \" + pageInfo);\r\n            setCustomProperty(bName, pageInfo);\r\n        }\r\n        xViewCursor.getText().insertString(xViewCursor, \" \", false);\r\n        if (style.isFormatCitations()) {\r\n            XPropertySet xCursorProps = UnoRuntime.queryInterface(XPropertySet.class, xViewCursor);\r\n            String charStyle = style.getCitationCharacterFormat();\r\n            try {\r\n                xCursorProps.setPropertyValue(CHAR_STYLE_NAME, charStyle);\r\n            } catch (UnknownPropertyException | PropertyVetoException | IllegalArgumentException | WrappedTargetException ex) {\r\n                xViewCursor.goLeft((short) 1, true);\r\n                xViewCursor.setString(\"\");\r\n                throw new UndefinedCharacterFormatException(charStyle);\r\n            }\r\n        }\r\n        xViewCursor.goLeft((short) 1, false);\r\n        Map<BibEntry, BibDatabase> databaseMap = new HashMap();\r\n        for (BibEntry entry : entries) {\r\n            databaseMap.put(entry, database);\r\n        }\r\n        String citeText = style.isNumberEntries() ? \"-\" : style.getCitationMarker(entries, databaseMap, inParenthesis, null, null);\r\n        insertReferenceMark(bName, citeText, xViewCursor, withText, style);\r\n        xViewCursor.collapseToEnd();\r\n        xViewCursor.goRight((short) 1, false);\r\n        XTextRange position = xViewCursor.getEnd();\r\n        if (sync) {\r\n            updateSortedReferenceMarks();\r\n            refreshCiteMarkers(allBases, style);\r\n            rebuildBibTextSection(allBases, style);\r\n        }\r\n        xViewCursor.gotoRange(position, false);\r\n    } catch (DisposedException ex) {\r\n        throw new ConnectionLostException(ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.reflect.Reflection.registerReflectiveClass",
	"Comment": "registers a reflective class.the field accesses to the instancesof this class are instrumented.",
	"Method": "void registerReflectiveClass(CtClass clazz){\r\n    CtField[] fs = clazz.getDeclaredFields();\r\n    for (int i = 0; i < fs.length; ++i) {\r\n        CtField f = fs[i];\r\n        int mod = f.getModifiers();\r\n        if ((mod & Modifier.PUBLIC) != 0 && (mod & Modifier.FINAL) == 0) {\r\n            String name = f.getName();\r\n            converter.replaceFieldRead(f, clazz, readPrefix + name);\r\n            converter.replaceFieldWrite(f, clazz, writePrefix + name);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.ConditionChecker.await",
	"Comment": "waits until the predicate becomes true, or a timeout occurs, whichever happens first.",
	"Method": "void await(long timeout,TimeUnit unit){\r\n    boolean interrupted = false;\r\n    long nanos = unit.toNanos(timeout);\r\n    lock.lock();\r\n    try {\r\n        while (!evalCondition()) {\r\n            if (nanos <= 0L)\r\n                fail(String.format(\"Timeout after %s %s while waiting for condition\", timeout, unit.toString().toLowerCase()));\r\n            try {\r\n                nanos = condition.awaitNanos(nanos);\r\n            } catch (InterruptedException e) {\r\n                interrupted = true;\r\n            }\r\n        }\r\n    } finally {\r\n        timer.cancel();\r\n        if (interrupted)\r\n            Thread.currentThread().interrupt();\r\n    }\r\n}"
}, {
	"Path": "com.beust.jcommander.JCommander.getParsedAlias",
	"Comment": "the name of the command or the alias in the form it waspassed to the command line. null if nocommand or alias was specified.",
	"Method": "String getParsedAlias(){\r\n    return parsedAlias;\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    final List<FoldingDescriptor> foldingDescriptorList = new ArrayList<FoldingDescriptor>();\r\n    PsiTreeUtil.processElements(root, new PsiElementProcessor() {\r\n        private Map<String, FoldingGroup> foldingGroupByModuleAttributeName = new HashMap<String, FoldingGroup>();\r\n        @Override\r\n        public boolean execute(@NotNull PsiElement element) {\r\n            boolean keepProcessing = true;\r\n            if (element instanceof AtNonNumericOperation) {\r\n                keepProcessing = execute((AtNonNumericOperation) element);\r\n            } else if (element instanceof AtUnqualifiedNoParenthesesCall) {\r\n                keepProcessing = execute((AtUnqualifiedNoParenthesesCall) element);\r\n            } else if (element instanceof ElixirDoBlock) {\r\n                keepProcessing = execute((ElixirDoBlock) element);\r\n            } else if (element instanceof ElixirStabOperation) {\r\n                keepProcessing = execute((ElixirStabOperation) element);\r\n            } else if (element instanceof Call) {\r\n                keepProcessing = execute((Call) element);\r\n            }\r\n            return keepProcessing;\r\n        }\r\n        private boolean execute(@NotNull AtNonNumericOperation atNonNumericOperation) {\r\n            boolean keepProcessing = true;\r\n            if (!quick) {\r\n                keepProcessing = slowExecute(atNonNumericOperation);\r\n            }\r\n            return keepProcessing;\r\n        }\r\n        private boolean execute(@NotNull AtUnqualifiedNoParenthesesCall atUnqualifiedNoParenthesesCall) {\r\n            String moduleAttributeName = moduleAttributeName(atUnqualifiedNoParenthesesCall);\r\n            String name = moduleAttributeName.substring(1);\r\n            if (ModuleAttribute.Companion.isDocumentationName(name)) {\r\n                ElixirNoParenthesesOneArgument noParenthesesOneArgument = atUnqualifiedNoParenthesesCall.getNoParenthesesOneArgument();\r\n                foldingDescriptorList.add(new NamedFoldingDescriptor(noParenthesesOneArgument.getNode(), noParenthesesOneArgument.getTextRange(), null, \"\\\"...\\\"\"));\r\n            } else if (ModuleAttribute.Companion.isTypeName(name)) {\r\n                ElixirNoParenthesesOneArgument noParenthesesOneArgument = atUnqualifiedNoParenthesesCall.getNoParenthesesOneArgument();\r\n                PsiElement[] children = noParenthesesOneArgument.getChildren();\r\n                if (children.length == 1) {\r\n                    PsiElement child = children[0];\r\n                    if (child instanceof Type) {\r\n                        Type type = (Type) child;\r\n                        PsiElement rightOperand = Normalized.rightOperand(type);\r\n                        if (rightOperand != null) {\r\n                            foldingDescriptorList.add(new NamedFoldingDescriptor(rightOperand.getNode(), rightOperand.getTextRange(), null, \"...\"));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        private boolean execute(@NotNull Call call) {\r\n            for (String resolvedFunctionName : RESOLVED_FUNCTION_NAMES) {\r\n                if (call.isCalling(KERNEL, resolvedFunctionName)) {\r\n                    if (isFirstInGroup(call, KERNEL, resolvedFunctionName)) {\r\n                        Call last = lastInGroup(call, KERNEL, resolvedFunctionName);\r\n                        PsiElement[] finalArguments = finalArguments(call);\r\n                        if (finalArguments != null && finalArguments.length >= 1) {\r\n                            TextRange textRange = new TextRange(finalArguments[0].getTextOffset(), last.getTextRange().getEndOffset());\r\n                            foldingDescriptorList.add(new NamedFoldingDescriptor(call.getParent().getNode(), textRange, null, \"...\"));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        private boolean execute(@NotNull ElixirDoBlock doBlock) {\r\n            foldingDescriptorList.add(new FoldingDescriptor(doBlock, doBlock.getTextRange()));\r\n            return true;\r\n        }\r\n        private boolean execute(@NotNull ElixirStabOperation stabOperation) {\r\n            int startOffset = stabOperation.operator().getTextOffset();\r\n            int endOffset = stabOperation.getTextRange().getEndOffset();\r\n            TextRange textRange = new TextRange(startOffset, endOffset);\r\n            foldingDescriptorList.add(new FoldingDescriptor(stabOperation, textRange));\r\n            return true;\r\n        }\r\n        private boolean isFirstInGroup(@NotNull Call call, @NotNull String resolvedModuleName, @NotNull String resolvedFunctionName) {\r\n            PsiElement previousSiblingExpression = previousSiblingExpression(call);\r\n            boolean first = true;\r\n            if (previousSiblingExpression instanceof Call) {\r\n                Call previousSiblingExpressionCall = (Call) previousSiblingExpression;\r\n                first = !previousSiblingExpressionCall.isCalling(resolvedModuleName, resolvedFunctionName);\r\n            }\r\n            return first;\r\n        }\r\n        @NotNull\r\n        private Call lastInGroup(@NotNull Call first, @NotNull String resolvedModuleName, @NotNull String resolvedFunctionName) {\r\n            PsiElement expression = first;\r\n            Call last = first;\r\n            while (true) {\r\n                expression = siblingExpression(expression, NEXT_SIBLING);\r\n                if (expression instanceof Call) {\r\n                    Call call = (Call) expression;\r\n                    if (call.isCalling(resolvedModuleName, resolvedFunctionName)) {\r\n                        last = call;\r\n                        continue;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            return last;\r\n        }\r\n        private boolean slowExecute(@NotNull AtNonNumericOperation atNonNumericOperation) {\r\n            boolean keepProcessing = true;\r\n            PsiReference reference = atNonNumericOperation.getReference();\r\n            if (reference != null) {\r\n                keepProcessing = slowExecute(atNonNumericOperation, reference);\r\n            }\r\n            return keepProcessing;\r\n        }\r\n        private boolean slowExecute(@NotNull AtNonNumericOperation atNonNumericOperation, @NotNull final AtUnqualifiedNoParenthesesCall atUnqualifiedNoParenthesesCall) {\r\n            return slowExecute(atNonNumericOperation, atUnqualifiedNoParenthesesCall, atUnqualifiedNoParenthesesCall.getNoParenthesesOneArgument().getText());\r\n        }\r\n        private boolean slowExecute(@NotNull AtNonNumericOperation atNonNumericOperation, @NotNull PsiElement target) {\r\n            boolean keepProcessing = true;\r\n            if (target instanceof AtUnqualifiedNoParenthesesCall) {\r\n                keepProcessing = slowExecute(atNonNumericOperation, (AtUnqualifiedNoParenthesesCall) target);\r\n            } else if (target instanceof QualifiableAlias) {\r\n                keepProcessing = slowExecute(atNonNumericOperation, (QualifiableAlias) target);\r\n            }\r\n            return keepProcessing;\r\n        }\r\n        private boolean slowExecute(@NotNull AtNonNumericOperation atNonNumericOperation, @NotNull PsiReference reference) {\r\n            PsiElement target = reference.resolve();\r\n            boolean keepProcessing = true;\r\n            if (target != null) {\r\n                keepProcessing = slowExecute(atNonNumericOperation, target);\r\n            }\r\n            return keepProcessing;\r\n        }\r\n        private boolean slowExecute(@NotNull AtNonNumericOperation atNonNumericOperation, @NotNull final QualifiableAlias qualifiableAlias) {\r\n            return slowExecute(atNonNumericOperation, qualifiableAlias, qualifiableAlias.getName());\r\n        }\r\n        private boolean slowExecute(@NotNull AtNonNumericOperation atNonNumericOperation, @NotNull PsiElement element, @Nullable final String placeHolderText) {\r\n            String moduleAttributeName = atNonNumericOperation.moduleAttributeName();\r\n            FoldingGroup foldingGroup = foldingGroupByModuleAttributeName.computeIfAbsent(moduleAttributeName, FoldingGroup::newGroup);\r\n            foldingDescriptorList.add(new FoldingDescriptor(atNonNumericOperation.getNode(), atNonNumericOperation.getTextRange(), foldingGroup, Collections.singleton(element)) {\r\n                @Nullable\r\n                @Override\r\n                public String getPlaceholderText() {\r\n                    return placeHolderText;\r\n                }\r\n            });\r\n            return true;\r\n        }\r\n    });\r\n    return foldingDescriptorList.toArray(new FoldingDescriptor[foldingDescriptorList.size()]);\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    boolean keepProcessing = true;\r\n    if (element instanceof AtNonNumericOperation) {\r\n        keepProcessing = execute((AtNonNumericOperation) element);\r\n    } else if (element instanceof AtUnqualifiedNoParenthesesCall) {\r\n        keepProcessing = execute((AtUnqualifiedNoParenthesesCall) element);\r\n    } else if (element instanceof ElixirDoBlock) {\r\n        keepProcessing = execute((ElixirDoBlock) element);\r\n    } else if (element instanceof ElixirStabOperation) {\r\n        keepProcessing = execute((ElixirStabOperation) element);\r\n    } else if (element instanceof Call) {\r\n        keepProcessing = execute((Call) element);\r\n    }\r\n    return keepProcessing;\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    boolean keepProcessing = true;\r\n    if (!quick) {\r\n        keepProcessing = slowExecute(atNonNumericOperation);\r\n    }\r\n    return keepProcessing;\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    String moduleAttributeName = moduleAttributeName(atUnqualifiedNoParenthesesCall);\r\n    String name = moduleAttributeName.substring(1);\r\n    if (ModuleAttribute.Companion.isDocumentationName(name)) {\r\n        ElixirNoParenthesesOneArgument noParenthesesOneArgument = atUnqualifiedNoParenthesesCall.getNoParenthesesOneArgument();\r\n        foldingDescriptorList.add(new NamedFoldingDescriptor(noParenthesesOneArgument.getNode(), noParenthesesOneArgument.getTextRange(), null, \"\\\"...\\\"\"));\r\n    } else if (ModuleAttribute.Companion.isTypeName(name)) {\r\n        ElixirNoParenthesesOneArgument noParenthesesOneArgument = atUnqualifiedNoParenthesesCall.getNoParenthesesOneArgument();\r\n        PsiElement[] children = noParenthesesOneArgument.getChildren();\r\n        if (children.length == 1) {\r\n            PsiElement child = children[0];\r\n            if (child instanceof Type) {\r\n                Type type = (Type) child;\r\n                PsiElement rightOperand = Normalized.rightOperand(type);\r\n                if (rightOperand != null) {\r\n                    foldingDescriptorList.add(new NamedFoldingDescriptor(rightOperand.getNode(), rightOperand.getTextRange(), null, \"...\"));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    for (String resolvedFunctionName : RESOLVED_FUNCTION_NAMES) {\r\n        if (call.isCalling(KERNEL, resolvedFunctionName)) {\r\n            if (isFirstInGroup(call, KERNEL, resolvedFunctionName)) {\r\n                Call last = lastInGroup(call, KERNEL, resolvedFunctionName);\r\n                PsiElement[] finalArguments = finalArguments(call);\r\n                if (finalArguments != null && finalArguments.length >= 1) {\r\n                    TextRange textRange = new TextRange(finalArguments[0].getTextOffset(), last.getTextRange().getEndOffset());\r\n                    foldingDescriptorList.add(new NamedFoldingDescriptor(call.getParent().getNode(), textRange, null, \"...\"));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    foldingDescriptorList.add(new FoldingDescriptor(doBlock, doBlock.getTextRange()));\r\n    return true;\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    int startOffset = stabOperation.operator().getTextOffset();\r\n    int endOffset = stabOperation.getTextRange().getEndOffset();\r\n    TextRange textRange = new TextRange(startOffset, endOffset);\r\n    foldingDescriptorList.add(new FoldingDescriptor(stabOperation, textRange));\r\n    return true;\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    PsiElement previousSiblingExpression = previousSiblingExpression(call);\r\n    boolean first = true;\r\n    if (previousSiblingExpression instanceof Call) {\r\n        Call previousSiblingExpressionCall = (Call) previousSiblingExpression;\r\n        first = !previousSiblingExpressionCall.isCalling(resolvedModuleName, resolvedFunctionName);\r\n    }\r\n    return first;\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    PsiElement expression = first;\r\n    Call last = first;\r\n    while (true) {\r\n        expression = siblingExpression(expression, NEXT_SIBLING);\r\n        if (expression instanceof Call) {\r\n            Call call = (Call) expression;\r\n            if (call.isCalling(resolvedModuleName, resolvedFunctionName)) {\r\n                last = call;\r\n                continue;\r\n            }\r\n        }\r\n        break;\r\n    }\r\n    return last;\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    boolean keepProcessing = true;\r\n    PsiReference reference = atNonNumericOperation.getReference();\r\n    if (reference != null) {\r\n        keepProcessing = slowExecute(atNonNumericOperation, reference);\r\n    }\r\n    return keepProcessing;\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    return slowExecute(atNonNumericOperation, atUnqualifiedNoParenthesesCall, atUnqualifiedNoParenthesesCall.getNoParenthesesOneArgument().getText());\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    boolean keepProcessing = true;\r\n    if (target instanceof AtUnqualifiedNoParenthesesCall) {\r\n        keepProcessing = slowExecute(atNonNumericOperation, (AtUnqualifiedNoParenthesesCall) target);\r\n    } else if (target instanceof QualifiableAlias) {\r\n        keepProcessing = slowExecute(atNonNumericOperation, (QualifiableAlias) target);\r\n    }\r\n    return keepProcessing;\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    PsiElement target = reference.resolve();\r\n    boolean keepProcessing = true;\r\n    if (target != null) {\r\n        keepProcessing = slowExecute(atNonNumericOperation, target);\r\n    }\r\n    return keepProcessing;\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    return slowExecute(atNonNumericOperation, qualifiableAlias, qualifiableAlias.getName());\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    String moduleAttributeName = atNonNumericOperation.moduleAttributeName();\r\n    FoldingGroup foldingGroup = foldingGroupByModuleAttributeName.computeIfAbsent(moduleAttributeName, FoldingGroup::newGroup);\r\n    foldingDescriptorList.add(new FoldingDescriptor(atNonNumericOperation.getNode(), atNonNumericOperation.getTextRange(), foldingGroup, Collections.singleton(element)) {\r\n        @Nullable\r\n        @Override\r\n        public String getPlaceholderText() {\r\n            return placeHolderText;\r\n        }\r\n    });\r\n    return true;\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.buildFoldRegions",
	"Comment": "builds the folding regions for the specified node in the ast tree and its children.",
	"Method": "FoldingDescriptor[] buildFoldRegions(PsiElement root,Document document,boolean quick){\r\n    return placeHolderText;\r\n}"
}, {
	"Path": "org.jabref.model.database.BibDatabase.getStringValues",
	"Comment": "returns a collection of all bibtexstring objects in the database.these are in no particular order.",
	"Method": "Collection<BibtexString> getStringValues(){\r\n    return bibtexStrings.values();\r\n}"
}, {
	"Path": "com.datastax.driver.core.SSLEncryptionTest.should_connect_with_ssl_without_client_auth_and_node_doesnt_require_auth",
	"Comment": "validates that an ssl connection can be established without client auth if the target cassandracluster is using ssl and does not require auth.",
	"Method": "void should_connect_with_ssl_without_client_auth_and_node_doesnt_require_auth(SslImplementation sslImplementation){\r\n    connectWithSSLOptions(getSSLOptions(sslImplementation, false, true));\r\n}"
}, {
	"Path": "org.jabref.gui.plaintextimport.TagToMarkedTextStore.insertPosition",
	"Comment": "insert selection properties for tag, old entries were deleted",
	"Method": "void insertPosition(String tag,int start,int end){\r\n    List<TMarkedStoreItem> ll = tagMap.get(tag);\r\n    if (ll == null) {\r\n        ll = new ArrayList();\r\n        tagMap.put(tag, ll);\r\n    } else {\r\n        ll.clear();\r\n    }\r\n    ll.add(new TMarkedStoreItem(start, end));\r\n}"
}, {
	"Path": "org.jabref.gui.preferences.NameFormatterTab.storeSettings",
	"Comment": "store changes to table preferences. this method is called when the userclicks ok.",
	"Method": "void storeSettings(){\r\n    if (tableChanged) {\r\n        int i = 0;\r\n        while (i < tableRows.size()) {\r\n            if (tableRows.get(i).getName().isEmpty()) {\r\n                tableRows.remove(i);\r\n            } else {\r\n                i++;\r\n            }\r\n        }\r\n        List<String> names = new ArrayList(tableRows.size());\r\n        List<String> formats = new ArrayList(tableRows.size());\r\n        for (TableRow tr : tableRows) {\r\n            names.add(tr.getName());\r\n            formats.add(tr.getFormat());\r\n        }\r\n        prefs.putStringList(JabRefPreferences.NAME_FORMATER_KEY, names);\r\n        prefs.putStringList(JabRefPreferences.NAME_FORMATTER_VALUE, formats);\r\n    }\r\n}"
}, {
	"Path": "org.elixir_lang.parser.ElixirParser.matchedQualifiedParenthesesCall_0",
	"Comment": "dotinfixoperator relativeidentifier matchedparenthesesarguments",
	"Method": "boolean matchedQualifiedParenthesesCall_0(PsiBuilder b,int l){\r\n    if (!recursion_guard_(b, l, \"matchedQualifiedParenthesesCall_0\"))\r\n        return false;\r\n    boolean r;\r\n    Marker m = enter_section_(b);\r\n    r = dotInfixOperator(b, l + 1);\r\n    r = r && relativeIdentifier(b, l + 1);\r\n    r = r && matchedParenthesesArguments(b, l + 1);\r\n    exit_section_(b, m, null, r);\r\n    return r;\r\n}"
}, {
	"Path": "me.ramswaroop.jbot.core.slack.Bot.isConversationOn",
	"Comment": "check whether a conversation is up in a particular slack channel.",
	"Method": "boolean isConversationOn(Event event){\r\n    return isConversationOn(event.getChannelId());\r\n}"
}, {
	"Path": "com.datastax.driver.core.HeartbeatTest.should_send_heartbeat_when_requests_being_written_but_nothing_received",
	"Comment": "ensures that a heartbeat message is sent after the configured heartbeat interval of idle timewhen no data is received on a connection even though are successful writes on the socket.",
	"Method": "void should_send_heartbeat_when_requests_being_written_but_nothing_received(){\r\n    Cluster cluster = Cluster.builder().addContactPoints(hostAddress.getAddress()).withPort(scassandra.getBinaryPort()).withPoolingOptions(new PoolingOptions().setHeartbeatIntervalSeconds(3).setConnectionsPerHost(HostDistance.LOCAL, 1, 1)).build();\r\n    scassandra.primingClient().prime(queryBuilder().withQuery(\"ping\").withThen(then().withFixedDelay(8675309999L)));\r\n    Thread submitter = null;\r\n    try {\r\n        cluster.init();\r\n        SessionManager session = (SessionManager) cluster.connect();\r\n        Host host = TestUtils.findHost(cluster, 1);\r\n        Connection connection = session.pools.get(host).connections.get(0);\r\n        String connectionName = // Replace - with \\- so its properly escaped as a regex.\r\n        connection.toString().replaceAll(\"\\\\-\", // Replace first part of toString (Connection[\r\n        \"\\\\\\\\-\").replaceAll(\"Connection\\\\[\\\\/\", // Replace everything after ',inFlight'\r\n        \"\").replaceAll(\"\\\\, inFlight.*\", \"\");\r\n        Pattern heartbeatSentPattern = Pattern.compile(\".*\" + connectionName + \".*sending heartbeat\");\r\n        Pattern heartbeatReceivedPattern = Pattern.compile(\".*\" + connectionName + \".*heartbeat query succeeded\");\r\n        logger.debug(\"Heartbeat pattern is {}\", heartbeatSentPattern);\r\n        submitter = new Thread(new QuerySubmitter(session));\r\n        submitter.start();\r\n        for (int i = 0; i < 5; i++) {\r\n            session.execute(\"bar\");\r\n            SECONDS.sleep(1);\r\n        }\r\n        String log = logs.getNext();\r\n        assertNoLineMatches(log, heartbeatSentPattern);\r\n        int inFlight = connection.inFlight.get();\r\n        assertThat(inFlight).isGreaterThan(0);\r\n        SECONDS.sleep(4);\r\n        assertThat(connection.inFlight.get()).isGreaterThan(inFlight);\r\n        log = logs.getNext();\r\n        assertLineMatches(log, heartbeatSentPattern);\r\n        assertLineMatches(log, heartbeatReceivedPattern);\r\n    } finally {\r\n        if (submitter != null) {\r\n            submitter.interrupt();\r\n        }\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.fieldeditors.contextmenu.EditorMenus.getCleanupURLMenu",
	"Comment": "the default context menu with a specific menu item to cleanup url.",
	"Method": "Supplier<List<MenuItem>> getCleanupURLMenu(TextArea textArea){\r\n    return () -> {\r\n        CustomMenuItem cleanupURL = new CustomMenuItem(new Label(Localization.lang(\"Cleanup URL link\")));\r\n        cleanupURL.setDisable(textArea.textProperty().isEmpty().get());\r\n        cleanupURL.setOnAction(event -> textArea.setText(new CleanupURLFormatter().format(textArea.getText())));\r\n        List<MenuItem> menuItems = new ArrayList();\r\n        menuItems.add(cleanupURL);\r\n        return menuItems;\r\n    };\r\n}"
}, {
	"Path": "com.datastax.driver.core.exceptions.ReadWriteFailureExceptionTest.should_readFailure_on_tombstone_overwelmed",
	"Comment": "validates that readfailureexception occurs, and that in the case of protocol v5 the reason mapis surfaced appropriately on the exception.",
	"Method": "void should_readFailure_on_tombstone_overwelmed(){\r\n    session().execute(\"CREATE KEYSPACE ks_read_fail WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1}\");\r\n    session().execute(\"CREATE TABLE ks_read_fail.foo(pk int, cc int, v int, primary key (pk, cc))\");\r\n    PreparedStatement prepared = session().prepare(\"INSERT INTO ks_read_fail.foo (pk, cc, v) VALUES (1, ?, null)\");\r\n    for (int v = 0; v < 2000; v++) {\r\n        BoundStatement bound = prepared.bind(v);\r\n        session().execute(bound);\r\n    }\r\n    try {\r\n        ResultSet result = session().execute(\"SELECT * FROM ks_read_fail.foo WHERE pk = 1\");\r\n        fail(\"A ReadFailureException should have been thrown here\");\r\n    } catch (ReadFailureException e) {\r\n        if (cluster().getConfiguration().getProtocolOptions().getProtocolVersion().compareTo(ProtocolVersion.V5) >= 0) {\r\n            assertThat(e.getFailuresMap()).hasSize(1).containsValue(1);\r\n        } else {\r\n            assertThat(e.getFailuresMap()).isEmpty();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.weld.command.BeanClassRefreshAgent.reloadBean",
	"Comment": "reload bean according strategy, reinject bean instances. called from beanclassrefreshcommand.",
	"Method": "void reloadBean(ClassLoader classLoader,String archivePath,String beanClassName,Map<String, String> oldFullSignatures,Map<String, String> oldSignatures,String strReloadStrategy){\r\n    BeanClassRefreshAgent bdaAgent = BdaAgentRegistry.get(archivePath);\r\n    if (bdaAgent == null) {\r\n        LOGGER.error(\"Archive path '{}' is not associated with any BeanClassRefreshAgent\", archivePath);\r\n        return;\r\n    }\r\n    ClassLoader oldContextClassLoader = Thread.currentThread().getContextClassLoader();\r\n    try {\r\n        Thread.currentThread().setContextClassLoader(classLoader);\r\n        Class<?> beanClass = bdaAgent.getClass().getClassLoader().loadClass(beanClassName);\r\n        BeanManagerImpl beanManager;\r\n        if (CDI.current().getBeanManager() instanceof BeanManagerImpl) {\r\n            beanManager = ((BeanManagerImpl) CDI.current().getBeanManager()).unwrap();\r\n        } else {\r\n            beanManager = ((BeanManagerProxy) CDI.current().getBeanManager()).unwrap();\r\n        }\r\n        ClassLoader beanManagerClassLoader = beanManager.getClass().getClassLoader();\r\n        Class<?> bdaAgentClazz = Class.forName(BeanReloadExecutor.class.getName(), true, beanManagerClassLoader);\r\n        ReflectionHelper.invoke(null, bdaAgentClazz, \"reloadBean\", new Class[] { String.class, Class.class, Map.class, Map.class, String.class }, bdaAgent.getBdaId(), beanClass, oldFullSignatures, oldSignatures, strReloadStrategy);\r\n    } catch (Exception e) {\r\n        LOGGER.error(\"Bean reloading failed.\", e);\r\n    } finally {\r\n        reloadFlag = false;\r\n        Thread.currentThread().setContextClassLoader(oldContextClassLoader);\r\n    }\r\n}"
}, {
	"Path": "org.menacheri.jetserver.concurrent.Fibers.pooledFiber",
	"Comment": "creates and starts a fiber and returns the created instance.",
	"Method": "Fiber pooledFiber(Fiber pooledFiber,Lane<String, ExecutorService> lane){\r\n    if (null == lanePoolFactoryMap.get(lane)) {\r\n        lanePoolFactoryMap.putIfAbsent(lane, new PoolFiberFactory(lane.getUnderlyingLane()));\r\n    }\r\n    Fiber fiber = lanePoolFactoryMap.get(lane).create();\r\n    fiber.start();\r\n    return fiber;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.mapper.Mappers.findFor",
	"Comment": "obtain a mapper for the given qualified type. if the type is unqualified,and a row mapper is registered for the given type, it is returned. if acolumn mapper is registered for the given qualified type, it is adaptedinto a row mapper, mapping the first column of the result set. if neithera row or column mapper is registered, empty is returned.",
	"Method": "Optional<RowMapper<T>> findFor(Class<T> type,Optional<RowMapper<T>> findFor,GenericType<T> type,Optional<RowMapper<?>> findFor,Type type,Optional<RowMapper<?>> findFor,QualifiedType type){\r\n    if (type.getQualifiers().isEmpty()) {\r\n        Optional<RowMapper<?>> result = rowMappers.findFor(type.getType());\r\n        if (result.isPresent()) {\r\n            return result;\r\n        }\r\n    }\r\n    return columnMappers.findFor(type).map(SingleColumnMapper::new);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.ReflectionHelper.set",
	"Comment": "convenience wrapper to reflection method invoke api. set field value and hide checked exceptions.",
	"Method": "void set(Object target,Class<?> clazz,String fieldName,Object value){\r\n    try {\r\n        Field field = clazz.getDeclaredField(fieldName);\r\n        field.setAccessible(true);\r\n        field.set(target, value);\r\n    } catch (NoSuchFieldException e) {\r\n        throw new IllegalArgumentException(String.format(\"No such field %s.%s on %s\", clazz.getName(), fieldName, target), e);\r\n    } catch (IllegalAccessException e) {\r\n        throw new IllegalArgumentException(String.format(\"Illegal access field %s.%s on %s\", clazz.getName(), fieldName, target), e);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.java.CtClassJavaProxyGenerator.generateProxyClass",
	"Comment": "generate a proxy class given a name and a list of proxy interfaces.",
	"Method": "byte[] generateProxyClass(String name,CtClass[] interfaces,ClassPool cp,byte[] generateProxyClass,String name,CtClass[] interfaces,ClassPool cp,int accessFlags){\r\n    CtClassJavaProxyGenerator gen = new CtClassJavaProxyGenerator(name, interfaces, cp, accessFlags);\r\n    final byte[] classFile = gen.generateClassFile();\r\n    return classFile;\r\n}"
}, {
	"Path": "com.datastax.driver.core.MaterializedViewMetadata.setBaseTable",
	"Comment": "updates the base table for this view and adds it to that table. this is used when a tableupdate is processed and the views need to be carried over.",
	"Method": "void setBaseTable(TableMetadata table){\r\n    this.baseTable = table;\r\n    table.add(this);\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.AbstractCreateStatement.addUDTColumn",
	"Comment": "add a column definition to this create statement, when the type contains a udt.",
	"Method": "T addUDTColumn(String columnName,UDTType udtType){\r\n    validateNotEmpty(columnName, \"Column name\");\r\n    validateNotNull(udtType, \"Column type\");\r\n    validateNotKeyWord(columnName, String.format(\"The column name '%s' is not allowed because it is a reserved keyword\", columnName));\r\n    simpleColumns.put(columnName, udtType);\r\n    return self;\r\n}"
}, {
	"Path": "org.jabref.logic.shared.DBMSProcessor.removeSharedFieldsByDifference",
	"Comment": "helping method. removes shared fields which do not exist locally",
	"Method": "void removeSharedFieldsByDifference(BibEntry localBibEntry,BibEntry sharedBibEntry){\r\n    Set<String> nullFields = new HashSet(sharedBibEntry.getFieldNames());\r\n    nullFields.removeAll(localBibEntry.getFieldNames());\r\n    for (String nullField : nullFields) {\r\n        StringBuilder deleteFieldQuery = new StringBuilder().append(\"DELETE FROM \").append(escape(\"FIELD\")).append(\" WHERE \").append(escape(\"NAME\")).append(\" = ? AND \").append(escape(\"ENTRY_SHARED_ID\")).append(\" = ?\");\r\n        try (PreparedStatement preparedDeleteFieldStatement = connection.prepareStatement(deleteFieldQuery.toString())) {\r\n            preparedDeleteFieldStatement.setString(1, nullField);\r\n            preparedDeleteFieldStatement.setInt(2, localBibEntry.getSharedBibEntryData().getSharedID());\r\n            preparedDeleteFieldStatement.executeUpdate();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.openoffice.OpenOfficePreferences.getSyncWhenCiting",
	"Comment": "true if the reference list is updated when adding a new citation",
	"Method": "Boolean getSyncWhenCiting(){\r\n    return syncWhenCiting;\r\n}"
}, {
	"Path": "org.jabref.gui.BasePanel.setCurrentSearchQuery",
	"Comment": "set the query the user currently searches while this basepanel is active",
	"Method": "void setCurrentSearchQuery(SearchQuery currentSearchQuery){\r\n    this.currentSearchQuery = Optional.ofNullable(currentSearchQuery);\r\n}"
}, {
	"Path": "com.github.javafaker.service.FakeValuesService.resolveExpression",
	"Comment": "search ordersearch for methods on the current objectlocal keys in yaml filesearch for methods on faker child objectssearch for keys in yaml file by transforming object reference to yaml reference",
	"Method": "String resolveExpression(String expression,Object current,Faker root,String resolveExpression,String directive,List<String> args,Object current,Faker root){\r\n    final String simpleDirective = (isDotDirective(directive) || current == null) ? directive : classNameToYamlName(current) + \".\" + directive;\r\n    String resolved = null;\r\n    if (!isDotDirective(directive)) {\r\n        resolved = resolveFromMethodOn(current, directive, args);\r\n    }\r\n    if (resolved == null) {\r\n        resolved = safeFetch(simpleDirective, null);\r\n    }\r\n    if (resolved == null && !isDotDirective(directive)) {\r\n        resolved = resolveFromMethodOn(root, directive, args);\r\n    }\r\n    if (resolved == null && isDotDirective(directive)) {\r\n        resolved = resolveFakerObjectAndMethod(root, directive, args);\r\n    }\r\n    if (resolved == null && isDotDirective(directive)) {\r\n        resolved = safeFetch(javaNameToYamlName(simpleDirective), null);\r\n    }\r\n    return resolved;\r\n}"
}, {
	"Path": "com.datastax.driver.core.policies.LoggingRetryPolicy.logDecision",
	"Comment": "logs the decision according to the given template and parameters. the log level is info, butsubclasses may override.",
	"Method": "void logDecision(String template,Object parameters){\r\n    logger.info(template, parameters);\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fileformat.RepecNepImporter.readMultipleLines",
	"Comment": "read multiple lines.reads multiple lines until eitheran empty linethe end of filethe next working paper ora keywordis found. whitespace at start or end of lines is trimmed except for one blank character.",
	"Method": "String readMultipleLines(BufferedReader in){\r\n    StringBuilder result = new StringBuilder(this.lastLine.trim());\r\n    readLine(in);\r\n    while ((this.lastLine != null) && !\"\".equals(this.lastLine.trim()) && !startsWithKeyword(RepecNepImporter.RECOGNIZED_FIELDS) && !isStartOfWorkingPaper()) {\r\n        result.append(this.lastLine.isEmpty() ? this.lastLine.trim() : \" \" + this.lastLine.trim());\r\n        readLine(in);\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "org.jabref.gui.JabRefFrame.setEnabled",
	"Comment": "takes a list of object and calls the method setenabled on them, depending on whether it is an action or acomponent.",
	"Method": "void setEnabled(List<Object> list,boolean enabled){\r\n    for (Object actionOrComponent : list) {\r\n        if (actionOrComponent instanceof Action) {\r\n            ((Action) actionOrComponent).setEnabled(enabled);\r\n        }\r\n        if (actionOrComponent instanceof Component) {\r\n            ((Component) actionOrComponent).setEnabled(enabled);\r\n            if (actionOrComponent instanceof JPanel) {\r\n                JPanel root = (JPanel) actionOrComponent;\r\n                for (int index = 0; index < root.getComponentCount(); index++) {\r\n                    root.getComponent(index).setEnabled(enabled);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.ParseUtils.isLongLiteral",
	"Comment": "check whether the given string corresponds to a valid cql long literal. long literals arecomposed solely by digits, but can have an optional leading minus sign.",
	"Method": "boolean isLongLiteral(String str){\r\n    if (str == null || str.isEmpty())\r\n        return false;\r\n    char[] chars = str.toCharArray();\r\n    for (int i = 0; i < chars.length; i++) {\r\n        char c = chars[i];\r\n        if ((c < '0' && (i != 0 || c != '-')) || c > '9')\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.StatementContext.getConfig",
	"Comment": "gets the configuration object of the given type, associated with this context.",
	"Method": "C getConfig(Class<C> configClass,ConfigRegistry getConfig){\r\n    return config;\r\n}"
}, {
	"Path": "com.datastax.driver.core.ConsistencyTest.should_use_query_option_cl",
	"Comment": "exhaustively tests all consistency levels when they are set via queryoptions.",
	"Method": "void should_use_query_option_cl(ConsistencyLevel cl){\r\n    Cluster cluster = builder().withQueryOptions(new QueryOptions().setConsistencyLevel(cl)).build();\r\n    try {\r\n        Session session = cluster.connect();\r\n        String queryString = \"query_cl\";\r\n        Query clQuery = executeSimple(session, queryString, null, null);\r\n        assertTrue(clQuery.getConsistency().equals(cl.toString()));\r\n        String prepareString = \"preapred_query_cl\";\r\n        PreparedStatementExecution pse = executePrepared(session, prepareString, null, null);\r\n        assertTrue(pse.getConsistency().equals(cl.toString()));\r\n        String batchStateString = \"batch_query_cl\";\r\n        BatchExecution batch = executeBatch(session, batchStateString, null, null);\r\n        assertTrue(batch.getConsistency().equals(cl.toString()));\r\n    } finally {\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.util.Version.shouldBeUpdatedTo",
	"Comment": "checks if this version should be updated to the given one.ignoring the other version if this one is stable and the other one is not.",
	"Method": "Optional<Version> shouldBeUpdatedTo(List<Version> availableVersions,boolean shouldBeUpdatedTo,Version otherVersion){\r\n    if (developmentStage == Version.DevelopmentStage.STABLE && otherVersion.developmentStage != Version.DevelopmentStage.STABLE) {\r\n        return false;\r\n    }\r\n    return otherVersion.isNewerThan(this);\r\n}"
}, {
	"Path": "org.elixir_lang.navigation.item_presentation.structure.Field.getPresentableText",
	"Comment": "returns the name of the object to be presented in most renderers across the program.",
	"Method": "String getPresentableText(){\r\n    return name + \": \" + defaultValue;\r\n}"
}, {
	"Path": "org.jabref.model.EntryTypes.getStandardType",
	"Comment": "this method returns the standard bibtexentrytype for thename of a type, or null if it does not exist.",
	"Method": "Optional<EntryType> getStandardType(String name,Optional<EntryType> getStandardType,String name,BibDatabaseMode mode){\r\n    return mode == BibDatabaseMode.BIBLATEX ? BIBLATEX.getStandardType(name) : BIBTEX.getStandardType(name);\r\n}"
}, {
	"Path": "org.jabref.logic.util.io.FileFinders.constructFromConfiguration",
	"Comment": "creates a preconfigurated file finder based on the given autolink preferences.",
	"Method": "FileFinder constructFromConfiguration(AutoLinkPreferences autoLinkPreferences){\r\n    if (autoLinkPreferences.isUseRegularExpression()) {\r\n        return new RegExpBasedFileFinder(autoLinkPreferences.getRegularExpression(), autoLinkPreferences.getKeywordDelimiter());\r\n    } else {\r\n        return new CiteKeyBasedFileFinder(autoLinkPreferences.isOnlyFindByExactCiteKey());\r\n    }\r\n}"
}, {
	"Path": "org.jabref.preferences.JabRefPreferences.overwritePreferences",
	"Comment": "only for testing!do not use in production code. otherwise the singleton pattern is broken and preferences might get lost.",
	"Method": "void overwritePreferences(JabRefPreferences owPrefs){\r\n    singleton = owPrefs;\r\n}"
}, {
	"Path": "com.datastax.driver.core.QueryOptions.getRefreshNodeIntervalMillis",
	"Comment": "the default window size in milliseconds used to debounce node refresh requests.",
	"Method": "int getRefreshNodeIntervalMillis(){\r\n    return refreshNodeIntervalMillis;\r\n}"
}, {
	"Path": "com.datastax.driver.core.ControlConnection.connect",
	"Comment": "only for the initial connection. does not schedule retries if it fails",
	"Method": "void connect(){\r\n    if (isShutdown)\r\n        return;\r\n    List<Host> hosts = new ArrayList<Host>(cluster.metadata.allHosts());\r\n    Collections.shuffle(hosts);\r\n    setNewConnection(reconnectInternal(hosts.iterator(), true));\r\n}"
}, {
	"Path": "org.jdbi.v3.core.result.RowView.getRow",
	"Comment": "use a row mapper to extract a type from the current resultset row.",
	"Method": "T getRow(Class<T> rowType,T getRow,GenericType<T> rowType,Object getRow,Type type){\r\n    try {\r\n        return rowMapperFor(type).map(rs, ctx);\r\n    } catch (SQLException e) {\r\n        throw new MappingException(e);\r\n    }\r\n}"
}, {
	"Path": "com.beust.jcommander.JCommander.parseValues",
	"Comment": "main method that parses the values and initializes the fields accordingly.",
	"Method": "void parseValues(String[] args,boolean validate){\r\n    boolean commandParsed = false;\r\n    int i = 0;\r\n    boolean isDashDash = false;\r\n    while (i < args.length && !commandParsed) {\r\n        String arg = args[i];\r\n        String a = trim(arg);\r\n        args[i] = a;\r\n        p(\"Parsing arg: \" + a);\r\n        JCommander jc = findCommandByAlias(arg);\r\n        int increment = 1;\r\n        if (!isDashDash && !\"--\".equals(a) && isOption(a) && jc == null) {\r\n            ParameterDescription pd = findParameterDescription(a);\r\n            if (pd != null) {\r\n                if (pd.getParameter().password()) {\r\n                    increment = processPassword(args, i, pd, validate);\r\n                } else {\r\n                    if (pd.getParameter().variableArity()) {\r\n                        increment = processVariableArity(args, i, pd, validate);\r\n                    } else {\r\n                        Class<?> fieldType = pd.getParameterized().getType();\r\n                        if (pd.getParameter().arity() == -1 && isBooleanType(fieldType)) {\r\n                            handleBooleanOption(pd, fieldType);\r\n                        } else {\r\n                            increment = processFixedArity(args, i, pd, validate, fieldType);\r\n                        }\r\n                        if (pd.isHelp()) {\r\n                            helpWasSpecified = true;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (options.acceptUnknownOptions) {\r\n                    unknownArgs.add(arg);\r\n                    i++;\r\n                    while (i < args.length && !isOption(args[i])) {\r\n                        unknownArgs.add(args[i++]);\r\n                    }\r\n                    increment = 0;\r\n                } else {\r\n                    throw new ParameterException(\"Unknown option: \" + arg);\r\n                }\r\n            }\r\n        } else {\r\n            if (\"--\".equals(arg) && !isDashDash) {\r\n                isDashDash = true;\r\n            } else if (commands.isEmpty()) {\r\n                initMainParameterValue(arg);\r\n                String value = a;\r\n                Object convertedValue = value;\r\n                if (mainParameter.annotation.converter() != null && mainParameter.annotation.converter() != NoConverter.class) {\r\n                    convertedValue = convertValue(mainParameter.parameterized, mainParameter.parameterized.getType(), null, value);\r\n                }\r\n                Type genericType = mainParameter.parameterized.getGenericType();\r\n                if (genericType instanceof ParameterizedType) {\r\n                    ParameterizedType p = (ParameterizedType) genericType;\r\n                    Type cls = p.getActualTypeArguments()[0];\r\n                    if (cls instanceof Class) {\r\n                        convertedValue = convertValue(mainParameter.parameterized, (Class) cls, null, value);\r\n                    }\r\n                }\r\n                for (final Class<? extends IParameterValidator> validator : mainParameter.annotation.validateWith()) {\r\n                    mainParameter.description.validateParameter(validator, \"Default\", value);\r\n                }\r\n                mainParameter.description.setAssigned(true);\r\n                mainParameter.addValue(convertedValue);\r\n            } else {\r\n                if (jc == null && validate) {\r\n                    throw new MissingCommandException(\"Expected a command, got \" + arg, arg);\r\n                } else if (jc != null) {\r\n                    parsedCommand = jc.programName.name;\r\n                    parsedAlias = arg;\r\n                    jc.parse(validate, subArray(args, i + 1));\r\n                    commandParsed = true;\r\n                }\r\n            }\r\n        }\r\n        i += increment;\r\n    }\r\n    for (ParameterDescription parameterDescription : descriptions.values()) {\r\n        if (parameterDescription.isAssigned()) {\r\n            fields.get(parameterDescription.getParameterized()).setAssigned(true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.CCMTestsSupport.errorOut",
	"Comment": "signals that the test has encountered an unexpected error.this method is automatically called when a test finishes with an unexpected exception beingthrown, but it is also possible to manually invoke it.calling this method will close the current cluster and session. the ccm data directory willbe kept after the test session is finished, for debugging purposesthis method should not be called before the test has started, nor after the test isfinished.",
	"Method": "void errorOut(){\r\n    erroredOut = true;\r\n    if (ccm != null) {\r\n        ccm.setKeepLogs(true);\r\n    }\r\n}"
}, {
	"Path": "org.elixir_lang.beam.psi.BeamFileImpl.getManager",
	"Comment": "returns the psi manager for the project to which the psi element belongs.",
	"Method": "PsiManager getManager(){\r\n    return fileViewProvider.getManager();\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.ClassPathResource.exists",
	"Comment": "this implementation checks for the resolution of a resource url.",
	"Method": "boolean exists(){\r\n    return (resolveURL() != null);\r\n}"
}, {
	"Path": "org.elixir_lang.SdkType.homePathByVersion",
	"Comment": "map of home paths to versions in descending version order so that newer versions are favored.",
	"Method": "Map<Version, String> homePathByVersion(){\r\n    Map<Version, String> homePathByVersion = new TreeMap<Version, String>(new Comparator<Version>() {\r\n        @Override\r\n        public int compare(Version version1, Version version2) {\r\n            return version2.compareTo(version1);\r\n        }\r\n    });\r\n    if (SystemInfo.isMac) {\r\n        File homebrewRoot = new File(\"/usr/local/Cellar/elixir\");\r\n        if (homebrewRoot.isDirectory()) {\r\n            for (File child : homebrewRoot.listFiles()) {\r\n                if (child.isDirectory()) {\r\n                    String versionString = child.getName();\r\n                    String[] versionParts = versionString.split(\"\\\\.\", 3);\r\n                    int major = Integer.parseInt(versionParts[0]);\r\n                    int minor = Integer.parseInt(versionParts[1]);\r\n                    int bugfix = Integer.parseInt(versionParts[2]);\r\n                    Version version = new Version(major, minor, bugfix);\r\n                    homePathByVersion.put(version, child.getAbsolutePath());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return homePathByVersion;\r\n}"
}, {
	"Path": "org.elixir_lang.SdkType.homePathByVersion",
	"Comment": "map of home paths to versions in descending version order so that newer versions are favored.",
	"Method": "Map<Version, String> homePathByVersion(){\r\n    return version2.compareTo(version1);\r\n}"
}, {
	"Path": "com.datastax.driver.core.MaterializedViewMetadataTest.should_create_view_metadata",
	"Comment": "validates that a materialized view is properly retrieved and parsed.",
	"Method": "void should_create_view_metadata(){\r\n    String createTable = String.format(\"CREATE TABLE %s.scores(\" + \"user TEXT,\" + \"game TEXT,\" + \"year INT,\" + \"month INT,\" + \"day INT,\" + \"score INT,\" + \"PRIMARY KEY (user, game, year, month, day)\" + \")\", keyspace);\r\n    String createMV = String.format(\"CREATE MATERIALIZED VIEW %s.monthlyhigh AS \" + \"SELECT game, year, month, score, user, day FROM %s.scores \" + \"WHERE game IS NOT NULL AND year IS NOT NULL AND month IS NOT NULL AND score IS NOT NULL AND user IS NOT NULL AND day IS NOT NULL \" + \"PRIMARY KEY ((game, year, month), score, user, day) \" + \"WITH CLUSTERING ORDER BY (score DESC, user ASC, day ASC)\", keyspace, keyspace);\r\n    session().execute(createTable);\r\n    session().execute(createMV);\r\n    TableMetadata table = cluster().getMetadata().getKeyspace(keyspace).getTable(\"scores\");\r\n    MaterializedViewMetadata mv = cluster().getMetadata().getKeyspace(keyspace).getMaterializedView(\"monthlyhigh\");\r\n    assertThat(table).isNotNull().hasName(\"scores\").hasMaterializedView(mv).hasNumberOfColumns(6);\r\n    assertThat(table.getColumns().get(0)).isNotNull().hasName(\"user\").isPartitionKey();\r\n    assertThat(table.getColumns().get(1)).isNotNull().hasName(\"game\").isClusteringColumn();\r\n    assertThat(table.getColumns().get(2)).isNotNull().hasName(\"year\").isClusteringColumn();\r\n    assertThat(table.getColumns().get(3)).isNotNull().hasName(\"month\").isClusteringColumn();\r\n    assertThat(table.getColumns().get(4)).isNotNull().hasName(\"day\").isClusteringColumn();\r\n    assertThat(table.getColumns().get(5)).isNotNull().hasName(\"score\").isRegularColumn();\r\n    assertThat(mv).isNotNull().hasName(\"monthlyhigh\").hasBaseTable(table).hasNumberOfColumns(6).isEqualTo(table.getView(\"monthlyhigh\"));\r\n    assertThat(mv.getColumns().get(0)).isNotNull().hasName(\"game\").isPartitionKey();\r\n    assertThat(mv.getColumns().get(1)).isNotNull().hasName(\"year\").isPartitionKey();\r\n    assertThat(mv.getColumns().get(2)).isNotNull().hasName(\"month\").isPartitionKey();\r\n    assertThat(mv.getColumns().get(3)).isNotNull().hasName(\"score\").isClusteringColumn().hasClusteringOrder(DESC);\r\n    assertThat(mv.getColumns().get(4)).isNotNull().hasName(\"user\").isClusteringColumn();\r\n    assertThat(mv.getColumns().get(5)).isNotNull().hasName(\"day\").isClusteringColumn();\r\n    assertThat(mv.asCQLQuery(false)).contains(createMV);\r\n}"
}, {
	"Path": "org.jabref.model.entry.AuthorListParser.getAuthor",
	"Comment": "parses one author name and returns preformatted information.",
	"Method": "Optional<Author> getAuthor(){\r\n    List<Object> tokens = new ArrayList();\r\n    int vonStart = -1;\r\n    int lastStart = -1;\r\n    int commaFirst = -1;\r\n    int commaSecond = -1;\r\n    boolean continueLoop = true;\r\n    while (continueLoop) {\r\n        int token = getToken();\r\n        switch(token) {\r\n            case TOKEN_EOF:\r\n            case TOKEN_AND:\r\n                continueLoop = false;\r\n                break;\r\n            case TOKEN_COMMA:\r\n                if (commaFirst < 0) {\r\n                    commaFirst = tokens.size();\r\n                } else if (commaSecond < 0) {\r\n                    commaSecond = tokens.size();\r\n                }\r\n                break;\r\n            case TOKEN_WORD:\r\n                tokens.add(original.substring(tokenStart, tokenEnd));\r\n                tokens.add(original.substring(tokenStart, tokenAbbrEnd));\r\n                tokens.add(tokenTerm);\r\n                tokens.add(tokenCase);\r\n                if (commaFirst >= 0) {\r\n                    break;\r\n                }\r\n                if (lastStart >= 0) {\r\n                    break;\r\n                }\r\n                if (vonStart < 0) {\r\n                    if (!tokenCase) {\r\n                        int previousTermToken = (tokens.size() - TOKEN_GROUP_LENGTH - TOKEN_GROUP_LENGTH) + OFFSET_TOKEN_TERM;\r\n                        if ((previousTermToken >= 0) && tokens.get(previousTermToken).equals('-')) {\r\n                            break;\r\n                        }\r\n                        int thisTermToken = previousTermToken + TOKEN_GROUP_LENGTH;\r\n                        if ((thisTermToken >= 0) && tokens.get(thisTermToken).equals('-')) {\r\n                            break;\r\n                        }\r\n                        vonStart = tokens.size() - TOKEN_GROUP_LENGTH;\r\n                        break;\r\n                    }\r\n                } else if ((lastStart < 0) && tokenCase) {\r\n                    lastStart = tokens.size() - TOKEN_GROUP_LENGTH;\r\n                    break;\r\n                }\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    if (tokens.isEmpty()) {\r\n        return Optional.empty();\r\n    }\r\n    int firstPartStart = -1;\r\n    int vonPartStart = -1;\r\n    int lastPartStart = -1;\r\n    int jrPartStart = -1;\r\n    int firstPartEnd;\r\n    int vonPartEnd = 0;\r\n    int lastPartEnd = 0;\r\n    int jrPartEnd = 0;\r\n    if (commaFirst < 0) {\r\n        if (vonStart < 0) {\r\n            lastPartEnd = tokens.size();\r\n            lastPartStart = tokens.size() - TOKEN_GROUP_LENGTH;\r\n            int index = (tokens.size() - (2 * TOKEN_GROUP_LENGTH)) + OFFSET_TOKEN_TERM;\r\n            if (index > 0) {\r\n                Character ch = (Character) tokens.get(index);\r\n                if (ch == '-') {\r\n                    lastPartStart -= TOKEN_GROUP_LENGTH;\r\n                }\r\n            }\r\n            firstPartEnd = lastPartStart;\r\n            if (firstPartEnd > 0) {\r\n                firstPartStart = 0;\r\n            }\r\n        } else {\r\n            if (lastStart >= 0) {\r\n                lastPartEnd = tokens.size();\r\n                lastPartStart = lastStart;\r\n                vonPartEnd = lastPartStart;\r\n            } else {\r\n                vonPartEnd = tokens.size();\r\n            }\r\n            vonPartStart = vonStart;\r\n            firstPartEnd = vonPartStart;\r\n            if (firstPartEnd > 0) {\r\n                firstPartStart = 0;\r\n            }\r\n        }\r\n    } else {\r\n        firstPartEnd = tokens.size();\r\n        if (commaSecond < 0) {\r\n            if (commaFirst < firstPartEnd) {\r\n                firstPartStart = commaFirst;\r\n            }\r\n        } else {\r\n            if (commaSecond < firstPartEnd) {\r\n                firstPartStart = commaSecond;\r\n            }\r\n            jrPartEnd = commaSecond;\r\n            if (commaFirst < jrPartEnd) {\r\n                jrPartStart = commaFirst;\r\n            }\r\n        }\r\n        if (vonStart == 0) {\r\n            if (lastStart < 0) {\r\n                vonPartEnd = commaFirst;\r\n            } else {\r\n                lastPartEnd = commaFirst;\r\n                lastPartStart = lastStart;\r\n                vonPartEnd = lastPartStart;\r\n            }\r\n            vonPartStart = 0;\r\n        } else {\r\n            lastPartEnd = commaFirst;\r\n            if (lastPartEnd > 0) {\r\n                lastPartStart = 0;\r\n            }\r\n        }\r\n    }\r\n    if ((firstPartStart == -1) && (lastPartStart == -1) && (vonPartStart != -1)) {\r\n        lastPartStart = vonPartStart;\r\n        lastPartEnd = vonPartEnd;\r\n        vonPartStart = -1;\r\n        vonPartEnd = -1;\r\n    }\r\n    String firstPart = firstPartStart < 0 ? null : concatTokens(tokens, firstPartStart, firstPartEnd, OFFSET_TOKEN, false);\r\n    String firstAbbr = firstPartStart < 0 ? null : concatTokens(tokens, firstPartStart, firstPartEnd, OFFSET_TOKEN_ABBR, true);\r\n    String vonPart = vonPartStart < 0 ? null : concatTokens(tokens, vonPartStart, vonPartEnd, OFFSET_TOKEN, false);\r\n    String lastPart = lastPartStart < 0 ? null : concatTokens(tokens, lastPartStart, lastPartEnd, OFFSET_TOKEN, false);\r\n    String jrPart = jrPartStart < 0 ? null : concatTokens(tokens, jrPartStart, jrPartEnd, OFFSET_TOKEN, false);\r\n    if ((firstPart != null) && (lastPart != null) && lastPart.equals(lastPart.toUpperCase(Locale.ROOT)) && (lastPart.length() < 5) && (Character.UnicodeScript.of(lastPart.charAt(0)) != Character.UnicodeScript.HAN)) {\r\n        return Optional.of(new Author(lastPart, lastPart, vonPart, firstPart, jrPart));\r\n    } else {\r\n        return Optional.of(new Author(firstPart, firstAbbr, vonPart, lastPart, jrPart));\r\n    }\r\n}"
}, {
	"Path": "org.jdbi.v3.core.HandleAccess.createHandle",
	"Comment": "create a handle with a fake connection,useful for tests that do not actually hita database.",
	"Method": "Handle createHandle(){\r\n    Connection fakeConnection = Mockito.mock(Connection.class);\r\n    return new Handle(new ConfigRegistry(), Connection::close, new LocalTransactionHandler(), new DefaultStatementBuilder(), fakeConnection);\r\n}"
}, {
	"Path": "com.datastax.driver.core.Metadata.getTokenRanges",
	"Comment": "returns the token ranges that define data distribution in the ring.note that this information is refreshed asynchronously by the control connection, whenschema or ring topology changes. it might occasionally be stale.",
	"Method": "Set<TokenRange> getTokenRanges(Set<TokenRange> getTokenRanges,String keyspace,Host host){\r\n    keyspace = handleId(keyspace);\r\n    TokenMap current = tokenMap;\r\n    if (current == null) {\r\n        return Collections.emptySet();\r\n    } else {\r\n        Map<Host, Set<TokenRange>> dcRanges = current.hostsToRangesByKeyspace.get(keyspace);\r\n        if (dcRanges == null) {\r\n            return Collections.emptySet();\r\n        } else {\r\n            Set<TokenRange> ranges = dcRanges.get(host);\r\n            return (ranges == null) ? Collections.<TokenRange>emptySet() : ranges;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.resteasy.ResteasyRegistryPlugin.patchResourceMethodRegistry",
	"Comment": "patch resourcemethodregistry, make rootnode && root fields public",
	"Method": "void patchResourceMethodRegistry(CtClass ctClass,ClassPool classPool){\r\n    try {\r\n        ctClass.getField(\"rootNode\").setModifiers(AccessFlag.PUBLIC);\r\n        ctClass.getField(\"root\").setModifiers(AccessFlag.PUBLIC);\r\n    } catch (NotFoundException e) {\r\n        LOGGER.error(\"Error patching FilterDispatcher\", e);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.auxparser.DefaultAuxParser.resolveTags",
	"Comment": "try to find an equivalent bibtex entry inside the reference database for all keys inside the aux file.",
	"Method": "void resolveTags(AuxParserResult result){\r\n    for (String key : result.getUniqueKeys()) {\r\n        Optional<BibEntry> entry = masterDatabase.getEntryByKey(key);\r\n        if (result.getGeneratedBibDatabase().getEntryByKey(key).isPresent()) {\r\n        } else if (entry.isPresent()) {\r\n            insertEntry(entry.get(), result);\r\n            resolveCrossReferences(entry.get(), result);\r\n        } else {\r\n            result.getUnresolvedKeys().add(key);\r\n        }\r\n    }\r\n    if (result.getGeneratedBibDatabase().hasEntries()) {\r\n        result.getGeneratedBibDatabase().copyPreamble(masterDatabase);\r\n        result.insertStrings(masterDatabase.getUsedStrings(result.getGeneratedBibDatabase().getEntries()));\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.hscglib.CglibEnhancerProxyBytecodeGenerator.setFieldValuesWithNewLoadedClasses",
	"Comment": "replaces fields with class values with new classes loaded by aparentlastclassloader",
	"Method": "void setFieldValuesWithNewLoadedClasses(Collection<FieldState> fieldStates){\r\n    for (FieldState fieldState : fieldStates) {\r\n        fieldState.field.set(generator, loadFromClassloader(fieldState.fieldValue));\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ObjectUtils.addObjectToArray",
	"Comment": "append the given object to the given array, returning a new arrayconsisting of the input array contents plus the given object.",
	"Method": "A[] addObjectToArray(A[] array,O obj){\r\n    Class<?> compType = Object.class;\r\n    if (array != null) {\r\n        compType = array.getClass().getComponentType();\r\n    } else if (obj != null) {\r\n        compType = obj.getClass();\r\n    }\r\n    int newArrLength = (array != null ? array.length + 1 : 1);\r\n    @SuppressWarnings(\"unchecked\")\r\n    A[] newArr = (A[]) Array.newInstance(compType, newArrLength);\r\n    if (array != null) {\r\n        System.arraycopy(array, 0, newArr, 0, array.length);\r\n    }\r\n    newArr[newArr.length - 1] = obj;\r\n    return newArr;\r\n}"
}, {
	"Path": "org.jabref.model.ChainNode.isAncestorOf",
	"Comment": "returns true if this node is an ancestor of the given node.a node is considered an ancestor of itself.",
	"Method": "boolean isAncestorOf(T anotherNode){\r\n    Objects.requireNonNull(anotherNode);\r\n    if (anotherNode == this) {\r\n        return true;\r\n    } else {\r\n        return child.isAncestorOf(anotherNode);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.ClassPathResource.getInputStream",
	"Comment": "this implementation opens an inputstream for the given class pathresource.",
	"Method": "InputStream getInputStream(){\r\n    InputStream is;\r\n    if (this.clazz != null) {\r\n        is = this.clazz.getResourceAsStream(this.path);\r\n    } else if (this.classLoader != null) {\r\n        is = this.classLoader.getResourceAsStream(this.path);\r\n    } else {\r\n        is = ClassLoader.getSystemResourceAsStream(this.path);\r\n    }\r\n    if (is == null) {\r\n        throw new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\r\n    }\r\n    return is;\r\n}"
}, {
	"Path": "org.jabref.logic.xmp.XmpUtilReader.loadWithAutomaticDecryption",
	"Comment": "loads the specified file with the basic pdfbox functionality and uses an empty string as default password.",
	"Method": "PDDocument loadWithAutomaticDecryption(Path path){\r\n    PDDocument doc = PDDocument.load(path.toFile());\r\n    return doc;\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fileformat.BibtexParser.purgeEOFCharacters",
	"Comment": "removes all eof characters from a stringbuilder and returns a new string with the resulting content",
	"Method": "String purgeEOFCharacters(String input){\r\n    StringBuilder remainingText = new StringBuilder();\r\n    for (Character character : input.toCharArray()) {\r\n        if (!(isEOFCharacter(character))) {\r\n            remainingText.append(character);\r\n        }\r\n    }\r\n    return remainingText.toString();\r\n}"
}, {
	"Path": "org.jabref.model.database.BibDatabase.getEntriesByKey",
	"Comment": "collects entries having the specified bibtex key and returns these entries as list.the order of the entries is the order they appear in the database.",
	"Method": "List<BibEntry> getEntriesByKey(String key){\r\n    List<BibEntry> result = new ArrayList();\r\n    for (BibEntry entry : entries) {\r\n        entry.getCiteKeyOptional().ifPresent(entryKey -> {\r\n            if (key.equals(entryKey)) {\r\n                result.add(entry);\r\n            }\r\n        });\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.java.CtClassJavaProxyGenerator.codeClassForName",
	"Comment": "generate code to invoke the class.forname with the name of the givenclass to get its class object at runtime. the code is written to thesupplied stream. note that the code generated by this method may causedthe checked classnotfoundexception to be thrown.",
	"Method": "void codeClassForName(CtClass cl,DataOutputStream out){\r\n    if (cl.isArray()) {\r\n        code_ldc(cp.getString(Descriptor.of(cl).replace(\"/\", \".\")), out);\r\n    } else\r\n        code_ldc(cp.getString(cl.getName()), out);\r\n    out.writeByte(opc_invokestatic);\r\n    out.writeShort(cp.getMethodRef(\"java/lang/Class\", \"forName\", \"(Ljava/lang/String;)Ljava/lang/Class;\"));\r\n}"
}, {
	"Path": "com.datastax.driver.core.QueryLogger.setMaxParameterValueLength",
	"Comment": "set the maximum length of a query parameter value that can be logged verbatim by the driver.parameter values longer than this value will be truncated when logged.",
	"Method": "void setMaxParameterValueLength(int maxParameterValueLength){\r\n    if (maxParameterValueLength <= 0 && maxParameterValueLength != -1)\r\n        throw new IllegalArgumentException(\"Invalid maxParameterValueLength, should be > 0 or -1, got \" + maxParameterValueLength);\r\n    this.maxParameterValueLength = maxParameterValueLength;\r\n}"
}, {
	"Path": "com.datastax.driver.core.QueryOptions.getRefreshSchemaIntervalMillis",
	"Comment": "the default window size in milliseconds used to debounce schema refresh requests.",
	"Method": "int getRefreshSchemaIntervalMillis(){\r\n    return refreshSchemaIntervalMillis;\r\n}"
}, {
	"Path": "org.jabref.gui.fieldeditors.contextmenu.EditorMenus.getNameMenu",
	"Comment": "the default context menu with a specific menu for normalizing person names regarding to bibtex rules.",
	"Method": "Supplier<List<MenuItem>> getNameMenu(TextInputControl textInput){\r\n    return () -> {\r\n        CustomMenuItem normalizeNames = new CustomMenuItem(new Label(Localization.lang(\"Normalize to BibTeX name format\")));\r\n        normalizeNames.setOnAction(event -> textInput.setText(new NormalizeNamesFormatter().format(textInput.getText())));\r\n        Tooltip toolTip = new Tooltip(Localization.lang(\"If possible, normalize this list of names to conform to standard BibTeX name formatting\"));\r\n        Tooltip.install(normalizeNames.getContent(), toolTip);\r\n        List<MenuItem> menuItems = new ArrayList(6);\r\n        menuItems.add(normalizeNames);\r\n        menuItems.addAll(getDefaultMenu(textInput).get());\r\n        return menuItems;\r\n    };\r\n}"
}, {
	"Path": "org.jabref.gui.journals.ManageJournalAbbreviationsViewModel.saveExternalFilesList",
	"Comment": "this method stores all file paths of the files in the journalfiles propertyto the global jabref preferences. pseudo abbreviation files will not be stored.",
	"Method": "void saveExternalFilesList(){\r\n    List<String> extFiles = new ArrayList();\r\n    journalFiles.forEach(file -> {\r\n        if (!file.isBuiltInListProperty().get()) {\r\n            file.getAbsolutePath().ifPresent(path -> extFiles.add(path.toAbsolutePath().toString()));\r\n        }\r\n    });\r\n    abbreviationsPreferences.setExternalJournalLists(extFiles);\r\n}"
}, {
	"Path": "com.beust.jcommander.Parameterized.describeClassTree",
	"Comment": "given an object return the set of classes that it extendsor implements.",
	"Method": "void describeClassTree(Class<?> inputClass,Set<Class<?>> setOfClasses,Set<Class<?>> describeClassTree,Class<?> inputClass){\r\n    if (inputClass == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    Set<Class<?>> classes = Sets.newLinkedHashSet();\r\n    describeClassTree(inputClass, classes);\r\n    return classes;\r\n}"
}, {
	"Path": "org.jabref.migrations.FileLinksUpgradeWarning.performAction",
	"Comment": "this method presents a dialog box explaining and offering to make thechanges. if the user confirms, the changes are performed.",
	"Method": "void performAction(BasePanel panel,ParserResult parserResult){\r\n    if (!isThereSomethingToBeDone()) {\r\n        return;\r\n    }\r\n    JCheckBox changeSettings = new JCheckBox(Localization.lang(\"Change table column and General fields settings to use the new feature\"), offerChangeSettings);\r\n    JCheckBox changeDatabase = new JCheckBox(Localization.lang(\"Upgrade old external file links to use the new feature\"), offerChangeDatabase);\r\n    JCheckBox setFileDir = new JCheckBox(Localization.lang(\"Set main external file directory\") + \":\", offerSetFileDir);\r\n    JTextField fileDir = new JTextField(30);\r\n    JCheckBox doNotShowDialog = new JCheckBox(Localization.lang(\"Do not show these options in the future\"), false);\r\n    JPanel message = new JPanel();\r\n    FormBuilder formBuilder = FormBuilder.create().layout(new FormLayout(\"left:pref\", \"p\"));\r\n    int row = 1;\r\n    formBuilder.add(new JLabel(\"<html>\" + Localization.lang(\"This library uses outdated file links.\") + \"<br><br>\" + Localization.lang(\"JabRef no longer supports 'ps' or 'pdf' fields.<br>File links are now stored in the 'file' field and files are stored in an external file directory.<br>To make use of this feature, JabRef needs to upgrade file links.<br><br>\") + \"<p>\" + Localization.lang(\"Do you want JabRef to do the following operations?\") + \"<\/html>\")).xy(1, row);\r\n    if (offerChangeSettings) {\r\n        formBuilder.appendRows(\"2dlu, p\");\r\n        row += 2;\r\n        formBuilder.add(changeSettings).xy(1, row);\r\n    }\r\n    if (offerChangeDatabase) {\r\n        formBuilder.appendRows(\"2dlu, p\");\r\n        row += 2;\r\n        formBuilder.add(changeDatabase).xy(1, row);\r\n    }\r\n    if (offerSetFileDir) {\r\n        if (Globals.prefs.hasKey(FieldName.PDF + FilePreferences.DIR_SUFFIX)) {\r\n            fileDir.setText(Globals.prefs.get(FieldName.PDF + FilePreferences.DIR_SUFFIX));\r\n        } else {\r\n            fileDir.setText(Globals.prefs.get(FieldName.PS + FilePreferences.DIR_SUFFIX));\r\n        }\r\n        JPanel builderPanel = new JPanel();\r\n        builderPanel.add(setFileDir);\r\n        builderPanel.add(fileDir);\r\n        JButton browse = new JButton(Localization.lang(\"Browse\"));\r\n        FileDialogConfiguration fileDialogConfiguration = new FileDialogConfiguration.Builder().withInitialDirectory(Globals.prefs.get(JabRefPreferences.WORKING_DIRECTORY)).build();\r\n        DialogService ds = new FXDialogService();\r\n        browse.addActionListener(e -> DefaultTaskExecutor.runInJavaFXThread(() -> ds.showFileOpenDialog(fileDialogConfiguration).ifPresent(f -> fileDir.setText(f.toAbsolutePath().toString()))));\r\n        builderPanel.add(browse);\r\n        formBuilder.appendRows(\"2dlu, p\");\r\n        row += 2;\r\n        formBuilder.add(builderPanel).xy(1, row);\r\n    }\r\n    formBuilder.appendRows(\"6dlu, p\");\r\n    formBuilder.add(doNotShowDialog).xy(1, row + 2);\r\n    message.add(formBuilder.build());\r\n    int answer = JOptionPane.showConfirmDialog(null, message, Localization.lang(\"Upgrade file\"), JOptionPane.YES_NO_OPTION);\r\n    if (doNotShowDialog.isSelected()) {\r\n        Globals.prefs.putBoolean(JabRefPreferences.SHOW_FILE_LINKS_UPGRADE_WARNING, false);\r\n    }\r\n    if (answer == JOptionPane.YES_OPTION) {\r\n        makeChanges(panel, parserResult, changeSettings.isSelected(), changeDatabase.isSelected(), setFileDir.isSelected() ? fileDir.getText() : null);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.model.util.FileHelper.expandFilename",
	"Comment": "converts a relative filename to an absolute one, if necessary. returnsan empty optional if the file does not exist.",
	"Method": "Optional<Path> expandFilename(BibDatabaseContext databaseContext,String name,FilePreferences filePreferences,Optional<Path> expandFilename,String name,List<String> directories,Optional<Path> expandFilename,String filename,Path directory){\r\n    Objects.requireNonNull(filename);\r\n    Objects.requireNonNull(directory);\r\n    Path file = Paths.get(filename);\r\n    if (filename.isEmpty()) {\r\n        return Optional.of(directory);\r\n    }\r\n    Path resolvedFile = directory.resolve(file);\r\n    if (Files.exists(resolvedFile)) {\r\n        return Optional.of(resolvedFile);\r\n    } else {\r\n        return Optional.empty();\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.reflect.Reflection.makeReflective",
	"Comment": "produces a reflective class.it modifies the givenctclass object and makes it reflective.if the super class is also made reflective, it must be donebefore the sub class.",
	"Method": "boolean makeReflective(String classname,String metaobject,String metaclass,boolean makeReflective,Class<?> clazz,Class<?> metaobject,Class<?> metaclass,boolean makeReflective,CtClass clazz,CtClass metaobject,CtClass metaclass){\r\n    if (clazz.isInterface())\r\n        throw new CannotReflectException(\"Cannot reflect an interface: \" + clazz.getName());\r\n    if (clazz.subclassOf(classPool.get(classMetaobjectClassName)))\r\n        throw new CannotReflectException(\"Cannot reflect a subclass of ClassMetaobject: \" + clazz.getName());\r\n    if (clazz.subclassOf(classPool.get(metaobjectClassName)))\r\n        throw new CannotReflectException(\"Cannot reflect a subclass of Metaobject: \" + clazz.getName());\r\n    registerReflectiveClass(clazz);\r\n    return modifyClassfile(clazz, metaobject, metaclass);\r\n}"
}, {
	"Path": "org.jabref.preferences.CustomImportList.replaceImporter",
	"Comment": "adds an importer.if an old one equal to the new one was contained, the oldone is replaced.",
	"Method": "boolean replaceImporter(CustomImporter customImporter){\r\n    boolean wasContained = this.remove(customImporter);\r\n    this.addImporter(customImporter);\r\n    return wasContained;\r\n}"
}, {
	"Path": "org.elixir_lang.navigation.item_presentation.modular.Quote.getPresentableText",
	"Comment": "returns the name of the object to be presented in most renderers across the program.",
	"Method": "String getPresentableText(){\r\n    return null;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.reflect.ClassMetaobject.getParameterTypes",
	"Comment": "returns an array of class objects representing theformal parameter types of the method specifiedby identifier.",
	"Method": "Class<?>[] getParameterTypes(int identifier){\r\n    return getReflectiveMethods()[identifier].getParameterTypes();\r\n}"
}, {
	"Path": "org.elixir_lang.beam.psi.impl.CallDefinitionImpl.exportedArity",
	"Comment": "the arity of the function or macro that was exported into the compiled .beam file",
	"Method": "int exportedArity(){\r\n    return stub.callDefinitionClauseHeadArity();\r\n}"
}, {
	"Path": "org.jabref.migrations.PreferencesMigrations.runMigrations",
	"Comment": "perform checks and changes for users with a preference set from an older jabref version.",
	"Method": "void runMigrations(){\r\n    Preferences mainPrefsNode = Preferences.userNodeForPackage(JabRefMain.class);\r\n    upgradePrefsToOrgJabRef(mainPrefsNode);\r\n    upgradeSortOrder(Globals.prefs);\r\n    upgradeFaultyEncodingStrings(Globals.prefs);\r\n    upgradeLabelPatternToBibtexKeyPattern(Globals.prefs);\r\n    upgradeImportFileAndDirePatterns(Globals.prefs, mainPrefsNode);\r\n    upgradeStoredCustomEntryTypes(Globals.prefs, mainPrefsNode);\r\n    upgradeKeyBindingsToJavaFX(Globals.prefs);\r\n    addCrossRefRelatedFieldsForAutoComplete(Globals.prefs);\r\n    upgradePreviewStyleFromReviewToComment(Globals.prefs);\r\n}"
}, {
	"Path": "org.menacheri.jetclient.util.NettyUtils.writeStrings",
	"Comment": "writes multiple strings to a channelbuffer with the length of the string\tpreceding its content. so if there are two string hello and\tworld then the channel buffer returned would contain",
	"Method": "ChannelBuffer writeStrings(String msgs,ChannelBuffer writeStrings,Charset charset,String msgs){\r\n    ChannelBuffer buffer = null;\r\n    for (String msg : msgs) {\r\n        if (null == buffer) {\r\n            buffer = writeString(msg, charset);\r\n        } else {\r\n            ChannelBuffer theBuffer = writeString(msg, charset);\r\n            if (null != theBuffer) {\r\n                buffer = ChannelBuffers.wrappedBuffer(buffer, theBuffer);\r\n            }\r\n        }\r\n    }\r\n    return buffer;\r\n}"
}, {
	"Path": "com.datastax.driver.core.TableOptionsMetadata.getLocalReadRepairChance",
	"Comment": "returns the cluster local read repair chance set for this table.",
	"Method": "double getLocalReadRepairChance(){\r\n    return localReadRepair;\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiletype.ExternalFileTypes.updateExternalFileTypes",
	"Comment": "set up the list of external file types, either from default values, or from values recorded in preferences.",
	"Method": "void updateExternalFileTypes(){\r\n    List<ExternalFileType> types = new ArrayList(getDefaultExternalFileTypes());\r\n    if (Globals.prefs.get(JabRefPreferences.EXTERNAL_FILE_TYPES, null) == null) {\r\n        externalFileTypes.clear();\r\n        externalFileTypes.addAll(types);\r\n        return;\r\n    }\r\n    String[][] vals = StringUtil.decodeStringDoubleArray(Globals.prefs.get(JabRefPreferences.EXTERNAL_FILE_TYPES, \"\"));\r\n    for (String[] val : vals) {\r\n        if ((val.length == 2) && val[1].equals(FILE_TYPE_REMOVED_FLAG)) {\r\n            ExternalFileType toRemove = null;\r\n            for (ExternalFileType type : types) {\r\n                if (type.getName().equals(val[0])) {\r\n                    toRemove = type;\r\n                    break;\r\n                }\r\n            }\r\n            if (toRemove != null) {\r\n                types.remove(toRemove);\r\n            }\r\n        } else {\r\n            ExternalFileType type = CustomExternalFileType.buildFromArgs(val);\r\n            ExternalFileType toRemove = null;\r\n            for (ExternalFileType defType : types) {\r\n                if (type.getName().equals(defType.getName())) {\r\n                    toRemove = defType;\r\n                    break;\r\n                }\r\n            }\r\n            if (toRemove != null) {\r\n                types.remove(toRemove);\r\n            }\r\n            types.add(type);\r\n        }\r\n    }\r\n    externalFileTypes.addAll(types);\r\n}"
}, {
	"Path": "org.elixir_lang.navigation.item_presentation.Exception.getPresentableText",
	"Comment": "returns the name of the object to be presented in most renderers across the program.",
	"Method": "String getPresentableText(){\r\n    return name;\r\n}"
}, {
	"Path": "org.jabref.logic.exporter.TemplateExporter.withEncoding",
	"Comment": "set an encoding which will be used in preference to the default valueobtained from the basepanel.",
	"Method": "TemplateExporter withEncoding(Charset encoding){\r\n    this.encoding = encoding;\r\n    return this;\r\n}"
}, {
	"Path": "org.menacheri.jetserver.app.impl.DefaultSession.isUDPEnabled",
	"Comment": "not synchronized because default implementation does not care whether a\tduplicated message sender is created.",
	"Method": "SessionBuilder isUDPEnabled(boolean isUDPEnabled,boolean isUDPEnabled){\r\n    return isUDPEnabled;\r\n}"
}, {
	"Path": "com.datastax.driver.core.EventDebouncerIntegrationTest.should_wait_until_load_balancing_policy_is_fully_initialized",
	"Comment": "tests that down, up, remove or add events will not be delivered to load balancing policy norhost state listeners before the cluster is fully initialized.",
	"Method": "void should_wait_until_load_balancing_policy_is_fully_initialized(){\r\n    TestLoadBalancingPolicy policy = new TestLoadBalancingPolicy();\r\n    final Cluster cluster = register(createClusterBuilderNoDebouncing().addContactPoints(getContactPoints().get(0)).withPort(ccm().getBinaryPort()).withLoadBalancingPolicy(policy).build());\r\n    new Thread() {\r\n        @Override\r\n        public void run() {\r\n            cluster.init();\r\n        }\r\n    }.start();\r\n    policy.stop();\r\n    ccm().stop(3);\r\n    ccm().waitForDown(3);\r\n    policy.proceed();\r\n    assertThat(policy.onDownCalledBeforeInit).isFalse();\r\n    assertThat(policy.onDownCalled()).isTrue();\r\n    assertThat(policy.hosts).doesNotContain(TestUtils.findHost(cluster, 3));\r\n}"
}, {
	"Path": "com.datastax.driver.core.EventDebouncerIntegrationTest.should_wait_until_load_balancing_policy_is_fully_initialized",
	"Comment": "tests that down, up, remove or add events will not be delivered to load balancing policy norhost state listeners before the cluster is fully initialized.",
	"Method": "void should_wait_until_load_balancing_policy_is_fully_initialized(){\r\n    cluster.init();\r\n}"
}, {
	"Path": "org.jabref.model.entry.AuthorList.buildWithAffix",
	"Comment": "builds a new array of strings with stringbuilder.regarding to the name affixes.",
	"Method": "StringBuilder buildWithAffix(Collection<Integer> indexArray,List<String> nameList){\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    int avoidedTimes = 0;\r\n    for (int i = 0; i < nameList.size(); i++) {\r\n        if (indexArray.contains(i)) {\r\n            stringBuilder.append(nameList.get(i));\r\n            stringBuilder.append(',');\r\n            avoidedTimes++;\r\n        } else {\r\n            stringBuilder.append(nameList.get(i));\r\n            if (((i + avoidedTimes) % 2) == 0) {\r\n                stringBuilder.append(',');\r\n            } else {\r\n                stringBuilder.append(';');\r\n            }\r\n        }\r\n    }\r\n    return stringBuilder;\r\n}"
}, {
	"Path": "org.jabref.logic.formatter.casechanger.Word.toLowerCase",
	"Comment": "only change letters of the word that are unprotected to lower case.",
	"Method": "void toLowerCase(){\r\n    for (int i = 0; i < chars.length; i++) {\r\n        if (protectedChars[i]) {\r\n            continue;\r\n        }\r\n        chars[i] = Character.toLowerCase(chars[i]);\r\n    }\r\n}"
}, {
	"Path": "com.github.javafaker.Lorem.fixedString",
	"Comment": "create a string with a fixed size. can be useful for testingvalidator based on length string for example",
	"Method": "String fixedString(int numberOfLetters){\r\n    StringBuilder builder = new StringBuilder();\r\n    while (builder.length() < numberOfLetters) {\r\n        builder.append(sentence());\r\n    }\r\n    return StringUtils.substring(builder.toString(), 0, numberOfLetters);\r\n}"
}, {
	"Path": "com.datastax.driver.core.HeartbeatTest.should_send_heartbeat_when_connection_is_inactive",
	"Comment": "ensures that a heartbeat message is sent after the configured heartbeat interval of idle timeand succeeds and continues to be sent as long as the connection remains idle.",
	"Method": "void should_send_heartbeat_when_connection_is_inactive(){\r\n    Cluster cluster = Cluster.builder().addContactPoints(hostAddress.getAddress()).withPort(scassandra.getBinaryPort()).withPoolingOptions(new PoolingOptions().setHeartbeatIntervalSeconds(3)).build();\r\n    try {\r\n        cluster.init();\r\n        for (int i = 0; i < 5; i++) {\r\n            triggerRequestOnControlConnection(cluster);\r\n            SECONDS.sleep(1);\r\n        }\r\n        assertThat(logs.getNext()).doesNotContain(\"sending heartbeat\");\r\n        SECONDS.sleep(4);\r\n        assertThat(logs.getNext()).contains(\"sending heartbeat\").contains(\"heartbeat query succeeded\");\r\n        SECONDS.sleep(4);\r\n        assertThat(logs.getNext()).contains(\"sending heartbeat\").contains(\"heartbeat query succeeded\");\r\n        logs.getNext();\r\n        for (int i = 0; i < 5; i++) {\r\n            triggerRequestOnControlConnection(cluster);\r\n            SECONDS.sleep(1);\r\n        }\r\n        assertThat(logs.getNext()).doesNotContain(\"sending heartbeat\");\r\n        SECONDS.sleep(4);\r\n        assertThat(logs.getNext()).contains(\"sending heartbeat\").contains(\"heartbeat query succeeded\");\r\n    } finally {\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.fieldeditors.LinkedFilesEditorViewModel.findAssociatedNotLinkedFiles",
	"Comment": "find files that are probably associatedto the given entry but not yet linked.",
	"Method": "List<LinkedFileViewModel> findAssociatedNotLinkedFiles(BibEntry entry){\r\n    List<LinkedFileViewModel> result = new ArrayList();\r\n    AutoSetFileLinksUtil util = new AutoSetFileLinksUtil(databaseContext, preferences.getFilePreferences(), preferences.getAutoLinkPreferences(), ExternalFileTypes.getInstance());\r\n    try {\r\n        List<LinkedFile> linkedFiles = util.findAssociatedNotLinkedFiles(entry);\r\n        for (LinkedFile linkedFile : linkedFiles) {\r\n            LinkedFileViewModel newLinkedFile = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences);\r\n            newLinkedFile.markAsAutomaticallyFound();\r\n            result.add(newLinkedFile);\r\n        }\r\n    } catch (IOException e) {\r\n        dialogService.showErrorDialogAndWait(\"Error accessing the file system\", e);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jabref.gui.filelist.FileListTableModel.addEntry",
	"Comment": "add an entry to the table model, and fire a change event. the change eventis fired on the event dispatch thread.",
	"Method": "void addEntry(int index,FileListEntry entry){\r\n    synchronized (list) {\r\n        list.add(index, entry);\r\n        if (SwingUtilities.isEventDispatchThread()) {\r\n            fireTableRowsInserted(index, index);\r\n        } else {\r\n            SwingUtilities.invokeLater(() -> fireTableRowsInserted(index, index));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.ControlConnectionTest.should_randomize_contact_points_when_determining_control_connection",
	"Comment": "ensures that contact points are randomized when determining the initial control connection bydefault. initializes a cluster with 5 contact points 100 times and ensures that all 5 wereused.",
	"Method": "void should_randomize_contact_points_when_determining_control_connection(){\r\n    int hostCount = 5;\r\n    int iterations = 100;\r\n    ScassandraCluster scassandras = ScassandraCluster.builder().withNodes(hostCount).build();\r\n    scassandras.init();\r\n    try {\r\n        Collection<InetAddress> contactPoints = newArrayList();\r\n        for (int i = 1; i <= hostCount; i++) {\r\n            contactPoints.add(scassandras.address(i).getAddress());\r\n        }\r\n        final HashMultiset<InetAddress> occurrencesByHost = HashMultiset.create(hostCount);\r\n        for (int i = 0; i < iterations; i++) {\r\n            Cluster cluster = Cluster.builder().addContactPoints(contactPoints).withPort(scassandras.getBinaryPort()).withNettyOptions(nonQuietClusterCloseOptions).build();\r\n            try {\r\n                cluster.init();\r\n                occurrencesByHost.add(cluster.manager.controlConnection.connectedHost().getAddress());\r\n            } finally {\r\n                cluster.close();\r\n            }\r\n        }\r\n        if (logger.isDebugEnabled()) {\r\n            Map<InetAddress, Integer> hostCounts = Maps.toMap(occurrencesByHost.elementSet(), new Function<InetAddress, Integer>() {\r\n                @Override\r\n                public Integer apply(InetAddress input) {\r\n                    return occurrencesByHost.count(input);\r\n                }\r\n            });\r\n            logger.debug(\"Control Connection Use Counts by Host: {}\", hostCounts);\r\n        }\r\n        assertThat(occurrencesByHost.elementSet().size()).as(\"Not all hosts were used as contact points.  There is a very small chance\" + \" of this happening based on randomness, investigate whether or not this\" + \" is a bug.\").isEqualTo(hostCount);\r\n    } finally {\r\n        scassandras.stop();\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.ControlConnectionTest.should_randomize_contact_points_when_determining_control_connection",
	"Comment": "ensures that contact points are randomized when determining the initial control connection bydefault. initializes a cluster with 5 contact points 100 times and ensures that all 5 wereused.",
	"Method": "void should_randomize_contact_points_when_determining_control_connection(){\r\n    return occurrencesByHost.count(input);\r\n}"
}, {
	"Path": "org.menacheri.jetserver.util.NettyUtils.readString",
	"Comment": "read a string from a channel buffer with the specified length. it resets\tthe reader index of the buffer to the end of the string.",
	"Method": "String readString(ChannelBuffer buffer,String readString,ChannelBuffer buffer,Charset charset,String readString,ChannelBuffer buffer,int length,String readString,ChannelBuffer buffer,int length,Charset charset){\r\n    String str = null;\r\n    if (null == charset) {\r\n        charset = CharsetUtil.UTF_8;\r\n    }\r\n    try {\r\n        ChannelBuffer stringBuffer = buffer.readSlice(length);\r\n        str = stringBuffer.toString(charset);\r\n    } catch (Exception e) {\r\n        LOG.error(\"Error occurred while trying to read string from buffer: {}\", e);\r\n    }\r\n    return str;\r\n}"
}, {
	"Path": "com.github.javafaker.DateAndTime.past",
	"Comment": "generates a past date from now. note that there is a 1 second slack added.",
	"Method": "Date past(int atMost,TimeUnit unit,Date past,int atMost,int minimum,TimeUnit unit,Date past,int atMost,TimeUnit unit,Date referenceDate){\r\n    long upperBound = unit.toMillis(atMost);\r\n    long futureMillis = referenceDate.getTime();\r\n    futureMillis -= 1 + faker.random().nextLong(upperBound - 1);\r\n    return new Date(futureMillis);\r\n}"
}, {
	"Path": "org.elixir_lang.psi.scope.Variable.execute",
	"Comment": "infix operations where either side can declare a variable in a match",
	"Method": "boolean execute(PsiElement element,ResolveState state,boolean execute,Call match,ResolveState state,boolean execute,ElixirContainerAssociationOperation match,ResolveState state,boolean execute,ElixirMapArguments match,ResolveState state,boolean execute,ElixirMapOperation match,ResolveState state,boolean execute,ElixirMatchedWhenOperation match,ResolveState state,boolean execute,ElixirStabNoParenthesesSignature match,ResolveState state,boolean execute,ElixirStabOperation match,ResolveState state,boolean execute,ElixirStabParenthesesSignature match,ResolveState state,boolean execute,ElixirStructOperation match,ResolveState state,boolean execute,In match,ResolveState state,boolean execute,Infix match,ResolveState state,boolean execute,InMatch match,ResolveState state,boolean execute,Match match,ResolveState state,boolean execute,PsiElement[] parameters,ResolveState state,boolean execute,QualifiedMultipleAliases match,ResolveState state,boolean execute,QuotableKeywordList match,ResolveState state,boolean execute,QuotableKeywordPair match,ResolveState state,boolean execute,Type match,ResolveState state,boolean execute,UnaryNonNumericOperation match,ResolveState state){\r\n    Operator operator = match.operator();\r\n    String operatorText = operator.getText();\r\n    boolean keepProcessing = true;\r\n    if (!operatorText.equals(\"^\")) {\r\n        keepProcessing = execute((Call) match, state);\r\n    }\r\n    return keepProcessing;\r\n}"
}, {
	"Path": "com.beust.jcommander.DefaultUsageFormatterTest.nonexistentCommandShouldThrow",
	"Comment": "getting the description of a nonexistent command should throw an exception.",
	"Method": "void nonexistentCommandShouldThrow(){\r\n    String[] argv = {};\r\n    JCommander jc = JCommander.newBuilder().addObject(new Object()).build();\r\n    jc.parse(argv);\r\n    jc.getUsageFormatter().getCommandDescription(\"foo\");\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ClassUtils.isPrimitiveArray",
	"Comment": "check if the given class represents an array of primitives, i.e. boolean,byte, char, short, int, long, float, or double.",
	"Method": "boolean isPrimitiveArray(Class<?> clazz){\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return (clazz.isArray() && clazz.getComponentType().isPrimitive());\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.PathResource.createRelative",
	"Comment": "this implementation creates a fileresource, applying the given pathrelative to the path of the underlying file of this resource descriptor.",
	"Method": "Resource createRelative(String relativePath){\r\n    return new PathResource(this.path.resolve(relativePath));\r\n}"
}, {
	"Path": "org.hotswap.agent.logging.AgentLoggerHandler.printMessage",
	"Comment": "print a message to system.out and optionally to custom stream",
	"Method": "void printMessage(String message){\r\n    String log = \"HOTSWAP AGENT: \" + sdf.format(new Date()) + \" \" + message;\r\n    System.out.println(log);\r\n    if (outputStream != null)\r\n        outputStream.println(log);\r\n}"
}, {
	"Path": "org.jdbi.v3.core.qualifier.Qualifiers.getQualifiers",
	"Comment": "returns the set of qualifying annotations on the given elements.",
	"Method": "Set<Annotation> getQualifiers(AnnotatedElement elements){\r\n    return Arrays.stream(elements).filter(Objects::nonNull).map(AnnotatedElement::getAnnotations).flatMap(Arrays::stream).filter(anno -> anno.annotationType().isAnnotationPresent(Qualifier.class)).collect(toSet());\r\n}"
}, {
	"Path": "org.elixir_lang.code_insight.highlighting.brace_matcher.Paired.isPairedBracesAllowedBeforeType",
	"Comment": "returns true if paired rbrace should be inserted after lbrace of given type when lbrace is encountered beforecontexttype token. it is safe to always return true, then paired brace will be inserted anyway.",
	"Method": "boolean isPairedBracesAllowedBeforeType(IElementType lbraceType,IElementType contextType){\r\n    return true;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.result.ResultIterable.withStream",
	"Comment": "passes the stream of results to the callback. database resources owned by the query arereleased before this method returns.",
	"Method": "R withStream(StreamCallback<T, R, X> callback){\r\n    try (Stream<T> stream = stream()) {\r\n        return callback.withStream(stream);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.importer.FulltextFetcher.getTrustLevel",
	"Comment": "returns the level of trust for this fetcher.we distinguish between publishers and meta search engines for example.",
	"Method": "TrustLevel getTrustLevel(){\r\n    return TrustLevel.UNKNOWN;\r\n}"
}, {
	"Path": "org.jabref.logic.search.SearchQuery.isGrammarBasedSearch",
	"Comment": "tests if the query is an advanced search query described as described in the help",
	"Method": "boolean isGrammarBasedSearch(){\r\n    return rule instanceof GrammarBasedSearchRule;\r\n}"
}, {
	"Path": "com.datastax.driver.mapping.MapperSaveNullFieldsTest.should_order_save_query_prepared_statement_columns_consistently",
	"Comment": "ensure that queries generated between different sessions consistently generates the sameprepared statement query for different permutations of null columns being present and saved.",
	"Method": "void should_order_save_query_prepared_statement_columns_consistently(){\r\n    List<List<String>> allSessionStatements = Lists.newArrayList();\r\n    for (int i = 0; i < 5; i++) {\r\n        Session session = cluster().connect(keyspace);\r\n        Mapper<User> userMapper = new MappingManager(session()).mapper(User.class);\r\n        List<String> statements = Lists.newArrayList();\r\n        statements.add(getQuery(userMapper, false, false, Option.saveNullFields(false)));\r\n        statements.add(getQuery(userMapper, true, true, Option.saveNullFields(false)));\r\n        statements.add(getQuery(userMapper, true, false, Option.saveNullFields(false)));\r\n        statements.add(getQuery(userMapper, false, true, Option.saveNullFields(false)));\r\n        allSessionStatements.add(statements);\r\n        session.close();\r\n    }\r\n    int statementCount = allSessionStatements.iterator().next().size();\r\n    for (int i = 0; i < statementCount; i++) {\r\n        Set<String> uniqueStatements = Sets.newTreeSet();\r\n        for (List<String> statements : allSessionStatements) {\r\n            uniqueStatements.add(statements.get(i));\r\n        }\r\n        assertThat(uniqueStatements).as(\"Expected only one statement permutation, must not be ordered consistently.\").hasSize(1);\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.PreparedStatementTest.should_create_tombstone_when_null_value_on_batch_statement",
	"Comment": "tests that a tombstone is created when binding a null value to a column in a batch statement.",
	"Method": "void should_create_tombstone_when_null_value_on_batch_statement(){\r\n    PreparedStatement prepared = session().prepare(\"INSERT INTO \" + SIMPLE_TABLE + \" (k, i) VALUES (?, ?)\");\r\n    BoundStatement st1 = prepared.bind();\r\n    st1.setString(0, \"foo\");\r\n    st1.setToNull(1);\r\n    session().execute(new BatchStatement().add(st1));\r\n    Statement st2 = new SimpleStatement(\"SELECT i from \" + SIMPLE_TABLE + \" where k = 'foo'\");\r\n    st2.enableTracing();\r\n    ResultSet rows = session().execute(st2);\r\n    assertThat(rows.one().isNull(0)).isTrue();\r\n    Uninterruptibles.sleepUninterruptibly(10, TimeUnit.SECONDS);\r\n    QueryTrace queryTrace = rows.getExecutionInfo().getQueryTrace();\r\n    assertEventsContain(queryTrace, \"1 tombstone\");\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.reflect.Metaobject.getParameterTypes",
	"Comment": "returns an array of class objects representing theformal parameter types of the method specifiedby identifier.",
	"Method": "Class<?>[] getParameterTypes(int identifier){\r\n    return methods[identifier].getParameterTypes();\r\n}"
}, {
	"Path": "com.datastax.driver.core.QueryLogger.setMaxLoggedParameters",
	"Comment": "set the maximum number of query parameters that can be logged by the driver. queries with anumber of parameters higher than this value will not have all their parameters logged.",
	"Method": "void setMaxLoggedParameters(int maxLoggedParameters){\r\n    if (maxLoggedParameters <= 0 && maxLoggedParameters != -1)\r\n        throw new IllegalArgumentException(\"Invalid maxLoggedParameters, should be > 0 or -1, got \" + maxLoggedParameters);\r\n    this.maxLoggedParameters = maxLoggedParameters;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.util.proxy.RuntimeSupport.findSuperClassMethod",
	"Comment": "finds a method that has the given name and descriptor and is declaredin the super class.",
	"Method": "Method findSuperClassMethod(Class<?> clazz,String name,String desc){\r\n    Method m = findSuperMethod2(clazz.getSuperclass(), name, desc);\r\n    if (m == null)\r\n        m = searchInterfaces(clazz, name, desc);\r\n    if (m == null)\r\n        error(clazz, name, desc);\r\n    return m;\r\n}"
}, {
	"Path": "com.datastax.driver.core.ProtocolV1Test.should_execute_query_with_no_variables",
	"Comment": "validates that a simple query with no variables is correctly executed.",
	"Method": "void should_execute_query_with_no_variables(){\r\n    session().execute(\"select * from system.local\");\r\n}"
}, {
	"Path": "org.jdbi.v3.core.mapper.reflect.ReflectionMapperUtil.anyColumnsStartWithPrefix",
	"Comment": "returns whether any of the given column names begin with the given prefix, according to the list of column namematchers.",
	"Method": "boolean anyColumnsStartWithPrefix(Collection<String> columnNames,String prefix,List<ColumnNameMatcher> columnNameMatchers){\r\n    return columnNames.stream().anyMatch(columnName -> columnNameMatchers.stream().anyMatch(matcher -> matcher.columnNameStartsWith(columnName, prefix)));\r\n}"
}, {
	"Path": "com.datastax.driver.mapping.MapperTest.should_flag_all_mapper_generated_statements_as_idempotent",
	"Comment": "ensures that all statements generated by the mapper are flagged as idempotent.",
	"Method": "void should_flag_all_mapper_generated_statements_as_idempotent(){\r\n    MappingManager manager = new MappingManager(session());\r\n    Mapper<User> mapper = manager.mapper(User.class);\r\n    User u = new User(\"Paul\", \"paul@yahoo.com\");\r\n    Statement saveQuery = mapper.saveQuery(u);\r\n    assertThat(saveQuery.isIdempotent()).isTrue();\r\n    Statement getQuery = mapper.getQuery(u.getUserId());\r\n    assertThat(saveQuery.isIdempotent()).isTrue();\r\n    Statement deleteQuery = mapper.deleteQuery(u.getUserId());\r\n    assertThat(saveQuery.isIdempotent()).isTrue();\r\n}"
}, {
	"Path": "org.jabref.logic.shared.PostgreSQLProcessor.setUp",
	"Comment": "creates and sets up the needed tables and columns according to the database type.",
	"Method": "void setUp(){\r\n    connection.createStatement().executeUpdate(\"CREATE TABLE IF NOT EXISTS \\\"ENTRY\\\" (\" + \"\\\"SHARED_ID\\\" SERIAL PRIMARY KEY, \" + \"\\\"TYPE\\\" VARCHAR, \" + \"\\\"VERSION\\\" INTEGER DEFAULT 1)\");\r\n    connection.createStatement().executeUpdate(\"CREATE TABLE IF NOT EXISTS \\\"FIELD\\\" (\" + \"\\\"ENTRY_SHARED_ID\\\" INTEGER REFERENCES \\\"ENTRY\\\"(\\\"SHARED_ID\\\") ON DELETE CASCADE, \" + \"\\\"NAME\\\" VARCHAR, \" + \"\\\"VALUE\\\" TEXT)\");\r\n    connection.createStatement().executeUpdate(\"CREATE TABLE IF NOT EXISTS \\\"METADATA\\\" (\" + \"\\\"KEY\\\" VARCHAR,\" + \"\\\"VALUE\\\" TEXT)\");\r\n}"
}, {
	"Path": "org.elixir_lang.navigation.item_presentation.Overridable.getPresentableText",
	"Comment": "returns the name of the object to be presented in most renderers across the program.",
	"Method": "String getPresentableText(){\r\n    return DEFOVERRIDABLE;\r\n}"
}, {
	"Path": "org.hotswap.agent.tutorial.framework.PrinterSourceScanner.scanPackageForPrintSources",
	"Comment": "standard framework usually has custom methods to scan files.",
	"Method": "List<PrintSource> scanPackageForPrintSources(String sourcePackage){\r\n    final List<PrintSource> discoveredSources = new ArrayList();\r\n    String sourcePath = sourcePackage.replace(\".\", \"/\");\r\n    new ClassPathScanner().scan(getClass().getClassLoader(), sourcePath, new ScannerVisitor() {\r\n        @Override\r\n        public void visit(InputStream file) throws IOException {\r\n            ClassFile cf;\r\n            try {\r\n                DataInputStream dstream = new DataInputStream(file);\r\n                cf = new ClassFile(dstream);\r\n                for (String iface : cf.getInterfaces()) {\r\n                    if (iface.equals(PrintSource.class.getName())) {\r\n                        Class<PrintSource> printSource = (Class<PrintSource>) getClass().getClassLoader().loadClass(cf.getName());\r\n                        discoveredSources.add(printSource.newInstance());\r\n                    }\r\n                }\r\n            } catch (IOException e) {\r\n                throw new IOException(\"Stream not a valid classFile\", e);\r\n            } catch (ClassNotFoundException e) {\r\n                throw new IOException(\"Discovered class not found by classloader\", e);\r\n            } catch (IllegalAccessException e) {\r\n                throw new IOException(\"Unable to create new instance\", e);\r\n            } catch (InstantiationException e) {\r\n                throw new IOException(\"Print source does not contain no-arg constructor\", e);\r\n            }\r\n        }\r\n    });\r\n    return discoveredSources;\r\n}"
}, {
	"Path": "org.hotswap.agent.tutorial.framework.PrinterSourceScanner.scanPackageForPrintSources",
	"Comment": "standard framework usually has custom methods to scan files.",
	"Method": "List<PrintSource> scanPackageForPrintSources(String sourcePackage){\r\n    ClassFile cf;\r\n    try {\r\n        DataInputStream dstream = new DataInputStream(file);\r\n        cf = new ClassFile(dstream);\r\n        for (String iface : cf.getInterfaces()) {\r\n            if (iface.equals(PrintSource.class.getName())) {\r\n                Class<PrintSource> printSource = (Class<PrintSource>) getClass().getClassLoader().loadClass(cf.getName());\r\n                discoveredSources.add(printSource.newInstance());\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        throw new IOException(\"Stream not a valid classFile\", e);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new IOException(\"Discovered class not found by classloader\", e);\r\n    } catch (IllegalAccessException e) {\r\n        throw new IOException(\"Unable to create new instance\", e);\r\n    } catch (InstantiationException e) {\r\n        throw new IOException(\"Print source does not contain no-arg constructor\", e);\r\n    }\r\n}"
}, {
	"Path": "org.elixir_lang.formatting.ModelBuilder.createModel",
	"Comment": "requests building the formatting model for a section of the file containingthe specified psi element and its children.",
	"Method": "FormattingModel createModel(PsiElement element,CodeStyleSettings settings){\r\n    PsiFile containingFile = element.getContainingFile();\r\n    if (DUMP_FORMATTING_AST) {\r\n        System.out.println(\"AST tree for \" + containingFile.getName() + \":\");\r\n        printAST(containingFile.getNode(), 0);\r\n    }\r\n    Block block = new Block(element.getNode(), createSpaceBuilder(settings));\r\n    if (DUMP_FORMATTING_AST) {\r\n        FormattingModelDumper.dumpFormattingModel(block, 2, System.out);\r\n    }\r\n    return FormattingModelProvider.createFormattingModelForPsiFile(containingFile, block, settings);\r\n}"
}, {
	"Path": "me.ramswaroop.jbot.core.slack.Bot.afterConnectionEstablished",
	"Comment": "invoked after a successful web socket connection isestablished. you can override this method in the child classes.",
	"Method": "void afterConnectionEstablished(WebSocketSession session){\r\n    logger.debug(\"WebSocket connected: {}\", session);\r\n}"
}, {
	"Path": "org.jabref.gui.groups.GroupAddRemoveDialog.checkGroupEnable",
	"Comment": "check if we can perform the action for this group. determines whetherthe group should be shown in an enabled state, and if selecting it shouldleave the ok button enabled.",
	"Method": "boolean checkGroupEnable(GroupTreeNodeViewModel node){\r\n    return (add ? node.canAddEntries(selection) : node.canRemoveEntries(selection));\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.StatementContext.findMapperFor",
	"Comment": "obtain a mapper for the given qualified type in this context.",
	"Method": "Optional<RowMapper<T>> findMapperFor(Class<T> type,Optional<RowMapper<T>> findMapperFor,GenericType<T> type,Optional<RowMapper<?>> findMapperFor,Type type,Optional<RowMapper<?>> findMapperFor,QualifiedType type){\r\n    return getConfig(Mappers.class).findFor(type);\r\n}"
}, {
	"Path": "me.ramswaroop.jbot.core.slack.SlackService.connectRTM",
	"Comment": "start a rtm connection. fetch the web socket url to connect to, current user detailsand list of channel ids where the current user has had conversation.",
	"Method": "void connectRTM(String slackToken){\r\n    RTM rtm = restTemplate.getForEntity(slackApiEndpoints.getRtmConnectApi(), RTM.class, slackToken).getBody();\r\n    currentUser = rtm.getSelf();\r\n    webSocketUrl = rtm.getUrl();\r\n    getImChannels(slackToken, 200, \"\");\r\n}"
}, {
	"Path": "org.jabref.gui.BasePanel.saveDividerLocation",
	"Comment": "depending on whether a preview or an entry editor is showing, save the current divider location in the correct preference setting.",
	"Method": "void saveDividerLocation(Number position){\r\n    if (position == null) {\r\n        return;\r\n    }\r\n    if (mode == BasePanelMode.SHOWING_PREVIEW) {\r\n        PreviewPreferences previewPreferences = Globals.prefs.getPreviewPreferences().getBuilder().withPreviewPanelDividerPosition(position).build();\r\n        Globals.prefs.storePreviewPreferences(previewPreferences);\r\n    } else if (mode == BasePanelMode.SHOWING_EDITOR) {\r\n        preferences.setEntryEditorDividerPosition(position.doubleValue());\r\n    }\r\n}"
}, {
	"Path": "org.elixir_lang.structure_view.Model.getSuitableClasses",
	"Comment": "returns the list of psi element classes which are shown as structure view elements.when determining the current editor element, the psi tree is walked up until an elementmatching one of these classes is found.",
	"Method": "Class[] getSuitableClasses(){\r\n    return new Class[] { Call.class, ElixirAtom.class, QuotableKeywordPair.class };\r\n}"
}, {
	"Path": "com.datastax.driver.core.ThreadingOptions.createReconnectionExecutor",
	"Comment": "builds the executor when reconnection attempts will be scheduled.the default implementation uses 2 threads.",
	"Method": "ScheduledExecutorService createReconnectionExecutor(String clusterName){\r\n    return new ScheduledThreadPoolExecutor(2, createThreadFactory(clusterName, \"reconnection\"));\r\n}"
}, {
	"Path": "com.datastax.driver.core.QueryOptions.getMaxPendingRefreshNodeListRequests",
	"Comment": "sets the maximum number of node list refresh requests that the control connection canaccumulate before executing them.",
	"Method": "int getMaxPendingRefreshNodeListRequests(){\r\n    return maxPendingRefreshNodeListRequests;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.PathResource.getInputStream",
	"Comment": "this implementation opens a inputstream for the underlying file.",
	"Method": "InputStream getInputStream(){\r\n    if (!exists()) {\r\n        throw new FileNotFoundException(getPath() + \" (no such file or directory)\");\r\n    }\r\n    if (Files.isDirectory(this.path)) {\r\n        throw new FileNotFoundException(getPath() + \" (is a directory)\");\r\n    }\r\n    return Files.newInputStream(this.path);\r\n}"
}, {
	"Path": "org.elixir_lang.parser.ElixirParser.mapUpdateArguments",
	"Comment": "matchedmatchoperation pipeinfixoperator maptailarguments",
	"Method": "boolean mapUpdateArguments(PsiBuilder b,int l){\r\n    if (!recursion_guard_(b, l, \"mapUpdateArguments\"))\r\n        return false;\r\n    boolean r;\r\n    Marker m = enter_section_(b, l, _NONE_, MAP_UPDATE_ARGUMENTS, \"<map update arguments>\");\r\n    r = matchedExpression(b, l + 1, 6);\r\n    r = r && pipeInfixOperator(b, l + 1);\r\n    r = r && mapTailArguments(b, l + 1);\r\n    exit_section_(b, l, m, r, false, null);\r\n    return r;\r\n}"
}, {
	"Path": "org.menacheri.jetclient.util.NettyUtils.clearPipeline",
	"Comment": "a utility method to clear the netty pipeline of all handlers.",
	"Method": "void clearPipeline(ChannelPipeline pipeline){\r\n    while (pipeline.getFirst() != null) {\r\n        pipeline.removeFirst();\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.PluginManagerInvokerTest.registerPlugin",
	"Comment": "plugin registration is not public, use reflection to insert test data",
	"Method": "void registerPlugin(Object plugin){\r\n    Field f = PluginRegistry.class.getDeclaredField(\"registeredPlugins\");\r\n    f.setAccessible(true);\r\n    Map<Class, Map<ClassLoader, Object>> registeredPlugins = (Map<Class, Map<ClassLoader, Object>>) f.get(PluginManager.getInstance().getPluginRegistry());\r\n    registeredPlugins.put(plugin.getClass(), Collections.singletonMap(getClass().getClassLoader(), plugin));\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.util.proxy.FactoryHelper.toClass",
	"Comment": "loads a class file by a given class loader.this method uses a default protection domain for the classbut it may not work with a security manager or a signed jar file.",
	"Method": "Class<?> toClass(ClassFile cf,ClassLoader loader,Class<?> toClass,ClassFile cf,Class<?> neighbor,ClassLoader loader,ProtectionDomain domain,Class<?> toClass,ClassFile cf,java.lang.invoke.MethodHandles.Lookup lookup){\r\n    try {\r\n        byte[] b = toBytecode(cf);\r\n        return DefineClassHelper.toClass(lookup, b);\r\n    } catch (IOException e) {\r\n        throw new CannotCompileException(e);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.jersey1.Jersey1Plugin.registerJerseyContainer",
	"Comment": "register the jersey container and the classes involved in configuring the jersey application",
	"Method": "void registerJerseyContainer(Object jerseyContainer,Object resourceConfig){\r\n    try {\r\n        Class<?> resourceConfigClass = resolveClass(\"com.sun.jersey.api.core.ResourceConfig\");\r\n        LOGGER.info(\"registerJerseyContainer : \" + jerseyContainer.getClass().getName());\r\n        Set<Class<?>> containerClasses = getContainerClasses(resourceConfigClass, resourceConfig);\r\n        registeredJerseyContainers.add(jerseyContainer);\r\n        allRegisteredClasses.addAll(containerClasses);\r\n        LOGGER.debug(\"registerJerseyContainer : finished\");\r\n    } catch (Exception e) {\r\n        LOGGER.error(\"Error registering Jersey Container.\", e);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.customentrytypes.FieldSetComponent.addField",
	"Comment": "this method is called when a new field should be added to the list. performs validation of thefield.",
	"Method": "void addField(String str){\r\n    String s = str.trim();\r\n    if (forceLowerCase) {\r\n        s = s.toLowerCase(Locale.ROOT);\r\n    }\r\n    if (\"\".equals(s) || listModel.contains(s)) {\r\n        return;\r\n    }\r\n    String testString = BibtexKeyGenerator.cleanKey(s, Globals.prefs.getBoolean(JabRefPreferences.ENFORCE_LEGAL_BIBTEX_KEY));\r\n    if (!testString.equals(s) || (s.indexOf('&') >= 0)) {\r\n        JOptionPane.showMessageDialog(this, Localization.lang(\"Field names are not allowed to contain white space or the following \" + \"characters\") + \": # { } ~ , ^ &\", Localization.lang(\"Error\"), JOptionPane.ERROR_MESSAGE);\r\n        return;\r\n    }\r\n    addFieldUncritically(s);\r\n}"
}, {
	"Path": "com.datastax.driver.core.PreparedStatementTest.should_not_allow_unbound_value_on_bound_statement_when_protocol_lesser_than_v4",
	"Comment": "tests that, under protocol versions lesser than v4, it is not possible to execute a preparedstatement with unbound values. note that we have to force protocol version to less than v4because higher protocol versions would allow such unbound values to be sent.",
	"Method": "void should_not_allow_unbound_value_on_bound_statement_when_protocol_lesser_than_v4(){\r\n    Cluster cluster = register(Cluster.builder().addContactPoints(getContactPoints()).withPort(ccm().getBinaryPort()).withProtocolVersion(ccm().getProtocolVersion(ProtocolVersion.V3)).build());\r\n    Session session = cluster.connect();\r\n    try {\r\n        PreparedStatement ps = session.prepare(\"INSERT INTO \" + keyspace + \".\" + SIMPLE_TABLE + \" (k, i) VALUES (?, ?)\");\r\n        BoundStatement bs = ps.bind(\"foo\");\r\n        assertFalse(bs.isSet(\"i\"));\r\n        session.execute(bs);\r\n        fail(\"Should not have executed statement with UNSET values in protocol V3\");\r\n    } catch (IllegalStateException e) {\r\n        assertThat(e.getMessage()).contains(\"Unset value at index 1\");\r\n    }\r\n}"
}, {
	"Path": "org.jabref.model.ChainNode.moveTo",
	"Comment": "removes this node from its parent and makes it a child of the specified node.in this way the whole subchain based at this node is moved to the given node.",
	"Method": "void moveTo(T target){\r\n    Objects.requireNonNull(target);\r\n    if (this.isAncestorOf(target)) {\r\n        throw new UnsupportedOperationException(\"the target cannot be a descendant of this node\");\r\n    }\r\n    getParent().ifPresent(oldParent -> oldParent.removeChild());\r\n    target.setChild((T) this);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.weld.command.BeanClassRefreshCommand.isDeleteEvent",
	"Comment": "check all merged events with same classname for delete and create events. if delete without create is found, than assumefile was deleted.",
	"Method": "boolean isDeleteEvent(List<Command> mergedCommands){\r\n    boolean createFound = false;\r\n    boolean deleteFound = false;\r\n    for (Command cmd : mergedCommands) {\r\n        BeanClassRefreshCommand refreshCommand = (BeanClassRefreshCommand) cmd;\r\n        if (className.equals(refreshCommand.className)) {\r\n            if (refreshCommand.event != null) {\r\n                if (refreshCommand.event.getEventType().equals(FileEvent.DELETE))\r\n                    deleteFound = true;\r\n                if (refreshCommand.event.getEventType().equals(FileEvent.CREATE))\r\n                    createFound = true;\r\n            }\r\n        }\r\n    }\r\n    LOGGER.trace(\"isDeleteEvent result {}: createFound={}, deleteFound={}\", createFound, deleteFound);\r\n    return !createFound && deleteFound;\r\n}"
}, {
	"Path": "com.github.javafaker.service.FakeValuesService.regexify",
	"Comment": "generates a string that matches the given regular expression.",
	"Method": "String regexify(String regex){\r\n    Generex generex = new Generex(regex);\r\n    generex.setSeed(randomService.nextLong());\r\n    return generex.random();\r\n}"
}, {
	"Path": "com.datastax.driver.core.KeyspaceMetadata.getTable",
	"Comment": "returns the metadata for a table contained in this keyspace.",
	"Method": "TableMetadata getTable(String name){\r\n    return tables.get(Metadata.handleId(name));\r\n}"
}, {
	"Path": "org.menacheri.jetclient.util.LoginHelper.getReconnectBuffer",
	"Comment": "creates a wrapped netty buffer with reconnect key and udp address as its\tpayload.",
	"Method": "MessageBuffer<ChannelBuffer> getReconnectBuffer(String reconnectKey,InetSocketAddress udpAddress){\r\n    ChannelBuffer reconnectBuffer = null;\r\n    ChannelBuffer buffer = NettyUtils.writeString(reconnectKey);\r\n    if (null != udpAddress) {\r\n        reconnectBuffer = ChannelBuffers.wrappedBuffer(buffer, NettyUtils.writeSocketAddress(udpAddress));\r\n    } else {\r\n        reconnectBuffer = buffer;\r\n    }\r\n    return new NettyMessageBuffer(reconnectBuffer);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ClassUtils.registerCommonClasses",
	"Comment": "register the given common classes with the classutils cache.",
	"Method": "void registerCommonClasses(Class<?> commonClasses){\r\n    for (Class<?> clazz : commonClasses) {\r\n        commonClassCache.put(clazz.getName(), clazz);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.test.util.HotSwapTestHelper.__toVersion__Delayed",
	"Comment": "redefines all inner classes of a outer class to a specified version. inner classes who do not have a particularrepresentation for a version remain unchanged.caller class is used as an outer class.",
	"Method": "void __toVersion__Delayed(int versionNumber,Class<?> extra){\r\n    MultistepProxyTransformer.addThirdStep = true;\r\n    HotSwapTool.toVersion(determineOuter(0), versionNumber, extra);\r\n    WaitHelper.waitForCommand(new WaitHelper.Command() {\r\n        @Override\r\n        public boolean result() throws Exception {\r\n            return !CglibProxyTransformer.isReloadingInProgress() && !JavaProxyTransformer.isReloadingInProgress();\r\n        }\r\n    });\r\n    MultistepProxyTransformer.addThirdStep = false;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.test.util.HotSwapTestHelper.__toVersion__Delayed",
	"Comment": "redefines all inner classes of a outer class to a specified version. inner classes who do not have a particularrepresentation for a version remain unchanged.caller class is used as an outer class.",
	"Method": "void __toVersion__Delayed(int versionNumber,Class<?> extra){\r\n    return !CglibProxyTransformer.isReloadingInProgress() && !JavaProxyTransformer.isReloadingInProgress();\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.jvm.AnonymousClassInfos.searchForMappings",
	"Comment": "iterate through both lists and find matching anonymous classes using matcher.found matches are removed from previous and current lists and added to transitions.",
	"Method": "void searchForMappings(Map<AnonymousClassInfo, AnonymousClassInfo> transitions,List<AnonymousClassInfo> previousInfos,List<AnonymousClassInfo> currentInfos,AnonymousClassInfoMatcher matcher){\r\n    for (ListIterator<AnonymousClassInfo> previousIt = previousInfos.listIterator(); previousIt.hasNext(); ) {\r\n        AnonymousClassInfo previous = previousIt.next();\r\n        for (ListIterator<AnonymousClassInfo> currentIt = currentInfos.listIterator(); currentIt.hasNext(); ) {\r\n            AnonymousClassInfo current = currentIt.next();\r\n            if (matcher.match(previous, current)) {\r\n                transitions.put(previous, current);\r\n                previousIt.remove();\r\n                currentIt.remove();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ClassUtils.isVisible",
	"Comment": "check whether the given class is visible in the given classloader.",
	"Method": "boolean isVisible(Class<?> clazz,ClassLoader classLoader){\r\n    if (classLoader == null) {\r\n        return true;\r\n    }\r\n    try {\r\n        Class<?> actualClass = classLoader.loadClass(clazz.getName());\r\n        return (clazz == actualClass);\r\n    } catch (ClassNotFoundException ex) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.FunctionMetadataTest.should_parse_and_format_functions_with_complex_arguments",
	"Comment": "ensures that functions whose arguments contain complex types such as tuples and collections,and nested combinations thereof, are correctly parsed.",
	"Method": "void should_parse_and_format_functions_with_complex_arguments(){\r\n    String cql = String.format(\"CREATE FUNCTION %s.complex(x tuple<tuple<int>, map<int, int>>) RETURNS NULL ON NULL INPUT RETURNS int LANGUAGE java AS 'return 42;';\", keyspace);\r\n    session().execute(cql);\r\n    KeyspaceMetadata keyspace = cluster().getMetadata().getKeyspace(this.keyspace);\r\n    DataType argumentType = cluster().getMetadata().newTupleType(cluster().getMetadata().newTupleType(cint()), map(cint(), cint()));\r\n    FunctionMetadata function = keyspace.getFunction(\"complex\", argumentType);\r\n    assertThat(function).isNotNull();\r\n    assertThat(function.getKeyspace()).isEqualTo(keyspace);\r\n    assertThat(function.getSignature()).isEqualTo(\"complex(tuple<tuple<int>, map<int, int>>)\");\r\n    assertThat(function.getSimpleName()).isEqualTo(\"complex\");\r\n    assertThat(function.getReturnType()).isEqualTo(cint());\r\n    assertThat(function.getArguments()).containsEntry(\"x\", argumentType);\r\n    assertThat(function.getLanguage()).isEqualTo(\"java\");\r\n    assertThat(function.getBody()).isEqualTo(\"return 42;\");\r\n    assertThat(function.isCalledOnNullInput()).isFalse();\r\n    assertThat(function.toString()).isEqualTo(cql);\r\n    assertThat(function.exportAsString()).isEqualTo(String.format(\"CREATE FUNCTION %s.complex(x tuple<tuple<int>, map<int, int>>)\\n\" + \"    RETURNS NULL ON NULL INPUT\\n\" + \"    RETURNS int\\n\" + \"    LANGUAGE java\\n\" + \"    AS 'return 42;';\", this.keyspace));\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.SqlStatement.cleanupHandleRollback",
	"Comment": "when the statement is closed, roll it back then close the owning handle.",
	"Method": "This cleanupHandleRollback(){\r\n    return cleanupHandle(Handle::rollback);\r\n}"
}, {
	"Path": "org.jabref.logic.openoffice.OOBibStyle.handleStructureLine",
	"Comment": "parse a line providing bibliography structure information for an entry type.",
	"Method": "void handleStructureLine(String line){\r\n    int index = line.indexOf('=');\r\n    if ((index > 0) && (index < (line.length() - 1))) {\r\n        String formatString = line.substring(index + 1);\r\n        boolean setDefault = line.substring(0, index).equals(OOBibStyle.DEFAULT_MARK);\r\n        String type = line.substring(0, index);\r\n        try {\r\n            Layout layout = new LayoutHelper(new StringReader(formatString), this.prefs).getLayoutFromText();\r\n            if (setDefault) {\r\n                defaultBibLayout = layout;\r\n            } else {\r\n                bibLayout.put(type.toLowerCase(Locale.ENGLISH), layout);\r\n            }\r\n        } catch (IOException ex) {\r\n            LOGGER.warn(\"Cannot parse bibliography structure\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.search.SearchQuery.getSearchWords",
	"Comment": "returns a list of words this query searches for.the returned strings can be a regular expression.",
	"Method": "List<String> getSearchWords(){\r\n    if (isRegularExpression()) {\r\n        return Collections.singletonList(getQuery());\r\n    } else {\r\n        return (new SentenceAnalyzer(getQuery())).getWords();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fetcher.IacrEprintFetcherTest.getIdsFor",
	"Comment": "helper method for allnonwithdrawnidswitholdhtmlformat.",
	"Method": "List<String> getIdsFor(int year,int maxId){\r\n    List<String> result = new ArrayList();\r\n    for (int i = 1; i <= maxId; i++) {\r\n        result.add(String.format(\"d/d\", year, i));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jabref.gui.keyboard.KeyBindingRepository.checkKeyCombinationEquality",
	"Comment": "check if the given keycombination equals the given keyevent",
	"Method": "boolean checkKeyCombinationEquality(KeyCombination combination,KeyEvent keyEvent,boolean checkKeyCombinationEquality,KeyBinding binding,KeyEvent keyEvent){\r\n    KeyCombination keyCombination = getKeyCombination(binding);\r\n    return checkKeyCombinationEquality(keyCombination, keyEvent);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.AbstractProxyBytecodeTransformer.addInitCallToMethods",
	"Comment": "adds the initcall as java code to all the non static methods of the class. the initialization is only done if\tclinitfieldname is false. responsibility to set the clinitfieldname is on the initcall.",
	"Method": "void addInitCallToMethods(CtClass cc,String clinitFieldName,String initCall){\r\n    CtMethod[] methods = cc.getDeclaredMethods();\r\n    for (CtMethod ctMethod : methods) {\r\n        if (!ctMethod.isEmpty() && !Modifier.isStatic(ctMethod.getModifiers())) {\r\n            ctMethod.insertBefore(\"if(!\" + clinitFieldName + \"){synchronized(\" + cc.getName() + \".class){if(!\" + clinitFieldName + \"){\" + initCall + \"}}}\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolTest.should_wait_on_connection_if_zero_core_connections",
	"Comment": "ensures that if a pool is created with zero core connections that when a request is first sentthat one and only one connection is created and that it waits on availability of thatconnection and returns it.",
	"Method": "void should_wait_on_connection_if_zero_core_connections(){\r\n    int readTimeout = 1000;\r\n    int reconnectInterval = 1000;\r\n    Cluster cluster = this.createClusterBuilder().withSocketOptions(new SocketOptions().setConnectTimeoutMillis(readTimeout).setReadTimeoutMillis(reconnectInterval)).withReconnectionPolicy(new ConstantReconnectionPolicy(1000)).build();\r\n    try {\r\n        cluster.init();\r\n        assertThat(cluster).hasOpenControlConnection();\r\n        Connection.Factory factory = spy(cluster.manager.connectionFactory);\r\n        cluster.manager.connectionFactory = factory;\r\n        HostConnectionPool pool = createPool(cluster, 0, 2);\r\n        assertThat(pool.connections).hasSize(0);\r\n        assertThat(cluster).host(1).hasState(Host.State.UP);\r\n        assertThat(cluster).hasOpenControlConnection();\r\n        reset(factory);\r\n        MockRequest request = MockRequest.send(pool, 1);\r\n        verify(factory, timeout(readTimeout).times(1)).open(any(HostConnectionPool.class));\r\n        assertPoolSize(pool, 1);\r\n        Uninterruptibles.getUninterruptibly(request.requestInitialized, 10, TimeUnit.SECONDS);\r\n        request.simulateSuccessResponse();\r\n    } finally {\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.SchemaParser.updateKeyspaces",
	"Comment": "this method also takes care of triggering the relevant events",
	"Method": "void updateKeyspaces(Metadata metadata,Map<String, KeyspaceMetadata> oldKeyspaces,Map<String, KeyspaceMetadata> newKeyspaces,String keyspaceToRebuild){\r\n    Iterator<KeyspaceMetadata> it = oldKeyspaces.values().iterator();\r\n    while (it.hasNext()) {\r\n        KeyspaceMetadata oldKeyspace = it.next();\r\n        String keyspaceName = oldKeyspace.getName();\r\n        if ((keyspaceToRebuild == null || keyspaceToRebuild.equals(keyspaceName)) && !newKeyspaces.containsKey(keyspaceName)) {\r\n            it.remove();\r\n            metadata.triggerOnKeyspaceRemoved(oldKeyspace);\r\n        }\r\n    }\r\n    for (KeyspaceMetadata newKeyspace : newKeyspaces.values()) {\r\n        KeyspaceMetadata oldKeyspace = oldKeyspaces.put(newKeyspace.getName(), newKeyspace);\r\n        if (oldKeyspace == null) {\r\n            metadata.triggerOnKeyspaceAdded(newKeyspace);\r\n        } else if (!oldKeyspace.equals(newKeyspace)) {\r\n            metadata.triggerOnKeyspaceChanged(newKeyspace, oldKeyspace);\r\n        }\r\n        Map<String, TableMetadata> oldTables = oldKeyspace == null ? new HashMap<String, TableMetadata>() : oldKeyspace.tables;\r\n        updateTables(metadata, oldTables, newKeyspace.tables, null);\r\n        Map<String, UserType> oldTypes = oldKeyspace == null ? new HashMap<String, UserType>() : oldKeyspace.userTypes;\r\n        updateUserTypes(metadata, oldTypes, newKeyspace.userTypes, null);\r\n        Map<String, FunctionMetadata> oldFunctions = oldKeyspace == null ? new HashMap<String, FunctionMetadata>() : oldKeyspace.functions;\r\n        updateFunctions(metadata, oldFunctions, newKeyspace.functions, null);\r\n        Map<String, AggregateMetadata> oldAggregates = oldKeyspace == null ? new HashMap<String, AggregateMetadata>() : oldKeyspace.aggregates;\r\n        updateAggregates(metadata, oldAggregates, newKeyspace.aggregates, null);\r\n        Map<String, MaterializedViewMetadata> oldViews = oldKeyspace == null ? new HashMap<String, MaterializedViewMetadata>() : oldKeyspace.views;\r\n        updateViews(metadata, oldViews, newKeyspace.views, null);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.search.SearchResultFrame.setWidths",
	"Comment": "set column widths according to which field is shown, and lock icon columnsto a suitable width.",
	"Method": "void setWidths(){\r\n    TableColumnModel cm = entryTable.getColumnModel();\r\n    for (int i = 0; i < (PAD + FIELDS.length); i++) {\r\n        switch(i) {\r\n            case FILE_COL:\r\n            case URL_COL:\r\n                cm.getColumn(i).setPreferredWidth(GUIGlobals.WIDTH_ICON_COL);\r\n                cm.getColumn(i).setMinWidth(GUIGlobals.WIDTH_ICON_COL);\r\n                cm.getColumn(i).setMaxWidth(GUIGlobals.WIDTH_ICON_COL);\r\n                break;\r\n            case DATABASE_COL:\r\n                {\r\n                    Double width = InternalBibtexFields.getFieldLength(FieldName.AUTHOR);\r\n                    cm.getColumn(i).setPreferredWidth(width.intValue());\r\n                    break;\r\n                }\r\n            default:\r\n                {\r\n                    Double width = InternalBibtexFields.getFieldLength(FIELDS[i - PAD]);\r\n                    cm.getColumn(i).setPreferredWidth(width.intValue());\r\n                    break;\r\n                }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.EventDebouncerIntegrationTest.should_change_debouncer_settings_dynamically",
	"Comment": "tests that settings for a debouncer can be modified dynamically without requiring the clusterto be restarted.",
	"Method": "void should_change_debouncer_settings_dynamically(){\r\n    ControlConnection controlConnection = spy(cluster().manager.controlConnection);\r\n    cluster().manager.controlConnection = controlConnection;\r\n    for (int i = 0; i < 10; i++) {\r\n        cluster().manager.submitNodeListRefresh();\r\n        Thread.sleep(100);\r\n    }\r\n    verify(controlConnection, timeout(10000)).refreshNodeListAndTokenMap();\r\n    reset(controlConnection);\r\n    cluster().getConfiguration().getQueryOptions().setRefreshNodeListIntervalMillis(0);\r\n    for (int i = 0; i < 10; i++) {\r\n        cluster().manager.submitNodeListRefresh();\r\n        Thread.sleep(100);\r\n    }\r\n    verify(controlConnection, timeout(10000).times(10)).refreshNodeListAndTokenMap();\r\n}"
}, {
	"Path": "com.datastax.driver.mapping.MapperUDTTest.should_format_mapped_udt",
	"Comment": "ensures that mappedudtcodec is able to properly format udts when printing the query string of abuiltstatement.",
	"Method": "void should_format_mapped_udt(){\r\n    MappingManager manager = new MappingManager(session());\r\n    UUID uuid = UUIDs.random();\r\n    BuiltStatement update = update(\"users\").with(set(\"mainaddress\", new Address(\"12 4th Street\", \"Springfield\", 12345, \"12341343\", \"435423245\"))).where(eq(\"user_id\", uuid));\r\n    CodecRegistry codecRegistry = cluster().getConfiguration().getCodecRegistry();\r\n    codecRegistry.register(manager.udtCodec(Address.class));\r\n    String queryString = update.getQueryString(codecRegistry);\r\n    assertThat(queryString).isEqualTo(\"UPDATE users SET mainaddress=? WHERE user_id=?;\");\r\n    update.setForceNoValues(true);\r\n    queryString = update.getQueryString(codecRegistry);\r\n    assertThat(queryString).isEqualTo(\"UPDATE users \" + \"SET mainaddress={street:'12 4th Street',city:'Springfield',\\\"ZIP_code\\\":12345,phones:{'435423245','12341343'}} \" + \"WHERE user_id=\" + uuid + \";\");\r\n    session().execute(queryString);\r\n}"
}, {
	"Path": "org.jabref.logic.net.URLUtil.isURL",
	"Comment": "checks whether the given string is a url.currently only checks for a protocol string.",
	"Method": "boolean isURL(String url){\r\n    return url.contains(\"://\");\r\n}"
}, {
	"Path": "com.datastax.driver.core.ConsistencyTest.should_use_query_option_serial_cl",
	"Comment": "exhaustively tests all serial consistency levels when they are set via queryoptions.",
	"Method": "void should_use_query_option_serial_cl(ConsistencyLevel cl){\r\n    Cluster cluster = builder().withQueryOptions(new QueryOptions().setSerialConsistencyLevel(cl)).build();\r\n    try {\r\n        Session session = cluster.connect();\r\n        String queryString = \"serial_query_cl\";\r\n        Query clQuery = executeSimple(session, queryString, null, cl);\r\n        checkSerialCLMatch(cl, clQuery.getSerialConsistency());\r\n        String prepareString = \"preapred_statement_serial_cl\";\r\n        PreparedStatementExecution pse = executePrepared(session, prepareString, null, null);\r\n        checkSerialCLMatch(cl, pse.getSerialConsistency());\r\n        String batchStateString = \"batch_statement_serial_cl\";\r\n        BatchExecution batch = executeBatch(session, batchStateString, null, null);\r\n        checkSerialCLMatch(cl, batch.getSerialConsistency());\r\n    } finally {\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.model.cleanup.Formatter.equals",
	"Comment": "indicates whether some other object is the same formatter as this one based on the key.",
	"Method": "boolean equals(Object obj){\r\n    if (obj instanceof Formatter) {\r\n        return getKey().equals(((Formatter) obj).getKey());\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.java.ProxyGenerator.generateProxyClass",
	"Comment": "generate a proxy class given a name and a list of proxy interfaces.",
	"Method": "byte[] generateProxyClass(String name,Class<?>[] interfaces,byte[] generateProxyClass,String name,Class<?>[] interfaces,int accessFlags){\r\n    ProxyGenerator gen = new ProxyGenerator(name, interfaces, accessFlags);\r\n    final byte[] classFile = gen.generateClassFile();\r\n    if (saveGeneratedFiles) {\r\n        java.security.AccessController.doPrivileged(new java.security.PrivilegedAction<Void>() {\r\n            public Void run() {\r\n                try {\r\n                    int i = name.lastIndexOf('.');\r\n                    Path path;\r\n                    if (i > 0) {\r\n                        Path dir = Paths.get(name.substring(0, i).replace('.', File.separatorChar));\r\n                        Files.createDirectories(dir);\r\n                        path = dir.resolve(name.substring(i + 1, name.length()) + \".class\");\r\n                    } else {\r\n                        path = Paths.get(name + \".class\");\r\n                    }\r\n                    Files.write(path, classFile);\r\n                    return null;\r\n                } catch (IOException e) {\r\n                    throw new InternalError(\"I/O exception saving generated file: \" + e);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return classFile;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.java.ProxyGenerator.generateProxyClass",
	"Comment": "generate a proxy class given a name and a list of proxy interfaces.",
	"Method": "byte[] generateProxyClass(String name,Class<?>[] interfaces,byte[] generateProxyClass,String name,Class<?>[] interfaces,int accessFlags){\r\n    try {\r\n        int i = name.lastIndexOf('.');\r\n        Path path;\r\n        if (i > 0) {\r\n            Path dir = Paths.get(name.substring(0, i).replace('.', File.separatorChar));\r\n            Files.createDirectories(dir);\r\n            path = dir.resolve(name.substring(i + 1, name.length()) + \".class\");\r\n        } else {\r\n            path = Paths.get(name + \".class\");\r\n        }\r\n        Files.write(path, classFile);\r\n        return null;\r\n    } catch (IOException e) {\r\n        throw new InternalError(\"I/O exception saving generated file: \" + e);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.rmi.ObjectImporter.setHttpProxy",
	"Comment": "sets an http proxy server.after this method is called, the objectimporter connects a server through the http proxy server.",
	"Method": "void setHttpProxy(String host,int port){\r\n    String proxyHeader = \"POST http://\" + orgServername + \":\" + orgPort;\r\n    String cmd = proxyHeader + \"/lookup HTTP/1.0\";\r\n    lookupCommand = cmd.getBytes();\r\n    cmd = proxyHeader + \"/rmi HTTP/1.0\";\r\n    rmiCommand = cmd.getBytes();\r\n    this.servername = host;\r\n    this.port = port;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.util.proxy.ProxyFactory.isUseWriteReplace",
	"Comment": "test whether this factory installs a writereplace method in created classes",
	"Method": "boolean isUseWriteReplace(){\r\n    return factoryWriteReplace;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.test.util.HotSwapTestHelper.__version__",
	"Comment": "returns the current version of the inner classes of an outer class.caller class is used as an outer class.",
	"Method": "int __version__(){\r\n    return HotSwapTool.getCurrentVersion(determineOuter(0));\r\n}"
}, {
	"Path": "org.hotswap.agent.tutorial.plugin.PrinterHAPlugin.reloadConfiguration",
	"Comment": "reload printer configuration after the property file changes.",
	"Method": "void reloadConfiguration(){\r\n    List<PrintSource> currentSource = (List<PrintSource>) ReflectionHelper.get(printerService, \"printSources\");\r\n    currentSource.removeAll(autoDiscoveredPrintSources);\r\n    currentSource.addAll(new PrinterSourceScanner().scanPrintSources());\r\n    printerService.refresh();\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.owb.command.BeanClassRefreshCommand.isCreateEvent",
	"Comment": "check all merged events with same classname for create events.",
	"Method": "boolean isCreateEvent(List<Command> mergedCommands){\r\n    boolean createFound = false;\r\n    for (Command cmd : mergedCommands) {\r\n        BeanClassRefreshCommand refreshCommand = (BeanClassRefreshCommand) cmd;\r\n        if (className.equals(refreshCommand.className)) {\r\n            if (refreshCommand.event != null) {\r\n                if (refreshCommand.event.getEventType().equals(FileEvent.CREATE))\r\n                    createFound = true;\r\n            }\r\n        }\r\n    }\r\n    LOGGER.trace(\"isCreateEvent result {}: createFound={}\", createFound);\r\n    return createFound;\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.Alter.renameColumn",
	"Comment": "add a new rename column clause to this alter table statement.note that you can only rename a column that is part of the primary key.",
	"Method": "RenameColumn renameColumn(String columnName){\r\n    validateNotEmpty(columnName, \"Column to be renamed\");\r\n    validateNotKeyWord(columnName, String.format(\"The renamed column name '%s' is not allowed because it is a reserved keyword\", columnName));\r\n    return new RenameColumn(this, columnName);\r\n}"
}, {
	"Path": "com.datastax.driver.core.PoolingOptions.getInitializationExecutor",
	"Comment": "returns the executor to use for connection initialization.",
	"Method": "Executor getInitializationExecutor(){\r\n    return initializationExecutor;\r\n}"
}, {
	"Path": "com.datastax.driver.core.CustomPayloadTest.should_override_incoming_payload_when_outgoing_payload_explicitly_set_on_preparing_statement",
	"Comment": "ensures that an incoming payload is overridden by an explicitly set outgoing payload whenpropagated to bound statements.",
	"Method": "void should_override_incoming_payload_when_outgoing_payload_explicitly_set_on_preparing_statement(){\r\n    RegularStatement statement = new SimpleStatement(\"SELECT c2 as col2 FROM t1 where c1 = ?\");\r\n    statement.setOutgoingPayload(payload1);\r\n    PreparedStatement ps = session().prepare(statement);\r\n    assertThat(ps.getOutgoingPayload()).isEqualTo(payload1);\r\n    assertThat(ps.getIncomingPayload()).isEqualTo(payload1);\r\n    ps.setOutgoingPayload(payload2);\r\n    BoundStatement bs = ps.bind(1);\r\n    ResultSet rows = session().execute(bs);\r\n    Map<String, ByteBuffer> actual = rows.getExecutionInfo().getIncomingPayload();\r\n    assertThat(actual).isEqualTo(payload2);\r\n    bs = ps.bind();\r\n    bs.setInt(0, 1);\r\n    rows = session().execute(bs);\r\n    actual = rows.getExecutionInfo().getIncomingPayload();\r\n    assertThat(actual).isEqualTo(payload2);\r\n}"
}, {
	"Path": "me.ramswaroop.jbot.core.facebook.Bot.getPatternFromEventType",
	"Comment": "match the pattern with different attributes based on the event type.",
	"Method": "String getPatternFromEventType(Event event){\r\n    switch(event.getType()) {\r\n        case MESSAGE:\r\n            return event.getMessage().getText();\r\n        case QUICK_REPLY:\r\n            return event.getMessage().getQuickReply().getPayload();\r\n        case POSTBACK:\r\n            return event.getPostback().getPayload();\r\n        default:\r\n            return event.getMessage().getText();\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.AbstractFileResolvingResource.getFile",
	"Comment": "this implementation returns a file reference for the underlying classpath resource, provided that it refers to a file in the file system.",
	"Method": "File getFile(File getFile,URI uri){\r\n    if (uri.getScheme().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\r\n        return VfsResourceDelegate.getResource(uri).getFile();\r\n    }\r\n    return ResourceUtils.getFile(uri, getDescription());\r\n}"
}, {
	"Path": "com.datastax.driver.core.ExecutionInfo.getSpeculativeExecutions",
	"Comment": "the number of speculative executions that were started for this query.this does not include the initial, normal execution of the query. therefore, if speculativeexecutions are disabled, this will always be 0. if they are enabled and one speculativeexecution was triggered in addition to the initial execution, this will be 1, etc.",
	"Method": "int getSpeculativeExecutions(){\r\n    return speculativeExecutions;\r\n}"
}, {
	"Path": "org.elixir_lang.beam.psi.BeamFileImpl.checkSetName",
	"Comment": "checks if it is possible to rename the element to the specified name,and throws an exception if the rename is not possible. does not actually modify anything.",
	"Method": "void checkSetName(String name){\r\n    throw new IncorrectOperationException(CAN_NOT_MODIFY_MESSAGE);\r\n}"
}, {
	"Path": "org.jabref.model.entry.CustomEntryType.getRequiredFieldsString",
	"Comment": "get a string describing the required field set for this entry type.",
	"Method": "String getRequiredFieldsString(){\r\n    return String.join(\";\", required);\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.TableOptions.memtableFlushPeriodInMillis",
	"Comment": "define the memtable flush period.if set, this forces flushing of the memtable after the specified time elapses.if no call is made to this method, the default value set by cassandra is 0.",
	"Method": "T memtableFlushPeriodInMillis(Integer memtableFlushPeriodInMillis){\r\n    this.memtableFlushPeriodInMillis = Optional.fromNullable(memtableFlushPeriodInMillis);\r\n    return self;\r\n}"
}, {
	"Path": "org.jabref.model.groups.GroupTreeNode.setGroup",
	"Comment": "associates the specified group with this node while also providing the possibility to modify previous matchedentries so that they are now matched by the new group.",
	"Method": "void setGroup(AbstractGroup newGroup,List<FieldChange> setGroup,AbstractGroup newGroup,boolean shouldKeepPreviousAssignments,boolean shouldRemovePreviousAssignments,List<BibEntry> entriesInDatabase){\r\n    AbstractGroup oldGroup = getGroup();\r\n    setGroup(newGroup);\r\n    List<FieldChange> changes = new ArrayList();\r\n    boolean shouldRemove = shouldRemovePreviousAssignments && (oldGroup instanceof GroupEntryChanger);\r\n    boolean shouldAdd = shouldKeepPreviousAssignments && (newGroup instanceof GroupEntryChanger);\r\n    if (shouldAdd || shouldRemove) {\r\n        List<BibEntry> entriesMatchedByOldGroup = entriesInDatabase.stream().filter(oldGroup::isMatch).collect(Collectors.toList());\r\n        if (shouldRemove) {\r\n            GroupEntryChanger entryChanger = (GroupEntryChanger) oldGroup;\r\n            changes.addAll(entryChanger.remove(entriesMatchedByOldGroup));\r\n        }\r\n        if (shouldAdd) {\r\n            GroupEntryChanger entryChanger = (GroupEntryChanger) newGroup;\r\n            changes.addAll(entryChanger.add(entriesMatchedByOldGroup));\r\n        }\r\n    }\r\n    return changes;\r\n}"
}, {
	"Path": "org.jabref.logic.util.strings.StringSimilarity.isSimilar",
	"Comment": "string similarity based on levenshtein, ignorecase, and fixed metric threshold of 4.",
	"Method": "boolean isSimilar(String a,String b){\r\n    return editDistanceIgnoreCase(a, b) <= METRIC_THRESHOLD;\r\n}"
}, {
	"Path": "org.jabref.gui.desktop.JabRefDesktop.openFolderAndSelectFile",
	"Comment": "opens a file browser of the folder of the given file. if possible, the file is selected",
	"Method": "void openFolderAndSelectFile(Path fileLink){\r\n    NATIVE_DESKTOP.openFolderAndSelectFile(fileLink);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.AbstractResource.getURL",
	"Comment": "this implementation throws a filenotfoundexception, assuming that theresource cannot be resolved to a url.",
	"Method": "URL getURL(){\r\n    throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL\");\r\n}"
}, {
	"Path": "org.jabref.gui.JabRefFrame.addImportedEntries",
	"Comment": "this method does the job of adding imported entries into the active database, or into a new one. it shows theimportinspectiondialog if preferences indicate it should be used. otherwise it imports directly.",
	"Method": "void addImportedEntries(BasePanel panel,List<BibEntry> entries){\r\n    SwingUtilities.invokeLater(() -> {\r\n        ImportInspectionDialog diag = new ImportInspectionDialog(JabRefFrame.this, panel, Localization.lang(\"Import\"), false);\r\n        diag.addEntries(entries);\r\n        diag.entryListComplete();\r\n        diag.setVisible(true);\r\n        diag.toFront();\r\n    });\r\n}"
}, {
	"Path": "com.datastax.driver.core.DurationIntegrationTest.should_serialize_and_deserialize_durations",
	"Comment": "validates that columns using the duration type are properly handled by the driver when used asa parameter and retrieved in a row result for a variety of sample inputs.",
	"Method": "void should_serialize_and_deserialize_durations(String durationStr){\r\n    UUID id = UUID.randomUUID();\r\n    Duration expected = Duration.from(durationStr);\r\n    session().execute(\"INSERT INTO test_duration (pk, c1) VALUES (?, ?)\", id, expected);\r\n    Row row = session().execute(\"SELECT c1 from test_duration WHERE pk = ?\", id).one();\r\n    Duration actual = row.get(\"c1\", Duration.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}"
}, {
	"Path": "com.datastax.driver.core.TypeCodecTest.should_wrap_primitive_types",
	"Comment": "ensures that primitive types are correctly handled and wrapped when necessary.",
	"Method": "void should_wrap_primitive_types(){\r\n    assertThat(TypeCodec.cboolean()).accepts(Boolean.class).accepts(Boolean.TYPE).accepts(true);\r\n    assertThat(TypeCodec.cint()).accepts(Integer.class).accepts(Integer.TYPE).accepts(42);\r\n    assertThat(TypeCodec.bigint()).accepts(Long.class).accepts(Long.TYPE).accepts(42L);\r\n    assertThat(TypeCodec.cfloat()).accepts(Float.class).accepts(Float.TYPE).accepts(42.0F);\r\n    assertThat(TypeCodec.cdouble()).accepts(Double.class).accepts(Double.TYPE).accepts(42.0D);\r\n}"
}, {
	"Path": "org.elixir_lang.ElixirFlexLexer.yytext",
	"Comment": "returns the text matched by the current regular expression.",
	"Method": "CharSequence yytext(){\r\n    return zzBuffer.subSequence(zzStartRead, zzMarkedPos);\r\n}"
}, {
	"Path": "com.datastax.driver.core.QueryOptions.isPrepareOnAllHosts",
	"Comment": "returns whether the driver should prepare statements on all hosts in the cluster.",
	"Method": "boolean isPrepareOnAllHosts(){\r\n    return this.prepareOnAllHosts;\r\n}"
}, {
	"Path": "org.jabref.model.TreeNode.childIndexExists",
	"Comment": "returns whether the specified index is a valid index for a child.",
	"Method": "boolean childIndexExists(int index){\r\n    return (index >= 0) && (index < children.size());\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPool.shrinkIfBelowCapacity",
	"Comment": "if we have more active connections than needed, trash some of them",
	"Method": "void shrinkIfBelowCapacity(){\r\n    int currentLoad = maxTotalInFlight.getAndSet(totalInFlight.get());\r\n    int maxRequestsPerConnection = options().getMaxRequestsPerConnection(hostDistance);\r\n    int needed = currentLoad / maxRequestsPerConnection + 1;\r\n    if (currentLoad % maxRequestsPerConnection > options().getNewConnectionThreshold(hostDistance))\r\n        needed += 1;\r\n    needed = Math.max(needed, options().getCoreConnectionsPerHost(hostDistance));\r\n    int actual = open.get();\r\n    int toTrash = Math.max(0, actual - needed);\r\n    logger.trace(\"Current inFlight = {}, {} connections needed, {} connections available, trashing {}\", currentLoad, needed, actual, toTrash);\r\n    if (toTrash <= 0)\r\n        return;\r\n    for (Connection connection : connections) if (trashConnection(connection)) {\r\n        toTrash -= 1;\r\n        if (toTrash == 0)\r\n            return;\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.CollectionUtils.findValueOfType",
	"Comment": "find a single value of the given type in the given collection.",
	"Method": "T findValueOfType(Collection<?> collection,Class<T> type,Object findValueOfType,Collection<?> collection,Class<?>[] types){\r\n    if (isEmpty(collection) || ObjectUtils.isEmpty(types)) {\r\n        return null;\r\n    }\r\n    for (Class<?> type : types) {\r\n        Object value = findValueOfType(collection, type);\r\n        if (value != null) {\r\n            return value;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.jvm.AnonymousClassInfos.calculateCompatibleTransitions",
	"Comment": "search for a mapping between previous and nwe anonymous classes.",
	"Method": "void calculateCompatibleTransitions(){\r\n    compatibleTransitions = new HashMap<AnonymousClassInfo, AnonymousClassInfo>();\r\n    List<AnonymousClassInfo> previousInfos = new ArrayList<AnonymousClassInfo>(previous.anonymousClassInfoList);\r\n    List<AnonymousClassInfo> currentInfos = new ArrayList<AnonymousClassInfo>(anonymousClassInfoList);\r\n    if (previousInfos.size() > currentInfos.size()) {\r\n        if (currentInfos.size() == 0)\r\n            previousInfos.clear();\r\n        else\r\n            previousInfos = previousInfos.subList(0, currentInfos.size());\r\n    }\r\n    searchForMappings(compatibleTransitions, previousInfos, currentInfos, new AnonymousClassInfoMatcher() {\r\n        @Override\r\n        public boolean match(AnonymousClassInfo previous, AnonymousClassInfo current) {\r\n            return previous.matchExact(current);\r\n        }\r\n    });\r\n    searchForMappings(compatibleTransitions, previousInfos, currentInfos, new AnonymousClassInfoMatcher() {\r\n        @Override\r\n        public boolean match(AnonymousClassInfo previous, AnonymousClassInfo current) {\r\n            return previous.matchSignatures(current);\r\n        }\r\n    });\r\n    searchForMappings(compatibleTransitions, previousInfos, currentInfos, new AnonymousClassInfoMatcher() {\r\n        @Override\r\n        public boolean match(AnonymousClassInfo previous, AnonymousClassInfo current) {\r\n            return previous.matchClassSignature(current);\r\n        }\r\n    });\r\n    int newDefinitionCount = anonymousClassInfoList.size();\r\n    int lastAnonymousClassIndex = previous.anonymousClassInfoList.size();\r\n    for (AnonymousClassInfo currentNotMatched : currentInfos) {\r\n        if (lastAnonymousClassIndex < newDefinitionCount) {\r\n            compatibleTransitions.put(new AnonymousClassInfo(className + \"$\" + (lastAnonymousClassIndex + 1)), currentNotMatched);\r\n            lastAnonymousClassIndex++;\r\n        } else {\r\n            compatibleTransitions.put(new AnonymousClassInfo(className + \"$\" + uniqueClass++), currentNotMatched);\r\n        }\r\n    }\r\n    if (LOGGER.isLevelEnabled(AgentLogger.Level.TRACE)) {\r\n        for (Map.Entry<AnonymousClassInfo, AnonymousClassInfo> mapping : compatibleTransitions.entrySet()) {\r\n            LOGGER.trace(\"Transition {} => {}\", mapping.getKey().getClassName(), mapping.getValue().getClassName());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.jvm.AnonymousClassInfos.calculateCompatibleTransitions",
	"Comment": "search for a mapping between previous and nwe anonymous classes.",
	"Method": "void calculateCompatibleTransitions(){\r\n    return previous.matchExact(current);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.jvm.AnonymousClassInfos.calculateCompatibleTransitions",
	"Comment": "search for a mapping between previous and nwe anonymous classes.",
	"Method": "void calculateCompatibleTransitions(){\r\n    return previous.matchSignatures(current);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.jvm.AnonymousClassInfos.calculateCompatibleTransitions",
	"Comment": "search for a mapping between previous and nwe anonymous classes.",
	"Method": "void calculateCompatibleTransitions(){\r\n    return previous.matchClassSignature(current);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.spring.scanner.ClassPathBeanDefinitionScannerAgent.refreshClass",
	"Comment": "called by a reflection command from springplugin transformer.",
	"Method": "void refreshClass(String basePackage,byte[] classDefinition){\r\n    ClassPathBeanDefinitionScannerAgent scannerAgent = getInstance(basePackage);\r\n    if (scannerAgent == null) {\r\n        LOGGER.error(\"basePackage '{}' not associated with any scannerAgent\", basePackage);\r\n        return;\r\n    }\r\n    BeanDefinition beanDefinition = scannerAgent.resolveBeanDefinition(classDefinition);\r\n    if (beanDefinition != null) {\r\n        scannerAgent.defineBean(beanDefinition);\r\n    }\r\n    reloadFlag = false;\r\n}"
}, {
	"Path": "org.jabref.gui.autocompleter.AutoCompletePreferences.getCompleteFields",
	"Comment": "returns the list of fields for which autocomplete is enabled",
	"Method": "List<String> getCompleteFields(){\r\n    return completeFields;\r\n}"
}, {
	"Path": "org.jabref.logic.remote.client.RemoteClient.sendCommandLineArguments",
	"Comment": "attempt to send command line arguments to already running jabref instance.",
	"Method": "boolean sendCommandLineArguments(String[] args){\r\n    try (Protocol protocol = openNewConnection()) {\r\n        protocol.sendMessage(RemoteMessage.SEND_COMMAND_LINE_ARGUMENTS, args);\r\n        Pair<RemoteMessage, Object> response = protocol.receiveMessage();\r\n        return response.getKey() == RemoteMessage.OK;\r\n    } catch (IOException e) {\r\n        LOGGER.debug(\"Could not send args \" + String.join(\", \", args) + \" to the server at port \" + port, e);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.SchemaBuilder.snappy",
	"Comment": "create options for the snappy compression strategy, to use in a create or alter tablestatement.",
	"Method": "TableOptions.CompressionOptions snappy(){\r\n    return new TableOptions.CompressionOptions(TableOptions.CompressionOptions.Algorithm.SNAPPY);\r\n}"
}, {
	"Path": "com.datastax.driver.core.exceptions.AlreadyExistsException.getTable",
	"Comment": "if the failed creation was a table creation, the name of the table that already exists.",
	"Method": "String getTable(){\r\n    return table.isEmpty() ? null : table;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.ClassPathResource.getClassLoader",
	"Comment": "return the classloader that this resource will be obtained from.",
	"Method": "ClassLoader getClassLoader(){\r\n    return (this.clazz != null ? this.clazz.getClassLoader() : this.classLoader);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.util.proxy.ProxyFactory.createClass",
	"Comment": "generates a proxy class with a specific signature.access is package local so proxyobjectinputstream can use this.",
	"Method": "Class<?> createClass(Class<?> createClass,MethodFilter filter,Class<?> createClass,byte[] signature,Class<?> createClass,Lookup lookup,Class<?> createClass,Lookup lookup,MethodFilter filter,Class<?> createClass,Lookup lookup,byte[] signature){\r\n    installSignature(signature);\r\n    return createClass1(lookup);\r\n}"
}, {
	"Path": "org.jabref.logic.util.Version.getAllAvailableVersions",
	"Comment": "grabs all the available releases from the github repository",
	"Method": "List<Version> getAllAvailableVersions(){\r\n    URLConnection connection = new URL(JABREF_GITHUB_RELEASES).openConnection();\r\n    connection.setRequestProperty(\"Accept-Charset\", \"UTF-8\");\r\n    try (BufferedReader rd = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\r\n        List<Version> versions = new ArrayList();\r\n        JSONArray objects = new JSONArray(rd.readLine());\r\n        for (int i = 0; i < objects.length(); i++) {\r\n            JSONObject jsonObject = objects.getJSONObject(i);\r\n            Version version = Version.parse(jsonObject.getString(\"tag_name\").replaceFirst(\"v\", \"\"));\r\n            versions.add(version);\r\n        }\r\n        return versions;\r\n    }\r\n}"
}, {
	"Path": "com.beust.jcommander.UnixStyleUsageFormatterTest.nonexistentCommandShouldThrow",
	"Comment": "getting the description of a nonexistent command should throw an exception.",
	"Method": "void nonexistentCommandShouldThrow(){\r\n    String[] argv = {};\r\n    JCommander jc = JCommander.newBuilder().addObject(new Object()).build();\r\n    jc.setUsageFormatter(new UnixStyleUsageFormatter(jc));\r\n    jc.parse(argv);\r\n    jc.getUsageFormatter().getCommandDescription(\"foo\");\r\n}"
}, {
	"Path": "org.elixir_lang.formatter.settings.CodeStyleSettingsProvider.getConfigurableDisplayName",
	"Comment": "returns the name of the configurable page without creating a configurable instance.",
	"Method": "String getConfigurableDisplayName(){\r\n    return ElixirLanguage.INSTANCE.getDisplayName();\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.logback.LogbackPlugin.initLogback",
	"Comment": "callback method from ch.qos.logback.core.joran.genericconfigurator.",
	"Method": "void initLogback(Object configurator,URL url){\r\n    try {\r\n        final URI uri = url.toURI();\r\n        if (registeredURIs.contains(uri))\r\n            return;\r\n        LOGGER.debug(\"Watching '{}' URL for Logback configuration changes.\", url);\r\n        registeredURIs.add(uri);\r\n        watcher.addEventListener(appClassLoader, uri, new WatchEventListener() {\r\n            @Override\r\n            public void onEvent(WatchFileEvent event) {\r\n                if (event.getEventType() != FileEvent.DELETE)\r\n                    reload(configurator, url);\r\n            }\r\n        });\r\n    } catch (Exception e) {\r\n        LOGGER.error(\"Exception initializing logback configurator {} on url {}.\", e, configurator, url);\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.logback.LogbackPlugin.initLogback",
	"Comment": "callback method from ch.qos.logback.core.joran.genericconfigurator.",
	"Method": "void initLogback(Object configurator,URL url){\r\n    if (event.getEventType() != FileEvent.DELETE)\r\n        reload(configurator, url);\r\n}"
}, {
	"Path": "org.jabref.model.entry.BibEntry.clone",
	"Comment": "returns a clone of this entry. useful for copying.this will set a new id for the cloned entry to be able to distinguish both copies.",
	"Method": "Object clone(){\r\n    BibEntry clone = new BibEntry(type.getValue());\r\n    clone.fields = FXCollections.observableMap(new ConcurrentHashMap(fields));\r\n    return clone;\r\n}"
}, {
	"Path": "org.jabref.gui.entryeditor.RelatedArticlesTab.getRelatedArticlesPane",
	"Comment": "gets a stackpane of related article information to be displayed in the related articles tab",
	"Method": "StackPane getRelatedArticlesPane(BibEntry entry){\r\n    StackPane root = new StackPane();\r\n    root.getStyleClass().add(\"related-articles-tab\");\r\n    ProgressIndicator progress = new ProgressIndicator();\r\n    progress.setMaxSize(100, 100);\r\n    MrDLibFetcher fetcher = new MrDLibFetcher(Globals.prefs.get(JabRefPreferences.LANGUAGE), Globals.BUILD_INFO.getVersion());\r\n    BackgroundTask.wrap(() -> fetcher.performSearch(entry)).onRunning(() -> progress.setVisible(true)).onSuccess(relatedArticles -> {\r\n        progress.setVisible(false);\r\n        root.getChildren().add(getRelatedArticleInfo(relatedArticles));\r\n    }).executeWith(Globals.TASK_EXECUTOR);\r\n    root.getChildren().add(progress);\r\n    return root;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.Jdbi.inTransaction",
	"Comment": "a convenience function which manages the lifecycle of a handle and yields it to a callbackfor use by clients. the handle will be in a transaction when the callback is invoked, andthat transaction will be committed if the callback finishes normally, or rolled back if thecallback raises an exception.this form accepts a transaction isolation level which will be applied to the connectionfor the scope of this transaction, after which the original isolation level will be restored.",
	"Method": "R inTransaction(HandleCallback<R, X> callback,R inTransaction,TransactionIsolationLevel level,HandleCallback<R, X> callback){\r\n    return withHandle(handle -> handle.<R, X>inTransaction(level, callback));\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ClassUtils.getAllInterfacesForClassAsSet",
	"Comment": "return all interfaces that the given class implements as set, includingones implemented by superclasses.if the class itself is an interface, it gets returned as sole interface.",
	"Method": "Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz,Set<Class<?>> getAllInterfacesForClassAsSet,Class<?> clazz,ClassLoader classLoader){\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    if (clazz.isInterface() && isVisible(clazz, classLoader)) {\r\n        return Collections.<Class<?>>singleton(clazz);\r\n    }\r\n    Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();\r\n    while (clazz != null) {\r\n        Class<?>[] ifcs = clazz.getInterfaces();\r\n        for (Class<?> ifc : ifcs) {\r\n            interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));\r\n        }\r\n        clazz = clazz.getSuperclass();\r\n    }\r\n    return interfaces;\r\n}"
}, {
	"Path": "com.datastax.driver.mapping.MapperCaseSensitivityTest.should_handle_case_sensitive_identifiers_without_keyspace_specified",
	"Comment": "validates that case sensitive identifiers for fields, types, columns, tables and keyspaces workwith the mapper when the keyspace name isspecified on the mapped class.",
	"Method": "void should_handle_case_sensitive_identifiers_without_keyspace_specified(){\r\n    MappingManager mappingManager = new MappingManager(session());\r\n    Mapper<UserNoKeyspace> mapper = mappingManager.mapper(UserNoKeyspace.class);\r\n    mapper.save(user);\r\n    assertThat(mapper.get(user.getUserId())).isEqualTo(user);\r\n}"
}, {
	"Path": "org.jabref.gui.preferences.BibtexKeyPatternPrefTab.storeSettings",
	"Comment": "store changes to table preferences. this method is called when the user clicks ok.",
	"Method": "void storeSettings(){\r\n    Globals.prefs.put(JabRefPreferences.DEFAULT_BIBTEX_KEY_PATTERN, defaultPat.getText());\r\n    Globals.prefs.putBoolean(JabRefPreferences.WARN_BEFORE_OVERWRITING_KEY, warnBeforeOverwriting.isSelected());\r\n    Globals.prefs.putBoolean(JabRefPreferences.AVOID_OVERWRITING_KEY, dontOverwrite.isSelected());\r\n    Globals.prefs.put(JabRefPreferences.KEY_PATTERN_REGEX, keyPatternRegex.getText());\r\n    Globals.prefs.put(JabRefPreferences.KEY_PATTERN_REPLACEMENT, keyPatternReplacement.getText());\r\n    Globals.prefs.putBoolean(JabRefPreferences.GENERATE_KEYS_AFTER_INSPECTION, autoGenerateOnImport.isSelected());\r\n    Globals.prefs.putBoolean(JabRefPreferences.GENERATE_KEYS_BEFORE_SAVING, generateOnSave.isSelected());\r\n    if (alwaysAddLetter.isSelected()) {\r\n        Globals.prefs.putBoolean(JabRefPreferences.KEY_GEN_ALWAYS_ADD_LETTER, true);\r\n    } else if (letterStartA.isSelected()) {\r\n        Globals.prefs.putBoolean(JabRefPreferences.KEY_GEN_FIRST_LETTER_A, true);\r\n        Globals.prefs.putBoolean(JabRefPreferences.KEY_GEN_ALWAYS_ADD_LETTER, false);\r\n    } else {\r\n        Globals.prefs.putBoolean(JabRefPreferences.KEY_GEN_FIRST_LETTER_A, false);\r\n        Globals.prefs.putBoolean(JabRefPreferences.KEY_GEN_ALWAYS_ADD_LETTER, false);\r\n    }\r\n    GlobalBibtexKeyPattern keypatterns = getKeyPatternAsGlobalBibtexKeyPattern();\r\n    prefs.putKeyPattern(keypatterns);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.PathResource.getFile",
	"Comment": "this implementation returns the underlying file reference.",
	"Method": "File getFile(){\r\n    try {\r\n        return this.path.toFile();\r\n    } catch (UnsupportedOperationException ex) {\r\n        throw new FileNotFoundException(this.path + \" cannot be resolved to \" + \"absolute file path\");\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ReflectionUtils.doWithLocalFields",
	"Comment": "invoke the given callback on all fields in the target class, going up theclass hierarchy to get all declared fields.",
	"Method": "void doWithLocalFields(Class<?> clazz,FieldCallback fc){\r\n    for (Field field : getDeclaredFields(clazz)) {\r\n        try {\r\n            fc.doWith(field);\r\n        } catch (IllegalAccessException ex) {\r\n            throw new IllegalStateException(\"Not allowed to access field '\" + field.getName() + \"': \" + ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.NestedIOException.getMessage",
	"Comment": "return the detail message, including the message from the nestedexception if there is one.",
	"Method": "String getMessage(){\r\n    return NestedExceptionUtils.buildMessage(super.getMessage(), getCause());\r\n}"
}, {
	"Path": "com.datastax.driver.core.ProtocolBetaVersionTest.should_not_initialize_when_beta_flag_is_set_and_version_explicitly_required",
	"Comment": "verifies that the cluster builder fails when beta flag is set and user attempts to pass aversion explicitly.",
	"Method": "void should_not_initialize_when_beta_flag_is_set_and_version_explicitly_required(){\r\n    try {\r\n        Cluster.builder().addContactPoints(getContactPoints()).withPort(ccm().getBinaryPort()).allowBetaProtocolVersion().withProtocolVersion(V4).build();\r\n        fail(\"Expected IllegalStateException\");\r\n    } catch (IllegalStateException e) {\r\n        assertThat(e.getMessage()).isEqualTo(\"Can not set the version explicitly if `allowBetaProtocolVersion` was used.\");\r\n    }\r\n}"
}, {
	"Path": "org.bytedeco.javacpp.samples.tensorflow.EigenvalueExample.checkStatus",
	"Comment": "checks the status and throws an exception in case any error occurred",
	"Method": "void checkStatus(Status s){\r\n    if (!s.ok())\r\n        throw new Exception(s.error_message().getString());\r\n    s.close();\r\n}"
}, {
	"Path": "org.jabref.JabRefExecutorService.executeAll",
	"Comment": "executes a collection of callable tasks and returns a list of the resulting future objects after the calculation is done.",
	"Method": "List<Future<T>> executeAll(Collection<Callable<T>> tasks,List<Future<T>> executeAll,Collection<Callable<T>> tasks,int timeout,TimeUnit timeUnit){\r\n    Objects.requireNonNull(tasks);\r\n    try {\r\n        return executorService.invokeAll(tasks, timeout, timeUnit);\r\n    } catch (InterruptedException exception) {\r\n        return Collections.emptyList();\r\n    }\r\n}"
}, {
	"Path": "org.elixir_lang.folding.Builder.getPlaceholderText",
	"Comment": "returns the text which is displayed in the editor for the folding region related to thespecified node when the folding region is collapsed.",
	"Method": "String getPlaceholderText(ASTNode node){\r\n    PsiElement element = node.getPsi();\r\n    String placeholderText = null;\r\n    if (element instanceof ElixirDoBlock) {\r\n        placeholderText = \"do: ...\";\r\n    } else if (element instanceof ElixirStabOperation) {\r\n        placeholderText = \"-> ...\";\r\n    }\r\n    return placeholderText;\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.rmi.ObjectImporter.getObject",
	"Comment": "finds the object exported by a server with the specified name.if the object is not found, this method returns null.",
	"Method": "Object getObject(String name){\r\n    try {\r\n        return lookupObject(name);\r\n    } catch (ObjectNotFoundException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.JabRefFrame.setupAllTables",
	"Comment": "this method causes all open basepanels to set up their tables anew. when called from prefsdialog3, this updatesto the new settings.",
	"Method": "void setupAllTables(){\r\n    for (int i = 0; i < tabbedPane.getTabs().size(); i++) {\r\n        BasePanel bf = getBasePanelAt(i);\r\n        if (bf.getDatabase() != null) {\r\n            DefaultTaskExecutor.runInJavaFXThread(bf::setupMainPanel);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.HotSwapTool.getCurrentVersion",
	"Comment": "returns the current version of the inner classes of a specified outerclass.",
	"Method": "int getCurrentVersion(Class<?> baseClass){\r\n    if (!currentVersion.containsKey(baseClass)) {\r\n        currentVersion.put(baseClass, 0);\r\n    }\r\n    return currentVersion.get(baseClass);\r\n}"
}, {
	"Path": "org.jabref.logic.l10n.Localization.setLanguage",
	"Comment": "sets the language and loads the appropriate translations. note, that this function should be called before anyother function of this class.",
	"Method": "void setLanguage(Language language){\r\n    Optional<Locale> knownLanguage = Language.convertToSupportedLocale(language);\r\n    final Locale defaultLocale = Locale.getDefault();\r\n    if (!knownLanguage.isPresent()) {\r\n        LOGGER.warn(\"Language \" + language + \" is not supported by JabRef (Default:\" + defaultLocale + \")\");\r\n        setLanguage(Language.English);\r\n        return;\r\n    }\r\n    final Locale langLocale = knownLanguage.get();\r\n    if ((locale != null) && locale.equals(langLocale) && locale.equals(defaultLocale)) {\r\n        return;\r\n    }\r\n    locale = langLocale;\r\n    Locale.setDefault(locale);\r\n    javax.swing.JComponent.setDefaultLocale(locale);\r\n    try {\r\n        createResourceBundles(locale);\r\n    } catch (MissingResourceException ex) {\r\n        LOGGER.warn(\"Could not find bundles for language \" + locale + \", switching to full english language\", ex);\r\n        setLanguage(Language.English);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.exporter.GroupSerializer.serializeTree",
	"Comment": "returns a textual representation of this node and its children. thisrepresentation contains both the tree structure and the textualrepresentations of the group associated with each node.every node is one entry in the list of strings.",
	"Method": "List<String> serializeTree(GroupTreeNode node){\r\n    List<String> representation = new ArrayList();\r\n    representation.add(String.valueOf(node.getLevel()) + ' ' + serializeGroup(node.getGroup()));\r\n    for (GroupTreeNode child : node.getChildren()) {\r\n        representation.addAll(serializeTree(child));\r\n    }\r\n    return representation;\r\n}"
}, {
	"Path": "com.datastax.driver.core.ClusterInitTest.should_not_abort_init_if_host_does_not_support_protocol_version",
	"Comment": "ensures that if a node is detected that does not support the protocol version in use on initthat the node is ignored and remains in an added state and the all other hosts areappropriately marked up.",
	"Method": "void should_not_abort_init_if_host_does_not_support_protocol_version(){\r\n    ScassandraCluster scassandraCluster = // For node 2, report an older version which uses protocol v1.\r\n    ScassandraCluster.builder().withIpPrefix(TestUtils.IP_PREFIX).withNodes(5).forcePeerInfo(1, 2, \"release_version\", \"1.2.19\").build();\r\n    Cluster cluster = Cluster.builder().addContactPoints(scassandraCluster.address(1).getAddress()).withPort(scassandraCluster.getBinaryPort()).withNettyOptions(nonQuietClusterCloseOptions).build();\r\n    try {\r\n        scassandraCluster.init();\r\n        cluster.init();\r\n        for (int i = 1; i <= 5; i++) {\r\n            InetAddress hostAddress = scassandraCluster.address(i).getAddress();\r\n            if (i == 2) {\r\n                assertThat(cluster).host(hostAddress).hasState(Host.State.ADDED);\r\n            } else {\r\n                assertThat(cluster).host(hostAddress).hasState(Host.State.UP);\r\n            }\r\n        }\r\n    } finally {\r\n        cluster.close();\r\n        scassandraCluster.stop();\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.weld.command.BeanClassRefreshAgent.registerArchive",
	"Comment": "register bean archive into bdaagentregistry and into weldplugin. current classloader isset tobeanarchive classloader.",
	"Method": "void registerArchive(ClassLoader appClassLoader,BeanDeploymentArchive beanArchive,String beanArchiveType){\r\n    BeansXml beansXml = beanArchive.getBeansXml();\r\n    if (beansXml != null && beansXml.getUrl() != null && (beanArchiveType == null || \"EXPLICIT\".equals(beanArchiveType) || \"IMPLICIT\".equals(beanArchiveType))) {\r\n        String archivePath = null;\r\n        String beansXmlPath = beansXml.getUrl().getPath();\r\n        if (beansXmlPath.endsWith(\"META-INF/beans.xml\")) {\r\n            archivePath = beansXmlPath.substring(0, beansXmlPath.length() - \"META-INF/beans.xml\".length());\r\n        } else if (beansXmlPath.endsWith(\"WEB-INF/beans.xml\")) {\r\n            archivePath = beansXmlPath.substring(0, beansXmlPath.length() - \"beans.xml\".length()) + \"classes\";\r\n        }\r\n        if (archivePath.endsWith(\".jar!/\")) {\r\n            archivePath = archivePath.substring(0, archivePath.length() - \"!/\".length());\r\n        }\r\n        BeanClassRefreshAgent bdaAgent = null;\r\n        try {\r\n            LOGGER.debug(\"BeanClassRefreshAgent registerArchive bdaId='{}' archivePath='{}'.\", beanArchive.getId(), archivePath);\r\n            @SuppressWarnings(\"unused\")\r\n            File path = new File(archivePath);\r\n            Class<?> registryClass = Class.forName(BdaAgentRegistry.class.getName(), true, appClassLoader);\r\n            boolean contain = (boolean) ReflectionHelper.invoke(null, registryClass, \"contains\", new Class[] { String.class }, archivePath);\r\n            if (!contain) {\r\n                bdaAgent = new BeanClassRefreshAgent(beanArchive, archivePath);\r\n                ReflectionHelper.invoke(null, registryClass, \"put\", new Class[] { String.class, BeanClassRefreshAgent.class }, archivePath, bdaAgent);\r\n                bdaAgent.register();\r\n            }\r\n        } catch (IllegalArgumentException e) {\r\n            LOGGER.warning(\"Unable to watch BeanDeploymentArchive with id={}\", beanArchive.getId());\r\n        } catch (Exception e) {\r\n            LOGGER.error(\"Register archive failed.\", e.getMessage());\r\n        }\r\n    } else {\r\n    }\r\n}"
}, {
	"Path": "org.elixir_lang.beam.psi.BeamFileImpl.getMirror",
	"Comment": "returns the corresponding psi element in a decompiled file created by idea fromthe library element.",
	"Method": "PsiElement getMirror(){\r\n    TreeElement mirrorTreeElement = mirrorFileElement;\r\n    if (mirrorTreeElement == null) {\r\n        synchronized (mirrorLock) {\r\n            mirrorTreeElement = mirrorFileElement;\r\n            if (mirrorTreeElement == null) {\r\n                VirtualFile file = getVirtualFile();\r\n                String fileName = file.getName() + \".decompiled.ex\";\r\n                final Document document = FileDocumentManager.getInstance().getDocument(file);\r\n                assert document != null : file.getUrl();\r\n                CharSequence mirrorText = document.getImmutableCharSequence();\r\n                PsiFileFactory factory = PsiFileFactory.getInstance(getManager().getProject());\r\n                PsiFile mirror = factory.createFileFromText(fileName, ElixirLanguage.INSTANCE, mirrorText, false, false);\r\n                mirrorTreeElement = SourceTreeToPsiMap.psiToTreeNotNull(mirror);\r\n                try {\r\n                    final TreeElement finalMirrorTreeElement = mirrorTreeElement;\r\n                    ProgressManager.getInstance().executeNonCancelableSection(new Runnable() {\r\n                        public void run() {\r\n                            setMirror(finalMirrorTreeElement);\r\n                            putUserData(MODULE_DOCUMENT_LINK_KEY, document);\r\n                        }\r\n                    });\r\n                } catch (InvalidMirrorException e) {\r\n                    LOGGER.error(file.getUrl(), e);\r\n                }\r\n                ((PsiFileImpl) mirror).setOriginalFile(this);\r\n                mirrorFileElement = mirrorTreeElement;\r\n            }\r\n        }\r\n    }\r\n    return mirrorTreeElement.getPsi();\r\n}"
}, {
	"Path": "org.elixir_lang.beam.psi.BeamFileImpl.getMirror",
	"Comment": "returns the corresponding psi element in a decompiled file created by idea fromthe library element.",
	"Method": "PsiElement getMirror(){\r\n    setMirror(finalMirrorTreeElement);\r\n    putUserData(MODULE_DOCUMENT_LINK_KEY, document);\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolMultiTest.should_replace_control_connection_if_it_goes_down_but_host_remains_up",
	"Comment": "ensures that if the control connection goes down, but the host bound the control connectionstill has an up pool, the host should remain up and the control connection should be replaced.",
	"Method": "void should_replace_control_connection_if_it_goes_down_but_host_remains_up(){\r\n    createCluster(1, 2);\r\n    assertThat(cluster).usesControlHost(1);\r\n    Connection controlConnection = cluster.manager.controlConnection.connectionRef.get();\r\n    InetSocketAddress controlSocket = (InetSocketAddress) controlConnection.channel.localAddress();\r\n    scassandra.node(1).currentClient().closeConnection(CLOSE, controlSocket);\r\n    Uninterruptibles.sleepUninterruptibly(2, SECONDS);\r\n    assertThat(cluster).hasOpenControlConnection().host(1).isUp();\r\n    assertThat(cluster.manager.controlConnection.connectionRef.get()).isNotEqualTo(controlConnection);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.reflect.Metaobject.getReturnType",
	"Comment": "returns a class objects representing thereturn type of the method specified by identifier.",
	"Method": "Class<?> getReturnType(int identifier){\r\n    return methods[identifier].getReturnType();\r\n}"
}, {
	"Path": "org.jabref.logic.importer.ImportFormatReader.importUnknownFormat",
	"Comment": "tries to import a string by iterating through the available import filters,and keeping the import that seems the most promising",
	"Method": "UnknownFormatImport importUnknownFormat(Path filePath,FileUpdateMonitor fileMonitor,UnknownFormatImport importUnknownFormat,CheckedFunction<Importer, ParserResult> importDatabase,CheckedFunction<Importer, Boolean> isRecognizedFormat,UnknownFormatImport importUnknownFormat,String data){\r\n    Objects.requireNonNull(data);\r\n    return importUnknownFormat(importer -> importer.importDatabase(data), importer -> importer.isRecognizedFormat(data));\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.ClassPathResource.getURL",
	"Comment": "this implementation returns a url for the underlying class path resource,if available.",
	"Method": "URL getURL(){\r\n    URL url = resolveURL();\r\n    if (url == null) {\r\n        throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL because it does not exist\");\r\n    }\r\n    return url;\r\n}"
}, {
	"Path": "org.jabref.logic.util.io.RegExpBasedFileFinder.findAssociatedFiles",
	"Comment": "method for searching for files using regexp. a list of extensions and directories can begiven.",
	"Method": "List<Path> findAssociatedFiles(BibEntry entry,List<Path> directories,List<String> extensions){\r\n    String extensionRegExp = '(' + String.join(\"|\", extensions) + ')';\r\n    return findFile(entry, directories, extensionRegExp);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.FileSystemResource.getFile",
	"Comment": "this implementation returns the underlying file reference.",
	"Method": "File getFile(){\r\n    return this.file;\r\n}"
}, {
	"Path": "org.jabref.logic.openoffice.OOBibStyle.getAuthorLastName",
	"Comment": "look up the nth author and return the proper last name for citation markers.",
	"Method": "String getAuthorLastName(AuthorList al,int number){\r\n    StringBuilder sb = new StringBuilder();\r\n    if (al.getNumberOfAuthors() > number) {\r\n        Author a = al.getAuthor(number);\r\n        a.getVon().filter(von -> !von.isEmpty()).ifPresent(von -> sb.append(von).append(' '));\r\n        sb.append(a.getLast().orElse(\"\"));\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolTest.should_throw_exception_if_convicted_and_no_connections_available",
	"Comment": "ensures that if all connections fail on pool init that the host and subsequently the controlconnection is not marked down since the control connection is still active. the test alsoensures that borrow attempts on the pool fail if we are still in the reconnection windowaccording to the convictionpolicy.",
	"Method": "void should_throw_exception_if_convicted_and_no_connections_available(){\r\n    int readTimeout = 1000;\r\n    int reconnectInterval = 1000;\r\n    Cluster cluster = this.createClusterBuilder().withSocketOptions(new SocketOptions().setConnectTimeoutMillis(readTimeout).setReadTimeoutMillis(reconnectInterval)).withReconnectionPolicy(new ConstantReconnectionPolicy(1000)).build();\r\n    try {\r\n        cluster.init();\r\n        assertThat(cluster).hasOpenControlConnection();\r\n        Connection.Factory factory = spy(cluster.manager.connectionFactory);\r\n        cluster.manager.connectionFactory = factory;\r\n        currentClient.disableListener();\r\n        HostConnectionPool pool = createPool(cluster, 8, 8);\r\n        reset(factory);\r\n        assertThat(pool.connections).hasSize(0);\r\n        assertThat(cluster).host(1).hasState(Host.State.UP);\r\n        assertThat(cluster).hasOpenControlConnection();\r\n        MockRequest failedBorrow = MockRequest.send(pool);\r\n        try {\r\n            failedBorrow.getConnection();\r\n            fail(\"Expected a BusyPoolException\");\r\n        } catch (BusyPoolException e) {\r\n        }\r\n    } finally {\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPoolTest.should_not_close_trashed_connection_until_no_in_flight",
	"Comment": "ensures that a trashed connection that has been timed out should not be closed until it has 0in flight requests.",
	"Method": "void should_not_close_trashed_connection_until_no_in_flight(){\r\n    Cluster cluster = createClusterBuilder().withPoolingOptions(new PoolingOptions().setIdleTimeoutSeconds(20)).build();\r\n    List<MockRequest> allRequests = newArrayList();\r\n    try {\r\n        HostConnectionPool pool = createPool(cluster, 1, 2);\r\n        Connection.Factory factory = spy(cluster.manager.connectionFactory);\r\n        cluster.manager.connectionFactory = factory;\r\n        Connection connection1 = pool.connections.get(0);\r\n        List<MockRequest> requests = MockRequest.sendMany(NEW_CONNECTION_THRESHOLD, pool);\r\n        assertBorrowedConnections(requests, Collections.singletonList(connection1));\r\n        allRequests.addAll(requests);\r\n        allRequests.add(MockRequest.send(pool));\r\n        verify(factory, after(2000).times(1)).open(any(HostConnectionPool.class));\r\n        assertThat(pool.connections).hasSize(2);\r\n        MockRequest.completeMany(50, allRequests);\r\n        Uninterruptibles.sleepUninterruptibly(30, TimeUnit.SECONDS);\r\n        assertThat(pool.trash).containsExactly(connection1);\r\n        assertThat(connection1.inFlight.get()).isEqualTo(51);\r\n        assertThat(connection1.isClosed()).isFalse();\r\n        MockRequest.completeMany(51, allRequests);\r\n        Uninterruptibles.sleepUninterruptibly(30, TimeUnit.SECONDS);\r\n        assertThat(connection1.isClosed()).isTrue();\r\n        assertThat(pool.connections).doesNotContain(connection1);\r\n        assertThat(pool.trash).doesNotContain(connection1);\r\n    } finally {\r\n        MockRequest.completeAll(allRequests);\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "com.beust.jcommander.JCommanderTest.multipleNames",
	"Comment": "required options with multiple names should work with all names.",
	"Method": "void multipleNames(String option){\r\n    Args1 args = new Args1();\r\n    String[] argv = { option, \"2\" };\r\n    JCommander.newBuilder().addObject(args).build().parse(argv);\r\n    Assert.assertEquals(args.verbose.intValue(), 2);\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.spring.ResetSpringStaticCaches.resetBeanNamesByType",
	"Comment": "spring bean by type cache.cache names change between versions, call via reflection and ignore errors.",
	"Method": "void resetBeanNamesByType(DefaultListableBeanFactory defaultListableBeanFactory){\r\n    try {\r\n        Field field = DefaultListableBeanFactory.class.getDeclaredField(\"singletonBeanNamesByType\");\r\n        field.setAccessible(true);\r\n        Map singletonBeanNamesByType = (Map) field.get(defaultListableBeanFactory);\r\n        singletonBeanNamesByType.clear();\r\n    } catch (Exception e) {\r\n        LOGGER.trace(\"Unable to clear DefaultListableBeanFactory.singletonBeanNamesByType cache (is Ok for pre 3.1.2 Spring version)\", e);\r\n    }\r\n    try {\r\n        Field field = DefaultListableBeanFactory.class.getDeclaredField(\"allBeanNamesByType\");\r\n        field.setAccessible(true);\r\n        Map allBeanNamesByType = (Map) field.get(defaultListableBeanFactory);\r\n        allBeanNamesByType.clear();\r\n    } catch (Exception e) {\r\n        LOGGER.trace(\"Unable to clear allBeanNamesByType cache (is Ok for pre 3.2 Spring version)\");\r\n    }\r\n    try {\r\n        Field field = DefaultListableBeanFactory.class.getDeclaredField(\"nonSingletonBeanNamesByType\");\r\n        field.setAccessible(true);\r\n        Map nonSingletonBeanNamesByType = (Map) field.get(defaultListableBeanFactory);\r\n        nonSingletonBeanNamesByType.clear();\r\n    } catch (Exception e) {\r\n        LOGGER.debug(\"Unable to clear nonSingletonBeanNamesByType cache (is Ok for pre 3.2 Spring version)\");\r\n    }\r\n}"
}, {
	"Path": "org.elixir_lang.ElixirFlexLexer.yypushback",
	"Comment": "pushes the specified amount of characters back into the input stream.they will be read again by then next call of the scanning method",
	"Method": "void yypushback(int number){\r\n    if (number > yylength())\r\n        zzScanError(ZZ_PUSHBACK_2BIG);\r\n    zzMarkedPos -= number;\r\n}"
}, {
	"Path": "com.datastax.driver.mapping.MapperMaterializedViewTest.should_access_mapped_materialized_view",
	"Comment": "validates that a materialized view can be mapped as a regular table.",
	"Method": "void should_access_mapped_materialized_view(){\r\n    AllTimeHigh allTimeHigh = mapper.get(\"Coup\", 4000, \"pcmanus\", 2015, 5, 1);\r\n    assertThat(allTimeHigh).isNotNull();\r\n}"
}, {
	"Path": "org.jabref.logic.openoffice.OOUtil.insertFullReferenceAtCurrentLocation",
	"Comment": "insert a reference, formatted using a layout, at the position of a given cursor.",
	"Method": "void insertFullReferenceAtCurrentLocation(XText text,XTextCursor cursor,Layout layout,String parStyle,BibEntry entry,BibDatabase database,String uniquefier){\r\n    Optional<String> oldUniqVal = entry.getField(UNIQUEFIER_FIELD);\r\n    if (uniquefier == null) {\r\n        entry.clearField(UNIQUEFIER_FIELD);\r\n    } else {\r\n        entry.setField(UNIQUEFIER_FIELD, uniquefier);\r\n    }\r\n    String formattedText = layout.doLayout(entry, database);\r\n    if (oldUniqVal.isPresent()) {\r\n        entry.setField(UNIQUEFIER_FIELD, oldUniqVal.get());\r\n    } else {\r\n        entry.clearField(UNIQUEFIER_FIELD);\r\n    }\r\n    OOUtil.insertOOFormattedTextAtCurrentLocation(text, cursor, formattedText, parStyle);\r\n}"
}, {
	"Path": "org.jabref.model.database.DuplicationChecker.getNumberOfKeyOccurrences",
	"Comment": "returns the number of occurrences of the given key in this database.",
	"Method": "int getNumberOfKeyOccurrences(String citeKey){\r\n    return allKeys.getOrDefault(citeKey, 0);\r\n}"
}, {
	"Path": "com.beust.jcommander.DefaultUsageFormatter.getI18nString",
	"Comment": "returns the internationalized version of the string if available, otherwise it returns def.",
	"Method": "String getI18nString(ResourceBundle bundle,String key,String def){\r\n    String s = bundle != null ? bundle.getString(key) : null;\r\n    return s != null ? s : def;\r\n}"
}, {
	"Path": "org.jabref.model.EntryTypes.isEqualNameAndFieldBased",
	"Comment": "checks whether two entrytypes are equal or not based on the equality of the type names and on the equality ofthe required and optional field lists",
	"Method": "boolean isEqualNameAndFieldBased(EntryType type1,EntryType type2){\r\n    if ((type1 == null) && (type2 == null)) {\r\n        return true;\r\n    } else if ((type1 == null) || (type2 == null)) {\r\n        return false;\r\n    } else {\r\n        return type1.getName().equals(type2.getName()) && type1.getRequiredFields().equals(type2.getRequiredFields()) && type1.getOptionalFields().equals(type2.getOptionalFields()) && type1.getSecondaryOptionalFields().equals(type2.getSecondaryOptionalFields());\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.mapping.MapperReconnectionTest.should_not_keep_failed_future_in_query_cache",
	"Comment": "ensures that when the driver looses connectivity, if a mapper query preparation is attempted inthe meanwhile, the failed future will not be kept in cache, so that when connectivity comesback again, the same query preparation can be reattempted.",
	"Method": "void should_not_keep_failed_future_in_query_cache(){\r\n    MappingManager manager = new MappingManager(session());\r\n    Mapper<User> m = manager.mapper(User.class);\r\n    User u1 = new User(\"Paul\", \"paul@gmail.com\");\r\n    m.save(u1);\r\n    ccm().stop(1);\r\n    ccm().waitForDown(1);\r\n    waitForDown(ipOfNode(1), cluster());\r\n    try {\r\n        m.get(u1.getUserId());\r\n        fail(\"Should have thrown NoHostAvailableException\");\r\n    } catch (NoHostAvailableException e) {\r\n    }\r\n    ccm().start(1);\r\n    ccm().waitForUp(1);\r\n    waitForUp(ipOfNode(1), cluster());\r\n    try {\r\n        m.get(u1.getUserId());\r\n    } catch (NoHostAvailableException e) {\r\n        fail(\"Should not have thrown NoHostAvailableException\");\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.ClassPathResource.getFilename",
	"Comment": "this implementation returns the name of the file that this class pathresource refers to.",
	"Method": "String getFilename(){\r\n    return StringUtils.getFilename(this.path);\r\n}"
}, {
	"Path": "com.datastax.driver.core.AbstractSession.prepareAsync",
	"Comment": "prepares the provided query string asynchronously, sending along the provided custom payload,if any.",
	"Method": "ListenableFuture<PreparedStatement> prepareAsync(String query,ListenableFuture<PreparedStatement> prepareAsync,RegularStatement statement,ListenableFuture<PreparedStatement> prepareAsync,String query,Map<String, ByteBuffer> customPayload){\r\n    if (statement.hasValues())\r\n        throw new IllegalArgumentException(\"A statement to prepare should not have values\");\r\n    final CodecRegistry codecRegistry = getCluster().getConfiguration().getCodecRegistry();\r\n    ListenableFuture<PreparedStatement> prepared = prepareAsync(statement.getQueryString(codecRegistry), statement.getOutgoingPayload());\r\n    return GuavaCompatibility.INSTANCE.transform(prepared, new Function<PreparedStatement, PreparedStatement>() {\r\n        @Override\r\n        public PreparedStatement apply(PreparedStatement prepared) {\r\n            ProtocolVersion protocolVersion = getCluster().getConfiguration().getProtocolOptions().getProtocolVersion();\r\n            ByteBuffer routingKey = statement.getRoutingKey(protocolVersion, codecRegistry);\r\n            if (routingKey != null)\r\n                prepared.setRoutingKey(routingKey);\r\n            if (statement.getConsistencyLevel() != null)\r\n                prepared.setConsistencyLevel(statement.getConsistencyLevel());\r\n            if (statement.getSerialConsistencyLevel() != null)\r\n                prepared.setSerialConsistencyLevel(statement.getSerialConsistencyLevel());\r\n            if (statement.isTracing())\r\n                prepared.enableTracing();\r\n            prepared.setRetryPolicy(statement.getRetryPolicy());\r\n            prepared.setOutgoingPayload(statement.getOutgoingPayload());\r\n            prepared.setIdempotent(statement.isIdempotent());\r\n            return prepared;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.datastax.driver.core.AbstractSession.prepareAsync",
	"Comment": "prepares the provided query string asynchronously, sending along the provided custom payload,if any.",
	"Method": "ListenableFuture<PreparedStatement> prepareAsync(String query,ListenableFuture<PreparedStatement> prepareAsync,RegularStatement statement,ListenableFuture<PreparedStatement> prepareAsync,String query,Map<String, ByteBuffer> customPayload){\r\n    ProtocolVersion protocolVersion = getCluster().getConfiguration().getProtocolOptions().getProtocolVersion();\r\n    ByteBuffer routingKey = statement.getRoutingKey(protocolVersion, codecRegistry);\r\n    if (routingKey != null)\r\n        prepared.setRoutingKey(routingKey);\r\n    if (statement.getConsistencyLevel() != null)\r\n        prepared.setConsistencyLevel(statement.getConsistencyLevel());\r\n    if (statement.getSerialConsistencyLevel() != null)\r\n        prepared.setSerialConsistencyLevel(statement.getSerialConsistencyLevel());\r\n    if (statement.isTracing())\r\n        prepared.enableTracing();\r\n    prepared.setRetryPolicy(statement.getRetryPolicy());\r\n    prepared.setOutgoingPayload(statement.getOutgoingPayload());\r\n    prepared.setIdempotent(statement.isIdempotent());\r\n    return prepared;\r\n}"
}, {
	"Path": "org.jabref.logic.formatter.bibtexfields.ClearFormatterTest.formatReturnsEmptyForEmptyString",
	"Comment": "check whether the clear formatter really returns the empty string for the empty string",
	"Method": "void formatReturnsEmptyForEmptyString(){\r\n    assertEquals(\"\", formatter.format(\"\"));\r\n}"
}, {
	"Path": "org.jabref.logic.importer.ParserResult.toOpenTab",
	"Comment": "check if this database is marked to be added to the currently open tab. default is false.",
	"Method": "boolean toOpenTab(){\r\n    return toOpenTab;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.FileSystemResource.createRelative",
	"Comment": "this implementation creates a filesystemresource, applying the given pathrelative to the path of the underlying file of this resource descriptor.",
	"Method": "Resource createRelative(String relativePath){\r\n    String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\r\n    return new FileSystemResource(pathToUse);\r\n}"
}, {
	"Path": "org.elixir_lang.structure_view.element.Exception.defaultValueElementByKeyElement",
	"Comment": "the default value elements for the struct defined for the exception.",
	"Method": "Map<PsiElement, PsiElement> defaultValueElementByKeyElement(){\r\n    PsiElement[] finalArguments = finalArguments(navigationItem);\r\n    assert finalArguments != null;\r\n    assert finalArguments.length == 1;\r\n    PsiElement finalArgument = finalArguments[0];\r\n    Map<PsiElement, PsiElement> defaultValueElementByKeyElement = new HashMap<PsiElement, PsiElement>(finalArguments.length);\r\n    if (finalArgument instanceof ElixirAccessExpression) {\r\n        PsiElement accessExpressionChild = stripAccessExpression(finalArgument);\r\n        assert accessExpressionChild instanceof ElixirList;\r\n        ElixirList list = (ElixirList) accessExpressionChild;\r\n        PsiElement[] listChildren = list.getChildren();\r\n        if (listChildren.length == 1) {\r\n            PsiElement listChild = listChildren[0];\r\n            if (listChild instanceof QuotableKeywordList) {\r\n                QuotableKeywordList quotableKeywordList = (QuotableKeywordList) listChild;\r\n                putQuotableKeywordList(defaultValueElementByKeyElement, quotableKeywordList);\r\n            } else {\r\n                defaultValueElementByKeyElement.put(listChild, null);\r\n            }\r\n        } else {\r\n            for (PsiElement key : list.getChildren()) {\r\n                defaultValueElementByKeyElement.put(key, null);\r\n            }\r\n        }\r\n    } else if (finalArgument instanceof QuotableKeywordList) {\r\n        QuotableKeywordList quotableKeywordList = (QuotableKeywordList) finalArgument;\r\n        putQuotableKeywordList(defaultValueElementByKeyElement, quotableKeywordList);\r\n    } else {\r\n        assert finalArgument != null;\r\n    }\r\n    return defaultValueElementByKeyElement;\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.SchemaBuilder.noSpeculativeRetry",
	"Comment": "create the speculative retry strategy that never retries reads, to use in a create or altertable statement.",
	"Method": "TableOptions.SpeculativeRetryValue noSpeculativeRetry(){\r\n    return new TableOptions.SpeculativeRetryValue(\"'NONE'\");\r\n}"
}, {
	"Path": "com.datastax.driver.mapping.MapperCaseSensitivityTest.should_handle_case_sensitive_identifiers_when_keyspace_specified",
	"Comment": "validates that case sensitive identifiers for fields, types, columns, tables and keyspaces workwith the mapper when the keyspace name is specified on the mapped class.",
	"Method": "void should_handle_case_sensitive_identifiers_when_keyspace_specified(){\r\n    MappingManager mappingManager = new MappingManager(session());\r\n    Mapper<User> mapper = mappingManager.mapper(User.class);\r\n    mapper.save(user);\r\n    assertThat(mapper.get(user.getUserId())).isEqualTo(user);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.path.PathMatchingResourcePatternResolver.setPathMatcher",
	"Comment": "set the pathmatcher implementation to use for this resource patternresolver. default is antpathmatcher.",
	"Method": "void setPathMatcher(PathMatcher pathMatcher){\r\n    Assert.notNull(pathMatcher, \"PathMatcher must not be null\");\r\n    this.pathMatcher = pathMatcher;\r\n}"
}, {
	"Path": "org.jabref.gui.maintable.MainTableNameFormatter.formatName",
	"Comment": "format a name field for the table, according to user preferences.",
	"Method": "String formatName(String nameToFormat){\r\n    if (nameToFormat == null) {\r\n        return null;\r\n    }\r\n    final boolean namesNatbib = Globals.prefs.getBoolean(JabRefPreferences.NAMES_NATBIB);\r\n    final boolean namesLastOnly = Globals.prefs.getBoolean(JabRefPreferences.NAMES_LAST_ONLY);\r\n    final boolean namesAsIs = Globals.prefs.getBoolean(JabRefPreferences.NAMES_AS_IS);\r\n    final boolean namesFf = Globals.prefs.getBoolean(JabRefPreferences.NAMES_FIRST_LAST);\r\n    final boolean abbrAuthorNames = Globals.prefs.getBoolean(JabRefPreferences.ABBR_AUTHOR_NAMES);\r\n    if (namesAsIs) {\r\n        return nameToFormat;\r\n    } else if (namesNatbib) {\r\n        return AuthorList.fixAuthorNatbib(nameToFormat);\r\n    } else if (namesLastOnly) {\r\n        return AuthorList.fixAuthorLastNameOnlyCommas(nameToFormat, false);\r\n    } else if (namesFf) {\r\n        return AuthorList.fixAuthorFirstNameFirstCommas(nameToFormat, abbrAuthorNames, false);\r\n    }\r\n    return AuthorList.fixAuthorLastNameFirstCommas(nameToFormat, abbrAuthorNames, false);\r\n}"
}, {
	"Path": "org.jabref.model.EntryTypes.getType",
	"Comment": "this method returns the bibtexentrytype for the name of a type,or null if it does not exist.",
	"Method": "Optional<EntryType> getType(String name,Optional<EntryType> getType,String name,BibDatabaseMode type){\r\n    return type == BibDatabaseMode.BIBLATEX ? BIBLATEX.getType(name) : BIBTEX.getType(name);\r\n}"
}, {
	"Path": "com.github.javafaker.DateAndTime.future",
	"Comment": "generates a future date from now. note that there is a 1 second slack to avoid generating a past date.",
	"Method": "Date future(int atMost,TimeUnit unit,Date future,int atMost,int minimum,TimeUnit unit,Date future,int atMost,TimeUnit unit,Date referenceDate){\r\n    long upperBound = unit.toMillis(atMost);\r\n    long futureMillis = referenceDate.getTime();\r\n    futureMillis += 1 + faker.random().nextLong(upperBound - 1);\r\n    return new Date(futureMillis);\r\n}"
}, {
	"Path": "org.jabref.gui.filelist.FileListTableModel.getToolTipHTMLRepresentation",
	"Comment": "transform the file list shown in the table into a html string representationsuitable for displaying the contents in a tooltip.",
	"Method": "String getToolTipHTMLRepresentation(){\r\n    StringJoiner sb = new StringJoiner(\"<br>\", \"<html>\", \"<\/html>\");\r\n    synchronized (list) {\r\n        for (FileListEntry entry : list) {\r\n            sb.add(String.format(\"%s (%s)\", entry.getDescription(), entry.getLink()));\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.jabref.gui.JabRefFrame.updateEnabledState",
	"Comment": "enable or disable all actions based on the number of open tabs.the action that are affected are set in initactions.",
	"Method": "void updateEnabledState(ListChangeListener.Change<? extends Tab> change){\r\n    int tabCount = tabbedPane.getTabs().size();\r\n    if (!change.next()) {\r\n        return;\r\n    }\r\n    if (change.wasAdded() || change.wasRemoved()) {\r\n        setEnabled(openDatabaseOnlyActions, tabCount > 0);\r\n        setEnabled(severalDatabasesOnlyActions, tabCount > 1);\r\n    }\r\n    if (tabCount == 0) {\r\n        setEnabled(openAndSavedDatabasesOnlyActions, false);\r\n        setEnabled(sharedDatabaseOnlyActions, false);\r\n        setEnabled(oneEntryOnlyActions, false);\r\n    }\r\n    if (tabCount > 0) {\r\n        BasePanel current = getCurrentBasePanel();\r\n        boolean saved = current.getBibDatabaseContext().getDatabasePath().isPresent();\r\n        setEnabled(openAndSavedDatabasesOnlyActions, saved);\r\n        boolean isShared = current.getBibDatabaseContext().getLocation() == DatabaseLocation.SHARED;\r\n        setEnabled(sharedDatabaseOnlyActions, isShared);\r\n        setEnabled(noSharedDatabaseActions, !isShared);\r\n        boolean oneEntrySelected = current.getSelectedEntries().size() == 1;\r\n        setEnabled(oneEntryOnlyActions, oneEntrySelected);\r\n        setEnabled(oneEntryWithFileOnlyActions, isExistFile(current.getSelectedEntries()));\r\n        setEnabled(oneEntryWithURLorDOIOnlyActions, isExistURLorDOI(current.getSelectedEntries()));\r\n        boolean twoEntriesSelected = current.getSelectedEntries().size() == 2;\r\n        setEnabled(twoEntriesOnlyActions, twoEntriesSelected);\r\n        boolean atLeastOneEntrySelected = !current.getSelectedEntries().isEmpty();\r\n        setEnabled(atLeastOneEntryActions, atLeastOneEntrySelected);\r\n    }\r\n}"
}, {
	"Path": "com.github.javafaker.Weather.temperatureFahrenheit",
	"Comment": "generates a random temperature fahrenheit between two temperatures.",
	"Method": "String temperatureFahrenheit(String temperatureFahrenheit,int minTemperature,int maxTemperature){\r\n    return temperature(minTemperature, maxTemperature, \"weather.temperature.fahrenheit\");\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPool.replaceConnection",
	"Comment": "directly because we want to make sure the connection is always trashed.",
	"Method": "void replaceConnection(Connection connection){\r\n    if (!connection.state.compareAndSet(OPEN, TRASHED))\r\n        return;\r\n    open.decrementAndGet();\r\n    maybeSpawnNewConnection();\r\n    connection.maxIdleTime = Long.MIN_VALUE;\r\n    doTrashConnection(connection);\r\n}"
}, {
	"Path": "org.elixir_lang.parser.ElixirParser.matchedQualifiedBracketOperation_0",
	"Comment": "dotinfixoperator relativeidentifier call bracketarguments",
	"Method": "boolean matchedQualifiedBracketOperation_0(PsiBuilder b,int l){\r\n    if (!recursion_guard_(b, l, \"matchedQualifiedBracketOperation_0\"))\r\n        return false;\r\n    boolean r;\r\n    Marker m = enter_section_(b);\r\n    r = dotInfixOperator(b, l + 1);\r\n    r = r && relativeIdentifier(b, l + 1);\r\n    r = r && consumeToken(b, CALL);\r\n    r = r && bracketArguments(b, l + 1);\r\n    exit_section_(b, m, null, r);\r\n    return r;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.result.RowView.getColumn",
	"Comment": "use a column mapper to extract a type from the current resultset row.",
	"Method": "T getColumn(String column,Class<T> type,T getColumn,int column,Class<T> type,T getColumn,String column,GenericType<T> type,T getColumn,int column,GenericType<T> type,Object getColumn,String column,Type type,Object getColumn,int column,Type type){\r\n    try {\r\n        return columnMapperFor(type).map(rs, column, ctx);\r\n    } catch (SQLException e) {\r\n        throw new MappingException(e);\r\n    }\r\n}"
}, {
	"Path": "org.jdbi.v3.core.Handle.execute",
	"Comment": "execute a sql statement, and return the number of rows affected by the statement.",
	"Method": "int execute(String sql,Object args){\r\n    Update stmt = createUpdate(sql);\r\n    int position = 0;\r\n    for (Object arg : args) {\r\n        stmt.bind(position++, arg);\r\n    }\r\n    return stmt.execute();\r\n}"
}, {
	"Path": "org.menacheri.jetserver.util.NettyUtils.readSocketAddress",
	"Comment": "read a socket address from a buffer. the socket address will be provided\tas two strings containing host and port.",
	"Method": "InetSocketAddress readSocketAddress(ChannelBuffer buffer){\r\n    String remoteHost = NettyUtils.readString(buffer);\r\n    int remotePort = 0;\r\n    if (buffer.readableBytes() >= 4) {\r\n        remotePort = buffer.readInt();\r\n    } else {\r\n        return null;\r\n    }\r\n    InetSocketAddress remoteAddress = null;\r\n    if (null != remoteHost) {\r\n        remoteAddress = new InetSocketAddress(remoteHost, remotePort);\r\n    }\r\n    return remoteAddress;\r\n}"
}, {
	"Path": "com.datastax.driver.core.PreparedStatementTest.should_unset_value_by_index",
	"Comment": "tests that a value that was previously set on a bound statement can be unset by index. thisonly works from protocol v4 onwards.",
	"Method": "void should_unset_value_by_index(){\r\n    PreparedStatement prepared = session().prepare(\"INSERT INTO \" + SIMPLE_TABLE + \" (k, i) VALUES (?, ?)\");\r\n    BoundStatement bound = prepared.bind();\r\n    bound.setString(0, \"foo\");\r\n    bound.setInt(1, 1234);\r\n    bound.unset(1);\r\n    assertThat(bound.isSet(1)).isFalse();\r\n    session().execute(bound);\r\n    ResultSet rows = session().execute(new SimpleStatement(\"SELECT i from \" + SIMPLE_TABLE + \" where k = 'foo'\").enableTracing());\r\n    assertThat(rows.one().isNull(\"i\"));\r\n    Uninterruptibles.sleepUninterruptibly(10, TimeUnit.SECONDS);\r\n    QueryTrace queryTrace = rows.getExecutionInfo().getQueryTrace();\r\n    assertEventsContain(queryTrace, \"0 tombstone\");\r\n}"
}, {
	"Path": "com.datastax.driver.core.QueryOptions.getMaxPendingRefreshSchemaRequests",
	"Comment": "the maximum number of schema refresh requests that the control connection can accumulate beforeexecuting them.",
	"Method": "int getMaxPendingRefreshSchemaRequests(){\r\n    return maxPendingRefreshSchemaRequests;\r\n}"
}, {
	"Path": "org.jabref.logic.openoffice.OOBibStyle.handleJournalsLine",
	"Comment": "parse a line providing a journal name for which this style is valid.",
	"Method": "void handleJournalsLine(String line){\r\n    if (!line.trim().isEmpty()) {\r\n        journals.add(line.trim());\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.entryeditor.EntryEditorTab.notifyAboutFocus",
	"Comment": "notifies the tab that it got focus and should display the given entry.",
	"Method": "void notifyAboutFocus(BibEntry entry){\r\n    if (!entry.equals(currentEntry) || !currentEntryType.equals(entry.getType())) {\r\n        currentEntry = entry;\r\n        currentEntryType = entry.getType();\r\n        bindToEntry(entry);\r\n    }\r\n    handleFocus();\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiles.FindUnlinkedFilesDialog.initialize",
	"Comment": "initializes the components, the layout, the data structure and the actions in this dialog.",
	"Method": "void initialize(){\r\n    Button buttonBrowse = new Button(Localization.lang(\"Browse\"));\r\n    buttonBrowse.setTooltip(new Tooltip(Localization.lang(\"Opens the file browser.\")));\r\n    buttonBrowse.getStyleClass().add(\"text-button\");\r\n    buttonBrowse.setOnAction(e -> {\r\n        DirectoryDialogConfiguration directoryDialogConfiguration = new DirectoryDialogConfiguration.Builder().withInitialDirectory(preferences.get(JabRefPreferences.WORKING_DIRECTORY)).build();\r\n        dialogService.showDirectorySelectionDialog(directoryDialogConfiguration).ifPresent(selectedDirectory -> {\r\n            textfieldDirectoryPath.setText(selectedDirectory.toAbsolutePath().toString());\r\n            preferences.put(JabRefPreferences.WORKING_DIRECTORY, selectedDirectory.toAbsolutePath().toString());\r\n        });\r\n    });\r\n    buttonScan = new Button(Localization.lang(\"Scan directory\"));\r\n    buttonScan.setTooltip(new Tooltip((Localization.lang(\"Searches the selected directory for unlinked files.\"))));\r\n    buttonScan.setOnAction(e -> startSearch());\r\n    buttonScan.setDefaultButton(true);\r\n    buttonScan.setPadding(new Insets(5, 0, 0, 0));\r\n    buttonExport = new Button(Localization.lang(\"Export selected entries\"));\r\n    buttonExport.setTooltip(new Tooltip(Localization.lang(\"Export to text file.\")));\r\n    buttonExport.getStyleClass().add(\"text-button\");\r\n    buttonExport.setDisable(true);\r\n    buttonExport.setOnAction(e -> startExport());\r\n    ButtonType buttonTypeImport = new ButtonType(Localization.lang(\"Import\"), ButtonBar.ButtonData.OK_DONE);\r\n    getDialogPane().getButtonTypes().setAll(buttonTypeImport, ButtonType.CANCEL);\r\n    buttonApply = (Button) getDialogPane().lookupButton(buttonTypeImport);\r\n    buttonApply.setTooltip(new Tooltip((Localization.lang(\"Starts the import of BibTeX entries.\"))));\r\n    buttonApply.setDisable(true);\r\n    Button buttonOptionSelectAll = new Button();\r\n    buttonOptionSelectAll.setText(Localization.lang(\"Select all\"));\r\n    buttonOptionSelectAll.getStyleClass().add(\"text-button\");\r\n    buttonOptionSelectAll.setOnAction(event -> {\r\n        CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot();\r\n        root.setSelected(true);\r\n        root.setSelected(false);\r\n        root.setSelected(true);\r\n    });\r\n    Button buttonOptionDeselectAll = new Button();\r\n    buttonOptionDeselectAll.setText(Localization.lang(\"Unselect all\"));\r\n    buttonOptionDeselectAll.getStyleClass().add(\"text-button\");\r\n    buttonOptionDeselectAll.setOnAction(event -> {\r\n        CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot();\r\n        root.setSelected(false);\r\n        root.setSelected(true);\r\n        root.setSelected(false);\r\n    });\r\n    Button buttonOptionExpandAll = new Button();\r\n    buttonOptionExpandAll.setText(Localization.lang(\"Expand all\"));\r\n    buttonOptionExpandAll.getStyleClass().add(\"text-button\");\r\n    buttonOptionExpandAll.setOnAction(event -> {\r\n        CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot();\r\n        expandTree(root, true);\r\n    });\r\n    Button buttonOptionCollapseAll = new Button();\r\n    buttonOptionCollapseAll.setText(Localization.lang(\"Collapse all\"));\r\n    buttonOptionCollapseAll.getStyleClass().add(\"text-button\");\r\n    buttonOptionCollapseAll.setOnAction(event -> {\r\n        CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot();\r\n        expandTree(root, false);\r\n        root.setExpanded(true);\r\n    });\r\n    checkboxCreateKeywords = new CheckBox(Localization.lang(\"Create directory based keywords\"));\r\n    checkboxCreateKeywords.setTooltip(new Tooltip((Localization.lang(\"Creates keywords in created entrys with directory pathnames\"))));\r\n    textfieldDirectoryPath = new TextField();\r\n    Path initialPath = databaseContext.getFirstExistingFileDir(preferences.getFilePreferences()).orElse(preferences.getWorkingDir());\r\n    textfieldDirectoryPath.setText(initialPath.toAbsolutePath().toString());\r\n    Label labelDirectoryDescription = new Label(Localization.lang(\"Select a directory where the search shall start.\"));\r\n    Label labelFileTypesDescription = new Label(Localization.lang(\"Select file type:\"));\r\n    Label labelFilesDescription = new Label(Localization.lang(\"These files are not linked in the active library.\"));\r\n    Label labelEntryTypeDescription = new Label(Localization.lang(\"Entry type to be created:\"));\r\n    Label labelSearchingDirectoryInfo = new Label(Localization.lang(\"Searching file system...\"));\r\n    tree = new TreeView();\r\n    tree.setPrefWidth(Double.POSITIVE_INFINITY);\r\n    ScrollPane scrollPaneTree = new ScrollPane(tree);\r\n    scrollPaneTree.setFitToWidth(true);\r\n    ProgressIndicator progressBarSearching = new ProgressIndicator();\r\n    progressBarSearching.setMaxSize(50, 50);\r\n    setResultConverter(buttonPressed -> {\r\n        if (buttonPressed == buttonTypeImport) {\r\n            startImport();\r\n        } else {\r\n            if (findUnlinkedFilesTask != null) {\r\n                findUnlinkedFilesTask.cancel();\r\n            }\r\n        }\r\n        return null;\r\n    });\r\n    new ViewModelTreeCellFactory<FileNodeWrapper>().withText(node -> {\r\n        if (Files.isRegularFile(node.path)) {\r\n            return node.path.getFileName().toString();\r\n        } else {\r\n            return node.path.getFileName() + \" (\" + node.fileCount + \" file\" + (node.fileCount > 1 ? \"s\" : \"\") + \")\";\r\n        }\r\n    }).install(tree);\r\n    List<FileFilter> fileFilterList = creatorManager.getFileFilterList();\r\n    comboBoxFileTypeSelection = new ComboBox(FXCollections.observableArrayList(fileFilterList));\r\n    comboBoxFileTypeSelection.getSelectionModel().selectFirst();\r\n    new ViewModelListCellFactory<FileFilter>().withText(Object::toString).withIcon(fileFilter -> {\r\n        if (fileFilter instanceof EntryFromFileCreator) {\r\n            EntryFromFileCreator creator = (EntryFromFileCreator) fileFilter;\r\n            if (creator.getExternalFileType() != null) {\r\n                return creator.getExternalFileType().getIcon();\r\n            }\r\n        }\r\n        return null;\r\n    }).install(comboBoxFileTypeSelection);\r\n    Collection<EntryType> entryTypes = EntryTypes.getAllValues(frame.getCurrentBasePanel().getBibDatabaseContext().getMode());\r\n    comboBoxEntryTypeSelection = new ComboBox(FXCollections.observableArrayList(entryTypes));\r\n    comboBoxEntryTypeSelection.getSelectionModel().selectFirst();\r\n    new ViewModelListCellFactory<EntryType>().withText(EntryType::getName).install(comboBoxEntryTypeSelection);\r\n    panelSearchProgress = new VBox(5, labelSearchingDirectoryInfo, progressBarSearching);\r\n    panelSearchProgress.toFront();\r\n    panelSearchProgress.setVisible(false);\r\n    VBox panelDirectory = new VBox(5);\r\n    panelDirectory.getChildren().setAll(labelDirectoryDescription, new HBox(10, textfieldDirectoryPath, buttonBrowse), new HBox(15, labelFileTypesDescription, comboBoxFileTypeSelection), buttonScan);\r\n    HBox.setHgrow(textfieldDirectoryPath, Priority.ALWAYS);\r\n    StackPane stackPaneTree = new StackPane(scrollPaneTree, panelSearchProgress);\r\n    StackPane.setAlignment(panelSearchProgress, Pos.CENTER);\r\n    BorderPane panelFiles = new BorderPane();\r\n    panelFiles.setTop(labelFilesDescription);\r\n    panelFiles.setCenter(stackPaneTree);\r\n    panelFiles.setBottom(new HBox(5, buttonOptionSelectAll, buttonOptionDeselectAll, buttonOptionExpandAll, buttonOptionCollapseAll, buttonExport));\r\n    VBox panelEntryTypesSelection = new VBox(5);\r\n    panelEntryTypesSelection.getChildren().setAll(new HBox(15, labelEntryTypeDescription, comboBoxEntryTypeSelection), checkboxCreateKeywords);\r\n    VBox container = new VBox(20);\r\n    container.getChildren().addAll(panelDirectory, panelFiles, panelEntryTypesSelection);\r\n    container.setPrefWidth(600);\r\n    getDialogPane().setContent(container);\r\n}"
}, {
	"Path": "org.jabref.logic.shared.DBMSProcessor.setupSharedDatabase",
	"Comment": "creates and sets up the needed tables and columns according to the database type andperforms a check whether the needed tables are present.",
	"Method": "void setupSharedDatabase(){\r\n    setUp();\r\n    if (!checkBaseIntegrity()) {\r\n        LOGGER.error(\"Corrupt_shared_database_structure.\");\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.preferences.XmpPrefsTab.setValues",
	"Comment": "load settings from the preferences and initialize the table.",
	"Method": "void setValues(){\r\n    List<XMPPrivacyFilter> xmpExclusions = prefs.getStringList(JabRefPreferences.XMP_PRIVACY_FILTERS).stream().map(XMPPrivacyFilter::new).collect(Collectors.toList());\r\n    fields.setAll(xmpExclusions);\r\n    privacyFilterCheckBox.setSelected(JabRefPreferences.getInstance().getBoolean(JabRefPreferences.USE_XMP_PRIVACY_FILTER));\r\n}"
}, {
	"Path": "org.jdbi.v3.core.Handle.createUpdate",
	"Comment": "create an insert or update statement which returns the number of rows modified.",
	"Method": "Update createUpdate(String sql){\r\n    return new Update(this, sql);\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.SchemaBuilder.always",
	"Comment": "create the speculative retry strategy that retries reads of all replicas, to use in a create oralter table statement.",
	"Method": "TableOptions.SpeculativeRetryValue always(){\r\n    return new TableOptions.SpeculativeRetryValue(\"'ALWAYS'\");\r\n}"
}, {
	"Path": "com.datastax.driver.core.policies.Policies.getReconnectionPolicy",
	"Comment": "the reconnection policy in use.the reconnection policy defines how often the driver tries to reconnect to a dead node.",
	"Method": "ReconnectionPolicy getReconnectionPolicy(){\r\n    return reconnectionPolicy;\r\n}"
}, {
	"Path": "com.datastax.driver.core.exceptions.AlreadyExistsException.getKeyspace",
	"Comment": "the name of keyspace that either already exists or is home to the table that already exists.",
	"Method": "String getKeyspace(){\r\n    return keyspace;\r\n}"
}, {
	"Path": "org.jabref.model.entry.AuthorListParser.parse",
	"Comment": "parses the string containing person names and returns a list of person information.",
	"Method": "AuthorList parse(String listOfNames){\r\n    Objects.requireNonNull(listOfNames);\r\n    original = listOfNames;\r\n    tokenStart = 0;\r\n    tokenEnd = 0;\r\n    List<Author> authors = new ArrayList(5);\r\n    while (tokenStart < original.length()) {\r\n        getAuthor().ifPresent(authors::add);\r\n    }\r\n    return new AuthorList(authors);\r\n}"
}, {
	"Path": "org.jabref.logic.openoffice.OpenOfficeFileSearch.detectInstallations",
	"Comment": "detects existing installation of openoffice and libreoffice.",
	"Method": "List<Path> detectInstallations(){\r\n    if (OS.WINDOWS) {\r\n        List<Path> programDirs = findWindowsOpenOfficeDirs();\r\n        return programDirs.stream().filter(dir -> FileUtil.find(OpenOfficePreferences.WINDOWS_EXECUTABLE, dir).isPresent()).collect(Collectors.toList());\r\n    } else if (OS.OS_X) {\r\n        List<Path> programDirs = findOSXOpenOfficeDirs();\r\n        return programDirs.stream().filter(dir -> FileUtil.find(OpenOfficePreferences.OSX_EXECUTABLE, dir).isPresent()).collect(Collectors.toList());\r\n    } else if (OS.LINUX) {\r\n        List<Path> programDirs = findLinuxOpenOfficeDirs();\r\n        return programDirs.stream().filter(dir -> FileUtil.find(OpenOfficePreferences.LINUX_EXECUTABLE, dir).isPresent()).collect(Collectors.toList());\r\n    }\r\n    return new ArrayList(0);\r\n}"
}, {
	"Path": "org.jabref.model.entry.BibEntry.setField",
	"Comment": "sets a number of fields simultaneously. the given hashmap contains fieldnames as keys, each mapped to the value to set.",
	"Method": "void setField(Map<String, String> fields,Optional<FieldChange> setField,String name,String value,EntryEventSource eventSource,Optional<FieldChange> setField,String name,Optional<String> value,EntryEventSource eventSource,Optional<FieldChange> setField,String name,String value){\r\n    return setField(name, value, EntryEventSource.LOCAL);\r\n}"
}, {
	"Path": "org.jabref.gui.push.AbstractPushToApplication.getCommandName",
	"Comment": "function to get the command name in case it is different from the application name",
	"Method": "String getCommandName(){\r\n    return null;\r\n}"
}, {
	"Path": "com.datastax.driver.core.SSLEncryptionTest.should_use_system_properties_with_default_ssl_options",
	"Comment": "validates that ssl connectivity can be configured via the standard javax.net.ssl systemproperties.",
	"Method": "void should_use_system_properties_with_default_ssl_options(){\r\n    System.setProperty(\"javax.net.ssl.trustStore\", DEFAULT_CLIENT_TRUSTSTORE_FILE.getAbsolutePath());\r\n    System.setProperty(\"javax.net.ssl.trustStorePassword\", DEFAULT_CLIENT_TRUSTSTORE_PASSWORD);\r\n    try {\r\n        connectWithSSL();\r\n    } finally {\r\n        try {\r\n            System.clearProperty(\"javax.net.ssl.trustStore\");\r\n            System.clearProperty(\"javax.net.ssl.trustStorePassword\");\r\n        } catch (SecurityException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.spring.scanner.XmlBeanDefinationScannerAgent.registerXmlBeanDefinationScannerAgent",
	"Comment": "need to ensure that when method is invoked first time , this class is not loaded,so this class is will be loaded by appclassloader",
	"Method": "void registerXmlBeanDefinationScannerAgent(XmlBeanDefinitionReader reader,Resource resource){\r\n    String path;\r\n    if (resource instanceof ClassPathResource) {\r\n        path = ((ClassPathResource) resource).getPath();\r\n    } else {\r\n        try {\r\n            path = convertToClasspathURL(resource.getURL().getPath());\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            LOGGER.error(\"Cannot get url from resource: {}\", resource);\r\n            return;\r\n        }\r\n    }\r\n    instances.put(path, new XmlBeanDefinationScannerAgent(reader));\r\n}"
}, {
	"Path": "org.jabref.gui.menus.FileHistoryMenu.newFile",
	"Comment": "adds the filename to the top of the menu. if it already is inthe menu, it is merely moved to the top.",
	"Method": "void newFile(Path file){\r\n    history.newFile(file);\r\n    setItems();\r\n    setDisable(false);\r\n}"
}, {
	"Path": "org.jabref.model.database.BibDatabases.createDatabase",
	"Comment": "gets a collection of bibentries and sets an id for every entry. after thatall entries will be inserted into a new bibdatabase.",
	"Method": "BibDatabase createDatabase(Collection<BibEntry> bibentries){\r\n    BibDatabase database = new BibDatabase();\r\n    for (BibEntry entry : bibentries) {\r\n        entry.setId(IdGenerator.next());\r\n        database.insertEntry(entry);\r\n    }\r\n    return database;\r\n}"
}, {
	"Path": "org.jabref.logic.layout.format.FileLink.setArgument",
	"Comment": "this method is called if the layout file specifies an argument for thisformatter. we use it as an indicator of which file type we should look for.",
	"Method": "void setArgument(String arg){\r\n    fileType = arg;\r\n}"
}, {
	"Path": "org.jabref.gui.JabRefFrame.setProgressBarVisible",
	"Comment": "set the visibility of the progress bar in the right end of the status line at the bottom of the frame.",
	"Method": "void setProgressBarVisible(boolean visible){\r\n    progressBar.setVisible(visible);\r\n}"
}, {
	"Path": "com.datastax.driver.core.exceptions.QueryConsistencyException.getAddress",
	"Comment": "the full address of the coordinator host that caused this exception to be thrown. note thatthis is the query coordinator host, not the host which timed out.",
	"Method": "InetSocketAddress getAddress(){\r\n    return address;\r\n}"
}, {
	"Path": "org.jabref.model.entry.InternalBibtexFields.getAllPublicAndInternalFieldNames",
	"Comment": "returns a sorted list with all field names including internal field names",
	"Method": "List<String> getAllPublicAndInternalFieldNames(){\r\n    List<String> publicAndInternalFields = new ArrayList();\r\n    publicAndInternalFields.addAll(InternalBibtexFields.getAllPublicFieldNames());\r\n    publicAndInternalFields.add(FieldName.INTERNAL_ALL_FIELD);\r\n    publicAndInternalFields.add(FieldName.INTERNAL_ALL_TEXT_FIELDS_FIELD);\r\n    Collections.sort(publicAndInternalFields);\r\n    return publicAndInternalFields;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.spring.getbean.ProxyReplacer.register",
	"Comment": "creates a proxied spring bean. called from within webapp code by modification of spring classes",
	"Method": "Object register(Object beanFactry,Object bean,Class<?>[] paramClasses,Object[] paramValues){\r\n    if (bean == null) {\r\n        return bean;\r\n    }\r\n    if (SpringPlugin.basePackagePrefixes != null) {\r\n        boolean hasMatch = false;\r\n        for (String basePackagePrefix : SpringPlugin.basePackagePrefixes) {\r\n            if (bean.getClass().getName().startsWith(basePackagePrefix)) {\r\n                hasMatch = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!hasMatch) {\r\n            LOGGER.info(\"{} not in basePackagePrefix\", bean.getClass().getName());\r\n            return bean;\r\n        }\r\n    }\r\n    if (bean.getClass().getName().startsWith(\"com.sun.proxy.$Proxy\")) {\r\n        InvocationHandler handler = new HotswapSpringInvocationHandler(bean, beanFactry, paramClasses, paramValues);\r\n        Class<?>[] interfaces = bean.getClass().getInterfaces();\r\n        try {\r\n            if (!Arrays.asList(interfaces).contains(getInfrastructureProxyClass())) {\r\n                interfaces = Arrays.copyOf(interfaces, interfaces.length + 1);\r\n                interfaces[interfaces.length - 1] = getInfrastructureProxyClass();\r\n            }\r\n        } catch (ClassNotFoundException e) {\r\n            LOGGER.error(\"error adding org.springframework.core.InfrastructureProxy to proxy class\", e);\r\n        }\r\n        return Proxy.newProxyInstance(beanFactry.getClass().getClassLoader(), interfaces, handler);\r\n    } else if (EnhancerProxyCreater.isSupportedCglibProxy(bean)) {\r\n        if (bean.getClass().getName().contains(\"$HOTSWAPAGENT_\")) {\r\n            return bean;\r\n        }\r\n        return EnhancerProxyCreater.createProxy(beanFactry, bean, paramClasses, paramValues);\r\n    }\r\n    return bean;\r\n}"
}, {
	"Path": "org.elixir_lang.formatter.Block.buildEndOfExpressionChildren",
	"Comment": "builds endofexpression..importantly, it separates out the eols, which are whitespace from the comments thatmay be interlaced",
	"Method": "List<com.intellij.formatting.Block> buildEndOfExpressionChildren(ASTNode endOfExpression,Alignment childAlignment,Indent childIndent){\r\n    return buildChildren(endOfExpression, (child, childElementType, blockList) -> {\r\n        blockList.add(buildChild(child, childAlignment, childIndent));\r\n        return blockList;\r\n    });\r\n}"
}, {
	"Path": "org.elixir_lang.navigation.item_presentation.CallDefinitionHead.getPresentableText",
	"Comment": "returns the name of the object to be presented in most renderers across the program.",
	"Method": "String getPresentableText(){\r\n    return psiElement.getText().replaceAll(\"\\\\s+\", \" \").replaceAll(\"([\\\\[(]) ?\", \"$1\").replaceAll(\" ?(\\\\]|\\\\))\", \"$1\");\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.util.proxy.ProxyFactory.setHandler",
	"Comment": "sets the default invocation handler.this invocation handler is sharedamong all the instances of a proxy class unless another is explicitlyspecified.",
	"Method": "void setHandler(MethodHandler mi){\r\n    if (factoryUseCache && mi != null) {\r\n        factoryUseCache = false;\r\n        thisClass = null;\r\n    }\r\n    handler = mi;\r\n    setField(DEFAULT_INTERCEPTOR, handler);\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.StatementContext.getStatement",
	"Comment": "obtain the actual prepared statement being used.not available until execution time",
	"Method": "PreparedStatement getStatement(){\r\n    return statement;\r\n}"
}, {
	"Path": "com.datastax.driver.core.ConsistencyTest.should_use_statement_cl",
	"Comment": "exhaustively tests all consistency levels when they are set at the statement level.",
	"Method": "void should_use_statement_cl(ConsistencyLevel cl){\r\n    Cluster cluster = builder().build();\r\n    try {\r\n        Session session = cluster.connect();\r\n        String queryString = \"statement_cl\";\r\n        Query clQuery = executeSimple(session, queryString, cl, null);\r\n        assertTrue(clQuery.getConsistency().equals(cl.toString()));\r\n        String prepareString = \"preapred_statement_cl\";\r\n        PreparedStatementExecution pse = executePrepared(session, prepareString, cl, null);\r\n        assertTrue(pse.getConsistency().equals(cl.toString()));\r\n        String batchStateString = \"batch_statement_cl\";\r\n        BatchExecution batch = executeBatch(session, batchStateString, cl, null);\r\n        assertTrue(batch.getConsistency().equals(cl.toString()));\r\n    } finally {\r\n        cluster.close();\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.java.ProxyGenerator.generateStaticInitializer",
	"Comment": "generate the static initializer method for the proxy class.",
	"Method": "MethodInfo generateStaticInitializer(){\r\n    MethodInfo minfo = new MethodInfo(initMethodName, \"()V\", ACC_STATIC);\r\n    int localSlot0 = 1;\r\n    short pc, tryBegin = 0, tryEnd;\r\n    DataOutputStream out = new DataOutputStream(minfo.code);\r\n    for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\r\n        for (ProxyMethod pm : sigmethods) {\r\n            pm.codeFieldInitialization(out);\r\n        }\r\n    }\r\n    out.writeByte(opc_iconst_1);\r\n    out.writeByte(opc_putstatic);\r\n    out.writeShort(cp.getFieldRef(dotToSlash(className), initFieldName, \"Z\"));\r\n    out.writeByte(opc_return);\r\n    tryEnd = pc = (short) minfo.code.size();\r\n    minfo.exceptionTable.add(new ExceptionTableEntry(tryBegin, tryEnd, pc, cp.getClass(\"java/lang/NoSuchMethodException\")));\r\n    code_astore(localSlot0, out);\r\n    out.writeByte(opc_new);\r\n    out.writeShort(cp.getClass(\"java/lang/NoSuchMethodError\"));\r\n    out.writeByte(opc_dup);\r\n    code_aload(localSlot0, out);\r\n    out.writeByte(opc_invokevirtual);\r\n    out.writeShort(cp.getMethodRef(\"java/lang/Throwable\", \"getMessage\", \"()Ljava/lang/String;\"));\r\n    out.writeByte(opc_invokespecial);\r\n    out.writeShort(cp.getMethodRef(\"java/lang/NoSuchMethodError\", \"<init>\", \"(Ljava/lang/String;)V\"));\r\n    out.writeByte(opc_athrow);\r\n    pc = (short) minfo.code.size();\r\n    minfo.exceptionTable.add(new ExceptionTableEntry(tryBegin, tryEnd, pc, cp.getClass(\"java/lang/ClassNotFoundException\")));\r\n    code_astore(localSlot0, out);\r\n    out.writeByte(opc_new);\r\n    out.writeShort(cp.getClass(\"java/lang/NoClassDefFoundError\"));\r\n    out.writeByte(opc_dup);\r\n    code_aload(localSlot0, out);\r\n    out.writeByte(opc_invokevirtual);\r\n    out.writeShort(cp.getMethodRef(\"java/lang/Throwable\", \"getMessage\", \"()Ljava/lang/String;\"));\r\n    out.writeByte(opc_invokespecial);\r\n    out.writeShort(cp.getMethodRef(\"java/lang/NoClassDefFoundError\", \"<init>\", \"(Ljava/lang/String;)V\"));\r\n    out.writeByte(opc_athrow);\r\n    if (minfo.code.size() > 65535) {\r\n        throw new IllegalArgumentException(\"code size limit exceeded\");\r\n    }\r\n    minfo.maxStack = 10;\r\n    minfo.maxLocals = (short) (localSlot0 + 1);\r\n    minfo.declaredExceptions = new short[0];\r\n    return minfo;\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiles.FindUnlinkedFilesDialog.startImport",
	"Comment": "this will start the import of all file of all selected nodes in the file tree view.",
	"Method": "void startImport(){\r\n    CheckBoxTreeItem<FileNodeWrapper> root = (CheckBoxTreeItem<FileNodeWrapper>) tree.getRoot();\r\n    final List<Path> fileList = getFileListFromNode(root);\r\n    if (fileList.isEmpty()) {\r\n        return;\r\n    }\r\n    final EntryType entryType = comboBoxEntryTypeSelection.getValue();\r\n    List<String> errors = creatorManager.addEntriesFromFiles(fileList, databaseContext.getDatabase(), frame.getCurrentBasePanel(), entryType, checkboxCreateKeywords.isSelected());\r\n    if (!errors.isEmpty()) {\r\n        String message;\r\n        if (errors.size() == 1) {\r\n            message = Localization.lang(\"There was one file that could not be imported.\");\r\n        } else {\r\n            message = Localization.lang(\"There were %0 files which could not be imported.\", Integer.toString(errors.size()));\r\n        }\r\n        dialogService.showWarningDialogAndWait(Localization.lang(\"Warning\"), Localization.lang(\"The import finished with warnings:\") + \"\\n\" + message);\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.importer.ParserResult.hasDuplicateKeys",
	"Comment": "query whether any duplicated bibtex keys have been found in the database.",
	"Method": "boolean hasDuplicateKeys(){\r\n    return !duplicateKeys.isEmpty();\r\n}"
}, {
	"Path": "org.elixir_lang.lexer.StackFrame.setGroup",
	"Comment": "private because quote groups should be set from constructors and sigil groups should be set from namesigil",
	"Method": "void setGroup(Base group){\r\n    if (this.group != null) {\r\n        throw new IllegalStateException(\"Group already set to \" + this.group + \".  \" + \"It is illegal to set group more than once in any StackFrame.\");\r\n    }\r\n    this.group = group;\r\n}"
}, {
	"Path": "org.jabref.model.entry.AuthorList.parse",
	"Comment": "retrieve an authorlist for the given string of authors or editors.this function tries to cache the parsed authorlists by the string passed in.",
	"Method": "AuthorList parse(String authors){\r\n    Objects.requireNonNull(authors);\r\n    final boolean authorsContainAND = authors.toUpperCase(Locale.ENGLISH).contains(\" AND \");\r\n    final boolean authorsContainOpeningBrace = authors.contains(\"{\");\r\n    final boolean authorsContainSemicolon = authors.contains(\";\");\r\n    final boolean authorsContainTwoOrMoreCommas = (authors.length() - authors.replace(\",\", \"\").length()) >= 2;\r\n    if (!authorsContainAND && !authorsContainOpeningBrace && !authorsContainSemicolon && authorsContainTwoOrMoreCommas) {\r\n        List<String> arrayNameList = Arrays.asList(authors.split(\",\"));\r\n        arrayNameList.replaceAll(String::trim);\r\n        boolean spaceInAllParts = arrayNameList.stream().filter(name -> name.contains(\" \")).collect(Collectors.toList()).size() == arrayNameList.size();\r\n        if (spaceInAllParts) {\r\n            authors = authors.replaceAll(\",\", \" and\");\r\n        } else {\r\n            int valuePartsCount = arrayNameList.size();\r\n            Collection<Integer> avoidIndex = new HashSet();\r\n            for (int i = 0; i < arrayNameList.size(); i++) {\r\n                if (AVOID_TERMS_IN_LOWER_CASE.contains(arrayNameList.get(i).toLowerCase(Locale.ROOT))) {\r\n                    avoidIndex.add(i);\r\n                    valuePartsCount--;\r\n                }\r\n            }\r\n            if ((valuePartsCount % 2) == 0) {\r\n                authors = buildWithAffix(avoidIndex, arrayNameList).toString();\r\n            }\r\n        }\r\n    }\r\n    AuthorList authorList = AUTHOR_CACHE.get(authors);\r\n    if (authorList == null) {\r\n        AuthorListParser parser = new AuthorListParser();\r\n        authorList = parser.parse(authors);\r\n        AUTHOR_CACHE.put(authors, authorList);\r\n    }\r\n    return authorList;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.hscglib.CglibProxyBytecodeGenerator.getGenerateMethod",
	"Comment": "retrieves the actual method that generates and returns the bytecode",
	"Method": "Method getGenerateMethod(Object generator){\r\n    Method[] methods = generator.getClass().getMethods();\r\n    for (Method method : methods) {\r\n        if (method.getName().equals(\"generate\") && method.getReturnType().getSimpleName().equals(\"byte[]\") && method.getParameterTypes().length == 1) {\r\n            return method;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.java.CtClassJavaProxyGenerator.generateClassFile",
	"Comment": "generate a class file for the proxy class. this method drives the classfile generation process.",
	"Method": "byte[] generateClassFile(){\r\n    addProxyMethod(f.hashCodeMethod, f.oclp);\r\n    addProxyMethod(f.equalsMethod, f.oclp);\r\n    addProxyMethod(f.toStringMethod, f.oclp);\r\n    Collection<CtClass> iWithSuper = new HashSet();\r\n    addInterfacesWithSuperInterfaces(iWithSuper, interfaces);\r\n    for (CtClass intf : iWithSuper) {\r\n        for (CtMethod m : intf.getDeclaredMethods()) {\r\n            addProxyMethod(m, intf);\r\n        }\r\n    }\r\n    for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\r\n        checkReturnTypes(sigmethods);\r\n    }\r\n    try {\r\n        methods.add(generateConstructor());\r\n        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\r\n            for (ProxyMethod pm : sigmethods) {\r\n                fields.add(new FieldInfo(pm.methodFieldName, \"Ljava/lang/reflect/Method;\", ACC_PRIVATE | ACC_STATIC));\r\n            }\r\n        }\r\n        fields.add(new FieldInfo(initFieldName, \"Z\", ACC_PRIVATE | ACC_STATIC));\r\n        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\r\n            for (ProxyMethod pm : sigmethods) {\r\n                methods.add(pm.generateMethod());\r\n            }\r\n        }\r\n        methods.add(generateStaticInitializer());\r\n        methods.add(generateStaticInitializerCaller());\r\n    } catch (IOException e) {\r\n        throw new InternalError(\"unexpected I/O Exception\");\r\n    }\r\n    if (methods.size() > 65535) {\r\n        throw new IllegalArgumentException(\"method limit exceeded\");\r\n    }\r\n    if (fields.size() > 65535) {\r\n        throw new IllegalArgumentException(\"field limit exceeded\");\r\n    }\r\n    cp.getClass(dotToSlash(className));\r\n    cp.getClass(superclassName);\r\n    for (CtClass intf : interfaces) {\r\n        cp.getClass(dotToSlash(intf.getName()));\r\n    }\r\n    cp.setReadOnly();\r\n    ByteArrayOutputStream bout = new ByteArrayOutputStream();\r\n    DataOutputStream dout = new DataOutputStream(bout);\r\n    try {\r\n        dout.writeInt(0xCAFEBABE);\r\n        dout.writeShort(CLASSFILE_MINOR_VERSION);\r\n        dout.writeShort(CLASSFILE_MAJOR_VERSION);\r\n        cp.write(dout);\r\n        dout.writeShort(accessFlags);\r\n        dout.writeShort(cp.getClass(dotToSlash(className)));\r\n        dout.writeShort(cp.getClass(superclassName));\r\n        dout.writeShort(interfaces.length);\r\n        for (CtClass intf : interfaces) {\r\n            dout.writeShort(cp.getClass(dotToSlash(intf.getName())));\r\n        }\r\n        dout.writeShort(fields.size());\r\n        for (FieldInfo f : fields) {\r\n            f.write(dout);\r\n        }\r\n        dout.writeShort(methods.size());\r\n        for (MethodInfo m : methods) {\r\n            m.write(dout);\r\n        }\r\n        dout.writeShort(0);\r\n    } catch (IOException e) {\r\n        throw new InternalError(\"unexpected I/O Exception\");\r\n    }\r\n    return bout.toByteArray();\r\n}"
}, {
	"Path": "org.jabref.logic.xmp.XmpUtilReader.getXmpMetadata",
	"Comment": "this method is a hack to generate multiple xmpmetadata objects, because theimplementation of the pdfbox does not support methods for reading multipledublincoreschemas from a single metadata entry.",
	"Method": "List<XMPMetadata> getXmpMetadata(PDDocument document){\r\n    PDDocumentCatalog catalog = document.getDocumentCatalog();\r\n    PDMetadata metaRaw = catalog.getMetadata();\r\n    List<XMPMetadata> metaList = new ArrayList();\r\n    if (metaRaw == null) {\r\n        return metaList;\r\n    }\r\n    String xmp = metaRaw.getCOSObject().toTextString();\r\n    int startDescriptionSection = xmp.indexOf(START_TAG);\r\n    int endDescriptionSection = xmp.lastIndexOf(END_TAG) + END_TAG.length();\r\n    String start = xmp.substring(0, startDescriptionSection);\r\n    String[] descriptionsArray = xmp.substring(startDescriptionSection, endDescriptionSection).split(END_TAG);\r\n    String end = xmp.substring(endDescriptionSection);\r\n    for (String s : descriptionsArray) {\r\n        String xmpMetaString = start + s + END_TAG + end;\r\n        metaList.add(XmpUtilShared.parseXmpMetadata(new ByteArrayInputStream(xmpMetaString.getBytes())));\r\n    }\r\n    return metaList;\r\n}"
}, {
	"Path": "org.elixir_lang.navigation.item_presentation.Quote.getPresentableText",
	"Comment": "returns the name of the object to be presented in most renderers across the program.",
	"Method": "String getPresentableText(){\r\n    StringBuilder presentableTextBuilder = new StringBuilder(QUOTE);\r\n    PsiElement locationValueElement = keywordArgument(call, LOCATION);\r\n    PsiElement unquoteValueElement = keywordArgument(call, org.elixir_lang.psi.call.name.Quote.KeywordArgument.UNQUOTE);\r\n    if (locationValueElement != null) {\r\n        presentableTextBuilder.append(\" \").append(LOCATION).append(\": \").append(locationValueElement.getText());\r\n        if (unquoteValueElement != null) {\r\n            presentableTextBuilder.append(\",\");\r\n        }\r\n    }\r\n    if (unquoteValueElement != null) {\r\n        presentableTextBuilder.append(\", \").append(UNQUOTE).append(\": \").append(unquoteValueElement.getText());\r\n    }\r\n    return presentableTextBuilder.toString();\r\n}"
}, {
	"Path": "org.elixir_lang.structure_view.sorter.Visibility.getComparator",
	"Comment": "returns the comparator used for comparing nodes in the tree.",
	"Method": "Comparator getComparator(){\r\n    return new Comparator() {\r\n        @Override\r\n        public int compare(Object o1, Object o2) {\r\n            int comparison = 2;\r\n            org.elixir_lang.Visibility visibility1 = null;\r\n            org.elixir_lang.Visibility visibility2 = null;\r\n            if (o1 instanceof Visible) {\r\n                Visible visible1 = (Visible) o1;\r\n                visibility1 = visible1.visibility();\r\n            }\r\n            if (o2 instanceof Visible) {\r\n                Visible visible2 = (Visible) o2;\r\n                visibility2 = visible2.visibility();\r\n            }\r\n            if (visibility1 == visibility2) {\r\n                comparison = 0;\r\n            } else if (visibility1 == org.elixir_lang.Visibility.PUBLIC) {\r\n                comparison = -1;\r\n            } else if (visibility1 == null) {\r\n                if (visibility2 == org.elixir_lang.Visibility.PUBLIC) {\r\n                    comparison = 1;\r\n                } else if (visibility2 == org.elixir_lang.Visibility.PRIVATE) {\r\n                    comparison = -1;\r\n                }\r\n            } else if (visibility1 == org.elixir_lang.Visibility.PRIVATE) {\r\n                comparison = 1;\r\n            }\r\n            assert comparison != 2;\r\n            return comparison;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.elixir_lang.structure_view.sorter.Visibility.getComparator",
	"Comment": "returns the comparator used for comparing nodes in the tree.",
	"Method": "Comparator getComparator(){\r\n    int comparison = 2;\r\n    org.elixir_lang.Visibility visibility1 = null;\r\n    org.elixir_lang.Visibility visibility2 = null;\r\n    if (o1 instanceof Visible) {\r\n        Visible visible1 = (Visible) o1;\r\n        visibility1 = visible1.visibility();\r\n    }\r\n    if (o2 instanceof Visible) {\r\n        Visible visible2 = (Visible) o2;\r\n        visibility2 = visible2.visibility();\r\n    }\r\n    if (visibility1 == visibility2) {\r\n        comparison = 0;\r\n    } else if (visibility1 == org.elixir_lang.Visibility.PUBLIC) {\r\n        comparison = -1;\r\n    } else if (visibility1 == null) {\r\n        if (visibility2 == org.elixir_lang.Visibility.PUBLIC) {\r\n            comparison = 1;\r\n        } else if (visibility2 == org.elixir_lang.Visibility.PRIVATE) {\r\n            comparison = -1;\r\n        }\r\n    } else if (visibility1 == org.elixir_lang.Visibility.PRIVATE) {\r\n        comparison = 1;\r\n    }\r\n    assert comparison != 2;\r\n    return comparison;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.FileSystemResource.equals",
	"Comment": "this implementation compares the underlying file references.",
	"Method": "boolean equals(Object obj){\r\n    return (obj == this || (obj instanceof FileSystemResource && this.path.equals(((FileSystemResource) obj).path)));\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.SchemaBuilder.timeWindowCompactionStrategy",
	"Comment": "create options for the time window compaction strategy, to use in a create or alter tablestatement.this strategy was introduced in cassandra 3.0.8 and 3.9.",
	"Method": "TableOptions.CompactionOptions.TimeWindowCompactionStrategyOptions timeWindowCompactionStrategy(){\r\n    return new TableOptions.CompactionOptions.TimeWindowCompactionStrategyOptions();\r\n}"
}, {
	"Path": "org.jabref.gui.SidePaneManager.updatePreferredPositions",
	"Comment": "stores the current configuration of visible components in the preferences,so that we show components at the preferred position next time.",
	"Method": "void updatePreferredPositions(){\r\n    Map<SidePaneType, Integer> preferredPositions = preferences.getSidePanePreferredPositions();\r\n    int index = 0;\r\n    for (SidePaneComponent comp : visibleComponents) {\r\n        preferredPositions.put(comp.getType(), index);\r\n        index++;\r\n    }\r\n    preferences.storeSidePanePreferredPositions(preferredPositions);\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.Callback.insertAt",
	"Comment": "utility method to inserts callback at the specified line in the body.",
	"Method": "int insertAt(CtBehavior behavior,Callback callback,int lineNum){\r\n    return behavior.insertAt(lineNum, callback.toString());\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.FileSystemResource.getOutputStream",
	"Comment": "this implementation opens a fileoutputstream for the underlying file.",
	"Method": "OutputStream getOutputStream(){\r\n    return new FileOutputStream(this.file);\r\n}"
}, {
	"Path": "com.datastax.driver.core.policies.LatencyAwarePolicy.builder",
	"Comment": "creates a new latency aware policy builder given the child policy that the resulting policyshould wrap.",
	"Method": "Builder builder(LoadBalancingPolicy childPolicy){\r\n    return new Builder(childPolicy);\r\n}"
}, {
	"Path": "com.datastax.driver.core.SchemaParser.maybeSortUdts",
	"Comment": "some schema versions require parsing udts in a specific order",
	"Method": "List<Row> maybeSortUdts(List<Row> udtRows,Cluster cluster,String keyspace,List<Row> maybeSortUdts,List<Row> udtRows,Cluster cluster,String keyspace){\r\n    return udtRows;\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.proxy.AbstractProxyTransformer.isTransformingNeeded",
	"Comment": "checks if there were changes that require the redefinition of the proxy",
	"Method": "boolean isTransformingNeeded(){\r\n    return ProxyClassSignatureHelper.isNonSyntheticPoolClassOrParentDifferent(classBeingRedefined, classPool);\r\n}"
}, {
	"Path": "me.ramswaroop.jbot.core.facebook.Bot.isConversationOn",
	"Comment": "check whether a conversation is up in a particular slack channel.",
	"Method": "boolean isConversationOn(Event event){\r\n    return isConversationOn(event.getSender().getId());\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.io.resource.AbstractResource.contentLength",
	"Comment": "this implementation reads the entire inputstream to calculate the contentlength. subclasses will almost always be able to provide a more optimalversion of this, e.g. checking a file length.",
	"Method": "long contentLength(){\r\n    try (InputStream is = this.getInputStream()) {\r\n        Assert.state(is != null, \"resource input stream must not be null\");\r\n        long size = 0;\r\n        byte[] buf = new byte[255];\r\n        int read;\r\n        while ((read = is.read(buf)) != -1) {\r\n            size += read;\r\n        }\r\n        return size;\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.schemabuilder.AbstractCreateStatement.addUDTListColumn",
	"Comment": "shorthand to add a column definition to this create statement, when the type is a list of udt.",
	"Method": "T addUDTListColumn(String columnName,UDTType udtType){\r\n    validateNotEmpty(columnName, \"Column name\");\r\n    validateNotNull(udtType, \"Column element type\");\r\n    validateNotKeyWord(columnName, String.format(\"The column name '%s' is not allowed because it is a reserved keyword\", columnName));\r\n    simpleColumns.put(columnName, UDTType.list(udtType));\r\n    return self;\r\n}"
}, {
	"Path": "org.jabref.model.entry.BibEntry.hasField",
	"Comment": "returns true if the entry has the given field, or false if it is not set.",
	"Method": "boolean hasField(String name){\r\n    return fields.containsKey(toLowerCase(name));\r\n}"
}, {
	"Path": "org.jabref.gui.importer.actions.OpenDatabaseAction.performPostOpenActions",
	"Comment": "go through the list of post open actions, and perform those that need to be performed.",
	"Method": "void performPostOpenActions(BasePanel panel,ParserResult result){\r\n    for (GUIPostOpenAction action : OpenDatabaseAction.POST_OPEN_ACTIONS) {\r\n        if (action.isActionNecessary(result)) {\r\n            action.performAction(panel, result);\r\n            panel.frame().showBasePanel(panel);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.importer.fileformat.BibtexParser.removeWhitespaces",
	"Comment": "returns a new stringbuilder which corresponds to toremove without whitespaces",
	"Method": "StringBuilder removeWhitespaces(StringBuilder toRemove){\r\n    StringBuilder result = new StringBuilder();\r\n    char current;\r\n    for (int i = 0; i < toRemove.length(); ++i) {\r\n        current = toRemove.charAt(i);\r\n        if (!Character.isWhitespace(current)) {\r\n            result.append(current);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.datastax.driver.core.utils.Bytes.fromRawHexString",
	"Comment": "converts a cql hex string representation into a byte array.a cql blob string representation consist of the hexadecimal representation of the blobbytes.",
	"Method": "byte[] fromRawHexString(String str,int strOffset){\r\n    byte[] bytes = new byte[(str.length() - strOffset) / 2];\r\n    for (int i = 0; i < bytes.length; i++) {\r\n        byte halfByte1 = charToByte[str.charAt(strOffset + i * 2)];\r\n        byte halfByte2 = charToByte[str.charAt(strOffset + i * 2 + 1)];\r\n        if (halfByte1 == -1 || halfByte2 == -1)\r\n            throw new IllegalArgumentException(\"Non-hex characters in \" + str);\r\n        bytes[i] = (byte) ((halfByte1 << 4) | halfByte2);\r\n    }\r\n    return bytes;\r\n}"
}, {
	"Path": "org.jabref.model.TreeNode.isAncestorOf",
	"Comment": "returns true if this node is an ancestor of the given node.a node is considered an ancestor of itself.",
	"Method": "boolean isAncestorOf(T anotherNode){\r\n    Objects.requireNonNull(anotherNode);\r\n    if (anotherNode == this) {\r\n        return true;\r\n    } else {\r\n        for (T child : children) {\r\n            if (child.isAncestorOf(anotherNode)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.xmp.XmpUtilWriter.generateXmpStringWithoutXmpDeclaration",
	"Comment": "this method generates an xmp metadata string in dublin core format without themetadata section .",
	"Method": "String generateXmpStringWithoutXmpDeclaration(List<BibEntry> entries,XmpPreferences xmpPreferences){\r\n    String xmpContent = XmpUtilWriter.generateXmpStringWithXmpDeclaration(entries, xmpPreferences);\r\n    Predicate<String> isBeginOrEndTag = s -> s.contains(XMP_BEGIN_END_TAG);\r\n    String updatedXmpContent = Arrays.stream(xmpContent.split(System.lineSeparator())).filter(isBeginOrEndTag.negate()).map(line -> line.toString()).collect(Collectors.joining(System.lineSeparator()));\r\n    return updatedXmpContent;\r\n}"
}, {
	"Path": "org.jdbi.v3.core.spi.JdbiPlugin.customizeConnection",
	"Comment": "configure customizations for a newly acquired connection.",
	"Method": "Connection customizeConnection(Connection conn){\r\n    return conn;\r\n}"
}, {
	"Path": "org.menacheri.jetclient.communication.NettyTCPMessageSender.closeAfterFlushingPendingWrites",
	"Comment": "this method will write an event to the channel and then add a close\tlistener which will close it after the write has completed.",
	"Method": "void closeAfterFlushingPendingWrites(Channel channel,Event event){\r\n    if (channel.isConnected()) {\r\n        channel.write(event).addListener(ChannelFutureListener.CLOSE);\r\n    } else {\r\n        System.err.println(\"Unable to write the Event :\" + event + \" to socket as channel is ot connected\");\r\n    }\r\n}"
}, {
	"Path": "com.github.javafaker.Weather.temperatureCelsius",
	"Comment": "generates a random temperature celsius between two temperatures.",
	"Method": "String temperatureCelsius(String temperatureCelsius,int minTemperature,int maxTemperature){\r\n    return temperature(minTemperature, maxTemperature, \"weather.temperature.celsius\");\r\n}"
}, {
	"Path": "org.hotswap.agent.javassist.tools.reflect.Reflection.onLoad",
	"Comment": "inserts hooks for intercepting accesses to the fields declaredin reflective classes.",
	"Method": "void onLoad(ClassPool pool,String classname){\r\n    CtClass clazz = pool.get(classname);\r\n    clazz.instrument(converter);\r\n}"
}, {
	"Path": "com.datastax.driver.core.HostConnectionPool.cleanupTrash",
	"Comment": "close connections that have been sitting in the trash for too long",
	"Method": "void cleanupTrash(long now){\r\n    for (Connection connection : trash) {\r\n        if (connection.maxIdleTime < now && connection.state.compareAndSet(TRASHED, GONE)) {\r\n            if (connection.inFlight.get() == 0) {\r\n                logger.trace(\"Cleaning up {}\", connection);\r\n                trash.remove(connection);\r\n                close(connection);\r\n            } else {\r\n                connection.state.set(TRASHED);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.exporter.AtomicFileOutputStream.close",
	"Comment": "perform the final operations to move the temporary file to its final destination",
	"Method": "void close(){\r\n    try {\r\n        try {\r\n            flush();\r\n            if (out instanceof FileOutputStream) {\r\n                ((FileOutputStream) out).getFD().sync();\r\n            }\r\n        } catch (IOException exception) {\r\n            super.close();\r\n            throw exception;\r\n        }\r\n        super.close();\r\n        Set<PosixFilePermission> oldFilePermissions = EnumSet.of(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE, PosixFilePermission.GROUP_READ, PosixFilePermission.GROUP_WRITE, PosixFilePermission.OTHERS_READ);\r\n        if (Files.exists(targetFile)) {\r\n            Files.copy(targetFile, backupFile, StandardCopyOption.REPLACE_EXISTING);\r\n            if (FileUtil.IS_POSIX_COMPILANT) {\r\n                try {\r\n                    oldFilePermissions = Files.getPosixFilePermissions(targetFile);\r\n                } catch (IOException exception) {\r\n                    LOGGER.warn(\"Error getting file permissions for file {}.\", targetFile, exception);\r\n                }\r\n            }\r\n        }\r\n        Files.move(temporaryFile, targetFile, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);\r\n        if (FileUtil.IS_POSIX_COMPILANT) {\r\n            try {\r\n                Files.setPosixFilePermissions(targetFile, oldFilePermissions);\r\n            } catch (IOException exception) {\r\n                LOGGER.warn(\"Error writing file permissions to file {}.\", targetFile, exception);\r\n            }\r\n        }\r\n        if (!keepBackup) {\r\n            Files.deleteIfExists(backupFile);\r\n        }\r\n    } finally {\r\n        cleanup();\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.ColumnDefinitions.getIndexOf",
	"Comment": "the first index in this metadata of the provided name, if present.",
	"Method": "int getIndexOf(String name){\r\n    return findFirstIdx(name);\r\n}"
}, {
	"Path": "org.jabref.logic.xmp.XmpUtilReaderTest.testReadPDMetadata",
	"Comment": "test non xmp metadata. metadata are included in the pdinformation",
	"Method": "void testReadPDMetadata(){\r\n    List<BibEntry> entries = XmpUtilReader.readXmp(Paths.get(XmpUtilShared.class.getResource(\"PD_metadata.pdf\").toURI()), xmpPreferences);\r\n    String bibString = Resources.toString(XmpUtilShared.class.getResource(\"PD_metadata.bib\"), StandardCharsets.UTF_8);\r\n    Optional<BibEntry> entryFromBibFile = parser.parseSingleEntry(bibString);\r\n    assertEquals(entryFromBibFile.get(), entries.get(0));\r\n}"
}, {
	"Path": "com.datastax.driver.core.policies.ExponentialReconnectionPolicy.getMaxDelayMs",
	"Comment": "the maximum delay in milliseconds between reconnection attempts for this policy.",
	"Method": "long getMaxDelayMs(){\r\n    return maxDelayMs;\r\n}"
}, {
	"Path": "com.datastax.driver.core.RequestHandler.reportNoMoreHosts",
	"Comment": "this is only a failure if there are no other running executions.",
	"Method": "void reportNoMoreHosts(SpeculativeExecution execution){\r\n    runningExecutions.remove(execution);\r\n    if (runningExecutions.isEmpty())\r\n        setFinalException(execution, null, new NoHostAvailableException(errors == null ? Collections.<InetSocketAddress, Throwable>emptyMap() : errors));\r\n}"
}, {
	"Path": "org.jabref.gui.importer.EntryFromFileCreator.createEntry",
	"Comment": "create one bibentry containing information regarding the given file.",
	"Method": "Optional<BibEntry> createEntry(File f,boolean addPathTokensAsKeywords){\r\n    if ((f == null) || !f.exists()) {\r\n        return Optional.empty();\r\n    }\r\n    Optional<BibEntry> newEntry = createBibtexEntry(f);\r\n    if (!(newEntry.isPresent())) {\r\n        return newEntry;\r\n    }\r\n    if (addPathTokensAsKeywords) {\r\n        appendToField(newEntry.get(), FieldName.KEYWORDS, extractPathesToKeyWordsfield(f.getAbsolutePath()));\r\n    }\r\n    if (!newEntry.get().hasField(FieldName.TITLE)) {\r\n        newEntry.get().setField(FieldName.TITLE, f.getName());\r\n    }\r\n    addFileInfo(newEntry.get(), f);\r\n    return newEntry;\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ReflectionUtils.getAllDeclaredMethods",
	"Comment": "get all declared methods on the leaf class and all superclasses. leafclass methods are included first.",
	"Method": "Method[] getAllDeclaredMethods(Class<?> leafClass){\r\n    final List<Method> methods = new ArrayList<Method>(32);\r\n    doWithMethods(leafClass, new MethodCallback() {\r\n        @Override\r\n        public void doWith(Method method) {\r\n            methods.add(method);\r\n        }\r\n    });\r\n    return methods.toArray(new Method[methods.size()]);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.util.ReflectionUtils.getAllDeclaredMethods",
	"Comment": "get all declared methods on the leaf class and all superclasses. leafclass methods are included first.",
	"Method": "Method[] getAllDeclaredMethods(Class<?> leafClass){\r\n    methods.add(method);\r\n}"
}, {
	"Path": "com.datastax.driver.core.CodecUtils.readSize",
	"Comment": "utility method that reads a size value. mainly intended for collection codecs whendeserializing cql collections.",
	"Method": "int readSize(ByteBuffer input,ProtocolVersion version){\r\n    switch(version) {\r\n        case V1:\r\n        case V2:\r\n            return getUnsignedShort(input);\r\n        case V3:\r\n        case V4:\r\n        case V5:\r\n            return input.getInt();\r\n        default:\r\n            throw version.unsupported();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.gui.importer.ImportCustomizationDialog.addOrReplaceImporter",
	"Comment": "adds an importer to the model that underlies the custom importers.",
	"Method": "void addOrReplaceImporter(CustomImporter importer){\r\n    Globals.prefs.customImports.replaceImporter(importer);\r\n    Globals.IMPORT_FORMAT_READER.resetImportFormats(Globals.prefs.getImportFormatPreferences(), Globals.prefs.getXMPPreferences(), Globals.getFileUpdateMonitor());\r\n    ((ImportTableModel) customImporterTable.getModel()).fireTableDataChanged();\r\n}"
}, {
	"Path": "org.jabref.gui.BasePanel.clearAndSelect",
	"Comment": "this method selects the given entry, and scrolls it into view in the table. if an entryeditor is shown, it isgiven focus afterwards.",
	"Method": "void clearAndSelect(BibEntry bibEntry){\r\n    mainTable.clearAndSelect(bibEntry);\r\n}"
}, {
	"Path": "org.jabref.logic.net.URLDownload.asInputStream",
	"Comment": "takes the web resource as the source for a monitored input stream.",
	"Method": "ProgressInputStream asInputStream(){\r\n    HttpURLConnection urlConnection = (HttpURLConnection) this.openConnection();\r\n    if ((urlConnection.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) || (urlConnection.getResponseCode() == HttpURLConnection.HTTP_BAD_REQUEST)) {\r\n        LOGGER.error(\"Response message {} returned for url {}\", urlConnection.getResponseMessage(), urlConnection.getURL());\r\n        return new ProgressInputStream(new ByteArrayInputStream(new byte[0]), 0);\r\n    }\r\n    long fileSize = urlConnection.getContentLengthLong();\r\n    return new ProgressInputStream(new BufferedInputStream(urlConnection.getInputStream()), fileSize);\r\n}"
}, {
	"Path": "org.jdbi.v3.core.mapper.reflect.ConstructorMapper.of",
	"Comment": "instantiate a constructormapper using the given constructor and prefix",
	"Method": "RowMapper<T> of(Class<T> type,RowMapper<T> of,Class<T> type,String prefix,RowMapper<T> of,Constructor<T> constructor,RowMapper<T> of,Constructor<T> constructor,String prefix){\r\n    return new ConstructorMapper(new ConstructorInstanceFactory(constructor), prefix);\r\n}"
}, {
	"Path": "org.hotswap.agent.util.spring.path.PathMatchingResourcePatternResolver.retrieveMatchingFiles",
	"Comment": "retrieve files that match the given path pattern, checking the givendirectory and its subdirectories.",
	"Method": "Set<File> retrieveMatchingFiles(File rootDir,String pattern){\r\n    if (!rootDir.exists()) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Skipping [\" + rootDir.getAbsolutePath() + \"] because it does not exist\");\r\n        }\r\n        return Collections.emptySet();\r\n    }\r\n    if (!rootDir.isDirectory()) {\r\n        if (logger.isWarnEnabled()) {\r\n            logger.warning(\"Skipping [\" + rootDir.getAbsolutePath() + \"] because it does not denote a directory\");\r\n        }\r\n        return Collections.emptySet();\r\n    }\r\n    if (!rootDir.canRead()) {\r\n        if (logger.isWarnEnabled()) {\r\n            logger.warning(\"Cannot search for matching files underneath directory [\" + rootDir.getAbsolutePath() + \"] because the application is not allowed to read the directory\");\r\n        }\r\n        return Collections.emptySet();\r\n    }\r\n    String fullPattern = StringUtils.replace(rootDir.getAbsolutePath(), File.separator, \"/\");\r\n    if (!pattern.startsWith(\"/\")) {\r\n        fullPattern += \"/\";\r\n    }\r\n    fullPattern = fullPattern + StringUtils.replace(pattern, File.separator, \"/\");\r\n    Set<File> result = new LinkedHashSet<File>(8);\r\n    doRetrieveMatchingFiles(fullPattern, rootDir, result);\r\n    return result;\r\n}"
}, {
	"Path": "org.jabref.gui.worker.CitationStyleToClipboardWorker.processXslFo",
	"Comment": "inserts each citation into a xlsfo body and copies it to the clipboard",
	"Method": "ClipboardContent processXslFo(List<String> citations){\r\n    String result = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\" + OS.NEWLINE + \"<fo:root xmlns:fo=\\\"http://www.w3.org/1999/XSL/Format\\\">\" + OS.NEWLINE + \"   <fo:layout-master-set>\" + OS.NEWLINE + \"      <fo:simple-page-master master-name=\\\"citations\\\">\" + OS.NEWLINE + \"         <fo:region-body/>\" + OS.NEWLINE + \"      <\/fo:simple-page-master>\" + OS.NEWLINE + \"   <\/fo:layout-master-set>\" + OS.NEWLINE + \"   <fo:page-sequence master-reference=\\\"citations\\\">\" + OS.NEWLINE + \"      <fo:flow flow-name=\\\"xsl-region-body\\\">\" + OS.NEWLINE + OS.NEWLINE;\r\n    result += String.join(CitationStyleOutputFormat.XSL_FO.getLineSeparator(), citations);\r\n    result += OS.NEWLINE + \"      <\/fo:flow>\" + OS.NEWLINE + \"   <\/fo:page-sequence>\" + OS.NEWLINE + \"<\/fo:root>\" + OS.NEWLINE;\r\n    ClipboardContent content = new ClipboardContent();\r\n    content.put(ClipBoardManager.XML, result);\r\n    return content;\r\n}"
}, {
	"Path": "org.elixir_lang.beam.psi.impl.ModuleElementImpl.findElementAt",
	"Comment": "finds a leaf psi element at the specified offset from the start of the text range of this node.",
	"Method": "PsiElement findElementAt(int offset){\r\n    PsiElement mirror = getMirror();\r\n    PsiElement elementAt = null;\r\n    if (mirror != null) {\r\n        PsiElement mirrorAt = mirror.findElementAt(offset);\r\n        while (true) {\r\n            if (mirrorAt == null || mirrorAt instanceof PsiFile) {\r\n                break;\r\n            }\r\n            elementAt = mirrorToElement(mirrorAt);\r\n            if (elementAt != null) {\r\n                break;\r\n            }\r\n            mirrorAt = mirrorAt.getParent();\r\n        }\r\n    }\r\n    return elementAt;\r\n}"
}, {
	"Path": "org.jabref.gui.externalfiles.DownloadExternalFile.expandFilename",
	"Comment": "construct a file object pointing to the file linked, whether the link isabsolute or relative to the main directory.",
	"Method": "File expandFilename(String directory,String link){\r\n    File toFile = new File(link);\r\n    String dirPrefix = directory + OS.FILE_SEPARATOR;\r\n    if (!toFile.isAbsolute()) {\r\n        toFile = new File(dirPrefix + link);\r\n    }\r\n    return toFile;\r\n}"
}, {
	"Path": "org.jabref.gui.WrapLayout.layoutSize",
	"Comment": "returns the minimum or preferred dimension needed to layout the targetcontainer.",
	"Method": "Dimension layoutSize(Container target,boolean preferred){\r\n    synchronized (target.getTreeLock()) {\r\n        int targetWidth = target.getSize().width;\r\n        if (targetWidth == 0) {\r\n            targetWidth = Integer.MAX_VALUE;\r\n        }\r\n        int hgap = getHgap();\r\n        int vgap = getVgap();\r\n        Insets insets = target.getInsets();\r\n        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\r\n        int maxWidth = targetWidth - horizontalInsetsAndGap;\r\n        Dimension dim = new Dimension(0, 0);\r\n        int rowWidth = 0;\r\n        int rowHeight = 0;\r\n        int nmembers = target.getComponentCount();\r\n        for (int i = 0; i < nmembers; i++) {\r\n            Component m = target.getComponent(i);\r\n            if (m.isVisible()) {\r\n                Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();\r\n                if (d != null) {\r\n                    if ((rowWidth + d.width) > maxWidth) {\r\n                        addRow(dim, rowWidth, rowHeight);\r\n                        rowWidth = 0;\r\n                        rowHeight = 0;\r\n                    }\r\n                    if (rowWidth != 0) {\r\n                        rowWidth += hgap;\r\n                    }\r\n                    rowWidth += d.width;\r\n                    rowHeight = Math.max(rowHeight, d.height);\r\n                }\r\n            }\r\n        }\r\n        addRow(dim, rowWidth, rowHeight);\r\n        dim.width += horizontalInsetsAndGap;\r\n        dim.height += insets.top + insets.bottom + (vgap * 2);\r\n        Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\r\n        if (scrollPane != null) {\r\n            dim.width -= (hgap + 1);\r\n        }\r\n        return dim;\r\n    }\r\n}"
}, {
	"Path": "com.datastax.driver.core.IndexMetadata.getIndexClassName",
	"Comment": "the name of the class used to implement the custom index, if it is one.",
	"Method": "String getIndexClassName(){\r\n    return getOption(CUSTOM_INDEX_OPTION_NAME);\r\n}"
}, {
	"Path": "org.jabref.gui.BasePanel.ensureNotShowingBottomPanel",
	"Comment": "closes the entry editor or preview panel if it is showing the given entry.",
	"Method": "void ensureNotShowingBottomPanel(BibEntry entry){\r\n    if (((mode == BasePanelMode.SHOWING_EDITOR) && (entryEditor.getEntry() == entry)) || ((mode == BasePanelMode.SHOWING_PREVIEW) && (preview.getEntry() == entry))) {\r\n        closeBottomPane();\r\n    }\r\n}"
}, {
	"Path": "org.jabref.logic.formatter.bibtexfields.EscapeUnderscoresFormatterTest.formatEscapesUnderscoresIfPresent",
	"Comment": "check whether the clear formatter really returns the empty string for some string",
	"Method": "void formatEscapesUnderscoresIfPresent(){\r\n    assertEquals(\"Lorem\\\\_ipsum\", formatter.format(\"Lorem_ipsum\"));\r\n}"
}, {
	"Path": "org.elixir_lang.formatter.Block.buildSigilModifiersChildren",
	"Comment": "sigilmodifiers must be flattened because they may be empty and empty blocks should not be created a it messes upthe spacing",
	"Method": "List<com.intellij.formatting.Block> buildSigilModifiersChildren(ASTNode sigilModifiers,Wrap childrenWrap){\r\n    return buildChildren(sigilModifiers, (child, childElementType, blockList) -> {\r\n        blockList.add(buildChild(child, childrenWrap));\r\n        return blockList;\r\n    });\r\n}"
}, {
	"Path": "org.jabref.gui.BasePanel.entryEditorClosing",
	"Comment": "this method is called from an entryeditor when it should be closed. we relay to the selection listener, whichtakes care of the rest.",
	"Method": "void entryEditorClosing(EntryEditor editor){\r\n    if (Globals.prefs.getPreviewPreferences().isPreviewPanelEnabled()) {\r\n        showPreview(editor.getEntry());\r\n    } else {\r\n        closeBottomPane();\r\n    }\r\n    mainTable.requestFocus();\r\n}"
}, {
	"Path": "org.jabref.gui.menus.ChangeEntryTypeMenu.populateChangeEntryTypeMenu",
	"Comment": "remove all types from the menu. then cycle through all availabletypes, and add them.",
	"Method": "void populateChangeEntryTypeMenu(JMenu menu,BasePanel panel){\r\n    menu.removeAll();\r\n    if (panel.getBibDatabaseContext().isBiblatexMode()) {\r\n        for (EntryType type : EntryTypes.getAllValues(BibDatabaseMode.BIBLATEX)) {\r\n            menu.add(new ChangeTypeAction(type, panel));\r\n        }\r\n        List<EntryType> customTypes = EntryTypes.getAllCustomTypes(BibDatabaseMode.BIBLATEX);\r\n        if (!customTypes.isEmpty()) {\r\n            menu.addSeparator();\r\n            createEntryTypeSection(panel, menu, \"Custom Entries\", customTypes);\r\n        }\r\n    } else {\r\n        createEntryTypeSection(panel, menu, \"BibTeX Entries\", BibtexEntryTypes.ALL);\r\n        menu.addSeparator();\r\n        createEntryTypeSection(panel, menu, \"IEEETran Entries\", IEEETranEntryTypes.ALL);\r\n        List<EntryType> customTypes = EntryTypes.getAllCustomTypes(BibDatabaseMode.BIBTEX);\r\n        if (!customTypes.isEmpty()) {\r\n            menu.addSeparator();\r\n            createEntryTypeSection(panel, menu, \"Custom Entries\", customTypes);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hotswap.agent.plugin.weld.command.BdaAgentRegistry.getArchiveByClassName",
	"Comment": "iterate over agents and find the one containing the class by name",
	"Method": "String getArchiveByClassName(String className){\r\n    for (BeanClassRefreshAgent agent : INSTANCES.values()) {\r\n        if (agent.getDeploymentArchive().getBeanClasses().contains(className)) {\r\n            return agent.getArchivePath();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jabref.gui.preferences.XmpPrefsTab.storeSettings",
	"Comment": "store changes to table preferences. this method is called when the userclicks ok.",
	"Method": "void storeSettings(){\r\n    fields.stream().filter(s -> StringUtil.isNullOrEmpty(s.getField())).forEach(fields::remove);\r\n    prefs.putStringList(JabRefPreferences.XMP_PRIVACY_FILTERS, fields.stream().map(XMPPrivacyFilter::getField).collect(Collectors.toList()));\r\n    prefs.putBoolean(JabRefPreferences.USE_XMP_PRIVACY_FILTER, privacyFilterCheckBox.isSelected());\r\n}"
}]