[{
	"Path": "kilim.timerservice.Timer.setLiteral",
	"Comment": "set the timer value explicitly, ie not relative to the current time",
	"Method": "void setLiteral(long value){\r\n    nextExecutionTime = value;\r\n}"
}, {
	"Path": "org.jupiter.common.util.internal.UnsafeUpdater.newLongFieldUpdater",
	"Comment": "creates and returns an updater for objects with the given field.",
	"Method": "UnsafeLongFieldUpdater<U> newLongFieldUpdater(Class<? super U> tClass,String fieldName){\r\n    try {\r\n        return new UnsafeLongFieldUpdater(UnsafeUtil.getUnsafe(), tClass, fieldName);\r\n    } catch (Throwable t) {\r\n        ThrowUtil.throwException(t);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ArchiveSearch.setQueryString",
	"Comment": "sets the query string used for the search, which can be null to indicate thatno query string should be used. the query string can contain the fullsearch syntaxsupported by lucene.",
	"Method": "void setQueryString(String queryString){\r\n    this.queryString = queryString;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.input.InputDecoder.removePattern",
	"Comment": "removes one pattern from the list of patterns in this inputdecoder",
	"Method": "boolean removePattern(CharacterPattern pattern){\r\n    synchronized (bytePatterns) {\r\n        return bytePatterns.remove(pattern);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.BookmarkInterceptor.appendSharedElement",
	"Comment": "adds the shared namespace element to indicate to clients that this bookmark is a shared bookmark.",
	"Method": "void appendSharedElement(Element bookmarkElement){\r\n    bookmarkElement.addElement(\"shared_bookmark\", \"http://jivesoftware.com/jeps/bookmarks\");\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.GridLayout.getTopMarginSize",
	"Comment": "returns the top margin, i.e. number of empty rows above the first row in the grid",
	"Method": "int getTopMarginSize(){\r\n    return topMarginSize;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.dialogs.TextInputDialogBuilder.setValidationPattern",
	"Comment": "helper method that assigned a validator to the text box the dialog will have which matches the pattern supplied",
	"Method": "TextInputDialogBuilder setValidationPattern(Pattern pattern,String errorMessage){\r\n    return setValidator(new TextInputDialogResultValidator() {\r\n        @Override\r\n        public String validate(String content) {\r\n            Matcher matcher = pattern.matcher(content);\r\n            if (!matcher.matches()) {\r\n                if (errorMessage == null) {\r\n                    return \"Invalid input\";\r\n                }\r\n                return errorMessage;\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.dialogs.TextInputDialogBuilder.setValidationPattern",
	"Comment": "helper method that assigned a validator to the text box the dialog will have which matches the pattern supplied",
	"Method": "TextInputDialogBuilder setValidationPattern(Pattern pattern,String errorMessage){\r\n    Matcher matcher = pattern.matcher(content);\r\n    if (!matcher.matches()) {\r\n        if (errorMessage == null) {\r\n            return \"Invalid input\";\r\n        }\r\n        return errorMessage;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.moquette.interception.BrokerInterceptorTest.interval",
	"Comment": "used to wait handler notification by the interceptor internal thread",
	"Method": "void interval(){\r\n    Thread.sleep(100);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.stats.StatisticsModule.addPacketStatistic",
	"Comment": "tracks the total number of packets both incoming and outgoing in the server.",
	"Method": "void addPacketStatistic(){\r\n    Statistic packetTrafficStatistic = new i18nStatistic(TRAFFIC_KEY, MonitoringConstants.NAME, Statistic.Type.rate) {\r\n        public double sample() {\r\n            return packetCount.getAndSet(0);\r\n        }\r\n        public boolean isPartialSample() {\r\n            return true;\r\n        }\r\n    };\r\n    statisticsManager.addStatistic(TRAFFIC_KEY, packetTrafficStatistic);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.stats.StatisticsModule.addPacketStatistic",
	"Comment": "tracks the total number of packets both incoming and outgoing in the server.",
	"Method": "void addPacketStatistic(){\r\n    return packetCount.getAndSet(0);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.stats.StatisticsModule.addPacketStatistic",
	"Comment": "tracks the total number of packets both incoming and outgoing in the server.",
	"Method": "void addPacketStatistic(){\r\n    return true;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.dialogs.AbstractDialogBuilder.build",
	"Comment": "builds a new dialog following the specifications of this builder",
	"Method": "T build(){\r\n    T dialog = buildDialog();\r\n    if (!extraWindowHints.isEmpty()) {\r\n        Set<Window.Hint> combinedHints = new HashSet<Window.Hint>(dialog.getHints());\r\n        combinedHints.addAll(extraWindowHints);\r\n        dialog.setHints(combinedHints);\r\n    }\r\n    return dialog;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.AnimatedLabel.createClassicSpinningLine",
	"Comment": "creates a classic spinning bar which can be used to signal to the user that an operation in is process.",
	"Method": "AnimatedLabel createClassicSpinningLine(AnimatedLabel createClassicSpinningLine,int speed){\r\n    AnimatedLabel animatedLabel = new AnimatedLabel(\"-\");\r\n    animatedLabel.addFrame(\"\\\\\");\r\n    animatedLabel.addFrame(\"|\");\r\n    animatedLabel.addFrame(\"/\");\r\n    animatedLabel.startAnimation(speed);\r\n    return animatedLabel;\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.config.MeterFilter.denyNameStartsWith",
	"Comment": "meters that start with the provided name should not be present in published metrics.",
	"Method": "MeterFilter denyNameStartsWith(String prefix){\r\n    return deny(id -> id.getName().startsWith(prefix));\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.table.TableModel.removeListener",
	"Comment": "removes a listener from this model so that it will no longer receive any notifications when the model changes",
	"Method": "TableModel<V> removeListener(Listener<V> listener){\r\n    listeners.remove(listener);\r\n    return this;\r\n}"
}, {
	"Path": "org.junit.platform.engine.FilterResult.getReason",
	"Comment": "get the reason why the filtered object should be included or excluded,\tif available.",
	"Method": "Optional<String> getReason(){\r\n    return this.reason;\r\n}"
}, {
	"Path": "org.jupiter.common.atomic.AtomicUpdater.newAtomicReferenceFieldUpdater",
	"Comment": "creates and returns an updater for objects with the given field.",
	"Method": "AtomicReferenceFieldUpdater<U, W> newAtomicReferenceFieldUpdater(Class<U> tClass,Class<W> vClass,String fieldName){\r\n    try {\r\n        return new UnsafeAtomicReferenceFieldUpdater(UnsafeUtil.getUnsafe(), tClass, fieldName);\r\n    } catch (Throwable t) {\r\n        return AtomicReferenceFieldUpdater.newUpdater(tClass, vClass, fieldName);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.spi.dispatcher.BasicAgentSelector.bestAgentFrom",
	"Comment": "the best agent will be the agent with less number of chats. if more than one agent hasthe less number of chats then select the agent that never rejected the offer.",
	"Method": "AgentSession bestAgentFrom(List<AgentSession> possibleSessions,Offer offer){\r\n    Collections.sort(possibleSessions, new SessionComparator(offer));\r\n    int size = possibleSessions.size() - 1;\r\n    return possibleSessions.get(size);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.AbstractTextGUI.invalidate",
	"Comment": "marks the whole text gui as invalid and that it needs to be redrawn at next opportunity",
	"Method": "void invalidate(){\r\n    dirty = true;\r\n}"
}, {
	"Path": "io.micrometer.spring.web.servlet.DefaultWebMvcTagsProvider.httpRequestTags",
	"Comment": "supplies default tags to the web mvc server programming model.",
	"Method": "Iterable<Tag> httpRequestTags(HttpServletRequest request,HttpServletResponse response,Object handler,Throwable ex){\r\n    return Arrays.asList(WebMvcTags.method(request), WebMvcTags.uri(request, response), WebMvcTags.exception(ex), WebMvcTags.status(response), WebMvcTags.outcome(response));\r\n}"
}, {
	"Path": "org.jdbi.v3.sqlobject.SqlObjectFactory.attach",
	"Comment": "create a sql object of the specified type bound to this handle. any state changes to the handle, or the sqlobject, such as transaction status, closing it, etc, will apply to both the object and the handle.",
	"Method": "E attach(Class<E> extensionType,HandleSupplier handle){\r\n    Map<Method, Handler> handlers = methodHandlersFor(extensionType, handle.getConfig(Handlers.class), handle.getConfig(HandlerDecorators.class));\r\n    ConfigRegistry instanceConfig = handle.getConfig().createCopy();\r\n    for (Class<?> iface : extensionType.getInterfaces()) {\r\n        forEachConfigurer(iface, (configurer, annotation) -> configurer.configureForType(instanceConfig, annotation, extensionType));\r\n    }\r\n    forEachConfigurer(extensionType, (configurer, annotation) -> configurer.configureForType(instanceConfig, annotation, extensionType));\r\n    InvocationHandler invocationHandler = createInvocationHandler(extensionType, instanceConfig, handlers, handle);\r\n    return extensionType.cast(Proxy.newProxyInstance(extensionType.getClassLoader(), new Class[] { extensionType }, invocationHandler));\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.OpeningHandshakeException.getStatusLine",
	"Comment": "get the status line contained in the websocket opening handshakeresponse from the server.",
	"Method": "StatusLine getStatusLine(){\r\n    return mStatusLine;\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.distribution.DistributionStatisticConfig.getMaximumExpectedValue",
	"Comment": "the maximum value that the meter is expected to observe. sets an upper boundon histogram buckets that are shipped to monitoring systems that support aggregable percentile approximations.",
	"Method": "Long getMaximumExpectedValue(){\r\n    return maximumExpectedValue;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TerminalSize.withColumns",
	"Comment": "creates a new size based on this size, but with a different width",
	"Method": "TerminalSize withColumns(int columns){\r\n    if (this.columns == columns) {\r\n        return this;\r\n    }\r\n    if (columns == 0 && this.rows == 0) {\r\n        return ZERO;\r\n    }\r\n    return new TerminalSize(columns, this.rows);\r\n}"
}, {
	"Path": "kilim.test.TestMailbox.testSelectSimple",
	"Comment": "send messages on two mailboxes and collect them back on one mailbox.",
	"Method": "void testSelectSimple(){\r\n    Mailbox<Msg> mainmb = new Mailbox<Msg>();\r\n    SelectTaskMB t = new SelectTaskMB(mainmb);\r\n    t.start();\r\n    try {\r\n        Thread.sleep(100);\r\n    } catch (InterruptedException ignore) {\r\n    }\r\n    assertTrue(!mainmb.hasMessage());\r\n    HashSet<Msg> sentMsgs = new HashSet<Msg>();\r\n    final int n = 10;\r\n    for (int i = 0; i < n; i++) {\r\n        Msg m = new Msg();\r\n        assertTrue(t.mymb2.putnb(m));\r\n        sentMsgs.add(m);\r\n        try {\r\n            Thread.sleep(10);\r\n        } catch (InterruptedException ignore) {\r\n        }\r\n        m = new Msg();\r\n        assertTrue(t.mymb1.putnb(m));\r\n        sentMsgs.add(m);\r\n    }\r\n    for (int i = 0; i < n * 2; i++) {\r\n        Msg m = mainmb.getb(1000);\r\n        assertTrue(m != null && sentMsgs.contains(m));\r\n    }\r\n}"
}, {
	"Path": "com.jvmtop.openjdk.tools.MemoryPoolStat.getLastGcEndTime",
	"Comment": "returns the end time of the most recent gc onthe memory pool for this statistics in milliseconds.return 0 if no gc occurs.",
	"Method": "long getLastGcEndTime(){\r\n    return lastGcEndTime;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.ChatbotSession.getChatbot",
	"Comment": "returns the chatbot where this session was created. this is the chatbot that is havinga conversation with the owner of this session.",
	"Method": "Chatbot getChatbot(){\r\n    return chatbot;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.stats.StatisticsModule.addServerToServerStatistic",
	"Comment": "tracks the number of server to server connections taking place in the server at anyone time.this includes both incoming and outgoing connections.",
	"Method": "void addServerToServerStatistic(){\r\n    Statistic serverToServerStatistic = new i18nStatistic(SERVER_2_SERVER_SESSIONS_KEY, MonitoringConstants.NAME, Statistic.Type.count) {\r\n        public double sample() {\r\n            return (SessionManager.getInstance().getIncomingServers().size() + SessionManager.getInstance().getOutgoingServers().size());\r\n        }\r\n        public boolean isPartialSample() {\r\n            return false;\r\n        }\r\n    };\r\n    statisticsManager.addStatistic(SERVER_2_SERVER_SESSIONS_KEY, serverToServerStatistic);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.stats.StatisticsModule.addServerToServerStatistic",
	"Comment": "tracks the number of server to server connections taking place in the server at anyone time.this includes both incoming and outgoing connections.",
	"Method": "void addServerToServerStatistic(){\r\n    return (SessionManager.getInstance().getIncomingServers().size() + SessionManager.getInstance().getOutgoingServers().size());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.stats.StatisticsModule.addServerToServerStatistic",
	"Comment": "tracks the number of server to server connections taking place in the server at anyone time.this includes both incoming and outgoing connections.",
	"Method": "void addServerToServerStatistic(){\r\n    return false;\r\n}"
}, {
	"Path": "com.alicp.jetcache.Cache.remove",
	"Comment": "removes the mapping for a key from this cache if it is present.if error occurs during cache access, the method will not throw an exception.",
	"Method": "boolean remove(K key){\r\n    return REMOVE(key).isSuccess();\r\n}"
}, {
	"Path": "org.junit.platform.commons.util.ModuleUtils.isJavaPlatformModuleSystemAvailable",
	"Comment": "determine if the current java runtime supports the java platform module system.",
	"Method": "boolean isJavaPlatformModuleSystemAvailable(){\r\n    return true;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getBackHelpMessage",
	"Comment": "returns the message that describes the effect of running the back command.",
	"Method": "String getBackHelpMessage(){\r\n    return settings.getChatSetting(KeyEnum.back_help_message).getValue();\r\n}"
}, {
	"Path": "com.drew.metadata.Directory.getTags",
	"Comment": "returns an iterator of tag instances that have been set in this directory.",
	"Method": "Collection<Tag> getTags(){\r\n    return Collections.unmodifiableCollection(_definedTagList);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.AgentSession.getUsersJID",
	"Comment": "returns a collection with the jid of the users that this agent is having a chat with.",
	"Method": "Collection<JID> getUsersJID(Workgroup workgroup){\r\n    Collection<ChatInfo> chats = getChats(workgroup);\r\n    Collection<JID> jids = new ArrayList<JID>(chats.size());\r\n    for (ChatInfo info : chats) {\r\n        jids.add(info.getUserJID());\r\n    }\r\n    return jids;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.table.Table.setSelectedRow",
	"Comment": "sets the index of the selected row and ensures the selected row is visible in the view",
	"Method": "Table<V> setSelectedRow(int selectedRow){\r\n    this.selectedRow = selectedRow;\r\n    return this;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.ansi.TelnetTerminalServer.getServerSocket",
	"Comment": "returns the actual server socket used by this object. can be used to tweak settings but be careful!",
	"Method": "ServerSocket getServerSocket(){\r\n    return serverSocket;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.GridLayout.setVerticalSpacing",
	"Comment": "sets the vertical spacing, i.e. the number of empty columns between each row",
	"Method": "GridLayout setVerticalSpacing(int verticalSpacing){\r\n    if (verticalSpacing < 0) {\r\n        throw new IllegalArgumentException(\"Vertical spacing cannot be less than 0\");\r\n    }\r\n    this.verticalSpacing = verticalSpacing;\r\n    this.changed = true;\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.fastpath.util.TaskEngine.submit",
	"Comment": "submits a runnable task for execution and returns a futurerepresenting that task.",
	"Method": "Future<?> submit(Runnable task){\r\n    return executor.submit(task);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.input.BasicCharacterPattern.getPattern",
	"Comment": "returns the characters that makes up this pattern, as an array that is a copy of the array used internally",
	"Method": "char[] getPattern(){\r\n    return Arrays.copyOf(pattern, pattern.length);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.messagefilter.MainInterceptor.searchJIDforSubdomain",
	"Comment": "as our set of subdomains is a hash of strings like icq.domain.tld, if we want to check if a jid contains awatched subdomain we need to iterate over the set. we also return the subdomain as a string so we can use it ifwe find it.",
	"Method": "String searchJIDforSubdomain(String jid){\r\n    if (jid.length() > 0) {\r\n        for (String subdomain : activeTransports) {\r\n            if (jid.contains(subdomain))\r\n                return subdomain;\r\n        }\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocket.readHandshake",
	"Comment": "receive an opening handshake response from the websocket server.",
	"Method": "Map<String, List<String>> readHandshake(WebSocketInputStream input,String key){\r\n    return new HandshakeReader(this).readHandshake(input, key);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.PacketFilterUtil.getDomain",
	"Comment": "method to get the component part from a jid. the packet could be from the component itself so just return.",
	"Method": "String getDomain(String jid){\r\n    if (jid.contains(\"@\")) {\r\n        int atIndex = jid.indexOf(\"@\");\r\n        return (jid.substring(atIndex + 1, jid.length()));\r\n    } else {\r\n        return jid;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getBackCommand",
	"Comment": "returns the string that indicates that the user is requesting to go back one step inthe dialog and repeat the previous message.",
	"Method": "String getBackCommand(){\r\n    return settings.getChatSetting(KeyEnum.back_command).getValue();\r\n}"
}, {
	"Path": "io.moquette.Utils.encodeRemainingLength",
	"Comment": "encode the value in the format defined in specification as variable length array.",
	"Method": "ByteBuf encodeRemainingLength(int value){\r\n    if (value > MAX_LENGTH_LIMIT || value < 0) {\r\n        throw new CorruptedFrameException(\"Value should in range 0..\" + MAX_LENGTH_LIMIT + \" found \" + value);\r\n    }\r\n    ByteBuf encoded = Unpooled.buffer(4);\r\n    byte digit;\r\n    do {\r\n        digit = (byte) (value % 128);\r\n        value = value / 128;\r\n        if (value > 0) {\r\n            digit = (byte) (digit | 0x80);\r\n        }\r\n        encoded.writeByte(digit);\r\n    } while (value > 0);\r\n    return encoded;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.screen.AbstractScreen.setCursorPosition",
	"Comment": "moves the current cursor position or hides it. if the cursor is hidden and given a new position, it will bevisible after this method call.",
	"Method": "void setCursorPosition(TerminalPosition position){\r\n    if (position == null) {\r\n        this.cursorPosition = null;\r\n        return;\r\n    }\r\n    if (position.getColumn() < 0) {\r\n        position = position.withColumn(0);\r\n    }\r\n    if (position.getRow() < 0) {\r\n        position = position.withRow(0);\r\n    }\r\n    if (position.getColumn() >= terminalSize.getColumns()) {\r\n        position = position.withColumn(terminalSize.getColumns() - 1);\r\n    }\r\n    if (position.getRow() >= terminalSize.getRows()) {\r\n        position = position.withRow(terminalSize.getRows() - 1);\r\n    }\r\n    this.cursorPosition = position;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.TrafficMonitor.isOnlyNotProcessedEnabled",
	"Comment": "returns true if only the packets that were not processed will be printed to the console.",
	"Method": "boolean isOnlyNotProcessedEnabled(){\r\n    return onlyNotProcessedEnabled;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.routing.RequestRouter.isConfigurable",
	"Comment": "returns true if the admin select the queue to route to, otherwise false toonly have the router select the queue itself. by default, this returns true.",
	"Method": "boolean isConfigurable(){\r\n    return true;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.AWTTerminal.addInput",
	"Comment": "takes a keystroke and puts it on the input queue of the terminal emulator. this way you can insert syntheticinput events to be processed as if they came from the user typing on the keyboard.",
	"Method": "void addInput(KeyStroke keyStroke){\r\n    terminalImplementation.addInput(keyStroke);\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.ReadingThread.verifyReservedBit1ForPMCE",
	"Comment": "verify the rsv1 bit of a frame using the rule described in rfc 7692.see 6. framingin rfc 7692 for details.",
	"Method": "boolean verifyReservedBit1ForPMCE(WebSocketFrame frame){\r\n    if (frame.isTextFrame() || frame.isBinaryFrame()) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ConversationManager.getArchivedMessageCount",
	"Comment": "returns the total number of messages that have been archived to the database.",
	"Method": "int getArchivedMessageCount(){\r\n    int messageCount = 0;\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(MESSAGE_COUNT);\r\n        rs = pstmt.executeQuery();\r\n        if (rs.next()) {\r\n            messageCount = rs.getInt(1);\r\n        }\r\n    } catch (SQLException sqle) {\r\n        Log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    return messageCount;\r\n}"
}, {
	"Path": "com.github.neuralnetworks.builder.NeuralNetworkBuilder.buildWithTrainer",
	"Comment": "create the neural network and a trainer for this network with the given hyper parameters",
	"Method": "Pair<NeuralNetworkImpl, Trainer<NeuralNetwork>> buildWithTrainer(){\r\n    Hyperparameters hyperparameters = createHyperparameters();\r\n    NeuralNetworkImpl neuralNetwork = buildNetwork(hyperparameters);\r\n    Properties properties = createProperties(neuralNetwork);\r\n    properties.setParameter(Constants.HYPERPARAMETERS, hyperparameters);\r\n    properties.setParameter(Constants.BACKPROPAGATION, TrainerFactory.bplc(neuralNetwork, properties));\r\n    Trainer<NeuralNetwork> trainer = new BackPropagationTrainer(properties);\r\n    if (Environment.getInstance().getRuntimeConfiguration().getCalculationProvider() == RuntimeConfiguration.CalculationProvider.OPENCL) {\r\n        trainer.addEventListener(new OpenCLManagementListener(), 0);\r\n    }\r\n    trainer.addEventListener(new ClearValuesEventListener());\r\n    for (TrainingEventListener trainingEventListener : listOfEventListener) {\r\n        trainer.addEventListener(trainingEventListener);\r\n    }\r\n    return new Pair<NeuralNetworkImpl, Trainer<NeuralNetwork>>(neuralNetwork, trainer);\r\n}"
}, {
	"Path": "com.drew.imaging.jpeg.JpegSegmentData.getSegment",
	"Comment": "gets segment data for a specific occurrence and type.use this method when more than one occurrenceof segment data for a given type exists.",
	"Method": "byte[] getSegment(byte segmentType,byte[] getSegment,JpegSegmentType segmentType,byte[] getSegment,JpegSegmentType segmentType,int occurrence,byte[] getSegment,byte segmentType,int occurrence){\r\n    final List<byte[]> segmentList = getSegmentList(segmentType);\r\n    return segmentList != null && segmentList.size() > occurrence ? segmentList.get(occurrence) : null;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Agent.sendAgentAddedToAllAgents",
	"Comment": "this agent has been added to a queue so we need to inform the existing agents of the queue,that previously requested agent information, of this new agent.",
	"Method": "void sendAgentAddedToAllAgents(RequestQueue requestQueue){\r\n    Workgroup workgroup = requestQueue.getWorkgroup();\r\n    for (AgentSession session : workgroup.getAgentSessions()) {\r\n        if (session.hasRequestedAgentInfo()) {\r\n            IQ iq = new IQ(IQ.Type.set);\r\n            iq.setFrom(workgroup.getJID());\r\n            iq.setTo(session.getJID());\r\n            Element agentStatusRequest = iq.setChildElement(\"agent-status-request\", \"http://jabber.org/protocol/workgroup\");\r\n            agentStatusRequest.add(getAgentInfo());\r\n            workgroup.send(iq);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jupiter.common.util.internal.UnsafeUpdater.newIntegerFieldUpdater",
	"Comment": "creates and returns an updater for objects with the given field.",
	"Method": "UnsafeIntegerFieldUpdater<U> newIntegerFieldUpdater(Class<? super U> tClass,String fieldName){\r\n    try {\r\n        return new UnsafeIntegerFieldUpdater(UnsafeUtil.getUnsafe(), tClass, fieldName);\r\n    } catch (Throwable t) {\r\n        ThrowUtil.throwException(t);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.drew.metadata.Directory.hasErrors",
	"Comment": "gets a value indicating whether this directory has any error messages.",
	"Method": "boolean hasErrors(){\r\n    return _errorList.size() > 0;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.AgentSession.isWaitingOfferAnswer",
	"Comment": "returns true if the agent has received an offer and the server is still waiting for ananswer.",
	"Method": "boolean isWaitingOfferAnswer(){\r\n    return offer != null;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.UserInterceptor.getEmailNotifyList",
	"Comment": "returns the list of email addresses that will be notified whena user is banned.",
	"Method": "String getEmailNotifyList(){\r\n    if (emailNotifyList == null || emailNotifyList.isEmpty()) {\r\n        return \"\";\r\n    }\r\n    StringBuilder buf = new StringBuilder();\r\n    buf.append(emailNotifyList.get(0));\r\n    for (int i = 1; i < emailNotifyList.size(); i++) {\r\n        buf.append(\", \");\r\n        buf.append(emailNotifyList.get(i));\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.ScrollingAWTTerminal.addInput",
	"Comment": "takes a keystroke and puts it on the input queue of the terminal emulator. this way you can insert syntheticinput events to be processed as if they came from the user typing on the keyboard.",
	"Method": "void addInput(KeyStroke keyStroke){\r\n    awtTerminal.addInput(keyStroke);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.fastpath.macros.WorkgroupMacros.getInstance",
	"Comment": "returns the singleton instance of workgroupmacros,creating it if necessary.",
	"Method": "WorkgroupMacros getInstance(){\r\n    synchronized (LOCK) {\r\n        if (singleton == null) {\r\n            WorkgroupMacros WorkgroupMacros = new WorkgroupMacros();\r\n            singleton = WorkgroupMacros;\r\n            return WorkgroupMacros;\r\n        }\r\n    }\r\n    return singleton;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.graph.GraphEngine.generateGraph",
	"Comment": "creates a graph in png format.the png graph is encoded by the keypointpngencoderadapterso that the resulting png is encoded with alpha transparency.",
	"Method": "byte[] generateGraph(String key,int width,int height,String color,long startTime,long endTime,int dataPoints){\r\n    JFreeChart chart = generateChart(key, width, height, color, startTime, endTime, dataPoints);\r\n    KeypointPNGEncoderAdapter encoder = new KeypointPNGEncoderAdapter();\r\n    encoder.setEncodingAlpha(true);\r\n    return encoder.encode(chart.createBufferedImage(width, height, BufferedImage.BITMASK, null));\r\n}"
}, {
	"Path": "org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameters",
	"Comment": "resolve the array of parameters for the supplied executable, target, and\touter instance.",
	"Method": "Object[] resolveParameters(Executable executable,Optional<Object> target,ExtensionContext extensionContext,ExtensionRegistry extensionRegistry,Object[] resolveParameters,Executable executable,Optional<Object> target,Object outerInstance,ExtensionContext extensionContext,ExtensionRegistry extensionRegistry){\r\n    Preconditions.notNull(target, \"target must not be null\");\r\n    Parameter[] parameters = executable.getParameters();\r\n    Object[] values = new Object[parameters.length];\r\n    int start = 0;\r\n    if (outerInstance != null) {\r\n        values[0] = outerInstance;\r\n        start = 1;\r\n    }\r\n    for (int i = start; i < parameters.length; i++) {\r\n        ParameterContext parameterContext = new DefaultParameterContext(parameters[i], i, target);\r\n        values[i] = resolveParameter(parameterContext, executable, extensionContext, extensionRegistry);\r\n    }\r\n    return values;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getInvitationSentMessage",
	"Comment": "returns the message to send to the user informing that he is now being routed to an agent.",
	"Method": "String getInvitationSentMessage(){\r\n    return settings.getChatSetting(KeyEnum.invitation_sent_message).getValue();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getIdleTimeout",
	"Comment": "returns the milliseconds that a session must be idle to be considered candidate for removal.",
	"Method": "long getIdleTimeout(){\r\n    long timeout = 30 * 60 * 1000;\r\n    try {\r\n        timeout = Long.parseLong(workgroup.getProperties().getProperty(\"chatbot.session.timeout\"));\r\n    } catch (NumberFormatException e) {\r\n    }\r\n    return timeout;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.setSchedule",
	"Comment": "sets a new schedule for this workgroup thus enabling the scheduling feature.",
	"Method": "void setSchedule(Schedule schedule){\r\n    if (schedule == null || schedule.getID() != id) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    followSchedule = true;\r\n    if (updateWorkgroup()) {\r\n        broadcastPresence();\r\n    }\r\n}"
}, {
	"Path": "kilim.mirrors.CachedClassMirrors.getVersion",
	"Comment": "get the major version of klass by loading the bytecode from source",
	"Method": "int getVersion(ClassLoader source,Class klass){\r\n    String cname = WeavingClassLoader.makeResourceName(klass.getName());\r\n    DataInputStream in = new DataInputStream(source.getResourceAsStream(cname));\r\n    try {\r\n        int magic = in.readInt();\r\n        int minor = in.readUnsignedShort();\r\n        int major = in.readUnsignedShort();\r\n        in.close();\r\n        return major;\r\n    } catch (IOException ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ConversationManager.getRoomsArchived",
	"Comment": "returns list of room names whose messages will be archived. when room archiving is enabled and this list is empty then messages of all localrooms will be archived. however, when name of rooms are defined in this list then only messages of those rooms will be archived.",
	"Method": "Collection<String> getRoomsArchived(){\r\n    return roomsArchived;\r\n}"
}, {
	"Path": "org.junit.platform.commons.util.ReflectionUtils.getOutermostInstance",
	"Comment": "get the outermost instance of the required type, searching recursively\tthrough enclosing instances.\tif the supplied inner object is of the required type, it will simply\tbe returned.",
	"Method": "Optional<Object> getOutermostInstance(Object inner,Class<?> requiredType){\r\n    Preconditions.notNull(inner, \"inner object must not be null\");\r\n    Preconditions.notNull(requiredType, \"requiredType must not be null\");\r\n    if (requiredType.isInstance(inner)) {\r\n        return Optional.of(inner);\r\n    }\r\n    Optional<Object> candidate = getOuterInstance(inner);\r\n    if (candidate.isPresent()) {\r\n        return getOutermostInstance(candidate.get(), requiredType);\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getCannotJoinMessage",
	"Comment": "returns the message to send to the user informing that the user is not allowed to jointhe queue. this may happen because the workgroup is closed or the specific user cannot joindue to some restriction policy.",
	"Method": "String getCannotJoinMessage(){\r\n    return settings.getChatSetting(KeyEnum.cannot_join_message).getValue();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.routing.RequestRouter.setRoutingQueue",
	"Comment": "sets the id of the queue to route to when this router evalutes to true.",
	"Method": "void setRoutingQueue(long routingQueue){\r\n    this.routingQueue = routingQueue;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.emailListener.EmailListener.setPort",
	"Comment": "sets the port where the imap server is listening. by default unsecured connectionsuse port 143 and secured ones use 993.",
	"Method": "void setPort(int port){\r\n    JiveGlobals.setProperty(\"plugin.email.listener.port\", Integer.toString(port));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ArchiveSearcher.luceneSearch",
	"Comment": "searches the lucene index for all archived conversations using the specified search.",
	"Method": "Collection<Conversation> luceneSearch(ArchiveSearch search){\r\n    try {\r\n        IndexSearcher searcher = archiveIndexer.getSearcher();\r\n        final StandardAnalyzer analyzer = new StandardAnalyzer();\r\n        Query query = new QueryParser(\"text\", analyzer).parse(search.getQueryString());\r\n        Sort sort = null;\r\n        if (search.getSortField() != ArchiveSearch.SortField.relevance) {\r\n            if (search.getSortField() == ArchiveSearch.SortField.date) {\r\n                sort = new Sort(\"date\", search.getSortOrder() == ArchiveSearch.SortOrder.descending);\r\n            }\r\n        }\r\n        Filter filter = null;\r\n        if (search.getDateRangeMin() != null || search.getDateRangeMax() != null) {\r\n            String min = null;\r\n            if (search.getDateRangeMin() != null) {\r\n                min = DateTools.dateToString(search.getDateRangeMin(), DateTools.Resolution.DAY);\r\n            }\r\n            String max = null;\r\n            if (search.getDateRangeMax() != null) {\r\n                max = DateTools.dateToString(search.getDateRangeMax(), DateTools.Resolution.DAY);\r\n            }\r\n            filter = new RangeFilter(\"date\", min, max, min != null, max != null);\r\n        }\r\n        Collection<JID> participants = search.getParticipants();\r\n        if (search.getParticipants().size() < 2 && search.isExternalWildcardMode()) {\r\n            TermQuery externalQuery = new TermQuery(new Term(\"external\", \"true\"));\r\n            BooleanQuery booleanQuery = new BooleanQuery();\r\n            booleanQuery.add(query, BooleanClause.Occur.MUST);\r\n            booleanQuery.add(externalQuery, BooleanClause.Occur.MUST);\r\n            query = booleanQuery;\r\n        }\r\n        if (!participants.isEmpty()) {\r\n            if (participants.size() == 1) {\r\n                String jid = participants.iterator().next().toBareJID();\r\n                Query participantQuery = new QueryParser(\"jid\", analyzer).parse(jid);\r\n                BooleanQuery booleanQuery = new BooleanQuery();\r\n                booleanQuery.add(query, BooleanClause.Occur.MUST);\r\n                booleanQuery.add(participantQuery, BooleanClause.Occur.MUST);\r\n                query = booleanQuery;\r\n            } else {\r\n                Iterator<JID> iter = participants.iterator();\r\n                String participant1 = iter.next().toBareJID();\r\n                String participant2 = iter.next().toBareJID();\r\n                BooleanQuery participantQuery = new BooleanQuery();\r\n                participantQuery.add(new QueryParser(\"jid\", analyzer).parse(participant1), BooleanClause.Occur.MUST);\r\n                participantQuery.add(new QueryParser(\"jid\", analyzer).parse(participant2), BooleanClause.Occur.MUST);\r\n                BooleanQuery booleanQuery = new BooleanQuery();\r\n                booleanQuery.add(query, BooleanClause.Occur.MUST);\r\n                booleanQuery.add(participantQuery, BooleanClause.Occur.MUST);\r\n                query = booleanQuery;\r\n            }\r\n        }\r\n        Hits hits = searcher.search(query, filter, sort);\r\n        int startIndex = search.getStartIndex();\r\n        int endIndex = startIndex + search.getNumResults() - 1;\r\n        if (endIndex > hits.length() - 1) {\r\n        }\r\n        if (((endIndex - startIndex) + 1) <= 0) {\r\n            return Collections.emptyList();\r\n        } else {\r\n            return new LuceneQueryResults(hits, startIndex, endIndex);\r\n        }\r\n    } catch (ParseException pe) {\r\n        Log.error(pe.getMessage(), pe);\r\n        return Collections.emptySet();\r\n    } catch (IOException ioe) {\r\n        Log.error(ioe.getMessage(), ioe);\r\n        return Collections.emptySet();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.TrafficMonitor.isSentEnabled",
	"Comment": "returns true if packets that were sent will be printed to the console.",
	"Method": "boolean isSentEnabled(){\r\n    return sentEnabled;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.search.QueryResult.getAgentJIDs",
	"Comment": "returns the bare jid of the agents that were involved in the chat support. more thanone agent may have been involved in a chat transfer was done to another agent or a chatinvitation was sent to another agent.",
	"Method": "List<String> getAgentJIDs(){\r\n    return agentJIDs;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.Bookmark.getGroups",
	"Comment": "returns the collection of group names that have been assigned the the bookmark.",
	"Method": "Collection<String> getGroups(){\r\n    return groups;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.BroadcastPlugin.setGroupMembersAllowed",
	"Comment": "sets whether normal group members are allowed to send broadcast messagesto groups they belong to. otherwise, only group administrators can sendbroadcast messages to groups. global allowed users can also send messages togroups.",
	"Method": "void setGroupMembersAllowed(boolean allowed){\r\n    this.groupMembersAllowed = allowed;\r\n    JiveGlobals.setProperty(\"plugin.broadcast.groupMembersAllowed\", Boolean.toString(allowed));\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.TerminalEmulatorDeviceConfiguration.withCursorColor",
	"Comment": "copies the current configuration. the new object has the given value.",
	"Method": "TerminalEmulatorDeviceConfiguration withCursorColor(TextColor cursorColor){\r\n    if (this.cursorColor == cursorColor) {\r\n        return this;\r\n    } else {\r\n        return new TerminalEmulatorDeviceConfiguration(this.lineBufferScrollbackSize, this.blinkLengthInMilliSeconds, this.cursorStyle, cursorColor, this.cursorBlinking, this.clipboardAvailable);\r\n    }\r\n}"
}, {
	"Path": "com.javamonitor.JmxHelper.queryLong",
	"Comment": "query for a long, based on the object name. convenience method that doesthe casts.",
	"Method": "Long queryLong(ObjectName objectName,String attribute){\r\n    final Object value = query(objectName, attribute);\r\n    return value == null ? null : parseLong(value.toString());\r\n}"
}, {
	"Path": "com.reucon.openfire.plugin.archive.model.ArchivedMessage.isEmpty",
	"Comment": "checks if this message contains payload that should be archived.",
	"Method": "boolean isEmpty(){\r\n    return subject == null && body == null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.fastpath.settings.chat.ChatSettingsManager.getInstance",
	"Comment": "returns the singleton instance of chatsettingsmanager,creating it if necessary.",
	"Method": "ChatSettingsManager getInstance(){\r\n    return singleton;\r\n}"
}, {
	"Path": "org.jupiter.serialization.proto.io.UnsafeNioBufInput.skipMessage",
	"Comment": "reads and discards an entire message. this will read either until eof or until an endgroup tag, whichever comesfirst.",
	"Method": "void skipMessage(){\r\n    while (true) {\r\n        final int tag = readTag();\r\n        if (tag == 0 || !skipField(tag)) {\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.github.neuralnetworks.usage.NeuralNetworkUsage.classifyVector",
	"Comment": "create a tensor with the input vector, classify it, trim the result and returns the output vector of the network.",
	"Method": "float[] classifyVector(float[] input){\r\n    return classifyVectorWithActivationOutput(input).getLeft();\r\n}"
}, {
	"Path": "com.jvmtop.openjdk.tools.MemoryPoolStat.getLastGcStartTime",
	"Comment": "returns the start time of the most recent gc onthe memory pool for this statistics in milliseconds.return 0 if no gc occurs.",
	"Method": "long getLastGcStartTime(){\r\n    return lastGcStartTime;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getSession",
	"Comment": "returns the session of the specified user in a given workgroup. if no session exists thena new one will be created for the user if requested. if the session of the user remainsinactive for some time then it may be discarded.",
	"Method": "ChatbotSession getSession(JID user,boolean create){\r\n    String fullJID = user.toString();\r\n    ChatbotSession session = sessions.get(fullJID);\r\n    if (session == null && create) {\r\n        synchronized (fullJID.intern()) {\r\n            session = sessions.get(fullJID);\r\n            if (session == null) {\r\n                session = new ChatbotSession(user, this);\r\n                sessions.put(fullJID, session);\r\n            }\r\n        }\r\n    }\r\n    return session;\r\n}"
}, {
	"Path": "org.junit.platform.commons.util.ReflectionUtils.isWideningConversion",
	"Comment": "determine if java supports a widening primitive conversion from the\tsupplied source type to the supplied primitive target type.",
	"Method": "boolean isWideningConversion(Class<?> sourceType,Class<?> targetType){\r\n    Preconditions.condition(targetType.isPrimitive(), \"targetType must be primitive\");\r\n    boolean isPrimitive = sourceType.isPrimitive();\r\n    boolean isWrapper = primitiveToWrapperMap.containsValue(sourceType);\r\n    if (!isPrimitive && !isWrapper) {\r\n        return false;\r\n    }\r\n    if (isPrimitive) {\r\n        sourceType = primitiveToWrapperMap.get(sourceType);\r\n    }\r\n    if (sourceType == Byte.class) {\r\n        return targetType == short.class || targetType == int.class || targetType == long.class || targetType == float.class || targetType == double.class;\r\n    }\r\n    if (sourceType == Short.class || sourceType == Character.class) {\r\n        return targetType == int.class || targetType == long.class || targetType == float.class || targetType == double.class;\r\n    }\r\n    if (sourceType == Integer.class) {\r\n        return targetType == long.class || targetType == float.class || targetType == double.class;\r\n    }\r\n    if (sourceType == Long.class) {\r\n        return targetType == float.class || targetType == double.class;\r\n    }\r\n    if (sourceType == Float.class) {\r\n        return targetType == double.class;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterExternalizableUtil.writeStringMap",
	"Comment": "writes a map of string key and value pairs. this method handles thecase when the map is null.",
	"Method": "void writeStringMap(DataOutput out,Map<String, String> stringMap){\r\n    writeObject(out, stringMap);\r\n}"
}, {
	"Path": "io.micrometer.azuremonitor.AzureMonitorConfig.instrumentationKey",
	"Comment": "default implementation to get the instrumentation key from the config",
	"Method": "String instrumentationKey(){\r\n    String v = get(prefix() + \".instrumentationKey\");\r\n    if (v == null)\r\n        throw new MissingRequiredConfigurationException(\"instrumentationKey must be set to report metrics to Application Insights\");\r\n    return v;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.emailListener.EmailListener.getHost",
	"Comment": "returns the host where the imap server is running or null if none was defined.",
	"Method": "String getHost(){\r\n    return JiveGlobals.getProperty(\"plugin.email.listener.host\");\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TerminalTextUtils.getColumnWidth",
	"Comment": "given a string, returns how many columns this string would need to occupy in a terminal, taking into account thatcjk characters takes up two columns.",
	"Method": "int getColumnWidth(String s){\r\n    return getColumnIndex(s, s.length());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.sessions.TransportSessionManager.connectUserTo",
	"Comment": "add the session of user that connected to gateway and update or create timestamp for session",
	"Method": "boolean connectUserTo(String transport,String user){\r\n    if (transportSessions.get(transport) != null && transportSessions.get(transport).get(user) == null) {\r\n        long millis = System.currentTimeMillis();\r\n        transportSessions.get(transport).put(user, millis);\r\n        db.insertOrUpdateSession(transport, user, millis);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.DefaultTerminalFactory.setTerminalEmulatorDeviceConfiguration",
	"Comment": "sets the device configuration to use on created swingterminalframes created by this factory",
	"Method": "DefaultTerminalFactory setTerminalEmulatorDeviceConfiguration(TerminalEmulatorDeviceConfiguration deviceConfiguration){\r\n    this.deviceConfiguration = deviceConfiguration;\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.broadcastQueuesStatus",
	"Comment": "broadcasts the presence of all the queues in the workgroup to all agents.",
	"Method": "void broadcastQueuesStatus(){\r\n    TaskEngine.getInstance().submit(new Runnable() {\r\n        public void run() {\r\n            try {\r\n                for (RequestQueue requestQueue : getRequestQueues()) {\r\n                    requestQueue.getAgentSessionList().broadcastQueueStatus(requestQueue);\r\n                }\r\n            } catch (Exception e) {\r\n                Log.error(\"Error broadcasting status of queues\", e);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.broadcastQueuesStatus",
	"Comment": "broadcasts the presence of all the queues in the workgroup to all agents.",
	"Method": "void broadcastQueuesStatus(){\r\n    try {\r\n        for (RequestQueue requestQueue : getRequestQueues()) {\r\n            requestQueue.getAgentSessionList().broadcastQueueStatus(requestQueue);\r\n        }\r\n    } catch (Exception e) {\r\n        Log.error(\"Error broadcasting status of queues\", e);\r\n    }\r\n}"
}, {
	"Path": "com.reucon.openfire.plugin.archive.xep0313.IQQueryHandler.buildSupportedFieldsResult",
	"Comment": "declare dataform fields supported by the mam implementation on this server",
	"Method": "IQ buildSupportedFieldsResult(IQ packet){\r\n    IQ result = IQ.createResultIQ(packet);\r\n    Element query = result.setChildElement(\"query\", NAMESPACE);\r\n    DataForm form = new DataForm(DataForm.Type.form);\r\n    form.addField(\"FORM_TYPE\", null, FormField.Type.hidden);\r\n    form.getField(\"FORM_TYPE\").addValue(NAMESPACE);\r\n    form.addField(\"with\", null, FormField.Type.jid_single);\r\n    form.addField(\"start\", null, FormField.Type.text_single);\r\n    form.addField(\"end\", null, FormField.Type.text_single);\r\n    query.add(form.getElement());\r\n    return result;\r\n}"
}, {
	"Path": "kilim.http.HttpRequest.reuse",
	"Comment": "clear the request object so that it can be reused for the next message.",
	"Method": "void reuse(){\r\n    method = null;\r\n    uriPath = null;\r\n    versionRange = 0;\r\n    uriFragmentRange = queryStringRange = 0;\r\n    contentOffset = 0;\r\n    contentLength = 0;\r\n    if (buffer != null) {\r\n        buffer.clear();\r\n    }\r\n    for (int i = 0; i < nFields; i++) {\r\n        keys[i] = null;\r\n    }\r\n    nFields = 0;\r\n}"
}, {
	"Path": "org.jdbi.v3.sqlobject.config.Configurer.configureForMethod",
	"Comment": "configures the registry for the given annotation on a sql object method.",
	"Method": "void configureForMethod(ConfigRegistry registry,Annotation annotation,Class<?> sqlObjectType,Method method){\r\n    throw new UnsupportedOperationException(\"Not supported for method\");\r\n}"
}, {
	"Path": "com.drew.lang.Rational.doubleValue",
	"Comment": "returns the value of the specified number as a double.this may involve rounding.",
	"Method": "double doubleValue(){\r\n    return _numerator == 0 ? 0.0 : (double) _numerator / (double) _denominator;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ArchiveSearch.getRoom",
	"Comment": "returns the jid of the room for conversations that will be returned by the search. ifthis value has not been set, the method will return null.",
	"Method": "JID getRoom(){\r\n    return room;\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.Metrics.timer",
	"Comment": "measures the time taken for short tasks and the count of these tasks.",
	"Method": "Timer timer(String name,Iterable<Tag> tags,Timer timer,String name,String tags,FunctionTimer timer,String name,Iterable<Tag> tags,T obj,ToLongFunction<T> countFunction,ToDoubleFunction<T> totalTimeFunction,TimeUnit totalTimeFunctionUnit){\r\n    return globalRegistry.timer(name, tags);\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocket.setPingPayloadGenerator",
	"Comment": "set the generator of payload of ping frames that are sent automatically.",
	"Method": "WebSocket setPingPayloadGenerator(PayloadGenerator generator){\r\n    mPingSender.setPayloadGenerator(generator);\r\n    return this;\r\n}"
}, {
	"Path": "gab.opencv.OpenCV.getUseColor",
	"Comment": "checks whether opencv is currently using the color version of the imageor the grayscale version.",
	"Method": "boolean getUseColor(){\r\n    return useColor;\r\n}"
}, {
	"Path": "com.javamonitor.JmxHelper.queryInt",
	"Comment": "query for an integer, based on the object name. convenience method thatdoes the casts.",
	"Method": "Integer queryInt(String objectName,String attribute,Integer queryInt,ObjectName objectName,String attribute){\r\n    final Object value = query(objectName, attribute);\r\n    return value == null ? null : parseInt(value.toString());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.graph.GraphEngine.getColor",
	"Comment": "takes a hexidecimel color value and returns its color equivelent.",
	"Method": "Color getColor(String hexColor){\r\n    return new Color(Integer.valueOf(hexColor.substring(0, 2), 16), Integer.valueOf(hexColor.substring(2, 4), 16), Integer.valueOf(hexColor.substring(4, 6), 16));\r\n}"
}, {
	"Path": "com.github.fge.jsonschema.main.JsonSchemaFactory.getProcessor",
	"Comment": "return the raw validation processorthis will allow you to chain the full validation processor with otherprocessors of your choice. useful if, for instance, you wish to add postchecking which json schema cannot do by itself.",
	"Method": "Processor<FullData, FullData> getProcessor(){\r\n    return validator.getProcessor();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.getAgentSessions",
	"Comment": "returns a collection with all the agent session that are present in the workgroup. if thesame agent is present in more than one queue then the answer will only include one instanceof the agent session.",
	"Method": "Collection<AgentSession> getAgentSessions(){\r\n    Collection<AgentSession> answer = new HashSet<AgentSession>();\r\n    for (RequestQueue queue : queues.values()) {\r\n        answer.addAll(queue.getAgentSessionList().getAgentSessions());\r\n    }\r\n    return Collections.unmodifiableCollection(answer);\r\n}"
}, {
	"Path": "io.micrometer.statsd.StatsdDistributionSummary.max",
	"Comment": "the statsd agent will likely compute max with a different window, so the value may not match what you see here.this value is not exported to the agent, and is only for diagnostic use.",
	"Method": "double max(){\r\n    return max.poll();\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.SwingTerminal.addInput",
	"Comment": "takes a keystroke and puts it on the input queue of the terminal emulator. this way you can insert syntheticinput events to be processed as if they came from the user typing on the keyboard.",
	"Method": "void addInput(KeyStroke keyStroke){\r\n    terminalImplementation.addInput(keyStroke);\r\n}"
}, {
	"Path": "com.drew.metadata.iptc.IptcDirectory.getExpirationDate",
	"Comment": "parses the expiration date tag and the expiration time tag to obtain a single date object representingthat this image should not used after this date and time.",
	"Method": "Date getExpirationDate(){\r\n    return getDate(TAG_EXPIRATION_DATE, TAG_EXPIRATION_TIME);\r\n}"
}, {
	"Path": "kilim.analysis.Handler.startComparator",
	"Comment": "return a comparator that orders the handlers by start position",
	"Method": "Comparator<Handler> startComparator(){\r\n    return comp;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getPositionHelpMessage",
	"Comment": "returns the message that describes the effect of running the position command.",
	"Method": "String getPositionHelpMessage(){\r\n    return settings.getChatSetting(KeyEnum.position_help_message).getValue();\r\n}"
}, {
	"Path": "com.javamonitor.JmxHelper.unregister",
	"Comment": "unregister an mbean, suppressing all errors that may arise. good formaking sure a bean really is not there. we assume that the registeredbean was registered in the platform mbean server.",
	"Method": "void unregister(String objectName){\r\n    try {\r\n        getPlatformMBeanServer().unregisterMBean(new ObjectName(objectName));\r\n    } catch (Exception e) {\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.AgentManager.removeAgentIfNecessary",
	"Comment": "removes an agent from the system if they no longer belong to any workgroups.",
	"Method": "void removeAgentIfNecessary(Agent agent){\r\n    WorkgroupManager workgroupManager = WorkgroupManager.getInstance();\r\n    for (Workgroup workgroup : workgroupManager.getWorkgroups()) {\r\n        for (RequestQueue queue : workgroup.getRequestQueues()) {\r\n            if (queue.getMembers().contains(agent)) {\r\n                return;\r\n            }\r\n            for (Group group : queue.getGroups()) {\r\n                if (group.isUser(agent.getAgentJID())) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        AgentSession session = agent.getAgentSession();\r\n        if (session != null) {\r\n            for (Workgroup workgroup : session.getWorkgroups()) {\r\n                session.depart(workgroup);\r\n            }\r\n        }\r\n        deleteAgent(agent.getAgentJID());\r\n    } catch (IllegalArgumentException e) {\r\n        Log.error(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ConversationEventsQueue.addGroupChatEvent",
	"Comment": "queues the group chat event to be later sent to the senior cluster member.",
	"Method": "void addGroupChatEvent(String conversationKey,ConversationEvent event){\r\n    synchronized (roomEvents) {\r\n        List<ConversationEvent> events = roomEvents.get(conversationKey);\r\n        if (events == null) {\r\n            events = new ArrayList<ConversationEvent>();\r\n            roomEvents.put(conversationKey, events);\r\n        }\r\n        events.add(event);\r\n    }\r\n}"
}, {
	"Path": "org.jupiter.common.util.collection.LongObjectHashMap.indexOf",
	"Comment": "locates the index for the given key. this method probes using double hashing.",
	"Method": "int indexOf(long key){\r\n    int startIndex = hashIndex(key);\r\n    int index = startIndex;\r\n    for (; ; ) {\r\n        if (values[index] == null) {\r\n            return -1;\r\n        }\r\n        if (key == keys[index]) {\r\n            return index;\r\n        }\r\n        if ((index = probeNext(index)) == startIndex) {\r\n            return -1;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.ChatbotSession.setMessageThread",
	"Comment": "updates the referene to the message thread that the user is using for sending his messages.it is important to send messages to the user using the same thread so that messages appearin the same chat window that the user is using.",
	"Method": "void setMessageThread(String thread){\r\n    this.messageThread = thread;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.OfferInterceptorManager.getInstance",
	"Comment": "returns a singleton instance of offerinterceptormanager.",
	"Method": "InterceptorManager getInstance(){\r\n    return instance;\r\n}"
}, {
	"Path": "com.drew.imaging.jpeg.JpegSegmentData.containsSegment",
	"Comment": "determines whether data is present for a given segment type.",
	"Method": "boolean containsSegment(JpegSegmentType segmentType,boolean containsSegment,byte segmentType){\r\n    return _segmentDataMap.containsKey(segmentType);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.AgentSessionList.getAgentSession",
	"Comment": "obtain the agent session by address.the current implementation is slow, but weexpect it to only be used by the admin interface sooverhead is not a concern. if this is used for theruntime behavior of the workgroup itself, theimplementation must be changed.",
	"Method": "AgentSession getAgentSession(JID address){\r\n    AgentSession session = null;\r\n    for (AgentSession agentSession : sessionList.keySet()) {\r\n        if (agentSession.getJID().equals(address)) {\r\n            session = agentSession;\r\n            break;\r\n        }\r\n    }\r\n    if (session == null) {\r\n        throw new AgentNotFoundException(address.toString());\r\n    }\r\n    return session;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.GridLayout.setHorizontalSpacing",
	"Comment": "sets the horizontal spacing, i.e. the number of empty columns between each cell",
	"Method": "GridLayout setHorizontalSpacing(int horizontalSpacing){\r\n    if (horizontalSpacing < 0) {\r\n        throw new IllegalArgumentException(\"Horizontal spacing cannot be less than 0\");\r\n    }\r\n    this.horizontalSpacing = horizontalSpacing;\r\n    this.changed = true;\r\n    return this;\r\n}"
}, {
	"Path": "org.jupiter.common.concurrent.collection.ConcurrentAutoTable.get",
	"Comment": "current value of the counter.since other threads are updating furiouslythe value is only approximate, but it includes all counts made by thecurrent thread.requires a pass over the internally striped counters.",
	"Method": "long get(){\r\n    return _cat.sum();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.RequestQueue.isOpened",
	"Comment": "returns true if this queue is opened and may be eligible for receiving new requests. thequeue will be opened if there are agents connected to it.",
	"Method": "boolean isOpened(){\r\n    return !activeAgents.isEmpty();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.search.ChatSearchManager.setAnalyzerClass",
	"Comment": "sets the lucene analyzer class that is used for indexing. anytime the analyzer classis changed, the search index must be rebuilt for searching to work reliably. the analyzerclass name is stored as the jive property workgroup.search.analyzer.classname.",
	"Method": "void setAnalyzerClass(String className){\r\n    if (className == null) {\r\n        throw new NullPointerException(\"Argument is null.\");\r\n    }\r\n    if (className.equals(getAnalyzerClass())) {\r\n        return;\r\n    }\r\n    JiveGlobals.setProperty(\"workgroup.search.analyzer.className\", className);\r\n}"
}, {
	"Path": "org.jupiter.common.concurrent.collection.NonBlockingHashMap.clone",
	"Comment": "creates a shallow copy of this hashtable. all the structure of thehashtable itself is copied, but the keys and values are not cloned.this is a relatively expensive operation.",
	"Method": "Object clone(){\r\n    try {\r\n        NonBlockingHashMap<TypeK, TypeV> t = (NonBlockingHashMap<TypeK, TypeV>) super.clone();\r\n        t.clear();\r\n        for (TypeK K : keySet()) {\r\n            final TypeV V = get(K);\r\n            t.put(K, V);\r\n        }\r\n        return t;\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new InternalError();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.WorkgroupProviderManager.getInstance",
	"Comment": "returns the singleton instance of workgroupprovidermanager,creating it if necessary.",
	"Method": "WorkgroupProviderManager getInstance(){\r\n    return singleton;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Agent.getAgentSession",
	"Comment": "returns the session of the agent or null if the agent has not logged.",
	"Method": "AgentSession getAgentSession(){\r\n    return session;\r\n}"
}, {
	"Path": "kilim.timerservice.TimerService.isEmptyLazy",
	"Comment": "return true if empty at a particular moment during the call allowing false negatives if operations are ongoing",
	"Method": "boolean isEmptyLazy(WatchdogContext executor){\r\n    return empty() && new Empty().check(executor);\r\n}"
}, {
	"Path": "com.javamonitor.JmxHelper.queryString",
	"Comment": "query for a string, based on the object name. convenience method thatdoes the casts.",
	"Method": "String queryString(String objectName,String attribute,String queryString,ObjectName objectName,String attribute){\r\n    final Object value = query(objectName, attribute);\r\n    return value == null ? null : value.toString();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.SparkManager.shutdown",
	"Comment": "remove any resources sparkmanager was using. this will allowfor a clean reload.",
	"Method": "void shutdown(){\r\n    SessionEventDispatcher.removeListener(sessionEventListener);\r\n    if (statisticsManager != null) {\r\n        statisticsManager.removeStatistic(SPARK_CLIENTS_KEY);\r\n        statisticsManager.removeStatistic(INVALID_DISCONNECTS_KEY);\r\n    }\r\n    componentManager = null;\r\n    sessionManager = null;\r\n    sessionEventListener = null;\r\n    statisticsManager = null;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.UserInterceptor.getFromEmail",
	"Comment": "returns the email address that notification emails will appear to be from.",
	"Method": "String getFromEmail(){\r\n    return fromEmail;\r\n}"
}, {
	"Path": "com.drew.metadata.xmp.XmpDirectory.getXmpProperties",
	"Comment": "gets a map of all xmp properties in this directory.this is required because xmp properties are represented as strings, whereas the rest of this libraryuses integers for keys.",
	"Method": "Map<String, String> getXmpProperties(){\r\n    Map<String, String> propertyValueByPath = new HashMap<String, String>();\r\n    if (_xmpMeta != null) {\r\n        try {\r\n            IteratorOptions options = new IteratorOptions().setJustLeafnodes(true);\r\n            for (Iterator i = _xmpMeta.iterator(options); i.hasNext(); ) {\r\n                XMPPropertyInfo prop = (XMPPropertyInfo) i.next();\r\n                String path = prop.getPath();\r\n                String value = prop.getValue();\r\n                if (path != null && value != null) {\r\n                    propertyValueByPath.put(path, value);\r\n                }\r\n            }\r\n        } catch (XMPException ignored) {\r\n        }\r\n    }\r\n    return Collections.unmodifiableMap(propertyValueByPath);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.table.Table.getVisibleRows",
	"Comment": "returns the number of rows this table will show. if there are more rows in the table model, a scrollbar will beused to allow the user to scroll up and down and view all rows.",
	"Method": "int getVisibleRows(){\r\n    return visibleRows;\r\n}"
}, {
	"Path": "com.github.fge.jsonschema.main.JsonSchemaFactory.byDefault",
	"Comment": "return a default factorythis default factory has validators for both draft v4 and draft v3. itdefaults to draft v4.",
	"Method": "JsonSchemaFactory byDefault(){\r\n    return newBuilder().freeze();\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.distribution.DistributionStatisticConfig.getMinimumExpectedValue",
	"Comment": "the minimum value that the meter is expected to observe. sets a lower boundon histogram buckets that are shipped to monitoring systems that support aggregable percentile approximations.",
	"Method": "Long getMinimumExpectedValue(){\r\n    return minimumExpectedValue;\r\n}"
}, {
	"Path": "org.jdbi.v3.testing.JdbiRule.getJdbi",
	"Comment": "get jdbi, in case you want to open additional handles to the same data source.",
	"Method": "Jdbi getJdbi(){\r\n    return jdbi;\r\n}"
}, {
	"Path": "org.jupiter.common.util.JvmTools.jStack",
	"Comment": "returns java stack traces of java threads for the current java process.",
	"Method": "List<String> jStack(){\r\n    List<String> stackList = new LinkedList();\r\n    Map<Thread, StackTraceElement[]> allStackTraces = Thread.getAllStackTraces();\r\n    for (Map.Entry<Thread, StackTraceElement[]> entry : allStackTraces.entrySet()) {\r\n        Thread thread = entry.getKey();\r\n        StackTraceElement[] stackTraces = entry.getValue();\r\n        stackList.add(String.format(\"\\\"%s\\\" tid=%s isDaemon=%s priority=%s\" + JConstants.NEWLINE, thread.getName(), thread.getId(), thread.isDaemon(), thread.getPriority()));\r\n        stackList.add(\"java.lang.Thread.State: \" + thread.getState() + JConstants.NEWLINE);\r\n        if (stackTraces != null) {\r\n            for (StackTraceElement s : stackTraces) {\r\n                stackList.add(\"    \" + s.toString() + JConstants.NEWLINE);\r\n            }\r\n        }\r\n    }\r\n    return stackList;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ConversationManager.isConversationJID",
	"Comment": "returns true if the specified jid should be recorded in a conversation.",
	"Method": "boolean isConversationJID(JID jid){\r\n    if (jid == null) {\r\n        return false;\r\n    }\r\n    XMPPServer server = XMPPServer.getInstance();\r\n    if (jid.getNode() == null) {\r\n        return false;\r\n    }\r\n    if (server.isLocal(jid) || gateways.contains(jid.getDomain())) {\r\n        return true;\r\n    }\r\n    if (!jid.getDomain().endsWith(serverInfo.getXMPPDomain())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.StatusLine.toString",
	"Comment": "get the string representation of this instance, which isequal to the raw status line.",
	"Method": "String toString(){\r\n    return mString;\r\n}"
}, {
	"Path": "io.moquette.broker.Authorizator.canWrite",
	"Comment": "ask the authorization policy if the topic can be used in a publish.",
	"Method": "boolean canWrite(Topic topic,String user,String client){\r\n    return policy.canWrite(topic, user, client);\r\n}"
}, {
	"Path": "kilim.WeavingClassLoader.weaveClass",
	"Comment": "load the bytecode for a class of a given name from the classpath and weave it",
	"Method": "ClassWeaver weaveClass(String name){\r\n    String cname = makeResourceName(name);\r\n    InputStream is = getByteStream(pcl, name, cname);\r\n    ClassWeaver cw = weaver.weave(is);\r\n    return cw;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.getModificationDate",
	"Comment": "returns the last date when the workgroup properties were modified.",
	"Method": "Date getModificationDate(){\r\n    return modDate;\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocket.setPongPayloadGenerator",
	"Comment": "set the generator of payload of pong frames that are sent automatically.",
	"Method": "WebSocket setPongPayloadGenerator(PayloadGenerator generator){\r\n    mPongSender.setPayloadGenerator(generator);\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.WorkgroupInterceptorManager.getInstance",
	"Comment": "returns a singleton instance of workgroupinterceptormanager.",
	"Method": "InterceptorManager getInstance(){\r\n    return instance;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getJoinQuestion",
	"Comment": "returns the question to send to the user asking if he wants to join the workgroup.",
	"Method": "String getJoinQuestion(){\r\n    return settings.getChatSetting(KeyEnum.join_question).getValue();\r\n}"
}, {
	"Path": "com.reucon.openfire.plugin.archive.xep0313.IQQueryHandler.retrieveMessages",
	"Comment": "retrieve messages matching query request from server archive",
	"Method": "Collection<ArchivedMessage> retrieveMessages(QueryRequest queryRequest){\r\n    String withField = null;\r\n    String startField = null;\r\n    String endField = null;\r\n    DataForm dataForm = queryRequest.getDataForm();\r\n    if (dataForm != null) {\r\n        if (dataForm.getField(\"with\") != null) {\r\n            withField = dataForm.getField(\"with\").getFirstValue();\r\n        }\r\n        if (dataForm.getField(\"start\") != null) {\r\n            startField = dataForm.getField(\"start\").getFirstValue();\r\n        }\r\n        if (dataForm.getField(\"end\") != null) {\r\n            endField = dataForm.getField(\"end\").getFirstValue();\r\n        }\r\n    }\r\n    Date startDate = null;\r\n    Date endDate = null;\r\n    try {\r\n        if (startField != null) {\r\n            startDate = xmppDateTimeFormat.parseString(startField);\r\n        }\r\n        if (endField != null) {\r\n            endDate = xmppDateTimeFormat.parseString(endField);\r\n        }\r\n    } catch (ParseException e) {\r\n        Log.error(\"Error parsing query date filters.\", e);\r\n    }\r\n    return getPersistenceManager(queryRequest.getArchive()).findMessages(startDate, endDate, queryRequest.getArchive().toBareJID(), withField, queryRequest.getResultSet());\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.ansi.TelnetTerminalServer.acceptConnection",
	"Comment": "waits for the next client to connect in to our server and returns a terminal implementation, telnetterminal, thatrepresents the remote terminal this client is running. the terminal can be used just like any other terminal, butkeep in mind that all operations are sent over the network.",
	"Method": "TelnetTerminal acceptConnection(){\r\n    Socket clientSocket = serverSocket.accept();\r\n    clientSocket.setTcpNoDelay(true);\r\n    return new TelnetTerminal(clientSocket, charset);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.session.RemoteSession.doSynchronousClusterTask",
	"Comment": "invokes a task on the remote cluster member synchronously and returns the result ofthe remote operation.",
	"Method": "Object doSynchronousClusterTask(ClusterTask task){\r\n    ClusterNodeInfo info = CacheFactory.getClusterNodeInfo(nodeID);\r\n    Object result = null;\r\n    if (info == null && task instanceof RemoteSessionTask) {\r\n        Session remoteSession = ((RemoteSessionTask) task).getSession();\r\n        if (remoteSession instanceof ClientSession) {\r\n            SessionManager.getInstance().removeSession(null, remoteSession.getAddress(), false, false);\r\n        }\r\n    } else {\r\n        result = (info == null) ? null : CacheFactory.doSynchronousClusterTask(task, nodeID);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "kilim.nio.EndPoint.close",
	"Comment": "close the endpoint, printing and returning and any ioexception",
	"Method": "IOException close(){\r\n    try {\r\n        sockch.close();\r\n        return null;\r\n    } catch (IOException ignore) {\r\n        ignore.printStackTrace();\r\n        return ignore;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.spi.ChatHistoryUtils.getNumberOfChatsForWorkgroup",
	"Comment": "returns the total number of chats that have occured within a workgroup.",
	"Method": "int getNumberOfChatsForWorkgroup(String workgroupName){\r\n    Workgroup workgroup = null;\r\n    try {\r\n        workgroup = WorkgroupManager.getInstance().getWorkgroup(new JID(workgroupName));\r\n    } catch (Exception ex) {\r\n        Log.error(ex.getMessage(), ex);\r\n    }\r\n    int count = 0;\r\n    for (RequestQueue requestQueue : workgroup.getRequestQueues()) {\r\n        count += requestQueue.getTotalChatCount();\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TextCharacter.withBackgroundColor",
	"Comment": "returns a copy of this textcharacter with a specified background color",
	"Method": "TextCharacter withBackgroundColor(TextColor backgroundColor){\r\n    if (this.backgroundColor == backgroundColor || this.backgroundColor.equals(backgroundColor)) {\r\n        return this;\r\n    }\r\n    return new TextCharacter(character, foregroundColor, backgroundColor, modifiers);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getDepartureConfirmedMessage",
	"Comment": "returns the message to send to the user when the user asks to leave the waiting queue.",
	"Method": "String getDepartureConfirmedMessage(){\r\n    return settings.getChatSetting(KeyEnum.departure_confirmed_message).getValue();\r\n}"
}, {
	"Path": "org.junit.platform.testkit.engine.EventStatistics.dynamicallyRegistered",
	"Comment": "specify the number of expected dynamic registration events.",
	"Method": "EventStatistics dynamicallyRegistered(long expected){\r\n    this.executables.add(() -> assertEquals(expected, this.events.dynamicallyRegistered().count(), \"dynamically registered\"));\r\n    return this;\r\n}"
}, {
	"Path": "org.jupiter.transport.netty.NativeSupport.isNativeKQueueAvailable",
	"Comment": "the native socket transport for bsd systems such as macos using jni.",
	"Method": "boolean isNativeKQueueAvailable(){\r\n    return KQueue.isAvailable();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.stats.StatsAction.getUpdatedStat",
	"Comment": "retrieve a a single stat update given a stat name and the name of atime period.",
	"Method": "Map getUpdatedStat(String statkey,String timePeriod,Map getUpdatedStat,String statkey,long[] timePeriod){\r\n    MonitoringPlugin plugin = (MonitoringPlugin) XMPPServer.getInstance().getPluginManager().getPlugin(MonitoringConstants.NAME);\r\n    StatsViewer viewer = (StatsViewer) plugin.getModule(StatsViewer.class);\r\n    String[] lowHigh = getLowAndHigh(statkey, timePeriod);\r\n    Map stat = new HashMap();\r\n    stat.put(\"low\", lowHigh[0]);\r\n    stat.put(\"high\", lowHigh[1]);\r\n    stat.put(\"count\", (int) viewer.getCurrentValue(statkey)[0]);\r\n    return stat;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.sessions.TransportSessionManager.getConnectionsFor",
	"Comment": "searches for sessions with given username and returns them as arrlist",
	"Method": "ArrayList<GatewaySession> getConnectionsFor(String username){\r\n    ArrayList<GatewaySession> userconnections = new ArrayList<GatewaySession>();\r\n    for (Map.Entry<String, Map<String, Long>> transport : transportSessions.entrySet()) {\r\n        if (transport.getValue().containsKey(username)) {\r\n            Timestamp stamp = new Timestamp(transport.getValue().get(username));\r\n            Date date = new Date(stamp.getTime());\r\n            userconnections.add(new GatewaySession(username, transport.getKey(), date));\r\n        }\r\n    }\r\n    return userconnections;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.event.WorkgroupEventDispatcher.workgroupClosed",
	"Comment": "notification message that a workgroup has closed since no agent is availableor because of its schedule.",
	"Method": "void workgroupClosed(Workgroup workgroup){\r\n    for (WorkgroupEventListener listener : listeners) {\r\n        try {\r\n            listener.workgroupClosed(workgroup);\r\n        } catch (Exception e) {\r\n            Log.error(e.getMessage(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.BroadcastPlugin.getGlobalAllowedUsers",
	"Comment": "returns a collection of the addresses of users allowed to send broadcastmessages. if no users are defined, anyone can send broadcast messages toall users. additional users may also be allowed to send broadcast messagesto specific groups depending on the group settings.",
	"Method": "Collection<JID> getGlobalAllowedUsers(){\r\n    return allowedUsers;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.ansi.StreamBasedTerminal.writeToTerminal",
	"Comment": "this method will write a list of bytes directly to the output stream of the terminal.",
	"Method": "void writeToTerminal(byte bytes){\r\n    synchronized (terminalOutput) {\r\n        terminalOutput.write(bytes);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.userAnsweredField",
	"Comment": "returns true if the received message contains a valid answer for the current question.",
	"Method": "boolean userAnsweredField(Message message,ChatbotSession session){\r\n    boolean validAnswer = false;\r\n    List<String> answers = Request.decodeMetadataValue(message.getBody().trim());\r\n    FormElement field = getForm().getFormElementAt(session.getCurrentSubstep());\r\n    List<String> options = field.getAnswers();\r\n    if (!options.isEmpty()) {\r\n        for (String answer : answers) {\r\n            validAnswer = false;\r\n            for (String option : options) {\r\n                option = option.replace(\"\\r\", \"\");\r\n                if (option.equalsIgnoreCase(answer)) {\r\n                    validAnswer = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!validAnswer) {\r\n                return false;\r\n            }\r\n        }\r\n    } else {\r\n        validAnswer = true;\r\n    }\r\n    if (validAnswer) {\r\n        session.putAttribute(field.getVariable(), answers);\r\n    }\r\n    return validAnswer;\r\n}"
}, {
	"Path": "org.jdbi.v3.sqlobject.customizer.SqlStatementCustomizerFactory.createForType",
	"Comment": "used to create customizers for annotations on sql object interfaces",
	"Method": "SqlStatementCustomizer createForType(Annotation annotation,Class<?> sqlObjectType){\r\n    throw new UnsupportedOperationException(\"Not supported for type\");\r\n}"
}, {
	"Path": "com.jvmtop.view.AbstractConsoleView.join",
	"Comment": "joins the given list of strings using the given delimiter delim",
	"Method": "String join(List<String> list,String delim){\r\n    StringBuilder sb = new StringBuilder();\r\n    String loopDelim = \"\";\r\n    for (String s : list) {\r\n        sb.append(loopDelim);\r\n        sb.append(s);\r\n        loopDelim = delim;\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.reucon.openfire.plugin.archive.model.Conversation.isNew",
	"Comment": "checks if this conversation is new and has not yet been persisted.",
	"Method": "boolean isNew(){\r\n    return id == null;\r\n}"
}, {
	"Path": "io.micrometer.spring.autoconfigure.MeterValue.getValue",
	"Comment": "return the underlying value of the sla in form suitable to apply to the given metertype.",
	"Method": "Long getValue(Meter.Type meterType){\r\n    if (meterType == Meter.Type.DISTRIBUTION_SUMMARY) {\r\n        return getDistributionSummaryValue();\r\n    }\r\n    if (meterType == Meter.Type.TIMER) {\r\n        return getTimerValue();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocket.clearUserInfo",
	"Comment": "clear the credentials to connect to the websocket endpoint.",
	"Method": "WebSocket clearUserInfo(){\r\n    mHandshakeBuilder.clearUserInfo();\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.Conversation.messageReceived",
	"Comment": "called when a new message for the conversation is received. each time a new message is received, the last activity date will be updated and themessage count incremented.",
	"Method": "void messageReceived(JID entity,Date date){\r\n    lastActivity = date;\r\n    messageCount++;\r\n}"
}, {
	"Path": "com.drew.metadata.Tag.getTagName",
	"Comment": "get the name of the tag, such as aperture, orinteropversion.",
	"Method": "String getTagName(){\r\n    return _directory.getTagName(_tagType);\r\n}"
}, {
	"Path": "com.reucon.openfire.plugin.archive.xep0136.RemoveRequest.getEnd",
	"Comment": "if the end date is in the future then then all collections after the start date are removed.",
	"Method": "Date getEnd(){\r\n    return end;\r\n}"
}, {
	"Path": "kilim.Task.getTid",
	"Comment": "return the thread id that the task is currently running on, valid only during execute",
	"Method": "int getTid(){\r\n    return tid;\r\n}"
}, {
	"Path": "kilim.analysis.Usage.evalBornIn",
	"Comment": "evolve the born value a single iteration by mixing in either pred or combo",
	"Method": "boolean evalBornIn(Usage pred,BitSet combo){\r\n    BitSet old = (BitSet) born.clone();\r\n    if (combo == null)\r\n        combo = pred.born;\r\n    if (firstBorn)\r\n        born.or(combo);\r\n    else\r\n        born.and(combo);\r\n    firstBorn = false;\r\n    return !old.equals(born);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.GridLayout.setBottomMarginSize",
	"Comment": "sets the bottom margin, i.e. number of empty rows below the last row in the grid",
	"Method": "GridLayout setBottomMarginSize(int bottomMarginSize){\r\n    if (bottomMarginSize < 0) {\r\n        throw new IllegalArgumentException(\"Bottom margin size cannot be less than 0\");\r\n    }\r\n    this.bottomMarginSize = bottomMarginSize;\r\n    this.changed = true;\r\n    return this;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.TerminalEmulatorColorConfiguration.getDefault",
	"Comment": "this is the default settings that is used when you create a new swingterminal without specifying any colorconfiguration. it will use classic vga colors for the ansi palette and bright colors on bold text.",
	"Method": "TerminalEmulatorColorConfiguration getDefault(){\r\n    return newInstance(TerminalEmulatorPalette.STANDARD_VGA);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.getDisplayName",
	"Comment": "returns the name to use when displaying the workgroup. this information can be usedwhen showing the workgroup as a roster item.",
	"Method": "String getDisplayName(){\r\n    return displayName;\r\n}"
}, {
	"Path": "org.jdbi.v3.stringtemplate4.StringTemplateSqlLocator.findStringTemplateGroup",
	"Comment": "loads the stringtemplategroup from the given path on the classpath.",
	"Method": "STGroup findStringTemplateGroup(Class<?> type,STGroup findStringTemplateGroup,String path,STGroup findStringTemplateGroup,ClassLoader classLoader,String path){\r\n    return CACHE.computeIfAbsent(path, p -> ThreadLocal.withInitial(() -> readStringTemplateGroup(classLoader, path))).get();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.database.DatabaseManager.getAllLogs",
	"Comment": "this method return the last 100 log entries. every entry is one string and added to a arraylist",
	"Method": "List<String> getAllLogs(){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    List<String> _result = new ArrayList<String>();\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(GET_ALL_LOGS);\r\n        rs = pstmt.executeQuery();\r\n        while (rs.next()) {\r\n            String from = rs.getString(4);\r\n            String to = rs.getString(5);\r\n            String type = rs.getString(3);\r\n            String component = rs.getString(6);\r\n            Timestamp date = rs.getTimestamp(2);\r\n            String res = \"From: \" + from + \" To: \" + to + \" Type: \" + type + \" Timestamp: \" + date.toString() + \"Component: \" + component;\r\n            _result.add(res);\r\n        }\r\n    } catch (SQLException sqle) {\r\n        Log.error(\"An exception occurred while getting all log entries.\", sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    return _result;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.table.Table.setTableModel",
	"Comment": "updates the table with a new table model, effectively replacing the content of the table completely",
	"Method": "Table<V> setTableModel(TableModel<V> tableModel){\r\n    if (tableModel == null) {\r\n        throw new IllegalArgumentException(\"Cannot assign a null TableModel\");\r\n    }\r\n    this.tableModel.removeListener(tableModelListener);\r\n    this.tableModel = tableModel;\r\n    this.tableModel.addListener(tableModelListener);\r\n    invalidate();\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.InterceptorManager.getChildrenPropertyNames",
	"Comment": "returns a child property names given a parent and an iterator of property names.",
	"Method": "Collection<String> getChildrenPropertyNames(String parent,Collection<String> properties){\r\n    List<String> results = new ArrayList<String>();\r\n    for (String name : properties) {\r\n        if (name.startsWith(parent) && !name.equals(parent)) {\r\n            results.add(name);\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.jupiter.common.util.ThrowUtil.throwException",
	"Comment": "raises an exception bypassing compiler checks for checked exceptions.",
	"Method": "void throwException(Throwable t){\r\n    Unsafe unsafe = UnsafeUtil.getUnsafe();\r\n    if (unsafe != null) {\r\n        unsafe.throwException(t);\r\n    } else {\r\n        ThrowUtil.<RuntimeException>throwException0(t);\r\n    }\r\n}"
}, {
	"Path": "org.jupiter.common.concurrent.collection.NonBlockingHashMap.print2",
	"Comment": "print only the live values, broken down by the table they are in",
	"Method": "void print2(Object[] kvs){\r\n    for (int i = 0; i < len(kvs); i++) {\r\n        Object key = key(kvs, i);\r\n        Object val = val(kvs, i);\r\n        Object U = Prime.unbox(val);\r\n        if (key != null && key != TOMBSTONE && val != null && U != TOMBSTONE) {\r\n            String p = (val == U) ? \"\" : \"prime_\";\r\n            System.out.println(\"\" + i + \" (\" + key + \",\" + p + val + \")\");\r\n        }\r\n    }\r\n    Object[] newkvs = chm(kvs)._newkvs;\r\n    if (newkvs != null) {\r\n        System.out.println(\"----\");\r\n        print2(newkvs);\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.input.EscapeSequenceCharacterPattern.getKeyStrokeRaw",
	"Comment": "combines the raw parts of the sequence into a keystroke.this method does not check the first char, but overrides may do so.",
	"Method": "KeyStroke getKeyStrokeRaw(char first,int num1,int num2,char last,boolean bEsc){\r\n    KeyType kt;\r\n    boolean bPuttyCtrl = false;\r\n    if (last == '~' && stdMap.containsKey(num1)) {\r\n        kt = stdMap.get(num1);\r\n    } else if (finMap.containsKey(last)) {\r\n        kt = finMap.get(last);\r\n        if (first == 'O' && last >= 'A' && last <= 'D') {\r\n            bPuttyCtrl = true;\r\n        }\r\n    } else {\r\n        kt = null;\r\n    }\r\n    int mods = num2 - 1;\r\n    if (bEsc) {\r\n        if (mods >= 0) {\r\n            mods |= ALT;\r\n        } else {\r\n            mods = ALT;\r\n        }\r\n    }\r\n    if (bPuttyCtrl) {\r\n        if (mods >= 0) {\r\n            mods |= CTRL;\r\n        } else {\r\n            mods = CTRL;\r\n        }\r\n    }\r\n    return getKeyStroke(kt, mods);\r\n}"
}, {
	"Path": "com.drew.metadata.Metadata.getDirectoryCount",
	"Comment": "returns the count of directories in this metadata collection.",
	"Method": "int getDirectoryCount(){\r\n    return _directories.size();\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.TerminalEmulatorDeviceConfiguration.withCursorStyle",
	"Comment": "copies the current configuration. the new object has the given value.",
	"Method": "TerminalEmulatorDeviceConfiguration withCursorStyle(CursorStyle cursorStyle){\r\n    if (this.cursorStyle == cursorStyle) {\r\n        return this;\r\n    } else {\r\n        return new TerminalEmulatorDeviceConfiguration(this.lineBufferScrollbackSize, this.blinkLengthInMilliSeconds, cursorStyle, this.cursorColor, this.cursorBlinking, this.clipboardAvailable);\r\n    }\r\n}"
}, {
	"Path": "org.jupiter.serialization.proto.io.VarInts.computeRawVarInt64Size",
	"Comment": "compute the number of bytes that would be needed to encode a varint.",
	"Method": "int computeRawVarInt64Size(long value){\r\n    if ((value & (~0L << 7)) == 0L) {\r\n        return 1;\r\n    }\r\n    if (value < 0L) {\r\n        return 10;\r\n    }\r\n    int n = 2;\r\n    if ((value & (~0L << 35)) != 0L) {\r\n        n += 4;\r\n        value >>>= 28;\r\n    }\r\n    if ((value & (~0L << 21)) != 0L) {\r\n        n += 2;\r\n        value >>>= 14;\r\n    }\r\n    if ((value & (~0L << 14)) != 0L) {\r\n        n += 1;\r\n    }\r\n    return n;\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.config.MeterFilter.renameTag",
	"Comment": "rename a tag key for every metric beginning with a given prefix.",
	"Method": "MeterFilter renameTag(String meterNamePrefix,String fromTagKey,String toTagKey){\r\n    return new MeterFilter() {\r\n        @Override\r\n        public Meter.Id map(Meter.Id id) {\r\n            if (!id.getName().startsWith(meterNamePrefix))\r\n                return id;\r\n            List<Tag> tags = new ArrayList();\r\n            for (Tag tag : id.getTagsAsIterable()) {\r\n                if (tag.getKey().equals(fromTagKey))\r\n                    tags.add(Tag.of(toTagKey, tag.getValue()));\r\n                else\r\n                    tags.add(tag);\r\n            }\r\n            return id.replaceTags(tags);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.config.MeterFilter.renameTag",
	"Comment": "rename a tag key for every metric beginning with a given prefix.",
	"Method": "MeterFilter renameTag(String meterNamePrefix,String fromTagKey,String toTagKey){\r\n    if (!id.getName().startsWith(meterNamePrefix))\r\n        return id;\r\n    List<Tag> tags = new ArrayList();\r\n    for (Tag tag : id.getTagsAsIterable()) {\r\n        if (tag.getKey().equals(fromTagKey))\r\n            tags.add(Tag.of(toTagKey, tag.getValue()));\r\n        else\r\n            tags.add(tag);\r\n    }\r\n    return id.replaceTags(tags);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.emailListener.EmailListener.getPassword",
	"Comment": "returns the password to use to connect to the imap server. a null value means thatthis property needs to be configured to be used.",
	"Method": "String getPassword(){\r\n    return JiveGlobals.getProperty(\"plugin.email.listener.password\");\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.TrafficMonitor.isReadEnabled",
	"Comment": "returns true if packets that were received will be printed to the console.",
	"Method": "boolean isReadEnabled(){\r\n    return readEnabled;\r\n}"
}, {
	"Path": "com.drew.lang.SequentialReader.getS15Fixed16",
	"Comment": "gets a s15.16 fixed point float from the buffer.this particular fixed point encoding has one sign bit, 15 numerator bits and 16 denominator bits.",
	"Method": "float getS15Fixed16(){\r\n    if (_isMotorolaByteOrder) {\r\n        float res = (getByte() & 0xFF) << 8 | (getByte() & 0xFF);\r\n        int d = (getByte() & 0xFF) << 8 | (getByte() & 0xFF);\r\n        return (float) (res + d / 65536.0);\r\n    } else {\r\n        int d = (getByte() & 0xFF) | (getByte() & 0xFF) << 8;\r\n        float res = (getByte() & 0xFF) | (getByte() & 0xFF) << 8;\r\n        return (float) (res + d / 65536.0);\r\n    }\r\n}"
}, {
	"Path": "com.drew.metadata.exif.GpsDirectory.getGpsDate",
	"Comment": "parses the date stamp tag and the time stamp tag to obtain a single date object representing thedate and time when this image was captured.",
	"Method": "Date getGpsDate(){\r\n    String date = getString(TAG_DATE_STAMP);\r\n    Rational[] timeComponents = getRationalArray(TAG_TIME_STAMP);\r\n    if (date == null)\r\n        return null;\r\n    if (timeComponents == null || timeComponents.length != 3)\r\n        return null;\r\n    String dateTime = String.format(Locale.US, \"%s d:d:.3f UTC\", date, timeComponents[0].intValue(), timeComponents[1].intValue(), timeComponents[2].doubleValue());\r\n    try {\r\n        DateFormat parser = new SimpleDateFormat(\"yyyy:MM:dd HH:mm:ss.S z\");\r\n        return parser.parse(dateTime);\r\n    } catch (ParseException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.table.Table.getVisibleColumns",
	"Comment": "returns the number of columns this table will show. if there are more columns in the table model, a scrollbarwill be used to allow the user to scroll left and right and view all columns.",
	"Method": "int getVisibleColumns(){\r\n    return visibleColumns;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getSendInvitationQuestion",
	"Comment": "returns the message to send to the user asking if he wants to receive again the roominvitation.",
	"Method": "String getSendInvitationQuestion(){\r\n    return settings.getChatSetting(KeyEnum.send_invitation_question).getValue();\r\n}"
}, {
	"Path": "com.drew.metadata.xmp.XmpReader.readJpegSegments",
	"Comment": "version specifically for dealing with xmp found in jpeg segments. this form of xmp has a peculiar preamble, whichmust be removed before parsing the xml.",
	"Method": "void readJpegSegments(Iterable<byte[]> segments,Metadata metadata,JpegSegmentType segmentType){\r\n    final int preambleLength = XMP_JPEG_PREAMBLE.length();\r\n    final int extensionPreambleLength = XMP_EXTENSION_JPEG_PREAMBLE.length();\r\n    String extendedXMPGUID = null;\r\n    byte[] extendedXMPBuffer = null;\r\n    for (byte[] segmentBytes : segments) {\r\n        if (segmentBytes.length >= preambleLength) {\r\n            if (XMP_JPEG_PREAMBLE.equalsIgnoreCase(new String(segmentBytes, 0, preambleLength)) || \"XMP\".equalsIgnoreCase(new String(segmentBytes, 0, 3))) {\r\n                byte[] xmlBytes = new byte[segmentBytes.length - preambleLength];\r\n                System.arraycopy(segmentBytes, preambleLength, xmlBytes, 0, xmlBytes.length);\r\n                extract(xmlBytes, metadata);\r\n                extendedXMPGUID = getExtendedXMPGUID(metadata);\r\n                continue;\r\n            }\r\n        }\r\n        if (extendedXMPGUID != null && segmentBytes.length >= extensionPreambleLength && XMP_EXTENSION_JPEG_PREAMBLE.equalsIgnoreCase(new String(segmentBytes, 0, extensionPreambleLength))) {\r\n            extendedXMPBuffer = processExtendedXMPChunk(metadata, segmentBytes, extendedXMPGUID, extendedXMPBuffer);\r\n        }\r\n    }\r\n    if (extendedXMPBuffer != null) {\r\n        extract(extendedXMPBuffer, metadata);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.sessions.TransportSessionManager.getNumberOfActiveSessionsFor",
	"Comment": "returns number of active sessions for specified transport or 0 if not valid transport.",
	"Method": "int getNumberOfActiveSessionsFor(String transport){\r\n    if (transportSessions.containsKey(transport))\r\n        return transportSessions.get(transport).size();\r\n    return 0;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.TerminalEmulatorDeviceConfiguration.getDefault",
	"Comment": "this is a static reference to the default terminal device configuration. use this one if you are unsure.",
	"Method": "TerminalEmulatorDeviceConfiguration getDefault(){\r\n    return new TerminalEmulatorDeviceConfiguration();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.sessions.GojaraAdminManager.testAdminConfiguration",
	"Comment": "sends a testmessage to specified gateway, when a response gets intercepted we consider gateway configured",
	"Method": "void testAdminConfiguration(String gateway){\r\n    unconfiguredGateways.add(gateway);\r\n    Message message = generateCommand(gateway, \"config_check\");\r\n    message.setBody(\"status\");\r\n    router.route(message);\r\n    Log.info(\"Checking for admin configuration on \" + gateway);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterExternalizableUtil.readSerializableCollection",
	"Comment": "reads a collection of serializable objects and adds them to the collection passed as a parameter. thecollection passed as a parameter must be a collection and not a null value.",
	"Method": "int readSerializableCollection(DataInput in,Collection<? extends Serializable> value,ClassLoader loader){\r\n    Collection<Serializable> result = (Collection<Serializable>) readObject(in);\r\n    if (result == null)\r\n        return 0;\r\n    ((Collection<Serializable>) value).addAll(result);\r\n    return result.size();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.SparkManager.notifyDiscoInfoChanged",
	"Comment": "notify all users who have requested disco information from this component that settings have been changed.clients should perform a new service discovery to see what has changed.",
	"Method": "void notifyDiscoInfoChanged(){\r\n    final Message message = new Message();\r\n    message.setFrom(serviceName + \".\" + componentManager.getServerName());\r\n    Element child = message.addChildElement(\"event\", \"http://jabber.org/protocol/disco#info\");\r\n    buildFeatureSet(child);\r\n    sessionManager.broadcast(message);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.table.Table.setVisibleRows",
	"Comment": "sets the number of rows this table will show. if there are more rows in the table model, a scrollbar will be usedto allow the user to scroll up and down and view all rows.",
	"Method": "void setVisibleRows(int visibleRows){\r\n    this.visibleRows = visibleRows;\r\n    invalidate();\r\n}"
}, {
	"Path": "io.micrometer.spring.autoconfigure.ServiceLevelAgreementBoundary.getValue",
	"Comment": "return the underlying value of the sla in form suitable to apply to the given metertype.",
	"Method": "Long getValue(Meter.Type meterType){\r\n    return this.value.getValue(meterType);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.PacketRejectedException.setRejectionMessage",
	"Comment": "sets the text to include in a message that will be sent to the sender of the packetthat got rejected or null if no message will be sent to the sender of therejected packet. bt default, no message will be sent.",
	"Method": "void setRejectionMessage(String rejectionMessage){\r\n    this.rejectionMessage = rejectionMessage;\r\n}"
}, {
	"Path": "io.micrometer.spring.autoconfigure.CompositeMeterRegistryConfigurationDefaultSimpleRegistryTest.simpleWithNoCompositeCreated",
	"Comment": "the simple registry is off by default unless there is no other registry implementation onthe classpath, in which case it is on.",
	"Method": "void simpleWithNoCompositeCreated(){\r\n    assertThat(registry).isInstanceOf(SimpleMeterRegistry.class);\r\n}"
}, {
	"Path": "org.jdbi.v3.testing.JdbiRule.migrateWithFlyway",
	"Comment": "run database migration scripts from the given locations on the classpath, using flyway.",
	"Method": "JdbiRule migrateWithFlyway(JdbiRule migrateWithFlyway,String locations){\r\n    return withMigration(Migration.before().withPaths(locations));\r\n}"
}, {
	"Path": "kilim.Mailbox.putnb",
	"Comment": "attempt to put a message, and return true if successful. the thread is not blocked, nor is the taskpaused under any circumstance.",
	"Method": "boolean putnb(T msg){\r\n    return put(msg, null);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.bundle.BundleLocator.getBundle",
	"Comment": "gets the right bundle.a cache is handled as well as the concurrent accesses.",
	"Method": "ResourceBundle getBundle(Locale locale){\r\n    return ResourceBundle.getBundle(bundleName, locale, loader, new UTF8Control());\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TerminalSize.min",
	"Comment": "takes a different terminalsize and returns a new terminalsize that has the smallest dimensions of the two,measured separately. so calling 3x5 on a 5x3 will return 3x3.",
	"Method": "TerminalSize min(TerminalSize other){\r\n    return withColumns(Math.min(columns, other.columns)).withRows(Math.min(rows, other.rows));\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.config.MeterFilter.maximumAllowableTags",
	"Comment": "places an upper bound on the number of tags produced by matching metrics.",
	"Method": "MeterFilter maximumAllowableTags(String meterNamePrefix,String tagKey,int maximumTagValues,MeterFilter onMaxReached){\r\n    return new MeterFilter() {\r\n        private final Set<String> observedTagValues = new ConcurrentSkipListSet();\r\n        @Override\r\n        public MeterFilterReply accept(Meter.Id id) {\r\n            String value = matchNameAndGetTagValue(id);\r\n            if (value != null) {\r\n                if (!observedTagValues.contains(value)) {\r\n                    if (observedTagValues.size() >= maximumTagValues) {\r\n                        return onMaxReached.accept(id);\r\n                    }\r\n                    observedTagValues.add(value);\r\n                }\r\n            }\r\n            return MeterFilterReply.NEUTRAL;\r\n        }\r\n        @Nullable\r\n        private String matchNameAndGetTagValue(Meter.Id id) {\r\n            return id.getName().startsWith(meterNamePrefix) ? id.getTag(tagKey) : null;\r\n        }\r\n        @Override\r\n        public DistributionStatisticConfig configure(Meter.Id id, DistributionStatisticConfig config) {\r\n            String value = matchNameAndGetTagValue(id);\r\n            if (value != null) {\r\n                if (!observedTagValues.contains(value)) {\r\n                    if (observedTagValues.size() >= maximumTagValues) {\r\n                        return onMaxReached.configure(id, config);\r\n                    }\r\n                }\r\n            }\r\n            return config;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.config.MeterFilter.maximumAllowableTags",
	"Comment": "places an upper bound on the number of tags produced by matching metrics.",
	"Method": "MeterFilter maximumAllowableTags(String meterNamePrefix,String tagKey,int maximumTagValues,MeterFilter onMaxReached){\r\n    String value = matchNameAndGetTagValue(id);\r\n    if (value != null) {\r\n        if (!observedTagValues.contains(value)) {\r\n            if (observedTagValues.size() >= maximumTagValues) {\r\n                return onMaxReached.accept(id);\r\n            }\r\n            observedTagValues.add(value);\r\n        }\r\n    }\r\n    return MeterFilterReply.NEUTRAL;\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.config.MeterFilter.maximumAllowableTags",
	"Comment": "places an upper bound on the number of tags produced by matching metrics.",
	"Method": "MeterFilter maximumAllowableTags(String meterNamePrefix,String tagKey,int maximumTagValues,MeterFilter onMaxReached){\r\n    return id.getName().startsWith(meterNamePrefix) ? id.getTag(tagKey) : null;\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.config.MeterFilter.maximumAllowableTags",
	"Comment": "places an upper bound on the number of tags produced by matching metrics.",
	"Method": "MeterFilter maximumAllowableTags(String meterNamePrefix,String tagKey,int maximumTagValues,MeterFilter onMaxReached){\r\n    String value = matchNameAndGetTagValue(id);\r\n    if (value != null) {\r\n        if (!observedTagValues.contains(value)) {\r\n            if (observedTagValues.size() >= maximumTagValues) {\r\n                return onMaxReached.configure(id, config);\r\n            }\r\n        }\r\n    }\r\n    return config;\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocketFrame.setPayload",
	"Comment": "set the unmasked payload.note that the payload length of a control frame must be 125 bytes or less.",
	"Method": "WebSocketFrame setPayload(byte[] payload,WebSocketFrame setPayload,String payload){\r\n    if (payload == null || payload.length() == 0) {\r\n        return setPayload((byte[]) null);\r\n    }\r\n    return setPayload(Misc.getBytesUTF8(payload));\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.Gauge.builder",
	"Comment": "a convenience method for building a gauge from a supplying function, holding a strongreference to this function.",
	"Method": "Builder<T> builder(String name,T obj,ToDoubleFunction<T> f,Builder<Supplier<Number>> builder,String name,Supplier<Number> f){\r\n    return new Builder(name, f, f2 -> {\r\n        Number val = f2.get();\r\n        return val == null ? Double.NaN : val.doubleValue();\r\n    }).strongReference(true);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.sessions.GojaraAdminManager.getStatisticsPresentationString",
	"Comment": "preps the specified stat for nicer output which is used in tables.",
	"Method": "String getStatisticsPresentationString(String gateway,String stat){\r\n    if (gatewayStatisticsMap.containsKey(gateway)) {\r\n        if (stat.equals(\"uptime\")) {\r\n            if (gatewayStatisticsMap.get(gateway).get(\"uptime\") != null) {\r\n                int time = gatewayStatisticsMap.get(gateway).get(\"uptime\");\r\n                long diffSeconds = time % 60;\r\n                long diffMinutes = time / 60 % 60;\r\n                long diffHours = time / (60 * 60) % 24;\r\n                long diffDays = time / (24 * 60 * 60);\r\n                String seconds = diffSeconds == 0 ? \"\" : (diffSeconds + \" Sec\");\r\n                String minutes = diffMinutes == 0 ? \"\" : (diffMinutes + \" Min \");\r\n                String hours = diffHours == 0 ? \"\" : (diffHours + \" Hours \");\r\n                String days = diffDays == 0 ? \"\" : (diffDays + \" Days \");\r\n                return days + hours + minutes + seconds;\r\n            }\r\n        } else if (stat.equals(\"messages_from_xmpp\")) {\r\n            if (gatewayStatisticsMap.get(gateway).get(\"messages_from_xmpp\") != null)\r\n                return \"\" + gatewayStatisticsMap.get(gateway).get(\"messages_from_xmpp\");\r\n        } else if (stat.equals(\"messages_to_xmpp\")) {\r\n            if (gatewayStatisticsMap.get(gateway).get(\"messages_to_xmpp\") != null)\r\n                return \"\" + gatewayStatisticsMap.get(gateway).get(\"messages_to_xmpp\");\r\n        } else if (stat.equals(\"used_memory\")) {\r\n            if (gatewayStatisticsMap.get(gateway).get(\"used_memory\") != null) {\r\n                DecimalFormat f = new DecimalFormat(\"#0.00\");\r\n                double mb = gatewayStatisticsMap.get(gateway).get(\"used_memory\") / 1024.0;\r\n                return \"\" + f.format(mb) + \" MB\";\r\n            }\r\n        } else if (stat.equals(\"average_memory_per_user\")) {\r\n            if (gatewayStatisticsMap.get(gateway).get(\"average_memory_per_user\") != null) {\r\n                return \"\" + gatewayStatisticsMap.get(gateway).get(\"average_memory_per_user\") + \" KB\";\r\n            }\r\n        }\r\n    }\r\n    return \"-\";\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Offer.isOutstanding",
	"Comment": "returns true if the offer is still outstanding. an offer is considered outstanding if it hasnot been cancelled and an invitation was not yet sent to an agent.",
	"Method": "boolean isOutstanding(){\r\n    return !cancelled && !invitationSent;\r\n}"
}, {
	"Path": "org.junit.jupiter.engine.execution.ExecutableInvoker.invoke",
	"Comment": "invoke the supplied method on the supplied target object with dynamic parameter\tresolution.",
	"Method": "T invoke(Constructor<T> constructor,ExtensionContext extensionContext,ExtensionRegistry extensionRegistry,T invoke,Constructor<T> constructor,Object outerInstance,ExtensionContext extensionContext,ExtensionRegistry extensionRegistry,Object invoke,Method method,ExtensionContext extensionContext,ExtensionRegistry extensionRegistry,Object invoke,Method method,Object target,ExtensionContext extensionContext,ExtensionRegistry extensionRegistry){\r\n    @SuppressWarnings(\"unchecked\")\r\n    Optional<Object> optionalTarget = (target instanceof Optional ? (Optional<Object>) target : Optional.ofNullable(target));\r\n    return ReflectionUtils.invokeMethod(method, target, resolveParameters(method, optionalTarget, extensionContext, extensionRegistry));\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.GraphicalTerminalImplementation.clearBackBuffer",
	"Comment": "clears out the back buffer and the resets the visual state so next paint operation will do a full repaint ofeverything",
	"Method": "void clearBackBuffer(){\r\n    if (backbuffer != null) {\r\n        Graphics2D graphics = backbuffer.createGraphics();\r\n        Color backgroundColor = colorConfiguration.toAWTColor(TextColor.ANSI.DEFAULT, false, false);\r\n        graphics.setColor(backgroundColor);\r\n        graphics.fillRect(0, 0, getWidth(), getHeight());\r\n        graphics.dispose();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ConversationManager.isConversation",
	"Comment": "returns true if the specified message should be processed by the conversation manager. only messages between two users, group chats, orgateways are processed.",
	"Method": "boolean isConversation(Message message){\r\n    if (Message.Type.normal == message.getType() || Message.Type.chat == message.getType()) {\r\n        return isConversationJID(message.getFrom()) && isConversationJID(message.getTo());\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getPositionMessage",
	"Comment": "returns the message that informs the user his position in the waiting queue.",
	"Method": "String getPositionMessage(){\r\n    return settings.getChatSetting(KeyEnum.position_message).getValue();\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.Label.splitIntoMultipleLines",
	"Comment": "utility method for taking a string and turning it into an array of lines. this method is used in order to dealwith line endings consistently.",
	"Method": "String[] splitIntoMultipleLines(String text){\r\n    return text.replace(\"\\r\", \"\").split(\"\\n\");\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.request.Request.getJoinedRoomTime",
	"Comment": "returns the date when the user joined the room to have a chat with an agent. or answernull if the user never joined a chat room.",
	"Method": "Date getJoinedRoomTime(){\r\n    if (joinedRoom > 0) {\r\n        return new Date(joinedRoom);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.junit.platform.commons.util.ClasspathScanner.findClassesForUris",
	"Comment": "recursively scan for classes in all of the supplied source directories.",
	"Method": "List<Class<?>> findClassesForUris(List<URI> baseUris,String basePackageName,ClassFilter classFilter){\r\n    return baseUris.stream().map(baseUri -> findClassesForUri(baseUri, basePackageName, classFilter)).flatMap(Collection::stream).distinct().collect(toList());\r\n}"
}, {
	"Path": "com.googlecode.lanterna.input.MouseAction.getPosition",
	"Comment": "the location of the mouse cursor when this event was generated.",
	"Method": "TerminalPosition getPosition(){\r\n    return position;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ConversationManager.processRoomMessage",
	"Comment": "processes an incoming message sent to a room. the message will mapped to a conversation and then queued for storage if archiving is turned on.",
	"Method": "void processRoomMessage(JID roomJID,JID sender,String nickname,String body,String stanza,Date date){\r\n    String conversationKey = getRoomConversationKey(roomJID);\r\n    synchronized (conversationKey.intern()) {\r\n        Conversation conversation = conversations.get(conversationKey);\r\n        if (conversation == null) {\r\n            Date start = new Date(date.getTime() - 1);\r\n            conversation = new Conversation(this, roomJID, false, start);\r\n            conversations.put(conversationKey, conversation);\r\n            for (ConversationListener listener : conversationListeners) {\r\n                listener.conversationCreated(conversation);\r\n            }\r\n        } else if ((date.getTime() - conversation.getLastActivity().getTime() > idleTime) || (date.getTime() - conversation.getStartDate().getTime() > maxTime)) {\r\n            removeConversation(conversationKey, conversation, conversation.getLastActivity());\r\n            Date start = new Date(date.getTime() - 1);\r\n            conversation = new Conversation(this, roomJID, false, start);\r\n            conversations.put(conversationKey, conversation);\r\n            for (ConversationListener listener : conversationListeners) {\r\n                listener.conversationCreated(conversation);\r\n            }\r\n        }\r\n        conversation.messageReceived(sender, date);\r\n        if (metadataArchivingEnabled) {\r\n            conversationQueue.add(new ArchiveCandidate(conversation));\r\n        }\r\n        if (roomArchivingEnabled && (roomsArchived.isEmpty() || roomsArchived.contains(roomJID.getNode()))) {\r\n            JID jid = new JID(roomJID + \"/\" + nickname);\r\n            if (body != null) {\r\n                messageQueue.add(new ArchiveCandidate(new ArchivedMessage(conversation.getConversationID(), sender, jid, date, body, roomArchivingStanzasEnabled ? stanza : \"\", false)));\r\n            }\r\n        }\r\n        for (ConversationListener listener : conversationListeners) {\r\n            listener.conversationUpdated(conversation, date);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.TerminalEmulatorColorConfiguration.toAWTColor",
	"Comment": "given a textcolor and a hint as to if the color is to be used as foreground or not and if we currently havebold text enabled or not, it returns the closest awt color that matches this.",
	"Method": "Color toAWTColor(TextColor color,boolean isForeground,boolean inBoldContext){\r\n    if (color instanceof TextColor.ANSI) {\r\n        return colorPalette.get((TextColor.ANSI) color, isForeground, inBoldContext && useBrightColorsOnBold);\r\n    }\r\n    return color.toColor();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.search.ChatSearchManager.loadAnalyzer",
	"Comment": "load the search analyzer. a custom analyzer class will be used if it is defined.",
	"Method": "void loadAnalyzer(){\r\n    Analyzer analyzer = null;\r\n    String analyzerClass = null;\r\n    String words = null;\r\n    analyzerClass = workgroup.getProperties().getProperty(\"search.analyzer.className\");\r\n    if (analyzerClass != null) {\r\n        words = workgroup.getProperties().getProperty(\"search.analyzer.stopWordList\");\r\n    } else {\r\n        analyzerClass = getAnalyzerClass();\r\n        words = JiveGlobals.getProperty(\"workgroup.search.analyzer.stopWordList\");\r\n    }\r\n    List<String> stopWords = new ArrayList<String>();\r\n    if (words != null) {\r\n        StringTokenizer st = new StringTokenizer(words, \",\");\r\n        while (st.hasMoreTokens()) {\r\n            stopWords.add(st.nextToken().trim());\r\n        }\r\n    }\r\n    try {\r\n        analyzer = getAnalyzerInstance(analyzerClass, stopWords);\r\n    } catch (Exception e) {\r\n        Log.error(\"Error loading custom \" + \"search analyzer: \" + analyzerClass, e);\r\n    }\r\n    if (analyzer == null && stopWords.size() > 0) {\r\n        analyzer = new StandardAnalyzer(stopWords.toArray(new String[stopWords.size()]));\r\n    } else if (analyzer == null) {\r\n        analyzer = new StandardAnalyzer();\r\n    }\r\n    indexerAnalyzer = analyzer;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.Bookmark.getPropertyNames",
	"Comment": "returns an iterator for the names of the extended properties.",
	"Method": "Iterator<String> getPropertyNames(){\r\n    if (properties == null) {\r\n        loadPropertiesFromDb();\r\n    }\r\n    return Collections.unmodifiableSet(properties.keySet()).iterator();\r\n}"
}, {
	"Path": "com.drew.metadata.Directory.getObject",
	"Comment": "returns the object hashed for the particular tag type specified, if available.",
	"Method": "Object getObject(int tagType){\r\n    return _tagMap.get(Integer.valueOf(tagType));\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.broadcastPresence",
	"Comment": "broadcasts the presence of the workgroup to all users and agents of the workgroup.",
	"Method": "void broadcastPresence(){\r\n    TaskEngine.getInstance().submit(new Runnable() {\r\n        public void run() {\r\n            try {\r\n                Collection<AgentSession> sessions = getAgentSessions();\r\n                for (AgentSession session : sessions) {\r\n                    workgroupPresenceHandler.sendPresence(session.getJID());\r\n                }\r\n                Set<JID> jids = new HashSet<JID>();\r\n                for (AgentSession session : sessions) {\r\n                    jids.addAll(session.getUsersJID(Workgroup.this));\r\n                }\r\n                for (JID jid : jids) {\r\n                    workgroupPresenceHandler.sendPresence(jid);\r\n                }\r\n            } catch (Exception e) {\r\n                Log.error(\"Error broadcasting workgroup presence\", e);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.broadcastPresence",
	"Comment": "broadcasts the presence of the workgroup to all users and agents of the workgroup.",
	"Method": "void broadcastPresence(){\r\n    try {\r\n        Collection<AgentSession> sessions = getAgentSessions();\r\n        for (AgentSession session : sessions) {\r\n            workgroupPresenceHandler.sendPresence(session.getJID());\r\n        }\r\n        Set<JID> jids = new HashSet<JID>();\r\n        for (AgentSession session : sessions) {\r\n            jids.addAll(session.getUsersJID(Workgroup.this));\r\n        }\r\n        for (JID jid : jids) {\r\n            workgroupPresenceHandler.sendPresence(jid);\r\n        }\r\n    } catch (Exception e) {\r\n        Log.error(\"Error broadcasting workgroup presence\", e);\r\n    }\r\n}"
}, {
	"Path": "org.jdbi.v3.sqlobject.SqlObject.useHandle",
	"Comment": "a convenience function which manages the lifecycle of the handle associated to this sql object,and yields it to a consumer for use by clients.",
	"Method": "void useHandle(HandleConsumer<X> consumer){\r\n    consumer.useHandle(getHandle());\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getHelpHelpMessage",
	"Comment": "returns the message that describes the effect of running the help command.",
	"Method": "String getHelpHelpMessage(){\r\n    return settings.getChatSetting(KeyEnum.help_help_message).getValue();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.emailListener.EmailListener.getFrequency",
	"Comment": "returns the milliseconds to wait to check for new emails. this frequencyis used if the imap server does not support idle.",
	"Method": "int getFrequency(){\r\n    return JiveGlobals.getIntProperty(\"plugin.email.listener.frequency\", 5 * 60 * 1000);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.messagefilter.MainInterceptor.presencePush",
	"Comment": "just pushes a available presence, we need this for gajim client as it does not push available presence afterregistering we also wait a little so after register transport is on users roster. really didnt wanted this herebut doesnt really belong anywhere else",
	"Method": "void presencePush(JID to,JID from,int delay){\r\n    TimerTask pushPresenceTask = new TimerTask() {\r\n        @Override\r\n        public void run() {\r\n            PacketRouter router = server.getPacketRouter();\r\n            Packet presence = new Presence();\r\n            presence.setTo(to);\r\n            presence.setFrom(from);\r\n            router.route(presence);\r\n        }\r\n    };\r\n    Timer timer = new Timer();\r\n    timer.schedule(pushPresenceTask, delay);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.messagefilter.MainInterceptor.presencePush",
	"Comment": "just pushes a available presence, we need this for gajim client as it does not push available presence afterregistering we also wait a little so after register transport is on users roster. really didnt wanted this herebut doesnt really belong anywhere else",
	"Method": "void presencePush(JID to,JID from,int delay){\r\n    PacketRouter router = server.getPacketRouter();\r\n    Packet presence = new Presence();\r\n    presence.setTo(to);\r\n    presence.setFrom(from);\r\n    router.route(presence);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.request.UserRequest.getInvitationSentTime",
	"Comment": "returns the date when an invitation to join a room was sent to the user that made thisrequest. or answer null if an invitation was never sent.",
	"Method": "Date getInvitationSentTime(){\r\n    if (invitationSent > 0) {\r\n        return new Date(invitationSent);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.Huffman.createIntArray",
	"Comment": "create an array whose elements have the given initial value.",
	"Method": "int[] createIntArray(int size,int initialValue){\r\n    int[] array = new int[size];\r\n    for (int i = 0; i < size; ++i) {\r\n        array[i] = initialValue;\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.dispatcher.RoundRobinDispatcher.getAgentRejectionTimeout",
	"Comment": "returns the number of milliseconds to wait until expiring an agent rejection.",
	"Method": "long getAgentRejectionTimeout(){\r\n    return JiveGlobals.getIntProperty(\"xmpp.live.rejection.timeout\", 20000);\r\n}"
}, {
	"Path": "kilim.MailboxSPSC.putnb",
	"Comment": "attempt to put a message, and return true if successful. the thread is\tnot blocked, nor is the task paused under any circumstance.",
	"Method": "boolean putnb(T msg){\r\n    return put(msg, null);\r\n}"
}, {
	"Path": "org.jupiter.common.util.collection.LongObjectHashMap.removeAt",
	"Comment": "removes entry at the given index position. also performs opportunistic, incremental rehashingif necessary to not break conflict chains.",
	"Method": "boolean removeAt(int index){\r\n    --size;\r\n    keys[index] = 0;\r\n    values[index] = null;\r\n    int nextFree = index;\r\n    int i = probeNext(index);\r\n    for (V value = values[i]; value != null; value = values[i = probeNext(i)]) {\r\n        long key = keys[i];\r\n        int bucket = hashIndex(key);\r\n        if (i < bucket && (bucket <= nextFree || nextFree <= i) || bucket <= nextFree && nextFree <= i) {\r\n            keys[nextFree] = key;\r\n            values[nextFree] = value;\r\n            keys[i] = 0;\r\n            values[i] = null;\r\n            nextFree = i;\r\n        }\r\n    }\r\n    return nextFree != index;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.Bookmark.setUsers",
	"Comment": "sets the collection of usernames that have been assigned the bookmark.",
	"Method": "void setUsers(Collection<String> users){\r\n    this.users = users;\r\n    saveToDb();\r\n    insertBookmarkPermissions();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.BookmarkInterceptor.isBookmarkForJID",
	"Comment": "true if the specified bookmark should be appended to the users list ofbookmarks.",
	"Method": "boolean isBookmarkForJID(JID jid,Bookmark bookmark){\r\n    String username = jid.getNode();\r\n    if (bookmark.getUsers().contains(username)) {\r\n        return true;\r\n    }\r\n    Collection<String> groups = bookmark.getGroups();\r\n    if (groups != null && !groups.isEmpty()) {\r\n        GroupManager groupManager = GroupManager.getInstance();\r\n        for (String groupName : groups) {\r\n            try {\r\n                Group group = groupManager.getGroup(groupName);\r\n                if (group.isUser(jid.getNode())) {\r\n                    return true;\r\n                }\r\n            } catch (GroupNotFoundException e) {\r\n                Log.debug(e.getMessage(), e);\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.junit.platform.commons.util.ModuleUtils.getModuleVersion",
	"Comment": "return the raw version of the module that the class or interface is a member of.",
	"Method": "Optional<String> getModuleVersion(Class<?> type){\r\n    Preconditions.notNull(type, \"Class type must not be null\");\r\n    Module module = type.getModule();\r\n    return module.isNamed() ? module.getDescriptor().rawVersion() : Optional.empty();\r\n}"
}, {
	"Path": "org.jupiter.common.util.collection.IntObjectHashMap.removeAt",
	"Comment": "removes entry at the given index position. also performs opportunistic, incremental rehashingif necessary to not break conflict chains.",
	"Method": "boolean removeAt(int index){\r\n    --size;\r\n    keys[index] = 0;\r\n    values[index] = null;\r\n    int nextFree = index;\r\n    int i = probeNext(index);\r\n    for (V value = values[i]; value != null; value = values[i = probeNext(i)]) {\r\n        int key = keys[i];\r\n        int bucket = hashIndex(key);\r\n        if (i < bucket && (bucket <= nextFree || nextFree <= i) || bucket <= nextFree && nextFree <= i) {\r\n            keys[nextFree] = key;\r\n            values[nextFree] = value;\r\n            keys[i] = 0;\r\n            values[i] = null;\r\n            nextFree = i;\r\n        }\r\n    }\r\n    return nextFree != index;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.SimpleTerminalResizeListener.getLastKnownSize",
	"Comment": "returns the last known size the terminal is supposed to have.",
	"Method": "TerminalSize getLastKnownSize(){\r\n    return lastKnownSize;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.SwingTerminalFrame.addInput",
	"Comment": "takes a keystroke and puts it on the input queue of the terminal emulator. this way you can insert syntheticinput events to be processed as if they came from the user typing on the keyboard.",
	"Method": "void addInput(KeyStroke keyStroke){\r\n    swingTerminal.addInput(keyStroke);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterExternalizableUtil.readExternalizableCollection",
	"Comment": "reads a collection of externalizable objects and adds them to the collection passed as a parameter. thecollection passed as a parameter must be a collection and not a null value.",
	"Method": "int readExternalizableCollection(DataInput in,Collection<? extends Externalizable> value,ClassLoader loader){\r\n    Collection<Externalizable> result = (Collection<Externalizable>) readObject(in);\r\n    if (result == null)\r\n        return 0;\r\n    ((Collection<Externalizable>) value).addAll(result);\r\n    return result.size();\r\n}"
}, {
	"Path": "gab.opencv.OpenCV.brightness",
	"Comment": "adjust the brightness of the image. works on color or black and white images.",
	"Method": "void brightness(int amt){\r\n    Scalar modifier;\r\n    if (useColor) {\r\n        modifier = new Scalar(amt, amt, amt, 1);\r\n    } else {\r\n        modifier = new Scalar(amt);\r\n    }\r\n    Core.add(getCurrentMat(), modifier, getCurrentMat());\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TerminalTextUtils.isCharCJK",
	"Comment": "given a character, is this character considered to be a cjk character?shamelessly stolen fromstackoverflowwhere it was contributed by user rakesh n",
	"Method": "boolean isCharCJK(char c){\r\n    Character.UnicodeBlock unicodeBlock = Character.UnicodeBlock.of(c);\r\n    return (unicodeBlock == Character.UnicodeBlock.HIRAGANA) || (unicodeBlock == Character.UnicodeBlock.KATAKANA) || (unicodeBlock == Character.UnicodeBlock.KATAKANA_PHONETIC_EXTENSIONS) || (unicodeBlock == Character.UnicodeBlock.HANGUL_COMPATIBILITY_JAMO) || (unicodeBlock == Character.UnicodeBlock.HANGUL_JAMO) || (unicodeBlock == Character.UnicodeBlock.HANGUL_SYLLABLES) || (unicodeBlock == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS) || (unicodeBlock == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A) || (unicodeBlock == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B) || (unicodeBlock == Character.UnicodeBlock.CJK_COMPATIBILITY_FORMS) || (unicodeBlock == Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS) || (unicodeBlock == Character.UnicodeBlock.CJK_RADICALS_SUPPLEMENT) || (unicodeBlock == Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION) || (unicodeBlock == Character.UnicodeBlock.ENCLOSED_CJK_LETTERS_AND_MONTHS) || (unicodeBlock == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS && c < 0xFF61);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.screen.VirtualScreen.getViewportSize",
	"Comment": "returns the current size of the viewport. this will generally match the dimensions of the underlying terminal.",
	"Method": "TerminalSize getViewportSize(TerminalSize getViewportSize,TerminalSize realSize,TerminalSize virtualSize,TerminalSize getViewportSize,TerminalSize realSize,TerminalSize virtualSize){\r\n    return viewportSize;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.handleCommand",
	"Comment": "returns true if the message sent by the user requested to run a command. depending on thestage of the conversation different commands may be executed.",
	"Method": "boolean handleCommand(Message message,ChatbotSession session){\r\n    String command = message.getBody().trim();\r\n    if (getHelpCommand().equalsIgnoreCase(command)) {\r\n        sendHelpMessage(message);\r\n        return true;\r\n    } else if (getByeCommand().equalsIgnoreCase(command)) {\r\n        userDepartQueue(message);\r\n        return true;\r\n    }\r\n    if (session.getCurrentStep() == 1) {\r\n        if (getRepeatCommand().equalsIgnoreCase(command)) {\r\n            sendJoinQuestion(message, session);\r\n            return true;\r\n        } else if (getPositionCommand().equalsIgnoreCase(command)) {\r\n            sendReply(message, getNotInQueueMessage());\r\n            return true;\r\n        }\r\n    } else if (session.getCurrentStep() == 2) {\r\n        if (getBackCommand().equalsIgnoreCase(command)) {\r\n            sendPreviousQuestion(message, session);\r\n            return true;\r\n        } else if (getRepeatCommand().equalsIgnoreCase(command)) {\r\n            repeatQuestion(message, session);\r\n            return true;\r\n        } else if (getPositionCommand().equalsIgnoreCase(command)) {\r\n            sendReply(message, getNotInQueueMessage());\r\n            return true;\r\n        }\r\n    } else if (session.getCurrentStep() == 3) {\r\n        if (getPositionCommand().equalsIgnoreCase(command)) {\r\n            try {\r\n                UserRequest request = UserRequest.getRequest(workgroup, message.getFrom());\r\n                request.updateQueueStatus(true);\r\n            } catch (NotFoundException e) {\r\n                sendReply(message, getNotInQueueMessage());\r\n            }\r\n            return true;\r\n        }\r\n    } else if (session.getCurrentStep() == 6) {\r\n        if (getRepeatCommand().equalsIgnoreCase(command)) {\r\n            sendEmailQuestion(message.getFrom(), session);\r\n            return true;\r\n        }\r\n    } else if (session.getCurrentStep() == 7) {\r\n        if (getRepeatCommand().equalsIgnoreCase(command)) {\r\n            sendGetEmailQuestion(message, session);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.utils.JspHelper.sortingHelperRegistrations",
	"Comment": "create a link that leads to the same page, sorted by the attribute clicked on. the sorting order depends on thecurrent sorting order. if element is not the one currently sorted by, its always asc, else desc",
	"Method": "String sortingHelperRegistrations(String column,Map<String, String> sortParams){\r\n    String link_beginning = \"<a href=\\\"gojara-RegistrationsOverview.jsp?sortby=\";\r\n    return helpMe(column, sortParams, link_beginning);\r\n}"
}, {
	"Path": "io.micrometer.statsd.StatsdConfig.pollingFrequency",
	"Comment": "determines how often gauges will be polled. when a gauge is polled, its value is recalculated. if the value has changed,it is sent to the statsd server.",
	"Method": "Duration pollingFrequency(){\r\n    String v = get(prefix() + \".pollingFrequency\");\r\n    return v == null ? Duration.ofSeconds(10) : Duration.parse(v);\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.HostnameUnverifiedException.getSSLSocket",
	"Comment": "get the ssl socket against which the hostname verification failed.",
	"Method": "SSLSocket getSSLSocket(){\r\n    return mSSLSocket;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.ComboBox.setSelectedIndex",
	"Comment": "programmatically selects one item in the combo box, which causes the displayed text to change to match the labelof the selected index.",
	"Method": "void setSelectedIndex(int selectedIndex){\r\n    if (items.size() <= selectedIndex || selectedIndex < -1) {\r\n        throw new IndexOutOfBoundsException(\"Illegal argument to ComboBox.setSelectedIndex: \" + selectedIndex);\r\n    }\r\n    final int oldSelection = this.selectedIndex;\r\n    this.selectedIndex = selectedIndex;\r\n    if (selectedIndex == -1) {\r\n        updateText(\"\");\r\n    } else {\r\n        updateText(items.get(selectedIndex).toString());\r\n    }\r\n    runOnGUIThreadIfExistsOtherwiseRunDirect(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            for (Listener listener : listeners) {\r\n                listener.onSelectionChanged(selectedIndex, oldSelection);\r\n            }\r\n        }\r\n    });\r\n    invalidate();\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.ComboBox.setSelectedIndex",
	"Comment": "programmatically selects one item in the combo box, which causes the displayed text to change to match the labelof the selected index.",
	"Method": "void setSelectedIndex(int selectedIndex){\r\n    for (Listener listener : listeners) {\r\n        listener.onSelectionChanged(selectedIndex, oldSelection);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getByeCommand",
	"Comment": "returns the string that indicates that the user is closing the chat session no matterthe if he already joined a waiting queue or not. if the user joined a waiting queue thenthe user will leave the queue.",
	"Method": "String getByeCommand(){\r\n    return settings.getChatSetting(KeyEnum.bye_command).getValue();\r\n}"
}, {
	"Path": "kilim.test.Base.getBBForMethod",
	"Comment": "returns the first basic block in the flow that has a method invocation of",
	"Method": "BasicBlock getBBForMethod(MethodFlow flow,String methodName){\r\n    for (BasicBlock bb : flow.getBasicBlocks()) {\r\n        AbstractInsnNode ainode = bb.getInstruction(bb.startPos);\r\n        if (ainode instanceof MethodInsnNode && ((MethodInsnNode) ainode).name.equals(methodName)) {\r\n            return bb;\r\n        }\r\n    }\r\n    fail(\"No method invocation found for \" + methodName);\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ArchiveSearcher.databaseSearch",
	"Comment": "searches the database for all archived conversations using the specified search.",
	"Method": "Collection<Conversation> databaseSearch(ArchiveSearch search){\r\n    CachedPreparedStatement cachedPstmt = new CachedPreparedStatement();\r\n    StringBuilder query = new StringBuilder(160);\r\n    query.append(\"SELECT DISTINCT ofConversation.conversationID\");\r\n    Collection<JID> participants = search.getParticipants();\r\n    boolean filterParticipants = !participants.isEmpty();\r\n    boolean filterDate = search.getDateRangeMin() != null || search.getDateRangeMax() != null;\r\n    boolean filterTimestamp = search.getIncludeTimestamp() != null;\r\n    boolean filterRoom = search.getRoom() != null;\r\n    query.append(\", ofConversation.startDate\");\r\n    query.append(\" FROM ofConversation\");\r\n    if (filterParticipants) {\r\n        for (int i = 0; i < participants.size(); i++) {\r\n            query.append(\", ofConParticipant participant\").append(i);\r\n        }\r\n    }\r\n    boolean whereSet = false;\r\n    if (search.isExternalWildcardMode() && search.getParticipants().size() != 2) {\r\n        query.append(\" WHERE isExternal=?\");\r\n        cachedPstmt.addInt(1);\r\n        whereSet = true;\r\n    }\r\n    if (filterParticipants) {\r\n        Iterator<JID> iter = participants.iterator();\r\n        for (int i = 0; i < participants.size(); i++) {\r\n            if (!whereSet) {\r\n                query.append(\" WHERE\");\r\n                whereSet = true;\r\n            } else {\r\n                query.append(\" AND\");\r\n            }\r\n            query.append(\" ofConversation.conversationID=participant\").append(i).append(\".conversationID\");\r\n            query.append(\" AND \");\r\n            query.append(\"participant\").append(i).append(\".bareJID=?\");\r\n            String partJID = iter.next().toString();\r\n            cachedPstmt.addString(partJID);\r\n        }\r\n    }\r\n    if (filterDate) {\r\n        if (search.getDateRangeMin() != null) {\r\n            if (!whereSet) {\r\n                query.append(\" WHERE\");\r\n                whereSet = true;\r\n            } else {\r\n                query.append(\" AND\");\r\n            }\r\n            query.append(\" ofConversation.startDate >= ?\");\r\n            cachedPstmt.addLong(search.getDateRangeMin().getTime());\r\n        }\r\n        if (search.getDateRangeMax() != null) {\r\n            if (!whereSet) {\r\n                query.append(\" WHERE\");\r\n                whereSet = true;\r\n            } else {\r\n                query.append(\" AND\");\r\n            }\r\n            query.append(\" ofConversation.startDate <= ?\");\r\n            cachedPstmt.addLong(search.getDateRangeMax().getTime());\r\n        }\r\n    }\r\n    if (filterTimestamp) {\r\n        if (!whereSet) {\r\n            query.append(\" WHERE\");\r\n            whereSet = true;\r\n        } else {\r\n            query.append(\" AND\");\r\n        }\r\n        query.append(\" ofConversation.startDate <= ?\");\r\n        cachedPstmt.addLong(search.getIncludeTimestamp().getTime());\r\n        query.append(\" AND\");\r\n        query.append(\" ofConversation.lastActivity >= ?\");\r\n        cachedPstmt.addLong(search.getIncludeTimestamp().getTime());\r\n    }\r\n    if (filterRoom) {\r\n        if (!whereSet) {\r\n            query.append(\" WHERE\");\r\n            whereSet = true;\r\n        } else {\r\n            query.append(\" AND\");\r\n        }\r\n        query.append(\" ofConversation.room = ?\");\r\n        cachedPstmt.addString(search.getRoom().toString());\r\n    }\r\n    query.append(\" ORDER BY ofConversation.startDate\");\r\n    if (search.getSortOrder() == ArchiveSearch.SortOrder.descending) {\r\n        query.append(\" DESC\");\r\n    } else {\r\n        query.append(\" ASC\");\r\n    }\r\n    int startIndex = search.getStartIndex();\r\n    int numResults = search.getNumResults();\r\n    if (numResults != ArchiveSearch.NULL_INT) {\r\n        if (DbConnectionManager.getDatabaseType() == DbConnectionManager.DatabaseType.mysql) {\r\n            query.append(\" LIMIT \").append(startIndex).append(\",\").append(numResults);\r\n        } else if (DbConnectionManager.getDatabaseType() == DbConnectionManager.DatabaseType.postgresql) {\r\n            query.append(\" LIMIT \").append(numResults).append(\" OFFSET \").append(startIndex);\r\n        }\r\n    }\r\n    cachedPstmt.setSQL(query.toString());\r\n    List<Long> conversationIDs = new ArrayList<Long>();\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = DbConnectionManager.createScrollablePreparedStatement(con, cachedPstmt.getSQL());\r\n        cachedPstmt.setParams(pstmt);\r\n        if (DbConnectionManager.getDatabaseType() != DbConnectionManager.DatabaseType.mysql && DbConnectionManager.getDatabaseType() != DbConnectionManager.DatabaseType.postgresql) {\r\n            DbConnectionManager.setMaxRows(pstmt, startIndex + numResults);\r\n        }\r\n        ResultSet rs = pstmt.executeQuery();\r\n        if (DbConnectionManager.getDatabaseType() != DbConnectionManager.DatabaseType.mysql && DbConnectionManager.getDatabaseType() != DbConnectionManager.DatabaseType.postgresql) {\r\n            DbConnectionManager.scrollResultSet(rs, startIndex);\r\n        }\r\n        int count = 0;\r\n        while (rs.next() && count < numResults) {\r\n            conversationIDs.add(rs.getLong(1));\r\n            count++;\r\n        }\r\n        rs.close();\r\n    } catch (SQLException sqle) {\r\n        Log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n    return new DatabaseQueryResults(conversationIDs);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.ComboBox.getTextInputPosition",
	"Comment": "for writable combo boxes, this method returns the position where the text input cursor is right now. meaning, ifthe user types some character, where are those are going to be inserted in the string that is currentlydisplayed. if the text input position equals the size of the currently displayed text, new characters will beappended at the end. the user can usually move the text input position by using left and right arrow keys on thekeyboard.",
	"Method": "int getTextInputPosition(){\r\n    return textInputPosition;\r\n}"
}, {
	"Path": "kilim.Fiber.getCallee",
	"Comment": "called by the weaved code while rewinding the stack. if we are about tocall a virtual pausable method, we need an object reference on which tocall that method. the next state has that information in state.self",
	"Method": "Object getCallee(){\r\n    assert stateStack[iStack] != PAUSE_STATE : \"No callee: this state is the pause state\";\r\n    assert stateStack[iStack] != null : \"Callee is null\";\r\n    return stateStack[iStack + 1].self;\r\n}"
}, {
	"Path": "kilim.Task.fork",
	"Comment": "wraps the given object or lambda expression in a task and starts that task.beware of inadvertent sharing when multiple lambdas are created in the same context",
	"Method": "Task fork(Pausable.Fork body){\r\n    return new Fork(body).start();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getWelcomeMessage",
	"Comment": "returns the welcome message to send to the user after the user sent his first message.",
	"Method": "String getWelcomeMessage(){\r\n    return settings.getChatSetting(KeyEnum.welcome_message).getValue();\r\n}"
}, {
	"Path": "io.moquette.Utils.encodeFixedLengthContent",
	"Comment": "return the iobuffer with string encoded as msb, lsb and bytes array content.",
	"Method": "ByteBuf encodeFixedLengthContent(byte[] content){\r\n    ByteBuf out = Unpooled.buffer(2);\r\n    out.writeShort(content.length);\r\n    out.writeBytes(content);\r\n    return out;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterExternalizableUtil.readStringList",
	"Comment": "reads a list of strings. this method will return null if the listwritten to the stream was null.",
	"Method": "List<String> readStringList(DataInput in){\r\n    return (List<String>) readObject(in);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.sessions.TransportSessionManager.initializeSessions",
	"Comment": "initializes sessions through adminmanager, ofc needs to be called at a point where there are transports registered intransportsessions",
	"Method": "void initializeSessions(){\r\n    Log.info(\"Initializing Sessions.\");\r\n    for (String transport : transportSessions.keySet()) {\r\n        adminManager.getOnlineUsersOf(transport);\r\n    }\r\n}"
}, {
	"Path": "kilim.analysis.Frame.merge",
	"Comment": "merge the local variables and stack from the incoming frame into the current frame.",
	"Method": "Frame merge(Detector det,Frame inframe,boolean localsOnly,Usage usage){\r\n    int slen = stacklen;\r\n    Value[] nst = null;\r\n    if (!localsOnly) {\r\n        Value[] st = stack;\r\n        Value[] ist = inframe.stack;\r\n        for (int i = 0; i < slen; i++) {\r\n            Value va = st[i];\r\n            Value vb = ist[i];\r\n            if (va == vb || va.equals(vb))\r\n                continue;\r\n            Value newval = va.merge(det, vb);\r\n            if (newval != va) {\r\n                if (nst == null)\r\n                    nst = dupArray(st);\r\n                nst[i] = newval;\r\n            }\r\n        }\r\n    }\r\n    Value[] lo = locals;\r\n    Value[] ilo = inframe.locals;\r\n    Value[] nlo = null;\r\n    for (int i = 0; i < lo.length; i++) {\r\n        if (!usage.isLiveIn(i))\r\n            continue;\r\n        Value va = lo[i];\r\n        Value vb = ilo[i];\r\n        if (va == vb || va.equals(vb))\r\n            continue;\r\n        Value newval = va.merge(det, vb);\r\n        if (newval != va) {\r\n            if (nlo == null)\r\n                nlo = dupArray(lo);\r\n            nlo[i] = newval;\r\n        }\r\n    }\r\n    if (nst == null && nlo == null) {\r\n        return this;\r\n    } else {\r\n        if (nst == null)\r\n            nst = dupArray(stack);\r\n        if (nlo == null)\r\n            nlo = dupArray(locals);\r\n        return new Frame(nlo, nst, slen, numMonitorsActive);\r\n    }\r\n}"
}, {
	"Path": "org.jupiter.common.util.JvmTools.jMap",
	"Comment": "dumps the heap to the outputfile file in the same format as the hprof heap dump.",
	"Method": "void jMap(String outputFile,boolean live){\r\n    File file = new File(outputFile);\r\n    if (file.exists()) {\r\n        file.delete();\r\n    }\r\n    MXBeanHolder.hotSpotDiagnosticMxBean.dumpHeap(outputFile, live);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.BookmarkInterceptor.urlExists",
	"Comment": "checks if the bookmark has already been defined in the users private storage.",
	"Method": "Element urlExists(Element element,String url){\r\n    final Iterator<Element> urlBookmarks = element.elementIterator(\"url\");\r\n    while (urlBookmarks.hasNext()) {\r\n        Element urlElement = urlBookmarks.next();\r\n        String urlValue = urlElement.attributeValue(\"url\");\r\n        if (urlValue.equalsIgnoreCase(url)) {\r\n            return urlElement;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.fastpath.settings.chat.ChatSettingsManager.addChatSetting",
	"Comment": "adds a new chatsetting, persisting to the database and cache objects.",
	"Method": "void addChatSetting(ChatSetting settings){\r\n    Connection con;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        try {\r\n            pstmt = con.prepareStatement(INSERT_CHAT_SETTING);\r\n            pstmt.setString(1, settings.getWorkgroupNode());\r\n            pstmt.setInt(2, settings.getType().getType());\r\n            pstmt.setString(3, settings.getLabel());\r\n            pstmt.setString(4, settings.getDescription());\r\n            pstmt.setString(5, settings.getKey().toString());\r\n            DbConnectionManager.setLargeTextField(pstmt, 6, settings.getValue());\r\n            pstmt.setString(7, settings.getDefaultValue());\r\n            pstmt.executeUpdate();\r\n        } catch (Exception ex) {\r\n            Log.error(ex.getMessage(), ex);\r\n        } finally {\r\n            DbConnectionManager.closeConnection(pstmt, con);\r\n        }\r\n    } catch (Exception ex) {\r\n        Log.error(ex.getMessage(), ex);\r\n    }\r\n    ChatSettings chatSettings = cachedSettings.get(settings.getWorkgroupNode());\r\n    if (chatSettings != null) {\r\n        chatSettings.addChatSetting(settings);\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.DefaultTerminalFactory.setTerminalEmulatorTitle",
	"Comment": "sets the title to use on created swingterminalframes created by this factory",
	"Method": "DefaultTerminalFactory setTerminalEmulatorTitle(String title){\r\n    this.title = title;\r\n    return this;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.screen.VirtualScreen.getMinimumSize",
	"Comment": "returns the minimum size this virtual screen can have. if the real terminal is made smaller than this, thevirtual screen will draw scrollbars and implement scrolling",
	"Method": "TerminalSize getMinimumSize(){\r\n    return minimumSize;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.dispatcher.RoundRobinDispatcher.getOverflowTimes",
	"Comment": "returns the max number of times a request may overflow. once the request has exceded thisnumber it will be cancelled. this limit avoids infinite overflow loops.",
	"Method": "long getOverflowTimes(){\r\n    return JiveGlobals.getIntProperty(\"xmpp.live.request.overflow\", 3);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterExternalizableUtil.readLongArray",
	"Comment": "reads an array of long values. this method will return null ifthe array written to the stream was null.",
	"Method": "long[] readLongArray(DataInput in){\r\n    return (long[]) readObject(in);\r\n}"
}, {
	"Path": "org.jupiter.common.util.collection.IntObjectHashMap.indexOf",
	"Comment": "locates the index for the given key. this method probes using double hashing.",
	"Method": "int indexOf(int key){\r\n    int startIndex = hashIndex(key);\r\n    int index = startIndex;\r\n    for (; ; ) {\r\n        if (values[index] == null) {\r\n            return -1;\r\n        }\r\n        if (key == keys[index]) {\r\n            return index;\r\n        }\r\n        if ((index = probeNext(index)) == startIndex) {\r\n            return -1;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.TerminalEmulatorPalette.get",
	"Comment": "returns the awt color from this palette given an ansi color and two hints for if we are looking for a backgroundcolor and if we want to use the bright version.",
	"Method": "Color get(TextColor.ANSI color,boolean isForeground,boolean useBrightTones){\r\n    if (useBrightTones) {\r\n        switch(color) {\r\n            case BLACK:\r\n                return brightBlack;\r\n            case BLUE:\r\n                return brightBlue;\r\n            case CYAN:\r\n                return brightCyan;\r\n            case DEFAULT:\r\n                return isForeground ? defaultBrightColor : defaultBackgroundColor;\r\n            case GREEN:\r\n                return brightGreen;\r\n            case MAGENTA:\r\n                return brightMagenta;\r\n            case RED:\r\n                return brightRed;\r\n            case WHITE:\r\n                return brightWhite;\r\n            case YELLOW:\r\n                return brightYellow;\r\n        }\r\n    } else {\r\n        switch(color) {\r\n            case BLACK:\r\n                return normalBlack;\r\n            case BLUE:\r\n                return normalBlue;\r\n            case CYAN:\r\n                return normalCyan;\r\n            case DEFAULT:\r\n                return isForeground ? defaultColor : defaultBackgroundColor;\r\n            case GREEN:\r\n                return normalGreen;\r\n            case MAGENTA:\r\n                return normalMagenta;\r\n            case RED:\r\n                return normalRed;\r\n            case WHITE:\r\n                return normalWhite;\r\n            case YELLOW:\r\n                return normalYellow;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"Unknown text color \" + color);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TextCharacter.isBlinking",
	"Comment": "returns true if this textcharacter has the blink modifier active",
	"Method": "boolean isBlinking(){\r\n    return modifiers.contains(SGR.BLINK);\r\n}"
}, {
	"Path": "org.jupiter.common.util.collection.ByteObjectHashMap.growSize",
	"Comment": "grows the map size after an insertion. if necessary, performs a rehash of the map.",
	"Method": "void growSize(){\r\n    size++;\r\n    if (size > maxSize) {\r\n        if (keys.length == Integer.MAX_VALUE) {\r\n            throw new IllegalStateException(\"Max capacity reached at size=\" + size);\r\n        }\r\n        rehash(keys.length << 1);\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.DefaultTerminalFactory.setInitialTerminalSize",
	"Comment": "sets a hint to the terminalfactory of what size to use when creating the terminal. most terminals are not createdon request but for example the swingterminal and swingterminalframe are and this value will be passed down oncreation.",
	"Method": "DefaultTerminalFactory setInitialTerminalSize(TerminalSize initialTerminalSize){\r\n    this.initialTerminalSize = initialTerminalSize;\r\n    return this;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TextCharacter.isUnderlined",
	"Comment": "returns true if this textcharacter has the underline modifier active",
	"Method": "boolean isUnderlined(){\r\n    return modifiers.contains(SGR.UNDERLINE);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.table.TableModel.addListener",
	"Comment": "adds a listener to this table model that will be notified whenever the model changes",
	"Method": "TableModel<V> addListener(Listener<V> listener){\r\n    listeners.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.dialogs.FileDialogBuilder.isShowHiddenDirectories",
	"Comment": "checks if hidden files and directories will be visible in the dialog",
	"Method": "boolean isShowHiddenDirectories(){\r\n    return showHiddenDirectories;\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.config.MeterFilter.commonTags",
	"Comment": "add common tags that are applied to every meter created afterward.",
	"Method": "MeterFilter commonTags(Iterable<Tag> tags){\r\n    return new MeterFilter() {\r\n        @Override\r\n        public Meter.Id map(Meter.Id id) {\r\n            return id.withTags(Tags.concat(tags, id.getTagsAsIterable()));\r\n        }\r\n    };\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.config.MeterFilter.commonTags",
	"Comment": "add common tags that are applied to every meter created afterward.",
	"Method": "MeterFilter commonTags(Iterable<Tag> tags){\r\n    return id.withTags(Tags.concat(tags, id.getTagsAsIterable()));\r\n}"
}, {
	"Path": "org.junit.platform.engine.TestDescriptor.containsTests",
	"Comment": "determine if the supplied descriptor or any of its descendants contains\tany tests.",
	"Method": "boolean containsTests(TestDescriptor testDescriptor){\r\n    return testDescriptor.isTest() || testDescriptor.mayRegisterTests() || testDescriptor.getChildren().stream().anyMatch(TestDescriptor::containsTests);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.screen.AbstractScreen.addResizeRequest",
	"Comment": "tells this screen that the size has changed and it should, at next opportunity, resize itself and its buffers",
	"Method": "void addResizeRequest(TerminalSize newSize){\r\n    latestResizeRequest = newSize;\r\n}"
}, {
	"Path": "com.javamonitor.Collector.push",
	"Comment": "sign in with the collector server and ask for permission to sendstatistics.",
	"Method": "boolean push(Properties push,Properties request){\r\n    HttpURLConnection connection = null;\r\n    PrintStream out = null;\r\n    InputStream in = null;\r\n    try {\r\n        connection = (HttpURLConnection) pushUrl.openConnection(proxy);\r\n        connection.setRequestMethod(\"POST\");\r\n        connection.setDoOutput(true);\r\n        connection.setConnectTimeout(TWO_MINUTES);\r\n        connection.setReadTimeout(TWO_MINUTES);\r\n        connection.setRequestProperty(\"Connection\", \"close\");\r\n        out = new PrintStream(connection.getOutputStream());\r\n        request.storeToXML(out, null);\r\n        out.flush();\r\n        in = connection.getInputStream();\r\n        final Properties response = new Properties();\r\n        response.loadFromXML(in);\r\n        return response;\r\n    } finally {\r\n        if (in != null) {\r\n            try {\r\n                in.close();\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        if (out != null) {\r\n            try {\r\n                out.close();\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        if (connection != null) {\r\n            try {\r\n                connection.disconnect();\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.javamonitor.JmxHelper.registerCoolMBeans",
	"Comment": "register the cool beans we need to find our way in the jmx jungle.",
	"Method": "void registerCoolMBeans(Server server){\r\n    register(server, serverObjectName);\r\n    register(new Threading(), Threading.objectName);\r\n    register(new DNSCachePolicy(), DNSCachePolicy.objectName);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TextCharacter.isItalic",
	"Comment": "returns true if this textcharacter has the italic modifier active",
	"Method": "boolean isItalic(){\r\n    return modifiers.contains(SGR.ITALIC);\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.binder.kafka.KafkaConsumerMetrics.registerNotificationListener",
	"Comment": "this notification listener should remain indefinitely since new kafka consumers can be added at any time.",
	"Method": "void registerNotificationListener(String type,BiConsumer<ObjectName, Tags> perObject){\r\n    NotificationListener notificationListener = (notification, handback) -> {\r\n        MBeanServerNotification mbs = (MBeanServerNotification) notification;\r\n        ObjectName o = mbs.getMBeanName();\r\n        perObject.accept(o, Tags.concat(tags, nameTag(o)));\r\n    };\r\n    NotificationFilter filter = (NotificationFilter) notification -> {\r\n        if (!MBeanServerNotification.REGISTRATION_NOTIFICATION.equals(notification.getType()))\r\n            return false;\r\n        ObjectName obj = ((MBeanServerNotification) notification).getMBeanName();\r\n        return obj.getDomain().equals(JMX_DOMAIN) && obj.getKeyProperty(\"type\").equals(type) && obj.getKeyProperty(\"partition\") == null && obj.getKeyProperty(\"topic\") == null;\r\n    };\r\n    try {\r\n        mBeanServer.addNotificationListener(MBeanServerDelegate.DELEGATE_NAME, notificationListener, filter, null);\r\n    } catch (InstanceNotFoundException e) {\r\n        throw new RuntimeException(\"Error registering Kafka MBean listener\", e);\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TerminalSize.max",
	"Comment": "takes a different terminalsize and returns a new terminalsize that has the largest dimensions of the two,measured separately. so calling 3x5 on a 5x3 will return 5x5.",
	"Method": "TerminalSize max(TerminalSize other){\r\n    return withColumns(Math.max(columns, other.columns)).withRows(Math.max(rows, other.rows));\r\n}"
}, {
	"Path": "kilim.examples.Spawn.exampleUsage",
	"Comment": "an example showing pausable chaining with exception inference",
	"Method": "void exampleUsage(){\r\n    Pausable.apply(new Task.Spawn(), t -> t.start(), t -> {\r\n        throw new java.io.EOFException();\r\n    }, t -> {\r\n        throw new java.io.IOException();\r\n    });\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TerminalTextUtils.getANSIControlSequenceAt",
	"Comment": "given a string and an index in that string, returns the ansi control sequence beginning on this index. if thereis no control sequence starting there, the method will return null. the returned value is the complete escapesequence including the esc prefix.",
	"Method": "String getANSIControlSequenceAt(String string,int index){\r\n    int len = getANSIControlSequenceLength(string, index);\r\n    return len == 0 ? null : string.substring(index, index + len);\r\n}"
}, {
	"Path": "kilim.WeavingClassLoader.exclude",
	"Comment": "replace the exclude filter which determines whether a named class should be defineddefinitively by this loader or instead delegated to the parent loader.this is sometimes necessary to work with classes that may have been previously loaded,eg because they were used as a java agent",
	"Method": "WeavingClassLoader exclude(Excludable exclude){\r\n    checker = exclude;\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.RequestQueue.getMembers",
	"Comment": "returns members belong to this requestqueue. note, members does not includeusers belonging to groups.",
	"Method": "Collection<Agent> getMembers(){\r\n    final Set<Agent> agentList = new HashSet<Agent>(agents);\r\n    return Collections.unmodifiableCollection(agentList);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.request.UserRequest.supportEnded",
	"Comment": "notification message saying that the support session has finished. at this point all roomoccupants have left the room.",
	"Method": "void supportEnded(){\r\n    communicationMethod.supportEnded(this);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ArchiveSearch.setRoom",
	"Comment": "sets the jid of the room for conversations that will be returned by the search. ifthis value has not been set, the method will return null.",
	"Method": "void setRoom(JID room){\r\n    this.room = room;\r\n}"
}, {
	"Path": "com.alicp.jetcache.Cache.removeAll",
	"Comment": "removes entries for the specified keys.if error occurs during cache access, the method will not throw an exception.if the implementation supports asynchronous operation, the cache operation of this method is asynchronous.",
	"Method": "void removeAll(Set<? extends K> keys){\r\n    REMOVE_ALL(keys);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.request.UserRequest.updateQueueStatus",
	"Comment": "update the current position of the user in the queue. this will sendthe packet directly to the user.",
	"Method": "void updateQueueStatus(boolean isPolling){\r\n    try {\r\n        communicationMethod.notifyQueueStatus(workgroup.getJID(), userJID, this, isPolling);\r\n    } catch (Exception e) {\r\n        Log.error(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "com.github.neuralnetworks.samples.test.XorTest.testMLPSigmoidBPSoftmax",
	"Comment": "simple xor backpropagation test with 2 unit softmax output layer",
	"Method": "void testMLPSigmoidBPSoftmax(){\r\n    SimpleInputProvider input = new SimpleInputProvider(new float[][] { { 0, 0 }, { 0, 1 }, { 1, 0 }, { 1, 1 } }, new float[][] { { 0, 1 }, { 1, 0 }, { 1, 0 }, { 0, 1 } });\r\n    SimpleInputProvider inputTest = new SimpleInputProvider(new float[][] { { 0, 0 }, { 0, 1 }, { 1, 0 }, { 1, 1 } }, new float[][] { { 0, 1 }, { 1, 0 }, { 1, 0 }, { 0, 1 } });\r\n    NeuralNetworkBuilder builder = new NeuralNetworkBuilder();\r\n    builder.setOverrideAddBiasTo(true);\r\n    builder.addLayerBuilder(new InputLayerBuilder(\"inputLayer\", 2, 1, 1));\r\n    builder.addLayerBuilder(new FullyConnectedLayerBuilder(6).setActivationType(ActivationType.ReLU));\r\n    builder.addLayerBuilder(new FullyConnectedLayerBuilder(2).setActivationType(ActivationType.SoftMax));\r\n    builder.setTrainingSet(input);\r\n    builder.setTestingSet(inputTest);\r\n    builder.setRand(new NNRandomInitializer(new MersenneTwisterRandomInitializer(-0.01f, 0.01f)));\r\n    builder.setError(new MultipleNeuronsOutputError());\r\n    builder.setLearningRate(0.1f);\r\n    builder.setMomentum(0.9f);\r\n    builder.setEpochs(1000);\r\n    Pair<NeuralNetworkImpl, Trainer<NeuralNetwork>> neuralNetworkTrainerPair = builder.buildWithTrainer();\r\n    Trainer<?> bpt = neuralNetworkTrainerPair.getRight();\r\n    LogTrainingListener ls = new LogTrainingListener(Thread.currentThread().getStackTrace()[1].getMethodName(), true, true);\r\n    ls.setLogBatchLoss(true);\r\n    ls.setLogInterval(500);\r\n    bpt.addEventListener(ls);\r\n    bpt.train();\r\n    bpt.test();\r\n    assertEquals(0, bpt.getOutputError().getTotalNetworkError(), 0.1);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.DefaultTerminalFactory.setTerminalEmulatorColorConfiguration",
	"Comment": "sets the color configuration to use on created swingterminalframes created by this factory",
	"Method": "DefaultTerminalFactory setTerminalEmulatorColorConfiguration(TerminalEmulatorColorConfiguration colorConfiguration){\r\n    this.colorConfiguration = colorConfiguration;\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.emailListener.EmailListener.getUser",
	"Comment": "returns the user to use to connect to the imap server. a null value means thatthis property needs to be configured to be used.",
	"Method": "String getUser(){\r\n    return JiveGlobals.getProperty(\"plugin.email.listener.user\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ConversationManager.joinedGroupConversation",
	"Comment": "notification message indicating that a user joined a groupchat conversation. if no groupchat conversation was taking place in the specifiedroom then ignore this event.eventually, when a new conversation will start in the room and if this user is still in the room then the new conversation will detect thisuser and mark like if the user joined the converstion from the beginning.",
	"Method": "void joinedGroupConversation(JID room,JID user,String nickname,Date date){\r\n    Conversation conversation = getRoomConversation(room);\r\n    if (conversation != null) {\r\n        conversation.participantJoined(user, nickname, date.getTime());\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.fastpath.settings.chat.ChatSettingsManager.getChatSettingsByType",
	"Comment": "send all webchat settings for a particular workgroup and type.",
	"Method": "void getChatSettingsByType(IQ packet,Workgroup workgroup,int type){\r\n    IQ reply = IQ.createResultIQ(packet);\r\n    ChatSettings chatSettings = getChatSettings(workgroup);\r\n    if (chatSettings == null) {\r\n        reply.setChildElement(packet.getChildElement().createCopy());\r\n        reply.setError(new PacketError(PacketError.Condition.item_not_found));\r\n        workgroup.send(reply);\r\n        return;\r\n    }\r\n    Element webSettings = reply.setChildElement(\"chat-settings\", \"http://jivesoftware.com/protocol/workgroup\");\r\n    for (ChatSetting setting : chatSettings.getChatSettings()) {\r\n        if (setting.getType().getType() == type) {\r\n            Element root = webSettings.addElement(\"chat-setting\");\r\n            root.addElement(\"key\").setText(setting.getKey().toString());\r\n            root.addElement(\"value\").setText(setting.getValue());\r\n            root.addElement(\"type\").setText(Integer.toString(setting.getType().getType()));\r\n        }\r\n    }\r\n    workgroup.send(reply);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.ScrollingSwingTerminal.addInput",
	"Comment": "takes a keystroke and puts it on the input queue of the terminal emulator. this way you can insert syntheticinput events to be processed as if they came from the user typing on the keyboard.",
	"Method": "void addInput(KeyStroke keyStroke){\r\n    swingTerminal.addInput(keyStroke);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.Bookmark.deleteProperty",
	"Comment": "deletes an extended property. if the property specified byname does not exist, this method will do nothing.",
	"Method": "void deleteProperty(String name){\r\n    if (properties == null) {\r\n        loadPropertiesFromDb();\r\n    }\r\n    if (properties.containsKey(name)) {\r\n        properties.remove(name);\r\n        deletePropertyFromDb(name);\r\n    }\r\n}"
}, {
	"Path": "kilim.ForkJoinScheduler.main",
	"Comment": "run the main method from another class using this scheduler as the default scheduler",
	"Method": "void main(String[] args){\r\n    Integer numThreads = parseNum(args, 0);\r\n    int offset = numThreads == null ? 0 : 1;\r\n    if (args.length <= offset) {\r\n        System.out.println(\"usage:\\n\" + \"  java kilim.ForkJoinScheduler [numThreads] class [args]\\n\" + \"call the main method of the specified class and pass the remaining arguments,\\n\" + \"  using `new ForkJoinScheduler(numThreads)` as the default scheduler\");\r\n        System.exit(1);\r\n    }\r\n    int num = numThreads == null || numThreads <= 0 ? Scheduler.defaultNumberThreads : numThreads;\r\n    Scheduler sched = new ForkJoinScheduler(num);\r\n    Scheduler.setDefaultScheduler(sched);\r\n    String className = args[offset];\r\n    String[] pargs = processArgs(args, offset + 1);\r\n    run(className, \"main\", pargs);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.request.UserRequest.getUserID",
	"Comment": "returns the user unique identification. if the user joined using an anonymous connectionthen the userid will be the value of the id attribute of the user element. otherwise, theuserid will be the bare jid of the user that made the request.",
	"Method": "String getUserID(){\r\n    return userID;\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocket.getMaxPayloadSize",
	"Comment": "get the maximum payload size. the default value is 0 which means thatthe maximum payload size is not set and as a result frames are not split.",
	"Method": "int getMaxPayloadSize(){\r\n    return mMaxPayloadSize;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.request.Request.getRequest",
	"Comment": "returns an existing request based on it unique id. if none was found then a notfoundexceptionexception will be thrown.requests are tracked once an initial offer has been sent to an agent. tracking of requests isstopped once the request was cancelled or accepted.",
	"Method": "Request getRequest(String requestID){\r\n    Request request = requests.get(requestID);\r\n    if (request == null) {\r\n        Log.debug(\"Request not found by ID: \" + requestID);\r\n        throw new NotFoundException();\r\n    }\r\n    return request;\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocket.getFrameQueueSize",
	"Comment": "get the size of the frame queue. the default value is 0 and it meansthere is no limit on the queue size.",
	"Method": "int getFrameQueueSize(){\r\n    return mFrameQueueSize;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.destroy",
	"Comment": "the workgroup is been deleted so destroy the room and remove the acceptedpresence subscriptions.",
	"Method": "void destroy(){\r\n    workgroupPresenceHandler.workgroupDestroyed();\r\n    destroyGroupChatRoom();\r\n}"
}, {
	"Path": "io.micrometer.prometheus.PrometheusDistributionSummary.histogramCounts",
	"Comment": "for prometheus we cannot use the histogram counts from histogramsnapshot, as it is based on arolling histogram. prometheus requires a histogram that accumulates values over the lifetime of the app.",
	"Method": "CountAtBucket[] histogramCounts(){\r\n    return histogram == null ? EMPTY_HISTOGRAM : histogram.takeSnapshot(0, 0, 0).histogramCounts();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.ChatbotSession.getMessageThread",
	"Comment": "returns the message thread that the user is using for sending his messages. it is importantto send messages to the user using the same thread so that messages may appear in thesame chat window that the user is using.",
	"Method": "String getMessageThread(){\r\n    return messageThread;\r\n}"
}, {
	"Path": "com.reucon.openfire.plugin.archive.model.Conversation.hasParticipant",
	"Comment": "checks if this conversation has an active participant with the given jid.",
	"Method": "boolean hasParticipant(String jid){\r\n    synchronized (participants) {\r\n        for (Participant p : participants) {\r\n            if (p.getJid().equals(jid)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.jvmtop.openjdk.tools.MemoryPoolStat.getBeforeGcUsage",
	"Comment": "returns the memory usage before the most recent gc started.null if no gc occurs.",
	"Method": "MemoryUsage getBeforeGcUsage(){\r\n    return beforeGcUsage;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.table.Table.setViewLeftColumn",
	"Comment": "sets the view column offset for the first column to display in the table. calling this with 0 will make the firstcolumn in the model be the first visible column in the table.",
	"Method": "Table<V> setViewLeftColumn(int viewLeftColumn){\r\n    getRenderer().setViewLeftColumn(viewLeftColumn);\r\n    return this;\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocket.getPingPayloadGenerator",
	"Comment": "get the generator of payload of ping frames that are sent automatically.",
	"Method": "PayloadGenerator getPingPayloadGenerator(){\r\n    return mPingSender.getPayloadGenerator();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.BroadcastPlugin.setGroupPermissionsDisabled",
	"Comment": "enables or disables permission checking when sending messages to a group. whendisabled, any user in the system can send a message to a group.",
	"Method": "void setGroupPermissionsDisabled(boolean disableGroupPermissions){\r\n    this.disableGroupPermissions = disableGroupPermissions;\r\n    JiveGlobals.setProperty(\"plugin.broadcast.disableGroupPermissions\", Boolean.toString(disableGroupPermissions));\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.CheckBoxList.addItem",
	"Comment": "adds an item to the checkbox list with an explicit checked status",
	"Method": "CheckBoxList<V> addItem(V object,CheckBoxList<V> addItem,V object,boolean checkedState){\r\n    itemStatus.add(checkedState);\r\n    return super.addItem(object);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.search.ChatSearchManager.getOptimizationFrequency",
	"Comment": "returns the number of hours to wait until the next optimization. optimizing the index makesthe searches faster and reduces the number of files too.",
	"Method": "int getOptimizationFrequency(){\r\n    return JiveGlobals.getIntProperty(\"workgroup.search.frequency.optimization\", 24);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterExternalizableUtil.readLongIntMap",
	"Comment": "reads a map of long key and integer value pairs. this method will returnnull if the map written to the stream was null.",
	"Method": "Map<Long, Integer> readLongIntMap(DataInput in){\r\n    return (Map<Long, Integer>) readObject(in);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.GridLayout.setTopMarginSize",
	"Comment": "sets the top margin, i.e. number of empty rows above the first row in the grid",
	"Method": "GridLayout setTopMarginSize(int topMarginSize){\r\n    if (topMarginSize < 0) {\r\n        throw new IllegalArgumentException(\"Top margin size cannot be less than 0\");\r\n    }\r\n    this.topMarginSize = topMarginSize;\r\n    this.changed = true;\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.cleanup",
	"Comment": "removes idle sessions. after a session has been removed, if a user sends a message to thechatbot then the script will start from scratch. therefore, all the stored informationin the session will be lost.",
	"Method": "void cleanup(){\r\n    final long deadline = System.currentTimeMillis() - getIdleTimeout();\r\n    for (ChatbotSession session : sessions.values()) {\r\n        if (!session.isStartedSupport() && session.getLastActiveDate().getTime() < deadline) {\r\n            Log.debug(\"Removing idle chat \" + \"session for: \" + session.getUserJID());\r\n            removeSession(session.getUserJID());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.SparkManager.getNumberOfLoginsNotAllowed",
	"Comment": "returns the number of logins which were not valid due to spark manager restrictions.",
	"Method": "int getNumberOfLoginsNotAllowed(){\r\n    return disconnects.getAndSet(0);\r\n}"
}, {
	"Path": "kilim.Fiber.setState",
	"Comment": "called by the generated code before pausing and unwinding its stackframe.",
	"Method": "void setState(State state){\r\n    stateStack[iStack] = state;\r\n    isPausing = true;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.RadioBoxList.setCheckedItemIndex",
	"Comment": "sets the currently selected item by index. if the index is out of range, it does nothing.",
	"Method": "void setCheckedItemIndex(int index){\r\n    if (index < -1 || index >= getItemCount())\r\n        return;\r\n    setCheckedIndex(index);\r\n}"
}, {
	"Path": "org.jupiter.serialization.proto.io.NioBufInput.skipMessage",
	"Comment": "reads and discards an entire message. this will read either until eof or until an endgroup tag, whichever comesfirst.",
	"Method": "void skipMessage(){\r\n    while (true) {\r\n        final int tag = readTag();\r\n        if (tag == 0 || !skipField(tag)) {\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.GridLayout.getVerticalSpacing",
	"Comment": "returns the vertical spacing, i.e. the number of empty columns between each row",
	"Method": "int getVerticalSpacing(){\r\n    return verticalSpacing;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.getUserRequest",
	"Comment": "retuns the userrequest that is associated to the support session being currently serviced ornull if none was found.",
	"Method": "UserRequest getUserRequest(String sessionID){\r\n    return requests.get(sessionID);\r\n}"
}, {
	"Path": "gab.opencv.OpenCV.getColorSpace",
	"Comment": "get the colorspace of the current color image. will be either rgb or hsb.",
	"Method": "int getColorSpace(){\r\n    return colorSpace;\r\n}"
}, {
	"Path": "org.junit.platform.engine.FilterResult.includedIf",
	"Comment": "factory for creating filter results based on the condition given.",
	"Method": "FilterResult includedIf(boolean included,FilterResult includedIf,boolean included,Supplier<String> inclusionReasonSupplier,Supplier<String> exclusionReasonSupplier){\r\n    return included ? included(inclusionReasonSupplier.get()) : excluded(exclusionReasonSupplier.get());\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.InteractableLookupMap.getInteractableAt",
	"Comment": "looks up what interactable component is as a particular location in the map",
	"Method": "Interactable getInteractableAt(TerminalPosition position){\r\n    if (position.getRow() < 0 || position.getColumn() < 0) {\r\n        return null;\r\n    }\r\n    if (position.getRow() >= lookupMap.length) {\r\n        return null;\r\n    } else if (position.getColumn() >= lookupMap[0].length) {\r\n        return null;\r\n    } else if (lookupMap[position.getRow()][position.getColumn()] == -1) {\r\n        return null;\r\n    }\r\n    return interactables.get(lookupMap[position.getRow()][position.getColumn()]);\r\n}"
}, {
	"Path": "gab.opencv.Contour.getConvexHull",
	"Comment": "calculate a convex hull from the current contour.\treturns a new contour representing the convex hull.",
	"Method": "Contour getConvexHull(){\r\n    MatOfInt hull = new MatOfInt();\r\n    MatOfPoint points = new MatOfPoint(pointMat);\r\n    Imgproc.convexHull(points, hull);\r\n    Point[] hp = new Point[hull.height()];\r\n    for (int i = 0; i < hull.height(); i++) {\r\n        int index = (int) hull.get(i, 0)[0];\r\n        hp[i] = new Point(pointMat.get(index, 0));\r\n    }\r\n    MatOfPoint hullPoints = new MatOfPoint();\r\n    hullPoints.fromArray(hp);\r\n    return new Contour(parent, hullPoints);\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.ReadingThread.verifyFrameOpcode",
	"Comment": "ensure that the opcode of the give frame is a known one.from rfc 6455, 5.2. base framing protocolif an unknown opcode is received, the receiving endpoint mustfail the websocket connection.",
	"Method": "void verifyFrameOpcode(WebSocketFrame frame){\r\n    switch(frame.getOpcode()) {\r\n        case CONTINUATION:\r\n        case TEXT:\r\n        case BINARY:\r\n        case CLOSE:\r\n        case PING:\r\n        case PONG:\r\n            return;\r\n        default:\r\n            break;\r\n    }\r\n    if (mWebSocket.isExtended()) {\r\n        return;\r\n    }\r\n    throw new WebSocketException(WebSocketError.UNKNOWN_OPCODE, \"A frame has an unknown opcode: 0x\" + Integer.toHexString(frame.getOpcode()));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.Bookmark.getUsers",
	"Comment": "returns the collection of usersnames that have been assigned the bookmark.",
	"Method": "Collection<String> getUsers(){\r\n    return users;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Offer.updateUserSession",
	"Comment": "updates the database tables with new session state, waittime and metadata.",
	"Method": "void updateUserSession(int state){\r\n    request.updateSession(state, offerTime.getTime());\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.table.Table.setViewTopRow",
	"Comment": "sets the view row offset for the first row to display in the table. calling this with 0 will make the first rowin the model be the first visible row in the table.",
	"Method": "Table<V> setViewTopRow(int viewTopRow){\r\n    getRenderer().setViewTopRow(viewTopRow);\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.request.Request.hasJoinedRoom",
	"Comment": "returns true if the user that made this request joined a room to have a chat with an agent.",
	"Method": "boolean hasJoinedRoom(){\r\n    return joinedRoom > 0;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TerminalPosition.withRow",
	"Comment": "creates a new terminalposition object representing a position with the same column index as this but with asupplied row index.",
	"Method": "TerminalPosition withRow(int row){\r\n    if (row == 0 && this.column == 0) {\r\n        return TOP_LEFT_CORNER;\r\n    }\r\n    return new TerminalPosition(this.column, row);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getByeMessage",
	"Comment": "returns the message to send if the user does not want to join the workgroup.",
	"Method": "String getByeMessage(){\r\n    return settings.getChatSetting(KeyEnum.bye_message).getValue();\r\n}"
}, {
	"Path": "com.drew.metadata.Metadata.containsDirectoryOfType",
	"Comment": "indicates whether an instance of the given directory type exists in this metadata instance.",
	"Method": "boolean containsDirectoryOfType(Class<? extends Directory> type){\r\n    for (Directory dir : _directories) {\r\n        if (type.isAssignableFrom(dir.getClass()))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getHelpCommand",
	"Comment": "returns the string that indicates that the user is requesting the list of available commands.",
	"Method": "String getHelpCommand(){\r\n    return settings.getChatSetting(KeyEnum.help_command).getValue();\r\n}"
}, {
	"Path": "org.junit.jupiter.params.ParameterizedTestMethodContext.resolve",
	"Comment": "resolve the parameter for the supplied context using the supplied\targuments.",
	"Method": "Object resolve(ParameterContext parameterContext,Object[] arguments,Object resolve,ParameterContext parameterContext,Object[] arguments,Object resolve,ParameterContext parameterContext,Object[] arguments,Object resolve,ParameterContext parameterContext,Object[] arguments){\r\n    return getResolver(parameterContext).resolve(parameterContext, arguments);\r\n}"
}, {
	"Path": "org.jdbi.v3.sqlobject.config.Configurer.configureForType",
	"Comment": "configures the registry for the given annotation on a sql object type.",
	"Method": "void configureForType(ConfigRegistry registry,Annotation annotation,Class<?> sqlObjectType){\r\n    throw new UnsupportedOperationException(\"Not supported for type\");\r\n}"
}, {
	"Path": "com.googlecode.lanterna.bundle.BundleLocator.getBundleKeyValue",
	"Comment": "method that centralizes the way to get the value associated to a bundle key.",
	"Method": "String getBundleKeyValue(Locale locale,String key,Object parameters){\r\n    String value = null;\r\n    try {\r\n        value = getBundle(locale).getString(key);\r\n    } catch (Exception ignore) {\r\n    }\r\n    return value != null ? MessageFormat.format(value, parameters) : null;\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.composite.AbstractCompositeMeter.remove",
	"Comment": "does nothing. new registries added to the composite are automatically reflected in each meterbelonging to the composite.",
	"Method": "void remove(MeterRegistry registry){\r\n    for (; ; ) {\r\n        if (childrenGuard.compareAndSet(false, true)) {\r\n            try {\r\n                Map<MeterRegistry, T> newChildren = new IdentityHashMap(children);\r\n                newChildren.remove(registry);\r\n                this.children = newChildren;\r\n                break;\r\n            } finally {\r\n                childrenGuard.set(false);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "kilim.analysis.CallWeaver.getNumArgs",
	"Comment": "the total number consumed by the call, including its object reference",
	"Method": "int getNumArgs(){\r\n    if (numArgs == -1) {\r\n        numArgs = TypeDesc.getNumArgumentTypes(getMethodInsn().desc) + (isStaticCall() ? 0 : 1);\r\n    }\r\n    return numArgs;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterExternalizableUtil.writeExternalizableMap",
	"Comment": "writes a map of string key and value pairs. this method handles thecase when the map is null.",
	"Method": "void writeExternalizableMap(DataOutput out,Map<String, ? extends Externalizable> map){\r\n    writeObject(out, map);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.ComboBox.removeItem",
	"Comment": "removes a particular item from the combo box, if it is present, otherwise does nothing",
	"Method": "ComboBox<V> removeItem(V item){\r\n    int index = items.indexOf(item);\r\n    if (index == -1) {\r\n        return this;\r\n    }\r\n    return remoteItem(index);\r\n}"
}, {
	"Path": "com.drew.metadata.iptc.IptcDirectory.getDateCreated",
	"Comment": "parses the date created tag and the time created tag to obtain a single date object representing thedate and time when this image was captured.",
	"Method": "Date getDateCreated(){\r\n    return getDate(TAG_DATE_CREATED, TAG_TIME_CREATED);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TerminalPosition.withRelativeRow",
	"Comment": "creates a new terminalposition object representing a position on the same column, but with a row offset by asupplied value. calling this method with delta 0 will return this, calling it with a positive delta will returna terminal position delta number of rows to the down and for negative numbers the same up.",
	"Method": "TerminalPosition withRelativeRow(int delta){\r\n    if (delta == 0) {\r\n        return this;\r\n    }\r\n    return withRow(row + delta);\r\n}"
}, {
	"Path": "org.jdbi.v3.testing.Migration.cleanAfter",
	"Comment": "will drop all objects in the configured schemas after tests using flyway.",
	"Method": "Migration cleanAfter(){\r\n    this.cleanAfter = true;\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.request.UserRequest.supportStarted",
	"Comment": "notification message saying that the user that made the request has joined the room to havea chat with an agent.",
	"Method": "void supportStarted(String roomID){\r\n    joinedRoom = System.currentTimeMillis();\r\n    communicationMethod.supportStarted(this);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.event.WorkgroupEventDispatcher.workgroupOpened",
	"Comment": "notification message that a workgroup was closed and is now opened sincean agent is now available and the schedule is ok.",
	"Method": "void workgroupOpened(Workgroup workgroup){\r\n    for (WorkgroupEventListener listener : listeners) {\r\n        try {\r\n            listener.workgroupOpened(workgroup);\r\n        } catch (Exception e) {\r\n            Log.error(e.getMessage(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.AgentSession.sendStatusOfAllAgents",
	"Comment": "sends the presence of each available agent in the workgroup to this agent.",
	"Method": "void sendStatusOfAllAgents(Workgroup workgroup){\r\n    for (AgentSession agentSession : workgroup.getAgentSessions()) {\r\n        if (!agentSession.getJID().equals(address)) {\r\n            Presence statusPacket = agentSession.getPresence().createCopy();\r\n            statusPacket.setFrom(agentSession.getJID());\r\n            statusPacket.setTo(address);\r\n            agentSession.getAgentStatus(statusPacket, workgroup);\r\n            workgroup.send(statusPacket);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.drew.metadata.iptc.IptcDirectory.getKeywords",
	"Comment": "returns any keywords contained in the iptc data.this value may be null.",
	"Method": "List<String> getKeywords(){\r\n    final String[] array = getStringArray(TAG_KEYWORDS);\r\n    if (array == null)\r\n        return null;\r\n    return Arrays.asList(array);\r\n}"
}, {
	"Path": "org.jupiter.common.util.Reflects.getTotalTransformationCost",
	"Comment": "returns the sum of the object transformation cost for each class in thesource argument list.",
	"Method": "float getTotalTransformationCost(Class<?>[] srcArgs,Class<?>[] dstArgs){\r\n    float totalCost = 0.0f;\r\n    for (int i = 0; i < srcArgs.length; i++) {\r\n        Class<?> srcClass, dstClass;\r\n        srcClass = srcArgs[i];\r\n        dstClass = dstArgs[i];\r\n        totalCost += getObjectTransformationCost(srcClass, dstClass);\r\n    }\r\n    return totalCost;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ConversationManager.leftGroupConversation",
	"Comment": "notification message indicating that a user left a groupchat conversation. if no groupchat conversation was taking place in the specified roomthen ignore this event.",
	"Method": "void leftGroupConversation(JID room,JID user,Date date){\r\n    Conversation conversation = getRoomConversation(room);\r\n    if (conversation != null) {\r\n        conversation.participantLeft(user, date.getTime());\r\n    }\r\n}"
}, {
	"Path": "org.junit.platform.commons.util.ReflectionUtils.getFullyQualifiedMethodName",
	"Comment": "build the fully qualified method name for the method described by the\tsupplied class, method name, and parameter types.",
	"Method": "String getFullyQualifiedMethodName(Class<?> clazz,String methodName,Class<?> parameterTypes){\r\n    Preconditions.notNull(clazz, \"Class must not be null\");\r\n    Preconditions.notBlank(methodName, \"Method name must not be null or blank\");\r\n    return String.format(\"%s#%s(%s)\", clazz.getName(), methodName, ClassUtils.nullSafeToString(parameterTypes));\r\n}"
}, {
	"Path": "org.jupiter.serialization.proto.io.NioBufInput.readEnum",
	"Comment": "read an enum field value from the internal buffer. caller is responsible for converting the numeric value to anactual enum.",
	"Method": "int readEnum(){\r\n    checkIfPackedField();\r\n    return readRawVarInt32();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.spi.dispatcher.DbDispatcherInfoProvider.deleteDispatcherInfo",
	"Comment": "deletes the dispatcherinfo object from the given requestqueue.",
	"Method": "void deleteDispatcherInfo(long queueID){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(DELETE_DISPATCHER);\r\n        pstmt.setLong(1, queueID);\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException e) {\r\n        Log.error(LocaleUtils.getLocalizedString(\"admin.error\"), e);\r\n        throw new UnauthorizedException();\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.junit.platform.engine.TestDescriptor.accept",
	"Comment": "accept a visitor to the subtree starting with this descriptor.",
	"Method": "void accept(Visitor visitor){\r\n    visitor.visit(this);\r\n    new LinkedHashSet(this.getChildren()).forEach(child -> child.accept(visitor));\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getNotAcceptableMessage",
	"Comment": "returns the message to inform the user that the requested command cannot be processed.",
	"Method": "String getNotAcceptableMessage(){\r\n    return settings.getChatSetting(KeyEnum.not_acceptable_message).getValue();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.onMessage",
	"Comment": "process a message sent by the owner of the specified session.",
	"Method": "void onMessage(ChatbotSession session,Message message){\r\n    InterceptorManager interceptorManager = ChatbotInterceptorManager.getInstance();\r\n    try {\r\n        interceptorManager.invokeInterceptors(workgroup.getJID().toBareJID(), message, true, false);\r\n        session.setMessageThread(message.getThread());\r\n        synchronized (session) {\r\n            if (workgroup.getStatus() != Workgroup.Status.OPEN) {\r\n                sendReply(message, getWorkgroupClosedMessage());\r\n            } else if (handleCommand(message, session)) {\r\n            } else if (session.getCurrentStep() < 0) {\r\n                sendWelcomeMessage(message);\r\n                sendJoinQuestion(message, session);\r\n            } else if (session.getCurrentStep() == 1) {\r\n                if (yes.equalsIgnoreCase(message.getBody().trim())) {\r\n                    userAcceptedJoining(message, session);\r\n                } else if (no.equalsIgnoreCase(message.getBody().trim())) {\r\n                    closeSession(message);\r\n                } else {\r\n                    sendJoinQuestion(message, session);\r\n                }\r\n            } else if (session.getCurrentStep() == 2) {\r\n                if (userAnsweredField(message, session)) {\r\n                    if (session.getCurrentSubstep() < getForm().getFormElements().size() - 1) {\r\n                        sendNextQuestion(message, session);\r\n                    } else {\r\n                        userJoinQueue(message, session);\r\n                    }\r\n                } else {\r\n                    repeatQuestion(message, session);\r\n                }\r\n            } else if (session.getCurrentStep() == 4) {\r\n                if (yes.equalsIgnoreCase(message.getBody().trim())) {\r\n                    sendRoomInvitation(message, session);\r\n                } else if (no.equalsIgnoreCase(message.getBody().trim())) {\r\n                } else {\r\n                    sendInvitationQuestion(message.getFrom(), session);\r\n                }\r\n            } else if (session.getCurrentStep() == 6) {\r\n                if (yes.equalsIgnoreCase(message.getBody().trim())) {\r\n                    List<String> emailValue = session.getAttributes().get(\"email\");\r\n                    if (emailValue == null || emailValue.isEmpty()) {\r\n                        sendGetEmailQuestion(message, session);\r\n                    } else {\r\n                        sendTranscriptByMail(emailValue.get(0), message, session);\r\n                        closeSession(message);\r\n                    }\r\n                } else if (no.equalsIgnoreCase(message.getBody().trim())) {\r\n                    closeSession(message);\r\n                } else {\r\n                    sendEmailQuestion(message.getFrom(), session);\r\n                }\r\n            } else if (session.getCurrentStep() == 7) {\r\n                sendTranscriptByMail(message.getBody().trim(), message, session);\r\n                closeSession(message);\r\n            } else {\r\n                sendReply(message, getNotAcceptableMessage());\r\n            }\r\n        }\r\n        interceptorManager.invokeInterceptors(workgroup.getJID().toBareJID(), message, true, true);\r\n    } catch (PacketRejectedException e) {\r\n        workgroup.rejectPacket(message, e);\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.TerminalEmulatorDeviceConfiguration.getLineBufferScrollbackSize",
	"Comment": "how many lines of history should be saved so the user can scroll back to them?",
	"Method": "int getLineBufferScrollbackSize(){\r\n    return lineBufferScrollbackSize;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.input.MouseAction.getActionType",
	"Comment": "returns the mouse action type so the caller can determine which kind of action was performed.",
	"Method": "MouseActionType getActionType(){\r\n    return actionType;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.fastpath.WorkgroupSettings.add",
	"Comment": "stores private data. if the name and namespace of the element matches anotherstored private data xml document, then replace it with the new one.",
	"Method": "void add(String workgroupName,Element data){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        StringWriter writer = new StringWriter();\r\n        data.write(writer);\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(LOAD_SETTINGS);\r\n        pstmt.setString(1, workgroupName);\r\n        pstmt.setString(2, data.getNamespaceURI());\r\n        ResultSet rs = pstmt.executeQuery();\r\n        boolean update = false;\r\n        if (rs.next()) {\r\n            update = true;\r\n        }\r\n        rs.close();\r\n        pstmt.close();\r\n        if (update) {\r\n            pstmt = con.prepareStatement(UPDATE_SETTINGS);\r\n        } else {\r\n            pstmt = con.prepareStatement(INSERT_SETTINGS);\r\n        }\r\n        DbConnectionManager.setLargeTextField(pstmt, 1, writer.toString());\r\n        pstmt.setString(2, data.getName());\r\n        pstmt.setString(3, workgroupName);\r\n        pstmt.setString(4, data.getNamespaceURI());\r\n        pstmt.executeUpdate();\r\n    } catch (Exception e) {\r\n        Log.error(LocaleUtils.getLocalizedString(\"admin.error\"), e);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.getAgents",
	"Comment": "returns a collection with all the agents that belong to the workgroup. if the same agentis present in more than one queue then the answer will only include one instanceof the agent.",
	"Method": "Collection<Agent> getAgents(){\r\n    Collection<Agent> answer = new HashSet<Agent>();\r\n    for (RequestQueue queue : queues.values()) {\r\n        answer.addAll(queue.getMembers());\r\n        for (Group group : queue.getGroups()) {\r\n            for (Agent agent : agentManager.getAgents(group)) {\r\n                answer.add(agent);\r\n            }\r\n        }\r\n    }\r\n    return Collections.unmodifiableCollection(answer);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.WorkgroupManager.handleOutdatePresence",
	"Comment": "checks for outdated presences caused by network failures, etc.",
	"Method": "void handleOutdatePresence(){\r\n    for (Workgroup workgroup : getWorkgroups()) {\r\n        for (AgentSession agentSession : workgroup.getAgentSessions()) {\r\n            final JID agentJID = agentSession.getJID();\r\n            final PresenceManager presenceManager = XMPPServer.getInstance().getPresenceManager();\r\n            boolean isOnline = false;\r\n            for (Presence presence : presenceManager.getPresences(agentJID.getNode())) {\r\n                if (presence.getFrom().equals(agentJID)) {\r\n                    isOnline = true;\r\n                }\r\n            }\r\n            if (!isOnline) {\r\n                for (Workgroup wgroup : agentSession.getWorkgroups()) {\r\n                    Presence presence = new Presence();\r\n                    presence.setFrom(agentJID);\r\n                    presence.setTo(wgroup.getJID());\r\n                    presence.setType(Presence.Type.unavailable);\r\n                    wgroup.getWorkgroupPresenceHandler().process(presence);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterExternalizableUtil.writeStringList",
	"Comment": "writes a list of strings. this method handles the case when the list isnull.",
	"Method": "void writeStringList(DataOutput out,List<String> stringList){\r\n    writeObject(out, stringList);\r\n}"
}, {
	"Path": "org.jupiter.serialization.proto.io.UnsafeNioBufInput.readTag",
	"Comment": "attempt to read a field tag, returning zero if we have reached eof. protocol message parsers use this to readtags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.",
	"Method": "int readTag(){\r\n    if (!nioBuffer.hasRemaining()) {\r\n        lastTag = 0;\r\n        return 0;\r\n    }\r\n    final int tag = readRawVarInt32();\r\n    if (tag >>> TAG_TYPE_BITS == 0) {\r\n        throw ProtocolException.invalidTag();\r\n    }\r\n    lastTag = tag;\r\n    return tag;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.dialogs.AbstractDialogBuilder.setExtraWindowHints",
	"Comment": "assigns a set of extra window hints that you want the built dialog to have",
	"Method": "B setExtraWindowHints(Set<Window.Hint> extraWindowHints){\r\n    this.extraWindowHints = extraWindowHints;\r\n    return self();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.stats.StatsEngine.getLastMinute",
	"Comment": "returns the last minute that passed in seconds since the epoch.",
	"Method": "long getLastMinute(){\r\n    Calendar calendar = Calendar.getInstance();\r\n    calendar.setTimeInMillis(System.currentTimeMillis());\r\n    calendar.set(Calendar.SECOND, 0);\r\n    return calendar.getTimeInMillis() / 1000;\r\n}"
}, {
	"Path": "org.jupiter.common.concurrent.collection.ConcurrentAutoTable.set",
	"Comment": "atomically set the sum of the striped counters to specified value.rather more expensive than a simple store, in order to remain atomic.",
	"Method": "void set(long x){\r\n    CAT newcat = new CAT(null, 4, x);\r\n    while (!CAS_cat(_cat, newcat)) {\r\n    }\r\n}"
}, {
	"Path": "io.moquette.broker.PostOffice.receivedPublishQos2",
	"Comment": "first phase of a publish qos2 protocol, sent by publisher to the broker. publish to all interestedsubscribers.",
	"Method": "void receivedPublishQos2(MQTTConnection connection,MqttPublishMessage mqttPublishMessage,String username){\r\n    LOG.trace(\"Processing PUBREL message on connection: {}\", connection);\r\n    final Topic topic = new Topic(mqttPublishMessage.variableHeader().topicName());\r\n    final ByteBuf payload = mqttPublishMessage.payload();\r\n    final String clientId = connection.getClientId();\r\n    if (!authorizator.canWrite(topic, username, clientId)) {\r\n        LOG.error(\"MQTT client is not authorized to publish on topic. CId={}, topic: {}\", clientId, topic);\r\n        return;\r\n    }\r\n    publish2Subscribers(payload, topic, EXACTLY_ONCE);\r\n    final boolean retained = mqttPublishMessage.fixedHeader().isRetain();\r\n    if (retained) {\r\n        if (!payload.isReadable()) {\r\n            retainedRepository.cleanRetained(topic);\r\n        } else {\r\n            retainedRepository.retain(topic, mqttPublishMessage);\r\n        }\r\n    }\r\n    String clientID = connection.getClientId();\r\n    interceptor.notifyTopicPublished(mqttPublishMessage, clientID, username);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.util.TaskEngine.submit",
	"Comment": "submits a runnable task for execution and returns a futurerepresenting that task.",
	"Method": "Future<?> submit(Runnable task){\r\n    return executor.submit(task);\r\n}"
}, {
	"Path": "org.jupiter.common.util.collection.LongObjectHashMap.growSize",
	"Comment": "grows the map size after an insertion. if necessary, performs a rehash of the map.",
	"Method": "void growSize(){\r\n    size++;\r\n    if (size > maxSize) {\r\n        if (keys.length == Integer.MAX_VALUE) {\r\n            throw new IllegalStateException(\"Max capacity reached at size=\" + size);\r\n        }\r\n        rehash(keys.length << 1);\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.CheckBox.setChecked",
	"Comment": "programmatically updated the check box to a particular checked state",
	"Method": "CheckBox setChecked(boolean checked){\r\n    this.checked = checked;\r\n    runOnGUIThreadIfExistsOtherwiseRunDirect(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            for (Listener listener : listeners) {\r\n                listener.onStatusChanged(checked);\r\n            }\r\n        }\r\n    });\r\n    invalidate();\r\n    return this;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.CheckBox.setChecked",
	"Comment": "programmatically updated the check box to a particular checked state",
	"Method": "CheckBox setChecked(boolean checked){\r\n    for (Listener listener : listeners) {\r\n        listener.onStatusChanged(checked);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.routing.RequestRouter.getRoutingQueue",
	"Comment": "returns the id of the queue to route to if this router evalutes to true.",
	"Method": "long getRoutingQueue(){\r\n    return routingQueue;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.search.QueryResult.getRelevance",
	"Comment": "get the relevance of this query result as determined by the search engine.",
	"Method": "float getRelevance(){\r\n    return relevance;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.Bookmark.getProperty",
	"Comment": "returns an extended property. each bookmark can havean arbitrary number of extended properties. this allows for enhancedfunctionality that is not part of the base interface.",
	"Method": "String getProperty(String name){\r\n    if (properties == null) {\r\n        loadPropertiesFromDb();\r\n    }\r\n    return properties.get(name);\r\n}"
}, {
	"Path": "org.jupiter.transport.channel.CopyOnWriteGroupList.addIfAbsent",
	"Comment": "a version of addifabsent using the strong hint that givenrecent snapshot does not contain o.",
	"Method": "boolean addIfAbsent(JChannelGroup o,boolean addIfAbsent,JChannelGroup o,JChannelGroup[] snapshot){\r\n    final ReentrantLock lock = this.lock;\r\n    lock.lock();\r\n    try {\r\n        JChannelGroup[] current = tabAt0(array);\r\n        int len = current.length;\r\n        if (snapshot != current) {\r\n            int common = Math.min(snapshot.length, len);\r\n            for (int i = 0; i < common; i++) {\r\n                if (current[i] != snapshot[i] && eq(o, current[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (indexOf(o, current, common, len) >= 0) {\r\n                return false;\r\n            }\r\n        }\r\n        JChannelGroup[] newElements = Arrays.copyOf(current, len + 1);\r\n        newElements[len] = o;\r\n        setArray(newElements, null);\r\n        parent.incrementRefCount(o);\r\n        return true;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.micrometer.statsd.StatsdConfig.queueSize",
	"Comment": "governs the maximum size of the queue of items waiting to be sent to a statsd agent over udp.",
	"Method": "int queueSize(){\r\n    String v = get(prefix() + \".queueSize\");\r\n    return v == null ? Integer.MAX_VALUE : Integer.parseInt(v);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ConversationManager.getRoomConversation",
	"Comment": "returns the group conversation taking place in the specified room or null if none.",
	"Method": "Conversation getRoomConversation(JID room){\r\n    String conversationKey = room.toString();\r\n    return conversations.get(conversationKey);\r\n}"
}, {
	"Path": "com.github.fge.jsonschema.processors.syntax.SyntaxValidator.getProcessor",
	"Comment": "return the underlying processoryou can use this processor to chain it with your own.",
	"Method": "Processor<ValueHolder<SchemaTree>, ValueHolder<SchemaTree>> getProcessor(){\r\n    return processor;\r\n}"
}, {
	"Path": "org.jupiter.common.util.internal.InternalThreadLocal.size",
	"Comment": "returns the number of thread local variables bound to the current thread.",
	"Method": "int size(){\r\n    InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.getIfSet();\r\n    if (threadLocalMap == null) {\r\n        return 0;\r\n    } else {\r\n        return threadLocalMap.size();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.search.ChatSearchManager.getMaxPendingTranscripts",
	"Comment": "returns the maximum number of transcripts that can be generated since the last updateprocess was executed before forcing the update process to be executed. if the returnedvalue is in summary, the update process runs periodically but it may be force to be executedif a certain number of transcripts have been generated since the last update execution.",
	"Method": "int getMaxPendingTranscripts(){\r\n    return JiveGlobals.getIntProperty(\"workgroup.search.pending.transcripts\", 5);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TextCharacter.isReversed",
	"Comment": "returns true if this textcharacter has the reverse modifier active",
	"Method": "boolean isReversed(){\r\n    return modifiers.contains(SGR.REVERSE);\r\n}"
}, {
	"Path": "com.drew.metadata.iptc.IptcDirectory.getDigitalDateCreated",
	"Comment": "parses the digital date created tag and the digital time created tag to obtain a single date objectrepresenting the date and time when the digital representation of this image was created.",
	"Method": "Date getDigitalDateCreated(){\r\n    return getDate(TAG_DIGITAL_DATE_CREATED, TAG_DIGITAL_TIME_CREATED);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TextCharacter.isBordered",
	"Comment": "returns true if this textcharacter has the bordered modifier active",
	"Method": "boolean isBordered(){\r\n    return modifiers.contains(SGR.BORDERED);\r\n}"
}, {
	"Path": "kilim.test.ex.ExYieldStack.testStackBottom_v",
	"Comment": "load stack with a number of types, call a virtual pausable method",
	"Method": "void testStackBottom_v(){\r\n    verify(fd, fs, pausable_v(fl), fa, ff);\r\n}"
}, {
	"Path": "gab.opencv.OpenCV.useGray",
	"Comment": "set opencv to do image processing on the grayscale versionof the loaded image.",
	"Method": "void useGray(){\r\n    useColor = false;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.dialogs.ListSelectDialogBuilder.addListItems",
	"Comment": "adds a list of items to the list box at the end, in the order they are passed in",
	"Method": "ListSelectDialogBuilder<T> addListItems(T items){\r\n    this.content.addAll(Arrays.asList(items));\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterListener.cleanupPresences",
	"Comment": "simulate an unavailable presence for sessions that were being hosted in othercluster nodes. this method should be used only when this jvm left the cluster.",
	"Method": "void cleanupPresences(NodeID key){\r\n    Set<String> registeredUsers = lookupJIDList(key, C2SCache.getName());\r\n    if (!registeredUsers.isEmpty()) {\r\n        for (String fullJID : new ArrayList(registeredUsers)) {\r\n            JID offlineJID = new JID(fullJID);\r\n            try {\r\n                Presence presence = new Presence(Presence.Type.unavailable);\r\n                presence.setFrom(offlineJID);\r\n                XMPPServer.getInstance().getPresenceRouter().route(presence);\r\n            } catch (PacketException e) {\r\n                logger.error(\"Failed to cleanup user presence\", e);\r\n            }\r\n        }\r\n    }\r\n    Set<String> anonymousUsers = lookupJIDList(key, anonymousC2SCache.getName());\r\n    if (!anonymousUsers.isEmpty()) {\r\n        for (String fullJID : new ArrayList(anonymousUsers)) {\r\n            JID offlineJID = new JID(fullJID);\r\n            try {\r\n                Presence presence = new Presence(Presence.Type.unavailable);\r\n                presence.setFrom(offlineJID);\r\n                XMPPServer.getInstance().getPresenceRouter().route(presence);\r\n            } catch (PacketException e) {\r\n                logger.error(\"Failed to cleanp anonymous presence\", e);\r\n            }\r\n        }\r\n    }\r\n    nodeSessions.remove(key);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterExternalizableUtil.writeLongIntMap",
	"Comment": "writes a map of long key and integer value pairs. this method handlesthe case when the map is null.",
	"Method": "void writeLongIntMap(DataOutput out,Map<Long, Integer> map){\r\n    writeObject(out, map);\r\n}"
}, {
	"Path": "com.github.neuralnetworks.tensor.TensorFactory.tensor",
	"Comment": "create multiple combined tensors using shared elements array",
	"Method": "T tensor(int dimensions,T tensor,float[] elements,int offset,int dimensions,T tensor,Tensor parent,int[][] dimensionsLimit,boolean reduceChildDimensions,Tensor[] tensor,int[] dimensions,T tensor,Layer targetLayer,Collection<Connections> connections,ValuesProvider tp,T tensor,Layer targetLayer,Connections c,ValuesProvider tp){\r\n    return tp.get(targetLayer, getLayerDimensions(targetLayer, Arrays.asList(new Connections[] { c }), batchSize(tp)));\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TerminalPosition.withColumn",
	"Comment": "creates a new terminalposition object representing a position with the same row index as this but with asupplied column index.",
	"Method": "TerminalPosition withColumn(int column){\r\n    if (column == 0 && this.row == 0) {\r\n        return TOP_LEFT_CORNER;\r\n    }\r\n    return new TerminalPosition(column, this.row);\r\n}"
}, {
	"Path": "kilim.MailboxMPSC.putnb",
	"Comment": "attempt to put a message, and return true if successful. the thread is\tnot blocked, nor is the task paused under any circumstance.",
	"Method": "boolean putnb(T msg){\r\n    return put(msg, null);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.WorkgroupPresence.workgroupDestroyed",
	"Comment": "the workgroup is being destroyed so remove all the accepted presence subscriptions.",
	"Method": "void workgroupDestroyed(){\r\n    TaskEngine.getInstance().submit(new Runnable() {\r\n        public void run() {\r\n            try {\r\n                for (String bareJID : presenceSubscribers) {\r\n                    Presence reply = new Presence();\r\n                    reply.setTo(bareJID);\r\n                    reply.setFrom(workgroup.getJID());\r\n                    reply.setType(Presence.Type.unsubscribed);\r\n                    workgroup.send(reply);\r\n                }\r\n                deleteRosterItems();\r\n            } catch (Exception e) {\r\n                Log.error(\"Error broadcasting available presence\", e);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.WorkgroupPresence.workgroupDestroyed",
	"Comment": "the workgroup is being destroyed so remove all the accepted presence subscriptions.",
	"Method": "void workgroupDestroyed(){\r\n    try {\r\n        for (String bareJID : presenceSubscribers) {\r\n            Presence reply = new Presence();\r\n            reply.setTo(bareJID);\r\n            reply.setFrom(workgroup.getJID());\r\n            reply.setType(Presence.Type.unsubscribed);\r\n            workgroup.send(reply);\r\n        }\r\n        deleteRosterItems();\r\n    } catch (Exception e) {\r\n        Log.error(\"Error broadcasting available presence\", e);\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.ansi.TelnetTerminal.getRemoteSocketAddress",
	"Comment": "returns the socket address for the remote endpoint of the telnet connection",
	"Method": "SocketAddress getRemoteSocketAddress(){\r\n    return socket.getRemoteSocketAddress();\r\n}"
}, {
	"Path": "kilim.analysis.Value.make",
	"Comment": "create a new value with the given position and type and no constant value",
	"Method": "Value make(int pos,String desc,Value make,int pos,String desc,Object aConstVal){\r\n    return new Value(pos, desc, aConstVal);\r\n}"
}, {
	"Path": "com.jvmtop.openjdk.tools.ProxyClient.getMBeans",
	"Comment": "returns a map of mbeans with objectname as the key and mbeaninfo valueof a given domain.if domain is null, all mbeansare returned.if no mbean found, an empty map is returned.",
	"Method": "Map<ObjectName, MBeanInfo> getMBeans(String domain){\r\n    ObjectName name = null;\r\n    if (domain != null) {\r\n        try {\r\n            name = new ObjectName(domain + \":*\");\r\n        } catch (MalformedObjectNameException e) {\r\n            assert (false);\r\n        }\r\n    }\r\n    Set mbeans = server.queryNames(name, null);\r\n    Map<ObjectName, MBeanInfo> result = new HashMap<ObjectName, MBeanInfo>(mbeans.size());\r\n    Iterator iterator = mbeans.iterator();\r\n    while (iterator.hasNext()) {\r\n        Object object = iterator.next();\r\n        if (object instanceof ObjectName) {\r\n            ObjectName o = (ObjectName) object;\r\n            try {\r\n                MBeanInfo info = server.getMBeanInfo(o);\r\n                result.put(o, info);\r\n            } catch (IntrospectionException e) {\r\n            } catch (InstanceNotFoundException e) {\r\n            } catch (ReflectionException e) {\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.fastpath.dataforms.FormManager.getInstance",
	"Comment": "returns the singleton instance of formmanager,creating it if necessary.",
	"Method": "FormManager getInstance(){\r\n    return singleton;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.TrafficMonitor.setOnlyNotProcessedEnabled",
	"Comment": "sets if only the packets that were not processed will be printed to the console.",
	"Method": "void setOnlyNotProcessedEnabled(boolean onlyNotProcessedEnabled){\r\n    this.onlyNotProcessedEnabled = onlyNotProcessedEnabled;\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.MeterRegistry.isClosed",
	"Comment": "if the registry is closed, it will no longer accept new meters and any publishing activity will cease.",
	"Method": "boolean isClosed(){\r\n    return closed.get();\r\n}"
}, {
	"Path": "com.googlecode.lanterna.graphics.SimpleTheme.addOverride",
	"Comment": "adds an override for a particular class, or overwrites a previously defined override.",
	"Method": "Definition addOverride(Class<?> clazz,TextColor foreground,TextColor background,SGR styles){\r\n    Definition definition = new Definition(new Style(foreground, background, styles));\r\n    overrideDefinitions.put(clazz, definition);\r\n    return definition;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.ActionListBox.addItem",
	"Comment": "adds a new item to the list, which is displayed in the list using a supplied label.",
	"Method": "ActionListBox addItem(Runnable object,ActionListBox addItem,String label,Runnable action){\r\n    return addItem(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            action.run();\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return label;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.ActionListBox.addItem",
	"Comment": "adds a new item to the list, which is displayed in the list using a supplied label.",
	"Method": "ActionListBox addItem(Runnable object,ActionListBox addItem,String label,Runnable action){\r\n    action.run();\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.ActionListBox.addItem",
	"Comment": "adds a new item to the list, which is displayed in the list using a supplied label.",
	"Method": "ActionListBox addItem(Runnable object,ActionListBox addItem,String label,Runnable action){\r\n    return label;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.UserInterceptor.setFromName",
	"Comment": "sets the name that notification emails will appear to be from.",
	"Method": "void setFromName(String fromName){\r\n    this.fromName = fromName;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.CheckBoxList.isChecked",
	"Comment": "checks if a particular item is part of the check box list and returns a boolean value depending on the togglestate of the item.",
	"Method": "Boolean isChecked(V object,Boolean isChecked,int index){\r\n    if (index < 0 || index >= itemStatus.size())\r\n        return null;\r\n    return itemStatus.get(index);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.fastpath.providers.MetadataProvider.handleSet",
	"Comment": "would return true if we wished to handle setting of information from client to server.",
	"Method": "boolean handleSet(IQ packet){\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterExternalizableUtil.writeExternalizableCollection",
	"Comment": "writes a collection of externalizable objects. the collection passed as a parametermust be a collection and not a null value.",
	"Method": "void writeExternalizableCollection(DataOutput out,Collection<? extends Externalizable> value){\r\n    writeObject(out, value);\r\n}"
}, {
	"Path": "org.junit.platform.engine.TestDescriptor.getDescendants",
	"Comment": "get the immutable set of all descendants of this descriptor.\ta descendant is a child of this descriptor or a child of one of\tits children, recursively.",
	"Method": "Set<? extends TestDescriptor> getDescendants(){\r\n    Set<TestDescriptor> descendants = new LinkedHashSet();\r\n    descendants.addAll(getChildren());\r\n    for (TestDescriptor child : getChildren()) {\r\n        descendants.addAll(child.getDescendants());\r\n    }\r\n    return Collections.unmodifiableSet(descendants);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.AgentManager.getAgentSession",
	"Comment": "returns the session of the requested agent. if a session is not foundthen a null value will be return. if no agent was found for thespecified jid then an agentnotfoundexception will be thrown.",
	"Method": "AgentSession getAgentSession(JID agentJID){\r\n    return getAgent(agentJID).getAgentSession();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getWorkgroupClosedMessage",
	"Comment": "returns the message to send to the user informing that the workgroup is currently closed.",
	"Method": "String getWorkgroupClosedMessage(){\r\n    return settings.getChatSetting(KeyEnum.workgroup_closed_message).getValue();\r\n}"
}, {
	"Path": "org.junit.platform.commons.util.FunctionUtils.where",
	"Comment": "return a predicate that first applies the specified function and then\ttests the specified predicate against the result of the function.",
	"Method": "Predicate<T> where(Function<T, V> function,Predicate<? super V> predicate){\r\n    Preconditions.notNull(function, \"function must not be null\");\r\n    Preconditions.notNull(predicate, \"predicate must not be null\");\r\n    return input -> predicate.test(function.apply(input));\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.distribution.PercentileHistogramBuckets.buckets",
	"Comment": "pick values from a static set of percentile buckets that yields a decent error bound on most real worldtimers and distribution summaries because monitoring systems like prometheus require us to report thesame buckets at every interval, regardless of where actual samples have been observed.",
	"Method": "NavigableSet<Long> buckets(DistributionStatisticConfig distributionStatisticConfig){\r\n    return PERCENTILE_BUCKETS.subSet(distributionStatisticConfig.getMinimumExpectedValue(), true, distributionStatisticConfig.getMaximumExpectedValue(), true);\r\n}"
}, {
	"Path": "com.jvmtop.openjdk.tools.ProxyClient.getDomains",
	"Comment": "returns the list of domains in which any mbean iscurrently registered.",
	"Method": "String[] getDomains(){\r\n    return server.getDomains();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.emailListener.EmailListener.setPassword",
	"Comment": "sets the password to use to connect to the imap server. a null value means thatthis property needs to be configured to be used.",
	"Method": "void setPassword(String password){\r\n    JiveGlobals.setProperty(\"plugin.email.listener.password\", password);\r\n}"
}, {
	"Path": "com.drew.imaging.tiff.TiffReader.calculateTagOffset",
	"Comment": "determine the offset of a given tag within the specified ifd.",
	"Method": "int calculateTagOffset(int ifdStartOffset,int entryNumber){\r\n    return ifdStartOffset + 2 + (12 * entryNumber);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.spi.routers.WordMatchRouter.checkForHits",
	"Comment": "returns true if the query string matches results in the request map.",
	"Method": "boolean checkForHits(Map<String, List<String>> requestMap,String queryString){\r\n    setStemmingEnabled(true);\r\n    boolean foundMatch = false;\r\n    try {\r\n        RAMDirectory dir = new RAMDirectory();\r\n        IndexWriter writer = new IndexWriter(dir, analyzer, true);\r\n        BooleanQuery booleanQuery = new BooleanQuery();\r\n        Document doc = new Document();\r\n        for (String key : requestMap.keySet()) {\r\n            List<String> keyValue = requestMap.get(key);\r\n            if (keyValue != null) {\r\n                StringBuilder builder = new StringBuilder();\r\n                for (String value : keyValue) {\r\n                    if (ModelUtil.hasLength(value)) {\r\n                        builder.append(value);\r\n                        builder.append(\" \");\r\n                    }\r\n                }\r\n                doc.add(new Field(key, builder.toString(), Field.Store.YES, Field.Index.TOKENIZED));\r\n                QueryParser parser = new QueryParser(key, analyzer);\r\n                Query query = parser.parse(queryString);\r\n                booleanQuery.add(query, BooleanClause.Occur.MUST);\r\n            }\r\n        }\r\n        writer.addDocument(doc);\r\n        writer.close();\r\n        IndexSearcher searcher = new IndexSearcher(dir);\r\n        Hits hits = searcher.search(booleanQuery);\r\n        if (hits.length() > 0) {\r\n            foundMatch = true;\r\n        }\r\n        searcher.close();\r\n    } catch (Exception e) {\r\n        Log.error(e.getMessage(), e);\r\n    }\r\n    return foundMatch;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.disco.IQDiscoInfoHandler.addServerFeaturesProvider",
	"Comment": "adds a new features provider to the list of providers. the new features provider will beused whenever a disco for information is made against the workgroup service.",
	"Method": "void addServerFeaturesProvider(DiscoFeaturesProvider provider){\r\n    featuresProviders.add(provider);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.queueRequest",
	"Comment": "adds the request to a queue in the workgroup. if the workgroup is closed or the requestdoes not pass a filter then the request will be rejected and this method will return false.",
	"Method": "boolean queueRequest(UserRequest request){\r\n    RoutingManager routingManager = RoutingManager.getInstance();\r\n    boolean contains = containsValidReferer(request);\r\n    if (!contains) {\r\n        return false;\r\n    }\r\n    if (getStatus() != Workgroup.Status.OPEN) {\r\n        return false;\r\n    }\r\n    PacketError.Condition error = requestFilterFactory.getFilter().filter(request);\r\n    if (error == null) {\r\n        synchronized (routingManager) {\r\n            routingManager.routeRequest(this, request);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.RadioBoxList.isChecked",
	"Comment": "this method will see if an item, addressed by index, is the currently selected item in thisradiocheckboxlist",
	"Method": "Boolean isChecked(V object,boolean isChecked,int index){\r\n    if (index < 0 || index >= getItemCount()) {\r\n        return false;\r\n    }\r\n    return checkedIndex == index;\r\n}"
}, {
	"Path": "org.jupiter.common.util.collection.IntObjectHashMap.growSize",
	"Comment": "grows the map size after an insertion. if necessary, performs a rehash of the map.",
	"Method": "void growSize(){\r\n    size++;\r\n    if (size > maxSize) {\r\n        if (keys.length == Integer.MAX_VALUE) {\r\n            throw new IllegalStateException(\"Max capacity reached at size=\" + size);\r\n        }\r\n        rehash(keys.length << 1);\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.input.InputDecoder.getPatterns",
	"Comment": "returns a collection of all patterns registered in this inputdecoder.",
	"Method": "Collection<CharacterPattern> getPatterns(){\r\n    synchronized (bytePatterns) {\r\n        return new ArrayList<CharacterPattern>(bytePatterns);\r\n    }\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocket.onThreadsFinished",
	"Comment": "called when both the reading thread and the writing thread have finished.this method is called in the context of either the reading thread orthe writing thread.",
	"Method": "void onThreadsFinished(){\r\n    finish();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.search.ChatSearchManager.closeSearcherReader",
	"Comment": "closes the reader used by the searcher to indicate that a change to the index was made.a new searcher will be opened the next time one is requested.",
	"Method": "void closeSearcherReader(){\r\n    if (searcherReader != null) {\r\n        try {\r\n            searcherLock.writeLock().lock();\r\n            searcherReader.close();\r\n        } finally {\r\n            searcherReader = null;\r\n            searcherLock.writeLock().unlock();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.github.neuralnetworks.builder.designio.protobuf.ProtoBufNNConfigMapper.parseLearningParameter",
	"Comment": "set the learning rate and weight decay for current layer and bias layer",
	"Method": "void parseLearningParameter(LayerBuilder layerBuilder,ProtoBufWrapper.LayerParameter layerParameter,float generalLearningRage,float generalL1WeightDecay,boolean useBias){\r\n    if (layerBuilder instanceof LearnableLayer) {\r\n        if (layerParameter.getBlobsLrCount() > 0) {\r\n            ((LearnableLayer) layerBuilder).setLearningRate(generalLearningRage * layerParameter.getBlobsLr(0));\r\n        }\r\n        if (layerParameter.getWeightDecayCount() > 0) {\r\n            ((LearnableLayer) layerBuilder).setL1weightDecay(generalL1WeightDecay * layerParameter.getWeightDecay(0));\r\n        }\r\n    }\r\n    if (layerBuilder instanceof BiasLayerConnectable && useBias) {\r\n        if (layerParameter.getBlobsLrCount() > 1) {\r\n            ((BiasLayerConnectable) layerBuilder).setBiasLearningRate(generalLearningRage * layerParameter.getBlobsLr(1));\r\n        }\r\n        if (layerParameter.getWeightDecayCount() > 1) {\r\n            ((BiasLayerConnectable) layerBuilder).setBiasL1weightDecay(generalL1WeightDecay * layerParameter.getWeightDecay(1));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.emailListener.EmailListener.getPort",
	"Comment": "returns the port where the imap server is listening. by default unsecured connectionsuse port 143 and secured ones use 993.",
	"Method": "int getPort(){\r\n    return JiveGlobals.getIntProperty(\"plugin.email.listener.port\", isSSLEnabled() ? 993 : 143);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.Conversation.isExternal",
	"Comment": "returns true if one of the conversation participants is on an external server.",
	"Method": "boolean isExternal(){\r\n    return external;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.spi.ChatHistoryUtils.getAverageChatLengthForServer",
	"Comment": "returns the average chat time for all workgroups in the server.",
	"Method": "long getAverageChatLengthForServer(){\r\n    int numberOfChats = getTotalChatsInSystem();\r\n    long chatLength = getTotalTimeForAllChatsInServer();\r\n    if (numberOfChats == 0) {\r\n        return 0;\r\n    }\r\n    return chatLength / numberOfChats;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.setIdleTimeout",
	"Comment": "sets the time to wait before considering an idle session candidate to be removed.",
	"Method": "void setIdleTimeout(long timeout){\r\n    try {\r\n        workgroup.getProperties().setProperty(\"chatbot.session.timeout\", String.valueOf(timeout));\r\n    } catch (UnauthorizedException e) {\r\n        Log.error(\"Error setting timeout\", e);\r\n    }\r\n}"
}, {
	"Path": "org.jdbi.v3.sqlobject.transaction.Transactional.inTransaction",
	"Comment": "executes the given callback within a transaction, returning the value returned by the callback.",
	"Method": "R inTransaction(TransactionalCallback<R, This, X> callback,R inTransaction,TransactionIsolationLevel isolation,TransactionalCallback<R, This, X> callback){\r\n    return getHandle().inTransaction(isolation, h -> callback.inTransaction((This) this));\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.ansi.ANSITerminal.getDefaultKeyDecodingProfile",
	"Comment": "this method can be overridden in a custom terminal implementation to change the default key decoders.",
	"Method": "KeyDecodingProfile getDefaultKeyDecodingProfile(){\r\n    return new DefaultKeyDecodingProfile();\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.TerminalEmulatorColorConfiguration.newInstance",
	"Comment": "creates a new color configuration based on a particular palette and with using brighter colors on bold text.",
	"Method": "TerminalEmulatorColorConfiguration newInstance(TerminalEmulatorPalette colorPalette){\r\n    return new TerminalEmulatorColorConfiguration(colorPalette, true);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.permissions.PermissionManager.getGroupForGateway",
	"Comment": "returns the name of the group the usage is limited for the given gateway",
	"Method": "String getGroupForGateway(String gateway){\r\n    return JiveGlobals.getProperty(\"plugin.remoteroster.permissiongroup.\" + gateway, \"\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ArchiveSearch.getIncludeTimestamp",
	"Comment": "returns the timestamp to use for filtering conversations. this timestamphas to be between the time when the conversation started and ended.",
	"Method": "Date getIncludeTimestamp(){\r\n    return includeTimestamp;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterExternalizableUtil.writeStringsMap",
	"Comment": "writes a map of string key and set of strings value pairs. this method does not handle thecase when the map is null.",
	"Method": "void writeStringsMap(DataOutput out,Map<String, Set<String>> map){\r\n    writeObject(out, map);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.search.ChatSearchManager.getAnalyzerClass",
	"Comment": "returns the lucene analyzer class that is be used for indexing. the analyzer classname is stored as the jive property workgroup.search.analyzer.classname.",
	"Method": "String getAnalyzerClass(){\r\n    String analyzerClass = JiveGlobals.getProperty(\"workgroup.search.analyzer.className\");\r\n    if (analyzerClass == null) {\r\n        return StandardAnalyzer.class.getName();\r\n    } else {\r\n        return analyzerClass;\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.Panel.addComponent",
	"Comment": "adds a new child component to the panel. where within the panel the child will be displayed is up to the layoutmanager assigned to this panel. if the component has already been added to another panel, it will first beremoved from that panel before added to this one.",
	"Method": "Panel addComponent(Component component,Panel addComponent,Component component,LayoutData layoutData){\r\n    if (component != null) {\r\n        component.setLayoutData(layoutData);\r\n        addComponent(component);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.drew.metadata.iptc.IptcDirectory.getDateSent",
	"Comment": "parses the date sent tag and the time sent tag to obtain a single date object representing thedate and time when the service sent this image.",
	"Method": "Date getDateSent(){\r\n    return getDate(TAG_DATE_SENT, TAG_TIME_SENT);\r\n}"
}, {
	"Path": "com.drew.lang.RandomAccessReader.getS15Fixed16",
	"Comment": "gets a s15.16 fixed point float from the buffer.this particular fixed point encoding has one sign bit, 15 numerator bits and 16 denominator bits.",
	"Method": "float getS15Fixed16(int index){\r\n    validateIndex(index, 4);\r\n    if (_isMotorolaByteOrder) {\r\n        float res = (getByte(index) & 0xFF) << 8 | (getByte(index + 1) & 0xFF);\r\n        int d = (getByte(index + 2) & 0xFF) << 8 | (getByte(index + 3) & 0xFF);\r\n        return (float) (res + d / 65536.0);\r\n    } else {\r\n        float res = (getByte(index + 3) & 0xFF) << 8 | (getByte(index + 2) & 0xFF);\r\n        int d = (getByte(index + 1) & 0xFF) << 8 | (getByte(index) & 0xFF);\r\n        return (float) (res + d / 65536.0);\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.TerminalEmulatorDeviceConfiguration.withCursorBlinking",
	"Comment": "copies the current configuration. the new object has the given value.",
	"Method": "TerminalEmulatorDeviceConfiguration withCursorBlinking(boolean cursorBlinking){\r\n    if (this.cursorBlinking == cursorBlinking) {\r\n        return this;\r\n    } else {\r\n        return new TerminalEmulatorDeviceConfiguration(this.lineBufferScrollbackSize, this.blinkLengthInMilliSeconds, this.cursorStyle, this.cursorColor, cursorBlinking, this.clipboardAvailable);\r\n    }\r\n}"
}, {
	"Path": "org.jupiter.transport.netty.handler.IdleStateChecker.getReaderIdleTimeInMillis",
	"Comment": "return the readeridletime that was given when instance this class in milliseconds.",
	"Method": "long getReaderIdleTimeInMillis(){\r\n    return readerIdleTimeMillis;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.table.Table.setSelectedColumn",
	"Comment": "if in cell selection mode, updates which column is selected and ensures the selected column is visible in theview. if not in cell selection mode, does nothing.",
	"Method": "Table<V> setSelectedColumn(int selectedColumn){\r\n    if (cellSelection) {\r\n        this.selectedColumn = selectedColumn;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.javamonitor.JmxHelper.unregisterCoolMBeans",
	"Comment": "unregister all the useful mbeans from the jmx registry. we assume thatthe registered beans were registered in the platform mbean server.",
	"Method": "void unregisterCoolMBeans(){\r\n    unregister(serverObjectName);\r\n    unregister(Threading.objectName);\r\n    unregister(DNSCachePolicy.objectName);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.input.EscapeSequenceCharacterPattern.getKeyStroke",
	"Comment": "combines a keytype and modifiers into a keystroke.subclasses can override this for customization purposes.",
	"Method": "KeyStroke getKeyStroke(KeyType key,int mods){\r\n    boolean bShift = false, bCtrl = false, bAlt = false;\r\n    if (key == null) {\r\n        return null;\r\n    }\r\n    if (mods >= 0) {\r\n        bShift = (mods & SHIFT) != 0;\r\n        bAlt = (mods & ALT) != 0;\r\n        bCtrl = (mods & CTRL) != 0;\r\n    }\r\n    return new KeyStroke(key, bCtrl, bAlt, bShift);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.SparkManager.closeSession",
	"Comment": "sends an unsupported version error and name of client the user attempted to connect with.",
	"Method": "void closeSession(Session session,String clientName){\r\n    disconnects.incrementAndGet();\r\n    Log.debug(\"Closed connection to client attempting to connect from \" + clientName);\r\n    final Message message = new Message();\r\n    message.setFrom(serviceName + \".\" + componentManager.getServerName());\r\n    message.setTo(session.getAddress());\r\n    message.setBody(\"You are using an invalid client, and therefore will be disconnected. \" + \"Please ask your system administrator for client choices.\");\r\n    sendPacket(message);\r\n    taskEngine.schedule(new TimerTask() {\r\n        @Override\r\n        public void run() {\r\n            StreamError error = new StreamError(StreamError.Condition.policy_violation);\r\n            session.deliverRawText(error.toXML());\r\n            session.close();\r\n        }\r\n    }, 5000);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.SparkManager.closeSession",
	"Comment": "sends an unsupported version error and name of client the user attempted to connect with.",
	"Method": "void closeSession(Session session,String clientName){\r\n    StreamError error = new StreamError(StreamError.Condition.policy_violation);\r\n    session.deliverRawText(error.toXML());\r\n    session.close();\r\n}"
}, {
	"Path": "org.jupiter.common.util.internal.UnsafeUpdater.newReferenceFieldUpdater",
	"Comment": "creates and returns an updater for objects with the given field.",
	"Method": "UnsafeReferenceFieldUpdater<U, W> newReferenceFieldUpdater(Class<? super U> tClass,String fieldName){\r\n    try {\r\n        return new UnsafeReferenceFieldUpdater(UnsafeUtil.getUnsafe(), tClass, fieldName);\r\n    } catch (Throwable t) {\r\n        ThrowUtil.throwException(t);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cluster.NodeRuntimeStats.getNodeInfo",
	"Comment": "returns a map of hazelcastruntimestats.nodeinfo objects keyed by cluster member objects.a nodeinfo object is a collection of various node stats.",
	"Method": "Map<NodeID, NodeInfo> getNodeInfo(){\r\n    Collection<NodeInfo> taskResult = CacheFactory.doSynchronousClusterTask(new NodeInfoTask(), true);\r\n    Map<NodeID, NodeInfo> result = new HashMap();\r\n    for (NodeInfo nodeInfo : taskResult) {\r\n        NodeID nodeId = NodeID.getInstance(nodeInfo.getNodeId());\r\n        result.put(nodeId, nodeInfo);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.UserInterceptor.setFromEmail",
	"Comment": "sets the email address that notification emails will appear to be from.",
	"Method": "void setFromEmail(String fromEmail){\r\n    this.fromEmail = fromEmail;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.sessions.TransportSessionManager.registerUserTo",
	"Comment": "register is seperate to connect because a user may register to transport but not connect to it, e.g. with wrong credentials.we still want to keep track of those registrations so we know they happened and we can reset them",
	"Method": "void registerUserTo(String transport,String user){\r\n    db.insertOrUpdateSession(transport, user, 0);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.AWTTerminalFrame.addInput",
	"Comment": "takes a keystroke and puts it on the input queue of the terminal emulator. this way you can insert syntheticinput events to be processed as if they came from the user typing on the keyboard.",
	"Method": "void addInput(KeyStroke keyStroke){\r\n    awtTerminal.addInput(keyStroke);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.stats.StatisticsModule.addActiveSessionsStatistic",
	"Comment": "tracks the number of active sessions with the server at any point in time.active sessions are defined as one client connection.",
	"Method": "void addActiveSessionsStatistic(){\r\n    Statistic activeSessionStatistic = new i18nStatistic(SESSIONS_KEY, MonitoringConstants.NAME, Statistic.Type.count) {\r\n        public double sample() {\r\n            return SessionManager.getInstance().getUserSessionsCount(false);\r\n        }\r\n        public boolean isPartialSample() {\r\n            return false;\r\n        }\r\n    };\r\n    statisticsManager.addStatistic(SESSIONS_KEY, activeSessionStatistic);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.stats.StatisticsModule.addActiveSessionsStatistic",
	"Comment": "tracks the number of active sessions with the server at any point in time.active sessions are defined as one client connection.",
	"Method": "void addActiveSessionsStatistic(){\r\n    return SessionManager.getInstance().getUserSessionsCount(false);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.stats.StatisticsModule.addActiveSessionsStatistic",
	"Comment": "tracks the number of active sessions with the server at any point in time.active sessions are defined as one client connection.",
	"Method": "void addActiveSessionsStatistic(){\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Agent.sendAgentRemovedToAllAgents",
	"Comment": "this agent has been removed from a queue so we need to inform the existing agents of thequeue ,that previously requested agent information, of the agent deletion.",
	"Method": "void sendAgentRemovedToAllAgents(RequestQueue requestQueue){\r\n    Workgroup workgroup = requestQueue.getWorkgroup();\r\n    for (AgentSession session : workgroup.getAgentSessions()) {\r\n        if (session.hasRequestedAgentInfo()) {\r\n            IQ iq = new IQ(IQ.Type.set);\r\n            iq.setFrom(workgroup.getJID());\r\n            iq.setTo(session.getJID());\r\n            Element agentStatusRequest = iq.setChildElement(\"agent-status-request\", \"http://jabber.org/protocol/workgroup\");\r\n            Element agentInfo = getAgentInfo();\r\n            agentInfo.addAttribute(\"type\", \"remove\");\r\n            agentStatusRequest.add(agentInfo);\r\n            workgroup.send(iq);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.UserInterceptor.setEmailNotifyList",
	"Comment": "sets the list of email addresses that will be notified when a user is banned.",
	"Method": "void setEmailNotifyList(String notifyList){\r\n    if (notifyList == null || notifyList.equals(\"\")) {\r\n        emailNotifyList = null;\r\n    } else {\r\n        emailNotifyList = new ArrayList<String>();\r\n        StringTokenizer tokenizer = new StringTokenizer(notifyList, \",\");\r\n        while (tokenizer.hasMoreTokens()) {\r\n            String emailAddress = tokenizer.nextToken().trim();\r\n            emailNotifyList.add(emailAddress);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.RequestFilterFactory.loadProviders",
	"Comment": "loads the provider names from the jive properties config file.",
	"Method": "void loadProviders(){\r\n    if (factory == null) {\r\n        synchronized (classNames) {\r\n            if (factory == null) {\r\n                try {\r\n                    Class[] providers = new Class[classNames.length];\r\n                    for (int i = 0; i < classNames.length; i++) {\r\n                        JiveGlobals.migrateProperty(propNames[i]);\r\n                        String className = classNames[i];\r\n                        String classNameProp = JiveGlobals.getProperty(propNames[i]);\r\n                        if (classNameProp != null) {\r\n                            className = classNameProp;\r\n                        }\r\n                        try {\r\n                            providers[i] = ClassUtils.forName(className);\r\n                        } catch (Exception e) {\r\n                            Log.error(\"Exception loading class: \" + className, e);\r\n                        }\r\n                    }\r\n                    setProviders(providers);\r\n                } catch (Exception e) {\r\n                    Log.error(\"Exception loading class: \" + classNames, e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "kilim.AffineScheduler.waitIdle",
	"Comment": "wait till there are no pending timers no running tasks no tasks waiting to be run",
	"Method": "boolean waitIdle(int delay){\r\n    while (!Thread.interrupted()) {\r\n        if (resolved(timerService))\r\n            return true;\r\n        try {\r\n            Thread.sleep(delay);\r\n        } catch (InterruptedException ex) {\r\n            break;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "kilim.test.ex.ExYieldDups.useLongArg",
	"Comment": "test whether the weaver is correctly marking val as used after the pause",
	"Method": "void useLongArg(long index,LongVal val){\r\n    if (doPause)\r\n        Task.sleep(50);\r\n    val.msg = index;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.base.RemoteRosterPlugin.listenToSettings",
	"Comment": "registers a listener for jiveglobals. we might restart our service, ifthere were some changes for our gateways",
	"Method": "void listenToSettings(){\r\n    _settingsObserver = new RemoteRosterPropertyListener() {\r\n        @Override\r\n        protected void changedProperty(String prop) {\r\n            updateInterceptors(prop);\r\n        }\r\n    };\r\n    PropertyEventDispatcher.addListener(_settingsObserver);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.base.RemoteRosterPlugin.listenToSettings",
	"Comment": "registers a listener for jiveglobals. we might restart our service, ifthere were some changes for our gateways",
	"Method": "void listenToSettings(){\r\n    updateInterceptors(prop);\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.OpeningHandshakeException.getHeaders",
	"Comment": "get the http headers contained in the websocket opening handshakeresponse from the server.",
	"Method": "Map<String, List<String>> getHeaders(){\r\n    return mHeaders;\r\n}"
}, {
	"Path": "io.micrometer.prometheus.PrometheusTimer.histogramCounts",
	"Comment": "for prometheus we cannot use the histogram counts from histogramsnapshot, as it is based on arolling histogram. prometheus requires a histogram that accumulates values over the lifetime of the app.",
	"Method": "CountAtBucket[] histogramCounts(){\r\n    return histogram == null ? EMPTY_HISTOGRAM : histogram.takeSnapshot(0, 0, 0).histogramCounts();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.QueueInterceptorManager.getInstance",
	"Comment": "returns a singleton instance of queueinterceptormanager.",
	"Method": "InterceptorManager getInstance(){\r\n    return instance;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.utils.ModelUtil.nullifyIfEmpty",
	"Comment": "returns null if the specified string is empty ornull.otherwise the string itself is returned.",
	"Method": "String nullifyIfEmpty(String s){\r\n    return ModelUtil.hasLength(s) ? s : null;\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.util.JsonUtils.appendIndentedNewLine",
	"Comment": "print a new line with indention at the beginning of the new line.",
	"Method": "void appendIndentedNewLine(int indentLevel,StringBuilder stringBuilder){\r\n    stringBuilder.append(\"\\n\");\r\n    for (int i = 0; i < indentLevel; i++) {\r\n        stringBuilder.append(\"  \");\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.event.WorkgroupEventDispatcher.agentJoinedChatSupport",
	"Comment": "notification message that an agent has joined a chat session. the agent couldbe the initial agent that accepted the initial offer or may be an agent thatwas invited to participate in the chat or maybe an agent that accepted a chattranfer.",
	"Method": "void agentJoinedChatSupport(Workgroup workgroup,String sessionID,AgentSession agentSession){\r\n    for (WorkgroupEventListener listener : listeners) {\r\n        try {\r\n            listener.agentJoinedChatSupport(workgroup, sessionID, agentSession);\r\n        } catch (Exception e) {\r\n            Log.error(e.getMessage(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.GridLayout.createHorizontallyEndAlignedLayoutData",
	"Comment": "this is a shortcut method that will create a grid layout data object that will expand its cell as much as is canvertically and make the component occupy the whole area vertically and center it horizontally",
	"Method": "LayoutData createHorizontallyEndAlignedLayoutData(int horizontalSpan){\r\n    return createLayoutData(Alignment.END, Alignment.CENTER, true, false, horizontalSpan, 1);\r\n}"
}, {
	"Path": "com.jvmtop.monitor.VMInfo.createDeadVM",
	"Comment": "creates a dead vminfo, representing a jvm in a given statewhich cannot be attached or other monitoring issues occurred.",
	"Method": "VMInfo createDeadVM(int vmid,LocalVirtualMachine localVm,VMInfo createDeadVM,int vmid,LocalVirtualMachine localVm,VMInfoState state){\r\n    VMInfo vmInfo = new VMInfo();\r\n    vmInfo.state_ = state;\r\n    vmInfo.localVm_ = localVm;\r\n    return vmInfo;\r\n}"
}, {
	"Path": "com.jvmtop.openjdk.tools.MemoryPoolStat.getAfterGcUsage",
	"Comment": "returns the memory usage after the most recent gc finished.null if no gc occurs.",
	"Method": "MemoryUsage getAfterGcUsage(){\r\n    return beforeGcUsage;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.dialogs.AbstractDialogBuilder.getExtraWindowHints",
	"Comment": "returns the list of extra window hints that will be assigned to the window when built",
	"Method": "Set<Window.Hint> getExtraWindowHints(){\r\n    return extraWindowHints;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.messagefilter.processors.IQRosterPayloadProcessor.deleteSubdomainItemsFromRoster",
	"Comment": "searches the users roster for a specific subdomain and deletes all contacts that contain subdomain",
	"Method": "void deleteSubdomainItemsFromRoster(String username,String subdomain){\r\n    try {\r\n        Roster roster = _rosterManager.getRoster(username);\r\n        Collection<RosterItem> items = roster.getRosterItems();\r\n        for (RosterItem item : items) {\r\n            String itemName = item.getJid().toString();\r\n            if (itemName.contains(subdomain)) {\r\n                Log.debug(\"Removing contact \" + item.getJid().toString() + \" from contact list because of Unregister.\");\r\n                roster.deleteRosterItem(item.getJid(), false);\r\n            }\r\n        }\r\n    } catch (UserNotFoundException e) {\r\n        Log.debug(\"Couldnt find User!\" + e.toString());\r\n    } catch (SharedGroupException e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.jupiter.transport.netty.NettyAcceptor.createWriteBufferWaterMark",
	"Comment": "create a writebufferwatermark is used to set low water mark and high water mark for the write buffer.",
	"Method": "WriteBufferWaterMark createWriteBufferWaterMark(int bufLowWaterMark,int bufHighWaterMark){\r\n    WriteBufferWaterMark waterMark;\r\n    if (bufLowWaterMark >= 0 && bufHighWaterMark > 0) {\r\n        waterMark = new WriteBufferWaterMark(bufLowWaterMark, bufHighWaterMark);\r\n    } else {\r\n        waterMark = new WriteBufferWaterMark(512 * 1024, 1024 * 1024);\r\n    }\r\n    return waterMark;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterExternalizableUtil.writeSerializableCollection",
	"Comment": "writes a collection of serializable objects. the collection passed as a parametermust be a collection and not a null value.",
	"Method": "void writeSerializableCollection(DataOutput out,Collection<? extends Serializable> value){\r\n    writeObject(out, value);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.request.UserRequest.removeRelatedRequest",
	"Comment": "remvoes a request that is no longer related to this user request.",
	"Method": "void removeRelatedRequest(Request request){\r\n    relatedRequests.remove(request);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ConversationManager.setRoomsArchived",
	"Comment": "sets list of room names whose messages will be archived. when room archiving is enabled and this list is empty then messages of all local roomswill be archived. however, when name of rooms are defined in this list then only messages of those rooms will be archived.",
	"Method": "void setRoomsArchived(Collection<String> roomsArchived){\r\n    this.roomsArchived = roomsArchived;\r\n    JiveGlobals.setProperty(\"conversation.roomsArchived\", StringUtils.collectionToString(roomsArchived));\r\n}"
}, {
	"Path": "org.jdbi.v3.sqlobject.statement.internal.CustomizingStatementHandler.defaultParameterCustomizer",
	"Comment": "default parameter customizer for parameters with no annotations.",
	"Method": "BoundCustomizer defaultParameterCustomizer(Class<?> type,Method method,Parameter parameter,Integer i){\r\n    return (stmt, args) -> getDefaultParameterCustomizerFactory(stmt).createForParameter(type, method, parameter, i, getParameterType(parameter)).apply(stmt, args[i]);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getSendEmailQuestion",
	"Comment": "returns the message to send to the user asking if he wants to receive the chat transcriptby email.",
	"Method": "String getSendEmailQuestion(){\r\n    return settings.getChatSetting(KeyEnum.send_email_question).getValue();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.sendOccupantsInfo",
	"Comment": "sends information to the agent that requested it about the occupants in the specifiedroom. if the room does no longer exist then no information will be returned. this meansthat the chat should be happening at the moment of the query.",
	"Method": "void sendOccupantsInfo(IQ packet,String roomID){\r\n    IQ statusPacket = IQ.createResultIQ(packet);\r\n    Element occupantsInfo = statusPacket.setChildElement(\"occupants-info\", \"http://jivesoftware.com/protocol/workgroup\");\r\n    occupantsInfo.addAttribute(\"roomID\", roomID);\r\n    Map<Packet, java.util.Date> packets = transcripts.get(roomID);\r\n    if (packets != null) {\r\n        Collection<String> processed = new ArrayList<String>();\r\n        for (Packet p : packets.keySet()) {\r\n            if (p instanceof Presence) {\r\n                Presence presence = (Presence) p;\r\n                String userJID = presence.getChildElement(\"x\", \"http://jabber.org/protocol/muc#user\").element(\"item\").attributeValue(\"jid\");\r\n                if (!processed.contains(userJID)) {\r\n                    processed.add(userJID);\r\n                    Element occupantInfo = occupantsInfo.addElement(\"occupant\");\r\n                    occupantInfo.addElement(\"jid\").setText(userJID);\r\n                    occupantInfo.addElement(\"nickname\").setText(presence.getFrom().getResource());\r\n                    occupantInfo.addElement(\"joined\").setText(UTC_FORMAT.format(packets.get(p)));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    send(statusPacket);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.TerminalEmulatorDeviceConfiguration.withBlinkLengthInMilliSeconds",
	"Comment": "copies the current configuration. the new object has the given value.",
	"Method": "TerminalEmulatorDeviceConfiguration withBlinkLengthInMilliSeconds(int blinkLengthInMilliSeconds){\r\n    if (this.blinkLengthInMilliSeconds == blinkLengthInMilliSeconds) {\r\n        return this;\r\n    } else {\r\n        return new TerminalEmulatorDeviceConfiguration(this.lineBufferScrollbackSize, blinkLengthInMilliSeconds, this.cursorStyle, this.cursorColor, this.cursorBlinking, this.clipboardAvailable);\r\n    }\r\n}"
}, {
	"Path": "org.junit.platform.commons.support.ReflectionSupport.findNestedClasses",
	"Comment": "find all nested classes within the given class that conform to the given\tpredicate.",
	"Method": "List<Class<?>> findNestedClasses(Class<?> clazz,Predicate<Class<?>> predicate){\r\n    return ReflectionUtils.findNestedClasses(clazz, predicate);\r\n}"
}, {
	"Path": "com.drew.metadata.exif.GpsDirectory.getGeoLocation",
	"Comment": "parses various tags in an attempt to obtain a single object representing the latitude and longitudeat which this image was captured.",
	"Method": "GeoLocation getGeoLocation(){\r\n    Rational[] latitudes = getRationalArray(TAG_LATITUDE);\r\n    Rational[] longitudes = getRationalArray(TAG_LONGITUDE);\r\n    String latitudeRef = getString(TAG_LATITUDE_REF);\r\n    String longitudeRef = getString(TAG_LONGITUDE_REF);\r\n    if (latitudes == null || latitudes.length != 3)\r\n        return null;\r\n    if (longitudes == null || longitudes.length != 3)\r\n        return null;\r\n    if (latitudeRef == null || longitudeRef == null)\r\n        return null;\r\n    Double lat = GeoLocation.degreesMinutesSecondsToDecimal(latitudes[0], latitudes[1], latitudes[2], latitudeRef.equalsIgnoreCase(\"S\"));\r\n    Double lon = GeoLocation.degreesMinutesSecondsToDecimal(longitudes[0], longitudes[1], longitudes[2], longitudeRef.equalsIgnoreCase(\"W\"));\r\n    if (lat == null || lon == null)\r\n        return null;\r\n    return new GeoLocation(lat, lon);\r\n}"
}, {
	"Path": "com.reucon.openfire.plugin.archive.xep0136.RemoveRequest.getStart",
	"Comment": "if the start date is before all the collections in the archive then all collections priorto the end date are removed.",
	"Method": "Date getStart(){\r\n    return start;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ArchiveIndexer.updateIndex",
	"Comment": "updates the search index with all new conversation data since the last index update.",
	"Method": "void updateIndex(){\r\n    if (stopped) {\r\n        return;\r\n    }\r\n    if (!conversationManager.isArchivingEnabled()) {\r\n        return;\r\n    }\r\n    if (rebuildInProgress) {\r\n        return;\r\n    }\r\n    writerLock.lock();\r\n    IndexModifier writer = null;\r\n    try {\r\n        writer = new IndexModifier(directory, new StandardAnalyzer(), false);\r\n        List<Long> conversationIDs = new ArrayList<Long>();\r\n        Connection con = null;\r\n        PreparedStatement pstmt = null;\r\n        ResultSet rs = null;\r\n        try {\r\n            con = DbConnectionManager.getConnection();\r\n            pstmt = con.prepareStatement(NEW_CONVERSATIONS);\r\n            pstmt.setLong(1, lastModified);\r\n            rs = pstmt.executeQuery();\r\n            while (rs.next()) {\r\n                conversationIDs.add(rs.getLong(1));\r\n            }\r\n        } catch (SQLException sqle) {\r\n            Log.error(sqle.getMessage(), sqle);\r\n        } finally {\r\n            DbConnectionManager.closeConnection(rs, pstmt, con);\r\n        }\r\n        for (long conversationID : conversationIDs) {\r\n            writer.deleteDocuments(new Term(\"conversationID\", Long.toString(conversationID)));\r\n        }\r\n        Map<Long, Boolean> externalMetaData = new HashMap<Long, Boolean>();\r\n        for (long conversationID : conversationIDs) {\r\n            try {\r\n                con = DbConnectionManager.getConnection();\r\n                pstmt = con.prepareStatement(CONVERSATION_METADATA);\r\n                pstmt.setLong(1, conversationID);\r\n                rs = pstmt.executeQuery();\r\n                while (rs.next()) {\r\n                    externalMetaData.put(conversationID, rs.getInt(1) == 1);\r\n                }\r\n            } catch (SQLException sqle) {\r\n                Log.error(sqle.getMessage(), sqle);\r\n            } finally {\r\n                DbConnectionManager.closeConnection(rs, pstmt, con);\r\n            }\r\n        }\r\n        long newestDate = indexConversations(conversationIDs, externalMetaData, writer, false);\r\n        writer.optimize();\r\n        if (newestDate != -1) {\r\n            lastModified = newestDate;\r\n            indexProperties.setProperty(\"lastModified\", Long.toString(lastModified));\r\n        }\r\n    } catch (IOException ioe) {\r\n        Log.error(ioe.getMessage(), ioe);\r\n    } finally {\r\n        if (writer != null) {\r\n            try {\r\n                writer.close();\r\n            } catch (Exception e) {\r\n                Log.error(e.getMessage(), e);\r\n            }\r\n        }\r\n        writerLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.config.MeterFilter.replaceTagValues",
	"Comment": "replace tag values according to the provided mapping for all matching tag keys. this can be usedto reduce the total cardinality of a tag by mapping some portion of tag values to something else.",
	"Method": "MeterFilter replaceTagValues(String tagKey,Function<String, String> replacement,String exceptions){\r\n    return new MeterFilter() {\r\n        @Override\r\n        public Meter.Id map(Meter.Id id) {\r\n            List<Tag> tags = stream(id.getTagsAsIterable().spliterator(), false).map(t -> {\r\n                if (!t.getKey().equals(tagKey))\r\n                    return t;\r\n                for (String exception : exceptions) {\r\n                    if (t.getValue().equals(exception))\r\n                        return t;\r\n                }\r\n                return Tag.of(tagKey, replacement.apply(t.getValue()));\r\n            }).collect(toList());\r\n            return id.replaceTags(tags);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.config.MeterFilter.replaceTagValues",
	"Comment": "replace tag values according to the provided mapping for all matching tag keys. this can be usedto reduce the total cardinality of a tag by mapping some portion of tag values to something else.",
	"Method": "MeterFilter replaceTagValues(String tagKey,Function<String, String> replacement,String exceptions){\r\n    List<Tag> tags = stream(id.getTagsAsIterable().spliterator(), false).map(t -> {\r\n        if (!t.getKey().equals(tagKey))\r\n            return t;\r\n        for (String exception : exceptions) {\r\n            if (t.getValue().equals(exception))\r\n                return t;\r\n        }\r\n        return Tag.of(tagKey, replacement.apply(t.getValue()));\r\n    }).collect(toList());\r\n    return id.replaceTags(tags);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.session.RemoteSession.doClusterTask",
	"Comment": "invokes a task on the remote cluster member in an asynchronous fashion.",
	"Method": "void doClusterTask(ClusterTask task){\r\n    ClusterNodeInfo info = CacheFactory.getClusterNodeInfo(nodeID);\r\n    if (info == null && task instanceof RemoteSessionTask) {\r\n        Session remoteSession = ((RemoteSessionTask) task).getSession();\r\n        if (remoteSession instanceof ClientSession) {\r\n            SessionManager.getInstance().removeSession(null, remoteSession.getAddress(), false, false);\r\n        }\r\n    } else {\r\n        CacheFactory.doClusterTask(task, nodeID);\r\n    }\r\n}"
}, {
	"Path": "io.moquette.broker.PostOfficeSubscribeTest.testCleanSession_correctlyClientSubscriptions",
	"Comment": "check that after a client has connected with clean session false, subscribed to some topicand exited, if it reconnects with clean session true, the broker correctly cleanup everyprevious subscription",
	"Method": "void testCleanSession_correctlyClientSubscriptions(){\r\n    connection.processConnect(connectMessage);\r\n    ConnectionTestUtils.assertConnectAccepted(channel);\r\n    assertEquals(\"After CONNECT subscription MUST be empty\", 0, subscriptions.size());\r\n    final MqttSubscribeMessage subscribeMsg = MqttMessageBuilders.subscribe().addSubscription(AT_MOST_ONCE, NEWS_TOPIC).messageId(1).build();\r\n    connection.processSubscribe(subscribeMsg);\r\n    assertEquals(\"Subscribe MUST contain one subscription\", 1, subscriptions.size());\r\n    connection.processDisconnect(null);\r\n    assertEquals(\"Disconnection MUSTN'T clear subscriptions\", 1, subscriptions.size());\r\n    connectMessage = MqttMessageBuilders.connect().clientId(FAKE_CLIENT_ID).cleanSession(true).build();\r\n    channel = new EmbeddedChannel();\r\n    connection = createMQTTConnection(CONFIG, channel);\r\n    connection.processConnect(connectMessage);\r\n    ConnectionTestUtils.assertConnectAccepted(channel);\r\n    assertEquals(\"After CONNECT with clean, subscription MUST be empty\", 0, subscriptions.size());\r\n    final ByteBuf payload = Unpooled.copiedBuffer(\"Hello world!\", Charset.defaultCharset());\r\n    sut.receivedPublishQos0(new Topic(NEWS_TOPIC), TEST_USER, TEST_PWD, payload, false, MqttMessageBuilders.publish().payload(payload).qos(MqttQoS.AT_MOST_ONCE).retained(false).topicName(NEWS_TOPIC).build());\r\n    ConnectionTestUtils.verifyNoPublishIsReceived(channel);\r\n}"
}, {
	"Path": "org.jupiter.common.concurrent.queues.LinkedQueueNode.getAndNullValue",
	"Comment": "gets the current value and nulls out the reference to it from this node.",
	"Method": "E getAndNullValue(){\r\n    E temp = lpValue();\r\n    spValue(null);\r\n    return temp;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.Conversation.getMessageCount",
	"Comment": "returns the number of messages that make up the conversation.",
	"Method": "int getMessageCount(){\r\n    return messageCount;\r\n}"
}, {
	"Path": "org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.configurationParameters",
	"Comment": "add all of the supplied configuration parameters to the request.",
	"Method": "LauncherDiscoveryRequestBuilder configurationParameters(Map<String, String> configurationParameters){\r\n    Preconditions.notNull(configurationParameters, \"configuration parameters map must not be null\");\r\n    configurationParameters.forEach(this::configurationParameter);\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ArchiveSearch.getDateRangeMax",
	"Comment": "returns the date that represents the upper boundary for conversationsthat will be returned by the search. if this value has not been set, the methodwill return null.",
	"Method": "Date getDateRangeMax(){\r\n    return dateRangeMax;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.commands.GetGroupConversationTranscript.hasPermission",
	"Comment": "returns if the requester can access this command. admins and components are allowed toexecute this command.",
	"Method": "boolean hasPermission(JID requester){\r\n    InternalComponentManager componentManager = (InternalComponentManager) ComponentManagerFactory.getComponentManager();\r\n    return super.hasPermission(requester) || componentManager.hasComponent(requester);\r\n}"
}, {
	"Path": "gab.opencv.OpenCV.setROI",
	"Comment": "set a region of interest within the image. subsequent image processing\tfunctions will apply to this roi rather than the full image.\tfull image will display be included in output.",
	"Method": "boolean setROI(int x,int y,int w,int h){\r\n    if (x < 0 || x + w > width || y < 0 || y + h > height) {\r\n        return false;\r\n    } else {\r\n        roiWidth = w;\r\n        roiHeight = h;\r\n        if (useColor) {\r\n            nonROImat = matBGRA;\r\n            matROI = new Mat(matBGRA, new Rect(x, y, w, h));\r\n        } else {\r\n            nonROImat = matGray;\r\n            matROI = new Mat(matGray, new Rect(x, y, w, h));\r\n        }\r\n        useROI = true;\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TerminalSize.withRows",
	"Comment": "creates a new size based on this size, but with a different height",
	"Method": "TerminalSize withRows(int rows){\r\n    if (this.rows == rows) {\r\n        return this;\r\n    }\r\n    if (rows == 0 && this.columns == 0) {\r\n        return ZERO;\r\n    }\r\n    return new TerminalSize(this.columns, rows);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.DefaultTerminalFactory.setPreferTerminalEmulator",
	"Comment": "controls whether a swing or awt terminalframe shall be preferred if the system has both a console and a graphical environment",
	"Method": "DefaultTerminalFactory setPreferTerminalEmulator(boolean preferTerminalEmulator){\r\n    this.preferTerminalEmulator = preferTerminalEmulator;\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.fastpath.history.ChatTranscriptManager.getChatSessionsForWorkgroup",
	"Comment": "returns a collection of chatsessions for a particular workgroup.",
	"Method": "Collection<ChatSession> getChatSessionsForWorkgroup(Workgroup workgroup,Date start,Date end){\r\n    final List<ChatSession> resultList = new ArrayList<ChatSession>();\r\n    long wgID = workgroup.getID();\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(GET_WORKGROUP_SESSIONS);\r\n        pstmt.setLong(1, wgID);\r\n        pstmt.setString(2, StringUtils.dateToMillis(start));\r\n        pstmt.setString(3, StringUtils.dateToMillis(end));\r\n        rs = pstmt.executeQuery();\r\n        while (rs.next()) {\r\n            String sessionID = rs.getString(1);\r\n            String userID = rs.getString(2);\r\n            String startTime = rs.getString(3);\r\n            String endTime = rs.getString(4);\r\n            long queueWaitTime = rs.getLong(5);\r\n            int state = rs.getInt(6);\r\n            ChatSession session = new ChatSession();\r\n            session.setSessionID(sessionID);\r\n            session.setUserID(userID);\r\n            session.setWorkgroupID(wgID);\r\n            if (startTime.trim().length() > 0) {\r\n                session.setStartTime(Long.parseLong(startTime));\r\n            }\r\n            if (endTime.trim().length() > 0) {\r\n                session.setEndTime(Long.parseLong(endTime));\r\n            }\r\n            session.setQueueWaitTime(queueWaitTime);\r\n            session.setState(state);\r\n            populateSessionWithMetadata(session);\r\n            populateSessionWithAgents(session);\r\n            resultList.add(session);\r\n        }\r\n    } catch (Exception ex) {\r\n        Log.error(ex.getMessage(), ex);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    Collections.sort(resultList, dateComparator);\r\n    return resultList;\r\n}"
}, {
	"Path": "io.micrometer.wavefront.WavefrontConfig.apiToken",
	"Comment": "required when publishing directly to the wavefront api host, otherwise does nothing.",
	"Method": "String apiToken(){\r\n    String v = get(prefix() + \".apiToken\");\r\n    return v == null ? null : v.trim().length() > 0 ? v : null;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.WorkgroupManager.process",
	"Comment": "returns true if the iq packet was processed. this method should only process disco packetssent to the workgroup service.",
	"Method": "boolean process(IQ iq){\r\n    if (iq.getType() == IQ.Type.error) {\r\n        return false;\r\n    }\r\n    Element childElement = iq.getChildElement();\r\n    String name = null;\r\n    String namespace = null;\r\n    if (childElement != null) {\r\n        namespace = childElement.getNamespaceURI();\r\n        name = childElement.getName();\r\n    }\r\n    if (\"http://jabber.org/protocol/disco#info\".equals(namespace)) {\r\n        IQ reply = iqDiscoInfoHandler.handleIQ(iq);\r\n        if (reply != null) {\r\n            send(reply);\r\n        }\r\n    } else if (\"http://jabber.org/protocol/disco#items\".equals(namespace)) {\r\n        IQ reply = iqDiscoItemsHandler.handleIQ(iq);\r\n        if (reply != null) {\r\n            send(reply);\r\n        }\r\n    } else if (\"jabber:iq:version\".equals(namespace)) {\r\n        IQ reply = IQ.createResultIQ(iq);\r\n        Element version = reply.setChildElement(\"query\", \"jabber:iq:version\");\r\n        version.addElement(\"name\").setText(\"Spark Fastpath\");\r\n        version.addElement(\"version\").setText(\"3.2\");\r\n        version.addElement(\"os\").setText(\"Java 5\");\r\n        send(reply);\r\n    } else if (\"workgroups\".equals(name)) {\r\n        try {\r\n            getAgentManager().getAgent(iq.getFrom());\r\n            String agentJID = childElement.attributeValue(\"jid\");\r\n            try {\r\n                Agent agent = getAgentManager().getAgent(new JID(agentJID));\r\n                sendWorkgroups(iq, agent);\r\n            } catch (AgentNotFoundException e) {\r\n                IQ reply = IQ.createResultIQ(iq);\r\n                reply.setChildElement(iq.getChildElement().createCopy());\r\n                reply.setError(new PacketError(PacketError.Condition.item_not_found));\r\n                send(reply);\r\n            }\r\n        } catch (AgentNotFoundException e) {\r\n            IQ reply = IQ.createResultIQ(iq);\r\n            reply.setChildElement(iq.getChildElement().createCopy());\r\n            reply.setError(new PacketError(PacketError.Condition.not_authorized));\r\n            send(reply);\r\n        }\r\n    } else if (\"transcript-search\".equals(name)) {\r\n        iqChatSearchHandler.handleIQ(iq);\r\n    } else if (\"http://jabber.org/protocol/commands\".equals(namespace)) {\r\n        IQ reply = commandManager.process(iq);\r\n        send(reply);\r\n    } else {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "kilim.Task.spawn",
	"Comment": "wraps the given object or lambda expression in a task and starts that task.beware of inadvertent sharing when multiple lambdas are created in the same context",
	"Method": "Spawn<TT> spawn(Pausable.Spawn<TT> body,Invoke spawn,Method method,Object obj,Object args){\r\n    Invoke spawn = new Invoke(method, obj, args);\r\n    spawn.start();\r\n    return spawn;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.InterceptorManager.getAvailableInterceptors",
	"Comment": "returns an array of packetinterceptor objects that are all of the currently availableincerceptors in the system.",
	"Method": "List<PacketInterceptor> getAvailableInterceptors(){\r\n    return Collections.unmodifiableList(availableInterceptors);\r\n}"
}, {
	"Path": "org.jupiter.common.util.collection.ByteObjectHashMap.indexOf",
	"Comment": "locates the index for the given key. this method probes using double hashing.",
	"Method": "int indexOf(byte key){\r\n    int startIndex = hashIndex(key);\r\n    int index = startIndex;\r\n    for (; ; ) {\r\n        if (values[index] == null) {\r\n            return -1;\r\n        }\r\n        if (key == keys[index]) {\r\n            return index;\r\n        }\r\n        if ((index = probeNext(index)) == startIndex) {\r\n            return -1;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.emailListener.EmailListener.setUser",
	"Comment": "sets the user to use to connect to the imap server. a null value means thatthis property needs to be configured to be used.",
	"Method": "void setUser(String user){\r\n    JiveGlobals.setProperty(\"plugin.email.listener.user\", user);\r\n}"
}, {
	"Path": "com.drew.imaging.jpeg.JpegSegmentData.getSegments",
	"Comment": "returns all instances of a given jpeg segment.if no instances exist, an empty sequence is returned.",
	"Method": "Iterable<byte[]> getSegments(JpegSegmentType segmentType,Iterable<byte[]> getSegments,byte segmentType){\r\n    final List<byte[]> segmentList = getSegmentList(segmentType);\r\n    return segmentList == null ? new ArrayList<byte[]>() : segmentList;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.RadioBoxList.setCheckedItem",
	"Comment": "sets the currently checked item by the value itself. if null, the selection is cleared. when changing selection,any previously selected item is deselected.",
	"Method": "void setCheckedItem(V item){\r\n    if (item == null) {\r\n        setCheckedIndex(-1);\r\n    } else {\r\n        setCheckedItemIndex(indexOf(item));\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.PacketRejectedException.getRejectionMessage",
	"Comment": "retuns the text to include in a message that will be sent to the sender of the packetthat got rejected or null if none was defined. if no text was specified thenno message will be sent to the sender of the rejected packet.",
	"Method": "String getRejectionMessage(){\r\n    return rejectionMessage;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TerminalSize.withRelativeColumns",
	"Comment": "creates a new terminalsize object representing a size with the same number of rows, but with a column size offset by asupplied value. calling this method with delta 0 will return this, calling it with a positive delta will returna terminal size delta number of columns wider and for negative numbers shorter.",
	"Method": "TerminalSize withRelativeColumns(int delta){\r\n    if (delta == 0) {\r\n        return this;\r\n    }\r\n    return withColumns(columns + delta);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.getFullJID",
	"Comment": "returns a full jid of the workgroup composed by the workgroup jid and a resource thatwill match the workgroup name. the only place where a full jid may be required is whensending packets to the conference service. somce servers require that a full jid mightbe used to route packets between components.",
	"Method": "JID getFullJID(){\r\n    return new JID(workgroupName, \"workgroup.\" + ComponentManagerFactory.getComponentManager().getServerName(), workgroupName);\r\n}"
}, {
	"Path": "org.junit.platform.testkit.engine.EngineExecutionResults.filterEvents",
	"Comment": "filter the supplied list of events using the supplied predicate.",
	"Method": "Stream<Event> filterEvents(List<Event> events,Predicate<? super TestDescriptor> predicate){\r\n    return events.stream().filter(byTestDescriptor(predicate));\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.swing.TerminalEmulatorDeviceConfiguration.withLineBufferScrollbackSize",
	"Comment": "copies the current configuration. the new object has the given value.",
	"Method": "TerminalEmulatorDeviceConfiguration withLineBufferScrollbackSize(int lineBufferScrollbackSize){\r\n    if (this.lineBufferScrollbackSize == lineBufferScrollbackSize) {\r\n        return this;\r\n    } else {\r\n        return new TerminalEmulatorDeviceConfiguration(lineBufferScrollbackSize, this.blinkLengthInMilliSeconds, this.cursorStyle, this.cursorColor, this.cursorBlinking, this.clipboardAvailable);\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.dialogs.TextInputDialogBuilder.getValidator",
	"Comment": "returns the validator that will be attached to the text box in the dialog",
	"Method": "TextInputDialogResultValidator getValidator(){\r\n    return validator;\r\n}"
}, {
	"Path": "org.jupiter.transport.netty.handler.IdleStateChecker.getAllIdleTimeInMillis",
	"Comment": "return the allidletime that was given when instance this class in milliseconds.",
	"Method": "long getAllIdleTimeInMillis(){\r\n    return allIdleTimeMillis;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.table.Table.setVisibleColumns",
	"Comment": "sets the number of columns this table should show. if there are more columns in the table model, a scrollbar willbe used to allow the user to scroll left and right and view all columns.",
	"Method": "void setVisibleColumns(int visibleColumns){\r\n    this.visibleColumns = visibleColumns;\r\n    invalidate();\r\n}"
}, {
	"Path": "org.jdbi.v3.core.statement.StatementContextAccess.createContext",
	"Comment": "create a simple statement context that shares configurationwith the given handle.",
	"Method": "StatementContext createContext(StatementContext createContext,ConfigRegistry config,StatementContext createContext,Handle handle){\r\n    return new StatementContext(handle.getConfig());\r\n}"
}, {
	"Path": "org.jupiter.common.util.internal.UnsafeUtil.arrayBaseOffset",
	"Comment": "reports the offset of the first element in the storage allocation of agiven array class.",
	"Method": "int arrayBaseOffset(Class<?> clazz){\r\n    return unsafe != null ? unsafe.arrayBaseOffset(clazz) : -1;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ArchiveSearch.setIncludeTimestamp",
	"Comment": "set the timestamp to use for filtering conversations. this timestamphas to be between the time when the conversation started and ended.",
	"Method": "void setIncludeTimestamp(Date includeTimestamp){\r\n    this.includeTimestamp = includeTimestamp;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.CheckBox.removeListener",
	"Comment": "removes a listener from this check box so that, if it was previously added, it will no long receive any events",
	"Method": "CheckBox removeListener(Listener listener){\r\n    listeners.remove(listener);\r\n    return this;\r\n}"
}, {
	"Path": "org.jupiter.common.util.Pow2.roundToPowerOfTwo",
	"Comment": "find the next larger positive power of two value up from the given value.if value is a power of two then this value will be returned.",
	"Method": "int roundToPowerOfTwo(int value){\r\n    return 1 << (32 - Integer.numberOfLeadingZeros(value - 1));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.database.LogEntry.getTo",
	"Comment": "returns the receiver of this packet represented by this log entry",
	"Method": "String getTo(){\r\n    return _to;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.notifyClosed",
	"Comment": "notification method saying that the workgroup has been closed.",
	"Method": "void notifyClosed(){\r\n    workgroupPresenceHandler.broadcastWorkgroupPresence();\r\n    WorkgroupEventDispatcher.workgroupClosed(this);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.graphics.SimpleTheme.makeTheme",
	"Comment": "helper method that will quickly setup a new theme with some sensible component overrides.",
	"Method": "SimpleTheme makeTheme(boolean activeIsBold,TextColor baseForeground,TextColor baseBackground,TextColor editableForeground,TextColor editableBackground,TextColor selectedForeground,TextColor selectedBackground,TextColor guiBackground){\r\n    SGR[] activeStyle = activeIsBold ? new SGR[] { SGR.BOLD } : new SGR[0];\r\n    SimpleTheme theme = new SimpleTheme(baseForeground, baseBackground);\r\n    theme.getDefaultDefinition().setSelected(baseBackground, baseForeground, activeStyle);\r\n    theme.getDefaultDefinition().setActive(selectedForeground, selectedBackground, activeStyle);\r\n    theme.addOverride(AbstractBorder.class, baseForeground, baseBackground).setSelected(baseForeground, baseBackground, activeStyle);\r\n    theme.addOverride(AbstractListBox.class, baseForeground, baseBackground).setSelected(selectedForeground, selectedBackground, activeStyle);\r\n    theme.addOverride(Button.class, baseForeground, baseBackground).setActive(selectedForeground, selectedBackground, activeStyle).setSelected(selectedForeground, selectedBackground, activeStyle);\r\n    theme.addOverride(CheckBox.class, baseForeground, baseBackground).setActive(selectedForeground, selectedBackground, activeStyle).setPreLight(selectedForeground, selectedBackground, activeStyle).setSelected(selectedForeground, selectedBackground, activeStyle);\r\n    theme.addOverride(CheckBoxList.class, baseForeground, baseBackground).setActive(selectedForeground, selectedBackground, activeStyle);\r\n    theme.addOverride(ComboBox.class, baseForeground, baseBackground).setActive(editableForeground, editableBackground, activeStyle).setPreLight(editableForeground, editableBackground);\r\n    theme.addOverride(DefaultWindowDecorationRenderer.class, baseForeground, baseBackground).setActive(baseForeground, baseBackground, activeStyle);\r\n    theme.addOverride(GUIBackdrop.class, baseForeground, guiBackground);\r\n    theme.addOverride(RadioBoxList.class, baseForeground, baseBackground).setActive(selectedForeground, selectedBackground, activeStyle);\r\n    theme.addOverride(Table.class, baseForeground, baseBackground).setActive(editableForeground, editableBackground, activeStyle).setSelected(baseForeground, baseBackground);\r\n    theme.addOverride(TextBox.class, editableForeground, editableBackground).setActive(editableForeground, editableBackground, activeStyle).setSelected(editableForeground, editableBackground, activeStyle);\r\n    theme.setWindowPostRenderer(new WindowShadowRenderer());\r\n    return theme;\r\n}"
}, {
	"Path": "io.moquette.broker.Server.addInterceptHandler",
	"Comment": "spi method used by broker embedded applications to add intercept handlers.",
	"Method": "void addInterceptHandler(InterceptHandler interceptHandler){\r\n    if (!initialized) {\r\n        LOG.error(\"Moquette is not started, MQTT message interceptor cannot be added. InterceptorId={}\", interceptHandler.getID());\r\n        throw new IllegalStateException(\"Can't register interceptors on a integration that is not yet started\");\r\n    }\r\n    LOG.info(\"Adding MQTT message interceptor. InterceptorId={}\", interceptHandler.getID());\r\n    interceptor.addInterceptHandler(interceptHandler);\r\n}"
}, {
	"Path": "io.moquette.integration.MessageCollector.getMessageImmediate",
	"Comment": "return the message from the queue if not empty, else return null with wait period.",
	"Method": "MqttMessage getMessageImmediate(){\r\n    if (m_messages.isEmpty()) {\r\n        return null;\r\n    }\r\n    try {\r\n        return m_messages.take().message;\r\n    } catch (InterruptedException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.ansi.TelnetTerminal.getNegotiationState",
	"Comment": "retrieves the current negotiation state with the client, containing details on what options have been enabledand what the client has said it supports.",
	"Method": "NegotiationState getNegotiationState(){\r\n    return negotiationState;\r\n}"
}, {
	"Path": "org.jupiter.transport.netty.handler.IdleStateChecker.getWriterIdleTimeInMillis",
	"Comment": "return the writeridletime that was given when instance this class in milliseconds.",
	"Method": "long getWriterIdleTimeInMillis(){\r\n    return writerIdleTimeMillis;\r\n}"
}, {
	"Path": "org.jdbi.v3.sqlobject.statement.internal.ResultReturner.forMethod",
	"Comment": "inspect a method for its return type, and choose a resultreturner subclassthat handles any container that might wrap the results.",
	"Method": "ResultReturner forMethod(Class<?> extensionType,Method method){\r\n    Type returnType = GenericTypes.resolveType(method.getGenericReturnType(), extensionType);\r\n    QualifiedType qualifiedReturnType = QualifiedType.of(returnType, getQualifiers(method));\r\n    Class<?> returnClass = getErasedType(returnType);\r\n    if (Void.TYPE.equals(returnClass)) {\r\n        return findConsumer(method).orElseThrow(() -> new IllegalStateException(String.format(\"Method %s#%s is annotated as if it should return a value, but the method is void.\", method.getDeclaringClass().getName(), method.getName())));\r\n    } else if (ResultIterable.class.equals(returnClass)) {\r\n        return new ResultIterableReturner(qualifiedReturnType);\r\n    } else if (Stream.class.equals(returnClass)) {\r\n        return new StreamReturner(qualifiedReturnType);\r\n    } else if (ResultIterator.class.equals(returnClass)) {\r\n        return new ResultIteratorReturner(qualifiedReturnType);\r\n    } else if (Iterator.class.equals(returnClass)) {\r\n        return new IteratorReturner(qualifiedReturnType);\r\n    } else if (method.isAnnotationPresent(SingleValue.class)) {\r\n        return new SingleValueReturner(qualifiedReturnType);\r\n    } else {\r\n        return new CollectedResultReturner(qualifiedReturnType);\r\n    }\r\n}"
}, {
	"Path": "org.jdbi.v3.stringtemplate4.StringTemplateSqlLocator.findStringTemplate",
	"Comment": "locates sql for the given type and name. loads a stringtemplate group from the resource at the given path,and returns the template with the given name from the group.",
	"Method": "ST findStringTemplate(Class<?> type,String name,ST findStringTemplate,String path,String name,ST findStringTemplate,ClassLoader classLoader,String path,String name){\r\n    STGroup group = findStringTemplateGroup(classLoader, path);\r\n    return findTemplateInGroup(path, name, group);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.routing.RoutingManager.getInstance",
	"Comment": "returns the singleton instance of routingmanager,creating it if necessary.",
	"Method": "RoutingManager getInstance(){\r\n    return singleton;\r\n}"
}, {
	"Path": "com.drew.lang.Rational.getReciprocal",
	"Comment": "returns the reciprocal value of this object as a new rational.",
	"Method": "Rational getReciprocal(){\r\n    return new Rational(this._denominator, this._numerator);\r\n}"
}, {
	"Path": "com.drew.metadata.iptc.IptcDirectory.getReleaseDate",
	"Comment": "parses the release date tag and the release time tag to obtain a single date object representing thedate and time when this image was released.",
	"Method": "Date getReleaseDate(){\r\n    return getDate(TAG_RELEASE_DATE, TAG_RELEASE_TIME);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.search.ChatSearchManager.getChatsInformation",
	"Comment": "returns information about the chats that took place since a given date. the result issorted from oldest chats to newest chats.",
	"Method": "List<ChatInformation> getChatsInformation(Date since){\r\n    List<ChatInformation> chats = new ArrayList<ChatInformation>();\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet result = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(CHATS_SINCE_DATE);\r\n        pstmt.setLong(1, workgroup.getID());\r\n        pstmt.setString(2, StringUtils.dateToMillis(since));\r\n        result = pstmt.executeQuery();\r\n        while (result.next()) {\r\n            String sessionID = result.getString(1);\r\n            String transcript = result.getString(2);\r\n            String startTime = result.getString(3);\r\n            ChatNotes chatNotes = new ChatNotes();\r\n            String notes = chatNotes.getNotes(sessionID);\r\n            ChatInformation chatInfo = new ChatInformation(sessionID, transcript, startTime, notes);\r\n            if (chatInfo.getTranscript() != null) {\r\n                chats.add(chatInfo);\r\n            }\r\n        }\r\n        result.close();\r\n        for (ChatInformation chatInfo : chats) {\r\n            pstmt.close();\r\n            pstmt = con.prepareStatement(AGENTS_IN_SESSION);\r\n            pstmt.setString(1, chatInfo.getSessionID());\r\n            result = pstmt.executeQuery();\r\n            while (result.next()) {\r\n                chatInfo.getAgentJIDs().add(result.getString(1));\r\n            }\r\n            result.close();\r\n        }\r\n    } catch (Exception ex) {\r\n        Log.error(ex.getMessage(), ex);\r\n        chats = new ArrayList<ChatInformation>();\r\n    } finally {\r\n        try {\r\n            if (pstmt != null) {\r\n                pstmt.close();\r\n            }\r\n        } catch (Exception e) {\r\n            Log.error(e.getMessage(), e);\r\n        }\r\n        try {\r\n            if (result != null) {\r\n                result.close();\r\n            }\r\n        } catch (SQLException e) {\r\n            Log.error(e.getMessage(), e);\r\n        }\r\n        try {\r\n            if (con != null) {\r\n                con.close();\r\n            }\r\n        } catch (Exception e) {\r\n            Log.error(e.getMessage(), e);\r\n        }\r\n        try {\r\n            if (result != null) {\r\n                result.close();\r\n            }\r\n        } catch (Exception e) {\r\n            Log.error(e.getMessage(), e);\r\n        }\r\n    }\r\n    return chats;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.stats.StatsAction.getNLatestConversations",
	"Comment": "retrieves the last n conversations from the system that were created afterthe given conversationid.",
	"Method": "List<Map<String, Long>> getNLatestConversations(int count,long mostRecentConversationID){\r\n    List<Map<String, Long>> cons = new ArrayList<Map<String, Long>>();\r\n    MonitoringPlugin plugin = (MonitoringPlugin) XMPPServer.getInstance().getPluginManager().getPlugin(MonitoringConstants.NAME);\r\n    ConversationManager conversationManager = (ConversationManager) plugin.getModule(ConversationManager.class);\r\n    Collection<Conversation> conversations = conversationManager.getConversations();\r\n    List<Conversation> lConversations = Arrays.asList(conversations.toArray(new Conversation[conversations.size()]));\r\n    Collections.sort(lConversations, conversationComparator);\r\n    int counter = 0;\r\n    for (Iterator<Conversation> i = lConversations.iterator(); i.hasNext() && counter < count; ) {\r\n        Conversation con = i.next();\r\n        if (mostRecentConversationID == con.getConversationID()) {\r\n            break;\r\n        } else {\r\n            Map mCon = new HashMap();\r\n            mCon.put(\"conversationid\", con.getConversationID());\r\n            String[] users;\r\n            int usersIdx = 0;\r\n            if (con.getRoom() == null) {\r\n                users = new String[con.getParticipants().size()];\r\n                for (JID jid : con.getParticipants()) {\r\n                    String identifier = jid.toBareJID();\r\n                    try {\r\n                        identifier = UserNameManager.getUserName(jid, jid.toBareJID());\r\n                    } catch (UserNotFoundException e) {\r\n                    }\r\n                    users[usersIdx++] = StringUtils.abbreviate(identifier, 20);\r\n                }\r\n            } else {\r\n                users = new String[2];\r\n                users[0] = LocaleUtils.getLocalizedString(\"dashboard.group_conversation\", MonitoringConstants.NAME);\r\n                try {\r\n                    users[1] = \"(<i>\" + LocaleUtils.getLocalizedString(\"muc.room.summary.room\") + \": <a href='../../muc-room-occupants.jsp?roomName=\" + URLEncoder.encode(con.getRoom().getNode(), \"UTF-8\") + \"'>\" + con.getRoom().getNode() + \"<\/a><\/i>)\";\r\n                } catch (UnsupportedEncodingException e) {\r\n                    Log.error(e.getMessage(), e);\r\n                }\r\n            }\r\n            mCon.put(\"users\", users);\r\n            mCon.put(\"lastactivity\", formatTimeLong(con.getLastActivity()));\r\n            mCon.put(\"messages\", con.getMessageCount());\r\n            cons.add(0, mCon);\r\n            counter++;\r\n        }\r\n    }\r\n    return cons;\r\n}"
}, {
	"Path": "org.junit.platform.engine.TestDescriptor.isRoot",
	"Comment": "determine if this descriptor is a root descriptor.\ta root descriptor is a descriptor without a parent.",
	"Method": "boolean isRoot(){\r\n    return !getParent().isPresent();\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.ComboBox.getDropDownNumberOfRows",
	"Comment": "returns the number of items to display in drop down at one time, if there are more items in the model there willbe a scrollbar to help the user navigate. if this returns 0, the combo box will always grow to show all items inthe list, which might cause undesired effects if you put really a lot of items into the combo box.",
	"Method": "int getDropDownNumberOfRows(){\r\n    return dropDownNumberOfRows;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.GridLayout.getHorizontalSpacing",
	"Comment": "returns the horizontal spacing, i.e. the number of empty columns between each cell",
	"Method": "int getHorizontalSpacing(){\r\n    return horizontalSpacing;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.InterceptorManager.removeInterceptor",
	"Comment": "removes the interceptor for the specified workgroup from the list.",
	"Method": "boolean removeInterceptor(PacketInterceptor interceptor,boolean removeInterceptor,String workgroup,PacketInterceptor interceptor){\r\n    List<PacketInterceptor> interceptors = getLocalInterceptors(workgroup);\r\n    if (interceptors == null) {\r\n        return false;\r\n    }\r\n    boolean answer = interceptors.remove(interceptor);\r\n    saveInterceptors();\r\n    return answer;\r\n}"
}, {
	"Path": "org.jdbi.v3.sqlobject.TestBindLocalDate.testBindLocalDate",
	"Comment": "check that inserting a localdate value and select it back yields thesame date.",
	"Method": "void testBindLocalDate(){\r\n    LocalDate date = LocalDate.of(2001, 2, 1);\r\n    long id = dao.insert(date);\r\n    LocalDate inserted = dao.findById(id);\r\n    assertThat(inserted).isEqualTo(date);\r\n}"
}, {
	"Path": "org.junit.platform.commons.util.ModuleUtils.getModuleName",
	"Comment": "return the name of the module that the class or interface is a member of.",
	"Method": "Optional<String> getModuleName(Class<?> type){\r\n    Preconditions.notNull(type, \"Class type must not be null\");\r\n    return Optional.ofNullable(type.getModule().getName());\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.dispatcher.RoundRobinDispatcher.getChildrenPropertyNames",
	"Comment": "returns a child property names given a parent and an iterator of property names.",
	"Method": "Collection<String> getChildrenPropertyNames(String parent,Collection<String> properties){\r\n    List<String> results = new ArrayList<String>();\r\n    for (String name : properties) {\r\n        if (name.startsWith(parent) && !name.equals(parent)) {\r\n            results.add(name);\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.table.TableModel.getRows",
	"Comment": "returns all rows in the model as a list of lists containing the data as elements",
	"Method": "List<List<V>> getRows(){\r\n    List<List<V>> copy = new ArrayList<List<V>>();\r\n    for (List<V> row : rows) {\r\n        copy.add(new ArrayList<V>(row));\r\n    }\r\n    return copy;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.screen.VirtualScreen.setMinimumSize",
	"Comment": "sets the minimum size we want the virtual screen to have. if the user resizes the real terminal to somethingsmaller than this, the virtual screen will refuse to make it smaller and add scrollbars to the view.",
	"Method": "void setMinimumSize(TerminalSize minimumSize){\r\n    this.minimumSize = minimumSize;\r\n    TerminalSize virtualSize = minimumSize.max(realScreen.getTerminalSize());\r\n    if (!minimumSize.equals(virtualSize)) {\r\n        addResizeRequest(virtualSize);\r\n        super.doResizeIfNecessary();\r\n    }\r\n    calculateViewport(realScreen.getTerminalSize());\r\n}"
}, {
	"Path": "org.jupiter.transport.netty.NettyConnector.createWriteBufferWaterMark",
	"Comment": "create a writebufferwatermark is used to set low water mark and high water mark for the write buffer.",
	"Method": "WriteBufferWaterMark createWriteBufferWaterMark(int bufLowWaterMark,int bufHighWaterMark){\r\n    WriteBufferWaterMark waterMark;\r\n    if (bufLowWaterMark >= 0 && bufHighWaterMark > 0) {\r\n        waterMark = new WriteBufferWaterMark(bufLowWaterMark, bufHighWaterMark);\r\n    } else {\r\n        waterMark = new WriteBufferWaterMark(512 * 1024, 1024 * 1024);\r\n    }\r\n    return waterMark;\r\n}"
}, {
	"Path": "com.github.neuralnetworks.builder.designio.protobuf.nn.mapping.NNMapper.parseLearningParameter",
	"Comment": "set the learning rate and weight decay for current layer and bias layer",
	"Method": "void parseLearningParameter(LayerBuilder layerBuilder,NNProtoBufWrapper.LearnParameter learnParameter,NNProtoBufWrapper.LearnParameter biasLearnParameter,float generalLearningRage,float generalL1WeightDecay,float generalMomentum,boolean useBias){\r\n    if (layerBuilder instanceof LearnableLayer && learnParameter != null) {\r\n        LearnableLayer learnableLayer = (LearnableLayer) layerBuilder;\r\n        float localGeneralL1WeightDecay = generalL1WeightDecay;\r\n        float localGeneralLearningRate = generalLearningRage;\r\n        float localGeneralMomentum1 = generalMomentum;\r\n        if (learnParameter.getAbsoluteValues()) {\r\n            localGeneralL1WeightDecay = 1;\r\n            localGeneralLearningRate = 1;\r\n            localGeneralMomentum1 = 1;\r\n        }\r\n        if (learnParameter.hasLr()) {\r\n            learnableLayer.setLearningRate(localGeneralLearningRate * learnParameter.getLr());\r\n        }\r\n        if (learnParameter.hasWeightDecay()) {\r\n            learnableLayer.setL1weightDecay(localGeneralL1WeightDecay * learnParameter.getWeightDecay());\r\n        }\r\n        if (learnParameter.hasMomentum()) {\r\n            learnableLayer.setMomentum(localGeneralMomentum1 * learnParameter.getMomentum());\r\n        }\r\n    }\r\n    if (layerBuilder instanceof BiasLayerConnectable && useBias && biasLearnParameter != null) {\r\n        float localGeneralLearningRate = generalLearningRage;\r\n        float localGeneralL1WeightDecay = generalL1WeightDecay;\r\n        float localGeneralMomentum1 = generalMomentum;\r\n        if (biasLearnParameter.getAbsoluteValues()) {\r\n            localGeneralL1WeightDecay = 1;\r\n            localGeneralLearningRate = 1;\r\n            localGeneralMomentum1 = 1;\r\n        }\r\n        if (biasLearnParameter.hasLr()) {\r\n            ((BiasLayerConnectable) layerBuilder).setBiasLearningRate(localGeneralLearningRate * biasLearnParameter.getLr());\r\n        }\r\n        if (biasLearnParameter.hasWeightDecay()) {\r\n            ((BiasLayerConnectable) layerBuilder).setBiasL1weightDecay(localGeneralL1WeightDecay * biasLearnParameter.getWeightDecay());\r\n        }\r\n        if (biasLearnParameter.hasMomentum()) {\r\n            ((BiasLayerConnectable) layerBuilder).setBiasMomentum(localGeneralMomentum1 * biasLearnParameter.getMomentum());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jdbi.v3.sqlobject.SqlObject.withHandle",
	"Comment": "a convenience function which manages the lifecycle of the handle associated to this sql object,and yields it to a callback for use by clients.",
	"Method": "R withHandle(HandleCallback<R, X> callback){\r\n    return callback.withHandle(getHandle());\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocket.openInputStream",
	"Comment": "open the input stream of the websocket connection.the stream is used by the reading thread.",
	"Method": "WebSocketInputStream openInputStream(Socket socket){\r\n    try {\r\n        return new WebSocketInputStream(new BufferedInputStream(socket.getInputStream()));\r\n    } catch (IOException e) {\r\n        throw new WebSocketException(WebSocketError.SOCKET_INPUT_STREAM_FAILURE, \"Failed to get the input stream of the raw socket: \" + e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocket.onThreadsStarted",
	"Comment": "called when both the reading thread and the writing thread have started.this method is called in the context of either the reading thread orthe writing thread.",
	"Method": "void onThreadsStarted(){\r\n    mPingSender.start();\r\n    mPongSender.start();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.notifyOpened",
	"Comment": "notification method saying that the workgroup has been opened.",
	"Method": "void notifyOpened(){\r\n    workgroupPresenceHandler.broadcastWorkgroupPresence();\r\n    WorkgroupEventDispatcher.workgroupOpened(this);\r\n}"
}, {
	"Path": "org.jupiter.common.concurrent.collection.ConcurrentAutoTable.internal_size",
	"Comment": "return the internal counter striping factor.useful for diagnosingperformance problems.",
	"Method": "int internal_size(){\r\n    return _cat._t.length;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.stats.StatsEngine.getDefinition",
	"Comment": "returns the definition or definitions related to a statkey. there can be multipledefinitions if a stat is a multistat.",
	"Method": "StatDefinition[] getDefinition(String statKey){\r\n    List<StatDefinition> defs = multiMap.get(statKey);\r\n    if (defs == null) {\r\n        StatDefinition def = definitionMap.get(statKey);\r\n        if (def != null) {\r\n            return new StatDefinition[] { def };\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        return defs.toArray(new StatDefinition[defs.size()]);\r\n    }\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.MeterRegistry.close",
	"Comment": "closes this registry, releasing any resources in the process. once closed, this registry will no longeraccept new meters and any publishing activity will cease.",
	"Method": "void close(){\r\n    if (closed.compareAndSet(false, true)) {\r\n        synchronized (meterMapLock) {\r\n            for (Meter meter : meterMap.values()) {\r\n                meter.close();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.sessions.TransportSessionManager.getSessionsSorted",
	"Comment": "puts all sessions into an arraylist of gatewaysession objects, and sorts it according to specified sortingattributes.",
	"Method": "ArrayList<GatewaySession> getSessionsSorted(String sortby,String sortorder){\r\n    ArrayList<GatewaySession> result = new ArrayList<GatewaySession>(getNumberOfActiveSessions());\r\n    for (Map.Entry<String, Map<String, Long>> gateway : transportSessions.entrySet()) {\r\n        for (Map.Entry<String, Long> entry : gateway.getValue().entrySet()) {\r\n            Timestamp stamp = new Timestamp(entry.getValue());\r\n            Date date = new Date(stamp.getTime());\r\n            result.add(new GatewaySession(entry.getKey(), gateway.getKey(), date));\r\n        }\r\n    }\r\n    if (sortby.equals(\"username\")) {\r\n        Collections.sort(result, new SortUserName());\r\n    } else if (sortby.equals(\"transport\")) {\r\n        Collections.sort(result, new SortTransport());\r\n    } else if (sortby.equals(\"loginTime\")) {\r\n        Collections.sort(result, new SortLastActivity());\r\n    }\r\n    if (sortorder.equals(\"DESC\")) {\r\n        Collections.reverse(result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.virtual.DefaultVirtualTerminal.moveCursorToNextLine",
	"Comment": "moves the text cursor to the first column of the next line and trims the backlog of necessary",
	"Method": "void moveCursorToNextLine(){\r\n    cursorPosition = cursorPosition.withColumn(0).withRelativeRow(1);\r\n    if (cursorPosition.getRow() >= currentTextBuffer.getLineCount()) {\r\n        currentTextBuffer.newLine();\r\n    }\r\n    trimBufferBacklog();\r\n    correctCursor();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.BroadcastPlugin.isGroupMembersAllowed",
	"Comment": "returns true if normal group members are allowed to send broadcast messagesto groups they belong to. otherwise, only group administrators can sendbroadcast messages to groups. global allowed users can also send messages togroups.",
	"Method": "boolean isGroupMembersAllowed(){\r\n    return groupMembersAllowed;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.Bookmark.setProperty",
	"Comment": "sets an extended property. each bookmark can have anarbitrary number of extended properties. this allows for enhancedfunctionality that is not part of the base interface.if the property referenced by name already exists, itsvalue will be updated.",
	"Method": "void setProperty(String name,String value){\r\n    if (properties == null) {\r\n        loadPropertiesFromDb();\r\n    }\r\n    if (properties.containsKey(name)) {\r\n        if (!(value.equals(properties.get(name)))) {\r\n            properties.put(name, value);\r\n            updatePropertyInDb(name, value);\r\n        }\r\n    } else {\r\n        properties.put(name, value);\r\n        insertPropertyIntoDb(name, value);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.WorkgroupManager.addGroupManagerListener",
	"Comment": "listens for changes in the group model to update respective agents.",
	"Method": "void addGroupManagerListener(){\r\n    groupEventListener = new GroupEventListener() {\r\n        public void groupCreated(Group group, Map params) {\r\n        }\r\n        public void groupDeleting(Group group, Map params) {\r\n        }\r\n        public void groupModified(Group group, Map params) {\r\n        }\r\n        public void memberAdded(Group group, Map params) {\r\n            String userJID = (String) params.get(\"member\");\r\n            JID jid = new JID(userJID);\r\n            if (!agentManager.hasAgent(jid)) {\r\n                for (Workgroup workgroup : workgroups.values()) {\r\n                    for (RequestQueue queue : workgroup.getRequestQueues()) {\r\n                        if (queue.hasGroup(group)) {\r\n                            agentManager.getAgents(group);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        public void memberRemoved(Group group, Map params) {\r\n        }\r\n        public void adminAdded(Group group, Map params) {\r\n        }\r\n        public void adminRemoved(Group group, Map params) {\r\n        }\r\n    };\r\n    GroupEventDispatcher.addListener(groupEventListener);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.WorkgroupManager.addGroupManagerListener",
	"Comment": "listens for changes in the group model to update respective agents.",
	"Method": "void addGroupManagerListener(){\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.WorkgroupManager.addGroupManagerListener",
	"Comment": "listens for changes in the group model to update respective agents.",
	"Method": "void addGroupManagerListener(){\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.WorkgroupManager.addGroupManagerListener",
	"Comment": "listens for changes in the group model to update respective agents.",
	"Method": "void addGroupManagerListener(){\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.WorkgroupManager.addGroupManagerListener",
	"Comment": "listens for changes in the group model to update respective agents.",
	"Method": "void addGroupManagerListener(){\r\n    String userJID = (String) params.get(\"member\");\r\n    JID jid = new JID(userJID);\r\n    if (!agentManager.hasAgent(jid)) {\r\n        for (Workgroup workgroup : workgroups.values()) {\r\n            for (RequestQueue queue : workgroup.getRequestQueues()) {\r\n                if (queue.hasGroup(group)) {\r\n                    agentManager.getAgents(group);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.WorkgroupManager.addGroupManagerListener",
	"Comment": "listens for changes in the group model to update respective agents.",
	"Method": "void addGroupManagerListener(){\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.WorkgroupManager.addGroupManagerListener",
	"Comment": "listens for changes in the group model to update respective agents.",
	"Method": "void addGroupManagerListener(){\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.WorkgroupManager.addGroupManagerListener",
	"Comment": "listens for changes in the group model to update respective agents.",
	"Method": "void addGroupManagerListener(){\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.ChatbotSession.getLastActiveDate",
	"Comment": "returns the last time this session was updated. the session will be updated each time theuser changes the step in the chatbot. once the user has started a support session with anagent it is expected that the last active date will remain inactive for the duration of thesupport chat session.",
	"Method": "Date getLastActiveDate(){\r\n    return lastActiveDate;\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.MeterRegistry.timer",
	"Comment": "measures the time taken for short tasks and the count of these tasks.",
	"Method": "Timer timer(Meter.Id id,DistributionStatisticConfig distributionStatisticConfig,PauseDetector pauseDetectorOverride,Timer timer,String name,Iterable<Tag> tags,Timer timer,String name,String tags,FunctionTimer timer,String name,Iterable<Tag> tags,T obj,ToLongFunction<T> countFunction,ToDoubleFunction<T> totalTimeFunction,TimeUnit totalTimeFunctionUnit,FunctionTimer timer,Meter.Id id,T obj,ToLongFunction<T> countFunction,ToDoubleFunction<T> totalTimeFunction,TimeUnit totalTimeFunctionUnit){\r\n    return timer(name, Tags.of(tags));\r\n}"
}, {
	"Path": "io.moquette.Utils.numBytesToEncode",
	"Comment": "return the number of bytes to encode the given remaining length value",
	"Method": "int numBytesToEncode(int len){\r\n    if (0 <= len && len <= 127)\r\n        return 1;\r\n    if (128 <= len && len <= 16383)\r\n        return 2;\r\n    if (16384 <= len && len <= 2097151)\r\n        return 3;\r\n    if (2097152 <= len && len <= 268435455)\r\n        return 4;\r\n    throw new IllegalArgumentException(\"value should be in the range [0..268435455]\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.MonitoringPlugin.getModule",
	"Comment": "returns the instance of a module registered with the monitoring plugin.",
	"Method": "Object getModule(Class<?> clazz){\r\n    return picoContainer.getComponentInstanceOfType(clazz);\r\n}"
}, {
	"Path": "io.micrometer.statsd.internal.TelegrafStatsdLineBuilder.telegrafEscape",
	"Comment": "trying to escape spaces and comma drops everything after that",
	"Method": "String telegrafEscape(String value){\r\n    return value.replaceAll(\"=\", \"\\\\=\").replaceAll(\"[\\\\s,:]\", \"_\");\r\n}"
}, {
	"Path": "org.jupiter.common.util.Reflects.getValue",
	"Comment": "returns the value by name, on the specified object. the value isautomatically wrapped in an object if it has a primitive type.",
	"Method": "Object getValue(Object o,String name){\r\n    Object value = null;\r\n    try {\r\n        Field fd = setAccessible(getField(o.getClass(), name));\r\n        value = fd.get(o);\r\n    } catch (Exception e) {\r\n        ThrowUtil.throwException(e);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.junit.jupiter.engine.extension.ExtensionRegistry.createRegistryFrom",
	"Comment": "factory for creating and populating a new registry from a list of\textension types and a parent registry.",
	"Method": "ExtensionRegistry createRegistryFrom(ExtensionRegistry parentRegistry,List<Class<? extends Extension>> extensionTypes){\r\n    Preconditions.notNull(parentRegistry, \"parentRegistry must not be null\");\r\n    ExtensionRegistry registry = new ExtensionRegistry(parentRegistry);\r\n    extensionTypes.forEach(registry::registerExtension);\r\n    return registry;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TextCharacter.withCharacter",
	"Comment": "returns a new textcharacter with the same colors and modifiers but a different underlying character",
	"Method": "TextCharacter withCharacter(char character){\r\n    if (this.character == character) {\r\n        return this;\r\n    }\r\n    return new TextCharacter(character, foregroundColor, backgroundColor, modifiers);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TextCharacter.withModifiers",
	"Comment": "returns a copy of this textcharacter with specified list of sgr modifiers. none of the currently active sgr codeswill be carried over to the copy, only those in the passed in value.",
	"Method": "TextCharacter withModifiers(Collection<SGR> modifiers){\r\n    EnumSet<SGR> newSet = EnumSet.copyOf(modifiers);\r\n    if (modifiers.equals(newSet)) {\r\n        return this;\r\n    }\r\n    return new TextCharacter(character, foregroundColor, backgroundColor, newSet);\r\n}"
}, {
	"Path": "org.junit.platform.commons.util.ReflectionUtils.findConstructors",
	"Comment": "find all constructors in the supplied class that match the supplied predicate.",
	"Method": "List<Constructor<?>> findConstructors(Class<?> clazz,Predicate<Constructor<?>> predicate){\r\n    Preconditions.notNull(clazz, \"Class must not be null\");\r\n    Preconditions.notNull(predicate, \"Predicate must not be null\");\r\n    try {\r\n        return Arrays.stream(clazz.getDeclaredConstructors()).filter(predicate).collect(toUnmodifiableList());\r\n    } catch (Throwable t) {\r\n        throw ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));\r\n    }\r\n}"
}, {
	"Path": "org.jupiter.common.util.Reflects.setValue",
	"Comment": "sets new value by name, on the specified object. the new valueis automatically unwrapped if the underlying field has a primitive type.",
	"Method": "void setValue(Object o,String name,Object value){\r\n    try {\r\n        Field fd = setAccessible(getField(o.getClass(), name));\r\n        fd.set(o, value);\r\n    } catch (Exception e) {\r\n        ThrowUtil.throwException(e);\r\n    }\r\n}"
}, {
	"Path": "org.jupiter.serialization.proto.io.UnsafeNioBufInput.readEnum",
	"Comment": "read an enum field value from the internal buffer. caller is responsible for converting the numeric value to anactual enum.",
	"Method": "int readEnum(){\r\n    checkIfPackedField();\r\n    return readRawVarInt32();\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.dialogs.MessageDialogBuilder.setExtraWindowHints",
	"Comment": "assigns a set of extra window hints that you want the built dialog to have",
	"Method": "MessageDialogBuilder setExtraWindowHints(Collection<Window.Hint> extraWindowHints){\r\n    this.extraWindowHints.clear();\r\n    this.extraWindowHints.addAll(extraWindowHints);\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.spi.ChatHistoryUtils.getTotalTimeForAllChatsInServer",
	"Comment": "returns the total amount of time for all the chats in all workgroups.",
	"Method": "long getTotalTimeForAllChatsInServer(){\r\n    int totalWorkgroupChatTime = 0;\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(ALL_SESSION_TIMES);\r\n        rs = pstmt.executeQuery();\r\n        while (rs.next()) {\r\n            try {\r\n                String startTimeString = rs.getString(1);\r\n                String endTimeString = rs.getString(2);\r\n                if ((startTimeString != null) && (startTimeString.trim().length() > 0) && (endTimeString != null) && (endTimeString.trim().length() > 0)) {\r\n                    long startLong = Long.parseLong(startTimeString);\r\n                    long endLong = Long.parseLong(endTimeString);\r\n                    totalWorkgroupChatTime += endLong - startLong;\r\n                }\r\n            } catch (SQLException e) {\r\n                Log.error(e.getMessage(), e);\r\n            } catch (NumberFormatException e) {\r\n                Log.error(e.getMessage(), e);\r\n            }\r\n        }\r\n    } catch (Exception ex) {\r\n        Log.error(ex.getMessage(), ex);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    return totalWorkgroupChatTime;\r\n}"
}, {
	"Path": "com.github.neuralnetworks.builder.NeuralNetworkBuilder.build",
	"Comment": "create the neural network without a trainer and also ignore the hyper parameters for each layer!",
	"Method": "NeuralNetworkImpl build(){\r\n    return buildNetwork(null);\r\n}"
}, {
	"Path": "com.jvmtop.monitor.VMInfo.attachToVM",
	"Comment": "creates a new vminfo which is attached to a given localvirtualmachine",
	"Method": "VMInfo attachToVM(LocalVirtualMachine localvm,int vmid){\r\n    try {\r\n        ProxyClient proxyClient = ProxyClient.getProxyClient(localvm);\r\n        proxyClient.connect();\r\n        if (proxyClient.getConnectionState() == ConnectionState.DISCONNECTED) {\r\n            Logger.getLogger(\"jvmtop\").log(Level.FINE, \"connection refused (PID=\" + vmid + \")\");\r\n            return createDeadVM(vmid, localvm);\r\n        }\r\n        return new VMInfo(proxyClient, localvm, vmid + \"\");\r\n    } catch (ConnectException rmiE) {\r\n        if (rmiE.getMessage().contains(\"refused\")) {\r\n            Logger.getLogger(\"jvmtop\").log(Level.FINE, \"connection refused (PID=\" + vmid + \")\", rmiE);\r\n            return createDeadVM(vmid, localvm, VMInfoState.CONNECTION_REFUSED);\r\n        }\r\n        rmiE.printStackTrace(System.err);\r\n    } catch (IOException e) {\r\n        if ((e.getCause() != null && e.getCause() instanceof AttachNotSupportedException) || e.getMessage().contains(\"Permission denied\")) {\r\n            Logger.getLogger(\"jvmtop\").log(Level.FINE, \"could not attach (PID=\" + vmid + \")\", e);\r\n            return createDeadVM(vmid, localvm, VMInfoState.CONNECTION_REFUSED);\r\n        }\r\n        e.printStackTrace(System.err);\r\n    } catch (Exception e) {\r\n        Logger.getLogger(\"jvmtop\").log(Level.WARNING, \"could not attach (PID=\" + vmid + \")\", e);\r\n    }\r\n    return createDeadVM(vmid, localvm);\r\n}"
}, {
	"Path": "com.github.fge.jsonschema.cfg.ValidationConfigurationBuilder.setDefaultVersion",
	"Comment": "set the default schema version for this configurationthis will set the default library to use to the one registered forthis schema version.",
	"Method": "ValidationConfigurationBuilder setDefaultVersion(SchemaVersion version){\r\n    BUNDLE.checkNotNull(version, \"nullVersion\");\r\n    defaultLibrary = DEFAULT_LIBRARIES.get(version);\r\n    return this;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.virtual.DefaultVirtualTerminal.setWholeBufferDirty",
	"Comment": "marks the whole buffer as dirty so every cell is considered in need to repainting. this is used by methods suchas clear and bell that will affect all content at once.",
	"Method": "void setWholeBufferDirty(){\r\n    wholeBufferDirty = true;\r\n    dirtyTerminalCells.clear();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.stats.StatsEngine.getAllHighLevelNames",
	"Comment": "returns any multistat group names and any stats that are not part of a multistat.",
	"Method": "String[] getAllHighLevelNames(){\r\n    Set<String> keySet = multiMap.keySet();\r\n    return keySet.toArray(new String[keySet.size()]);\r\n}"
}, {
	"Path": "kilim.http.HttpRequest.readAllChunks",
	"Comment": "read all chunks untila chunksize of 0 is received, then consolidate the chunks into a single contiguous chunk.at the end of this method, the entire content is available in the requests buffer, starting at contentoffset andof length contentlength.",
	"Method": "void readAllChunks(EndPoint endpoint){\r\n    IntList chunkRanges = new IntList();\r\n    do {\r\n        int n = readLine(endpoint);\r\n        int beg = iread;\r\n        int size = parseChunkSize(buffer, iread - n, iread);\r\n        if (size == 0)\r\n            break;\r\n        fill(endpoint, iread, size + 2);\r\n        chunkRanges.add(beg);\r\n        chunkRanges.add(beg + size);\r\n        iread += size + 2;\r\n    } while (true);\r\n    if (chunkRanges.numElements == 0) {\r\n        contentLength = 0;\r\n        return;\r\n    }\r\n    contentOffset = chunkRanges.get(0);\r\n    int endOfLastChunk = chunkRanges.get(1);\r\n    byte[] bufa = buffer.array();\r\n    for (int i = 2; i < chunkRanges.numElements; i += 2) {\r\n        int beg = chunkRanges.get(i);\r\n        int chunkSize = chunkRanges.get(i + 1) - beg;\r\n        System.arraycopy(bufa, beg, bufa, endOfLastChunk, chunkSize);\r\n        endOfLastChunk += chunkSize;\r\n    }\r\n    contentLength = endOfLastChunk - contentOffset;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.fastpath.settings.chat.ChatSettingsManager.getChatSettings",
	"Comment": "retrieves the chatsettings mapped to a particular workgroup.",
	"Method": "ChatSettings getChatSettings(Workgroup workgroup){\r\n    String workgroupNode = workgroup.getJID().getNode();\r\n    ChatSettings chatSettings = cachedSettings.get(workgroupNode);\r\n    if (chatSettings == null) {\r\n        synchronized (workgroupNode.intern()) {\r\n            chatSettings = cachedSettings.get(workgroupNode);\r\n            if (chatSettings == null) {\r\n                chatSettings = getChatSettingsFromDb(workgroup);\r\n            }\r\n        }\r\n    }\r\n    return chatSettings;\r\n}"
}, {
	"Path": "org.jdbi.v3.sqlobject.SqlObjects.setDefaultParameterCustomizerFactory",
	"Comment": "configures sqlobject to use the given default parameter customizer factory.",
	"Method": "SqlObjects setDefaultParameterCustomizerFactory(ParameterCustomizerFactory defaultParameterCustomizerFactory){\r\n    this.defaultParameterCustomizerFactory = defaultParameterCustomizerFactory;\r\n    return this;\r\n}"
}, {
	"Path": "org.junit.jupiter.api.DisplayNameGenerator.parameterTypesAsString",
	"Comment": "compile a string representation from all simple parameter type names.",
	"Method": "String parameterTypesAsString(Method method){\r\n    Preconditions.notNull(method, \"Method must not be null\");\r\n    return '(' + ClassUtils.nullSafeToString(Class::getSimpleName, method.getParameterTypes()) + ')';\r\n}"
}, {
	"Path": "org.junit.platform.launcher.TagFilter.includeTags",
	"Comment": "create an include filter based on the supplied tag expressions.\tcontainers and tests will only be executed if their tags match at\tleast one of the supplied included tag expressions.",
	"Method": "PostDiscoveryFilter includeTags(String tagExpressions,PostDiscoveryFilter includeTags,List<String> tagExpressions){\r\n    return includeMatching(tagExpressions, Stream::anyMatch);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.request.UserRequest.getInvitedRoomID",
	"Comment": "returns the id of the room where the user was invited to have a chat with an agent ornull if the user was never invited.",
	"Method": "String getInvitedRoomID(){\r\n    return invitedRoomID;\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocketFrame.createContinuationFrame",
	"Comment": "create a continuation frame. note that the fin bit of thereturned frame is false.",
	"Method": "WebSocketFrame createContinuationFrame(WebSocketFrame createContinuationFrame,byte[] payload,WebSocketFrame createContinuationFrame,String payload){\r\n    return createContinuationFrame().setPayload(payload);\r\n}"
}, {
	"Path": "kilim.timerservice.TimerService.submit",
	"Comment": "ie, under heavy load, can moving a timer cause it to be missed ?",
	"Method": "void submit(Timer t){\r\n    if (t.onQueue.compareAndSet(false, true)) {\r\n        while (!timerQueue.offer(t)) {\r\n            trigger(defaultExec);\r\n            try {\r\n                Thread.sleep(0);\r\n            } catch (InterruptedException ex) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TerminalPosition.withRelativeColumn",
	"Comment": "creates a new terminalposition object representing a position on the same row, but with a column offset by asupplied value. calling this method with delta 0 will return this, calling it with a positive delta will returna terminal position delta number of columns to the right and for negative numbers the same to the left.",
	"Method": "TerminalPosition withRelativeColumn(int delta){\r\n    if (delta == 0) {\r\n        return this;\r\n    }\r\n    return withColumn(column + delta);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.SimpleTerminalResizeListener.isTerminalResized",
	"Comment": "checks if the terminal was resized since the last time this method was called. if this is the first time callingthis method, the result is going to be based on if the terminal has been resized since this listener was attachedto the terminal.",
	"Method": "boolean isTerminalResized(){\r\n    if (wasResized) {\r\n        wasResized = false;\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getRoutingMessage",
	"Comment": "returns the message to inform the user that he has entered a waiting queue andthat an agent will be with him in a moment.",
	"Method": "String getRoutingMessage(){\r\n    return settings.getChatSetting(KeyEnum.routing_message).getValue();\r\n}"
}, {
	"Path": "org.jupiter.serialization.proto.io.NioBufInput.readTag",
	"Comment": "attempt to read a field tag, returning zero if we have reached eof. protocol message parsers use this to readtags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.",
	"Method": "int readTag(){\r\n    if (!nioBuffer.hasRemaining()) {\r\n        lastTag = 0;\r\n        return 0;\r\n    }\r\n    final int tag = readRawVarInt32();\r\n    if (tag >>> TAG_TYPE_BITS == 0) {\r\n        throw ProtocolException.invalidTag();\r\n    }\r\n    lastTag = tag;\r\n    return tag;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.ContentFilter.clearPatterns",
	"Comment": "clears all patterns. calling this method means that all message contentwill be allowed.",
	"Method": "void clearPatterns(){\r\n    patterns = null;\r\n    compiledPatterns.clear();\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.ansi.StreamBasedTerminal.waitForCursorPositionReport",
	"Comment": "waits for up to 5 seconds for a terminal cursor position report to appear in the input stream. if the timeoutexpires, it will return null. you should have sent the cursor position query already beforecalling this method.",
	"Method": "TerminalPosition waitForCursorPositionReport(){\r\n    long startTime = System.currentTimeMillis();\r\n    TerminalPosition cursorPosition = lastReportedCursorPosition;\r\n    while (cursorPosition == null) {\r\n        if (System.currentTimeMillis() - startTime > 5000) {\r\n            return null;\r\n        }\r\n        KeyStroke keyStroke = readInput(false, false);\r\n        if (keyStroke != null) {\r\n            keyQueue.add(keyStroke);\r\n        } else {\r\n            try {\r\n                Thread.sleep(1);\r\n            } catch (InterruptedException ignored) {\r\n            }\r\n        }\r\n        cursorPosition = lastReportedCursorPosition;\r\n    }\r\n    return cursorPosition;\r\n}"
}, {
	"Path": "com.drew.metadata.xmp.XmpWriter.write",
	"Comment": "serializes the xmpdirectory component of metadata into an outputstream",
	"Method": "boolean write(OutputStream os,Metadata data){\r\n    XmpDirectory dir = data.getFirstDirectoryOfType(XmpDirectory.class);\r\n    if (dir == null)\r\n        return false;\r\n    XMPMeta meta = dir.getXMPMeta();\r\n    try {\r\n        SerializeOptions so = new SerializeOptions().setOmitPacketWrapper(true);\r\n        XMPMetaFactory.serialize(meta, os, so);\r\n    } catch (XMPException e) {\r\n        e.printStackTrace();\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.disableSchedule",
	"Comment": "disables the schedule that this workgroup might be following. to enable the schedule a newschedule must be assigned to the workgroup.",
	"Method": "void disableSchedule(){\r\n    followSchedule = false;\r\n    if (schedule != null) {\r\n        schedule.clear();\r\n    }\r\n    if (updateWorkgroup()) {\r\n        broadcastPresence();\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.CheckBoxList.getCheckedItems",
	"Comment": "returns all the items in the list box that have checked state, as a list",
	"Method": "List<V> getCheckedItems(){\r\n    List<V> result = new ArrayList<V>();\r\n    for (int i = 0; i < itemStatus.size(); i++) {\r\n        if (itemStatus.get(i)) {\r\n            result.add(getItemAt(i));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.GridLayout.createHorizontallyFilledLayoutData",
	"Comment": "this is a shortcut method that will create a grid layout data object that will expand its cell as much as is canhorizontally and make the component occupy the whole area horizontally and center it vertically",
	"Method": "LayoutData createHorizontallyFilledLayoutData(int horizontalSpan){\r\n    return createLayoutData(Alignment.FILL, Alignment.CENTER, true, false, horizontalSpan, 1);\r\n}"
}, {
	"Path": "com.github.neuralnetworks.training.Trainer.test",
	"Comment": "the network is tested via the testing input provider and the training error is aggregated for each example.",
	"Method": "void test(){\r\n    NetworkCalculatorImpl<N> nc = new NetworkCalculatorImpl<N>(getProperties()) {\r\n        private static final long serialVersionUID = 1L;\r\n        @Override\r\n        public PhaseStartedEvent phaseStartedEvent() {\r\n            return new TestingStartedEvent(Trainer.this);\r\n        }\r\n        @Override\r\n        public PhaseFinishedEvent phaseFinishedEvent() {\r\n            return new TestingFinishedEvent(Trainer.this);\r\n        }\r\n    };\r\n    nc.calculate(getTestingInputProvider());\r\n}"
}, {
	"Path": "com.github.neuralnetworks.training.Trainer.test",
	"Comment": "the network is tested via the testing input provider and the training error is aggregated for each example.",
	"Method": "void test(){\r\n    return new TestingStartedEvent(Trainer.this);\r\n}"
}, {
	"Path": "com.github.neuralnetworks.training.Trainer.test",
	"Comment": "the network is tested via the testing input provider and the training error is aggregated for each example.",
	"Method": "void test(){\r\n    return new TestingFinishedEvent(Trainer.this);\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.Metrics.removeRegistry",
	"Comment": "remove a registry from the global composite registry. removing a registry does not remove any metersthat were added to it by previous participation in the global composite.",
	"Method": "void removeRegistry(MeterRegistry registry){\r\n    globalRegistry.remove(registry);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ArchiveSearch.getDateRangeMin",
	"Comment": "returns the date that represents the lower boundary for conversationsthat will be returned by the search. if this value has not been set, the methodwill return null.",
	"Method": "Date getDateRangeMin(){\r\n    return dateRangeMin;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.DefaultTerminalFactory.setTerminalEmulatorFontConfiguration",
	"Comment": "sets the font configuration to use on created swingterminalframes created by this factory",
	"Method": "DefaultTerminalFactory setTerminalEmulatorFontConfiguration(AWTTerminalFontConfiguration fontConfiguration){\r\n    this.fontConfiguration = fontConfiguration;\r\n    return this;\r\n}"
}, {
	"Path": "com.drew.imaging.jpeg.JpegSegmentData.getSegmentCount",
	"Comment": "returns the count of segment data byte arrays stored for a given segment type.",
	"Method": "int getSegmentCount(JpegSegmentType segmentType,int getSegmentCount,byte segmentType){\r\n    final List<byte[]> segmentList = getSegmentList(segmentType);\r\n    return segmentList == null ? 0 : segmentList.size();\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.spi.ChatHistoryUtils.getAverageWaitTimeForWorkgroup",
	"Comment": "returns the average wait time for a specified workgroup between two dates.",
	"Method": "long getAverageWaitTimeForWorkgroup(String workgroupName,Date startDate,Date endTime){\r\n    int totalRequests = getNumberOfRequestsForWorkgroup(workgroupName, startDate, endTime);\r\n    long waitTime = getTotalWaitTimeForWorkgroup(workgroupName, startDate, endTime);\r\n    if (totalRequests == 0) {\r\n        return 0;\r\n    }\r\n    return waitTime / totalRequests;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.BroadcastPlugin.setGlobalAllowedUsers",
	"Comment": "sets the collection of addresses of users allowed to send broadcastmessages. if the collection is empty, anyone can send broadcast messages.additional users may also be allowed to send broadcast messages tospecific groups depending on the group settings.",
	"Method": "void setGlobalAllowedUsers(Collection<String> allowedUsers){\r\n    StringBuilder buf = new StringBuilder();\r\n    for (String jid : allowedUsers) {\r\n        buf.append(jid).append(\",\");\r\n    }\r\n    JiveGlobals.setProperty(\"plugin.broadcast.allowedUsers\", buf.toString());\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TerminalTextUtils.getANSIControlSequenceLength",
	"Comment": "given a string and an index in that string, returns the number of characters starting at index that make upa complete ansi control sequence. if there is no control sequence starting there, the method will return 0.",
	"Method": "int getANSIControlSequenceLength(String string,int index){\r\n    int len = 0, restlen = string.length() - index;\r\n    if (restlen >= 3) {\r\n        char esc = string.charAt(index), bracket = string.charAt(index + 1);\r\n        if (esc == 0x1B && bracket == '[') {\r\n            len = 3;\r\n            for (int i = 2; i < restlen; i++) {\r\n                char ch = string.charAt(i + index);\r\n                if ((ch >= '0' && ch <= '9') || ch == ';') {\r\n                    len++;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n            if (len > restlen) {\r\n                len = 0;\r\n            }\r\n        }\r\n    }\r\n    return len;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.InterceptorManager.getInterceptor",
	"Comment": "return the interceptor at the specified index in the list of currently configuredinterceptors for the specified workgroup.",
	"Method": "PacketInterceptor getInterceptor(int index,PacketInterceptor getInterceptor,String workgroup,int index){\r\n    List<PacketInterceptor> interceptors = getLocalInterceptors(workgroup);\r\n    if (interceptors == null) {\r\n        return null;\r\n    }\r\n    if (index < 0 || (index > interceptors.size())) {\r\n        throw new IndexOutOfBoundsException(\"Index \" + index + \" invalid.\");\r\n    }\r\n    return interceptors.get(index);\r\n}"
}, {
	"Path": "org.jupiter.common.util.Reflects.getObjectTransformationCost",
	"Comment": "gets the number of steps required needed to turn the source class intothe destination class. this represents the number of steps in the objecthierarchy graph.",
	"Method": "float getObjectTransformationCost(Class<?> srcClass,Class<?> dstClass){\r\n    if (dstClass.isPrimitive()) {\r\n        return getPrimitivePromotionCost(srcClass, dstClass);\r\n    }\r\n    float cost = 0.0f;\r\n    while (srcClass != null && !dstClass.equals(srcClass)) {\r\n        if (dstClass.isInterface() && isAssignable(srcClass, dstClass, true)) {\r\n            cost += 0.25f;\r\n            break;\r\n        }\r\n        cost++;\r\n        srcClass = srcClass.getSuperclass();\r\n    }\r\n    if (srcClass == null) {\r\n        cost += 1.5f;\r\n    }\r\n    return cost;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterExternalizableUtil.readStringMap",
	"Comment": "reads a map of string key and value pairs. this method will returnnull if the map written to the stream was null.",
	"Method": "Map<String, String> readStringMap(DataInput in){\r\n    return (Map<String, String>) readObject(in);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.CheckBox.addListener",
	"Comment": "adds a listener to this check box so that it will be notificed on certain user actions",
	"Method": "CheckBox addListener(Listener listener){\r\n    if (listener != null && !listeners.contains(listener)) {\r\n        listeners.add(listener);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.AgentSessionList.broadcastQueueStatus",
	"Comment": "sends two presence packets to each connected agent to the specified queue with the detailedand summary status of the specified queue.",
	"Method": "void broadcastQueueStatus(RequestQueue queue){\r\n    for (AgentSession session : sessionList.keySet()) {\r\n        queue.sendStatus(session.getJID());\r\n        queue.sendDetailedStatus(session.getJID());\r\n    }\r\n}"
}, {
	"Path": "io.moquette.broker.Server.removeInterceptHandler",
	"Comment": "spi method used by broker embedded applications to remove intercept handlers.",
	"Method": "void removeInterceptHandler(InterceptHandler interceptHandler){\r\n    if (!initialized) {\r\n        LOG.error(\"Moquette is not started, MQTT message interceptor cannot be removed. InterceptorId={}\", interceptHandler.getID());\r\n        throw new IllegalStateException(\"Can't deregister interceptors from a integration that is not yet started\");\r\n    }\r\n    LOG.info(\"Removing MQTT message interceptor. InterceptorId={}\", interceptHandler.getID());\r\n    interceptor.removeInterceptHandler(interceptHandler);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getRepeatHelpMessage",
	"Comment": "returns the message that describes the effect of running the repeat command.",
	"Method": "String getRepeatHelpMessage(){\r\n    return settings.getChatSetting(KeyEnum.repeat_help_message).getValue();\r\n}"
}, {
	"Path": "org.jupiter.common.concurrent.collection.NonBlockingHashMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this one, replacingany existing mappings.",
	"Method": "void putAll(Map<? extends TypeK, ? extends TypeV> m){\r\n    for (Map.Entry<? extends TypeK, ? extends TypeV> e : m.entrySet()) put(e.getKey(), e.getValue());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.fastpath.settings.offline.OfflineSettingsManager.getOfflineSettings",
	"Comment": "returns the offlinesettings found for the specified workgroup.",
	"Method": "OfflineSettings getOfflineSettings(Workgroup workgroup){\r\n    OfflineSettings offlineSettings = null;\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(GET_OFFLINE_SETTTINGS);\r\n        pstmt.setLong(1, workgroup.getID());\r\n        rs = pstmt.executeQuery();\r\n        if (rs.next()) {\r\n            String redirectPage = rs.getString(1);\r\n            String emailAddress = rs.getString(2);\r\n            String subject = rs.getString(3);\r\n            String offlineText = DbConnectionManager.getLargeTextField(rs, 4);\r\n            offlineSettings = new OfflineSettings();\r\n            offlineSettings.setRedirectURL(redirectPage);\r\n            offlineSettings.setEmailAddress(emailAddress);\r\n            offlineSettings.setSubject(subject);\r\n            offlineSettings.setOfflineText(offlineText);\r\n        }\r\n    } catch (Exception ex) {\r\n        Log.error(ex.getMessage(), ex);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    if (offlineSettings == null) {\r\n        throw new OfflineSettingsNotFound();\r\n    }\r\n    return offlineSettings;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ArchiveSearch.setDateRangeMax",
	"Comment": "sets the date that represents the upper boundary for conversationsthat will be returned by the search. a value of null indicates thatthere should be no upper boundary.",
	"Method": "void setDateRangeMax(Date dateRangeMax){\r\n    this.dateRangeMax = dateRangeMax;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.request.UserRequest.invitationsSent",
	"Comment": "notification message saying that the request has been accepted by an agent and thatinvitations have been sent to the agent and the user that made the request.",
	"Method": "void invitationsSent(String roomID){\r\n    invitationSent = System.currentTimeMillis();\r\n    invitedRoomID = roomID;\r\n    communicationMethod.invitationsSent(this);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterExternalizableUtil.readExternalizableMap",
	"Comment": "reads a map of string key and value pairs. this method will returnnull if the map written to the stream was null.",
	"Method": "int readExternalizableMap(DataInput in,Map<String, ? extends Externalizable> map,ClassLoader loader){\r\n    Map<String, Externalizable> result = (Map<String, Externalizable>) readObject(in);\r\n    if (result == null)\r\n        return 0;\r\n    ((Map<String, Externalizable>) map).putAll(result);\r\n    return result.size();\r\n}"
}, {
	"Path": "org.junit.platform.testkit.engine.EventStatistics.reportingEntryPublished",
	"Comment": "specify the number of expected reporting entry publication events.",
	"Method": "EventStatistics reportingEntryPublished(long expected){\r\n    this.executables.add(() -> assertEquals(expected, this.events.reportingEntryPublished().count(), \"reporting entry published\"));\r\n    return this;\r\n}"
}, {
	"Path": "gab.opencv.OpenCV.inRange",
	"Comment": "filter the image for values between a lower and upper bound.\tconverts the current image into a binary image with white where pixel\tvalues were within bounds and black elsewhere.",
	"Method": "void inRange(int lowerBound,int upperBound){\r\n    Core.inRange(getCurrentMat(), new Scalar(lowerBound), new Scalar(upperBound), getCurrentMat());\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.InterceptorManager.getInterceptors",
	"Comment": "returns an unmodifiable list of packet interceptors specific for the specified workgroup.",
	"Method": "List<PacketInterceptor> getInterceptors(List<PacketInterceptor> getInterceptors,String workgroup){\r\n    List<PacketInterceptor> interceptors = getLocalInterceptors(workgroup);\r\n    if (interceptors == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    return Collections.unmodifiableList(interceptors);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.TrafficMonitor.setReadEnabled",
	"Comment": "sets if packets that were received will be printed to the console.",
	"Method": "void setReadEnabled(boolean readEnabled){\r\n    this.readEnabled = readEnabled;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.reporting.stats.GetStatistics.sampleStat",
	"Comment": "profiles the sampling to make sure that it does not take longer than half a second tocomplete, if it does, a warning is logged.",
	"Method": "double sampleStat(String statKey,Statistic statistic){\r\n    long start = System.currentTimeMillis();\r\n    double sample = statistic.sample();\r\n    if (System.currentTimeMillis() - start >= 500) {\r\n        Log.warn(\"Stat \" + statKey + \" took longer than a second to sample.\");\r\n    }\r\n    return sample;\r\n}"
}, {
	"Path": "org.jupiter.registry.DefaultRegistry.doUnregister",
	"Comment": "notify to registry server unpublish corresponding service.",
	"Method": "void doUnregister(RegisterMeta meta){\r\n    Message msg = new Message(serializerType.value());\r\n    msg.messageCode(JProtocolHeader.PUBLISH_CANCEL_SERVICE);\r\n    msg.data(meta);\r\n    channel.writeAndFlush(msg).addListener(new ChannelFutureListener() {\r\n        @Override\r\n        public void operationComplete(ChannelFuture future) throws Exception {\r\n            if (!future.isSuccess()) {\r\n                Channel ch = future.channel();\r\n                if (ch.isActive()) {\r\n                    ch.pipeline().fireExceptionCaught(future.cause());\r\n                } else {\r\n                    if (logger.isWarnEnabled()) {\r\n                        logger.warn(\"Unregister {} fail because of channel is inactive: {}.\", meta, stackTrace(future.cause()));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n    MessageNonAck msgNonAck = new MessageNonAck(msg);\r\n    messagesNonAck.put(msgNonAck.id, msgNonAck);\r\n}"
}, {
	"Path": "org.jupiter.registry.DefaultRegistry.doUnregister",
	"Comment": "notify to registry server unpublish corresponding service.",
	"Method": "void doUnregister(RegisterMeta meta){\r\n    if (!future.isSuccess()) {\r\n        Channel ch = future.channel();\r\n        if (ch.isActive()) {\r\n            ch.pipeline().fireExceptionCaught(future.cause());\r\n        } else {\r\n            if (logger.isWarnEnabled()) {\r\n                logger.warn(\"Unregister {} fail because of channel is inactive: {}.\", meta, stackTrace(future.cause()));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.drew.metadata.Directory.hasTagName",
	"Comment": "gets whether the specified tag is known by the directory and has a name.",
	"Method": "boolean hasTagName(int tagType){\r\n    return getTagNameMap().containsKey(tagType);\r\n}"
}, {
	"Path": "org.jdbi.v3.postgres.TestJsonOperator.testJsonQuery",
	"Comment": "examples from postgres json functions.escaping rules from postgres prepared statements.",
	"Method": "void testJsonQuery(){\r\n    assertThat(db.getHandle().createQuery(\"SELECT '[{\\\"a\\\":\\\"foo\\\"},{\\\"b\\\":\\\"bar\\\"},{\\\"c\\\":\\\"baz\\\"}]'::json->2\").mapTo(String.class).findOnly()).isEqualTo(\"{\\\"c\\\":\\\"baz\\\"}\");\r\n    assertThat(db.getHandle().createQuery(\"SELECT '{\\\"a\\\": {\\\"b\\\":\\\"foo\\\"}}'::json->'a'\").mapTo(String.class).findOnly()).isEqualTo(\"{\\\"b\\\":\\\"foo\\\"}\");\r\n    assertThat(db.getHandle().createQuery(\"SELECT '[1,2,3]'::json->>2\").mapTo(Integer.class).findOnly()).isEqualTo(3);\r\n    assertThat(db.getHandle().createQuery(\"SELECT '{\\\"a\\\":1,\\\"b\\\":2}'::json->>'b'\").mapTo(Integer.class).findOnly()).isEqualTo(2);\r\n    assertThat(db.getHandle().createQuery(\"SELECT '{\\\"a\\\": {\\\"b\\\":{\\\"c\\\": \\\"foo\\\"}}}'::json#>'{a,b}'\").mapTo(String.class).findOnly()).isEqualTo(\"{\\\"c\\\": \\\"foo\\\"}\");\r\n    assertThat(db.getHandle().createQuery(\"SELECT '{\\\"a\\\":[1,2,3],\\\"b\\\":[4,5,6]}'::json#>>'{a,2}'\").mapTo(Integer.class).findOnly()).isEqualTo(3);\r\n    assertThat(db.getHandle().createQuery(\"SELECT '{\\\"a\\\":1, \\\"b\\\":2}'::jsonb @> '{\\\"b\\\":2}'::jsonb\").mapTo(boolean.class).findOnly()).isEqualTo(true);\r\n    assertThat(db.getHandle().createQuery(\"SELECT '{\\\"b\\\":2}'::jsonb <@ '{\\\"a\\\":1, \\\"b\\\":2}'::jsonb\").mapTo(boolean.class).findOnly()).isEqualTo(true);\r\n    assertThat(db.getHandle().createQuery(\"SELECT '{\\\"a\\\":1, \\\"b\\\":2}'::jsonb ?? 'b'\").mapTo(boolean.class).findOnly()).isEqualTo(true);\r\n    assertThat(db.getHandle().createQuery(\"SELECT '{\\\"a\\\":1, \\\"b\\\":2, \\\"c\\\":3}'::jsonb ??| array['b', 'c']\").mapTo(boolean.class).findOnly()).isEqualTo(true);\r\n    assertThat(db.getHandle().createQuery(\"SELECT '[\\\"a\\\", \\\"b\\\"]'::jsonb ??& array['a', 'b']\").mapTo(boolean.class).findOnly()).isEqualTo(true);\r\n    assertThat(db.getHandle().createQuery(\"SELECT '[\\\"a\\\", \\\"b\\\"]'::jsonb || '[\\\"c\\\", \\\"d\\\"]'::jsonb\").mapTo(String.class).findOnly()).isEqualTo(\"[\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\"]\");\r\n    assertThat(db.getHandle().createQuery(\"SELECT '{\\\"a\\\": \\\"b\\\"}'::jsonb - 'a'\").mapTo(String.class).findOnly()).isEqualTo(\"{}\");\r\n    assertThat(db.getHandle().createQuery(\"SELECT '{\\\"a\\\": \\\"b\\\", \\\"c\\\": \\\"d\\\"}'::jsonb - '{a,c}'::text[]\").mapTo(String.class).findOnly()).isEqualTo(\"{}\");\r\n    assertThat(db.getHandle().createQuery(\"SELECT '[\\\"a\\\", \\\"b\\\"]'::jsonb - 1\").mapTo(String.class).findOnly()).isEqualTo(\"[\\\"a\\\"]\");\r\n    assertThat(db.getHandle().createQuery(\"SELECT '[\\\"a\\\", {\\\"b\\\":1}]'::jsonb #- '{1,b}'\").mapTo(String.class).findOnly()).isEqualTo(\"[\\\"a\\\", {}]\");\r\n}"
}, {
	"Path": "kilim.test.TestYieldExceptions.testPausableCatch",
	"Comment": "pausable method throws an exception and thecatch handler makes a pausable call as well",
	"Method": "void testPausableCatch(){\r\n    TestYield.runTask(new kilim.test.ex.ExCatch(1));\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.GridLayout.getLeftMarginSize",
	"Comment": "returns the left margin, i.e. number of empty columns left of the first column in the grid",
	"Method": "int getLeftMarginSize(){\r\n    return leftMarginSize;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getFilloutFormMessage",
	"Comment": "returns the message to send to the user informing that a form must be filled out. thismessage is optional.",
	"Method": "String getFilloutFormMessage(){\r\n    return settings.getChatSetting(KeyEnum.fillout_form_message).getValue();\r\n}"
}, {
	"Path": "kilim.tools.Javac.getClassPath",
	"Comment": "get the class path comprising the paths of url class loaders ancestors",
	"Method": "ClassPath getClassPath(Class start,ClassLoader end){\r\n    ClassPath result = new ClassPath();\r\n    ClassLoader sys = end == null ? ClassLoader.getSystemClassLoader() : end.getParent();\r\n    ClassLoader cl = (start == null ? Javac.class : start).getClassLoader();\r\n    for (; cl != null & cl != sys; cl = cl.getParent()) if (cl instanceof java.net.URLClassLoader)\r\n        for (java.net.URL url : ((java.net.URLClassLoader) cl).getURLs()) result.add(url.getPath());\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.fastpath.settings.chat.ChatSettingsManager.getChatSetting",
	"Comment": "retrieves a webchatsetting based on the owning workgroup and setting key.",
	"Method": "ChatSetting getChatSetting(Workgroup workgroup,String key){\r\n    ChatSettings chatSettings = getChatSettings(workgroup);\r\n    if (chatSettings != null) {\r\n        return chatSettings.getChatSetting(key);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.drew.metadata.eps.EpsReader.extractImageData",
	"Comment": "parses %imagedata comment which holds several values including width in px,height in px and color type.",
	"Method": "void extractImageData(EpsDirectory directory,String imageData){\r\n    directory.setString(EpsDirectory.TAG_IMAGE_DATA, imageData.trim());\r\n    String[] imageDataParts = imageData.split(\" \");\r\n    int width = Integer.parseInt(imageDataParts[0]);\r\n    int height = Integer.parseInt(imageDataParts[1]);\r\n    int colorType = Integer.parseInt(imageDataParts[3]);\r\n    if (!directory.containsTag(EpsDirectory.TAG_IMAGE_WIDTH))\r\n        directory.setInt(EpsDirectory.TAG_IMAGE_WIDTH, width);\r\n    if (!directory.containsTag(EpsDirectory.TAG_IMAGE_HEIGHT))\r\n        directory.setInt(EpsDirectory.TAG_IMAGE_HEIGHT, height);\r\n    if (!directory.containsTag(EpsDirectory.TAG_COLOR_TYPE))\r\n        directory.setInt(EpsDirectory.TAG_COLOR_TYPE, colorType);\r\n    if (!directory.containsTag(EpsDirectory.TAG_RAM_SIZE)) {\r\n        int bytesPerPixel = 0;\r\n        if (colorType == 1)\r\n            bytesPerPixel = 1;\r\n        else if (colorType == 2 || colorType == 3)\r\n            bytesPerPixel = 3;\r\n        else if (colorType == 4)\r\n            bytesPerPixel = 3;\r\n        if (bytesPerPixel != 0)\r\n            directory.setInt(EpsDirectory.TAG_RAM_SIZE, bytesPerPixel * width * height);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.WorkgroupPresence.sendPresence",
	"Comment": "sends the presence of the workgroup to the specified jid address.",
	"Method": "void sendPresence(JID address){\r\n    Presence presence = new Presence();\r\n    presence.setTo(address);\r\n    presence.setFrom(workgroup.getJID());\r\n    Presence.Type type;\r\n    if (workgroup.isAvailable()) {\r\n        type = null;\r\n        Element child = presence.addChildElement(\"workgroup\", \"http://jivesoftware.com/protocol/workgroup\");\r\n        child.addElement(\"lastModified\").setText(UTC_FORMAT.format(workgroup.getModificationDate()));\r\n    } else {\r\n        type = Presence.Type.unavailable;\r\n        Element child = presence.addChildElement(\"workgroup\", \"http://jivesoftware.com/protocol/workgroup\");\r\n        child.addElement(\"lastModified\").setText(UTC_FORMAT.format(workgroup.getModificationDate()));\r\n    }\r\n    presence.setType(type);\r\n    workgroup.send(presence);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.SparkManager.handleDiscoInfo",
	"Comment": "send a reply back to the client to inform the client that this server hasa spark manager.",
	"Method": "void handleDiscoInfo(IQ packet){\r\n    IQ replyPacket = IQ.createResultIQ(packet);\r\n    Element responseElement = replyPacket.setChildElement(\"query\", \"http://jabber.org/protocol/disco#info\");\r\n    Element identity = responseElement.addElement(\"identity\");\r\n    identity.addAttribute(\"category\", \"manager\");\r\n    identity.addAttribute(\"type\", \"text\");\r\n    identity.addAttribute(\"name\", \"Client Control Manager\");\r\n    buildFeatureSet(responseElement);\r\n    sendPacket(replyPacket);\r\n}"
}, {
	"Path": "com.javamonitor.JmxHelper.query",
	"Comment": "query for a value, based on the object name as string. convenience methodthat does the casts.",
	"Method": "Object query(String objectName,String attribute,Object query,ObjectName objectName,String attribute){\r\n    final int dot = attribute.indexOf('.');\r\n    if (dot < 0) {\r\n        return findMBeanServer(objectName).getAttribute(objectName, attribute);\r\n    }\r\n    return resolveFields((CompositeData) findMBeanServer(objectName).getAttribute(objectName, attribute.substring(0, dot)), attribute.substring(dot + 1));\r\n}"
}, {
	"Path": "com.googlecode.lanterna.input.InputDecoder.addProfile",
	"Comment": "adds another key decoding profile to this inputdecoder, which means all patterns from the profile will be usedwhen decoding input.",
	"Method": "void addProfile(KeyDecodingProfile profile){\r\n    for (CharacterPattern pattern : profile.getPatterns()) {\r\n        synchronized (bytePatterns) {\r\n            bytePatterns.remove(pattern);\r\n            bytePatterns.add(pattern);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocket.setMissingCloseFrameAllowed",
	"Comment": "set whether to allow the server to close the websocket connectionwithout sending a close frameto this client.",
	"Method": "WebSocket setMissingCloseFrameAllowed(boolean allowed){\r\n    mMissingCloseFrameAllowed = allowed;\r\n    return this;\r\n}"
}, {
	"Path": "org.jupiter.common.util.ConstantPool.getOrCreate",
	"Comment": "get existing constant by name or creates new one if not exists. threadsafe",
	"Method": "T getOrCreate(String name){\r\n    T constant = constants.get(name);\r\n    if (constant == null) {\r\n        final T newConstant = newConstant(nextId.getAndIncrement(), name);\r\n        constant = constants.putIfAbsent(name, newConstant);\r\n        if (constant == null) {\r\n            constant = newConstant;\r\n        }\r\n    }\r\n    return constant;\r\n}"
}, {
	"Path": "org.jupiter.common.util.internal.UnsafeUtil.arrayIndexScale",
	"Comment": "reports the scale factor for addressing elements in the storageallocation of a given array class.",
	"Method": "int arrayIndexScale(Class<?> clazz){\r\n    return unsafe != null ? unsafe.arrayIndexScale(clazz) : -1;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.spi.ChatHistoryUtils.getNumberOfRequestsForWorkgroup",
	"Comment": "returns the number of request made to a workgroup betweenspecified dates.",
	"Method": "int getNumberOfRequestsForWorkgroup(String workgroupName,Date startDate,Date endDate){\r\n    Workgroup workgroup = getWorkgroup(workgroupName);\r\n    if (workgroup == null) {\r\n        return 0;\r\n    }\r\n    int count = 0;\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(WORKGROUP_REQUEST_COUNT);\r\n        pstmt.setLong(1, workgroup.getID());\r\n        pstmt.setString(2, StringUtils.dateToMillis(startDate));\r\n        pstmt.setString(3, StringUtils.dateToMillis(endDate));\r\n        rs = pstmt.executeQuery();\r\n        if (rs.next()) {\r\n            count = rs.getInt(1);\r\n        }\r\n    } catch (Exception ex) {\r\n        Log.error(ex.getMessage(), ex);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.GridLayout.setLeftMarginSize",
	"Comment": "sets the left margin, i.e. number of empty columns left of the first column in the grid",
	"Method": "GridLayout setLeftMarginSize(int leftMarginSize){\r\n    if (leftMarginSize < 0) {\r\n        throw new IllegalArgumentException(\"Left margin size cannot be less than 0\");\r\n    }\r\n    this.leftMarginSize = leftMarginSize;\r\n    this.changed = true;\r\n    return this;\r\n}"
}, {
	"Path": "org.junit.jupiter.engine.extension.ExtensionRegistry.isAlreadyRegistered",
	"Comment": "determine if the supplied type is already registered in this registry or in a\tparent registry.",
	"Method": "boolean isAlreadyRegistered(Class<? extends Extension> extensionType){\r\n    return (this.registeredExtensionTypes.contains(extensionType) || (this.parent != null && this.parent.isAlreadyRegistered(extensionType)));\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.AgentSession.updatePresence",
	"Comment": "updates the presence of the agentsession with the new received presence. the max number ofchats and number of current chats will be updated if that information was included in the presence.if no information was provided then default values of queues, workgroups or general settings willbe used instead.",
	"Method": "void updatePresence(Presence packet){\r\n    Presence sessionPresence = packet.createCopy();\r\n    Element child = sessionPresence.getChildElement(\"agent-status\", \"http://jabber.org/protocol/workgroup\");\r\n    sessionPresence.getElement().remove(child);\r\n    presence = sessionPresence;\r\n    Element elem = packet.getChildElement(\"agent-status\", \"http://jabber.org/protocol/workgroup\");\r\n    if (elem != null) {\r\n        Iterator<Element> metaIter = elem.elementIterator();\r\n        while (metaIter.hasNext()) {\r\n            Element agentStatusElement = metaIter.next();\r\n            if (\"max-chats\".equals(agentStatusElement.getName())) {\r\n                String maxChats = agentStatusElement.getText();\r\n                if (maxChats == null || maxChats.trim().length() == 0) {\r\n                    setMaxChats(-1);\r\n                } else {\r\n                    setMaxChats(Integer.parseInt(maxChats));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.TrafficMonitor.setSentEnabled",
	"Comment": "sets if packets that were sent will be printed to the console.",
	"Method": "void setSentEnabled(boolean sentEnabled){\r\n    this.sentEnabled = sentEnabled;\r\n}"
}, {
	"Path": "io.micrometer.core.instrument.distribution.DistributionStatisticConfig.getPercentilePrecision",
	"Comment": "determines the number of digits of precision to maintain on the dynamic range histogram used to computepercentile approximations. the higher the degrees of precision, the more accurate the approximation is at thecost of more memory.",
	"Method": "Integer getPercentilePrecision(){\r\n    return percentilePrecision;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.search.ChatSearchManager.shutdown",
	"Comment": "notification message saying that the workgroup service is being shutdown. release allthe instances so the gc can claim all the workgroup objects.",
	"Method": "void shutdown(){\r\n    for (ChatSearchManager manager : instances.values()) {\r\n        manager.stop();\r\n    }\r\n    instances.clear();\r\n}"
}, {
	"Path": "gab.opencv.OpenCV.pointToPVector",
	"Comment": "helper function to convert an opencv point into a processing pvector",
	"Method": "PVector pointToPVector(Point p){\r\n    return new PVector((float) p.x, (float) p.y);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.fastpath.dataforms.FormManager.createGenericForm",
	"Comment": "creates a new generic dataform for the workgroup if one does not exist.",
	"Method": "void createGenericForm(Workgroup workgroup){\r\n    WorkgroupForm workgroupForm = new WorkgroupForm();\r\n    FormElement username = new FormElement();\r\n    username.setRequired(true);\r\n    username.setAnswerType(WorkgroupForm.FormEnum.textfield);\r\n    username.setVariable(\"username\");\r\n    username.setLabel(\"Name:\");\r\n    workgroupForm.addFormElement(username);\r\n    FormElement email = new FormElement();\r\n    email.setRequired(true);\r\n    email.setAnswerType(WorkgroupForm.FormEnum.textfield);\r\n    email.setVariable(\"email\");\r\n    email.setLabel(\"Email Address:\");\r\n    workgroupForm.addFormElement(email);\r\n    FormElement question = new FormElement();\r\n    question.setRequired(true);\r\n    question.setAnswerType(WorkgroupForm.FormEnum.textfield);\r\n    question.setVariable(\"question\");\r\n    question.setLabel(\"Question:\");\r\n    workgroupForm.addFormElement(question);\r\n    addWorkgroupForm(workgroup, workgroupForm);\r\n    saveWorkgroupForm(workgroup);\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.dialogs.TextInputDialogBuilder.setValidator",
	"Comment": "sets the validator that will be attached to the text box in the dialog",
	"Method": "TextInputDialogBuilder setValidator(TextInputDialogResultValidator validator){\r\n    this.validator = validator;\r\n    return this;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.GridLayout.getBottomMarginSize",
	"Comment": "returns the bottom margin, i.e. number of empty rows below the last row in the grid",
	"Method": "int getBottomMarginSize(){\r\n    return bottomMarginSize;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.ChatbotInterceptorManager.getInstance",
	"Comment": "returns a singleton instance of chatbotinterceptormanager.",
	"Method": "InterceptorManager getInstance(){\r\n    return instance;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.base.RemoteRosterPlugin.manageExternalComponents",
	"Comment": "handles external components that connect to openfire. we check if theexternal component is maybe a gateway and interesting for us",
	"Method": "void manageExternalComponents(){\r\n    _componentObserver = new ComponentEventListener() {\r\n        public void componentUnregistered(JID componentJID) {\r\n            mainInterceptor.removeTransport(componentJID.toString());\r\n        }\r\n        public void componentRegistered(JID componentJID) {\r\n            _waitingForIQResponse.add(componentJID.getDomain());\r\n        }\r\n        public void componentInfoReceived(IQ iq) {\r\n            String from = iq.getFrom().getDomain();\r\n            if (_waitingForIQResponse.contains(from)) {\r\n                Element packet = iq.getChildElement();\r\n                Document doc = packet.getDocument();\r\n                List<Node> nodes = XpathHelper.findNodesInDocument(doc, \"//disco:identity[@category='gateway']\");\r\n                if (nodes.size() > 0) {\r\n                    updateInterceptors(from);\r\n                }\r\n                _waitingForIQResponse.remove(from);\r\n            }\r\n        }\r\n    };\r\n    compManager.addListener(_componentObserver);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.base.RemoteRosterPlugin.manageExternalComponents",
	"Comment": "handles external components that connect to openfire. we check if theexternal component is maybe a gateway and interesting for us",
	"Method": "void manageExternalComponents(){\r\n    mainInterceptor.removeTransport(componentJID.toString());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.base.RemoteRosterPlugin.manageExternalComponents",
	"Comment": "handles external components that connect to openfire. we check if theexternal component is maybe a gateway and interesting for us",
	"Method": "void manageExternalComponents(){\r\n    _waitingForIQResponse.add(componentJID.getDomain());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.base.RemoteRosterPlugin.manageExternalComponents",
	"Comment": "handles external components that connect to openfire. we check if theexternal component is maybe a gateway and interesting for us",
	"Method": "void manageExternalComponents(){\r\n    String from = iq.getFrom().getDomain();\r\n    if (_waitingForIQResponse.contains(from)) {\r\n        Element packet = iq.getChildElement();\r\n        Document doc = packet.getDocument();\r\n        List<Node> nodes = XpathHelper.findNodesInDocument(doc, \"//disco:identity[@category='gateway']\");\r\n        if (nodes.size() > 0) {\r\n            updateInterceptors(from);\r\n        }\r\n        _waitingForIQResponse.remove(from);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.UserInterceptor.getFromName",
	"Comment": "returns the name that notification emails will appear to be from.",
	"Method": "String getFromName(){\r\n    return fromName;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.ProgressBar.getLabelFormat",
	"Comment": "returns the current label format string which is the template for what the progress bar would like to be thelabel printed. exactly how this label is printed depends on the renderer, but the default renderer will printthe label centered in the middle of the progress indication.",
	"Method": "String getLabelFormat(){\r\n    return labelFormat;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.gui2.ProgressBar.getValue",
	"Comment": "returns the current value of this progress bar, which represents how complete the progress indication is.",
	"Method": "int getValue(){\r\n    return value;\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocket.flush",
	"Comment": "flush frames to the server. flush is performed asynchronously.",
	"Method": "WebSocket flush(){\r\n    synchronized (mStateManager) {\r\n        WebSocketState state = mStateManager.getState();\r\n        if (state != OPEN && state != CLOSING) {\r\n            return this;\r\n        }\r\n    }\r\n    WritingThread wt = mWritingThread;\r\n    if (wt != null) {\r\n        wt.queueFlush();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.input.ScreenInfoAction.getPosition",
	"Comment": "the location of the mouse cursor when this event was generated.",
	"Method": "TerminalPosition getPosition(){\r\n    return position;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.isChatbotEnabled",
	"Comment": "returns true if the chatbot is enabled. when the chatbot is enabled it will answermessages sent to the workgroup.",
	"Method": "boolean isChatbotEnabled(){\r\n    return \"true\".equals(getProperties().getProperty(\"chatbot.enabled\"));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.util.cache.ClusterExternalizableUtil.writeSerializableMap",
	"Comment": "writes a map of serializable key and value pairs. this method handles thecase when the map is null.",
	"Method": "void writeSerializableMap(DataOutput out,Map<? extends Serializable, ? extends Serializable> map){\r\n    writeObject(out, map);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.Workgroup.setDisplayName",
	"Comment": "sets the name to use when displaying the workgroup. this information can be usedwhen showing the workgroup as a roster item.",
	"Method": "void setDisplayName(String displayName){\r\n    if (displayName.equals(this.displayName)) {\r\n        return;\r\n    }\r\n    this.displayName = displayName;\r\n    updateWorkgroup();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ConversationManager.addConversationListener",
	"Comment": "adds a conversation listener, which will be notified of newly created conversations, conversations ending, and updates to conversations.",
	"Method": "void addConversationListener(ConversationListener listener){\r\n    conversationListeners.add(listener);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.getEmailSentMessage",
	"Comment": "returns the message to send to the user informing that the chat transcript was sent by email.",
	"Method": "String getEmailSentMessage(){\r\n    return settings.getChatSetting(KeyEnum.email_sent_message).getValue();\r\n}"
}, {
	"Path": "com.drew.metadata.Directory.getErrors",
	"Comment": "used to iterate over any error messages contained in this directory.",
	"Method": "Iterable<String> getErrors(){\r\n    return Collections.unmodifiableCollection(_errorList);\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocket.getPongPayloadGenerator",
	"Comment": "get the generator of payload of pong frames that are sent automatically.",
	"Method": "PayloadGenerator getPongPayloadGenerator(){\r\n    return mPongSender.getPayloadGenerator();\r\n}"
}, {
	"Path": "com.neovisionaries.ws.client.WebSocketFactory.setConnectionTimeout",
	"Comment": "set the timeout value in milliseconds for socket connection.a timeout of zero is interpreted as an infinite timeout.",
	"Method": "WebSocketFactory setConnectionTimeout(int timeout){\r\n    if (timeout < 0) {\r\n        throw new IllegalArgumentException(\"timeout value cannot be negative.\");\r\n    }\r\n    mConnectionTimeout = timeout;\r\n    return this;\r\n}"
}, {
	"Path": "org.jupiter.common.util.Preconditions.checkNotNull",
	"Comment": "ensures that an object reference passed as a parameter to the callingmethod is not null.",
	"Method": "T checkNotNull(T reference,T checkNotNull,T reference,Object errorMessage){\r\n    if (reference == null) {\r\n        throw new NullPointerException(String.valueOf(errorMessage));\r\n    }\r\n    return reference;\r\n}"
}, {
	"Path": "kilim.test.TestYieldJSR.testMixedJSRs",
	"Comment": "jsr sub1, jsr sub2, jsr sub1, jsr sub2, where sub2 is pausableand sub1 is not. only calls to sub2 should be inlined. we haveno automated way of checking this, but the behavior can certainlybe tested.",
	"Method": "void testMixedJSRs(){\r\n    TestYield.runTask(\"kilim.test.ex.ExYieldSub\", 3);\r\n}"
}, {
	"Path": "io.micrometer.statsd.StatsdTimer.max",
	"Comment": "the statsd agent will likely compute max with a different window, so the value may not match what you see here.this value is not exported to the agent, and is only for diagnostic use.",
	"Method": "double max(TimeUnit unit){\r\n    return TimeUtils.convert(max.poll(), TimeUnit.MILLISECONDS, unit);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.SparkUtil.nullifyIfEmpty",
	"Comment": "returns null if the specified string is empty ornull.otherwise the string itself is returned.",
	"Method": "String nullifyIfEmpty(String s){\r\n    return hasLength(s) ? s : null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.spark.BookmarkInterceptor.addBookmarks",
	"Comment": "adds all server defined bookmarks to the users requestedbookmarks.",
	"Method": "void addBookmarks(JID jid,Element storageElement){\r\n    final Collection<Bookmark> bookmarks = BookmarkManager.getBookmarks();\r\n    for (Bookmark bookmark : bookmarks) {\r\n        boolean addBookmarkForUser = bookmark.isGlobalBookmark() || isBookmarkForJID(jid, bookmark);\r\n        if (addBookmarkForUser) {\r\n            addBookmarkElement(jid, bookmark, storageElement);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.archive.ArchiveSearch.getQueryString",
	"Comment": "returns the query string used for the search or null if no query stringhas been set. the query string can contain the fullsearch syntaxsupported by lucene.",
	"Method": "String getQueryString(){\r\n    return queryString;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.messagefilter.processors.AbstractRemoteRosterProcessor.dispatchPacket",
	"Comment": "use this method if you want to send your own packets through openfire",
	"Method": "void dispatchPacket(Packet packet){\r\n    Log.debug(\"Sending package to PacketRouter: \\n\" + packet.toString() + \"\\n\");\r\n    _router.route(packet);\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.UserInterceptor.interceptPacket",
	"Comment": "checks to see if the sender of the packet is a banned user. if they are, apacketrejectedexception is thrown and email notifications may be sent.",
	"Method": "void interceptPacket(String workgroup,Packet packet,boolean read,boolean processed){\r\n    if (!read || processed) {\r\n        return;\r\n    }\r\n    JID jid = packet.getFrom();\r\n    if (jidBanMap.containsKey(jid.toBareJID()) || domainBanMap.containsKey(jid.getDomain())) {\r\n        sendNotifications(packet, jid.toString());\r\n        PacketRejectedException exception = new PacketRejectedException(\"User '\" + packet.getFrom().toBareJID() + \"' not allowed to join queue.\");\r\n        if (rejectionMessage != null) {\r\n            exception.setRejectionMessage(rejectionMessage);\r\n        }\r\n        throw exception;\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.lanterna.TextCharacter.withModifier",
	"Comment": "returns a copy of this textcharacter with an additional sgr modifier. all of the currently active sgr codeswill be carried over to the copy, in addition to the one specified.",
	"Method": "TextCharacter withModifier(SGR modifier){\r\n    if (modifiers.contains(modifier)) {\r\n        return this;\r\n    }\r\n    EnumSet<SGR> newSet = EnumSet.copyOf(this.modifiers);\r\n    newSet.add(modifier);\r\n    return new TextCharacter(character, foregroundColor, backgroundColor, newSet);\r\n}"
}, {
	"Path": "org.jupiter.common.util.Reflects.getPrimitivePromotionCost",
	"Comment": "gets the number of steps required to promote a primitive number to anothertype.",
	"Method": "float getPrimitivePromotionCost(Class<?> srcClass,Class<?> dstClass){\r\n    float cost = 0.0f;\r\n    Class<?> cls = srcClass;\r\n    if (!cls.isPrimitive()) {\r\n        cost += 0.1f;\r\n        cls = wrapperToPrimitive(cls);\r\n    }\r\n    for (int i = 0; cls != dstClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) {\r\n        if (cls == ORDERED_PRIMITIVE_TYPES[i]) {\r\n            cost += 0.1f;\r\n            if (i < ORDERED_PRIMITIVE_TYPES.length - 1) {\r\n                cls = ORDERED_PRIMITIVE_TYPES[i + 1];\r\n            }\r\n        }\r\n    }\r\n    return cost;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.interceptor.AgentInterceptorManager.getInstance",
	"Comment": "returns a singleton instance of agentinterceptormanager.",
	"Method": "InterceptorManager getInstance(){\r\n    return instance;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.gojara.database.LogEntry.getFrom",
	"Comment": "returns the sender of this packet represented by this log entry",
	"Method": "String getFrom(){\r\n    return _from;\r\n}"
}, {
	"Path": "org.jivesoftware.xmpp.workgroup.chatbot.Chatbot.repeatQuestion",
	"Comment": "repeat the last question to the user. this may happen either if because the user requestedit or because the user sent an invalid answer.",
	"Method": "void repeatQuestion(Message message,ChatbotSession session){\r\n    sendQuestion(message, session, session.getCurrentSubstep());\r\n}"
}, {
	"Path": "org.jupiter.common.util.collection.ByteObjectHashMap.removeAt",
	"Comment": "removes entry at the given index position. also performs opportunistic, incremental rehashingif necessary to not break conflict chains.",
	"Method": "boolean removeAt(int index){\r\n    --size;\r\n    keys[index] = 0;\r\n    values[index] = null;\r\n    boolean movedBack = false;\r\n    int nextFree = index;\r\n    for (int i = probeNext(index); values[i] != null; i = probeNext(i)) {\r\n        int bucket = hashIndex(keys[i]);\r\n        if (i < bucket && (bucket <= nextFree || nextFree <= i) || bucket <= nextFree && nextFree <= i) {\r\n            keys[nextFree] = keys[i];\r\n            values[nextFree] = values[i];\r\n            movedBack = true;\r\n            keys[i] = 0;\r\n            values[i] = null;\r\n            nextFree = i;\r\n        }\r\n    }\r\n    return movedBack;\r\n}"
}, {
	"Path": "com.googlecode.lanterna.terminal.DefaultTerminalFactory.isOperatingSystemWindows",
	"Comment": "detects whether the running platform is windows by looking at theoperating system name system property",
	"Method": "boolean isOperatingSystemWindows(){\r\n    return System.getProperty(\"os.name\", \"\").toLowerCase().startsWith(\"windows\");\r\n}"
}]