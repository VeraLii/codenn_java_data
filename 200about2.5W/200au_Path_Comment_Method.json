[{
	"Path": "org.springframework.batch.item.xml.StaxEventItemWriterTests.testDeleteIfEmptyNoRecordsWritten",
	"Comment": "resource is deleted when no items have been written and shoulddeleteifempty flag is set.",
	"Method": "void testDeleteIfEmptyNoRecordsWritten(){\r\n    writer.setShouldDeleteIfEmpty(true);\r\n    writer.open(executionContext);\r\n    writer.close();\r\n    assertFalse(\"file should be deleted\" + resource, resource.getFile().exists());\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.exception.SimpleLimitExceptionHandlerTests.testExceptionThrownAboveLimit",
	"Comment": "transactioninvalidexceptions are swallowed until the exception limit is\texceeded. after the limit is exceeded exceptions are rethrown as\tbatchcriticalexceptions",
	"Method": "void testExceptionThrownAboveLimit(){\r\n    final int EXCEPTION_LIMIT = 3;\r\n    handler.setLimit(EXCEPTION_LIMIT);\r\n    handler.afterPropertiesSet();\r\n    @SuppressWarnings(\"serial\")\r\n    List<Throwable> throwables = new ArrayList<Throwable>() {\r\n        {\r\n            for (int i = 0; i < (EXCEPTION_LIMIT); i++) {\r\n                add(new RuntimeException(\"below exception limit\"));\r\n            }\r\n        }\r\n    };\r\n    throwables.add(new RuntimeException(\"above exception limit\"));\r\n    RepeatContextSupport context = new RepeatContextSupport(null);\r\n    try {\r\n        for (Throwable throwable : throwables) {\r\n            handler.handleException(context, throwable);\r\n            assertTrue(\"exceptions up to limit are swallowed\", true);\r\n        }\r\n    } catch (RuntimeException expected) {\r\n        assertEquals(\"above exception limit\", expected.getMessage());\r\n    }\r\n    try {\r\n        handler.handleException(context, new RuntimeException(\"foo\"));\r\n        assertTrue(\"exceptions up to limit are swallowed\", true);\r\n    } catch (RuntimeException expected) {\r\n        assertEquals(\"foo\", expected.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.ExecutionContext.getString",
	"Comment": "typesafe getter for the string represented by the provided key with\tdefault value to return if key is not represented.",
	"Method": "String getString(String key,String getString,String key,String defaultString){\r\n    if (!containsKey(key)) {\r\n        return defaultString;\r\n    }\r\n    return getString(key);\r\n}"
}, {
	"Path": "org.springframework.batch.core.step.tasklet.AsyncTaskletStepTests.testStepExecutionUpdates",
	"Comment": "stepexecution should be updated after every chunk commit.",
	"Method": "void testStepExecutionUpdates(){\r\n    items = new ArrayList(Arrays.asList(StringUtils.commaDelimitedListToStringArray(\"1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25\")));\r\n    setUp();\r\n    JobExecution jobExecution = jobRepository.createJobExecution(\"JOB\", new JobParameters());\r\n    StepExecution stepExecution = jobExecution.createStepExecution(step.getName());\r\n    step.execute(stepExecution);\r\n    assertEquals(BatchStatus.COMPLETED, stepExecution.getStatus());\r\n    assertTrue(stepExecution.getReadCount() >= 25);\r\n    assertTrue(processed.size() >= 25);\r\n    assertTrue(\"Not enough commits: \" + stepExecution.getCommitCount(), stepExecution.getCommitCount() > processed.size() / 2);\r\n    assertTrue(\"Too many commits: \" + stepExecution.getCommitCount(), stepExecution.getCommitCount() <= processed.size() / 2 + throttleLimit + 1);\r\n}"
}, {
	"Path": "org.springframework.batch.item.ExecutionContext.containsValue",
	"Comment": "indicates whether or not a value is represented in this context.",
	"Method": "boolean containsValue(Object value){\r\n    return this.map.containsValue(value);\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.RepeatTemplate.executeAfterInterceptors",
	"Comment": "convenience method to execute after interceptors on a callback result.",
	"Method": "void executeAfterInterceptors(RepeatContext context,RepeatStatus value){\r\n    if (value != null && value.isContinuable()) {\r\n        for (int i = listeners.length; i-- > 0; ) {\r\n            RepeatListener interceptor = listeners[i];\r\n            interceptor.after(context, value);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.test.autoconfigure.web.servlet.WebDriverScope.registerWith",
	"Comment": "register this scope with the specified context and reassign appropriate bean\tdefinitions to used it.",
	"Method": "void registerWith(ConfigurableApplicationContext context){\r\n    if (!ClassUtils.isPresent(WEB_DRIVER_CLASS, null)) {\r\n        return;\r\n    }\r\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\r\n    if (beanFactory.getRegisteredScope(NAME) == null) {\r\n        beanFactory.registerScope(NAME, new WebDriverScope());\r\n    }\r\n    context.addBeanFactoryPostProcessor(WebDriverScope::postProcessBeanFactory);\r\n}"
}, {
	"Path": "org.springframework.batch.integration.chunk.RemoteChunkHandlerFactoryBean.setNonBuffering",
	"Comment": "overrides the buffering settings in the chunk processor if it is fault tolerant.",
	"Method": "void setNonBuffering(ChunkProcessor<T> chunkProcessor){\r\n    if (chunkProcessor instanceof FaultTolerantChunkProcessor<?, ?>) {\r\n        ((FaultTolerantChunkProcessor<?, ?>) chunkProcessor).setBuffering(false);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.core.step.item.SimpleStepFactoryBeanTests.testCommitIntervalAndCompletionPolicyBothSet",
	"Comment": "commit interval specified is not allowed to be zero or negative.",
	"Method": "void testCommitIntervalAndCompletionPolicyBothSet(){\r\n    SimpleStepFactoryBean<String, String> factory = getStepFactory(\"foo\");\r\n    factory.setCommitInterval(1);\r\n    factory.setChunkCompletionPolicy(new SimpleCompletionPolicy(2));\r\n    try {\r\n        factory.getObject();\r\n        fail();\r\n    } catch (IllegalStateException e) {\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.tunnel.payload.HttpTunnelPayload.writeTo",
	"Comment": "write the content of this payload to the given target channel.",
	"Method": "void writeTo(WritableByteChannel channel){\r\n    Assert.notNull(channel, \"Channel must not be null\");\r\n    while (this.data.hasRemaining()) {\r\n        channel.write(this.data);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.RepeatTemplate.waitForResults",
	"Comment": "if necessary, wait for results to come back from remote or concurrent\tprocesses. by default does nothing and returns true.",
	"Method": "boolean waitForResults(RepeatInternalState state){\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.AbstractCursorItemReader.doClose",
	"Comment": "close the cursor and database connection. make call to cleanuponclose so sub classes can cleanup\tany resources they have allocated.",
	"Method": "void doClose(){\r\n    initialized = false;\r\n    JdbcUtils.closeResultSet(this.rs);\r\n    rs = null;\r\n    cleanupOnClose();\r\n    if (this.con != null) {\r\n        this.con.setAutoCommit(this.initialConnectionAutoCommit);\r\n    }\r\n    if (useSharedExtendedConnection && dataSource instanceof ExtendedConnectionDataSourceProxy) {\r\n        ((ExtendedConnectionDataSourceProxy) dataSource).stopCloseSuppression(this.con);\r\n        if (!TransactionSynchronizationManager.isActualTransactionActive()) {\r\n            DataSourceUtils.releaseConnection(con, dataSource);\r\n        }\r\n    } else {\r\n        JdbcUtils.closeConnection(this.con);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.endpoint.Sanitizer.setKeysToSanitize",
	"Comment": "keys that should be sanitized. keys can be simple strings that the property ends\twith or regular expressions.",
	"Method": "void setKeysToSanitize(String keysToSanitize){\r\n    Assert.notNull(keysToSanitize, \"KeysToSanitize must not be null\");\r\n    this.keysToSanitize = new Pattern[keysToSanitize.length];\r\n    for (int i = 0; i < keysToSanitize.length; i++) {\r\n        this.keysToSanitize[i] = getPattern(keysToSanitize[i]);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.StoredProcedureItemReader.setRefCursorPosition",
	"Comment": "set the parameter position of the ref cursor. only used for oracle and\tpostgresql that use ref cursors. for any other database this should be\tkept as 0 which is the default.",
	"Method": "void setRefCursorPosition(int refCursorPosition){\r\n    this.refCursorPosition = refCursorPosition;\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler.setMessageWriters",
	"Comment": "configure http message writers to serialize the response body with.",
	"Method": "void setMessageWriters(List<HttpMessageWriter<?>> messageWriters){\r\n    Assert.notNull(messageWriters, \"'messageWriters' must not be null\");\r\n    this.messageWriters = messageWriters;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.MongoItemWriter.doWrite",
	"Comment": "performs the actual write to the store via the template.\tthis can be overridden by a subclass if necessary.",
	"Method": "void doWrite(List<? extends T> items){\r\n    if (!CollectionUtils.isEmpty(items)) {\r\n        if (delete) {\r\n            if (StringUtils.hasText(collection)) {\r\n                for (Object object : items) {\r\n                    template.remove(object, collection);\r\n                }\r\n            } else {\r\n                for (Object object : items) {\r\n                    template.remove(object);\r\n                }\r\n            }\r\n        } else {\r\n            if (StringUtils.hasText(collection)) {\r\n                for (Object object : items) {\r\n                    template.save(object, collection);\r\n                }\r\n            } else {\r\n                for (Object object : items) {\r\n                    template.save(object);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.JdbcCursorItemReaderBuilder.fetchSize",
	"Comment": "a hint to the driver as to how many rows to return with each fetch.",
	"Method": "JdbcCursorItemReaderBuilder<T> fetchSize(int fetchSize){\r\n    this.fetchSize = fetchSize;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.support.AbstractItemCountingItemStreamItemReader.isSaveState",
	"Comment": "the flag that determines whether to save internal state for restarts.",
	"Method": "boolean isSaveState(){\r\n    return saveState;\r\n}"
}, {
	"Path": "org.springframework.boot.diagnostics.FailureAnalysis.getAction",
	"Comment": "returns the action, if any, to be taken to address the failure.",
	"Method": "String getAction(){\r\n    return this.action;\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.server.AbstractServletWebServerFactory.shouldRegisterJspServlet",
	"Comment": "returns whether or not the jsp servlet should be registered with the web server.",
	"Method": "boolean shouldRegisterJspServlet(){\r\n    return this.jsp != null && this.jsp.getRegistered() && ClassUtils.isPresent(this.jsp.getClassName(), getClass().getClassLoader());\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.kafka.KafkaProperties.buildProducerProperties",
	"Comment": "create an initial map of producer properties from the state of this instance.\tthis allows you to add additional properties, if necessary, and override the\tdefault kafkaproducerfactory bean.",
	"Method": "Map<String, Object> buildProducerProperties(){\r\n    Map<String, Object> properties = buildCommonProperties();\r\n    properties.putAll(this.producer.buildProperties());\r\n    return properties;\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.ExtendedConnectionDataSourceProxy.getCloseSuppressingConnectionProxy",
	"Comment": "wrap the given connection with a proxy that delegates every method call\tto it but suppresses close calls.",
	"Method": "Connection getCloseSuppressingConnectionProxy(Connection target){\r\n    return (Connection) Proxy.newProxyInstance(ConnectionProxy.class.getClassLoader(), new Class[] { ConnectionProxy.class }, new CloseSuppressingInvocationHandler(target, this));\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.JpaItemWriter.doWrite",
	"Comment": "do perform the actual write operation. this can be overridden in a\tsubclass if necessary.",
	"Method": "void doWrite(EntityManager entityManager,List<? extends T> items){\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Writing to JPA with \" + items.size() + \" items.\");\r\n    }\r\n    if (!items.isEmpty()) {\r\n        long mergeCount = 0;\r\n        for (T item : items) {\r\n            if (!entityManager.contains(item)) {\r\n                entityManager.merge(item);\r\n                mergeCount++;\r\n            }\r\n        }\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(mergeCount + \" entities merged.\");\r\n            logger.debug((items.size() - mergeCount) + \" entities found in persistence context.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.support.transaction.TransactionAwareBufferedWriter.getBufferSize",
	"Comment": "convenience method for clients to determine if there is any unflushed\tdata.",
	"Method": "long getBufferSize(){\r\n    if (!transactionActive()) {\r\n        return 0L;\r\n    }\r\n    try {\r\n        return getCurrentBuffer().toString().getBytes(encoding).length;\r\n    } catch (UnsupportedEncodingException e) {\r\n        throw new WriteFailedException(\"Could not determine buffer size because of unsupported encoding: \" + encoding, e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.support.builder.CompositeItemWriterBuilder.delegates",
	"Comment": "the item writers to use as delegates. items are written to each of the\tdelegates.",
	"Method": "CompositeItemWriterBuilder<T> delegates(List<ItemWriter<? super T>> delegates,CompositeItemWriterBuilder<T> delegates,ItemWriter<? super T> delegates){\r\n    return delegates(Arrays.asList(delegates));\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.isExtensionExposed",
	"Comment": "determine if an extension bean should be exposed. subclasses can override this\tmethod to provide additional logic.",
	"Method": "boolean isExtensionExposed(EndpointBean endpointBean,ExtensionBean extensionBean,boolean isExtensionExposed,Object extensionBean){\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.batch.sample.domain.trade.internal.TradeProcessor.setValidationFailure",
	"Comment": "public setter for the the index on which failure should occur.",
	"Method": "void setValidationFailure(int failure){\r\n    this.failure = failure;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.MongoItemWriterTests.testWriteTransactionReadOnly",
	"Comment": "a pointless use case but validates that the flag is still honored.",
	"Method": "void testWriteTransactionReadOnly(){\r\n    final List<Object> items = new ArrayList<Object>() {\r\n        {\r\n            add(new Object());\r\n            add(new Object());\r\n        }\r\n    };\r\n    writer.setCollection(\"collection\");\r\n    try {\r\n        TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);\r\n        transactionTemplate.setReadOnly(true);\r\n        transactionTemplate.execute((TransactionCallback<Void>) status -> {\r\n            try {\r\n                writer.write(items);\r\n            } catch (Exception ignore) {\r\n                fail(\"unexpected exception thrown\");\r\n            }\r\n            return null;\r\n        });\r\n    } catch (Throwable t) {\r\n        fail(\"Unexpected exception was thrown\");\r\n    }\r\n    verifyZeroInteractions(template);\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.StoredProcedureItemReaderBuilder.useSharedExtendedConnection",
	"Comment": "indicates that the connection used for the cursor is being used by all other\tprocessing, therefor part of the same transaction.",
	"Method": "StoredProcedureItemReaderBuilder<T> useSharedExtendedConnection(boolean useSharedExtendedConnection){\r\n    this.useSharedExtendedConnection = useSharedExtendedConnection;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.SynchronousTests.testInternalRetrySuccessOnFirstAttemptRollbackOuter",
	"Comment": "message processing is successful on the second attempt without having to\treceive the message again.",
	"Method": "void testInternalRetrySuccessOnFirstAttemptRollbackOuter(){\r\n    assertInitialState();\r\n    TransactionTemplate outerTxTemplate = new TransactionTemplate(transactionManager);\r\n    outerTxTemplate.setPropagationBehavior(TransactionTemplate.PROPAGATION_REQUIRES_NEW);\r\n    outerTxTemplate.execute(new TransactionCallback<Void>() {\r\n        @Override\r\n        public Void doInTransaction(TransactionStatus outerStatus) {\r\n            final String text = (String) jmsTemplate.receiveAndConvert(\"queue\");\r\n            try {\r\n                retryTemplate.execute(new RetryCallback<String, Exception>() {\r\n                    @Override\r\n                    public String doWithRetry(RetryContext status) throws Exception {\r\n                        TransactionTemplate nestedTxTemplate = new TransactionTemplate(transactionManager);\r\n                        nestedTxTemplate.setPropagationBehavior(TransactionTemplate.PROPAGATION_NESTED);\r\n                        return nestedTxTemplate.execute(new TransactionCallback<String>() {\r\n                            @Override\r\n                            public String doInTransaction(TransactionStatus nestedStatus) {\r\n                                list.add(text);\r\n                                System.err.println(\"Inserting: [\" + list.size() + \",\" + text + \"]\");\r\n                                jdbcTemplate.update(\"INSERT into T_BARS (id,name,foo_date) values (?,?,null)\", list.size(), text);\r\n                                return text;\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            } catch (Exception e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n            int count = jdbcTemplate.queryForObject(\"select count(*) from T_BARS\", Integer.class);\r\n            assertEquals(1, count);\r\n            outerStatus.setRollbackOnly();\r\n            return null;\r\n        }\r\n    });\r\n    List<String> msgs = getMessages();\r\n    int count = jdbcTemplate.queryForObject(\"select count(*) from T_BARS\", Integer.class);\r\n    assertEquals(0, count);\r\n    assertEquals(\"[foo]\", msgs.toString());\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.SynchronousTests.testInternalRetrySuccessOnFirstAttemptRollbackOuter",
	"Comment": "message processing is successful on the second attempt without having to\treceive the message again.",
	"Method": "void testInternalRetrySuccessOnFirstAttemptRollbackOuter(){\r\n    final String text = (String) jmsTemplate.receiveAndConvert(\"queue\");\r\n    try {\r\n        retryTemplate.execute(new RetryCallback<String, Exception>() {\r\n            @Override\r\n            public String doWithRetry(RetryContext status) throws Exception {\r\n                TransactionTemplate nestedTxTemplate = new TransactionTemplate(transactionManager);\r\n                nestedTxTemplate.setPropagationBehavior(TransactionTemplate.PROPAGATION_NESTED);\r\n                return nestedTxTemplate.execute(new TransactionCallback<String>() {\r\n                    @Override\r\n                    public String doInTransaction(TransactionStatus nestedStatus) {\r\n                        list.add(text);\r\n                        System.err.println(\"Inserting: [\" + list.size() + \",\" + text + \"]\");\r\n                        jdbcTemplate.update(\"INSERT into T_BARS (id,name,foo_date) values (?,?,null)\", list.size(), text);\r\n                        return text;\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    int count = jdbcTemplate.queryForObject(\"select count(*) from T_BARS\", Integer.class);\r\n    assertEquals(1, count);\r\n    outerStatus.setRollbackOnly();\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.SynchronousTests.testInternalRetrySuccessOnFirstAttemptRollbackOuter",
	"Comment": "message processing is successful on the second attempt without having to\treceive the message again.",
	"Method": "void testInternalRetrySuccessOnFirstAttemptRollbackOuter(){\r\n    TransactionTemplate nestedTxTemplate = new TransactionTemplate(transactionManager);\r\n    nestedTxTemplate.setPropagationBehavior(TransactionTemplate.PROPAGATION_NESTED);\r\n    return nestedTxTemplate.execute(new TransactionCallback<String>() {\r\n        @Override\r\n        public String doInTransaction(TransactionStatus nestedStatus) {\r\n            list.add(text);\r\n            System.err.println(\"Inserting: [\" + list.size() + \",\" + text + \"]\");\r\n            jdbcTemplate.update(\"INSERT into T_BARS (id,name,foo_date) values (?,?,null)\", list.size(), text);\r\n            return text;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.SynchronousTests.testInternalRetrySuccessOnFirstAttemptRollbackOuter",
	"Comment": "message processing is successful on the second attempt without having to\treceive the message again.",
	"Method": "void testInternalRetrySuccessOnFirstAttemptRollbackOuter(){\r\n    list.add(text);\r\n    System.err.println(\"Inserting: [\" + list.size() + \",\" + text + \"]\");\r\n    jdbcTemplate.update(\"INSERT into T_BARS (id,name,foo_date) values (?,?,null)\", list.size(), text);\r\n    return text;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.exception.SimpleLimitExceptionHandlerTests.testExceptionNotThrownBelowLimit",
	"Comment": "exceptions are swallowed until the exception limit is exceeded. after the\tlimit is exceeded exceptions are rethrown",
	"Method": "void testExceptionNotThrownBelowLimit(){\r\n    final int EXCEPTION_LIMIT = 3;\r\n    handler.setLimit(EXCEPTION_LIMIT);\r\n    handler.afterPropertiesSet();\r\n    @SuppressWarnings(\"serial\")\r\n    List<Throwable> throwables = new ArrayList<Throwable>() {\r\n        {\r\n            for (int i = 0; i < (EXCEPTION_LIMIT); i++) {\r\n                add(new RuntimeException(\"below exception limit\"));\r\n            }\r\n        }\r\n    };\r\n    RepeatContextSupport context = new RepeatContextSupport(null);\r\n    try {\r\n        for (Throwable throwable : throwables) {\r\n            handler.handleException(context, throwable);\r\n            assertTrue(\"exceptions up to limit are swallowed\", true);\r\n        }\r\n    } catch (RuntimeException unexpected) {\r\n        fail(\"exception rethrown although exception limit was not exceeded\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BindException.getName",
	"Comment": "return the name of the configuration property being bound.",
	"Method": "ConfigurationPropertyName getName(){\r\n    return this.name;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.policy.CompositeCompletionPolicy.update",
	"Comment": "update all the composed contexts, and also increment the parent context.",
	"Method": "void update(RepeatContext context){\r\n    RepeatContext[] contexts = ((CompositeBatchContext) context).contexts;\r\n    CompletionPolicy[] policies = ((CompositeBatchContext) context).policies;\r\n    for (int i = 0; i < policies.length; i++) {\r\n        policies[i].update(contexts[i]);\r\n    }\r\n    ((RepeatContextSupport) context).increment();\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.SimpleRepeatTemplateTests.testEarlyCompletionWithContextTerminated",
	"Comment": "check that a the context can be used to signal early completion.",
	"Method": "void testEarlyCompletionWithContextTerminated(){\r\n    RepeatStatus result = template.iterate(new ItemReaderRepeatCallback<Trade>(provider, processor) {\r\n        @Override\r\n        public RepeatStatus doInIteration(RepeatContext context) throws Exception {\r\n            RepeatStatus result = super.doInIteration(context);\r\n            if (processor.count >= 2) {\r\n                context.setTerminateOnly();\r\n            }\r\n            return result;\r\n        }\r\n    });\r\n    assertEquals(2, processor.count);\r\n    assertTrue(result.isContinuable());\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.SimpleRepeatTemplateTests.testEarlyCompletionWithContextTerminated",
	"Comment": "check that a the context can be used to signal early completion.",
	"Method": "void testEarlyCompletionWithContextTerminated(){\r\n    RepeatStatus result = super.doInIteration(context);\r\n    if (processor.count >= 2) {\r\n        context.setTerminateOnly();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.transform.FormatterLineAggregator.setMinimumLength",
	"Comment": "public setter for the minimum length of the formatted string. if this is\tnot set the default is to allow any length.",
	"Method": "void setMinimumLength(int minimumLength){\r\n    this.minimumLength = minimumLength;\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.tunnel.payload.HttpTunnelPayload.logOutgoing",
	"Comment": "log incoming payload information at trace level to aid diagnostics.",
	"Method": "void logOutgoing(){\r\n    log(\"> \");\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.ServletRegistrationBean.configure",
	"Comment": "configure registration settings. subclasses can override this method to perform\tadditional configuration if required.",
	"Method": "void configure(ServletRegistration.Dynamic registration){\r\n    super.configure(registration);\r\n    String[] urlMapping = StringUtils.toStringArray(this.urlMappings);\r\n    if (urlMapping.length == 0 && this.alwaysMapUrl) {\r\n        urlMapping = DEFAULT_MAPPINGS;\r\n    }\r\n    if (!ObjectUtils.isEmpty(urlMapping)) {\r\n        registration.addMapping(urlMapping);\r\n    }\r\n    registration.setLoadOnStartup(this.loadOnStartup);\r\n    if (this.multipartConfig != null) {\r\n        registration.setMultipartConfig(this.multipartConfig);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.JpaPagingItemReaderBuilder.parameterValues",
	"Comment": "a map of parameter values to be set on the query. the key of the map is the name\tof the parameter to be set with the value being the value to be set.",
	"Method": "JpaPagingItemReaderBuilder<T> parameterValues(Map<String, Object> parameterValues){\r\n    this.parameterValues = parameterValues;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.builder.FlatFileItemReaderBuilder.currentItemCount",
	"Comment": "index for the current item. used on restarts to indicate where to start from.",
	"Method": "FlatFileItemReaderBuilder<T> currentItemCount(int currentItemCount){\r\n    this.currentItemCount = currentItemCount;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.ServletRegistrationBean.getUrlMappings",
	"Comment": "return a mutable collection of the url mappings, as defined in the servlet\tspecification, for the servlet.",
	"Method": "Collection<String> getUrlMappings(){\r\n    return this.urlMappings;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationmetadata.ConfigurationMetadataSource.getGroupId",
	"Comment": "the identifier of the group to which this source is associated.",
	"Method": "String getGroupId(){\r\n    return this.groupId;\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemReader.readToEndFragment",
	"Comment": "read until the first endelement tag that matches the provided fragmentrootelementname. because there may be any\tnumber of tags in between where the reader is now and the fragment end tag, this is done in a loop until the\telement type and name match",
	"Method": "void readToEndFragment(QName fragmentRootElementName){\r\n    while (true) {\r\n        XMLEvent nextEvent = eventReader.nextEvent();\r\n        if (nextEvent.isEndElement() && fragmentRootElementName.equals(((EndElement) nextEvent).getName())) {\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.JsonContentAssert.isNotEqualToJson",
	"Comment": "verifies that the actual value is not equal to the specified json resource.",
	"Method": "JsonContentAssert isNotEqualToJson(CharSequence expected,JsonContentAssert isNotEqualToJson,String path,Class<?> resourceLoadClass,JsonContentAssert isNotEqualToJson,byte[] expected,JsonContentAssert isNotEqualToJson,File expected,JsonContentAssert isNotEqualToJson,InputStream expected,JsonContentAssert isNotEqualToJson,Resource expected,JsonContentAssert isNotEqualToJson,CharSequence expected,JSONCompareMode compareMode,JsonContentAssert isNotEqualToJson,String path,Class<?> resourceLoadClass,JSONCompareMode compareMode,JsonContentAssert isNotEqualToJson,byte[] expected,JSONCompareMode compareMode,JsonContentAssert isNotEqualToJson,File expected,JSONCompareMode compareMode,JsonContentAssert isNotEqualToJson,InputStream expected,JSONCompareMode compareMode,JsonContentAssert isNotEqualToJson,Resource expected,JSONCompareMode compareMode,JsonContentAssert isNotEqualToJson,CharSequence expected,JSONComparator comparator,JsonContentAssert isNotEqualToJson,String path,Class<?> resourceLoadClass,JSONComparator comparator,JsonContentAssert isNotEqualToJson,byte[] expected,JSONComparator comparator,JsonContentAssert isNotEqualToJson,File expected,JSONComparator comparator,JsonContentAssert isNotEqualToJson,InputStream expected,JSONComparator comparator,JsonContentAssert isNotEqualToJson,Resource expected,JSONComparator comparator){\r\n    String expectedJson = this.loader.getJson(expected);\r\n    return assertNotPassed(compare(expectedJson, comparator));\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.policy.CompositeCompletionPolicy.isComplete",
	"Comment": "this policy is complete if any of the composed policies is complete.",
	"Method": "boolean isComplete(RepeatContext context,RepeatStatus result,boolean isComplete,RepeatContext context){\r\n    RepeatContext[] contexts = ((CompositeBatchContext) context).contexts;\r\n    CompletionPolicy[] policies = ((CompositeBatchContext) context).policies;\r\n    for (int i = 0; i < policies.length; i++) {\r\n        if (policies[i].isComplete(contexts[i])) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.HibernateCursorItemReaderBuilder.queryName",
	"Comment": "the name of the hibernate named query to be executed for this reader.",
	"Method": "HibernateCursorItemReaderBuilder<T> queryName(String queryName){\r\n    this.queryName = queryName;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.JdbcCursorItemReader.setPreparedStatementSetter",
	"Comment": "set the preparedstatementsetter to use if any parameter values that need\tto be set in the supplied query.",
	"Method": "void setPreparedStatementSetter(PreparedStatementSetter preparedStatementSetter){\r\n    this.preparedStatementSetter = preparedStatementSetter;\r\n}"
}, {
	"Path": "org.springframework.batch.integration.partition.RemotePartitioningWorkerStepBuilder.inputChannel",
	"Comment": "set the input channel on which step execution requests sent by the master\tare received.",
	"Method": "RemotePartitioningWorkerStepBuilder inputChannel(MessageChannel inputChannel){\r\n    Assert.notNull(inputChannel, \"inputChannel must not be null\");\r\n    this.inputChannel = inputChannel;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.Bindable.getAnnotations",
	"Comment": "return any associated annotations that could affect binding.",
	"Method": "Annotation[] getAnnotations(){\r\n    return this.annotations;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.builder.FlatFileItemReaderBuilder.prototypeBeanName",
	"Comment": "configures the id of a prototype scoped bean to be used as the item returned by the\treader.",
	"Method": "FlatFileItemReaderBuilder<T> prototypeBeanName(String prototypeBeanName){\r\n    this.prototypeBeanName = prototypeBeanName;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.SimpleRepeatTemplateTests.testEarlyCompletionWithSessionAndException",
	"Comment": "check that a the session can be used to signal early completion, but an\texception takes precedence.",
	"Method": "void testEarlyCompletionWithSessionAndException(){\r\n    template.setCompletionPolicy(new SimpleCompletionPolicy(4));\r\n    RepeatStatus result = RepeatStatus.FINISHED;\r\n    try {\r\n        result = template.iterate(new ItemReaderRepeatCallback<Trade>(provider, processor) {\r\n            @Override\r\n            public RepeatStatus doInIteration(RepeatContext context) throws Exception {\r\n                RepeatStatus result = super.doInIteration(context);\r\n                if (processor.count >= 2) {\r\n                    context.setCompleteOnly();\r\n                    throw new RuntimeException(\"Barf second try count=\" + processor.count);\r\n                }\r\n                return result;\r\n            }\r\n        });\r\n        fail(\"Expected exception on last item in batch\");\r\n    } catch (RuntimeException e) {\r\n        assertEquals(\"Barf second try count=2\", e.getMessage());\r\n    }\r\n    assertEquals(2, processor.count);\r\n    System.err.println(result);\r\n    assertFalse(result.isContinuable());\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.SimpleRepeatTemplateTests.testEarlyCompletionWithSessionAndException",
	"Comment": "check that a the session can be used to signal early completion, but an\texception takes precedence.",
	"Method": "void testEarlyCompletionWithSessionAndException(){\r\n    RepeatStatus result = super.doInIteration(context);\r\n    if (processor.count >= 2) {\r\n        context.setCompleteOnly();\r\n        throw new RuntimeException(\"Barf second try count=\" + processor.count);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemWriter.setTransactional",
	"Comment": "flag to indicate that writes should be deferred to the end of a\ttransaction if present. defaults to true.",
	"Method": "void setTransactional(boolean transactional){\r\n    this.transactional = transactional;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.exception.SimpleLimitExceptionHandler.setLimit",
	"Comment": "the limit on the given exception type within a single context before it\tis rethrown.",
	"Method": "void setLimit(int limit){\r\n    this.limit = limit;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.transform.CommonLineTokenizerTests.testHasNames",
	"Comment": "columns names are considered to be specified if they are not null or empty.",
	"Method": "void testHasNames(){\r\n    AbstractLineTokenizer tokenizer = new AbstractLineTokenizer() {\r\n        @Override\r\n        protected List<String> doTokenize(String line) {\r\n            return null;\r\n        }\r\n    };\r\n    assertFalse(tokenizer.hasNames());\r\n    tokenizer.setNames((String) null);\r\n    assertFalse(tokenizer.hasNames());\r\n    tokenizer.setNames(new ArrayList<String>().toArray(new String[0]));\r\n    assertFalse(tokenizer.hasNames());\r\n    tokenizer.setNames(\"name1\", \"name2\");\r\n    assertTrue(tokenizer.hasNames());\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.transform.CommonLineTokenizerTests.testHasNames",
	"Comment": "columns names are considered to be specified if they are not null or empty.",
	"Method": "void testHasNames(){\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemWriterTests.testDeleteIfEmptyRestartAfterDelete",
	"Comment": "test that the writer can restart if the previous execution deleted empty file.",
	"Method": "void testDeleteIfEmptyRestartAfterDelete(){\r\n    writer.setShouldDeleteIfEmpty(true);\r\n    writer.open(executionContext);\r\n    writer.update(executionContext);\r\n    writer.close();\r\n    assertFalse(resource.getFile().exists());\r\n    writer = createItemWriter();\r\n    writer.setShouldDeleteIfEmpty(true);\r\n    writer.open(executionContext);\r\n    writer.write(items);\r\n    writer.update(executionContext);\r\n    writer.close();\r\n    String content = getOutputFileContent();\r\n    assertTrue(\"Wrong content: \" + content, content.contains(TEST_STRING));\r\n}"
}, {
	"Path": "org.springframework.batch.item.mail.DefaultMailErrorHandler.setMaxMessageLength",
	"Comment": "the limit for the size of message that will be copied to the exception\tmessage. output will be truncated beyond that. default value is 1024.",
	"Method": "void setMaxMessageLength(int maxMessageLength){\r\n    this.maxMessageLength = maxMessageLength;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationprocessor.json.JSONTokener.syntaxError",
	"Comment": "returns an exception containing the given message plus the current position and the\tentire input string.",
	"Method": "JSONException syntaxError(String message){\r\n    return new JSONException(message + this);\r\n}"
}, {
	"Path": "org.springframework.batch.sample.domain.trade.internal.TradeWriter.setFailingCustomers",
	"Comment": "public setter for the the customers on which failure should occur.",
	"Method": "void setFailingCustomers(List<String> failingCustomers){\r\n    this.failingCustomers = failingCustomers;\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.builder.StaxEventItemReaderBuilder.currentItemCount",
	"Comment": "index for the current item. used on restarts to indicate where to start from.",
	"Method": "StaxEventItemReaderBuilder<T> currentItemCount(int currentItemCount){\r\n    this.currentItemCount = currentItemCount;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.core.test.repository.JobSupport.setName",
	"Comment": "set the name property. always overrides the default value if this object\tis a spring bean.",
	"Method": "void setName(String name){\r\n    this.name = name;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.RepeatTemplate.setListeners",
	"Comment": "set the listeners for this template, registering them for callbacks at\tappropriate times in the iteration.",
	"Method": "void setListeners(RepeatListener[] listeners){\r\n    this.listeners = Arrays.asList(listeners).toArray(new RepeatListener[listeners.length]);\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemReaderTests.testFragmentWrapping",
	"Comment": "regular usage scenario. itemreader should pass xml fragments to unmarshaller wrapped with startdocument and\tenddocument events.",
	"Method": "void testFragmentWrapping(){\r\n    source.afterPropertiesSet();\r\n    source.open(executionContext);\r\n    assertNotNull(source.read());\r\n    assertNotNull(source.read());\r\n    assertNull(source.read());\r\n    source.close();\r\n}"
}, {
	"Path": "org.springframework.batch.support.LastModifiedResourceComparator.compare",
	"Comment": "compare the two resources by last modified time, so that a sorted list of\tresources will have oldest first.",
	"Method": "int compare(Resource r1,Resource r2){\r\n    Assert.isTrue(r1.exists(), \"Resource does not exist: \" + r1);\r\n    Assert.isTrue(r2.exists(), \"Resource does not exist: \" + r2);\r\n    try {\r\n        long diff = r1.getFile().lastModified() - r2.getFile().lastModified();\r\n        return diff > 0 ? 1 : diff < 0 ? -1 : 0;\r\n    } catch (IOException e) {\r\n        throw new IllegalArgumentException(\"Resource modification times cannot be determined (unexpected).\", e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.isIncludeStackTrace",
	"Comment": "determine if the stacktrace attribute should be included.",
	"Method": "boolean isIncludeStackTrace(HttpServletRequest request,MediaType produces){\r\n    IncludeStacktrace include = getErrorProperties().getIncludeStacktrace();\r\n    if (include == IncludeStacktrace.ALWAYS) {\r\n        return true;\r\n    }\r\n    if (include == IncludeStacktrace.ON_TRACE_PARAM) {\r\n        return getTraceParameter(request);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.exception.SimpleLimitExceptionHandlerTests.testLimitedExceptionNotThrownFromSiblings",
	"Comment": "transactioninvalidexception should only be rethrown below the exception\tlimit.",
	"Method": "void testLimitedExceptionNotThrownFromSiblings(){\r\n    Throwable throwable = new RuntimeException(\"foo\");\r\n    final int MORE_THAN_ZERO = 1;\r\n    handler.setLimit(MORE_THAN_ZERO);\r\n    handler.setExceptionClasses(Collections.<Class<? extends Throwable>>singleton(RuntimeException.class));\r\n    handler.afterPropertiesSet();\r\n    RepeatContextSupport parent = new RepeatContextSupport(null);\r\n    try {\r\n        RepeatContextSupport context = new RepeatContextSupport(parent);\r\n        handler.handleException(context, throwable);\r\n        context = new RepeatContextSupport(parent);\r\n        handler.handleException(context, throwable);\r\n    } catch (RuntimeException expected) {\r\n        fail(\"Unexpected exception.\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.util.LambdaSafe.callbacks",
	"Comment": "start a call to callback instances, dealing with common generic type concerns and\texceptions.",
	"Method": "Callbacks<C, A> callbacks(Class<C> callbackType,Collection<? extends C> callbackInstances,A argument,Object additionalArguments){\r\n    Assert.notNull(callbackType, \"CallbackType must not be null\");\r\n    Assert.notNull(callbackInstances, \"CallbackInstances must not be null\");\r\n    return new Callbacks(callbackType, callbackInstances, argument, additionalArguments);\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.MultiResourceItemWriter.setSaveState",
	"Comment": "indicates that the state of the reader will be saved after each commit.",
	"Method": "void setSaveState(boolean saveState){\r\n    this.saveState = saveState;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.builder.RepositoryItemWriterBuilder.methodName",
	"Comment": "specifies what method on the repository to call. this method must have the type of\tobject passed to this writer as the sole argument.",
	"Method": "RepositoryItemWriterBuilder<T> methodName(String methodName){\r\n    this.methodName = methodName;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.support.PropertiesConverterTests.testShortConversionWithCommas",
	"Comment": "check that properties can be comma delimited with extra whitespace.",
	"Method": "void testShortConversionWithCommas(){\r\n    Properties storedProps = new Properties();\r\n    storedProps.setProperty(\"key1\", \"value1\");\r\n    storedProps.setProperty(\"key2\", \"value2\");\r\n    String value = PropertiesConverter.propertiesToString(storedProps);\r\n    assertTrue(\"Wrong value: \" + value, value.contains(\"key1=value1\"));\r\n    assertTrue(\"Wrong value: \" + value, value.contains(\"key2=value2\"));\r\n    assertEquals(1, StringUtils.countOccurrencesOf(value, \",\"));\r\n}"
}, {
	"Path": "org.springframework.batch.core.step.item.SimpleStepFactoryBeanTests.testCommitIntervalMustBeGreaterThanZero",
	"Comment": "commit interval specified is not allowed to be zero or negative.",
	"Method": "void testCommitIntervalMustBeGreaterThanZero(){\r\n    SimpleStepFactoryBean<String, String> factory = getStepFactory(\"foo\");\r\n    factory.getObject();\r\n    factory = getStepFactory(\"foo\");\r\n    factory.setCommitInterval(-1);\r\n    try {\r\n        factory.getObject();\r\n        fail();\r\n    } catch (IllegalStateException e) {\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.support.SystemPropertyInitializer.afterPropertiesSet",
	"Comment": "sets the system property with the provided name and default value.",
	"Method": "void afterPropertiesSet(){\r\n    Assert.state(defaultValue != null || System.getProperty(keyName) != null, \"Either a default value must be specified or the value should already be set for System property: \" + keyName);\r\n    System.setProperty(keyName, System.getProperty(keyName, defaultValue));\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.web.mappings.servlet.FilterRegistrationMappingDescription.getUrlPatternMappings",
	"Comment": "returns the url pattern mappings for the registered filter.",
	"Method": "Collection<String> getUrlPatternMappings(){\r\n    return this.getRegistration().getUrlPatternMappings();\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.exception.SimpleLimitExceptionHandlerTests.testLimitedExceptionThrownFromSiblingsWhenUsingParent",
	"Comment": "transactioninvalidexception should only be rethrown below the exception\tlimit.",
	"Method": "void testLimitedExceptionThrownFromSiblingsWhenUsingParent(){\r\n    Throwable throwable = new RuntimeException(\"foo\");\r\n    final int MORE_THAN_ZERO = 1;\r\n    handler.setLimit(MORE_THAN_ZERO);\r\n    handler.setExceptionClasses(Collections.<Class<? extends Throwable>>singleton(RuntimeException.class));\r\n    handler.setUseParent(true);\r\n    handler.afterPropertiesSet();\r\n    RepeatContextSupport parent = new RepeatContextSupport(null);\r\n    try {\r\n        RepeatContextSupport context = new RepeatContextSupport(parent);\r\n        handler.handleException(context, throwable);\r\n        context = new RepeatContextSupport(parent);\r\n        handler.handleException(context, throwable);\r\n        fail(\"Expected exception.\");\r\n    } catch (RuntimeException expected) {\r\n        assertSame(throwable, expected);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.builder.FlatFileItemWriterBuilder.shouldDeleteIfEmpty",
	"Comment": "if set to true, once the step is complete, if the resource previously provided is\tempty, it will be deleted.",
	"Method": "FlatFileItemWriterBuilder<T> shouldDeleteIfEmpty(boolean shouldDelete){\r\n    this.shouldDeleteIfEmpty = shouldDelete;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.integration.chunk.ChunkMessageChannelItemWriter.waitForResults",
	"Comment": "wait until all the results that are in the pipeline come back to the reply channel.",
	"Method": "boolean waitForResults(){\r\n    int count = 0;\r\n    int maxCount = maxWaitTimeouts;\r\n    Throwable failure = null;\r\n    logger.info(\"Waiting for \" + localState.getExpecting() + \" results\");\r\n    while (localState.getExpecting() > 0 && count++ < maxCount) {\r\n        try {\r\n            getNextResult();\r\n        } catch (Throwable t) {\r\n            logger.error(\"Detected error in remote result. Trying to recover \" + localState.getExpecting() + \" outstanding results before completing.\", t);\r\n            failure = t;\r\n        }\r\n    }\r\n    if (failure != null) {\r\n        throw wrapIfNecessary(failure);\r\n    }\r\n    return count < maxCount;\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.AbstractCursorItemReader.setVerifyCursorPosition",
	"Comment": "allow verification of cursor position after current row is processed by\trowmapper or rowcallbackhandler. default value is true.",
	"Method": "void setVerifyCursorPosition(boolean verifyCursorPosition){\r\n    this.verifyCursorPosition = verifyCursorPosition;\r\n}"
}, {
	"Path": "org.springframework.boot.logging.DeferredLog.replay",
	"Comment": "replay from a source log to a destination log when the source is deferred.",
	"Method": "Log replay(Log source,Class<?> destination,Log replay,Log source,Log destination){\r\n    if (source instanceof DeferredLog) {\r\n        ((DeferredLog) source).replayTo(destination);\r\n    }\r\n    return destination;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.autoconfigure.cloudfoundry.CloudFoundryAuthorizationException.getStatusCode",
	"Comment": "return the status code that should be returned to the client.",
	"Method": "HttpStatus getStatusCode(){\r\n    return getReason().getStatus();\r\n}"
}, {
	"Path": "org.springframework.batch.integration.partition.RemotePartitioningMasterStepBuilder.pollInterval",
	"Comment": "how often to poll the job repository for the status of the workers. defaults to 10 seconds.",
	"Method": "RemotePartitioningMasterStepBuilder pollInterval(long pollInterval){\r\n    Assert.isTrue(pollInterval > 0, \"The poll interval must be greater than zero\");\r\n    this.pollInterval = pollInterval;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.cli.compiler.grape.RepositoryConfiguration.getSnapshotsEnabled",
	"Comment": "return if the repository should enable access to snapshots.",
	"Method": "boolean getSnapshotsEnabled(){\r\n    return this.snapshotsEnabled;\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.builder.StaxEventItemWriterBuilder.shouldDeleteIfEmpty",
	"Comment": "flag to indicate that the output file should be deleted if no results were written\tto it.defaults to false.",
	"Method": "StaxEventItemWriterBuilder<T> shouldDeleteIfEmpty(boolean shouldDelete){\r\n    this.shouldDeleteIfEmpty = shouldDelete;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.cli.command.init.ProjectGenerationRequest.getType",
	"Comment": "the type of project to generate. should match one of the advertized type that the\tservice supports. if not set, the default is retrieved from the service metadata.",
	"Method": "String getType(){\r\n    return this.type;\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.AbstractJdbcItemReaderIntegrationTests.testInvalidRestore",
	"Comment": "reading from an input source and then trying to restore causes an error.",
	"Method": "void testInvalidRestore(){\r\n    getAsItemStream(itemReader).open(executionContext);\r\n    Foo foo1 = itemReader.read();\r\n    assertEquals(1, foo1.getValue());\r\n    Foo foo2 = itemReader.read();\r\n    assertEquals(2, foo2.getValue());\r\n    getAsItemStream(itemReader).update(executionContext);\r\n    itemReader = createItemReader();\r\n    getAsItemStream(itemReader).open(new ExecutionContext());\r\n    Foo foo = itemReader.read();\r\n    assertEquals(1, foo.getValue());\r\n    try {\r\n        getAsItemStream(itemReader).open(executionContext);\r\n        fail();\r\n    } catch (IllegalStateException ex) {\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.JdbcCursorItemReader.setSql",
	"Comment": "set the sql statement to be used when creating the cursor. this statement\tshould be a complete and valid sql statement, as it will be run directly\twithout any modification.",
	"Method": "void setSql(String sql){\r\n    this.sql = sql;\r\n}"
}, {
	"Path": "org.springframework.batch.item.ExecutionContext.put",
	"Comment": "add an object value to the context. putting null\tvalue for a given key removes the key.",
	"Method": "void put(String key,Object value){\r\n    if (value != null) {\r\n        Object result = this.map.put(key, value);\r\n        this.dirty = result == null || result != null && !result.equals(value);\r\n    } else {\r\n        Object result = this.map.remove(key);\r\n        this.dirty = result != null;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.stax.DefaultFragmentEventReader.checkFragmentEnd",
	"Comment": "sets the endfragmentfollows flag to true if next event is the last event\tof the fragment.",
	"Method": "void checkFragmentEnd(XMLEvent event){\r\n    if (event.isStartElement() && ((StartElement) event).getName().equals(fragmentRootName)) {\r\n        matchCounter++;\r\n    } else if (event.isEndElement() && ((EndElement) event).getName().equals(fragmentRootName)) {\r\n        matchCounter--;\r\n        if (matchCounter == 0) {\r\n            endFragmentFollows = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.SpringBootExceptionHandler.isLogConfigurationMessage",
	"Comment": "check if the exception is a log configuration message, i.e. the log call might not\thave actually output anything.",
	"Method": "boolean isLogConfigurationMessage(Throwable ex){\r\n    if (ex instanceof InvocationTargetException) {\r\n        return isLogConfigurationMessage(ex.getCause());\r\n    }\r\n    String message = ex.getMessage();\r\n    if (message != null) {\r\n        for (String candidate : LOG_CONFIGURATION_MESSAGES) {\r\n            if (message.contains(candidate)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.builder.Neo4jItemReaderBuilder.returnStatement",
	"Comment": "the return statement of the cypher query. return is prepended to the statement\tprovided and should not be included",
	"Method": "Neo4jItemReaderBuilder<T> returnStatement(String returnStatement){\r\n    this.returnStatement = returnStatement;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.kafka.ConcurrentKafkaListenerContainerFactoryConfigurer.configure",
	"Comment": "configure the specified kafka listener container factory. the factory can be\tfurther tuned and default settings can be overridden.",
	"Method": "void configure(ConcurrentKafkaListenerContainerFactory<Object, Object> listenerFactory,ConsumerFactory<Object, Object> consumerFactory){\r\n    listenerFactory.setConsumerFactory(consumerFactory);\r\n    configureListenerFactory(listenerFactory);\r\n    configureContainer(listenerFactory.getContainerProperties());\r\n}"
}, {
	"Path": "org.springframework.boot.type.classreading.ConcurrentReferenceCachingMetadataReaderFactory.clearCache",
	"Comment": "clear the entire metadatareader cache, removing all cached class metadata.",
	"Method": "void clearCache(){\r\n    this.cache.clear();\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.MongoItemReader.setTemplate",
	"Comment": "used to perform operations against the mongodb instance.also\thandles the mapping of documents to objects.",
	"Method": "void setTemplate(MongoOperations template){\r\n    this.template = template;\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.builder.StaxEventItemWriterBuilder.overwriteOutput",
	"Comment": "indicates if an existing file should be overwritten if found. defaults to true.",
	"Method": "StaxEventItemWriterBuilder<T> overwriteOutput(boolean overwriteOutput){\r\n    this.overwriteOutput = overwriteOutput;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemReader.moveCursorToNextFragment",
	"Comment": "responsible for moving the cursor before the startelement of the fragment root.\tthis implementation simply looks for the next corresponding element, it does not care about element nesting. you\twill need to override this method to correctly handle composite fragments.",
	"Method": "boolean moveCursorToNextFragment(XMLEventReader reader){\r\n    try {\r\n        while (true) {\r\n            while (reader.peek() != null && !reader.peek().isStartElement()) {\r\n                reader.nextEvent();\r\n            }\r\n            if (reader.peek() == null) {\r\n                return false;\r\n            }\r\n            QName startElementName = ((StartElement) reader.peek()).getName();\r\n            if (isFragmentRootElementName(startElementName)) {\r\n                return true;\r\n            }\r\n            reader.nextEvent();\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        throw new NonTransientResourceException(\"Error while reading from event reader\", e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.stax.NoStartEndDocumentWriterTests.testClose",
	"Comment": "close is not delegated to the wrapped writer. instead, the wrapped writer is flushed.",
	"Method": "void testClose(){\r\n    writer.close();\r\n    verify(wrappedWriter, times(1)).flush();\r\n    verify(wrappedWriter, never()).close();\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.AbstractCursorItemReader.getExceptionTranslator",
	"Comment": "creates a default sqlerrorcodesqlexceptiontranslator for the specified\tdatasource if none is set.",
	"Method": "SQLExceptionTranslator getExceptionTranslator(){\r\n    synchronized (this) {\r\n        if (exceptionTranslator == null) {\r\n            if (dataSource != null) {\r\n                exceptionTranslator = new SQLErrorCodeSQLExceptionTranslator(dataSource);\r\n            } else {\r\n                exceptionTranslator = new SQLStateSQLExceptionTranslator();\r\n            }\r\n        }\r\n    }\r\n    return exceptionTranslator;\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.HibernateCursorItemReaderBuilder.fetchSize",
	"Comment": "the number of items to be returned with each round trip to the database.used\tinternally by hibernate.",
	"Method": "HibernateCursorItemReaderBuilder<T> fetchSize(int fetchSize){\r\n    this.fetchSize = fetchSize;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.MultiResourceItemReader.readNextItem",
	"Comment": "use the delegate to read the next item, jump to next resource if current one is exhausted. items are appended to\tthe buffer.",
	"Method": "T readNextItem(){\r\n    T item = readFromDelegate();\r\n    while (item == null) {\r\n        currentResource++;\r\n        if (currentResource >= resources.length) {\r\n            return null;\r\n        }\r\n        delegate.close();\r\n        delegate.setResource(resources[currentResource]);\r\n        delegate.open(new ExecutionContext());\r\n        item = readFromDelegate();\r\n    }\r\n    return item;\r\n}"
}, {
	"Path": "org.springframework.batch.item.support.CompositeItemWriter.setIgnoreItemStream",
	"Comment": "establishes the policy whether to call the open, close, or update methods for the\titem writer delegates associated with the compositeitemwriter.",
	"Method": "void setIgnoreItemStream(boolean ignoreItemStream){\r\n    this.ignoreItemStream = ignoreItemStream;\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.AbstractCursorItemReader.moveCursorToRow",
	"Comment": "moves the cursor in the resultset to the position specified by the row\tparameter by traversing the resultset.",
	"Method": "void moveCursorToRow(int row){\r\n    try {\r\n        int count = 0;\r\n        while (row != count && rs.next()) {\r\n            count++;\r\n        }\r\n    } catch (SQLException se) {\r\n        throw getExceptionTranslator().translate(\"Attempted to move ResultSet to last committed row\", getSql(), se);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.JsonContentAssert.extractingJsonPathStringValue",
	"Comment": "extract the string value at the given json path for further object assertions.",
	"Method": "AbstractCharSequenceAssert<?, String> extractingJsonPathStringValue(CharSequence expression,Object args){\r\n    return Assertions.assertThat(extractingJsonPathValue(expression, args, String.class, \"a string\"));\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.StoredProcedureItemReaderBuilder.fetchSize",
	"Comment": "a hint to the driver as to how many rows to return with each fetch.",
	"Method": "StoredProcedureItemReaderBuilder<T> fetchSize(int fetchSize){\r\n    this.fetchSize = fetchSize;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.ExecutionContext.getLong",
	"Comment": "typesafe getter for the long represented by the provided key with default\tvalue to return if key is not represented.",
	"Method": "long getLong(String key,long getLong,String key,long defaultLong){\r\n    if (!containsKey(key)) {\r\n        return defaultLong;\r\n    }\r\n    return getLong(key);\r\n}"
}, {
	"Path": "org.springframework.boot.builder.SpringApplicationBuilder.main",
	"Comment": "fixes the main application class that is used to anchor the startup messages.",
	"Method": "SpringApplicationBuilder main(Class<?> mainApplicationClass){\r\n    this.application.setMainApplicationClass(mainApplicationClass);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler.setMessageReaders",
	"Comment": "configure http message readers to deserialize the request body with.",
	"Method": "void setMessageReaders(List<HttpMessageReader<?>> messageReaders){\r\n    Assert.notNull(messageReaders, \"'messageReaders' must not be null\");\r\n    this.messageReaders = messageReaders;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.policy.CompositeCompletionPolicy.start",
	"Comment": "create a new composite context from all the available policies.",
	"Method": "RepeatContext start(RepeatContext context){\r\n    List<RepeatContext> list = new ArrayList();\r\n    for (int i = 0; i < policies.length; i++) {\r\n        list.add(policies[i].start(context));\r\n    }\r\n    return new CompositeBatchContext(context, list);\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.restart.Restarter.relaunch",
	"Comment": "relaunch the application using the specified classloader.",
	"Method": "Throwable relaunch(ClassLoader classLoader){\r\n    RestartLauncher launcher = new RestartLauncher(classLoader, this.mainClassName, this.args, this.exceptionHandler);\r\n    launcher.start();\r\n    launcher.join();\r\n    return launcher.getError();\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.builder.FlatFileItemWriterBuilder.shouldDeleteIfExists",
	"Comment": "if set to true, upon the start of the step, if the resource already exists, it will\tbe deleted and recreated.",
	"Method": "FlatFileItemWriterBuilder<T> shouldDeleteIfExists(boolean shouldDelete){\r\n    this.shouldDeleteIfExists = shouldDelete;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.builder.RepositoryItemReaderBuilder.sorts",
	"Comment": "provides ordering of the results so that order is maintained between paged queries.",
	"Method": "RepositoryItemReaderBuilder<T> sorts(Map<String, Sort.Direction> sorts){\r\n    this.sorts = sorts;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.builder.MultiResourceItemWriterBuilder.itemCountLimitPerResource",
	"Comment": "after this limit is exceeded the next chunk will be written into newly created\tresource.",
	"Method": "MultiResourceItemWriterBuilder<T> itemCountLimitPerResource(int itemCountLimitPerResource){\r\n    this.itemCountLimitPerResource = itemCountLimitPerResource;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.util.FileUtilsTests.testCreateDirectoryStructure",
	"Comment": "if the directories on the file path do not exist, they should be created",
	"Method": "void testCreateDirectoryStructure(){\r\n    File file = new File(\"testDirectory/testDirectory2/testFile.tmp\");\r\n    File dir1 = new File(\"testDirectory\");\r\n    File dir2 = new File(\"testDirectory/testDirectory2\");\r\n    try {\r\n        FileUtils.setUpOutputFile(file, false, false, false);\r\n        assertTrue(file.exists());\r\n        assertTrue(dir1.exists());\r\n        assertTrue(dir2.exists());\r\n    } finally {\r\n        file.delete();\r\n        dir2.delete();\r\n        dir1.delete();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport.recordExclusions",
	"Comment": "records the names of the classes that have been excluded from condition evaluation.",
	"Method": "void recordExclusions(Collection<String> exclusions){\r\n    Assert.notNull(exclusions, \"exclusions must not be null\");\r\n    this.exclusions.addAll(exclusions);\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.JdbcCursorItemReaderBuilder.currentItemCount",
	"Comment": "index for the current item. used on restarts to indicate where to start from.",
	"Method": "JdbcCursorItemReaderBuilder<T> currentItemCount(int currentItemCount){\r\n    this.currentItemCount = currentItemCount;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.couchbase.CouchbaseConfiguration.initializeEnvironmentBuilder",
	"Comment": "initialize an environment builder based on the specified settings.",
	"Method": "DefaultCouchbaseEnvironment.Builder initializeEnvironmentBuilder(CouchbaseProperties properties){\r\n    CouchbaseProperties.Endpoints endpoints = properties.getEnv().getEndpoints();\r\n    CouchbaseProperties.Timeouts timeouts = properties.getEnv().getTimeouts();\r\n    DefaultCouchbaseEnvironment.Builder builder = DefaultCouchbaseEnvironment.builder();\r\n    if (timeouts.getConnect() != null) {\r\n        builder = builder.connectTimeout(timeouts.getConnect().toMillis());\r\n    }\r\n    builder = builder.keyValueServiceConfig(KeyValueServiceConfig.create(endpoints.getKeyValue()));\r\n    if (timeouts.getKeyValue() != null) {\r\n        builder = builder.kvTimeout(timeouts.getKeyValue().toMillis());\r\n    }\r\n    if (timeouts.getQuery() != null) {\r\n        builder = builder.queryTimeout(timeouts.getQuery().toMillis());\r\n        builder = builder.queryServiceConfig(getQueryServiceConfig(endpoints));\r\n        builder = builder.viewServiceConfig(getViewServiceConfig(endpoints));\r\n    }\r\n    if (timeouts.getSocketConnect() != null) {\r\n        builder = builder.socketConnectTimeout((int) timeouts.getSocketConnect().toMillis());\r\n    }\r\n    if (timeouts.getView() != null) {\r\n        builder = builder.viewTimeout(timeouts.getView().toMillis());\r\n    }\r\n    CouchbaseProperties.Ssl ssl = properties.getEnv().getSsl();\r\n    if (ssl.getEnabled()) {\r\n        builder = builder.sslEnabled(true);\r\n        if (ssl.getKeyStore() != null) {\r\n            builder = builder.sslKeystoreFile(ssl.getKeyStore());\r\n        }\r\n        if (ssl.getKeyStorePassword() != null) {\r\n            builder = builder.sslKeystorePassword(ssl.getKeyStorePassword());\r\n        }\r\n    }\r\n    return builder;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.RepositoryItemReader.setSort",
	"Comment": "provides ordering of the results so that order is maintained between paged queries",
	"Method": "void setSort(Map<String, Sort.Direction> sorts){\r\n    this.sort = convertToSort(sorts);\r\n}"
}, {
	"Path": "org.springframework.batch.sample.jmx.JobExecutionNotificationPublisher.publish",
	"Comment": "publish the provided message to an external listener if there is one.",
	"Method": "void publish(String message){\r\n    if (notificationPublisher != null) {\r\n        Notification notification = new Notification(\"JobExecutionApplicationEvent\", this, notificationCount++, message);\r\n        notification.setSource(null);\r\n        notificationPublisher.sendNotification(notification);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.context.properties.ConfigurationPropertiesReportEndpoint.sanitize",
	"Comment": "sanitize all unwanted configuration properties to avoid leaking of sensitive\tinformation.",
	"Method": "Map<String, Object> sanitize(String prefix,Map<String, Object> map,List<Object> sanitize,String prefix,List<Object> list){\r\n    List<Object> sanitized = new ArrayList();\r\n    for (Object item : list) {\r\n        if (item instanceof Map) {\r\n            sanitized.add(sanitize(prefix, (Map<String, Object>) item));\r\n        } else if (item instanceof List) {\r\n            sanitized.add(sanitize(prefix, (List<Object>) item));\r\n        } else {\r\n            sanitized.add(this.sanitizer.sanitize(prefix, item));\r\n        }\r\n    }\r\n    return sanitized;\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.DynamicRegistrationBean.getOrDeduceName",
	"Comment": "deduces the name for this registration. will return user specified name or fallback\tto convention based naming.",
	"Method": "String getOrDeduceName(Object value){\r\n    return (this.name != null) ? this.name : Conventions.getVariableName(value);\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.livereload.LiveReloadServerTests.main",
	"Comment": "useful main method for manual testing against a real browser.",
	"Method": "void main(String[] args){\r\n    LiveReloadServer server = new LiveReloadServer();\r\n    server.start();\r\n    while (true) {\r\n        try {\r\n            Thread.sleep(1000);\r\n        } catch (InterruptedException ex) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n        server.triggerReload();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BindResult.orElseCreate",
	"Comment": "return the object that was bound, or a new instance of the specified class if no\tvalue has been bound.",
	"Method": "T orElseCreate(Class<? extends T> type){\r\n    Assert.notNull(type, \"Type must not be null\");\r\n    return (this.value != null) ? this.value : BeanUtils.instantiateClass(type);\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BindResult.map",
	"Comment": "apply the provided mapping function to the bound value, or return an updated\tunbound result if no value has been bound.",
	"Method": "BindResult<U> map(Function<? super T, ? extends U> mapper){\r\n    Assert.notNull(mapper, \"Mapper must not be null\");\r\n    return of((this.value != null) ? mapper.apply(this.value) : null);\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.HibernatePagingItemReaderBuilder.currentItemCount",
	"Comment": "index for the current item. used on restarts to indicate where to start from.",
	"Method": "HibernatePagingItemReaderBuilder<T> currentItemCount(int currentItemCount){\r\n    this.currentItemCount = currentItemCount;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.support.AbstractFileItemWriter.setFooterCallback",
	"Comment": "footercallback will be called after writing the last item to file, but\tbefore the file is closed.",
	"Method": "void setFooterCallback(FlatFileFooterCallback footerCallback){\r\n    this.footerCallback = footerCallback;\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.jdbc.DataSourceProperties.determineUsername",
	"Comment": "determine the username to use based on this configuration and the environment.",
	"Method": "String determineUsername(){\r\n    if (StringUtils.hasText(this.username)) {\r\n        return this.username;\r\n    }\r\n    if (EmbeddedDatabaseConnection.isEmbedded(determineDriverClassName())) {\r\n        return \"sa\";\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.boot.SpringApplication.getMainApplicationClass",
	"Comment": "returns the main application class that has been deduced or explicitly configured.",
	"Method": "Class<?> getMainApplicationClass(){\r\n    return this.mainApplicationClass;\r\n}"
}, {
	"Path": "org.springframework.batch.item.json.builder.JsonItemReaderBuilder.currentItemCount",
	"Comment": "index for the current item. used on restarts to indicate where to start from.",
	"Method": "JsonItemReaderBuilder<T> currentItemCount(int currentItemCount){\r\n    this.currentItemCount = currentItemCount;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.core.step.StepSupport.execute",
	"Comment": "not supported but provided so that tests can easily create a step.",
	"Method": "void execute(StepExecution stepExecution){\r\n    throw new UnsupportedOperationException(\"Cannot process a StepExecution.  Use a smarter subclass of StepSupport.\");\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.AbstractCursorItemReader.setQueryTimeout",
	"Comment": "sets the number of seconds the driver will wait for a\tstatement object to execute to the given number of seconds.\tif the limit is exceeded, an sqlexception is thrown.",
	"Method": "void setQueryTimeout(int queryTimeout){\r\n    this.queryTimeout = queryTimeout;\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.JdbcPagingItemReaderBuilder.fetchSize",
	"Comment": "a hint to the underlying rdbms as to how many records to return with each fetch.",
	"Method": "JdbcPagingItemReaderBuilder<T> fetchSize(int fetchSize){\r\n    this.fetchSize = fetchSize;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationprocessor.json.JSONObject.names",
	"Comment": "returns an array containing the string names in this object. this method returns\tnull if this object contains no mappings.",
	"Method": "JSONArray names(){\r\n    return this.nameValuePairs.isEmpty() ? null : new JSONArray(new ArrayList(this.nameValuePairs.keySet()));\r\n}"
}, {
	"Path": "org.springframework.boot.configurationmetadata.ConfigurationMetadataGroup.getId",
	"Comment": "return the id of the group, used as a common prefix for all properties associated\tto it.",
	"Method": "String getId(){\r\n    return this.id;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.builder.FlatFileItemWriterBuilder.transactional",
	"Comment": "if set to true, the flushing of the buffer is delayed while a transaction is active.",
	"Method": "FlatFileItemWriterBuilder<T> transactional(boolean transactional){\r\n    this.transactional = transactional;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.separator.SuffixRecordSeparatorPolicy.setIgnoreWhitespace",
	"Comment": "flag to indicate that the decision to terminate a record should ignore\twhitespace at the end of the line.",
	"Method": "void setIgnoreWhitespace(boolean ignoreWhitespace){\r\n    this.ignoreWhitespace = ignoreWhitespace;\r\n}"
}, {
	"Path": "org.springframework.boot.web.embedded.netty.NettyReactiveWebServerFactory.setLifecycleTimeout",
	"Comment": "set the maximum amount of time that should be waited when starting or stopping the\tserver.",
	"Method": "void setLifecycleTimeout(Duration lifecycleTimeout){\r\n    this.lifecycleTimeout = lifecycleTimeout;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.RepositoryItemWriter.setMethodName",
	"Comment": "specifies what method on the repository to call.this method must have the type of\tobject passed to this writer as the sole argument.",
	"Method": "void setMethodName(String methodName){\r\n    this.methodName = methodName;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.AbstractNeo4jItemReader.setWhereStatement",
	"Comment": "an optional where fragment of the cypher query.where is\tprepended to the statement provided and should not\tbe included.",
	"Method": "void setWhereStatement(String whereStatement){\r\n    this.whereStatement = whereStatement;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.exception.RethrowOnThresholdExceptionHandler.setThresholds",
	"Comment": "a map from exception classes to a threshold value of type integer.",
	"Method": "void setThresholds(Map<Class<? extends Throwable>, Integer> thresholds){\r\n    Map<Class<? extends Throwable>, IntegerHolder> typeMap = new HashMap();\r\n    for (Entry<Class<? extends Throwable>, Integer> entry : thresholds.entrySet()) {\r\n        typeMap.put(entry.getKey(), new IntegerHolder(entry.getValue()));\r\n    }\r\n    exceptionClassifier = new SubclassClassifier(typeMap, ZERO);\r\n}"
}, {
	"Path": "org.springframework.batch.integration.chunk.RemoteChunkingMasterStepBuilderTest.testSetters",
	"Comment": "the following test is to cover setters that override those from parent builders.",
	"Method": "void testSetters(){\r\n    DefaultTransactionAttribute transactionAttribute = new DefaultTransactionAttribute();\r\n    Object annotatedListener = new Object();\r\n    MapRetryContextCache retryCache = new MapRetryContextCache();\r\n    RepeatTemplate stepOperations = new RepeatTemplate();\r\n    NoBackOffPolicy backOffPolicy = new NoBackOffPolicy();\r\n    ItemStreamSupport stream = new ItemStreamSupport() {\r\n    };\r\n    StepExecutionListener stepExecutionListener = mock(StepExecutionListener.class);\r\n    ItemReadListener<String> itemReadListener = mock(ItemReadListener.class);\r\n    ItemWriteListener<String> itemWriteListener = mock(ItemWriteListener.class);\r\n    ChunkListener chunkListener = mock(ChunkListener.class);\r\n    SkipListener<String, String> skipListener = mock(SkipListener.class);\r\n    RetryListener retryListener = mock(RetryListener.class);\r\n    when(retryListener.open(any(), any())).thenReturn(true);\r\n    ItemProcessor<String, String> itemProcessor = item -> {\r\n        System.out.println(\"processing item \" + item);\r\n        if (item.equals(\"b\")) {\r\n            throw new Exception(\"b was found\");\r\n        } else {\r\n            return item;\r\n        }\r\n    };\r\n    ItemReader<String> itemReader = new ItemReader<String>() {\r\n        int count = 0;\r\n        List<String> items = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\");\r\n        @Override\r\n        public String read() throws Exception {\r\n            System.out.println(\">> count == \" + count);\r\n            if (count == 6) {\r\n                count++;\r\n                throw new IOException(\"6th item\");\r\n            } else if (count == 7) {\r\n                count++;\r\n                throw new RuntimeException(\"7th item\");\r\n            } else if (count < items.size()) {\r\n                String item = items.get(count++);\r\n                System.out.println(\">> item read was \" + item);\r\n                return item;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n    };\r\n    TaskletStep taskletStep = new RemoteChunkingMasterStepBuilder<String, String>(\"step\").reader(itemReader).readerIsTransactionalQueue().processor(itemProcessor).repository(this.jobRepository).transactionManager(this.transactionManager).transactionAttribute(transactionAttribute).inputChannel(this.inputChannel).outputChannel(this.outputChannel).listener(annotatedListener).listener(skipListener).listener(chunkListener).listener(stepExecutionListener).listener(itemReadListener).listener(itemWriteListener).listener(retryListener).skip(Exception.class).noSkip(RuntimeException.class).skipLimit(10).retry(IOException.class).noRetry(RuntimeException.class).retryLimit(10).retryContextCache(retryCache).noRollback(Exception.class).startLimit(3).allowStartIfComplete(true).stepOperations(stepOperations).chunk(3).backOffPolicy(backOffPolicy).stream(stream).keyGenerator(Object::hashCode).build();\r\n    JobExecution jobExecution = this.jobRepository.createJobExecution(\"job1\", new JobParameters());\r\n    StepExecution stepExecution = new StepExecution(\"step1\", jobExecution);\r\n    this.jobRepository.add(stepExecution);\r\n    taskletStep.execute(stepExecution);\r\n    Assert.assertNotNull(taskletStep);\r\n    ChunkOrientedTasklet tasklet = (ChunkOrientedTasklet) ReflectionTestUtils.getField(taskletStep, \"tasklet\");\r\n    SimpleChunkProvider provider = (SimpleChunkProvider) ReflectionTestUtils.getField(tasklet, \"chunkProvider\");\r\n    SimpleChunkProcessor processor = (SimpleChunkProcessor) ReflectionTestUtils.getField(tasklet, \"chunkProcessor\");\r\n    ItemWriter itemWriter = (ItemWriter) ReflectionTestUtils.getField(processor, \"itemWriter\");\r\n    MessagingTemplate messagingTemplate = (MessagingTemplate) ReflectionTestUtils.getField(itemWriter, \"messagingGateway\");\r\n    CompositeItemStream compositeItemStream = (CompositeItemStream) ReflectionTestUtils.getField(taskletStep, \"stream\");\r\n    Assert.assertEquals(ReflectionTestUtils.getField(provider, \"itemReader\"), itemReader);\r\n    Assert.assertFalse((Boolean) ReflectionTestUtils.getField(tasklet, \"buffering\"));\r\n    Assert.assertEquals(ReflectionTestUtils.getField(taskletStep, \"jobRepository\"), this.jobRepository);\r\n    Assert.assertEquals(ReflectionTestUtils.getField(taskletStep, \"transactionManager\"), this.transactionManager);\r\n    Assert.assertEquals(ReflectionTestUtils.getField(taskletStep, \"transactionAttribute\"), transactionAttribute);\r\n    Assert.assertEquals(ReflectionTestUtils.getField(itemWriter, \"replyChannel\"), this.inputChannel);\r\n    Assert.assertEquals(ReflectionTestUtils.getField(messagingTemplate, \"defaultDestination\"), this.outputChannel);\r\n    Assert.assertEquals(ReflectionTestUtils.getField(processor, \"itemProcessor\"), itemProcessor);\r\n    Assert.assertEquals((int) ReflectionTestUtils.getField(taskletStep, \"startLimit\"), 3);\r\n    Assert.assertTrue((Boolean) ReflectionTestUtils.getField(taskletStep, \"allowStartIfComplete\"));\r\n    Object stepOperationsUsed = ReflectionTestUtils.getField(taskletStep, \"stepOperations\");\r\n    Assert.assertEquals(stepOperationsUsed, stepOperations);\r\n    Assert.assertEquals(((List) ReflectionTestUtils.getField(compositeItemStream, \"streams\")).size(), 2);\r\n    Assert.assertNotNull(ReflectionTestUtils.getField(processor, \"keyGenerator\"));\r\n    verify(skipListener, atLeastOnce()).onSkipInProcess(any(), any());\r\n    verify(retryListener, atLeastOnce()).open(any(), any());\r\n    verify(stepExecutionListener, atLeastOnce()).beforeStep(any());\r\n    verify(chunkListener, atLeastOnce()).beforeChunk(any());\r\n    verify(itemReadListener, atLeastOnce()).beforeRead();\r\n    verify(itemWriteListener, atLeastOnce()).beforeWrite(any());\r\n    Assert.assertEquals(stepExecution.getSkipCount(), 2);\r\n    Assert.assertEquals(stepExecution.getRollbackCount(), 3);\r\n}"
}, {
	"Path": "org.springframework.batch.integration.chunk.RemoteChunkingMasterStepBuilderTest.testSetters",
	"Comment": "the following test is to cover setters that override those from parent builders.",
	"Method": "void testSetters(){\r\n    System.out.println(\">> count == \" + count);\r\n    if (count == 6) {\r\n        count++;\r\n        throw new IOException(\"6th item\");\r\n    } else if (count == 7) {\r\n        count++;\r\n        throw new RuntimeException(\"7th item\");\r\n    } else if (count < items.size()) {\r\n        String item = items.get(count++);\r\n        System.out.println(\">> item read was \" + item);\r\n        return item;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.AbstractJsonMarshalTester.parseObject",
	"Comment": "return the object created from parsing the specific json string.",
	"Method": "T parseObject(byte[] jsonBytes,T parseObject,String jsonString){\r\n    verify();\r\n    return parse(jsonString).getObject();\r\n}"
}, {
	"Path": "org.springframework.batch.item.util.FileUtilsTests.testCreateDirectoryStructureAppendMode",
	"Comment": "if the directories on the file path do not exist, they should be created\tthis must be true also in append mode",
	"Method": "void testCreateDirectoryStructureAppendMode(){\r\n    File file = new File(\"testDirectory/testDirectory2/testFile.tmp\");\r\n    File dir1 = new File(\"testDirectory\");\r\n    File dir2 = new File(\"testDirectory/testDirectory2\");\r\n    try {\r\n        FileUtils.setUpOutputFile(file, false, true, false);\r\n        assertTrue(file.exists());\r\n        assertTrue(dir1.exists());\r\n        assertTrue(dir2.exists());\r\n    } finally {\r\n        file.delete();\r\n        dir2.delete();\r\n        dir1.delete();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.builder.SpringApplicationBuilder.parent",
	"Comment": "add an already running parent context to an existing application.",
	"Method": "SpringApplicationBuilder parent(Class<?> sources,SpringApplicationBuilder parent,ConfigurableApplicationContext parent){\r\n    this.parent = new SpringApplicationBuilder();\r\n    this.parent.context = parent;\r\n    this.parent.running.set(true);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.jta.atomikos.AtomikosProperties.setLogBaseDir",
	"Comment": "specifies the directory in which the log files should be stored. defaults to the\tcurrent working directory. this directory should be a stable storage like a san,\traid or at least backed up location. the transactions logs files are as important\tas the data themselves to guarantee consistency in case of failures.",
	"Method": "void setLogBaseDir(String logBaseDir){\r\n    this.logBaseDir = logBaseDir;\r\n}"
}, {
	"Path": "org.springframework.boot.web.embedded.jetty.JettyServletWebServerFactory.getMimeTypeConfiguration",
	"Comment": "create a configuration object that adds mime type mappings.",
	"Method": "Configuration getMimeTypeConfiguration(){\r\n    return new AbstractConfiguration() {\r\n        @Override\r\n        public void configure(WebAppContext context) throws Exception {\r\n            MimeTypes mimeTypes = context.getMimeTypes();\r\n            for (MimeMappings.Mapping mapping : getMimeMappings()) {\r\n                mimeTypes.addMimeMapping(mapping.getExtension(), mapping.getMimeType());\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.springframework.boot.web.embedded.jetty.JettyServletWebServerFactory.getMimeTypeConfiguration",
	"Comment": "create a configuration object that adds mime type mappings.",
	"Method": "Configuration getMimeTypeConfiguration(){\r\n    MimeTypes mimeTypes = context.getMimeTypes();\r\n    for (MimeMappings.Mapping mapping : getMimeMappings()) {\r\n        mimeTypes.addMimeMapping(mapping.getExtension(), mapping.getMimeType());\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport.recordEvaluationCandidates",
	"Comment": "records the names of the classes that are candidates for condition evaluation.",
	"Method": "void recordEvaluationCandidates(List<String> evaluationCandidates){\r\n    Assert.notNull(evaluationCandidates, \"evaluationCandidates must not be null\");\r\n    this.unconditionalClasses.addAll(evaluationCandidates);\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.isEndpointExposed",
	"Comment": "determine if an endpoint bean should be exposed. subclasses can override this\tmethod to provide additional logic.",
	"Method": "boolean isEndpointExposed(EndpointBean endpointBean,boolean isEndpointExposed,Object endpointBean){\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BeanPropertyName.toDashedForm",
	"Comment": "return the specified java bean property name in dashed form.",
	"Method": "String toDashedForm(String name,String toDashedForm,String name,int start){\r\n    StringBuilder result = new StringBuilder();\r\n    char[] chars = name.replace(\"_\", \"-\").toCharArray();\r\n    for (int i = start; i < chars.length; i++) {\r\n        char ch = chars[i];\r\n        if (Character.isUpperCase(ch) && result.length() > 0 && result.charAt(result.length() - 1) != '-') {\r\n            result.append(\"-\");\r\n        }\r\n        result.append(Character.toLowerCase(ch));\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemWriterTests.testOpenAndClose",
	"Comment": "open method writes the root tag, close method adds corresponding end tag.",
	"Method": "void testOpenAndClose(){\r\n    writer.setHeaderCallback(new StaxWriterCallback() {\r\n        @Override\r\n        public void write(XMLEventWriter writer) throws IOException {\r\n            XMLEventFactory factory = XMLEventFactory.newInstance();\r\n            try {\r\n                writer.add(factory.createStartElement(\"\", \"\", \"header\"));\r\n                writer.add(factory.createEndElement(\"\", \"\", \"header\"));\r\n            } catch (XMLStreamException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    });\r\n    writer.setFooterCallback(new StaxWriterCallback() {\r\n        @Override\r\n        public void write(XMLEventWriter writer) throws IOException {\r\n            XMLEventFactory factory = XMLEventFactory.newInstance();\r\n            try {\r\n                writer.add(factory.createStartElement(\"\", \"\", \"footer\"));\r\n                writer.add(factory.createEndElement(\"\", \"\", \"footer\"));\r\n            } catch (XMLStreamException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    });\r\n    writer.setRootTagName(\"testroot\");\r\n    writer.setRootElementAttributes(Collections.<String, String>singletonMap(\"attribute\", \"value\"));\r\n    writer.open(executionContext);\r\n    writer.close();\r\n    String content = getOutputFileContent();\r\n    assertTrue(content.contains(\"<testroot attribute=\\\"value\\\">\"));\r\n    assertTrue(content.contains(\"<header/>\"));\r\n    assertTrue(content.contains(\"<footer/>\"));\r\n    assertTrue(content.endsWith(\"<\/testroot>\"));\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemWriterTests.testOpenAndClose",
	"Comment": "open method writes the root tag, close method adds corresponding end tag.",
	"Method": "void testOpenAndClose(){\r\n    XMLEventFactory factory = XMLEventFactory.newInstance();\r\n    try {\r\n        writer.add(factory.createStartElement(\"\", \"\", \"header\"));\r\n        writer.add(factory.createEndElement(\"\", \"\", \"header\"));\r\n    } catch (XMLStreamException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemWriterTests.testOpenAndClose",
	"Comment": "open method writes the root tag, close method adds corresponding end tag.",
	"Method": "void testOpenAndClose(){\r\n    XMLEventFactory factory = XMLEventFactory.newInstance();\r\n    try {\r\n        writer.add(factory.createStartElement(\"\", \"\", \"footer\"));\r\n        writer.add(factory.createEndElement(\"\", \"\", \"footer\"));\r\n    } catch (XMLStreamException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemReaderTests.testExecutionContext",
	"Comment": "statistics return the current record count. calling read after end of input does not increase the counter.",
	"Method": "void testExecutionContext(){\r\n    final int NUMBER_OF_RECORDS = 2;\r\n    source.open(executionContext);\r\n    source.update(executionContext);\r\n    for (int i = 0; i < NUMBER_OF_RECORDS; i++) {\r\n        int recordCount = extractRecordCount();\r\n        assertEquals(i, recordCount);\r\n        source.read();\r\n        source.update(executionContext);\r\n    }\r\n    assertEquals(NUMBER_OF_RECORDS, extractRecordCount());\r\n    source.read();\r\n    assertEquals(NUMBER_OF_RECORDS, extractRecordCount());\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.server.AbstractServletWebServerFactory.isRegisterDefaultServlet",
	"Comment": "flag to indicate that the default servlet should be registered.",
	"Method": "boolean isRegisterDefaultServlet(){\r\n    return this.registerDefaultServlet;\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.builder.StaxEventItemWriterBuilder.transactional",
	"Comment": "the resulting writer is participating in a transaction and writes should be delayed\tas late as possible.",
	"Method": "StaxEventItemWriterBuilder<T> transactional(boolean transactional){\r\n    this.transactional = transactional;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.restart.Restarter.clearInstance",
	"Comment": "clear the instance. primarily provided for tests and not usually used in\tapplication code.",
	"Method": "void clearInstance(){\r\n    synchronized (INSTANCE_MONITOR) {\r\n        instance = null;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport.getExclusions",
	"Comment": "returns the names of the classes that have been excluded from condition evaluation.",
	"Method": "List<String> getExclusions(){\r\n    return Collections.unmodifiableList(this.exclusions);\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.autoconfigure.metrics.MeterValue.getValue",
	"Comment": "return the underlying value of the sla in form suitable to apply to the given meter\ttype.",
	"Method": "Long getValue(Type meterType){\r\n    if (meterType == Type.DISTRIBUTION_SUMMARY) {\r\n        return getDistributionSummaryValue();\r\n    }\r\n    if (meterType == Type.TIMER) {\r\n        return getTimerValue();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.tunnel.server.HttpTunnelServer.getServerThread",
	"Comment": "returns the active server thread, creating and starting it if necessary.",
	"Method": "ServerThread getServerThread(){\r\n    synchronized (this) {\r\n        if (this.serverThread == null) {\r\n            ByteChannel channel = this.serverConnection.open(this.longPollTimeout);\r\n            this.serverThread = new ServerThread(channel);\r\n            this.serverThread.start();\r\n        }\r\n        return this.serverThread;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.JdbcCursorItemReaderBuilder.build",
	"Comment": "validates configuration and builds a new reader instance.",
	"Method": "JdbcCursorItemReader<T> build(){\r\n    if (this.saveState) {\r\n        Assert.hasText(this.name, \"A name is required when saveSate is set to true\");\r\n    }\r\n    Assert.hasText(this.sql, \"A query is required\");\r\n    Assert.notNull(this.dataSource, \"A datasource is required\");\r\n    Assert.notNull(this.rowMapper, \"A rowmapper is required\");\r\n    JdbcCursorItemReader<T> reader = new JdbcCursorItemReader();\r\n    if (StringUtils.hasText(this.name)) {\r\n        reader.setName(this.name);\r\n    }\r\n    reader.setSaveState(this.saveState);\r\n    reader.setPreparedStatementSetter(this.preparedStatementSetter);\r\n    reader.setRowMapper(this.rowMapper);\r\n    reader.setSql(this.sql);\r\n    reader.setCurrentItemCount(this.currentItemCount);\r\n    reader.setDataSource(this.dataSource);\r\n    reader.setDriverSupportsAbsolute(this.driverSupportsAbsolute);\r\n    reader.setFetchSize(this.fetchSize);\r\n    reader.setIgnoreWarnings(this.ignoreWarnings);\r\n    reader.setMaxItemCount(this.maxItemCount);\r\n    reader.setMaxRows(this.maxRows);\r\n    reader.setQueryTimeout(this.queryTimeout);\r\n    reader.setUseSharedExtendedConnection(this.useSharedExtendedConnection);\r\n    reader.setVerifyCursorPosition(this.verifyCursorPosition);\r\n    return reader;\r\n}"
}, {
	"Path": "org.springframework.batch.test.common.LogAdvice.doBasicLogging",
	"Comment": "wraps original method and adds logging both before and after method",
	"Method": "void doBasicLogging(JoinPoint pjp){\r\n    Object[] args = pjp.getArgs();\r\n    StringBuilder output = new StringBuilder();\r\n    output.append(pjp.getTarget().getClass().getName()).append(\": \");\r\n    output.append(pjp.toShortString()).append(\": \");\r\n    for (Object arg : args) {\r\n        output.append(arg).append(\" \");\r\n    }\r\n    log.info(\"Basic: \" + output.toString());\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.builder.StaxEventItemReaderBuilder.addFragmentRootElements",
	"Comment": "adds the list of fragments to be used as the root of each chunk to the\tconfiguration.",
	"Method": "StaxEventItemReaderBuilder<T> addFragmentRootElements(String fragmentRootElements,StaxEventItemReaderBuilder<T> addFragmentRootElements,List<String> fragmentRootElements){\r\n    this.fragmentRootElements.addAll(fragmentRootElements);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.diagnostics.AbstractFailureAnalyzer.getCauseType",
	"Comment": "return the cause type being handled by the analyzer. by default the class generic\tis used.",
	"Method": "Class<? extends T> getCauseType(){\r\n    return (Class<? extends T>) ResolvableType.forClass(AbstractFailureAnalyzer.class, getClass()).resolveGeneric();\r\n}"
}, {
	"Path": "org.springframework.batch.test.JobLauncherTestUtils.launchStep",
	"Comment": "launch just the specified step in the job. an illegalstateexception is\tthrown if there is no step with the given name.",
	"Method": "JobExecution launchStep(String stepName,JobExecution launchStep,String stepName,ExecutionContext jobExecutionContext,JobExecution launchStep,String stepName,JobParameters jobParameters,JobExecution launchStep,String stepName,JobParameters jobParameters,ExecutionContext jobExecutionContext){\r\n    if (!(job instanceof StepLocator)) {\r\n        throw new UnsupportedOperationException(\"Cannot locate step from a Job that is not a StepLocator: job=\" + job.getName() + \" does not implement StepLocator\");\r\n    }\r\n    StepLocator locator = (StepLocator) this.job;\r\n    Step step = locator.getStep(stepName);\r\n    if (step == null) {\r\n        step = locator.getStep(this.job.getName() + \".\" + stepName);\r\n    }\r\n    if (step == null) {\r\n        throw new IllegalStateException(\"No Step found with name: [\" + stepName + \"]\");\r\n    }\r\n    return getStepRunner().launchStep(step, jobParameters, jobExecutionContext);\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.web.mappings.servlet.RegistrationMappingDescription.getClassName",
	"Comment": "returns the class name of the registered filter or servlet.",
	"Method": "String getClassName(){\r\n    return this.registration.getClassName();\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemWriterTests.testDeleteIfEmptyNoRecordsWrittenHeaderAndFooter",
	"Comment": "resource is deleted when items have not been written and shoulddeleteifempty flag is set.",
	"Method": "void testDeleteIfEmptyNoRecordsWrittenHeaderAndFooter(){\r\n    writer.setShouldDeleteIfEmpty(true);\r\n    writer.setHeaderCallback(new StaxWriterCallback() {\r\n        @Override\r\n        public void write(XMLEventWriter writer) throws IOException {\r\n            XMLEventFactory factory = XMLEventFactory.newInstance();\r\n            try {\r\n                writer.add(factory.createStartElement(\"\", \"\", \"header\"));\r\n                writer.add(factory.createEndElement(\"\", \"\", \"header\"));\r\n            } catch (XMLStreamException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    });\r\n    writer.setFooterCallback(new StaxWriterCallback() {\r\n        @Override\r\n        public void write(XMLEventWriter writer) throws IOException {\r\n            XMLEventFactory factory = XMLEventFactory.newInstance();\r\n            try {\r\n                writer.add(factory.createStartElement(\"\", \"\", \"footer\"));\r\n                writer.add(factory.createEndElement(\"\", \"\", \"footer\"));\r\n            } catch (XMLStreamException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    });\r\n    writer.open(executionContext);\r\n    writer.close();\r\n    assertFalse(\"file should be deleted\" + resource, resource.getFile().exists());\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemWriterTests.testDeleteIfEmptyNoRecordsWrittenHeaderAndFooter",
	"Comment": "resource is deleted when items have not been written and shoulddeleteifempty flag is set.",
	"Method": "void testDeleteIfEmptyNoRecordsWrittenHeaderAndFooter(){\r\n    XMLEventFactory factory = XMLEventFactory.newInstance();\r\n    try {\r\n        writer.add(factory.createStartElement(\"\", \"\", \"header\"));\r\n        writer.add(factory.createEndElement(\"\", \"\", \"header\"));\r\n    } catch (XMLStreamException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemWriterTests.testDeleteIfEmptyNoRecordsWrittenHeaderAndFooter",
	"Comment": "resource is deleted when items have not been written and shoulddeleteifempty flag is set.",
	"Method": "void testDeleteIfEmptyNoRecordsWrittenHeaderAndFooter(){\r\n    XMLEventFactory factory = XMLEventFactory.newInstance();\r\n    try {\r\n        writer.add(factory.createStartElement(\"\", \"\", \"footer\"));\r\n        writer.add(factory.createEndElement(\"\", \"\", \"footer\"));\r\n    } catch (XMLStreamException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.ConfigurationPropertiesTests.removeSystemProperties",
	"Comment": "strict tests need a known set of properties so we remove system items which may be\tenvironment specific.",
	"Method": "void removeSystemProperties(){\r\n    MutablePropertySources sources = this.context.getEnvironment().getPropertySources();\r\n    sources.remove(\"systemProperties\");\r\n    sources.remove(\"systemEnvironment\");\r\n}"
}, {
	"Path": "org.springframework.batch.core.step.tasklet.TaskletStepTests.testStepExecutionUpdateFailure",
	"Comment": "failure to update stepexecution after chunk commit is fatal.",
	"Method": "void testStepExecutionUpdateFailure(){\r\n    JobExecution jobExecution = new JobExecution(jobInstance, jobParameters);\r\n    StepExecution stepExecution = new StepExecution(step.getName(), jobExecution);\r\n    JobRepository repository = new JobRepositoryFailedUpdateStub();\r\n    step.setJobRepository(repository);\r\n    step.afterPropertiesSet();\r\n    step.execute(stepExecution);\r\n    assertEquals(BatchStatus.UNKNOWN, stepExecution.getStatus());\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.JdbcPagingItemReaderBuilder.currentItemCount",
	"Comment": "index for the current item. used on restarts to indicate where to start from.",
	"Method": "JdbcPagingItemReaderBuilder<T> currentItemCount(int currentItemCount){\r\n    this.currentItemCount = currentItemCount;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.support.MethodInvokerUtils.getParamTypesString",
	"Comment": "create a string representation of the array of parameter types.",
	"Method": "String getParamTypesString(Class<?> paramTypes){\r\n    StringBuilder paramTypesList = new StringBuilder(\"(\");\r\n    for (int i = 0; i < paramTypes.length; i++) {\r\n        paramTypesList.append(paramTypes[i].getSimpleName());\r\n        if (i + 1 < paramTypes.length) {\r\n            paramTypesList.append(\", \");\r\n        }\r\n    }\r\n    return paramTypesList.append(\")\").toString();\r\n}"
}, {
	"Path": "org.springframework.batch.item.ldif.builder.MappingLdifReaderBuilder.resource",
	"Comment": "establishes the resource that will be used as the input for the mappingldifreader.",
	"Method": "MappingLdifReaderBuilder<T> resource(Resource resource){\r\n    this.resource = resource;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.Bindable.getAnnotation",
	"Comment": "return a single associated annotations that could affect binding.",
	"Method": "A getAnnotation(Class<A> type){\r\n    for (Annotation annotation : this.annotations) {\r\n        if (type.isInstance(annotation)) {\r\n            return (A) annotation;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.validation.ValidationErrors.getBoundProperties",
	"Comment": "return the properties that were bound before validation failed.",
	"Method": "Set<ConfigurationProperty> getBoundProperties(){\r\n    return this.boundProperties;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.AbstractNeo4jItemReader.setMatchStatement",
	"Comment": "an optional match fragment of the cypher query.match is\tprepended to the statement provided and should not\tbe included.",
	"Method": "void setMatchStatement(String matchStatement){\r\n    this.matchStatement = matchStatement;\r\n}"
}, {
	"Path": "org.springframework.batch.core.step.StepSupport.setName",
	"Comment": "set the name property. always overrides the default value if this object is a spring bean.",
	"Method": "void setName(String name){\r\n    this.name = name;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.audit.AuditEvent.getPrincipal",
	"Comment": "returns the user principal responsible for the event or an empty string if the\tprincipal is not available.",
	"Method": "String getPrincipal(){\r\n    return this.principal;\r\n}"
}, {
	"Path": "org.springframework.batch.integration.chunk.RemoteChunkHandlerFactoryBean.replaceChunkProcessor",
	"Comment": "replace the chunk processor in the tasklet provided with one that can act as a master in the remote chunking\tpattern.",
	"Method": "void replaceChunkProcessor(ChunkOrientedTasklet<?> tasklet,ItemWriter<T> chunkWriter,StepContributionSource stepContributionSource){\r\n    setField(tasklet, \"chunkProcessor\", new SimpleChunkProcessor<T, T>(new PassThroughItemProcessor(), chunkWriter) {\r\n        @Override\r\n        protected void write(StepContribution contribution, Chunk<T> inputs, Chunk<T> outputs) throws Exception {\r\n            doWrite(outputs.getItems());\r\n            updateStepContribution(contribution, stepContributionSource);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.springframework.batch.integration.chunk.RemoteChunkHandlerFactoryBean.replaceChunkProcessor",
	"Comment": "replace the chunk processor in the tasklet provided with one that can act as a master in the remote chunking\tpattern.",
	"Method": "void replaceChunkProcessor(ChunkOrientedTasklet<?> tasklet,ItemWriter<T> chunkWriter,StepContributionSource stepContributionSource){\r\n    doWrite(outputs.getItems());\r\n    updateStepContribution(contribution, stepContributionSource);\r\n}"
}, {
	"Path": "org.springframework.batch.item.adapter.AbstractMethodInvokingDelegator.doInvoke",
	"Comment": "prepare and invoke the invoker, rethrow checked exceptions as unchecked.",
	"Method": "T doInvoke(MethodInvoker invoker){\r\n    try {\r\n        invoker.prepare();\r\n    } catch (ClassNotFoundException | NoSuchMethodException e) {\r\n        throw new DynamicMethodInvocationException(e);\r\n    }\r\n    try {\r\n        return (T) invoker.invoke();\r\n    } catch (InvocationTargetException e) {\r\n        if (e.getCause() instanceof Exception) {\r\n            throw (Exception) e.getCause();\r\n        } else {\r\n            throw new InvocationTargetThrowableWrapper(e.getCause());\r\n        }\r\n    } catch (IllegalAccessException e) {\r\n        throw new DynamicMethodInvocationException(e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.RepeatSynchronizationManager.setCompleteOnly",
	"Comment": "convenience method to set the current repeat operation to complete if it\texists.",
	"Method": "void setCompleteOnly(){\r\n    RepeatContext context = getContext();\r\n    if (context != null) {\r\n        context.setCompleteOnly();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.server.AbstractServletWebServerFactory.getDocumentRoot",
	"Comment": "returns the document root which will be used by the web context to serve static\tfiles.",
	"Method": "File getDocumentRoot(){\r\n    return this.documentRoot.getDirectory();\r\n}"
}, {
	"Path": "org.springframework.batch.item.json.GsonJsonObjectReader.setMapper",
	"Comment": "set the object mapper to use to map json objects to domain objects.",
	"Method": "void setMapper(Gson mapper){\r\n    Assert.notNull(mapper, \"The mapper must not be null\");\r\n    this.mapper = mapper;\r\n}"
}, {
	"Path": "org.springframework.batch.test.jmx.JobExecutionNotificationPublisher.publish",
	"Comment": "publish the provided message to an external listener if there is one.",
	"Method": "void publish(String message){\r\n    if (notificationPublisher != null) {\r\n        Notification notification = new Notification(\"JobExecutionApplicationEvent\", this, notificationCount++, message);\r\n        notification.setSource(null);\r\n        notificationPublisher.sendNotification(notification);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.AbstractCursorItemReader.setFetchSize",
	"Comment": "gives the jdbc driver a hint as to the number of rows that should be\tfetched from the database when more rows are needed for this\tresultset object. if the fetch size specified is zero, the\tjdbc driver ignores the value.",
	"Method": "void setFetchSize(int fetchSize){\r\n    this.fetchSize = fetchSize;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.MongoItemReader.replacePlaceholders",
	"Comment": "copied from stringbasedmongoquery...is there a place where this type of logic is already exposed?",
	"Method": "String replacePlaceholders(String input,List<Object> values){\r\n    Matcher matcher = PLACEHOLDER.matcher(input);\r\n    String result = input;\r\n    while (matcher.find()) {\r\n        String group = matcher.group();\r\n        int index = Integer.parseInt(matcher.group(1));\r\n        result = result.replace(group, getParameterWithIndex(values, index));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.builder.FlatFileItemReaderBuilder.linesToSkip",
	"Comment": "the number of lines to skip at the beginning of reading the file.",
	"Method": "FlatFileItemReaderBuilder<T> linesToSkip(int linesToSkip){\r\n    this.linesToSkip = linesToSkip;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.builder.MongoItemReaderBuilder.currentItemCount",
	"Comment": "index for the current item. used on restarts to indicate where to start from.",
	"Method": "MongoItemReaderBuilder<T> currentItemCount(int currentItemCount){\r\n    this.currentItemCount = currentItemCount;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.validator.SpringValidatorTests.testValidateUnsupportedType",
	"Comment": "validator does not know how to validate object of the given class",
	"Method": "void testValidateUnsupportedType(){\r\n    validator.validate(Integer.valueOf(1));\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.source.ConfigurationPropertySource.withAliases",
	"Comment": "return a variant of this source that supports name aliases.",
	"Method": "ConfigurationPropertySource withAliases(ConfigurationPropertyNameAliases aliases){\r\n    return new AliasedConfigurationPropertySource(this, aliases);\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.transform.IncorrectLineLengthException.getExpectedLength",
	"Comment": "retrieves the expected length that was recorded for this exception.",
	"Method": "int getExpectedLength(){\r\n    return expectedLength;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.jdbc.DataSourceHealthIndicator.setQuery",
	"Comment": "set a specific validation query to use to validate a connection. if none is set, a\tdefault validation query is used.",
	"Method": "void setQuery(String query){\r\n    this.query = query;\r\n}"
}, {
	"Path": "org.springframework.batch.support.PropertiesConverterTests.testTwoWayRegularConversion",
	"Comment": "check that properties can be converted to string and back correctly.",
	"Method": "void testTwoWayRegularConversion(){\r\n    Properties storedProps = new Properties();\r\n    storedProps.setProperty(\"key1\", \"value1\");\r\n    storedProps.setProperty(\"key2\", \"value2\");\r\n    props = PropertiesConverter.stringToProperties(PropertiesConverter.propertiesToString(storedProps));\r\n    assertEquals(storedProps, props);\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BindException.getProperty",
	"Comment": "return the configuration property name of the item that was being bound.",
	"Method": "ConfigurationProperty getProperty(){\r\n    return this.property;\r\n}"
}, {
	"Path": "org.springframework.batch.integration.chunk.RemoteChunkingMasterStepBuilder.throttleLimit",
	"Comment": "public setter for the throttle limit. this limits the number of pending requests for chunk processing to avoid\toverwhelming the receivers.",
	"Method": "RemoteChunkingMasterStepBuilder<I, O> throttleLimit(long throttleLimit){\r\n    Assert.isTrue(throttleLimit > 0, \"throttleLimit must be greater than zero\");\r\n    this.throttleLimit = throttleLimit;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.MongoItemReader.getParameterWithIndex",
	"Comment": "copied from stringbasedmongoquery...is there a place where this type of logic is already exposed?",
	"Method": "String getParameterWithIndex(List<Object> values,int index){\r\n    return JSON.serialize(values.get(index));\r\n}"
}, {
	"Path": "org.springframework.boot.BeanDefinitionLoader.setResourceLoader",
	"Comment": "set the resource loader to be used by the underlying readers and scanner.",
	"Method": "void setResourceLoader(ResourceLoader resourceLoader){\r\n    this.resourceLoader = resourceLoader;\r\n    this.xmlReader.setResourceLoader(resourceLoader);\r\n    this.scanner.setResourceLoader(resourceLoader);\r\n}"
}, {
	"Path": "org.springframework.boot.task.TaskExecutorBuilder.allowCoreThreadTimeOut",
	"Comment": "set whether core threads are allow to time out. when enabled, this enables dynamic\tgrowing and shrinking of the pool.",
	"Method": "TaskExecutorBuilder allowCoreThreadTimeOut(boolean allowCoreThreadTimeOut){\r\n    return new TaskExecutorBuilder(this.queueCapacity, this.corePoolSize, this.maxPoolSize, allowCoreThreadTimeOut, this.keepAlive, this.threadNamePrefix, this.taskDecorator, this.customizers);\r\n}"
}, {
	"Path": "org.springframework.boot.util.LambdaSafe.callback",
	"Comment": "start a call to a single callback instance, dealing with common generic type\tconcerns and exceptions.",
	"Method": "Callback<C, A> callback(Class<C> callbackType,C callbackInstance,A argument,Object additionalArguments){\r\n    Assert.notNull(callbackType, \"CallbackType must not be null\");\r\n    Assert.notNull(callbackInstance, \"CallbackInstance must not be null\");\r\n    return new Callback(callbackType, callbackInstance, argument, additionalArguments);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.amqp.RabbitProperties.determinePort",
	"Comment": "returns the port from the first address, or the configured port if no addresses\thave been set.",
	"Method": "int determinePort(){\r\n    if (CollectionUtils.isEmpty(this.parsedAddresses)) {\r\n        return getPort();\r\n    }\r\n    Address address = this.parsedAddresses.get(0);\r\n    return address.port;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.MultiResourceItemWriter.setResourceSuffixCreator",
	"Comment": "allows customization of the suffix of the created resources based on the\tindex.",
	"Method": "void setResourceSuffixCreator(ResourceSuffixCreator suffixCreator){\r\n    this.suffixCreator = suffixCreator;\r\n}"
}, {
	"Path": "org.springframework.boot.builder.SpringApplicationBuilder.child",
	"Comment": "create a child application with the provided sources. default args and environment\tare copied down into the child, but everything else is a clean sheet.",
	"Method": "SpringApplicationBuilder child(Class<?> sources){\r\n    SpringApplicationBuilder child = new SpringApplicationBuilder();\r\n    child.sources(sources);\r\n    child.properties(this.defaultProperties).environment(this.environment).additionalProfiles(this.additionalProfiles);\r\n    child.parent = this;\r\n    web(WebApplicationType.NONE);\r\n    bannerMode(Banner.Mode.OFF);\r\n    this.application.addPrimarySources(this.sources);\r\n    return child;\r\n}"
}, {
	"Path": "org.springframework.boot.task.TaskExecutorBuilder.keepAlive",
	"Comment": "set the time limit for which threads may remain idle before being terminated.",
	"Method": "TaskExecutorBuilder keepAlive(Duration keepAlive){\r\n    return new TaskExecutorBuilder(this.queueCapacity, this.corePoolSize, this.maxPoolSize, this.allowCoreThreadTimeOut, keepAlive, this.threadNamePrefix, this.taskDecorator, this.customizers);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.jdbc.DataSourceProperties.determineDriverClassName",
	"Comment": "determine the driver to use based on this configuration and the environment.",
	"Method": "String determineDriverClassName(){\r\n    if (StringUtils.hasText(this.driverClassName)) {\r\n        Assert.state(driverClassIsLoadable(), () -> \"Cannot load driver class: \" + this.driverClassName);\r\n        return this.driverClassName;\r\n    }\r\n    String driverClassName = null;\r\n    if (StringUtils.hasText(this.url)) {\r\n        driverClassName = DatabaseDriver.fromJdbcUrl(this.url).getDriverClassName();\r\n    }\r\n    if (!StringUtils.hasText(driverClassName)) {\r\n        driverClassName = this.embeddedDatabaseConnection.getDriverClassName();\r\n    }\r\n    if (!StringUtils.hasText(driverClassName)) {\r\n        throw new DataSourceBeanCreationException(\"Failed to determine a suitable driver class\", this, this.embeddedDatabaseConnection);\r\n    }\r\n    return driverClassName;\r\n}"
}, {
	"Path": "org.springframework.batch.item.json.JacksonJsonObjectReader.setMapper",
	"Comment": "set the object mapper to use to map json objects to domain objects.",
	"Method": "void setMapper(ObjectMapper mapper){\r\n    Assert.notNull(mapper, \"The mapper must not be null\");\r\n    this.mapper = mapper;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.exception.SimpleLimitExceptionHandler.handleException",
	"Comment": "rethrows only if the limit is breached for this context on the exception\ttype specified.",
	"Method": "void handleException(RepeatContext context,Throwable throwable){\r\n    delegate.handleException(context, throwable);\r\n}"
}, {
	"Path": "org.springframework.boot.context.config.ConfigFileApplicationListener.addPropertySources",
	"Comment": "add config file property sources to the specified environment.",
	"Method": "void addPropertySources(ConfigurableEnvironment environment,ResourceLoader resourceLoader){\r\n    RandomValuePropertySource.addToEnvironment(environment);\r\n    new Loader(environment, resourceLoader).load();\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.StoredProcedureItemReader.setProcedureName",
	"Comment": "set the sql statement to be used when creating the cursor. this statement\tshould be a complete and valid sql statement, as it will be run directly\twithout any modification.",
	"Method": "void setProcedureName(String sprocedureName){\r\n    this.procedureName = sprocedureName;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.SimpleRepeatTemplateTests.testEarlyCompletionWithPolicy",
	"Comment": "check that a dedicated terminationpolicy can terminate the batch.",
	"Method": "void testEarlyCompletionWithPolicy(){\r\n    template.setCompletionPolicy(new SimpleCompletionPolicy(2));\r\n    template.iterate(new ItemReaderRepeatCallback(provider, processor));\r\n    assertEquals(2, processor.count);\r\n}"
}, {
	"Path": "org.springframework.batch.sample.common.ColumnRangePartitioner.partition",
	"Comment": "partition a database table assuming that the data in the column specified\tare uniformly distributed. the execution context values will have keys\tminvalue and maxvalue specifying the range of\tvalues to consider in each partition.",
	"Method": "Map<String, ExecutionContext> partition(int gridSize){\r\n    int min = jdbcTemplate.queryForObject(\"SELECT MIN(\" + column + \") from \" + table, Integer.class);\r\n    int max = jdbcTemplate.queryForObject(\"SELECT MAX(\" + column + \") from \" + table, Integer.class);\r\n    int targetSize = (max - min) / gridSize + 1;\r\n    Map<String, ExecutionContext> result = new HashMap();\r\n    int number = 0;\r\n    int start = min;\r\n    int end = start + targetSize - 1;\r\n    while (start <= max) {\r\n        ExecutionContext value = new ExecutionContext();\r\n        result.put(\"partition\" + number, value);\r\n        if (end >= max) {\r\n            end = max;\r\n        }\r\n        value.putInt(\"minValue\", start);\r\n        value.putInt(\"maxValue\", end);\r\n        start += targetSize;\r\n        end += targetSize;\r\n        number++;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.http.HttpMessageConverters.getConverters",
	"Comment": "return an immutable list of the converters in the order that they will be\tregistered.",
	"Method": "List<HttpMessageConverter<?>> getConverters(){\r\n    return this.converters;\r\n}"
}, {
	"Path": "org.springframework.boot.BeanDefinitionLoader.setBeanNameGenerator",
	"Comment": "set the bean name generator to be used by the underlying readers and scanner.",
	"Method": "void setBeanNameGenerator(BeanNameGenerator beanNameGenerator){\r\n    this.annotatedReader.setBeanNameGenerator(beanNameGenerator);\r\n    this.xmlReader.setBeanNameGenerator(beanNameGenerator);\r\n    this.scanner.setBeanNameGenerator(beanNameGenerator);\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.exception.CompositeExceptionHandler.handleException",
	"Comment": "iterate over the handlers delegating the call to each in turn. the chain\tends if an exception is thrown.",
	"Method": "void handleException(RepeatContext context,Throwable throwable){\r\n    for (int i = 0; i < handlers.length; i++) {\r\n        ExceptionHandler handler = handlers[i];\r\n        handler.handleException(context, throwable);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.builder.FlatFileItemWriterBuilder.lineSeparator",
	"Comment": "string used to separate lines in output.defaults to the system property\tline.separator.",
	"Method": "FlatFileItemWriterBuilder<T> lineSeparator(String lineSeparator){\r\n    this.lineSeparator = lineSeparator;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.context.annotation.Configurations.sort",
	"Comment": "sort configuration classes into the order that they should be applied.",
	"Method": "Collection<Class<?>> sort(Collection<Class<?>> classes){\r\n    return classes;\r\n}"
}, {
	"Path": "org.springframework.batch.item.support.AbstractFileItemWriter.setHeaderCallback",
	"Comment": "headercallback will be called before writing the first item to file.\tnewline will be automatically appended after the header is written.",
	"Method": "void setHeaderCallback(FlatFileHeaderCallback headerCallback){\r\n    this.headerCallback = headerCallback;\r\n}"
}, {
	"Path": "org.springframework.boot.builder.SpringApplicationBuilder.addCommandLineProperties",
	"Comment": "flag to indicate that command line arguments should be added to the environment.",
	"Method": "SpringApplicationBuilder addCommandLineProperties(boolean addCommandLineProperties){\r\n    this.application.setAddCommandLineProperties(addCommandLineProperties);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.amqp.builder.AmqpItemReaderBuilder.amqpTemplate",
	"Comment": "establish the amqptemplate to be used by the amqpitemreader.",
	"Method": "AmqpItemReaderBuilder<T> amqpTemplate(AmqpTemplate amqpTemplate){\r\n    this.amqpTemplate = amqpTemplate;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.SpringApplication.logStartupInfo",
	"Comment": "called to log startup information, subclasses may override to add additional\tlogging.",
	"Method": "void logStartupInfo(boolean isRoot){\r\n    if (isRoot) {\r\n        new StartupInfoLogger(this.mainApplicationClass).logStarting(getApplicationLog());\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.condition.ResourceCondition.getResourceOutcome",
	"Comment": "check if one of the default resource locations actually exists.",
	"Method": "ConditionOutcome getResourceOutcome(ConditionContext context,AnnotatedTypeMetadata metadata){\r\n    List<String> found = new ArrayList();\r\n    for (String location : this.resourceLocations) {\r\n        Resource resource = context.getResourceLoader().getResource(location);\r\n        if (resource != null && resource.exists()) {\r\n            found.add(location);\r\n        }\r\n    }\r\n    if (found.isEmpty()) {\r\n        ConditionMessage message = startConditionMessage().didNotFind(\"resource\", \"resources\").items(Style.QUOTE, Arrays.asList(this.resourceLocations));\r\n        return ConditionOutcome.noMatch(message);\r\n    }\r\n    ConditionMessage message = startConditionMessage().found(\"resource\", \"resources\").items(Style.QUOTE, found);\r\n    return ConditionOutcome.match(message);\r\n}"
}, {
	"Path": "org.springframework.batch.integration.chunk.RemoteChunkingWorkerBuilder.inputChannel",
	"Comment": "set the input channel on which items sent by the master are received.",
	"Method": "RemoteChunkingWorkerBuilder<I, O> inputChannel(MessageChannel inputChannel){\r\n    Assert.notNull(inputChannel, \"inputChannel must not be null\");\r\n    this.inputChannel = inputChannel;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactoryTests.tomcatEngineNames",
	"Comment": "jmx mbean names clash if you get more than one engine with the same name...",
	"Method": "void tomcatEngineNames(){\r\n    TomcatServletWebServerFactory factory = getFactory();\r\n    this.webServer = factory.getWebServer();\r\n    factory.setPort(0);\r\n    TomcatWebServer tomcatWebServer = (TomcatWebServer) factory.getWebServer();\r\n    String firstName = ((TomcatWebServer) this.webServer).getTomcat().getEngine().getName();\r\n    String secondName = tomcatWebServer.getTomcat().getEngine().getName();\r\n    assertThat(firstName).as(\"Tomcat engines must have different names\").isNotEqualTo(secondName);\r\n    tomcatWebServer.stop();\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.AbstractNeo4jItemReader.setStartStatement",
	"Comment": "the start segment of the cypher query.start is prepended\tto the statement provided and should not be\tincluded.",
	"Method": "void setStartStatement(String startStatement){\r\n    this.startStatement = startStatement;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.separator.SuffixRecordSeparatorPolicy.setSuffix",
	"Comment": "lines ending in this terminator string signal the end of a record.",
	"Method": "void setSuffix(String suffix){\r\n    this.suffix = suffix;\r\n}"
}, {
	"Path": "org.springframework.boot.cli.command.init.ServiceCapabilitiesReportGenerator.generate",
	"Comment": "generate a report for the specified service. the report contains the available\tcapabilities as advertised by the root endpoint.",
	"Method": "String generate(String url){\r\n    Object content = this.initializrService.loadServiceCapabilities(url);\r\n    if (content instanceof InitializrServiceMetadata) {\r\n        return generateHelp(url, (InitializrServiceMetadata) content);\r\n    }\r\n    return content.toString();\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.AbstractCursorItemReader.setMaxRows",
	"Comment": "sets the limit for the maximum number of rows that any\tresultset object can contain to the given number.",
	"Method": "void setMaxRows(int maxRows){\r\n    this.maxRows = maxRows;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.SimpleRepeatTemplateTests.testEarlyCompletionWithContext",
	"Comment": "check that a the context can be used to signal early completion.",
	"Method": "void testEarlyCompletionWithContext(){\r\n    RepeatStatus result = template.iterate(new ItemReaderRepeatCallback<Trade>(provider, processor) {\r\n        @Override\r\n        public RepeatStatus doInIteration(RepeatContext context) throws Exception {\r\n            RepeatStatus result = super.doInIteration(context);\r\n            if (processor.count >= 2) {\r\n                context.setCompleteOnly();\r\n            }\r\n            return result;\r\n        }\r\n    });\r\n    assertEquals(2, processor.count);\r\n    assertTrue(result.isContinuable());\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.SimpleRepeatTemplateTests.testEarlyCompletionWithContext",
	"Comment": "check that a the context can be used to signal early completion.",
	"Method": "void testEarlyCompletionWithContext(){\r\n    RepeatStatus result = super.doInIteration(context);\r\n    if (processor.count >= 2) {\r\n        context.setCompleteOnly();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.boot.cli.command.init.ProjectGenerationRequest.getDependencies",
	"Comment": "the identifiers of the dependencies to include in the project.",
	"Method": "List<String> getDependencies(){\r\n    return this.dependencies;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.AbstractNeo4jItemReader.setOrderByStatement",
	"Comment": "a list of properties to order the results by.this is\trequired so that subsequent page requests pull back the\tsegment of results correctly.order by is prepended to\tthe statement provided and should not be included.",
	"Method": "void setOrderByStatement(String orderByStatement){\r\n    this.orderByStatement = orderByStatement;\r\n}"
}, {
	"Path": "org.springframework.batch.item.jms.builder.JmsItemReaderBuilder.jmsTemplate",
	"Comment": "establish the jms template that will be used by the jmsitemreader.",
	"Method": "JmsItemReaderBuilder<T> jmsTemplate(JmsOperations jmsTemplate){\r\n    this.jmsTemplate = jmsTemplate;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.support.transaction.TransactionAwareProxyFactory.begin",
	"Comment": "make a copy of the target that can be used inside a transaction to\tisolate changes from the original. also called from the factory\tconstructor to isolate the target from the original value passed in.",
	"Method": "T begin(T target){\r\n    synchronized (target) {\r\n        if (target instanceof List) {\r\n            if (appendOnly) {\r\n                return (T) new ArrayList();\r\n            }\r\n            return (T) new ArrayList((List) target);\r\n        } else if (target instanceof Set) {\r\n            if (appendOnly) {\r\n                return (T) new HashSet();\r\n            }\r\n            return (T) new HashSet((Set) target);\r\n        } else if (target instanceof Map) {\r\n            if (appendOnly) {\r\n                return (T) new HashMap();\r\n            }\r\n            return (T) new HashMap((Map) target);\r\n        } else {\r\n            throw new UnsupportedOperationException(\"Cannot copy target for this type: \" + target.getClass());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.classpath.ClassPathChangedEvent.isRestartRequired",
	"Comment": "return if an application restart is required due to the change.",
	"Method": "boolean isRestartRequired(){\r\n    return this.restartRequired;\r\n}"
}, {
	"Path": "org.springframework.batch.item.support.builder.CompositeItemWriterBuilder.ignoreItemStream",
	"Comment": "establishes the policy whether to call the open, close, or update methods for the\titem writer delegates associated with the compositeitemwriter.",
	"Method": "CompositeItemWriterBuilder<T> ignoreItemStream(boolean ignoreItemStream){\r\n    this.ignoreItemStream = ignoreItemStream;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.SimpleRepeatTemplateTests.testExceptionUnwrapping",
	"Comment": "checked exceptions are wrapped into runtime repeatexception.\trepeatexception should be unwrapped before before it is passed to\tlisteners and exception handler.",
	"Method": "void testExceptionUnwrapping(){\r\n    @SuppressWarnings(\"serial\")\r\n    class TestException extends Exception {\r\n        TestException(String msg) {\r\n            super(msg);\r\n        }\r\n    }\r\n    final TestException exception = new TestException(\"CRASH!\");\r\n    class ExceptionHandlerStub implements ExceptionHandler {\r\n        boolean called = false;\r\n        @Override\r\n        public void handleException(RepeatContext context, Throwable throwable) throws Throwable {\r\n            called = true;\r\n            assertSame(exception, throwable);\r\n            throw throwable;\r\n        }\r\n    }\r\n    ExceptionHandlerStub exHandler = new ExceptionHandlerStub();\r\n    class RepeatListenerStub extends RepeatListenerSupport {\r\n        boolean called = false;\r\n        @Override\r\n        public void onError(RepeatContext context, Throwable throwable) {\r\n            called = true;\r\n            assertSame(exception, throwable);\r\n        }\r\n    }\r\n    RepeatListenerStub listener = new RepeatListenerStub();\r\n    template.setExceptionHandler(exHandler);\r\n    template.setListeners(new RepeatListener[] { listener });\r\n    try {\r\n        template.iterate(new RepeatCallback() {\r\n            @Override\r\n            public RepeatStatus doInIteration(RepeatContext context) throws Exception {\r\n                throw new RepeatException(\"typically thrown by nested repeat template\", exception);\r\n            }\r\n        });\r\n        fail();\r\n    } catch (RepeatException expected) {\r\n        assertSame(exception, expected.getCause());\r\n    }\r\n    assertTrue(listener.called);\r\n    assertTrue(exHandler.called);\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.SimpleRepeatTemplateTests.testExceptionUnwrapping",
	"Comment": "checked exceptions are wrapped into runtime repeatexception.\trepeatexception should be unwrapped before before it is passed to\tlisteners and exception handler.",
	"Method": "void testExceptionUnwrapping(){\r\n    called = true;\r\n    assertSame(exception, throwable);\r\n    throw throwable;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.SimpleRepeatTemplateTests.testExceptionUnwrapping",
	"Comment": "checked exceptions are wrapped into runtime repeatexception.\trepeatexception should be unwrapped before before it is passed to\tlisteners and exception handler.",
	"Method": "void testExceptionUnwrapping(){\r\n    called = true;\r\n    assertSame(exception, throwable);\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.SimpleRepeatTemplateTests.testExceptionUnwrapping",
	"Comment": "checked exceptions are wrapped into runtime repeatexception.\trepeatexception should be unwrapped before before it is passed to\tlisteners and exception handler.",
	"Method": "void testExceptionUnwrapping(){\r\n    throw new RepeatException(\"typically thrown by nested repeat template\", exception);\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.JsonContentAssert.extractingJsonPathValue",
	"Comment": "extract the value at the given json path for further object assertions.",
	"Method": "AbstractObjectAssert<?, Object> extractingJsonPathValue(CharSequence expression,Object args,T extractingJsonPathValue,CharSequence expression,Object[] args,Class<T> type,String expectedDescription){\r\n    JsonPathValue value = new JsonPathValue(expression, args);\r\n    if (value.getValue(false) != null) {\r\n        value.assertHasValue(type, expectedDescription);\r\n    }\r\n    return (T) value.getValue(false);\r\n}"
}, {
	"Path": "org.springframework.batch.core.step.tasklet.SystemCommandTaskletIntegrationTests.testWorkingDirectory",
	"Comment": "working directory property must point to an existing location and it must\tbe a directory",
	"Method": "void testWorkingDirectory(){\r\n    File notExistingFile = new File(\"not-existing-path\");\r\n    Assert.state(!notExistingFile.exists(), \"not-existing-path does actually exist\");\r\n    try {\r\n        tasklet.setWorkingDirectory(notExistingFile.getCanonicalPath());\r\n        fail();\r\n    } catch (IllegalArgumentException e) {\r\n    }\r\n    File notDirectory = File.createTempFile(this.getClass().getName(), null);\r\n    Assert.state(notDirectory.exists(), \"The file does not exist\");\r\n    Assert.state(!notDirectory.isDirectory(), \"The file is actually a directory\");\r\n    try {\r\n        tasklet.setWorkingDirectory(notDirectory.getCanonicalPath());\r\n        fail();\r\n    } catch (IllegalArgumentException e) {\r\n    }\r\n    File directory = notDirectory.getParentFile();\r\n    Assert.state(directory.exists(), \"The directory does not exist\");\r\n    Assert.state(directory.isDirectory(), \"The directory is not a directory\");\r\n    tasklet.setWorkingDirectory(directory.getCanonicalPath());\r\n}"
}, {
	"Path": "org.springframework.batch.item.ldif.builder.MappingLdifReaderBuilder.recordMapper",
	"Comment": "setter for object mapper. this property is required to be set.",
	"Method": "MappingLdifReaderBuilder<T> recordMapper(RecordMapper<T> recordMapper){\r\n    this.recordMapper = recordMapper;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.MongoItemReader.setFields",
	"Comment": "json defining the fields to be returned from the matching documents\tby mongodb.",
	"Method": "void setFields(String fields){\r\n    this.fields = fields;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.exception.SimpleLimitExceptionHandlerTests.testLimitedExceptionTypeNotThrown",
	"Comment": "transactioninvalidexception should only be rethrown below the exception\tlimit.",
	"Method": "void testLimitedExceptionTypeNotThrown(){\r\n    final int MORE_THAN_ZERO = 1;\r\n    handler.setLimit(MORE_THAN_ZERO);\r\n    handler.setExceptionClasses(Collections.<Class<? extends Throwable>>singleton(RuntimeException.class));\r\n    handler.afterPropertiesSet();\r\n    try {\r\n        handler.handleException(new RepeatContextSupport(null), new RuntimeException(\"foo\"));\r\n    } catch (RuntimeException expected) {\r\n        fail(\"Unexpected exception.\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.AbstractFilterRegistrationBean.addUrlPatterns",
	"Comment": "add url patterns, as defined in the servlet specification, that the filter will be\tregistered against.",
	"Method": "void addUrlPatterns(String urlPatterns){\r\n    Assert.notNull(urlPatterns, \"UrlPatterns must not be null\");\r\n    Collections.addAll(this.urlPatterns, urlPatterns);\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.support.ListPreparedStatementSetter.setParameters",
	"Comment": "the parameter values that will be set on the preparedstatement.\tit is assumed that their order in the list is the order of the parameters\tin the preparedstatement.",
	"Method": "void setParameters(List<?> parameters){\r\n    this.parameters = parameters;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.transform.FormatterLineAggregatorTests.testAggregateNullRecordDescriptor",
	"Comment": "if no ranges are specified, illegalargumentexception is thrown",
	"Method": "void testAggregateNullRecordDescriptor(){\r\n    String[] args = { \"does not matter what is here\" };\r\n    try {\r\n        aggregator.aggregate(args);\r\n        fail(\"should not work with no format specified\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.configurationmetadata.Deprecation.getReplacement",
	"Comment": "the full name of the property that replaces the related deprecated property, if",
	"Method": "String getReplacement(){\r\n    return this.replacement;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.MultiResourceItemReaderIntegrationTests.testRestartAcrossResourceBoundary",
	"Comment": "read items with a couple of rollbacks, requiring to jump back to items from previous resources.",
	"Method": "void testRestartAcrossResourceBoundary(){\r\n    tested.open(ctx);\r\n    assertEquals(\"1\", tested.read());\r\n    tested.update(ctx);\r\n    assertEquals(\"2\", tested.read());\r\n    assertEquals(\"3\", tested.read());\r\n    tested.close();\r\n    tested.open(ctx);\r\n    assertEquals(\"2\", tested.read());\r\n    assertEquals(\"3\", tested.read());\r\n    assertEquals(\"4\", tested.read());\r\n    tested.close();\r\n    tested.open(ctx);\r\n    assertEquals(\"2\", tested.read());\r\n    assertEquals(\"3\", tested.read());\r\n    assertEquals(\"4\", tested.read());\r\n    assertEquals(\"5\", tested.read());\r\n    tested.update(ctx);\r\n    assertEquals(\"6\", tested.read());\r\n    assertEquals(\"7\", tested.read());\r\n    tested.close();\r\n    tested.open(ctx);\r\n    assertEquals(\"6\", tested.read());\r\n    assertEquals(\"7\", tested.read());\r\n    assertEquals(\"8\", tested.read());\r\n    assertEquals(null, tested.read());\r\n    tested.close();\r\n}"
}, {
	"Path": "org.springframework.batch.item.ExecutionContext.remove",
	"Comment": "removes the mapping for a key from this context if it is present.",
	"Method": "Object remove(String key){\r\n    return this.map.remove(key);\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.transform.FormatterLineAggregatorTests.testAggregateNullArgument",
	"Comment": "if one of the passed arguments is null, string filled with spaces should\tbe returned",
	"Method": "void testAggregateNullArgument(){\r\n    String[] args = { \"foo\", null, \"bar\" };\r\n    aggregator.setFormat(\"%3s%3s%3s\");\r\n    assertEquals(\"foo   bar\", aggregator.aggregate(args));\r\n}"
}, {
	"Path": "org.springframework.batch.item.ExecutionContext.readAndValidate",
	"Comment": "utility method that attempts to take a value represented by a given key\tand validate it as a member of the specified type.",
	"Method": "Object readAndValidate(String key,Class<?> type){\r\n    Object value = get(key);\r\n    if (!type.isInstance(value)) {\r\n        throw new ClassCastException(\"Value for key=[\" + key + \"] is not of type: [\" + type + \"], it is [\" + (value == null ? null : \"(\" + value.getClass() + \")\" + value) + \"]\");\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.springframework.batch.integration.partition.RemotePartitioningWorkerStepBuilder.stepLocator",
	"Comment": "set the step locator used to locate the worker step to execute.",
	"Method": "RemotePartitioningWorkerStepBuilder stepLocator(StepLocator stepLocator){\r\n    Assert.notNull(stepLocator, \"stepLocator must not be null\");\r\n    this.stepLocator = stepLocator;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.AbstractFilterRegistrationBean.setServletNames",
	"Comment": "set servlet names that the filter will be registered against. this will replace any\tpreviously specified servlet names.",
	"Method": "void setServletNames(Collection<String> servletNames){\r\n    Assert.notNull(servletNames, \"ServletNames must not be null\");\r\n    this.servletNames = new LinkedHashSet(servletNames);\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.support.AbstractSqlPagingQueryProvider.getSortKeyPlaceHolder",
	"Comment": "the sort key placeholder will vary depending on whether named parameters\tor traditional placeholders are used in query strings.",
	"Method": "String getSortKeyPlaceHolder(String keyName){\r\n    return usingNamedParameters ? \":_\" + keyName : \"?\";\r\n}"
}, {
	"Path": "org.springframework.batch.item.ExecutionContext.containsKey",
	"Comment": "indicates whether or not a key is represented in this context.",
	"Method": "boolean containsKey(String key){\r\n    return this.map.containsKey(key);\r\n}"
}, {
	"Path": "org.springframework.batch.item.json.builder.JsonFileItemWriterBuilder.shouldDeleteIfEmpty",
	"Comment": "if set to true, once the step is complete, if the resource previously provided is\tempty, it will be deleted.",
	"Method": "JsonFileItemWriterBuilder<T> shouldDeleteIfEmpty(boolean shouldDelete){\r\n    this.shouldDeleteIfEmpty = shouldDelete;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.TaskExecutorRepeatTemplateAsynchronousTests.testSingleThreadAsynchronousExecution",
	"Comment": "wrap an otherwise synchronous batch in a callback to an asynchronous\ttemplate.",
	"Method": "void testSingleThreadAsynchronousExecution(){\r\n    TaskExecutorRepeatTemplate jobTemplate = new TaskExecutorRepeatTemplate();\r\n    final RepeatTemplate stepTemplate = new RepeatTemplate();\r\n    SimpleAsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor();\r\n    taskExecutor.setConcurrencyLimit(2);\r\n    jobTemplate.setTaskExecutor(taskExecutor);\r\n    final String threadName = Thread.currentThread().getName();\r\n    final Set<String> threadNames = new HashSet();\r\n    final RepeatCallback stepCallback = new ItemReaderRepeatCallback<Trade>(provider, processor) {\r\n        @Override\r\n        public RepeatStatus doInIteration(RepeatContext context) throws Exception {\r\n            assertNotSame(threadName, Thread.currentThread().getName());\r\n            threadNames.add(Thread.currentThread().getName());\r\n            Thread.sleep(100);\r\n            TradeItemReader provider = new TradeItemReader(resource);\r\n            provider.open(new ExecutionContext());\r\n            while (provider.read() != null) ;\r\n            return super.doInIteration(context);\r\n        }\r\n    };\r\n    RepeatCallback jobCallback = new RepeatCallback() {\r\n        @Override\r\n        public RepeatStatus doInIteration(RepeatContext context) throws Exception {\r\n            stepTemplate.iterate(stepCallback);\r\n            return RepeatStatus.FINISHED;\r\n        }\r\n    };\r\n    jobTemplate.iterate(jobCallback);\r\n    assertEquals(NUMBER_OF_ITEMS, processor.count);\r\n    assertTrue(threadNames.size() >= 1);\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.TaskExecutorRepeatTemplateAsynchronousTests.testSingleThreadAsynchronousExecution",
	"Comment": "wrap an otherwise synchronous batch in a callback to an asynchronous\ttemplate.",
	"Method": "void testSingleThreadAsynchronousExecution(){\r\n    assertNotSame(threadName, Thread.currentThread().getName());\r\n    threadNames.add(Thread.currentThread().getName());\r\n    Thread.sleep(100);\r\n    TradeItemReader provider = new TradeItemReader(resource);\r\n    provider.open(new ExecutionContext());\r\n    while (provider.read() != null) ;\r\n    return super.doInIteration(context);\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.TaskExecutorRepeatTemplateAsynchronousTests.testSingleThreadAsynchronousExecution",
	"Comment": "wrap an otherwise synchronous batch in a callback to an asynchronous\ttemplate.",
	"Method": "void testSingleThreadAsynchronousExecution(){\r\n    stepTemplate.iterate(stepCallback);\r\n    return RepeatStatus.FINISHED;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationmetadata.SimpleConfigurationMetadataRepository.include",
	"Comment": "merge the content of the specified repository to this repository.",
	"Method": "void include(ConfigurationMetadataRepository repository){\r\n    for (ConfigurationMetadataGroup group : repository.getAllGroups().values()) {\r\n        ConfigurationMetadataGroup existingGroup = this.allGroups.get(group.getId());\r\n        if (existingGroup == null) {\r\n            this.allGroups.put(group.getId(), group);\r\n        } else {\r\n            group.getProperties().forEach((name, value) -> putIfAbsent(existingGroup.getProperties(), name, value));\r\n            group.getSources().forEach((name, value) -> putIfAbsent(existingGroup.getSources(), name, value));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.RepeatTemplate.createInternalState",
	"Comment": "create an internal state object that is used to store data needed\tinternally in the scope of an iteration. used by subclasses to manage the\tqueueing and retrieval of asynchronous results. the default just provides\tan accumulation of throwable instances for processing at the end of the\tbatch.",
	"Method": "RepeatInternalState createInternalState(RepeatContext context){\r\n    return new RepeatInternalStateSupport();\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper.afterPropertiesSet",
	"Comment": "check that precisely one of type or prototype bean name is specified.",
	"Method": "void afterPropertiesSet(){\r\n    Assert.state(name != null || type != null, \"Either name or type must be provided.\");\r\n    Assert.state(name == null || type == null, \"Both name and type cannot be specified together.\");\r\n    Assert.state(!this.isCustomEditorsSet || this.conversionService == null, \"Both customEditor and conversionService cannot be specified together.\");\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.policy.SimpleCompletionPolicy.isComplete",
	"Comment": "terminate if the chunk size has been reached, or the result is null.",
	"Method": "boolean isComplete(RepeatContext context,RepeatStatus result,boolean isComplete,RepeatContext context,boolean isComplete){\r\n    return ((SimpleTerminationContext) context).isComplete();\r\n}"
}, {
	"Path": "org.springframework.batch.sample.domain.person.PersonService.processPerson",
	"Comment": "badly designed method signature which accepts multiple implicitly related\targuments instead of a single person argument.",
	"Method": "void processPerson(String name,String city){\r\n    processedCounter++;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.builder.FlatFileItemWriterBuilder.append",
	"Comment": "if set to true and the file exists, the output will be appended to the existing\tfile.",
	"Method": "FlatFileItemWriterBuilder<T> append(boolean append){\r\n    this.append = append;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.restart.DefaultRestartInitializer.isMain",
	"Comment": "returns if the thread is for a main invocation. by default checks the name of the\tthread and the context classloader.",
	"Method": "boolean isMain(Thread thread){\r\n    return thread.getName().equals(\"main\") && thread.getContextClassLoader().getClass().getName().contains(\"AppClassLoader\");\r\n}"
}, {
	"Path": "org.springframework.batch.item.json.builder.JsonFileItemWriterBuilder.transactional",
	"Comment": "if set to true, the flushing of the buffer is delayed while a transaction is active.",
	"Method": "JsonFileItemWriterBuilder<T> transactional(boolean transactional){\r\n    this.transactional = transactional;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.mapping.PropertyMatches.calculateMatches",
	"Comment": "generate possible property alternatives for the given property and\tclass. internally uses the getstringdistance method, which\tin turn uses the levenshtein algorithm to determine the distance between\ttwo strings.",
	"Method": "String[] calculateMatches(PropertyDescriptor[] propertyDescriptors,int maxDistance){\r\n    List<String> candidates = new ArrayList();\r\n    for (int i = 0; i < propertyDescriptors.length; i++) {\r\n        if (propertyDescriptors[i].getWriteMethod() != null) {\r\n            String possibleAlternative = propertyDescriptors[i].getName();\r\n            int distance = calculateStringDistance(this.propertyName, possibleAlternative);\r\n            if (distance <= maxDistance) {\r\n                candidates.add(possibleAlternative);\r\n            }\r\n        }\r\n    }\r\n    Collections.sort(candidates);\r\n    return StringUtils.toStringArray(candidates);\r\n}"
}, {
	"Path": "org.springframework.boot.cli.CliTester.clearUrlHandler",
	"Comment": "the tomcaturlstreamhandlerfactory fails if the factory is already set, use\treflection to reset it.",
	"Method": "void clearUrlHandler(){\r\n    try {\r\n        Field field = URL.class.getDeclaredField(\"factory\");\r\n        field.setAccessible(true);\r\n        field.set(null, null);\r\n    } catch (Exception ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.configurationprocessor.json.JSONStringer.replaceTop",
	"Comment": "replace the value on the top of the stack with the given value.",
	"Method": "void replaceTop(Scope topOfStack){\r\n    this.stack.set(this.stack.size() - 1, topOfStack);\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.MultiResourceItemReader.update",
	"Comment": "store the current resource index and position in the resource.",
	"Method": "void update(ExecutionContext executionContext){\r\n    super.update(executionContext);\r\n    if (saveState) {\r\n        executionContext.putInt(getExecutionContextKey(RESOURCE_KEY), currentResource);\r\n        delegate.update(executionContext);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.builder.MongoItemReaderBuilder.fields",
	"Comment": "json defining the fields to be returned from the matching documents by mongodb.",
	"Method": "MongoItemReaderBuilder<T> fields(String fields){\r\n    this.fields = fields;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.builder.StaxEventItemReaderBuilder.strict",
	"Comment": "setting this value to true indicates that it is an error if the input does not\texist and an exception will be thrown. defaults to true.",
	"Method": "StaxEventItemReaderBuilder<T> strict(boolean strict){\r\n    this.strict = strict;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.autoconfigure.cloudfoundry.CloudFoundryAuthorizationException.getReason",
	"Comment": "return the reason why the authorization exception was thrown.",
	"Method": "Reason getReason(){\r\n    return this.reason;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.transform.AbstractLineTokenizer.tokenize",
	"Comment": "yields the tokens resulting from the splitting of the supplied\tline.",
	"Method": "FieldSet tokenize(String line){\r\n    if (line == null) {\r\n        line = \"\";\r\n    }\r\n    List<String> tokens = new ArrayList(doTokenize(line));\r\n    if ((names.length != 0) && (!strict)) {\r\n        adjustTokenCountIfNecessary(tokens);\r\n    }\r\n    String[] values = tokens.toArray(new String[tokens.size()]);\r\n    if (names.length == 0) {\r\n        return fieldSetFactory.create(values);\r\n    } else if (values.length != names.length) {\r\n        throw new IncorrectTokenCountException(names.length, values.length, line);\r\n    }\r\n    return fieldSetFactory.create(values, names);\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.tunnel.server.HttpTunnelServer.setDisconnectTimeout",
	"Comment": "set the maximum amount of time to wait for a client before closing the connection.",
	"Method": "void setDisconnectTimeout(long disconnectTimeout){\r\n    Assert.isTrue(disconnectTimeout > 0, \"DisconnectTimeout must be a positive value\");\r\n    this.disconnectTimeout = disconnectTimeout;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationprocessor.json.JSONStringer.beforeValue",
	"Comment": "inserts any necessary separators and whitespace before a literal value, inline\tarray, or inline object. also adjusts the stack to expect either a closing bracket\tor another element.",
	"Method": "void beforeValue(){\r\n    if (this.stack.isEmpty()) {\r\n        return;\r\n    }\r\n    Scope context = peek();\r\n    if (context == Scope.EMPTY_ARRAY) {\r\n        replaceTop(Scope.NONEMPTY_ARRAY);\r\n        newline();\r\n    } else if (context == Scope.NONEMPTY_ARRAY) {\r\n        this.out.append(',');\r\n        newline();\r\n    } else if (context == Scope.DANGLING_KEY) {\r\n        this.out.append(this.indent == null ? \":\" : \": \");\r\n        replaceTop(Scope.NONEMPTY_OBJECT);\r\n    } else if (context != Scope.NULL) {\r\n        throw new JSONException(\"Nesting problem\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.cli.command.shell.ShellPrompts.popPrompt",
	"Comment": "pop a previously pushed prompt, returning to the previous value.",
	"Method": "void popPrompt(){\r\n    if (!this.prompts.isEmpty()) {\r\n        this.prompts.pop();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.autoconfigure.metrics.ServiceLevelAgreementBoundary.getValue",
	"Comment": "return the underlying value of the sla in form suitable to apply to the given meter\ttype.",
	"Method": "Long getValue(Meter.Type meterType){\r\n    return this.value.getValue(meterType);\r\n}"
}, {
	"Path": "org.springframework.batch.item.ldif.LdifReader.setResource",
	"Comment": "establishes the resource that will be used as the input for the ldifreader.",
	"Method": "void setResource(Resource resource){\r\n    this.resource = resource;\r\n    this.ldifParser = new LdifParser(resource);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.AutoConfigurationImportSelector.getExclusions",
	"Comment": "return any exclusions that limit the candidate configurations.",
	"Method": "Set<String> getExclusions(AnnotationMetadata metadata,AnnotationAttributes attributes,Set<String> getExclusions){\r\n    Set<String> excluded = new LinkedHashSet();\r\n    excluded.addAll(asList(attributes, \"exclude\"));\r\n    excluded.addAll(Arrays.asList(attributes.getStringArray(\"excludeName\")));\r\n    excluded.addAll(getExcludeAutoConfigurationsProperty());\r\n    return excluded;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.builder.FlatFileItemWriterBuilder.lineAggregator",
	"Comment": "line aggregator used to build the string version of each item.",
	"Method": "FlatFileItemWriterBuilder<T> lineAggregator(LineAggregator<T> lineAggregator){\r\n    this.lineAggregator = lineAggregator;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.HibernateCursorItemReaderBuilder.currentItemCount",
	"Comment": "index for the current item. used on restarts to indicate where to start from.",
	"Method": "HibernateCursorItemReaderBuilder<T> currentItemCount(int currentItemCount){\r\n    this.currentItemCount = currentItemCount;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.HibernateItemReaderHelper.createQuery",
	"Comment": "open appropriate type of hibernate session and create the query.",
	"Method": "Query createQuery(){\r\n    if (useStatelessSession) {\r\n        if (statelessSession == null) {\r\n            statelessSession = sessionFactory.openStatelessSession();\r\n        }\r\n        if (queryProvider != null) {\r\n            queryProvider.setStatelessSession(statelessSession);\r\n        } else {\r\n            if (StringUtils.hasText(queryName)) {\r\n                return statelessSession.getNamedQuery(queryName);\r\n            } else {\r\n                return statelessSession.createQuery(queryString);\r\n            }\r\n        }\r\n    } else {\r\n        if (statefulSession == null) {\r\n            statefulSession = sessionFactory.openSession();\r\n        }\r\n        if (queryProvider != null) {\r\n            queryProvider.setSession(statefulSession);\r\n        } else {\r\n            if (StringUtils.hasText(queryName)) {\r\n                return statefulSession.getNamedQuery(queryName);\r\n            } else {\r\n                return statefulSession.createQuery(queryString);\r\n            }\r\n        }\r\n    }\r\n    return queryProvider.createQuery();\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.FlatFileItemWriterTests.setUp",
	"Comment": "create temporary output file, define mock behaviour, set dependencies and initialize the object under test",
	"Method": "void setUp(){\r\n    outputFile = File.createTempFile(\"flatfile-test-output-\", \".tmp\");\r\n    writer.setResource(new FileSystemResource(outputFile));\r\n    writer.setLineSeparator(\"\\n\");\r\n    writer.setLineAggregator(new PassThroughLineAggregator());\r\n    writer.afterPropertiesSet();\r\n    writer.setSaveState(true);\r\n    writer.setEncoding(\"UTF-8\");\r\n    executionContext = new ExecutionContext();\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.source.ConfigurationPropertySource.getUnderlyingSource",
	"Comment": "return the underlying source that is actually providing the properties.",
	"Method": "Object getUnderlyingSource(){\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BindHandler.onSuccess",
	"Comment": "called when binding of an element ends with a successful result. implementations\tmay change the ultimately returned result or perform addition validation.",
	"Method": "Object onSuccess(ConfigurationPropertyName name,Bindable<?> target,BindContext context,Object result){\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.JsonContentAssert.extractingJsonPathBooleanValue",
	"Comment": "extract the boolean value at the given json path for further object assertions.",
	"Method": "AbstractBooleanAssert<?> extractingJsonPathBooleanValue(CharSequence expression,Object args){\r\n    return Assertions.assertThat(extractingJsonPathValue(expression, args, Boolean.class, \"a boolean\"));\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.StoredProcedureItemReaderBuilder.ignoreWarnings",
	"Comment": "indicates if sql warnings should be ignored or if an exception should be thrown.",
	"Method": "StoredProcedureItemReaderBuilder<T> ignoreWarnings(boolean ignoreWarnings){\r\n    this.ignoreWarnings = ignoreWarnings;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.jms.DefaultJmsListenerContainerFactoryConfigurer.configure",
	"Comment": "configure the specified jms listener container factory. the factory can be further\ttuned and default settings can be overridden.",
	"Method": "void configure(DefaultJmsListenerContainerFactory factory,ConnectionFactory connectionFactory){\r\n    Assert.notNull(factory, \"Factory must not be null\");\r\n    Assert.notNull(connectionFactory, \"ConnectionFactory must not be null\");\r\n    factory.setConnectionFactory(connectionFactory);\r\n    factory.setPubSubDomain(this.jmsProperties.isPubSubDomain());\r\n    if (this.transactionManager != null) {\r\n        factory.setTransactionManager(this.transactionManager);\r\n    } else {\r\n        factory.setSessionTransacted(true);\r\n    }\r\n    if (this.destinationResolver != null) {\r\n        factory.setDestinationResolver(this.destinationResolver);\r\n    }\r\n    if (this.messageConverter != null) {\r\n        factory.setMessageConverter(this.messageConverter);\r\n    }\r\n    JmsProperties.Listener listener = this.jmsProperties.getListener();\r\n    factory.setAutoStartup(listener.isAutoStartup());\r\n    if (listener.getAcknowledgeMode() != null) {\r\n        factory.setSessionAcknowledgeMode(listener.getAcknowledgeMode().getMode());\r\n    }\r\n    String concurrency = listener.formatConcurrency();\r\n    if (concurrency != null) {\r\n        factory.setConcurrency(concurrency);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemWriterTests.testDeleteIfEmptyRecordsWritten",
	"Comment": "resource is not deleted when items have been written and shoulddeleteifempty flag is set.",
	"Method": "void testDeleteIfEmptyRecordsWritten(){\r\n    writer.setShouldDeleteIfEmpty(true);\r\n    writer.open(executionContext);\r\n    writer.write(items);\r\n    writer.close();\r\n    String content = getOutputFileContent();\r\n    assertTrue(\"Wrong content: \" + content, content.contains(TEST_STRING));\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.SynchronousTests.testInternalRetrySuccessOnSecondAttempt",
	"Comment": "message processing is successful on the second attempt without having to\treceive the message again.",
	"Method": "void testInternalRetrySuccessOnSecondAttempt(){\r\n    assertInitialState();\r\n    final String text = (String) jmsTemplate.receiveAndConvert(\"queue\");\r\n    assertNotNull(text);\r\n    retryTemplate.execute(new RetryCallback<String, Exception>() {\r\n        @Override\r\n        public String doWithRetry(RetryContext status) throws Exception {\r\n            TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);\r\n            transactionTemplate.setPropagationBehavior(TransactionTemplate.PROPAGATION_NESTED);\r\n            return transactionTemplate.execute(new TransactionCallback<String>() {\r\n                @Override\r\n                public String doInTransaction(TransactionStatus status) {\r\n                    list.add(text);\r\n                    System.err.println(\"Inserting: [\" + list.size() + \",\" + text + \"]\");\r\n                    jdbcTemplate.update(\"INSERT into T_BARS (id,name,foo_date) values (?,?,null)\", list.size(), text);\r\n                    if (list.size() == 1) {\r\n                        throw new RuntimeException(\"Rollback!\");\r\n                    }\r\n                    return text;\r\n                }\r\n            });\r\n        }\r\n    });\r\n    List<String> msgs = getMessages();\r\n    int count = jdbcTemplate.queryForObject(\"select count(*) from T_BARS\", Integer.class);\r\n    assertEquals(1, count);\r\n    assertEquals(\"[]\", msgs.toString());\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.SynchronousTests.testInternalRetrySuccessOnSecondAttempt",
	"Comment": "message processing is successful on the second attempt without having to\treceive the message again.",
	"Method": "void testInternalRetrySuccessOnSecondAttempt(){\r\n    TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);\r\n    transactionTemplate.setPropagationBehavior(TransactionTemplate.PROPAGATION_NESTED);\r\n    return transactionTemplate.execute(new TransactionCallback<String>() {\r\n        @Override\r\n        public String doInTransaction(TransactionStatus status) {\r\n            list.add(text);\r\n            System.err.println(\"Inserting: [\" + list.size() + \",\" + text + \"]\");\r\n            jdbcTemplate.update(\"INSERT into T_BARS (id,name,foo_date) values (?,?,null)\", list.size(), text);\r\n            if (list.size() == 1) {\r\n                throw new RuntimeException(\"Rollback!\");\r\n            }\r\n            return text;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.SynchronousTests.testInternalRetrySuccessOnSecondAttempt",
	"Comment": "message processing is successful on the second attempt without having to\treceive the message again.",
	"Method": "void testInternalRetrySuccessOnSecondAttempt(){\r\n    list.add(text);\r\n    System.err.println(\"Inserting: [\" + list.size() + \",\" + text + \"]\");\r\n    jdbcTemplate.update(\"INSERT into T_BARS (id,name,foo_date) values (?,?,null)\", list.size(), text);\r\n    if (list.size() == 1) {\r\n        throw new RuntimeException(\"Rollback!\");\r\n    }\r\n    return text;\r\n}"
}, {
	"Path": "org.springframework.batch.sample.iosample.AbstractIoSampleTests.testUpdateCredit",
	"Comment": "check the resulting credits correspond to inputs increased by fixed\tamount.",
	"Method": "void testUpdateCredit(){\r\n    open(reader);\r\n    List<CustomerCredit> inputs = getCredits(reader);\r\n    close(reader);\r\n    JobExecution jobExecution = jobLauncherTestUtils.launchJob(getUniqueJobParameters());\r\n    assertEquals(BatchStatus.COMPLETED, jobExecution.getStatus());\r\n    pointReaderToOutput(reader);\r\n    open(reader);\r\n    List<CustomerCredit> outputs = getCredits(reader);\r\n    close(reader);\r\n    assertEquals(inputs.size(), outputs.size());\r\n    int itemCount = inputs.size();\r\n    assertTrue(itemCount > 0);\r\n    for (int i = 0; i < itemCount; i++) {\r\n        assertEquals(inputs.get(i).getCredit().add(CustomerCreditIncreaseProcessor.FIXED_AMOUNT).intValue(), outputs.get(i).getCredit().intValue());\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.builder.SpringApplicationBuilder.beanNameGenerator",
	"Comment": "bean name generator for automatically generated bean names in the application\tcontext.",
	"Method": "SpringApplicationBuilder beanNameGenerator(BeanNameGenerator beanNameGenerator){\r\n    this.application.setBeanNameGenerator(beanNameGenerator);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.MultiResourceItemReader.read",
	"Comment": "reads the next item, jumping to next resource if necessary.",
	"Method": "T read(){\r\n    if (noInput) {\r\n        return null;\r\n    }\r\n    if (currentResource == -1) {\r\n        currentResource = 0;\r\n        delegate.setResource(resources[currentResource]);\r\n        delegate.open(new ExecutionContext());\r\n    }\r\n    return readNextItem();\r\n}"
}, {
	"Path": "org.springframework.batch.sample.HibernateFailureJobFunctionalTests.ensureState",
	"Comment": "ensure the state of the database is accurate by delete all the contents of the\tcustomer table and reading the expected defaults.",
	"Method": "void ensureState(){\r\n    new TransactionTemplate(transactionManager).execute(new TransactionCallback<Void>() {\r\n        @Override\r\n        public Void doInTransaction(TransactionStatus status) {\r\n            jdbcTemplate.update(DELETE_CUSTOMERS);\r\n            for (String customer : customers) {\r\n                jdbcTemplate.update(customer);\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.springframework.batch.sample.HibernateFailureJobFunctionalTests.ensureState",
	"Comment": "ensure the state of the database is accurate by delete all the contents of the\tcustomer table and reading the expected defaults.",
	"Method": "void ensureState(){\r\n    jdbcTemplate.update(DELETE_CUSTOMERS);\r\n    for (String customer : customers) {\r\n        jdbcTemplate.update(customer);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.RepeatTemplate.executeInternal",
	"Comment": "internal convenience method to loop over interceptors and batch\tcallbacks.",
	"Method": "RepeatStatus executeInternal(RepeatCallback callback){\r\n    RepeatContext context = start();\r\n    boolean running = !isMarkedComplete(context);\r\n    for (RepeatListener interceptor : listeners) {\r\n        interceptor.open(context);\r\n        running = running && !isMarkedComplete(context);\r\n        if (!running)\r\n            break;\r\n    }\r\n    RepeatStatus result = RepeatStatus.CONTINUABLE;\r\n    RepeatInternalState state = createInternalState(context);\r\n    Collection<Throwable> throwables = state.getThrowables();\r\n    Collection<Throwable> deferred = new ArrayList();\r\n    try {\r\n        while (running) {\r\n            for (int i = 0; i < listeners.length; i++) {\r\n                RepeatListener interceptor = listeners[i];\r\n                interceptor.before(context);\r\n                running = running && !isMarkedComplete(context);\r\n            }\r\n            if (running) {\r\n                try {\r\n                    result = getNextResult(context, callback, state);\r\n                    executeAfterInterceptors(context, result);\r\n                } catch (Throwable throwable) {\r\n                    doHandle(throwable, context, deferred);\r\n                }\r\n                if (isComplete(context, result) || isMarkedComplete(context) || !deferred.isEmpty()) {\r\n                    running = false;\r\n                }\r\n            }\r\n        }\r\n        result = result.and(waitForResults(state));\r\n        for (Throwable throwable : throwables) {\r\n            doHandle(throwable, context, deferred);\r\n        }\r\n        state = null;\r\n    } finally {\r\n        try {\r\n            if (!deferred.isEmpty()) {\r\n                Throwable throwable = deferred.iterator().next();\r\n                if (logger.isDebugEnabled()) {\r\n                    logger.debug(\"Handling fatal exception explicitly (rethrowing first of \" + deferred.size() + \"): \" + throwable.getClass().getName() + \": \" + throwable.getMessage());\r\n                }\r\n                rethrow(throwable);\r\n            }\r\n        } finally {\r\n            try {\r\n                for (int i = listeners.length; i-- > 0; ) {\r\n                    RepeatListener interceptor = listeners[i];\r\n                    interceptor.close(context);\r\n                }\r\n            } finally {\r\n                context.close();\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.batch.item.support.ClassifierCompositeItemProcessorTests.testGenericsClassifierCompositeItemProcessor",
	"Comment": "test the classifiercompositeitemprocessor with delegates that have more specific generic types for input as well as output.",
	"Method": "void testGenericsClassifierCompositeItemProcessor(){\r\n    ClassifierCompositeItemProcessor<Number, CharSequence> processor = new ClassifierCompositeItemProcessor();\r\n    ItemProcessor<Integer, String> intProcessor = new ItemProcessor<Integer, String>() {\r\n        @Override\r\n        public String process(Integer item) throws Exception {\r\n            return \"int: \" + item;\r\n        }\r\n    };\r\n    ItemProcessor<Long, StringBuffer> longProcessor = new ItemProcessor<Long, StringBuffer>() {\r\n        @Override\r\n        public StringBuffer process(Long item) throws Exception {\r\n            return new StringBuffer(\"long: \" + item);\r\n        }\r\n    };\r\n    ItemProcessor<Number, StringBuilder> defaultProcessor = new ItemProcessor<Number, StringBuilder>() {\r\n        @Override\r\n        public StringBuilder process(Number item) throws Exception {\r\n            return new StringBuilder(\"number: \" + item);\r\n        }\r\n    };\r\n    SubclassClassifier<Number, ItemProcessor<?, ? extends CharSequence>> classifier = new SubclassClassifier();\r\n    Map<Class<? extends Number>, ItemProcessor<?, ? extends CharSequence>> typeMap = new HashMap();\r\n    typeMap.put(Integer.class, intProcessor);\r\n    typeMap.put(Long.class, longProcessor);\r\n    typeMap.put(Number.class, defaultProcessor);\r\n    classifier.setTypeMap(typeMap);\r\n    processor.setClassifier(classifier);\r\n    assertEquals(\"int: 1\", processor.process(Integer.valueOf(1)).toString());\r\n    assertEquals(\"long: 2\", processor.process(Long.valueOf(2)).toString());\r\n    assertEquals(\"number: 3\", processor.process(Byte.valueOf((byte) 3)).toString());\r\n}"
}, {
	"Path": "org.springframework.batch.item.support.ClassifierCompositeItemProcessorTests.testGenericsClassifierCompositeItemProcessor",
	"Comment": "test the classifiercompositeitemprocessor with delegates that have more specific generic types for input as well as output.",
	"Method": "void testGenericsClassifierCompositeItemProcessor(){\r\n    return \"int: \" + item;\r\n}"
}, {
	"Path": "org.springframework.batch.item.support.ClassifierCompositeItemProcessorTests.testGenericsClassifierCompositeItemProcessor",
	"Comment": "test the classifiercompositeitemprocessor with delegates that have more specific generic types for input as well as output.",
	"Method": "void testGenericsClassifierCompositeItemProcessor(){\r\n    return new StringBuffer(\"long: \" + item);\r\n}"
}, {
	"Path": "org.springframework.batch.item.support.ClassifierCompositeItemProcessorTests.testGenericsClassifierCompositeItemProcessor",
	"Comment": "test the classifiercompositeitemprocessor with delegates that have more specific generic types for input as well as output.",
	"Method": "void testGenericsClassifierCompositeItemProcessor(){\r\n    return new StringBuilder(\"number: \" + item);\r\n}"
}, {
	"Path": "org.springframework.batch.item.json.builder.JsonFileItemWriterBuilder.append",
	"Comment": "if set to true and the file exists, the output will be appended to the existing\tfile.",
	"Method": "JsonFileItemWriterBuilder<T> append(boolean append){\r\n    this.append = append;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.core.step.item.FaultTolerantChunkProcessorTests.testWriteSkipOnError",
	"Comment": "an error can be retried or skipped but by default it is just propagated",
	"Method": "void testWriteSkipOnError(){\r\n    processor.setWriteSkipPolicy(new AlwaysSkipItemSkipPolicy());\r\n    processor.setItemWriter(new ItemWriter<String>() {\r\n        @Override\r\n        public void write(List<? extends String> items) throws Exception {\r\n            if (items.contains(\"fail\")) {\r\n                assertFalse(\"Expected Error!\", true);\r\n            }\r\n        }\r\n    });\r\n    Chunk<String> inputs = new Chunk(Arrays.asList(\"3\", \"fail\", \"2\"));\r\n    try {\r\n        processor.process(contribution, inputs);\r\n        fail(\"Expected Error\");\r\n    } catch (Error e) {\r\n        assertEquals(\"Expected Error!\", e.getMessage());\r\n    }\r\n    processor.process(contribution, inputs);\r\n}"
}, {
	"Path": "org.springframework.batch.core.step.item.FaultTolerantChunkProcessorTests.testWriteSkipOnError",
	"Comment": "an error can be retried or skipped but by default it is just propagated",
	"Method": "void testWriteSkipOnError(){\r\n    if (items.contains(\"fail\")) {\r\n        assertFalse(\"Expected Error!\", true);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.logging.LoggingSystem.get",
	"Comment": "detect and return the logging system in use. supports logback and java logging.",
	"Method": "LoggingSystem get(ClassLoader classLoader,LoggingSystem get,ClassLoader classLoader,String loggingSystemClass){\r\n    try {\r\n        Class<?> systemClass = ClassUtils.forName(loggingSystemClass, classLoader);\r\n        return (LoggingSystem) systemClass.getConstructor(ClassLoader.class).newInstance(classLoader);\r\n    } catch (Exception ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.integration.chunk.RemoteChunkHandlerFactoryBean.updateStepContribution",
	"Comment": "update a stepcontribution with all the data from a stepcontributionsource. the filter and write counts plus the\texit status will be updated to reflect the data in the source.",
	"Method": "void updateStepContribution(StepContribution contribution,StepContributionSource stepContributionSource){\r\n    for (StepContribution result : stepContributionSource.getStepContributions()) {\r\n        contribution.incrementFilterCount(result.getFilterCount());\r\n        contribution.incrementWriteCount(result.getWriteCount());\r\n        for (int i = 0; i < result.getProcessSkipCount(); i++) {\r\n            contribution.incrementProcessSkipCount();\r\n        }\r\n        for (int i = 0; i < result.getWriteSkipCount(); i++) {\r\n            contribution.incrementWriteSkipCount();\r\n        }\r\n        contribution.setExitStatus(contribution.getExitStatus().and(result.getExitStatus()));\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.sample.common.StagingItemProcessor.process",
	"Comment": "use the technical identifier to mark the input row as processed and\treturn unwrapped item.",
	"Method": "T process(ProcessIndicatorItemWrapper<T> wrapper){\r\n    int count = jdbcTemplate.update(\"UPDATE BATCH_STAGING SET PROCESSED=? WHERE ID=? AND PROCESSED=?\", StagingItemWriter.DONE, wrapper.getId(), StagingItemWriter.NEW);\r\n    if (count != 1) {\r\n        throw new OptimisticLockingFailureException(\"The staging record with ID=\" + wrapper.getId() + \" was updated concurrently when trying to mark as complete (updated \" + count + \" records.\");\r\n    }\r\n    return wrapper.getItem();\r\n}"
}, {
	"Path": "org.springframework.batch.test.AbstractJobTests.launchStep",
	"Comment": "launch just the specified step in the job. an illegalstateexception is\tthrown if there is no step with the given name.",
	"Method": "JobExecution launchStep(String stepName,JobExecution launchStep,String stepName,ExecutionContext jobExecutionContext,JobExecution launchStep,String stepName,JobParameters jobParameters,JobExecution launchStep,String stepName,JobParameters jobParameters,ExecutionContext jobExecutionContext){\r\n    Step step = this.job.getStep(stepName);\r\n    if (step == null) {\r\n        step = this.job.getStep(this.job.getName() + \".\" + stepName);\r\n    }\r\n    if (step == null) {\r\n        throw new IllegalStateException(\"No Step found with name: [\" + stepName + \"]\");\r\n    }\r\n    return getStepRunner().launchStep(step, jobParameters, jobExecutionContext);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.jdbc.DataSourceProperties.determinePassword",
	"Comment": "determine the password to use based on this configuration and the environment.",
	"Method": "String determinePassword(){\r\n    if (StringUtils.hasText(this.password)) {\r\n        return this.password;\r\n    }\r\n    if (EmbeddedDatabaseConnection.isEmbedded(determineDriverClassName())) {\r\n        return \"\";\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.AbstractJsonMarshalTester.readObject",
	"Comment": "read from the specified reader to create an object of the specified type.",
	"Method": "T readObject(String resourcePath,T readObject,File file,T readObject,InputStream inputStream,T readObject,Resource resource,T readObject,Reader reader,T readObject,InputStream inputStream,ResolvableType type,T readObject,Reader reader,ResolvableType type){\r\n    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\r\n    return readObject(reader, type);\r\n}"
}, {
	"Path": "org.springframework.batch.item.ExecutionContext.getDouble",
	"Comment": "typesafe getter for the double represented by the provided key with\tdefault value to return if key is not represented.",
	"Method": "double getDouble(String key,double getDouble,String key,double defaultDouble){\r\n    if (!containsKey(key)) {\r\n        return defaultDouble;\r\n    }\r\n    return getDouble(key);\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.ServletRegistrationBean.addUrlMappings",
	"Comment": "add url mappings, as defined in the servlet specification, for the servlet.",
	"Method": "void addUrlMappings(String urlMappings){\r\n    Assert.notNull(urlMappings, \"UrlMappings must not be null\");\r\n    this.urlMappings.addAll(Arrays.asList(urlMappings));\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.livereload.LiveReloadServer.start",
	"Comment": "start the livereload server and accept incoming connections.",
	"Method": "int start(){\r\n    synchronized (this.monitor) {\r\n        Assert.state(!isStarted(), \"Server already started\");\r\n        logger.debug(\"Starting live reload server on port \" + this.port);\r\n        this.serverSocket = new ServerSocket(this.port);\r\n        int localPort = this.serverSocket.getLocalPort();\r\n        this.listenThread = this.threadFactory.newThread(this::acceptConnections);\r\n        this.listenThread.setDaemon(true);\r\n        this.listenThread.setName(\"Live Reload Server\");\r\n        this.listenThread.start();\r\n        return localPort;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.AbstractDataSourceItemReaderIntegrationTests.testInvalidRestore",
	"Comment": "reading from an input source and then trying to restore causes an error.",
	"Method": "void testInvalidRestore(){\r\n    getAsItemStream(reader).open(executionContext);\r\n    Foo foo1 = reader.read();\r\n    assertEquals(1, foo1.getValue());\r\n    Foo foo2 = reader.read();\r\n    assertEquals(2, foo2.getValue());\r\n    getAsItemStream(reader).update(executionContext);\r\n    getAsItemStream(reader).close();\r\n    reader = createItemReader();\r\n    getAsItemStream(reader).open(new ExecutionContext());\r\n    Foo foo = reader.read();\r\n    assertEquals(1, foo.getValue());\r\n    try {\r\n        getAsItemStream(reader).open(executionContext);\r\n        fail();\r\n    } catch (Exception ex) {\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath.getPrefix",
	"Comment": "return a cleaned up version of the path that can be used as a prefix for urls. the\tresulting path will have path will not have a trailing slash.",
	"Method": "String getPrefix(){\r\n    String result = getPath();\r\n    int index = result.indexOf('*');\r\n    if (index != -1) {\r\n        result = result.substring(0, index);\r\n    }\r\n    if (result.endsWith(\"/\")) {\r\n        result = result.substring(0, result.length() - 1);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.stax.DefaultFragmentEventReaderTests.testMarkFragmentProcessed",
	"Comment": "when fragment is marked as processed the cursor is moved after the end of\tthe fragment.",
	"Method": "void testMarkFragmentProcessed(){\r\n    moveCursorBeforeFragmentStart();\r\n    fragmentReader.markStartFragment();\r\n    XMLEvent startFragment = fragmentReader.nextEvent();\r\n    assertTrue(startFragment.isStartDocument());\r\n    fragmentReader.markFragmentProcessed();\r\n    fragmentReader.nextEvent();\r\n    XMLEvent misc2 = fragmentReader.nextEvent();\r\n    assertTrue(EventHelper.startElementName(misc2).equals(\"misc2\"));\r\n}"
}, {
	"Path": "org.springframework.batch.support.PropertiesConverterTests.testRegularConversionWithCommaAndWhitespace",
	"Comment": "check that properties can be comma delimited with extra whitespace.",
	"Method": "void testRegularConversionWithCommaAndWhitespace(){\r\n    Properties storedProps = new Properties();\r\n    storedProps.setProperty(\"key1\", \"value1\");\r\n    storedProps.setProperty(\"key2\", \"value2\");\r\n    props = PropertiesConverter.stringToProperties(\"key1=value1, key2=value2\");\r\n    assertEquals(storedProps, props);\r\n}"
}, {
	"Path": "org.springframework.boot.loader.jar.Handler.setUseFastConnectionExceptions",
	"Comment": "set if a generic static exception can be thrown when a url cannot be connected.\tthis optimization is used during class loading to save creating lots of exceptions\twhich are then swallowed.",
	"Method": "void setUseFastConnectionExceptions(boolean useFastConnectionExceptions){\r\n    JarURLConnection.setUseFastExceptions(useFastConnectionExceptions);\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemReader.readToStartFragment",
	"Comment": "read until the first startelement tag that matches any of the provided fragmentrootelementnames. because there may be any\tnumber of tags in between where the reader is now and the fragment start, this is done in a loop until the\telement type and name match.",
	"Method": "QName readToStartFragment(){\r\n    while (true) {\r\n        XMLEvent nextEvent = eventReader.nextEvent();\r\n        if (nextEvent.isStartElement() && isFragmentRootElementName(((StartElement) nextEvent).getName())) {\r\n            return ((StartElement) nextEvent).getName();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.ExecutionContext.entrySet",
	"Comment": "returns the entry set containing the contents of this context.",
	"Method": "Set<Entry<String, Object>> entrySet(){\r\n    return this.map.entrySet();\r\n}"
}, {
	"Path": "org.springframework.boot.builder.SpringApplicationBuilder.logStartupInfo",
	"Comment": "flag to indicate the startup information should be logged.",
	"Method": "SpringApplicationBuilder logStartupInfo(boolean logStartupInfo){\r\n    this.application.setLogStartupInfo(logStartupInfo);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.trace.http.InMemoryHttpTraceRepository.setReverse",
	"Comment": "flag to say that the repository lists traces in reverse order.",
	"Method": "void setReverse(boolean reverse){\r\n    synchronized (this.traces) {\r\n        this.reverse = reverse;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemReader.jumpToItem",
	"Comment": "jumptoitem is overridden because reading in and attempting to bind an entire fragment is unacceptable in a\trestart scenario, and may cause exceptions to be thrown that were already skipped in previous runs.",
	"Method": "void jumpToItem(int itemIndex){\r\n    for (int i = 0; i < itemIndex; i++) {\r\n        try {\r\n            QName fragmentName = readToStartFragment();\r\n            readToEndFragment(fragmentName);\r\n        } catch (NoSuchElementException e) {\r\n            if (itemIndex == (i + 1)) {\r\n                return;\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.task.TaskExecutorBuilder.threadNamePrefix",
	"Comment": "set the prefix to use for the names of newly created threads.",
	"Method": "TaskExecutorBuilder threadNamePrefix(String threadNamePrefix){\r\n    return new TaskExecutorBuilder(this.queueCapacity, this.corePoolSize, this.maxPoolSize, this.allowCoreThreadTimeOut, this.keepAlive, threadNamePrefix, this.taskDecorator, this.customizers);\r\n}"
}, {
	"Path": "org.springframework.batch.integration.chunk.ChunkMessageChannelItemWriter.setThrottleLimit",
	"Comment": "public setter for the throttle limit. this limits the number of pending requests for chunk processing to avoid\toverwhelming the receivers.",
	"Method": "void setThrottleLimit(long throttleLimit){\r\n    this.throttleLimit = throttleLimit;\r\n}"
}, {
	"Path": "org.springframework.batch.item.ldif.builder.LdifReaderBuilder.currentItemCount",
	"Comment": "index for the current item. used on restarts to indicate where to start from.",
	"Method": "LdifReaderBuilder currentItemCount(int currentItemCount){\r\n    this.currentItemCount = currentItemCount;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.kafka.KafkaProperties.buildAdminProperties",
	"Comment": "create an initial map of admin properties from the state of this instance.\tthis allows you to add additional properties, if necessary, and override the\tdefault kafkaadmin bean.",
	"Method": "Map<String, Object> buildAdminProperties(){\r\n    Map<String, Object> properties = buildCommonProperties();\r\n    properties.putAll(this.admin.buildProperties());\r\n    return properties;\r\n}"
}, {
	"Path": "org.springframework.boot.security.reactive.ApplicationContextServerWebExchangeMatcher.matches",
	"Comment": "decides whether the rule implemented by the strategy matches the supplied exchange.",
	"Method": "Mono<MatchResult> matches(ServerWebExchange exchange,Mono<MatchResult> matches,ServerWebExchange exchange,Supplier<C> context){\r\n    return matches(exchange, getContext(exchange));\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.builder.MultiResourceItemReaderBuilder.delegate",
	"Comment": "establishes the delegate to use for reading the resources provided.",
	"Method": "MultiResourceItemReaderBuilder<T> delegate(ResourceAwareItemReaderItemStream<? extends T> delegate){\r\n    this.delegate = delegate;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.MongoItemWriter.write",
	"Comment": "if a transaction is active, buffer items to be written just before commit.\totherwise write items using the provided template.",
	"Method": "void write(List<? extends T> items){\r\n    if (!transactionActive()) {\r\n        doWrite(items);\r\n        return;\r\n    }\r\n    List<T> bufferedItems = getCurrentBuffer();\r\n    bufferedItems.addAll(items);\r\n}"
}, {
	"Path": "org.springframework.batch.sample.PartitionJdbcJobFunctionalTests.testUpdateCredit",
	"Comment": "check the resulting credits correspond to inputs increased by fixed\tamount.",
	"Method": "void testUpdateCredit(){\r\n    assertTrue(\"Define a prototype bean called 'outputTestReader' to check the output\", applicationContext.containsBeanDefinition(\"outputTestReader\"));\r\n    open(inputReader);\r\n    List<CustomerCredit> inputs = new ArrayList(getCredits(inputReader));\r\n    close(inputReader);\r\n    JobExecution jobExecution = jobLauncherTestUtils.launchJob();\r\n    assertEquals(BatchStatus.COMPLETED, jobExecution.getStatus());\r\n    @SuppressWarnings(\"unchecked\")\r\n    ItemReader<CustomerCredit> outputReader = (ItemReader<CustomerCredit>) applicationContext.getBean(\"outputTestReader\");\r\n    open(outputReader);\r\n    List<CustomerCredit> outputs = new ArrayList(getCredits(outputReader));\r\n    close(outputReader);\r\n    assertEquals(inputs.size(), outputs.size());\r\n    int itemCount = inputs.size();\r\n    assertTrue(itemCount > 0);\r\n    inputs.iterator();\r\n    for (int i = 0; i < itemCount; i++) {\r\n        assertEquals(inputs.get(i).getCredit().add(CustomerCreditIncreaseProcessor.FIXED_AMOUNT).intValue(), outputs.get(i).getCredit().intValue());\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.info.GitProperties.coerceToEpoch",
	"Comment": "attempt to convert the specified value to epoch time. git properties information\tare known to be specified either as epoch time in seconds or using a specific date\tformat.",
	"Method": "String coerceToEpoch(String s){\r\n    Long epoch = parseEpochSecond(s);\r\n    if (epoch != null) {\r\n        return String.valueOf(epoch);\r\n    }\r\n    SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\");\r\n    try {\r\n        return String.valueOf(format.parse(s).getTime());\r\n    } catch (ParseException ex) {\r\n        return s;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.ChunkedRepeatTests.testAsynchronousChunkedBatchWithCompletionPolicy",
	"Comment": "chunking with an asynchronous taskexecutor in the chunks. transactions\thave to be at the level of the business callback.",
	"Method": "void testAsynchronousChunkedBatchWithCompletionPolicy(){\r\n    RepeatTemplate repeatTemplate = new RepeatTemplate();\r\n    final RepeatCallback callback = new ItemReaderRepeatCallback(provider, processor);\r\n    final TaskExecutorRepeatTemplate chunkTemplate = new TaskExecutorRepeatTemplate();\r\n    chunkTemplate.setCompletionPolicy(new SimpleCompletionPolicy(2));\r\n    chunkTemplate.setTaskExecutor(new SimpleAsyncTaskExecutor());\r\n    RepeatStatus result = repeatTemplate.iterate(new NestedRepeatCallback(chunkTemplate, callback) {\r\n        @Override\r\n        public RepeatStatus doInIteration(RepeatContext context) throws Exception {\r\n            count++;\r\n            return super.doInIteration(context);\r\n        }\r\n    });\r\n    assertEquals(NUMBER_OF_ITEMS, processor.count);\r\n    assertFalse(result.isContinuable());\r\n    assertTrue(\"Expected at least 3 chunks but found: \" + count, count >= 3);\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.ChunkedRepeatTests.testAsynchronousChunkedBatchWithCompletionPolicy",
	"Comment": "chunking with an asynchronous taskexecutor in the chunks. transactions\thave to be at the level of the business callback.",
	"Method": "void testAsynchronousChunkedBatchWithCompletionPolicy(){\r\n    count++;\r\n    return super.doInIteration(context);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.amqp.RabbitProperties.determineHost",
	"Comment": "returns the host from the first address, or the configured host if no addresses\thave been set.",
	"Method": "String determineHost(){\r\n    if (CollectionUtils.isEmpty(this.parsedAddresses)) {\r\n        return getHost();\r\n    }\r\n    return this.parsedAddresses.get(0).host;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.exception.SimpleLimitExceptionHandler.afterPropertiesSet",
	"Comment": "apply the provided properties to create a delegate handler.",
	"Method": "void afterPropertiesSet(){\r\n    if (limit <= 0) {\r\n        return;\r\n    }\r\n    Map<Class<? extends Throwable>, Integer> thresholds = new HashMap();\r\n    for (Class<? extends Throwable> type : exceptionClasses) {\r\n        thresholds.put(type, limit);\r\n    }\r\n    for (Class<? extends Throwable> type : fatalExceptionClasses) {\r\n        thresholds.put(type, 0);\r\n    }\r\n    delegate.setThresholds(thresholds);\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.AbstractFilterRegistrationBean.configure",
	"Comment": "configure registration settings. subclasses can override this method to perform\tadditional configuration if required.",
	"Method": "void configure(FilterRegistration.Dynamic registration){\r\n    super.configure(registration);\r\n    EnumSet<DispatcherType> dispatcherTypes = this.dispatcherTypes;\r\n    if (dispatcherTypes == null) {\r\n        dispatcherTypes = EnumSet.of(DispatcherType.REQUEST);\r\n    }\r\n    Set<String> servletNames = new LinkedHashSet();\r\n    for (ServletRegistrationBean<?> servletRegistrationBean : this.servletRegistrationBeans) {\r\n        servletNames.add(servletRegistrationBean.getServletName());\r\n    }\r\n    servletNames.addAll(this.servletNames);\r\n    if (servletNames.isEmpty() && this.urlPatterns.isEmpty()) {\r\n        registration.addMappingForUrlPatterns(dispatcherTypes, this.matchAfter, DEFAULT_URL_MAPPINGS);\r\n    } else {\r\n        if (!servletNames.isEmpty()) {\r\n            registration.addMappingForServletNames(dispatcherTypes, this.matchAfter, StringUtils.toStringArray(servletNames));\r\n        }\r\n        if (!this.urlPatterns.isEmpty()) {\r\n            registration.addMappingForUrlPatterns(dispatcherTypes, this.matchAfter, StringUtils.toStringArray(this.urlPatterns));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.kafka.KafkaProperties.buildStreamsProperties",
	"Comment": "create an initial map of streams properties from the state of this instance.\tthis allows you to add additional properties, if necessary.",
	"Method": "Map<String, Object> buildStreamsProperties(){\r\n    Map<String, Object> properties = buildCommonProperties();\r\n    properties.putAll(this.streams.buildProperties());\r\n    return properties;\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.JdbcPagingItemReader.setRowMapper",
	"Comment": "the row mapper implementation to be used by this reader. the row mapper\tis used to convert result set rows into objects, which are then returned\tby the reader.",
	"Method": "void setRowMapper(RowMapper<T> rowMapper){\r\n    this.rowMapper = rowMapper;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.web.mappings.servlet.FilterRegistrationMappingDescription.getServletNameMappings",
	"Comment": "returns the servlet name mappings for the registered filter.",
	"Method": "Collection<String> getServletNameMappings(){\r\n    return this.getRegistration().getServletNameMappings();\r\n}"
}, {
	"Path": "org.springframework.boot.ant.FindMainClass.setMainClass",
	"Comment": "set the main class, which will cause the search to be bypassed.",
	"Method": "void setMainClass(String mainClass){\r\n    this.mainClass = mainClass;\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.HibernateCursorItemReaderBuilder.parameterValues",
	"Comment": "a map of parameter values to be set on the query. the key of the map is the name\tof the parameter to be set with the value being the value to be set.",
	"Method": "HibernateCursorItemReaderBuilder<T> parameterValues(Map<String, Object> parameterValues){\r\n    this.parameterValues = parameterValues;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.JsonContentAssert.extractingJsonPathNumberValue",
	"Comment": "extract the number value at the given json path for further object assertions.",
	"Method": "AbstractObjectAssert<?, Number> extractingJsonPathNumberValue(CharSequence expression,Object args){\r\n    return Assertions.assertThat(extractingJsonPathValue(expression, args, Number.class, \"a number\"));\r\n}"
}, {
	"Path": "org.springframework.batch.item.support.CompositeItemWriterTests.testProcess",
	"Comment": "regular usage scenario. all injected processors should be called.",
	"Method": "void testProcess(){\r\n    final int NUMBER_OF_WRITERS = 10;\r\n    List<Object> data = Collections.singletonList(new Object());\r\n    List<ItemWriter<? super Object>> writers = new ArrayList();\r\n    for (int i = 0; i < NUMBER_OF_WRITERS; i++) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        ItemWriter<? super Object> writer = mock(ItemWriter.class);\r\n        writer.write(data);\r\n        writers.add(writer);\r\n    }\r\n    itemWriter.setDelegates(writers);\r\n    itemWriter.write(data);\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.AbstractFilterRegistrationBean.setUrlPatterns",
	"Comment": "set the url patterns that the filter will be registered against. this will replace\tany previously specified url patterns.",
	"Method": "void setUrlPatterns(Collection<String> urlPatterns){\r\n    Assert.notNull(urlPatterns, \"UrlPatterns must not be null\");\r\n    this.urlPatterns = new LinkedHashSet(urlPatterns);\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.HibernatePagingItemReader.setFetchSize",
	"Comment": "fetch size used internally by hibernate to limit amount of data fetched\tfrom database per round trip.",
	"Method": "void setFetchSize(int fetchSize){\r\n    this.fetchSize = fetchSize;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.builder.FlatFileItemReaderBuilder.addComment",
	"Comment": "add a string to the list of strings that indicate commented lines.",
	"Method": "FlatFileItemReaderBuilder<T> addComment(String comment){\r\n    this.comments.add(comment);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.FlatFileItemReader.setLineMapper",
	"Comment": "setter for line mapper. this property is required to be set.",
	"Method": "void setLineMapper(LineMapper<T> lineMapper){\r\n    this.lineMapper = lineMapper;\r\n}"
}, {
	"Path": "org.springframework.boot.SpringApplication.registerLoggedException",
	"Comment": "register that the given exception has been logged. by default, if the running in\tthe main thread, this method will suppress additional printing of the stacktrace.",
	"Method": "void registerLoggedException(Throwable exception){\r\n    SpringBootExceptionHandler handler = getSpringBootExceptionHandler();\r\n    if (handler != null) {\r\n        handler.registerLoggedException(exception);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.support.PropertiesConverterTests.testPropertiesToStringNull",
	"Comment": "null or empty properties should be converted to empty string",
	"Method": "void testPropertiesToStringNull(){\r\n    string = PropertiesConverter.propertiesToString(null);\r\n    assertEquals(\"\", string);\r\n    string = PropertiesConverter.propertiesToString(new Properties());\r\n    assertEquals(\"\", string);\r\n}"
}, {
	"Path": "org.springframework.boot.context.annotation.Configurations.merge",
	"Comment": "merge configurations from another source of the same type.",
	"Method": "Configurations merge(Configurations other,Configurations merge,Set<Class<?>> mergedClasses){\r\n    Set<Class<?>> mergedClasses = new LinkedHashSet(getClasses());\r\n    mergedClasses.addAll(other.getClasses());\r\n    return merge(mergedClasses);\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.MultiResourceItemWriter.setItemCountLimitPerResource",
	"Comment": "after this limit is exceeded the next chunk will be written into newly\tcreated resource.",
	"Method": "void setItemCountLimitPerResource(int itemCountLimitPerResource){\r\n    this.itemCountLimitPerResource = itemCountLimitPerResource;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet.CloudFoundrySecurityService.getAccessLevel",
	"Comment": "return the access level that should be granted to the given token.",
	"Method": "AccessLevel getAccessLevel(String token,String applicationId){\r\n    try {\r\n        URI uri = getPermissionsUri(applicationId);\r\n        RequestEntity<?> request = RequestEntity.get(uri).header(\"Authorization\", \"bearer \" + token).build();\r\n        Map<?, ?> body = this.restTemplate.exchange(request, Map.class).getBody();\r\n        if (Boolean.TRUE.equals(body.get(\"read_sensitive_data\"))) {\r\n            return AccessLevel.FULL;\r\n        }\r\n        return AccessLevel.RESTRICTED;\r\n    } catch (HttpClientErrorException ex) {\r\n        if (ex.getStatusCode().equals(HttpStatus.FORBIDDEN)) {\r\n            throw new CloudFoundryAuthorizationException(Reason.ACCESS_DENIED, \"Access denied\");\r\n        }\r\n        throw new CloudFoundryAuthorizationException(Reason.INVALID_TOKEN, \"Invalid token\", ex);\r\n    } catch (HttpServerErrorException ex) {\r\n        throw new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE, \"Cloud controller not reachable\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.JsonContentAssert.isEqualToJson",
	"Comment": "verifies that the actual value is equal to the specified json resource.",
	"Method": "JsonContentAssert isEqualToJson(CharSequence expected,JsonContentAssert isEqualToJson,String path,Class<?> resourceLoadClass,JsonContentAssert isEqualToJson,byte[] expected,JsonContentAssert isEqualToJson,File expected,JsonContentAssert isEqualToJson,InputStream expected,JsonContentAssert isEqualToJson,Resource expected,JsonContentAssert isEqualToJson,CharSequence expected,JSONCompareMode compareMode,JsonContentAssert isEqualToJson,String path,Class<?> resourceLoadClass,JSONCompareMode compareMode,JsonContentAssert isEqualToJson,byte[] expected,JSONCompareMode compareMode,JsonContentAssert isEqualToJson,File expected,JSONCompareMode compareMode,JsonContentAssert isEqualToJson,InputStream expected,JSONCompareMode compareMode,JsonContentAssert isEqualToJson,Resource expected,JSONCompareMode compareMode,JsonContentAssert isEqualToJson,CharSequence expected,JSONComparator comparator,JsonContentAssert isEqualToJson,String path,Class<?> resourceLoadClass,JSONComparator comparator,JsonContentAssert isEqualToJson,byte[] expected,JSONComparator comparator,JsonContentAssert isEqualToJson,File expected,JSONComparator comparator,JsonContentAssert isEqualToJson,InputStream expected,JSONComparator comparator,JsonContentAssert isEqualToJson,Resource expected,JSONComparator comparator){\r\n    String expectedJson = this.loader.getJson(expected);\r\n    return assertNotFailed(compare(expectedJson, comparator));\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.AbstractFilterRegistrationBean.getUrlPatterns",
	"Comment": "return a mutable collection of url patterns, as defined in the servlet\tspecification, that the filter will be registered against.",
	"Method": "Collection<String> getUrlPatterns(){\r\n    return this.urlPatterns;\r\n}"
}, {
	"Path": "org.springframework.batch.item.support.AbstractFileItemWriter.open",
	"Comment": "initialize the reader. this method may be called multiple times before\tclose is called.",
	"Method": "void open(ExecutionContext executionContext){\r\n    super.open(executionContext);\r\n    Assert.notNull(resource, \"The resource must be set\");\r\n    if (!getOutputState().isInitialized()) {\r\n        doOpen(executionContext);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.DynamicRegistrationBean.isAsyncSupported",
	"Comment": "returns if asynchronous operations are supported for this registration.",
	"Method": "boolean isAsyncSupported(){\r\n    return this.asyncSupported;\r\n}"
}, {
	"Path": "org.springframework.boot.test.context.SpringBootTestContextBootstrapper.processPropertySourceProperties",
	"Comment": "post process the property source properties, adding or removing elements as\trequired.",
	"Method": "void processPropertySourceProperties(MergedContextConfiguration mergedConfig,List<String> propertySourceProperties){\r\n    Class<?> testClass = mergedConfig.getTestClass();\r\n    String[] properties = getProperties(testClass);\r\n    if (!ObjectUtils.isEmpty(properties)) {\r\n        propertySourceProperties.addAll(0, Arrays.asList(properties));\r\n    }\r\n    if (getWebEnvironment(testClass) == WebEnvironment.RANDOM_PORT) {\r\n        propertySourceProperties.add(\"server.port=0\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.web.servlet.JerseyApplicationPath.getPrefix",
	"Comment": "return a cleaned up version of the path that can be used as a prefix for urls. the\tresulting path will have path will not have a trailing slash.",
	"Method": "String getPrefix(){\r\n    String result = getPath();\r\n    int index = result.indexOf('*');\r\n    if (index != -1) {\r\n        result = result.substring(0, index);\r\n    }\r\n    if (result.endsWith(\"/\")) {\r\n        result = result.substring(0, result.length() - 1);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.builder.Neo4jItemReaderBuilder.orderByStatement",
	"Comment": "a list of properties to order the results by. this is required so that subsequent\tpage requests pull back the segment of results correctly. order by is prepended to\tthe statement provided and should not be included.",
	"Method": "Neo4jItemReaderBuilder<T> orderByStatement(String orderByStatement){\r\n    this.orderByStatement = orderByStatement;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.policy.TimeoutTerminationPolicy.isComplete",
	"Comment": "check the timeout and complete gracefully if it has expires.",
	"Method": "boolean isComplete(RepeatContext context,boolean isComplete){\r\n    return ((TimeoutBatchContext) context).isComplete();\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.mapping.PropertyMatches.buildErrorMessage",
	"Comment": "build an error message for the given invalid property name,\tindicating the possible property matches.",
	"Method": "String buildErrorMessage(){\r\n    StringBuilder buf = new StringBuilder();\r\n    buf.append(\"Bean property '\");\r\n    buf.append(this.propertyName);\r\n    buf.append(\"' is not writable or has an invalid setter method. \");\r\n    if (ObjectUtils.isEmpty(this.possibleMatches)) {\r\n        buf.append(\"Does the parameter type of the setter match the return type of the getter?\");\r\n    } else {\r\n        buf.append(\"Did you mean \");\r\n        for (int i = 0; i < this.possibleMatches.length; i++) {\r\n            buf.append('\\'');\r\n            buf.append(this.possibleMatches[i]);\r\n            if (i < this.possibleMatches.length - 2) {\r\n                buf.append(\"', \");\r\n            } else if (i == this.possibleMatches.length - 2) {\r\n                buf.append(\"', or \");\r\n            }\r\n        }\r\n        buf.append(\"'?\");\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.JpaPagingItemReaderBuilder.currentItemCount",
	"Comment": "index for the current item. used on restarts to indicate where to start from.",
	"Method": "JpaPagingItemReaderBuilder<T> currentItemCount(int currentItemCount){\r\n    this.currentItemCount = currentItemCount;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.SimpleRepeatTemplateTests.testEarlyCompletionWithException",
	"Comment": "check that a dedicated terminationpolicy can terminate the batch.",
	"Method": "void testEarlyCompletionWithException(){\r\n    try {\r\n        template.iterate(new RepeatCallback() {\r\n            @Override\r\n            public RepeatStatus doInIteration(RepeatContext context) throws Exception {\r\n                count++;\r\n                throw new IllegalStateException(\"foo!\");\r\n            }\r\n        });\r\n        fail(\"Expected IllegalStateException\");\r\n    } catch (IllegalStateException e) {\r\n        assertEquals(\"foo!\", e.getMessage());\r\n    }\r\n    assertEquals(1, count);\r\n    assertTrue(\"Too many attempts: \" + count, count <= 10);\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.SimpleRepeatTemplateTests.testEarlyCompletionWithException",
	"Comment": "check that a dedicated terminationpolicy can terminate the batch.",
	"Method": "void testEarlyCompletionWithException(){\r\n    count++;\r\n    throw new IllegalStateException(\"foo!\");\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.builder.Neo4jItemReaderBuilder.startStatement",
	"Comment": "the start segment of the cypher query. start is prepended to the statement provided\tand should not be included.",
	"Method": "Neo4jItemReaderBuilder<T> startStatement(String startStatement){\r\n    this.startStatement = startStatement;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BindResult.orElseThrow",
	"Comment": "return the object that was bound, or throw an exception to be created by the\tprovided supplier if no value has been bound.",
	"Method": "T orElseThrow(Supplier<? extends X> exceptionSupplier){\r\n    if (this.value == null) {\r\n        throw exceptionSupplier.get();\r\n    }\r\n    return this.value;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.builder.MultiResourceItemWriterBuilder.resourceSuffixCreator",
	"Comment": "allows customization of the suffix of the created resources based on the index.",
	"Method": "MultiResourceItemWriterBuilder<T> resourceSuffixCreator(ResourceSuffixCreator suffixCreator){\r\n    this.suffixCreator = suffixCreator;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.Neo4jItemWriter.doWrite",
	"Comment": "performs the actual write using the template.this can be overridden by\ta subclass if necessary.",
	"Method": "void doWrite(List<? extends T> items){\r\n    if (delete) {\r\n        delete(items);\r\n    } else {\r\n        save(items);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.test.StepRunner.launchStep",
	"Comment": "launch just the specified step as its own job. an illegalstateexception\tis thrown if there is no step with the given name.",
	"Method": "JobExecution launchStep(Step step,JobExecution launchStep,Step step,ExecutionContext jobExecutionContext,JobExecution launchStep,Step step,JobParameters jobParameters,JobExecution launchStep,Step step,JobParameters jobParameters,ExecutionContext jobExecutionContext){\r\n    SimpleJob job = new SimpleJob();\r\n    job.setName(\"TestJob\");\r\n    job.setJobRepository(this.jobRepository);\r\n    List<Step> stepsToExecute = new ArrayList();\r\n    stepsToExecute.add(step);\r\n    job.setSteps(stepsToExecute);\r\n    if (jobExecutionContext != null && !jobExecutionContext.isEmpty()) {\r\n        job.setJobExecutionListeners(new JobExecutionListener[] { new JobExecutionListenerSupport() {\r\n            @Override\r\n            public void beforeJob(JobExecution jobExecution) {\r\n                ExecutionContext jobContext = jobExecution.getExecutionContext();\r\n                for (Map.Entry<String, Object> entry : jobExecutionContext.entrySet()) {\r\n                    jobContext.put(entry.getKey(), entry.getValue());\r\n                }\r\n            }\r\n        } });\r\n    }\r\n    return this.launchJob(job, jobParameters);\r\n}"
}, {
	"Path": "org.springframework.batch.test.StepRunner.launchStep",
	"Comment": "launch just the specified step as its own job. an illegalstateexception\tis thrown if there is no step with the given name.",
	"Method": "JobExecution launchStep(Step step,JobExecution launchStep,Step step,ExecutionContext jobExecutionContext,JobExecution launchStep,Step step,JobParameters jobParameters,JobExecution launchStep,Step step,JobParameters jobParameters,ExecutionContext jobExecutionContext){\r\n    ExecutionContext jobContext = jobExecution.getExecutionContext();\r\n    for (Map.Entry<String, Object> entry : jobExecutionContext.entrySet()) {\r\n        jobContext.put(entry.getKey(), entry.getValue());\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.core.step.tasklet.TaskletStepTests.testStepExecutionUpdates",
	"Comment": "stepexecution should be updated after every chunk commit.",
	"Method": "void testStepExecutionUpdates(){\r\n    JobExecution jobExecution = new JobExecution(jobInstance, jobParameters);\r\n    StepExecution stepExecution = new StepExecution(step.getName(), jobExecution);\r\n    step.setStepOperations(new RepeatTemplate());\r\n    JobRepositoryStub jobRepository = new JobRepositoryStub();\r\n    step.setJobRepository(jobRepository);\r\n    step.execute(stepExecution);\r\n    assertEquals(3, processed.size());\r\n    assertEquals(3, stepExecution.getReadCount());\r\n    assertTrue(3 <= jobRepository.updateCount);\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.builder.Neo4jItemReaderBuilder.currentItemCount",
	"Comment": "index for the current item. used on restarts to indicate where to start from.",
	"Method": "Neo4jItemReaderBuilder<T> currentItemCount(int currentItemCount){\r\n    this.currentItemCount = currentItemCount;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.FlatFileItemReader.setComments",
	"Comment": "setter for comment prefixes. can be used to ignore header lines as well by using e.g. the first couple of column\tnames as a prefix.",
	"Method": "void setComments(String[] comments){\r\n    this.comments = new String[comments.length];\r\n    System.arraycopy(comments, 0, this.comments, 0, comments.length);\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.endpoint.invoker.cache.CachingOperationInvoker.getTimeToLive",
	"Comment": "return the maximum time in milliseconds that a response can be cached.",
	"Method": "long getTimeToLive(){\r\n    return this.timeToLive;\r\n}"
}, {
	"Path": "org.springframework.boot.builder.ParentContextCloserApplicationListener.createContextCloserListener",
	"Comment": "subclasses may override to create their own subclass of contextcloserlistener. this\tstill enforces the use of a weak reference.",
	"Method": "ContextCloserListener createContextCloserListener(ConfigurableApplicationContext child){\r\n    return new ContextCloserListener(child);\r\n}"
}, {
	"Path": "org.springframework.batch.item.support.CompositeItemProcessorTests.testItemProcessorGenerics",
	"Comment": "test that the compositeitemprocessor can work with generic types for the itemprocessor delegates.",
	"Method": "void testItemProcessorGenerics(){\r\n    CompositeItemProcessor<String, String> composite = new CompositeItemProcessor();\r\n    final ItemProcessor<String, Integer> processor1 = mock(ItemProcessor.class);\r\n    final ItemProcessor<Integer, String> processor2 = mock(ItemProcessor.class);\r\n    composite.setDelegates(new ArrayList<ItemProcessor<?, ?>>() {\r\n        {\r\n            add(processor1);\r\n            add(processor2);\r\n        }\r\n    });\r\n    composite.afterPropertiesSet();\r\n    when(processor1.process(\"input\")).thenReturn(5);\r\n    when(processor2.process(5)).thenReturn(\"output\");\r\n    assertEquals(\"output\", composite.process(\"input\"));\r\n}"
}, {
	"Path": "org.springframework.boot.jta.atomikos.AtomikosProperties.setForceShutdownOnVmExit",
	"Comment": "specifies whether vm shutdown should trigger forced shutdown of the transaction\tcore. defaults to false.",
	"Method": "void setForceShutdownOnVmExit(boolean forceShutdownOnVmExit){\r\n    this.forceShutdownOnVmExit = forceShutdownOnVmExit;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.builder.Neo4jItemWriterBuilder.delete",
	"Comment": "boolean flag indicating whether the writer should save or delete the item at write\ttime.",
	"Method": "Neo4jItemWriterBuilder<T> delete(boolean delete){\r\n    this.delete = delete;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.core.step.tasklet.SystemCommandTaskletIntegrationTests.testExecuteException",
	"Comment": "the attempt to execute the system command results in exception",
	"Method": "void testExecuteException(){\r\n    String command = \"non-sense-that-should-cause-exception-when-attempted-to-execute\";\r\n    tasklet.setCommand(command);\r\n    tasklet.afterPropertiesSet();\r\n    tasklet.execute(null, null);\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.separator.SuffixRecordSeparatorPolicy.isEndOfRecord",
	"Comment": "return true if the line ends with the specified substring. by default\twhitespace is trimmed before the comparison. also returns true if the\tline is null, but not if it is empty.",
	"Method": "boolean isEndOfRecord(String line){\r\n    if (line == null) {\r\n        return true;\r\n    }\r\n    String trimmed = ignoreWhitespace ? line.trim() : line;\r\n    return trimmed.endsWith(suffix);\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.AggregateElementBinder.bind",
	"Comment": "bind the given name to a target bindable using optionally limited to a single\tsource.",
	"Method": "Object bind(ConfigurationPropertyName name,Bindable<?> target,Object bind,ConfigurationPropertyName name,Bindable<?> target,ConfigurationPropertySource source){\r\n    return bind(name, target, null);\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.AbstractNeo4jItemReader.setReturnStatement",
	"Comment": "the return statement of the cypher query.return is prepended\tto the statement provided and should not be\tincluded",
	"Method": "void setReturnStatement(String returnStatement){\r\n    this.returnStatement = returnStatement;\r\n}"
}, {
	"Path": "org.springframework.boot.context.annotation.Configurations.getClasses",
	"Comment": "return the classes from all the specified configurations in the order that they\twould be registered.",
	"Method": "Set<Class<?>> getClasses(Class<?>[] getClasses,Configurations configurations,Class<?>[] getClasses,Collection<Configurations> configurations){\r\n    List<Configurations> ordered = new ArrayList(configurations);\r\n    ordered.sort(COMPARATOR);\r\n    List<Configurations> collated = collate(ordered);\r\n    LinkedHashSet<Class<?>> classes = collated.stream().flatMap(Configurations::streamClasses).collect(Collectors.toCollection(LinkedHashSet::new));\r\n    return ClassUtils.toClassArray(classes);\r\n}"
}, {
	"Path": "org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getTldSkipPatterns",
	"Comment": "returns a mutable set of the patterns that match jars to ignore for tld scanning.",
	"Method": "Set<String> getTldSkipPatterns(){\r\n    return this.tldSkipPatterns;\r\n}"
}, {
	"Path": "org.springframework.batch.item.json.builder.JsonFileItemWriterBuilder.shouldDeleteIfExists",
	"Comment": "if set to true, upon the start of the step, if the resource already exists, it will\tbe deleted and recreated.",
	"Method": "JsonFileItemWriterBuilder<T> shouldDeleteIfExists(boolean shouldDelete){\r\n    this.shouldDeleteIfExists = shouldDelete;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.mapping.PropertyMatches.calculateStringDistance",
	"Comment": "calculate the distance between the given two strings\taccording to the levenshtein algorithm.",
	"Method": "int calculateStringDistance(String s1,String s2){\r\n    if (s1.length() == 0) {\r\n        return s2.length();\r\n    }\r\n    if (s2.length() == 0) {\r\n        return s1.length();\r\n    }\r\n    int[][] d = new int[s1.length() + 1][s2.length() + 1];\r\n    for (int i = 0; i <= s1.length(); i++) {\r\n        d[i][0] = i;\r\n    }\r\n    for (int j = 0; j <= s2.length(); j++) {\r\n        d[0][j] = j;\r\n    }\r\n    for (int i = 1; i <= s1.length(); i++) {\r\n        char s_i = s1.charAt(i - 1);\r\n        for (int j = 1; j <= s2.length(); j++) {\r\n            int cost;\r\n            char t_j = s2.charAt(j - 1);\r\n            if (Character.toLowerCase(s_i) == Character.toLowerCase(t_j)) {\r\n                cost = 0;\r\n            } else {\r\n                cost = 1;\r\n            }\r\n            d[i][j] = Math.min(Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1), d[i - 1][j - 1] + cost);\r\n        }\r\n    }\r\n    return d[s1.length()][s2.length()];\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.RepositoryItemReader.doPageRead",
	"Comment": "performs the actual reading of a page via the repository.\tavailable for overriding as needed.",
	"Method": "List<T> doPageRead(){\r\n    Pageable pageRequest = PageRequest.of(page, pageSize, sort);\r\n    MethodInvoker invoker = createMethodInvoker(repository, methodName);\r\n    List<Object> parameters = new ArrayList();\r\n    if (arguments != null && arguments.size() > 0) {\r\n        parameters.addAll(arguments);\r\n    }\r\n    parameters.add(pageRequest);\r\n    invoker.setArguments(parameters.toArray());\r\n    Page<T> curPage = (Page<T>) doInvoke(invoker);\r\n    return curPage.getContent();\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.ConfigurationPropertiesBindException.getAnnotation",
	"Comment": "return the configuration properties annotation that triggered the binding.",
	"Method": "ConfigurationProperties getAnnotation(){\r\n    return this.annotation;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.policy.CountingCompletionPolicy.setUseParent",
	"Comment": "flag to indicate whether the count is at the level of the parent context,\tor just local to the context. if true then the count is aggregated among\tsiblings in a nested batch.",
	"Method": "void setUseParent(boolean useParent){\r\n    this.useParent = useParent;\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.ExternalRetryTests.testExternalRetrySuccessOnSecondAttempt",
	"Comment": "message processing is successful on the second attempt but must receive\tthe message again.",
	"Method": "void testExternalRetrySuccessOnSecondAttempt(){\r\n    assertInitialState();\r\n    final ItemWriter<Object> writer = new ItemWriter<Object>() {\r\n        @Override\r\n        public void write(final List<?> texts) {\r\n            for (Object text : texts) {\r\n                jdbcTemplate.update(\"INSERT into T_BARS (id,name,foo_date) values (?,?,null)\", list.size(), text);\r\n                if (list.size() == 1) {\r\n                    throw new RuntimeException(\"Rollback!\");\r\n                }\r\n            }\r\n        }\r\n    };\r\n    try {\r\n        new TransactionTemplate(transactionManager).execute(new TransactionCallback<Object>() {\r\n            @Override\r\n            public Object doInTransaction(TransactionStatus status) {\r\n                try {\r\n                    final Object item = provider.read();\r\n                    RetryCallback<Object, Exception> callback = new RetryCallback<Object, Exception>() {\r\n                        @Override\r\n                        public Object doWithRetry(RetryContext context) throws Exception {\r\n                            writer.write(Collections.singletonList(item));\r\n                            return null;\r\n                        }\r\n                    };\r\n                    return retryTemplate.execute(callback, new DefaultRetryState(item));\r\n                } catch (Exception e) {\r\n                    throw new RuntimeException(e.getMessage(), e);\r\n                }\r\n            }\r\n        });\r\n        fail(\"Expected Exception\");\r\n    } catch (Exception e) {\r\n        assertEquals(\"Rollback!\", e.getMessage());\r\n    }\r\n    new TransactionTemplate(transactionManager).execute(new TransactionCallback<Object>() {\r\n        @Override\r\n        public Object doInTransaction(TransactionStatus status) {\r\n            try {\r\n                final String item = provider.read();\r\n                RetryCallback<Object, Exception> callback = new RetryCallback<Object, Exception>() {\r\n                    @Override\r\n                    public Object doWithRetry(RetryContext context) throws Exception {\r\n                        writer.write(Collections.singletonList(item));\r\n                        return null;\r\n                    }\r\n                };\r\n                return retryTemplate.execute(callback, new DefaultRetryState(item));\r\n            } catch (Exception e) {\r\n                throw new RuntimeException(e.getMessage(), e);\r\n            }\r\n        }\r\n    });\r\n    List<String> msgs = getMessages();\r\n    int count = jdbcTemplate.queryForObject(\"select count(*) from T_BARS\", Integer.class);\r\n    assertEquals(1, count);\r\n    assertEquals(\"[]\", msgs.toString());\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.ExternalRetryTests.testExternalRetrySuccessOnSecondAttempt",
	"Comment": "message processing is successful on the second attempt but must receive\tthe message again.",
	"Method": "void testExternalRetrySuccessOnSecondAttempt(){\r\n    for (Object text : texts) {\r\n        jdbcTemplate.update(\"INSERT into T_BARS (id,name,foo_date) values (?,?,null)\", list.size(), text);\r\n        if (list.size() == 1) {\r\n            throw new RuntimeException(\"Rollback!\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.ExternalRetryTests.testExternalRetrySuccessOnSecondAttempt",
	"Comment": "message processing is successful on the second attempt but must receive\tthe message again.",
	"Method": "void testExternalRetrySuccessOnSecondAttempt(){\r\n    try {\r\n        final Object item = provider.read();\r\n        RetryCallback<Object, Exception> callback = new RetryCallback<Object, Exception>() {\r\n            @Override\r\n            public Object doWithRetry(RetryContext context) throws Exception {\r\n                writer.write(Collections.singletonList(item));\r\n                return null;\r\n            }\r\n        };\r\n        return retryTemplate.execute(callback, new DefaultRetryState(item));\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.ExternalRetryTests.testExternalRetrySuccessOnSecondAttempt",
	"Comment": "message processing is successful on the second attempt but must receive\tthe message again.",
	"Method": "void testExternalRetrySuccessOnSecondAttempt(){\r\n    writer.write(Collections.singletonList(item));\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.ExternalRetryTests.testExternalRetrySuccessOnSecondAttempt",
	"Comment": "message processing is successful on the second attempt but must receive\tthe message again.",
	"Method": "void testExternalRetrySuccessOnSecondAttempt(){\r\n    try {\r\n        final String item = provider.read();\r\n        RetryCallback<Object, Exception> callback = new RetryCallback<Object, Exception>() {\r\n            @Override\r\n            public Object doWithRetry(RetryContext context) throws Exception {\r\n                writer.write(Collections.singletonList(item));\r\n                return null;\r\n            }\r\n        };\r\n        return retryTemplate.execute(callback, new DefaultRetryState(item));\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.ExternalRetryTests.testExternalRetrySuccessOnSecondAttempt",
	"Comment": "message processing is successful on the second attempt but must receive\tthe message again.",
	"Method": "void testExternalRetrySuccessOnSecondAttempt(){\r\n    writer.write(Collections.singletonList(item));\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.boot.system.ApplicationTemp.getDir",
	"Comment": "return the directory to be used for application specific temp files.",
	"Method": "File getDir(String subDir,File getDir){\r\n    if (this.dir == null) {\r\n        synchronized (this) {\r\n            byte[] hash = generateHash(this.sourceClass);\r\n            this.dir = new File(getTempDirectory(), toHexString(hash));\r\n            this.dir.mkdirs();\r\n            Assert.state(this.dir.exists(), () -> \"Unable to create temp directory \" + this.dir);\r\n        }\r\n    }\r\n    return this.dir;\r\n}"
}, {
	"Path": "org.springframework.batch.item.support.AbstractFileItemWriter.setResource",
	"Comment": "setter for resource. represents a file that can be written.",
	"Method": "void setResource(Resource resource){\r\n    this.resource = resource;\r\n}"
}, {
	"Path": "org.springframework.batch.integration.chunk.RemoteChunkingWorkerBuilder.outputChannel",
	"Comment": "set the output channel on which replies will be sent to the master step.",
	"Method": "RemoteChunkingWorkerBuilder<I, O> outputChannel(MessageChannel outputChannel){\r\n    Assert.notNull(outputChannel, \"outputChannel must not be null\");\r\n    this.outputChannel = outputChannel;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.support.transaction.TransactionAwareProxyFactory.commit",
	"Comment": "take the working copy state and commit it back to the original target.\tthe target then reflects all the changes applied to the copy during a\ttransaction.",
	"Method": "void commit(T copy,T target){\r\n    synchronized (target) {\r\n        if (target instanceof Collection) {\r\n            if (!appendOnly) {\r\n                ((Collection) target).clear();\r\n            }\r\n            ((Collection) target).addAll((Collection) copy);\r\n        } else {\r\n            if (!appendOnly) {\r\n                ((Map) target).clear();\r\n            }\r\n            ((Map) target).putAll((Map) copy);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.cli.command.init.ProjectGenerationRequest.isDetectType",
	"Comment": "whether or not the type should be detected based on the build and format value.",
	"Method": "boolean isDetectType(){\r\n    return this.detectType;\r\n}"
}, {
	"Path": "org.springframework.batch.item.ldif.MappingLdifReader.setRecordMapper",
	"Comment": "setter for object mapper. this property is required to be set.",
	"Method": "void setRecordMapper(RecordMapper<T> recordMapper){\r\n    this.recordMapper = recordMapper;\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.AbstractFilterRegistrationBean.getServletNames",
	"Comment": "return a mutable collection of servlet names that the filter will be registered\tagainst.",
	"Method": "Collection<String> getServletNames(){\r\n    return this.servletNames;\r\n}"
}, {
	"Path": "org.springframework.batch.core.step.tasklet.AsyncTaskletStepTests.testStepExecutionFailsWithProcessor",
	"Comment": "stepexecution should fail immediately on error in processor.",
	"Method": "void testStepExecutionFailsWithProcessor(){\r\n    throttleLimit = 1;\r\n    concurrencyLimit = 1;\r\n    items = Arrays.asList(\"one\", \"barf\", \"three\", \"four\");\r\n    itemProcessor = new ItemProcessor<String, String>() {\r\n        @Override\r\n        public String process(String item) throws Exception {\r\n            logger.info(\"Item: \" + item);\r\n            processed.add(item);\r\n            if (item.equals(\"barf\")) {\r\n                throw new RuntimeException(\"Planned processor error\");\r\n            }\r\n            return item;\r\n        }\r\n    };\r\n    setUp();\r\n    JobExecution jobExecution = jobRepository.createJobExecution(\"JOB\", new JobParameters());\r\n    StepExecution stepExecution = jobExecution.createStepExecution(step.getName());\r\n    step.execute(stepExecution);\r\n    assertEquals(BatchStatus.FAILED, stepExecution.getStatus());\r\n    assertEquals(2, stepExecution.getReadCount());\r\n    assertEquals(2, processed.size());\r\n}"
}, {
	"Path": "org.springframework.batch.core.step.tasklet.AsyncTaskletStepTests.testStepExecutionFailsWithProcessor",
	"Comment": "stepexecution should fail immediately on error in processor.",
	"Method": "void testStepExecutionFailsWithProcessor(){\r\n    logger.info(\"Item: \" + item);\r\n    processed.add(item);\r\n    if (item.equals(\"barf\")) {\r\n        throw new RuntimeException(\"Planned processor error\");\r\n    }\r\n    return item;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.Neo4jItemWriter.setDelete",
	"Comment": "boolean flag indicating whether the writer should save or delete the item at write\ttime.",
	"Method": "void setDelete(boolean delete){\r\n    this.delete = delete;\r\n}"
}, {
	"Path": "org.springframework.batch.item.json.builder.JsonItemReaderBuilder.strict",
	"Comment": "setting this value to true indicates that it is an error if the input\tdoes not exist and an exception will be thrown. defaults to true.",
	"Method": "JsonItemReaderBuilder<T> strict(boolean strict){\r\n    this.strict = strict;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.support.RepeatTemplate.iterate",
	"Comment": "execute the batch callback until the completion policy decides that we\tare finished. wait for the whole batch to finish before returning even if\tthe task executor is asynchronous.",
	"Method": "RepeatStatus iterate(RepeatCallback callback){\r\n    RepeatContext outer = RepeatSynchronizationManager.getContext();\r\n    RepeatStatus result = RepeatStatus.CONTINUABLE;\r\n    try {\r\n        result = executeInternal(callback);\r\n    } finally {\r\n        RepeatSynchronizationManager.clear();\r\n        if (outer != null) {\r\n            RepeatSynchronizationManager.register(outer);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.batch.support.MethodInvokerUtils.getMethodInvokerByAnnotation",
	"Comment": "create a methodinvoker from the delegate based on the annotationtype.\tensure that the annotated method has a valid set of parameters.",
	"Method": "MethodInvoker getMethodInvokerByAnnotation(Class<? extends Annotation> annotationType,Object target,Class<?> expectedParamTypes,MethodInvoker getMethodInvokerByAnnotation,Class<? extends Annotation> annotationType,Object target){\r\n    Assert.notNull(target, \"Target must not be null\");\r\n    Assert.notNull(annotationType, \"AnnotationType must not be null\");\r\n    Assert.isTrue(ObjectUtils.containsElement(annotationType.getAnnotation(Target.class).value(), ElementType.METHOD), \"Annotation [\" + annotationType + \"] is not a Method-level annotation.\");\r\n    final Class<?> targetClass = (target instanceof Advised) ? ((Advised) target).getTargetSource().getTargetClass() : target.getClass();\r\n    if (targetClass == null) {\r\n        return null;\r\n    }\r\n    final AtomicReference<Method> annotatedMethod = new AtomicReference();\r\n    ReflectionUtils.doWithMethods(targetClass, method -> {\r\n        Annotation annotation = AnnotationUtils.findAnnotation(method, annotationType);\r\n        if (annotation != null) {\r\n            Assert.isNull(annotatedMethod.get(), \"found more than one method on target class [\" + targetClass.getSimpleName() + \"] with the annotation type [\" + annotationType.getSimpleName() + \"].\");\r\n            annotatedMethod.set(method);\r\n        }\r\n    });\r\n    Method method = annotatedMethod.get();\r\n    if (method == null) {\r\n        return null;\r\n    } else {\r\n        return new SimpleMethodInvoker(target, annotatedMethod.get());\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.AbstractFilterRegistrationBean.isMatchAfter",
	"Comment": "return if filter mappings should be matched after any declared filter mappings of\tthe servletcontext.",
	"Method": "boolean isMatchAfter(){\r\n    return this.matchAfter;\r\n}"
}, {
	"Path": "org.springframework.boot.SpringApplication.setWebApplicationType",
	"Comment": "sets the type of web application to be run. if not explicitly set the type of web\tapplication will be deduced based on the classpath.",
	"Method": "void setWebApplicationType(WebApplicationType webApplicationType){\r\n    Assert.notNull(webApplicationType, \"WebApplicationType must not be null\");\r\n    this.webApplicationType = webApplicationType;\r\n}"
}, {
	"Path": "org.springframework.batch.support.AnnotationMethodResolver.findMethod",
	"Comment": "find a single method on the given class that contains the\tannotation type for which this resolver is searching.",
	"Method": "Method findMethod(Object candidate,Method findMethod,Class<?> clazz){\r\n    Assert.notNull(clazz, \"class must not be null\");\r\n    final AtomicReference<Method> annotatedMethod = new AtomicReference();\r\n    ReflectionUtils.doWithMethods(clazz, new ReflectionUtils.MethodCallback() {\r\n        @Override\r\n        public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {\r\n            Annotation annotation = AnnotationUtils.findAnnotation(method, annotationType);\r\n            if (annotation != null) {\r\n                Assert.isNull(annotatedMethod.get(), \"found more than one method on target class [\" + clazz + \"] with the annotation type [\" + annotationType + \"]\");\r\n                annotatedMethod.set(method);\r\n            }\r\n        }\r\n    });\r\n    return annotatedMethod.get();\r\n}"
}, {
	"Path": "org.springframework.batch.support.AnnotationMethodResolver.findMethod",
	"Comment": "find a single method on the given class that contains the\tannotation type for which this resolver is searching.",
	"Method": "Method findMethod(Object candidate,Method findMethod,Class<?> clazz){\r\n    Annotation annotation = AnnotationUtils.findAnnotation(method, annotationType);\r\n    if (annotation != null) {\r\n        Assert.isNull(annotatedMethod.get(), \"found more than one method on target class [\" + clazz + \"] with the annotation type [\" + annotationType + \"]\");\r\n        annotatedMethod.set(method);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemWriterTests.testWriteRootTagWithAdditionalNamespace",
	"Comment": "item is written to the output file with additional namespaces and prefix.",
	"Method": "void testWriteRootTagWithAdditionalNamespace(){\r\n    writer.setRootTagName(\"{http://www.springframework.org/test}ns:root\");\r\n    marshaller.setNamespace(\"urn:org.test.foo\");\r\n    marshaller.setNamespacePrefix(\"foo\");\r\n    writer.setRootElementAttributes(Collections.singletonMap(\"xmlns:foo\", \"urn:org.test.foo\"));\r\n    writer.afterPropertiesSet();\r\n    writer.open(executionContext);\r\n    writer.write(items);\r\n    writer.close();\r\n    String content = getOutputFileContent();\r\n    assertTrue(\"Wrong content: \" + content, content.contains((\"<ns:root xmlns:ns=\\\"http://www.springframework.org/test\\\" \" + \"xmlns:foo=\\\"urn:org.test.foo\\\">\")));\r\n    assertTrue(\"Wrong content: \" + content, content.contains(FOO_TEST_STRING));\r\n    assertTrue(\"Wrong content: \" + content, content.contains((\"<\/ns:root>\")));\r\n    assertTrue(\"Wrong content: \" + content, content.contains((\"<ns:root\")));\r\n}"
}, {
	"Path": "org.springframework.batch.integration.chunk.RemoteChunkHandlerFactoryBean.setStep",
	"Comment": "the local step that is to be converted to a remote chunk master.",
	"Method": "void setStep(TaskletStep step){\r\n    this.step = step;\r\n}"
}, {
	"Path": "org.springframework.batch.item.amqp.builder.AmqpItemWriterBuilder.amqpTemplate",
	"Comment": "establish the amqptemplate to be used by the amqpitemwriter.",
	"Method": "AmqpItemWriterBuilder<T> amqpTemplate(AmqpTemplate amqpTemplate){\r\n    this.amqpTemplate = amqpTemplate;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper.setDistanceLimit",
	"Comment": "the maximum difference that can be tolerated in spelling between input\tkey names and bean property names. defaults to 5, but could be set lower\tif the field names match the bean names.",
	"Method": "void setDistanceLimit(int distanceLimit){\r\n    this.distanceLimit = distanceLimit;\r\n}"
}, {
	"Path": "org.springframework.boot.web.context.WebServerPortFileWriter.getPortFile",
	"Comment": "return the actual port file that should be written for the given application\tcontext. the default implementation builds a file from the source file and the\tapplication context namespace if available.",
	"Method": "File getPortFile(ApplicationContext applicationContext){\r\n    String namespace = getServerNamespace(applicationContext);\r\n    if (StringUtils.isEmpty(namespace)) {\r\n        return this.file;\r\n    }\r\n    String name = this.file.getName();\r\n    String extension = StringUtils.getFilenameExtension(this.file.getName());\r\n    name = name.substring(0, name.length() - extension.length() - 1);\r\n    if (isUpperCase(name)) {\r\n        name = name + \"-\" + namespace.toUpperCase(Locale.ENGLISH);\r\n    } else {\r\n        name = name + \"-\" + namespace.toLowerCase(Locale.ENGLISH);\r\n    }\r\n    if (StringUtils.hasLength(extension)) {\r\n        name = name + \".\" + extension;\r\n    }\r\n    return new File(this.file.getParentFile(), name);\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.exception.SimpleLimitExceptionHandlerTests.testNormalExceptionThrown",
	"Comment": "other than nominated exception type should be rethrown, ignoring the\texception limit.",
	"Method": "void testNormalExceptionThrown(){\r\n    Throwable throwable = new RuntimeException(\"foo\");\r\n    final int MORE_THAN_ZERO = 1;\r\n    handler.setLimit(MORE_THAN_ZERO);\r\n    handler.setExceptionClasses(Collections.<Class<? extends Throwable>>singleton(IllegalArgumentException.class));\r\n    handler.afterPropertiesSet();\r\n    try {\r\n        handler.handleException(new RepeatContextSupport(null), throwable);\r\n        fail(\"Exception was swallowed.\");\r\n    } catch (RuntimeException expected) {\r\n        assertTrue(\"Exception is rethrown, ignoring the exception limit\", true);\r\n        assertSame(expected, throwable);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.RepositoryItemWriter.write",
	"Comment": "write all items to the data store via a spring data repository.",
	"Method": "void write(List<? extends T> items){\r\n    if (!CollectionUtils.isEmpty(items)) {\r\n        doWrite(items);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.task.TaskSchedulerBuilder.threadNamePrefix",
	"Comment": "set the prefix to use for the names of newly created threads.",
	"Method": "TaskSchedulerBuilder threadNamePrefix(String threadNamePrefix){\r\n    return new TaskSchedulerBuilder(this.poolSize, threadNamePrefix, this.customizers);\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.JdbcParameterUtils.parameterNameContinues",
	"Comment": "determine whether a parameter name continues at the current position,\tthat is, does not end delimited by any whitespace character yet.",
	"Method": "boolean parameterNameContinues(char[] statement,int pos){\r\n    return (statement[pos] != ' ' && statement[pos] != ',' && statement[pos] != ')' && statement[pos] != '\"' && statement[pos] != '\\'' && statement[pos] != '|' && statement[pos] != ';' && statement[pos] != '\\n' && statement[pos] != '\\r');\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.support.SqlPagingQueryUtils.buildSortConditions",
	"Comment": "appends the where conditions required to query for the subsequent pages.",
	"Method": "void buildSortConditions(AbstractSqlPagingQueryProvider provider,StringBuilder sql){\r\n    List<Map.Entry<String, Order>> keys = new ArrayList(provider.getSortKeys().entrySet());\r\n    List<String> clauses = new ArrayList();\r\n    for (int i = 0; i < keys.size(); i++) {\r\n        StringBuilder clause = new StringBuilder();\r\n        String prefix = \"\";\r\n        for (int j = 0; j < i; j++) {\r\n            clause.append(prefix);\r\n            prefix = \" AND \";\r\n            Entry<String, Order> entry = keys.get(j);\r\n            clause.append(entry.getKey());\r\n            clause.append(\" = \");\r\n            clause.append(provider.getSortKeyPlaceHolder(entry.getKey()));\r\n        }\r\n        if (clause.length() > 0) {\r\n            clause.append(\" AND \");\r\n        }\r\n        clause.append(keys.get(i).getKey());\r\n        if (keys.get(i).getValue() != null && keys.get(i).getValue() == Order.DESCENDING) {\r\n            clause.append(\" < \");\r\n        } else {\r\n            clause.append(\" > \");\r\n        }\r\n        clause.append(provider.getSortKeyPlaceHolder(keys.get(i).getKey()));\r\n        clauses.add(clause.toString());\r\n    }\r\n    sql.append(\"(\");\r\n    String prefix = \"\";\r\n    for (String curClause : clauses) {\r\n        sql.append(prefix);\r\n        prefix = \" OR \";\r\n        sql.append(\"(\");\r\n        sql.append(curClause);\r\n        sql.append(\")\");\r\n    }\r\n    sql.append(\")\");\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive.ReactiveCloudFoundrySecurityService.getAccessLevel",
	"Comment": "return a mono of the access level that should be granted to the given token.",
	"Method": "Mono<AccessLevel> getAccessLevel(String token,String applicationId,AccessLevel getAccessLevel,Map<?, ?> body){\r\n    if (Boolean.TRUE.equals(body.get(\"read_sensitive_data\"))) {\r\n        return AccessLevel.FULL;\r\n    }\r\n    return AccessLevel.RESTRICTED;\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.builder.StoredProcedureItemReaderBuilder.parameters",
	"Comment": "sql parameters to be set when executing the stored procedure",
	"Method": "StoredProcedureItemReaderBuilder<T> parameters(SqlParameter parameters){\r\n    this.parameters = parameters;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.FlatFileItemReaderTests.testStrictness",
	"Comment": "in strict mode, resource must exist at the time reader is opened.",
	"Method": "void testStrictness(){\r\n    Resource resource = new NonExistentResource();\r\n    reader.setResource(resource);\r\n    reader.setStrict(true);\r\n    reader.afterPropertiesSet();\r\n    reader.open(executionContext);\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.builder.Neo4jItemReaderBuilder.matchStatement",
	"Comment": "an optional match fragment of the cypher query. match is prepended to the statement\tprovided and should not be included.",
	"Method": "Neo4jItemReaderBuilder<T> matchStatement(String matchStatement){\r\n    this.matchStatement = matchStatement;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.xml.StaxEventItemReader.afterPropertiesSet",
	"Comment": "ensure that all required dependencies for the itemreader to run are provided after all properties have been set.",
	"Method": "void afterPropertiesSet(){\r\n    Assert.notNull(unmarshaller, \"The Unmarshaller must not be null.\");\r\n    Assert.notEmpty(fragmentRootElementNames, \"The FragmentRootElementNames must not be empty\");\r\n    for (QName fragmentRootElementName : fragmentRootElementNames) {\r\n        Assert.hasText(fragmentRootElementName.getLocalPart(), \"The FragmentRootElementNames must not contain empty elements\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.kafka.KafkaProperties.buildConsumerProperties",
	"Comment": "create an initial map of consumer properties from the state of this instance.\tthis allows you to add additional properties, if necessary, and override the\tdefault kafkaconsumerfactory bean.",
	"Method": "Map<String, Object> buildConsumerProperties(){\r\n    Map<String, Object> properties = buildCommonProperties();\r\n    properties.putAll(this.consumer.buildProperties());\r\n    return properties;\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.server.Jsp.getInitParameters",
	"Comment": "return the init parameters used to configure the jsp servlet.",
	"Method": "Map<String, String> getInitParameters(){\r\n    return this.initParameters;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationprocessor.json.JSONStringer.open",
	"Comment": "enters a new scope by appending any necessary whitespace and the given bracket.",
	"Method": "JSONStringer open(Scope empty,String openBracket){\r\n    if (this.stack.isEmpty() && this.out.length() > 0) {\r\n        throw new JSONException(\"Nesting problem: multiple top-level roots\");\r\n    }\r\n    beforeValue();\r\n    this.stack.add(empty);\r\n    this.out.append(openBracket);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.builder.RepositoryItemReaderBuilder.currentItemCount",
	"Comment": "index for the current item. used on restarts to indicate where to start from.",
	"Method": "RepositoryItemReaderBuilder<T> currentItemCount(int currentItemCount){\r\n    this.currentItemCount = currentItemCount;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.policy.CompletionPolicySupport.update",
	"Comment": "increment the context so the counter is up to date. do nothing else.",
	"Method": "void update(RepeatContext context){\r\n    if (context instanceof RepeatContextSupport) {\r\n        ((RepeatContextSupport) context).increment();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.JsonContentAssert.extractingJsonPathMapValue",
	"Comment": "extract the map value at the given json path for further object assertions.",
	"Method": "MapAssert<K, V> extractingJsonPathMapValue(CharSequence expression,Object args){\r\n    return Assertions.assertThat(extractingJsonPathValue(expression, args, Map.class, \"a map\"));\r\n}"
}, {
	"Path": "org.springframework.batch.item.file.transform.IncorrectLineLengthException.getActualLength",
	"Comment": "retrieves the actual length that was recorded for this exception.",
	"Method": "int getActualLength(){\r\n    return actualLength;\r\n}"
}, {
	"Path": "org.springframework.batch.item.KeyValueItemWriter.setDelete",
	"Comment": "sets the delete flag to have the item writer perform deletes",
	"Method": "void setDelete(boolean delete){\r\n    this.delete = delete;\r\n}"
}, {
	"Path": "org.springframework.batch.item.support.CompositeItemWriter.setDelegates",
	"Comment": "the list of item writers to use as delegates. items are written to each of the\tdelegates.",
	"Method": "void setDelegates(List<ItemWriter<? super T>> delegates){\r\n    this.delegates = delegates;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationmetadata.ConfigurationMetadataSource.getType",
	"Comment": "the type of the source. usually this is the fully qualified name of a class that\tdefines configuration items. this class may or may not be available at runtime.",
	"Method": "String getType(){\r\n    return this.type;\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.JdbcBatchItemWriter.setAssertUpdates",
	"Comment": "public setter for the flag that determines whether an assertion is made\tthat all items cause at least one row to be updated.",
	"Method": "void setAssertUpdates(boolean assertUpdates){\r\n    this.assertUpdates = assertUpdates;\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.exception.LogOrRethrowExceptionHandler.handleException",
	"Comment": "classify the throwables and decide whether to rethrow based on the\tresult. the context is not used.",
	"Method": "void handleException(RepeatContext context,Throwable throwable){\r\n    Level key = exceptionClassifier.classify(throwable);\r\n    if (Level.ERROR.equals(key)) {\r\n        logger.error(\"Exception encountered in batch repeat.\", throwable);\r\n    } else if (Level.WARN.equals(key)) {\r\n        logger.warn(\"Exception encountered in batch repeat.\", throwable);\r\n    } else if (Level.DEBUG.equals(key) && logger.isDebugEnabled()) {\r\n        logger.debug(\"Exception encountered in batch repeat.\", throwable);\r\n    } else if (Level.RETHROW.equals(key)) {\r\n        throw throwable;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.database.JdbcPagingItemReader.setFetchSize",
	"Comment": "gives the jdbc driver a hint as to the number of rows that should be\tfetched from the database when more rows are needed for this\tresultset object. if the fetch size specified is zero, the\tjdbc driver ignores the value.",
	"Method": "void setFetchSize(int fetchSize){\r\n    this.fetchSize = fetchSize;\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.SynchronousTests.testExternalRetrySuccessOnSecondAttempt",
	"Comment": "message processing is successful on the second attempt but must receive\tthe message again.",
	"Method": "void testExternalRetrySuccessOnSecondAttempt(){\r\n    assertInitialState();\r\n    retryTemplate.execute(new RetryCallback<String, Exception>() {\r\n        @Override\r\n        public String doWithRetry(RetryContext status) throws Exception {\r\n            TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);\r\n            transactionTemplate.setPropagationBehavior(TransactionTemplate.PROPAGATION_REQUIRES_NEW);\r\n            return transactionTemplate.execute(new TransactionCallback<String>() {\r\n                @Override\r\n                public String doInTransaction(TransactionStatus status) {\r\n                    final String text = (String) jmsTemplate.receiveAndConvert(\"queue\");\r\n                    list.add(text);\r\n                    jdbcTemplate.update(\"INSERT into T_BARS (id,name,foo_date) values (?,?,null)\", list.size(), text);\r\n                    if (list.size() == 1) {\r\n                        throw new RuntimeException(\"Rollback!\");\r\n                    }\r\n                    return text;\r\n                }\r\n            });\r\n        }\r\n    });\r\n    List<String> msgs = getMessages();\r\n    int count = jdbcTemplate.queryForObject(\"select count(*) from T_BARS\", Integer.class);\r\n    assertEquals(1, count);\r\n    assertEquals(\"[]\", msgs.toString());\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.SynchronousTests.testExternalRetrySuccessOnSecondAttempt",
	"Comment": "message processing is successful on the second attempt but must receive\tthe message again.",
	"Method": "void testExternalRetrySuccessOnSecondAttempt(){\r\n    TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);\r\n    transactionTemplate.setPropagationBehavior(TransactionTemplate.PROPAGATION_REQUIRES_NEW);\r\n    return transactionTemplate.execute(new TransactionCallback<String>() {\r\n        @Override\r\n        public String doInTransaction(TransactionStatus status) {\r\n            final String text = (String) jmsTemplate.receiveAndConvert(\"queue\");\r\n            list.add(text);\r\n            jdbcTemplate.update(\"INSERT into T_BARS (id,name,foo_date) values (?,?,null)\", list.size(), text);\r\n            if (list.size() == 1) {\r\n                throw new RuntimeException(\"Rollback!\");\r\n            }\r\n            return text;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.springframework.batch.retry.jms.SynchronousTests.testExternalRetrySuccessOnSecondAttempt",
	"Comment": "message processing is successful on the second attempt but must receive\tthe message again.",
	"Method": "void testExternalRetrySuccessOnSecondAttempt(){\r\n    final String text = (String) jmsTemplate.receiveAndConvert(\"queue\");\r\n    list.add(text);\r\n    jdbcTemplate.update(\"INSERT into T_BARS (id,name,foo_date) values (?,?,null)\", list.size(), text);\r\n    if (list.size() == 1) {\r\n        throw new RuntimeException(\"Rollback!\");\r\n    }\r\n    return text;\r\n}"
}, {
	"Path": "org.springframework.boot.SpringApplication.setEnvironment",
	"Comment": "sets the underlying environment that should be used with the created application\tcontext.",
	"Method": "void setEnvironment(ConfigurableEnvironment environment){\r\n    this.isCustomEnvironment = true;\r\n    this.environment = environment;\r\n}"
}, {
	"Path": "org.springframework.boot.ExitCodeGenerators.getExitCode",
	"Comment": "get the final exit code that should be returned based on all contained generators.",
	"Method": "int getExitCode(int getExitCode){\r\n    int exitCode = 0;\r\n    for (ExitCodeGenerator generator : this.generators) {\r\n        try {\r\n            int value = generator.getExitCode();\r\n            if (value > 0 && value > exitCode || value < 0 && value < exitCode) {\r\n                exitCode = value;\r\n            }\r\n        } catch (Exception ex) {\r\n            exitCode = (exitCode != 0) ? exitCode : 1;\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n    return exitCode;\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport.getConditionAndOutcomesBySource",
	"Comment": "returns condition outcomes from this report, grouped by the source.",
	"Method": "Map<String, ConditionAndOutcomes> getConditionAndOutcomesBySource(){\r\n    if (!this.addedAncestorOutcomes) {\r\n        this.outcomes.forEach((source, sourceOutcomes) -> {\r\n            if (!sourceOutcomes.isFullMatch()) {\r\n                addNoMatchOutcomeToAncestors(source);\r\n            }\r\n        });\r\n        this.addedAncestorOutcomes = true;\r\n    }\r\n    return Collections.unmodifiableMap(this.outcomes);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler.getErrorAttributes",
	"Comment": "extract the error attributes from the current request, to be used to populate error\tviews or json payloads.",
	"Method": "Map<String, Object> getErrorAttributes(ServerRequest request,boolean includeStackTrace){\r\n    return this.errorAttributes.getErrorAttributes(request, includeStackTrace);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler.isTraceEnabled",
	"Comment": "check whether the trace attribute has been set on the given request.",
	"Method": "boolean isTraceEnabled(ServerRequest request){\r\n    String parameter = request.queryParam(\"trace\").orElse(\"false\");\r\n    return !\"false\".equalsIgnoreCase(parameter);\r\n}"
}, {
	"Path": "org.springframework.batch.item.data.RepositoryItemWriter.doWrite",
	"Comment": "performs the actual write to the repository.this can be overridden by\ta subclass if necessary.",
	"Method": "void doWrite(List<? extends T> items){\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Writing to the repository with \" + items.size() + \" items.\");\r\n    }\r\n    MethodInvoker invoker = createMethodInvoker(repository, methodName);\r\n    for (T object : items) {\r\n        invoker.setArguments(new Object[] { object });\r\n        doInvoke(invoker);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.batch.item.ExecutionContext.getInt",
	"Comment": "typesafe getter for the integer represented by the provided key with\tdefault value to return if key is not represented.",
	"Method": "int getInt(String key,int getInt,String key,int defaultInt){\r\n    if (!containsKey(key)) {\r\n        return defaultInt;\r\n    }\r\n    return getInt(key);\r\n}"
}, {
	"Path": "org.springframework.batch.integration.partition.RemotePartitioningWorkerStepBuilder.outputChannel",
	"Comment": "set the output channel on which replies will be sent to the master step.",
	"Method": "RemotePartitioningWorkerStepBuilder outputChannel(MessageChannel outputChannel){\r\n    Assert.notNull(outputChannel, \"outputChannel must not be null\");\r\n    this.outputChannel = outputChannel;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationprocessor.TestProject.revert",
	"Comment": "restore source code of given class to its original contents.",
	"Method": "void revert(Class<?> type){\r\n    Assert.assertTrue(getSourceFile(type).exists());\r\n    copySources(type);\r\n}"
}, {
	"Path": "org.springframework.batch.repeat.exception.RethrowOnThresholdExceptionHandler.setUseParent",
	"Comment": "flag to indicate the the exception counters should be shared between\tsibling contexts in a nested batch. default is false.",
	"Method": "void setUseParent(boolean useParent){\r\n    this.useParent = useParent;\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.DynamicRegistrationBean.setName",
	"Comment": "set the name of this registration. if not specified the bean name will be used.",
	"Method": "void setName(String name){\r\n    Assert.hasLength(name, \"Name must not be empty\");\r\n    this.name = name;\r\n}"
}]