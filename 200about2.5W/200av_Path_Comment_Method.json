[{
	"Path": "com.turn.ttorrent.client.peer.SharingPeer.isConnected",
	"Comment": "tells whether this peer as an active connection through a peer exchange.",
	"Method": "boolean isConnected(){\r\n    return this.socketChannel.isOpen();\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerDivideTest.testCase6",
	"Comment": "divide two positive numbers of the same length.the second is greater.",
	"Method": "void testCase6(){\r\n    byte[] aBytes = { 1, 100, 56, 7, 98, -1, 39, -128, 127 };\r\n    byte[] bBytes = { 15, 100, 56, 7, 98, -1, 39, -128, 127 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 0 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.divide(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 0, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerDivideTest.testCase5",
	"Comment": "divide two numbers of different length and different signs.the second is longer.",
	"Method": "void testCase5(){\r\n    byte[] aBytes = { -127, 100, 56, 7, 98, -1, 39, -128, 127 };\r\n    byte[] bBytes = { -127, 100, 56, 7, 98, -1, 39, -128, 127, 1, 2, 3, 4, 5 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 0 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.divide(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 0, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerDivideTest.testCase4",
	"Comment": "divide two equal in absolute value numbers of different signs.",
	"Method": "void testCase4(){\r\n    byte[] aBytes = { -127, 100, 56, 7, 98, -1, 39, -128, 127 };\r\n    byte[] bBytes = { -127, 100, 56, 7, 98, -1, 39, -128, 127 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -1 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.divide(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "jsyntaxpane.DefaultLexer.getTokenSrring",
	"Comment": "return the current matched token as a string.this is expensiveas it creates a new string object for the token.use with care.",
	"Method": "CharSequence getTokenSrring(){\r\n    return yytext();\r\n}"
}, {
	"Path": "com.turn.ttorrent.tracker.TrackerRequestProcessor.process",
	"Comment": "process the announce request.this method attemps to read and parse the incoming announce request intoan announce request message, then creates the appropriate announceresponse message and sends it back to the client.",
	"Method": "void process(String uri,String hostAddress,RequestHandler requestHandler){\r\n    HTTPAnnounceRequestMessage announceRequest;\r\n    try {\r\n        announceRequest = this.parseQuery(uri, hostAddress);\r\n    } catch (MessageValidationException mve) {\r\n        LoggerUtils.warnAndDebugDetails(logger, \"Unable to parse request message. Request url is {}\", uri, mve);\r\n        serveError(Status.BAD_REQUEST, mve.getMessage(), requestHandler);\r\n        return;\r\n    }\r\n    AnnounceRequestMessage.RequestEvent event = announceRequest.getEvent();\r\n    if (event == null) {\r\n        event = AnnounceRequestMessage.RequestEvent.NONE;\r\n    }\r\n    TrackedTorrent torrent = myTorrentsRepository.getTorrent(announceRequest.getHexInfoHash());\r\n    if (!myAcceptForeignTorrents && torrent == null) {\r\n        logger.warn(\"Requested torrent hash was: {}\", announceRequest.getHexInfoHash());\r\n        serveError(Status.BAD_REQUEST, ErrorMessage.FailureReason.UNKNOWN_TORRENT, requestHandler);\r\n        return;\r\n    }\r\n    final boolean isSeeder = (event == AnnounceRequestMessage.RequestEvent.COMPLETED) || (announceRequest.getLeft() == 0);\r\n    if (myAddressChecker.isBadAddress(announceRequest.getIp())) {\r\n        if (torrent == null) {\r\n            writeEmptyResponse(announceRequest, requestHandler);\r\n        } else {\r\n            writeAnnounceResponse(torrent, null, isSeeder, requestHandler);\r\n        }\r\n        return;\r\n    }\r\n    final Peer peer = new Peer(announceRequest.getIp(), announceRequest.getPort());\r\n    try {\r\n        torrent = myTorrentsRepository.putIfAbsentAndUpdate(announceRequest.getHexInfoHash(), new TrackedTorrent(announceRequest.getInfoHash()), event, ByteBuffer.wrap(announceRequest.getPeerId()), announceRequest.getHexPeerId(), announceRequest.getIp(), announceRequest.getPort(), announceRequest.getUploaded(), announceRequest.getDownloaded(), announceRequest.getLeft());\r\n    } catch (IllegalArgumentException iae) {\r\n        LoggerUtils.warnAndDebugDetails(logger, \"Unable to update peer torrent. Request url is {}\", uri, iae);\r\n        serveError(Status.BAD_REQUEST, ErrorMessage.FailureReason.INVALID_EVENT, requestHandler);\r\n        return;\r\n    }\r\n    writeAnnounceResponse(torrent, peer, isSeeder, requestHandler);\r\n}"
}, {
	"Path": "be.tarsos.dsp.example.KernelDensityEstimate.calculateSumFreq",
	"Comment": "calculates the sum of all estimates in the accummulator. should be called after each update.",
	"Method": "void calculateSumFreq(){\r\n    sum = 0;\r\n    for (int i = 0; i < accumulator.length; i++) {\r\n        sum += accumulator[i];\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.oqlsyntax.OqlLexer.yytext",
	"Comment": "returns the text matched by the current regular expression.",
	"Method": "String yytext(){\r\n    return new String(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);\r\n}"
}, {
	"Path": "com.facebook.swift.service.explicitidentifiers.ExplicitIdentifiersTest.testExplicitParameterOrdering",
	"Comment": "client passes all parameters, but in a different order than the server expects",
	"Method": "void testExplicitParameterOrdering(){\r\n    int integerParam = Integer.MAX_VALUE;\r\n    byte byteParam = Byte.MAX_VALUE;\r\n    Boolean booleanParam = Boolean.TRUE;\r\n    getClient().explicitParameterOrdering(\"STRING\", integerParam, booleanParam, byteParam);\r\n    assertEquals(getHandler().getLastIntegerParam().get(), (Integer) integerParam);\r\n    assertEquals(getHandler().getLastBooleanParam().get(), booleanParam);\r\n    assertEquals(getHandler().getLastByteParam().get(), (Byte) byteParam);\r\n    assertEquals(getHandler().getLastStringParam().get(), \"STRING\");\r\n    assertFalse(getHandler().hasLastCustomParam());\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.mbeans.XMBeanAttributes.getRowCount",
	"Comment": "override jtable method in order to make any call to this methodatomic with tablemodel elements.",
	"Method": "int getRowCount(){\r\n    return super.getRowCount();\r\n}"
}, {
	"Path": "org.teavm.backend.javascript.JavaScriptTarget.setMinifying",
	"Comment": "specifies whether this teavm instance uses obfuscation when generating the javascript code.",
	"Method": "void setMinifying(boolean minifying){\r\n    this.minifying = minifying;\r\n}"
}, {
	"Path": "be.tarsos.dsp.filters.BandPass.setBandWidth",
	"Comment": "sets the band width of the filter. doing this will cause the coefficientsto be recalculated.",
	"Method": "void setBandWidth(float bandWidth){\r\n    bw = bandWidth / getSampleRate();\r\n    calcCoeff();\r\n}"
}, {
	"Path": "org.sqlite.core.DB.open",
	"Comment": "creates an sqlite interface to a database for the given connection.",
	"Method": "void open(String file,int openFlags){\r\n    _open(file, openFlags);\r\n    closed.set(false);\r\n    if (fileName.startsWith(\"file:\") && !fileName.contains(\"cache=\")) {\r\n        shared_cache(config.isEnabledSharedCache());\r\n    }\r\n    enable_load_extension(config.isEnabledLoadExtension());\r\n    busy_timeout(config.getBusyTimeout());\r\n}"
}, {
	"Path": "org.springframework.cloud.config.server.support.PassphraseCredentialsProvider.get",
	"Comment": "ask for the credential items to be populated with the passphrase.",
	"Method": "boolean get(URIish uri,CredentialItem items){\r\n    for (final CredentialItem item : items) {\r\n        if (item instanceof CredentialItem.StringType && item.getPromptText().startsWith(PROMPT)) {\r\n            ((CredentialItem.StringType) item).setValue(passphrase);\r\n            continue;\r\n        }\r\n        throw new UnsupportedCredentialItem(uri, item.getClass().getName() + \":\" + item.getPromptText());\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.telegram.abilitybots.api.bot.BaseAbilityBot.getUserIdSendError",
	"Comment": "gets the user with the specified username. if user was not found, the bot will send a message on telegram.",
	"Method": "int getUserIdSendError(String username,MessageContext ctx){\r\n    try {\r\n        return getUser(username).getId();\r\n    } catch (IllegalStateException ex) {\r\n        silent.send(getLocalizedMessage(USER_NOT_FOUND, ctx.user().getLanguageCode(), username), ctx.chatId());\r\n        throw propagate(ex);\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase1",
	"Comment": "subtract two positive numbers of the same length.the first is greater.",
	"Method": "void testCase1(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 9, 18, 27, 36, 45, 54, 63, 9, 18, 27 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.TBigInteger.copy",
	"Comment": "returns a copy of the current instance to achieve immutability",
	"Method": "TBigInteger copy(){\r\n    int[] copyDigits = new int[numberLength];\r\n    System.arraycopy(digits, 0, copyDigits, 0, numberLength);\r\n    return new TBigInteger(sign, numberLength, copyDigits);\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.peer.SharingPeer.fireIOException",
	"Comment": "fire the ioexception event to all registered listeners.the event contains the peer that triggered the problem, and theexception object.",
	"Method": "void fireIOException(IOException ioe){\r\n    for (PeerActivityListener listener : this.listeners) {\r\n        listener.handleIOException(this, ioe);\r\n    }\r\n}"
}, {
	"Path": "org.sqlite.SQLiteJDBCLoader.extractAndLoadLibraryFile",
	"Comment": "extracts and loads the specified library file to the target folder",
	"Method": "boolean extractAndLoadLibraryFile(String libFolderForCurrentOS,String libraryFileName,String targetFolder){\r\n    String nativeLibraryFilePath = libFolderForCurrentOS + \"/\" + libraryFileName;\r\n    String uuid = UUID.randomUUID().toString();\r\n    String extractedLibFileName = String.format(\"sqlite-%s-%s-%s\", getVersion(), uuid, libraryFileName);\r\n    String extractedLckFileName = extractedLibFileName + \".lck\";\r\n    File extractedLibFile = new File(targetFolder, extractedLibFileName);\r\n    File extractedLckFile = new File(targetFolder, extractedLckFileName);\r\n    try {\r\n        InputStream reader = SQLiteJDBCLoader.class.getResourceAsStream(nativeLibraryFilePath);\r\n        if (!extractedLckFile.exists()) {\r\n            new FileOutputStream(extractedLckFile).close();\r\n        }\r\n        FileOutputStream writer = new FileOutputStream(extractedLibFile);\r\n        try {\r\n            byte[] buffer = new byte[8192];\r\n            int bytesRead = 0;\r\n            while ((bytesRead = reader.read(buffer)) != -1) {\r\n                writer.write(buffer, 0, bytesRead);\r\n            }\r\n        } finally {\r\n            extractedLibFile.deleteOnExit();\r\n            extractedLckFile.deleteOnExit();\r\n            if (writer != null) {\r\n                writer.close();\r\n            }\r\n            if (reader != null) {\r\n                reader.close();\r\n            }\r\n        }\r\n        extractedLibFile.setReadable(true);\r\n        extractedLibFile.setWritable(true, true);\r\n        extractedLibFile.setExecutable(true);\r\n        {\r\n            InputStream nativeIn = SQLiteJDBCLoader.class.getResourceAsStream(nativeLibraryFilePath);\r\n            InputStream extractedLibIn = new FileInputStream(extractedLibFile);\r\n            try {\r\n                if (!contentsEquals(nativeIn, extractedLibIn)) {\r\n                    throw new RuntimeException(String.format(\"Failed to write a native library file at %s\", extractedLibFile));\r\n                }\r\n            } finally {\r\n                if (nativeIn != null) {\r\n                    nativeIn.close();\r\n                }\r\n                if (extractedLibIn != null) {\r\n                    extractedLibIn.close();\r\n                }\r\n            }\r\n        }\r\n        return loadNativeLibrary(targetFolder, extractedLibFileName);\r\n    } catch (IOException e) {\r\n        System.err.println(e.getMessage());\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.swift.service.ThriftClientManager.getRemoteAddress",
	"Comment": "returns the remote address that a swift client is connected to",
	"Method": "HostAndPort getRemoteAddress(Object client){\r\n    NiftyClientChannel niftyChannel = getNiftyChannel(client);\r\n    try {\r\n        Channel nettyChannel = niftyChannel.getNettyChannel();\r\n        SocketAddress address = nettyChannel.getRemoteAddress();\r\n        InetSocketAddress inetAddress = (InetSocketAddress) address;\r\n        return HostAndPort.fromParts(inetAddress.getHostString(), inetAddress.getPort());\r\n    } catch (NullPointerException | ClassCastException e) {\r\n        throw new IllegalArgumentException(\"Invalid swift client object\", e);\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.AudioEvent.getTimeStamp",
	"Comment": "calculates and returns the time stamp at the beginning of this audio event.",
	"Method": "double getTimeStamp(){\r\n    return bytesProcessed / format.getFrameSize() / format.getSampleRate();\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorSignBytesNegative6",
	"Comment": "create a negative number from a sign and an array of bytes.the number of bytes is multiple of 4.the most significant byte is positive.",
	"Method": "void testConstructorSignBytesNegative6(){\r\n    byte[] aBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 23, -101 };\r\n    int aSign = -1;\r\n    byte[] rBytes = { -13, -57, -101, 1, 75, -90, -46, -92, -4, 14, -24, 101 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorSignBytesNegative7",
	"Comment": "create a negative number from a sign and an array of bytes.the number of bytes is multiple of 4.the most significant byte is negative.",
	"Method": "void testConstructorSignBytesNegative7(){\r\n    byte[] aBytes = { -12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 23, -101 };\r\n    int aSign = -1;\r\n    byte[] rBytes = { -1, 11, -57, -101, 1, 75, -90, -46, -92, -4, 14, -24, 101 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testDoubleValuePosNotRounded",
	"Comment": "convert a positive number to a double value.rounding is not needed.",
	"Method": "void testDoubleValuePosNotRounded(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, -128, 23, 1, -3, -5 };\r\n    int aSign = 1;\r\n    double result = 1.5474726438794828E26;\r\n    double aNumber = new BigInteger(aSign, a).doubleValue();\r\n    assertEquals(aNumber, result, 1E14);\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.readSingleFieldValue",
	"Comment": "defines the code to read all of the data from the protocol into local variables.",
	"Method": "Map<Short, LocalVariableDefinition> readSingleFieldValue(MethodDefinition read){\r\n    LocalVariableDefinition protocol = read.getLocalVariable(\"reader\");\r\n    Map<Short, LocalVariableDefinition> unionData = new TreeMap();\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        LocalVariableDefinition variable = read.addInitializedLocalVariable(toParameterizedType(field.getThriftType()), \"f_\" + field.getName());\r\n        unionData.put(field.getId(), variable);\r\n    }\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"readStructBegin\", void.class);\r\n    read.visitLabel(\"while-begin\");\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"nextField\", boolean.class);\r\n    read.ifZeroGoto(\"while-end\");\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"getFieldId\", short.class);\r\n    read.storeVariable(\"fieldId\");\r\n    read.loadVariable(\"fieldId\");\r\n    List<CaseStatement> cases = new ArrayList();\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        cases.add(caseStatement(field.getId(), field.getName() + \"-field\"));\r\n    }\r\n    read.switchStatement(\"default\", cases);\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        read.visitLabel(field.getName() + \"-field\");\r\n        read.loadVariable(protocol);\r\n        FieldDefinition codecField = codecFields.get(field.getId());\r\n        if (codecField != null) {\r\n            read.loadThis().getField(codecType, codecField);\r\n        }\r\n        Method readMethod = getReadMethod(field.getThriftType());\r\n        if (readMethod == null) {\r\n            throw new IllegalArgumentException(\"Unsupported field type \" + field.getThriftType().getProtocolType());\r\n        }\r\n        read.invokeVirtual(readMethod);\r\n        if (needsCastAfterRead(field, readMethod)) {\r\n            read.checkCast(toParameterizedType(field.getThriftType()));\r\n        }\r\n        if (field.getCoercion().isPresent()) {\r\n            read.invokeStatic(field.getCoercion().get().getFromThrift());\r\n        }\r\n        read.storeVariable(unionData.get(field.getId()));\r\n        read.gotoLabel(\"while-begin\");\r\n    }\r\n    read.visitLabel(\"default\").loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"skipFieldData\", void.class).gotoLabel(\"while-begin\");\r\n    read.visitLabel(\"while-end\");\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"readStructEnd\", void.class);\r\n    return unionData;\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.tracer.TracerProgressObject.isFinished",
	"Comment": "returns true for a finished tracerprogressobject, false otherwise.",
	"Method": "boolean isFinished(){\r\n    return currentStep == steps;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorSignBytesZeroNull2",
	"Comment": "create a zero number from a sign and an array of zero length.the sign is 0.",
	"Method": "void testConstructorSignBytesZeroNull2(){\r\n    byte[] aBytes = {};\r\n    int aSign = 0;\r\n    byte[] rBytes = { 0 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 0, aNumber.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase3",
	"Comment": "subtract two numbers of the same length and different signs.the first is positive.the first is greater in absolute value.",
	"Method": "void testCase3(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 11, 22, 33, 44, 55, 66, 77, 11, 22, 33 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorSignBytesZeroNull3",
	"Comment": "create a zero number from a sign and an array of zero length.the sign is 1.",
	"Method": "void testConstructorSignBytesZeroNull3(){\r\n    byte[] aBytes = {};\r\n    int aSign = 1;\r\n    byte[] rBytes = { 0 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 0, aNumber.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase2",
	"Comment": "subtract two positive numbers of the same length.the second is greater.",
	"Method": "void testCase2(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -10, -19, -28, -37, -46, -55, -64, -10, -19, -27 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase5",
	"Comment": "subtract two negative numbers of the same length.the first is greater in absolute value.",
	"Method": "void testCase5(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    int aSign = -1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { -10, -19, -28, -37, -46, -55, -64, -10, -19, -27 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase4",
	"Comment": "subtract two numbers of the same length and different signs.the first is positive.the second is greater in absolute value.",
	"Method": "void testCase4(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 11, 22, 33, 44, 55, 66, 77, 11, 22, 33 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase7",
	"Comment": "subtract two numbers of the same length and different signs.the first is negative.the first is greater in absolute value.",
	"Method": "void testCase7(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -12, -23, -34, -45, -56, -67, -78, -12, -23, -33 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase6",
	"Comment": "subtract two negative numbers of the same length.the second is greater in absolute value.",
	"Method": "void testCase6(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 9, 18, 27, 36, 45, 54, 63, 9, 18, 27 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase9",
	"Comment": "subtract two positive numbers of different length.the first is longer.",
	"Method": "void testCase9(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 1, 2, 3, 3, -6, -15, -24, -40, -49, -58, -67, -6, -15, -23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase8",
	"Comment": "subtract two numbers of the same length and different signs.the first is negative.the second is greater in absolute value.",
	"Method": "void testCase8(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -12, -23, -34, -45, -56, -67, -78, -12, -23, -33 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "org.sqlite.date.FormatCache.getInstance",
	"Comment": "gets a formatter instance using the specified pattern, time zoneand locale.",
	"Method": "F getInstance(F getInstance,String pattern,TimeZone timeZone,Locale locale){\r\n    if (pattern == null) {\r\n        throw new NullPointerException(\"pattern must not be null\");\r\n    }\r\n    if (timeZone == null) {\r\n        timeZone = TimeZone.getDefault();\r\n    }\r\n    if (locale == null) {\r\n        locale = Locale.getDefault();\r\n    }\r\n    final MultipartKey key = new MultipartKey(pattern, timeZone, locale);\r\n    F format = cInstanceCache.get(key);\r\n    if (format == null) {\r\n        format = createInstance(pattern, timeZone, locale);\r\n        final F previousValue = cInstanceCache.putIfAbsent(key, format);\r\n        if (previousValue != null) {\r\n            format = previousValue;\r\n        }\r\n    }\r\n    return format;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigDecimalArithmeticTest.testSubtractMathContextEqualScalePosPos",
	"Comment": "subtract two numbers of equal positive scales using mathcontext",
	"Method": "void testSubtractMathContextEqualScalePosPos(){\r\n    String a = \"1231212478987482988429808779810457634781384756794987\";\r\n    int aScale = 10;\r\n    String b = \"747233429293018787918347987234564568\";\r\n    int bScale = 10;\r\n    String c = \"1.23121247898749E+41\";\r\n    int cScale = -27;\r\n    BigDecimal aNumber = new BigDecimal(new BigInteger(a), aScale);\r\n    BigDecimal bNumber = new BigDecimal(new BigInteger(b), bScale);\r\n    MathContext mc = new MathContext(15, RoundingMode.CEILING);\r\n    BigDecimal result = aNumber.subtract(bNumber, mc);\r\n    assertEquals(\"incorrect value\", c, result.toString());\r\n    assertEquals(\"incorrect scale\", cScale, result.scale());\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.filter.ratelimit.RedisRateLimiter.isAllowed",
	"Comment": "this uses a basic token bucket algorithm and relies on the fact that redis scripts\texecute atomically. no other operations can run between fetching the count and\twriting the new count.",
	"Method": "Mono<Response> isAllowed(String routeId,String id){\r\n    if (!this.initialized.get()) {\r\n        throw new IllegalStateException(\"RedisRateLimiter is not initialized\");\r\n    }\r\n    Config routeConfig = getConfig().getOrDefault(routeId, defaultConfig);\r\n    if (routeConfig == null) {\r\n        throw new IllegalArgumentException(\"No Configuration found for route \" + routeId);\r\n    }\r\n    int replenishRate = routeConfig.getReplenishRate();\r\n    int burstCapacity = routeConfig.getBurstCapacity();\r\n    try {\r\n        List<String> keys = getKeys(id);\r\n        List<String> scriptArgs = Arrays.asList(replenishRate + \"\", burstCapacity + \"\", Instant.now().getEpochSecond() + \"\", \"1\");\r\n        Flux<List<Long>> flux = this.redisTemplate.execute(this.script, keys, scriptArgs);\r\n        return flux.onErrorResume(throwable -> Flux.just(Arrays.asList(1L, -1L))).reduce(new ArrayList<Long>(), (longs, l) -> {\r\n            longs.addAll(l);\r\n            return longs;\r\n        }).map(results -> {\r\n            boolean allowed = results.get(0) == 1L;\r\n            Long tokensLeft = results.get(1);\r\n            Response response = new Response(allowed, getHeaders(routeConfig, tokensLeft));\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(\"response: \" + response);\r\n            }\r\n            return response;\r\n        });\r\n    } catch (Exception e) {\r\n        log.error(\"Error determining if user allowed from redis\", e);\r\n    }\r\n    return Mono.just(new Response(true, getHeaders(routeConfig, -1L)));\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testIntValuePositive2",
	"Comment": "convert a positive biginteger to an integer value.the low digit is positive",
	"Method": "void testIntValuePositive2(){\r\n    byte[] aBytes = { 12, 56, 100 };\r\n    int resInt = 800868;\r\n    int aNumber = new BigInteger(aBytes).intValue();\r\n    assertTrue(aNumber == resInt);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testIntValuePositive3",
	"Comment": "convert a positive biginteger to an integer value.the low digit is negative.",
	"Method": "void testIntValuePositive3(){\r\n    byte[] aBytes = { 56, 13, 78, -12, -5, 56, 100 };\r\n    int sign = 1;\r\n    int resInt = -184862620;\r\n    int aNumber = new BigInteger(sign, aBytes).intValue();\r\n    assertTrue(aNumber == resInt);\r\n}"
}, {
	"Path": "org.teavm.backend.javascript.JavaScriptTarget.isMinifying",
	"Comment": "reports whether this teavm instance uses obfuscation when generating the javascript code.",
	"Method": "boolean isMinifying(){\r\n    return minifying;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testIntValuePositive1",
	"Comment": "convert a positive biginteger to an integer value.the low digit is positive",
	"Method": "void testIntValuePositive1(){\r\n    byte[] aBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3 };\r\n    int resInt = 1496144643;\r\n    int aNumber = new BigInteger(aBytes).intValue();\r\n    assertTrue(aNumber == resInt);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testLongValueNegative1",
	"Comment": "convert a number to a negative long valuethe biginteger is longer than int.",
	"Method": "void testLongValueNegative1(){\r\n    byte[] aBytes = { 12, -1, 100, -2, -76, -128, 45, 91, 3 };\r\n    long result = -43630045168837885L;\r\n    long aNumber = new BigInteger(aBytes).longValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testLongValueNegative2",
	"Comment": "convert a number to a negative long valuethe number fits in a long.",
	"Method": "void testLongValueNegative2(){\r\n    byte[] aBytes = { -12, 56, 100, 45, -101, 45, 98 };\r\n    long result = -3315696807498398L;\r\n    long aNumber = new BigInteger(aBytes).longValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "be.tarsos.dsp.granulator.Granulator.getFrameLinear",
	"Comment": "retrieves a frame of audio using linear interpolation. if the frame is\tnot in the sample range then zeros are returned.",
	"Method": "double getFrameLinear(double posInMS){\r\n    double result = 0.0;\r\n    double sampleNumber = msToSamples(posInMS);\r\n    int sampleNumberFloor = (int) Math.floor(sampleNumber);\r\n    if (sampleNumberFloor > 0 && sampleNumberFloor < audioBufferWatermark) {\r\n        double sampleNumberFraction = sampleNumber - sampleNumberFloor;\r\n        if (sampleNumberFloor == audioBufferWatermark - 1) {\r\n            result = audioBuffer[sampleNumberFloor];\r\n        } else {\r\n            double current = audioBuffer[sampleNumberFloor];\r\n            double next = audioBuffer[sampleNumberFloor];\r\n            result = (float) ((1 - sampleNumberFraction) * current + sampleNumberFraction * next);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "be.tarsos.dsp.pitch.FastYin.difference",
	"Comment": "implements the difference function as described in step 2 of the yin\tpaper with an fft to reduce the number of operations.",
	"Method": "void difference(float[] audioBuffer){\r\n    float[] powerTerms = new float[yinBuffer.length];\r\n    for (int j = 0; j < yinBuffer.length; ++j) {\r\n        powerTerms[0] += audioBuffer[j] * audioBuffer[j];\r\n    }\r\n    for (int tau = 1; tau < yinBuffer.length; ++tau) {\r\n        powerTerms[tau] = powerTerms[tau - 1] - audioBuffer[tau - 1] * audioBuffer[tau - 1] + audioBuffer[tau + yinBuffer.length] * audioBuffer[tau + yinBuffer.length];\r\n    }\r\n    for (int j = 0; j < audioBuffer.length; ++j) {\r\n        audioBufferFFT[2 * j] = audioBuffer[j];\r\n        audioBufferFFT[2 * j + 1] = 0;\r\n    }\r\n    fft.complexForward(audioBufferFFT);\r\n    for (int j = 0; j < yinBuffer.length; ++j) {\r\n        kernel[2 * j] = audioBuffer[(yinBuffer.length - 1) - j];\r\n        kernel[2 * j + 1] = 0;\r\n        kernel[2 * j + audioBuffer.length] = 0;\r\n        kernel[2 * j + audioBuffer.length + 1] = 0;\r\n    }\r\n    fft.complexForward(kernel);\r\n    for (int j = 0; j < audioBuffer.length; ++j) {\r\n        yinStyleACF[2 * j] = audioBufferFFT[2 * j] * kernel[2 * j] - audioBufferFFT[2 * j + 1] * kernel[2 * j + 1];\r\n        yinStyleACF[2 * j + 1] = audioBufferFFT[2 * j + 1] * kernel[2 * j] + audioBufferFFT[2 * j] * kernel[2 * j + 1];\r\n    }\r\n    fft.complexInverse(yinStyleACF, true);\r\n    for (int j = 0; j < yinBuffer.length; ++j) {\r\n        yinBuffer[j] = powerTerms[0] + powerTerms[j] - 2 * yinStyleACF[2 * (yinBuffer.length - 1 + j)];\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.util.CubicSplineFast.calcDeriv",
	"Comment": "this method follows the procedure in numerical methods c language procedure for calculating second derivatives",
	"Method": "void calcDeriv(){\r\n    double p = 0.0D, qn = 0.0D, sig = 0.0D, un = 0.0D;\r\n    double[] u = new double[nPoints];\r\n    d2ydx2[0] = u[0] = 0.0;\r\n    for (int i = 1; i <= this.nPoints - 2; i++) {\r\n        sig = (this.x[i] - this.x[i - 1]) / (this.x[i + 1] - this.x[i - 1]);\r\n        p = sig * this.d2ydx2[i - 1] + 2.0;\r\n        this.d2ydx2[i] = (sig - 1.0) / p;\r\n        u[i] = (this.y[i + 1] - this.y[i]) / (this.x[i + 1] - this.x[i]) - (this.y[i] - this.y[i - 1]) / (this.x[i] - this.x[i - 1]);\r\n        u[i] = (6.0 * u[i] / (this.x[i + 1] - this.x[i - 1]) - sig * u[i - 1]) / p;\r\n    }\r\n    qn = un = 0.0;\r\n    this.d2ydx2[this.nPoints - 1] = (un - qn * u[this.nPoints - 2]) / (qn * this.d2ydx2[this.nPoints - 2] + 1.0);\r\n    for (int k = this.nPoints - 2; k >= 0; k--) {\r\n        this.d2ydx2[k] = this.d2ydx2[k] * this.d2ydx2[k + 1] + u[k];\r\n    }\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.SharedTorrent.handlePeerChoked",
	"Comment": "peer choked handler.when a peer chokes, the requests made to it are canceled and we need tomark the eventually piece we requested from it as available again fordownload tentative from another peer.",
	"Method": "void handlePeerChoked(SharingPeer peer){\r\n    Set<Piece> pieces = peer.getRequestedPieces();\r\n    if (pieces.size() > 0) {\r\n        for (Piece piece : pieces) {\r\n            this.requestedPieces.set(piece.getIndex(), false);\r\n        }\r\n    }\r\n    logger.trace(\"Peer {} choked, we now have {} outstanding \" + \"request(s): {}.\", new Object[] { peer, this.requestedPieces.cardinality(), this.requestedPieces });\r\n}"
}, {
	"Path": "com.turn.ttorrent.tracker.Tracker.stop",
	"Comment": "stop the tracker.this effectively closes the listening http connection to terminatethe service, and interrupts the peer mypeercollectorthread thread as well.",
	"Method": "void stop(){\r\n    this.stop = true;\r\n    try {\r\n        this.connection.close();\r\n        logger.info(\"BitTorrent tracker closed.\");\r\n    } catch (IOException ioe) {\r\n        logger.error(\"Could not stop the tracker: {}!\", ioe.getMessage());\r\n    }\r\n    if (myPeerCollectorThread != null && myPeerCollectorThread.isAlive()) {\r\n        myPeerCollectorThread.interrupt();\r\n        try {\r\n            myPeerCollectorThread.join();\r\n        } catch (InterruptedException e) {\r\n        }\r\n        logger.info(\"Peer collection terminated.\");\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.impl.tz.DateTimeZone.convertUTCToLocal",
	"Comment": "converts a standard utc instant to a local instant with the samelocal time. this conversion is used before performing a calculationso that the calculation can be done using a simple local zone.",
	"Method": "long convertUTCToLocal(long instantUTC){\r\n    int offset = getOffset(instantUTC);\r\n    long instantLocal = instantUTC + offset;\r\n    if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\r\n        throw new ArithmeticException(\"Adding time zone offset caused overflow\");\r\n    }\r\n    return instantLocal;\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.mbeans.Resources.getText",
	"Comment": "returns the text of the resource for the specifiedkey formatted with the specified arguments.",
	"Method": "String getText(String key,Object args){\r\n    return NbBundle.getMessage(Resources.class, key, args);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerAddTest.testCase9",
	"Comment": "add two negative numbers of different length.the first is longer.",
	"Method": "void testCase9(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { -2, -3, -4, -5, -16, -27, -38, -42, -53, -64, -75, -16, -27, -37 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.CommunicationManager.addTorrent",
	"Comment": "adds torrent to storage with any storage, metadata source and specified listeners",
	"Method": "TorrentManager addTorrent(String dotTorrentFilePath,String downloadDirPath,TorrentManager addTorrent,String dotTorrentFilePath,String downloadDirPath,List<TorrentListener> listeners,TorrentManager addTorrent,String dotTorrentFilePath,String downloadDirPath,PieceStorageFactory pieceStorageFactory,TorrentManager addTorrent,String dotTorrentFilePath,String downloadDirPath,PieceStorageFactory pieceStorageFactory,List<TorrentListener> listeners,TorrentManager addTorrent,TorrentMetadataProvider metadataProvider,PieceStorage pieceStorage,TorrentManager addTorrent,TorrentMetadataProvider metadataProvider,PieceStorage pieceStorage,List<TorrentListener> listeners){\r\n    CopyOnWriteArrayList<TorrentListener> cowListeners = new CopyOnWriteArrayList<TorrentListener>(listeners);\r\n    TorrentMetadata torrentMetadata = metadataProvider.getTorrentMetadata();\r\n    final LoadedTorrentImpl loadedTorrent = new LoadedTorrentImpl(new TorrentStatistic(), metadataProvider, torrentMetadata, pieceStorage, new EventDispatcher(cowListeners));\r\n    if (pieceStorage.isFinished()) {\r\n        loadedTorrent.getTorrentStatistic().setLeft(0);\r\n    } else {\r\n        long left = calculateLeft(pieceStorage, torrentMetadata);\r\n        loadedTorrent.getTorrentStatistic().setLeft(left);\r\n    }\r\n    this.torrentsStorage.addTorrent(loadedTorrent.getTorrentHash().getHexInfoHash(), loadedTorrent);\r\n    forceAnnounceAndLogError(loadedTorrent, pieceStorage.isFinished() ? COMPLETED : STARTED);\r\n    logger.debug(String.format(\"Added torrent %s (%s)\", loadedTorrent, loadedTorrent.getTorrentHash().getHexInfoHash()));\r\n    return new TorrentManagerImpl(cowListeners, loadedTorrent.getTorrentHash());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerAddTest.testCase6",
	"Comment": "add two numbers of the same length.the first one is negative and the second is positive.the first one is less in absolute value.",
	"Method": "void testCase6(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 3, 4, 5, 6, 7, 8, 9 };\r\n    byte[] rBytes = { 2, 2, 2, 2, 2, 2, 2 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerAddTest.testCase5",
	"Comment": "add two numbers of the same length.the first is positive and the second is negative.the first is less in absolute value.",
	"Method": "void testCase5(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 3, 4, 5, 6, 7, 8, 9 };\r\n    byte[] rBytes = { -3, -3, -3, -3, -3, -3, -2 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerAddTest.testCase8",
	"Comment": "add two positive numbers of different length.the second is longer.",
	"Method": "void testCase8(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] rBytes = { 1, 2, 3, 4, 15, 26, 37, 41, 52, 63, 74, 15, 26, 37 };\r\n    BigInteger aNumber = new BigInteger(aBytes);\r\n    BigInteger bNumber = new BigInteger(bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerAddTest.testCase7",
	"Comment": "add two positive numbers of different length.the first is longer.",
	"Method": "void testCase7(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 1, 2, 3, 4, 15, 26, 37, 41, 52, 63, 74, 15, 26, 37 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "com.turn.ttorrent.tracker.TrackedTorrent.getPeers",
	"Comment": "returns the map of all peers currently exchanging on this torrent.",
	"Method": "Map<PeerUID, TrackedPeer> getPeers(){\r\n    return this.peers;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerAddTest.testCase4",
	"Comment": "add two numbers of the same length.the first one is negative and the second is positive.the first one is greater in absolute value.",
	"Method": "void testCase4(){\r\n    byte[] aBytes = { 3, 4, 5, 6, 7, 8, 9 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] rBytes = { -3, -3, -3, -3, -3, -3, -2 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "org.sqlite.SQLiteConnection.setTransactionMode",
	"Comment": "sets the mode that will be used to start transactions on this connection.",
	"Method": "void setTransactionMode(SQLiteConfig.TransactionMode mode){\r\n    connectionConfig.setTransactionMode(mode);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerAddTest.testCase3",
	"Comment": "add two numbers of the same length.the first one is positive and the second is negative.the first one is greater in absolute value.",
	"Method": "void testCase3(){\r\n    byte[] aBytes = { 3, 4, 5, 6, 7, 8, 9 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] rBytes = { 2, 2, 2, 2, 2, 2, 2 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "org.telegram.abilitybots.api.bot.BaseAbilityBot.checkGlobalFlags",
	"Comment": "test the update against the provided global flags. the default implementation is a passthrough to all updates.this method should be overridden if the user wants to restrict bot usage to only certain updates.",
	"Method": "boolean checkGlobalFlags(Update update){\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.mvc.ProxyExchange.uri",
	"Comment": "sets the uri for the backend call when triggered by the http methods.",
	"Method": "ProxyExchange<T> uri(String uri){\r\n    try {\r\n        this.uri = new URI(uri);\r\n    } catch (URISyntaxException e) {\r\n        throw new IllegalStateException(\"Cannot create URI\", e);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.facebook.swift.service.ThriftServerConfig.setMaxQueuedRequests",
	"Comment": "sets the maximum number of received requests that will wait in the queue to be executed.after this many requests are waiting, the worker queue will start rejecting requests, whichwill cause the server to fail those requests.",
	"Method": "ThriftServerConfig setMaxQueuedRequests(Integer maxQueuedRequests){\r\n    this.maxQueuedRequests = Optional.fromNullable(maxQueuedRequests);\r\n    return this;\r\n}"
}, {
	"Path": "jsyntaxpane.DefaultSyntaxKit.addSyntaxActions",
	"Comment": "add keyboard actions to this control using the configuration we have",
	"Method": "void addSyntaxActions(Keymap map,String prefix){\r\n    Pattern splitter = CONFIG.getValueSeparator(prefix);\r\n    Configuration actionsConf = CONFIG.subConfig(prefix, \"Action.\");\r\n    for (String actionName : actionsConf.stringPropertyNames()) {\r\n        String[] values = splitter.split(actionsConf.getProperty(actionName));\r\n        String actionClass = values[0];\r\n        SyntaxAction action = editorActions.get(actionClass);\r\n        if (action == null) {\r\n            action = createAction(actionClass);\r\n            action.config(CONFIG, prefix, actionName);\r\n        }\r\n        String keyStrokeString = values[1];\r\n        KeyStroke ks = KeyStroke.getKeyStroke(keyStrokeString);\r\n        if (ks == null) {\r\n            throw new IllegalArgumentException(\"Invalid KeyStroke: \" + keyStrokeString);\r\n        }\r\n        TextAction ta = action.getAction(actionName);\r\n        if (ta == null) {\r\n            throw new IllegalArgumentException(\"Invalid ActionName: \" + actionName);\r\n        }\r\n        map.addActionForKeyStroke(ks, ta);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.mbeans.Utils.isUniformCollection",
	"Comment": "check if the given collection is a uniform collection of the given type.",
	"Method": "boolean isUniformCollection(Collection<?> c,Class<?> e){\r\n    if (e == null) {\r\n        throw new IllegalArgumentException(\"Null reference type\");\r\n    }\r\n    if (c == null) {\r\n        throw new IllegalArgumentException(\"Null collection\");\r\n    }\r\n    if (c.isEmpty()) {\r\n        return false;\r\n    }\r\n    for (Object o : c) {\r\n        if (o == null || !e.isAssignableFrom(o.getClass())) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "be.tarsos.dsp.io.TarsosDSPAudioFormat.getProperty",
	"Comment": "obtain the property value specified by the key.the concept of properties is further explained inthe.if the specified property is not defined for aparticular file format, this method returnsnull.",
	"Method": "Object getProperty(String key){\r\n    if (properties == null) {\r\n        return null;\r\n    }\r\n    return properties.get(key);\r\n}"
}, {
	"Path": "be.tarsos.dsp.wavelet.lift.PolynomialWavelets.update",
	"Comment": "the update stage calculates the forward and inverse haarwavelet scaling\tfunctions. the forward haarwavelet scaling function is simply the average\tof the even and odd elements. the inverse function is found by simple\talgebraic manipulation, solving for the even element given the average\tand the odd element.\tin this version of the wavelet transform the update stage preceeds the\tpredict stage in the forward transform. in the inverse transform the\tpredict stage preceeds the update stage, reversing the calculation on the\todd elements.",
	"Method": "void update(float[] vec,int N,int direction){\r\n    int half = N >> 1;\r\n    for (int i = 0; i < half; i++) {\r\n        int j = i + half;\r\n        if (direction == forward) {\r\n            vec[i] = (vec[i] + vec[j]) / 2;\r\n        } else if (direction == inverse) {\r\n            vec[i] = (2 * vec[i]) - vec[j];\r\n        } else {\r\n            System.out.println(\"update: bad direction value\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.netbeans.modules.consumervisualvm.engine.FlashingIcon.startFlashing",
	"Comment": "start flashing of the icon. if the icon is already flashing, the timeris reset.if the icon is visible but not flashing, it starts flashing againand the disappear timer is reset.",
	"Method": "void startFlashing(){\r\n    synchronized (this) {\r\n        startTime = System.currentTimeMillis();\r\n        isIconVisible = !isIconVisible;\r\n        keepRunning = true;\r\n        keepFlashing = true;\r\n        if (null == timerTask) {\r\n            timerTask = RequestProcessor.getDefault().post(new Timer());\r\n        } else {\r\n            timerTask.run();\r\n        }\r\n        this.setVisible(true);\r\n    }\r\n    repaint();\r\n}"
}, {
	"Path": "jsyntaxpane.components.LineNumbersRuler.updateSize",
	"Comment": "update the size of the line numbers based on the length of the document",
	"Method": "void updateSize(){\r\n    int newLineCount = ActionUtils.getLineCount(pane);\r\n    if (newLineCount == lineCount) {\r\n        return;\r\n    }\r\n    lineCount = newLineCount;\r\n    int h = lineCount * charHeight + pane.getHeight();\r\n    int d = (int) Math.log10(lineCount) + 1;\r\n    if (d < 1) {\r\n        d = 1;\r\n    }\r\n    int w = d * charWidth + r_margin + l_margin;\r\n    format = \"%\" + d + \"d\";\r\n    setPreferredSize(new Dimension(w, h));\r\n    if (getParent() != null) {\r\n        getParent().doLayout();\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.example.dissonance.KernelDensityEstimate.optimalCorrelation",
	"Comment": "calculates the optimal correlation between two kernel density estimates\tby shifting and searching for optimal correlation.",
	"Method": "double optimalCorrelation(KernelDensityEstimate other,double optimalCorrelation,KDECorrelation correlationMeasure,KernelDensityEstimate other){\r\n    int shift = shiftForOptimalCorrelation(correlationMeasure, other);\r\n    return correlationMeasure.correlation(this, other, shift);\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.tracer.ProbeItemDescriptor.discreteLineFillItem",
	"Comment": "creates descriptor for a discrete item created by line segments representing the outline and filled segments.",
	"Method": "ProbeItemDescriptor discreteLineFillItem(String name,String description,ItemValueFormatter formatter,ProbeItemDescriptor discreteLineFillItem,String name,String description,ItemValueFormatter formatter,double dataFactor,long minValue,long maxValue){\r\n    return discreteOutlineItem(name, description, formatter, dataFactor, minValue, maxValue, DEFAULT_LINE_WIDTH, DEFAULT_COLOR, DEFAULT_COLOR);\r\n}"
}, {
	"Path": "com.facebook.swift.service.ThriftServerConfig.setTaskExpirationTimeout",
	"Comment": "sets a timeout period between receiving a request and the completion of that request. ifthe timeout expires before the request reaches the front of the queue and begins processing,the server will discard the request instead of processing it. if the timeout expires afterthe request has started processing, the server will send an error immediately, and discardthe result of request handling.",
	"Method": "ThriftServerConfig setTaskExpirationTimeout(Duration taskExpirationTimeout){\r\n    this.taskExpirationTimeout = taskExpirationTimeout;\r\n    return this;\r\n}"
}, {
	"Path": "be.tarsos.dsp.test.TestUtilities.audioBufferSine",
	"Comment": "constructs and returns a buffer of a two seconds long pure sine of 440hz\tsampled at 44.1khz.",
	"Method": "float[] audioBufferSine(float[] audioBufferSine,int numberOfSamples){\r\n    final double sampleRate = 44100.0;\r\n    final double f0 = 440.0;\r\n    final double amplitudeF0 = 0.5;\r\n    final float[] buffer = new float[numberOfSamples];\r\n    for (int sample = 0; sample < buffer.length; sample++) {\r\n        final double time = sample / sampleRate;\r\n        buffer[sample] = (float) (amplitudeF0 * Math.sin(2 * Math.PI * f0 * time));\r\n    }\r\n    return buffer;\r\n}"
}, {
	"Path": "be.tarsos.dsp.granulator.OptimizedGranulator.getFrameLinear",
	"Comment": "retrieves a frame of audio using linear interpolation. if the frame is\tnot in the sample range then zeros are returned.",
	"Method": "double getFrameLinear(double posInMS){\r\n    double result = 0.0;\r\n    double sampleNumber = msToSamples(posInMS);\r\n    int sampleNumberFloor = (int) Math.floor(sampleNumber);\r\n    if (sampleNumberFloor > 0 && sampleNumberFloor < audioBufferWatermark) {\r\n        double sampleNumberFraction = sampleNumber - sampleNumberFloor;\r\n        if (sampleNumberFloor == audioBufferWatermark - 1) {\r\n            result = audioBuffer[sampleNumberFloor];\r\n        } else {\r\n            double current = audioBuffer[sampleNumberFloor];\r\n            double next = audioBuffer[sampleNumberFloor];\r\n            result = (float) ((1 - sampleNumberFraction) * current + sampleNumberFraction * next);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.TMathContext.getPrecision",
	"Comment": "returns the precision. the precision is the number of digits used for anoperation. results are rounded to this precision. the precision isguaranteed to be non negative. if the precision is zero, then thecomputations have to be performed exact, results are not rounded in thiscase.",
	"Method": "int getPrecision(){\r\n    return precision;\r\n}"
}, {
	"Path": "be.tarsos.dsp.resample.Resampler.process",
	"Comment": "process a batch of samples. alternative interface if you prefer to work with arrays.",
	"Method": "boolean process(double factor,SampleBuffers buffers,boolean lastBatch,boolean process,double factor,FloatBuffer inputBuffer,boolean lastBatch,FloatBuffer outputBuffer,Result process,double factor,float[] inBuffer,int inBufferOffset,int inBufferLen,boolean lastBatch,float[] outBuffer,int outBufferOffset,int outBufferLen){\r\n    FloatBuffer inputBuffer = FloatBuffer.wrap(inBuffer, inBufferOffset, inBufferLen);\r\n    FloatBuffer outputBuffer = FloatBuffer.wrap(outBuffer, outBufferOffset, outBufferLen);\r\n    process(factor, inputBuffer, lastBatch, outputBuffer);\r\n    return new Result(inputBuffer.position() - inBufferOffset, outputBuffer.position() - outBufferOffset);\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.prefixPath",
	"Comment": "a filter that can be used to add a prefix to the path of a request before it is routed by the gateway.",
	"Method": "GatewayFilterSpec prefixPath(String prefix){\r\n    return filter(getBean(PrefixPathGatewayFilterFactory.class).apply(c -> c.setPrefix(prefix)));\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.peer.SharingPeer.send",
	"Comment": "send a message to the peer.delivery of the message can only happen if the peer is connected.",
	"Method": "void send(PeerMessage message){\r\n    logger.trace(\"Sending msg {} to {}\", message.getType(), this);\r\n    if (this.isConnected()) {\r\n        ByteBuffer data = message.getData();\r\n        data.rewind();\r\n        connectionManager.offerWrite(new WriteTask(socketChannel, data, new WriteListener() {\r\n            @Override\r\n            public void onWriteFailed(String message, Throwable e) {\r\n                if (e == null) {\r\n                    logger.info(message);\r\n                } else if (e instanceof ConnectionClosedException) {\r\n                    logger.debug(message, e);\r\n                    unbind(true);\r\n                } else {\r\n                    LoggerUtils.warnAndDebugDetails(logger, message, e);\r\n                }\r\n            }\r\n            @Override\r\n            public void onWriteDone() {\r\n            }\r\n        }), 1, TimeUnit.SECONDS);\r\n    } else {\r\n        logger.trace(\"Attempting to send a message to non-connected peer {}!\", this);\r\n        unbind(true);\r\n    }\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.peer.SharingPeer.send",
	"Comment": "send a message to the peer.delivery of the message can only happen if the peer is connected.",
	"Method": "void send(PeerMessage message){\r\n    if (e == null) {\r\n        logger.info(message);\r\n    } else if (e instanceof ConnectionClosedException) {\r\n        logger.debug(message, e);\r\n        unbind(true);\r\n    } else {\r\n        LoggerUtils.warnAndDebugDetails(logger, message, e);\r\n    }\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.peer.SharingPeer.send",
	"Comment": "send a message to the peer.delivery of the message can only happen if the peer is connected.",
	"Method": "void send(PeerMessage message){\r\n}"
}, {
	"Path": "com.turn.ttorrent.bcodec.BEValue.getMap",
	"Comment": "returns this bevalue as a map of string keys and bevalue values.",
	"Method": "Map<String, BEValue> getMap(){\r\n    if (this.value instanceof HashMap) {\r\n        return (Map<String, BEValue>) this.value;\r\n    } else {\r\n        throw new InvalidBEncodingException(\"Expected Map<String, BEValue> !\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.PredicateSpec.weight",
	"Comment": "a predicate which will select a route based on its assigned weight.the",
	"Method": "BooleanSpec weight(String group,int weight){\r\n    return asyncPredicate(getBean(WeightRoutePredicateFactory.class).applyAsync(c -> c.setGroup(group).setRouteId(routeBuilder.getId()).setWeight(weight)));\r\n}"
}, {
	"Path": "org.telegram.telegrambots.updatesreceivers.ExponentialBackOff.incrementCurrentInterval",
	"Comment": "increments the current interval by multiplying it with the multiplier.",
	"Method": "void incrementCurrentInterval(){\r\n    if (currentIntervalMillis >= maxIntervalMillis / multiplier) {\r\n        currentIntervalMillis = maxIntervalMillis;\r\n    } else {\r\n        currentIntervalMillis *= multiplier;\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.util.ConcurrencyUtils.getThreadsBeginN_1D_FFT_2Threads",
	"Comment": "returns the minimal size of 1d data for which two threads are used.",
	"Method": "int getThreadsBeginN_1D_FFT_2Threads(){\r\n    return THREADS_BEGIN_N_1D_FFT_2THREADS;\r\n}"
}, {
	"Path": "be.tarsos.dsp.util.ConcurrencyUtils.getThreadsBeginN_3D",
	"Comment": "returns the minimal size of 3d data for which threads are used.",
	"Method": "int getThreadsBeginN_3D(){\r\n    return THREADS_BEGIN_N_3D;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.text.TAttributedString.addAttributes",
	"Comment": "applies a given set of attributes to the given range of the string.",
	"Method": "void addAttributes(TMap<? extends TAttributedCharacterIterator.Attribute, ?> attributes,int start,int end){\r\n    TIterator<?> it = attributes.entrySet().iterator();\r\n    while (it.hasNext()) {\r\n        TMap.Entry<?, ?> entry = (TMap.Entry<?, ?>) it.next();\r\n        addAttribute((TAttributedCharacterIterator.Attribute) entry.getKey(), entry.getValue(), start, end);\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerDivideTest.testDivisionKnuthFirstDigitsEqual",
	"Comment": "verifies the case when the first digits of the dividendand divisor equal.",
	"Method": "void testDivisionKnuthFirstDigitsEqual(){\r\n    byte[] aBytes = { 2, -3, -4, -5, -1, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5 };\r\n    byte[] bBytes = { 2, -3, -4, -5, -1, -1, -1, -1 };\r\n    int aSign = -1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 0, -1, -1, -1, -1, -2, -88, -60, 41 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.divide(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.tracer.ProbeItemDescriptor.continuousLineFillItem",
	"Comment": "creates descriptor for a continuous item created by line and filled segments.",
	"Method": "ProbeItemDescriptor continuousLineFillItem(String name,String description,ItemValueFormatter formatter,ProbeItemDescriptor continuousLineFillItem,String name,String description,ItemValueFormatter formatter,double dataFactor,long minValue,long maxValue){\r\n    return continuousItem(name, description, formatter, dataFactor, minValue, maxValue, DEFAULT_LINE_WIDTH, DEFAULT_COLOR, DEFAULT_COLOR);\r\n}"
}, {
	"Path": "org.sqlite.date.FastDatePrinter.readObject",
	"Comment": "create the object after serialization. this implementation reinitializes thetransient properties.",
	"Method": "void readObject(ObjectInputStream in){\r\n    in.defaultReadObject();\r\n    init();\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.defineReadBridgeMethod",
	"Comment": "defines the generics bridge method with untyped args to the type specific read method.",
	"Method": "void defineReadBridgeMethod(){\r\n    classDefinition.addMethod(new MethodDefinition(a(PUBLIC, BRIDGE, SYNTHETIC), \"read\", type(Object.class), arg(\"protocol\", TProtocol.class)).addException(Exception.class).loadThis().loadVariable(\"protocol\").invokeVirtual(codecType, \"read\", structType, type(TProtocol.class)).retObject());\r\n}"
}, {
	"Path": "org.teavm.model.util.DominatorWalkerCallback.filter",
	"Comment": "called before visiting block. this method should tell whether this block and all of its descendant blocksshould be visited.",
	"Method": "boolean filter(BasicBlock block){\r\n    return true;\r\n}"
}, {
	"Path": "com.facebook.swift.codec.metadata.AbstractThriftMetadataBuilder.verifyFieldType",
	"Comment": "verifies that the the fields all have a supported java type and that all fields map to theexact same thrifttype.",
	"Method": "void verifyFieldType(short id,String name,Collection<FieldMetadata> fields,ThriftCatalog catalog){\r\n    boolean isSupportedType = true;\r\n    for (FieldMetadata field : fields) {\r\n        if (!catalog.isSupportedStructFieldType(field.getJavaType())) {\r\n            metadataErrors.addError(\"Thrift class '%s' field '%s(%s)' type '%s' is not a supported Java type\", structName, name, id, TypeToken.of(field.getJavaType()));\r\n            isSupportedType = false;\r\n            break;\r\n        }\r\n    }\r\n    if (isSupportedType) {\r\n        Set<ThriftTypeReference> types = new HashSet();\r\n        for (FieldMetadata field : fields) {\r\n            types.add(catalog.getFieldThriftTypeReference(field));\r\n        }\r\n        if (types.size() > 1) {\r\n            metadataErrors.addError(\"Thrift class '%s' field '%s(%s)' has multiple types: %s\", structName, name, id, types);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sqlite.SQLiteConfig.setSharedCache",
	"Comment": "enables or disables the sharing of the database cache and schema datastructures between connections to the same database.",
	"Method": "void setSharedCache(boolean enable){\r\n    set(Pragma.SHARED_CACHE, enable);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigDecimalArithmeticTest.testMultiplyMathContextDiffScalePosNeg",
	"Comment": "multiply two numbers of different scales using mathcontext",
	"Method": "void testMultiplyMathContextDiffScalePosNeg(){\r\n    String a = \"987667796597975765768768767866756808779810457634781384756794987\";\r\n    int aScale = 100;\r\n    String b = \"747233429293018787918347987234564568\";\r\n    int bScale = -70;\r\n    String c = \"7.3801839465418518653942222612429081498248509257207477E+68\";\r\n    int cScale = -16;\r\n    BigDecimal aNumber = new BigDecimal(new BigInteger(a), aScale);\r\n    BigDecimal bNumber = new BigDecimal(new BigInteger(b), bScale);\r\n    MathContext mc = new MathContext(53, RoundingMode.HALF_UP);\r\n    BigDecimal result = aNumber.multiply(bNumber, mc);\r\n    assertEquals(\"incorrect value\", c, result.toString());\r\n    assertEquals(\"incorrect scale\", cScale, result.scale());\r\n}"
}, {
	"Path": "jsyntaxpane.actions.ComboCompletionAction.config",
	"Comment": "the completions will for now reside on another properties style filereferenced by prefix.completions.file",
	"Method": "void config(Configuration config,String prefix,String name){\r\n    items = config.getPrefixPropertyList(prefix, name + \".Items\");\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TQuantifierSet.processSecondPass",
	"Comment": "this method is used for traversing nodes after the first stage ofcompilation.",
	"Method": "void processSecondPass(){\r\n    this.isSecondPassVisited = true;\r\n    if (next != null) {\r\n        if (!next.isSecondPassVisited) {\r\n            TJointSet set = next.processBackRefReplacement();\r\n            if (set != null) {\r\n                next.isSecondPassVisited = true;\r\n                next = set;\r\n            }\r\n            next.processSecondPass();\r\n        }\r\n    }\r\n    if (innerSet != null) {\r\n        if (!innerSet.isSecondPassVisited) {\r\n            TJointSet set = innerSet.processBackRefReplacement();\r\n            if (set != null) {\r\n                innerSet.isSecondPassVisited = true;\r\n                innerSet = set;\r\n            }\r\n            innerSet.processSecondPass();\r\n        } else {\r\n            if (innerSet instanceof TSingleSet && ((TFSet) ((TJointSet) innerSet).fSet).isBackReferenced) {\r\n                innerSet = innerSet.next;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.example.dissonance.KernelDensityEstimate.shiftForOptimalCorrelation",
	"Comment": "calculates how much the other kerneldensityestimate needs to be shifted\tfor optimal correlation.",
	"Method": "int shiftForOptimalCorrelation(KernelDensityEstimate other,int shiftForOptimalCorrelation,KDECorrelation correlationMeasure,KernelDensityEstimate other){\r\n    int optimalShift = 0;\r\n    double maximumCorrelation = -1;\r\n    for (int shift = 0; shift < size(); shift++) {\r\n        final double currentCorrelation = correlationMeasure.correlation(this, other, shift);\r\n        if (maximumCorrelation < currentCorrelation) {\r\n            maximumCorrelation = currentCorrelation;\r\n            optimalShift = shift;\r\n        }\r\n    }\r\n    return optimalShift;\r\n}"
}, {
	"Path": "com.turn.ttorrent.common.protocol.PeerMessage.parse",
	"Comment": "parse the given buffer into a peer protocol message.parses the provided byte array and builds the corresponding peermessagesubclass object.",
	"Method": "PeerMessage parse(ByteBuffer buffer,TorrentInfo torrent,KeepAliveMessage parse,ByteBuffer buffer,TorrentInfo torrent,ChokeMessage parse,ByteBuffer buffer,TorrentInfo torrent,UnchokeMessage parse,ByteBuffer buffer,TorrentInfo torrent,InterestedMessage parse,ByteBuffer buffer,TorrentInfo torrent,NotInterestedMessage parse,ByteBuffer buffer,TorrentInfo torrent,HaveMessage parse,ByteBuffer buffer,TorrentInfo torrent,BitfieldMessage parse,ByteBuffer buffer,TorrentInfo torrent,RequestMessage parse,ByteBuffer buffer,TorrentInfo torrent,PieceMessage parse,ByteBuffer buffer,TorrentInfo torrent,CancelMessage parse,ByteBuffer buffer,TorrentInfo torrent){\r\n    int length = buffer.getInt();\r\n    if (length == 0) {\r\n        return KeepAliveMessage.parse(buffer, torrent);\r\n    } else if (length != buffer.remaining()) {\r\n        throw new ParseException(\"Message size did not match announced \" + \"size!\", 0);\r\n    }\r\n    Type type = Type.get(buffer.get());\r\n    if (type == null) {\r\n        throw new ParseException(\"Unknown message ID!\", buffer.position() - 1);\r\n    }\r\n    switch(type) {\r\n        case CHOKE:\r\n            return ChokeMessage.parse(buffer.slice(), torrent);\r\n        case UNCHOKE:\r\n            return UnchokeMessage.parse(buffer.slice(), torrent);\r\n        case INTERESTED:\r\n            return InterestedMessage.parse(buffer.slice(), torrent);\r\n        case NOT_INTERESTED:\r\n            return NotInterestedMessage.parse(buffer.slice(), torrent);\r\n        case HAVE:\r\n            return HaveMessage.parse(buffer.slice(), torrent);\r\n        case BITFIELD:\r\n            return BitfieldMessage.parse(buffer.slice(), torrent);\r\n        case REQUEST:\r\n            return RequestMessage.parse(buffer.slice(), torrent);\r\n        case PIECE:\r\n            return PieceMessage.parse(buffer.slice(), torrent);\r\n        case CANCEL:\r\n            return CancelMessage.parse(buffer.slice(), torrent);\r\n        default:\r\n            throw new IllegalStateException(\"Message type should have \" + \"been properly defined by now.\");\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.util.ConcurrencyUtils.getThreadsBeginN_2D",
	"Comment": "returns the minimal size of 2d data for which threads are used.",
	"Method": "int getThreadsBeginN_2D(){\r\n    return THREADS_BEGIN_N_2D;\r\n}"
}, {
	"Path": "com.facebook.swift.service.ThriftServerConfig.setConnectionLimit",
	"Comment": "sets an upper bound on the number of concurrent connections the server will accept.the default is not to limit the number of connections.",
	"Method": "ThriftServerConfig setConnectionLimit(int connectionLimit){\r\n    this.connectionLimit = connectionLimit;\r\n    return this;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigDecimalArithmeticTest.testMultiplyMathContextDiffScaleNegPos",
	"Comment": "multiply two numbers of different scales using mathcontext",
	"Method": "void testMultiplyMathContextDiffScaleNegPos(){\r\n    String a = \"488757458676796558668876576576579097029810457634781384756794987\";\r\n    int aScale = -63;\r\n    String b = \"747233429293018787918347987234564568\";\r\n    int bScale = 63;\r\n    String c = \"3.6521591193960361339707130098174381429788164316E+98\";\r\n    int cScale = -52;\r\n    BigDecimal aNumber = new BigDecimal(new BigInteger(a), aScale);\r\n    BigDecimal bNumber = new BigDecimal(new BigInteger(b), bScale);\r\n    MathContext mc = new MathContext(47, RoundingMode.HALF_UP);\r\n    BigDecimal result = aNumber.multiply(bNumber, mc);\r\n    assertEquals(\"incorrect value\", c, result.toString());\r\n    assertEquals(\"incorrect scale\", cScale, result.scale());\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.requestHeaderToRequestUri",
	"Comment": "a filter which changes the uri the request will be routed to by the gateway by pulling it from a header on the\trequest.",
	"Method": "GatewayFilterSpec requestHeaderToRequestUri(String headerName){\r\n    return filter(getBean(RequestHeaderToRequestUriGatewayFilterFactory.class).apply(c -> c.setName(headerName)));\r\n}"
}, {
	"Path": "be.tarsos.dsp.wavelet.lift.LiftingSchemeBaseWavelet.split",
	"Comment": "split the vec into even and odd elements, where the even elements\tare in the first half of the vector and the odd elements are in the\tsecond half.",
	"Method": "void split(float[] vec,int N){\r\n    int start = 1;\r\n    int end = N - 1;\r\n    while (start < end) {\r\n        for (int i = start; i < end; i = i + 2) {\r\n            float tmp = vec[i];\r\n            vec[i] = vec[i + 1];\r\n            vec[i + 1] = tmp;\r\n        }\r\n        start = start + 1;\r\n        end = end - 1;\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.net.TURI.isAbsolute",
	"Comment": "indicates whether this uri is absolute, which means that a scheme part isdefined in this uri.",
	"Method": "boolean isAbsolute(){\r\n    return absolute;\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.modifyResponseBody",
	"Comment": "a filter that can be used to modify the response body\tthis filter is beta and may be subject to change in a future release.",
	"Method": "GatewayFilterSpec modifyResponseBody(Class<T> inClass,Class<R> outClass,RewriteFunction<T, R> rewriteFunction,GatewayFilterSpec modifyResponseBody,Class<T> inClass,Class<R> outClass,String newContentType,RewriteFunction<T, R> rewriteFunction){\r\n    return filter(getBean(ModifyResponseBodyGatewayFilterFactory.class).apply(c -> c.setRewriteFunction(inClass, outClass, rewriteFunction).setNewContentType(newContentType)));\r\n}"
}, {
	"Path": "be.tarsos.dsp.beatroot.AgentList.sort",
	"Comment": "sorts the agentlist by increasing beatinterval, using a bubble sort\t since it is assumed that the list is almost sorted.",
	"Method": "void sort(){\r\n    boolean sorted = false;\r\n    while (!sorted) {\r\n        sorted = true;\r\n        for (AgentList ptr = this; ptr.ag != null; ptr = ptr.next) {\r\n            if ((ptr.next.ag != null) && (ptr.ag.beatInterval > ptr.next.ag.beatInterval)) {\r\n                Agent temp = ptr.ag;\r\n                ptr.ag = ptr.next.ag;\r\n                ptr.next.ag = temp;\r\n                sorted = false;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.PredicateSpec.path",
	"Comment": "a predicate that checks if the path of the request matches the given pattern",
	"Method": "BooleanSpec path(String pattern,BooleanSpec path,String pattern,boolean matchOptionalTrailingSeparator){\r\n    return asyncPredicate(getBean(PathRoutePredicateFactory.class).applyAsync(c -> c.setPattern(pattern).setMatchOptionalTrailingSeparator(matchOptionalTrailingSeparator)));\r\n}"
}, {
	"Path": "be.tarsos.dsp.example.KernelDensityEstimate.remove",
	"Comment": "remove a value from the kde, removes a kernel at the specified position.",
	"Method": "void remove(double value){\r\n    int accumulatorSize = accumulator.length;\r\n    int calculationAria = kernel.size() / 2;\r\n    int start = (int) (value + accumulatorSize - calculationAria);\r\n    int stop = (int) (value + accumulatorSize + calculationAria);\r\n    if (kernel.size() % 2 != 0)\r\n        stop++;\r\n    for (int i = start; i < stop; i++) {\r\n        double kernelValue = kernel.value(i - start);\r\n        accumulator[i % accumulatorSize] -= kernelValue;\r\n        sum -= kernelValue;\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testFloatValueNegRounded1",
	"Comment": "convert a positive number to a float value.rounding is needed.",
	"Method": "void testFloatValueNegRounded1(){\r\n    byte[] a = { -128, 1, -1, -4, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = -1;\r\n    float result = -1.5475195E26f;\r\n    float aNumber = new BigInteger(aSign, a).floatValue();\r\n    assertEquals(aNumber, result, 1E20);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testFloatValueNegRounded2",
	"Comment": "convert a positive number to a float value.rounding is needed.the rounding bit is 1 and the next bit to the left is 0but some of dropped bits are 1s.",
	"Method": "void testFloatValueNegRounded2(){\r\n    byte[] a = { -128, 1, 2, -128, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = -1;\r\n    float result = -1.5474728E26f;\r\n    float aNumber = new BigInteger(aSign, a).floatValue();\r\n    assertEquals(aNumber, result, 1E20);\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.tracer.TracerProbe.getItemDescriptors",
	"Comment": "returns descriptors of ui appearance of items provided by the probe.",
	"Method": "ProbeItemDescriptor[] getItemDescriptors(){\r\n    return itemDescriptors;\r\n}"
}, {
	"Path": "org.telegram.telegrambots.extensions.bots.commandbot.commands.helpCommand.HelpCommand.getHelpText",
	"Comment": "returns the command and description of all supplied commands as a formatted string",
	"Method": "String getHelpText(IBotCommand botCommands,String getHelpText,Collection<IBotCommand> botCommands,String getHelpText,ICommandRegistry registry){\r\n    return getHelpText(registry.getRegisteredCommands());\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.defineGetTypeMethod",
	"Comment": "defines the gettype method which simply returns the value of the type field.",
	"Method": "void defineGetTypeMethod(){\r\n    classDefinition.addMethod(new MethodDefinition(a(PUBLIC), \"getType\", type(ThriftType.class)).loadThis().getField(codecType, typeField).retObject());\r\n}"
}, {
	"Path": "org.telegram.telegrambots.updatesreceivers.ExponentialBackOff.getMaxIntervalMillis",
	"Comment": "returns the maximum value of the back off period in milliseconds. once the current intervalreaches this value it stops increasing.",
	"Method": "int getMaxIntervalMillis(int getMaxIntervalMillis){\r\n    return maxIntervalMillis;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TLexer.isSpecial",
	"Comment": "returns true, if current token is special, i.e. quantifier, or othercompound token.",
	"Method": "boolean isSpecial(){\r\n    return curST != null;\r\n}"
}, {
	"Path": "org.sqlite.SQLiteConnection.extractPragmasFromFilename",
	"Comment": "extracts pragma values from the filename and sets them into the propertiesobject which will be used to build the sqlconfig.the sanitized filenameis returned.",
	"Method": "String extractPragmasFromFilename(String url,String filename,Properties prop){\r\n    int parameterDelimiter = filename.indexOf('?');\r\n    if (parameterDelimiter == -1) {\r\n        return filename;\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(filename.substring(0, parameterDelimiter));\r\n    int nonPragmaCount = 0;\r\n    String[] parameters = filename.substring(parameterDelimiter + 1).split(\"&\");\r\n    for (int i = 0; i < parameters.length; i++) {\r\n        String parameter = parameters[parameters.length - 1 - i].trim();\r\n        if (parameter.isEmpty()) {\r\n            continue;\r\n        }\r\n        String[] kvp = parameter.split(\"=\");\r\n        String key = kvp[0].trim().toLowerCase();\r\n        if (SQLiteConfig.pragmaSet.contains(key)) {\r\n            if (kvp.length == 1) {\r\n                throw new SQLException(String.format(\"Please specify a value for PRAGMA %s in URL %s\", key, url));\r\n            }\r\n            String value = kvp[1].trim();\r\n            if (!value.isEmpty()) {\r\n                if (prop.containsKey(key)) {\r\n                } else {\r\n                    prop.setProperty(key, value);\r\n                }\r\n            }\r\n        } else {\r\n            sb.append(nonPragmaCount == 0 ? '?' : '&');\r\n            sb.append(parameter);\r\n            nonPragmaCount++;\r\n        }\r\n    }\r\n    final String newFilename = sb.toString();\r\n    return newFilename;\r\n}"
}, {
	"Path": "be.tarsos.dsp.granulator.Granulator.getFrameNoInterp",
	"Comment": "retrieves a frame of audio using no interpolation. if the frame is not in\tthe sample range then zeros are returned.",
	"Method": "float getFrameNoInterp(double posInMS){\r\n    double frame = msToSamples(posInMS);\r\n    int frame_floor = (int) Math.floor(frame);\r\n    return audioBuffer[frame_floor];\r\n}"
}, {
	"Path": "org.springframework.boot.loader.tools.Repackager.setLayoutFactory",
	"Comment": "sets the layout factory for the jar. the factory can be used when no specific\tlayout is specified.",
	"Method": "void setLayoutFactory(LayoutFactory layoutFactory){\r\n    this.layoutFactory = layoutFactory;\r\n}"
}, {
	"Path": "org.sqlite.SQLiteConfig.setDefaultCacheSize",
	"Comment": "sets the suggested maximum number of database disk pages that sqlite willhold in memory at once per open database file. the cache size set herepersists across database connections.",
	"Method": "void setDefaultCacheSize(int numberOfPages){\r\n    set(Pragma.DEFAULT_CACHE_SIZE, numberOfPages);\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.SharedTorrent.getAvailablePieces",
	"Comment": "return a copy of the bit field of available pieces for this torrent.available pieces are pieces available in the swarm, and it does notinclude our own pieces.",
	"Method": "BitSet getAvailablePieces(){\r\n    if (!this.isInitialized()) {\r\n        throw new IllegalStateException(\"Torrent not yet initialized!\");\r\n    }\r\n    BitSet availablePieces = new BitSet(this.pieces.length);\r\n    synchronized (this.pieces) {\r\n        for (Piece piece : this.pieces) {\r\n            if (piece.available()) {\r\n                availablePieces.set(piece.getIndex());\r\n            }\r\n        }\r\n    }\r\n    return availablePieces;\r\n}"
}, {
	"Path": "be.tarsos.dsp.AudioDispatcher.setZeroPadLastBuffer",
	"Comment": "if zero pad last buffer is true then the last buffer is filled with zeros until the normal amount\tof elements are present in the buffer. otherwise the buffer only contains the last elements and no zeros.\tby default it is set to true.",
	"Method": "void setZeroPadLastBuffer(boolean zeroPadLastBuffer){\r\n    this.zeroPadLastBuffer = zeroPadLastBuffer;\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.support.CachedBodyOutputMessage.setWriteHandler",
	"Comment": "configure a custom handler for writing the request body.\tthe default write handler consumes and caches the request body so it\tmay be accessed subsequently, e.g. in test assertions. use this property\twhen the request body is an infinite stream.",
	"Method": "void setWriteHandler(Function<Flux<DataBuffer>, Mono<Void>> writeHandler){\r\n    Assert.notNull(writeHandler, \"'writeHandler' is required\");\r\n    this.writeHandler = writeHandler;\r\n}"
}, {
	"Path": "org.telegram.abilitybots.api.bot.BaseAbilityBot.registerAbilities",
	"Comment": "registers the declared abilities using method reflection. also, replies are accumulated using the built abilities and standalone methods that return a reply.only abilities and replies with the public accessor are registered!",
	"Method": "void registerAbilities(){\r\n    try {\r\n        abilities = stream(this.getClass().getMethods()).filter(method -> method.getReturnType().equals(Ability.class)).map(this::returnAbility).collect(ImmutableMap::<String, Ability>builder, (b, a) -> b.put(a.name(), a), (b1, b2) -> b1.putAll(b2.build())).build();\r\n        Stream<Reply> methodReplies = stream(this.getClass().getMethods()).filter(method -> method.getReturnType().equals(Reply.class)).map(this::returnReply);\r\n        Stream<Reply> abilityReplies = abilities.values().stream().flatMap(ability -> ability.replies().stream());\r\n        replies = Stream.concat(methodReplies, abilityReplies).collect(ImmutableList::<Reply>builder, Builder::add, (b1, b2) -> b1.addAll(b2.build())).build();\r\n    } catch (IllegalStateException e) {\r\n        BotLogger.error(TAG, \"Duplicate names found while registering abilities. Make sure that the abilities declared don't clash with the reserved ones.\", e);\r\n        throw propagate(e);\r\n    }\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.Piece.available",
	"Comment": "tells whether this piece is available in the current connected peer swarm.",
	"Method": "boolean available(){\r\n    return this.seen > 0;\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.setPath",
	"Comment": "a filter that sets the path of the request before it is routed by the gateway.",
	"Method": "GatewayFilterSpec setPath(String template){\r\n    return filter(getBean(SetPathGatewayFilterFactory.class).apply(c -> c.setTemplate(template)));\r\n}"
}, {
	"Path": "be.tarsos.dsp.test.AudioDispatcherTest.testFirstAndLastBuffer",
	"Comment": "tests the case when the first buffer is immediately the last.",
	"Method": "void testFirstAndLastBuffer(){\r\n    testFirstAndLastBufferForStream(getAudioInputStream());\r\n    testFirstAndLastBufferForStream(getAudioInputStreamPiped());\r\n}"
}, {
	"Path": "be.tarsos.dsp.example.KernelDensityEstimate.shiftForOptimalCorrelation",
	"Comment": "calculates how much the other kerneldensityestimate needs to be shifted\tfor optimal correlation.",
	"Method": "int shiftForOptimalCorrelation(KernelDensityEstimate other,int shiftForOptimalCorrelation,KDECorrelation correlationMeasure,KernelDensityEstimate other){\r\n    int optimalShift = 0;\r\n    double maximumCorrelation = -1;\r\n    for (int shift = 0; shift < size(); shift++) {\r\n        final double currentCorrelation = correlationMeasure.correlation(this, other, shift);\r\n        if (maximumCorrelation < currentCorrelation) {\r\n            maximumCorrelation = currentCorrelation;\r\n            optimalShift = shift;\r\n        }\r\n    }\r\n    return optimalShift;\r\n}"
}, {
	"Path": "be.tarsos.dsp.granulator.OptimizedGranulator.getFrameCubic",
	"Comment": "retrieves a frame of audio using cubic interpolation. if the frame is not\tin the sample range then zeros are returned.",
	"Method": "float getFrameCubic(double posInMS){\r\n    float frame = (float) msToSamples(posInMS);\r\n    float result = 0.0f;\r\n    float a0, a1, a2, a3, mu2;\r\n    float ym1, y0, y1, y2;\r\n    int realCurrentSample = (int) Math.floor(frame);\r\n    float fractionOffset = (float) (frame - realCurrentSample);\r\n    if (realCurrentSample >= 0 && realCurrentSample < (audioBufferWatermark - 1)) {\r\n        realCurrentSample--;\r\n        if (realCurrentSample < 0) {\r\n            ym1 = audioBuffer[0];\r\n            realCurrentSample = 0;\r\n        } else {\r\n            ym1 = audioBuffer[realCurrentSample++];\r\n        }\r\n        y0 = audioBuffer[realCurrentSample++];\r\n        if (realCurrentSample >= audioBufferWatermark) {\r\n            y1 = audioBuffer[audioBufferWatermark - 1];\r\n        } else {\r\n            y1 = audioBuffer[realCurrentSample++];\r\n        }\r\n        if (realCurrentSample >= audioBufferWatermark) {\r\n            y2 = audioBuffer[audioBufferWatermark - 1];\r\n        } else {\r\n            y2 = audioBuffer[realCurrentSample++];\r\n        }\r\n        mu2 = fractionOffset * fractionOffset;\r\n        a0 = y2 - y1 - ym1 + y0;\r\n        a1 = ym1 - y0 - a0;\r\n        a2 = y1 - ym1;\r\n        a3 = y0;\r\n        result = a0 * fractionOffset * mu2 + a1 * mu2 + a2 * fractionOffset + a3;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.buildUnion",
	"Comment": "defines the code to build the struct instance using the data in the local variables.",
	"Method": "LocalVariableDefinition buildUnion(MethodDefinition read,Map<Short, LocalVariableDefinition> unionData){\r\n    LocalVariableDefinition instance = constructUnionInstance(read);\r\n    read.loadVariable(\"fieldId\");\r\n    List<CaseStatement> cases = new ArrayList();\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        cases.add(caseStatement(field.getId(), field.getName() + \"-inject-field\"));\r\n    }\r\n    read.switchStatement(\"inject-default\", cases);\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        read.visitLabel(field.getName() + \"-inject-field\");\r\n        injectField(read, field, instance, unionData.get(field.getId()));\r\n        if (field.getMethodInjection().isPresent()) {\r\n            injectMethod(read, field.getMethodInjection().get(), instance, unionData);\r\n        }\r\n        read.gotoLabel(\"inject-default\");\r\n    }\r\n    read.visitLabel(\"inject-default\");\r\n    ThriftFieldMetadata idField = getOnlyElement(metadata.getFields(THRIFT_UNION_ID));\r\n    injectIdField(read, idField, instance, unionData);\r\n    invokeFactoryMethod(read, unionData, instance);\r\n    return instance;\r\n}"
}, {
	"Path": "be.tarsos.dsp.experimental.AudioDispatcher.removeAudioProcessor",
	"Comment": "removes an audioprocessor to the chain of processors and calls processingfinished.",
	"Method": "void removeAudioProcessor(AudioProcessor audioProcessor){\r\n    audioProcessors.remove(audioProcessor);\r\n    audioProcessor.processingFinished();\r\n    LOG.fine(\"Remove an audioprocessor to the list of processors: \" + audioProcessor.toString());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.TBitLevel.flipBit",
	"Comment": "performs a flipbit on the biginteger, returning a biginteger with the thespecified bit flipped.",
	"Method": "TBigInteger flipBit(TBigInteger val,int n){\r\n    int resSign = (val.sign == 0) ? 1 : val.sign;\r\n    int intCount = n >> 5;\r\n    int bitN = n & 31;\r\n    int resLength = Math.max(intCount + 1, val.numberLength) + 1;\r\n    int[] resDigits = new int[resLength];\r\n    int i;\r\n    int bitNumber = 1 << bitN;\r\n    System.arraycopy(val.digits, 0, resDigits, 0, val.numberLength);\r\n    if (val.sign < 0) {\r\n        if (intCount >= val.numberLength) {\r\n            resDigits[intCount] = bitNumber;\r\n        } else {\r\n            int firstNonZeroDigit = val.getFirstNonzeroDigit();\r\n            if (intCount > firstNonZeroDigit) {\r\n                resDigits[intCount] ^= bitNumber;\r\n            } else if (intCount < firstNonZeroDigit) {\r\n                resDigits[intCount] = -bitNumber;\r\n                for (i = intCount + 1; i < firstNonZeroDigit; i++) {\r\n                    resDigits[i] = -1;\r\n                }\r\n                resDigits[i] = resDigits[i]--;\r\n            } else {\r\n                i = intCount;\r\n                resDigits[i] = -((-resDigits[intCount]) ^ bitNumber);\r\n                if (resDigits[i] == 0) {\r\n                    for (i++; resDigits[i] == -1; i++) {\r\n                        resDigits[i] = 0;\r\n                    }\r\n                    resDigits[i]++;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        resDigits[intCount] ^= bitNumber;\r\n    }\r\n    TBigInteger result = new TBigInteger(resSign, resLength, resDigits);\r\n    result.cutOffLeadingZeroes();\r\n    return result;\r\n}"
}, {
	"Path": "org.sqlite.SQLiteJDBCLoader.loadNativeLibrary",
	"Comment": "loads native library using the given path and name of the library.",
	"Method": "boolean loadNativeLibrary(String path,String name){\r\n    File libPath = new File(path, name);\r\n    if (libPath.exists()) {\r\n        try {\r\n            System.load(new File(path, name).getAbsolutePath());\r\n            return true;\r\n        } catch (UnsatisfiedLinkError e) {\r\n            System.err.println(\"Failed to load native library:\" + name + \". osinfo: \" + OSInfo.getNativeLibFolderPathForCurrentOS());\r\n            System.err.println(e);\r\n            return false;\r\n        }\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "jsyntaxpane.DefaultSyntaxKit.getProperty",
	"Comment": "return the property with the given key.if the kit is notinitialized,then calls initkitbe careful when changing property as the default property may be used",
	"Method": "String getProperty(String key){\r\n    if (!initialized) {\r\n        initKit();\r\n    }\r\n    return CONFIG.getProperty(key);\r\n}"
}, {
	"Path": "org.telegram.abilitybots.api.bot.BaseAbilityBot.onUpdateReceived",
	"Comment": "this method contains the stream of actions that are applied on any update.it will correctly handle addition of users into the db and the execution of abilities and replies.",
	"Method": "void onUpdateReceived(Update update){\r\n    BotLogger.info(format(\"New update [%s] received at %s\", update.getUpdateId(), now()), format(\"%s - %s\", TAG, botUsername));\r\n    BotLogger.info(update.toString(), TAG);\r\n    long millisStarted = System.currentTimeMillis();\r\n    Stream.of(update).filter(this::checkGlobalFlags).filter(this::checkBlacklist).map(this::addUser).filter(this::filterReply).map(this::getAbility).filter(this::validateAbility).filter(this::checkPrivacy).filter(this::checkLocality).filter(this::checkInput).filter(this::checkMessageFlags).map(this::getContext).map(this::consumeUpdate).forEach(this::postConsumption);\r\n    long processingTime = System.currentTimeMillis() - millisStarted;\r\n    BotLogger.info(format(\"Processing of update [%s] ended at %s%n---> Processing time: [%d ms] <---%n\", update.getUpdateId(), now(), processingTime), format(\"%s - %s\", TAG, botUsername));\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testFloatValueNegNotRounded",
	"Comment": "convert a positive number to a float value.rounding is not needed.",
	"Method": "void testFloatValueNegNotRounded(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = -1;\r\n    float result = -1.5474726E26f;\r\n    float aNumber = new BigInteger(aSign, a).floatValue();\r\n    assertEquals(aNumber, result, 1E20);\r\n}"
}, {
	"Path": "com.facebook.swift.codec.metadata.ReflectionHelper.findAnnotatedMethods",
	"Comment": "find methods that are tagged with a given annotation somewhere in the hierarchy",
	"Method": "Collection<Method> findAnnotatedMethods(Class<?> type,Class<? extends Annotation> annotation){\r\n    List<Method> result = new ArrayList();\r\n    for (Method method : type.getMethods()) {\r\n        if (method.isSynthetic() || method.isBridge() || isStatic(method.getModifiers())) {\r\n            continue;\r\n        }\r\n        Method managedMethod = findAnnotatedMethod(type, annotation, method.getName(), method.getParameterTypes());\r\n        if (managedMethod != null) {\r\n            result.add(managedMethod);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TWordBoundary.hasConsumed",
	"Comment": "returns false, because word boundary does not consumes any characters anddo not move string index.",
	"Method": "boolean hasConsumed(TMatchResultImpl matchResult){\r\n    return false;\r\n}"
}, {
	"Path": "org.sqlite.date.FastDatePrinter.getTimeZoneDisplay",
	"Comment": "gets the time zone display name, using a cache for performance.",
	"Method": "String getTimeZoneDisplay(TimeZone tz,boolean daylight,int style,Locale locale){\r\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\r\n    String value = cTimeZoneDisplayCache.get(key);\r\n    if (value == null) {\r\n        value = tz.getDisplayName(daylight, style, locale);\r\n        final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\r\n        if (prior != null) {\r\n            value = prior;\r\n        }\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.sqlite.date.FastDateFormat.getDateInstance",
	"Comment": "gets a date formatter instance using the specified style, timezone and locale.",
	"Method": "FastDateFormat getDateInstance(int style,FastDateFormat getDateInstance,int style,Locale locale,FastDateFormat getDateInstance,int style,TimeZone timeZone,FastDateFormat getDateInstance,int style,TimeZone timeZone,Locale locale){\r\n    return cache.getDateInstance(style, timeZone, locale);\r\n}"
}, {
	"Path": "jsyntaxpane.SyntaxStyles.setGraphicsStyle",
	"Comment": "set the graphics font and others to the style for the given token",
	"Method": "void setGraphicsStyle(Graphics g,TokenType type){\r\n    Font c = g.getFont();\r\n    SyntaxStyle ss = styles.get(type);\r\n    if (ss != null) {\r\n        g.setFont(g.getFont().deriveFont(ss.getFontStyle()));\r\n        g.setColor(ss.getColor());\r\n    } else {\r\n        g.setFont(g.getFont().deriveFont(Font.PLAIN));\r\n        g.setColor(Color.BLACK);\r\n    }\r\n}"
}, {
	"Path": "org.sqlite.ProgressHandler.clearHandler",
	"Comment": "clears any progress handler registered with the connection.",
	"Method": "void clearHandler(Connection conn){\r\n    SQLiteConnection sqliteConnection = (SQLiteConnection) conn;\r\n    sqliteConnection.getDatabase().clear_progress_handler();\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.readFieldValues",
	"Comment": "defines the code to read all of the data from the protocol into local variables.",
	"Method": "Map<Short, LocalVariableDefinition> readFieldValues(MethodDefinition read){\r\n    LocalVariableDefinition protocol = read.getLocalVariable(\"reader\");\r\n    Map<Short, LocalVariableDefinition> structData = new TreeMap();\r\n    for (ThriftFieldMetadata field : metadata.getFields(FieldKind.THRIFT_FIELD)) {\r\n        LocalVariableDefinition variable = read.addInitializedLocalVariable(toParameterizedType(field.getThriftType()), \"f_\" + field.getName());\r\n        structData.put(field.getId(), variable);\r\n    }\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"readStructBegin\", void.class);\r\n    read.visitLabel(\"while-begin\");\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"nextField\", boolean.class);\r\n    read.ifZeroGoto(\"while-end\");\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"getFieldId\", short.class);\r\n    List<CaseStatement> cases = new ArrayList();\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        cases.add(caseStatement(field.getId(), field.getName() + \"-field\"));\r\n    }\r\n    read.switchStatement(\"default\", cases);\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        read.visitLabel(field.getName() + \"-field\");\r\n        read.loadVariable(protocol);\r\n        FieldDefinition codecField = codecFields.get(field.getId());\r\n        if (codecField != null) {\r\n            read.loadThis().getField(codecType, codecField);\r\n        }\r\n        Method readMethod = getReadMethod(field.getThriftType());\r\n        if (readMethod == null) {\r\n            throw new IllegalArgumentException(\"Unsupported field type \" + field.getThriftType().getProtocolType());\r\n        }\r\n        read.invokeVirtual(readMethod);\r\n        if (needsCastAfterRead(field, readMethod)) {\r\n            read.checkCast(toParameterizedType(field.getThriftType()));\r\n        }\r\n        if (field.getCoercion().isPresent()) {\r\n            read.invokeStatic(field.getCoercion().get().getFromThrift());\r\n        }\r\n        read.storeVariable(structData.get(field.getId()));\r\n        read.gotoLabel(\"while-begin\");\r\n    }\r\n    read.visitLabel(\"default\").loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"skipFieldData\", void.class).gotoLabel(\"while-begin\");\r\n    read.visitLabel(\"while-end\");\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"readStructEnd\", void.class);\r\n    return structData;\r\n}"
}, {
	"Path": "com.oreilly.springdata.gemfire.core.GemfireCustomerRepository.findAll",
	"Comment": "returns all objects in the region. not advisable for very large data sets.",
	"Method": "List<Customer> findAll(){\r\n    return new ArrayList<Customer>((Collection<? extends Customer>) template.getRegion().values());\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.mbeans.Utils.getParameters",
	"Comment": "this method is responsible for converting the inputs given by the userinto a useful object array for passing into a parameter array.",
	"Method": "Object[] getParameters(XTextField[] inputs,String[] params){\r\n    Object[] result = new Object[inputs.length];\r\n    Object userInput;\r\n    for (int i = 0; i < inputs.length; i++) {\r\n        userInput = inputs[i].getValue();\r\n        if (userInput instanceof XObject) {\r\n            result[i] = ((XObject) userInput).getObject();\r\n        } else {\r\n            result[i] = createObjectFromString(params[i].toString(), (String) userInput);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "be.tarsos.dsp.wavelet.lift.PolynomialWavelets.forwardTrans",
	"Comment": "polynomial wavelet lifting scheme transform.\tthis version of the forwardtrans function overrides the function in the\tliftingschemebasewavelet base class. this function introduces an extra\tpolynomial interpolation stage at the end of the transform.",
	"Method": "void forwardTrans(float[] vec){\r\n    final int N = vec.length;\r\n    for (int n = N; n > 1; n = n >> 1) {\r\n        split(vec, n);\r\n        update(vec, n, forward);\r\n        predict(vec, n, forward);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.defineConstructor",
	"Comment": "defines the constructor with a parameter for the thrifttype and the delegate codecs. theconstructor simply assigns these parameters to the class fields.",
	"Method": "void defineConstructor(){\r\n    MethodDefinition constructor = new MethodDefinition(a(PUBLIC), \"<init>\", type(void.class), parameters.getParameters());\r\n    constructor.loadThis().invokeConstructor(type(Object.class));\r\n    for (FieldDefinition fieldDefinition : parameters.getFields()) {\r\n        constructor.loadThis().loadVariable(fieldDefinition.getName()).putField(codecType, fieldDefinition);\r\n    }\r\n    constructor.ret();\r\n    classDefinition.addMethod(constructor);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.net.TURISyntaxException.getMessage0",
	"Comment": "gets a description of the exception, including the reason, the stringthat caused the syntax error and the position of the syntax error ifavailable.",
	"Method": "TString getMessage0(){\r\n    return TString.wrap(\"\");\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.TObservable.addObserver",
	"Comment": "adds the specified observer to the list of observers. if it is alreadyregistered, it is not added a second time.",
	"Method": "void addObserver(TObserver observer){\r\n    if (observer == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    synchronized (this) {\r\n        if (!observers.contains(observer)) {\r\n            observers.add(observer);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.tracer.ProbeItemDescriptor.continuousLineItem",
	"Comment": "creates descriptor for a continuous item created by line segments.",
	"Method": "ProbeItemDescriptor continuousLineItem(String name,String description,ItemValueFormatter formatter,ProbeItemDescriptor continuousLineItem,String name,String description,ItemValueFormatter formatter,double dataFactor,long minValue,long maxValue){\r\n    return continuousItem(name, description, formatter, dataFactor, minValue, maxValue, DEFAULT_LINE_WIDTH, DEFAULT_COLOR, null);\r\n}"
}, {
	"Path": "org.sqlite.SQLiteDataSource.setSharedCache",
	"Comment": "enables or disables the sharing of the database cache and schema datastructures between connections to the same database.",
	"Method": "void setSharedCache(boolean enable){\r\n    config.setSharedCache(enable);\r\n}"
}, {
	"Path": "be.tarsos.dsp.experimental.AudioDispatcher.readNextAudioBlock",
	"Comment": "reads the next audio block. it tries to read the number of bytes defined\tby the audio buffer size minus the overlap. if the expected number of\tbytes could not be read either the end of the stream is reached or\tsomething went wrong.\tthe behavior for the first and last buffer is defined by their corresponding the zero pad settings. the method also handles the case if\tthe first buffer is also the last.",
	"Method": "int readNextAudioBlock(){\r\n    assert floatOverlap < audioFloatBuffer.length;\r\n    boolean isFirstBuffer = (bytesProcessed == 0 || bytesProcessed == bytesToSkip);\r\n    final int offsetInBytes;\r\n    final int offsetInSamples;\r\n    final int bytesToRead;\r\n    if (isFirstBuffer && !zeroPadFirstBuffer) {\r\n        bytesToRead = audioByteBuffer.length;\r\n        offsetInBytes = 0;\r\n        offsetInSamples = 0;\r\n    } else {\r\n        bytesToRead = byteStepSize;\r\n        offsetInBytes = byteOverlap;\r\n        offsetInSamples = floatOverlap;\r\n    }\r\n    if (!isFirstBuffer && audioFloatBuffer.length == floatOverlap + floatStepSize) {\r\n        System.arraycopy(audioFloatBuffer, floatStepSize, audioFloatBuffer, 0, floatOverlap);\r\n    }\r\n    int totalBytesRead = 0;\r\n    int bytesRead = 0;\r\n    boolean endOfStream = false;\r\n    while (!stopped && !endOfStream && totalBytesRead < bytesToRead) {\r\n        bytesRead = audioInputStream.read(audioByteBuffer, offsetInBytes + totalBytesRead, bytesToRead - totalBytesRead);\r\n        if (bytesRead == -1) {\r\n            endOfStream = true;\r\n        } else {\r\n            totalBytesRead += bytesRead;\r\n        }\r\n    }\r\n    if (endOfStream) {\r\n        if (zeroPadLastBuffer) {\r\n            for (int i = offsetInBytes + totalBytesRead; i < audioByteBuffer.length; i++) {\r\n                audioByteBuffer[i] = 0;\r\n            }\r\n            converter.toFloatArray(audioByteBuffer, offsetInBytes, audioFloatBuffer, offsetInSamples, floatStepSize);\r\n        } else {\r\n            audioByteBuffer = new byte[offsetInBytes + totalBytesRead];\r\n            int totalSamplesRead = totalBytesRead / format.getFrameSize();\r\n            audioFloatBuffer = new float[offsetInSamples + totalBytesRead / format.getFrameSize()];\r\n            converter.toFloatArray(audioByteBuffer, offsetInBytes, audioFloatBuffer, offsetInSamples, totalSamplesRead);\r\n            audioEvent = new AudioEvent(format, audioFloatBuffer);\r\n            audioEvent.setBytesProcessed(bytesProcessed);\r\n        }\r\n    } else if (bytesToRead == totalBytesRead) {\r\n        converter.toFloatArray(audioByteBuffer, offsetInBytes, audioFloatBuffer, offsetInSamples, floatStepSize);\r\n    } else {\r\n        throw new IOException(String.format(\"The end of the audio stream has not been reached and the number of bytes read (%d) is not equal \" + \"to the expected amount of bytes(%d).\", totalBytesRead, bytesToRead));\r\n    }\r\n    return totalBytesRead;\r\n}"
}, {
	"Path": "be.tarsos.dsp.AudioEvent.getProgress",
	"Comment": "calculate the progress in percentage of the total number of frames.",
	"Method": "double getProgress(){\r\n    return bytesProcessed / format.getFrameSize() / (double) frameLength;\r\n}"
}, {
	"Path": "org.sqlite.date.FastDateFormat.getTimeInstance",
	"Comment": "gets a time formatter instance using the specified style, timezone and locale.",
	"Method": "FastDateFormat getTimeInstance(int style,FastDateFormat getTimeInstance,int style,Locale locale,FastDateFormat getTimeInstance,int style,TimeZone timeZone,FastDateFormat getTimeInstance,int style,TimeZone timeZone,Locale locale){\r\n    return cache.getTimeInstance(style, timeZone, locale);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.TPrimality.consBigInteger",
	"Comment": "a random number is generated until a probable prime number is found.",
	"Method": "TBigInteger consBigInteger(int bitLength,int certainty,Random rnd){\r\n    if (bitLength <= 10) {\r\n        int[] rp = offsetPrimes[bitLength];\r\n        return BIprimes[rp[0] + rnd.nextInt(rp[1])];\r\n    }\r\n    int shiftCount = (-bitLength) & 31;\r\n    int last = (bitLength + 31) >> 5;\r\n    TBigInteger n = new TBigInteger(1, last, new int[last]);\r\n    last--;\r\n    do {\r\n        for (int i = 0; i < n.numberLength; i++) {\r\n            n.digits[i] = rnd.nextInt();\r\n        }\r\n        n.digits[last] |= 0x80000000;\r\n        n.digits[last] >>>= shiftCount;\r\n        n.digits[0] |= 1;\r\n    } while (!isProbablePrime(n, certainty));\r\n    return n;\r\n}"
}, {
	"Path": "jsyntaxpane.SyntaxDocument.getMatcher",
	"Comment": "return a matcher that matches the given pattern in the part of thedocument starting at offset start.note that the matcher will haveoffset starting from start",
	"Method": "Matcher getMatcher(Pattern pattern,Matcher getMatcher,Pattern pattern,int start,Matcher getMatcher,Pattern pattern,int start,int length){\r\n    Matcher matcher = null;\r\n    if (getLength() == 0) {\r\n        return null;\r\n    }\r\n    try {\r\n        Segment seg = new Segment();\r\n        getText(start, length, seg);\r\n        matcher = pattern.matcher(seg);\r\n    } catch (BadLocationException ex) {\r\n        log.log(Level.SEVERE, \"Requested offset: \" + ex.offsetRequested(), ex);\r\n    }\r\n    return matcher;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TAbstractSet.processSecondPass",
	"Comment": "this method is used for traversing nodes after the first stage ofcompilation.",
	"Method": "void processSecondPass(){\r\n    this.isSecondPassVisited = true;\r\n    if (next != null) {\r\n        if (!next.isSecondPassVisited) {\r\n            TJointSet set = next.processBackRefReplacement();\r\n            if (set != null) {\r\n                next.isSecondPassVisited = true;\r\n                next = set;\r\n            }\r\n            next.processSecondPass();\r\n        } else {\r\n            if (next instanceof TSingleSet && ((TFSet) ((TJointSet) next).fSet).isBackReferenced) {\r\n                next = next.next;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorSignBytesPositive1",
	"Comment": "create a positive number from a sign and an array of bytes.the number fits in an array of integers.the most significant byte is positive.",
	"Method": "void testConstructorSignBytesPositive1(){\r\n    byte[] aBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3, -15 };\r\n    int aSign = 1;\r\n    byte[] rBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3, -15 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "jsyntaxpane.actions.FindReplaceActions.msgNotFound",
	"Comment": "display an optionpane dialog that the search string is not found",
	"Method": "void msgNotFound(){\r\n    JOptionPane.showMessageDialog(null, \"Search String \" + pattern + \" not found\", \"Find\", JOptionPane.INFORMATION_MESSAGE);\r\n}"
}, {
	"Path": "be.tarsos.dsp.pitch.Yin.difference",
	"Comment": "implements the difference function as described in step 2 of the yin\tpaper.",
	"Method": "void difference(float[] audioBuffer){\r\n    int index, tau;\r\n    float delta;\r\n    for (tau = 0; tau < yinBuffer.length; tau++) {\r\n        yinBuffer[tau] = 0;\r\n    }\r\n    for (tau = 1; tau < yinBuffer.length; tau++) {\r\n        for (index = 0; index < yinBuffer.length; index++) {\r\n            delta = audioBuffer[index] - audioBuffer[index + tau];\r\n            yinBuffer[tau] += delta * delta;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorBytesNegative1",
	"Comment": "create a negative number from an array of bytes.the number fits in an array of integers.",
	"Method": "void testConstructorBytesNegative1(){\r\n    byte[] aBytes = { -12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 35, 26, 3, 91 };\r\n    byte[] rBytes = { -12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 35, 26, 3, 91 };\r\n    BigInteger aNumber = new BigInteger(aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorSignBytesPositive6",
	"Comment": "create a positive number from a sign and an array of bytes.the number of bytes is multiple of 4.the most significant byte is positive.",
	"Method": "void testConstructorSignBytesPositive6(){\r\n    byte[] aBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 23, -101 };\r\n    int aSign = 1;\r\n    byte[] rBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 23, -101 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorBytesNegative2",
	"Comment": "create a negative number from an array of bytes.the number fits in an integer.",
	"Method": "void testConstructorBytesNegative2(){\r\n    byte[] aBytes = { -12, 56, 100 };\r\n    byte[] rBytes = { -12, 56, 100 };\r\n    BigInteger aNumber = new BigInteger(aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorSignBytesPositive7",
	"Comment": "create a positive number from a sign and an array of bytes.the number of bytes is multiple of 4.the most significant byte is negative.",
	"Method": "void testConstructorSignBytesPositive7(){\r\n    byte[] aBytes = { -12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 23, -101 };\r\n    int aSign = 1;\r\n    byte[] rBytes = { 0, -12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 23, -101 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "org.springframework.cloud.config.server.environment.JGitEnvironmentRepositoryIntegrationTests.pullDirtyRepo",
	"Comment": "tests a special use case where the remote repository has been updated\twith a forced push conflicting with the local repo of the config server.\tthe config server has to reset hard on the new reference because a simple\tpull operation could result in a conflicting local repository.",
	"Method": "void pullDirtyRepo(){\r\n    ConfigServerTestUtils.prepareLocalRepo();\r\n    String uri = ConfigServerTestUtils.copyLocalRepo(\"config-copy\");\r\n    Repository remote = ConfigServerTestUtils.prepareBareRemote();\r\n    Git git = Git.open(ResourceUtils.getFile(uri).getAbsoluteFile());\r\n    StoredConfig config = git.getRepository().getConfig();\r\n    config.setString(\"remote\", \"origin\", \"url\", remote.getDirectory().getAbsolutePath());\r\n    config.setString(\"remote\", \"origin\", \"fetch\", \"+refs/heads/*:refs/remotes/origin/*\");\r\n    config.save();\r\n    git.push().call();\r\n    String commitToRevertBeforePull = git.log().setMaxCount(1).call().iterator().next().getName();\r\n    this.context = new SpringApplicationBuilder(TestConfiguration.class).web(WebApplicationType.NONE).run(\"--spring.cloud.config.server.git.uri=\" + uri);\r\n    JGitEnvironmentRepository repository = this.context.getBean(JGitEnvironmentRepository.class);\r\n    SearchPathLocator.Locations locations = repository.getLocations(\"bar\", \"test\", \"raw\");\r\n    assertEquals(locations.getVersion(), commitToRevertBeforePull);\r\n    git.reset().setMode(ResetType.HARD).setRef(\"master\").call();\r\n    Path applicationFilePath = Paths.get(ResourceUtils.getFile(uri).getAbsoluteFile() + \"/application.yml\");\r\n    Files.write(applicationFilePath, Arrays.asList(\"info:\", \"  foo: bar\", \"raw: false\"), StandardCharsets.UTF_8, StandardOpenOption.TRUNCATE_EXISTING);\r\n    git.add().addFilepattern(\".\").call();\r\n    git.commit().setMessage(\"Conflicting commit.\").call();\r\n    git.push().setForce(true).call();\r\n    String conflictingCommit = git.log().setMaxCount(1).call().iterator().next().getName();\r\n    git.reset().setMode(ResetType.HARD).setRef(commitToRevertBeforePull).call();\r\n    locations = repository.getLocations(\"bar\", \"test\", \"raw\");\r\n    assertEquals(locations.getVersion(), conflictingCommit);\r\n    assertTrue(\"Local repository is not cleaned after retrieving resources.\", git.status().call().isClean());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorSignBytesPositive2",
	"Comment": "create a positive number from a sign and an array of bytes.the number fits in an array of integers.the most significant byte is negative.",
	"Method": "void testConstructorSignBytesPositive2(){\r\n    byte[] aBytes = { -12, 56, 100, -2, -76, 89, 45, 91, 3, -15 };\r\n    int aSign = 1;\r\n    byte[] rBytes = { 0, -12, 56, 100, -2, -76, 89, 45, 91, 3, -15 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "jsyntaxpane.DefaultSyntaxKit.install",
	"Comment": "install the view on the given editorpane.this is called by swing andcan be used to do anything you need on the jeditorpane control.herei set some default actions.",
	"Method": "void install(JEditorPane editorPane){\r\n    super.install(editorPane);\r\n    editorPane.setFont(DEFAULT_FONT);\r\n    Keymap km_parent = JTextComponent.getKeymap(JTextComponent.DEFAULT_KEYMAP);\r\n    Keymap km_new = JTextComponent.addKeymap(null, km_parent);\r\n    String kitName = this.getClass().getSimpleName();\r\n    Color caretColor = CONFIG.getPrefixColor(kitName, \"CaretColor\", Color.BLACK);\r\n    editorPane.setCaretColor(caretColor);\r\n    addSyntaxActions(km_new, \"\");\r\n    addSyntaxActions(km_new, kitName);\r\n    editorPane.setKeymap(km_new);\r\n    String[] components = CONFIG.getPrefixPropertyList(kitName, \"Components\");\r\n    for (String c : components) {\r\n        try {\r\n            @SuppressWarnings(\"unchecked\")\r\n            Class<SyntaxComponent> compClass = (Class<SyntaxComponent>) Class.forName(c);\r\n            SyntaxComponent comp = compClass.newInstance();\r\n            comp.config(CONFIG, kitName);\r\n            comp.install(editorPane);\r\n            editorComponents.add(comp);\r\n        } catch (InstantiationException ex) {\r\n            LOG.log(Level.SEVERE, null, ex);\r\n        } catch (IllegalAccessException ex) {\r\n            LOG.log(Level.SEVERE, null, ex);\r\n        } catch (ClassNotFoundException ex) {\r\n            LOG.log(Level.SEVERE, null, ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.swift.generator.SwiftGeneratorConfig.getIncludeSearchPaths",
	"Comment": "returns the list of uris used as prefixes to search for include files.",
	"Method": "Iterable<URI> getIncludeSearchPaths(){\r\n    return includeSearchPaths;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorSignBytesPositive3",
	"Comment": "create a positive number from a sign and an array of bytes.the number fits in an integer.",
	"Method": "void testConstructorSignBytesPositive3(){\r\n    byte[] aBytes = { -12, 56, 100 };\r\n    int aSign = 1;\r\n    byte[] rBytes = { 0, -12, 56, 100 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "be.tarsos.dsp.util.ConcurrencyUtils.resetThreadsBeginN",
	"Comment": "resets the minimal size of 2d and 3d data for which threads are used.",
	"Method": "void resetThreadsBeginN(){\r\n    THREADS_BEGIN_N_2D = 65536;\r\n    THREADS_BEGIN_N_3D = 65536;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorSignBytesPositive4",
	"Comment": "create a positive number from a sign and an array of bytes.the number of bytes is 4.the most significant byte is positive.",
	"Method": "void testConstructorSignBytesPositive4(){\r\n    byte[] aBytes = { 127, 56, 100, -2 };\r\n    int aSign = 1;\r\n    byte[] rBytes = { 127, 56, 100, -2 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorSignBytesPositive5",
	"Comment": "create a positive number from a sign and an array of bytes.the number of bytes is 4.the most significant byte is negative.",
	"Method": "void testConstructorSignBytesPositive5(){\r\n    byte[] aBytes = { -127, 56, 100, -2 };\r\n    int aSign = 1;\r\n    byte[] rBytes = { 0, -127, 56, 100, -2 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase10",
	"Comment": "subtract two positive numbers of different length.the second is longer.",
	"Method": "void testCase10(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -2, -3, -4, -4, 5, 14, 23, 39, 48, 57, 66, 5, 14, 23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase12",
	"Comment": "subtract two numbers of the same length and different signs.the first is positive.the second is greater in absolute value.",
	"Method": "void testCase12(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 1, 2, 3, 4, 15, 26, 37, 41, 52, 63, 74, 15, 26, 37 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "jsyntaxpane.actions.ActionUtils.getColumnNumber",
	"Comment": "gets the column number at given position of editor.the first column iszero",
	"Method": "int getColumnNumber(JTextComponent editor,int pos){\r\n    Rectangle r = editor.modelToView(pos);\r\n    int start = editor.viewToModel(new Point(0, r.y));\r\n    int column = pos - start;\r\n    return column;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase11",
	"Comment": "subtract two numbers of different length and different signs.the first is positive.the first is greater in absolute value.",
	"Method": "void testCase11(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 1, 2, 3, 4, 15, 26, 37, 41, 52, 63, 74, 15, 26, 37 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase14",
	"Comment": "subtract two numbers of the same length and different signs.the first is negative.the second is longer.",
	"Method": "void testCase14(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -2, -3, -4, -5, -16, -27, -38, -42, -53, -64, -75, -16, -27, -37 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase13",
	"Comment": "subtract two numbers of different length and different signs.the first is negative.the first is longer.",
	"Method": "void testCase13(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -2, -3, -4, -5, -16, -27, -38, -42, -53, -64, -75, -16, -27, -37 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase16",
	"Comment": "subtract two negative numbers of different length.the second is longer.",
	"Method": "void testCase16(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    int aSign = -1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 1, 2, 3, 3, -6, -15, -24, -40, -49, -58, -67, -6, -15, -23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "jsyntaxpane.DefaultSyntaxKit.setProperty",
	"Comment": "sets the given property to the given value.if the kit is notinitialized,then calls initkit",
	"Method": "void setProperty(String key,String value){\r\n    if (!initialized) {\r\n        initKit();\r\n    }\r\n    CONFIG.put(key, value);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerSubtractTest.testCase15",
	"Comment": "subtract two negative numbers of different length.the first is longer.",
	"Method": "void testCase15(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { -2, -3, -4, -4, 5, 14, 23, 39, 48, 57, 66, 5, 14, 23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "jsyntaxpane.actions.ActionUtils.insertIntoCombo",
	"Comment": "insert the given item into the combo box, and set it as first selecteditem.if the item already exists, it is removed, so there are noduplicates.",
	"Method": "void insertIntoCombo(JComboBox combo,Object item){\r\n    MutableComboBoxModel model = (MutableComboBoxModel) combo.getModel();\r\n    if (model.getSize() == 0) {\r\n        model.insertElementAt(item, 0);\r\n        return;\r\n    }\r\n    Object o = model.getElementAt(0);\r\n    if (o.equals(item)) {\r\n        return;\r\n    }\r\n    model.removeElement(item);\r\n    model.insertElementAt(item, 0);\r\n    combo.setSelectedIndex(0);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TLexer.getDecomposition",
	"Comment": "gets decomposition for given codepoint from decomposition mappings table.",
	"Method": "int[] getDecomposition(int ch){\r\n    return decompTable.get(ch);\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.oqlsyntax.OqlLexer.token",
	"Comment": "helper method to create and return a new token from of tokentype",
	"Method": "Token token(TokenType type){\r\n    return new Token(type, yychar, yylength());\r\n}"
}, {
	"Path": "be.tarsos.dsp.ui.layers.LayerUtilities.pixelsToUnits",
	"Comment": "transforms a number of pixels into a corresponding time or frequency span. e.g. 10 horizontal\tpixels could translate to 320 milliseconds. 10 vertical pixels could translate to 32cents.",
	"Method": "Point2D pixelsToUnits(Graphics2D g,int x,int y,float pixelsToUnits,Graphics2D g,int pixels,boolean horizontal){\r\n    float numberOfUnits = 0;\r\n    try {\r\n        Point2D originSrc = new Point2D.Double(0, 0);\r\n        Point2D originDest;\r\n        originDest = g.getTransform().inverseTransform(originSrc, null);\r\n        Point2D destSrc = new Point2D.Double(pixels, pixels);\r\n        Point2D destDest;\r\n        destDest = g.getTransform().inverseTransform(destSrc, null);\r\n        if (horizontal) {\r\n            numberOfUnits = (float) (destDest.getX() - originDest.getX());\r\n        } else {\r\n            numberOfUnits = (float) (-destDest.getY() + originDest.getY());\r\n        }\r\n    } catch (NoninvertibleTransformException e) {\r\n        e.printStackTrace();\r\n    }\r\n    return numberOfUnits;\r\n}"
}, {
	"Path": "org.sqlite.core.CoreStatement.exec",
	"Comment": "executes sql statement and throws sqlexceptions if the given sqlstatement is null or no database is open.",
	"Method": "boolean exec(boolean exec,String sql){\r\n    if (sql == null)\r\n        throw new SQLException(\"SQLiteJDBC internal error: sql==null\");\r\n    if (rs.isOpen())\r\n        throw new SQLException(\"SQLite JDBC internal error: rs.isOpen() on exec.\");\r\n    boolean rc = false;\r\n    boolean success = false;\r\n    try {\r\n        rc = conn.getDatabase().execute(sql, conn.getAutoCommit());\r\n        success = true;\r\n    } finally {\r\n        resultsWaiting = rc;\r\n        if (!success)\r\n            conn.getDatabase().finalize(this);\r\n    }\r\n    return conn.getDatabase().column_count(pointer) != 0;\r\n}"
}, {
	"Path": "org.eclipse.visualvm.launcher.preferences.LocationPreferencePage.createFieldEditors",
	"Comment": "creates the field editors. field editors are abstractions of\tthe common gui blocks needed to manipulate various types\tof preferences. each field editor knows how to save and\trestore itself.",
	"Method": "void createFieldEditors(){\r\n    FileFieldEditor ffe = new FileFieldEditor(PreferenceConstants.P_PATH, PreferencesMessages.LocationPreferencePage_1, getFieldEditorParent()) {\r\n        @Override\r\n        protected void refreshValidState() {\r\n            super.refreshValidState();\r\n            if (isValid()) {\r\n                boolean isWindows = System.getProperty(\"os.name\").toUpperCase().contains(\"WIN\");\r\n                boolean validated = isWindows ? getStringValue().endsWith(\"visualvm.exe\") : getStringValue().endsWith(\"visualvm\");\r\n                if (!validated) {\r\n                    setErrorMessage(PreferencesMessages.LocationPreferencePage_6);\r\n                }\r\n                setValid(validated);\r\n            }\r\n        }\r\n    };\r\n    ffe.setValidateStrategy(FileFieldEditor.VALIDATE_ON_KEY_STROKE);\r\n    addField(ffe);\r\n    DirectoryFieldEditor dfe = new DirectoryFieldEditor(PreferenceConstants.P_JAVAHOME, PreferencesMessages.LocationPreferencePage_2, getFieldEditorParent()) {\r\n        @Override\r\n        protected void refreshValidState() {\r\n            super.refreshValidState();\r\n            if (isValid()) {\r\n                String toolsJarPath = getStringValue() + File.separator + \"lib\" + File.separator + \"tools.jar\";\r\n                File toolsJarFile = new File(toolsJarPath);\r\n                boolean validated = toolsJarFile.exists() && toolsJarFile.isFile();\r\n                if (!validated) {\r\n                    setErrorMessage(PreferencesMessages.LocationPreferencePage_7);\r\n                }\r\n                setValid(validated);\r\n            }\r\n        }\r\n    };\r\n    dfe.setValidateStrategy(FileFieldEditor.VALIDATE_ON_KEY_STROKE);\r\n    addField(dfe);\r\n}"
}, {
	"Path": "org.eclipse.visualvm.launcher.preferences.LocationPreferencePage.createFieldEditors",
	"Comment": "creates the field editors. field editors are abstractions of\tthe common gui blocks needed to manipulate various types\tof preferences. each field editor knows how to save and\trestore itself.",
	"Method": "void createFieldEditors(){\r\n    super.refreshValidState();\r\n    if (isValid()) {\r\n        boolean isWindows = System.getProperty(\"os.name\").toUpperCase().contains(\"WIN\");\r\n        boolean validated = isWindows ? getStringValue().endsWith(\"visualvm.exe\") : getStringValue().endsWith(\"visualvm\");\r\n        if (!validated) {\r\n            setErrorMessage(PreferencesMessages.LocationPreferencePage_6);\r\n        }\r\n        setValid(validated);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.visualvm.launcher.preferences.LocationPreferencePage.createFieldEditors",
	"Comment": "creates the field editors. field editors are abstractions of\tthe common gui blocks needed to manipulate various types\tof preferences. each field editor knows how to save and\trestore itself.",
	"Method": "void createFieldEditors(){\r\n    super.refreshValidState();\r\n    if (isValid()) {\r\n        String toolsJarPath = getStringValue() + File.separator + \"lib\" + File.separator + \"tools.jar\";\r\n        File toolsJarFile = new File(toolsJarPath);\r\n        boolean validated = toolsJarFile.exists() && toolsJarFile.isFile();\r\n        if (!validated) {\r\n            setErrorMessage(PreferencesMessages.LocationPreferencePage_7);\r\n        }\r\n        setValid(validated);\r\n    }\r\n}"
}, {
	"Path": "org.telegram.telegrambots.updatesreceivers.ExponentialBackOff.getRandomizationFactor",
	"Comment": "returns the randomization factor to use for creating a range around the retry interval.a randomization factor of 0.5 results in a random period ranging between 50% below and 50ove the retry interval.",
	"Method": "double getRandomizationFactor(double getRandomizationFactor){\r\n    return randomizationFactor;\r\n}"
}, {
	"Path": "com.turn.ttorrent.tracker.TrackedPeer.getLeft",
	"Comment": "returns how many bytes the peer reported it needs to retrieve beforeits download is complete.",
	"Method": "long getLeft(){\r\n    return this.left;\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.webflux.ProxyExchange.sensitive",
	"Comment": "sets the names of sensitive headers that are not passed downstream to the backend\tservice.",
	"Method": "ProxyExchange<T> sensitive(String names){\r\n    if (this.sensitive == null) {\r\n        this.sensitive = new HashSet();\r\n    }\r\n    for (String name : names) {\r\n        this.sensitive.add(name.toLowerCase());\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.sqlite.core.DB.executeUpdate",
	"Comment": "execute an sql insert, update or delete statement with the stmt object and an array ofparameter values of the sql statement..",
	"Method": "int executeUpdate(CoreStatement stmt,Object[] vals){\r\n    try {\r\n        if (execute(stmt, vals)) {\r\n            throw new SQLException(\"query returns results\");\r\n        }\r\n    } finally {\r\n        if (stmt.pointer != 0)\r\n            reset(stmt.pointer);\r\n    }\r\n    return changes();\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.stripPrefix",
	"Comment": "strips the prefix from the path of the request before it is routed by the gateway.",
	"Method": "GatewayFilterSpec stripPrefix(int parts){\r\n    return filter(getBean(StripPrefixGatewayFilterFactory.class).apply(c -> c.setParts(parts)));\r\n}"
}, {
	"Path": "jsyntaxpane.SyntaxDocument.getLineNumberAt",
	"Comment": "return the line number at given position.the line numbers are zero based",
	"Method": "int getLineNumberAt(int pos){\r\n    int lineNr = getDefaultRootElement().getElementIndex(pos);\r\n    return lineNr;\r\n}"
}, {
	"Path": "be.tarsos.dsp.SpectralPeakProcessor.getFrequencyForBin",
	"Comment": "calculates a frequency for a bin using phase info, if available.",
	"Method": "float getFrequencyForBin(int binIndex){\r\n    final float frequencyInHertz;\r\n    if (previousPhaseOffsets != null) {\r\n        float phaseDelta = currentPhaseOffsets[binIndex] - previousPhaseOffsets[binIndex];\r\n        long k = Math.round(cbin * binIndex - inv_2pi * phaseDelta);\r\n        frequencyInHertz = (float) (inv_2pideltat * phaseDelta + inv_deltat * k);\r\n    } else {\r\n        frequencyInHertz = (float) fft.binToHz(binIndex, sampleRate);\r\n    }\r\n    return frequencyInHertz;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorBytesNegative3",
	"Comment": "create a negative number from an array of bytes.the number of bytes is 4.",
	"Method": "void testConstructorBytesNegative3(){\r\n    byte[] aBytes = { -128, -12, 56, 100 };\r\n    byte[] rBytes = { -128, -12, 56, 100 };\r\n    BigInteger aNumber = new BigInteger(aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorBytesNegative4",
	"Comment": "create a negative number from an array of bytes.the number of bytes is multiple of 4.",
	"Method": "void testConstructorBytesNegative4(){\r\n    byte[] aBytes = { -128, -12, 56, 100, -13, 56, 93, -78 };\r\n    byte[] rBytes = { -128, -12, 56, 100, -13, 56, 93, -78 };\r\n    BigInteger aNumber = new BigInteger(aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "be.tarsos.dsp.ConstantQ.calculateMagintudes",
	"Comment": "take an input buffer with audio and calculate the constant q magnitudes.",
	"Method": "void calculateMagintudes(float[] inputBuffer){\r\n    calculate(inputBuffer);\r\n    for (int i = 0; i < magnitudes.length; i++) {\r\n        magnitudes[i] = (float) Math.sqrt(coefficients[i * 2] * coefficients[i * 2] + coefficients[i * 2 + 1] * coefficients[i * 2 + 1]);\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.SilenceDetector.isSilence",
	"Comment": "checks if the dbspl level in the buffer falls below a certain threshold.",
	"Method": "boolean isSilence(float[] buffer,double silenceThreshold,boolean isSilence,float[] buffer){\r\n    return isSilence(buffer, threshold);\r\n}"
}, {
	"Path": "be.tarsos.dsp.util.ConcurrencyUtils.resetThreadsBeginN_FFT",
	"Comment": "resets the minimal size of 1d data for which two and four threads areused.",
	"Method": "void resetThreadsBeginN_FFT(){\r\n    THREADS_BEGIN_N_1D_FFT_2THREADS = 8192;\r\n    THREADS_BEGIN_N_1D_FFT_4THREADS = 65536;\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.setRequestHeader",
	"Comment": "a filter that sets a header on the request before it is routed by the gateway.",
	"Method": "GatewayFilterSpec setRequestHeader(String headerName,String headerValue){\r\n    return filter(getBean(SetRequestHeaderGatewayFilterFactory.class).apply(c -> c.setName(headerName).setValue(headerValue)));\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorBytesException",
	"Comment": "create a number from an array of bytes.verify an exception thrown if an array is zero bytes long",
	"Method": "void testConstructorBytesException(){\r\n    byte[] aBytes = {};\r\n    try {\r\n        new BigInteger(aBytes);\r\n        fail(\"NumberFormatException has not been caught\");\r\n    } catch (NumberFormatException e) {\r\n        assertEquals(\"Improper exception message\", \"Zero length BigInteger\", e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.loader.tools.Repackager.addMainClassTimeoutWarningListener",
	"Comment": "add a listener that will be triggered to display a warning if searching for the\tmain class takes too long.",
	"Method": "void addMainClassTimeoutWarningListener(MainClassTimeoutWarningListener listener){\r\n    this.mainClassTimeoutListeners.add(listener);\r\n}"
}, {
	"Path": "be.tarsos.dsp.AudioEvent.getByteBuffer",
	"Comment": "return a byte array with the audio data in bytes.\t a conversion is done from float, cache accordingly on the other side...",
	"Method": "byte[] getByteBuffer(){\r\n    int length = getFloatBuffer().length * format.getFrameSize();\r\n    if (byteBuffer == null || byteBuffer.length != length) {\r\n        byteBuffer = new byte[length];\r\n    }\r\n    converter.toByteArray(getFloatBuffer(), byteBuffer);\r\n    return byteBuffer;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.TDivision.multiplyAndSubtract",
	"Comment": "multiplies an array by int and subtracts it from a subarray of anotherarray.",
	"Method": "int multiplyAndSubtract(int[] a,int start,int[] b,int bLen,int c){\r\n    long carry0 = 0;\r\n    long carry1 = 0;\r\n    for (int i = 0; i < bLen; i++) {\r\n        carry0 = TMultiplication.unsignedMultAddAdd(b[i], c, (int) carry0, 0);\r\n        carry1 = (a[start + i] & 0xffffffffL) - (carry0 & 0xffffffffL) + carry1;\r\n        a[start + i] = (int) carry1;\r\n        carry1 >>= 32;\r\n        carry0 >>>= 32;\r\n    }\r\n    carry1 = (a[start + bLen] & 0xffffffffL) - carry0 + carry1;\r\n    a[start + bLen] = (int) carry1;\r\n    return (int) (carry1 >> 32);\r\n}"
}, {
	"Path": "org.telegram.telegrambots.meta.api.methods.send.SendAudio.setAudio",
	"Comment": "use this method to set the audio to an audio existing in telegram system",
	"Method": "SendAudio setAudio(String audio,SendAudio setAudio,File file,SendAudio setAudio,String audioName,InputStream inputStream,SendAudio setAudio,InputFile audio){\r\n    Objects.requireNonNull(audio, \"audio cannot be null!\");\r\n    this.audio = audio;\r\n    return this;\r\n}"
}, {
	"Path": "org.sqlite.date.FastDatePrinter.applyRulesToString",
	"Comment": "creates a string representation of the given calendar by applying the rules of this printer to it.",
	"Method": "String applyRulesToString(Calendar c){\r\n    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.TDivision.slidingWindow",
	"Comment": "implements the montgomery modular exponentiation based in the slidingwindows algorithm and the mongomeryreduction.",
	"Method": "TBigInteger slidingWindow(TBigInteger x2,TBigInteger a2,TBigInteger exponent,TBigInteger modulus,int n2){\r\n    TBigInteger[] pows = new TBigInteger[8];\r\n    TBigInteger res = x2;\r\n    int lowexp;\r\n    TBigInteger x3;\r\n    int acc3;\r\n    pows[0] = a2;\r\n    x3 = monPro(a2, a2, modulus, n2);\r\n    for (int i = 1; i <= 7; i++) {\r\n        pows[i] = monPro(pows[i - 1], x3, modulus, n2);\r\n    }\r\n    for (int i = exponent.bitLength() - 1; i >= 0; i--) {\r\n        if (TBitLevel.testBit(exponent, i)) {\r\n            lowexp = 1;\r\n            acc3 = i;\r\n            for (int j = Math.max(i - 3, 0); j <= i - 1; j++) {\r\n                if (TBitLevel.testBit(exponent, j)) {\r\n                    if (j < acc3) {\r\n                        acc3 = j;\r\n                        lowexp = (lowexp << (i - j)) ^ 1;\r\n                    } else {\r\n                        lowexp = lowexp ^ (1 << (j - acc3));\r\n                    }\r\n                }\r\n            }\r\n            for (int j = acc3; j <= i; j++) {\r\n                res = monPro(res, res, modulus, n2);\r\n            }\r\n            res = monPro(pows[(lowexp - 1) >> 1], res, modulus, n2);\r\n            i = acc3;\r\n        } else {\r\n            res = monPro(res, res, modulus, n2);\r\n        }\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.injectStructFields",
	"Comment": "defines the code to inject data into the struct public fields.",
	"Method": "void injectStructFields(MethodDefinition read,LocalVariableDefinition instance,Map<Short, LocalVariableDefinition> structData){\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        injectField(read, field, instance, structData.get(field.getId()));\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigDecimalConvertTest.testToEngineeringStringZeroNegExponent",
	"Comment": "convert a negative bigdecimal to an engineering string representation",
	"Method": "void testToEngineeringStringZeroNegExponent(){\r\n    String a = \"0.0E-16\";\r\n    BigDecimal aNumber = new BigDecimal(a);\r\n    String result = \"0.00E-15\";\r\n    assertEquals(\"incorrect value\", result, aNumber.toEngineeringString());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testDoubleValueNegRounded1",
	"Comment": "convert a positive number to a double value.rounding is needed.",
	"Method": "void testDoubleValueNegRounded1(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = -1;\r\n    double result = -1.54747264387948E26;\r\n    double aNumber = new BigInteger(aSign, a).doubleValue();\r\n    assertEquals(aNumber, result, 1E14);\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.announce.TrackerClient.handleTrackerAnnounceResponse",
	"Comment": "handle the announce response from the tracker.analyzes the response from the tracker and acts on it. if the responseis an error, it is logged. otherwise, the announce response is usedto fire the corresponding announce and peer events to all announcelisteners.",
	"Method": "void handleTrackerAnnounceResponse(TrackerMessage message,boolean inhibitEvents,String hexInfoHash){\r\n    if (message instanceof ErrorMessage) {\r\n        ErrorMessage error = (ErrorMessage) message;\r\n        throw new AnnounceException(error.getReason());\r\n    }\r\n    if (!(message instanceof AnnounceResponseMessage)) {\r\n        throw new AnnounceException(\"Unexpected tracker message type \" + message.getType().name() + \"!\");\r\n    }\r\n    AnnounceResponseMessage response = (AnnounceResponseMessage) message;\r\n    this.fireAnnounceResponseEvent(response.getComplete(), response.getIncomplete(), response.getInterval(), hexInfoHash);\r\n    if (inhibitEvents) {\r\n        return;\r\n    }\r\n    this.fireDiscoveredPeersEvent(response.getPeers(), hexInfoHash);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testDoubleValueNegRounded2",
	"Comment": "convert a positive number to a double value.rounding is needed.the rounding bit is 1 and the next bit to the left is 0but some of dropped bits are 1s.",
	"Method": "void testDoubleValueNegRounded2(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, 36, 23, 1, -3, -5 };\r\n    int aSign = -1;\r\n    double result = -1.547472643879479E26;\r\n    double aNumber = new BigInteger(aSign, a).doubleValue();\r\n    assertEquals(aNumber, result, 1E14);\r\n}"
}, {
	"Path": "org.telegram.abilitybots.api.db.MapDBContext.offlineInstance",
	"Comment": "this db returned by this method gets deleted on jvm shutdown.",
	"Method": "DBContext offlineInstance(String name){\r\n    DB db = DBMaker.fileDB(name).fileMmapEnableIfSupported().closeOnJvmShutdown().cleanerHackEnable().transactionEnable().fileDeleteAfterClose().make();\r\n    return new MapDBContext(db);\r\n}"
}, {
	"Path": "be.tarsos.dsp.io.android.AudioDispatcherFactory.fromDefaultMicrophone",
	"Comment": "create a new audiodispatcher connected to the default microphone.",
	"Method": "AudioDispatcher fromDefaultMicrophone(int sampleRate,int audioBufferSize,int bufferOverlap){\r\n    int minAudioBufferSize = AudioRecord.getMinBufferSize(sampleRate, android.media.AudioFormat.CHANNEL_IN_MONO, android.media.AudioFormat.ENCODING_PCM_16BIT);\r\n    int minAudioBufferSizeInSamples = minAudioBufferSize / 2;\r\n    if (minAudioBufferSizeInSamples <= audioBufferSize) {\r\n        AudioRecord audioInputStream = new AudioRecord(MediaRecorder.AudioSource.MIC, sampleRate, android.media.AudioFormat.CHANNEL_IN_MONO, android.media.AudioFormat.ENCODING_PCM_16BIT, audioBufferSize * 2);\r\n        TarsosDSPAudioFormat format = new TarsosDSPAudioFormat(sampleRate, 16, 1, true, false);\r\n        TarsosDSPAudioInputStream audioStream = new AndroidAudioInputStream(audioInputStream, format);\r\n        audioInputStream.startRecording();\r\n        return new AudioDispatcher(audioStream, audioBufferSize, bufferOverlap);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Buffer size too small should be at least \" + (minAudioBufferSize * 2));\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.granulator.OptimizedGranulator.getFrameNoInterp",
	"Comment": "retrieves a frame of audio using no interpolation. if the frame is not in\tthe sample range then zeros are returned.",
	"Method": "float getFrameNoInterp(double posInMS){\r\n    double frame = msToSamples(posInMS);\r\n    int frame_floor = (int) Math.floor(frame);\r\n    return audioBuffer[frame_floor];\r\n}"
}, {
	"Path": "com.turn.ttorrent.common.protocol.http.HTTPAnnounceResponseMessage.craft",
	"Comment": "craft a compact announce response message with a torrent identifier.",
	"Method": "HTTPAnnounceResponseMessage craft(int interval,int complete,int incomplete,List<Peer> peers,String hexInfoHash){\r\n    Map<String, BEValue> response = new HashMap<String, BEValue>();\r\n    response.put(\"interval\", new BEValue(interval));\r\n    response.put(\"complete\", new BEValue(complete));\r\n    response.put(\"incomplete\", new BEValue(incomplete));\r\n    if (hexInfoHash != null) {\r\n        response.put(\"torrentIdentifier\", new BEValue(hexInfoHash));\r\n    }\r\n    ByteBuffer data = ByteBuffer.allocate(peers.size() * 6);\r\n    for (Peer peer : peers) {\r\n        byte[] ip = peer.getRawIp();\r\n        if (ip == null || ip.length != 4) {\r\n            continue;\r\n        }\r\n        data.put(ip);\r\n        data.putShort((short) peer.getPort());\r\n    }\r\n    response.put(\"peers\", new BEValue(Arrays.copyOf(data.array(), data.position())));\r\n    return new HTTPAnnounceResponseMessage(BEncoder.bencode(response), interval, complete, incomplete, peers, hexInfoHash);\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.changeRequestUri",
	"Comment": "a filter which change the uri the request will be routed to by the gateway.",
	"Method": "GatewayFilterSpec changeRequestUri(Function<ServerWebExchange, Optional<URI>> determineRequestUri){\r\n    return filter(new AbstractChangeRequestUriGatewayFilterFactory<Object>(Object.class) {\r\n        @Override\r\n        protected Optional<URI> determineRequestUri(ServerWebExchange exchange, Object config) {\r\n            return determineRequestUri.apply(exchange);\r\n        }\r\n    }.apply(c -> {\r\n    }));\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.changeRequestUri",
	"Comment": "a filter which change the uri the request will be routed to by the gateway.",
	"Method": "GatewayFilterSpec changeRequestUri(Function<ServerWebExchange, Optional<URI>> determineRequestUri){\r\n    return determineRequestUri.apply(exchange);\r\n}"
}, {
	"Path": "com.facebook.swift.generator.SwiftGeneratorConfig.isGenerateIncludedCode",
	"Comment": "if true, generate code for all included thrift idls instead of just referring tothem.",
	"Method": "boolean isGenerateIncludedCode(){\r\n    return generateIncludedCode;\r\n}"
}, {
	"Path": "be.tarsos.dsp.io.PipedAudioStream.getMonoStream",
	"Comment": "return a one channel, signed pcm stream of audio of a defined sample rate.",
	"Method": "TarsosDSPAudioInputStream getMonoStream(int targetSampleRate,double startTimeOffset,TarsosDSPAudioInputStream getMonoStream,int targetSampleRate,double startTimeOffset,double numberOfSeconds){\r\n    InputStream stream = null;\r\n    stream = decoder.getDecodedStream(resource, targetSampleRate, startTimeOffset, numberOfSeconds);\r\n    return new UniversalAudioInputStream(stream, getTargetFormat(targetSampleRate));\r\n}"
}, {
	"Path": "be.tarsos.dsp.util.PitchConverter.hertzToMidiKey",
	"Comment": "a midi key is an integer between 0 and 127, inclusive. within a certain\trange every pitch is mapped to a midi key. if a value outside the range\tis given an illegalarugmentexception is thrown.",
	"Method": "int hertzToMidiKey(Double hertzValue){\r\n    final int midiKey = (int) Math.round(hertzToMidiCent(hertzValue));\r\n    if (midiKey < 0 || midiKey > 127) {\r\n    }\r\n    return midiKey;\r\n}"
}, {
	"Path": "org.sqlite.SQLiteDataSource.setCacheSize",
	"Comment": "sets the suggested maximum number of database disk pages that sqlite willhold in memory at once per open database file.",
	"Method": "void setCacheSize(int numberOfPages){\r\n    config.setCacheSize(numberOfPages);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TMatcher.groupCount",
	"Comment": "returns the number of groups in the results, which is always equal to thenumber of groups in the original regular expression.",
	"Method": "int groupCount(){\r\n    return matchResult.groupCount();\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TMatcher.end",
	"Comment": "returns the index of the first character following the text that matchedthe whole regular expression.",
	"Method": "int end(int group,int end){\r\n    return end(0);\r\n}"
}, {
	"Path": "org.teavm.classlib.impl.tz.DateTimeZoneBuilder.addCutover",
	"Comment": "adds a cutover for added rules. the standard offset at the cutoverdefaults to 0. call setstandardoffset afterwards to change it.",
	"Method": "DateTimeZoneBuilder addCutover(int year,char mode,int monthOfYear,int dayOfMonth,int dayOfWeek,boolean advanceDayOfWeek,int millisOfDay){\r\n    if (iRuleSets.size() > 0) {\r\n        OfYear ofYear = new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\r\n        RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1);\r\n        lastRuleSet.setUpperLimit(year, ofYear);\r\n    }\r\n    iRuleSets.add(new RuleSet());\r\n    return this;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorStringException3",
	"Comment": "create a number from a string value and radix.verify an exception thrown if the string contains improper characters.",
	"Method": "void testConstructorStringException3(){\r\n    String value = \"92348$*#78987\";\r\n    int radix = 34;\r\n    try {\r\n        new BigInteger(value, radix);\r\n        fail(\"NumberFormatException has not been caught\");\r\n    } catch (NumberFormatException e) {\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorStringException4",
	"Comment": "create a number from a string value and radix.verify an exception thrown if some digits are greater than radix.",
	"Method": "void testConstructorStringException4(){\r\n    String value = \"98zv765hdsaiy\";\r\n    int radix = 20;\r\n    try {\r\n        new BigInteger(value, radix);\r\n        fail(\"NumberFormatException has not been caught\");\r\n    } catch (NumberFormatException e) {\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorStringException1",
	"Comment": "create a number from a string value and radix.verify an exception thrown if a radix is out of range",
	"Method": "void testConstructorStringException1(){\r\n    String value = \"9234853876401\";\r\n    int radix = 45;\r\n    try {\r\n        new BigInteger(value, radix);\r\n        fail(\"NumberFormatException has not been caught\");\r\n    } catch (NumberFormatException e) {\r\n        assertEquals(\"Improper exception message\", \"Radix out of range\", e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.sqlite.core.CorePreparedStatement.batch",
	"Comment": "assigns the object value to the element at the specific position of arraybatch.",
	"Method": "void batch(int pos,Object value){\r\n    checkOpen();\r\n    if (batch == null) {\r\n        batch = new Object[paramCount];\r\n        paramValid.clear();\r\n    }\r\n    batch[batchPos + pos - 1] = value;\r\n    paramValid.set(pos - 1);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorStringException2",
	"Comment": "create a number from a string value and radix.verify an exception thrown if the string starts with a space.",
	"Method": "void testConstructorStringException2(){\r\n    String value = \"   9234853876401\";\r\n    int radix = 10;\r\n    try {\r\n        new BigInteger(value, radix);\r\n        fail(\"NumberFormatException has not been caught\");\r\n    } catch (NumberFormatException e) {\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TPattern.finalizeCompile",
	"Comment": "this method do traverses of automata to finish compilation.",
	"Method": "void finalizeCompile(){\r\n    if (needsBackRefReplacement) {\r\n        start.processSecondPass();\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.SpectralPeakProcessor.findLocalMaxima",
	"Comment": "finds the local magintude maxima and stores them in the given list.",
	"Method": "List<Integer> findLocalMaxima(float[] magnitudes,float[] noisefloor){\r\n    List<Integer> localMaximaIndexes = new ArrayList<Integer>();\r\n    for (int i = 1; i < magnitudes.length - 1; i++) {\r\n        boolean largerThanPrevious = (magnitudes[i - 1] < magnitudes[i]);\r\n        boolean largerThanNext = (magnitudes[i] > magnitudes[i + 1]);\r\n        boolean largerThanNoiseFloor = (magnitudes[i] > noisefloor[i]);\r\n        if (largerThanPrevious && largerThanNext && largerThanNoiseFloor) {\r\n            localMaximaIndexes.add(i);\r\n        }\r\n    }\r\n    return localMaximaIndexes;\r\n}"
}, {
	"Path": "org.springframework.boot.maven.AbstractRunMojo.logDisabledFork",
	"Comment": "log a warning indicating that fork mode has been explicitly disabled while some\tconditions are present that require to enable it.",
	"Method": "void logDisabledFork(){\r\n    if (getLog().isWarnEnabled()) {\r\n        if (hasAgent()) {\r\n            getLog().warn(\"Fork mode disabled, ignoring agent\");\r\n        }\r\n        if (hasJvmArgs()) {\r\n            RunArguments runArguments = resolveJvmArguments();\r\n            getLog().warn(\"Fork mode disabled, ignoring JVM argument(s) [\" + Arrays.stream(runArguments.asArray()).collect(Collectors.joining(\" \")) + \"]\");\r\n        }\r\n        if (hasWorkingDirectorySet()) {\r\n            getLog().warn(\"Fork mode disabled, ignoring working directory configuration\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.SharedTorrent.isComplete",
	"Comment": "tells whether this torrent has been fully downloaded, or is fullyavailable locally.",
	"Method": "boolean isComplete(){\r\n    return this.pieces.length > 0 && pieceStorage.getAvailablePieces().cardinality() == myTorrentMetadata.getPiecesCount();\r\n}"
}, {
	"Path": "org.sqlite.SQLiteJDBCLoader.loadSQLiteNativeLibrary",
	"Comment": "loads sqlite native library using given path and name of the library.",
	"Method": "void loadSQLiteNativeLibrary(){\r\n    if (extracted) {\r\n        return;\r\n    }\r\n    String sqliteNativeLibraryPath = System.getProperty(\"org.sqlite.lib.path\");\r\n    String sqliteNativeLibraryName = System.getProperty(\"org.sqlite.lib.name\");\r\n    if (sqliteNativeLibraryName == null) {\r\n        sqliteNativeLibraryName = System.mapLibraryName(\"sqlitejdbc\");\r\n        if (sqliteNativeLibraryName != null && sqliteNativeLibraryName.endsWith(\"dylib\")) {\r\n            sqliteNativeLibraryName = sqliteNativeLibraryName.replace(\"dylib\", \"jnilib\");\r\n        }\r\n    }\r\n    if (sqliteNativeLibraryPath != null) {\r\n        if (loadNativeLibrary(sqliteNativeLibraryPath, sqliteNativeLibraryName)) {\r\n            extracted = true;\r\n            return;\r\n        }\r\n    }\r\n    String packagePath = SQLiteJDBCLoader.class.getPackage().getName().replaceAll(\"\\\\.\", \"/\");\r\n    sqliteNativeLibraryPath = String.format(\"/%s/native/%s\", packagePath, OSInfo.getNativeLibFolderPathForCurrentOS());\r\n    boolean hasNativeLib = hasResource(sqliteNativeLibraryPath + \"/\" + sqliteNativeLibraryName);\r\n    if (!hasNativeLib) {\r\n        if (OSInfo.getOSName().equals(\"Mac\")) {\r\n            String altName = \"libsqlitejdbc.jnilib\";\r\n            if (hasResource(sqliteNativeLibraryPath + \"/\" + altName)) {\r\n                sqliteNativeLibraryName = altName;\r\n                hasNativeLib = true;\r\n            }\r\n        }\r\n    }\r\n    if (!hasNativeLib) {\r\n        extracted = false;\r\n        throw new Exception(String.format(\"No native library is found for os.name=%s and os.arch=%s. path=%s\", OSInfo.getOSName(), OSInfo.getArchName(), sqliteNativeLibraryPath));\r\n    }\r\n    String tempFolder = getTempDir().getAbsolutePath();\r\n    if (extractAndLoadLibraryFile(sqliteNativeLibraryPath, sqliteNativeLibraryName, tempFolder)) {\r\n        extracted = true;\r\n        return;\r\n    }\r\n    extracted = false;\r\n    return;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TLexer.reread",
	"Comment": "reread current character, may be require if previous token changes modeto one with different character interpretation.",
	"Method": "void reread(){\r\n    lookAhead = ch;\r\n    lookAheadST = curST;\r\n    index = lookAheadToc;\r\n    lookAheadToc = curToc;\r\n    movePointer();\r\n}"
}, {
	"Path": "org.springframework.boot.loader.tools.Repackager.setBackupSource",
	"Comment": "sets if source files should be backed up when they would be overwritten.",
	"Method": "void setBackupSource(boolean backupSource){\r\n    this.backupSource = backupSource;\r\n}"
}, {
	"Path": "org.sqlite.core.CoreDatabaseMetaData.escape",
	"Comment": "applies sql escapes for special characters in a given string.",
	"Method": "String escape(String val){\r\n    int len = val.length();\r\n    StringBuilder buf = new StringBuilder(len);\r\n    for (int i = 0; i < len; i++) {\r\n        if (val.charAt(i) == '\\'') {\r\n            buf.append('\\'');\r\n        }\r\n        buf.append(val.charAt(i));\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "be.tarsos.dsp.example.dissonance.KernelDensityEstimate.calculateSumFreq",
	"Comment": "calculates the sum of all estimates in the accummulator. should be called after each update.",
	"Method": "void calculateSumFreq(){\r\n    sum = 0;\r\n    for (int i = 0; i < accumulator.length; i++) {\r\n        sum += accumulator[i];\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorSignBytesException1",
	"Comment": "create a number from a sign and an array of bytes.verify an exception thrown if a sign has improper value.",
	"Method": "void testConstructorSignBytesException1(){\r\n    byte[] aBytes = { 123, 45, -3, -76 };\r\n    int aSign = 3;\r\n    try {\r\n        new BigInteger(aSign, aBytes);\r\n        fail(\"NumberFormatException has not been caught\");\r\n    } catch (NumberFormatException e) {\r\n        assertEquals(\"Improper exception message\", \"Invalid signum value\", e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.mbeans.XTextField.getValue",
	"Comment": "this method returns either the user inputted string, or an xobjectif one was dropped on the input field.",
	"Method": "Object getValue(){\r\n    if (selectedObject != null) {\r\n        if (selectedObject == XObject.NULL_OBJECT) {\r\n            return null;\r\n        } else {\r\n            return selectedObject;\r\n        }\r\n    } else {\r\n        return textField.getText();\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerAddTest.testCase14",
	"Comment": "add two numbers of different length and sign.the first is negative.the second is longer.",
	"Method": "void testCase14(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 1, 2, 3, 3, -6, -15, -24, -40, -49, -58, -67, -6, -15, -23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "be.tarsos.dsp.util.ConcurrencyUtils.submit",
	"Comment": "submits a runnable task for execution and returns a future representingthat task.",
	"Method": "Future<?> submit(Runnable task){\r\n    return THREAD_POOL.submit(task);\r\n}"
}, {
	"Path": "be.tarsos.dsp.util.fft.FFT.backwardsTransform",
	"Comment": "computes inverse dft.\twarning, does not reverse the window function.",
	"Method": "void backwardsTransform(float[] data){\r\n    fft.realInverse(data, true);\r\n}"
}, {
	"Path": "org.sqlite.SQLiteDataSource.setTransactionMode",
	"Comment": "sets the mode that will be used to start transactions for this database.",
	"Method": "void setTransactionMode(String transactionMode){\r\n    config.setTransactionMode(transactionMode);\r\n}"
}, {
	"Path": "com.facebook.swift.codec.metadata.ThriftCatalog.getThriftType",
	"Comment": "gets the thrifttype for the specified java type.the native thrift type for the java type willbe inferred from the java type, and if necessary type coercions will be applied.",
	"Method": "ThriftType getThriftType(Type javaType){\r\n    ThriftType thriftType = getThriftTypeFromCache(javaType);\r\n    if (thriftType == null) {\r\n        thriftType = buildThriftType(javaType);\r\n    }\r\n    return thriftType;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerAddTest.testCase11",
	"Comment": "add two numbers of different length and sign.the first is positive.the first is longer.",
	"Method": "void testCase11(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 1, 2, 3, 3, -6, -15, -24, -40, -49, -58, -67, -6, -15, -23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerAddTest.testCase10",
	"Comment": "add two negative numbers of different length.the second is longer.",
	"Method": "void testCase10(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    int aSign = -1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { -2, -3, -4, -5, -16, -27, -38, -42, -53, -64, -75, -16, -27, -37 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerAddTest.testCase13",
	"Comment": "add two numbers of different length and sign.the first is negative.the first is longer.",
	"Method": "void testCase13(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -2, -3, -4, -4, 5, 14, 23, 39, 48, 57, 66, 5, 14, 23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "be.tarsos.dsp.ConstantQ.calculate",
	"Comment": "take an input buffer with audio and calculate the constant q\tcoefficients.",
	"Method": "void calculate(float[] inputBuffer){\r\n    fft.forwardTransform(inputBuffer);\r\n    for (int i = 0; i < qKernel.length; i++) {\r\n        float[] kernel = qKernel[i];\r\n        int[] indexes = qKernel_indexes[i];\r\n        float t_r = 0;\r\n        float t_i = 0;\r\n        for (int j = 0, l = 0; j < kernel.length; j += 2, l++) {\r\n            int jj = indexes[l];\r\n            float b_r = inputBuffer[jj];\r\n            float b_i = inputBuffer[jj + 1];\r\n            float k_r = kernel[j];\r\n            float k_i = kernel[j + 1];\r\n            t_r += b_r * k_r - b_i * k_i;\r\n            t_i += b_r * k_i + b_i * k_r;\r\n        }\r\n        coefficients[i * 2] = t_r;\r\n        coefficients[i * 2 + 1] = t_i;\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerAddTest.testCase12",
	"Comment": "add two numbers of different length and sign.the first is positive.the second is longer.",
	"Method": "void testCase12(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { -2, -3, -4, -4, 5, 14, 23, 39, 48, 57, 66, 5, 14, 23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "org.sqlite.SQLiteConnection.checkOpen",
	"Comment": "whether an sqlite library interface to the database has been established.",
	"Method": "void checkOpen(){\r\n    if (isClosed())\r\n        throw new SQLException(\"database connection closed\");\r\n}"
}, {
	"Path": "org.sqlite.SQLiteConfig.getBoolean",
	"Comment": "checks if the provided value is the default for a given pragma.",
	"Method": "boolean getBoolean(Pragma pragma,String defaultValue){\r\n    return Boolean.parseBoolean(pragmaTable.getProperty(pragma.pragmaName, defaultValue));\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.tracer.TracerProgressObject.finish",
	"Comment": "adds all remaining steps to finish the initialization progress.",
	"Method": "void finish(){\r\n    if (isFinished())\r\n        return;\r\n    currentStep = steps;\r\n    fireChange();\r\n}"
}, {
	"Path": "org.sqlite.date.FastDateParser.readObject",
	"Comment": "create the object after serialization. this implementation reinitializes thetransient properties.",
	"Method": "void readObject(ObjectInputStream in){\r\n    in.defaultReadObject();\r\n    final Calendar definingCalendar = Calendar.getInstance(timeZone, locale);\r\n    init(definingCalendar);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorBytesPositive",
	"Comment": "create a positive number from an array of bytes.the number of bytes is multiple of 4.",
	"Method": "void testConstructorBytesPositive(){\r\n    byte[] aBytes = { 127, 56, 100, -1, 14, 75, -24, -100 };\r\n    byte[] rBytes = { 127, 56, 100, -1, 14, 75, -24, -100 };\r\n    BigInteger aNumber = new BigInteger(aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "org.springframework.cloud.config.server.support.GitCredentialsProviderFactory.createFor",
	"Comment": "search for a credential provider that will handle the specified uri. if not found,\tand the username or passphrase has text, then create a default using the provided\tusername and password or passphrase. otherwise null.",
	"Method": "CredentialsProvider createFor(String uri,String username,String password,String passphrase,CredentialsProvider createFor,String uri,String username,String password,String passphrase,boolean skipSslValidation){\r\n    CredentialsProvider provider = null;\r\n    if (awsAvailable() && AwsCodeCommitCredentialProvider.canHandle(uri)) {\r\n        logger.debug(\"Constructing AwsCodeCommitCredentialProvider for URI \" + uri);\r\n        AwsCodeCommitCredentialProvider aws = new AwsCodeCommitCredentialProvider();\r\n        aws.setUsername(username);\r\n        aws.setPassword(password);\r\n        provider = aws;\r\n    } else if (hasText(username)) {\r\n        logger.debug(\"Constructing UsernamePasswordCredentialsProvider for URI \" + uri);\r\n        provider = new UsernamePasswordCredentialsProvider(username, password.toCharArray());\r\n    } else if (hasText(passphrase)) {\r\n        logger.debug(\"Constructing PassphraseCredentialsProvider for URI \" + uri);\r\n        provider = new PassphraseCredentialsProvider(passphrase);\r\n    }\r\n    if (skipSslValidation && GitSkipSslValidationCredentialsProvider.canHandle(uri)) {\r\n        logger.debug(\"Constructing GitSkipSslValidationCredentialsProvider for URI \" + uri);\r\n        provider = new GitSkipSslValidationCredentialsProvider(provider);\r\n    }\r\n    if (provider == null) {\r\n        logger.debug(\"No credentials provider required for URI \" + uri);\r\n    }\r\n    return provider;\r\n}"
}, {
	"Path": "org.sqlite.SQLiteDataSource.setJournalMode",
	"Comment": "sets the journal mode for databases associated with the current databaseconnection.",
	"Method": "void setJournalMode(String mode){\r\n    config.setJournalMode(JournalMode.valueOf(mode));\r\n}"
}, {
	"Path": "org.springframework.boot.loader.tools.Library.isUnpackRequired",
	"Comment": "return if the file cannot be used directly as a nested jar and needs to be\tunpacked.",
	"Method": "boolean isUnpackRequired(){\r\n    return this.unpackRequired;\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.secureHeaders",
	"Comment": "a filter that adds a number of headers to the response at the reccomendation from\tthis blog post.",
	"Method": "GatewayFilterSpec secureHeaders(){\r\n    return filter(getBean(SecureHeadersGatewayFilterFactory.class).apply(c -> {\r\n    }));\r\n}"
}, {
	"Path": "com.turn.ttorrent.tracker.TrackedPeer.isCompleted",
	"Comment": "tells whether this peer has completed its download and can thus beconsidered a seeder.",
	"Method": "boolean isCompleted(){\r\n    return PeerState.COMPLETED.equals(this.state);\r\n}"
}, {
	"Path": "be.tarsos.dsp.AudioGenerator.getTargetAudioFormat",
	"Comment": "constructs the target audio format. the audio format is one channel\tsigned pcm of a given sample rate.",
	"Method": "TarsosDSPAudioFormat getTargetAudioFormat(int targetSampleRate){\r\n    TarsosDSPAudioFormat audioFormat = new TarsosDSPAudioFormat(TarsosDSPAudioFormat.Encoding.PCM_SIGNED, targetSampleRate, 2 * 8, 1, 2 * 1, targetSampleRate, ByteOrder.BIG_ENDIAN.equals(ByteOrder.nativeOrder()));\r\n    return audioFormat;\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.tracer.ProbeItemDescriptor.continuousFillItem",
	"Comment": "creates descriptor for a continuous item created by filled segments.",
	"Method": "ProbeItemDescriptor continuousFillItem(String name,String description,ItemValueFormatter formatter,ProbeItemDescriptor continuousFillItem,String name,String description,ItemValueFormatter formatter,double dataFactor,long minValue,long maxValue){\r\n    return continuousItem(name, description, formatter, dataFactor, minValue, maxValue, DEFAULT_LINE_WIDTH, null, DEFAULT_COLOR);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TMatcher.start",
	"Comment": "returns the index of the first character of the text that matched thewhole regular expression.",
	"Method": "int start(int group,int start){\r\n    return start(0);\r\n}"
}, {
	"Path": "com.turn.ttorrent.tracker.TrackedTorrent.getSomePeers",
	"Comment": "get a list of peers we can return in an announce response for thistorrent.",
	"Method": "List<Peer> getSomePeers(Peer peer){\r\n    List<Peer> peers = new LinkedList<Peer>();\r\n    List<TrackedPeer> candidates = new LinkedList<TrackedPeer>(this.peers.values());\r\n    Collections.shuffle(candidates);\r\n    int count = 0;\r\n    for (TrackedPeer candidate : candidates) {\r\n        if (peer != null && peer.looksLike(candidate)) {\r\n            continue;\r\n        }\r\n        if (count++ > this.answerPeers) {\r\n            break;\r\n        }\r\n        peers.add(candidate);\r\n    }\r\n    return peers;\r\n}"
}, {
	"Path": "be.tarsos.dsp.wavelet.lift.LiftingSchemeBaseWavelet.merge",
	"Comment": "merge the odd elements from the second half of the n element region in\tthe array with the even elements in the first half of the n element\tregion. the result will be the combination of the odd and even elements\tin a region of length n.",
	"Method": "void merge(float[] vec,int N){\r\n    int half = N >> 1;\r\n    int start = half - 1;\r\n    int end = half;\r\n    while (start > 0) {\r\n        for (int i = start; i < end; i = i + 2) {\r\n            float tmp = vec[i];\r\n            vec[i] = vec[i + 1];\r\n            vec[i + 1] = tmp;\r\n        }\r\n        start = start - 1;\r\n        end = end + 1;\r\n    }\r\n}"
}, {
	"Path": "jsyntaxpane.actions.ReplaceDialog.updateHighlights",
	"Comment": "updates the highlights in the document when it is updated.this is called by the documentlistener methods",
	"Method": "void updateHighlights(){\r\n    Markers.removeMarkers(textComponent, SEARCH_MARKER);\r\n    if (jTglHighlight.isSelected()) {\r\n        Markers.markAll(textComponent, finder.getPattern(), SEARCH_MARKER);\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.AudioGenerator.removeAudioProcessor",
	"Comment": "removes an audioprocessor to the chain of processors and calls processingfinished.",
	"Method": "void removeAudioProcessor(AudioProcessor audioProcessor){\r\n    audioProcessors.remove(audioProcessor);\r\n    audioProcessor.processingFinished();\r\n    LOG.fine(\"Remove an audioprocessor to the list of processors: \" + audioProcessor.toString());\r\n}"
}, {
	"Path": "org.netbeans.nbbuild.Repeat.setTarget",
	"Comment": "name of target which will be used with ant task. if not specified,owning target name is used.",
	"Method": "void setTarget(String s){\r\n    log(\"SET target = \" + s, Project.MSG_DEBUG);\r\n    target = s;\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.rewritePath",
	"Comment": "a filter which rewrites the request path before it is routed by the gateway",
	"Method": "GatewayFilterSpec rewritePath(String regex,String replacement){\r\n    return filter(getBean(RewritePathGatewayFilterFactory.class).apply(c -> c.setRegexp(regex).setReplacement(replacement)));\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.redirect",
	"Comment": "a filter that will return a redirect response back to the client.",
	"Method": "GatewayFilterSpec redirect(int status,URI url,GatewayFilterSpec redirect,int status,String url,GatewayFilterSpec redirect,String status,URI url,GatewayFilterSpec redirect,String status,String url,GatewayFilterSpec redirect,HttpStatus status,URL url){\r\n    try {\r\n        return filter(getBean(RedirectToGatewayFilterFactory.class).apply(status, url.toURI()));\r\n    } catch (URISyntaxException e) {\r\n        throw new IllegalArgumentException(\"Invalid URL\", e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.support.ShortcutConfigurable.shortcutFieldOrder",
	"Comment": "returns hints about the number of args and the order for shortcut parsing.",
	"Method": "List<String> shortcutFieldOrder(){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "be.tarsos.dsp.experimental.AudioEvent.calculateRMS",
	"Comment": "calculates and returns the root mean square of the signal. please\tcache the result since it is calculated every time.",
	"Method": "double calculateRMS(float[] floatBuffer){\r\n    double rms = 0.0;\r\n    for (int i = 0; i < floatBuffer.length; i++) {\r\n        rms += floatBuffer[i] * floatBuffer[i];\r\n    }\r\n    rms = rms / Double.valueOf(floatBuffer.length);\r\n    rms = Math.sqrt(rms);\r\n    return rms;\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.SharedTorrent.handlePieceCompleted",
	"Comment": "piece download completion handler.if the complete piece downloaded is valid, we can record in the torrentcompletedpieces bit field that we know have this piece.",
	"Method": "void handlePieceCompleted(SharingPeer peer,Piece piece){\r\n    myTorrentStatistic.addDownloaded(piece.size());\r\n    this.requestedPieces.set(piece.getIndex(), false);\r\n    logger.trace(\"We now have {} piece(s) and {} outstanding request(s): {}\", new Object[] { this.completedPieces.cardinality(), this.requestedPieces.cardinality(), this.requestedPieces });\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.tracer.ProbeItemDescriptor.discreteLineItem",
	"Comment": "creates descriptor for a discrete item created by line segments representing the outline.",
	"Method": "ProbeItemDescriptor discreteLineItem(String name,String description,ItemValueFormatter formatter,ProbeItemDescriptor discreteLineItem,String name,String description,ItemValueFormatter formatter,double dataFactor,long minValue,long maxValue){\r\n    return discreteOutlineItem(name, description, formatter, dataFactor, minValue, maxValue, DEFAULT_LINE_WIDTH, DEFAULT_COLOR, null);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testFloatValuePosNotRounded",
	"Comment": "convert a positive number to a float value.rounding is not needed.",
	"Method": "void testFloatValuePosNotRounded(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = 1;\r\n    float result = 1.5474726E26f;\r\n    float aNumber = new BigInteger(aSign, a).floatValue();\r\n    assertEquals(aNumber, result, 1E20);\r\n}"
}, {
	"Path": "jsyntaxpane.actions.ActionUtils.getSyntaxDocument",
	"Comment": "a helper function that will return the syntaxdocument attached to thegiven text component.return null if the document is not a syntaxdocument, or if the text component is null",
	"Method": "SyntaxDocument getSyntaxDocument(JTextComponent component){\r\n    if (component == null) {\r\n        return null;\r\n    }\r\n    Document doc = component.getDocument();\r\n    if (doc instanceof SyntaxDocument) {\r\n        return (SyntaxDocument) doc;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.swift.service.ThriftServerConfig.setQueueTimeout",
	"Comment": "sets a timeout period between receiving a request and the pulling the request off the queue.if the timeout expires before the request reaches the front of the queue and beginsprocessing, the server will discard the request instead of processing it.",
	"Method": "ThriftServerConfig setQueueTimeout(Duration queueTimeout){\r\n    this.queueTimeout = queueTimeout;\r\n    return this;\r\n}"
}, {
	"Path": "jsyntaxpane.DefaultSyntaxKit.setConfig",
	"Comment": "merges the given properties with the defaults, which are read from thejar file",
	"Method": "void setConfig(Properties config){\r\n    DefaultSyntaxKit.CONFIG.putAll(config);\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.PredicateSpec.cookie",
	"Comment": "a predicate that checks if a cookie matches a given regular expression",
	"Method": "BooleanSpec cookie(String name,String regex){\r\n    return asyncPredicate(getBean(CookieRoutePredicateFactory.class).applyAsync(c -> c.setName(name).setRegexp(regex)));\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.storage.FileCollectionStorage.select",
	"Comment": "select the group of files impacted by an operation.this function selects which files are impacted by a read or writeoperation, with their respective relative offset and chunk length.",
	"Method": "List<FileOffset> select(long offset,long length){\r\n    if (offset + length > this.size) {\r\n        throw new IllegalArgumentException(\"Buffer overrun (\" + offset + \" + \" + length + \" > \" + this.size + \") !\");\r\n    }\r\n    List<FileOffset> selected = new LinkedList<FileOffset>();\r\n    long bytes = 0;\r\n    for (FileStorage file : this.files) {\r\n        if (file.offset() >= offset + length) {\r\n            break;\r\n        }\r\n        if (file.offset() + file.size() < offset) {\r\n            continue;\r\n        }\r\n        long position = offset - file.offset();\r\n        position = position > 0 ? position : 0;\r\n        long size = Math.min(file.size() - position, length - bytes);\r\n        selected.add(new FileOffset(file, position, size));\r\n        bytes += size;\r\n    }\r\n    if (selected.size() == 0 || bytes < length) {\r\n        throw new IllegalStateException(\"Buffer underrun (only got \" + bytes + \" out of \" + length + \" byte(s) requested)!\");\r\n    }\r\n    return selected;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.TDivision.divideLongByInt",
	"Comment": "divides an unsigned long a by an unsigned int b. it is supposed that themost significant bit of b is set to 1, i.e. b0",
	"Method": "long divideLongByInt(long a,int b){\r\n    long quot;\r\n    long rem;\r\n    long bLong = b & 0xffffffffL;\r\n    if (a >= 0) {\r\n        quot = a / bLong;\r\n        rem = a % bLong;\r\n    } else {\r\n        long aPos = a >>> 1;\r\n        long bPos = b >>> 1;\r\n        quot = aPos / bPos;\r\n        rem = aPos % bPos;\r\n        rem = (rem << 1) + (a & 1);\r\n        if ((b & 1) != 0) {\r\n            if (quot <= rem) {\r\n                rem -= quot;\r\n            } else {\r\n                if (quot - rem <= bLong) {\r\n                    rem += bLong - quot;\r\n                    quot -= 1;\r\n                } else {\r\n                    rem += (bLong << 1) - quot;\r\n                    quot -= 2;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return (rem << 32) | (quot & 0xffffffffL);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerMultiplyTest.testCase6",
	"Comment": "multiply two numbers of different length and different signs.the first is positive.the second is longer.",
	"Method": "void testCase6(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 1, 2, 3, 4, 5 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { -11, -41, -101, 54, -97, -52, -77, -41, 44, -86, -116, -45, 126, -116, 20, 61, 14, -86, -65, 86, 1, 35, 35, 106 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.multiply(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "org.sqlite.date.FastDateFormat.getInstance",
	"Comment": "gets a formatter instance using the specified pattern, time zoneand locale.",
	"Method": "FastDateFormat getInstance(FastDateFormat getInstance,String pattern,FastDateFormat getInstance,String pattern,TimeZone timeZone,FastDateFormat getInstance,String pattern,Locale locale,FastDateFormat getInstance,String pattern,TimeZone timeZone,Locale locale){\r\n    return cache.getInstance(pattern, timeZone, locale);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerMultiplyTest.testCase4",
	"Comment": "multiply two positive numbers of different length.the second is longer.",
	"Method": "void testCase4(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 1, 2, 3, 4, 5 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 10, 40, 100, -55, 96, 51, 76, 40, -45, 85, 115, 44, -127, 115, -21, -62, -15, 85, 64, -87, -2, -36, -36, -106 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.multiply(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerMultiplyTest.testCase5",
	"Comment": "multiply two numbers of different length and different signs.the first is positive.the first is longer.",
	"Method": "void testCase5(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 1, 2, 3, 4, 5 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { -11, -41, -101, 54, -97, -52, -77, -41, 44, -86, -116, -45, 126, -116, 20, 61, 14, -86, -65, 86, 1, 35, 35, 106 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.multiply(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerMultiplyTest.testCase2",
	"Comment": "multiply two numbers of the same length and different signs.the first is negative.",
	"Method": "void testCase2(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -11, -41, -101, 54, -97, -52, -77, -41, 44, -86, -106, -5, -29, 85, 116, 51, -101, -121, -90 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.multiply(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerMultiplyTest.testCase3",
	"Comment": "multiply two positive numbers of different length.the first is longer.",
	"Method": "void testCase3(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 1, 2, 3, 4, 5 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 10, 40, 100, -55, 96, 51, 76, 40, -45, 85, 115, 44, -127, 115, -21, -62, -15, 85, 64, -87, -2, -36, -36, -106 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.multiply(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "be.tarsos.dsp.wavelet.lift.HaarWithPolynomialInterpolationWavelet.inverseTrans",
	"Comment": "haarwavelet transform extened with polynomial interpolation inverse\ttransform.\tthis version of the inversetrans function overrides the function in the\tliftingschemebasewavelet base class. this function introduces an inverse\tpolynomial interpolation stage at the start of the inverse transform.",
	"Method": "void inverseTrans(float[] vec){\r\n    final int N = vec.length;\r\n    for (int n = 2; n <= N; n = n << 1) {\r\n        interp(vec, n, inverse);\r\n        update(vec, n, inverse);\r\n        predict(vec, n, inverse);\r\n        merge(vec, n);\r\n    }\r\n}"
}, {
	"Path": "com.turn.ttorrent.TempFiles.getCurrentTempDir",
	"Comment": "returns the current directory used by the test or null if no test is running or no directory is created yet.",
	"Method": "File getCurrentTempDir(){\r\n    return myCurrentTempDir;\r\n}"
}, {
	"Path": "be.tarsos.dsp.AudioDispatcher.removeAudioProcessor",
	"Comment": "removes an audioprocessor to the chain of processors and calls its processingfinished method.",
	"Method": "void removeAudioProcessor(AudioProcessor audioProcessor){\r\n    audioProcessors.remove(audioProcessor);\r\n    audioProcessor.processingFinished();\r\n    LOG.fine(\"Remove an audioprocessor to the list of processors: \" + audioProcessor.toString());\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.setRequestSize",
	"Comment": "a filter that sets the maximum permissible size of a request.",
	"Method": "GatewayFilterSpec setRequestSize(Long size){\r\n    return filter(getBean(RequestSizeGatewayFilterFactory.class).apply(c -> c.setMaxSize(size)));\r\n}"
}, {
	"Path": "be.tarsos.dsp.io.jvm.AudioDispatcherFactory.fromByteArray",
	"Comment": "create a stream from an array of bytes and use that to create a new\taudiodispatcher.",
	"Method": "AudioDispatcher fromByteArray(byte[] byteArray,AudioFormat audioFormat,int audioBufferSize,int bufferOverlap){\r\n    final ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);\r\n    final long length = byteArray.length / audioFormat.getFrameSize();\r\n    final AudioInputStream stream = new AudioInputStream(bais, audioFormat, length);\r\n    TarsosDSPAudioInputStream audioStream = new JVMAudioInputStream(stream);\r\n    return new AudioDispatcher(audioStream, audioBufferSize, bufferOverlap);\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.PredicateSpec.header",
	"Comment": "a predicate that checks if a given headers has a value which matches a regular expression",
	"Method": "BooleanSpec header(String header,BooleanSpec header,String header,String regex){\r\n    return asyncPredicate(getBean(HeaderRoutePredicateFactory.class).applyAsync(c -> c.setHeader(header).setRegexp(regex)));\r\n}"
}, {
	"Path": "org.teavm.vm.TeaVM.setProperties",
	"Comment": "specifies configuration properties for teavm and its plugins. you should call this method beforeinstalling any plugins or interceptors.",
	"Method": "void setProperties(Properties properties){\r\n    this.properties.clear();\r\n    if (properties != null) {\r\n        this.properties.putAll(properties);\r\n    }\r\n}"
}, {
	"Path": "jsyntaxpane.actions.FindReplaceActions.doFindNext",
	"Comment": "perform a findnext operation on the given text component.positionthe caret at the start of the next found pattern",
	"Method": "void doFindNext(JTextComponent target){\r\n    if (target == null || pattern == null) {\r\n        return;\r\n    }\r\n    SyntaxDocument sDoc = ActionUtils.getSyntaxDocument(target);\r\n    if (sDoc == null) {\r\n        return;\r\n    }\r\n    int start = target.getCaretPosition() + 1;\r\n    if (start >= sDoc.getLength()) {\r\n        start = 0;\r\n    }\r\n    Matcher matcher = sDoc.getMatcher(pattern, start);\r\n    if (matcher != null && matcher.find()) {\r\n        target.select(matcher.start() + start, matcher.end() + start);\r\n    } else {\r\n        if (isWrap()) {\r\n            matcher = sDoc.getMatcher(pattern);\r\n            if (matcher != null && matcher.find()) {\r\n                target.select(matcher.start(), matcher.end());\r\n            } else {\r\n                msgNotFound();\r\n            }\r\n        } else {\r\n            msgNotFound();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.addRequestParameter",
	"Comment": "adds a request parameter to the request before it is routed by the gateway.",
	"Method": "GatewayFilterSpec addRequestParameter(String param,String value){\r\n    return filter(getBean(AddRequestParameterGatewayFilterFactory.class).apply(c -> c.setName(param).setValue(value)));\r\n}"
}, {
	"Path": "be.tarsos.dsp.SpectralPeakProcessor.calculateFrequencyEstimates",
	"Comment": "for each bin, calculate a precise frequency estimate using phase offset.",
	"Method": "void calculateFrequencyEstimates(){\r\n    for (int i = 0; i < frequencyEstimates.length; i++) {\r\n        frequencyEstimates[i] = getFrequencyForBin(i);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.loader.tools.Repackager.setMainClass",
	"Comment": "sets the main class that should be run. if not specified the value from the\tmanifest will be used, or if no manifest entry is found the archive will be\tsearched for a suitable class.",
	"Method": "void setMainClass(String mainClass){\r\n    this.mainClass = mainClass;\r\n}"
}, {
	"Path": "org.sqlite.core.DB.exec",
	"Comment": "executes an sql statement using the process of compiling, evaluating, and destroying theprepared statement object.",
	"Method": "void exec(String sql,boolean autoCommit){\r\n    long pointer = 0;\r\n    try {\r\n        pointer = prepare(sql);\r\n        int rc = step(pointer);\r\n        switch(rc) {\r\n            case SQLITE_DONE:\r\n                ensureAutoCommit(autoCommit);\r\n                return;\r\n            case SQLITE_ROW:\r\n                return;\r\n            default:\r\n                throwex(rc);\r\n        }\r\n    } finally {\r\n        finalize(pointer);\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.AudioEvent.getRMS",
	"Comment": "calculates and returns the root mean square of the signal. please\tcache the result since it is calculated every time.",
	"Method": "double getRMS(){\r\n    return calculateRMS(floatBuffer);\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.peer.SharingPeer.removeBlockRequest",
	"Comment": "remove the request message from the request pipeline matching thispiece message.upon reception of a piece block with a piece message, remove thecorresponding request from the pipeline to make room for the next blockrequests.",
	"Method": "void removeBlockRequest(Piece piece){\r\n    synchronized (this.requestsLock) {\r\n        Integer requestedBlocksCount = myRequestedPieces.get(piece);\r\n        if (requestedBlocksCount == null) {\r\n            return;\r\n        }\r\n        if (requestedBlocksCount <= 1) {\r\n            myRequestedPieces.remove(piece);\r\n        } else {\r\n            myRequestedPieces.put(piece, requestedBlocksCount - 1);\r\n        }\r\n        this.downloading = myRequestedPieces.size() > 0;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.tracer.impl.timeline.TimelineColorFactory.getPredefinedGradient",
	"Comment": "returns a color pair predefined for visualvm charts gradients.",
	"Method": "Color[] getPredefinedGradient(int index){\r\n    return PREDEFINED_GRADIENTS[index];\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.webflux.ProxyExchange.headers",
	"Comment": "additional headers, or overrides of the incoming ones, to be used in the downstream\tcall.",
	"Method": "ProxyExchange<T> headers(HttpHeaders headers,BodyBuilder headers,BodyBuilder builder){\r\n    proxy();\r\n    for (String name : filterHeaderKeys(headers)) {\r\n        builder.header(name, headers.get(name).toArray(new String[0]));\r\n    }\r\n    return builder;\r\n}"
}, {
	"Path": "org.sqlite.date.DateFormatUtils.format",
	"Comment": "formats a calendar into a specific pattern in a time zoneand locale.",
	"Method": "String format(long millis,String pattern,String format,Date date,String pattern,String format,Calendar calendar,String pattern,String format,long millis,String pattern,TimeZone timeZone,String format,Date date,String pattern,TimeZone timeZone,String format,Calendar calendar,String pattern,TimeZone timeZone,String format,long millis,String pattern,Locale locale,String format,Date date,String pattern,Locale locale,String format,Calendar calendar,String pattern,Locale locale,String format,long millis,String pattern,TimeZone timeZone,Locale locale,String format,Date date,String pattern,TimeZone timeZone,Locale locale,String format,Calendar calendar,String pattern,TimeZone timeZone,Locale locale){\r\n    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);\r\n    return df.format(calendar);\r\n}"
}, {
	"Path": "jsyntaxpane.SyntaxDocument.parse",
	"Comment": "parse the entire document and return list of tokens that do not alreadyexist in the tokens list.there may be overlaps, and replacements, which we will cleanup later.",
	"Method": "void parse(){\r\n    if (lexer == null) {\r\n        tokens = null;\r\n        return;\r\n    }\r\n    List<Token> toks = new ArrayList<Token>(getLength() / 10);\r\n    long ts = System.nanoTime();\r\n    int len = getLength();\r\n    try {\r\n        Segment seg = new Segment();\r\n        getText(0, getLength(), seg);\r\n        CharArrayReader reader = new CharArrayReader(seg.array, seg.offset, seg.count);\r\n        lexer.yyreset(reader);\r\n        Token token;\r\n        while ((token = lexer.yylex()) != null) {\r\n            toks.add(token);\r\n        }\r\n    } catch (BadLocationException ex) {\r\n        log.log(Level.SEVERE, null, ex);\r\n    } catch (IOException ex) {\r\n        log.log(Level.SEVERE, null, ex);\r\n    } finally {\r\n        if (log.isLoggable(Level.FINEST)) {\r\n            log.finest(String.format(\"Parsed %d in %d ms, giving %d tokens\\n\", len, (System.nanoTime() - ts) / 1000000, toks.size()));\r\n        }\r\n        tokens = toks;\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.example.KernelDensityEstimate.optimalCorrelation",
	"Comment": "calculates the optimal correlation between two kernel density estimates\tby shifting and searching for optimal correlation.",
	"Method": "double optimalCorrelation(KernelDensityEstimate other,double optimalCorrelation,KDECorrelation correlationMeasure,KernelDensityEstimate other){\r\n    int shift = shiftForOptimalCorrelation(correlationMeasure, other);\r\n    return correlationMeasure.correlation(this, other, shift);\r\n}"
}, {
	"Path": "com.turn.ttorrent.common.TorrentUtils.byteArrayToHexString",
	"Comment": "convert a byte string to a string containing an hexadecimalrepresentation of the original data.",
	"Method": "String byteArrayToHexString(byte[] bytes){\r\n    char[] hexChars = new char[bytes.length * 2];\r\n    for (int j = 0; j < bytes.length; j++) {\r\n        int v = bytes[j] & 0xFF;\r\n        hexChars[j * 2] = HEX_SYMBOLS[v >>> 4];\r\n        hexChars[j * 2 + 1] = HEX_SYMBOLS[v & 0x0F];\r\n    }\r\n    return new String(hexChars);\r\n}"
}, {
	"Path": "jsyntaxpane.SyntaxDocument.replaceLineAt",
	"Comment": "replace the line at given position with the given string, which can spanmultiple lines",
	"Method": "void replaceLineAt(int pos,String newLines){\r\n    Element e = getParagraphElement(pos);\r\n    replace(e.getStartOffset(), getElementLength(e), newLines, null);\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.builtin.VoidThriftCodec.read",
	"Comment": "always returns null without reading anything from the stream.",
	"Method": "Void read(TProtocol protocol){\r\n    Preconditions.checkNotNull(protocol, \"protocol is null\");\r\n    return null;\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.peer.SharingPeer.firePeerChoked",
	"Comment": "fire the peer choked event to all registered listeners.the event contains the peer that chocked.",
	"Method": "void firePeerChoked(){\r\n    for (PeerActivityListener listener : this.listeners) {\r\n        listener.handlePeerChoked(this);\r\n    }\r\n}"
}, {
	"Path": "org.telegram.abilitybots.api.db.MapDBContext.onlineInstance",
	"Comment": "this db returned by this method does not trigger deletion on jvm shutdown.",
	"Method": "DBContext onlineInstance(String name){\r\n    DB db = DBMaker.fileDB(name).fileMmapEnableIfSupported().closeOnJvmShutdown().transactionEnable().make();\r\n    return new MapDBContext(db);\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.mbeans.XTable.getSelectedIndex",
	"Comment": "this returns the select index as the table was at initialization",
	"Method": "int getSelectedIndex(){\r\n    return convertRowToIndex(getSelectedRow());\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TMatcher.quoteReplacement",
	"Comment": "returns a replacement string for the given one that has all backslashesand dollar signs escaped.",
	"Method": "String quoteReplacement(String s){\r\n    if (s.indexOf('\\\\') < 0 && s.indexOf('$') < 0) {\r\n        return s;\r\n    }\r\n    StringBuilder res = new StringBuilder(s.length() * 2);\r\n    char ch;\r\n    int len = s.length();\r\n    for (int i = 0; i < len; i++) {\r\n        ch = s.charAt(i);\r\n        switch(ch) {\r\n            case '$':\r\n                res.append('\\\\');\r\n                res.append('$');\r\n                break;\r\n            case '\\\\':\r\n                res.append('\\\\');\r\n                res.append('\\\\');\r\n                break;\r\n            default:\r\n                res.append(ch);\r\n        }\r\n    }\r\n    return res.toString();\r\n}"
}, {
	"Path": "jsyntaxpane.actions.FindReplaceActions.replaceAll",
	"Comment": "perform a replace all operation on the given component.note that this create a new duplicate string big as the entiredocument and then assign it to the target text component",
	"Method": "void replaceAll(JTextComponent target,String replacement){\r\n    SyntaxDocument sDoc = ActionUtils.getSyntaxDocument(target);\r\n    if (pattern == null || sDoc == null) {\r\n        return;\r\n    }\r\n    Matcher matcher = sDoc.getMatcher(pattern);\r\n    String newText = matcher.replaceAll(replacement);\r\n    target.setText(newText);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TLeafSet.matches",
	"Comment": "checks if we can enter this state and pass the control to the next one.return positive value if match succeeds, negative otherwise.",
	"Method": "int matches(int stringIndex,CharSequence testString,TMatchResultImpl matchResult){\r\n    if (stringIndex + charCount() > matchResult.getRightBound()) {\r\n        matchResult.hitEnd = true;\r\n        return -1;\r\n    }\r\n    int shift = accepts(stringIndex, testString);\r\n    if (shift < 0) {\r\n        return -1;\r\n    }\r\n    return next.matches(stringIndex + shift, testString, matchResult);\r\n}"
}, {
	"Path": "org.sqlite.date.FastDatePrinter.getMaxLengthEstimate",
	"Comment": "gets an estimate for the maximum string length that theformatter will produce.the actual formatted length will almost always be less than orequal to this amount.",
	"Method": "int getMaxLengthEstimate(){\r\n    return mMaxLengthEstimate;\r\n}"
}, {
	"Path": "be.tarsos.dsp.pitch.DTMF.audioBufferDTMF",
	"Comment": "creates an audio buffer in a float array of the defined size. the sample\trate is 44100hz by default. it mixes the two given frequencies with an\tamplitude of 0.5.",
	"Method": "float[] audioBufferDTMF(double f0,double f1,int size){\r\n    final double sampleRate = 44100.0;\r\n    final double amplitudeF0 = 0.4;\r\n    final double amplitudeF1 = 0.4;\r\n    final double twoPiF0 = 2 * Math.PI * f0;\r\n    final double twoPiF1 = 2 * Math.PI * f1;\r\n    final float[] buffer = new float[size];\r\n    for (int sample = 0; sample < buffer.length; sample++) {\r\n        final double time = sample / sampleRate;\r\n        double f0Component = amplitudeF0 * Math.sin(twoPiF0 * time);\r\n        double f1Component = amplitudeF1 * Math.sin(twoPiF1 * time);\r\n        buffer[sample] = (float) (f0Component + f1Component);\r\n    }\r\n    return buffer;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigDecimalConvertTest.testToEngineeringStringPos",
	"Comment": "convert a positive bigdecimal to an engineering string representation",
	"Method": "void testToEngineeringStringPos(){\r\n    String a = \"123809648392384754573567356745735.63567890295784902768787678287E-501\";\r\n    BigDecimal aNumber = new BigDecimal(a);\r\n    String result = \"123.80964839238475457356735674573563567890295784902768787678287E-471\";\r\n    assertEquals(\"incorrect value\", result, aNumber.toEngineeringString());\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.removeResponseHeader",
	"Comment": "a filter that will remove a response header before the gateway returns the response to the client.",
	"Method": "GatewayFilterSpec removeResponseHeader(String headerName){\r\n    return filter(getBean(RemoveResponseHeaderGatewayFilterFactory.class).apply(c -> c.setName(headerName)));\r\n}"
}, {
	"Path": "org.sqlite.SQLiteConfig.setJournalMode",
	"Comment": "sets the journal mode for databases associated with the current databaseconnection.",
	"Method": "void setJournalMode(JournalMode mode){\r\n    setPragma(Pragma.JOURNAL_MODE, mode.name());\r\n}"
}, {
	"Path": "be.tarsos.dsp.util.ConcurrencyUtils.getThreadsBeginN_1D_FFT_4Threads",
	"Comment": "returns the minimal size of 1d data for which four threads are used.",
	"Method": "int getThreadsBeginN_1D_FFT_4Threads(){\r\n    return THREADS_BEGIN_N_1D_FFT_4THREADS;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TPattern.getSupplement",
	"Comment": "returns supplementary character. at this time only for ascii chars.",
	"Method": "char getSupplement(char ch){\r\n    char res = ch;\r\n    if (ch >= 'a' && ch <= 'z') {\r\n        res -= 32;\r\n    } else if (ch >= 'A' && ch <= 'Z') {\r\n        res += 32;\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.tracer.TracerProbe.getStateHandler",
	"Comment": "optionally returns probestatehandler instance which obtains notificationsabout the tracer session status. default implementation returns null.you may use stateaware subclass instead of implementing this method toobtain the notifications.",
	"Method": "ProbeStateHandler<X> getStateHandler(ProbeStateHandler<X> getStateHandler){\r\n    return null;\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.buildStruct",
	"Comment": "defines the code to build the struct instance using the data in the local variables.",
	"Method": "LocalVariableDefinition buildStruct(MethodDefinition read,Map<Short, LocalVariableDefinition> structData){\r\n    LocalVariableDefinition instance = constructStructInstance(read, structData);\r\n    injectStructFields(read, instance, structData);\r\n    injectStructMethods(read, instance, structData);\r\n    invokeFactoryMethod(read, structData, instance);\r\n    return instance;\r\n}"
}, {
	"Path": "org.telegram.telegrambots.updatesreceivers.ExponentialBackOff.reset",
	"Comment": "sets the interval back to the initial retry interval and restarts the timer.",
	"Method": "void reset(){\r\n    currentIntervalMillis = initialIntervalMillis;\r\n    startTimeNanos = nanoTime();\r\n}"
}, {
	"Path": "be.tarsos.dsp.util.ConcurrencyUtils.setThreadsBeginN_1D_FFT_4Threads",
	"Comment": "sets the minimal size of 1d data for which four threads are used.",
	"Method": "void setThreadsBeginN_1D_FFT_4Threads(int n){\r\n    if (n < 512) {\r\n        THREADS_BEGIN_N_1D_FFT_4THREADS = 512;\r\n    } else {\r\n        THREADS_BEGIN_N_1D_FFT_4THREADS = n;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.swift.generator.swift2thrift.Swift2ThriftGenerator.verifyTypes",
	"Comment": "and does a topological sort of thrifttypes in dependency order",
	"Method": "boolean verifyTypes(){\r\n    SuccessAndResult<ThriftType> output = topologicalSort(thriftTypes, new Predicate<ThriftType>() {\r\n        @Override\r\n        public boolean apply(@Nullable ThriftType t) {\r\n            ThriftProtocolType proto = checkNotNull(t).getProtocolType();\r\n            if (proto == ThriftProtocolType.ENUM || proto == ThriftProtocolType.STRUCT) {\r\n                return verifyStruct(t, true);\r\n            } else {\r\n                Preconditions.checkState(false, \"Top-level non-enum and non-struct?\");\r\n                return false;\r\n            }\r\n        }\r\n    });\r\n    if (output.success) {\r\n        thriftTypes = output.result;\r\n        return true;\r\n    } else {\r\n        for (ThriftType t : output.result) {\r\n            verifyStruct(t, false);\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.swift.generator.swift2thrift.Swift2ThriftGenerator.verifyTypes",
	"Comment": "and does a topological sort of thrifttypes in dependency order",
	"Method": "boolean verifyTypes(){\r\n    ThriftProtocolType proto = checkNotNull(t).getProtocolType();\r\n    if (proto == ThriftProtocolType.ENUM || proto == ThriftProtocolType.STRUCT) {\r\n        return verifyStruct(t, true);\r\n    } else {\r\n        Preconditions.checkState(false, \"Top-level non-enum and non-struct?\");\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.experimental.AudioEvent.getStartTimeStamp",
	"Comment": "calculates and returns the time stamp at the beginning of this audio event.",
	"Method": "double getStartTimeStamp(){\r\n    return bytesProcessed / format.getFrameSize() / format.getSampleRate();\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigDecimalConvertTest.testToEngineeringStringZeroPosExponent",
	"Comment": "convert a negative bigdecimal to an engineering string representation",
	"Method": "void testToEngineeringStringZeroPosExponent(){\r\n    String a = \"0.0E+16\";\r\n    BigDecimal aNumber = new BigDecimal(a);\r\n    String result = \"0E+15\";\r\n    assertEquals(\"incorrect value\", result, aNumber.toEngineeringString());\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.peer.Rate.get",
	"Comment": "get the current rate.the exchange rate is the number of bytes exchanged since the lastreset and the last input.",
	"Method": "float get(){\r\n    if (this.last - this.reset == 0) {\r\n        return 0;\r\n    }\r\n    return this.bytes / ((this.last - this.reset) / 1000.0f);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TMatcher.useTransparentBounds",
	"Comment": "determines whether this matcher has transparent bounds enabled or not.when transparent bounds are enabled, the parts of the input outside theregion are subject to lookahead and lookbehind, otherwise they are not.transparent bounds are disabled by default.",
	"Method": "TMatcher useTransparentBounds(boolean value){\r\n    matchResult.useTransparentBounds(value);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.cloud.config.server.environment.EnvironmentController.setAcceptEmpty",
	"Comment": "flag to indicate that if http 404 needs to be sent if application is not found",
	"Method": "void setAcceptEmpty(boolean acceptEmpty){\r\n    this.acceptEmpty = acceptEmpty;\r\n}"
}, {
	"Path": "jsyntaxpane.util.Configuration.subConfig",
	"Comment": "return a sub configuration from this instance that has the keys equal toeither prefix.keyprefix or keyprefix.the entries of keyprefix areadded first, so they are the defaults if prefix is not found.",
	"Method": "Configuration subConfig(String prefix,String keyPrefix){\r\n    Configuration sub = new Configuration();\r\n    addToSubConf(sub, prefix.length() > 0 ? prefix + \".\" + keyPrefix : keyPrefix);\r\n    return sub;\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.tracer.TracerProgressObject.setText",
	"Comment": "updates text describing the current state without adding any steps to thecurrent initialization progress.",
	"Method": "void setText(String text){\r\n    this.text = text;\r\n    fireChange();\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.mbeans.XTable.getCellRenderer",
	"Comment": "this method sets read write rows to be blue, and other rows to be theirdefault rendered colour.",
	"Method": "TableCellRenderer getCellRenderer(int row,int column){\r\n    DefaultTableCellRenderer tcr = (DefaultTableCellRenderer) super.getCellRenderer(row, column);\r\n    tcr.setToolTipText(getToolTip(row, column));\r\n    if (defaultColor == null) {\r\n        defaultColor = tcr.getForeground();\r\n        editableColor = Color.blue;\r\n        errorColor = Color.red;\r\n        if (defaultColor == null) {\r\n            return tcr;\r\n        }\r\n    }\r\n    if (column != VALUE_COLUMN) {\r\n        tcr.setForeground(defaultColor);\r\n        return tcr;\r\n    }\r\n    if (isCellError(row, column)) {\r\n        tcr.setForeground(errorColor);\r\n    } else if (isCellEditable(row, column)) {\r\n        tcr.setForeground(editableColor);\r\n    } else {\r\n        tcr.setForeground(defaultColor);\r\n    }\r\n    return tcr;\r\n}"
}, {
	"Path": "be.tarsos.dsp.wavelet.lift.HaarWithPolynomialInterpolationWavelet.forwardTrans",
	"Comment": "haarwavelet transform extened with polynomial interpolation forward\ttransform.\tthis version of the forwardtrans function overrides the function in the\tliftingschemebasewavelet base class. this function introduces an extra\tpolynomial interpolation stage at the end of the transform.",
	"Method": "void forwardTrans(float[] vec){\r\n    final int N = vec.length;\r\n    for (int n = N; n > 1; n = n >> 1) {\r\n        split(vec, n);\r\n        predict(vec, n, forward);\r\n        update(vec, n, forward);\r\n        interp(vec, n, forward);\r\n    }\r\n}"
}, {
	"Path": "org.telegram.telegrambots.updatesreceivers.ExponentialBackOff.getMultiplier",
	"Comment": "returns the value to multiply the current interval with for each retry attempt.",
	"Method": "double getMultiplier(double getMultiplier){\r\n    return multiplier;\r\n}"
}, {
	"Path": "jsyntaxpane.SyntaxDocument.getPairFor",
	"Comment": "this is used to return the other part of a paired token in the document.a paired part has token.pairvalue0, and the paired token willhave the negative of t.pairvalue.this method properly handles nestings of same pairvalues, but overlapsare not checked.if the document does not contain a paired",
	"Method": "Token getPairFor(Token t){\r\n    if (t == null || t.pairValue == 0) {\r\n        return null;\r\n    }\r\n    Token p = null;\r\n    int ndx = tokens.indexOf(t);\r\n    int w = t.pairValue;\r\n    int direction = (t.pairValue > 0) ? 1 : -1;\r\n    boolean done = false;\r\n    int v = Math.abs(t.pairValue);\r\n    while (!done) {\r\n        ndx += direction;\r\n        if (ndx < 0 || ndx >= tokens.size()) {\r\n            break;\r\n        }\r\n        Token current = tokens.get(ndx);\r\n        if (Math.abs(current.pairValue) == v) {\r\n            w += current.pairValue;\r\n            if (w == 0) {\r\n                p = current;\r\n                done = true;\r\n            }\r\n        }\r\n    }\r\n    return p;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.TBitLevel.shiftLeftOneBit",
	"Comment": "shifts the source digits left one bit, creating a value whose magnitudeis doubled.",
	"Method": "void shiftLeftOneBit(int[] result,int[] source,int srcLen,TBigInteger shiftLeftOneBit,TBigInteger source){\r\n    int srcLen = source.numberLength;\r\n    int resLen = srcLen + 1;\r\n    int[] resDigits = new int[resLen];\r\n    shiftLeftOneBit(resDigits, source.digits, srcLen);\r\n    TBigInteger result = new TBigInteger(source.sign, resLen, resDigits);\r\n    result.cutOffLeadingZeroes();\r\n    return result;\r\n}"
}, {
	"Path": "be.tarsos.dsp.beatroot.AgentList.removeDuplicates",
	"Comment": "removes agents from the list which are duplicates of other agents.\t a duplicate is defined by the tempo and phase thresholds\t thresholdbi and thresholdbt respectively.",
	"Method": "void removeDuplicates(){\r\n    sort();\r\n    for (AgentList ptr = this; ptr.ag != null; ptr = ptr.next) {\r\n        if (ptr.ag.phaseScore < 0.0)\r\n            continue;\r\n        for (AgentList ptr2 = ptr.next; ptr2.ag != null; ptr2 = ptr2.next) {\r\n            if (ptr2.ag.beatInterval - ptr.ag.beatInterval > thresholdBI)\r\n                break;\r\n            if (Math.abs(ptr.ag.beatTime - ptr2.ag.beatTime) > thresholdBT)\r\n                continue;\r\n            if (ptr.ag.phaseScore < ptr2.ag.phaseScore) {\r\n                ptr.ag.phaseScore = -1.0;\r\n                if (ptr2.ag.topScoreTime < ptr.ag.topScoreTime)\r\n                    ptr2.ag.topScoreTime = ptr.ag.topScoreTime;\r\n                break;\r\n            } else {\r\n                ptr2.ag.phaseScore = -1.0;\r\n                if (ptr.ag.topScoreTime < ptr2.ag.topScoreTime)\r\n                    ptr.ag.topScoreTime = ptr2.ag.topScoreTime;\r\n            }\r\n        }\r\n    }\r\n    for (AgentList ptr = this; ptr.ag != null; ) {\r\n        if (ptr.ag.phaseScore < 0.0) {\r\n            remove(ptr);\r\n        } else\r\n            ptr = ptr.next;\r\n    }\r\n}"
}, {
	"Path": "jsyntaxpane.actions.ActionUtils.getLineNumber",
	"Comment": "gets the line number at the give position of the editor component.the first line number is zero",
	"Method": "int getLineNumber(JTextComponent editor,int pos){\r\n    if (getSyntaxDocument(editor) != null) {\r\n        SyntaxDocument sdoc = getSyntaxDocument(editor);\r\n        return sdoc.getLineNumberAt(pos);\r\n    } else {\r\n        Document doc = editor.getDocument();\r\n        return doc.getDefaultRootElement().getElementIndex(pos);\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.example.dissonance.KernelDensityEstimate.remove",
	"Comment": "remove a value from the kde, removes a kernel at the specified position.",
	"Method": "void remove(double value){\r\n    int accumulatorSize = accumulator.length;\r\n    int calculationAria = kernel.size() / 2;\r\n    int start = (int) (value + accumulatorSize - calculationAria);\r\n    int stop = (int) (value + accumulatorSize + calculationAria);\r\n    if (kernel.size() % 2 != 0)\r\n        stop++;\r\n    for (int i = start; i < stop; i++) {\r\n        double kernelValue = kernel.value(i - start);\r\n        accumulator[i % accumulatorSize] -= kernelValue;\r\n        sum -= kernelValue;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.addResponseHeader",
	"Comment": "adds a header to the response returned to the gateway from the route.",
	"Method": "GatewayFilterSpec addResponseHeader(String headerName,String headerValue){\r\n    return filter(getBean(AddResponseHeaderGatewayFilterFactory.class).apply(c -> c.setName(headerName).setValue(headerValue)));\r\n}"
}, {
	"Path": "be.tarsos.dsp.AudioEvent.calculateRMS",
	"Comment": "calculates and returns the root mean square of the signal. please\tcache the result since it is calculated every time.",
	"Method": "double calculateRMS(float[] floatBuffer){\r\n    double rms = 0.0;\r\n    for (int i = 0; i < floatBuffer.length; i++) {\r\n        rms += floatBuffer[i] * floatBuffer[i];\r\n    }\r\n    rms = rms / Double.valueOf(floatBuffer.length);\r\n    rms = Math.sqrt(rms);\r\n    return rms;\r\n}"
}, {
	"Path": "com.turn.ttorrent.bcodec.BEValue.getString",
	"Comment": "returns this bevalue as a string, interpreted with the specifiedencoding.",
	"Method": "String getString(String getString,String encoding){\r\n    try {\r\n        return new String(this.getBytes(), encoding);\r\n    } catch (ClassCastException cce) {\r\n        throw new InvalidBEncodingException(cce.toString());\r\n    } catch (UnsupportedEncodingException uee) {\r\n        throw new InternalError(uee.toString());\r\n    }\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.mvc.ProxyExchange.sensitive",
	"Comment": "sets the names of sensitive headers that are not passed downstream to the backend\tservice.",
	"Method": "ProxyExchange<T> sensitive(String names){\r\n    if (this.sensitive == null) {\r\n        this.sensitive = new HashSet();\r\n    }\r\n    for (String name : names) {\r\n        this.sensitive.add(name.toLowerCase());\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.teavm.classlib.impl.tz.DateTimeZone.getMillisKeepLocal",
	"Comment": "gets the millisecond instant in another zone keeping the same local time.the conversion is performed by converting the specified utc millis to localmillis in this zone, then converting back to utc millis in the new zone.",
	"Method": "long getMillisKeepLocal(DateTimeZone newZone,long oldInstant){\r\n    if (newZone == this) {\r\n        return oldInstant;\r\n    }\r\n    long instantLocal = convertUTCToLocal(oldInstant);\r\n    return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.net.TURI.toString",
	"Comment": "returns the textual string representation of this uri instance.",
	"Method": "String toString(){\r\n    if (string == null) {\r\n        TStringBuilder result = new TStringBuilder();\r\n        if (scheme != null) {\r\n            result.append(scheme);\r\n            result.append(':');\r\n        }\r\n        if (opaque) {\r\n            result.append(schemespecificpart);\r\n        } else {\r\n            if (authority != null) {\r\n                result.append(TString.wrap(\"//\"));\r\n                result.append(authority);\r\n            }\r\n            if (path != null) {\r\n                result.append(path);\r\n            }\r\n            if (query != null) {\r\n                result.append('?');\r\n                result.append(query);\r\n            }\r\n        }\r\n        if (fragment != null) {\r\n            result.append('#');\r\n            result.append(fragment);\r\n        }\r\n        string = TString.wrap(result.toString());\r\n    }\r\n    return string.toString();\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.jconsole.JConsolePluginWrapper.pathToURLs",
	"Comment": "utility method for converting a search path string to an arrayof directory and jar file urls.",
	"Method": "URL[] pathToURLs(String path){\r\n    String[] names = path.split(File.pathSeparator);\r\n    URL[] urls = new URL[names.length + 1];\r\n    urls[0] = JConsolePluginWrapper.class.getProtectionDomain().getCodeSource().getLocation();\r\n    int count = 1;\r\n    for (String f : names) {\r\n        URL url = fileToURL(new File(f));\r\n        urls[count++] = url;\r\n    }\r\n    return urls;\r\n}"
}, {
	"Path": "org.sqlite.SQLiteConfig.createConnection",
	"Comment": "create a new jdbc connection using the current configuration",
	"Method": "Connection createConnection(String url){\r\n    return JDBC.createConnection(url, toProperties());\r\n}"
}, {
	"Path": "org.sqlite.date.FastDateFormat.getMaxLengthEstimate",
	"Comment": "gets an estimate for the maximum string length that theformatter will produce.the actual formatted length will almost always be less than orequal to this amount.",
	"Method": "int getMaxLengthEstimate(){\r\n    return printer.getMaxLengthEstimate();\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TMatcher.hasTransparentBounds",
	"Comment": "indicates whether this matcher has transparent bounds enabled. whentransparent bounds are enabled, the parts of the input outside the regionare subject to lookahead and lookbehind, otherwise they are not.transparent bounds are disabled by default.",
	"Method": "boolean hasTransparentBounds(){\r\n    return matchResult.hasTransparentBounds();\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.PredicateSpec.query",
	"Comment": "a predicate that checks if a given query parameter is present in the request url",
	"Method": "BooleanSpec query(String param,String regex,BooleanSpec query,String param){\r\n    return asyncPredicate(getBean(QueryRoutePredicateFactory.class).applyAsync(c -> c.setParam(param)));\r\n}"
}, {
	"Path": "jsyntaxpane.SyntaxDocument.getElementLength",
	"Comment": "helper method to get the length of an element and avoid gettinga too long element at the end of the document",
	"Method": "int getElementLength(Element e){\r\n    int end = e.getEndOffset();\r\n    if (end >= (getLength() - 1)) {\r\n        end--;\r\n    }\r\n    return end - e.getStartOffset();\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.defineWriteBridgeMethod",
	"Comment": "defines the generics bridge method with untyped args to the type specific write method.",
	"Method": "void defineWriteBridgeMethod(){\r\n    classDefinition.addMethod(new MethodDefinition(a(PUBLIC, BRIDGE, SYNTHETIC), \"write\", null, arg(\"struct\", Object.class), arg(\"protocol\", TProtocol.class)).addException(Exception.class).loadThis().loadVariable(\"struct\", structType).loadVariable(\"protocol\").invokeVirtual(codecType, \"write\", type(void.class), structType, type(TProtocol.class)).ret());\r\n}"
}, {
	"Path": "org.springframework.cloud.config.server.environment.JGitEnvironmentRepository.deleteUntrackedLocalBranches",
	"Comment": "deletes local branches if corresponding remote branch was removed.",
	"Method": "Collection<String> deleteUntrackedLocalBranches(Collection<TrackingRefUpdate> trackingRefUpdates,Git git){\r\n    if (CollectionUtils.isEmpty(trackingRefUpdates)) {\r\n        return Collections.emptyList();\r\n    }\r\n    Collection<String> branchesToDelete = new ArrayList();\r\n    for (TrackingRefUpdate trackingRefUpdate : trackingRefUpdates) {\r\n        ReceiveCommand receiveCommand = trackingRefUpdate.asReceiveCommand();\r\n        if (receiveCommand.getType() == DELETE) {\r\n            String localRefName = trackingRefUpdate.getLocalName();\r\n            if (StringUtils.startsWithIgnoreCase(localRefName, LOCAL_BRANCH_REF_PREFIX)) {\r\n                String localBranchName = localRefName.substring(LOCAL_BRANCH_REF_PREFIX.length(), localRefName.length());\r\n                branchesToDelete.add(localBranchName);\r\n            }\r\n        }\r\n    }\r\n    if (CollectionUtils.isEmpty(branchesToDelete)) {\r\n        return Collections.emptyList();\r\n    }\r\n    try {\r\n        checkout(git, defaultLabel);\r\n        return deleteBranches(git, branchesToDelete);\r\n    } catch (Exception ex) {\r\n        String message = format(\"Failed to delete %s branches.\", branchesToDelete);\r\n        warn(message, ex);\r\n        return Collections.emptyList();\r\n    }\r\n}"
}, {
	"Path": "jsyntaxpane.actions.ActionUtils.getDocumentPosition",
	"Comment": "get the closest position within the document of the component thathas given line and column.",
	"Method": "int getDocumentPosition(JTextComponent editor,int line,int column){\r\n    int lineHeight = editor.getFontMetrics(editor.getFont()).getHeight();\r\n    int charWidth = editor.getFontMetrics(editor.getFont()).charWidth('m');\r\n    int y = line * lineHeight;\r\n    int x = column * charWidth;\r\n    Point pt = new Point(x, y);\r\n    int pos = editor.viewToModel(pt);\r\n    return pos;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testDoubleValuePosRounded2",
	"Comment": "convert a positive number to a double value.rounding is needed.the rounding bit is 1 and the next bit to the left is 0but some of dropped bits are 1s.",
	"Method": "void testDoubleValuePosRounded2(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, 36, 23, 1, -3, -5 };\r\n    int aSign = 1;\r\n    double result = 1.547472643879479E26;\r\n    double aNumber = new BigInteger(aSign, a).doubleValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "org.telegram.abilitybots.api.util.AbilityUtils.fullName",
	"Comment": "the full name is identified as the concatenation of the first and last name, separated by a space.this method can return an empty name if both first and last name are empty.",
	"Method": "String fullName(User user){\r\n    StringJoiner name = new StringJoiner(\" \");\r\n    if (!isEmpty(user.getFirstName()))\r\n        name.add(user.getFirstName());\r\n    if (!isEmpty(user.getLastName()))\r\n        name.add(user.getLastName());\r\n    return name.toString();\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TJointSet.processSecondPass",
	"Comment": "this method is used for traversing nodes after the first stage ofcompilation.",
	"Method": "void processSecondPass(){\r\n    this.isSecondPassVisited = true;\r\n    if (fSet != null && !fSet.isSecondPassVisited) {\r\n        fSet.processSecondPass();\r\n    }\r\n    if (children != null) {\r\n        int childrenSize = children.size();\r\n        for (int i = 0; i < childrenSize; i++) {\r\n            TAbstractSet child = children.get(i);\r\n            TJointSet set = child.processBackRefReplacement();\r\n            if (set != null) {\r\n                child.isSecondPassVisited = true;\r\n                children.remove(i);\r\n                children.add(i, set);\r\n                child = set;\r\n            }\r\n            if (!child.isSecondPassVisited) {\r\n                child.processSecondPass();\r\n            }\r\n        }\r\n    }\r\n    if (next != null) {\r\n        super.processSecondPass();\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TLexer.hasSingleCodepointDecomposition",
	"Comment": "tests if given codepoint is a canonical decomposition of anothercodepoint.",
	"Method": "boolean hasSingleCodepointDecomposition(int ch){\r\n    int hasSingleDecomp = singleDecompTable.get(ch);\r\n    return hasSingleDecomp != singleDecompTableSize;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testDoubleValuePosRounded1",
	"Comment": "convert a positive number to a double value.rounding is needed.the rounding bit is 1 and the next bit to the left is 1.",
	"Method": "void testDoubleValuePosRounded1(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = 1;\r\n    double result = 1.54747264387948E26;\r\n    double aNumber = new BigInteger(aSign, a).doubleValue();\r\n    assertEquals(aNumber, result, 1E14);\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.rewriteResponseHeader",
	"Comment": "a filter that rewrites a header value on the response before it is returned to the client by the gateway.",
	"Method": "GatewayFilterSpec rewriteResponseHeader(String headerName,String regex,String replacement){\r\n    return filter(getBean(RewriteResponseHeaderGatewayFilterFactory.class).apply(c -> c.setReplacement(replacement).setRegexp(regex).setName(headerName)));\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.tracer.TracerPackage.getStateHandler",
	"Comment": "optionally returns packagestatehandler instance which obtains notificationsabout the tracer session status in context of tracerprobes provided by thistracerpackage. default implementation returns null. you may use stateawaresubclass instead of implementing this method to obtain the notifications.",
	"Method": "PackageStateHandler<X> getStateHandler(PackageStateHandler<X> getStateHandler){\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.setStatus",
	"Comment": "a filter that sets the status on the response before it is returned to the client by the gateway.",
	"Method": "GatewayFilterSpec setStatus(int status,GatewayFilterSpec setStatus,HttpStatus status,GatewayFilterSpec setStatus,String status){\r\n    return filter(getBean(SetStatusGatewayFilterFactory.class).apply(c -> c.setStatus(status)));\r\n}"
}, {
	"Path": "com.turn.ttorrent.tracker.TrackedPeer.getDownloaded",
	"Comment": "returns how many bytes the peer reported it has downloaded so far.",
	"Method": "long getDownloaded(){\r\n    return this.downloaded;\r\n}"
}, {
	"Path": "org.springframework.boot.loader.tools.MainClassFinder.doWithMainClasses",
	"Comment": "perform the given callback operation on all main classes from the given jar.",
	"Method": "T doWithMainClasses(File rootFolder,MainClassCallback<T> callback,T doWithMainClasses,JarFile jarFile,String classesLocation,MainClassCallback<T> callback){\r\n    List<JarEntry> classEntries = getClassEntries(jarFile, classesLocation);\r\n    classEntries.sort(new ClassEntryComparator());\r\n    for (JarEntry entry : classEntries) {\r\n        try (InputStream inputStream = new BufferedInputStream(jarFile.getInputStream(entry))) {\r\n            ClassDescriptor classDescriptor = createClassDescriptor(inputStream);\r\n            if (classDescriptor != null && classDescriptor.isMainMethodFound()) {\r\n                String className = convertToClassName(entry.getName(), classesLocation);\r\n                T result = callback.doWith(new MainClass(className, classDescriptor.getAnnotationNames()));\r\n                if (result != null) {\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.SharedTorrent.markCompleted",
	"Comment": "mark a piece as completed, decrementing the piece size in bytes from ourleft bytes to download counter.",
	"Method": "void markCompleted(Piece piece){\r\n    if (this.completedPieces.get(piece.getIndex())) {\r\n        return;\r\n    }\r\n    myTorrentStatistic.addLeft(-piece.size());\r\n    this.completedPieces.set(piece.getIndex());\r\n    if (completedPieces.cardinality() == getPiecesCount()) {\r\n        logger.info(\"all pieces are received for torrent {}. Validating...\", this);\r\n    }\r\n}"
}, {
	"Path": "jsyntaxpane.actions.MapCompletionAction.config",
	"Comment": "the completions will for now reside on another properties style filereferenced by prefix.completions.file",
	"Method": "void config(Configuration config,String prefix,String name){\r\n    String completionsFile = config.getPrefixProperty(prefix, \"Completions.File\", \"NONE\");\r\n    if (completionsFile != null) {\r\n        completions = JarServiceProvider.readStringsMap(completionsFile);\r\n    }\r\n}"
}, {
	"Path": "jsyntaxpane.SyntaxStyles.drawText",
	"Comment": "draw the given token.this will simply find the proper syntaxstyle forthe tokentype and then asks the proper style to draw the text of thetoken.",
	"Method": "int drawText(Segment segment,int x,int y,Graphics graphics,TabExpander e,Token token){\r\n    SyntaxStyle s = getStyle(token.type);\r\n    return s.drawText(segment, x, y, graphics, e, token.start);\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.CommunicationManager.setAnnounceInterval",
	"Comment": "set specified announce interval between requests to the tracker",
	"Method": "void setAnnounceInterval(int announceInterval){\r\n    announce.setAnnounceInterval(announceInterval);\r\n}"
}, {
	"Path": "be.tarsos.dsp.granulator.Granulator.getFrameCubic",
	"Comment": "retrieves a frame of audio using cubic interpolation. if the frame is not\tin the sample range then zeros are returned.",
	"Method": "float getFrameCubic(double posInMS){\r\n    float frame = (float) msToSamples(posInMS);\r\n    float result = 0.0f;\r\n    float a0, a1, a2, a3, mu2;\r\n    float ym1, y0, y1, y2;\r\n    int realCurrentSample = (int) Math.floor(frame);\r\n    float fractionOffset = (float) (frame - realCurrentSample);\r\n    if (realCurrentSample >= 0 && realCurrentSample < (audioBufferWatermark - 1)) {\r\n        realCurrentSample--;\r\n        if (realCurrentSample < 0) {\r\n            ym1 = audioBuffer[0];\r\n            realCurrentSample = 0;\r\n        } else {\r\n            ym1 = audioBuffer[realCurrentSample++];\r\n        }\r\n        y0 = audioBuffer[realCurrentSample++];\r\n        if (realCurrentSample >= audioBufferWatermark) {\r\n            y1 = audioBuffer[audioBufferWatermark - 1];\r\n        } else {\r\n            y1 = audioBuffer[realCurrentSample++];\r\n        }\r\n        if (realCurrentSample >= audioBufferWatermark) {\r\n            y2 = audioBuffer[audioBufferWatermark - 1];\r\n        } else {\r\n            y2 = audioBuffer[realCurrentSample++];\r\n        }\r\n        mu2 = fractionOffset * fractionOffset;\r\n        a0 = y2 - y1 - ym1 + y0;\r\n        a1 = ym1 - y0 - a0;\r\n        a2 = y1 - ym1;\r\n        a3 = y0;\r\n        result = a0 * fractionOffset * mu2 + a1 * mu2 + a2 * fractionOffset + a3;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.setResponseHeader",
	"Comment": "a filter that sets a header on the response before it is returned to the client by the gateway.",
	"Method": "GatewayFilterSpec setResponseHeader(String headerName,String headerValue){\r\n    return filter(getBean(SetResponseHeaderGatewayFilterFactory.class).apply(c -> c.setName(headerName).setValue(headerValue)));\r\n}"
}, {
	"Path": "com.turn.ttorrent.tracker.TrackedPeer.getUploaded",
	"Comment": "returns how many bytes the peer reported it has uploaded so far.",
	"Method": "long getUploaded(){\r\n    return this.uploaded;\r\n}"
}, {
	"Path": "jsyntaxpane.actions.ActionUtils.getTabSize",
	"Comment": "return the tabstop property for the given text component, or 0 if notused",
	"Method": "int getTabSize(JTextComponent text){\r\n    Integer tabs = (Integer) text.getDocument().getProperty(PlainDocument.tabSizeAttribute);\r\n    return (null == tabs) ? 0 : tabs.intValue();\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.TMultiplication.multiply",
	"Comment": "performs a multiplication of two biginteger and hides the algorithm used.",
	"Method": "TBigInteger multiply(TBigInteger x,TBigInteger y){\r\n    return karatsuba(x, y);\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.modifyRequestBody",
	"Comment": "a filter that can be used to modify the request body.\tthis filter is beta and may be subject to change in a future release.",
	"Method": "GatewayFilterSpec modifyRequestBody(Class<T> inClass,Class<R> outClass,RewriteFunction<T, R> rewriteFunction,GatewayFilterSpec modifyRequestBody,Class<T> inClass,Class<R> outClass,String newContentType,RewriteFunction<T, R> rewriteFunction){\r\n    return filter(getBean(ModifyRequestBodyGatewayFilterFactory.class).apply(c -> c.setRewriteFunction(inClass, outClass, rewriteFunction).setContentType(newContentType)));\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.removeRequestHeader",
	"Comment": "a filter that will remove a request header before the request is routed by the gateway.",
	"Method": "GatewayFilterSpec removeRequestHeader(String headerName){\r\n    return filter(getBean(RemoveRequestHeaderGatewayFilterFactory.class).apply(c -> c.setName(headerName)));\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerDivideTest.testCase21",
	"Comment": "divideandremainder of two numbers of different signs.the first is negative.",
	"Method": "void testCase21(){\r\n    byte[] aBytes = { -127, 100, 56, 7, 98, -1, 39, -128, 127, 75 };\r\n    byte[] bBytes = { 27, -15, 65, 39, 100 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[][] rBytes = { { -5, 94, -115, -74, -85, 84 }, { -13, 20, -74, -57, -27 } };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger[] result = aNumber.divideAndRemainder(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result[0].toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        if (resBytes[i] != rBytes[0][i]) {\r\n            fail(\"Incorrect quotation\");\r\n        }\r\n    }\r\n    assertEquals(-1, result[0].signum());\r\n    resBytes = result[1].toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        if (resBytes[i] != rBytes[1][i]) {\r\n            fail(\"Incorrect remainder\");\r\n        }\r\n        assertEquals(-1, result[1].signum());\r\n    }\r\n}"
}, {
	"Path": "jsyntaxpane.DefaultLexer.token",
	"Comment": "helper method to create and return a new token from of tokentype",
	"Method": "Token token(TokenType type,int tStart,int tLength,int newStart,int newLength){\r\n    tokenStart = newStart;\r\n    tokenLength = newLength;\r\n    return new Token(type, tStart, tLength);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerDivideTest.testCase20",
	"Comment": "remainder of division of two numbers of different signs.the first is negative.",
	"Method": "void testCase20(){\r\n    byte[] aBytes = { -127, 100, 56, 7, 98, -1, 39, -128, 127, 75 };\r\n    byte[] bBytes = { 27, -15, 65, 39, 100 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -13, 20, -74, -57, -27 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.remainder(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "org.sqlite.date.FastDatePrinter.applyRules",
	"Comment": "performs the formatting by applying the rules to thespecified calendar.",
	"Method": "StringBuffer applyRules(Calendar calendar,StringBuffer buf){\r\n    for (final Rule rule : mRules) {\r\n        rule.appendTo(buf, calendar);\r\n    }\r\n    return buf;\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.mbeans.Utils.getDefaultValue",
	"Comment": "this method inserts a default value for the standard java types,else it inserts the text name of the expected class type.it acts to give a clue as to the input type.",
	"Method": "String getDefaultValue(String type){\r\n    if (numericalTypes.contains(type) || extraNumericalTypes.contains(type)) {\r\n        return \"0\";\r\n    }\r\n    if (booleanTypes.contains(type)) {\r\n        return \"true\";\r\n    }\r\n    type = getReadableClassName(type);\r\n    int i = type.lastIndexOf('.');\r\n    if (i > 0) {\r\n        return type.substring(i + 1, type.length());\r\n    } else {\r\n        return type;\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TSingleSet.processSecondPass",
	"Comment": "this method is used for traversing nodes after the first stage ofcompilation.",
	"Method": "void processSecondPass(){\r\n    this.isSecondPassVisited = true;\r\n    if (fSet != null && !fSet.isSecondPassVisited) {\r\n        fSet.processSecondPass();\r\n    }\r\n    if (kid != null && !kid.isSecondPassVisited) {\r\n        TJointSet set = kid.processBackRefReplacement();\r\n        if (set != null) {\r\n            kid.isSecondPassVisited = true;\r\n            kid = set;\r\n        }\r\n        kid.processSecondPass();\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerDivideTest.testCase19",
	"Comment": "remainder of division of two numbers of different signs.the first is positive.",
	"Method": "void testCase19(){\r\n    byte[] aBytes = { -127, 100, 56, 7, 98, -1, 39, -128, 127, 75 };\r\n    byte[] bBytes = { 27, -15, 65, 39, 100 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 12, -21, 73, 56, 27 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.remainder(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.Piece.noLongerAt",
	"Comment": "mark this piece as no longer being available at the given peer.",
	"Method": "void noLongerAt(SharingPeer peer){\r\n    this.seen--;\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.mbeans.XTextFieldEditor.actionPerformed",
	"Comment": "edition stopped ou jmenuitem selection & jtextfield selection",
	"Method": "void actionPerformed(ActionEvent e){\r\n    super.actionPerformed(e);\r\n    if ((e.getSource() instanceof JMenuItem) || (e.getSource() instanceof JTextField)) {\r\n        fireEditingStopped();\r\n    }\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testDoubleValueNegNotRounded",
	"Comment": "convert a positive number to a double value.rounding is not needed.",
	"Method": "void testDoubleValueNegNotRounded(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, -128, 23, 1, -3, -5 };\r\n    int aSign = -1;\r\n    double result = -1.5474726438794828E26;\r\n    double aNumber = new BigInteger(aSign, a).doubleValue();\r\n    assertEquals(aNumber, result, 1E14);\r\n}"
}, {
	"Path": "be.tarsos.dsp.experimental.AudioEvent.getRMS",
	"Comment": "calculates and returns the root mean square of the signal. please\tcache the result since it is calculated every time.",
	"Method": "double getRMS(){\r\n    return calculateRMS(inputBuffer);\r\n}"
}, {
	"Path": "jsyntaxpane.DefaultSyntaxKit.createDefaultDocument",
	"Comment": "this is called by swing to create a document for the jeditorpane documentthis may be called before you actually get a reference to the control.we use it here to create a proper lexer and pass it to the syntaxdcument we return.",
	"Method": "Document createDefaultDocument(){\r\n    return new SyntaxDocument(lexer);\r\n}"
}, {
	"Path": "org.sqlite.SQLiteConfig.enforceForeignKeys",
	"Comment": "whether to enforce foreign key constraints. this setting affects theexecution of all statements prepared using the database connection,including those prepared before the setting was changed.",
	"Method": "void enforceForeignKeys(boolean enforce){\r\n    set(Pragma.FOREIGN_KEYS, enforce);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testFloatValuePosRounded2",
	"Comment": "convert a positive number to a float value.rounding is needed.the rounding bit is 1 and the next bit to the left is 0but some of dropped bits are 1s.",
	"Method": "void testFloatValuePosRounded2(){\r\n    byte[] a = { -128, 1, 2, -128, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = 1;\r\n    float result = 1.5474728E26f;\r\n    float aNumber = new BigInteger(aSign, a).floatValue();\r\n    assertEquals(aNumber, result, 1E20);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConvertTest.testFloatValuePosRounded1",
	"Comment": "convert a positive number to a float value.rounding is needed.the rounding bit is 1 and the next bit to the left is 1.",
	"Method": "void testFloatValuePosRounded1(){\r\n    byte[] a = { -128, 1, -1, -4, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = 1;\r\n    float result = 1.5475195E26f;\r\n    float aNumber = new BigInteger(aSign, a).floatValue();\r\n    assertEquals(aNumber, result, 1E20);\r\n}"
}, {
	"Path": "org.sqlite.core.DB.column_names",
	"Comment": "returns an array of column names in the result set of the select statement.",
	"Method": "String[] column_names(long stmt){\r\n    String[] names = new String[column_count(stmt)];\r\n    for (int i = 0; i < names.length; i++) {\r\n        names[i] = column_name(stmt, i);\r\n    }\r\n    return names;\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.preserveHostHeader",
	"Comment": "a filter that will preserve the host header of the request on the outgoing request from the gateway.",
	"Method": "GatewayFilterSpec preserveHostHeader(){\r\n    return filter(getBean(PreserveHostHeaderGatewayFilterFactory.class).apply());\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.mbeans.Utilities.newTableScrollPane",
	"Comment": "a slightly modified border for jscrollpane to be used with a jtable insidea jtabbedpane. it has only top part and the rest is clipped to make theoverall border less thick.the top border helps differentiating the containing table from its container.",
	"Method": "JScrollPane newTableScrollPane(JComponent comp){\r\n    return new TableScrollPane(comp);\r\n}"
}, {
	"Path": "org.sqlite.date.FastDateFormat.applyRules",
	"Comment": "performs the formatting by applying the rules to thespecified calendar.",
	"Method": "StringBuffer applyRules(Calendar calendar,StringBuffer buf){\r\n    return printer.applyRules(calendar, buf);\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.tracer.TracerProbeDescriptor.isProbeAvailable",
	"Comment": "returns true if the probe is available in current context, false otherwise.",
	"Method": "boolean isProbeAvailable(){\r\n    return available;\r\n}"
}, {
	"Path": "org.sqlite.SQLiteDataSource.setDefaultCacheSize",
	"Comment": "sets the default maximum number of database disk pages that sqlite willhold in memory at once per open database file.",
	"Method": "void setDefaultCacheSize(int numberOfPages){\r\n    config.setDefaultCacheSize(numberOfPages);\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.peer.SharingPeer.unchoke",
	"Comment": "unchoke this peer.mark that we are no longer choking from this peer and can resumeuploading to it.",
	"Method": "void unchoke(){\r\n    logger.trace(\"Unchoking {}\", this);\r\n    this.send(PeerMessage.UnchokeMessage.craft());\r\n    this.choking = false;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.TDivision.remainder",
	"Comment": "divides a biginteger by a signed int andreturns the remainder.",
	"Method": "int remainder(TBigInteger dividend,int divisor){\r\n    return remainderArrayByInt(dividend.digits, dividend.numberLength, divisor);\r\n}"
}, {
	"Path": "be.tarsos.dsp.AudioGenerator.generateNextAudioBlock",
	"Comment": "reads the next audio block. it tries to read the number of bytes defined\tby the audio buffer size minus the overlap. if the expected number of\tbytes could not be read either the end of the stream is reached or\tsomething went wrong.\tthe behavior for the first and last buffer is defined by their corresponding the zero pad settings. the method also handles the case if\tthe first buffer is also the last.",
	"Method": "void generateNextAudioBlock(){\r\n    assert floatOverlap < audioFloatBuffer.length;\r\n    if (audioFloatBuffer.length == floatOverlap + floatStepSize) {\r\n        System.arraycopy(audioFloatBuffer, floatStepSize, audioFloatBuffer, 0, floatOverlap);\r\n    }\r\n    samplesProcessed += floatStepSize;\r\n}"
}, {
	"Path": "be.tarsos.dsp.io.jvm.AudioDispatcherFactory.fromFloatArray",
	"Comment": "create a stream from an array of floats and use that to create a new\taudiodispatcher.",
	"Method": "AudioDispatcher fromFloatArray(float[] floatArray,int sampleRate,int audioBufferSize,int bufferOverlap){\r\n    final AudioFormat audioFormat = new AudioFormat(sampleRate, 16, 1, true, false);\r\n    final TarsosDSPAudioFloatConverter converter = TarsosDSPAudioFloatConverter.getConverter(JVMAudioInputStream.toTarsosDSPFormat(audioFormat));\r\n    final byte[] byteArray = new byte[floatArray.length * audioFormat.getFrameSize()];\r\n    converter.toByteArray(floatArray, byteArray);\r\n    return AudioDispatcherFactory.fromByteArray(byteArray, audioFormat, audioBufferSize, bufferOverlap);\r\n}"
}, {
	"Path": "org.sqlite.SQLiteConfig.setPageSize",
	"Comment": "sets the page size of the database. the page size must be a power of twobetween 512 and 65536 inclusive.",
	"Method": "void setPageSize(int numBytes){\r\n    set(Pragma.PAGE_SIZE, numBytes);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.lang.TRuntime.freeMemory",
	"Comment": "returns the amount of free memory in the system. calling the gc methodmay result in increasing the value returned by freememory.",
	"Method": "long freeMemory(){\r\n    return Integer.MAX_VALUE;\r\n}"
}, {
	"Path": "org.teavm.classlib.java.util.regex.TMatcher.group",
	"Comment": "returns the text that matched the whole regular expression.",
	"Method": "String group(int group,String group){\r\n    return group(0);\r\n}"
}, {
	"Path": "com.turn.ttorrent.client.Piece.size",
	"Comment": "returns the size, in bytes, of this piece.all pieces, except the last one, are expected to have the same size.",
	"Method": "long size(){\r\n    return this.length;\r\n}"
}, {
	"Path": "com.facebook.swift.generator.SwiftGeneratorConfig.getOutputFolder",
	"Comment": "returns the output folder which will contain the generated sources.",
	"Method": "File getOutputFolder(){\r\n    return outputFolder;\r\n}"
}, {
	"Path": "be.tarsos.dsp.wavelet.lift.PolynomialWavelets.inverseTrans",
	"Comment": "polynomial wavelet lifting scheme inverse transform.\tthis version of the inversetrans function overrides the function in the\tliftingschemebasewavelet base class. this function introduces an inverse\tpolynomial interpolation stage at the start of the inverse transform.",
	"Method": "void inverseTrans(float[] vec){\r\n    final int N = vec.length;\r\n    for (int n = 2; n <= N; n = n << 1) {\r\n        predict(vec, n, inverse);\r\n        update(vec, n, inverse);\r\n        merge(vec, n);\r\n    }\r\n}"
}, {
	"Path": "org.sqlite.SQLiteDataSource.setEnforceForeignKeys",
	"Comment": "enables or disables the enforcement of foreign key constraints.",
	"Method": "void setEnforceForeignKeys(boolean enforce){\r\n    config.enforceForeignKeys(enforce);\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.GatewayFilterSpec.addRequestHeader",
	"Comment": "adds a request header to the request before it is routed by the gateway.",
	"Method": "GatewayFilterSpec addRequestHeader(String headerName,String headerValue){\r\n    return filter(getBean(AddRequestHeaderGatewayFilterFactory.class).apply(c -> c.setName(headerName).setValue(headerValue)));\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.webflux.ProxyExchange.uri",
	"Comment": "sets the uri for the backend call when triggered by the http methods.",
	"Method": "ProxyExchange<T> uri(String uri){\r\n    try {\r\n        this.uri = new URI(uri);\r\n    } catch (URISyntaxException e) {\r\n        throw new IllegalStateException(\"Cannot create URI\", e);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "jsyntaxpane.SyntaxStyles.mergeStyles",
	"Comment": "you can call the mergestyles method with a properties file to customizethe existing styles.any existing styles will be overwritten by thestyles you provide.",
	"Method": "void mergeStyles(Properties styles){\r\n    for (String token : styles.stringPropertyNames()) {\r\n        String stv = styles.getProperty(token);\r\n        try {\r\n            TokenType tt = TokenType.valueOf(token);\r\n            SyntaxStyle tokenStyle = new SyntaxStyle(stv);\r\n            put(tt, tokenStyle);\r\n        } catch (IllegalArgumentException ex) {\r\n            LOG.warning(\"illegal token type or style for: \" + token);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.io.jvm.AudioDispatcherFactory.fromFile",
	"Comment": "create a stream from a file and use that to create a new audiodispatcher",
	"Method": "AudioDispatcher fromFile(File audioFile,int audioBufferSize,int bufferOverlap){\r\n    final AudioInputStream stream = AudioSystem.getAudioInputStream(audioFile);\r\n    TarsosDSPAudioInputStream audioStream = new JVMAudioInputStream(stream);\r\n    return new AudioDispatcher(audioStream, audioBufferSize, bufferOverlap);\r\n}"
}, {
	"Path": "org.teavm.classlib.java.net.TURI.equalsHexCaseInsensitive",
	"Comment": "takes two strings that may contain hex sequences like  or + andcompares them, ignoring case for the hex values. hex values must alwaysoccur in pairs as above",
	"Method": "boolean equalsHexCaseInsensitive(TString first,TString second){\r\n    if (first.indexOf('%') != second.indexOf('%')) {\r\n        return first.equals(second);\r\n    }\r\n    int index = 0;\r\n    int previndex = 0;\r\n    while (true) {\r\n        index = first.indexOf('%', previndex);\r\n        if (index == -1) {\r\n            break;\r\n        }\r\n        if (second.indexOf('%', previndex) != index) {\r\n            break;\r\n        }\r\n        boolean match = first.substring(previndex, index).equals(second.substring(previndex, index));\r\n        if (!match) {\r\n            return false;\r\n        }\r\n        match = first.substring(index + 1, index + 3).equals(second.substring(index + 1, index + 3));\r\n        if (!match) {\r\n            return false;\r\n        }\r\n        index += 3;\r\n        previndex = index;\r\n    }\r\n    return first.substring(previndex).equals(second.substring(previndex));\r\n}"
}, {
	"Path": "org.sqlite.SQLiteConfig.setCacheSize",
	"Comment": "changes the maximum number of database disk pages that sqlite will holdin memory at once per open database file.",
	"Method": "void setCacheSize(int numberOfPages){\r\n    set(Pragma.CACHE_SIZE, numberOfPages);\r\n}"
}, {
	"Path": "be.tarsos.dsp.io.TarsosDSPAudioFormat.properties",
	"Comment": "obtain an unmodifiable map of properties.the concept of properties is further explained inthe.",
	"Method": "Map<String, Object> properties(){\r\n    Map<String, Object> ret;\r\n    if (properties == null) {\r\n        ret = new HashMap<String, Object>(0);\r\n    } else {\r\n        ret = (Map<String, Object>) (properties.clone());\r\n    }\r\n    return (Map<String, Object>) Collections.unmodifiableMap(ret);\r\n}"
}, {
	"Path": "org.sqlite.core.DB.close",
	"Comment": "closes a database connection and finalizes any remaining statements beforethe closing operation.",
	"Method": "void close(){\r\n    synchronized (stmts) {\r\n        Iterator<Map.Entry<Long, CoreStatement>> i = stmts.entrySet().iterator();\r\n        while (i.hasNext()) {\r\n            Map.Entry<Long, CoreStatement> entry = i.next();\r\n            CoreStatement stmt = entry.getValue();\r\n            finalize(entry.getKey().longValue());\r\n            if (stmt != null) {\r\n                stmt.pointer = 0;\r\n            }\r\n            i.remove();\r\n        }\r\n    }\r\n    free_functions();\r\n    if (begin != 0) {\r\n        finalize(begin);\r\n        begin = 0;\r\n    }\r\n    if (commit != 0) {\r\n        finalize(commit);\r\n        commit = 0;\r\n    }\r\n    closed.set(true);\r\n    _close();\r\n}"
}, {
	"Path": "org.teavm.classlib.impl.tz.CachedDateTimeZone.forZone",
	"Comment": "returns a new cacheddatetimezone unless given zone is already cached.",
	"Method": "CachedDateTimeZone forZone(StorableDateTimeZone zone){\r\n    if (zone instanceof CachedDateTimeZone) {\r\n        return (CachedDateTimeZone) zone;\r\n    }\r\n    return new CachedDateTimeZone(zone);\r\n}"
}, {
	"Path": "jsyntaxpane.actions.ActionUtils.getFrameFor",
	"Comment": "returns the frame that contains this component or null if the componentis not within a window or the containing window is not a frame",
	"Method": "Frame getFrameFor(Component comp){\r\n    Window w = SwingUtilities.getWindowAncestor(comp);\r\n    if (w != null && w instanceof Frame) {\r\n        Frame frame = (Frame) w;\r\n        return frame;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.graalvm.visualvm.modules.tracer.ProbeItemDescriptor.discreteFillItem",
	"Comment": "creates descriptor of a discrete item created by filled segments.",
	"Method": "ProbeItemDescriptor discreteFillItem(String name,String description,ItemValueFormatter formatter,ProbeItemDescriptor discreteFillItem,String name,String description,ItemValueFormatter formatter,double dataFactor,long minValue,long maxValue){\r\n    return discreteOutlineItem(name, description, formatter, dataFactor, minValue, maxValue, DEFAULT_LINE_WIDTH, null, DEFAULT_COLOR);\r\n}"
}, {
	"Path": "jsyntaxpane.actions.ActionUtils.isEmptyOrBlanks",
	"Comment": "checks if the given string is null, empty or contains whitespace only",
	"Method": "boolean isEmptyOrBlanks(String string){\r\n    if (string == null || string.length() == 0) {\r\n        return true;\r\n    }\r\n    for (int i = 0; i < string.length(); i++) {\r\n        char c = string.charAt(i);\r\n        if (!Character.isWhitespace(c)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "be.tarsos.dsp.io.jvm.AudioDispatcherFactory.fromURL",
	"Comment": "create a stream from an url and use that to create a new audiodispatcher",
	"Method": "AudioDispatcher fromURL(URL audioURL,int audioBufferSize,int bufferOverlap){\r\n    final AudioInputStream stream = AudioSystem.getAudioInputStream(audioURL);\r\n    TarsosDSPAudioInputStream audioStream = new JVMAudioInputStream(stream);\r\n    return new AudioDispatcher(audioStream, audioBufferSize, bufferOverlap);\r\n}"
}, {
	"Path": "jsyntaxpane.components.PairsMarker.removeMarkers",
	"Comment": "remove all the highlights from the editor pane.this should be calledwhen the editorkit is removed.",
	"Method": "void removeMarkers(){\r\n    Markers.removeMarkers(pane, marker);\r\n}"
}, {
	"Path": "org.springframework.cloud.gateway.route.builder.PredicateSpec.readBody",
	"Comment": "this predicate is beta and may be subject to change in a future release.\ta predicate that checks the contents of the request body",
	"Method": "BooleanSpec readBody(Class<T> inClass,Predicate<T> predicate){\r\n    return asyncPredicate(getBean(ReadBodyPredicateFactory.class).applyAsync(c -> c.setPredicate(inClass, predicate)));\r\n}"
}, {
	"Path": "org.teavm.classlib.java.math.BigIntegerConstructorsTest.testConstructorSignBytesZero2",
	"Comment": "create a zero number from a sign and an array of zero bytes.the sign is 0.",
	"Method": "void testConstructorSignBytesZero2(){\r\n    byte[] aBytes = { -0, 0, +0, 0, 0, 00, 000 };\r\n    int aSign = 0;\r\n    byte[] rBytes = { 0 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 0, aNumber.signum());\r\n}"
}, {
	"Path": "be.tarsos.dsp.util.ConcurrencyUtils.setThreadsBeginN_1D_FFT_2Threads",
	"Comment": "sets the minimal size of 1d data for which two threads are used.",
	"Method": "void setThreadsBeginN_1D_FFT_2Threads(int n){\r\n    if (n < 512) {\r\n        THREADS_BEGIN_N_1D_FFT_2THREADS = 512;\r\n    } else {\r\n        THREADS_BEGIN_N_1D_FFT_2THREADS = n;\r\n    }\r\n}"
}, {
	"Path": "be.tarsos.dsp.test.FFTTest.testAudioBufferSine",
	"Comment": "constructs and returns a buffer of a two seconds long pure sine of 440hz\tsampled at 44.1khz.",
	"Method": "float[] testAudioBufferSine(){\r\n    final double sampleRate = 44100.0;\r\n    final double f0 = 440.0;\r\n    final double amplitudeF0 = 0.5;\r\n    final double seconds = 2.0;\r\n    final float[] buffer = new float[(int) (seconds * sampleRate)];\r\n    for (int sample = 0; sample < buffer.length; sample++) {\r\n        final double time = sample / sampleRate;\r\n        buffer[sample] = (float) (amplitudeF0 * Math.sin(2 * Math.PI * f0 * time));\r\n    }\r\n    return buffer;\r\n}"
}]