[{
	"Path": "org.jivesoftware.openfire.XMPPServer.setRemoteSessionLocator",
	"Comment": "sets the locator to use to find sessions hosted in other cluster nodes. when not runningin a cluster set a null value.",
	"Method": "void setRemoteSessionLocator(RemoteSessionLocator remoteSessionLocator){\r\n    this.remoteSessionLocator = remoteSessionLocator;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.setNotifiedOfDelete",
	"Comment": "sets whether subscribers will be notified when the node is deleted.",
	"Method": "void setNotifiedOfDelete(boolean notifyDelete){\r\n    this.notifyDelete = notifyDelete;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.ImportExportPlugin.validateImportFile",
	"Comment": "returns whether or not the supplied fileitem matches the openfire user schema",
	"Method": "boolean validateImportFile(FileItem usersFile,boolean xep227Support){\r\n    try {\r\n        InExporter exporter = XMLImportExportFactory.getExportInstance(xep227Support);\r\n        return exporter.validate(usersFile.getInputStream());\r\n    } catch (Exception e) {\r\n        Log.error(e.getMessage(), e);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.setPersistPublishedItems",
	"Comment": "sets if items are going to be persisted in a storage. note that when thevariable is false then the last published item is the only items being savedto the backend storage.",
	"Method": "void setPersistPublishedItems(boolean persistPublishedItems){\r\n    this.persistPublishedItems = persistPublishedItems;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.mediaproxy.MediaProxySession.getCreator",
	"Comment": "get the agent creator.this field is open to mediaproxy users and just can be set in constructor.",
	"Method": "String getCreator(){\r\n    return creator;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.interceptor.InterceptorManager.getUserInterceptors",
	"Comment": "returns an unmodifable list of packet interceptors that are related to thespecified username.",
	"Method": "List<PacketInterceptor> getUserInterceptors(String username){\r\n    List<PacketInterceptor> userInterceptors = usersInterceptors.get(username);\r\n    if (userInterceptors == null) {\r\n        return Collections.emptyList();\r\n    } else {\r\n        return Collections.unmodifiableList(userInterceptors);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getPubSubModule",
	"Comment": "returns the pubsubmodule registered with this server. thepubsubmodule was registered with the server as a module while starting upthe server.",
	"Method": "PubSubModule getPubSubModule(){\r\n    return (PubSubModule) modules.get(PubSubModule.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.HistoryRequest.sendHistory",
	"Comment": "sends the smallest amount of traffic that meets any combination of the requested criteria.",
	"Method": "void sendHistory(LocalMUCRole joinRole,MUCRoomHistory roomHistory){\r\n    if (!isConfigured()) {\r\n        Iterator<Message> history = roomHistory.getMessageHistory();\r\n        while (history.hasNext()) {\r\n            joinRole.send(history.next());\r\n        }\r\n    } else {\r\n        if (getMaxChars() == 0) {\r\n            return;\r\n        }\r\n        int accumulatedChars = 0;\r\n        int accumulatedStanzas = 0;\r\n        Element delayInformation;\r\n        LinkedList<Message> historyToSend = new LinkedList();\r\n        ListIterator<Message> iterator = roomHistory.getReverseMessageHistory();\r\n        while (iterator.hasPrevious()) {\r\n            Message message = iterator.previous();\r\n            String text = message.getBody() == null ? message.getSubject() : message.getBody();\r\n            if (text == null) {\r\n                continue;\r\n            }\r\n            accumulatedChars += text.length();\r\n            if (getMaxChars() > -1 && accumulatedChars > getMaxChars()) {\r\n                break;\r\n            }\r\n            accumulatedStanzas++;\r\n            if (getMaxStanzas() > -1 && accumulatedStanzas > getMaxStanzas()) {\r\n                break;\r\n            }\r\n            if (getSeconds() > -1 || getSince() != null) {\r\n                delayInformation = message.getChildElement(\"delay\", \"urn:xmpp:delay\");\r\n                try {\r\n                    Date delayedDate = xmppDateTime.parseString(delayInformation.attributeValue(\"stamp\"));\r\n                    if (getSince() != null && delayedDate != null && delayedDate.before(getSince())) {\r\n                        break;\r\n                    }\r\n                    if (getSeconds() > -1) {\r\n                        Date current = new Date();\r\n                        long diff = (current.getTime() - delayedDate.getTime()) / 1000;\r\n                        if (getSeconds() <= diff) {\r\n                            break;\r\n                        }\r\n                    }\r\n                } catch (Exception e) {\r\n                    Log.error(\"Error parsing date from historic message\", e);\r\n                }\r\n            }\r\n            historyToSend.addFirst(message);\r\n        }\r\n        for (Object aHistoryToSend : historyToSend) {\r\n            joinRole.send((Message) aHistoryToSend);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.CheckChainTrustedTest.testNullChainArgument",
	"Comment": "verifies that providing a null value for the first argument causes a runtime exception to be thrown.",
	"Method": "void testNullChainArgument(){\r\n    final CertSelector selector = new X509CertSelector();\r\n    final X509Certificate[] chain = null;\r\n    trustManager.checkChainTrusted(selector, chain);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.ConnectionManagerImpl.getAdminConsoleListenAddress",
	"Comment": "returns the specific network interface on which the openfire administrationconsole should be configured to listen, or null when no such preferencehas been configured.",
	"Method": "InetAddress getAdminConsoleListenAddress(){\r\n    String acInterfaceName = JiveGlobals.getXMLProperty(\"adminConsole.interface\");\r\n    InetAddress acBindInterface = null;\r\n    if (acInterfaceName != null) {\r\n        if (acInterfaceName.trim().length() > 0) {\r\n            acBindInterface = InetAddress.getByName(acInterfaceName);\r\n        }\r\n    }\r\n    return acBindInterface;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.view.UserInfoView.extractUserInfoClaimsIntoSet",
	"Comment": "pull the claims that have been targeted into a set for processing.\treturns an empty set if the input is null.",
	"Method": "Set<String> extractUserInfoClaimsIntoSet(JsonObject claims){\r\n    Set<String> target = new HashSet();\r\n    if (claims != null) {\r\n        JsonObject userinfoAuthorized = claims.getAsJsonObject(\"userinfo\");\r\n        if (userinfoAuthorized != null) {\r\n            for (Entry<String, JsonElement> entry : userinfoAuthorized.entrySet()) {\r\n                target.add(entry.getKey());\r\n            }\r\n        }\r\n    }\r\n    return target;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.MultiUserChatManager.getMultiUserChatServices",
	"Comment": "retrieves all of the multiuserchatservices managed and configured for this server, sorted bysubdomain.",
	"Method": "List<MultiUserChatService> getMultiUserChatServices(){\r\n    List<MultiUserChatService> services = new ArrayList(mucServices.values());\r\n    Collections.sort(services, new ServiceComparator());\r\n    return services;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sasl.ScramSha1SaslServer.getIterations",
	"Comment": "retrieve the iteration count from the database for a given username.",
	"Method": "int getIterations(String username){\r\n    try {\r\n        return AuthFactory.getIterations(username);\r\n    } catch (UserNotFoundException e) {\r\n        return JiveGlobals.getIntProperty(\"sasl.scram-sha-1.iteration-count\", ScramUtils.DEFAULT_ITERATION_COUNT);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.getLanguage",
	"Comment": "returns the default language of the node. this information is really optional and can bemodified by submiting a completed data form with the new node configuration.",
	"Method": "String getLanguage(){\r\n    return language;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.readSerializableMap",
	"Comment": "reads a map of serializable key and value pairs. this method will returnnull if the map written to the stream was null.",
	"Method": "int readSerializableMap(DataInput in,Map<? extends Serializable, ? extends Serializable> map,ClassLoader loader){\r\n    return strategy.readSerializableMap(in, map, loader);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.commands.admin.GetServerStats.hasPermission",
	"Comment": "returns if the requester can access this command. only admins and componentsare allowed to execute this command.",
	"Method": "boolean hasPermission(JID requester){\r\n    return super.hasPermission(requester) || InternalComponentManager.getInstance().hasComponent(requester);\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.TestDefaultUserInfoService.getByUsernameAndClientId_pairwiseClients",
	"Comment": "clients with pairwise subs should be grouped by the sector uri",
	"Method": "void getByUsernameAndClientId_pairwiseClients(){\r\n    Mockito.when(clientDetailsEntityService.loadClientByClientId(pairwiseClientId1)).thenReturn(pairwiseClient1);\r\n    Mockito.when(clientDetailsEntityService.loadClientByClientId(pairwiseClientId2)).thenReturn(pairwiseClient2);\r\n    Mockito.when(clientDetailsEntityService.loadClientByClientId(pairwiseClientId3)).thenReturn(pairwiseClient3);\r\n    Mockito.when(clientDetailsEntityService.loadClientByClientId(pairwiseClientId4)).thenReturn(pairwiseClient4);\r\n    Mockito.when(userInfoRepository.getByUsername(regularUsername)).thenAnswer(new Answer<UserInfo>() {\r\n        @Override\r\n        public UserInfo answer(InvocationOnMock invocation) throws Throwable {\r\n            UserInfo userInfo = new DefaultUserInfo();\r\n            userInfo.setPreferredUsername(regularUsername);\r\n            userInfo.setSub(regularSub);\r\n            return userInfo;\r\n        }\r\n    });\r\n    Mockito.when(pairwiseIdentiferService.getIdentifier(userInfoRegular, pairwiseClient1)).thenReturn(pairwiseSub12);\r\n    Mockito.when(pairwiseIdentiferService.getIdentifier(userInfoRegular, pairwiseClient2)).thenReturn(pairwiseSub12);\r\n    Mockito.when(pairwiseIdentiferService.getIdentifier(userInfoRegular, pairwiseClient3)).thenReturn(pairwiseSub3);\r\n    Mockito.when(pairwiseIdentiferService.getIdentifier(userInfoRegular, pairwiseClient4)).thenReturn(pairwiseSub4);\r\n    UserInfo user1 = service.getByUsernameAndClientId(regularUsername, pairwiseClientId1);\r\n    UserInfo user2 = service.getByUsernameAndClientId(regularUsername, pairwiseClientId2);\r\n    UserInfo user3 = service.getByUsernameAndClientId(regularUsername, pairwiseClientId3);\r\n    UserInfo user4 = service.getByUsernameAndClientId(regularUsername, pairwiseClientId4);\r\n    assertEquals(pairwiseSub12, user1.getSub());\r\n    assertEquals(pairwiseSub12, user2.getSub());\r\n    assertEquals(pairwiseSub3, user3.getSub());\r\n    assertEquals(pairwiseSub4, user4.getSub());\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.TestDefaultUserInfoService.getByUsernameAndClientId_pairwiseClients",
	"Comment": "clients with pairwise subs should be grouped by the sector uri",
	"Method": "void getByUsernameAndClientId_pairwiseClients(){\r\n    UserInfo userInfo = new DefaultUserInfo();\r\n    userInfo.setPreferredUsername(regularUsername);\r\n    userInfo.setSub(regularSub);\r\n    return userInfo;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.admin.DefaultAdminProvider.setAdmins",
	"Comment": "the default provider sets a comma separated list as the system propertyadmin.authorizedjids",
	"Method": "void setAdmins(List<JID> admins){\r\n    Collection<String> adminList = new ArrayList();\r\n    for (JID admin : admins) {\r\n        adminList.add(admin.toBareJID());\r\n    }\r\n    JiveGlobals.setProperty(\"admin.authorizedJIDs\", StringUtils.collectionToString(adminList));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.filetransfer.DefaultFileTransferManager.isMatchProxyTransfer",
	"Comment": "returns true if the proxy transfer should be matched to an existing file transferin the system.",
	"Method": "boolean isMatchProxyTransfer(){\r\n    return JiveGlobals.getBooleanProperty(\"xmpp.proxy.transfer.required\", true);\r\n}"
}, {
	"Path": "org.jivesoftware.database.bugfix.OF1515.toPubsubData",
	"Comment": "creates appropriate database entries for each pubsub record",
	"Method": "void toPubsubData(List<PubsubRecordData> newRecords){\r\n    Log.info(\"Writing Pubsub entities.\");\r\n    Connection con = null;\r\n    boolean abortTransaction = false;\r\n    try {\r\n        con = DbConnectionManager.getTransactionConnection();\r\n        for (final PubsubRecordData newRecord : newRecords) {\r\n            if (!hasRootNode(con, newRecord.serviceID)) {\r\n                writeRootNode(con, newRecord.serviceID);\r\n            }\r\n            writeNode(con, newRecord);\r\n            writeItem(con, newRecord);\r\n            writeAffiliation(con, newRecord);\r\n        }\r\n    } catch (SQLException e) {\r\n        abortTransaction = true;\r\n    } finally {\r\n        DbConnectionManager.closeTransactionConnection(con, abortTransaction);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.setStrategy",
	"Comment": "sets the implementation to use for serializing and deserializingobjects.",
	"Method": "void setStrategy(ExternalizableUtilStrategy strategy){\r\n    this.strategy = strategy;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.rest.RESTServicePlugin.setCustomAuthFiIterClassName",
	"Comment": "sets the customauthfilterclassname used to grant permission to use the rest services.",
	"Method": "void setCustomAuthFiIterClassName(String customAuthFilterClassName){\r\n    JiveGlobals.setProperty(CUSTOM_AUTH_FILTER_PROPERTY_NAME, customAuthFilterClassName);\r\n    this.customAuthFilterClassName = customAuthFilterClassName;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginManager.removePluginListener",
	"Comment": "deregisters a pluginlistener, which will no longer receive events.when the listener was never added, this method will have no effect.",
	"Method": "void removePluginListener(PluginListener listener){\r\n    pluginListeners.remove(listener);\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.TestDefaultBlacklistedSiteService.isBlacklisted_no",
	"Comment": "tests for finding a site that is not blacklisted in the repository.",
	"Method": "void isBlacklisted_no(){\r\n    Mockito.when(mockRepository.getAll()).thenReturn(blackListedSitesSet);\r\n    assertFalse(service.isBlacklisted(uri3));\r\n    Mockito.verify(mockRepository).getAll();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyListProvider.loadPrivacyList",
	"Comment": "loads the requested privacy list from the database. returns null if a listwith the specified name does not exist.",
	"Method": "PrivacyList loadPrivacyList(String username,String listName){\r\n    if (!databaseContainsPrivacyLists.get()) {\r\n        return null;\r\n    }\r\n    boolean isDefault = false;\r\n    String listValue = null;\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(LOAD_PRIVACY_LIST);\r\n        pstmt.setString(1, username);\r\n        pstmt.setString(2, listName);\r\n        rs = pstmt.executeQuery();\r\n        if (rs.next()) {\r\n            isDefault = rs.getInt(1) == 1;\r\n            listValue = rs.getString(2);\r\n        } else {\r\n            return null;\r\n        }\r\n    } catch (Exception e) {\r\n        Log.error(\"Error loading privacy list: \" + listName + \" of username: \" + username, e);\r\n        return null;\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    PrivacyList privacyList = null;\r\n    SAXReader xmlReader = null;\r\n    try {\r\n        xmlReader = xmlReaders.take();\r\n        Element listElement = xmlReader.read(new StringReader(listValue)).getRootElement();\r\n        privacyList = new PrivacyList(username, listName, isDefault, listElement);\r\n    } catch (Exception e) {\r\n        Log.error(e.getMessage(), e);\r\n    } finally {\r\n        if (xmlReader != null) {\r\n            xmlReaders.add(xmlReader);\r\n        }\r\n    }\r\n    return privacyList;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.setBodyXSLT",
	"Comment": "sets the url of an xsl transformation which can be applied to payloads in orderto generate an appropriate message body element.",
	"Method": "void setBodyXSLT(String bodyXSLT){\r\n    this.bodyXSLT = bodyXSLT;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.setInactivityTimeout",
	"Comment": "sets the time, in seconds, after which this session will be considered inactive and be beterminated.",
	"Method": "void setInactivityTimeout(int inactivityTimeout){\r\n    this.inactivityTimeout = inactivityTimeout;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.launcher.GraphicUtils.centerWindowOnScreen",
	"Comment": "sets the location of the specified window so that it is centered on screen.",
	"Method": "void centerWindowOnScreen(Window window){\r\n    final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    final Dimension size = window.getSize();\r\n    if (size.height > screenSize.height) {\r\n        size.height = screenSize.height;\r\n    }\r\n    if (size.width > screenSize.width) {\r\n        size.width = screenSize.width;\r\n    }\r\n    window.setLocation((screenSize.width - size.width) / 2, (screenSize.height - size.height) / 2);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getPrivateStorage",
	"Comment": "returns the privatestorage registered with this server. theprivatestorage was registered with the server as a module while starting upthe server.",
	"Method": "PrivateStorage getPrivateStorage(){\r\n    return (PrivateStorage) modules.get(PrivateStorage.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalIncomingServerSession.removeValidatedDomain",
	"Comment": "removes the previously validated domain from the list of validated domains. the remoteserver will no longer be able to send packets from the removed domain, subdomain orvirtual host.",
	"Method": "void removeValidatedDomain(String domain){\r\n    validatedDomains.remove(domain);\r\n    SessionManager.getInstance().unregisterIncomingServerSession(domain, this);\r\n}"
}, {
	"Path": "org.jivesoftware.util.CertificateManager.parsePrivateKey",
	"Comment": "parses a privatekey instance from a pem representation.when the provided key is encrypted, the provided pass phrase is applied.",
	"Method": "PrivateKey parsePrivateKey(String pemRepresentation,String passPhrase,PrivateKey parsePrivateKey,InputStream pemRepresentation,String passPhrase){\r\n    if (passPhrase == null) {\r\n        passPhrase = \"\";\r\n    }\r\n    try (Reader reader = new InputStreamReader(pemRepresentation);\r\n        PEMParser pemParser = new PEMParser(reader)) {\r\n        final Object object = pemParser.readObject();\r\n        final JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\r\n        final KeyPair kp;\r\n        if (object instanceof PEMEncryptedKeyPair) {\r\n            final PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(passPhrase.toCharArray());\r\n            kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\r\n        } else if (object instanceof PKCS8EncryptedPrivateKeyInfo) {\r\n            try {\r\n                final PKCS8EncryptedPrivateKeyInfo encryptedInfo = (PKCS8EncryptedPrivateKeyInfo) object;\r\n                final InputDecryptorProvider provider = new JceOpenSSLPKCS8DecryptorProviderBuilder().build(passPhrase.toCharArray());\r\n                final PrivateKeyInfo privateKeyInfo = encryptedInfo.decryptPrivateKeyInfo(provider);\r\n                return converter.getPrivateKey(privateKeyInfo);\r\n            } catch (PKCSException | OperatorCreationException e) {\r\n                throw new IOException(\"Unable to decrypt private key.\", e);\r\n            }\r\n        } else if (object instanceof PrivateKeyInfo) {\r\n            return converter.getPrivateKey((PrivateKeyInfo) object);\r\n        } else {\r\n            kp = converter.getKeyPair((PEMKeyPair) object);\r\n        }\r\n        return kp.getPrivate();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.webdav.WebDAVLiteServlet.isAuthorized",
	"Comment": "verifies that the authenticated user is a member of a conference service and room, or elsethey are not entitled to view any of the files in the room.",
	"Method": "Boolean isAuthorized(HttpServletRequest request,HttpServletResponse response,String service,String room){\r\n    String auth = request.getHeader(\"Authorization\");\r\n    try {\r\n        if (auth == null || !request.getAuthType().equals(HttpServletRequest.BASIC_AUTH)) {\r\n            throw new Exception(\"No authorization or improper authorization provided.\");\r\n        }\r\n        auth = auth.substring(auth.indexOf(\" \"));\r\n        String decoded = new String(Base64.decode(auth));\r\n        int i = decoded.indexOf(\":\");\r\n        String username = decoded.substring(0, i);\r\n        if (!username.contains(\"@\")) {\r\n            throw new Exception(\"Not a valid JID.\");\r\n        }\r\n        final JID bareJID = new JID(username).asBareJID();\r\n        XMPPServer.getInstance().getMultiUserChatManager().getMultiUserChatService(service).getChatRoom(room).getOccupantsByBareJID(bareJID);\r\n        return true;\r\n    } catch (Exception e) {\r\n        response.setHeader(\"WWW-Authenticate\", \"Basic realm=\\\"Openfire WebDAV\\\"\");\r\n        response.sendError(HttpServletResponse.SC_FORBIDDEN);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.ElementUtil.includesProperty",
	"Comment": "returns true if the specified property is included in the xml hierarchy. a property couldhave a value associated or not. if the property has an associated value then",
	"Method": "boolean includesProperty(Element element,String name){\r\n    String[] propName = parsePropertyName(name);\r\n    String lastName = propName[propName.length - 1];\r\n    String attName = null;\r\n    int attributeIndex = lastName.indexOf(':');\r\n    if (attributeIndex >= 0) {\r\n        propName[propName.length - 1] = lastName.substring(0, attributeIndex);\r\n        attName = lastName.substring(attributeIndex + 1);\r\n    }\r\n    int i = propName[0].equals(element.getName()) ? 1 : 0;\r\n    for (; i < propName.length; i++) {\r\n        element = element.element(propName[i]);\r\n        if (element == null) {\r\n            break;\r\n        }\r\n    }\r\n    if (element != null) {\r\n        if (attName == null) {\r\n            return true;\r\n        } else {\r\n            return element.attribute(attName) != null;\r\n        }\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getSessionManager",
	"Comment": "returns the sessionmanager registered with this server. thesessionmanager was registered with the server as a module while starting upthe server.",
	"Method": "SessionManager getSessionManager(){\r\n    return (SessionManager) modules.get(SessionManager.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.Group.getProperties",
	"Comment": "returns all extended properties of the group. groups have an arbitrarynumber of extended properties. the returned collection can be modifiedto add new properties or remove existing ones.",
	"Method": "PersistableMap<String, String> getProperties(){\r\n    synchronized (this) {\r\n        if (properties == null) {\r\n            properties = provider.loadProperties(this);\r\n        }\r\n    }\r\n    return properties;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheSizes.sizeOfObject",
	"Comment": "returns the size in bytes of a basic object. this method should onlybe used for actual object objects and not classes that extend object.",
	"Method": "int sizeOfObject(){\r\n    return 4;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.UpdateManager.buildPluginsUpdateList",
	"Comment": "recreate the list of plugins that need to be updated based on the list ofavailable plugins at igniterealtime.org.",
	"Method": "void buildPluginsUpdateList(){\r\n    pluginUpdates = new ArrayList();\r\n    XMPPServer server = XMPPServer.getInstance();\r\n    Version currentServerVersion = XMPPServer.getInstance().getServerInfo().getVersion();\r\n    for (final PluginMetadata plugin : server.getPluginManager().getMetadataExtractedPlugins().values()) {\r\n        final AvailablePlugin latestPlugin = availablePlugins.get(plugin.getName());\r\n        if (latestPlugin == null) {\r\n            continue;\r\n        }\r\n        final Version latestPluginVersion = latestPlugin.getVersion();\r\n        if (latestPluginVersion.isNewerThan(plugin.getVersion())) {\r\n            final Version pluginMinServerVersion = latestPlugin.getMinServerVersion();\r\n            if (pluginMinServerVersion != null && pluginMinServerVersion.isNewerThan(currentServerVersion)) {\r\n                continue;\r\n            }\r\n            final Version pluginPriorToServerVersion = latestPlugin.getPriorToServerVersion();\r\n            if (pluginPriorToServerVersion != null && !pluginPriorToServerVersion.isNewerThan(currentServerVersion)) {\r\n                continue;\r\n            }\r\n            final Update update = new Update(plugin.getName(), latestPlugin.getVersion().getVersionString(), latestPlugin.getChangelog().toExternalForm(), latestPlugin.getDownloadURL().toExternalForm());\r\n            pluginUpdates.add(update);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.ServerSocketReader.processMessage",
	"Comment": "processes the packet in another thread if the packet has not been rejected.",
	"Method": "void processMessage(Message packet){\r\n    try {\r\n        packetReceived(packet);\r\n        try {\r\n            ServerSocketReader.super.processMessage(packet);\r\n        } catch (UnauthorizedException e) {\r\n            Log.error(\"Error processing packet\", e);\r\n        }\r\n    } catch (PacketRejectedException e) {\r\n        Log.debug(\"Message rejected: \" + packet.toXML(), e);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.User.getPropertyValue",
	"Comment": "returns the value of the specified property for the given username. this method isan optimization to avoid loading a user to get a specific property.",
	"Method": "String getPropertyValue(String username,String propertyName){\r\n    return UserManager.getUserPropertyProvider().loadProperty(username, propertyName);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.isPreAuthenticatedSession",
	"Comment": "returns true if the specified address belongs to a preauthenticated session. preauthenticatedsessions are only available to the local cluster node when running inside of a cluster.",
	"Method": "boolean isPreAuthenticatedSession(JID address){\r\n    return serverName.equals(address.getDomain()) && localSessionManager.getPreAuthenticatedSessions().containsKey(address.getResource());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginCacheRegistry.registerCache",
	"Comment": "registers cache configuration data for a give cache and plugin.",
	"Method": "void registerCache(String pluginName,CacheInfo info){\r\n    extraCacheMappings.put(info.getCacheName(), info);\r\n    List<CacheInfo> caches = pluginCaches.get(pluginName);\r\n    if (caches == null) {\r\n        caches = new ArrayList();\r\n        pluginCaches.put(pluginName, caches);\r\n    }\r\n    caches.add(info);\r\n    CacheFactory.setCacheTypeProperty(info.getCacheName(), info.getType().getName());\r\n    CacheFactory.setMaxSizeProperty(info.getCacheName(), getMaxSizeFromProperty(info));\r\n    CacheFactory.setMaxLifetimeProperty(info.getCacheName(), getMaxLifetimeFromProperty(info));\r\n    CacheFactory.setMinCacheSize(info.getCacheName(), getMinSizeFromProperty(info));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.server.OutgoingServerSocketReader.getElement",
	"Comment": "retrieves and removes the first received element that was stored in the queue, waitingif necessary up to the specified wait time if no elements are present on this queue.",
	"Method": "Element getElement(long timeout,TimeUnit unit){\r\n    return elements.poll(timeout, unit);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.AvailablePlugin.getDownloadURL",
	"Comment": "url from where the latest version of the plugin can be downloaded.",
	"Method": "URL getDownloadURL(){\r\n    return downloadURL;\r\n}"
}, {
	"Path": "org.jivesoftware.util.SetCharacterEncodingFilter.doFilter",
	"Comment": "sets the character encoding to be used for any content passing out of this filter.",
	"Method": "void doFilter(ServletRequest request,ServletResponse response,FilterChain chain){\r\n    request.setCharacterEncoding(\"UTF-8\");\r\n    response.setContentType(\"text/html; charset=\" + \"UTF-8\");\r\n    chain.doFilter(request, response);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MUCPersistenceManager.loadRoomsFromDB",
	"Comment": "loads all the rooms that had occupants after a given date from the database. this querywill be executed only when the service is starting up.",
	"Method": "Collection<LocalMUCRoom> loadRoomsFromDB(MultiUserChatService chatserver,Date emptyDate,PacketRouter packetRouter){\r\n    Long serviceID = XMPPServer.getInstance().getMultiUserChatManager().getMultiUserChatServiceID(chatserver.getServiceName());\r\n    final Map<Long, LocalMUCRoom> rooms;\r\n    try {\r\n        rooms = loadRooms(serviceID, emptyDate, chatserver, packetRouter);\r\n        loadHistory(serviceID, rooms);\r\n        loadAffiliations(serviceID, rooms);\r\n        loadMembers(serviceID, rooms);\r\n    } catch (SQLException sqle) {\r\n        Log.error(\"A database error prevented MUC rooms to be loaded from the database.\", sqle);\r\n        return Collections.emptyList();\r\n    }\r\n    for (final MUCRoom room : rooms.values()) {\r\n        room.setSavedToDB(true);\r\n        if (room.getEmptyDate() == null) {\r\n            room.setEmptyDate(new Date());\r\n        }\r\n    }\r\n    return rooms.values();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.setDeliverPayloads",
	"Comment": "sets if payloads are going to be delivered with event notifications.",
	"Method": "void setDeliverPayloads(boolean deliverPayloads){\r\n    this.deliverPayloads = deliverPayloads;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.MulticastRouter.sendToRemoteServer",
	"Comment": "actually sends pending packets of the specified domain using the discovered multicastservice address. if remote server supports multicast service then a copy of theorignal will be sent to the remote server. however, if no multicast service was foundthen the local server sends a copy of the original stanza to each address.",
	"Method": "void sendToRemoteServer(String domain,String multicastService){\r\n    Collection<Packet> packets = null;\r\n    synchronized (domain.intern()) {\r\n        packets = remotePackets.remove(domain);\r\n    }\r\n    if (multicastService != null && multicastService.trim().length() > 0) {\r\n        for (Packet packet : packets) {\r\n            Element addresses = getAddresses(packet);\r\n            for (Iterator it = addresses.elementIterator(\"address\"); it.hasNext(); ) {\r\n                Element address = (Element) it.next();\r\n                String jid = address.attributeValue(\"jid\");\r\n                if (!jid.contains(\"@\" + domain)) {\r\n                    if (Type.bcc.toString().equals(address.attributeValue(\"type\"))) {\r\n                        it.remove();\r\n                    } else {\r\n                        address.addAttribute(\"delivered\", \"true\");\r\n                    }\r\n                }\r\n            }\r\n            packet.setTo(multicastService);\r\n            packetRouter.route(packet);\r\n        }\r\n    } else {\r\n        for (Packet packet : packets) {\r\n            Element addresses = getAddresses(packet);\r\n            List<String> targets = new ArrayList();\r\n            for (Iterator it = addresses.elementIterator(\"address\"); it.hasNext(); ) {\r\n                Element address = (Element) it.next();\r\n                String jid = address.attributeValue(\"jid\");\r\n                if (jid.contains(\"@\" + domain)) {\r\n                    targets.add(jid);\r\n                }\r\n                address.addAttribute(\"delivered\", \"true\");\r\n                if (Type.bcc.toString().equals(address.attributeValue(\"type\"))) {\r\n                    it.remove();\r\n                }\r\n            }\r\n            for (String jid : targets) {\r\n                packet.setTo(jid);\r\n                packetRouter.route(packet);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.setStartTlsEnabled",
	"Comment": "sets whether the connection to the ldap server should be made via starttls or not.",
	"Method": "void setStartTlsEnabled(boolean startTlsEnabled){\r\n    this.startTlsEnabled = startTlsEnabled;\r\n    properties.put(\"ldap.startTlsEnabled\", Boolean.toString(startTlsEnabled));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MUCServiceProperties.getPropertyNames",
	"Comment": "returns all property names as a collection of string values.",
	"Method": "Collection<String> getPropertyNames(){\r\n    return properties.keySet();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getLockOutManager",
	"Comment": "returns the lockoutmanager registered with this server.thelockoutmanager was registered with the server as a module while starting upthe server.",
	"Method": "LockOutManager getLockOutManager(){\r\n    return LockOutManager.getInstance();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyList.getName",
	"Comment": "returns the name that uniquely identifies this list among the users lists.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "org.jivesoftware.util.EmailService.getUsername",
	"Comment": "returns the username used to connect to the smtp server. if the usernameis null, no username will be used when connecting to the server.",
	"Method": "String getUsername(){\r\n    return username;\r\n}"
}, {
	"Path": "org.jivesoftware.util.WebManager.isSetupMode",
	"Comment": "returns true if the openfire container is in setup mode, false otherwise.",
	"Method": "boolean isSetupMode(){\r\n    return getXMPPServer().isSetupMode();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterItem.setID",
	"Comment": "sets the roster id associated with this particular roster item. a value of zeromeans that the roster item is not being persisted in the backend store.databases can use the roster id as the key in locating roster items.",
	"Method": "void setID(long rosterID){\r\n    this.rosterID = rosterID;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.client.OIDCAuthenticationFilter.createNonce",
	"Comment": "create a cryptographically random nonce and store it in the session",
	"Method": "String createNonce(HttpSession session){\r\n    String nonce = new BigInteger(50, new SecureRandom()).toString(16);\r\n    session.setAttribute(NONCE_SESSION_VARIABLE, nonce);\r\n    return nonce;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginServlet.registerServlet",
	"Comment": "registers a live servlet for a plugin programmatically, does notinitialize the servlet.",
	"Method": "String registerServlet(PluginManager pluginManager,Plugin plugin,GenericServlet servlet,String relativeUrl){\r\n    String pluginName = pluginManager.getPluginPath(plugin).getFileName().toString();\r\n    PluginServlet.pluginManager = pluginManager;\r\n    if (servlet == null) {\r\n        throw new ServletException(\"Servlet is missing\");\r\n    }\r\n    String pluginServletUrl = pluginName + relativeUrl;\r\n    servlets.put((pluginName + relativeUrl).toLowerCase(), servlet);\r\n    return PLUGINS_WEBROOT + pluginServletUrl;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginServlet.handleDevJSP",
	"Comment": "handles a request for a jsp page in development mode. if development mode isnot enabled, this method returns false so that normal jsp handling can be performed.if development mode is enabled, this method tries to locate the jsp, compileit using jspc, and then return the output.",
	"Method": "boolean handleDevJSP(String pathInfo,HttpServletRequest request,HttpServletResponse response){\r\n    String jspURL = pathInfo.substring(1);\r\n    int fileSeperator = jspURL.indexOf(\"/\");\r\n    if (fileSeperator != -1) {\r\n        String pluginName = jspURL.substring(0, fileSeperator);\r\n        Plugin plugin = pluginManager.getPlugin(pluginName);\r\n        PluginDevEnvironment environment = pluginManager.getDevEnvironment(plugin);\r\n        if (environment == null) {\r\n            return false;\r\n        }\r\n        File webDir = environment.getWebRoot();\r\n        if (webDir == null || !webDir.exists()) {\r\n            return false;\r\n        }\r\n        File pluginDirectory = pluginManager.getPluginPath(plugin).toFile();\r\n        File compilationDir = new File(pluginDirectory, \"classes\");\r\n        final boolean dirMade = compilationDir.mkdirs();\r\n        if (dirMade) {\r\n            Log.info(\"Created directory for compiled JSPs: {}\", compilationDir);\r\n        }\r\n        String jsp = jspURL.substring(fileSeperator + 1);\r\n        int indexOfLastSlash = jsp.lastIndexOf(\"/\");\r\n        String relativeDir = \"\";\r\n        if (indexOfLastSlash != -1) {\r\n            relativeDir = jsp.substring(0, indexOfLastSlash);\r\n            relativeDir = relativeDir.replaceAll(\"//\", \".\") + '.';\r\n        }\r\n        File jspFile = new File(webDir, jsp);\r\n        String filename = jspFile.getName();\r\n        int indexOfPeriod = filename.indexOf(\".\");\r\n        if (indexOfPeriod != -1) {\r\n            filename = \"dev\" + StringUtils.randomString(4);\r\n        }\r\n        JspC jspc = new JspC();\r\n        if (!jspFile.exists()) {\r\n            return false;\r\n        }\r\n        try {\r\n            jspc.setJspFiles(jspFile.getCanonicalPath());\r\n        } catch (IOException e) {\r\n            Log.error(e.getMessage(), e);\r\n        }\r\n        jspc.setOutputDir(compilationDir.getAbsolutePath());\r\n        jspc.setClassName(filename);\r\n        jspc.setCompile(true);\r\n        jspc.setClassPath(getClasspathForPlugin(plugin));\r\n        jspc.execute();\r\n        try {\r\n            Object servletInstance = pluginManager.loadClass(plugin, \"org.apache.jsp.\" + relativeDir + filename).newInstance();\r\n            HttpServlet servlet = (HttpServlet) servletInstance;\r\n            servlet.init(servletConfig);\r\n            servlet.service(request, response);\r\n            return true;\r\n        } catch (Exception e) {\r\n            Log.error(e.getMessage(), e);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.HistoryStrategy.getReverseMessageHistory",
	"Comment": "obtain the current history to be iterated in reverse mode. this means that the returned list iterator will be positioned at the end of the history so senders of this message must traverse the list in reverse mode.",
	"Method": "ListIterator<Message> getReverseMessageHistory(){\r\n    LinkedList<Message> list = new LinkedList(history);\r\n    Collections.sort(list, new MessageComparator());\r\n    return list.listIterator(list.size());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.VirtualConnection.close",
	"Comment": "closes the session, the virtual connection and notifies listeners that the connectionhas been closed.",
	"Method": "void close(){\r\n    if (state.compareAndSet(State.OPEN, State.CLOSED)) {\r\n        if (session != null) {\r\n            session.setStatus(Session.STATUS_CLOSED);\r\n        }\r\n        notifyCloseListeners();\r\n        try {\r\n            closeVirtualConnection();\r\n        } catch (Exception e) {\r\n            Log.error(LocaleUtils.getLocalizedString(\"admin.error.close\") + \"\\n\" + toString(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.readLongArray",
	"Comment": "reads an array of long values. this method will return null ifthe array written to the stream was null.",
	"Method": "long[] readLongArray(DataInput in){\r\n    return strategy.readLongArray(in);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.LocalMUCRoom.setLockedDate",
	"Comment": "sets the date when the room was locked. initially when the room is created it is locked sothe locked date is the creation date of the room. afterwards, the room may be manuallylocked and unlocked so the locked date may be in these cases different than the creationdate. a date with time 0 means that the the room is unlocked.",
	"Method": "void setLockedDate(Date lockedTime){\r\n    this.lockedTime = lockedTime.getTime();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.addContact",
	"Comment": "adds a new user as a candidate to answer questions about the node.",
	"Method": "void addContact(JID user){\r\n    contacts.add(user);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.getAvailableStreamFeaturesElements",
	"Comment": "returns the stream features which are available for this session.",
	"Method": "Collection<Element> getAvailableStreamFeaturesElements(){\r\n    List<Element> elements = new ArrayList();\r\n    if (getAuthToken() == null) {\r\n        Element sasl = SASLAuthentication.getSASLMechanismsElement(this);\r\n        if (sasl != null) {\r\n            elements.add(sasl);\r\n        }\r\n    }\r\n    if (XMPPServer.getInstance().getIQRegisterHandler().isInbandRegEnabled()) {\r\n        elements.add(DocumentHelper.createElement(new QName(\"register\", new Namespace(\"\", \"http://jabber.org/features/iq-register\"))));\r\n    }\r\n    Element bind = DocumentHelper.createElement(new QName(\"bind\", new Namespace(\"\", \"urn:ietf:params:xml:ns:xmpp-bind\")));\r\n    elements.add(bind);\r\n    Element session = DocumentHelper.createElement(new QName(\"session\", new Namespace(\"\", \"urn:ietf:params:xml:ns:xmpp-session\")));\r\n    session.addElement(\"optional\");\r\n    elements.add(session);\r\n    return elements;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalComponentSession.authenticate",
	"Comment": "authenticate the external component using a digest method. the digest includes thestream id and the secret key of the main domain of the external component. a componentneeds to authenticate just once but it may bind several domains.",
	"Method": "boolean authenticate(String digest){\r\n    String secretKey = ExternalComponentManager.getSecretForComponent(defaultSubdomain);\r\n    String anticipatedDigest = AuthFactory.createDigest(getStreamID().getID(), secretKey);\r\n    if (!anticipatedDigest.equalsIgnoreCase(digest)) {\r\n        Log.debug(\"LocalComponentSession: [ExComp] Incorrect handshake for component with domain: \" + defaultSubdomain);\r\n        conn.deliverRawText(new StreamError(StreamError.Condition.not_authorized).toXML());\r\n        conn.close();\r\n        return false;\r\n    } else {\r\n        setStatus(STATUS_AUTHENTICATED);\r\n        conn.deliverRawText(\"<handshake><\/handshake>\");\r\n        ExternalComponent component = getExternalComponent();\r\n        try {\r\n            InternalComponentManager.getInstance().addComponent(defaultSubdomain, component);\r\n            Log.debug(\"LocalComponentSession: [ExComp] External component was registered SUCCESSFULLY with domain: \" + defaultSubdomain);\r\n            return true;\r\n        } catch (ComponentException e) {\r\n            Log.debug(\"LocalComponentSession: [ExComp] Another component is already using domain: \" + defaultSubdomain);\r\n            conn.deliverRawText(new StreamError(StreamError.Condition.conflict).toXML());\r\n            conn.close();\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.streammanagement.StreamManager.enable",
	"Comment": "attempts to enable stream management for the entity identified by the provided jid.",
	"Method": "void enable(String namespace,boolean resume){\r\n    boolean offerResume = allowResume();\r\n    if (session.getStatus() != Session.STATUS_AUTHENTICATED) {\r\n        this.namespace = namespace;\r\n        sendUnexpectedError();\r\n        return;\r\n    }\r\n    String smId = null;\r\n    synchronized (this) {\r\n        if (isEnabled()) {\r\n            sendUnexpectedError();\r\n            return;\r\n        }\r\n        this.namespace = namespace;\r\n        this.resume = resume && offerResume;\r\n        if (this.resume) {\r\n            smId = StringUtils.encodeBase64(session.getAddress().getResource() + \"\\0\" + session.getStreamID().getID());\r\n        }\r\n    }\r\n    Element enabled = new DOMElement(QName.get(\"enabled\", namespace));\r\n    if (this.resume) {\r\n        enabled.addAttribute(\"resume\", \"true\");\r\n        enabled.addAttribute(\"id\", smId);\r\n    }\r\n    session.deliverRawText(enabled.asXML());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.security.DefaultSecurityAuditProvider.getEvents",
	"Comment": "the default provider retrieves events from a ofsecurityauditlog table in the database.",
	"Method": "List<SecurityAuditEvent> getEvents(String username,Integer skipEvents,Integer numEvents,Date startTime,Date endTime){\r\n    List<SecurityAuditEvent> events = new ArrayList();\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    String sql = GET_EVENTS;\r\n    boolean addedOne = false;\r\n    if (username != null) {\r\n        sql += \" WHERE username = ?\";\r\n        addedOne = true;\r\n    }\r\n    if (startTime != null) {\r\n        if (!addedOne) {\r\n            sql += \" WHERE\";\r\n        } else {\r\n            sql += \" AND\";\r\n        }\r\n        sql += \" entryStamp >= ?\";\r\n        addedOne = true;\r\n    }\r\n    if (endTime != null) {\r\n        if (!addedOne) {\r\n            sql += \" WHERE\";\r\n        } else {\r\n            sql += \" AND\";\r\n        }\r\n        sql += \" entryStamp <= ?\";\r\n    }\r\n    sql += \" ORDER BY entryStamp DESC\";\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = DbConnectionManager.createScrollablePreparedStatement(con, sql);\r\n        int i = 1;\r\n        if (username != null) {\r\n            pstmt.setString(i, username);\r\n            i++;\r\n        }\r\n        if (startTime != null) {\r\n            pstmt.setLong(i, startTime.getTime());\r\n            i++;\r\n        }\r\n        if (endTime != null) {\r\n            pstmt.setLong(i, endTime.getTime());\r\n        }\r\n        rs = pstmt.executeQuery();\r\n        if (skipEvents != null) {\r\n            DbConnectionManager.scrollResultSet(rs, skipEvents);\r\n        }\r\n        if (numEvents != null) {\r\n            DbConnectionManager.setFetchSize(rs, numEvents);\r\n        }\r\n        int count = 0;\r\n        while (rs.next() && count < numEvents) {\r\n            SecurityAuditEvent event = new SecurityAuditEvent();\r\n            event.setMsgID(rs.getLong(1));\r\n            event.setUsername(rs.getString(2));\r\n            event.setEventStamp(new Date(rs.getLong(3)));\r\n            event.setSummary(rs.getString(4));\r\n            event.setNode(rs.getString(5));\r\n            event.setDetails(rs.getString(6));\r\n            events.add(event);\r\n            count++;\r\n        }\r\n    } catch (SQLException e) {\r\n        Log.error(e.getMessage(), e);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    return events;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.interceptor.PacketCopier.addSubscriber",
	"Comment": "creates new subscription for the specified component with the specified settings.",
	"Method": "void addSubscriber(JID componentJID,boolean iqEnabled,boolean messageEnabled,boolean presenceEnabled,boolean incoming,boolean processed){\r\n    subscribers.put(componentJID.toString(), new Subscription(iqEnabled, messageEnabled, presenceEnabled, incoming, processed));\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.MITREidDataService_1_1.readSystemScopes",
	"Comment": "read the list of system scopes from the reader and insert them into the\tscope repository.",
	"Method": "void readSystemScopes(JsonReader reader){\r\n    reader.beginArray();\r\n    while (reader.hasNext()) {\r\n        SystemScope scope = new SystemScope();\r\n        reader.beginObject();\r\n        while (reader.hasNext()) {\r\n            switch(reader.peek()) {\r\n                case END_OBJECT:\r\n                    continue;\r\n                case NAME:\r\n                    String name = reader.nextName();\r\n                    if (reader.peek() == JsonToken.NULL) {\r\n                        reader.skipValue();\r\n                    } else if (name.equals(\"value\")) {\r\n                        scope.setValue(reader.nextString());\r\n                    } else if (name.equals(\"description\")) {\r\n                        scope.setDescription(reader.nextString());\r\n                    } else if (name.equals(\"allowDynReg\")) {\r\n                        scope.setRestricted(!reader.nextBoolean());\r\n                    } else if (name.equals(\"defaultScope\")) {\r\n                        scope.setDefaultScope(reader.nextBoolean());\r\n                    } else if (name.equals(\"structured\")) {\r\n                        logger.warn(\"Found a structured scope, ignoring structure\");\r\n                    } else if (name.equals(\"structuredParameter\")) {\r\n                        logger.warn(\"Found a structured scope, ignoring structure\");\r\n                    } else if (name.equals(\"icon\")) {\r\n                        scope.setIcon(reader.nextString());\r\n                    } else {\r\n                        logger.debug(\"found unexpected entry\");\r\n                        reader.skipValue();\r\n                    }\r\n                    break;\r\n                default:\r\n                    logger.debug(\"Found unexpected entry\");\r\n                    reader.skipValue();\r\n                    continue;\r\n            }\r\n        }\r\n        reader.endObject();\r\n        sysScopeRepository.save(scope);\r\n    }\r\n    reader.endArray();\r\n    logger.info(\"Done reading system scopes\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.createClientSession",
	"Comment": "creates a new clientsession. the new client session will have a newly createdstream id.",
	"Method": "LocalClientSession createClientSession(Connection conn,Locale language,LocalClientSession createClientSession,Connection conn,StreamID id,LocalClientSession createClientSession,Connection conn,StreamID id,Locale language){\r\n    if (serverName == null) {\r\n        throw new IllegalStateException(\"Server not initialized\");\r\n    }\r\n    LocalClientSession session = new LocalClientSession(serverName, conn, id, language);\r\n    conn.init(session);\r\n    conn.registerCloseListener(clientSessionListener, session);\r\n    localSessionManager.getPreAuthenticatedSessions().put(session.getAddress().getResource(), session);\r\n    connectionsCounter.incrementAndGet();\r\n    return session;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.handler.IQBlockingHandler.sendPresence",
	"Comment": "sends current presence information of the local user to the a collection of jids, if appropriate.",
	"Method": "void sendPresence(User user,Set<JID> recipients){\r\n    if (recipients.isEmpty()) {\r\n        return;\r\n    }\r\n    final PresenceManager presenceManager = XMPPServer.getInstance().getPresenceManager();\r\n    final Presence presence = presenceManager.getPresence(user);\r\n    if (presence == null) {\r\n        return;\r\n    }\r\n    for (final JID recipient : recipients) {\r\n        try {\r\n            if (presenceManager.canProbePresence(recipient, user.getUsername())) {\r\n                presenceManager.probePresence(recipient.asBareJID(), XMPPServer.getInstance().createJID(user.getUsername(), null));\r\n            }\r\n        } catch (UserNotFoundException e) {\r\n            Log.error(\"Unable to send presence information of user '{}' to unblocked entity '{}' as local user is not found.\", user.getUsername(), recipient);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sasl.SaslServerPlainImpl.unwrap",
	"Comment": "unwraps a byte array received from the client. plain supports no security layer.",
	"Method": "byte[] unwrap(byte[] incoming,int offset,int len){\r\n    if (completed) {\r\n        throw new IllegalStateException(\"PLAIN does not support integrity or privacy\");\r\n    } else {\r\n        throw new IllegalStateException(\"PLAIN authentication not completed\");\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.setFollowReferralsEnabled",
	"Comment": "sets whether ldap referrals should be automatically followed.",
	"Method": "void setFollowReferralsEnabled(boolean followReferrals){\r\n    this.followReferrals = followReferrals;\r\n    properties.put(\"ldap.autoFollowReferrals\", String.valueOf(followReferrals));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.rest.RESTServicePlugin.setSecret",
	"Comment": "sets the secret key that grants permission to use the userservice.",
	"Method": "void setSecret(String secret){\r\n    JiveGlobals.setProperty(\"plugin.restapi.secret\", secret);\r\n    this.secret = secret;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.UserManager.isRegisteredUser",
	"Comment": "returns true if the specified local username belongs to a registered local user.",
	"Method": "boolean isRegisteredUser(String username,boolean isRegisteredUser,JID user){\r\n    XMPPServer server = XMPPServer.getInstance();\r\n    if (server.isLocal(user)) {\r\n        try {\r\n            getUser(user.getNode());\r\n            return true;\r\n        } catch (UserNotFoundException e) {\r\n            return false;\r\n        }\r\n    } else {\r\n        Boolean isRegistered = remoteUsersCache.get(user.toString());\r\n        if (isRegistered == null) {\r\n            isRegistered = remoteUsersCache.get(user.toBareJID());\r\n            if (isRegistered == null) {\r\n                IQ iq = new IQ(IQ.Type.get);\r\n                iq.setFrom(server.getServerInfo().getXMPPDomain());\r\n                iq.setTo(user.toBareJID());\r\n                iq.setChildElement(\"query\", \"http://jabber.org/protocol/disco#info\");\r\n                server.getIQRouter().addIQResultListener(iq.getID(), this);\r\n                synchronized ((user.toBareJID() + MUTEX_SUFFIX).intern()) {\r\n                    server.getIQRouter().route(iq);\r\n                    try {\r\n                        user.toBareJID().intern().wait(JiveGlobals.getLongProperty(\"usermanager.remote-disco-info-timeout-seconds\", 60) * JiveConstants.SECOND);\r\n                    } catch (InterruptedException e) {\r\n                    }\r\n                }\r\n                isRegistered = remoteUsersCache.get(user.toBareJID());\r\n                if (isRegistered == null) {\r\n                    isRegistered = Boolean.FALSE;\r\n                    remoteUsersCache.put(user.toString(), isRegistered);\r\n                }\r\n            }\r\n        }\r\n        return isRegistered;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginManager.addPluginManagerListener",
	"Comment": "registers a pluginmanagerlistener, which will now start receiving events regarding plugin management.",
	"Method": "void addPluginManagerListener(PluginManagerListener listener){\r\n    pluginManagerListeners.add(listener);\r\n    if (isExecuted()) {\r\n        firePluginsMonitored(listener);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.disco.IQDiscoInfoHandler.removeServerFeature",
	"Comment": "removes a feature from the information returned whenever a disco for information ismade against the server.",
	"Method": "void removeServerFeature(String namespace){\r\n    if (localServerFeatures.remove(namespace)) {\r\n        Lock lock = CacheFactory.getLock(namespace, serverFeatures);\r\n        try {\r\n            lock.lock();\r\n            HashSet<NodeID> nodeIDs = serverFeatures.get(namespace);\r\n            if (nodeIDs != null) {\r\n                nodeIDs.remove(XMPPServer.getInstance().getNodeID());\r\n                if (nodeIDs.isEmpty()) {\r\n                    serverFeatures.remove(namespace);\r\n                } else {\r\n                    serverFeatures.put(namespace, nodeIDs);\r\n                }\r\n            }\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MultiUserChatServiceImpl.getIncomingMessageCount",
	"Comment": "returns the total number of incoming messages since last reset.",
	"Method": "long getIncomingMessageCount(boolean resetAfter){\r\n    if (resetAfter) {\r\n        return inMessages.getAndSet(0);\r\n    } else {\r\n        return inMessages.get();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterEventDispatcher.contactDeleted",
	"Comment": "notifies the listeners that a contact has been deleted from a roster.",
	"Method": "void contactDeleted(Roster roster,RosterItem item){\r\n    if (!listeners.isEmpty()) {\r\n        for (RosterEventListener listener : listeners) {\r\n            listener.contactDeleted(roster, item);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterManager.userCreated",
	"Comment": "a new user has been created so members of public shared groups need to havetheir rosters updated. members of public shared groups need to have a rosteritem with subscription from for the new user since the new user can see them.",
	"Method": "void userCreated(User newUser,Map<String, Object> params){\r\n    JID newUserJID = server.createJID(newUser.getUsername(), null);\r\n    for (Group group : getPublicSharedGroups()) {\r\n        Collection<JID> users = new HashSet(group.getMembers());\r\n        users.addAll(group.getAdmins());\r\n        for (JID userToUpdate : users) {\r\n            Roster roster = null;\r\n            if (server.isLocal(userToUpdate)) {\r\n                try {\r\n                    roster = getRoster(userToUpdate.getNode());\r\n                } catch (UserNotFoundException e) {\r\n                    continue;\r\n                }\r\n            }\r\n            roster.addSharedUser(group, newUserJID);\r\n            if (!server.isLocal(userToUpdate)) {\r\n                sendSubscribeRequest(newUserJID, userToUpdate, true);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.mediaproxy.MediaProxy.setMinPort",
	"Comment": "sets the minimum port value to listen from incoming packets.",
	"Method": "void setMinPort(int minPort){\r\n    this.minPort = minPort;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.isKeywordMatched",
	"Comment": "returns true if the published item matches the keyword filter specified inthe subscription. if no keyword was specified then answer true.",
	"Method": "boolean isKeywordMatched(PublishedItem publishedItem){\r\n    if (keyword != null && keyword.length() > 0 && !publishedItem.containsKeyword(keyword)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.getInstance",
	"Comment": "provides singleton access to an instance of the ldapmanager class.",
	"Method": "LdapManager getInstance(){\r\n    return instance;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.auth.DefaultAuthorizationMapping.map",
	"Comment": "returns true if the principal is explicity authorized to the jid",
	"Method": "String map(String principal){\r\n    if (principal.contains(\"@\")) {\r\n        String realm = principal.substring(principal.lastIndexOf('@') + 1);\r\n        String username = principal.substring(0, principal.lastIndexOf('@'));\r\n        if (realm.length() > 0) {\r\n            if (realm.equals(JiveGlobals.getProperty(\"xmpp.domain\"))) {\r\n                Log.debug(\"DefaultAuthorizationMapping: realm = xmpp.domain\");\r\n                return username;\r\n            } else if (realm.equals(JiveGlobals.getProperty(\"sasl.realm\"))) {\r\n                Log.debug(\"DefaultAuthorizationMapping: ream = sasl.realm\");\r\n                return username;\r\n            } else {\r\n                for (String approvedRealm : approvedRealms) {\r\n                    if (realm.equals(approvedRealm)) {\r\n                        Log.debug(\"DefaultAuthorizationMapping: realm (\" + realm + \") = \" + approvedRealm + \" which is approved\");\r\n                        return username;\r\n                    } else {\r\n                        Log.debug(\"DefaultAuthorizationPolicy: realm (\" + realm + \") != \" + approvedRealm + \" which is approved\");\r\n                    }\r\n                }\r\n            }\r\n            Log.debug(\"DefaultAuthorizationMapping: No approved mappings found.\");\r\n            return principal;\r\n        } else {\r\n            Log.debug(\"DefaultAuthorizationMapping: Realm has no length\");\r\n        }\r\n    } else {\r\n        Log.debug(\"DefaultAuthorizationMapping: No realm found\");\r\n    }\r\n    return principal;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.handler.IQPrivacyHandler.setActiveList",
	"Comment": "user has specified a new active list that should be used for the current session.",
	"Method": "IQ setActiveList(IQ packet,JID from,String listName){\r\n    IQ result = IQ.createResultIQ(packet);\r\n    Element childElement = packet.getChildElement().createCopy();\r\n    result.setChildElement(childElement);\r\n    PrivacyList list = manager.getPrivacyList(from.getNode(), listName);\r\n    if (list != null) {\r\n        ClientSession session = sessionManager.getSession(from);\r\n        if (session != null) {\r\n            session.setActiveList(list);\r\n        }\r\n    } else {\r\n        result.setError(PacketError.Condition.item_not_found);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.getPresenceStates",
	"Comment": "the presence states for which an entity wants to receive notifications. when the owneris in any of the returned presence states then he is allowed to receive notifications.",
	"Method": "Collection<String> getPresenceStates(){\r\n    return presenceStates;\r\n}"
}, {
	"Path": "org.jivesoftware.util.EmailService.setPassword",
	"Comment": "sets the password that will be used when connecting to the smtpserver. the default is null, or no password.",
	"Method": "void setPassword(String password){\r\n    this.password = password;\r\n    if (password == null) {\r\n        JiveGlobals.deleteProperty(\"mail.smtp.password\");\r\n    } else {\r\n        JiveGlobals.setProperty(\"mail.smtp.password\", password);\r\n    }\r\n    session = null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sip.tester.stack.SipManager.isRegistered",
	"Comment": "queries the registerprocessing object whether the application isregistered with a registrar.",
	"Method": "boolean isRegistered(){\r\n    return (registerProcessing != null && registerProcessing.isRegistered());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.ConnectionListener.generateConnectionConfiguration",
	"Comment": "generates an immutable connectionconfiguration based on the current state.",
	"Method": "ConnectionConfiguration generateConnectionConfiguration(){\r\n    final int defaultMaxPoolSize = 16;\r\n    final int maxThreadPoolSize;\r\n    if (maxPoolSizePropertyName == null) {\r\n        maxThreadPoolSize = defaultMaxPoolSize;\r\n    } else {\r\n        maxThreadPoolSize = JiveGlobals.getIntProperty(maxPoolSizePropertyName, defaultMaxPoolSize);\r\n    }\r\n    final int maxBufferSize;\r\n    if (maxReadBufferPropertyName != null) {\r\n        maxBufferSize = JiveGlobals.getIntProperty(maxReadBufferPropertyName, 10 * 1024 * 1024);\r\n    } else {\r\n        maxBufferSize = -1;\r\n    }\r\n    return new ConnectionConfiguration(getType(), isEnabled(), maxThreadPoolSize, maxBufferSize, getClientAuth(), getBindAddress(), getPort(), getTLSPolicy(), identityStoreConfiguration, trustStoreConfiguration, acceptSelfSignedCertificates(), verifyCertificateValidity(), getEncryptionProtocols(), getEncryptionCipherSuites(), getCompressionPolicy());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.isPosixMode",
	"Comment": "return true if the ldap server is operating in posix mode. by defaultfalse is returned. when in posix mode, users are stored within a groupby their username alone. when not enabled, users are stored in a group usingtheir entire dn.",
	"Method": "boolean isPosixMode(){\r\n    return posixMode;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.client.service.impl.TestSignedAuthRequestUrlBuilder.buildAuthRequestUrl",
	"Comment": "this test takes the uri from the result of building a signed request\tand checks that the jws object parsed from the request uri matches up\twith the expected claim values.",
	"Method": "void buildAuthRequestUrl(){\r\n    String requestUri = urlBuilder.buildAuthRequestUrl(serverConfig, clientConfig, redirectUri, nonce, state, options, null);\r\n    UriComponentsBuilder builder = null;\r\n    try {\r\n        builder = UriComponentsBuilder.fromUri(new URI(requestUri));\r\n    } catch (URISyntaxException e1) {\r\n        fail(\"URISyntaxException was thrown.\");\r\n    }\r\n    UriComponents components = builder.build();\r\n    String jwtString = components.getQueryParams().get(\"request\").get(0);\r\n    JWTClaimsSet claims = null;\r\n    try {\r\n        SignedJWT jwt = SignedJWT.parse(jwtString);\r\n        claims = jwt.getJWTClaimsSet();\r\n    } catch (ParseException e) {\r\n        fail(\"ParseException was thrown.\");\r\n    }\r\n    assertEquals(responseType, claims.getClaim(\"response_type\"));\r\n    assertEquals(clientConfig.getClientId(), claims.getClaim(\"client_id\"));\r\n    List<String> scopeList = Arrays.asList(((String) claims.getClaim(\"scope\")).split(\" \"));\r\n    assertTrue(scopeList.containsAll(clientConfig.getScope()));\r\n    assertEquals(redirectUri, claims.getClaim(\"redirect_uri\"));\r\n    assertEquals(nonce, claims.getClaim(\"nonce\"));\r\n    assertEquals(state, claims.getClaim(\"state\"));\r\n    for (String claim : options.keySet()) {\r\n        assertEquals(options.get(claim), claims.getClaim(claim));\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SocketSendingTracker.shutdown",
	"Comment": "indicates that the checking thread should be stoped. the thread will be waked upso that it can be stoped.",
	"Method": "void shutdown(){\r\n    shutdown = true;\r\n    synchronized (checkingThread) {\r\n        checkingThread.notify();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getIncomingServers",
	"Comment": "returns a collection with the hostnames of the remote servers that currently have anincoming server connection to this server.",
	"Method": "Collection<String> getIncomingServers(){\r\n    return hostnameSessionsCache.keySet();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.filetransfer.FileTransferRejectedException.setRejectionMessage",
	"Comment": "sets the text to include in a message that will be sent to the intiator and target of thefile transfer that got rejected or null if no message will be sent to the partiesof the rejected file transfer. bt default, no message will be sent.",
	"Method": "void setRejectionMessage(String rejectionMessage){\r\n    this.rejectionMessage = rejectionMessage;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.client.keypublisher.ClientKeyPublisher.publishClientJwk",
	"Comment": "return a view to publish all keys in jwk format. only used if jwkpublishurl is set.",
	"Method": "ModelAndView publishClientJwk(){\r\n    Map<String, JWK> keys = signingAndValidationService.getAllPublicKeys();\r\n    return new ModelAndView(jwkViewName, \"keys\", keys);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.MUCRoomHistory.getReverseMessageHistory",
	"Comment": "obtain the current history to be iterated in reverse mode. this means that the returned listiterator will be positioned at the end of the history so senders of this message musttraverse the list in reverse mode.",
	"Method": "ListIterator<Message> getReverseMessageHistory(){\r\n    return historyStrategy.getReverseMessageHistory();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.LocalMUCRoom.applyAffiliationChange",
	"Comment": "evaluate the given jid to determine what the appropriate affiliation should beafter a change has been made. each affected user will be granted the highestaffiliation they now possess, either explicitly or implicitly via membershipin one or more groups. if the jid is a user, the effective affiliation isapplied to each presence corresponding to that user. if the given jid is a group,each user in the group is evaluated to determine what their new affiliations willbe. the returned presence updates will be broadcast to the occupants of the room.",
	"Method": "List<Presence> applyAffiliationChange(MUCRole senderRole,JID affiliationJID,String reason){\r\n    List<JID> affectedOccupants = new ArrayList();\r\n    if (GroupJID.isGroup(affiliationJID)) {\r\n        try {\r\n            Group group = GroupManager.getInstance().getGroup(affiliationJID);\r\n            for (JID groupMember : group.getAll()) {\r\n                if (occupantsByBareJID.containsKey(groupMember)) {\r\n                    affectedOccupants.add(groupMember);\r\n                }\r\n            }\r\n        } catch (GroupNotFoundException gnfe) {\r\n            Log.error(\"Error updating group presences for \" + affiliationJID, gnfe);\r\n        }\r\n    } else {\r\n        if (occupantsByBareJID.containsKey(affiliationJID)) {\r\n            affectedOccupants.add(affiliationJID);\r\n        }\r\n    }\r\n    MUCRole.Role newRole;\r\n    MUCRole.Affiliation newAffiliation;\r\n    List<Presence> updatedPresences = new ArrayList();\r\n    for (JID occupantJID : affectedOccupants) {\r\n        Log.info(\"Applying affiliation change for \" + occupantJID);\r\n        boolean kickMember = false, isOutcast = false;\r\n        if (owners.includes(occupantJID)) {\r\n            newRole = MUCRole.Role.moderator;\r\n            newAffiliation = MUCRole.Affiliation.owner;\r\n        } else if (admins.includes(occupantJID)) {\r\n            newRole = MUCRole.Role.moderator;\r\n            newAffiliation = MUCRole.Affiliation.admin;\r\n        } else if (outcasts.includes(occupantJID)) {\r\n            newAffiliation = MUCRole.Affiliation.outcast;\r\n            newRole = MUCRole.Role.none;\r\n            kickMember = true;\r\n            isOutcast = true;\r\n        } else if (members.includesKey(occupantJID)) {\r\n            newRole = MUCRole.Role.participant;\r\n            newAffiliation = MUCRole.Affiliation.member;\r\n        } else if (isMembersOnly()) {\r\n            newRole = MUCRole.Role.none;\r\n            newAffiliation = MUCRole.Affiliation.none;\r\n            kickMember = true;\r\n        } else {\r\n            newRole = isModerated() ? MUCRole.Role.visitor : MUCRole.Role.participant;\r\n            newAffiliation = MUCRole.Affiliation.none;\r\n        }\r\n        Log.info(\"New affiliation: \" + newAffiliation);\r\n        try {\r\n            List<Presence> thisOccupant = changeOccupantAffiliation(senderRole, occupantJID, newAffiliation, newRole);\r\n            if (kickMember) {\r\n                for (Presence presence : thisOccupant) {\r\n                    presence.setType(Presence.Type.unavailable);\r\n                    presence.setStatus(null);\r\n                    Element x = presence.getChildElement(\"x\", \"http://jabber.org/protocol/muc#user\");\r\n                    if (reason != null && reason.trim().length() > 0) {\r\n                        x.element(\"item\").addElement(\"reason\").setText(reason);\r\n                    }\r\n                    x.addElement(\"status\").addAttribute(\"code\", isOutcast ? \"301\" : \"321\");\r\n                    kickPresence(presence, senderRole.getUserAddress(), senderRole.getNickname());\r\n                }\r\n            }\r\n            updatedPresences.addAll(thisOccupant);\r\n        } catch (NotAllowedException e) {\r\n            Log.error(\"Error updating presences for \" + occupantJID, e);\r\n        }\r\n    }\r\n    return updatedPresences;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.CheckChainTrustedTest.testEmptyChainArgument",
	"Comment": "verifies that providing an empty array for the first argument causes a runtime exception to be thrown.",
	"Method": "void testEmptyChainArgument(){\r\n    final CertSelector selector = new X509CertSelector();\r\n    final X509Certificate[] chain = new X509Certificate[0];\r\n    trustManager.checkChainTrusted(selector, chain);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.audit.spi.AuditorImpl.ensureMaxTotalSize",
	"Comment": "ensures that max total size limit is not exceeded. if total size of audit filesexceed the limit then oldest audit files will be removed until total size doesnot exceed limit.",
	"Method": "void ensureMaxTotalSize(){\r\n    FilenameFilter filter = new FilenameFilter() {\r\n        @Override\r\n        public boolean accept(File dir, String name) {\r\n            return name.startsWith(\"jive.audit-\") && name.endsWith(\".log\");\r\n        }\r\n    };\r\n    File[] files = baseFolder.listFiles(filter);\r\n    if (files == null) {\r\n        Log.debug(\"Path '{}' does not denote a directory, or an IO exception occured while trying to list its content.\", baseFolder);\r\n        return;\r\n    }\r\n    long totalLength = 0;\r\n    for (File file : files) {\r\n        totalLength = totalLength + file.length();\r\n    }\r\n    if (totalLength > maxTotalSize) {\r\n        List<File> sortedFiles = new ArrayList(Arrays.asList(files));\r\n        Collections.sort(sortedFiles, new Comparator<File>() {\r\n            @Override\r\n            public int compare(File o1, File o2) {\r\n                return o1.getName().compareTo(o2.getName());\r\n            }\r\n        });\r\n        while (totalLength > maxTotalSize && !sortedFiles.isEmpty()) {\r\n            File fileToDelete = sortedFiles.remove(0);\r\n            totalLength = totalLength - fileToDelete.length();\r\n            if (fileToDelete.equals(currentAuditFile)) {\r\n                close();\r\n            }\r\n            if (!fileToDelete.delete()) {\r\n                Log.warn(\"Unable to delete file '{}' as part of regular log rotation based on size of files (Openfire failed to clean up after itself)!\", fileToDelete);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.audit.spi.AuditorImpl.ensureMaxTotalSize",
	"Comment": "ensures that max total size limit is not exceeded. if total size of audit filesexceed the limit then oldest audit files will be removed until total size doesnot exceed limit.",
	"Method": "void ensureMaxTotalSize(){\r\n    return name.startsWith(\"jive.audit-\") && name.endsWith(\".log\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.audit.spi.AuditorImpl.ensureMaxTotalSize",
	"Comment": "ensures that max total size limit is not exceeded. if total size of audit filesexceed the limit then oldest audit files will be removed until total size doesnot exceed limit.",
	"Method": "void ensureMaxTotalSize(){\r\n    return o1.getName().compareTo(o2.getName());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getCertificateStoreManager",
	"Comment": "returns the certificatestoremanager registered with this server. thecertificatestoremanager was registered with the server as a module while starting upthe server.",
	"Method": "CertificateStoreManager getCertificateStoreManager(){\r\n    return (CertificateStoreManager) modules.get(CertificateStoreManager.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.isNotifiedOfDelete",
	"Comment": "returns true if subscribers will be notified when the node is deleted.",
	"Method": "boolean isNotifiedOfDelete(){\r\n    return notifyDelete;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterEventDispatcher.contactAdded",
	"Comment": "notifies the listeners that a contact has been added to a roster.",
	"Method": "void contactAdded(Roster roster,RosterItem item){\r\n    if (!listeners.isEmpty()) {\r\n        for (RosterEventListener listener : listeners) {\r\n            listener.contactAdded(roster, item);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.nio.ConnectionHandler.updateWrittenBytesCounter",
	"Comment": "updates the system counter of written bytes. this information is used by the outgoingbytes statistic.",
	"Method": "void updateWrittenBytesCounter(IoSession session){\r\n    long currentBytes = session.getWrittenBytes();\r\n    Long prevBytes = (Long) session.getAttribute(\"_written_bytes\");\r\n    long delta;\r\n    if (prevBytes == null) {\r\n        delta = currentBytes;\r\n    } else {\r\n        delta = currentBytes - prevBytes;\r\n    }\r\n    session.setAttribute(\"_written_bytes\", currentBytes);\r\n    ServerTrafficCounter.incrementOutgoingCounter(delta);\r\n}"
}, {
	"Path": "org.jivesoftware.util.BeanUtils.getPropertyDescriptors",
	"Comment": "returns the propertydescriptor array for the specified java bean class.the method also does a special check to see of the bean has a beaninfoclass that extends the jivebeaninfo class. if yes, we load thepropertydescriptor array directly from that beaninfo class rather thanthrough the introspector in order to preserve the desired ordering ofproperties.",
	"Method": "PropertyDescriptor[] getPropertyDescriptors(Class beanClass){\r\n    try {\r\n        JiveBeanInfo beanInfo = (JiveBeanInfo) ClassUtils.forName(beanClass.getName() + \"BeanInfo\").newInstance();\r\n        return beanInfo.getPropertyDescriptors();\r\n    } catch (Exception e) {\r\n    }\r\n    return Introspector.getBeanInfo(beanClass).getPropertyDescriptors();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sasl.SaslServerPlainImpl.wrap",
	"Comment": "wraps a byte array to be sent to the client. plain supports no security layer.",
	"Method": "byte[] wrap(byte[] outgoing,int offset,int len){\r\n    if (completed) {\r\n        throw new IllegalStateException(\"PLAIN does not support integrity or privacy\");\r\n    } else {\r\n        throw new IllegalStateException(\"PLAIN authentication not completed\");\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.HistoryRequest.getSince",
	"Comment": "returns the since date to use to filter the messages received during that time. in other words, only the messages received since the datetime specified will be included in the history.",
	"Method": "Date getSince(){\r\n    return since;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.DefaultGroupPropertyMap.put",
	"Comment": "custom method to put properties into the map, optionally withouttriggering persistence. this is used when the map is being initially loaded from the database.",
	"Method": "V put(K key,V value,boolean persist,V put,K key,V value){\r\n    if (value == null) {\r\n        return remove(key);\r\n    } else {\r\n        return put(key, value, true);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.StringUtils.encodeBase32",
	"Comment": "encodes a string as a base32 string using the base32hex profile.",
	"Method": "String encodeBase32(String data,String encodeBase32,byte[] data){\r\n    return data == null ? null : Base32Hex.encodeAsString(data).toLowerCase();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.rest.controller.UserServiceLegacyController.deleteRosterItem",
	"Comment": "delete roster item for specified user. no error returns if nothing todelete.",
	"Method": "void deleteRosterItem(String username,String itemJID){\r\n    getUser(username);\r\n    Roster r = rosterManager.getRoster(username);\r\n    JID j = new JID(itemJID);\r\n    r.deleteRosterItem(j, true);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.LocalRoutingTable.getServerRoutes",
	"Comment": "returns the outgoing server sessions that are connected to this jvm.",
	"Method": "Collection<LocalOutgoingServerSession> getServerRoutes(){\r\n    List<LocalOutgoingServerSession> sessions = new ArrayList();\r\n    for (RoutableChannelHandler route : routes.values()) {\r\n        if (route instanceof LocalOutgoingServerSession) {\r\n            sessions.add((LocalOutgoingServerSession) route);\r\n        }\r\n    }\r\n    return sessions;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginDevEnvironment.setClassesDir",
	"Comment": "sets the classes directory of a plugin used in development mode.",
	"Method": "void setClassesDir(File classesDir){\r\n    this.classesDir = classesDir;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.OfflineMessageStore.getMessages",
	"Comment": "returns a collection of all messages in the store for a user.messages may be deleted after being selected from the database depending onthe delete param.",
	"Method": "Collection<OfflineMessage> getMessages(String username,boolean delete){\r\n    List<OfflineMessage> messages = new ArrayList();\r\n    SAXReader xmlReader = null;\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        xmlReader = xmlReaders.take();\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(LOAD_OFFLINE);\r\n        pstmt.setString(1, username);\r\n        rs = pstmt.executeQuery();\r\n        while (rs.next()) {\r\n            String msgXML = rs.getString(1);\r\n            Date creationDate = new Date(Long.parseLong(rs.getString(2).trim()));\r\n            OfflineMessage message;\r\n            try {\r\n                message = new OfflineMessage(creationDate, xmlReader.read(new StringReader(msgXML)).getRootElement());\r\n            } catch (DocumentException e) {\r\n                Matcher matcher = pattern.matcher(msgXML);\r\n                if (matcher.find()) {\r\n                    msgXML = matcher.replaceAll(\"\");\r\n                }\r\n                try {\r\n                    message = new OfflineMessage(creationDate, xmlReader.read(new StringReader(msgXML)).getRootElement());\r\n                } catch (DocumentException de) {\r\n                    Log.error(\"Failed to route packet (offline message): \" + msgXML, de);\r\n                    continue;\r\n                }\r\n            }\r\n            Element delaytest = message.getChildElement(\"delay\", \"urn:xmpp:delay\");\r\n            if (delaytest == null) {\r\n                Element delay = message.addChildElement(\"delay\", \"urn:xmpp:delay\");\r\n                delay.addAttribute(\"from\", XMPPServer.getInstance().getServerInfo().getXMPPDomain());\r\n                delay.addAttribute(\"stamp\", XMPPDateTimeFormat.format(creationDate));\r\n            }\r\n            messages.add(message);\r\n        }\r\n        if (delete && !messages.isEmpty()) {\r\n            PreparedStatement pstmt2 = null;\r\n            try {\r\n                pstmt2 = con.prepareStatement(DELETE_OFFLINE);\r\n                pstmt2.setString(1, username);\r\n                pstmt2.executeUpdate();\r\n                removeUsernameFromSizeCache(username);\r\n            } catch (Exception e) {\r\n                Log.error(\"Error deleting offline messages of username: \" + username, e);\r\n            } finally {\r\n                DbConnectionManager.closeStatement(pstmt2);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        Log.error(\"Error retrieving offline messages of username: \" + username, e);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n        if (xmlReader != null) {\r\n            xmlReaders.add(xmlReader);\r\n        }\r\n    }\r\n    return messages;\r\n}"
}, {
	"Path": "org.jivesoftware.util.FastDateFormat.getMaxLengthEstimate",
	"Comment": "returns an estimate for the maximum length date that this dateformatter will produce. the actual formatted length will almost alwaysbe less than or equal to this amount.",
	"Method": "int getMaxLengthEstimate(){\r\n    return mMaxLengthEstimate;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.launcher.GraphicUtils.getPopupMenuShowPoint",
	"Comment": "returns a point where the given popup menu should be shown. thepoint is calculated by adjusting the x and y coordinates so thatthe popup menu will not be clipped by the screen boundaries.",
	"Method": "Point getPopupMenuShowPoint(JPopupMenu popup,MouseEvent event,Point getPopupMenuShowPoint,JPopupMenu popup,int x,int y){\r\n    Dimension sizeMenu = popup.getPreferredSize();\r\n    Point bottomRightMenu = new Point(x + sizeMenu.width, y + sizeMenu.height);\r\n    Rectangle[] screensBounds = getScreenBounds();\r\n    int n = screensBounds.length;\r\n    for (int i = 0; i < n; i++) {\r\n        Rectangle screenBounds = screensBounds[i];\r\n        if (screenBounds.x <= x && x <= (screenBounds.x + screenBounds.width)) {\r\n            Dimension sizeScreen = screenBounds.getSize();\r\n            sizeScreen.height -= 32;\r\n            int xOffset = 0;\r\n            if (bottomRightMenu.x > (screenBounds.x + sizeScreen.width))\r\n                xOffset = -sizeMenu.width;\r\n            int yOffset = 0;\r\n            if (bottomRightMenu.y > (screenBounds.y + sizeScreen.height))\r\n                yOffset = sizeScreen.height - bottomRightMenu.y;\r\n            return new Point(x + xOffset, y + yOffset);\r\n        }\r\n    }\r\n    return new Point(x, y);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.UpdateManager.isUsingProxy",
	"Comment": "returns true if a proxy is being used to connect to igniterealtime.org or false ifa direct connection should be attempted.",
	"Method": "boolean isUsingProxy(){\r\n    return !getProxyHost().isEmpty() && getProxyPort() > 0;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.UserMultiProvider.isNameRequired",
	"Comment": "returns whether all backing providers require a name to be set on user objects. if at least one proivderdoes not, this method returns false.",
	"Method": "boolean isNameRequired(){\r\n    for (final UserProvider provider : getUserProviders()) {\r\n        if (!provider.isNameRequired()) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cert.SANCertificateIdentityMapping.mapIdentity",
	"Comment": "returns the jid representation of an xmpp entity contained as a subjectaltname extensionin the certificate. if none was found then return an empty list.",
	"Method": "List<String> mapIdentity(X509Certificate certificate){\r\n    List<String> identities = new ArrayList();\r\n    try {\r\n        Collection<List<?>> altNames = certificate.getSubjectAlternativeNames();\r\n        if (altNames == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        for (List<?> item : altNames) {\r\n            final Integer type = (Integer) item.get(0);\r\n            final Object value = item.get(1);\r\n            final String result;\r\n            switch(type) {\r\n                case 0:\r\n                    result = parseOtherName((byte[]) value);\r\n                    break;\r\n                case 2:\r\n                    result = (String) value;\r\n                    break;\r\n                case 6:\r\n                    result = (String) value;\r\n                    break;\r\n                default:\r\n                    result = null;\r\n                    break;\r\n            }\r\n            if (result != null) {\r\n                identities.add(result);\r\n            }\r\n        }\r\n    } catch (CertificateParsingException e) {\r\n        Log.error(\"Error parsing SubjectAltName in certificate: \" + certificate.getSubjectDN(), e);\r\n    }\r\n    return identities;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MultiUserChatServiceImpl.removeExtraFeature",
	"Comment": "removes an extra disco feature from the list of features returned for the conference service.",
	"Method": "void removeExtraFeature(String feature){\r\n    extraDiscoFeatures.remove(feature);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.restartHTTPServer",
	"Comment": "restarts the http server only when running in stand alone mode. the restartprocess will be done in another thread that will wait 1 second before doingthe actual restart. the delay will give time to the page that requested therestart to fully render its content.",
	"Method": "void restartHTTPServer(){\r\n    Thread restartThread = new Thread() {\r\n        @Override\r\n        public void run() {\r\n            if (isStandAlone()) {\r\n                try {\r\n                    Thread.sleep(1000);\r\n                    ((AdminConsolePlugin) pluginManager.getPlugin(\"admin\")).restart();\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    };\r\n    restartThread.setContextClassLoader(loader);\r\n    restartThread.start();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.restartHTTPServer",
	"Comment": "restarts the http server only when running in stand alone mode. the restartprocess will be done in another thread that will wait 1 second before doingthe actual restart. the delay will give time to the page that requested therestart to fully render its content.",
	"Method": "void restartHTTPServer(){\r\n    if (isStandAlone()) {\r\n        try {\r\n            Thread.sleep(1000);\r\n            ((AdminConsolePlugin) pluginManager.getPlugin(\"admin\")).restart();\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalIncomingServerSession.verifyReceivedKey",
	"Comment": "verifies the received key sent by the remote server. this server is trying to generatean outgoing connection to the remote server and the remote server is reusing an incomingconnection for validating the key.",
	"Method": "void verifyReceivedKey(Element doc){\r\n    ServerDialback.verifyReceivedKey(doc, getConnection());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getConnectionMultiplexerSession",
	"Comment": "returns the session originated from the specified address or null if none wasfound. the specified address must contain a resource that uniquely identifies the session.a single connection manager should connect to the same node.",
	"Method": "ConnectionMultiplexerSession getConnectionMultiplexerSession(JID address){\r\n    LocalConnectionMultiplexerSession session = localSessionManager.getConnnectionManagerSessions().get(address.toString());\r\n    if (session == null && server.getRemoteSessionLocator() != null) {\r\n        byte[] nodeID = multiplexerSessionsCache.get(address.toString());\r\n        if (nodeID != null) {\r\n            return server.getRemoteSessionLocator().getConnectionMultiplexerSession(nodeID, address);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.commands.SessionData.setStage",
	"Comment": "sets the current stage where the requester is located. stages are numbered from 0. astage with value 0 means that a command request has just been received and no data formhas been sent to the requester yet. the first sent data form of the first stage would berepresented as stage 1.",
	"Method": "void setStage(int stage){\r\n    this.stage = stage;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.cluster.ClusterManager.getNodesInfo",
	"Comment": "returns basic information about the current members of the cluster or an emptycollection if not running in a cluster.",
	"Method": "Collection<ClusterNodeInfo> getNodesInfo(){\r\n    return CacheFactory.getClusterNodesInfo();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.lookupExistence",
	"Comment": "looks up an ldap object by its dn and returns true ifthe search was successful.",
	"Method": "Boolean lookupExistence(InitialDirContext ctx,String dn,String[] returnattrs){\r\n    boolean debug = Log.isDebugEnabled();\r\n    if (debug) {\r\n        Log.debug(\"LdapManager: In lookupExistence(ctx, dn, returnattrs), searchdn is: \" + dn);\r\n    }\r\n    ctx.addToEnvironment(Context.PROVIDER_URL, getProviderURL(dn));\r\n    String filter = \"(&(objectClass=*))\";\r\n    SearchControls srcnt = new SearchControls();\r\n    srcnt.setSearchScope(SearchControls.OBJECT_SCOPE);\r\n    srcnt.setReturningAttributes(returnattrs);\r\n    NamingEnumeration<SearchResult> answer = null;\r\n    try {\r\n        answer = ctx.search(\"\", filter, srcnt);\r\n    } catch (javax.naming.NameNotFoundException nex) {\r\n    } catch (NamingException ex) {\r\n        throw ex;\r\n    }\r\n    if (answer == null || !answer.hasMoreElements()) {\r\n        Log.debug(\"LdapManager: .... lookupExistence: DN not found.\");\r\n        return false;\r\n    } else {\r\n        Log.debug(\"LdapManager: .... lookupExistence: DN found.\");\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.setPort",
	"Comment": "sets the ldap server port number. the default is 389. this value isstored as the jive property ldap.port.",
	"Method": "void setPort(int port){\r\n    this.port = port;\r\n    properties.put(\"ldap.port\", Integer.toString(port));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.server.ServerDialback.authenticateDomain",
	"Comment": "authenticates the originating server domain with the receiving server. once the domain hasbeen authenticated the receiving server will start accepting packets from the originatingserver.the receiving server will connect to the authoritative server to verify the dialback key.most probably the originating server machine will be the authoritative server too.",
	"Method": "boolean authenticateDomain(OutgoingServerSocketReader socketReader,String localDomain,String remoteDomain,String id){\r\n    final Logger log = LoggerFactory.getLogger(Log.getName() + \"[Acting as Originating Server: Authenticate domain: \" + localDomain + \" with RS: \" + remoteDomain + \" (id: \" + id + \")]\");\r\n    log.debug(\"Authenticating domain ...\");\r\n    String key = AuthFactory.createDigest(id, getSecretkey());\r\n    synchronized (socketReader) {\r\n        log.debug(\"Sending dialback key and wait for the validation response...\");\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"<db:result\");\r\n        sb.append(\" from=\\\"\").append(localDomain).append(\"\\\"\");\r\n        sb.append(\" to=\\\"\").append(remoteDomain).append(\"\\\">\");\r\n        sb.append(key);\r\n        sb.append(\"<\/db:result>\");\r\n        connection.deliverRawText(sb.toString());\r\n        try {\r\n            while (true) {\r\n                Element doc = socketReader.getElement(RemoteServerManager.getSocketTimeout(), TimeUnit.MILLISECONDS);\r\n                if (doc == null) {\r\n                    log.debug(\"Failed to authenticate domain: Time out waiting for validation response.\");\r\n                    return false;\r\n                } else if (\"db\".equals(doc.getNamespacePrefix()) && \"result\".equals(doc.getName())) {\r\n                    if (\"valid\".equals(doc.attributeValue(\"type\"))) {\r\n                        log.debug(\"Authenticated succeeded!\");\r\n                        return true;\r\n                    } else {\r\n                        log.debug(\"Failed to authenticate domain: the validation response was received, but did not grant authentication.\");\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    log.warn(\"Ignoring unexpected answer while waiting for dialback validation: \" + doc.asXML());\r\n                }\r\n            }\r\n        } catch (InterruptedException e) {\r\n            log.debug(\"Failed to authenticate domain: An interrupt was received while waiting for validation response (is Openfire shutting down?)\");\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.UserServicePlugin.deleteRosterItem",
	"Comment": "delete roster item for specified user. no error returns if nothing todelete.",
	"Method": "void deleteRosterItem(String username,String itemJID){\r\n    getUser(username);\r\n    Roster r = rosterManager.getRoster(username);\r\n    JID j = new JID(itemJID);\r\n    r.deleteRosterItem(j, true);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.component.InternalComponentManager.hasComponent",
	"Comment": "returns true if a component is associated to the specified address. componentsregistered with this jvm or other cluster nodes are going to be considered.",
	"Method": "boolean hasComponent(JID componentJID,Boolean hasComponent,Component component){\r\n    synchronized (routables) {\r\n        if (componentJID.getNode() != null || componentJID.getResource() != null) {\r\n            return false;\r\n        }\r\n        return routingTable.hasComponentRoute(componentJID);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.ServerStanzaHandler.packetReceived",
	"Comment": "make sure that the received packet has a to and from values defined and that it was sentfrom a previously validated domain. if the packet does not matches any of the aboveconditions then a packetrejectedexception will be thrown.",
	"Method": "void packetReceived(Packet packet){\r\n    if (packet.getTo() == null || packet.getFrom() == null) {\r\n        Log.debug(\"ServerStanzaHandler: Closing IncomingServerSession due to packet with no TO or FROM: \" + packet.toXML());\r\n        StreamError error = new StreamError(StreamError.Condition.improper_addressing);\r\n        connection.deliverRawText(error.toXML());\r\n        throw new UnauthorizedException(\"Packet with no TO or FROM attributes\");\r\n    } else if (!((LocalIncomingServerSession) session).isValidDomain(packet.getFrom().getDomain())) {\r\n        Log.debug(\"ServerStanzaHandler: Closing IncomingServerSession due to packet with invalid domain: \" + packet.toXML());\r\n        StreamError error = new StreamError(StreamError.Condition.invalid_from);\r\n        connection.deliverRawText(error.toXML());\r\n        throw new UnauthorizedException(\"Packet with no TO or FROM attributes\");\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SocketSendingTracker.checkHealth",
	"Comment": "checks if a socket has been trying to send data for a given amount of time. if it hasexceded a limit of time then the socket will be closed.it is expected that sending operations will not take too much time so the checking willbe very fast since very few sockets will be present in the map and most or all of themwill not exceed the time limit. therefore, it is expected the overhead of this class to bequite small.",
	"Method": "void checkHealth(){\r\n    for (SocketConnection connection : SocketConnection.getInstances()) {\r\n        connection.checkHealth();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.DefaultCache.getName",
	"Comment": "returns the name of this cache. the name is completely arbitraryand used only for display to administrators.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyListProvider.loadDefaultPrivacyList",
	"Comment": "loads the default privacy list of a given user from the database. returns nullif no list was found.",
	"Method": "PrivacyList loadDefaultPrivacyList(String username){\r\n    if (!databaseContainsPrivacyLists.get()) {\r\n        return null;\r\n    }\r\n    String listName = null;\r\n    String listValue = null;\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(LOAD_DEFAULT_PRIVACY_LIST);\r\n        pstmt.setString(1, username);\r\n        rs = pstmt.executeQuery();\r\n        if (rs.next()) {\r\n            listName = rs.getString(1);\r\n            listValue = rs.getString(2);\r\n        } else {\r\n            return null;\r\n        }\r\n    } catch (Exception e) {\r\n        Log.error(\"Error loading default privacy list of username: \" + username, e);\r\n        return null;\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    PrivacyList privacyList = null;\r\n    SAXReader xmlReader = null;\r\n    try {\r\n        xmlReader = xmlReaders.take();\r\n        Element listElement = xmlReader.read(new StringReader(listValue)).getRootElement();\r\n        privacyList = new PrivacyList(username, listName, true, listElement);\r\n    } catch (Exception e) {\r\n        Log.error(e.getMessage(), e);\r\n    } finally {\r\n        if (xmlReader != null) {\r\n            xmlReaders.add(xmlReader);\r\n        }\r\n    }\r\n    return privacyList;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.CollectionNode.getAssociationTrusted",
	"Comment": "returns the users that are allowed to associate leaf nodes with this collection node.this collection is going to be used only when the associationpolicy is whitelist.",
	"Method": "Collection<JID> getAssociationTrusted(){\r\n    return Collections.unmodifiableCollection(associationTrusted);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterManager.isPublicSharedGroup",
	"Comment": "returns true if the specified group may be seen by all users in the system. the decisionis made based on the group properties that are configurable through the admin console.",
	"Method": "boolean isPublicSharedGroup(Group group){\r\n    String showInRoster = group.getProperties().get(\"sharedRoster.showInRoster\");\r\n    if (\"everybody\".equals(showInRoster)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.Update.isDownloaded",
	"Comment": "returns true if the plugin was downloaded. once a plugin has been downloadedit may take a couple of seconds to be installed. this flag only makes sense forplugins since we currently do not support download new openfire releases.",
	"Method": "boolean isDownloaded(){\r\n    return downloaded;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.auth.DefaultAuthorizationPolicy.authorize",
	"Comment": "returns true if the principal is explicitly authorized to the jid",
	"Method": "boolean authorize(String username,String authenID){\r\n    boolean authorized = false;\r\n    String userUser = username;\r\n    String userRealm = null;\r\n    String authenUser = authenID;\r\n    String authenRealm = null;\r\n    if (username.contains(\"@\")) {\r\n        userUser = username.substring(0, username.lastIndexOf(\"@\"));\r\n        userRealm = username.substring((username.lastIndexOf(\"@\") + 1));\r\n    }\r\n    if (authenID.contains(\"@\")) {\r\n        authenUser = authenID.substring(0, (authenID.lastIndexOf(\"@\")));\r\n        authenRealm = authenID.substring((authenID.lastIndexOf(\"@\") + 1));\r\n    }\r\n    if (!proxyAuth || !AdminManager.getInstance().isUserAdmin(authenUser, true)) {\r\n        if (!userUser.equals(authenUser)) {\r\n            if (JiveGlobals.getBooleanProperty(\"xmpp.auth.ignorecase\", true)) {\r\n                if (!userUser.toLowerCase().equals(authenUser.toLowerCase())) {\r\n                    if (Log.isDebugEnabled()) {\r\n                        Log.debug(\"DefaultAuthorizationPolicy: usernames don't match (\" + userUser + \" \" + authenUser + \")\");\r\n                    }\r\n                    return false;\r\n                }\r\n            } else {\r\n                Log.debug(\"DefaultAuthorizationPolicy: usernames don't match (\" + userUser + \" \" + authenUser + \")\");\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    Log.debug(\"DefaultAuthorizationPolicy: Checking authenID realm\");\r\n    if (authenRealm != null) {\r\n        if (authenRealm.equals(JiveGlobals.getProperty(\"xmpp.domain\"))) {\r\n            Log.debug(\"DefaultAuthorizationPolicy: authenRealm = xmpp.domain\");\r\n            authorized = true;\r\n        } else if (authenRealm.equals(JiveGlobals.getProperty(\"sasl.realm\"))) {\r\n            Log.debug(\"DefaultAuthorizationPolicy: authenRealm = sasl.realm\");\r\n            authorized = true;\r\n        } else {\r\n            for (String realm : approvedRealms) {\r\n                if (authenRealm.equals(realm)) {\r\n                    if (Log.isDebugEnabled()) {\r\n                        Log.debug(\"DefaultAuthorizationPolicy: authenRealm = \" + realm + \" which is approved\");\r\n                    }\r\n                    authorized = true;\r\n                } else {\r\n                    if (Log.isDebugEnabled()) {\r\n                        Log.debug(\"DefaultAuthorizationPolicy: authenRealm != \" + realm + \" which is approved\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        authorized = true;\r\n    }\r\n    if (!authorized) {\r\n        return false;\r\n    } else {\r\n        authorized = false;\r\n    }\r\n    if (userRealm != null) {\r\n        if (userRealm.equals(JiveGlobals.getProperty(\"xmpp.domain\"))) {\r\n            Log.debug(\"DefaultAuthorizationPolicy: userRealm = xmpp.domain\");\r\n            authorized = true;\r\n        } else {\r\n            if (authenRealm != null && authenRealm.equals(userRealm)) {\r\n                if (Log.isDebugEnabled()) {\r\n                    Log.debug(\"DefaultAuthorizationPolicy: userRealm = \" + authenRealm + \" which is approved\");\r\n                }\r\n                authorized = true;\r\n            }\r\n        }\r\n    } else {\r\n        authorized = true;\r\n    }\r\n    return authorized;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PubSubPersistenceManager.createDefaultConfiguration",
	"Comment": "creates a new default node configuration for the specified service.",
	"Method": "void createDefaultConfiguration(PubSubService service,DefaultNodeConfiguration config){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(ADD_DEFAULT_CONF);\r\n        pstmt.setString(1, service.getServiceID());\r\n        pstmt.setInt(2, (config.isLeaf() ? 1 : 0));\r\n        pstmt.setInt(3, (config.isDeliverPayloads() ? 1 : 0));\r\n        pstmt.setInt(4, config.getMaxPayloadSize());\r\n        pstmt.setInt(5, (config.isPersistPublishedItems() ? 1 : 0));\r\n        pstmt.setInt(6, config.getMaxPublishedItems());\r\n        pstmt.setInt(7, (config.isNotifyConfigChanges() ? 1 : 0));\r\n        pstmt.setInt(8, (config.isNotifyDelete() ? 1 : 0));\r\n        pstmt.setInt(9, (config.isNotifyRetract() ? 1 : 0));\r\n        pstmt.setInt(10, (config.isPresenceBasedDelivery() ? 1 : 0));\r\n        pstmt.setInt(11, (config.isSendItemSubscribe() ? 1 : 0));\r\n        pstmt.setString(12, config.getPublisherModel().getName());\r\n        pstmt.setInt(13, (config.isSubscriptionEnabled() ? 1 : 0));\r\n        pstmt.setString(14, config.getAccessModel().getName());\r\n        pstmt.setString(15, config.getLanguage());\r\n        if (config.getReplyPolicy() != null) {\r\n            pstmt.setString(16, config.getReplyPolicy().name());\r\n        } else {\r\n            pstmt.setString(16, null);\r\n        }\r\n        pstmt.setString(17, config.getAssociationPolicy().name());\r\n        pstmt.setInt(18, config.getMaxLeafNodes());\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException sqle) {\r\n        log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.CertificateStoreManager.getTrustStorePassword",
	"Comment": "the password of the trust store for connections created by this listener.",
	"Method": "String getTrustStorePassword(ConnectionType type){\r\n    final String propertyName = type.getPrefix() + \"trustpass\";\r\n    final String defaultValue = \"changeit\";\r\n    if (type.getFallback() == null) {\r\n        return JiveGlobals.getProperty(propertyName, defaultValue).trim();\r\n    } else {\r\n        return JiveGlobals.getProperty(propertyName, getTrustStorePassword(type.getFallback())).trim();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalOutgoingServerSession.createOutgoingSession",
	"Comment": "establishes a new outgoing session to a remote domain. if the remote domain supports tls and sasl then the newoutgoing connection will be secured with tls and authenticatedusing sasl. however, if tls or sasl is notsupported by the remote domain or if an error occurred while securing or authenticating the connection using saslthen server dialback will be used.",
	"Method": "LocalOutgoingServerSession createOutgoingSession(String localDomain,String remoteDomain,int port){\r\n    final Logger log = LoggerFactory.getLogger(Log.getName() + \"[Create outgoing session for: \" + localDomain + \" to \" + remoteDomain + \"]\");\r\n    log.debug(\"Creating new session...\");\r\n    log.debug(\"Creating plain socket connection to a host that belongs to the remote XMPP domain.\");\r\n    final Map.Entry<Socket, Boolean> socketToXmppDomain = SocketUtil.createSocketToXmppDomain(remoteDomain, port);\r\n    if (socketToXmppDomain == null) {\r\n        log.info(\"Unable to create new session: Cannot create a plain socket connection with any applicable remote host.\");\r\n        return null;\r\n    }\r\n    final Socket socket = socketToXmppDomain.getKey();\r\n    final boolean directTLS = socketToXmppDomain.getValue();\r\n    SocketConnection connection = null;\r\n    try {\r\n        connection = new SocketConnection(XMPPServer.getInstance().getPacketDeliverer(), socket, false);\r\n        if (directTLS) {\r\n            connection.startTLS(true, directTLS);\r\n        }\r\n        log.debug(\"Send the stream header and wait for response...\");\r\n        StringBuilder openingStream = new StringBuilder();\r\n        openingStream.append(\"<stream:stream\");\r\n        openingStream.append(\" xmlns:db=\\\"jabber:server:dialback\\\"\");\r\n        openingStream.append(\" xmlns:stream=\\\"http://etherx.jabber.org/streams\\\"\");\r\n        openingStream.append(\" xmlns=\\\"jabber:server\\\"\");\r\n        openingStream.append(\" from=\\\"\").append(localDomain).append(\"\\\"\");\r\n        openingStream.append(\" to=\\\"\").append(remoteDomain).append(\"\\\"\");\r\n        openingStream.append(\" version=\\\"1.0\\\">\");\r\n        connection.deliverRawText(openingStream.toString());\r\n        int soTimeout = socket.getSoTimeout();\r\n        socket.setSoTimeout(5000);\r\n        XMPPPacketReader reader = new XMPPPacketReader();\r\n        final InputStream inputStream;\r\n        if (directTLS) {\r\n            inputStream = connection.getTLSStreamHandler().getInputStream();\r\n        } else {\r\n            inputStream = socket.getInputStream();\r\n        }\r\n        reader.getXPPParser().setInput(new InputStreamReader(inputStream, StandardCharsets.UTF_8));\r\n        XmlPullParser xpp = reader.getXPPParser();\r\n        for (int eventType = xpp.getEventType(); eventType != XmlPullParser.START_TAG; ) {\r\n            eventType = xpp.next();\r\n        }\r\n        String serverVersion = xpp.getAttributeValue(\"\", \"version\");\r\n        String id = xpp.getAttributeValue(\"\", \"id\");\r\n        log.debug(\"Got a response (stream ID: {}, version: {}). Check if the remote server is XMPP 1.0 compliant...\", id, serverVersion);\r\n        if (serverVersion != null && decodeVersion(serverVersion)[0] >= 1) {\r\n            log.debug(\"The remote server is XMPP 1.0 compliant (or at least reports to be).\");\r\n            socket.setSoTimeout(soTimeout);\r\n            log.debug(\"Processing stream features of the remote domain...\");\r\n            Element features = reader.parseDocument().getRootElement();\r\n            if (features != null) {\r\n                if (directTLS) {\r\n                    log.debug(\"We connected to the remote server using direct TLS. Authenticate the connection with SASL...\");\r\n                    LocalOutgoingServerSession answer = authenticate(remoteDomain, connection, reader, openingStream, localDomain, features, id);\r\n                    if (answer != null) {\r\n                        log.debug(\"Successfully authenticated the connection with SASL)!\");\r\n                        log.debug(\"Successfully created new session!\");\r\n                        return answer;\r\n                    }\r\n                    log.debug(\"Unable to authenticate the connection with SASL.\");\r\n                } else {\r\n                    log.debug(\"Check if both us as well as the remote server have enabled STARTTLS and/or dialback ...\");\r\n                    final boolean useTLS = JiveGlobals.getBooleanProperty(ConnectionSettings.Server.TLS_ENABLED, true);\r\n                    if (useTLS && features.element(\"starttls\") != null) {\r\n                        log.debug(\"Both us and the remote server support the STARTTLS feature. Secure and authenticate the connection with TLS & SASL...\");\r\n                        LocalOutgoingServerSession answer = secureAndAuthenticate(remoteDomain, connection, reader, openingStream, localDomain);\r\n                        if (answer != null) {\r\n                            log.debug(\"Successfully secured/authenticated the connection with TLS/SASL)!\");\r\n                            log.debug(\"Successfully created new session!\");\r\n                            return answer;\r\n                        }\r\n                        log.debug(\"Unable to secure and authenticate the connection with TLS & SASL.\");\r\n                    } else if (connection.getTlsPolicy() == Connection.TLSPolicy.required) {\r\n                        log.debug(\"I have no StartTLS yet I must TLS\");\r\n                        connection.close();\r\n                        return null;\r\n                    } else if (ServerDialback.isEnabled() && features.element(\"dialback\") != null) {\r\n                        log.debug(\"Both us and the remote server support the 'dialback' feature. Authenticate the connection with dialback...\");\r\n                        ServerDialback method = new ServerDialback(connection, localDomain);\r\n                        OutgoingServerSocketReader newSocketReader = new OutgoingServerSocketReader(reader);\r\n                        if (method.authenticateDomain(newSocketReader, localDomain, remoteDomain, id)) {\r\n                            log.debug(\"Successfully authenticated the connection with dialback!\");\r\n                            StreamID streamID = new BasicStreamIDFactory().createStreamID(id);\r\n                            LocalOutgoingServerSession session = new LocalOutgoingServerSession(localDomain, connection, newSocketReader, streamID);\r\n                            connection.init(session);\r\n                            session.setAddress(new JID(null, remoteDomain, null));\r\n                            log.debug(\"Successfully created new session!\");\r\n                            return session;\r\n                        } else {\r\n                            log.debug(\"Unable to authenticate the connection with dialback.\");\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                log.debug(\"Error! No data from the remote server (expected a 'feature' element).\");\r\n            }\r\n        } else {\r\n            log.debug(\"The remote server is not XMPP 1.0 compliant.\");\r\n        }\r\n        log.debug(\"Something went wrong so close the connection and try server dialback over a plain connection\");\r\n        if (connection.getTlsPolicy() == Connection.TLSPolicy.required) {\r\n            log.debug(\"I have no StartTLS yet I must TLS\");\r\n            connection.close();\r\n            return null;\r\n        }\r\n        connection.close();\r\n    } catch (SSLHandshakeException e) {\r\n        log.info(\"{} negotiation failed. Closing connection (without sending any data such as <failure/> or <\/stream>).\", (directTLS ? \"Direct TLS\" : \"StartTLS\"), e);\r\n        if (connection != null) {\r\n            connection.forceClose();\r\n        }\r\n    } catch (Exception e) {\r\n        log.warn(\"An exception occurred while creating an encrypted session. Closing connection.\", e);\r\n        if (connection != null) {\r\n            connection.close();\r\n        }\r\n    }\r\n    if (ServerDialback.isEnabled()) {\r\n        log.debug(\"Unable to create a new session. Going to try connecting using server dialback as a fallback.\");\r\n        final LocalOutgoingServerSession outgoingSession = new ServerDialback().createOutgoingSession(localDomain, remoteDomain, port);\r\n        if (outgoingSession != null) {\r\n            log.debug(\"Successfully created new session (using dialback as a fallback)!\");\r\n            return outgoingSession;\r\n        } else {\r\n            log.warn(\"Unable to create a new session: Dialback (as a fallback) failed.\");\r\n            return null;\r\n        }\r\n    } else {\r\n        log.warn(\"Unable to create a new session: exhausted all options (not trying dialback as a fallback, as server dialback is disabled by configuration.\");\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.rest.controller.UserServiceLegacyController.getUserGroups",
	"Comment": "returns all group names or an empty collection for specific user.",
	"Method": "Collection<String> getUserGroups(String username){\r\n    User user = getUser(username);\r\n    Collection<Group> groups = GroupManager.getInstance().getGroups(user);\r\n    Collection<String> groupNames = new ArrayList<String>();\r\n    for (Group group : groups) {\r\n        groupNames.add(group.getName());\r\n    }\r\n    return groupNames;\r\n}"
}, {
	"Path": "org.jivesoftware.util.WebXmlUtils.getServletUrlPatterns",
	"Comment": "retrieves all url patterns that apply to a specific servlet.",
	"Method": "Set<String> getServletUrlPatterns(Document webXml,String servletName){\r\n    return getUrlPatterns(\"servlet\", webXml, servletName);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginDevEnvironment.getClassesDir",
	"Comment": "returns the classes directory of a plugin in development mode.",
	"Method": "File getClassesDir(){\r\n    return classesDir;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.isSslEnabled",
	"Comment": "returns true if ldap connection is via ssl or not. ssl is turned off by default.",
	"Method": "boolean isSslEnabled(){\r\n    return sslEnabled;\r\n}"
}, {
	"Path": "org.jivesoftware.database.DbConnectionManager.isProfilingEnabled",
	"Comment": "returns true if connection profiling is turned on. you can collectprofiling statistics by using the static methods of the profiledconnectionclass.",
	"Method": "boolean isProfilingEnabled(){\r\n    return profilingEnabled;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginManager.getPlugins",
	"Comment": "returns a collection of all loaded plugins.the returned collection will not include plugins that have been downloaded, but not loaded.",
	"Method": "Collection<Plugin> getPlugins(){\r\n    return Collections.unmodifiableCollection(Arrays.asList(pluginsLoaded.values().toArray(new Plugin[0])));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalClientSession.canProcess",
	"Comment": "returns true if the specified packet must not be blocked based on the active or defaultprivacy list rules. the active list will be tried first. if none was found then thedefault list is going to be used. if no default list was defined for this user thenallow the packet to flow.",
	"Method": "boolean canProcess(Packet packet){\r\n    PrivacyList list = getActiveList();\r\n    if (list != null) {\r\n        return !list.shouldBlockPacket(packet);\r\n    } else {\r\n        list = getDefaultList();\r\n        return list == null || !list.shouldBlockPacket(packet);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.isClosed",
	"Comment": "returns true if this session has been closed and no longer actively accepting connections.",
	"Method": "boolean isClosed(){\r\n    return isClosed;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pep.IQPEPHandler.createSubscriptionToPEPService",
	"Comment": "generates and processes an iq stanza that subscribes to a pep service.",
	"Method": "void createSubscriptionToPEPService(PEPService pepService,JID subscriber,JID owner){\r\n    IQ subscriptionPacket = new IQ(IQ.Type.set);\r\n    subscriptionPacket.setFrom(subscriber);\r\n    subscriptionPacket.setTo(owner.toBareJID());\r\n    Element pubsubElement = subscriptionPacket.setChildElement(\"pubsub\", \"http://jabber.org/protocol/pubsub\");\r\n    Element subscribeElement = pubsubElement.addElement(\"subscribe\");\r\n    subscribeElement.addAttribute(\"jid\", subscriber.toBareJID());\r\n    Element optionsElement = pubsubElement.addElement(\"options\");\r\n    Element xElement = optionsElement.addElement(QName.get(\"x\", \"jabber:x:data\"));\r\n    DataForm dataForm = new DataForm(xElement);\r\n    FormField formField = dataForm.addField();\r\n    formField.setVariable(\"FORM_TYPE\");\r\n    formField.setType(FormField.Type.hidden);\r\n    formField.addValue(\"http://jabber.org/protocol/pubsub#subscribe_options\");\r\n    formField = dataForm.addField();\r\n    formField.setVariable(\"pubsub#subscription_type\");\r\n    formField.addValue(\"items\");\r\n    formField = dataForm.addField();\r\n    formField.setVariable(\"pubsub#subscription_depth\");\r\n    formField.addValue(\"all\");\r\n    pepServiceManager.process(pepService, subscriptionPacket);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.entitycaps.EntityCapabilitiesManager.getExtendedDataForms",
	"Comment": "extracts a list of extended service discovery information from an iqpacket.",
	"Method": "List<String> getExtendedDataForms(IQ packet){\r\n    List<String> results = new ArrayList();\r\n    Element query = packet.getChildElement();\r\n    Iterator<Element> extensionIterator = query.elementIterator(QName.get(\"x\", \"jabber:x:data\"));\r\n    if (extensionIterator != null) {\r\n        while (extensionIterator.hasNext()) {\r\n            Element extensionElement = extensionIterator.next();\r\n            final StringBuilder formType = new StringBuilder();\r\n            Iterator<Element> fieldIterator = extensionElement.elementIterator(\"field\");\r\n            List<String> vars = new ArrayList();\r\n            while (fieldIterator != null && fieldIterator.hasNext()) {\r\n                final Element fieldElement = fieldIterator.next();\r\n                if (fieldElement.attributeValue(\"var\").equals(\"FORM_TYPE\")) {\r\n                    formType.append(fieldElement.element(\"value\").getText());\r\n                    formType.append('<');\r\n                } else {\r\n                    final StringBuilder var = new StringBuilder();\r\n                    var.append(fieldElement.attributeValue(\"var\"));\r\n                    var.append('<');\r\n                    Iterator<Element> valIter = fieldElement.elementIterator(\"value\");\r\n                    List<String> values = new ArrayList();\r\n                    while (valIter != null && valIter.hasNext()) {\r\n                        Element value = valIter.next();\r\n                        values.add(value.getText());\r\n                    }\r\n                    Collections.sort(values);\r\n                    for (String v : values) {\r\n                        var.append(v);\r\n                        var.append('<');\r\n                    }\r\n                    vars.add(var.toString());\r\n                }\r\n            }\r\n            Collections.sort(vars);\r\n            for (String v : vars) {\r\n                formType.append(v);\r\n            }\r\n            results.add(formType.toString());\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.multiplex.ConnectionMultiplexerManager.multiplexerAvailable",
	"Comment": "a connection manager has become available. clients can now connect to the server throughthe connection manager.",
	"Method": "void multiplexerAvailable(String connectionManagerName){\r\n    Map<StreamID, LocalClientSession> sessions = sessionsByManager.get(connectionManagerName);\r\n    if (sessions == null) {\r\n        synchronized (connectionManagerName.intern()) {\r\n            sessions = sessionsByManager.get(connectionManagerName);\r\n            if (sessions == null) {\r\n                sessions = new ConcurrentHashMap();\r\n                sessionsByManager.put(connectionManagerName, sessions);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.rest.RESTServicePlugin.isEnabled",
	"Comment": "returns true if the user service is enabled. if not enabled, it will notaccept requests to create new accounts.",
	"Method": "boolean isEnabled(){\r\n    return enabled;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.GroupManager.getGroup",
	"Comment": "returns the corresponding group if the given jid represents a group.",
	"Method": "Group getGroup(JID jid,Group getGroup,String name,Group getGroup,String name,boolean forceLookup){\r\n    Group group = null;\r\n    if (forceLookup) {\r\n        groupCache.remove(name);\r\n    } else {\r\n        group = groupCache.get(name);\r\n    }\r\n    if (group == null) {\r\n        synchronized ((name + MUTEX_SUFFIX_GROUP).intern()) {\r\n            group = groupCache.get(name);\r\n            if (group == null) {\r\n                group = provider.getGroup(name);\r\n                groupCache.put(name, group);\r\n            }\r\n        }\r\n    }\r\n    return group;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.MultiUserChatManager.createMultiUserChatService",
	"Comment": "creates a new muc service and registers it with the manager, and starts up the service.",
	"Method": "MultiUserChatServiceImpl createMultiUserChatService(String subdomain,String description,Boolean isHidden){\r\n    if (getMultiUserChatServiceID(subdomain) != null)\r\n        throw new AlreadyExistsException();\r\n    MultiUserChatServiceImpl muc = new MultiUserChatServiceImpl(subdomain, description, isHidden);\r\n    insertService(subdomain, description, isHidden);\r\n    registerMultiUserChatService(muc);\r\n    return muc;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.HistoryRequest.getMaxChars",
	"Comment": "returns the total number of characters to receive in the history.",
	"Method": "int getMaxChars(){\r\n    return maxChars;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.DNSUtilTest.testOneHost",
	"Comment": "a basic check that verifies that when one hosts exists, it gets returned in the output.",
	"Method": "void testOneHost(){\r\n    final DNSUtil.WeightedHostAddress host = new DNSUtil.WeightedHostAddress(\"host\", 5222, false, 1, 1);\r\n    final List<DNSUtil.WeightedHostAddress> result = DNSUtil.prioritize(new DNSUtil.WeightedHostAddress[] { host });\r\n    Assert.assertEquals(1, result.size());\r\n    Assert.assertEquals(host, result.get(0));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.removeServerListener",
	"Comment": "removes a server listener that was being notified when the server was being startedor was about to be stopped.",
	"Method": "void removeServerListener(XMPPServerListener listener){\r\n    listeners.remove(listener);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyListManager.getPrivacyList",
	"Comment": "returns a specific privacy list of the specified user or null ifnone was found.",
	"Method": "PrivacyList getPrivacyList(String username,String listName){\r\n    String cacheKey = getCacheKey(username, listName);\r\n    PrivacyList list = listsCache.get(cacheKey);\r\n    if (list == null) {\r\n        list = provider.loadPrivacyList(username, listName);\r\n        if (list != null) {\r\n            listsCache.put(cacheKey, list);\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sip.tester.security.MessageDigestAlgorithm.calculateResponse",
	"Comment": "calculates a response an http authentication response in accordance withrfc2617.",
	"Method": "String calculateResponse(String algorithm,String username_value,String realm_value,String passwd,String nonce_value,String nc_value,String cnonce_value,String Method,String digest_uri_value,String entity_body,String qop_value){\r\n    if (username_value == null || realm_value == null || passwd == null || Method == null || digest_uri_value == null || nonce_value == null)\r\n        throw new NullPointerException(\"Null parameter to MessageDigestAlgorithm.calculateResponse()\");\r\n    String A1 = null;\r\n    if (algorithm == null || algorithm.trim().length() == 0 || algorithm.trim().equalsIgnoreCase(\"MD5\")) {\r\n        A1 = username_value + \":\" + realm_value + \":\" + passwd;\r\n    } else {\r\n        if (cnonce_value == null || cnonce_value.length() == 0)\r\n            throw new NullPointerException(\"cnonce_value may not be absent for MD5-Sess algorithm.\");\r\n        A1 = MessageDigestAlgorithm.H(username_value + \":\" + realm_value + \":\" + passwd) + \":\" + nonce_value + \":\" + cnonce_value;\r\n    }\r\n    String A2 = null;\r\n    if (qop_value == null || qop_value.trim().length() == 0 || qop_value.trim().equalsIgnoreCase(\"auth\")) {\r\n        A2 = Method + \":\" + digest_uri_value;\r\n    } else {\r\n        if (entity_body == null)\r\n            entity_body = \"\";\r\n        A2 = Method + \":\" + digest_uri_value + \":\" + MessageDigestAlgorithm.H(entity_body);\r\n    }\r\n    String request_digest = null;\r\n    if (cnonce_value != null && qop_value != null && (qop_value.equals(\"auth\") || (qop_value.equals(\"auth-int\")))) {\r\n        request_digest = MessageDigestAlgorithm.KD(MessageDigestAlgorithm.H(A1), nonce_value + \":\" + nc_value + \":\" + cnonce_value + \":\" + qop_value + \":\" + MessageDigestAlgorithm.H(A2));\r\n    } else {\r\n        request_digest = MessageDigestAlgorithm.KD(MessageDigestAlgorithm.H(A1), nonce_value + \":\" + MessageDigestAlgorithm.H(A2));\r\n    }\r\n    return request_digest;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.lockout.LockOutFlag.getUsername",
	"Comment": "retrieves the username that this lock out flag is attached to.",
	"Method": "String getUsername(){\r\n    return username;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.server.RemoteServerManager.deleteConfiguration",
	"Comment": "removes any existing defined permission and configuration for the specifiedremote server.",
	"Method": "void deleteConfiguration(String domain){\r\n    configurationsCache.remove(domain);\r\n    java.sql.Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(DELETE_CONFIGURATION);\r\n        pstmt.setString(1, domain);\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException sqle) {\r\n        Log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.mediaproxy.MediaProxySession.datagramReceived",
	"Comment": "implement datagramlistener to timestamp last packet arrived",
	"Method": "boolean datagramReceived(DatagramPacket datagramPacket){\r\n    timestamp = System.currentTimeMillis();\r\n    return true;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyListManager.deletePrivacyList",
	"Comment": "deletes an existing privacy list of a user. if the privacy list being deleted wasthe default list then the user will end up with no default list. therefore, the userwill have to set a new default list.",
	"Method": "void deletePrivacyList(String username,String listName){\r\n    for (PrivacyListEventListener listener : listeners) {\r\n        listener.privacyListDeleting(listName);\r\n    }\r\n    listsCache.remove(getCacheKey(username, listName));\r\n    provider.deletePrivacyList(username, listName);\r\n    PrivacyList defaultList = listsCache.get(getDefaultCacheKey(username));\r\n    if (defaultList != null && listName.equals(defaultList.getName())) {\r\n        listsCache.remove(getDefaultCacheKey(username));\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.admin.LdapUserTester.getAttributes",
	"Comment": "returns a list of attributes and their ldap values found in ldap for the specified username.",
	"Method": "Map<String, String> getAttributes(String username){\r\n    Map<String, String> userAttributes = new HashMap();\r\n    username = JID.unescapeNode(username);\r\n    DirContext ctx = null;\r\n    try {\r\n        String userDN = manager.findUserDN(username);\r\n        Map<String, PropertyMapping> ldapMappings = getLdapAttributes();\r\n        Set<String> fields = new HashSet();\r\n        for (PropertyMapping mapping : ldapMappings.values()) {\r\n            fields.addAll(mapping.getFields());\r\n        }\r\n        fields.add(manager.getUsernameField());\r\n        ctx = manager.getContext(manager.getUsersBaseDN(username));\r\n        Attributes attrs = ctx.getAttributes(userDN, fields.toArray(new String[] {}));\r\n        for (Map.Entry<String, PropertyMapping> entry : ldapMappings.entrySet()) {\r\n            String attribute = entry.getKey();\r\n            PropertyMapping mapping = entry.getValue();\r\n            String value = mapping.getDisplayFormat();\r\n            for (String field : mapping.getFields()) {\r\n                Attribute ldapField = attrs.get(field);\r\n                if (ldapField != null) {\r\n                    String answer;\r\n                    Object ob = ldapField.get();\r\n                    if (ob instanceof String) {\r\n                        answer = (String) ob;\r\n                    } else {\r\n                        answer = Base64.encodeBytes((byte[]) ob);\r\n                    }\r\n                    value = value.replace(\"{\" + field + \"}\", answer);\r\n                }\r\n            }\r\n            userAttributes.put(attribute, value);\r\n        }\r\n    } catch (Exception e) {\r\n        Log.error(e.getMessage(), e);\r\n    } finally {\r\n        try {\r\n            if (ctx != null) {\r\n                ctx.close();\r\n            }\r\n        } catch (Exception ignored) {\r\n        }\r\n    }\r\n    return userAttributes;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.config.ConfigurationPropertiesBean.getLanguageNamespacesString",
	"Comment": "get the list of namespaces as a json string, for injection into the javascript ui",
	"Method": "String getLanguageNamespacesString(){\r\n    return new Gson().toJson(getLanguageNamespaces());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.setServerSessionTimeout",
	"Comment": "sets the number of milliseconds to elapse between clearing of idle server sessions.",
	"Method": "void setServerSessionTimeout(int timeout){\r\n    if (getServerSessionTimeout() == timeout) {\r\n        return;\r\n    }\r\n    JiveGlobals.setProperty(\"xmpp.server.session.timeout\", Integer.toString(timeout));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sip.tester.stack.SipCommRouter.getNextHops",
	"Comment": "return the default address to forward the request to. the list isorganized in the following priority.if the outboung proxy has been specified, then it is used to constructthe first element of the list.if the requesturi refers directly to a host, the host and portinformation are extracted from it and made the next hop on the list.",
	"Method": "ListIterator<Hop> getNextHops(Request sipRequest){\r\n    URI requestURI = sipRequest.getRequestURI();\r\n    if (requestURI == null) {\r\n        throw new IllegalArgumentException(\"Bad message: Null requestURI\");\r\n    }\r\n    LinkedList<Hop> hops = new LinkedList<Hop>();\r\n    if (outboundProxy != null) {\r\n        hops.add(outboundProxy);\r\n    }\r\n    ListIterator routes = sipRequest.getHeaders(RouteHeader.NAME);\r\n    if (routes != null && routes.hasNext()) {\r\n        while (routes.hasNext()) {\r\n            RouteHeader route = (RouteHeader) routes.next();\r\n            SipURI uri = (SipURI) route.getAddress().getURI();\r\n            int port = uri.getPort();\r\n            port = (port == -1) ? 5060 : port;\r\n            String host = uri.getHost();\r\n            Log.debug(\"getNextHops\", host);\r\n            String transport = uri.getTransportParam();\r\n            if (transport == null) {\r\n                transport = \"udp\";\r\n            }\r\n            Hop hop = new SipCommHop(host + ':' + port + '/' + transport);\r\n            hops.add(hop);\r\n        }\r\n    } else if (requestURI instanceof SipURI && ((SipURI) requestURI).getMAddrParam() != null) {\r\n        SipURI sipURI = ((SipURI) requestURI);\r\n        String maddr = sipURI.getMAddrParam();\r\n        String transport = sipURI.getTransportParam();\r\n        if (transport == null) {\r\n            transport = \"udp\";\r\n        }\r\n        int port = 5060;\r\n        Hop hop = new SipCommHop(maddr, port, transport);\r\n        hops.add(hop);\r\n    } else if (requestURI instanceof SipURI) {\r\n        SipURI sipURI = ((SipURI) requestURI);\r\n        int port = sipURI.getPort();\r\n        if (port == -1) {\r\n            port = 5060;\r\n        }\r\n        String host = sipURI.getHost();\r\n        String transport = sipURI.getTransportParam();\r\n        if (transport == null) {\r\n            transport = \"UDP\";\r\n        }\r\n        Hop hop = new SipCommHop(host + \":\" + port + \"/\" + transport);\r\n        hops.add(hop);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Malformed requestURI\");\r\n    }\r\n    return (hops.size() == 0) ? null : hops.listIterator();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapAuthorizationPolicy.getAuthorized",
	"Comment": "returns a string collection of principals that are authorized to usethe named user.",
	"Method": "Collection<String> getAuthorized(String username){\r\n    username = JID.unescapeNode(username);\r\n    Collection<String> authorized = new ArrayList();\r\n    DirContext ctx = null;\r\n    try {\r\n        String userDN = manager.findUserDN(username);\r\n        String[] attributes = new String[] { usernameField, authorizeField };\r\n        ctx = manager.getContext();\r\n        Attributes attrs = ctx.getAttributes(userDN, attributes);\r\n        Attribute authorizeField_a = attrs.get(authorizeField);\r\n        if (authorizeField_a != null) {\r\n            for (Enumeration e = authorizeField_a.getAll(); e.hasMoreElements(); ) {\r\n                authorized.add((String) e.nextElement());\r\n            }\r\n        }\r\n        return authorized;\r\n    } catch (Exception e) {\r\n    } finally {\r\n        try {\r\n            if (ctx != null) {\r\n                ctx.close();\r\n            }\r\n        } catch (Exception ignored) {\r\n        }\r\n    }\r\n    return authorized;\r\n}"
}, {
	"Path": "org.jivesoftware.util.XMLWriter.shouldEncodeChar",
	"Comment": "should the given character be escaped. this depends on theencoding of the document.",
	"Method": "boolean shouldEncodeChar(char c){\r\n    int max = getMaximumAllowedCharacter();\r\n    return max > 0 && c > max;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.rest.RESTServicePlugin.getCustomAuthFilterClassName",
	"Comment": "returns the custom authentication filter class name used in place of the basic ones to grant permission to use the rest services.",
	"Method": "String getCustomAuthFilterClassName(){\r\n    return customAuthFilterClassName;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.getLastActivity",
	"Comment": "returns the time in milliseconds since the epoch that this session was last active. activityis a request was either made or responded to. if the session is currently active, meaningthere are connections awaiting a response, the current time is returned.",
	"Method": "long getLastActivity(){\r\n    if (!connectionQueue.isEmpty()) {\r\n        synchronized (connectionQueue) {\r\n            for (HttpConnection connection : connectionQueue) {\r\n                if (!(connection.isClosed())) {\r\n                    lastActivity = System.currentTimeMillis();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return lastActivity;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.getBodyXSLT",
	"Comment": "returns the url of an xsl transformation which can be applied to payloads in orderto generate an appropriate message body element.",
	"Method": "String getBodyXSLT(){\r\n    return bodyXSLT;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.readLongIntMap",
	"Comment": "reads a map of long key and integer value pairs. this method will returnnull if the map written to the stream was null.",
	"Method": "Map<Long, Integer> readLongIntMap(DataInput in){\r\n    return strategy.readLongIntMap(in);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.PluginDownloadManager.updatePluginsList",
	"Comment": "updates the pluginlist from the server. please note, this method is used with javascript calls and will notbe found with a find usages.",
	"Method": "boolean updatePluginsList(){\r\n    UpdateManager updateManager = XMPPServer.getInstance().getUpdateManager();\r\n    try {\r\n        updateManager.checkForServerUpdate(true);\r\n        updateManager.checkForPluginsUpdates(true);\r\n        JiveGlobals.setProperty(\"update.lastCheck\", String.valueOf(System.currentTimeMillis()));\r\n        return true;\r\n    } catch (Exception e) {\r\n        Log.error(e.getMessage(), e);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.filetransfer.proxy.FileTransferProxy.getProxyPort",
	"Comment": "returns the port that the file transfer proxy is opertating on.",
	"Method": "int getProxyPort(){\r\n    return JiveGlobals.getIntProperty(JIVEPROPERTY_PORT, DEFAULT_PORT);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.MultiUserChatManager.getMultiUserChatServicesCount",
	"Comment": "retrieves the number of multiuserchatservices that are configured for this server.",
	"Method": "Integer getMultiUserChatServicesCount(){\r\n    return mucServices.size();\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.setServerURL",
	"Comment": "sets the jdbc connection url used to make database connections.",
	"Method": "void setServerURL(String serverURL){\r\n    this.serverURL = serverURL;\r\n    saveProperties();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.GroupManager.createGroup",
	"Comment": "factory method for creating a new group. a unique name is the only required field.",
	"Method": "Group createGroup(String name){\r\n    synchronized ((name + MUTEX_SUFFIX_GROUP).intern()) {\r\n        Group newGroup;\r\n        try {\r\n            getGroup(name);\r\n            throw new GroupAlreadyExistsException();\r\n        } catch (GroupNotFoundException unfe) {\r\n            newGroup = provider.createGroup(name);\r\n            groupCache.put(name, newGroup);\r\n            GroupEventDispatcher.dispatchEvent(newGroup, GroupEventDispatcher.EventType.group_created, Collections.emptyMap());\r\n        }\r\n        return newGroup;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getAuditManager",
	"Comment": "returns the auditmanager registered with this server. theauditmanager was registered with the server as a module while starting upthe server.",
	"Method": "AuditManager getAuditManager(){\r\n    return (AuditManager) modules.get(AuditManagerImpl.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.isFollowReferralsEnabled",
	"Comment": "returns true if ldap referrals will automatically be followed when found.",
	"Method": "boolean isFollowReferralsEnabled(){\r\n    return followReferrals;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.writeStrings",
	"Comment": "writes content of collection of strings to the output stream.",
	"Method": "void writeStrings(DataOutput out,Collection<String> collection){\r\n    strategy.writeStrings(out, collection);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.GroupManager.getPublicSharedGroups",
	"Comment": "returns an unmodifiable collection of all public shared groups in the system.",
	"Method": "Collection<Group> getPublicSharedGroups(){\r\n    HashSet<String> groupNames = getPublicGroupsFromCache();\r\n    if (groupNames == null) {\r\n        synchronized (PUBLIC_GROUPS) {\r\n            groupNames = getPublicGroupsFromCache();\r\n            if (groupNames == null) {\r\n                groupNames = new HashSet(provider.getPublicSharedGroupNames());\r\n                savePublicGroupsInCache(groupNames);\r\n            }\r\n        }\r\n    }\r\n    return new GroupCollection(groupNames);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.commands.AdHocCommandManager.getCommand",
	"Comment": "returns the command whose code matches the specified code or null if nonewas found.",
	"Method": "AdHocCommand getCommand(String code){\r\n    return commands.get(code);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getDefaultNodeID",
	"Comment": "returns the default node id used by this server before clustering isinitialized.",
	"Method": "NodeID getDefaultNodeID(){\r\n    return DEFAULT_NODE_ID;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginManager.removePluginManagerListener",
	"Comment": "deregisters a pluginmanagerlistener, which will no longer receive events.when the listener was never added, this method will have no effect.",
	"Method": "void removePluginManagerListener(PluginManagerListener listener){\r\n    pluginManagerListeners.remove(listener);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getIQDiscoItemsHandler",
	"Comment": "returns the iqdiscoitemshandler registered with this server. theiqdiscoitemshandler was registered with the server as a module while starting upthe server.",
	"Method": "IQDiscoItemsHandler getIQDiscoItemsHandler(){\r\n    return (IQDiscoItemsHandler) modules.get(IQDiscoItemsHandler.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginServlet.unregisterServlet",
	"Comment": "unregister a live servlet for a plugin programmatically. does not callthe servlet destroy method.",
	"Method": "GenericServlet unregisterServlet(Plugin plugin,String url){\r\n    String pluginName = pluginManager.getPluginPath(plugin).getFileName().toString();\r\n    if (url == null) {\r\n        throw new ServletException(\"Servlet URL is missing\");\r\n    }\r\n    String fullUrl = pluginName + url;\r\n    return servlets.remove(fullUrl.toLowerCase());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.LocalMUCRoom.getLockedDate",
	"Comment": "returns the date when the room was locked. initially when the room is created it is locked sothe locked date is the creation date of the room. afterwards, the room may be manuallylocked and unlocked so the locked date may be in these cases different than the creationdate. when the room is unlocked a date with time 0 is returned.",
	"Method": "Date getLockedDate(){\r\n    return new Date(lockedTime);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.UserServicePlugin.isEnabled",
	"Comment": "returns true if the user service is enabled. if not enabled, it will notaccept requests to create new accounts.",
	"Method": "boolean isEnabled(){\r\n    return enabled;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PubSubPersistenceManager.loadDefaultConfiguration",
	"Comment": "loads from the database the default node configuration for the specified node typeand pubsub service.",
	"Method": "DefaultNodeConfiguration loadDefaultConfiguration(PubSubService service,boolean isLeafType){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    DefaultNodeConfiguration config = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(LOAD_DEFAULT_CONF);\r\n        pstmt.setString(1, service.getServiceID());\r\n        pstmt.setInt(2, (isLeafType ? 1 : 0));\r\n        rs = pstmt.executeQuery();\r\n        if (rs.next()) {\r\n            config = new DefaultNodeConfiguration(isLeafType);\r\n            config.setDeliverPayloads(rs.getInt(1) == 1);\r\n            config.setMaxPayloadSize(rs.getInt(2));\r\n            config.setPersistPublishedItems(rs.getInt(3) == 1);\r\n            config.setMaxPublishedItems(rs.getInt(4));\r\n            config.setNotifyConfigChanges(rs.getInt(5) == 1);\r\n            config.setNotifyDelete(rs.getInt(6) == 1);\r\n            config.setNotifyRetract(rs.getInt(7) == 1);\r\n            config.setPresenceBasedDelivery(rs.getInt(8) == 1);\r\n            config.setSendItemSubscribe(rs.getInt(9) == 1);\r\n            config.setPublisherModel(PublisherModel.valueOf(rs.getString(10)));\r\n            config.setSubscriptionEnabled(rs.getInt(11) == 1);\r\n            config.setAccessModel(AccessModel.valueOf(rs.getString(12)));\r\n            config.setLanguage(rs.getString(13));\r\n            if (rs.getString(14) != null) {\r\n                config.setReplyPolicy(Node.ItemReplyPolicy.valueOf(rs.getString(14)));\r\n            }\r\n            config.setAssociationPolicy(CollectionNode.LeafNodeAssociationPolicy.valueOf(rs.getString(15)));\r\n            config.setMaxLeafNodes(rs.getInt(16));\r\n        }\r\n    } catch (Exception sqle) {\r\n        log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    return config;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PubSubPersistenceManager.removeAffiliation",
	"Comment": "removes the affiliation and subsription state of the user from the db.",
	"Method": "void removeAffiliation(Node node,NodeAffiliate affiliate){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(DELETE_AFFILIATION);\r\n        pstmt.setString(1, node.getService().getServiceID());\r\n        pstmt.setString(2, encodeNodeID(node.getNodeID()));\r\n        pstmt.setString(3, affiliate.getJID().toString());\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException sqle) {\r\n        log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.security.DefaultSecurityAuditProvider.isWriteOnly",
	"Comment": "the default provider writes logs into a local openfire database.",
	"Method": "boolean isWriteOnly(){\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MultiUserChatServiceImpl.isAllowToDiscoverLockedRooms",
	"Comment": "returns the flag that indicates if the service should provide information about locked roomswhen handling service discovery requests.",
	"Method": "boolean isAllowToDiscoverLockedRooms(){\r\n    return allowToDiscoverLockedRooms;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.commands.AdHocCommandManager.getCommands",
	"Comment": "returns a list with the available commands in this command manager.",
	"Method": "Collection<AdHocCommand> getCommands(){\r\n    return commands.values();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.getContext",
	"Comment": "returns a dircontext for the ldap server that can be used to performlookups and searches using the specified base dn. the context uses theadmin login that is defined by admindn and adminpassword.",
	"Method": "LdapContext getContext(LdapContext getContext,String baseDN){\r\n    boolean debug = Log.isDebugEnabled();\r\n    if (debug) {\r\n        Log.debug(\"LdapManager: Creating a DirContext in LdapManager.getContext()...\");\r\n        if (!sslEnabled && !startTlsEnabled) {\r\n            Log.debug(\"LdapManager: Warning: Using unencrypted connection to LDAP service!\");\r\n        }\r\n    }\r\n    Hashtable<String, Object> env = new Hashtable();\r\n    env.put(Context.INITIAL_CONTEXT_FACTORY, initialContextFactory);\r\n    env.put(Context.PROVIDER_URL, getProviderURL(baseDN));\r\n    if (sslEnabled) {\r\n        env.put(\"java.naming.ldap.factory.socket\", \"org.jivesoftware.util.SimpleSSLSocketFactory\");\r\n        env.put(Context.SECURITY_PROTOCOL, \"ssl\");\r\n    }\r\n    if (adminDN != null) {\r\n        if (!(startTlsEnabled && !sslEnabled)) {\r\n            env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\r\n            env.put(Context.SECURITY_PRINCIPAL, adminDN);\r\n            if (adminPassword != null) {\r\n                env.put(Context.SECURITY_CREDENTIALS, adminPassword);\r\n            }\r\n        }\r\n    } else {\r\n        env.put(Context.SECURITY_AUTHENTICATION, \"none\");\r\n    }\r\n    if (ldapDebugEnabled) {\r\n        env.put(\"com.sun.jndi.ldap.trace.ber\", System.err);\r\n    }\r\n    if (connectionPoolEnabled) {\r\n        if (!startTlsEnabled) {\r\n            env.put(\"com.sun.jndi.ldap.connect.pool\", \"true\");\r\n            System.setProperty(\"com.sun.jndi.ldap.connect.pool.protocol\", \"plain ssl\");\r\n        } else {\r\n            if (debug) {\r\n                Log.debug(\"LdapManager: connection pooling was requested but has been disabled because of StartTLS.\");\r\n            }\r\n            env.put(\"com.sun.jndi.ldap.connect.pool\", \"false\");\r\n        }\r\n    } else {\r\n        env.put(\"com.sun.jndi.ldap.connect.pool\", \"false\");\r\n    }\r\n    if (connTimeout > 0) {\r\n        env.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(connTimeout));\r\n    } else {\r\n        env.put(\"com.sun.jndi.ldap.connect.timeout\", \"10000\");\r\n    }\r\n    if (readTimeout > 0) {\r\n        env.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(readTimeout));\r\n    }\r\n    if (followReferrals) {\r\n        env.put(Context.REFERRAL, \"follow\");\r\n    }\r\n    if (!followAliasReferrals) {\r\n        env.put(\"java.naming.ldap.derefAliases\", \"never\");\r\n    }\r\n    if (debug) {\r\n        Log.debug(\"LdapManager: Created hashtable with context values, attempting to create context...\");\r\n    }\r\n    JiveInitialLdapContext context = new JiveInitialLdapContext(env, null);\r\n    if (startTlsEnabled && !sslEnabled) {\r\n        if (debug) {\r\n            Log.debug(\"LdapManager: ... StartTlsRequest\");\r\n        }\r\n        if (followReferrals) {\r\n            Log.warn(\"\\tConnections to referrals are unencrypted! If you do not want this, please turn off ldap.autoFollowReferrals\");\r\n        }\r\n        StartTlsResponse tls = (StartTlsResponse) context.extendedOperation(new StartTlsRequest());\r\n        try {\r\n            SSLSession session = tls.negotiate(new org.jivesoftware.util.SimpleSSLSocketFactory());\r\n            context.setTlsResponse(tls);\r\n            context.setSslSession(session);\r\n            if (debug) {\r\n                Log.debug(\"LdapManager: ... peer host: \" + session.getPeerHost() + \", CipherSuite: \" + session.getCipherSuite());\r\n            }\r\n            if (adminDN != null) {\r\n                context.addToEnvironment(Context.SECURITY_AUTHENTICATION, \"simple\");\r\n                context.addToEnvironment(Context.SECURITY_PRINCIPAL, adminDN);\r\n                if (adminPassword != null) {\r\n                    context.addToEnvironment(Context.SECURITY_CREDENTIALS, adminPassword);\r\n                }\r\n            }\r\n        } catch (java.io.IOException ex) {\r\n            Log.error(ex.getMessage(), ex);\r\n        }\r\n    }\r\n    if (debug) {\r\n        Log.debug(\"LdapManager: ... context created successfully, returning.\");\r\n    }\r\n    return context;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.getDescription",
	"Comment": "returns the description of the node. this information is really optional and can bemodified by submiting a completed data form with the new node configuration.",
	"Method": "String getDescription(){\r\n    return description;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginMetadataHelper.getLicense",
	"Comment": "returns the license agreement type that the plugin is governed by. the value is retrieved from the plugin.xmlfile of the plugin.",
	"Method": "String getLicense(Plugin plugin,String getLicense,Path pluginDir){\r\n    return getElementValue(pluginDir, \"/plugin/licenseType\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.getAssociationPolicy",
	"Comment": "returns the policy that defines who may associate leaf nodes with a collection.",
	"Method": "CollectionNode.LeafNodeAssociationPolicy getAssociationPolicy(){\r\n    return associationPolicy;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.UpdateManager.getNotificationMessage",
	"Comment": "returns the message to send to admins when new updates are available. when sendingthis message information about the new updates avaiable will be appended.",
	"Method": "String getNotificationMessage(){\r\n    return LocaleUtils.getLocalizedString(\"update.notification-message\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.OfflineMessageStore.addMessage",
	"Comment": "adds a message to this message store. messages will be stored and madeavailable for later delivery.",
	"Method": "void addMessage(Message message){\r\n    if (message == null) {\r\n        return;\r\n    }\r\n    if (!shouldStoreMessage(message)) {\r\n        return;\r\n    }\r\n    JID recipient = message.getTo();\r\n    String username = recipient.getNode();\r\n    if (username == null || !UserManager.getInstance().isRegisteredUser(recipient)) {\r\n        return;\r\n    } else if (!XMPPServer.getInstance().getServerInfo().getXMPPDomain().equals(recipient.getDomain())) {\r\n        return;\r\n    }\r\n    long messageID = SequenceManager.nextID(JiveConstants.OFFLINE);\r\n    String msgXML = message.getElement().asXML();\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(INSERT_OFFLINE);\r\n        pstmt.setString(1, username);\r\n        pstmt.setLong(2, messageID);\r\n        pstmt.setString(3, StringUtils.dateToMillis(new java.util.Date()));\r\n        pstmt.setInt(4, msgXML.length());\r\n        pstmt.setString(5, msgXML);\r\n        pstmt.executeUpdate();\r\n    } catch (Exception e) {\r\n        Log.error(LocaleUtils.getLocalizedString(\"admin.error\"), e);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n    if (sizeCache.containsKey(username)) {\r\n        int size = sizeCache.get(username);\r\n        size += msgXML.length();\r\n        sizeCache.put(username, size);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.setTestBeforeUse",
	"Comment": "sets whether connections will be tested before being handed over to be used.",
	"Method": "void setTestBeforeUse(Boolean testBeforeUse){\r\n    this.testBeforeUse = testBeforeUse;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.LeafNode.isSendItemSubscribe",
	"Comment": "returns true if the last published item is going to be sent to new subscribers.",
	"Method": "boolean isSendItemSubscribe(){\r\n    return sendItemSubscribe;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SocketConnection.checkHealth",
	"Comment": "returns true if the socket was closed due to a bad health. the socket is considered tobe in a bad state if a thread has been writing for a while and the write operation hasnot finished in a long time or when the client has not sent a heartbeat for a long time.in any of both cases the socket will be closed.",
	"Method": "boolean checkHealth(){\r\n    long writeTimestamp = writeStarted;\r\n    if (writeTimestamp > -1 && System.currentTimeMillis() - writeTimestamp > JiveGlobals.getIntProperty(\"xmpp.session.sending-limit\", 60000)) {\r\n        if (Log.isDebugEnabled()) {\r\n            Log.debug(\"Closing connection: \" + this + \" that started sending data at: \" + new Date(writeTimestamp));\r\n        }\r\n        forceClose();\r\n        return true;\r\n    } else {\r\n        if (idleTimeout > -1 && socketReader != null && System.currentTimeMillis() - socketReader.getLastActive() > idleTimeout) {\r\n            if (Log.isDebugEnabled()) {\r\n                Log.debug(\"Closing connection that has been idle: \" + this);\r\n            }\r\n            forceClose();\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.isDebugEnabled",
	"Comment": "returns true if ldap connection debugging is turned on. when on, traceinformation about ber buffers sent and received by the ldap provider iswritten to system.out. debugging is turned off by default.",
	"Method": "boolean isDebugEnabled(){\r\n    return ldapDebugEnabled;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getFileTransferProxy",
	"Comment": "returns the filetransferproxy registered with this server. thefiletransferproxy was registered with the server as a module while starting upthe server.",
	"Method": "FileTransferProxy getFileTransferProxy(){\r\n    return (FileTransferProxy) modules.get(FileTransferProxy.class);\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheSizes.sizeOfCollection",
	"Comment": "returns the size in bytes of a collection object. elements are assumed to bestrings, longs or cacheable objects.",
	"Method": "int sizeOfCollection(Collection list){\r\n    if (list == null) {\r\n        return 0;\r\n    }\r\n    int size = 36;\r\n    Object[] values = list.toArray();\r\n    for (int i = 0; i < values.length; i++) {\r\n        size += sizeOfAnything(values[i]);\r\n    }\r\n    return size;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.config.JsonMessageSource.getValue",
	"Comment": "get a value from the set of maps, taking the first match in order",
	"Method": "String getValue(String code,List<JsonObject> langs,String getValue,String code,JsonObject lang){\r\n    if (lang == null) {\r\n        return null;\r\n    }\r\n    JsonElement e = lang;\r\n    Iterable<String> parts = Splitter.on('.').split(code);\r\n    Iterator<String> it = parts.iterator();\r\n    String value = null;\r\n    while (it.hasNext()) {\r\n        String p = it.next();\r\n        if (e.isJsonObject()) {\r\n            JsonObject o = e.getAsJsonObject();\r\n            if (o.has(p)) {\r\n                e = o.get(p);\r\n                if (!it.hasNext()) {\r\n                    if (e.isJsonPrimitive()) {\r\n                        value = e.getAsString();\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.getAccessModel",
	"Comment": "returns the access model that specifies who is allowed to subscribe and retrieve items.",
	"Method": "AccessModel getAccessModel(){\r\n    return accessModel;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getNodeID",
	"Comment": "returns an id that uniquely identifies this server in a cluster. when not running in cluster modethe returned value is always the same. however, when in cluster mode the value should be setwhen joining the cluster and must be unique even upon restarts of this node.",
	"Method": "NodeID getNodeID(){\r\n    return nodeID == null ? DEFAULT_NODE_ID : nodeID;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sasl.ScramSha1SaslServer.getStoredKey",
	"Comment": "retrieve the stored key from the database for a given username.",
	"Method": "byte[] getStoredKey(String username){\r\n    final String storedKey = AuthFactory.getStoredKey(username);\r\n    if (storedKey == null) {\r\n        return null;\r\n    } else {\r\n        return DatatypeConverter.parseBase64Binary(storedKey);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sasl.JiveSharedSecretSaslServer.isSharedSecretAllowed",
	"Comment": "returns true if shared secret authentication is enabled. shared secret authentication creates an anonymoussession, but requires that the authenticating entity know a shared secret key. the client sends a digest of thesecret key, which is compared against a digest of the local shared key.",
	"Method": "boolean isSharedSecretAllowed(){\r\n    return JiveGlobals.getBooleanProperty(\"xmpp.auth.sharedSecretEnabled\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.removeOutcast",
	"Comment": "removes the banning to subscribe to the node for the specified entity.",
	"Method": "void removeOutcast(JID jid){\r\n    removeAffiliation(jid, NodeAffiliate.Affiliation.outcast);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.isLeaf",
	"Comment": "returns true if this default configutation belongs to a leaf node.",
	"Method": "boolean isLeaf(){\r\n    return leaf;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PubSubEngine.getPublishOptions",
	"Comment": "get the dataform that describes the publish options from the request, or null if no such form was included.",
	"Method": "DataForm getPublishOptions(IQ iq){\r\n    final Element publishOptionsElement = iq.getChildElement().element(\"publish-options\");\r\n    if (publishOptionsElement == null) {\r\n        return null;\r\n    }\r\n    final Element x = publishOptionsElement.element(QName.get(DataForm.ELEMENT_NAME, DataForm.NAMESPACE));\r\n    if (x == null) {\r\n        return null;\r\n    }\r\n    final DataForm result = new DataForm(x);\r\n    if (result.getType() != DataForm.Type.submit) {\r\n        return null;\r\n    }\r\n    final FormField formType = result.getField(\"FORM_TYPE\");\r\n    if (formType == null || !\"http://jabber.org/protocol/pubsub#publish-options\".equals(formType.getFirstValue())) {\r\n        return null;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.MUCRoomHistory.addOldMessage",
	"Comment": "creates a new message and adds it to the history. the new message will be created based onthe provided information. this information will likely come from the database when loadingthe room history from the database.",
	"Method": "void addOldMessage(String senderJID,String nickname,Date sentDate,String subject,String body,String stanza){\r\n    Message message = new Message();\r\n    message.setType(Message.Type.groupchat);\r\n    if (stanza != null) {\r\n        SAXReader xmlReader = new SAXReader();\r\n        xmlReader.setEncoding(\"UTF-8\");\r\n        try {\r\n            Element element = xmlReader.read(new StringReader(stanza)).getRootElement();\r\n            for (Element child : (List<Element>) element.elements()) {\r\n                Namespace ns = child.getNamespace();\r\n                if (ns == null || ns.getURI().equals(\"jabber:client\") || ns.getURI().equals(\"jabber:server\")) {\r\n                    continue;\r\n                }\r\n                Element added = message.addChildElement(child.getName(), child.getNamespaceURI());\r\n                if (!child.getText().isEmpty()) {\r\n                    added.setText(child.getText());\r\n                }\r\n                for (Attribute attr : (List<Attribute>) child.attributes()) {\r\n                    added.addAttribute(attr.getQName(), attr.getValue());\r\n                }\r\n                for (Element el : (List<Element>) child.elements()) {\r\n                    added.add(el.createCopy());\r\n                }\r\n            }\r\n            if (element.attribute(\"id\") != null) {\r\n                message.setID(element.attributeValue(\"id\"));\r\n            }\r\n        } catch (Exception ex) {\r\n            Log.error(\"Failed to parse payload XML\", ex);\r\n        }\r\n    }\r\n    message.setSubject(subject);\r\n    message.setBody(body);\r\n    if (nickname != null && nickname.trim().length() > 0) {\r\n        JID roomJID = room.getRole().getRoleAddress();\r\n        message.setFrom(new JID(roomJID.getNode(), roomJID.getDomain(), nickname, true));\r\n    } else {\r\n        message.setFrom(room.getRole().getRoleAddress());\r\n    }\r\n    Element delayInformation = message.addChildElement(\"delay\", \"urn:xmpp:delay\");\r\n    delayInformation.addAttribute(\"stamp\", XMPPDateTimeFormat.format(sentDate));\r\n    if (room.canAnyoneDiscoverJID()) {\r\n        delayInformation.addAttribute(\"from\", senderJID);\r\n    } else {\r\n        delayInformation.addAttribute(\"from\", room.getRole().getRoleAddress().toString());\r\n    }\r\n    historyStrategy.addMessage(message);\r\n}"
}, {
	"Path": "org.jivesoftware.util.StringUtils.isValidEmailAddress",
	"Comment": "returns true if the string passed in is a valid email address.",
	"Method": "boolean isValidEmailAddress(String address){\r\n    if (address == null) {\r\n        return false;\r\n    }\r\n    if (!address.contains(\"@\")) {\r\n        return false;\r\n    }\r\n    try {\r\n        InternetAddress.parse(address);\r\n        return true;\r\n    } catch (AddressException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.PresenceEventDispatcher.subscribedToPresence",
	"Comment": "notification message indicating that a user has successfully subscribedto the presence of another user.",
	"Method": "void subscribedToPresence(JID subscriberJID,JID authorizerJID){\r\n    if (!listeners.isEmpty()) {\r\n        for (PresenceEventListener listener : listeners) {\r\n            listener.subscribedToPresence(subscriberJID, authorizerJID);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.audit.SessionEvent.createAuthSuccessEvent",
	"Comment": "create an event associated with a successful authentication.",
	"Method": "SessionEvent createAuthSuccessEvent(Session session){\r\n    return new SessionEvent(session, SESSION_AUTH_SUCCESS, null);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.commands.admin.PacketsNotification.hasPermission",
	"Comment": "returns if the requester can access this command. only components are allowed toexecute this command.",
	"Method": "boolean hasPermission(JID requester){\r\n    return InternalComponentManager.getInstance().hasComponent(requester);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.broadcast",
	"Comment": "broadcasts the given data to all connected sessions. excellentfor server administration messages.",
	"Method": "void broadcast(Message packet){\r\n    routingTable.broadcastPacket(packet, false);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.isOtherResourcePresenceEnabled",
	"Comment": "returns true if the session should broadcast presences to all other resources for thecurrent client. when disabled it is not possible to broadcast presence packets to anotherresource of the connected user. this is desirable if you have a use case where you havemany resources attached to the same user account.",
	"Method": "boolean isOtherResourcePresenceEnabled(){\r\n    return JiveGlobals.getBooleanProperty(\"xmpp.client.other-resource.presence\", true);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.User.getEmail",
	"Comment": "returns the email address of the user or null if none is defined.",
	"Method": "String getEmail(){\r\n    return email;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.LocalRoutingTable.getRoute",
	"Comment": "returns the route hosted by this node that is associated to the specified address.",
	"Method": "RoutableChannelHandler getRoute(DomainPair pair,RoutableChannelHandler getRoute,JID jid){\r\n    return routes.get(new DomainPair(\"\", jid.toString()));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.ServerTrafficCounter.wrapReadableChannel",
	"Comment": "wraps the specified readable channel to count the number of bytes that were read.",
	"Method": "ReadableByteChannel wrapReadableChannel(ReadableByteChannel originalChannel){\r\n    return new ReadableByteChannelWrapper(originalChannel);\r\n}"
}, {
	"Path": "org.jivesoftware.util.LinkedList.addLast",
	"Comment": "adds an object to the end of the list by automatically creating aa new node and adding it to the end of the list.",
	"Method": "LinkedListNode<E> addLast(LinkedListNode<E> node,LinkedListNode<E> addLast,E object){\r\n    return new LinkedListNode(object, head, head.previous);\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveProperties.getPropertyNames",
	"Comment": "returns all property names as a collection of string values.",
	"Method": "Collection<String> getPropertyNames(){\r\n    return properties.keySet();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sip.tester.security.SipSecurityManager.setSipManCallback",
	"Comment": "if the user name was wrong and the user fixes it here we should alsnotify the sip manager that the currentlyuseduri it has is not valid.",
	"Method": "void setSipManCallback(SipManager sipManCallback){\r\n    this.sipManCallback = sipManCallback;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.isCollectionNode",
	"Comment": "returns true if this node is a node container. node containers may only contain nodesbut are not allowed to get items published.",
	"Method": "boolean isCollectionNode(){\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getPreAuthenticatedKeys",
	"Comment": "returns the temporary keys used by the sessions that has not been authenticated yet. thisis an utility method useful for debugging situations.",
	"Method": "Collection<String> getPreAuthenticatedKeys(){\r\n    return localSessionManager.getPreAuthenticatedSessions().keySet();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.ConnectionListener.getCompressionPolicy",
	"Comment": "returns whether compression is optional or disabled for new connections.",
	"Method": "Connection.CompressionPolicy getCompressionPolicy(){\r\n    final Connection.CompressionPolicy defaultPolicy;\r\n    switch(getType()) {\r\n        case COMPONENT:\r\n        case CONNECTION_MANAGER:\r\n        case SOCKET_S2S:\r\n            defaultPolicy = Connection.CompressionPolicy.disabled;\r\n            break;\r\n        case SOCKET_C2S:\r\n        case BOSH_C2S:\r\n        case WEBADMIN:\r\n        default:\r\n            defaultPolicy = Connection.CompressionPolicy.optional;\r\n            break;\r\n    }\r\n    if (compressionPolicyPropertyName == null) {\r\n        return defaultPolicy;\r\n    } else {\r\n        final String policyName = JiveGlobals.getProperty(compressionPolicyPropertyName, defaultPolicy.toString());\r\n        try {\r\n            return Connection.CompressionPolicy.valueOf(policyName);\r\n        } catch (IllegalArgumentException e) {\r\n            Log.error(\"Error parsing property value of '{}' into a valid Compression Policy. Offending value: '{}'.\", tlsPolicyPropertyName, policyName, e);\r\n            return defaultPolicy;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.view.UserInfoView.toJsonFromRequestObj",
	"Comment": "build a json response according to the request object received.\tclaims requested in requestobj.userinfo.claims are added to any\tclaims corresponding to requested scopes, if any.",
	"Method": "JsonObject toJsonFromRequestObj(UserInfo ui,Set<String> scope,JsonObject authorizedClaims,JsonObject requestedClaims){\r\n    JsonObject obj = ui.toJson();\r\n    Set<String> allowedByScope = translator.getClaimsForScopeSet(scope);\r\n    Set<String> authorizedByClaims = extractUserInfoClaimsIntoSet(authorizedClaims);\r\n    Set<String> requestedByClaims = extractUserInfoClaimsIntoSet(requestedClaims);\r\n    JsonObject result = new JsonObject();\r\n    for (Entry<String, JsonElement> entry : obj.entrySet()) {\r\n        if (allowedByScope.contains(entry.getKey()) || authorizedByClaims.contains(entry.getKey())) {\r\n            if (requestedByClaims.isEmpty() || requestedByClaims.contains(entry.getKey())) {\r\n                result.add(entry.getKey(), entry.getValue());\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.database.DbConnectionManager.getConnectionProvider",
	"Comment": "returns the current connection provider. the only case in which thismethod should be called is if more information about the currentconnection provider is needed. database connections should always beobtained by calling the getconnection method of this class.",
	"Method": "ConnectionProvider getConnectionProvider(){\r\n    return connectionProvider;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.launcher.GraphicUtils.focusComponentOrChild",
	"Comment": "puts the focus on the first component in the tree of c thatcan accept the focus.",
	"Method": "Component focusComponentOrChild(Component c,Component focusComponentOrChild,Component c,boolean deepest){\r\n    final Component focusable = getFocusableComponentOrChild(c, deepest);\r\n    if (focusable != null) {\r\n        focusable.requestFocus();\r\n    }\r\n    return focusable;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sip.calllog.CallLogDAO.read",
	"Comment": "read a calllog result set and return a calllog instance with the information of the resultset",
	"Method": "CallLog read(ResultSet rs){\r\n    CallLog callLog = null;\r\n    try {\r\n        String username = rs.getString(\"username\");\r\n        String numA = rs.getString(\"addressFrom\");\r\n        String numB = rs.getString(\"addressTo\");\r\n        long dateTime = rs.getLong(\"datetime\");\r\n        int duration = rs.getInt(\"duration\");\r\n        String callType = rs.getString(\"calltype\");\r\n        if (\"loss\".equals(callType)) {\r\n            callType = \"missed\";\r\n        }\r\n        CallLog.Type type = CallLog.Type.valueOf(callType);\r\n        callLog = new CallLog(username);\r\n        callLog.setNumA(numA);\r\n        callLog.setNumB(numB);\r\n        callLog.setDateTime(dateTime);\r\n        callLog.setDuration(duration);\r\n        callLog.setType(type);\r\n    } catch (SQLException e) {\r\n        Log.error(e.getMessage(), e);\r\n    }\r\n    return callLog;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpBindManager.isHttpBindActive",
	"Comment": "returns true if a listener on the http binding port is running.",
	"Method": "boolean isHttpBindActive(){\r\n    if (isHttpBindEnabled()) {\r\n        final int configuredPort = getHttpBindUnsecurePort();\r\n        for (final Connector connector : httpBindServer.getConnectors()) {\r\n            if (!(connector instanceof ServerConnector)) {\r\n                continue;\r\n            }\r\n            final int activePort = ((ServerConnector) connector).getLocalPort();\r\n            if (activePort == configuredPort) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.rest.RESTServicePlugin.getSecret",
	"Comment": "returns the secret key that only valid requests should know.",
	"Method": "String getSecret(){\r\n    return secret;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.ConnectionListener.getType",
	"Comment": "returns the type of connection that is accepted by this listener.",
	"Method": "ConnectionType getType(){\r\n    return type;\r\n}"
}, {
	"Path": "org.jivesoftware.admin.SidebarTag.getCss",
	"Comment": "returns the value of the css class to be used for tab decoration. if not set will return a blank string.",
	"Method": "String getCss(){\r\n    return clean(css);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.HistoryStrategy.setMaxNumber",
	"Comment": "set the maximum number of messages for strategies using message number limitations.",
	"Method": "void setMaxNumber(int max){\r\n    if (maxNumber == max) {\r\n        return;\r\n    }\r\n    this.maxNumber = max;\r\n    if (contextPrefix != null) {\r\n        MUCPersistenceManager.setProperty(contextSubdomain, contextPrefix + \".maxNumber\", Integer.toString(maxNumber));\r\n    }\r\n    if (parent == null) {\r\n        CacheFactory.doClusterTask(new UpdateHistoryStrategy(contextSubdomain, this));\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.security.SecurityAuditEvent.getNode",
	"Comment": "retrieves the node that triggered the event, usually a hostname or ip address.",
	"Method": "String getNode(){\r\n    return node;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterItem.getInvisibleSharedGroups",
	"Comment": "returns the invisible shared groups for the item. these groups are for internal useand help track the reason why a roster item has a presence subscription of type fromwhen using shared groups.",
	"Method": "Collection<Group> getInvisibleSharedGroups(){\r\n    Collection<Group> groups = new ArrayList(invisibleSharedGroups.size());\r\n    for (String groupName : invisibleSharedGroups) {\r\n        try {\r\n            groups.add(GroupManager.getInstance().getGroup(groupName));\r\n        } catch (GroupNotFoundException e) {\r\n        }\r\n    }\r\n    return groups;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.security.SecurityAuditManager.getEvent",
	"Comment": "retrieves a specific event by id in the form of a securityauditevent.",
	"Method": "SecurityAuditEvent getEvent(Integer msgID){\r\n    if (provider.isWriteOnly()) {\r\n        throw new AuditWriteOnlyException();\r\n    }\r\n    return provider.getEvent(msgID);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.auth.AuthFactory.authenticate",
	"Comment": "authenticates a user with a username and plain text password and returns andauthtoken. if the username and password do not match the record ofany user in the system, this method throws an unauthorizedexception.",
	"Method": "AuthToken authenticate(String username,String password){\r\n    if (LockOutManager.getInstance().isAccountDisabled(username)) {\r\n        LockOutManager.getInstance().recordFailedLogin(username);\r\n        throw new UnauthorizedException();\r\n    }\r\n    authProvider.authenticate(username, password);\r\n    return AuthToken.generateUserToken(username);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.isAuthorizationPending",
	"Comment": "returns true if the subscription needs to be approved by a node owner to becomeactive. until the subscription is not activated the subscriber will not receiveevent notifications.",
	"Method": "boolean isAuthorizationPending(){\r\n    return state == State.pending;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterItem.isShared",
	"Comment": "returns true if this item belongs to a shared group. return true even if the item belongsto a personal group and a shared group.",
	"Method": "boolean isShared(){\r\n    return !sharedGroups.isEmpty() || !invisibleSharedGroups.isEmpty();\r\n}"
}, {
	"Path": "org.mitre.openid.connect.web.ProtectedResourceRegistrationEndpoint.registerNewProtectedResource",
	"Comment": "create a new client, issue a client id, and create a registration access token.",
	"Method": "String registerNewProtectedResource(String jsonString,Model m){\r\n    ClientDetailsEntity newClient = null;\r\n    try {\r\n        newClient = ClientDetailsEntityJsonProcessor.parse(jsonString);\r\n    } catch (JsonSyntaxException e) {\r\n        logger.error(\"registerNewProtectedResource failed; submitted JSON is malformed\");\r\n        m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\r\n        return HttpCodeView.VIEWNAME;\r\n    }\r\n    if (newClient != null) {\r\n        newClient.setClientId(null);\r\n        newClient.setClientSecret(null);\r\n        try {\r\n            newClient = validateScopes(newClient);\r\n            newClient = validateAuth(newClient);\r\n        } catch (ValidationException ve) {\r\n            m.addAttribute(JsonErrorView.ERROR, ve.getError());\r\n            m.addAttribute(JsonErrorView.ERROR_MESSAGE, ve.getErrorDescription());\r\n            m.addAttribute(HttpCodeView.CODE, ve.getStatus());\r\n            return JsonErrorView.VIEWNAME;\r\n        }\r\n        newClient.setGrantTypes(new HashSet<String>());\r\n        newClient.setResponseTypes(new HashSet<String>());\r\n        newClient.setRedirectUris(new HashSet<String>());\r\n        newClient.setAccessTokenValiditySeconds(0);\r\n        newClient.setIdTokenValiditySeconds(0);\r\n        newClient.setRefreshTokenValiditySeconds(0);\r\n        newClient.setDefaultACRvalues(new HashSet<String>());\r\n        newClient.setDefaultMaxAge(null);\r\n        newClient.setIdTokenEncryptedResponseAlg(null);\r\n        newClient.setIdTokenEncryptedResponseEnc(null);\r\n        newClient.setIdTokenSignedResponseAlg(null);\r\n        newClient.setInitiateLoginUri(null);\r\n        newClient.setPostLogoutRedirectUris(null);\r\n        newClient.setRequestObjectSigningAlg(null);\r\n        newClient.setRequireAuthTime(null);\r\n        newClient.setReuseRefreshToken(false);\r\n        newClient.setSectorIdentifierUri(null);\r\n        newClient.setSubjectType(null);\r\n        newClient.setUserInfoEncryptedResponseAlg(null);\r\n        newClient.setUserInfoEncryptedResponseEnc(null);\r\n        newClient.setUserInfoSignedResponseAlg(null);\r\n        newClient.setDynamicallyRegistered(true);\r\n        newClient.setAllowIntrospection(true);\r\n        try {\r\n            ClientDetailsEntity savedClient = clientService.saveNewClient(newClient);\r\n            OAuth2AccessTokenEntity token = connectTokenService.createResourceAccessToken(savedClient);\r\n            tokenService.saveAccessToken(token);\r\n            RegisteredClient registered = new RegisteredClient(savedClient, token.getValue(), config.getIssuer() + \"resource/\" + UriUtils.encodePathSegment(savedClient.getClientId(), \"UTF-8\"));\r\n            m.addAttribute(\"client\", registered);\r\n            // http 201\r\n            m.addAttribute(HttpCodeView.CODE, HttpStatus.CREATED);\r\n            return ClientInformationResponseView.VIEWNAME;\r\n        } catch (UnsupportedEncodingException e) {\r\n            logger.error(\"Unsupported encoding\", e);\r\n            m.addAttribute(HttpCodeView.CODE, HttpStatus.INTERNAL_SERVER_ERROR);\r\n            return HttpCodeView.VIEWNAME;\r\n        } catch (IllegalArgumentException e) {\r\n            logger.error(\"Couldn't save client\", e);\r\n            m.addAttribute(JsonErrorView.ERROR, \"invalid_client_metadata\");\r\n            m.addAttribute(JsonErrorView.ERROR_MESSAGE, \"Unable to save client due to invalid or inconsistent metadata.\");\r\n            m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\r\n            return JsonErrorView.VIEWNAME;\r\n        }\r\n    } else {\r\n        logger.error(\"registerNewClient failed; submitted JSON is malformed\");\r\n        m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\r\n        return HttpCodeView.VIEWNAME;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.filetransfer.FileTransferRejectedException.getRejectionMessage",
	"Comment": "returns the text to include in a message that will be sent to the intitiator and targetof the file transfer that got rejected or null if none was defined. if no text wasspecified then no message will be sent to the parties of the rejected file transfer.",
	"Method": "String getRejectionMessage(){\r\n    return rejectionMessage;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.mediaproxy.DynamicAddressChannel.datagramReceived",
	"Comment": "implement datagramlistener method.set the host and port value to the host and port value from the received packet.",
	"Method": "boolean datagramReceived(DatagramPacket datagramPacket){\r\n    this.relayPacket(datagramPacket);\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.auth.AuthToken.generateAnonymousToken",
	"Comment": "constructs a new authtoken that represents an authenticated, but anonymous user.",
	"Method": "AuthToken generateAnonymousToken(){\r\n    return new AuthToken(null);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MultiUserChatServiceImpl.logAllConversation",
	"Comment": "logs all the remaining conversation log entries to the database. use this method to forcesaving all the conversation log entries before the service becomes unavailable.",
	"Method": "void logAllConversation(){\r\n    ConversationLogEntry entry;\r\n    while (!logQueue.isEmpty()) {\r\n        entry = logQueue.poll();\r\n        if (entry != null) {\r\n            MUCPersistenceManager.saveConversationLogEntry(entry);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.setMajorVersion",
	"Comment": "sets the major version of bosh which the client implements. currently, the only versionssupported by openfire are 1.5 and 1.6.",
	"Method": "void setMajorVersion(int majorVersion){\r\n    if (majorVersion != 1) {\r\n        return;\r\n    }\r\n    this.majorVersion = majorVersion;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalSession.setSessionData",
	"Comment": "saves given session data. data are saved to temporary storage only and are accessible duringthis session life only and only from this session instance.",
	"Method": "void setSessionData(String key,Object value){\r\n    synchronized (sessionData) {\r\n        sessionData.put(key, value);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyListProvider.getPrivacyLists",
	"Comment": "returns the names of the existing privacy lists indicating which one is thedefault privacy list associated to a user.",
	"Method": "Map<String, Boolean> getPrivacyLists(String username){\r\n    if (!databaseContainsPrivacyLists.get()) {\r\n        return Collections.emptyMap();\r\n    }\r\n    Map<String, Boolean> names = new HashMap();\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(LOAD_LIST_NAMES);\r\n        pstmt.setString(1, username);\r\n        rs = pstmt.executeQuery();\r\n        while (rs.next()) {\r\n            names.put(rs.getString(1), rs.getInt(2) == 1);\r\n        }\r\n    } catch (Exception e) {\r\n        Log.error(\"Error loading names of privacy lists for username: \" + username, e);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    return names;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sasl.ScramSha1SaslServer.getServerKey",
	"Comment": "retrieve the server key from the database for a given username.",
	"Method": "byte[] getServerKey(String username){\r\n    final String serverKey = AuthFactory.getServerKey(username);\r\n    if (serverKey == null) {\r\n        return null;\r\n    } else {\r\n        return DatatypeConverter.parseBase64Binary(serverKey);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalSession.incrementServerPacketCount",
	"Comment": "increments the number of packets sent from the server to the client.",
	"Method": "void incrementServerPacketCount(){\r\n    serverPacketCount.incrementAndGet();\r\n    lastActiveDate = System.currentTimeMillis();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.CertificateStoreWatcher.watch",
	"Comment": "start watching the file that backs a certificate store for changes, reloading the certificate store whenappropriate.this method does nothing when the file watching functionality is not supported by the file system.",
	"Method": "void watch(CertificateStore store){\r\n    if (store == null) {\r\n        throw new IllegalArgumentException(\"Argument 'store' cannot be null.\");\r\n    }\r\n    if (storeWatcher == null) {\r\n        return;\r\n    }\r\n    final Path dir = store.getConfiguration().getFile().toPath().normalize().getParent();\r\n    synchronized (watchedStores) {\r\n        watchedStores.put(store, dir);\r\n        if (!watchedPaths.containsKey(dir)) {\r\n            try {\r\n                final WatchKey watchKey = dir.register(storeWatcher, StandardWatchEventKinds.ENTRY_MODIFY, StandardWatchEventKinds.ENTRY_CREATE);\r\n                watchedPaths.put(dir, watchKey);\r\n            } catch (Throwable t) {\r\n                Log.warn(\"Unable to add a watcher for a path that contains files that provides the backend storage for certificate stores. Changes to those files are unlikely to be picked up automatically. Path: {}\", dir, t);\r\n                watchedStores.remove(store);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.mediaproxy.MediaProxy.getSessions",
	"Comment": "returns the list of all currently active and running sessions.",
	"Method": "Collection<MediaProxySession> getSessions(){\r\n    return sessions.values();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.security.DefaultSecurityAuditProvider.getEventCount",
	"Comment": "the default provider counts the number of entries in the ofsecurityauditlog table.",
	"Method": "Integer getEventCount(){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    Integer cnt = 0;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(GET_EVENT_COUNT);\r\n        rs = pstmt.executeQuery();\r\n        cnt = rs.getInt(1);\r\n    } catch (Exception e) {\r\n        Log.error(\"Error while looking up number of security audit events: \", e);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    return cnt;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.SearchPlugin.replyDataFormResult",
	"Comment": "constructs a query that is returned as an iq packet that contains the search results.",
	"Method": "IQ replyDataFormResult(Collection<User> users,IQ packet){\r\n    final DataForm searchResults = new DataForm(DataForm.Type.result);\r\n    searchResults.addField(\"FORM_TYPE\", null, FormField.Type.hidden);\r\n    searchResults.addReportedField(\"jid\", \"JID\", FormField.Type.jid_single);\r\n    for (final String fieldName : getFilteredSearchFields()) {\r\n        searchResults.addReportedField(fieldName, LocaleUtils.getLocalizedString(\"advance.user.search.\" + fieldName.toLowerCase(), \"search\"), FormField.Type.text_single);\r\n    }\r\n    for (final User user : users) {\r\n        final String username = JID.unescapeNode(user.getUsername());\r\n        final Map<String, Object> item = new HashMap<String, Object>();\r\n        item.put(\"jid\", username + \"@\" + serverName);\r\n        item.put(LocaleUtils.getLocalizedString(\"advance.user.search.username\", \"search\"), username);\r\n        item.put(LocaleUtils.getLocalizedString(\"advance.user.search.name\", \"search\"), (user.isNameVisible() ? removeNull(user.getName()) : \"\"));\r\n        item.put(LocaleUtils.getLocalizedString(\"advance.user.search.email\", \"search\"), (user.isEmailVisible() ? removeNull(user.getEmail()) : \"\"));\r\n        searchResults.addItemFields(item);\r\n    }\r\n    IQ replyPacket = IQ.createResultIQ(packet);\r\n    Element reply = replyPacket.setChildElement(\"query\", NAMESPACE_JABBER_IQ_SEARCH);\r\n    reply.add(searchResults.getElement());\r\n    return replyPacket;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.multiplex.ConnectionMultiplexerManager.closeClientSession",
	"Comment": "closes an existing client session that was established through a connection manager.",
	"Method": "void closeClientSession(String connectionManagerDomain,StreamID streamID){\r\n    Map<StreamID, LocalClientSession> sessions = sessionsByManager.get(connectionManagerDomain);\r\n    if (sessions != null) {\r\n        Session session = sessions.remove(streamID);\r\n        if (session != null) {\r\n            Log.debug(\"Closing session: {}\", session);\r\n            session.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sip.tester.security.SipSecurityManager.setTransactionCreator",
	"Comment": "sets a valid sipprovider that would enable the security manager to mapcredentials to transactionsand thus understand when it is suitable to usecached passwords and when it should go ask the user.",
	"Method": "void setTransactionCreator(SipProvider transactionCreator){\r\n    this.transactionCreator = transactionCreator;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.MITREidDataService_1_2.readSystemScopes",
	"Comment": "read the list of system scopes from the reader and insert them into the\tscope repository.",
	"Method": "void readSystemScopes(JsonReader reader){\r\n    reader.beginArray();\r\n    while (reader.hasNext()) {\r\n        SystemScope scope = new SystemScope();\r\n        reader.beginObject();\r\n        while (reader.hasNext()) {\r\n            switch(reader.peek()) {\r\n                case END_OBJECT:\r\n                    continue;\r\n                case NAME:\r\n                    String name = reader.nextName();\r\n                    if (reader.peek() == JsonToken.NULL) {\r\n                        reader.skipValue();\r\n                    } else if (name.equals(VALUE)) {\r\n                        scope.setValue(reader.nextString());\r\n                    } else if (name.equals(DESCRIPTION)) {\r\n                        scope.setDescription(reader.nextString());\r\n                    } else if (name.equals(RESTRICTED)) {\r\n                        scope.setRestricted(reader.nextBoolean());\r\n                    } else if (name.equals(DEFAULT_SCOPE)) {\r\n                        scope.setDefaultScope(reader.nextBoolean());\r\n                    } else if (name.equals(ICON)) {\r\n                        scope.setIcon(reader.nextString());\r\n                    } else if (name.equals(STRUCTURED)) {\r\n                        logger.warn(\"Found a structured scope, ignoring structure\");\r\n                    } else if (name.equals(STRUCTURED_PARAMETER)) {\r\n                        logger.warn(\"Found a structured scope, ignoring structure\");\r\n                    } else {\r\n                        logger.debug(\"found unexpected entry\");\r\n                        reader.skipValue();\r\n                    }\r\n                    break;\r\n                default:\r\n                    logger.debug(\"Found unexpected entry\");\r\n                    reader.skipValue();\r\n                    continue;\r\n            }\r\n        }\r\n        reader.endObject();\r\n        sysScopeRepository.save(scope);\r\n    }\r\n    reader.endArray();\r\n    logger.info(\"Done reading system scopes\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.GroupJID.toBareJID",
	"Comment": "override the base class implementation to retain the resourceidentifier for group jids.",
	"Method": "String toBareJID(){\r\n    return this.toString();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.ClientStanzaHandler.processUnknowPacket",
	"Comment": "only packets of type message, presence and iq can be processed by this class. any othertype of packet is unknown and thus rejected generating the connection to be closed.",
	"Method": "boolean processUnknowPacket(Element doc){\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.LeafNode.deleteItems",
	"Comment": "deletes the list of published items from the node. event notifications may be sent tosubscribers for the deleted items. when an affiliate has many subscriptions to the node,the affiliate will get a notification for each set of items that affected the same listof subscriptions.for performance reasons the deleted published items are saved to the databaseusing a background thread. sending event notifications to node subscribers mayalso use another thread to ensure good performance.",
	"Method": "void deleteItems(List<PublishedItem> toDelete){\r\n    for (PublishedItem item : toDelete) {\r\n        PubSubPersistenceManager.removePublishedItem(item);\r\n        if (lastPublished != null && lastPublished.getID().equals(item.getID())) {\r\n            lastPublished = null;\r\n        }\r\n    }\r\n    if (isNotifiedOfRetract()) {\r\n        Message message = new Message();\r\n        Element event = message.addChildElement(\"event\", \"http://jabber.org/protocol/pubsub#event\");\r\n        Set<NodeAffiliate> affiliatesToNotify = new HashSet(affiliates);\r\n        for (CollectionNode parentNode : getParents()) {\r\n            for (NodeSubscription subscription : parentNode.getSubscriptions()) {\r\n                affiliatesToNotify.add(subscription.getAffiliate());\r\n            }\r\n        }\r\n        for (NodeAffiliate affiliate : affiliatesToNotify) {\r\n            affiliate.sendDeletionNotifications(message, event, this, toDelete);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getComponentSession",
	"Comment": "returns the session of the component whose domain matches the specified domain.",
	"Method": "ComponentSession getComponentSession(String domain){\r\n    for (ComponentSession session : localSessionManager.getComponentsSessions()) {\r\n        if (domain.equals(session.getAddress().getDomain())) {\r\n            return session;\r\n        }\r\n    }\r\n    RemoteSessionLocator locator = server.getRemoteSessionLocator();\r\n    if (locator != null) {\r\n        byte[] nodeID = componentSessionsCache.get(domain);\r\n        if (nodeID != null) {\r\n            return locator.getComponentSession(nodeID, new JID(domain));\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.ConnectionManagerImpl.getListenAddress",
	"Comment": "returns the specific network interface on which openfire is configured to listen, or null when no such preferencehas been configured.",
	"Method": "InetAddress getListenAddress(){\r\n    String interfaceName = JiveGlobals.getXMLProperty(\"network.interface\");\r\n    InetAddress bindInterface = null;\r\n    if (interfaceName != null) {\r\n        if (interfaceName.trim().length() > 0) {\r\n            bindInterface = InetAddress.getByName(interfaceName);\r\n        }\r\n    }\r\n    return bindInterface;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.Group.isUser",
	"Comment": "returns true if the provided username belongs to a user of the group.",
	"Method": "boolean isUser(JID user,boolean isUser,String username){\r\n    if (username != null) {\r\n        return isUser(XMPPServer.getInstance().createJID(username, null, true));\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.Channel.getQueueSize",
	"Comment": "returns the current number of channelmessage objects waiting to be processed bythe channel.",
	"Method": "int getQueueSize(){\r\n    return executor.getQueue().size();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.UserSchemaValidator.validateAndParse",
	"Comment": "perform a validate and a parse of the specified source document.validating is done with the specified schemafiles.",
	"Method": "Document validateAndParse(){\r\n    ValidatorErrorHandler handler = new ValidatorErrorHandler();\r\n    try {\r\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\r\n        documentBuilderFactory.setNamespaceAware(true);\r\n        documentBuilderFactory.setXIncludeAware(true);\r\n        documentBuilderFactory.setValidating(false);\r\n        documentBuilderFactory.setFeature(\"http://apache.org/xml/features/xinclude/fixup-base-uris\", false);\r\n        documentBuilderFactory.setFeature(\"http://apache.org/xml/features/xinclude/fixup-language\", false);\r\n        if (schemaSources.length > 0) {\r\n            Log.info(\"Checking Schema's\");\r\n            SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\r\n            schemaFactory.setErrorHandler(handler);\r\n            Schema schema = schemaFactory.newSchema(schemaSources);\r\n            documentBuilderFactory.setSchema(schema);\r\n            Log.info(\"Start validating document\");\r\n        } else {\r\n            Log.info(\"Loading document\");\r\n        }\r\n        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\r\n        handler.reset();\r\n        documentBuilder.setEntityResolver(new EntityResolver() {\r\n            @Override\r\n            public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\r\n                Log.info(String.format(\"resolved Entity:%s %s\", (publicId != null ? publicId : \"\"), systemId));\r\n                return null;\r\n            }\r\n        });\r\n        documentBuilder.setErrorHandler(handler);\r\n        Document result = documentBuilder.parse(source);\r\n        if (result != null && handler.isValid()) {\r\n            return result;\r\n        } else {\r\n            Log.warn(String.format(\"document is invalid. %1$d errors found.\", handler.getNrOfErrors()));\r\n            return null;\r\n        }\r\n    } catch (Exception e) {\r\n        Log.warn(String.format(\"document validation failed. %1$d errors found.\", handler.getNrOfErrors()));\r\n        Log.debug(\"\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.UserSchemaValidator.validateAndParse",
	"Comment": "perform a validate and a parse of the specified source document.validating is done with the specified schemafiles.",
	"Method": "Document validateAndParse(){\r\n    Log.info(String.format(\"resolved Entity:%s %s\", (publicId != null ? publicId : \"\"), systemId));\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.sendSubscriptions",
	"Comment": "sends the list of subscriptions with the node to the owner that sent the iqrequest.",
	"Method": "void sendSubscriptions(IQ iqRequest){\r\n    IQ reply = IQ.createResultIQ(iqRequest);\r\n    Element childElement = iqRequest.getChildElement().createCopy();\r\n    reply.setChildElement(childElement);\r\n    Element subscriptions = childElement.element(\"subscriptions\");\r\n    for (NodeAffiliate affiliate : affiliates) {\r\n        for (NodeSubscription subscription : affiliate.getSubscriptions()) {\r\n            if (subscription.isAuthorizationPending()) {\r\n                continue;\r\n            }\r\n            Element entity = subscriptions.addElement(\"subscription\");\r\n            entity.addAttribute(\"jid\", subscription.getJID().toString());\r\n            entity.addAttribute(\"subscription\", subscription.getState().name());\r\n            if (isMultipleSubscriptionsEnabled()) {\r\n                entity.addAttribute(\"subid\", subscription.getID());\r\n            }\r\n        }\r\n    }\r\n    service.send(reply);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpBindManager.isHttpBindEnabled",
	"Comment": "returns true if the http binding server is currently enabled.",
	"Method": "boolean isHttpBindEnabled(){\r\n    return httpBindServer != null && httpBindServer.isRunning();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.setUsernameSuffix",
	"Comment": "set the suffix appended to the username whenever ldap lookups are performed.",
	"Method": "void setUsernameSuffix(String usernameSuffix){\r\n    this.usernameSuffix = usernameSuffix;\r\n    if (usernameSuffix == null) {\r\n        properties.remove(\"ldap.usernameSuffix\");\r\n        this.usernameSuffix = \"\";\r\n    } else {\r\n        properties.put(\"ldap.usernameSuffix\", usernameSuffix);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.admin.SidebarTag.getHeadercss",
	"Comment": "returns the value of the css class to be used for sidebar header sections.",
	"Method": "String getHeadercss(){\r\n    return headercss;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.commands.AdHocCommand.addPreviousStageInformation",
	"Comment": "decrements the stage number by one and adds to the command the data form and allowedactions that the user might perform of the previous stage.",
	"Method": "void addPreviousStageInformation(SessionData data,Element command){\r\n    data.setStage(data.getStage() - 1);\r\n    addStageInformation(data, command);\r\n    addStageActions(data, command);\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ClientDetailsEntityService.checkSectorIdentifierUri",
	"Comment": "load the sector identifier uri if it exists and check the redirect uris against it",
	"Method": "void checkSectorIdentifierUri(ClientDetailsEntity client){\r\n    if (!Strings.isNullOrEmpty(client.getSectorIdentifierUri())) {\r\n        try {\r\n            List<String> redirects = sectorRedirects.get(client.getSectorIdentifierUri());\r\n            if (client.getRegisteredRedirectUri() != null) {\r\n                for (String uri : client.getRegisteredRedirectUri()) {\r\n                    if (!redirects.contains(uri)) {\r\n                        throw new IllegalArgumentException(\"Requested Redirect URI \" + uri + \" is not listed at sector identifier \" + redirects);\r\n                    }\r\n                }\r\n            }\r\n        } catch (UncheckedExecutionException | ExecutionException e) {\r\n            throw new IllegalArgumentException(\"Unable to load sector identifier URI \" + client.getSectorIdentifierUri() + \": \" + e.getMessage());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.EmailService.getPassword",
	"Comment": "returns the password used to connect to the smtp server. if the passwordis null, no password will be used when connecting to the server.",
	"Method": "String getPassword(){\r\n    return password;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.isSecure",
	"Comment": "returns true if all connections on this session should be secured, and false if they shouldnot.",
	"Method": "boolean isSecure(){\r\n    return isSecure;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.TestDefaultApprovedSiteService.prepare",
	"Comment": "initialize the service and repository mock. initialize a client and\tseveral approvedsite objects for use in unit tests.",
	"Method": "void prepare(){\r\n    client = new ClientDetailsEntity();\r\n    client.setClientId(clientId);\r\n    site1 = new ApprovedSite();\r\n    site1.setId(1L);\r\n    site1.setUserId(\"user1\");\r\n    site1.setClientId(\"other\");\r\n    site2 = new ApprovedSite();\r\n    site2.setId(2L);\r\n    site2.setUserId(\"user1\");\r\n    site2.setClientId(clientId);\r\n    site3 = new ApprovedSite();\r\n    site3.setId(3L);\r\n    site3.setUserId(\"user2\");\r\n    site3.setClientId(clientId);\r\n    Mockito.reset(repository, statsService);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.getParent",
	"Comment": "returns the collection node that is containing this node. the only node thatdoes not have a parent node is the root collection node.",
	"Method": "CollectionNode getParent(){\r\n    return parent;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.OpenfireX509TrustManagerTest.testInvalidChainMissingIntermediate",
	"Comment": "verifies that a chain that is missing an intermediate certificate is rejected.",
	"Method": "void testInvalidChainMissingIntermediate(){\r\n    assert validChain.length == 4;\r\n    final X509Certificate[] input = new X509Certificate[3];\r\n    input[0] = validChain[0];\r\n    input[1] = validChain[2];\r\n    input[2] = validChain[3];\r\n    systemUnderTest.checkClientTrusted(input, \"RSA\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.server.ServerDialback.createOutgoingSession",
	"Comment": "creates a new connection from the originating server to the receiving server forauthenticating the specified domain.",
	"Method": "LocalOutgoingServerSession createOutgoingSession(String localDomain,String remoteDomain,int port){\r\n    final Logger log = LoggerFactory.getLogger(Log.getName() + \"[Acting as Originating Server: Create Outgoing Session from: \" + localDomain + \" to RS at: \" + remoteDomain + \" (port: \" + port + \")]\");\r\n    log.debug(\"Creating new outgoing session...\");\r\n    String hostname = null;\r\n    int realPort = port;\r\n    try {\r\n        final Map.Entry<Socket, Boolean> socketToXmppDomain = SocketUtil.createSocketToXmppDomain(remoteDomain, port);\r\n        if (socketToXmppDomain == null) {\r\n            log.info(\"Unable to create new outgoing session: Cannot create a plain socket connection with any applicable remote host.\");\r\n            return null;\r\n        }\r\n        final Socket socket = socketToXmppDomain.getKey();\r\n        final boolean directTLS = socketToXmppDomain.getValue();\r\n        connection = new SocketConnection(XMPPServer.getInstance().getPacketDeliverer(), socket, false);\r\n        if (directTLS) {\r\n            connection.startTLS(false, directTLS);\r\n        }\r\n        log.debug(\"Send the stream header and wait for response...\");\r\n        StringBuilder stream = new StringBuilder();\r\n        stream.append(\"<stream:stream\");\r\n        stream.append(\" xmlns:stream=\\\"http://etherx.jabber.org/streams\\\"\");\r\n        stream.append(\" xmlns=\\\"jabber:server\\\"\");\r\n        stream.append(\" to=\\\"\").append(remoteDomain).append(\"\\\"\");\r\n        stream.append(\" from=\\\"\").append(localDomain).append(\"\\\"\");\r\n        stream.append(\" xmlns:db=\\\"jabber:server:dialback\\\"\");\r\n        stream.append(\">\");\r\n        connection.deliverRawText(stream.toString());\r\n        int soTimeout = socket.getSoTimeout();\r\n        socket.setSoTimeout(RemoteServerManager.getSocketTimeout());\r\n        XMPPPacketReader reader = new XMPPPacketReader();\r\n        reader.setXPPFactory(FACTORY);\r\n        final InputStream input;\r\n        if (directTLS) {\r\n            input = ((SocketConnection) connection).getTLSStreamHandler().getInputStream();\r\n        } else {\r\n            input = socket.getInputStream();\r\n        }\r\n        reader.getXPPParser().setInput(new InputStreamReader(ServerTrafficCounter.wrapInputStream(input), CHARSET));\r\n        XmlPullParser xpp = reader.getXPPParser();\r\n        for (int eventType = xpp.getEventType(); eventType != XmlPullParser.START_TAG; ) {\r\n            eventType = xpp.next();\r\n        }\r\n        log.debug(\"Got a response. Check if the remote server supports dialback...\");\r\n        if (\"jabber:server:dialback\".equals(xpp.getNamespace(\"db\"))) {\r\n            log.debug(\"Dialback seems to be supported by the remote server.\");\r\n            socket.setSoTimeout(soTimeout);\r\n            String id = xpp.getAttributeValue(\"\", \"id\");\r\n            OutgoingServerSocketReader socketReader = new OutgoingServerSocketReader(reader);\r\n            if (authenticateDomain(socketReader, localDomain, remoteDomain, id)) {\r\n                log.debug(\"Successfully authenticated the connection with dialback.\");\r\n                StreamID streamID = BasicStreamIDFactory.createStreamID(id);\r\n                LocalOutgoingServerSession session = new LocalOutgoingServerSession(localDomain, connection, socketReader, streamID);\r\n                connection.init(session);\r\n                session.setAddress(new JID(null, remoteDomain, null));\r\n                log.debug(\"Successfully created new outgoing session!\");\r\n                return session;\r\n            } else {\r\n                log.debug(\"Failed to authenticate the connection with dialback.\");\r\n                connection.close();\r\n            }\r\n        } else {\r\n            log.debug(\"Error! Invalid namespace in packet: '{}'. Closing connection.\", xpp.getText());\r\n            connection.deliverRawText(new StreamError(StreamError.Condition.invalid_namespace).toXML());\r\n            connection.close();\r\n        }\r\n    } catch (Exception e) {\r\n        log.error(\"An exception occurred while creating outgoing session to remote server:\", e);\r\n        if (connection != null) {\r\n            connection.close();\r\n        }\r\n    }\r\n    log.warn(\"Unable to create a new outgoing session\");\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.setMinorVersion",
	"Comment": "sets the minor version of bosh which the client implements. currently, the only versionssupported by openfire are 1.5 and 1.6. any versions less than or equal to 5 will beinterpreted as 5 and any values greater than or equal to 6 will be interpreted as 6.",
	"Method": "void setMinorVersion(int minorVersion){\r\n    if (minorVersion <= 5) {\r\n        this.minorVersion = 5;\r\n    } else if (minorVersion >= 6) {\r\n        this.minorVersion = 6;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.server.ServerDialback.getSecretkey",
	"Comment": "returns the secret key that was randomly generated. when running inside of a clusterthe key will be unique to all cluster nodes.",
	"Method": "String getSecretkey(){\r\n    String key = \"secretKey\";\r\n    Lock lock = CacheFactory.getLock(key, secretKeyCache);\r\n    try {\r\n        lock.lock();\r\n        String secret = secretKeyCache.get(key);\r\n        if (secret == null) {\r\n            secret = StringUtils.randomString(10);\r\n            secretKeyCache.put(key, secret);\r\n        }\r\n        return secret;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getValidatedDomains",
	"Comment": "returns a collection with all the domains, subdomains and virtual hosts that wherevalidated. the remote server is allowed to send packets from any of these domains,subdomains and virtual hosts.content is stored in a clustered cache so that even in the case of the node hostingthe sessions is lost we can still have access to this info to be able to performproper clean up logic.",
	"Method": "Collection<String> getValidatedDomains(StreamID streamID){\r\n    Lock lock = CacheFactory.getLock(streamID, validatedDomainsCache);\r\n    try {\r\n        lock.lock();\r\n        Set<String> validatedDomains = validatedDomainsCache.get(streamID);\r\n        if (validatedDomains == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return Collections.unmodifiableCollection(validatedDomains);\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalIncomingServerSession.getLocalDomain",
	"Comment": "returns the domain or subdomain of the local server used by the remote serverwhen validating the session. this information is only used to prevent manyconnections from the same remote server to the same domain or subdomain ofthe local server.",
	"Method": "String getLocalDomain(){\r\n    return localDomain;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.GroupManager.search",
	"Comment": "returns an unmodifiable collection of all groups in the system thatmatch given propvalue for the specified propname.",
	"Method": "Collection<Group> search(String propName,String propValue,Collection<Group> search,String query,Collection<Group> search,String query,int startIndex,int numResults){\r\n    Collection<String> groupNames = provider.search(query, startIndex, numResults);\r\n    return new GroupCollection(groupNames);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.security.SecurityAuditEvent.getDetails",
	"Comment": "retrieves detailed information about what occurred in the event.",
	"Method": "String getDetails(){\r\n    return details;\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.getTestBeforeUse",
	"Comment": "returns whether returned connections will be tested before being handed overto be used.",
	"Method": "Boolean getTestBeforeUse(){\r\n    return testBeforeUse;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.TLSStreamHandler.flush",
	"Comment": "writes bytebuffer to the socketchannel. returns true when the bytebuffer has no remaining data.",
	"Method": "boolean flush(ByteBuffer bb){\r\n    wbc.write(bb);\r\n    return !bb.hasRemaining();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.OfflineMessageStore.deleteMessage",
	"Comment": "deletes the specified offline message in the store for a user. the way to identify themessage to delete is based on the creationdate and username.",
	"Method": "void deleteMessage(String username,Date creationDate){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(DELETE_OFFLINE_MESSAGE);\r\n        pstmt.setString(1, username);\r\n        pstmt.setString(2, StringUtils.dateToMillis(creationDate));\r\n        pstmt.executeUpdate();\r\n        removeUsernameFromSizeCache(username);\r\n    } catch (Exception e) {\r\n        Log.error(\"Error deleting offline messages of username: \" + username + \" creationDate: \" + creationDate, e);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.LocalMUCRoom.hasToCheckRoleToBroadcastPresence",
	"Comment": "returns true if we need to check whether a presence could be sent or not.",
	"Method": "boolean hasToCheckRoleToBroadcastPresence(){\r\n    return rolesToBroadcastPresence.size() < 3;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.EncryptionArtifactFactory.getKeyManagers",
	"Comment": "generates keymanager instances suitable for connections that are created based on a particular configuration.",
	"Method": "KeyManager[] getKeyManagers(){\r\n    try {\r\n        if (keyManagerFactory == null) {\r\n            try {\r\n                keyManagerFactory = KeyManagerFactory.getInstance(\"NewSunX509\");\r\n            } catch (NoSuchAlgorithmException e) {\r\n                Log.info(\"Unable to load the 'NewSunX509' KeyManager implementation. Will fall back to the default.\");\r\n                keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\r\n            }\r\n            keyManagerFactory.init(configuration.getIdentityStore().getStore(), configuration.getIdentityStoreConfiguration().getPassword());\r\n        }\r\n        return keyManagerFactory.getKeyManagers();\r\n    } catch (UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException | RuntimeException ex) {\r\n        keyManagerFactory = null;\r\n        throw ex;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MUCPersistenceManager.getReservedNickname",
	"Comment": "returns the reserved room nickname for the bare jid in a given room or null if none.",
	"Method": "String getReservedNickname(MUCRoom room,String bareJID){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    String answer = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(GET_RESERVED_NAME);\r\n        pstmt.setLong(1, room.getID());\r\n        pstmt.setString(2, bareJID);\r\n        rs = pstmt.executeQuery();\r\n        if (rs.next()) {\r\n            answer = rs.getString(1);\r\n        }\r\n    } catch (SQLException sqle) {\r\n        Log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.component.ExternalComponentManager.addListener",
	"Comment": "registers a listener to receive events when a configuration change happens. listenershave the chance to deny the operation from happening.",
	"Method": "void addListener(ExternalComponentManagerListener listener){\r\n    if (listener == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    listeners.add(listener);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.SearchPlugin.setServiceEnabled",
	"Comment": "enables or disables the search service. when disabled, when a client tries to do a search they will receive an xform informing thatthe service is unavailable.",
	"Method": "void setServiceEnabled(boolean enabled){\r\n    serviceEnabled = enabled;\r\n    JiveGlobals.setProperty(SERVICEENABLED, enabled ? \"true\" : \"false\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.commands.SessionData.setAllowedActions",
	"Comment": "sets the valid actions that the user can follow from the current stage.",
	"Method": "void setAllowedActions(List<AdHocCommand.Action> allowedActions){\r\n    if (allowedActions == null) {\r\n        allowedActions = new ArrayList();\r\n    }\r\n    this.allowedActions = allowedActions;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.interceptor.PacketRejectedException.getRejectionMessage",
	"Comment": "retuns the text to include in a message that will be sent to the sender of the packetthat got rejected or null if none was defined. if no text was specified thenno message will be sent to the sender of the rejected packet.",
	"Method": "String getRejectionMessage(){\r\n    return rejectionMessage;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MultiUserChatServiceImpl.chatRoomRemoved",
	"Comment": "notification message indicating that the specified chat room wasremoved from some other cluster member.",
	"Method": "void chatRoomRemoved(LocalMUCRoom room){\r\n    removeChatRoom(room.getName(), false);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.UserManager.getUsernames",
	"Comment": "returns an unmodifiable collection of usernames of all users in the system.",
	"Method": "Collection<String> getUsernames(){\r\n    return provider.getUsernames();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PublishedItem.getPublisher",
	"Comment": "returns the jid of the entity that published the item to the node.",
	"Method": "JID getPublisher(){\r\n    return publisher;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.multiplex.MultiplexerPacketHandler.sendResultPacket",
	"Comment": "sends an iq result packet confirming that the operation was successful.",
	"Method": "void sendResultPacket(IQ packet){\r\n    IQ reply = IQ.createResultIQ(packet);\r\n    reply.setChildElement(packet.getChildElement().createCopy());\r\n    deliver(reply);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PublishedItem.getPayloadXML",
	"Comment": "returns a textual representation of the payload or null if no payloadwas specified with the item.",
	"Method": "String getPayloadXML(){\r\n    return payloadXML;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.component.InternalComponentManager.getComponents",
	"Comment": "retrieves the component which is mapped to the specified jid. thelook up will only be done on components that were registered with this jvm. thatmeans that components registered in other cluster nodes are not going to beconsidered.",
	"Method": "List<Component> getComponents(JID componentJID,List<Component> getComponents){\r\n    synchronized (routables) {\r\n        if (componentJID.getNode() != null) {\r\n            return Collections.emptyList();\r\n        }\r\n        RoutableComponents routable = routables.get(componentJID.getDomain());\r\n        if (routable != null) {\r\n            return routable.getComponents();\r\n        } else {\r\n            String serverName = componentJID.getDomain();\r\n            int index = serverName.lastIndexOf(\".\" + serverDomain);\r\n            if (index > -1) {\r\n                routable = routables.get(serverName.substring(0, index));\r\n                if (routable != null) {\r\n                    return routable.getComponents();\r\n                }\r\n            }\r\n        }\r\n        return Collections.emptyList();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.WebManager.isEmbedded",
	"Comment": "returns true if the server is in embedded mode, false otherwise.",
	"Method": "boolean isEmbedded(){\r\n    try {\r\n        ClassUtils.forName(\"org.jivesoftware.openfire.starter.ServerStarter\");\r\n        return true;\r\n    } catch (Exception ignored) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginMetadataHelper.getAuthor",
	"Comment": "returns the author of a plugin. the value is retrieved from the plugin.xml file of the plugin. if the value couldnot be found, null will be returned.",
	"Method": "String getAuthor(Plugin plugin,String getAuthor,Path pluginDir){\r\n    return getElementValue(pluginDir, \"/plugin/author\");\r\n}"
}, {
	"Path": "org.mitre.openid.connect.ClientDetailsEntityJsonProcessor.parse",
	"Comment": "create an unbound clientdetailsentity from the given json string.",
	"Method": "ClientDetailsEntity parse(String jsonString,ClientDetailsEntity parse,JsonElement jsonEl){\r\n    if (jsonEl.isJsonObject()) {\r\n        JsonObject o = jsonEl.getAsJsonObject();\r\n        ClientDetailsEntity c = new ClientDetailsEntity();\r\n        c.setClientId(getAsString(o, CLIENT_ID));\r\n        c.setClientSecret(getAsString(o, CLIENT_SECRET));\r\n        c.setRedirectUris(getAsStringSet(o, REDIRECT_URIS));\r\n        c.setClientName(getAsString(o, CLIENT_NAME));\r\n        c.setClientUri(getAsString(o, CLIENT_URI));\r\n        c.setLogoUri(getAsString(o, LOGO_URI));\r\n        c.setContacts(getAsStringSet(o, CONTACTS));\r\n        c.setTosUri(getAsString(o, TOS_URI));\r\n        String authMethod = getAsString(o, TOKEN_ENDPOINT_AUTH_METHOD);\r\n        if (authMethod != null) {\r\n            c.setTokenEndpointAuthMethod(AuthMethod.getByValue(authMethod));\r\n        }\r\n        String scope = getAsString(o, SCOPE);\r\n        if (scope != null) {\r\n            c.setScope(Sets.newHashSet(Splitter.on(SCOPE_SEPARATOR).split(scope)));\r\n        }\r\n        c.setGrantTypes(getAsStringSet(o, GRANT_TYPES));\r\n        c.setResponseTypes(getAsStringSet(o, RESPONSE_TYPES));\r\n        c.setPolicyUri(getAsString(o, POLICY_URI));\r\n        c.setJwksUri(getAsString(o, JWKS_URI));\r\n        JsonElement jwksEl = o.get(JWKS);\r\n        if (jwksEl != null && jwksEl.isJsonObject()) {\r\n            try {\r\n                JWKSet jwks = JWKSet.parse(jwksEl.toString());\r\n                c.setJwks(jwks);\r\n            } catch (ParseException e) {\r\n                logger.error(\"Unable to parse JWK Set for client\", e);\r\n                return null;\r\n            }\r\n        }\r\n        String appType = getAsString(o, APPLICATION_TYPE);\r\n        if (appType != null) {\r\n            c.setApplicationType(AppType.getByValue(appType));\r\n        }\r\n        c.setSectorIdentifierUri(getAsString(o, SECTOR_IDENTIFIER_URI));\r\n        String subjectType = getAsString(o, SUBJECT_TYPE);\r\n        if (subjectType != null) {\r\n            c.setSubjectType(SubjectType.getByValue(subjectType));\r\n        }\r\n        c.setRequestObjectSigningAlg(getAsJwsAlgorithm(o, REQUEST_OBJECT_SIGNING_ALG));\r\n        c.setUserInfoSignedResponseAlg(getAsJwsAlgorithm(o, USERINFO_SIGNED_RESPONSE_ALG));\r\n        c.setUserInfoEncryptedResponseAlg(getAsJweAlgorithm(o, USERINFO_ENCRYPTED_RESPONSE_ALG));\r\n        c.setUserInfoEncryptedResponseEnc(getAsJweEncryptionMethod(o, USERINFO_ENCRYPTED_RESPONSE_ENC));\r\n        c.setIdTokenSignedResponseAlg(getAsJwsAlgorithm(o, ID_TOKEN_SIGNED_RESPONSE_ALG));\r\n        c.setIdTokenEncryptedResponseAlg(getAsJweAlgorithm(o, ID_TOKEN_ENCRYPTED_RESPONSE_ALG));\r\n        c.setIdTokenEncryptedResponseEnc(getAsJweEncryptionMethod(o, ID_TOKEN_ENCRYPTED_RESPONSE_ENC));\r\n        c.setTokenEndpointAuthSigningAlg(getAsJwsAlgorithm(o, TOKEN_ENDPOINT_AUTH_SIGNING_ALG));\r\n        if (o.has(DEFAULT_MAX_AGE)) {\r\n            if (o.get(DEFAULT_MAX_AGE).isJsonPrimitive()) {\r\n                c.setDefaultMaxAge(o.get(DEFAULT_MAX_AGE).getAsInt());\r\n            }\r\n        }\r\n        if (o.has(REQUIRE_AUTH_TIME)) {\r\n            if (o.get(REQUIRE_AUTH_TIME).isJsonPrimitive()) {\r\n                c.setRequireAuthTime(o.get(REQUIRE_AUTH_TIME).getAsBoolean());\r\n            }\r\n        }\r\n        c.setDefaultACRvalues(getAsStringSet(o, DEFAULT_ACR_VALUES));\r\n        c.setInitiateLoginUri(getAsString(o, INITIATE_LOGIN_URI));\r\n        c.setPostLogoutRedirectUris(getAsStringSet(o, POST_LOGOUT_REDIRECT_URIS));\r\n        c.setRequestUris(getAsStringSet(o, REQUEST_URIS));\r\n        c.setClaimsRedirectUris(getAsStringSet(o, CLAIMS_REDIRECT_URIS));\r\n        c.setCodeChallengeMethod(getAsPkceAlgorithm(o, CODE_CHALLENGE_METHOD));\r\n        c.setSoftwareId(getAsString(o, SOFTWARE_ID));\r\n        c.setSoftwareVersion(getAsString(o, SOFTWARE_VERSION));\r\n        String softwareStatement = getAsString(o, SOFTWARE_STATEMENT);\r\n        if (!Strings.isNullOrEmpty(softwareStatement)) {\r\n            try {\r\n                JWT softwareStatementJwt = JWTParser.parse(softwareStatement);\r\n                c.setSoftwareStatement(softwareStatementJwt);\r\n            } catch (ParseException e) {\r\n                logger.warn(\"Error parsing software statement\", e);\r\n                return null;\r\n            }\r\n        }\r\n        return c;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getIncomingServerSessionsCount",
	"Comment": "returns number of sessions coming from remote servers. current implementation is only countingsessions connected to this jvm and not adding up sessions connected to other cluster nodes.",
	"Method": "int getIncomingServerSessionsCount(boolean onlyLocal){\r\n    int total = localSessionManager.getIncomingServerSessions().size();\r\n    if (!onlyLocal) {\r\n    }\r\n    return total;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.EncryptionArtifactFactory.getDefaultProtocols",
	"Comment": "returns the names of all encryption protocols that are enabled by default.",
	"Method": "List<String> getDefaultProtocols(){\r\n    final SSLContext context = SSLContext.getInstance(\"TLSv1\");\r\n    context.init(null, null, null);\r\n    return Arrays.asList(context.createSSLEngine().getEnabledProtocols());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getTransportHandler",
	"Comment": "returns the transporthandler registered with this server. thetransporthandler was registered with the server as a module while starting upthe server.",
	"Method": "TransportHandler getTransportHandler(){\r\n    return (TransportHandler) modules.get(TransportHandler.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.OfflineMessageStore.getInstance",
	"Comment": "returns the instance of offlinemessagestore being used by the xmppserver.",
	"Method": "OfflineMessageStore getInstance(){\r\n    return XMPPServer.getInstance().getOfflineMessageStore();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.setLanguage",
	"Comment": "sets the default language of the node. this information is really optional and can bemodified by submiting a completed data form with the new node configuration.",
	"Method": "void setLanguage(String language){\r\n    this.language = language;\r\n}"
}, {
	"Path": "org.jivesoftware.util.LinkedList.toString",
	"Comment": "returns a string representation of the linked list with a commadelimited list of all the elements in the list.",
	"Method": "String toString(){\r\n    LinkedListNode<E> node = head.next;\r\n    StringBuilder buf = new StringBuilder();\r\n    while (node != head) {\r\n        buf.append(node.toString()).append(\", \");\r\n        node = node.next;\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.security.DefaultSecurityAuditProvider.getEvent",
	"Comment": "the default provider retrieves events from a ofsecurityauditlog table in the database.",
	"Method": "SecurityAuditEvent getEvent(Integer msgID){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    SecurityAuditEvent event = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(GET_EVENT);\r\n        pstmt.setLong(1, msgID);\r\n        rs = pstmt.executeQuery();\r\n        if (!rs.next()) {\r\n            throw new EventNotFoundException();\r\n        }\r\n        event = new SecurityAuditEvent();\r\n        event.setMsgID(rs.getLong(1));\r\n        event.setUsername(rs.getString(2));\r\n        event.setEventStamp(new Date(rs.getLong(3)));\r\n        event.setSummary(rs.getString(4));\r\n        event.setNode(rs.getString(5));\r\n        event.setDetails(rs.getString(6));\r\n    } catch (Exception e) {\r\n        throw new EventNotFoundException();\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    return event;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getComponentSessions",
	"Comment": "returns a collection with the established sessions from external components.",
	"Method": "Collection<ComponentSession> getComponentSessions(){\r\n    List<ComponentSession> sessions = new ArrayList();\r\n    sessions.addAll(localSessionManager.getComponentsSessions());\r\n    RemoteSessionLocator locator = server.getRemoteSessionLocator();\r\n    if (locator != null) {\r\n        for (Map.Entry<String, byte[]> entry : componentSessionsCache.entrySet()) {\r\n            if (!server.getNodeID().equals(entry.getValue())) {\r\n                sessions.add(locator.getComponentSession(entry.getValue(), new JID(entry.getKey())));\r\n            }\r\n        }\r\n    }\r\n    return sessions;\r\n}"
}, {
	"Path": "org.jivesoftware.util.XMLProperties.getChildrenProperties",
	"Comment": "return all children property names of a parent property as a string array,or an empty array if the if there are no children. for example, giventhe properties x.y.a, x.y.b, and x.y.c, thenthe child properties of x.y are a, b, andc.",
	"Method": "String[] getChildrenProperties(String parent){\r\n    String[] propName = parsePropertyName(parent);\r\n    Element element = document.getRootElement();\r\n    for (String aPropName : propName) {\r\n        element = element.element(aPropName);\r\n        if (element == null) {\r\n            return new String[] {};\r\n        }\r\n    }\r\n    List children = element.elements();\r\n    int childCount = children.size();\r\n    String[] childrenNames = new String[childCount];\r\n    for (int i = 0; i < childCount; i++) {\r\n        childrenNames[i] = ((Element) children.get(i)).getName();\r\n    }\r\n    return childrenNames;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.VirtualConnection.notifyCloseListeners",
	"Comment": "notifies all close listeners that the connection has been closed.",
	"Method": "void notifyCloseListeners(){\r\n    synchronized (listeners) {\r\n        for (ConnectionCloseListener listener : listeners.keySet()) {\r\n            try {\r\n                listener.onConnectionClose(listeners.get(listener));\r\n            } catch (Exception e) {\r\n                Log.error(\"Error notifying listener: \" + listener, e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ProviderTokenService.clearExpiredTokens",
	"Comment": "clears out expired tokens and any abandoned authentication objects",
	"Method": "void clearExpiredTokens(){\r\n    logger.debug(\"Cleaning out all expired tokens\");\r\n    new AbstractPageOperationTemplate<OAuth2AccessTokenEntity>(\"clearExpiredAccessTokens\") {\r\n        @Override\r\n        public Collection<OAuth2AccessTokenEntity> fetchPage() {\r\n            return tokenRepository.getAllExpiredAccessTokens(new DefaultPageCriteria());\r\n        }\r\n        @Override\r\n        public void doOperation(OAuth2AccessTokenEntity item) {\r\n            revokeAccessToken(item);\r\n        }\r\n    }.execute();\r\n    new AbstractPageOperationTemplate<OAuth2RefreshTokenEntity>(\"clearExpiredRefreshTokens\") {\r\n        @Override\r\n        public Collection<OAuth2RefreshTokenEntity> fetchPage() {\r\n            return tokenRepository.getAllExpiredRefreshTokens(new DefaultPageCriteria());\r\n        }\r\n        @Override\r\n        public void doOperation(OAuth2RefreshTokenEntity item) {\r\n            revokeRefreshToken(item);\r\n        }\r\n    }.execute();\r\n    new AbstractPageOperationTemplate<AuthenticationHolderEntity>(\"clearExpiredAuthenticationHolders\") {\r\n        @Override\r\n        public Collection<AuthenticationHolderEntity> fetchPage() {\r\n            return authenticationHolderRepository.getOrphanedAuthenticationHolders(new DefaultPageCriteria());\r\n        }\r\n        @Override\r\n        public void doOperation(AuthenticationHolderEntity item) {\r\n            authenticationHolderRepository.remove(item);\r\n        }\r\n    }.execute();\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ProviderTokenService.clearExpiredTokens",
	"Comment": "clears out expired tokens and any abandoned authentication objects",
	"Method": "void clearExpiredTokens(){\r\n    return tokenRepository.getAllExpiredAccessTokens(new DefaultPageCriteria());\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ProviderTokenService.clearExpiredTokens",
	"Comment": "clears out expired tokens and any abandoned authentication objects",
	"Method": "void clearExpiredTokens(){\r\n    revokeAccessToken(item);\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ProviderTokenService.clearExpiredTokens",
	"Comment": "clears out expired tokens and any abandoned authentication objects",
	"Method": "void clearExpiredTokens(){\r\n    return tokenRepository.getAllExpiredRefreshTokens(new DefaultPageCriteria());\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ProviderTokenService.clearExpiredTokens",
	"Comment": "clears out expired tokens and any abandoned authentication objects",
	"Method": "void clearExpiredTokens(){\r\n    revokeRefreshToken(item);\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ProviderTokenService.clearExpiredTokens",
	"Comment": "clears out expired tokens and any abandoned authentication objects",
	"Method": "void clearExpiredTokens(){\r\n    return authenticationHolderRepository.getOrphanedAuthenticationHolders(new DefaultPageCriteria());\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ProviderTokenService.clearExpiredTokens",
	"Comment": "clears out expired tokens and any abandoned authentication objects",
	"Method": "void clearExpiredTokens(){\r\n    authenticationHolderRepository.remove(item);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.getDigestFrequency",
	"Comment": "returns the minimum number of milliseconds between sending any two notification digests.default is 24 hours.",
	"Method": "int getDigestFrequency(){\r\n    return digestFrequency;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.SearchPlugin.replyDisabled",
	"Comment": "constructs a iq result stanza, based on the request stanza that is provided as an argument. the stanza tells the recipient that thisservice is currently unavailable.",
	"Method": "IQ replyDisabled(IQ packet){\r\n    IQ replyPacket = IQ.createResultIQ(packet);\r\n    Element reply = replyPacket.setChildElement(\"query\", NAMESPACE_JABBER_IQ_SEARCH);\r\n    final DataForm unavailableForm = new DataForm(DataForm.Type.cancel);\r\n    unavailableForm.setTitle(LocaleUtils.getLocalizedString(\"advance.user.search.title\", \"search\"));\r\n    unavailableForm.addInstruction(LocaleUtils.getLocalizedString(\"search.service_unavailable\", \"search\"));\r\n    reply.add(unavailableForm.getElement());\r\n    return replyPacket;\r\n}"
}, {
	"Path": "org.jivesoftware.util.CertificateManager.createSigningRequest",
	"Comment": "creates and returns the content of a new singing request for the specified certificate. signingrequests are required by certificate authorities as part of their signing process. the signing requestcontains information about the certificate issuer, subject dn, subject alternative names and public key.private keys are not included. after the certificate authority verified and signed the certificate a newcertificate is going to be returned.",
	"Method": "String createSigningRequest(X509Certificate cert,PrivateKey privKey){\r\n    JcaPKCS10CertificationRequestBuilder csrBuilder = new JcaPKCS10CertificationRequestBuilder(cert.getSubjectX500Principal(), cert.getPublicKey());\r\n    final ASN1EncodableVector subjectAlternativeNames = new ASN1EncodableVector();\r\n    final Collection<List<?>> certSans = cert.getSubjectAlternativeNames();\r\n    if (certSans != null) {\r\n        for (final List<?> certSan : certSans) {\r\n            final int nameType = (Integer) certSan.get(0);\r\n            final Object value = certSan.get(1);\r\n            switch(nameType) {\r\n                case 0:\r\n                    try (final ASN1InputStream decoder = new ASN1InputStream((byte[]) value)) {\r\n                        final ASN1Primitive object = decoder.readObject();\r\n                        final ASN1Sequence otherNameSeq = (ASN1Sequence) object;\r\n                        final ASN1ObjectIdentifier typeId = (ASN1ObjectIdentifier) otherNameSeq.getObjectAt(0);\r\n                        final ASN1TaggedObject taggedValue = (ASN1TaggedObject) otherNameSeq.getObjectAt(1);\r\n                        final int tagNo = taggedValue.getTagNo();\r\n                        if (tagNo != 0) {\r\n                            throw new IllegalArgumentException(\"subjectAltName 'otherName' sequence's second object is expected to be a tagged value of which the tag number is 0. The tag number that was detected: \" + tagNo);\r\n                        }\r\n                        subjectAlternativeNames.add(new DERTaggedObject(false, GeneralName.otherName, new DERSequence(new ASN1Encodable[] { typeId, taggedValue })));\r\n                    } catch (Exception e) {\r\n                        Log.warn(\"Unable to parse certificate SAN 'otherName' value\", e);\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    subjectAlternativeNames.add(new GeneralName(GeneralName.dNSName, (String) value));\r\n                    break;\r\n                case 6:\r\n                    subjectAlternativeNames.add(new GeneralName(GeneralName.uniformResourceIdentifier, (String) value));\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    final GeneralNames subjectAltNames = GeneralNames.getInstance(new DERSequence(subjectAlternativeNames));\r\n    final ExtensionsGenerator extGen = new ExtensionsGenerator();\r\n    extGen.addExtension(Extension.subjectAlternativeName, false, subjectAltNames);\r\n    csrBuilder.addAttribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest, extGen.generate());\r\n    String signatureAlgorithm = \"SHA256WITH\" + cert.getPublicKey().getAlgorithm();\r\n    ContentSigner signer = new JcaContentSignerBuilder(signatureAlgorithm).build(privKey);\r\n    PKCS10CertificationRequest csr = csrBuilder.build(signer);\r\n    StringWriter string = new StringWriter();\r\n    PemWriter pemWriter = new PemWriter(string);\r\n    PemObjectGenerator objGen = new MiscPEMGenerator(csr);\r\n    pemWriter.writeObject(objGen);\r\n    pemWriter.close();\r\n    return string.toString();\r\n}"
}, {
	"Path": "org.mitre.openid.connect.config.ConfigurationPropertiesBean.checkConfigConsistency",
	"Comment": "endpoints protected by tls must have https scheme in the uri.",
	"Method": "void checkConfigConsistency(){\r\n    if (!StringUtils.startsWithIgnoreCase(issuer, \"https\")) {\r\n        if (this.forceHttps) {\r\n            logger.error(\"Configured issuer url is not using https scheme. Server will be shut down!\");\r\n            throw new BeanCreationException(\"Issuer is not using https scheme as required: \" + issuer);\r\n        } else {\r\n            logger.warn(\"\\n\\n**\\n** WARNING: Configured issuer url is not using https scheme.\\n**\\n\\n\");\r\n        }\r\n    }\r\n    if (languageNamespaces == null || languageNamespaces.isEmpty()) {\r\n        logger.error(\"No configured language namespaces! Text rendering will fail!\");\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.CheckChainTrustedTest.testIgnoreEmptyArraySlots",
	"Comment": "verifies that null values in the provided chain are silently ignored.",
	"Method": "void testIgnoreEmptyArraySlots(){\r\n    final CertSelector selector = new X509CertSelector();\r\n    final List<X509Certificate> copy = new ArrayList(Arrays.asList(validChain));\r\n    copy.add(1, null);\r\n    final X509Certificate[] chain = copy.toArray(new X509Certificate[copy.size()]);\r\n    final CertPath result = trustManager.checkChainTrusted(selector, chain);\r\n    Assert.assertNotNull(result);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.vcard.VCardEventDispatcher.addListener",
	"Comment": "registers a listener to receive events when a vcard is created, updated or deleted.",
	"Method": "void addListener(VCardListener listener){\r\n    if (listener == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    listeners.add(listener);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.createConnection",
	"Comment": "creates a new connection on this session. if a response is currently available for thissession the connection is responded to immediately, otherwise it is queued awaiting aresponse.",
	"Method": "HttpConnection createConnection(long rid,boolean isSecure,boolean isPoll,AsyncContext context){\r\n    final HttpConnection connection = new HttpConnection(rid, isSecure, sslCertificates, context);\r\n    connection.setSession(this);\r\n    context.setTimeout(getWait() * JiveConstants.SECOND);\r\n    context.addListener(new AsyncListener() {\r\n        @Override\r\n        public void onComplete(AsyncEvent asyncEvent) throws IOException {\r\n            Log.debug(\"complete event \" + asyncEvent);\r\n            connectionQueue.remove(connection);\r\n            fireConnectionClosed(connection);\r\n        }\r\n        @Override\r\n        public void onTimeout(AsyncEvent asyncEvent) throws IOException {\r\n            Log.debug(\"timeout event \" + asyncEvent);\r\n            try {\r\n                connection.deliverBody(createEmptyBody(false), false);\r\n                setLastResponseEmpty(true);\r\n                if (connection.getRequestId() != lastRequestID + 1) {\r\n                    throw new IOException(\"Unexpected RID error.\");\r\n                }\r\n                lastRequestID = connection.getRequestId();\r\n            } catch (HttpConnectionClosedException e) {\r\n                Log.warn(\"Unexpected exception while processing connection timeout.\", e);\r\n            }\r\n        }\r\n        @Override\r\n        public void onError(AsyncEvent asyncEvent) throws IOException {\r\n            Log.debug(\"error event \" + asyncEvent);\r\n            Log.warn(\"Unhandled AsyncListener error: \" + asyncEvent.getThrowable());\r\n            connectionQueue.remove(connection);\r\n            fireConnectionClosed(connection);\r\n        }\r\n        @Override\r\n        public void onStartAsync(AsyncEvent asyncEvent) throws IOException {\r\n        }\r\n    });\r\n    if (rid <= lastRequestID) {\r\n        Delivered deliverable = retrieveDeliverable(rid);\r\n        if (deliverable == null) {\r\n            Log.warn(\"Deliverable unavailable for \" + rid);\r\n            throw new HttpBindException(\"Unexpected RID error.\", BoshBindingError.itemNotFound);\r\n        }\r\n        connection.deliverBody(createDeliverable(deliverable.deliverables), true);\r\n        addConnection(connection, isPoll);\r\n        return connection;\r\n    } else if (rid > (lastRequestID + maxRequests)) {\r\n        Log.warn(\"Request \" + rid + \" > \" + (lastRequestID + maxRequests) + \", ending session.\");\r\n        throw new HttpBindException(\"Unexpected RID error.\", BoshBindingError.itemNotFound);\r\n    }\r\n    addConnection(connection, isPoll);\r\n    return connection;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.createConnection",
	"Comment": "creates a new connection on this session. if a response is currently available for thissession the connection is responded to immediately, otherwise it is queued awaiting aresponse.",
	"Method": "HttpConnection createConnection(long rid,boolean isSecure,boolean isPoll,AsyncContext context){\r\n    Log.debug(\"complete event \" + asyncEvent);\r\n    connectionQueue.remove(connection);\r\n    fireConnectionClosed(connection);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.createConnection",
	"Comment": "creates a new connection on this session. if a response is currently available for thissession the connection is responded to immediately, otherwise it is queued awaiting aresponse.",
	"Method": "HttpConnection createConnection(long rid,boolean isSecure,boolean isPoll,AsyncContext context){\r\n    Log.debug(\"timeout event \" + asyncEvent);\r\n    try {\r\n        connection.deliverBody(createEmptyBody(false), false);\r\n        setLastResponseEmpty(true);\r\n        if (connection.getRequestId() != lastRequestID + 1) {\r\n            throw new IOException(\"Unexpected RID error.\");\r\n        }\r\n        lastRequestID = connection.getRequestId();\r\n    } catch (HttpConnectionClosedException e) {\r\n        Log.warn(\"Unexpected exception while processing connection timeout.\", e);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.createConnection",
	"Comment": "creates a new connection on this session. if a response is currently available for thissession the connection is responded to immediately, otherwise it is queued awaiting aresponse.",
	"Method": "HttpConnection createConnection(long rid,boolean isSecure,boolean isPoll,AsyncContext context){\r\n    Log.debug(\"error event \" + asyncEvent);\r\n    Log.warn(\"Unhandled AsyncListener error: \" + asyncEvent.getThrowable());\r\n    connectionQueue.remove(connection);\r\n    fireConnectionClosed(connection);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.createConnection",
	"Comment": "creates a new connection on this session. if a response is currently available for thissession the connection is responded to immediately, otherwise it is queued awaiting aresponse.",
	"Method": "HttpConnection createConnection(long rid,boolean isSecure,boolean isPoll,AsyncContext context){\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalSession.setDetached",
	"Comment": "set the session to detached mode, indicating that the underlying connectionhas been closed.",
	"Method": "void setDetached(){\r\n    this.sessionManager.addDetached(this);\r\n    this.conn = null;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.DummyExternalizableUtil.readLongArray",
	"Comment": "reads an array of long values. this method will return null ifthe array written to the stream was null.",
	"Method": "long[] readLongArray(DataInput in){\r\n    return new long[] {};\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.component.ExternalComponentManager.hasConfiguration",
	"Comment": "returns true if there is a configuration for the specified subdomain. thischecking can be used as an indirect way of checking that the specifiedsubdomain belongs to an external component.",
	"Method": "boolean hasConfiguration(String subdomain){\r\n    return getConfiguration(subdomain, true) != null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.MINAConnectionAcceptor.start",
	"Comment": "starts this acceptor by binding the socket acceptor. when the acceptor is already started, a warning will belogged and the method invocation is otherwise ignored.",
	"Method": "void start(){\r\n    if (socketAcceptor != null) {\r\n        Log.warn(\"Unable to start acceptor (it is already started!)\");\r\n        return;\r\n    }\r\n    try {\r\n        final int initialSize = (configuration.getMaxThreadPoolSize() / 4) + 1;\r\n        final ExecutorFilter executorFilter = new ExecutorFilter(initialSize, configuration.getMaxThreadPoolSize(), 60, TimeUnit.SECONDS);\r\n        final ThreadPoolExecutor eventExecutor = (ThreadPoolExecutor) executorFilter.getExecutor();\r\n        final ThreadFactory threadFactory = new NamedThreadFactory(name + \"-thread-\", eventExecutor.getThreadFactory(), true, null);\r\n        eventExecutor.setThreadFactory(threadFactory);\r\n        socketAcceptor = buildSocketAcceptor();\r\n        if (JMXManager.isEnabled()) {\r\n            configureJMX(socketAcceptor, name);\r\n        }\r\n        final DefaultIoFilterChainBuilder filterChain = socketAcceptor.getFilterChain();\r\n        filterChain.addFirst(ConnectionManagerImpl.EXECUTOR_FILTER_NAME, executorFilter);\r\n        filterChain.addAfter(ConnectionManagerImpl.EXECUTOR_FILTER_NAME, ConnectionManagerImpl.XMPP_CODEC_FILTER_NAME, new ProtocolCodecFilter(new XMPPCodecFactory()));\r\n        filterChain.addAfter(ConnectionManagerImpl.XMPP_CODEC_FILTER_NAME, ConnectionManagerImpl.CAPACITY_FILTER_NAME, new StalledSessionsFilter());\r\n        if (configuration.getTlsPolicy() == Connection.TLSPolicy.legacyMode) {\r\n            final SslFilter sslFilter = encryptionArtifactFactory.createServerModeSslFilter();\r\n            filterChain.addAfter(ConnectionManagerImpl.EXECUTOR_FILTER_NAME, ConnectionManagerImpl.TLS_FILTER_NAME, sslFilter);\r\n        }\r\n        if (configuration.getMaxBufferSize() > 0) {\r\n            socketAcceptor.getSessionConfig().setMaxReadBufferSize(configuration.getMaxBufferSize());\r\n            Log.debug(\"Throttling read buffer for connections to max={} bytes\", configuration.getMaxBufferSize());\r\n        }\r\n        socketAcceptor.setHandler(connectionHandler);\r\n        socketAcceptor.bind(new InetSocketAddress(configuration.getBindAddress(), configuration.getPort()));\r\n    } catch (Exception e) {\r\n        System.err.println(\"Error starting \" + configuration.getPort() + \": \" + e.getMessage());\r\n        Log.error(\"Error starting: \" + configuration.getPort(), e);\r\n        if (socketAcceptor != null) {\r\n            try {\r\n                socketAcceptor.unbind();\r\n            } finally {\r\n                socketAcceptor = null;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getIQRouter",
	"Comment": "returns the iqrouter registered with this server. theiqrouter was registered with the server as a module while starting upthe server.",
	"Method": "IQRouter getIQRouter(){\r\n    return (IQRouter) modules.get(IQRouter.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.getMaxRequests",
	"Comment": "returns the max number of requests it is permissible for this session to have open at any onetime.",
	"Method": "int getMaxRequests(){\r\n    return this.maxRequests;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyList.asElement",
	"Comment": "returns an element with the privacy list xml representation.",
	"Method": "Element asElement(){\r\n    Element listElement = DocumentFactory.getInstance().createDocument().addElement(\"list\", \"jabber:iq:privacy\");\r\n    listElement.addAttribute(\"name\", getName());\r\n    for (PrivacyItem item : items) {\r\n        listElement.add(item.asElement());\r\n    }\r\n    return listElement;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.client.keypublisher.ClientKeyPublisher.postProcessBeanFactory",
	"Comment": "if the jwkpublishurl field is set on this bean, set up a listener on that url to publish keys.",
	"Method": "void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory){\r\n    if (!Strings.isNullOrEmpty(getJwkPublishUrl())) {\r\n        BeanDefinitionBuilder clientKeyMapping = BeanDefinitionBuilder.rootBeanDefinition(ClientKeyPublisherMapping.class);\r\n        BeanDefinitionBuilder viewResolver = BeanDefinitionBuilder.rootBeanDefinition(JwkViewResolver.class);\r\n        if (!Strings.isNullOrEmpty(getJwkPublishUrl())) {\r\n            clientKeyMapping.addPropertyValue(\"jwkPublishUrl\", getJwkPublishUrl());\r\n            jwkViewName = JWKSetView.VIEWNAME + \"-\" + UUID.randomUUID().toString();\r\n            viewResolver.addPropertyValue(\"jwkViewName\", jwkViewName);\r\n            BeanDefinitionBuilder jwkView = BeanDefinitionBuilder.rootBeanDefinition(JWKSetView.class);\r\n            registry.registerBeanDefinition(JWKSetView.VIEWNAME, jwkView.getBeanDefinition());\r\n            viewResolver.addPropertyReference(\"jwk\", JWKSetView.VIEWNAME);\r\n        }\r\n        registry.registerBeanDefinition(\"clientKeyMapping\", clientKeyMapping.getBeanDefinition());\r\n        registry.registerBeanDefinition(\"jwkViewResolver\", viewResolver.getBeanDefinition());\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.sendEventNotification",
	"Comment": "sends an event notification to the specified subscriber. the event notification mayinclude information about the affected subscriptions.",
	"Method": "void sendEventNotification(JID subscriberJID,Message notification,Collection<String> subIDs){\r\n    Element headers = null;\r\n    if (subIDs != null) {\r\n        headers = notification.addChildElement(\"headers\", \"http://jabber.org/protocol/shim\");\r\n        for (String subID : subIDs) {\r\n            Element header = headers.addElement(\"header\");\r\n            header.addAttribute(\"name\", \"SubID\");\r\n            header.setText(subID);\r\n        }\r\n    }\r\n    if (subscriberJID.getResource() == null || SessionManager.getInstance().getSession(subscriberJID) != null) {\r\n        service.sendNotification(this, notification, subscriberJID);\r\n    }\r\n    if (headers != null) {\r\n        notification.getElement().remove(headers);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PubSubPersistenceManager.updateDefaultConfiguration",
	"Comment": "updates the default node configuration for the specified service.",
	"Method": "void updateDefaultConfiguration(PubSubService service,DefaultNodeConfiguration config){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(UPDATE_DEFAULT_CONF);\r\n        pstmt.setInt(1, (config.isDeliverPayloads() ? 1 : 0));\r\n        pstmt.setInt(2, config.getMaxPayloadSize());\r\n        pstmt.setInt(3, (config.isPersistPublishedItems() ? 1 : 0));\r\n        pstmt.setInt(4, config.getMaxPublishedItems());\r\n        pstmt.setInt(5, (config.isNotifyConfigChanges() ? 1 : 0));\r\n        pstmt.setInt(6, (config.isNotifyDelete() ? 1 : 0));\r\n        pstmt.setInt(7, (config.isNotifyRetract() ? 1 : 0));\r\n        pstmt.setInt(8, (config.isPresenceBasedDelivery() ? 1 : 0));\r\n        pstmt.setInt(9, (config.isSendItemSubscribe() ? 1 : 0));\r\n        pstmt.setString(10, config.getPublisherModel().getName());\r\n        pstmt.setInt(11, (config.isSubscriptionEnabled() ? 1 : 0));\r\n        pstmt.setString(12, config.getAccessModel().getName());\r\n        pstmt.setString(13, config.getLanguage());\r\n        if (config.getReplyPolicy() != null) {\r\n            pstmt.setString(14, config.getReplyPolicy().name());\r\n        } else {\r\n            pstmt.setString(14, null);\r\n        }\r\n        pstmt.setString(15, config.getAssociationPolicy().name());\r\n        pstmt.setInt(16, config.getMaxLeafNodes());\r\n        pstmt.setString(17, service.getServiceID());\r\n        pstmt.setInt(18, (config.isLeaf() ? 1 : 0));\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException sqle) {\r\n        log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.launcher.GraphicUtils.getFocusableComponentOrChild",
	"Comment": "returns the first component in the tree of c that can acceptthe focus.",
	"Method": "Component getFocusableComponentOrChild(Component c,boolean deepest){\r\n    if (c != null && c.isEnabled() && c.isVisible()) {\r\n        if (c instanceof Container) {\r\n            Container cont = (Container) c;\r\n            if (deepest == false) {\r\n                if (c instanceof JComponent) {\r\n                    JComponent jc = (JComponent) c;\r\n                    if (jc.isRequestFocusEnabled()) {\r\n                        return jc;\r\n                    }\r\n                }\r\n            }\r\n            int n = cont.getComponentCount();\r\n            for (int i = 0; i < n; i++) {\r\n                Component child = cont.getComponent(i);\r\n                Component focused = getFocusableComponentOrChild(child, deepest);\r\n                if (focused != null) {\r\n                    return focused;\r\n                }\r\n            }\r\n            if (c instanceof JComponent) {\r\n                if (deepest == true) {\r\n                    JComponent jc = (JComponent) c;\r\n                    if (jc.isRequestFocusEnabled()) {\r\n                        return jc;\r\n                    }\r\n                }\r\n            } else {\r\n                return c;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.GroupManager.getGroups",
	"Comment": "returns an iterator for all groups that the entity with the specified jid is a member of.",
	"Method": "Collection<Group> getGroups(Collection<Group> getGroups,int startIndex,int numResults,Collection<Group> getGroups,User user,Collection<Group> getGroups,JID user){\r\n    HashSet<String> groupNames = getUserGroupsFromCache(user);\r\n    if (groupNames == null) {\r\n        synchronized ((user.getNode() + MUTEX_SUFFIX_USER).intern()) {\r\n            groupNames = getUserGroupsFromCache(user);\r\n            if (groupNames == null) {\r\n                groupNames = new HashSet(provider.getGroupNames(user));\r\n                saveUserGroupsInCache(user, groupNames);\r\n            }\r\n        }\r\n    }\r\n    return new GroupCollection(groupNames);\r\n}"
}, {
	"Path": "org.jivesoftware.database.bugfix.OF33.executeFix",
	"Comment": "check and repair the serviceids for the ofmucservice table.",
	"Method": "void executeFix(Connection con){\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    String answer = null;\r\n    try {\r\n        pstmt = con.prepareStatement(\"SELECT id FROM ofID WHERE idType=\" + JiveConstants.MUC_SERVICE);\r\n        rs = pstmt.executeQuery();\r\n        if (rs.next()) {\r\n            answer = rs.getString(1);\r\n        }\r\n        rs.close();\r\n        if (answer == null) {\r\n            return;\r\n        }\r\n        if (answer.equals(\"1\")) {\r\n            pstmt = con.prepareStatement(\"UPDATE ofID SET id=2 WHERE idType=\" + JiveConstants.MUC_SERVICE);\r\n            pstmt.executeUpdate();\r\n            return;\r\n        } else {\r\n            String subdomain = null;\r\n            try {\r\n                pstmt = con.prepareStatement(\"SELECT subdomain FROM ofMucService WHERE serviceID=1\");\r\n                rs = pstmt.executeQuery();\r\n                if (rs.next()) {\r\n                    subdomain = rs.getString(1);\r\n                }\r\n                if (subdomain == null || !rs.next()) {\r\n                    return;\r\n                }\r\n                subdomain = rs.getString(1);\r\n            } finally {\r\n                rs.close();\r\n            }\r\n            long newID = SequenceManager.nextID(JiveConstants.MUC_SERVICE);\r\n            pstmt = con.prepareStatement(\"UPDATE ofMucService SET serviceID=? WHERE serviceID=1 AND subdomain=?\");\r\n            pstmt.setLong(1, newID);\r\n            pstmt.setString(2, subdomain);\r\n            pstmt.executeUpdate();\r\n            try {\r\n                pstmt = con.prepareStatement(\"SELECT name, propValue FROM ofMucServiceProp WHERE serviceID=1\");\r\n                rs = pstmt.executeQuery();\r\n                String name = null;\r\n                String value = null;\r\n                while (rs.next()) {\r\n                    name = rs.getString(1);\r\n                    value = rs.getString(2);\r\n                    if (name != null && value != null) {\r\n                        pstmt = con.prepareStatement(\"INSERT INTO ofMucServiceProp(serviceID, name, propValue) \" + \"VALUES(?,?,?)\");\r\n                        pstmt.setLong(1, newID);\r\n                        pstmt.setString(2, name);\r\n                        pstmt.setString(3, value);\r\n                        pstmt.executeUpdate();\r\n                    }\r\n                }\r\n            } finally {\r\n                rs.close();\r\n            }\r\n            try {\r\n                Long roomID, newRoomID;\r\n                ResultSet roomRS = null;\r\n                pstmt = con.prepareStatement(\"SELECT roomID, creationDate, modificationDate, \" + \"name, naturalName, description, lockedDate, emptyDate, \" + \"canChangeSubject, maxUsers, publicRoom, moderated, membersOnly, \" + \"canInvite, roomPassword, canDiscoverJID, logEnabled, subject, \" + \"rolesToBroadcast, useReservedNick, canChangeNick, canRegister \" + \"FROM ofMucRoom WHERE serviceID=1\");\r\n                rs = pstmt.executeQuery();\r\n                while (rs.next()) {\r\n                    roomID = rs.getLong(1);\r\n                    newRoomID = SequenceManager.nextID(JiveConstants.MUC_ROOM);\r\n                    pstmt = con.prepareStatement(\"INSERT INTO ofMucRoom (serviceID, roomID, \" + \"creationDate, modificationDate, name, naturalName, description, \" + \"lockedDate, emptyDate, canChangeSubject, maxUsers, publicRoom, \" + \"moderated, membersOnly, canInvite, roomPassword, canDiscoverJID, \" + \"logEnabled, subject, rolesToBroadcast, useReservedNick, \" + \"canChangeNick, canRegister) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\");\r\n                    pstmt.setLong(1, newID);\r\n                    pstmt.setLong(2, newRoomID);\r\n                    pstmt.setString(3, rs.getString(2));\r\n                    pstmt.setString(4, rs.getString(3));\r\n                    pstmt.setString(5, rs.getString(4));\r\n                    pstmt.setString(6, rs.getString(5));\r\n                    pstmt.setString(7, rs.getString(6));\r\n                    pstmt.setString(8, rs.getString(7));\r\n                    pstmt.setString(9, rs.getString(8));\r\n                    pstmt.setInt(10, rs.getInt(9));\r\n                    pstmt.setInt(11, rs.getInt(10));\r\n                    pstmt.setInt(12, rs.getInt(11));\r\n                    pstmt.setInt(13, rs.getInt(12));\r\n                    pstmt.setInt(14, rs.getInt(13));\r\n                    pstmt.setInt(15, rs.getInt(14));\r\n                    pstmt.setString(16, rs.getString(15));\r\n                    pstmt.setInt(17, rs.getInt(16));\r\n                    pstmt.setInt(18, rs.getInt(17));\r\n                    pstmt.setString(19, rs.getString(18));\r\n                    pstmt.setInt(20, rs.getInt(19));\r\n                    pstmt.setInt(21, rs.getInt(20));\r\n                    pstmt.setInt(22, rs.getInt(21));\r\n                    pstmt.setInt(23, rs.getInt(22));\r\n                    pstmt.executeUpdate();\r\n                    try {\r\n                        pstmt = con.prepareStatement(\"SELECT name, propValue FROM ofMucRoomProp WHERE roomID=?\");\r\n                        pstmt.setLong(1, roomID);\r\n                        roomRS = pstmt.executeQuery();\r\n                        String name = null;\r\n                        String value = null;\r\n                        while (roomRS.next()) {\r\n                            name = roomRS.getString(1);\r\n                            value = roomRS.getString(2);\r\n                            if (name != null && value != null) {\r\n                                pstmt = con.prepareStatement(\"INSERT INTO ofMucRoomProp(roomID, name, propValue) \" + \"VALUES(?,?,?)\");\r\n                                pstmt.setLong(1, newRoomID);\r\n                                pstmt.setString(2, name);\r\n                                pstmt.setString(3, value);\r\n                                pstmt.executeUpdate();\r\n                            }\r\n                        }\r\n                    } finally {\r\n                        roomRS.close();\r\n                    }\r\n                    try {\r\n                        pstmt = con.prepareStatement(\"SELECT jid, affiliation FROM ofMucAffiliation WHERE roomID=?\");\r\n                        pstmt.setLong(1, roomID);\r\n                        roomRS = pstmt.executeQuery();\r\n                        while (roomRS.next()) {\r\n                            pstmt = con.prepareStatement(\"INSERT INTO ofMucAffiliation(roomID, jid, affiliation) \" + \"VALUES(?,?,?)\");\r\n                            pstmt.setLong(1, newRoomID);\r\n                            pstmt.setString(2, roomRS.getString(1));\r\n                            pstmt.setInt(3, roomRS.getInt(2));\r\n                            pstmt.executeUpdate();\r\n                        }\r\n                    } finally {\r\n                        roomRS.close();\r\n                    }\r\n                    try {\r\n                        pstmt = con.prepareStatement(\"SELECT jid, nickname, firstName, lastName, url, email, faqentry \" + \"FROM ofMucMember WHERE roomID=?\");\r\n                        pstmt.setLong(1, roomID);\r\n                        roomRS = pstmt.executeQuery();\r\n                        while (roomRS.next()) {\r\n                            pstmt = con.prepareStatement(\"INSERT INTO ofMucMember(roomID, jid, nickname, firstName, \" + \"lastName, url, email, faqentry) VALUES(?,?,?,?,?,?,?,?)\");\r\n                            pstmt.setLong(1, newRoomID);\r\n                            pstmt.setString(2, roomRS.getString(1));\r\n                            pstmt.setString(3, roomRS.getString(2));\r\n                            pstmt.setString(4, roomRS.getString(3));\r\n                            pstmt.setString(5, roomRS.getString(4));\r\n                            pstmt.setString(6, roomRS.getString(5));\r\n                            pstmt.setString(7, roomRS.getString(6));\r\n                            pstmt.setString(8, roomRS.getString(7));\r\n                            pstmt.executeUpdate();\r\n                        }\r\n                    } finally {\r\n                        roomRS.close();\r\n                    }\r\n                    try {\r\n                        pstmt = con.prepareStatement(\"SELECT sender, nickname, logTime, subject, body \" + \"FROM ofMucConversationLog WHERE roomID=?\");\r\n                        pstmt.setLong(1, roomID);\r\n                        roomRS = pstmt.executeQuery();\r\n                        while (roomRS.next()) {\r\n                            pstmt = con.prepareStatement(\"INSERT INTO ofMucConversationLog(roomID, \" + \"sender, nickname, logTime, subject, body VALUES(?,?,?,?,?,?)\");\r\n                            pstmt.setLong(1, newRoomID);\r\n                            pstmt.setString(2, roomRS.getString(1));\r\n                            pstmt.setString(3, roomRS.getString(2));\r\n                            pstmt.setString(4, roomRS.getString(3));\r\n                            pstmt.setString(5, roomRS.getString(4));\r\n                            pstmt.setString(6, roomRS.getString(5));\r\n                            pstmt.executeUpdate();\r\n                        }\r\n                    } finally {\r\n                        roomRS.close();\r\n                    }\r\n                }\r\n            } finally {\r\n                rs.close();\r\n            }\r\n        }\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n    } finally {\r\n        DbConnectionManager.closeStatement(pstmt);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterManager.isGroupVisible",
	"Comment": "returns true if a given group is visible to a given user. that means, if the user cansee the group in his roster.",
	"Method": "boolean isGroupVisible(Group group,JID user){\r\n    String showInRoster = group.getProperties().get(\"sharedRoster.showInRoster\");\r\n    if (\"everybody\".equals(showInRoster)) {\r\n        return true;\r\n    } else if (\"onlyGroup\".equals(showInRoster)) {\r\n        if (group.isUser(user)) {\r\n            return true;\r\n        }\r\n        Collection<Group> groupList = parseGroups(group.getProperties().get(\"sharedRoster.groupList\"));\r\n        for (Group groupInList : groupList) {\r\n            if (groupInList.isUser(user)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.database.SchemaManager.isSQLCommandPart",
	"Comment": "returns true if a line from a sql schema is a valid command part.",
	"Method": "boolean isSQLCommandPart(String line){\r\n    line = line.trim();\r\n    if (line.equals(\"\")) {\r\n        return false;\r\n    }\r\n    return !(line.startsWith(\"//\") || line.startsWith(\"--\") || line.startsWith(\"#\") || line.startsWith(\"REM\") || line.startsWith(\"/*\") || line.startsWith(\"*\"));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.CertificateStore.reload",
	"Comment": "reloads the content of the store from disk. useful when the store content has been modified outside of theopenfire process, or when changes that have not been persisted need to be undone.",
	"Method": "void reload(){\r\n    try (final FileInputStream is = new FileInputStream(configuration.getFile())) {\r\n        store.load(is, configuration.getPassword());\r\n        CertificateManager.fireCertificateStoreChanged(this);\r\n    } catch (IOException | NoSuchAlgorithmException | CertificateException ex) {\r\n        throw new CertificateStoreConfigException(\"Unable to reload store in '\" + configuration.getFile() + \"'\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.server.RemoteServerManager.allowAccess",
	"Comment": "allows a remote server to connect to the local server with the specified configuration.",
	"Method": "void allowAccess(RemoteServerConfiguration configuration){\r\n    deleteConfiguration(configuration.getDomain());\r\n    configuration.setPermission(Permission.allowed);\r\n    addConfiguration(configuration);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.CollectionNode.getSubscriptions",
	"Comment": "returns a collection with the subscriptions to this node that should be notifiedthat a new child was added or deleted.",
	"Method": "Collection<NodeSubscription> getSubscriptions(Node child){\r\n    Collection<NodeSubscription> subscriptions = new ArrayList();\r\n    for (NodeSubscription subscription : getSubscriptions()) {\r\n        if (subscription.canSendChildNodeEvent(child)) {\r\n            subscriptions.add(subscription);\r\n        }\r\n    }\r\n    return subscriptions;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.server.OutgoingSessionPromise.shutdown",
	"Comment": "shuts down the thread that consumes the queued packets and also stops the poolof threads that actually send the packets to the remote servers.",
	"Method": "void shutdown(){\r\n    threadPool.shutdown();\r\n    shutdown = true;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.UserServicePlugin.setEnabled",
	"Comment": "enables or disables the user service. if not enabled, it will not acceptrequests to create new accounts.",
	"Method": "void setEnabled(boolean enabled){\r\n    this.enabled = enabled;\r\n    JiveGlobals.setProperty(\"plugin.userservice.enabled\", enabled ? \"true\" : \"false\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyList.setDefaultList",
	"Comment": "sets if this privacy list is the default list to apply for the user. defaultprivacy lists can be overriden per session by setting an active privacy list.",
	"Method": "void setDefaultList(boolean isDefault){\r\n    this.isDefault = isDefault;\r\n    PrivacyListManager.getInstance().dispatchModifiedEvent(this);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.GroupManager.getProvider",
	"Comment": "returns the configured group provider. note that this method has special accessprivileges since only a few certain classes need to access the provider directly.",
	"Method": "GroupProvider getProvider(){\r\n    return provider;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.getReplyPolicy",
	"Comment": "returns the policy that defines whether owners or publisher should receivereplies to items.",
	"Method": "Node.ItemReplyPolicy getReplyPolicy(){\r\n    return replyPolicy;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getFlashCrossDomainHandler",
	"Comment": "returns the flashcrossdomainhandler registered with this server. theflashcrossdomainhandler was registered with the server as a module while starting upthe server.",
	"Method": "FlashCrossDomainHandler getFlashCrossDomainHandler(){\r\n    return (FlashCrossDomainHandler) modules.get(FlashCrossDomainHandler.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.stop",
	"Comment": "stops the server only if running in standalone mode. do nothing if the server is runninginside of another server.",
	"Method": "void stop(){\r\n    logger.info(\"Initiating shutdown ...\");\r\n    if (isStandAlone()) {\r\n        if (isRestartable()) {\r\n            try {\r\n                Class<?> wrapperClass = Class.forName(WRAPPER_CLASSNAME);\r\n                Method stopMethod = wrapperClass.getMethod(\"stop\", Integer.TYPE);\r\n                stopMethod.invoke(null, 0);\r\n            } catch (Exception e) {\r\n                logger.error(\"Could not stop container\", e);\r\n            }\r\n        } else {\r\n            shutdownServer();\r\n            Thread shutdownThread = new ShutdownThread();\r\n            shutdownThread.setDaemon(true);\r\n            shutdownThread.start();\r\n        }\r\n    } else {\r\n        shutdownServer();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.lockout.LockOutFlag.setStartTime",
	"Comment": "sets the start time for when the account will be disabled, or null if immediate.",
	"Method": "void setStartTime(Date startTime){\r\n    this.startTime = startTime;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginMetadataHelper.getDescription",
	"Comment": "returns the description of a plugin. the value is retrieved from the plugin.xml file of the plugin. if the valuecould not be found, null will be returned.",
	"Method": "String getDescription(Plugin plugin,String getDescription,Path pluginDir){\r\n    final String name = getCanonicalName(pluginDir);\r\n    final String description = getElementValue(pluginDir, \"/plugin/description\");\r\n    return AdminConsole.getAdminText(description, name);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PublishedItem.containsKeyword",
	"Comment": "returns true if payload contains the specified keyword. if the item has no payloador keyword is null then return true.",
	"Method": "boolean containsKeyword(String keyword){\r\n    if (getPayloadXML() == null || keyword == null) {\r\n        return true;\r\n    }\r\n    return payloadXML.contains(keyword);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.PrivateStorage.add",
	"Comment": "stores private data. if the name and namespace of the element matches anotherstored private data xml document, then replace it with the new one.",
	"Method": "void add(String username,Element data){\r\n    if (!enabled) {\r\n        return;\r\n    }\r\n    final JID owner = XMPPServer.getInstance().createJID(username, null);\r\n    final PEPServiceManager serviceMgr = XMPPServer.getInstance().getIQPEPHandler().getServiceManager();\r\n    PEPService pepService = serviceMgr.getPEPService(owner);\r\n    if (pepService == null) {\r\n        pepService = serviceMgr.create(owner);\r\n    }\r\n    Node node = pepService.getNode(data.getNamespaceURI());\r\n    if (node == null) {\r\n        PubSubEngine.CreateNodeResponse response = PubSubEngine.createNodeHelper(pepService, owner, pepService.getDefaultNodeConfiguration(true).getConfigurationForm().getElement(), data.getNamespaceURI(), PRIVATE_DATA_PUBLISHING_OPTIONS);\r\n        node = response.newNode;\r\n        if (node == null) {\r\n            Log.error(\"Unable to create new PEP node, to be used to store private data. Error condition: {}\", response.creationStatus.toXMPP());\r\n            return;\r\n        }\r\n    }\r\n    if (!(node instanceof LeafNode)) {\r\n        Log.error(\"Unable to store private data into a PEP node. The node that is available is not a leaf node.\");\r\n        return;\r\n    }\r\n    data.detach();\r\n    final Element item = DocumentHelper.createElement(\"item\");\r\n    item.addAttribute(\"id\", \"current\");\r\n    item.add(data);\r\n    ((LeafNode) node).publishItems(owner, Collections.singletonList(item));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.multiplex.ConnectionMultiplexerManager.multiplexerUnavailable",
	"Comment": "a connection manager has gone unavailable. close client sessions that were establishedto the specified connection manager.",
	"Method": "void multiplexerUnavailable(String connectionManagerName){\r\n    Map<StreamID, LocalClientSession> sessions = sessionsByManager.remove(connectionManagerName);\r\n    if (sessions != null) {\r\n        for (StreamID streamID : sessions.keySet()) {\r\n            streamIDs.remove(streamID);\r\n            sessions.get(streamID).close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MultiUserChatServiceImpl.getNumberRoomOccupants",
	"Comment": "retuns the total number of users that have joined in all rooms in the server.",
	"Method": "int getNumberRoomOccupants(){\r\n    int total = 0;\r\n    for (MUCRoom room : localMUCRoomManager.getRooms()) {\r\n        total = total + room.getOccupantsCount();\r\n    }\r\n    return total;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getAdHocCommandHandler",
	"Comment": "returns the adhoccommandhandler registered with this server. theadhoccommandhandler was registered with the server as a module while starting upthe server.",
	"Method": "AdHocCommandHandler getAdHocCommandHandler(){\r\n    return (AdHocCommandHandler) modules.get(AdHocCommandHandler.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.cluster.MUCRoomTask.execute",
	"Comment": "executes the requested task considering that this jvm may still be joining the cluster.this means that events regarding rooms that were not loaded yet will be stored for laterprocessing. once the jvm is done joining the cluster queued tasks will be processed.",
	"Method": "void execute(Runnable runnable){\r\n    boolean clusterStarting = ClusterManager.isClusteringStarting();\r\n    try {\r\n        getRoom();\r\n        runnable.run();\r\n    } catch (IllegalArgumentException e) {\r\n        if (clusterStarting) {\r\n            QueuedTasksManager.getInstance().addTask(this);\r\n        } else {\r\n            Log.error(e.getMessage(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.setPassword",
	"Comment": "sets the password used to connect to the database. in some cases, apassword is not needed so null should be passed in.",
	"Method": "void setPassword(String password){\r\n    this.password = password;\r\n    saveProperties();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.MINAConnectionAcceptor.stop",
	"Comment": "stops this acceptor by unbinding the socket acceptor. does nothing when the instance is not started.",
	"Method": "void stop(){\r\n    if (socketAcceptor != null) {\r\n        socketAcceptor.unbind();\r\n        socketAcceptor = null;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.webdav.WebDAVLiteServlet.getFileReference",
	"Comment": "retrieves a file object referring to a file in a service and room.leaving file as nullwill get you the directory that would contain all of the files for a particular service and room.",
	"Method": "File getFileReference(String service,String room,String file){\r\n    return new File(JiveGlobals.getHomeDirectory(), WEBDAV_SUBDIR + File.separator + service + File.separator + room + (file != null ? File.separator + file : \"\"));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.SearchPlugin.getFilteredSearchFields",
	"Comment": "returns the collection of searchable field names that does not include the fields listed in the excludedfields property list.",
	"Method": "Collection<String> getFilteredSearchFields(){\r\n    Collection<String> searchFields;\r\n    try {\r\n        searchFields = new ArrayList<String>(userManager.getSearchFields());\r\n    } catch (UnsupportedOperationException uoe) {\r\n        searchFields = getSearchPluginUserManagerSearchFields();\r\n    }\r\n    searchFields.removeAll(excludedFields);\r\n    return searchFields;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getIQDiscoInfoHandler",
	"Comment": "returns the iqdiscoinfohandler registered with this server. theiqdiscoinfohandler was registered with the server as a module while starting upthe server.",
	"Method": "IQDiscoInfoHandler getIQDiscoInfoHandler(){\r\n    return (IQDiscoInfoHandler) modules.get(IQDiscoInfoHandler.class);\r\n}"
}, {
	"Path": "org.jivesoftware.util.StringUtils.getFullElapsedTime",
	"Comment": "returns a textual representation for the time that has elapsed.",
	"Method": "String getFullElapsedTime(long delta,String getFullElapsedTime,Duration delta){\r\n    return getFullElapsedTime(delta.toMillis());\r\n}"
}, {
	"Path": "org.mitre.jose.keystore.JWKSetKeyStore.getKeys",
	"Comment": "get the list of keys in this keystore. this is a passthrough to the underlying jwk set",
	"Method": "List<JWK> getKeys(){\r\n    if (jwkSet == null) {\r\n        initializeJwkSet();\r\n    }\r\n    return jwkSet.getKeys();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.ConnectionListener.getIdentityStoreConfiguration",
	"Comment": "returns the configuration for the identity store that identifies this instance of openfire to the peeron connections created by this listener.",
	"Method": "CertificateStoreConfiguration getIdentityStoreConfiguration(){\r\n    return this.identityStoreConfiguration;\r\n}"
}, {
	"Path": "org.jivesoftware.database.ProfiledConnection.getAverageQueryTime",
	"Comment": "returns the average amount of time spent executing the specified typeof query.",
	"Method": "double getAverageQueryTime(Type type){\r\n    long time, count;\r\n    switch(type) {\r\n        case select:\r\n            count = selectCount;\r\n            time = totalSelectTime;\r\n            break;\r\n        case update:\r\n            count = updateCount;\r\n            time = totalUpdateTime;\r\n            break;\r\n        case insert:\r\n            count = insertCount;\r\n            time = totalInsertTime;\r\n            break;\r\n        case delete:\r\n            count = deleteCount;\r\n            time = totalDeleteTime;\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Invalid type\");\r\n    }\r\n    if (count != 0) {\r\n        return time / (double) count;\r\n    } else {\r\n        return 0.0;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.setMaxRequests",
	"Comment": "the max number of requests it is permissible for this session to have open at any one time.",
	"Method": "void setMaxRequests(int maxRequests){\r\n    this.maxRequests = maxRequests;\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.getUsername",
	"Comment": "returns the username used to connect to the database. in some cases,a username is not needed so this method will return null.",
	"Method": "String getUsername(){\r\n    return username;\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ClientDetailsEntityService.saveNewClient_noOfflineAccess",
	"Comment": "makes sure client does not have offline access if not allowed to have refresh tokens.",
	"Method": "void saveNewClient_noOfflineAccess(){\r\n    ClientDetailsEntity client = new ClientDetailsEntity();\r\n    client = service.saveNewClient(client);\r\n    Mockito.verify(scopeService, Mockito.atLeastOnce()).removeReservedScopes(Matchers.anySet());\r\n    assertThat(client.getScope().contains(SystemScopeService.OFFLINE_ACCESS), is(equalTo(false)));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.RoutingTableImpl.routeToRemoteDomain",
	"Comment": "routes packets that are sent to other xmpp domains than the local xmppdomain.",
	"Method": "boolean routeToRemoteDomain(JID jid,Packet packet,boolean routed){\r\n    if (!JiveGlobals.getBooleanProperty(ConnectionSettings.Server.ALLOW_ANONYMOUS_OUTBOUND_DATA, false)) {\r\n        if (isAnonymousRoute(packet.getFrom())) {\r\n            Log.info(\"The anonymous user '{}' attempted to send data to '{}', which is on a remote domain. Openfire is configured to not allow anonymous users to send data to remote domains.\", packet.getFrom(), jid);\r\n            routed = false;\r\n            return routed;\r\n        }\r\n    }\r\n    DomainPair pair = new DomainPair(packet.getFrom().getDomain(), jid.getDomain());\r\n    byte[] nodeID = serversCache.get(pair);\r\n    if (nodeID != null) {\r\n        if (server.getNodeID().equals(nodeID)) {\r\n            try {\r\n                localRoutingTable.getRoute(pair).process(packet);\r\n                routed = true;\r\n            } catch (UnauthorizedException e) {\r\n                Log.error(\"Unable to route packet \" + packet.toXML(), e);\r\n            }\r\n        } else {\r\n            if (remotePacketRouter != null) {\r\n                routed = remotePacketRouter.routePacket(nodeID, jid, packet);\r\n            }\r\n        }\r\n    } else if (!RemoteServerManager.canAccess(jid.getDomain())) {\r\n        Log.info(\"Will not route: Remote domain {} is not accessible according to our configuration (typical causes: server federation is disabled, or domain is blacklisted).\", jid.getDomain());\r\n        routed = false;\r\n    } else {\r\n        OutgoingSessionPromise.getInstance().process(packet);\r\n        routed = true;\r\n    }\r\n    return routed;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getFileTransferManager",
	"Comment": "returns the filetransfermanager registered with this server. thefiletransfermanager was registered with the server as a module while starting upthe server.",
	"Method": "FileTransferManager getFileTransferManager(){\r\n    return (FileTransferManager) modules.get(DefaultFileTransferManager.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.Roster.getImplicitRosterItem",
	"Comment": "returns a roster item if the specified user has a subscription of type from to thisuser and the susbcription only exists due to some shared groups or otherwisenull. this method assumes that this user does not have a subscription tothe contact. in other words, this method will not check if there should be a subscriptionof type to ot both.",
	"Method": "RosterItem getImplicitRosterItem(JID user){\r\n    Set<String> invisibleSharedGroups = implicitFrom.get(user.toBareJID());\r\n    if (invisibleSharedGroups != null) {\r\n        RosterItem rosterItem = new RosterItem(user, RosterItem.SUB_FROM, RosterItem.ASK_NONE, RosterItem.RECV_NONE, \"\", null);\r\n        rosterItem.setInvisibleSharedGroupsNames(invisibleSharedGroups);\r\n        return rosterItem;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.util.EmailService.setUsername",
	"Comment": "sets the username that will be used when connecting to the smtpserver. the default is null, or no username.",
	"Method": "void setUsername(String username){\r\n    this.username = username;\r\n    if (username == null) {\r\n        JiveGlobals.deleteProperty(\"mail.smtp.username\");\r\n    } else {\r\n        JiveGlobals.setProperty(\"mail.smtp.username\", username);\r\n    }\r\n    session = null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.EncryptionArtifactFactoryTest.testHasDefaultCipherSuites",
	"Comment": "verifies that the collection of default cipher suites is not empty.",
	"Method": "void testHasDefaultCipherSuites(){\r\n    final Collection<String> result = EncryptionArtifactFactory.getDefaultCipherSuites();\r\n    Assert.assertFalse(result.isEmpty());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.server.RemoteServerManager.getSocketTimeout",
	"Comment": "returns the number of milliseconds to wait to connect to a remote server or readdata from a remote server. default timeout value is 120 seconds. configure thexmpp.server.read.timeout global property to override the default value.",
	"Method": "int getSocketTimeout(){\r\n    return JiveGlobals.getIntProperty(ConnectionSettings.Server.SOCKET_READ_TIMEOUT, 120000);\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.readSerializableCollection",
	"Comment": "reads a collection of serializable objects and adds them to the collection passed as a parameter. thecollection passed as a parameter must be a collection and not a null value.",
	"Method": "int readSerializableCollection(DataInput in,Collection<? extends Serializable> value,ClassLoader loader){\r\n    return strategy.readSerializableCollection(in, value, loader);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.rules.RuleGroupEventListener.parseGroups",
	"Comment": "returns a collection of groups obtained by parsing a comma delimited string with the name of groups.",
	"Method": "Collection<Group> parseGroups(String groupNames){\r\n    Collection<Group> answer = new HashSet<Group>();\r\n    for (String groupName : parseGroupNames(groupNames)) {\r\n        try {\r\n            answer.add(GroupManager.getInstance().getGroup(groupName));\r\n        } catch (GroupNotFoundException e) {\r\n        }\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.Roster.shareGroupRenamed",
	"Comment": "a shared group of the user has been renamed. update the existing roster items with the newname of the shared group and make a roster push for all the available resources.",
	"Method": "void shareGroupRenamed(Collection<JID> users){\r\n    JID userJID = getUserJID();\r\n    for (JID user : users) {\r\n        if (userJID.equals(user)) {\r\n            continue;\r\n        }\r\n        RosterItem item;\r\n        try {\r\n            item = getRosterItem(user);\r\n            broadcast(item, true);\r\n        } catch (UserNotFoundException e) {\r\n            Log.warn(\"Unexpected error while broadcasting shared group rename for user '{}'!\", user, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpBindManager.isScriptSyntaxEnabled",
	"Comment": "returns true if script syntax is enabled. script syntax allows bosh to be used inenvironments where clients may be restricted to using a particular server. instead of usingstandard http post requests to transmit data,http get requests are used.",
	"Method": "boolean isScriptSyntaxEnabled(){\r\n    return JiveGlobals.getBooleanProperty(\"xmpp.httpbind.scriptSyntax.enabled\", false);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.ConnectionManagerImpl.startListeners",
	"Comment": "starts all listeners. this ensures that all those that are enabled will start accept connections.",
	"Method": "void startListeners(){\r\n    Log.debug(\"Received a request to start listeners. Have plugins been loaded?\");\r\n    PluginManager pluginManager = XMPPServer.getInstance().getPluginManager();\r\n    if (!pluginManager.isExecuted()) {\r\n        Log.debug(\"Plugins not yet loaded. Waiting for plugins to be loaded...\");\r\n        pluginManager.addPluginManagerListener(new PluginManagerListener() {\r\n            public void pluginsMonitored() {\r\n                Log.debug(\"Received plugin monitor event! Plugins should now be loaded.\");\r\n                XMPPServer.getInstance().getPluginManager().removePluginManagerListener(this);\r\n                startListeners();\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    Log.debug(\"Starting listeners...\");\r\n    for (final ConnectionListener listener : getListeners()) {\r\n        try {\r\n            listener.start();\r\n            Log.debug(\"Started '{}' (port {}) listener.\", listener.getType(), listener.getPort());\r\n        } catch (RuntimeException ex) {\r\n            Log.error(\"An exception occurred while starting listener \" + listener, ex);\r\n        }\r\n    }\r\n    try {\r\n        HttpBindManager.getInstance().start();\r\n        Log.debug(\"Started HTTP client listener.\");\r\n    } catch (RuntimeException ex) {\r\n        Log.error(\"An exception occurred while starting HTTP Bind listener \", ex);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.ConnectionManagerImpl.startListeners",
	"Comment": "starts all listeners. this ensures that all those that are enabled will start accept connections.",
	"Method": "void startListeners(){\r\n    Log.debug(\"Received plugin monitor event! Plugins should now be loaded.\");\r\n    XMPPServer.getInstance().getPluginManager().removePluginManagerListener(this);\r\n    startListeners();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.models.AccessModel.valueOf",
	"Comment": "returns the specific subclass of accessmodel as specified by the accessmodel name. if an unknown name is specified then an illegalargumentexceptionis going to be thrown.",
	"Method": "AccessModel valueOf(String name){\r\n    if (\"open\".equals(name)) {\r\n        return open;\r\n    } else if (\"whitelist\".equals(name)) {\r\n        return whitelist;\r\n    } else if (\"authorize\".equals(name)) {\r\n        return authorize;\r\n    } else if (\"presence\".equals(name)) {\r\n        return presence;\r\n    } else if (\"roster\".equals(name)) {\r\n        return roster;\r\n    }\r\n    throw new IllegalArgumentException(\"Unknown access model: \" + name);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.setPublisherModel",
	"Comment": "sets the publisher model that specifies who is allowed to publish items to the node.",
	"Method": "void setPublisherModel(PublisherModel publisherModel){\r\n    this.publisherModel = publisherModel;\r\n}"
}, {
	"Path": "org.jivesoftware.util.SmsService.send",
	"Comment": "causes a new sms message to be sent.note that the message is sent asynchronously. this method does not block. a successful invocation does notguarantee successful delivery",
	"Method": "void send(String message,String recipient){\r\n    if (message == null || message.isEmpty()) {\r\n        throw new IllegalArgumentException(\"Argument 'message' cannot be null or an empty String.\");\r\n    }\r\n    if (recipient == null || recipient.isEmpty()) {\r\n        throw new IllegalArgumentException(\"Argument 'recipient' cannot be null or an empty String.\");\r\n    }\r\n    TaskEngine.getInstance().submit(new SmsTask(sessionPool, message, recipient));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.component.ExternalComponentManager.deleteConfigurationFromDB",
	"Comment": "removes any existing defined permission and configuration for the specifiedexternal component from the database.",
	"Method": "void deleteConfigurationFromDB(ExternalComponentConfiguration configuration){\r\n    if (configuration == null) {\r\n        return;\r\n    }\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(DELETE_CONFIGURATION);\r\n        pstmt.setString(1, configuration.getSubdomain() + (configuration.isWildcard() ? \"%\" : \"\"));\r\n        pstmt.setInt(2, configuration.isWildcard() ? 1 : 0);\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException sqle) {\r\n        Log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterManager.isSharedGroup",
	"Comment": "returns true if the specified group may be included in a user roster. the decision is madebased on the group properties that are configurable through the admin console.",
	"Method": "boolean isSharedGroup(Group group){\r\n    String showInRoster = group.getProperties().get(\"sharedRoster.showInRoster\");\r\n    if (\"onlyGroup\".equals(showInRoster) || \"everybody\".equals(showInRoster)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.commands.admin.GetAdminConsoleInfo.hasPermission",
	"Comment": "returns if the requester can access this command. only admins and componentsare allowed to execute this command.",
	"Method": "boolean hasPermission(JID requester){\r\n    return super.hasPermission(requester) || InternalComponentManager.getInstance().hasComponent(requester);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.handler.IQBlockingHandler.removeFromBlockList",
	"Comment": "removes a collection of jids from the blocklist of the provided user.this method removes the jids to the default privacy list. when no default privacy list exists for this user, thismethod does nothing.",
	"Method": "Set<JID> removeFromBlockList(User user,Collection<JID> toUnblocks){\r\n    final Set<JID> result = new HashSet();\r\n    if (toUnblocks == null || toUnblocks.isEmpty()) {\r\n        return result;\r\n    }\r\n    Log.debug(\"Obtain the default privacy list for '{}'\", user.getUsername());\r\n    PrivacyList defaultPrivacyList = PrivacyListManager.getInstance().getDefaultPrivacyList(user.getUsername());\r\n    if (defaultPrivacyList == null) {\r\n        return result;\r\n    }\r\n    Log.debug(\"Removing {} JIDs as blocked items from list '{}' (belonging to '{}')\", toUnblocks.size(), defaultPrivacyList.getName(), user.getUsername());\r\n    final Element listElement = defaultPrivacyList.asElement();\r\n    final Set<Element> toRemove = new HashSet();\r\n    for (final Element element : listElement.elements(\"item\")) {\r\n        final JID jid = new JID(element.attributeValue(\"value\"));\r\n        if (\"jid\".equals(element.attributeValue(\"type\")) && \"deny\".equals(element.attributeValue(\"action\")) && toUnblocks.contains(jid)) {\r\n            toRemove.add(element);\r\n            result.add(jid);\r\n        }\r\n    }\r\n    if (!toRemove.isEmpty()) {\r\n        for (final Element remove : toRemove) {\r\n            listElement.remove(remove);\r\n        }\r\n        defaultPrivacyList.updateList(listElement);\r\n        PrivacyListProvider.getInstance().updatePrivacyList(user.getUsername(), defaultPrivacyList);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SocketAcceptThread.run",
	"Comment": "about as simple as it gets.the thread spins around an acceptcall getting sockets and handing them to the socketmanager.",
	"Method": "void run(){\r\n    acceptingMode.run();\r\n    shutdown();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.DNSUtil.getDnsOverride",
	"Comment": "returns the internal dns that allows to specify target ip addresses and portsto use for domains. the internal dns will be checked up before performing anactual dns srv lookup.",
	"Method": "Map<String, HostAddress> getDnsOverride(){\r\n    return dnsOverride;\r\n}"
}, {
	"Path": "org.jivesoftware.admin.LdapUserProfile.initForOpenLDAP",
	"Comment": "sets default mapping values when using an active directory server.",
	"Method": "void initForOpenLDAP(){\r\n    name = \"{cn}\";\r\n    email = \"{mail}\";\r\n    fullName = \"{displayName}\";\r\n    nickname = \"{uid}\";\r\n    birthday = \"\";\r\n    photo = \"{jpegPhoto}\";\r\n    homeStreet = \"{homePostalAddress}\";\r\n    homeCity = \"\";\r\n    homeState = \"\";\r\n    homeZip = \"\";\r\n    homeCountry = \"\";\r\n    homePhone = \"{homePhone}\";\r\n    homeMobile = \"\";\r\n    homeFax = \"\";\r\n    homePager = \"\";\r\n    businessStreet = \"{postalAddress}\";\r\n    businessCity = \"{l}\";\r\n    businessState = \"{st}\";\r\n    businessZip = \"{postalCode}\";\r\n    businessCountry = \"\";\r\n    businessJobTitle = \"{title}\";\r\n    businessDepartment = \"{departmentNumber}\";\r\n    businessPhone = \"{telephoneNumber}\";\r\n    businessMobile = \"{mobile}\";\r\n    businessFax = \"\";\r\n    businessPager = \"{pager}\";\r\n    avatarStoredInDB = false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.multiplex.ConnectionMultiplexerManager.getNumConnectedClients",
	"Comment": "returns the number of connected clients to a specific connection manager.",
	"Method": "int getNumConnectedClients(String managerName){\r\n    Map<StreamID, LocalClientSession> clients = sessionsByManager.get(managerName);\r\n    if (clients == null) {\r\n        return 0;\r\n    } else {\r\n        return clients.size();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyListProvider.loadDatabaseContainsPrivacyLists",
	"Comment": "loads the total number of privacy lists stored in the database to know if we must use them.",
	"Method": "void loadDatabaseContainsPrivacyLists(){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(PRIVACY_LIST_COUNT);\r\n        rs = pstmt.executeQuery();\r\n        rs.next();\r\n        databaseContainsPrivacyLists.set(rs.getInt(1) != 0);\r\n    } catch (Exception e) {\r\n        Log.error(e.getMessage(), e);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.setNotifyConfigChanges",
	"Comment": "sets if subscribers are going to be notified when node configuration changes.",
	"Method": "void setNotifyConfigChanges(boolean notifyConfigChanges){\r\n    this.notifyConfigChanges = notifyConfigChanges;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.entitycaps.EntityCapabilities.containsIdentity",
	"Comment": "determines whether or not a given identity is included in these entitycapabilities.",
	"Method": "boolean containsIdentity(String category,String type){\r\n    return identities.contains(category + \"/\" + type);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.component.ExternalComponentManager.allowAccess",
	"Comment": "allows an external component to connect to the local server with the specified configuration.",
	"Method": "void allowAccess(ExternalComponentConfiguration configuration){\r\n    for (ExternalComponentManagerListener listener : listeners) {\r\n        listener.componentAllowed(configuration.getSubdomain(), configuration);\r\n    }\r\n    deleteConfigurationFromDB(configuration);\r\n    configuration.setPermission(Permission.allowed);\r\n    addConfiguration(configuration);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.multiplex.ConnectionMultiplexerManager.setDefaultSecret",
	"Comment": "sets the default secret key that connection managers should present while trying toestablish a new connection.",
	"Method": "void setDefaultSecret(String defaultSecret){\r\n    JiveGlobals.setProperty(\"xmpp.multiplex.defaultSecret\", defaultSecret);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.ConnectionListener.getPort",
	"Comment": "the tcp port number on which connections will be accepted when this listener is enabled.",
	"Method": "int getPort(){\r\n    if (tcpPortPropertyName != null) {\r\n        return JiveGlobals.getIntProperty(tcpPortPropertyName, defaultPort);\r\n    } else {\r\n        return defaultPort;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getVCardManager",
	"Comment": "returns the vcardmanager registered with this server. thevcardmanager was registered with the server as a module while starting upthe server.",
	"Method": "VCardManager getVCardManager(){\r\n    return VCardManager.getInstance();\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.isSetupMode",
	"Comment": "returns true if in setup mode. a false value means that setup has been completedor that a connection to the database was possible to properties stored in thedatabase can be retrieved now. the latter means that once the database settingsduring the setup was done a connection to the database should be available thusproperties stored from a previous setup will be available.",
	"Method": "boolean isSetupMode(){\r\n    if (Boolean.valueOf(JiveGlobals.getXMLProperty(\"setup\"))) {\r\n        return false;\r\n    }\r\n    if (DbConnectionManager.getConnectionProvider() == null) {\r\n        return true;\r\n    }\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n    } catch (SQLException e) {\r\n        return true;\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.getPort",
	"Comment": "returns the ldap server port number. the default is 389. this value isstored as the jive property ldap.port.",
	"Method": "int getPort(){\r\n    return port;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.ServerTrafficCounter.wrapInputStream",
	"Comment": "wraps the specified input stream to count the number of bytes that were read.",
	"Method": "InputStream wrapInputStream(InputStream originalStream){\r\n    return new InputStreamWrapper(originalStream);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.HybridUserProvider.setModificationDate",
	"Comment": "changes the modification date of a user in the first provider that contains the user.",
	"Method": "void setModificationDate(String username,Date modificationDate){\r\n    getUserProvider(username).setCreationDate(username, modificationDate);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.TLSStreamWriter.writeToSocket",
	"Comment": "writes outnetdata to the socketchannel.returns true when the bytebuffer has no remainingdata.",
	"Method": "boolean writeToSocket(ByteBuffer outNetData){\r\n    wbc.write(outNetData);\r\n    return !outNetData.hasRemaining();\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.readStringList",
	"Comment": "reads a list of strings. this method will return null if the listwritten to the stream was null.",
	"Method": "List<String> readStringList(DataInput in){\r\n    return strategy.readStringList(in);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getRemoteSessionLocator",
	"Comment": "returns the locator to use to find sessions hosted in other cluster nodes. when not runningin a cluster a null value is returned.",
	"Method": "RemoteSessionLocator getRemoteSessionLocator(){\r\n    return remoteSessionLocator;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.CollectionNode.removeChildNode",
	"Comment": "removes a child node from the list of child nodes. this method will not triggernotifications to node subscribers.",
	"Method": "void removeChildNode(Node child){\r\n    nodes.remove(child.getNodeID());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.component.ExternalComponentManager.blockAccess",
	"Comment": "blocks an external component from connecting to the local server. if the component wasconnected when the permission was revoked then the connection of the entity will be closed.",
	"Method": "void blockAccess(String subdomain){\r\n    for (ExternalComponentManagerListener listener : listeners) {\r\n        listener.componentBlocked(subdomain);\r\n    }\r\n    deleteConfigurationFromDB(getConfiguration(subdomain, false));\r\n    ExternalComponentConfiguration config = new ExternalComponentConfiguration(subdomain, false, Permission.blocked, null);\r\n    addConfiguration(config);\r\n    String domain = subdomain + \".\" + XMPPServer.getInstance().getServerInfo().getXMPPDomain();\r\n    Session session = SessionManager.getInstance().getComponentSession(domain);\r\n    if (session != null) {\r\n        Log.debug(\"Closing session for external component '{}' as the domain is being blocked. Affected session: {}\", domain, session);\r\n        session.close();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.Roster.getUsername",
	"Comment": "return the username of the user or chatbot that owns this roster.",
	"Method": "String getUsername(){\r\n    return username;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.getKeyword",
	"Comment": "returns the keyword that the event needs to match. when null all eventare going to be notified to the subscriber.",
	"Method": "String getKeyword(){\r\n    return keyword;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSessionDeliverable.testNamespaceOnEmptyStanza",
	"Comment": "verifies that the default namespace is set on empty stanzas.",
	"Method": "void testNamespaceOnEmptyStanza(){\r\n    final Message message = new Message();\r\n    message.addChildElement(\"unittest\", \"unit:test:namespace\");\r\n    final List<Packet> packets = new ArrayList();\r\n    packets.add(message);\r\n    final HttpSession.Deliverable deliverable = new HttpSession.Deliverable(packets);\r\n    final String result = deliverable.getDeliverable();\r\n    assertEquals(\"<message xmlns=\\\"jabber:client\\\"><unittest xmlns=\\\"unit:test:namespace\\\"/><\/message>\", result);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.streammanagement.StreamManager.formalClose",
	"Comment": "called when a session receives a closing stream tag, this prevents thesession from being detached.",
	"Method": "void formalClose(){\r\n    this.resume = false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.vcard.VCardManager.reset",
	"Comment": "resets the manager state. the cache where loaded vcards are stored will be flushed.",
	"Method": "void reset(){\r\n    vcardCache.clear();\r\n}"
}, {
	"Path": "org.jivesoftware.util.LocaleUtils.getLocalizedNumber",
	"Comment": "returns an internationalized string representation of the number usingthe specified locale.",
	"Method": "String getLocalizedNumber(long number,String getLocalizedNumber,long number,Locale locale,String getLocalizedNumber,double number,String getLocalizedNumber,double number,Locale locale){\r\n    return NumberFormat.getInstance(locale).format(number);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PubSubEngine.cancelAllSubscriptions",
	"Comment": "terminates the subscription of the specified entity to all nodes hosted at the service.the affiliation with the node will be removed if the entity was not a node owner orpublisher.",
	"Method": "void cancelAllSubscriptions(PubSubService service,JID user){\r\n    for (Node node : service.getNodes()) {\r\n        NodeAffiliate affiliate = node.getAffiliate(user);\r\n        if (affiliate == null) {\r\n            continue;\r\n        }\r\n        for (NodeSubscription subscription : affiliate.getSubscriptions()) {\r\n            node.cancelSubscription(subscription);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.isNotifyRetract",
	"Comment": "returns true if subscribers are going to be notified when items are removed from the node.",
	"Method": "boolean isNotifyRetract(){\r\n    return notifyRetract;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.interceptor.PacketRejectedException.setRejectionMessage",
	"Comment": "sets the text to include in a message that will be sent to the sender of the packetthat got rejected or null if no message will be sent to the sender of therejected packet. bt default, no message will be sent.",
	"Method": "void setRejectionMessage(String rejectionMessage){\r\n    this.rejectionMessage = rejectionMessage;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.getPublisherModel",
	"Comment": "returns the publisher model that specifies who is allowed to publish items to the node.",
	"Method": "PublisherModel getPublisherModel(){\r\n    return publisherModel;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MultiUserChatServiceImpl.getNumberConnectedUsers",
	"Comment": "retuns the total number of occupants in all rooms in the server.",
	"Method": "int getNumberConnectedUsers(boolean onlyLocal){\r\n    int total = 0;\r\n    for (LocalMUCUser user : users.values()) {\r\n        if (user.isJoined()) {\r\n            total = total + 1;\r\n        }\r\n    }\r\n    if (!onlyLocal) {\r\n        Collection<Integer> results = CacheFactory.doSynchronousClusterTask(new GetNumberConnectedUsers(), false);\r\n        for (Integer result : results) {\r\n            if (result == null) {\r\n                continue;\r\n            }\r\n            total = total + result;\r\n        }\r\n    }\r\n    return total;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.isNotifiedOfRetract",
	"Comment": "returns true if subscribers will be notified when items are removed from the node.",
	"Method": "boolean isNotifiedOfRetract(){\r\n    return notifyRetract;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.LegacyConnectionAcceptor.start",
	"Comment": "starts this acceptor by binding the socket acceptor. when the acceptor is already started, a warning will belogged and the method invocation is otherwise ignored.",
	"Method": "void start(){\r\n    if (socketAcceptThread != null) {\r\n        Log.warn(\"Unable to start acceptor (it is already started!)\");\r\n        return;\r\n    }\r\n    if (configuration.getMaxThreadPoolSize() > 1) {\r\n        Log.warn(\"Configuration allows for up to \" + configuration.getMaxThreadPoolSize() + \" threads, although implementation is limited to exactly one.\");\r\n    }\r\n    try {\r\n        socketAcceptThread = new SocketAcceptThread(configuration.getPort(), configuration.getBindAddress(), configuration.getTlsPolicy() == Connection.TLSPolicy.legacyMode);\r\n        socketAcceptThread.setDaemon(true);\r\n        socketAcceptThread.setPriority(Thread.MAX_PRIORITY);\r\n        socketAcceptThread.start();\r\n    } catch (Exception e) {\r\n        System.err.println(\"Error starting \" + configuration.getPort() + \": \" + e.getMessage());\r\n        Log.error(\"Error starting: \" + configuration.getPort(), e);\r\n        if (socketAcceptThread != null) {\r\n            try {\r\n                socketAcceptThread.shutdown();\r\n            } finally {\r\n                socketAcceptThread = null;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.LeafNode.purge",
	"Comment": "purges items that were published to the node. only owners can request this operation.this operation is only available for nodes configured to store items in the database. allpublished items will be deleted with the exception of the last published item.",
	"Method": "void purge(){\r\n    PubSubPersistenceManager.purgeNode(this);\r\n    Message message = new Message();\r\n    Element event = message.addChildElement(\"event\", \"http://jabber.org/protocol/pubsub#event\");\r\n    Element items = event.addElement(\"purge\");\r\n    items.addAttribute(\"node\", nodeID);\r\n    broadcastNodeEvent(message, false);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.security.SecurityAuditEvent.getUsername",
	"Comment": "retrieves the username of the user who performed this event.",
	"Method": "String getUsername(){\r\n    return username;\r\n}"
}, {
	"Path": "org.jivesoftware.admin.SiteMinderServletRequestAuthenticator.isEnabled",
	"Comment": "indicates if this servletrequestauthenticator is enabled or not",
	"Method": "boolean isEnabled(){\r\n    return AuthCheckFilter.isServletRequestAuthenticatorInstanceOf(SiteMinderServletRequestAuthenticator.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.AbstractGroupProvider.isSearchSupported",
	"Comment": "returns true if the provider supports group search capability. this implementationalways returns false.",
	"Method": "boolean isSearchSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.getMinorVersion",
	"Comment": "returns the major version of bosh which this session utilizes. the version refers to theversion of the xep which the connecting client implements. if the client did not specifya version 5 is returned as 1.5 is the last version of the xep that the client was notrequired to pass along its version information when creating a session.",
	"Method": "int getMinorVersion(){\r\n    if (this.minorVersion != -1) {\r\n        return this.minorVersion;\r\n    } else {\r\n        return 5;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.commands.AdHocCommandManager.saveCompletedForm",
	"Comment": "stores in the sessiondata the fields and their values as specified in the completeddata form by the user.",
	"Method": "void saveCompletedForm(Element iqCommand,SessionData session){\r\n    Element formElement = iqCommand.element(QName.get(\"x\", \"jabber:x:data\"));\r\n    if (formElement != null) {\r\n        Map<String, List<String>> data = new HashMap();\r\n        DataForm dataForm = new DataForm(formElement);\r\n        for (FormField field : dataForm.getFields()) {\r\n            data.put(field.getVariable(), field.getValues());\r\n        }\r\n        session.addStageForm(data);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.UserServicePlugin.getUserGroups",
	"Comment": "returns all group names or an empty collection for specific user",
	"Method": "Collection<String> getUserGroups(String username){\r\n    User user = getUser(username);\r\n    Collection<Group> groups = GroupManager.getInstance().getGroups(user);\r\n    Collection<String> groupNames = new ArrayList<String>();\r\n    for (Group group : groups) {\r\n        groupNames.add(group.getName());\r\n    }\r\n    return groupNames;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SocketConnection.setTlsPolicy",
	"Comment": "sets whether tls is mandatory, optional or is disabled. when tls is mandatory clientsare required to secure their connections or otherwise their connections will be closed.on the other hand, when tls is disabled clients are not allowed to secure their connectionsusing tls. their connections will be closed if they try to secure the connection. in thislast case.",
	"Method": "void setTlsPolicy(TLSPolicy tlsPolicy){\r\n    this.tlsPolicy = tlsPolicy;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MultiUserChatServiceImpl.getOutgoingMessageCount",
	"Comment": "returns the total number of outgoing messages since last reset.",
	"Method": "long getOutgoingMessageCount(boolean resetAfter){\r\n    if (resetAfter) {\r\n        return outMessages.getAndSet(0);\r\n    } else {\r\n        return outMessages.get();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.isPayloadDelivered",
	"Comment": "returns true if event notifications will include payloads. payloads are included whenpublishing new items. however, new items may not always include a payload dependingon the node configuration. nodes can be configured to not deliver payloads for performancereasons.",
	"Method": "boolean isPayloadDelivered(){\r\n    return deliverPayloads;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.writeExternalizableMap",
	"Comment": "writes a map of string key and value pairs. this method handles thecase when the map is null.",
	"Method": "void writeExternalizableMap(DataOutput out,Map<String, ? extends Externalizable> map){\r\n    strategy.writeExternalizableMap(out, map);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginMetadataHelper.getPriorToServerVersion",
	"Comment": "returns the server version up, but not including, in which this plugin can run within. the value is retrieved fromthe plugin.xml file of the plugin. if the value could not be found, null will be returned.",
	"Method": "Version getPriorToServerVersion(Plugin plugin,Version getPriorToServerVersion,Path pluginDir){\r\n    final String value = getElementValue(pluginDir, \"/plugin/priorToServerVersion\");\r\n    if (value == null || value.trim().isEmpty()) {\r\n        return null;\r\n    }\r\n    return new Version(value);\r\n}"
}, {
	"Path": "org.jivesoftware.util.XMLWriter.setEscapeText",
	"Comment": "sets whether text output should be escaped or not.this is enabled by default. it could be disabled ifthe output format is textual, like in xslt where we can havexml, html or text output.",
	"Method": "void setEscapeText(boolean escapeText){\r\n    this.escapeText = escapeText;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PubSubPersistenceManager.saveSubscription",
	"Comment": "updates the db with the new subsription of the user to the node.",
	"Method": "void saveSubscription(Node node,NodeSubscription subscription,boolean create){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        if (create) {\r\n            pstmt = con.prepareStatement(ADD_SUBSCRIPTION);\r\n            pstmt.setString(1, node.getService().getServiceID());\r\n            pstmt.setString(2, encodeNodeID(node.getNodeID()));\r\n            pstmt.setString(3, subscription.getID());\r\n            pstmt.setString(4, subscription.getJID().toString());\r\n            pstmt.setString(5, subscription.getOwner().toString());\r\n            pstmt.setString(6, subscription.getState().name());\r\n            pstmt.setInt(7, (subscription.shouldDeliverNotifications() ? 1 : 0));\r\n            pstmt.setInt(8, (subscription.isUsingDigest() ? 1 : 0));\r\n            pstmt.setInt(9, subscription.getDigestFrequency());\r\n            Date expireDate = subscription.getExpire();\r\n            if (expireDate == null) {\r\n                pstmt.setString(10, null);\r\n            } else {\r\n                pstmt.setString(10, StringUtils.dateToMillis(expireDate));\r\n            }\r\n            pstmt.setInt(11, (subscription.isIncludingBody() ? 1 : 0));\r\n            pstmt.setString(12, encodeWithComma(subscription.getPresenceStates()));\r\n            pstmt.setString(13, subscription.getType().name());\r\n            pstmt.setInt(14, subscription.getDepth());\r\n            pstmt.setString(15, subscription.getKeyword());\r\n            pstmt.executeUpdate();\r\n            subscription.setSavedToDB(true);\r\n        } else {\r\n            if (NodeSubscription.State.none == subscription.getState()) {\r\n                pstmt = con.prepareStatement(DELETE_SUBSCRIPTION);\r\n                pstmt.setString(1, node.getService().getServiceID());\r\n                pstmt.setString(2, encodeNodeID(node.getNodeID()));\r\n                pstmt.setString(2, subscription.getID());\r\n                pstmt.executeUpdate();\r\n            } else {\r\n                pstmt = con.prepareStatement(UPDATE_SUBSCRIPTION);\r\n                pstmt.setString(1, subscription.getOwner().toString());\r\n                pstmt.setString(2, subscription.getState().name());\r\n                pstmt.setInt(3, (subscription.shouldDeliverNotifications() ? 1 : 0));\r\n                pstmt.setInt(4, (subscription.isUsingDigest() ? 1 : 0));\r\n                pstmt.setInt(5, subscription.getDigestFrequency());\r\n                Date expireDate = subscription.getExpire();\r\n                if (expireDate == null) {\r\n                    pstmt.setString(6, null);\r\n                } else {\r\n                    pstmt.setString(6, StringUtils.dateToMillis(expireDate));\r\n                }\r\n                pstmt.setInt(7, (subscription.isIncludingBody() ? 1 : 0));\r\n                pstmt.setString(8, encodeWithComma(subscription.getPresenceStates()));\r\n                pstmt.setString(9, subscription.getType().name());\r\n                pstmt.setInt(10, subscription.getDepth());\r\n                pstmt.setString(11, subscription.getKeyword());\r\n                pstmt.setString(12, node.getService().getServiceID());\r\n                pstmt.setString(13, encodeNodeID(node.getNodeID()));\r\n                pstmt.setString(14, subscription.getID());\r\n                pstmt.executeUpdate();\r\n            }\r\n        }\r\n    } catch (SQLException sqle) {\r\n        log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.Roster.isRosterItem",
	"Comment": "returns true if the specified user is a member of the roster, false otherwise.",
	"Method": "boolean isRosterItem(JID user){\r\n    return rosterItems.containsKey(user.toBareJID()) || getImplicitRosterItem(user) != null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.setFollowAliasReferralsEnabled",
	"Comment": "sets whether ldap alias referrals should be automatically followed.",
	"Method": "void setFollowAliasReferralsEnabled(boolean followAliasReferrals){\r\n    this.followAliasReferrals = followAliasReferrals;\r\n    properties.put(\"ldap.autoFollowAliasReferrals\", String.valueOf(followAliasReferrals));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.IQRouter.removeHandler",
	"Comment": "removes an iqhandler from the list of registered handler. the iqhandler to remove wasresponsible for handling iq packet whose namespace matches the namespace of theiqhandler.an illegalargumentexception may be thrown if the iqhandler to remove was already providedby the server. the server provides a certain list of iqhandlers when the server isstarted up.",
	"Method": "void removeHandler(IQHandler handler){\r\n    if (iqHandlers.contains(handler)) {\r\n        throw new IllegalArgumentException(\"Cannot remove an IQHandler provided by the server\");\r\n    }\r\n    namespace2Handlers.remove(handler.getInfo().getNamespace());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.getID",
	"Comment": "returns the id that uniquely identifies the subscription of the user in the node.",
	"Method": "String getID(){\r\n    return id;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyListManager.deletePrivacyLists",
	"Comment": "deletes all privacy lists of a user. this may be necessary when a user is beingdeleted from the system.",
	"Method": "void deletePrivacyLists(String username){\r\n    for (String listName : provider.getPrivacyLists(username).keySet()) {\r\n        listsCache.remove(getCacheKey(username, listName));\r\n        for (PrivacyListEventListener listener : listeners) {\r\n            listener.privacyListDeleting(listName);\r\n        }\r\n    }\r\n    provider.deletePrivacyLists(username);\r\n}"
}, {
	"Path": "org.jivesoftware.database.DbConnectionManager.setProfilingEnabled",
	"Comment": "turns connection profiling on or off. you can collect profilingstatistics by using the static methods of the profiledconnectionclass.",
	"Method": "void setProfilingEnabled(boolean enable){\r\n    if (!profilingEnabled && enable) {\r\n        ProfiledConnection.start();\r\n    } else if (profilingEnabled && !enable) {\r\n        ProfiledConnection.stop();\r\n    }\r\n    profilingEnabled = enable;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.cluster.ClusterManager.isClusteringEnabled",
	"Comment": "returns true if clustering support is enabled. this does not meanthat clustering has started or that clustering will be able to start.",
	"Method": "boolean isClusteringEnabled(){\r\n    return JiveGlobals.getXMLProperty(CLUSTER_PROPERTY_NAME, false);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.handler.IQPrivacyHandler.declineDefaultList",
	"Comment": "user has specified that there is no default list that should be used for this user.",
	"Method": "IQ declineDefaultList(IQ packet,JID from){\r\n    IQ result = IQ.createResultIQ(packet);\r\n    Element childElement = packet.getChildElement().createCopy();\r\n    result.setChildElement(childElement);\r\n    if (sessionManager.getSessionCount(from.getNode()) > 1) {\r\n        result.setError(PacketError.Condition.conflict);\r\n    } else {\r\n        ClientSession session = sessionManager.getSession(from);\r\n        if (session.getDefaultList() != null) {\r\n            session.getDefaultList().setDefaultList(false);\r\n            provider.updatePrivacyList(from.getNode(), session.getDefaultList());\r\n            session.setDefaultList(null);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SASLAuthentication.setEnabledMechanisms",
	"Comment": "sets the collection of mechanism names that the system administrator allows to be used.",
	"Method": "void setEnabledMechanisms(List<String> mechanisms){\r\n    JiveGlobals.setProperty(\"sasl.mechs\", mechanisms);\r\n    initMechanisms();\r\n}"
}, {
	"Path": "org.jivesoftware.util.Version.getStatusVersion",
	"Comment": "obtain the status release number for this product. for example, ifthe release status is alpha the release may be 5resulting in a release status of alpha 5.",
	"Method": "int getStatusVersion(){\r\n    return statusVersion;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.Update.getChangelog",
	"Comment": "returns the url to the change log of the latest version of the component.",
	"Method": "String getChangelog(){\r\n    return changelog;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.server.RemoteServerManager.blockAccess",
	"Comment": "blocks a remote server from connecting to the local server. if the remote server wasconnected when the permission was revoked then the connection of the entity will be closed.",
	"Method": "void blockAccess(String domain){\r\n    deleteConfiguration(domain);\r\n    RemoteServerConfiguration config = new RemoteServerConfiguration(domain);\r\n    config.setPermission(Permission.blocked);\r\n    addConfiguration(config);\r\n    for (Session session : SessionManager.getInstance().getIncomingServerSessions(domain)) {\r\n        Log.debug(\"Closing session for domain '{}' as the domain is being blocked. Affected session: {}\", domain, session);\r\n        session.close();\r\n    }\r\n    for (DomainPair domainPair : SessionManager.getInstance().getOutgoingDomainPairs()) {\r\n        if (domainPair.getRemote().equals(domain)) {\r\n            Session session = SessionManager.getInstance().getOutgoingServerSession(domainPair);\r\n            Log.debug(\"Closing (domain-pair) session for domain '{}' as the domain is being blocked. Affected session: {}\", domain, session);\r\n            session.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.CertificateUtils.toTrustAnchors",
	"Comment": "transforms a collection of certificates into trustanchor instances.this method does not set the nameconstraints parameter of the generated trustanchors.the return value of this method is a set, which means that duplicate certificates in the input are implicitlybeing removed from the result.",
	"Method": "Set<TrustAnchor> toTrustAnchors(X509Certificate certificates,Set<TrustAnchor> toTrustAnchors,Collection<X509Certificate> certificates){\r\n    if (certificates == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    return toTrustAnchors(certificates.toArray(new X509Certificate[certificates.size()]));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pep.IQPEPHandler.startExecutor",
	"Comment": "starts a new thread pool, unless an existing one is still running.",
	"Method": "void startExecutor(){\r\n    if (executor == null || executor.isShutdown()) {\r\n        Log.debug(\"Starting executor service...\");\r\n        executor = Executors.newScheduledThreadPool(2);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getPresenceManager",
	"Comment": "returns the presencemanager registered with this server. thepresencemanager was registered with the server as a module while starting upthe server.",
	"Method": "PresenceManager getPresenceManager(){\r\n    return (PresenceManager) modules.get(PresenceManagerImpl.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.server.RemoteServerManager.canAccess",
	"Comment": "returns true if the remote server with the specified domain can connect to thelocal server.",
	"Method": "boolean canAccess(String domain){\r\n    if (!JiveGlobals.getBooleanProperty(ConnectionSettings.Server.SOCKET_ACTIVE, true)) {\r\n        return false;\r\n    }\r\n    Permission permission = null;\r\n    RemoteServerConfiguration config = getConfiguration(domain);\r\n    if (config != null) {\r\n        permission = config.getPermission();\r\n    }\r\n    if (PermissionPolicy.blacklist == getPermissionPolicy()) {\r\n        return Permission.blocked != permission;\r\n    } else {\r\n        return Permission.allowed == permission;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.EncryptionArtifactFactory.getDefaultCipherSuites",
	"Comment": "returns the names of all encryption cipher suites that are enabled by default.",
	"Method": "List<String> getDefaultCipherSuites(){\r\n    final SSLContext context = SSLContext.getInstance(\"TLSv1\");\r\n    context.init(null, null, null);\r\n    return Arrays.asList(context.createSSLEngine().getEnabledCipherSuites());\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.MITREidDataService_1_3.readSystemScopes",
	"Comment": "read the list of system scopes from the reader and insert them into the\tscope repository.",
	"Method": "void readSystemScopes(JsonReader reader){\r\n    reader.beginArray();\r\n    while (reader.hasNext()) {\r\n        SystemScope scope = new SystemScope();\r\n        reader.beginObject();\r\n        while (reader.hasNext()) {\r\n            switch(reader.peek()) {\r\n                case END_OBJECT:\r\n                    continue;\r\n                case NAME:\r\n                    String name = reader.nextName();\r\n                    if (reader.peek() == JsonToken.NULL) {\r\n                        reader.skipValue();\r\n                    } else if (name.equals(VALUE)) {\r\n                        scope.setValue(reader.nextString());\r\n                    } else if (name.equals(DESCRIPTION)) {\r\n                        scope.setDescription(reader.nextString());\r\n                    } else if (name.equals(RESTRICTED)) {\r\n                        scope.setRestricted(reader.nextBoolean());\r\n                    } else if (name.equals(DEFAULT_SCOPE)) {\r\n                        scope.setDefaultScope(reader.nextBoolean());\r\n                    } else if (name.equals(ICON)) {\r\n                        scope.setIcon(reader.nextString());\r\n                    } else {\r\n                        logger.debug(\"found unexpected entry\");\r\n                        reader.skipValue();\r\n                    }\r\n                    break;\r\n                default:\r\n                    logger.debug(\"Found unexpected entry\");\r\n                    reader.skipValue();\r\n                    continue;\r\n            }\r\n        }\r\n        reader.endObject();\r\n        sysScopeRepository.save(scope);\r\n    }\r\n    reader.endArray();\r\n    logger.info(\"Done reading system scopes\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.interceptor.InterceptorManager.addUserInterceptor",
	"Comment": "inserts a new interceptor at specified index in the list of currently configuredinterceptors for a specific username. this interceptor will be used only when a packetwas sent or received by the specified username.",
	"Method": "void addUserInterceptor(String username,int index,PacketInterceptor interceptor){\r\n    List<PacketInterceptor> userInterceptors = usersInterceptors.get(username);\r\n    if (userInterceptors == null) {\r\n        userInterceptors = new CopyOnWriteArrayList();\r\n        usersInterceptors.put(username, userInterceptors);\r\n    } else {\r\n        if (index < 0 || (index > userInterceptors.size())) {\r\n            throw new IndexOutOfBoundsException(\"Index \" + index + \" invalid.\");\r\n        }\r\n        if (interceptor == null) {\r\n            throw new NullPointerException(\"Parameter interceptor was null.\");\r\n        }\r\n        if (userInterceptors.contains(interceptor)) {\r\n            int oldIndex = userInterceptors.indexOf(interceptor);\r\n            if (oldIndex < index) {\r\n                index -= 1;\r\n            }\r\n            userInterceptors.remove(interceptor);\r\n        }\r\n    }\r\n    userInterceptors.add(index, interceptor);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.HistoryStrategy.addMessage",
	"Comment": "add a message to the current chat history. the strategy type will determine what actually happens to the message.",
	"Method": "void addMessage(Message packet){\r\n    Type strategyType;\r\n    int strategyMaxNumber;\r\n    if (type == Type.defaulType && parent != null) {\r\n        strategyType = parent.getType();\r\n        strategyMaxNumber = parent.getMaxNumber();\r\n    } else {\r\n        strategyType = type;\r\n        strategyMaxNumber = maxNumber;\r\n    }\r\n    boolean subjectChange = isSubjectChangeRequest(packet);\r\n    if (subjectChange) {\r\n        roomSubject = packet;\r\n        return;\r\n    }\r\n    if (strategyType == Type.all) {\r\n        history.add(packet);\r\n    } else if (strategyType == Type.number) {\r\n        if (history.size() >= strategyMaxNumber) {\r\n            Iterator<Message> historyIter = history.iterator();\r\n            while (historyIter.hasNext() && history.size() >= strategyMaxNumber) {\r\n                if (historyIter.next() != roomSubject) {\r\n                    historyIter.remove();\r\n                }\r\n            }\r\n        }\r\n        history.add(packet);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.IdentityStore.replaceCertificate",
	"Comment": "imports a certificate and the private key that was used to generate the certificate, replacing any previouslyinstalled entries for the same domain.this method will import the certificate and key in the store using a unique alias. this alias is returned.this method will fail when the provided certificate does not match the domain of this xmpp service.",
	"Method": "String replaceCertificate(String pemCertificates,String pemPrivateKey,String passPhrase){\r\n    if (pemCertificates == null || pemCertificates.trim().isEmpty()) {\r\n        throw new IllegalArgumentException(\"Argument 'pemCertificates' cannot be null or an empty String.\");\r\n    }\r\n    if (pemPrivateKey == null || pemPrivateKey.trim().isEmpty()) {\r\n        throw new IllegalArgumentException(\"Argument 'pemPrivateKey' cannot be null or an empty String.\");\r\n    }\r\n    pemCertificates = pemCertificates.trim();\r\n    try {\r\n        final Collection<X509Certificate> certificates = CertificateManager.parseCertificates(pemCertificates);\r\n        if (certificates.isEmpty()) {\r\n            throw new CertificateStoreConfigException(\"No certificate was found in the input.\");\r\n        }\r\n        final List<X509Certificate> ordered = CertificateUtils.order(certificates);\r\n        if (!isForThisDomain(ordered.get(0))) {\r\n            throw new CertificateStoreConfigException(\"The supplied certificate chain does not cover the domain of this XMPP service.\");\r\n        }\r\n        final PrivateKey privateKey = CertificateManager.parsePrivateKey(pemPrivateKey, passPhrase);\r\n        removeAllDomainEntries();\r\n        final String alias = generateUniqueAlias();\r\n        store.setKeyEntry(alias, privateKey, configuration.getPassword(), ordered.toArray(new X509Certificate[ordered.size()]));\r\n        persist();\r\n        Log.info(\"Replaced all private keys and corresponding certificate chains with a new private key and certificate chain.\");\r\n        return alias;\r\n    } catch (CertificateException | KeyStoreException | IOException e) {\r\n        reload();\r\n        throw new CertificateStoreConfigException(\"Unable to install a certificate into an identity store.\", e);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheFactory.getClusterNodesInfo",
	"Comment": "returns basic information about the current members of the cluster or an emptycollection if not running in a cluster.",
	"Method": "Collection<ClusterNodeInfo> getClusterNodesInfo(){\r\n    return cacheFactoryStrategy.getClusterNodesInfo();\r\n}"
}, {
	"Path": "org.mitre.data.AbstractPageOperationTemplateTest.execute_nonzerotime",
	"Comment": "this is a valid test however it is vulnerable to a race condition\tas such it is being ignored.",
	"Method": "void execute_nonzerotime(){\r\n    Long timeMillis = 200L;\r\n    CountingPageOperation op = new CountingPageOperation(Integer.MAX_VALUE, timeMillis);\r\n    op.execute();\r\n    assertFalse(\"last fetch time \" + op.getTimeToLastFetch() + \"\" + \" and previous fetch time  \" + op.getTimeToPreviousFetch() + \" exceed max time\" + timeMillis, op.getTimeToLastFetch() > timeMillis && op.getTimeToPreviousFetch() > timeMillis);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SocketAcceptThread.getServerPort",
	"Comment": "returns information about the port on which the server is listening for connections.",
	"Method": "ServerPort getServerPort(){\r\n    return new ServerPort(tcpPort, null, bindInterface.getHostName(), directTLS, null, ServerPort.Type.server);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.StanzaHandler.compressClient",
	"Comment": "start using compression but first check if the connection can and should use compression.the connection will be closed if the requested method is not supported, if the connectionis already using compression or if client requested to use compression but this featureis disabled.",
	"Method": "boolean compressClient(Element doc){\r\n    String error = null;\r\n    if (connection.getCompressionPolicy() == Connection.CompressionPolicy.disabled) {\r\n        error = \"<failure xmlns='http://jabber.org/protocol/compress'><setup-failed/><\/failure>\";\r\n        Log.warn(\"Client requested compression while compression is disabled. Closing \" + \"connection : \" + connection);\r\n    } else if (connection.isCompressed()) {\r\n        error = \"<failure xmlns='http://jabber.org/protocol/compress'><setup-failed/><\/failure>\";\r\n        Log.warn(\"Client requested compression and connection is already compressed. Closing \" + \"connection : \" + connection);\r\n    } else {\r\n        String method = doc.elementText(\"method\");\r\n        if (!\"zlib\".equals(method)) {\r\n            error = \"<failure xmlns='http://jabber.org/protocol/compress'><unsupported-method/><\/failure>\";\r\n            Log.warn(\"Requested compression method is not supported: \" + method + \". Closing connection : \" + connection);\r\n        }\r\n    }\r\n    if (error != null) {\r\n        connection.deliverRawText(error);\r\n        return false;\r\n    } else {\r\n        connection.addCompression();\r\n        connection.deliverRawText(\"<compressed xmlns='http://jabber.org/protocol/compress'/>\");\r\n        connection.startCompression();\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.BeanUtils.encode",
	"Comment": "encodes a bean property value as a string. if the object type is notsupported, null will be returned.",
	"Method": "String encode(Object value){\r\n    if (value instanceof String) {\r\n        return (String) value;\r\n    }\r\n    if (value instanceof Boolean || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double) {\r\n        return value.toString();\r\n    }\r\n    if (value instanceof Date) {\r\n        try {\r\n            return dateFormatter.format((Date) value);\r\n        } catch (Exception ignored) {\r\n        }\r\n    }\r\n    if (value instanceof Color) {\r\n        Color color = (Color) value;\r\n        return color.getRed() + \",\" + color.getGreen() + \",\" + color.getBlue();\r\n    }\r\n    if (value instanceof Class) {\r\n        return ((Class) value).getName();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getIQRegisterHandler",
	"Comment": "returns the iqregisterhandler registered with this server. theiqregisterhandler was registered with the server as a module while starting upthe server.",
	"Method": "IQRegisterHandler getIQRegisterHandler(){\r\n    return (IQRegisterHandler) modules.get(IQRegisterHandler.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginClassLoader.addURLFile",
	"Comment": "add the given url to the classpath for this class loader, caching the jar file connection so it can be unloaded later",
	"Method": "void addURLFile(URL file){\r\n    try {\r\n        URLConnection uc = file.openConnection();\r\n        if (uc instanceof JarURLConnection) {\r\n            uc.setUseCaches(true);\r\n            ((JarURLConnection) uc).getManifest();\r\n            cachedJarFiles.add((JarURLConnection) uc);\r\n        }\r\n    } catch (Exception e) {\r\n        Log.warn(\"Failed to cache plugin JAR file: \" + file.toExternalForm());\r\n    }\r\n    addURL(file);\r\n}"
}, {
	"Path": "org.jivesoftware.database.DbConnectionManager.createScrollablePreparedStatement",
	"Comment": "creates a scroll insensitive preparedstatement if the jdbc driver supports it, or a normalpreparedstatement otherwise.",
	"Method": "PreparedStatement createScrollablePreparedStatement(Connection con,String sql){\r\n    if (isScrollResultsSupported()) {\r\n        return con.prepareStatement(sql, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\r\n    } else {\r\n        return con.prepareStatement(sql);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.DefaultGroupPropertyMap.deleteProperty",
	"Comment": "delete a group property from the database for the current group",
	"Method": "void deleteProperty(String key){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(DELETE_PROPERTY);\r\n        pstmt.setString(1, group.getName());\r\n        pstmt.setString(2, key);\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException e) {\r\n        logger.error(e.getMessage(), e);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n    Map<String, Object> event = new HashMap();\r\n    event.put(\"type\", \"propertyDeleted\");\r\n    event.put(\"propertyKey\", key);\r\n    GroupEventDispatcher.dispatchEvent(group, GroupEventDispatcher.EventType.group_modified, event);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.isAdmin",
	"Comment": "returns true if the specified user is allowed to administer the node. nodeadministrator are allowed to retrieve the node configuration, change the nodeconfiguration, purge the node, delete the node and get the node affiliations andsubscriptions.",
	"Method": "boolean isAdmin(JID user){\r\n    if (getOwners().contains(user) || service.isServiceAdmin(user)) {\r\n        return true;\r\n    }\r\n    if (user.getResource() != null) {\r\n        user = user.asBareJID();\r\n        return isAdmin(user);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.token.TofuUserApprovalHandler.setAuthTime",
	"Comment": "get the auth time out of the current session and add it to the\tauth request in the extensions map.",
	"Method": "void setAuthTime(AuthorizationRequest authorizationRequest){\r\n    ServletRequestAttributes attr = (ServletRequestAttributes) RequestContextHolder.currentRequestAttributes();\r\n    if (attr != null) {\r\n        HttpSession session = attr.getRequest().getSession();\r\n        if (session != null) {\r\n            Date authTime = (Date) session.getAttribute(AuthenticationTimeStamper.AUTH_TIMESTAMP);\r\n            if (authTime != null) {\r\n                String authTimeString = Long.toString(authTime.getTime());\r\n                authorizationRequest.getExtensions().put(AuthenticationTimeStamper.AUTH_TIMESTAMP, authTimeString);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpConnection.isClosed",
	"Comment": "returns true if this connection has been closed, either a response was delivered to theclient or the server closed the connection abruptly.",
	"Method": "boolean isClosed(){\r\n    return isClosed;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.nio.NIOConnection.notifyCloseListeners",
	"Comment": "notifies all close listeners that the connection has been closed.used by subclasses to properly finish closing the connection.",
	"Method": "void notifyCloseListeners(){\r\n    if (closeListener != null) {\r\n        try {\r\n            closeListener.onConnectionClose(session);\r\n        } catch (Exception e) {\r\n            Log.error(\"Error notifying listener: \" + closeListener, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getConnectionsCount",
	"Comment": "returns number of client sessions that are connected to the server. sessions thatare authenticated and not authenticated will be included",
	"Method": "int getConnectionsCount(boolean onlyLocal){\r\n    int total = connectionsCounter.get();\r\n    if (!onlyLocal) {\r\n        Collection<Integer> results = CacheFactory.doSynchronousClusterTask(new GetSessionsCountTask(false), false);\r\n        for (Integer result : results) {\r\n            if (result == null) {\r\n                continue;\r\n            }\r\n            total = total + result;\r\n        }\r\n    }\r\n    return total;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MultiUserChatServiceImpl.addExtraFeature",
	"Comment": "adds an extra disco feature to the list of features returned for the conference service.",
	"Method": "void addExtraFeature(String feature){\r\n    extraDiscoFeatures.add(feature);\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ClientDetailsEntityService.ensureRefreshTokenConsistency",
	"Comment": "make sure the client has the appropriate scope and grant type.",
	"Method": "void ensureRefreshTokenConsistency(ClientDetailsEntity client){\r\n    if (client.getAuthorizedGrantTypes().contains(\"refresh_token\") || client.getScope().contains(SystemScopeService.OFFLINE_ACCESS)) {\r\n        client.getScope().add(SystemScopeService.OFFLINE_ACCESS);\r\n        client.getAuthorizedGrantTypes().add(\"refresh_token\");\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.TestDefaultUserInfoService.prepare",
	"Comment": "initialize the service and the mocked repository.\tinitialize 2 users, one of them an admin, for use in unit tests.",
	"Method": "void prepare(){\r\n    userInfoAdmin = new DefaultUserInfo();\r\n    userInfoAdmin.setPreferredUsername(adminUsername);\r\n    userInfoAdmin.setSub(adminSub);\r\n    userInfoRegular = new DefaultUserInfo();\r\n    userInfoRegular.setPreferredUsername(regularUsername);\r\n    userInfoRegular.setSub(regularSub);\r\n    publicClient1 = new ClientDetailsEntity();\r\n    publicClient1.setClientId(publicClientId1);\r\n    publicClient2 = new ClientDetailsEntity();\r\n    publicClient2.setClientId(publicClientId2);\r\n    publicClient2.setSubjectType(SubjectType.PUBLIC);\r\n    pairwiseClient1 = new ClientDetailsEntity();\r\n    pairwiseClient1.setClientId(pairwiseClientId1);\r\n    pairwiseClient1.setSubjectType(SubjectType.PAIRWISE);\r\n    pairwiseClient1.setSectorIdentifierUri(sectorIdentifier1);\r\n    pairwiseClient2 = new ClientDetailsEntity();\r\n    pairwiseClient2.setClientId(pairwiseClientId2);\r\n    pairwiseClient2.setSubjectType(SubjectType.PAIRWISE);\r\n    pairwiseClient2.setSectorIdentifierUri(sectorIdentifier2);\r\n    pairwiseClient3 = new ClientDetailsEntity();\r\n    pairwiseClient3.setClientId(pairwiseClientId3);\r\n    pairwiseClient3.setSubjectType(SubjectType.PAIRWISE);\r\n    pairwiseClient3.setSectorIdentifierUri(sectorIdentifier3);\r\n    pairwiseClient4 = new ClientDetailsEntity();\r\n    pairwiseClient4.setClientId(pairwiseClientId4);\r\n    pairwiseClient4.setSubjectType(SubjectType.PAIRWISE);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.cluster.QueuedTasksManager.addTask",
	"Comment": "queues a task. the queued task will be executed once this jvm completed joining the cluster.moreover, if joining the cluster failed then the queue will also be consumed.",
	"Method": "void addTask(MUCRoomTask task){\r\n    taskQueue.add(task);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.Roster.broadcastPresence",
	"Comment": "broadcast the presence update to all subscribers of the roter.any presence change typically results in a broadcast to the roster members.",
	"Method": "void broadcastPresence(Presence packet){\r\n    final RoutingTable routingTable = XMPPServer.getInstance().getRoutingTable();\r\n    if (routingTable == null) {\r\n        return;\r\n    }\r\n    PrivacyList list = null;\r\n    JID from = packet.getFrom();\r\n    if (from != null) {\r\n        ClientSession session = SessionManager.getInstance().getSession(from);\r\n        if (session != null) {\r\n            list = session.getActiveList();\r\n            list = list == null ? session.getDefaultList() : list;\r\n        }\r\n    }\r\n    if (list == null) {\r\n        list = PrivacyListManager.getInstance().getDefaultPrivacyList(username);\r\n    }\r\n    for (RosterItem item : rosterItems.values()) {\r\n        if (item.getSubStatus() == RosterItem.SUB_BOTH || item.getSubStatus() == RosterItem.SUB_FROM) {\r\n            packet.setTo(item.getJid());\r\n            if (list != null && list.shouldBlockPacket(packet)) {\r\n                continue;\r\n            }\r\n            JID searchNode = new JID(item.getJid().getNode(), item.getJid().getDomain(), null, true);\r\n            for (JID jid : routingTable.getRoutes(searchNode, null)) {\r\n                try {\r\n                    routingTable.routePacket(jid, packet, false);\r\n                } catch (Exception e) {\r\n                    Log.debug(e.getMessage(), e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (String contact : implicitFrom.keySet()) {\r\n        if (contact.contains(\"@\")) {\r\n            String node = contact.substring(0, contact.lastIndexOf(\"@\"));\r\n            String domain = contact.substring(contact.lastIndexOf(\"@\") + 1);\r\n            node = JID.escapeNode(node);\r\n            contact = new JID(node, domain, null).toBareJID();\r\n        }\r\n        packet.setTo(contact);\r\n        if (list != null && list.shouldBlockPacket(packet)) {\r\n            continue;\r\n        }\r\n        for (JID jid : routingTable.getRoutes(new JID(contact), null)) {\r\n            try {\r\n                routingTable.routePacket(jid, packet, false);\r\n            } catch (Exception e) {\r\n                Log.debug(e.getMessage(), e);\r\n            }\r\n        }\r\n    }\r\n    if (from != null) {\r\n        SessionManager.getInstance().broadcastPresenceToResources(from, packet);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheFactory.doSynchronousClusterTask",
	"Comment": "invokes a task on a given cluster member synchronously and returns the result ofthe remote operation. if clustering is not enabled, this method will return null.",
	"Method": "Collection<T> doSynchronousClusterTask(ClusterTask<T> task,boolean includeLocalMember,T doSynchronousClusterTask,ClusterTask<T> task,byte[] nodeID){\r\n    return cacheFactoryStrategy.doSynchronousClusterTask(task, nodeID);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.CertificateStoreManager.getIdentityStorePassword",
	"Comment": "the password of the identity store for connection created by this listener.",
	"Method": "String getIdentityStorePassword(ConnectionType type){\r\n    final String propertyName = type.getPrefix() + \"keypass\";\r\n    final String defaultValue = \"changeit\";\r\n    if (type.getFallback() == null) {\r\n        return JiveGlobals.getProperty(propertyName, defaultValue).trim();\r\n    } else {\r\n        return JiveGlobals.getProperty(propertyName, getIdentityStorePassword(type.getFallback())).trim();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.Group.search",
	"Comment": "search for a jid within a group. if the given haystack is not resolvableto a group, this method returns false.",
	"Method": "boolean search(JID needle,Object haystack){\r\n    Group group = resolveFrom(haystack);\r\n    return (group != null && group.isUser(needle));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.lockout.DefaultLockOutProvider.unsetDisabledStatus",
	"Comment": "default provider deletes existing flag from ofuserflag table.",
	"Method": "void unsetDisabledStatus(String username){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(DELETE_FLAG);\r\n        pstmt.setString(1, username);\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException sqle) {\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeAffiliate.getSubscriptions",
	"Comment": "returns the list of subscriptions of the affiliate in the node.",
	"Method": "Collection<NodeSubscription> getSubscriptions(){\r\n    return node.getSubscriptions(jid);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.security.SecurityAuditManager.getEvents",
	"Comment": "retrieves security events that have occurred, filtered by the parameters passed.the events will be in order of most recent to least recent.any parameters that are left null are to be ignored.in other words, if username is null,then no specific username is being searched for.",
	"Method": "List<SecurityAuditEvent> getEvents(String username,Integer skipEvents,Integer numEvents,Date startTime,Date endTime){\r\n    if (provider.isWriteOnly()) {\r\n        throw new AuditWriteOnlyException();\r\n    }\r\n    return provider.getEvents(username, skipEvents, numEvents, startTime, endTime);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.CertificateStore.backup",
	"Comment": "copies the file that is the persistent storage for this store to a new file in the backup location.",
	"Method": "Path backup(){\r\n    final String postfix = \".\" + new Date().getTime();\r\n    final Path original = configuration.getFile().toPath();\r\n    final Path backup = configuration.getBackupDirectory().toPath().resolve(original.getFileName() + postfix);\r\n    Log.info(\"Creating a backup of {} in {}.\", original, backup);\r\n    try {\r\n        Files.copy(original, backup);\r\n        return backup;\r\n    } catch (IOException e) {\r\n        Log.error(\"An error occurred creating a backup of {} in {}!\", original, backup, e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.readExternalizableCollection",
	"Comment": "reads a collection of externalizable objects and adds them to the collection passed as a parameter. thecollection passed as a parameter must be a collection and not a null value.",
	"Method": "int readExternalizableCollection(DataInput in,Collection<? extends Externalizable> value,ClassLoader loader){\r\n    return strategy.readExternalizableCollection(in, value, loader);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getPluginManager",
	"Comment": "returns the pluginmanager instance registered with this server.",
	"Method": "PluginManager getPluginManager(){\r\n    return pluginManager;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.nio.ConnectionHandler.updateReadBytesCounter",
	"Comment": "updates the system counter of read bytes. this information is used by the incomingbytes statistic.",
	"Method": "void updateReadBytesCounter(IoSession session){\r\n    long currentBytes = session.getReadBytes();\r\n    Long prevBytes = (Long) session.getAttribute(\"_read_bytes\");\r\n    long delta;\r\n    if (prevBytes == null) {\r\n        delta = currentBytes;\r\n    } else {\r\n        delta = currentBytes - prevBytes;\r\n    }\r\n    session.setAttribute(\"_read_bytes\", currentBytes);\r\n    ServerTrafficCounter.incrementIncomingCounter(delta);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.security.SecurityAuditEvent.setNode",
	"Comment": "sets the node that triggered the event, usually a hostname or ip address.",
	"Method": "void setNode(String node){\r\n    this.node = node;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.DefaultGroupPropertyMap.insertProperty",
	"Comment": "persist a new group property to the database for the current group",
	"Method": "void insertProperty(String key,String value){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(INSERT_PROPERTY);\r\n        pstmt.setString(1, group.getName());\r\n        pstmt.setString(2, key);\r\n        pstmt.setString(3, value);\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException e) {\r\n        logger.error(e.getMessage(), e);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n    Map<String, Object> event = new HashMap();\r\n    event.put(\"propertyKey\", key);\r\n    event.put(\"type\", \"propertyAdded\");\r\n    GroupEventDispatcher.dispatchEvent(group, GroupEventDispatcher.EventType.group_modified, event);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSessionManager.stop",
	"Comment": "stops any services and cleans up any resources used by the httpsessionmanager.",
	"Method": "void stop(){\r\n    Log.info(\"Stopping instance\");\r\n    inactivityTask.cancel();\r\n    for (HttpSession session : sessionMap.values()) {\r\n        Log.debug(\"Closing as session manager instance is being stopped: {}\", session);\r\n        session.close();\r\n    }\r\n    sessionMap.clear();\r\n    sendPacketPool.shutdown();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getMulticastRouter",
	"Comment": "returns the multicastrouter registered with this server. themulticastrouter was registered with the server as a module while starting upthe server.",
	"Method": "MulticastRouter getMulticastRouter(){\r\n    return (MulticastRouter) modules.get(MulticastRouter.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.isDescendantNode",
	"Comment": "returns true if the specified node is a direct child node of this node ora descendant of the children nodes.",
	"Method": "boolean isDescendantNode(Node child){\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MultiUserChatServiceImpl.addExtraIdentity",
	"Comment": "adds an extra disco identity to the list of identities returned for the conference service.",
	"Method": "void addExtraIdentity(String category,String name,String type){\r\n    Element identity = DocumentHelper.createElement(\"identity\");\r\n    identity.addAttribute(\"category\", category);\r\n    identity.addAttribute(\"name\", name);\r\n    identity.addAttribute(\"type\", type);\r\n    extraDiscoIdentities.add(identity);\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.readStringMap",
	"Comment": "reads a map of string key and value pairs. this method will returnnull if the map written to the stream was null.",
	"Method": "Map<String, String> readStringMap(DataInput in){\r\n    return strategy.readStringMap(in);\r\n}"
}, {
	"Path": "org.jivesoftware.util.XMLProperties.migrateProperty",
	"Comment": "convenience routine to migrate an xml property into the databasestorage method.will check for the xml property being null beforemigrating.",
	"Method": "void migrateProperty(String name){\r\n    final String xmlPropertyValue = getProperty(name);\r\n    if (xmlPropertyValue != null) {\r\n        final String databasePropertyValue = JiveGlobals.getProperty(name);\r\n        if (databasePropertyValue == null) {\r\n            Log.debug(\"JiveGlobals: Migrating XML property '\" + name + \"' into database.\");\r\n            JiveGlobals.setProperty(name, xmlPropertyValue);\r\n            if (JiveGlobals.isXMLPropertyEncrypted(name)) {\r\n                JiveGlobals.setPropertyEncrypted(name, true);\r\n            }\r\n            deleteProperty(name);\r\n        } else if (databasePropertyValue.equals(xmlPropertyValue)) {\r\n            Log.debug(\"JiveGlobals: Deleting duplicate XML property '\" + name + \"' that is already in database.\");\r\n            if (JiveGlobals.isXMLPropertyEncrypted(name)) {\r\n                JiveGlobals.setPropertyEncrypted(name, true);\r\n            }\r\n            deleteProperty(name);\r\n        } else if (!databasePropertyValue.equals(xmlPropertyValue)) {\r\n            Log.warn(\"XML Property '\" + name + \"' differs from what is stored in the database.  Please make property changes in the database instead of the configuration file.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyItem.isRosterRequired",
	"Comment": "returns true if this privacy item needs the user roster to figure outif a packet must be blocked.",
	"Method": "boolean isRosterRequired(){\r\n    return type == Type.group || type == Type.subscription;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.setSendItemSubscribe",
	"Comment": "sets if new subscribers are going to receive new items once subscribed.",
	"Method": "void setSendItemSubscribe(boolean sendItemSubscribe){\r\n    this.sendItemSubscribe = sendItemSubscribe;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.isSendItemSubscribe",
	"Comment": "returns true if the last published item is going to be sent to new subscribers.",
	"Method": "boolean isSendItemSubscribe(){\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.PresenceEventDispatcher.unsubscribedToPresence",
	"Comment": "notification message indicating that a user has unsubscribedto the presence of another user.",
	"Method": "void unsubscribedToPresence(JID unsubscriberJID,JID recipientJID){\r\n    if (!listeners.isEmpty()) {\r\n        for (PresenceEventListener listener : listeners) {\r\n            listener.unsubscribedToPresence(unsubscriberJID, recipientJID);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.component.ExternalComponentManager.canAccess",
	"Comment": "returns true if the external component with the specified subdomain can connect to thelocal server.",
	"Method": "boolean canAccess(String subdomain){\r\n    Permission permission = null;\r\n    ExternalComponentConfiguration config = getConfiguration(subdomain, true);\r\n    if (config != null) {\r\n        permission = config.getPermission();\r\n    }\r\n    if (PermissionPolicy.blacklist == getPermissionPolicy()) {\r\n        return Permission.blocked != permission;\r\n    } else {\r\n        return Permission.allowed == permission;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpConnection.close",
	"Comment": "the connection should be closed without delivering a stanza to the requestor.",
	"Method": "void close(){\r\n    synchronized (this) {\r\n        if (isClosed) {\r\n            return;\r\n        }\r\n    }\r\n    try {\r\n        deliverBody(null, true);\r\n    } catch (HttpConnectionClosedException | IOException e) {\r\n        Log.warn(\"Unexpected exception occurred while trying to close an HttpException.\", e);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.canSendPublicationEvent",
	"Comment": "returns true if an event notification can be sent to the subscriber for the specifiedpublished item based on the subsription configuration and subscriber status.",
	"Method": "boolean canSendPublicationEvent(LeafNode leafNode,PublishedItem publishedItem){\r\n    if (!canSendEvents()) {\r\n        return false;\r\n    }\r\n    if (publishedItem != null && !isKeywordMatched(publishedItem)) {\r\n        return false;\r\n    }\r\n    if (node.isCollectionNode()) {\r\n        if (Type.items != type) {\r\n            return false;\r\n        }\r\n        if (getDepth() == 1 && !node.isChildNode(leafNode)) {\r\n            return false;\r\n        }\r\n        if (getDepth() == 0 && !node.isDescendantNode(leafNode)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalIncomingServerSession.addValidatedDomain",
	"Comment": "adds a new validated domain, subdomain or virtual host to the list ofvalidated domains for the remote server.",
	"Method": "void addValidatedDomain(String domain){\r\n    if (validatedDomains.add(domain)) {\r\n        if (validatedDomains.size() < 2) {\r\n            setAddress(new JID(null, domain, null));\r\n        }\r\n        SessionManager.getInstance().registerIncomingServerSession(domain, this);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginMetadataHelper.getMinServerVersion",
	"Comment": "returns the minimum server version this plugin can run within. the value is retrieved from the plugin.xml fileof the plugin. if the value could not be found, null will be returned.",
	"Method": "Version getMinServerVersion(Plugin plugin,Version getMinServerVersion,Path pluginDir){\r\n    final String value = getElementValue(pluginDir, \"/plugin/minServerVersion\");\r\n    if (value == null || value.trim().isEmpty()) {\r\n        return null;\r\n    }\r\n    return new Version(value);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.MultiplexerStanzaHandler.processRoute",
	"Comment": "process stanza sent by a client that is connected to a connection manager. theoriginal stanza is wrapped in the route element. only a single stanza must bewrapped in the route element.",
	"Method": "void processRoute(Route packet){\r\n    if (session.getStatus() != Session.STATUS_AUTHENTICATED) {\r\n        Route reply = new Route(packet.getStreamID());\r\n        reply.setID(packet.getID());\r\n        reply.setTo(packet.getFrom());\r\n        reply.setFrom(packet.getTo());\r\n        reply.setError(PacketError.Condition.not_authorized);\r\n        session.process(reply);\r\n        return;\r\n    }\r\n    packetHandler.route(packet);\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.formatTime",
	"Comment": "formats a date object to return a time using the global locale.",
	"Method": "String formatTime(Date date){\r\n    if (timeFormat == null) {\r\n        if (properties != null) {\r\n            timeFormat = DateFormat.getTimeInstance(DateFormat.SHORT, getLocale());\r\n            timeFormat.setTimeZone(getTimeZone());\r\n        } else {\r\n            DateFormat instance = DateFormat.getTimeInstance(DateFormat.SHORT, getLocale());\r\n            instance.setTimeZone(getTimeZone());\r\n            return instance.format(date);\r\n        }\r\n    }\r\n    return timeFormat.format(date);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyList.isDefault",
	"Comment": "returns true if this privacy list is the default list to apply for the user. defaultprivacy lists can be overriden per session by setting an active privacy list.",
	"Method": "boolean isDefault(){\r\n    return isDefault;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.matchesComponent",
	"Comment": "returns true if the given address matches a component service jid.",
	"Method": "boolean matchesComponent(JID jid){\r\n    return jid != null && !jid.getDomain().equals(xmppServerInfo.getXMPPDomain()) && componentManager.hasComponent(jid);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sasl.JiveSharedSecretSaslServer.authenticateSharedSecret",
	"Comment": "returns true if the supplied digest matches the shared secret value. the digest must be an md5 hash of the secretkey, encoded as hex. this value is supplied by clients attempting shared secret authentication.",
	"Method": "boolean authenticateSharedSecret(String digest){\r\n    if (!isSharedSecretAllowed()) {\r\n        return false;\r\n    }\r\n    return StringUtils.hash(getSharedSecret()).equals(digest);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getOutgoingServers",
	"Comment": "returns a collection with the hostnames of the remote servers that currently may receivepackets sent from this server.",
	"Method": "Collection<String> getOutgoingServers(){\r\n    return routingTable.getServerHostnames();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.CollectionNode.isDescendantNode",
	"Comment": "returns true if the specified node is a direct child node of this collection node ora descendant of the children nodes.",
	"Method": "boolean isDescendantNode(Node child){\r\n    if (isChildNode(child)) {\r\n        return true;\r\n    }\r\n    for (Node node : getNodes()) {\r\n        if (node.isDescendantNode(child)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.addFormFields",
	"Comment": "adds the required form fields to the specified form. when editing is true the field typeand a label is included in each fields. the form being completed will contain the currentnode configuration. this information can be used for editing the node or for notifing thatthe node configuration has changed.",
	"Method": "void addFormFields(DataForm form,boolean isEditing){\r\n    FormField formField = form.addField();\r\n    formField.setVariable(\"pubsub#title\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.text_single);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.short_name\"));\r\n    }\r\n    formField.addValue(name);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#description\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.text_single);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.description\"));\r\n    }\r\n    formField.addValue(description);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#node_type\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.text_single);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.node_type\"));\r\n    }\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#collection\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.text_single);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.collection\"));\r\n    }\r\n    if (parent != null && !parent.isRootCollectionNode()) {\r\n        formField.addValue(parent.getNodeID());\r\n    }\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#subscribe\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.boolean_type);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.subscribe\"));\r\n    }\r\n    formField.addValue(subscriptionEnabled);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#subscription_required\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.boolean_type);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.subscription_required\"));\r\n    }\r\n    formField.addValue(subscriptionConfigurationRequired);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#deliver_payloads\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.boolean_type);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.deliver_payloads\"));\r\n    }\r\n    formField.addValue(deliverPayloads);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#notify_config\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.boolean_type);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.notify_config\"));\r\n    }\r\n    formField.addValue(notifyConfigChanges);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#notify_delete\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.boolean_type);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.notify_delete\"));\r\n    }\r\n    formField.addValue(notifyDelete);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#notify_retract\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.boolean_type);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.notify_retract\"));\r\n    }\r\n    formField.addValue(notifyRetract);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#presence_based_delivery\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.boolean_type);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.presence_based\"));\r\n    }\r\n    formField.addValue(presenceBasedDelivery);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#type\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.text_single);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.type\"));\r\n    }\r\n    formField.addValue(payloadType);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#body_xslt\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.text_single);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.body_xslt\"));\r\n    }\r\n    formField.addValue(bodyXSLT);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#dataform_xslt\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.text_single);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.dataform_xslt\"));\r\n    }\r\n    formField.addValue(dataformXSLT);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#access_model\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.list_single);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.access_model\"));\r\n        formField.addOption(null, AccessModel.authorize.getName());\r\n        formField.addOption(null, AccessModel.open.getName());\r\n        formField.addOption(null, AccessModel.presence.getName());\r\n        formField.addOption(null, AccessModel.roster.getName());\r\n        formField.addOption(null, AccessModel.whitelist.getName());\r\n    }\r\n    formField.addValue(accessModel.getName());\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#publish_model\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.list_single);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.publish_model\"));\r\n        formField.addOption(null, PublisherModel.publishers.getName());\r\n        formField.addOption(null, PublisherModel.subscribers.getName());\r\n        formField.addOption(null, PublisherModel.open.getName());\r\n    }\r\n    formField.addValue(publisherModel.getName());\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#roster_groups_allowed\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.list_multi);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.roster_allowed\"));\r\n    }\r\n    for (String group : rosterGroupsAllowed) {\r\n        formField.addValue(group);\r\n    }\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#contact\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.jid_multi);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.contact\"));\r\n    }\r\n    for (JID contact : contacts) {\r\n        formField.addValue(contact.toString());\r\n    }\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#language\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.text_single);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.language\"));\r\n    }\r\n    formField.addValue(language);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#owner\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.jid_multi);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.owner\"));\r\n    }\r\n    for (JID owner : getOwners()) {\r\n        formField.addValue(owner.toString());\r\n    }\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#publisher\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.jid_multi);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.publisher\"));\r\n    }\r\n    for (JID owner : getPublishers()) {\r\n        formField.addValue(owner.toString());\r\n    }\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#itemreply\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.list_single);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.itemreply\"));\r\n        formField.addOption(null, ItemReplyPolicy.owner.name());\r\n        formField.addOption(null, ItemReplyPolicy.publisher.name());\r\n    }\r\n    if (replyPolicy != null) {\r\n        formField.addValue(replyPolicy.name());\r\n    }\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#replyroom\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.jid_multi);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.replyroom\"));\r\n    }\r\n    for (JID owner : getReplyRooms()) {\r\n        formField.addValue(owner.toString());\r\n    }\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#replyto\");\r\n    if (isEditing) {\r\n        formField.setType(FormField.Type.jid_multi);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.conf.replyto\"));\r\n    }\r\n    for (JID owner : getReplyTo()) {\r\n        formField.addValue(owner.toString());\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.UpdateManager.isPluginDownloaded",
	"Comment": "returns true if the plugin downloaded from the specified url has been downloaded. pluginsmay be downloaded but not installed. the install process may take like 30 seconds todetect new plugins to install.",
	"Method": "boolean isPluginDownloaded(String url){\r\n    String pluginFilename = url.substring(url.lastIndexOf(\"/\") + 1);\r\n    return XMPPServer.getInstance().getPluginManager().isInstalled(pluginFilename);\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ProviderTokenService.createAccessToken_noRefresh",
	"Comment": "tests the creation of access tokens for clients that are not allowed to have refresh tokens.",
	"Method": "void createAccessToken_noRefresh(){\r\n    when(client.isAllowRefresh()).thenReturn(false);\r\n    OAuth2AccessTokenEntity token = service.createAccessToken(authentication);\r\n    verify(clientDetailsService).loadClientByClientId(anyString());\r\n    verify(authenticationHolderRepository).save(any(AuthenticationHolderEntity.class));\r\n    verify(tokenEnhancer).enhance(any(OAuth2AccessTokenEntity.class), Matchers.eq(authentication));\r\n    verify(tokenRepository).saveAccessToken(any(OAuth2AccessTokenEntity.class));\r\n    verify(scopeService, atLeastOnce()).removeReservedScopes(anySet());\r\n    verify(tokenRepository, Mockito.never()).saveRefreshToken(any(OAuth2RefreshTokenEntity.class));\r\n    assertThat(token.getRefreshToken(), is(nullValue()));\r\n}"
}, {
	"Path": "org.jivesoftware.util.CertificateManager.determineSubjectAlternateNameDnsNameValues",
	"Comment": "finds all values that aught to be added as a subject alternate name of the dnsname type to a certificate thatidentifies this xmpp server.",
	"Method": "Set<String> determineSubjectAlternateNameDnsNameValues(){\r\n    final HashSet<String> result = new HashSet();\r\n    result.add(XMPPServer.getInstance().getServerInfo().getXMPPDomain());\r\n    result.add(XMPPServer.getInstance().getServerInfo().getHostname());\r\n    if (XMPPServer.getInstance().getIQDiscoItemsHandler() != null) {\r\n        for (final DiscoItem item : XMPPServer.getInstance().getIQDiscoItemsHandler().getServerItems()) {\r\n            result.add(item.getJID().toBareJID());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.EncryptionArtifactFactoryTest.testHasSupportedCipherSuites",
	"Comment": "verifies that the collection of supported cipher suites is not empty.",
	"Method": "void testHasSupportedCipherSuites(){\r\n    final Collection<String> result = EncryptionArtifactFactory.getSupportedCipherSuites();\r\n    Assert.assertFalse(result.isEmpty());\r\n}"
}, {
	"Path": "org.jivesoftware.util.XMLProperties.saveProperties",
	"Comment": "saves the properties to disk as an xml document. a temporary file isused during the writing process for maximum safety.",
	"Method": "boolean saveProperties(){\r\n    if (file == null) {\r\n        Log.error(\"Unable to save XML properties; no file specified\");\r\n        return false;\r\n    }\r\n    final Path tempFile = file.getParent().resolve(file.getFileName() + \".tmp\");\r\n    try (final Writer writer = Files.newBufferedWriter(tempFile, StandardCharsets.UTF_8)) {\r\n        OutputFormat prettyPrinter = OutputFormat.createPrettyPrint();\r\n        XMLWriter xmlWriter = new XMLWriter(writer, prettyPrinter);\r\n        xmlWriter.write(document);\r\n    } catch (final Exception e) {\r\n        Log.error(\"Unable to write properties to tmpFile {}\", tempFile, e);\r\n        return false;\r\n    }\r\n    try {\r\n        Files.deleteIfExists(file);\r\n    } catch (final IOException e) {\r\n        Log.error(\"Error deleting existing property file {}: \", tempFile, e);\r\n        return false;\r\n    }\r\n    try {\r\n        Files.copy(tempFile, file, StandardCopyOption.REPLACE_EXISTING);\r\n    } catch (final Exception e) {\r\n        Log.error(\"Error copying new property file from {} to {}:\", tempFile, file, e);\r\n        return false;\r\n    }\r\n    try {\r\n        Files.deleteIfExists(tempFile);\r\n    } catch (IOException e) {\r\n        Log.error(\"Error deleting temp file {}\", tempFile, e);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.getAccessModel",
	"Comment": "returns the access model that specifies who is allowed to subscribe and retrieve items.",
	"Method": "AccessModel getAccessModel(){\r\n    return accessModel;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getOutgoingServerSession",
	"Comment": "returns a session that was originated from this server to a remote server.outgoingserversession an only send packets to the remote server but are not capable ofreceiving packets from the remote server.",
	"Method": "OutgoingServerSession getOutgoingServerSession(DomainPair pair){\r\n    return routingTable.getServerRoute(pair);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.lockout.DefaultLockOutProvider.getDisabledStatus",
	"Comment": "default provider retrieves disabled status from ofuserflag table.",
	"Method": "LockOutFlag getDisabledStatus(String username){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    LockOutFlag ret = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(RETRIEVE_FLAG);\r\n        pstmt.setString(1, username);\r\n        rs = pstmt.executeQuery();\r\n        if (!rs.next()) {\r\n            return null;\r\n        }\r\n        Date startTime = null;\r\n        if (rs.getString(2) != null) {\r\n            startTime = new Date(Long.parseLong(rs.getString(2).trim()));\r\n        }\r\n        Date endTime = null;\r\n        if (rs.getString(3) != null) {\r\n            endTime = new Date(Long.parseLong(rs.getString(3).trim()));\r\n        }\r\n        ret = new LockOutFlag(username, startTime, endTime);\r\n    } catch (Exception e) {\r\n        Log.error(\"Error loading lockout information from DB\", e);\r\n        return null;\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.setUsername",
	"Comment": "sets the username used to connect to the database. in some cases, ausername is not needed so null should be passed in.",
	"Method": "void setUsername(String username){\r\n    this.username = username;\r\n    saveProperties();\r\n}"
}, {
	"Path": "org.mitre.openid.connect.assertion.JWTBearerAuthenticationProvider.authenticate",
	"Comment": "try to validate the client credentials by parsing and validating the jwt.",
	"Method": "Authentication authenticate(Authentication authentication){\r\n    JWTBearerAssertionAuthenticationToken jwtAuth = (JWTBearerAssertionAuthenticationToken) authentication;\r\n    try {\r\n        ClientDetailsEntity client = clientService.loadClientByClientId(jwtAuth.getName());\r\n        JWT jwt = jwtAuth.getJwt();\r\n        JWTClaimsSet jwtClaims = jwt.getJWTClaimsSet();\r\n        if (!(jwt instanceof SignedJWT)) {\r\n            throw new AuthenticationServiceException(\"Unsupported JWT type: \" + jwt.getClass().getName());\r\n        }\r\n        SignedJWT jws = (SignedJWT) jwt;\r\n        JWSAlgorithm alg = jws.getHeader().getAlgorithm();\r\n        if (client.getTokenEndpointAuthSigningAlg() != null && !client.getTokenEndpointAuthSigningAlg().equals(alg)) {\r\n            throw new AuthenticationServiceException(\"Client's registered token endpoint signing algorithm (\" + client.getTokenEndpointAuthSigningAlg() + \") does not match token's actual algorithm (\" + alg.getName() + \")\");\r\n        }\r\n        if (client.getTokenEndpointAuthMethod() == null || client.getTokenEndpointAuthMethod().equals(AuthMethod.NONE) || client.getTokenEndpointAuthMethod().equals(AuthMethod.SECRET_BASIC) || client.getTokenEndpointAuthMethod().equals(AuthMethod.SECRET_POST)) {\r\n            throw new AuthenticationServiceException(\"Client does not support this authentication method.\");\r\n        } else if ((client.getTokenEndpointAuthMethod().equals(AuthMethod.PRIVATE_KEY) && (alg.equals(JWSAlgorithm.RS256) || alg.equals(JWSAlgorithm.RS384) || alg.equals(JWSAlgorithm.RS512) || alg.equals(JWSAlgorithm.ES256) || alg.equals(JWSAlgorithm.ES384) || alg.equals(JWSAlgorithm.ES512) || alg.equals(JWSAlgorithm.PS256) || alg.equals(JWSAlgorithm.PS384) || alg.equals(JWSAlgorithm.PS512))) || (client.getTokenEndpointAuthMethod().equals(AuthMethod.SECRET_JWT) && (alg.equals(JWSAlgorithm.HS256) || alg.equals(JWSAlgorithm.HS384) || alg.equals(JWSAlgorithm.HS512)))) {\r\n            if (config.isHeartMode() && !client.getTokenEndpointAuthMethod().equals(AuthMethod.PRIVATE_KEY)) {\r\n                throw new AuthenticationServiceException(\"[HEART mode] Invalid authentication method\");\r\n            }\r\n            JWTSigningAndValidationService validator = validators.getValidator(client, alg);\r\n            if (validator == null) {\r\n                throw new AuthenticationServiceException(\"Unable to create signature validator for client \" + client + \" and algorithm \" + alg);\r\n            }\r\n            if (!validator.validateSignature(jws)) {\r\n                throw new AuthenticationServiceException(\"Signature did not validate for presented JWT authentication.\");\r\n            }\r\n        } else {\r\n            throw new AuthenticationServiceException(\"Unable to create signature validator for method \" + client.getTokenEndpointAuthMethod() + \" and algorithm \" + alg);\r\n        }\r\n        if (jwtClaims.getIssuer() == null) {\r\n            throw new AuthenticationServiceException(\"Assertion Token Issuer is null\");\r\n        } else if (!jwtClaims.getIssuer().equals(client.getClientId())) {\r\n            throw new AuthenticationServiceException(\"Issuers do not match, expected \" + client.getClientId() + \" got \" + jwtClaims.getIssuer());\r\n        }\r\n        if (jwtClaims.getExpirationTime() == null) {\r\n            throw new AuthenticationServiceException(\"Assertion Token does not have required expiration claim\");\r\n        } else {\r\n            Date now = new Date(System.currentTimeMillis() - (timeSkewAllowance * 1000));\r\n            if (now.after(jwtClaims.getExpirationTime())) {\r\n                throw new AuthenticationServiceException(\"Assertion Token is expired: \" + jwtClaims.getExpirationTime());\r\n            }\r\n        }\r\n        if (jwtClaims.getNotBeforeTime() != null) {\r\n            Date now = new Date(System.currentTimeMillis() + (timeSkewAllowance * 1000));\r\n            if (now.before(jwtClaims.getNotBeforeTime())) {\r\n                throw new AuthenticationServiceException(\"Assertion Token not valid untill: \" + jwtClaims.getNotBeforeTime());\r\n            }\r\n        }\r\n        if (jwtClaims.getIssueTime() != null) {\r\n            Date now = new Date(System.currentTimeMillis() + (timeSkewAllowance * 1000));\r\n            if (now.before(jwtClaims.getIssueTime())) {\r\n                throw new AuthenticationServiceException(\"Assertion Token was issued in the future: \" + jwtClaims.getIssueTime());\r\n            }\r\n        }\r\n        if (jwtClaims.getAudience() == null) {\r\n            throw new AuthenticationServiceException(\"Assertion token audience is null\");\r\n        } else if (!(jwtClaims.getAudience().contains(config.getIssuer()) || jwtClaims.getAudience().contains(config.getIssuer() + \"token\"))) {\r\n            throw new AuthenticationServiceException(\"Audience does not match, expected \" + config.getIssuer() + \" or \" + (config.getIssuer() + \"token\") + \" got \" + jwtClaims.getAudience());\r\n        }\r\n        Set<GrantedAuthority> authorities = new HashSet(client.getAuthorities());\r\n        authorities.add(ROLE_CLIENT);\r\n        return new JWTBearerAssertionAuthenticationToken(jwt, authorities);\r\n    } catch (InvalidClientException e) {\r\n        throw new UsernameNotFoundException(\"Could not find client: \" + jwtAuth.getName());\r\n    } catch (ParseException e) {\r\n        logger.error(\"Failure during authentication, error was: \", e);\r\n        throw new AuthenticationServiceException(\"Invalid JWT format\");\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PublishedItem.getPayload",
	"Comment": "returns the payload included when publishing the item. a published item may or may nothave a payload. transient nodes that are configured to not broadcast payloads may allowpublished items to have no payload.",
	"Method": "Element getPayload(){\r\n    if (payload == null && payloadXML != null) {\r\n        synchronized (this) {\r\n            if (payload == null) {\r\n                SAXReader xmlReader = null;\r\n                try {\r\n                    xmlReader = xmlReaders.take();\r\n                    payload = xmlReader.read(new StringReader(payloadXML)).getRootElement();\r\n                } catch (Exception ex) {\r\n                    log.error(\"Failed to parse payload XML\", ex);\r\n                } finally {\r\n                    if (xmlReader != null) {\r\n                        xmlReaders.add(xmlReader);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return payload;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.UpdateManager.getCheckFrequency",
	"Comment": "returns the frequency to check for updates. by default, this will happen every 48 hours.the frequency returned will never be less than 12 hours.",
	"Method": "int getCheckFrequency(){\r\n    int frequency = JiveGlobals.getIntProperty(\"update.frequency\", 48);\r\n    if (frequency < 12) {\r\n        return 12;\r\n    } else {\r\n        return frequency;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.DefaultCache.getCacheSize",
	"Comment": "returns the size of the cache contents in bytes. this value is only arough approximation, so cache users should expect that actual vmmemory used by the cache could be significantly higher than the valuereported by this method.",
	"Method": "int getCacheSize(){\r\n    return cacheSize;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterItem.setAsCopyOf",
	"Comment": "update the cached item as a copy of the given item.a convenience for getting the item and setting each attribute.",
	"Method": "void setAsCopyOf(org.xmpp.packet.Roster.Item item){\r\n    setGroups(new LinkedList(item.getGroups()));\r\n    setNickname(item.getName());\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheFactory.isClusteringStarting",
	"Comment": "returns true is clustering is currently being started. once the clusteris started or failed to be started this value will be false.",
	"Method": "boolean isClusteringStarting(){\r\n    return clusteringStarting;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.PresencePlugin.isPresencePublic",
	"Comment": "returns true if anyone is allowed to see the presence of other users. false means thatonly the users that are subscribed to a user presence will be able to get informationabout the user. by default, presence information is not publicly available.",
	"Method": "boolean isPresencePublic(){\r\n    return JiveGlobals.getBooleanProperty(\"plugin.presence.public\", false);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.audit.spi.AuditorImpl.ensureMaxDays",
	"Comment": "deletes old audit files that exceeded the max number of days limit.",
	"Method": "void ensureMaxDays(){\r\n    if (maxDays == -1) {\r\n        return;\r\n    }\r\n    Calendar calendar = Calendar.getInstance();\r\n    calendar.add(Calendar.DATE, maxDays * -1);\r\n    final String oldestFile = \"jive.audit-\" + dateFormat.format(calendar.getTime()) + \"-000.log\";\r\n    FilenameFilter filter = new FilenameFilter() {\r\n        @Override\r\n        public boolean accept(File dir, String name) {\r\n            return name.startsWith(\"jive.audit-\") && name.endsWith(\".log\") && name.compareTo(oldestFile) < 0;\r\n        }\r\n    };\r\n    File[] files = baseFolder.listFiles(filter);\r\n    for (File fileToDelete : files) {\r\n        if (fileToDelete.equals(currentAuditFile)) {\r\n            close();\r\n        }\r\n        if (!fileToDelete.delete()) {\r\n            Log.warn(\"Unable to delete file '{}' as part of regular log rotation based on age of file. (Openfire failed to clean up after itself)!\", fileToDelete);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.audit.spi.AuditorImpl.ensureMaxDays",
	"Comment": "deletes old audit files that exceeded the max number of days limit.",
	"Method": "void ensureMaxDays(){\r\n    return name.startsWith(\"jive.audit-\") && name.endsWith(\".log\") && name.compareTo(oldestFile) < 0;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.cluster.ClusterManager.isSeniorClusterMember",
	"Comment": "returns true if this member is the senior member in the cluster. if clusteringis not enabled, this method will also return true. this test is useful fortasks that should only be run on a single member in a cluster.",
	"Method": "boolean isSeniorClusterMember(){\r\n    return CacheFactory.isSeniorClusterMember();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.lockout.DefaultLockOutProvider.setDisabledStatus",
	"Comment": "default provider deletes existing flag, if it exists, and adds new described flag in ofuserflag table.",
	"Method": "void setDisabledStatus(LockOutFlag flag){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(DELETE_FLAG);\r\n        pstmt.setString(1, flag.getUsername());\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException sqle) {\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(ADD_FLAG);\r\n        pstmt.setString(1, flag.getUsername());\r\n        if (flag.getStartTime() != null) {\r\n            pstmt.setString(2, StringUtils.dateToMillis(flag.getStartTime()));\r\n        } else {\r\n            pstmt.setNull(2, Types.VARCHAR);\r\n        }\r\n        if (flag.getEndTime() != null) {\r\n            pstmt.setString(3, StringUtils.dateToMillis(flag.getEndTime()));\r\n        } else {\r\n            pstmt.setNull(3, Types.VARCHAR);\r\n        }\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException sqle) {\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyListProvider.deletePrivacyLists",
	"Comment": "deletes all existing privacy list from the database for the given user.",
	"Method": "void deletePrivacyLists(String username){\r\n    if (!databaseContainsPrivacyLists.get()) {\r\n        return;\r\n    }\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(DELETE_PRIVACY_LISTS);\r\n        pstmt.setString(1, username);\r\n        pstmt.executeUpdate();\r\n    } catch (Exception e) {\r\n        Log.error(\"Error deleting privacy lists of username: \" + username, e);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n    databaseContainsPrivacyLists.set(true);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.isNotifyConfigChanges",
	"Comment": "returns true if subscribers are going to be notified when node configuration changes.",
	"Method": "boolean isNotifyConfigChanges(){\r\n    return notifyConfigChanges;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheFactory.isSeniorClusterMember",
	"Comment": "returns true if this member is the senior member in the cluster. if clusteringis not enabled, this method will also return true. this test is useful fortasks that should only be run on a single member in a cluster.",
	"Method": "boolean isSeniorClusterMember(){\r\n    return cacheFactoryStrategy.isSeniorClusterMember();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.Channel.getThreadCount",
	"Comment": "returns the number of currently active worker threads in the channel. this valuewill always fall in between the min a max thread count.",
	"Method": "int getThreadCount(){\r\n    return executor.getPoolSize();\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.writeLongIntMap",
	"Comment": "writes a map of long key and integer value pairs. this method handlesthe case when the map is null.",
	"Method": "void writeLongIntMap(DataOutput out,Map<Long, Integer> map){\r\n    strategy.writeLongIntMap(out, map);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getPacketRouter",
	"Comment": "returns the packetrouter registered with this server. thepacketrouter was registered with the server as a module while starting upthe server.",
	"Method": "PacketRouter getPacketRouter(){\r\n    return (PacketRouter) modules.get(PacketRouterImpl.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.component.ExternalComponentManager.getSecretForComponent",
	"Comment": "returns the shared secret with the specified external component. if no shared secret wasdefined then use the default shared secret.",
	"Method": "String getSecretForComponent(String subdomain){\r\n    String secret = null;\r\n    ExternalComponentConfiguration config = getConfiguration(subdomain, true);\r\n    if (config != null) {\r\n        secret = config.getSecret();\r\n    }\r\n    secret = (secret == null ? getDefaultSecret() : secret);\r\n    if (secret == null) {\r\n        Log.error(\"Setup for external components is incomplete. Property \" + \"xmpp.component.defaultSecret does not exist.\");\r\n    }\r\n    return secret;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.CertificateStore.persist",
	"Comment": "saves the current state of the store to disk. useful when certificates have been added or removed from thestore.",
	"Method": "void persist(){\r\n    try (final FileOutputStream os = new FileOutputStream(configuration.getFile())) {\r\n        store.store(os, configuration.getPassword());\r\n    } catch (NoSuchAlgorithmException | KeyStoreException | CertificateException | IOException ex) {\r\n        throw new CertificateStoreConfigException(\"Unable to save changes to store in '\" + configuration.getFile() + \"'\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.component.ExternalComponentManager.getBlockedComponents",
	"Comment": "returns the list of external components that are not allowed to connect to thisserver.",
	"Method": "Collection<ExternalComponentConfiguration> getBlockedComponents(){\r\n    return getConfigurations(Permission.blocked);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.CollectionNode.addChildNode",
	"Comment": "adds a child node to the list of child nodes. the new child node may just have beencreated or just restored from the database. this method will not trigger notificationsto node subscribers since the node could be a node that has just been loaded from thedatabase.",
	"Method": "void addChildNode(Node child){\r\n    nodes.put(child.getNodeID(), child);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.security.SecurityAuditEvent.setDetails",
	"Comment": "sets the detailed information about what occured in the event.",
	"Method": "void setDetails(String details){\r\n    this.details = details;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginMetadataHelper.getVersion",
	"Comment": "returns the version of a plugin. the value is retrieved from the plugin.xml file of the plugin. if the valuecould not be found, null will be returned.",
	"Method": "Version getVersion(Plugin plugin,Version getVersion,Path pluginDir){\r\n    final String value = getElementValue(pluginDir, \"/plugin/version\");\r\n    if (value == null || value.trim().isEmpty()) {\r\n        return null;\r\n    }\r\n    return new Version(value);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapVCardProvider.loadVCard",
	"Comment": "loads the avatar from ldap, based off the vcard template.if enabled, will replace a blank photo element with one from a db stored vcard.",
	"Method": "Element loadVCard(String username){\r\n    username = JID.unescapeNode(username);\r\n    Map<String, String> map = getLdapAttributes(username);\r\n    Log.debug(\"LdapVCardProvider: Getting mapped vcard for \" + username);\r\n    Element vcard = new VCard(template).getVCard(map);\r\n    if (dbStorageEnabled && vcard != null && (vcard.element(\"PHOTO\") == null || vcard.element(\"PHOTO\").element(\"BINVAL\") == null || vcard.element(\"PHOTO\").element(\"BINVAL\").getText().matches(\"\\\\s*\"))) {\r\n        Element avatarElement = loadAvatarFromDatabase(username);\r\n        if (avatarElement != null) {\r\n            Log.debug(\"LdapVCardProvider: Adding avatar element from local storage\");\r\n            Element currentElement = vcard.element(\"PHOTO\");\r\n            if (currentElement != null) {\r\n                vcard.remove(currentElement);\r\n            }\r\n            vcard.add(avatarElement);\r\n        }\r\n    }\r\n    if (JiveGlobals.getBooleanProperty(PhotoResizer.PROPERTY_RESIZE_ON_LOAD, PhotoResizer.PROPERTY_RESIZE_ON_LOAD_DEFAULT)) {\r\n        PhotoResizer.resizeAvatar(vcard);\r\n    }\r\n    Log.debug(\"LdapVCardProvider: Returning vcard\");\r\n    return vcard;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.CollectionNode.setAssociationTrusted",
	"Comment": "sets the users that are allowed to associate leaf nodes with this collection node.this collection is going to be used only when the associationpolicy is whitelist.",
	"Method": "void setAssociationTrusted(Collection<JID> associationTrusted){\r\n    this.associationTrusted = associationTrusted;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.model.PendingOIDCAuthenticationToken.getPrincipal",
	"Comment": "get the principal of this object, an immutable map of the subject and issuer.",
	"Method": "Object getPrincipal(){\r\n    return principal;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.isSubscriptionEnabled",
	"Comment": "returns true if users are allowed to subscribe and unsubscribe.",
	"Method": "boolean isSubscriptionEnabled(){\r\n    return subscriptionEnabled;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.UserServicePlugin.getSecret",
	"Comment": "returns the secret key that only valid requests should know.",
	"Method": "String getSecret(){\r\n    return secret;\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ProviderTokenService.refreshAccessToken_expiration",
	"Comment": "checks to see that the expiration date of refreshed tokens is being set accurately to within some delta for time skew.",
	"Method": "void refreshAccessToken_expiration(){\r\n    Integer accessTokenValiditySeconds = 3600;\r\n    when(client.getAccessTokenValiditySeconds()).thenReturn(accessTokenValiditySeconds);\r\n    long start = System.currentTimeMillis();\r\n    OAuth2AccessTokenEntity token = service.refreshAccessToken(refreshTokenValue, tokenRequest);\r\n    long end = System.currentTimeMillis();\r\n    Date lowerBoundAccessTokens = new Date(start + (accessTokenValiditySeconds * 1000L) - DELTA);\r\n    Date upperBoundAccessTokens = new Date(end + (accessTokenValiditySeconds * 1000L) + DELTA);\r\n    verify(scopeService, atLeastOnce()).removeReservedScopes(anySet());\r\n    assertTrue(token.getExpiration().after(lowerBoundAccessTokens) && token.getExpiration().before(upperBoundAccessTokens));\r\n}"
}, {
	"Path": "org.jivesoftware.util.EmailService.setSSLEnabled",
	"Comment": "sets whether the smtp connection is configured to use ssl or not.typically, the port should be 465 when using ssl with smtp.",
	"Method": "void setSSLEnabled(boolean sslEnabled){\r\n    this.sslEnabled = sslEnabled;\r\n    JiveGlobals.setProperty(\"mail.smtp.ssl\", Boolean.toString(sslEnabled));\r\n    session = null;\r\n}"
}, {
	"Path": "org.jivesoftware.util.XMLProperties.buildDoc",
	"Comment": "builds the document xml model up based the given reader of xml data.",
	"Method": "void buildDoc(Reader in){\r\n    try {\r\n        SAXReader xmlReader = new SAXReader();\r\n        xmlReader.setEncoding(\"UTF-8\");\r\n        document = xmlReader.read(in);\r\n    } catch (Exception e) {\r\n        Log.error(\"Error reading XML properties\", e);\r\n        throw new IOException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.HybridUserProvider.setName",
	"Comment": "changes the full name of a user in the first provider that contains the user.",
	"Method": "void setName(String username,String name){\r\n    getUserProvider(username).setEmail(username, name);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.mediaproxy.MediaProxySession.addLifeTime",
	"Comment": "add a limited life time to the session.the session is stoped and remove from agents list after a certain time.prevents that network cycles, refreshes a session forever.",
	"Method": "void addLifeTime(long lifetime){\r\n    lifetime *= 1000;\r\n    if (lifeTimer != null)\r\n        return;\r\n    lifeTimer = new Timer();\r\n    lifeTimer.scheduleAtFixedRate(new TimerTask() {\r\n        @Override\r\n        public void run() {\r\n            stopAgent();\r\n        }\r\n    }, lifetime, lifetime);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.mediaproxy.MediaProxySession.addLifeTime",
	"Comment": "add a limited life time to the session.the session is stoped and remove from agents list after a certain time.prevents that network cycles, refreshes a session forever.",
	"Method": "void addLifeTime(long lifetime){\r\n    stopAgent();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.DNSUtil.setDnsOverride",
	"Comment": "sets the internal dns that allows to specify target ip addresses and portsto use for domains. the internal dns will be checked up before performing anactual dns srv lookup.",
	"Method": "void setDnsOverride(Map<String, HostAddress> dnsOverride){\r\n    DNSUtil.dnsOverride = dnsOverride;\r\n    JiveGlobals.setProperty(\"dnsutil.dnsOverride\", encode(dnsOverride));\r\n}"
}, {
	"Path": "org.jivesoftware.util.FastDateFormat.getTimeZone",
	"Comment": "returns the time zone used by this formatter, or null if time zone offormatted dates is used instead.",
	"Method": "TimeZone getTimeZone(){\r\n    return mTimeZone;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.getPresenceBasedSubscribers",
	"Comment": "returns the jid of the affiliates that are receiving notifications based on theirpresence status.",
	"Method": "Collection<JID> getPresenceBasedSubscribers(){\r\n    Collection<JID> affiliatesJID = new ArrayList();\r\n    if (presenceBasedDelivery) {\r\n        for (NodeAffiliate affiliate : affiliates) {\r\n            if (!affiliate.getSubscriptions().isEmpty()) {\r\n                affiliatesJID.add(affiliate.getJID());\r\n            }\r\n        }\r\n    } else {\r\n        for (NodeAffiliate affiliate : affiliates) {\r\n            Collection<NodeSubscription> subscriptions = affiliate.getSubscriptions();\r\n            for (NodeSubscription subscription : subscriptions) {\r\n                if (!subscription.getPresenceStates().isEmpty()) {\r\n                    affiliatesJID.add(affiliate.getJID());\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return affiliatesJID;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.SearchPlugin.getSearchPluginUserManagerSearchFields",
	"Comment": "returns the collection of field names that can be used to search for a user. typical fields are username, name, and email. thesevalues can be used to contruct a data form.",
	"Method": "Collection<String> getSearchPluginUserManagerSearchFields(){\r\n    return Arrays.asList(\"Username\", \"Name\", \"Email\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.MultiUserChatManager.getMultiUserChatService",
	"Comment": "retrieves a multiuserchatservice instance specified by any jid that refers to it.in other words, it can be a hostname for the service, a room jid, or even the jidof a occupant of the room.basically it takes the hostname part of the jid,strips off the server hostname from the end, leaving only the subdomain, and then callsthe subdomain version of the call.",
	"Method": "MultiUserChatService getMultiUserChatService(Long serviceID,MultiUserChatService getMultiUserChatService,String subdomain,MultiUserChatService getMultiUserChatService,JID jid){\r\n    String subdomain = jid.getDomain().replace(\".\" + XMPPServer.getInstance().getServerInfo().getXMPPDomain(), \"\");\r\n    return getMultiUserChatService(subdomain);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MultiUserChatServiceImpl.getCleanupDate",
	"Comment": "returns the limit date after which rooms without activity will be removed from memory.",
	"Method": "Date getCleanupDate(){\r\n    return new Date(System.currentTimeMillis() - (emptyLimit * 3600000));\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.writeSerializableCollection",
	"Comment": "writes a collection of serializable objects. the collection passed as a parametermust be a collection and not a null value.",
	"Method": "void writeSerializableCollection(DataOutput out,Collection<? extends Serializable> value){\r\n    strategy.writeSerializableCollection(out, value);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getMultiUserChatManager",
	"Comment": "returns the multiuserchatmanager registered with this server. themultiuserchatmanager was registered with the server as a module while starting upthe server.",
	"Method": "MultiUserChatManager getMultiUserChatManager(){\r\n    return (MultiUserChatManager) modules.get(MultiUserChatManager.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.forms.spi.XFormFieldImpl.getOptions",
	"Comment": "returns an iterator for the available options that the user has in order to answerthe question.",
	"Method": "Iterator<Option> getOptions(){\r\n    synchronized (options) {\r\n        return Collections.unmodifiableList(new ArrayList(options)).iterator();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.handler.IQPrivacyHandler.setDefaultList",
	"Comment": "user has specified a new default list that should be used for all session.",
	"Method": "IQ setDefaultList(IQ packet,JID from,String listName){\r\n    IQ result = IQ.createResultIQ(packet);\r\n    Element childElement = packet.getChildElement().createCopy();\r\n    result.setChildElement(childElement);\r\n    if (sessionManager.getSessionCount(from.getNode()) > 1) {\r\n        result.setError(PacketError.Condition.conflict);\r\n    } else {\r\n        PrivacyList list = manager.getPrivacyList(from.getNode(), listName);\r\n        if (list != null) {\r\n            ClientSession session = sessionManager.getSession(from);\r\n            PrivacyList oldDefaultList = session.getDefaultList();\r\n            manager.changeDefaultList(from.getNode(), list, oldDefaultList);\r\n            session.setDefaultList(list);\r\n        } else {\r\n            result.setError(PacketError.Condition.item_not_found);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.web.AuthenticationTimeStamper.onAuthenticationSuccess",
	"Comment": "set the timestamp on the session to mark when the authentication happened,\tuseful for calculating authentication age. this gets stored in the sesion\tand can get pulled out by other components.",
	"Method": "void onAuthenticationSuccess(HttpServletRequest request,HttpServletResponse response,Authentication authentication){\r\n    Date authTimestamp = new Date();\r\n    HttpSession session = request.getSession();\r\n    session.setAttribute(AUTH_TIMESTAMP, authTimestamp);\r\n    if (session.getAttribute(AuthorizationRequestFilter.PROMPT_REQUESTED) != null) {\r\n        session.setAttribute(AuthorizationRequestFilter.PROMPTED, Boolean.TRUE);\r\n        session.removeAttribute(AuthorizationRequestFilter.PROMPT_REQUESTED);\r\n    }\r\n    logger.info(\"Successful Authentication of \" + authentication.getName() + \" at \" + authTimestamp.toString());\r\n    super.onAuthenticationSuccess(request, response, authentication);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapVCardProvider.initTemplate",
	"Comment": "initializes the vcard template as set by the administrator.",
	"Method": "void initTemplate(){\r\n    String property = JiveGlobals.getProperty(\"ldap.vcard-mapping\");\r\n    Log.debug(\"LdapVCardProvider: Found vcard mapping: '\" + property);\r\n    try {\r\n        if (property.startsWith(\"<![CDATA[\")) {\r\n            property = property.substring(9, property.length() - 3);\r\n        }\r\n        Document document = DocumentHelper.parseText(property);\r\n        template = new VCardTemplate(document);\r\n    } catch (Exception e) {\r\n        Log.error(\"Error loading vcard mapping: \" + e.getMessage());\r\n    }\r\n    Log.debug(\"LdapVCardProvider: attributes size==\" + template.getAttributes().length);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyListManager.getDefaultCacheKey",
	"Comment": "returns the key to use to locate default privacy lists in the cache.",
	"Method": "String getDefaultCacheKey(String username){\r\n    return getCacheKey(username, \"__d_e_f_a_u_l_t__\");\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.setupPropertyEncryption",
	"Comment": "setup the property encryption key, rewriting encrypted values as appropriate",
	"Method": "void setupPropertyEncryption(){\r\n    Encryptor keyEncryptor = new AesEncryptor();\r\n    String encryptedKey = securityProperties.getProperty(ENCRYPTION_KEY_CURRENT);\r\n    if (encryptedKey == null || encryptedKey.isEmpty()) {\r\n        currentKey = null;\r\n    } else {\r\n        currentKey = keyEncryptor.decrypt(encryptedKey);\r\n    }\r\n    String newKey = securityProperties.getProperty(ENCRYPTION_KEY_NEW, false);\r\n    if (newKey != null) {\r\n        Log.info(\"Detected new encryption key; updating encrypted properties\");\r\n        String oldKey = securityProperties.getProperty(ENCRYPTION_KEY_OLD);\r\n        if (oldKey == null) {\r\n            if (currentKey != null) {\r\n                Log.warn(\"Old encryption key was not provided; ignoring new encryption key\");\r\n                return;\r\n            }\r\n        } else {\r\n            if (!oldKey.equals(currentKey)) {\r\n                Log.warn(\"Old encryption key does not match current encryption key; ignoring new encryption key\");\r\n                return;\r\n            }\r\n        }\r\n        if (properties == null) {\r\n            properties = JiveProperties.getInstance();\r\n        }\r\n        Map<String, String> openfireProps = new HashMap();\r\n        for (String xmlProp : openfireProperties.getAllPropertyNames()) {\r\n            if (isPropertyEncrypted(xmlProp)) {\r\n                openfireProps.put(xmlProp, openfireProperties.getProperty(xmlProp));\r\n            }\r\n        }\r\n        currentKey = newKey.isEmpty() ? null : newKey;\r\n        propertyEncryptor = null;\r\n        for (String propertyName : securityProperties.getProperties(ENCRYPTED_PROPERTY_NAMES, true)) {\r\n            Log.info(\"Updating encrypted value for \" + propertyName);\r\n            if (openfireProps.containsKey(propertyName)) {\r\n                openfireProperties.setProperty(propertyName, openfireProps.get(propertyName));\r\n            } else if (!resetProperty(propertyName)) {\r\n                Log.warn(\"Failed to reset encrypted property value for \" + propertyName);\r\n            }\r\n        }\r\n        securityProperties.deleteProperty(ENCRYPTION_KEY_NEW);\r\n        securityProperties.deleteProperty(ENCRYPTION_KEY_OLD);\r\n    }\r\n    securityProperties.setProperty(ENCRYPTION_KEY_CURRENT, keyEncryptor.encrypt(currentKey));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginMetadata.getInstance",
	"Comment": "constructs a metadata object based on a plugin.the plugin must be installed in openfire.",
	"Method": "PluginMetadata getInstance(Path pluginDir,PluginMetadata getInstance,Plugin plugin){\r\n    return new PluginMetadata(PluginMetadataHelper.getName(plugin), PluginMetadataHelper.getCanonicalName(plugin), PluginMetadataHelper.getDescription(plugin), PluginMetadataHelper.getVersion(plugin), PluginMetadataHelper.getAuthor(plugin), PluginMetadataHelper.getIcon(plugin), PluginMetadataHelper.getChangelog(plugin), PluginMetadataHelper.getReadme(plugin), PluginMetadataHelper.getLicense(plugin), PluginMetadataHelper.getMinServerVersion(plugin), PluginMetadataHelper.getPriorToServerVersion(plugin), PluginMetadataHelper.getMinJavaVersion(plugin));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.starter.ServerStarter.start",
	"Comment": "starts the server by loading and instantiating the bootstrapcontainer. once the start method is called, the server isstarted and the server starter should not be used again.",
	"Method": "void start(){\r\n    try {\r\n        final ClassLoader parent = findParentClassLoader();\r\n        String libDirString = System.getProperty(\"openfire.lib.dir\");\r\n        File libDir;\r\n        if (libDirString != null) {\r\n            libDir = new File(libDirString);\r\n            if (!libDir.exists()) {\r\n                Log.warn(\"Lib directory \" + libDirString + \" does not exist. Using default \" + DEFAULT_LIB_DIR);\r\n                libDir = new File(DEFAULT_LIB_DIR);\r\n            }\r\n        } else {\r\n            libDir = new File(DEFAULT_LIB_DIR);\r\n        }\r\n        ClassLoader loader = new JiveClassLoader(parent, libDir);\r\n        Thread.currentThread().setContextClassLoader(loader);\r\n        Class containerClass = loader.loadClass(\"org.jivesoftware.openfire.XMPPServer\");\r\n        containerClass.newInstance();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.LocalMUCRoom.changeOccupantRole",
	"Comment": "updates the presence of the given user with the new role information. do nothing if the givenjid is not present in the room.",
	"Method": "Presence changeOccupantRole(JID jid,MUCRole.Role newRole){\r\n    MUCRole role = occupantsByFullJID.get(jid);\r\n    if (role != null) {\r\n        if (role.isLocal()) {\r\n            role.setRole(newRole);\r\n            CacheFactory.doClusterTask(new UpdateOccupant(this, role));\r\n            return role.getPresence().createCopy();\r\n        } else {\r\n            Element element = (Element) CacheFactory.doSynchronousClusterTask(new UpdateOccupantRequest(this, role.getNickname(), null, newRole), role.getNodeID().toByteArray());\r\n            if (element != null) {\r\n                return new Presence(element, true);\r\n            } else {\r\n                throw new NotAllowedException();\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.AbstractGroupProvider.search",
	"Comment": "returns a collection of group search results. this implementationreturns an empty collection.",
	"Method": "Collection<String> search(String query,Collection<String> search,String query,int startIndex,int numResults,Collection<String> search,String key,String value){\r\n    Set<String> groupNames = new HashSet();\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(GROUPS_FOR_PROP);\r\n        pstmt.setString(1, key);\r\n        pstmt.setString(2, value);\r\n        rs = pstmt.executeQuery();\r\n        while (rs.next()) {\r\n            groupNames.add(rs.getString(1));\r\n        }\r\n    } catch (SQLException sqle) {\r\n        Log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    return groupNames;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.IQHandlerInfo.getNamespace",
	"Comment": "obtain the namespace of the root iq element for this packet type.",
	"Method": "String getNamespace(){\r\n    return namespace;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getPresenceRouter",
	"Comment": "returns the presencerouter registered with this server. thepresencerouter was registered with the server as a module while starting upthe server.",
	"Method": "PresenceRouter getPresenceRouter(){\r\n    return (PresenceRouter) modules.get(PresenceRouter.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.getSubscription",
	"Comment": "returns the subscription whose subscription id matches the specified id or nullif none was found. accessing subscriptions by subscription id is always possible no matterif the node allows one or multiple subscriptions for the same entity. even when users canonly subscribe once to the node a subscription id is going to be internally created thoughnever returned to the user.",
	"Method": "NodeSubscription getSubscription(JID subscriberJID,NodeSubscription getSubscription,String subscriptionID){\r\n    return subscriptionsByID.get(subscriptionID);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.StanzaHandler.negotiateTLS",
	"Comment": "tries to secure the connection using tls. if the connection is secured then resetthe parser to use the new secured reader. but if the connection failed to be securedthen send astanza and close the connection.",
	"Method": "boolean negotiateTLS(){\r\n    if (connection.getTlsPolicy() == Connection.TLSPolicy.disabled) {\r\n        StreamError error = new StreamError(StreamError.Condition.not_authorized);\r\n        connection.deliverRawText(error.toXML());\r\n        connection.close();\r\n        Log.warn(\"TLS requested by initiator when TLS was never offered by server. \" + \"Closing connection : \" + connection);\r\n        return false;\r\n    }\r\n    try {\r\n        startTLS();\r\n    } catch (Exception e) {\r\n        Log.error(\"Error while negotiating TLS\", e);\r\n        connection.deliverRawText(\"<failure xmlns=\\\"urn:ietf:params:xml:ns:xmpp-tls\\\"/>\");\r\n        connection.close();\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.server.OutgoingServerSocketReader.setSession",
	"Comment": "sets the outgoingserversession for which this reader is working for.",
	"Method": "void setSession(OutgoingServerSession session){\r\n    this.session = session;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.getPeerCertificates",
	"Comment": "return the x509certificates associated with this session.",
	"Method": "X509Certificate[] getPeerCertificates(Certificate[] getPeerCertificates){\r\n    return sslCertificates;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyListManager.addListener",
	"Comment": "registers a listener to receive events when a privacy list is created, updated or deleted.",
	"Method": "void addListener(PrivacyListEventListener listener){\r\n    if (listener == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    listeners.add(listener);\r\n}"
}, {
	"Path": "org.jivesoftware.util.StringUtils.replace",
	"Comment": "replaces all instances of oldstring with newstring in line.the count integer is updated with number of replaces.",
	"Method": "String replace(String string,String oldString,String newString,String replace,String line,String oldString,String newString,int[] count,String replace,String line,String oldString,String newString,boolean ignoreCase,int[] count){\r\n    if (line == null) {\r\n        return null;\r\n    }\r\n    String lcLine = ignoreCase ? line.toLowerCase() : line;\r\n    String lcOldString = ignoreCase ? oldString.toLowerCase() : oldString;\r\n    int i = 0;\r\n    if ((i = lcLine.indexOf(lcOldString, i)) >= 0) {\r\n        int counter = 1;\r\n        char[] line2 = line.toCharArray();\r\n        char[] newString2 = newString.toCharArray();\r\n        int oLength = oldString.length();\r\n        StringBuilder buf = new StringBuilder(line2.length);\r\n        buf.append(line2, 0, i).append(newString2);\r\n        i += oLength;\r\n        int j = i;\r\n        while ((i = lcLine.indexOf(lcOldString, i)) > 0) {\r\n            counter++;\r\n            buf.append(line2, j, i - j).append(newString2);\r\n            i += oLength;\r\n            j = i;\r\n        }\r\n        buf.append(line2, j, line2.length - j);\r\n        count[0] = counter;\r\n        return buf.toString();\r\n    }\r\n    return line;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.StanzaHandler.closeNeverSecuredConnection",
	"Comment": "close the connection since tls was mandatory and the entity never negotiated tls. beforeclosing the connection a stream error will be sent to the entity.",
	"Method": "void closeNeverSecuredConnection(){\r\n    StreamError error = new StreamError(StreamError.Condition.not_authorized);\r\n    connection.deliverRawText(error.toXML());\r\n    connection.close();\r\n    Log.warn(\"TLS was required by the server and connection was never secured. \" + \"Closing connection : \" + connection);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.GroupManager.getGroupNamesFromCache",
	"Comment": "for reasons currently unclear, this class stores a number of different objects in the groupmetacache. tobetter encapsulate this, all access to the groupmetacache is via these methods",
	"Method": "HashSet<String> getGroupNamesFromCache(){\r\n    return (HashSet<String>) groupMetaCache.get(GROUP_NAMES_KEY);\r\n}"
}, {
	"Path": "org.dom4j.io.XMPPPacketReader.setDefaultHandler",
	"Comment": "when multiple elementhandler instances have beenregistered, this will set a default elementhandlerto be called for any path which does not have a handlerregistered.",
	"Method": "void setDefaultHandler(ElementHandler handler){\r\n    getDispatchHandler().setDefaultHandler(handler);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpBindManager.setHttpBindPorts",
	"Comment": "set the ports on which the http binding service will be running.",
	"Method": "void setHttpBindPorts(int unsecurePort,int securePort){\r\n    if (unsecurePort != HTTP_BIND_PORT_DEFAULT) {\r\n        JiveGlobals.setProperty(HTTP_BIND_PORT, String.valueOf(unsecurePort));\r\n    } else {\r\n        JiveGlobals.deleteProperty(HTTP_BIND_PORT);\r\n    }\r\n    if (securePort != HTTP_BIND_SECURE_PORT_DEFAULT) {\r\n        JiveGlobals.setProperty(HTTP_BIND_SECURE_PORT, String.valueOf(securePort));\r\n    } else {\r\n        JiveGlobals.deleteProperty(HTTP_BIND_SECURE_PORT);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.EncryptionArtifactFactory.createClientModeSSLEngine",
	"Comment": "creates an ssl engine that is configured to use client mode when handshaking.for openfire, an engine of this mode is typically used when the server tries to connect to another server.these sslengines never send sslv2 clienthello messages.",
	"Method": "SSLEngine createClientModeSSLEngine(){\r\n    final SSLEngine sslEngine = createSSLEngine();\r\n    sslEngine.setUseClientMode(true);\r\n    final Set<String> protocols = new LinkedHashSet(Arrays.asList(sslEngine.getEnabledProtocols()));\r\n    protocols.remove(\"SSLv2Hello\");\r\n    sslEngine.setEnabledProtocols(protocols.toArray(new String[protocols.size()]));\r\n    return sslEngine;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.DummyExternalizableUtil.readLongIntMap",
	"Comment": "reads a map of long key and integer value pairs. this method will returnnull if the map written to the stream was null.",
	"Method": "Map<Long, Integer> readLongIntMap(DataInput in){\r\n    return Collections.emptyMap();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.mediaproxy.MediaProxy.sessionClosed",
	"Comment": "implements session listener stopagent event.remove the stopped session from the sessions list.",
	"Method": "void sessionClosed(MediaProxySession session){\r\n    sessions.remove(session.getSID());\r\n    if (Log.isDebugEnabled()) {\r\n        Log.debug(\"MediaProxy: Session: \" + session.getSID() + \" removed.\");\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.commands.SessionData.isValidAction",
	"Comment": "returns true if the specified action is valid in the current stage. the action should havepreviously been offered to the user.",
	"Method": "boolean isValidAction(String actionName){\r\n    for (AdHocCommand.Action action : allowedActions) {\r\n        if (actionName.equals(action.name())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ProviderTokenService.createAccessToken_expiration",
	"Comment": "checks to see that the expiration date of new tokens is being set accurately to within some delta for time skew.",
	"Method": "void createAccessToken_expiration(){\r\n    Integer accessTokenValiditySeconds = 3600;\r\n    Integer refreshTokenValiditySeconds = 600;\r\n    when(client.getAccessTokenValiditySeconds()).thenReturn(accessTokenValiditySeconds);\r\n    when(client.getRefreshTokenValiditySeconds()).thenReturn(refreshTokenValiditySeconds);\r\n    long start = System.currentTimeMillis();\r\n    OAuth2AccessTokenEntity token = service.createAccessToken(authentication);\r\n    long end = System.currentTimeMillis();\r\n    Date lowerBoundAccessTokens = new Date(start + (accessTokenValiditySeconds * 1000L) - DELTA);\r\n    Date upperBoundAccessTokens = new Date(end + (accessTokenValiditySeconds * 1000L) + DELTA);\r\n    Date lowerBoundRefreshTokens = new Date(start + (refreshTokenValiditySeconds * 1000L) - DELTA);\r\n    Date upperBoundRefreshTokens = new Date(end + (refreshTokenValiditySeconds * 1000L) + DELTA);\r\n    verify(scopeService, atLeastOnce()).removeReservedScopes(anySet());\r\n    assertTrue(token.getExpiration().after(lowerBoundAccessTokens) && token.getExpiration().before(upperBoundAccessTokens));\r\n    assertTrue(token.getRefreshToken().getExpiration().after(lowerBoundRefreshTokens) && token.getRefreshToken().getExpiration().before(upperBoundRefreshTokens));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.MulticastRouter.getAddresses",
	"Comment": "returns the element that contains the multiple recipients.",
	"Method": "Element getAddresses(Packet packet){\r\n    if (packet instanceof IQ) {\r\n        return ((IQ) packet).getChildElement().element(\"addresses\");\r\n    } else {\r\n        return packet.getElement().element(\"addresses\");\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pep.PEPService.canProbePresence",
	"Comment": "returns true if the the prober is allowed to see the presence of the probee.",
	"Method": "boolean canProbePresence(JID prober,JID probee){\r\n    Roster roster;\r\n    roster = XMPPServer.getInstance().getRosterManager().getRoster(prober.getNode());\r\n    RosterItem item = roster.getRosterItem(probee);\r\n    if (item.getSubStatus() == RosterItem.SUB_BOTH || item.getSubStatus() == RosterItem.SUB_FROM) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.ConnectionListener.reloadConfiguration",
	"Comment": "reconfigures the acceptor without breaking existing connections. note that not all configuration changescan be applied. these changes will be applied after a restart.",
	"Method": "void reloadConfiguration(){\r\n    if (connectionAcceptor == null) {\r\n        return;\r\n    }\r\n    Log.debug(\"Reconfiguring...\");\r\n    connectionAcceptor.reconfigure(generateConnectionConfiguration());\r\n    Log.info(\"Reconfigured.\");\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.loadOpenfireProperties",
	"Comment": "loads openfire properties if necessary. property loading must be done lazily sothat we give outside classes a chance to set home.",
	"Method": "void loadOpenfireProperties(){\r\n    if (openfireProperties == null) {\r\n        if (home == null && !failedLoading) {\r\n            failedLoading = true;\r\n            System.err.println(\"Critical Error! The home directory has not been configured, \\n\" + \"which will prevent the application from working correctly.\\n\\n\");\r\n        } else {\r\n            try {\r\n                openfireProperties = new XMLProperties(home + File.separator + getConfigName());\r\n            } catch (IOException ioe) {\r\n                Log.error(ioe.getMessage());\r\n                failedLoading = true;\r\n            }\r\n        }\r\n        if (openfireProperties == null) {\r\n            try {\r\n                openfireProperties = new XMLProperties();\r\n            } catch (IOException e) {\r\n                Log.error(\"Failed to setup default openfire properties\", e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpConnection.deliverBody",
	"Comment": "delivers content to the client. the content should be valid xmpp wrapped inside of a body.a null value for body indicates that the connection should be closed and the clientsent an empty body.",
	"Method": "void deliverBody(String body,boolean async){\r\n    synchronized (this) {\r\n        if (isClosed) {\r\n            throw new HttpConnectionClosedException(\"The http connection is no longer \" + \"available to deliver content\");\r\n        }\r\n        isClosed = true;\r\n    }\r\n    if (body == null) {\r\n        body = getSession().createEmptyBody(false);\r\n    }\r\n    HttpBindServlet.respond(getSession(), this.context, body, async);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.admin.DefaultAdminProvider.convertXMLToProvider",
	"Comment": "converts the old openfire.xml style admin list to use the new provider mechanism.",
	"Method": "void convertXMLToProvider(){\r\n    if (JiveGlobals.getXMLProperty(\"admin.authorizedJIDs\") == null && JiveGlobals.getXMLProperty(\"admin.authorizedUsernames\") == null && JiveGlobals.getXMLProperty(\"adminConsole.authorizedUsernames\") == null) {\r\n        return;\r\n    }\r\n    List<JID> adminList = new ArrayList();\r\n    String jids = JiveGlobals.getXMLProperty(\"admin.authorizedJIDs\");\r\n    jids = (jids == null || jids.trim().length() == 0) ? \"\" : jids;\r\n    StringTokenizer tokenizer = new StringTokenizer(jids, \",\");\r\n    while (tokenizer.hasMoreTokens()) {\r\n        String jid = tokenizer.nextToken().toLowerCase().trim();\r\n        try {\r\n            adminList.add(new JID(jid));\r\n        } catch (IllegalArgumentException e) {\r\n            Log.warn(\"Invalid JID found in authorizedJIDs at openfire.xml: \" + jid, e);\r\n        }\r\n    }\r\n    String usernames = JiveGlobals.getXMLProperty(\"admin.authorizedUsernames\");\r\n    if (usernames == null) {\r\n        usernames = JiveGlobals.getXMLProperty(\"adminConsole.authorizedUsernames\");\r\n    }\r\n    usernames = (usernames == null || usernames.trim().length() == 0) ? (adminList.size() == 0 ? \"admin\" : \"\") : usernames;\r\n    tokenizer = new StringTokenizer(usernames, \",\");\r\n    while (tokenizer.hasMoreTokens()) {\r\n        String username = tokenizer.nextToken();\r\n        try {\r\n            adminList.add(XMPPServer.getInstance().createJID(username.toLowerCase().trim(), null));\r\n        } catch (IllegalArgumentException e) {\r\n            Log.warn(\"Invalid username found in authorizedUsernames at openfire.xml: \" + username, e);\r\n        }\r\n    }\r\n    setAdmins(adminList);\r\n    JiveGlobals.deleteXMLProperty(\"admin.authorizedJIDs\");\r\n    JiveGlobals.deleteXMLProperty(\"admin.authorizedUsernames\");\r\n    JiveGlobals.deleteXMLProperty(\"adminConsole.authorizedUsernames\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getServerSessionTimeout",
	"Comment": "returns the number of milliseconds to elapse between clearing of idle server sessions.",
	"Method": "int getServerSessionTimeout(){\r\n    return JiveGlobals.getIntProperty(\"xmpp.server.session.timeout\", 5 * 60 * 1000);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.commands.AdHocCommand.addNextStageInformation",
	"Comment": "increments the stage number by one and adds to the command element the new data form andnew allowed actions that the user might perform.",
	"Method": "void addNextStageInformation(SessionData data,Element command){\r\n    data.setStage(data.getStage() + 1);\r\n    addStageInformation(data, command);\r\n    addStageActions(data, command);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.getMetadataForm",
	"Comment": "returns a data form containing the node configuration that is going to be used forservice discovery.",
	"Method": "DataForm getMetadataForm(){\r\n    DataForm form = new DataForm(DataForm.Type.result);\r\n    FormField formField = form.addField();\r\n    formField.setVariable(\"FORM_TYPE\");\r\n    formField.setType(FormField.Type.hidden);\r\n    formField.addValue(\"http://jabber.org/protocol/pubsub#meta-data\");\r\n    addFormFields(form, true);\r\n    return form;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.ConnectionManagerImpl.getPort",
	"Comment": "retrieves the configured tcp port on which a listener accepts connections.",
	"Method": "int getPort(ConnectionType type,boolean startInSslMode){\r\n    return getListener(type, startInSslMode).getPort();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.CertificateStoreManager.canonicalize",
	"Comment": "canonicalizes a path. when the provided path is a relative path, it is interpreted as to be relative to the homedirectory of openfire.",
	"Method": "File canonicalize(String path){\r\n    File file = new File(path);\r\n    if (!file.isAbsolute()) {\r\n        file = new File(JiveGlobals.getHomeDirectory() + File.separator + path);\r\n    }\r\n    return file;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sip.tester.security.CredentialsCacheEntry.processRequest",
	"Comment": "adds the specified branch id to the transaction history list.",
	"Method": "void processRequest(String requestBranchID){\r\n    transactionHistory.add(requestBranchID);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.close",
	"Comment": "closes the session. after a session has been closed it will no longer accept new connectionson the session id.",
	"Method": "void close(){\r\n    if (isClosed) {\r\n        return;\r\n    }\r\n    conn.close();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.EncryptionArtifactFactory.getSSLContext",
	"Comment": "generates a new, initialized sslcontext instance that is suitable for connections that are created based on aparticular configuration.",
	"Method": "SSLContext getSSLContext(){\r\n    final SSLContext sslContext = SSLContext.getInstance(\"TLSv1\");\r\n    sslContext.init(getKeyManagers(), getTrustManagers(), new SecureRandom());\r\n    return sslContext;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.auth.JDBCAuthProvider.getPasswordValue",
	"Comment": "returns the value of the password field. it will be in plain text or hashedformat, depending on the password type.",
	"Method": "String getPasswordValue(String username){\r\n    String password = null;\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    if (username.contains(\"@\")) {\r\n        int index = username.indexOf(\"@\");\r\n        String domain = username.substring(index + 1);\r\n        if (domain.equals(XMPPServer.getInstance().getServerInfo().getXMPPDomain())) {\r\n            username = username.substring(0, index);\r\n        } else {\r\n            throw new UserNotFoundException();\r\n        }\r\n    }\r\n    try {\r\n        con = getConnection();\r\n        pstmt = con.prepareStatement(passwordSQL);\r\n        pstmt.setString(1, username);\r\n        rs = pstmt.executeQuery();\r\n        if (!rs.next()) {\r\n            throw new UserNotFoundException();\r\n        }\r\n        password = rs.getString(1);\r\n    } catch (SQLException e) {\r\n        Log.error(\"Exception in JDBCAuthProvider\", e);\r\n        throw new UserNotFoundException();\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    return password;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapVCardProvider.getMergedVCard",
	"Comment": "returns a merged ldap vcard combined with a photo element provided in specified vcard.",
	"Method": "Element getMergedVCard(String username,Element mergeVCard){\r\n    username = JID.unescapeNode(username);\r\n    Map<String, String> map = getLdapAttributes(username);\r\n    Log.debug(\"LdapVCardProvider: Retrieving LDAP mapped vcard for \" + username);\r\n    if (map.isEmpty()) {\r\n        return null;\r\n    }\r\n    Element vcard = new VCard(template).getVCard(map);\r\n    if (mergeVCard == null) {\r\n        return vcard;\r\n    }\r\n    if (mergeVCard.element(\"PHOTO\") == null) {\r\n        return vcard;\r\n    }\r\n    Element photoElement = mergeVCard.element(\"PHOTO\").createCopy();\r\n    if (photoElement == null || photoElement.element(\"BINVAL\") == null || photoElement.element(\"BINVAL\").getText().matches(\"\\\\s*\")) {\r\n        return vcard;\r\n    }\r\n    if (!((vcard.element(\"PHOTO\") == null || vcard.element(\"PHOTO\").element(\"BINVAL\") == null || vcard.element(\"PHOTO\").element(\"BINVAL\").getText().matches(\"\\\\s*\")))) {\r\n        return vcard;\r\n    }\r\n    Log.debug(\"LdapVCardProvider: Merging avatar element from passed vcard\");\r\n    Element currentElement = vcard.element(\"PHOTO\");\r\n    if (currentElement != null) {\r\n        vcard.remove(currentElement);\r\n    }\r\n    vcard.add(photoElement);\r\n    return vcard;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SocketReadingMode.negotiateTLS",
	"Comment": "tries to secure the connection using tls. if the connection is secured then resetthe parser to use the new secured reader. but if the connection failed to be securedthen send astanza and close the connection.",
	"Method": "boolean negotiateTLS(){\r\n    if (socketReader.connection.getTlsPolicy() == Connection.TLSPolicy.disabled) {\r\n        StreamError error = new StreamError(StreamError.Condition.not_authorized);\r\n        socketReader.connection.deliverRawText(error.toXML());\r\n        socketReader.connection.close();\r\n        Log.warn(\"TLS requested by initiator when TLS was never offered by server. \" + \"Closing connection : \" + socketReader.connection);\r\n        return false;\r\n    }\r\n    try {\r\n        socketReader.connection.startTLS(false, false);\r\n    } catch (SSLHandshakeException e) {\r\n        Log.info(\"STARTTLS negotiation (with: {}) failed.\", socketReader.connection, e);\r\n        socketReader.connection.forceClose();\r\n        return false;\r\n    } catch (IOException | RuntimeException e) {\r\n        Log.warn(\"An exception occurred while performing STARTTLS negotiation (with: {})\", socketReader.connection, e);\r\n        socketReader.connection.deliverRawText(\"<failure xmlns=\\\"urn:ietf:params:xml:ns:xmpp-tls\\\"/>\");\r\n        socketReader.connection.close();\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.OpenfireX509TrustManagerTest.testInvalidChainCAnotTrusted",
	"Comment": "verifies that a chain that is valid, but does not have its root ca certificate in the trust store, is rejected.",
	"Method": "void testInvalidChainCAnotTrusted(){\r\n    systemUnderTest.checkClientTrusted(untrustedCAChain, \"RSA\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.EncryptionArtifactFactoryTest.testHasSupportedProtocols",
	"Comment": "verifies that the collection of supported encryption protocols is not empty.",
	"Method": "void testHasSupportedProtocols(){\r\n    final Collection<String> result = EncryptionArtifactFactory.getSupportedProtocols();\r\n    Assert.assertFalse(result.isEmpty());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.UserManager.createUser",
	"Comment": "creates a new user. required values are username and password. the email addressand name can optionally be null, unless the userprovider deems thateither of them are required.",
	"Method": "User createUser(String username,String password,String name,String email){\r\n    if (provider.isReadOnly()) {\r\n        throw new UnsupportedOperationException(\"User provider is read-only.\");\r\n    }\r\n    if (username == null || username.isEmpty()) {\r\n        throw new IllegalArgumentException(\"Null or empty username.\");\r\n    }\r\n    if (password == null || password.isEmpty()) {\r\n        throw new IllegalArgumentException(\"Null or empty password.\");\r\n    }\r\n    try {\r\n        username = Stringprep.nodeprep(username);\r\n    } catch (StringprepException se) {\r\n        throw new IllegalArgumentException(\"Invalid username: \" + username, se);\r\n    }\r\n    if (provider.isNameRequired() && (name == null || name.matches(\"\\\\s*\"))) {\r\n        throw new IllegalArgumentException(\"Invalid or empty name specified with provider that requires name. User: \" + username + \" Name: \" + name);\r\n    }\r\n    if (provider.isEmailRequired() && !StringUtils.isValidEmailAddress(email)) {\r\n        throw new IllegalArgumentException(\"Invalid or empty email address specified with provider that requires email address. User: \" + username + \" Email: \" + email);\r\n    }\r\n    User user = provider.createUser(username, password, name, email);\r\n    userCache.put(username, user);\r\n    Map<String, Object> params = Collections.emptyMap();\r\n    UserEventDispatcher.dispatchEvent(user, UserEventDispatcher.EventType.user_created, params);\r\n    return user;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.HistoryRequest.getMaxStanzas",
	"Comment": "returns the total number of messages to receive in the history.",
	"Method": "int getMaxStanzas(){\r\n    return maxStanzas;\r\n}"
}, {
	"Path": "org.jivesoftware.util.LinkedListNode.insert",
	"Comment": "inserts this node into the linked list that it will be a part of.",
	"Method": "LinkedListNode<E> insert(LinkedListNode<E> next,LinkedListNode<E> previous){\r\n    this.next = next;\r\n    this.previous = previous;\r\n    this.previous.next = this.next.previous = this;\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.isPersistPublishedItems",
	"Comment": "returns true if items are going to be persisted in a storage. note that when thevariable is false then the last published item is the only items being savedto the backend storage.",
	"Method": "boolean isPersistPublishedItems(){\r\n    return persistPublishedItems;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.OpenfireX509TrustManagerTest.testInvalidChainExpiredIntermediate",
	"Comment": "verifies that a chain that has an intermediate certificate that is expired is rejected.",
	"Method": "void testInvalidChainExpiredIntermediate(){\r\n    systemUnderTest.checkClientTrusted(expiredIntChain, \"RSA\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.setReplyPolicy",
	"Comment": "sets the policy that defines whether owners or publisher should receive replies to items.",
	"Method": "void setReplyPolicy(Node.ItemReplyPolicy replyPolicy){\r\n    this.replyPolicy = replyPolicy;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.security.SecurityAuditEvent.setSummary",
	"Comment": "sets the summary, or short description of what transpired in the event.",
	"Method": "void setSummary(String summary){\r\n    this.summary = summary;\r\n}"
}, {
	"Path": "org.mitre.util.jpa.JpaUtil.getResultPage",
	"Comment": "get a page of results from the specified typedquery\tby using the given pagecriteria to limit the query\tresults. the pagecriteria will override any size or\toffset already specified on the query.",
	"Method": "List<T> getResultPage(TypedQuery<T> query,PageCriteria pageCriteria){\r\n    query.setMaxResults(pageCriteria.getPageSize());\r\n    query.setFirstResult(pageCriteria.getPageNumber() * pageCriteria.getPageSize());\r\n    return query.getResultList();\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.isXMLPropertyEncrypted",
	"Comment": "determines whether an xml property is configured for encryption.",
	"Method": "boolean isXMLPropertyEncrypted(String name){\r\n    if (securityProperties == null) {\r\n        loadSecurityProperties();\r\n    }\r\n    return name != null && !name.startsWith(JiveGlobals.ENCRYPTED_PROPERTY_NAME_PREFIX) && securityProperties.getProperties(JiveGlobals.ENCRYPTED_PROPERTY_NAMES, true).contains(name);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.isSubscriptionConfigurationRequired",
	"Comment": "returns true if new subscriptions should be configured to be active. inactivesubscriptions will not get event notifications. however, subscribers will benotified when a node is deleted no matter the subscription status.",
	"Method": "boolean isSubscriptionConfigurationRequired(){\r\n    return subscriptionConfigurationRequired;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.cancelPresenceSubscriptions",
	"Comment": "unsubscribe from affiliates presences if node is only sending notifications toonly users or only unsubscribe from those subscribers that configured theirsubscription to send notifications based on their presence show value.",
	"Method": "void cancelPresenceSubscriptions(){\r\n    for (NodeSubscription subscription : getSubscriptions()) {\r\n        if (isPresenceBasedDelivery() || !subscription.getPresenceStates().isEmpty()) {\r\n            service.presenceSubscriptionNotRequired(this, subscription.getOwner());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.getConfigurationChangeForm",
	"Comment": "returns a data form with the node configuration. the returned data form is used fornotifying node subscribers that the node configuration has changed. the data form isony going to be included if node is configure to include payloads in eventnotifications.",
	"Method": "DataForm getConfigurationChangeForm(){\r\n    DataForm form = new DataForm(DataForm.Type.result);\r\n    FormField formField = form.addField();\r\n    formField.setVariable(\"FORM_TYPE\");\r\n    formField.setType(FormField.Type.hidden);\r\n    formField.addValue(\"http://jabber.org/protocol/pubsub#node_config\");\r\n    addFormFields(form, false);\r\n    return form;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.multiplex.ConnectionMultiplexerManager.getDefaultSecret",
	"Comment": "returns the default secret key that connection managers should present while trying toestablish a new connection.",
	"Method": "String getDefaultSecret(){\r\n    return JiveGlobals.getProperty(\"xmpp.multiplex.defaultSecret\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.handler.IQPrivacyHandler.getPrivacyList",
	"Comment": "returns the iq packet containing the details of the specified list. if no listwas found or the iq request contains more than one specified list then an error willbe returned.",
	"Method": "IQ getPrivacyList(IQ packet,JID from){\r\n    IQ result = IQ.createResultIQ(packet);\r\n    Element childElement = packet.getChildElement().createCopy();\r\n    result.setChildElement(childElement);\r\n    List<Element> lists = childElement.elements(\"list\");\r\n    if (lists.size() > 1) {\r\n        result.setError(PacketError.Condition.bad_request);\r\n    } else {\r\n        String listName = lists.get(0).attributeValue(\"name\");\r\n        PrivacyList list = null;\r\n        if (listName != null) {\r\n            list = manager.getPrivacyList(from.getNode(), listName);\r\n        }\r\n        if (list != null) {\r\n            childElement = result.setChildElement(\"query\", \"jabber:iq:privacy\");\r\n            childElement.add(list.asElement());\r\n        } else {\r\n            result.setError(PacketError.Condition.item_not_found);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.TestDefaultUserInfoService.loadByUsername_nullUser",
	"Comment": "if a user is not found, the loadbyusername method should throw an exception.",
	"Method": "void loadByUsername_nullUser(){\r\n    Mockito.when(userInfoRepository.getByUsername(adminUsername)).thenReturn(null);\r\n    UserInfo user = service.getByUsername(adminUsername);\r\n    assertNull(user);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.addSession",
	"Comment": "add a new session to be managed. the session has been authenticated and resourcebinding has been done.",
	"Method": "void addSession(LocalClientSession session){\r\n    routingTable.addClientRoute(session.getAddress(), session);\r\n    localSessionManager.getPreAuthenticatedSessions().remove(session.getStreamID().toString());\r\n    SessionEventDispatcher.EventType event = session.getAuthToken().isAnonymous() ? SessionEventDispatcher.EventType.anonymous_session_created : SessionEventDispatcher.EventType.session_created;\r\n    SessionEventDispatcher.dispatchEvent(session, event);\r\n    if (ClusterManager.isClusteringStarted()) {\r\n        sessionInfoCache.put(session.getAddress().toString(), new ClientSessionInfo(session));\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.getType",
	"Comment": "returns if the owner has subscribed to receive notification of new items onlyor of new nodes only. when subscribed to a leaf node then only itemsis available.",
	"Method": "Type getType(){\r\n    return type;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginServlet.handleJSP",
	"Comment": "handles a request for a jsp page. it checks to see if a servlet is mappedfor the jsp url. if one is found, request handling is passed to it. if noservlet is found, a 404 error is returned.",
	"Method": "void handleJSP(String pathInfo,HttpServletRequest request,HttpServletResponse response){\r\n    String jspURL = pathInfo.substring(1);\r\n    GenericServlet servlet = servlets.get(jspURL.toLowerCase());\r\n    if (servlet != null) {\r\n        servlet.service(request, response);\r\n    } else {\r\n        response.setStatus(HttpServletResponse.SC_NOT_FOUND);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.HybridUserProvider.setCreationDate",
	"Comment": "changes the creation date of a user in the first provider that contains the user.",
	"Method": "void setCreationDate(String username,Date creationDate){\r\n    getUserProvider(username).setCreationDate(username, creationDate);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.PresencePlugin.setPresencePublic",
	"Comment": "sets if anyone is allowed to see the presence of other users. a false value means thatonly the users that are subscribed to a user presence will be able to get informationabout the user. by default, presence information is not publicly available.",
	"Method": "void setPresencePublic(boolean presencesPublic){\r\n    JiveGlobals.setProperty(\"plugin.presence.public\", presencesPublic ? \"true\" : \"false\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.commands.SessionData.getStage",
	"Comment": "returns the current stage where the requester is located. stages are numbered from 0. astage with value 0 means that a command request has just been received and no data formhas been sent to the requester yet. the first sent data form of the first stage would berepresented as stage 1.",
	"Method": "int getStage(){\r\n    return stage;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.PacketTransporterImpl.getTransportHandler",
	"Comment": "obtain the transport handler that this transporter uses for deliveringtransport packets.",
	"Method": "TransportHandler getTransportHandler(){\r\n    return transportHandler;\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ProviderTokenService.createAccessToken_nullAuth",
	"Comment": "tests exception handling for null authentication or null authorization.",
	"Method": "void createAccessToken_nullAuth(){\r\n    when(authentication.getOAuth2Request()).thenReturn(null);\r\n    try {\r\n        service.createAccessToken(null);\r\n        fail(\"Authentication parameter is null. Excpected a AuthenticationCredentialsNotFoundException.\");\r\n    } catch (AuthenticationCredentialsNotFoundException e) {\r\n        assertThat(e, is(notNullValue()));\r\n    }\r\n    try {\r\n        service.createAccessToken(authentication);\r\n        fail(\"AuthorizationRequest is null. Excpected a AuthenticationCredentialsNotFoundException.\");\r\n    } catch (AuthenticationCredentialsNotFoundException e) {\r\n        assertThat(e, is(notNullValue()));\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.setPayloadDelivered",
	"Comment": "sets whether event notifications will include payloads. payloads are included whenpublishing new items. however, new items may not always include a payload dependingon the node configuration. nodes can be configured to not deliver payloads for performancereasons.",
	"Method": "void setPayloadDelivered(boolean deliverPayloads){\r\n    this.deliverPayloads = deliverPayloads;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SASLAuthentication.removeSupportedMechanism",
	"Comment": "removes a sasl mechanism from the list of supported sasl mechanisms by the server.",
	"Method": "void removeSupportedMechanism(String mechanismName){\r\n    if (mechanismName == null || mechanismName.isEmpty()) {\r\n        throw new IllegalArgumentException(\"Argument 'mechanism' must cannot be null or an empty string.\");\r\n    }\r\n    if (mechanisms.remove(mechanismName.toUpperCase())) {\r\n        Log.info(\"Support removed for the '{}' SASL mechanism.\", mechanismName.toUpperCase());\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.canSendNodeEvents",
	"Comment": "returns true if node events such as configuration changed or node purged can besent to the subscriber.",
	"Method": "boolean canSendNodeEvents(){\r\n    return canSendEvents();\r\n}"
}, {
	"Path": "org.jivesoftware.util.EmailService.isDebugEnabled",
	"Comment": "returns true if smtp debugging is enabled. debug information iswritten to system.out by the underlying javamail provider.",
	"Method": "boolean isDebugEnabled(){\r\n    return debugEnabled;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.isSubscriptionEnabled",
	"Comment": "returns true if subscribing and unsubscribing are enabled.",
	"Method": "boolean isSubscriptionEnabled(){\r\n    return subscriptionEnabled;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.writeStringList",
	"Comment": "writes a list of strings. this method handles the case when the list isnull.",
	"Method": "void writeStringList(DataOutput out,List<String> stringList){\r\n    strategy.writeStringList(out, stringList);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sasl.JiveSharedSecretSaslServer.setSharedSecretAllowed",
	"Comment": "sets whether shared secret authentication is enabled. shared secret authentication creates an anonymous session,but requires that the authenticating entity know a shared secret key. the client sends a digest of the secretkey, which is compared against a digest of the local shared key.",
	"Method": "void setSharedSecretAllowed(boolean sharedSecretAllowed){\r\n    JiveGlobals.setProperty(\"xmpp.auth.sharedSecretEnabled\", sharedSecretAllowed ? \"true\" : \"false\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalIncomingServerSession.createSession",
	"Comment": "creates a new session that will receive packets. the new session will be authenticatedbefore being returned. if the authentication process fails then the answer will benull.",
	"Method": "LocalIncomingServerSession createSession(String serverName,XMPPPacketReader reader,SocketConnection connection,boolean directTLS){\r\n    XmlPullParser xpp = reader.getXPPParser();\r\n    String version = xpp.getAttributeValue(\"\", \"version\");\r\n    String fromDomain = xpp.getAttributeValue(\"\", \"from\");\r\n    String toDomain = xpp.getAttributeValue(\"\", \"to\");\r\n    int[] serverVersion = version != null ? decodeVersion(version) : new int[] { 0, 0 };\r\n    if (toDomain == null) {\r\n        toDomain = serverName;\r\n    }\r\n    try {\r\n        StreamID streamID = SessionManager.getInstance().nextStreamID();\r\n        LocalIncomingServerSession session = SessionManager.getInstance().createIncomingServerSession(connection, streamID, fromDomain);\r\n        StringBuilder openingStream = new StringBuilder();\r\n        openingStream.append(\"<stream:stream\");\r\n        openingStream.append(\" xmlns:db=\\\"jabber:server:dialback\\\"\");\r\n        openingStream.append(\" xmlns:stream=\\\"http://etherx.jabber.org/streams\\\"\");\r\n        openingStream.append(\" xmlns=\\\"jabber:server\\\"\");\r\n        openingStream.append(\" from=\\\"\").append(toDomain).append(\"\\\"\");\r\n        if (fromDomain != null) {\r\n            openingStream.append(\" to=\\\"\").append(fromDomain).append(\"\\\"\");\r\n        }\r\n        openingStream.append(\" id=\\\"\").append(streamID).append(\"\\\"\");\r\n        if (serverVersion[0] >= 1) {\r\n            openingStream.append(\" version=\\\"1.0\\\">\");\r\n        } else {\r\n            openingStream.append('>');\r\n        }\r\n        connection.deliverRawText(openingStream.toString());\r\n        if (serverVersion[0] >= 1) {\r\n            Connection.TLSPolicy tlsPolicy = connection.getTlsPolicy();\r\n            boolean hasCertificates = false;\r\n            try {\r\n                hasCertificates = XMPPServer.getInstance().getCertificateStoreManager().getIdentityStore(ConnectionType.SOCKET_S2S).getStore().size() > 0;\r\n            } catch (Exception e) {\r\n                Log.error(e.getMessage(), e);\r\n            }\r\n            if (Connection.TLSPolicy.required == tlsPolicy && !hasCertificates) {\r\n                Log.error(\"Server session rejected. TLS is required but no certificates \" + \"were created.\");\r\n                return null;\r\n            }\r\n            connection.setTlsPolicy(hasCertificates ? tlsPolicy : Connection.TLSPolicy.disabled);\r\n        }\r\n        connection.setCompressionPolicy(connection.getConfiguration().getCompressionPolicy());\r\n        StringBuilder sb = new StringBuilder();\r\n        if (serverVersion[0] >= 1) {\r\n            sb.append(\"<stream:features>\");\r\n            if (!directTLS && JiveGlobals.getBooleanProperty(ConnectionSettings.Server.TLS_ENABLED, true)) {\r\n                sb.append(\"<starttls xmlns=\\\"urn:ietf:params:xml:ns:xmpp-tls\\\">\");\r\n                if (!ServerDialback.isEnabled()) {\r\n                    sb.append(\"<required/>\");\r\n                }\r\n                sb.append(\"<\/starttls>\");\r\n            }\r\n            sb.append(SASLAuthentication.getSASLMechanisms(session));\r\n            if (ServerDialback.isEnabled()) {\r\n                sb.append(\"<dialback xmlns=\\\"urn:xmpp:features:dialback\\\"><errors/><\/dialback>\");\r\n            }\r\n            sb.append(\"<\/stream:features>\");\r\n        }\r\n        connection.deliverRawText(sb.toString());\r\n        session.setLocalDomain(serverName);\r\n        return session;\r\n    } catch (Exception e) {\r\n        Log.error(\"Error establishing connection from remote server:\" + connection, e);\r\n        connection.close();\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getPresenceSubscribeHandler",
	"Comment": "returns the presencesubscribehandler registered with this server. thepresencesubscribehandler was registered with the server as a module whilestarting up the server.",
	"Method": "PresenceSubscribeHandler getPresenceSubscribeHandler(){\r\n    return (PresenceSubscribeHandler) modules.get(PresenceSubscribeHandler.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.isConnectionPoolEnabled",
	"Comment": "returns whether an ldap connection pool should be used or not.",
	"Method": "boolean isConnectionPoolEnabled(){\r\n    return connectionPoolEnabled;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.multiplex.MultiplexerPacketHandler.handle",
	"Comment": "process iq packet sent by a connection manager indicating that a new session hasbeen created, should be closed or that a packet was failed to be delivered.",
	"Method": "void handle(Packet packet){\r\n    if (packet instanceof IQ) {\r\n        IQ iq = (IQ) packet;\r\n        if (iq.getType() == IQ.Type.result) {\r\n        } else if (iq.getType() == IQ.Type.error) {\r\n            Log.warn(\"Connection Manager failed to process IQ packet: \" + packet.toXML());\r\n        } else if (iq.getType() == IQ.Type.set) {\r\n            Element child = iq.getChildElement();\r\n            String streamIDValue = child.attributeValue(\"id\");\r\n            if (streamIDValue == null) {\r\n                Element extraError = DocumentHelper.createElement(QName.get(\"id-required\", \"http://jabber.org/protocol/connectionmanager#errors\"));\r\n                sendErrorPacket(iq, PacketError.Condition.bad_request, extraError);\r\n            } else if (\"session\".equals(child.getName())) {\r\n                StreamID streamID = BasicStreamIDFactory.createStreamID(streamIDValue);\r\n                Element create = child.element(\"create\");\r\n                if (create != null) {\r\n                    Element hostElement = create.element(\"host\");\r\n                    String hostName = hostElement != null ? hostElement.attributeValue(\"name\") : null;\r\n                    String hostAddress = hostElement != null ? hostElement.attributeValue(\"address\") : null;\r\n                    boolean created = multiplexerManager.createClientSession(connectionManagerDomain, streamID, hostName, hostAddress);\r\n                    if (created) {\r\n                        sendResultPacket(iq);\r\n                    } else {\r\n                        sendErrorPacket(iq, PacketError.Condition.not_allowed, null);\r\n                    }\r\n                } else {\r\n                    ClientSession session = multiplexerManager.getClientSession(connectionManagerDomain, streamID);\r\n                    if (session == null) {\r\n                        sendErrorPacket(iq, PacketError.Condition.item_not_found, null);\r\n                    } else if (child.element(\"close\") != null) {\r\n                        multiplexerManager.closeClientSession(connectionManagerDomain, streamID);\r\n                        sendResultPacket(iq);\r\n                    } else if (child.element(\"failed\") != null) {\r\n                        List wrappedElements = child.element(\"failed\").elements();\r\n                        if (wrappedElements.size() != 1) {\r\n                            Element extraError = DocumentHelper.createElement(QName.get(\"invalid-payload\", \"http://jabber.org/protocol/connectionmanager#errors\"));\r\n                            sendErrorPacket(iq, PacketError.Condition.bad_request, extraError);\r\n                        } else {\r\n                            Element wrappedElement = (Element) wrappedElements.get(0);\r\n                            String tag = wrappedElement.getName();\r\n                            if (\"message\".equals(tag)) {\r\n                                XMPPServer.getInstance().getOfflineMessageStrategy().storeOffline(new Message(wrappedElement));\r\n                                sendResultPacket(iq);\r\n                            } else {\r\n                                Element extraError = DocumentHelper.createElement(QName.get(\"unknown-stanza\", \"http://jabber.org/protocol/connectionmanager#errors\"));\r\n                                sendErrorPacket(iq, PacketError.Condition.bad_request, extraError);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        sendErrorPacket(iq, PacketError.Condition.bad_request, null);\r\n                    }\r\n                }\r\n            } else {\r\n                sendErrorPacket(iq, PacketError.Condition.bad_request, null);\r\n            }\r\n        } else {\r\n            sendErrorPacket(iq, PacketError.Condition.bad_request, null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getIncomingServerSession",
	"Comment": "returns the incoming server session hosted by this jvm that matches the specified stream id.",
	"Method": "LocalIncomingServerSession getIncomingServerSession(StreamID streamID){\r\n    return localSessionManager.getIncomingServerSession(streamID);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SocketSendingTracker.start",
	"Comment": "start up the daemon thread that will check for the health of the sockets that arecurrently sending data.",
	"Method": "void start(){\r\n    shutdown = false;\r\n    checkingThread = new Thread(\"SocketSendingTracker\") {\r\n        @Override\r\n        public void run() {\r\n            while (!shutdown) {\r\n                checkHealth();\r\n                synchronized (this) {\r\n                    try {\r\n                        wait(10000);\r\n                    } catch (InterruptedException e) {\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    checkingThread.setDaemon(true);\r\n    checkingThread.start();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SocketSendingTracker.start",
	"Comment": "start up the daemon thread that will check for the health of the sockets that arecurrently sending data.",
	"Method": "void start(){\r\n    while (!shutdown) {\r\n        checkHealth();\r\n        synchronized (this) {\r\n            try {\r\n                wait(10000);\r\n            } catch (InterruptedException e) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.isNotifiedOfConfigChanges",
	"Comment": "returns true if subscribers will be notified when the node configuration changes.",
	"Method": "boolean isNotifiedOfConfigChanges(){\r\n    return notifyConfigChanges;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalClientSession.setActiveList",
	"Comment": "sets the privacy list that overrides the default privacy list. this list affectsonly this session and only for the duration of the session.",
	"Method": "void setActiveList(PrivacyList activeList){\r\n    this.activeList = activeList != null ? activeList.getName() : null;\r\n    if (ClusterManager.isClusteringStarted()) {\r\n        Cache<String, ClientSessionInfo> cache = SessionManager.getInstance().getSessionInfoCache();\r\n        cache.put(getAddress().toString(), new ClientSessionInfo(this));\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.PacketTransporterImpl.deliver",
	"Comment": "delivers the given packet based on packet recipient and sender. thedeliverer defers actual routing decisions to other classes.warningbe careful to enforce concurrency dbc of concurrent by synchronizingany accesses to class resources.",
	"Method": "void deliver(Packet packet){\r\n    if (packet == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (xmppServer != null && xmppServer.isLocal(packet.getTo())) {\r\n        deliverer.deliver(packet);\r\n    } else if (transportHandler != null) {\r\n        transportHandler.process(packet);\r\n    } else {\r\n        Log.warn(\"Could not deliver message: no deliverer available \" + packet.toString());\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.DummyExternalizableUtil.readStringList",
	"Comment": "reads a list of strings. this method will return null if the listwritten to the stream was null.",
	"Method": "List<String> readStringList(DataInput in){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.multiplex.ConnectionMultiplexerManager.getClientSession",
	"Comment": "returns the clientsession with the specified stream id that is being hosted by thespecified connection manager.",
	"Method": "LocalClientSession getClientSession(String connectionManagerDomain,StreamID streamID){\r\n    Map<StreamID, LocalClientSession> sessions = sessionsByManager.get(connectionManagerDomain);\r\n    if (sessions != null) {\r\n        return sessions.get(streamID);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.SearchPlugin.performSearch",
	"Comment": "performs a search based on form data, and returns the search results.",
	"Method": "Set<User> performSearch(Element incomingForm,int startIndex,int max,Set<User> performSearch,Element incomingForm){\r\n    return performSearch(incomingForm, -1, -1);\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.getMinConnections",
	"Comment": "returns the minimum number of connections that the pool will use. thisshould probably be at least three.",
	"Method": "int getMinConnections(){\r\n    return minConnections;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.GroupJID.isGroup",
	"Comment": "check a jid to determine whether it represents a group. if the givenjid is an instance of this class, it is a group jid. otherwise,calculate the hash to determine whether the jid can be resolved toa group. this method also optionally validates that the corresponding group actually exists in the local domain.",
	"Method": "boolean isGroup(JID jid,boolean isGroup,JID jid,boolean groupMustExist){\r\n    boolean isGroup = false;\r\n    String groupName = null, node = jid.getNode();\r\n    if (node != null) {\r\n        isGroup = (jid instanceof GroupJID) ? true : jid.getResource() != null && StringUtils.isBase32(node) && StringUtils.hash(groupName = decodeNode(node)).equals(jid.getResource());\r\n        if (isGroup && groupMustExist) {\r\n            Log.debug(\"Validating group: \" + jid);\r\n            if (XMPPServer.getInstance().isLocal(jid)) {\r\n                GroupManager.getInstance().getGroup(groupName);\r\n            } else {\r\n                isGroup = false;\r\n            }\r\n        }\r\n    }\r\n    return isGroup;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.multiplex.ConnectionMultiplexerManager.getMultiplexers",
	"Comment": "returns the names of the connected connection managers to this server.",
	"Method": "Collection<String> getMultiplexers(){\r\n    return sessionsByManager.keySet();\r\n}"
}, {
	"Path": "org.jivesoftware.util.StringUtils.getElapsedTime",
	"Comment": "returns a textual representation for the time that has elapsed.",
	"Method": "String getElapsedTime(long delta){\r\n    if (delta < JiveConstants.MINUTE) {\r\n        return LocaleUtils.getLocalizedString(\"global.less-minute\");\r\n    } else if (delta < JiveConstants.HOUR) {\r\n        long mins = delta / JiveConstants.MINUTE;\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(mins).append(' ');\r\n        sb.append((mins == 1) ? LocaleUtils.getLocalizedString(\"global.minute\") : LocaleUtils.getLocalizedString(\"global.minutes\"));\r\n        return sb.toString();\r\n    } else if (delta < JiveConstants.DAY) {\r\n        long hours = delta / JiveConstants.HOUR;\r\n        delta -= hours * JiveConstants.HOUR;\r\n        long mins = delta / JiveConstants.MINUTE;\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(hours).append(' ');\r\n        sb.append((hours == 1) ? LocaleUtils.getLocalizedString(\"global.hour\") : LocaleUtils.getLocalizedString(\"global.hours\"));\r\n        sb.append(\", \");\r\n        sb.append(mins).append(' ');\r\n        sb.append((mins == 1) ? LocaleUtils.getLocalizedString(\"global.minute\") : LocaleUtils.getLocalizedString(\"global.minutes\"));\r\n        return sb.toString();\r\n    } else {\r\n        long days = delta / JiveConstants.DAY;\r\n        delta -= days * JiveConstants.DAY;\r\n        long hours = delta / JiveConstants.HOUR;\r\n        delta -= hours * JiveConstants.HOUR;\r\n        long mins = delta / JiveConstants.MINUTE;\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(days).append(' ');\r\n        sb.append((days == 1) ? LocaleUtils.getLocalizedString(\"global.day\") : LocaleUtils.getLocalizedString(\"global.days\"));\r\n        sb.append(\", \");\r\n        sb.append(hours).append(' ');\r\n        sb.append((hours == 1) ? LocaleUtils.getLocalizedString(\"global.hour\") : LocaleUtils.getLocalizedString(\"global.hours\"));\r\n        sb.append(\", \");\r\n        sb.append(mins).append(' ');\r\n        sb.append((mins == 1) ? LocaleUtils.getLocalizedString(\"global.minute\") : LocaleUtils.getLocalizedString(\"global.minutes\"));\r\n        return sb.toString();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.ConcurrentGroupMap.syncGroups",
	"Comment": "this method is called from several of the mutators to keepthe group set in sync with the keys in the map.",
	"Method": "boolean syncGroups(Object item,boolean keyOrValue,boolean addOrRemove){\r\n    boolean result = false;\r\n    Set<String> groupSet = (keyOrValue == KEYS) ? knownGroupNamesFromKeys : knownGroupNamesFromValues;\r\n    if (groupSet != null) {\r\n        Group group = Group.resolveFrom(item);\r\n        if (group != null) {\r\n            result = true;\r\n            if (addOrRemove == ADD) {\r\n                groupSet.add(group.getName());\r\n            } else if (addOrRemove == REMOVE) {\r\n                groupSet.remove(group.getName());\r\n                if (groupSet.isEmpty()) {\r\n                    if (keyOrValue == KEYS) {\r\n                        knownGroupNamesFromKeys = null;\r\n                    } else {\r\n                        knownGroupNamesFromValues = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.AdminConsolePlugin.getBindInterface",
	"Comment": "returns null if the admin console will be available in all network interfaces of this machineor a string representing the only interface where the admin console will be available.",
	"Method": "String getBindInterface(){\r\n    String adminInterfaceName = JiveGlobals.getXMLProperty(\"adminConsole.interface\");\r\n    String globalInterfaceName = JiveGlobals.getXMLProperty(\"network.interface\");\r\n    String bindInterface = null;\r\n    if (adminInterfaceName != null && adminInterfaceName.trim().length() > 0) {\r\n        bindInterface = adminInterfaceName;\r\n    } else if (globalInterfaceName != null && globalInterfaceName.trim().length() > 0) {\r\n        bindInterface = globalInterfaceName;\r\n    }\r\n    return bindInterface;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginDevEnvironment.getWebRoot",
	"Comment": "returns the document root of a plugins web developmentapplication.",
	"Method": "File getWebRoot(){\r\n    return webRoot;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.disco.IQDiscoInfoHandler.getProvider",
	"Comment": "returns the discoinfoprovider responsible for providing information about a given entity ornull if none was found.",
	"Method": "DiscoInfoProvider getProvider(String name){\r\n    return entities.get(name);\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.DefaultCache.deleteExpiredEntries",
	"Comment": "clears all entries out of cache where the entries are older than themaximum defined age.",
	"Method": "void deleteExpiredEntries(){\r\n    if (maxLifetime <= 0) {\r\n        return;\r\n    }\r\n    LinkedListNode<K> node = ageList.getLast();\r\n    if (node == null) {\r\n        return;\r\n    }\r\n    long expireTime = System.currentTimeMillis() - maxLifetime;\r\n    while (expireTime > node.timestamp) {\r\n        remove(node.object);\r\n        node = ageList.getLast();\r\n        if (node == null) {\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getRoutingTable",
	"Comment": "returns the routingtable registered with this server. theroutingtable was registered with the server as a module while starting upthe server.",
	"Method": "RoutingTable getRoutingTable(){\r\n    return (RoutingTable) modules.get(RoutingTableImpl.class);\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.setTestAfterUse",
	"Comment": "sets whether connections will be tested after being returned to the pool.",
	"Method": "void setTestAfterUse(Boolean testAfterUse){\r\n    this.testAfterUse = testAfterUse;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.HistoryStrategy.getMaxNumber",
	"Comment": "obtain the maximum number of messages for strategies using message number limitations.",
	"Method": "int getMaxNumber(){\r\n    return maxNumber;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.Roster.probePresence",
	"Comment": "sends a presence probe to the probee for each connected resource of this user.",
	"Method": "void probePresence(JID probee){\r\n    final PresenceManager presenceManager = XMPPServer.getInstance().getPresenceManager();\r\n    for (ClientSession session : SessionManager.getInstance().getSessions(username)) {\r\n        presenceManager.probePresence(session.getAddress(), probee);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.FlashCrossDomainHandler.read",
	"Comment": "safely read a string from the reader until a zero character or a newlineis received, more then 100 invalid code points where read or the 200character is reached.",
	"Method": "String read(BufferedReader in){\r\n    StringBuilder buffer = new StringBuilder();\r\n    int codePoint;\r\n    boolean stopReading = false;\r\n    int invalidCodePoints = 0;\r\n    try {\r\n        do {\r\n            codePoint = in.read();\r\n            if (codePoint == 0 || codePoint == '\\n' || codePoint == -1) {\r\n                stopReading = true;\r\n            } else if (Character.isValidCodePoint(codePoint)) {\r\n                buffer.appendCodePoint(codePoint);\r\n            } else {\r\n                invalidCodePoints++;\r\n            }\r\n        } while (!stopReading && buffer.length() < 200 && invalidCodePoints < 100);\r\n    } catch (Exception e) {\r\n        Log.debug(\"Exception (read): \" + e.getMessage());\r\n    }\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.AdminConsolePlugin.getAdminSecurePort",
	"Comment": "returns the ssl port on which the admin console is current operating.",
	"Method": "int getAdminSecurePort(){\r\n    if (!sslEnabled) {\r\n        return 0;\r\n    }\r\n    return adminSecurePort;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.UserMultiProvider.isEmailRequired",
	"Comment": "returns whether all backing providers require an email address to be set on user objects. if at leastone proivder does not, this method returns false.",
	"Method": "boolean isEmailRequired(){\r\n    for (final UserProvider provider : getUserProviders()) {\r\n        if (!provider.isEmailRequired()) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.addServerListener",
	"Comment": "adds a new server listener that will be notified when the server has been startedor is about to be stopped.",
	"Method": "void addServerListener(XMPPServerListener listener){\r\n    listeners.add(listener);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.ConnectionManagerImpl.stopListeners",
	"Comment": "stops all listeners. this ensures no listener will accept new connections.",
	"Method": "void stopListeners(){\r\n    for (final ConnectionListener listener : getListeners()) {\r\n        try {\r\n            listener.stop();\r\n        } catch (RuntimeException ex) {\r\n            Log.error(\"An exception occurred while stopping listener \" + listener, ex);\r\n        }\r\n    }\r\n    try {\r\n        HttpBindManager.getInstance().stop();\r\n    } catch (RuntimeException ex) {\r\n        Log.error(\"An exception occurred while stopping HTTP Bind listener \", ex);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.MINAConnectionAcceptor.isIdle",
	"Comment": "determines if this instance is currently in a state where it is actively serving connections.",
	"Method": "boolean isIdle(){\r\n    return this.socketAcceptor != null && this.socketAcceptor.getManagedSessionCount() == 0;\r\n}"
}, {
	"Path": "org.mitre.util.JsonUtils.getAsArray",
	"Comment": "translate a set of strings to a json array, empty array returned as null",
	"Method": "JsonElement getAsArray(Set<String> value,JsonElement getAsArray,Set<String> value,boolean preserveEmpty){\r\n    if (!preserveEmpty && value != null && value.isEmpty()) {\r\n        return JsonNull.INSTANCE;\r\n    } else {\r\n        return gson.toJsonTree(value, new TypeToken<Set<String>>() {\r\n        }.getType());\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.getState",
	"Comment": "returns the current subscription state. subscriptions with status of pending should beauthorized by a node owner.",
	"Method": "State getState(){\r\n    return state;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.stun.STUNService.getStunServerAddresses",
	"Comment": "abstraction method used to convert a string into a stun server address list",
	"Method": "List<StunServerAddress> getStunServerAddresses(String addresses){\r\n    List<StunServerAddress> list = new ArrayList<StunServerAddress>();\r\n    if (addresses.equals(\"\")) {\r\n        return list;\r\n    }\r\n    String[] servers = addresses.split(\";\");\r\n    for (String server : servers) {\r\n        String[] address = server.split(\":\");\r\n        StunServerAddress aux = new StunServerAddress(address[0], address[1]);\r\n        if (!list.contains(aux)) {\r\n            list.add(aux);\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.setNotifiedOfConfigChanges",
	"Comment": "sets whether subscribers will be notified when the node configuration changes.",
	"Method": "void setNotifiedOfConfigChanges(boolean notifyConfigChanges){\r\n    this.notifyConfigChanges = notifyConfigChanges;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.filetransfer.proxy.FileTransferProxy.setProxyPort",
	"Comment": "sets the port that the proxy operates on. this requires a restart of the file transfer proxy.",
	"Method": "void setProxyPort(int port){\r\n    JiveGlobals.setProperty(JIVEPROPERTY_PORT, Integer.toString(port));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ServerPort.isConnectionManagerPort",
	"Comment": "returns true if connection managers can connect to this port.",
	"Method": "boolean isConnectionManagerPort(){\r\n    return type == Type.connectionManager;\r\n}"
}, {
	"Path": "org.jivesoftware.util.TaskEngine.submit",
	"Comment": "submits a runnable task for execution and returns a futurerepresenting that task.",
	"Method": "Future<?> submit(Runnable task){\r\n    try {\r\n        return executor.submit(task);\r\n    } catch (Throwable t) {\r\n        Log.warn(\"Failed to schedule task; will retry using caller's thread: {0}\", t.getMessage());\r\n        FutureTask<?> result = new FutureTask(task, null);\r\n        result.run();\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.setMinConnections",
	"Comment": "sets the minimum number of connections that the pool will use. thisshould probably be at least three.",
	"Method": "void setMinConnections(int minConnections){\r\n    this.minConnections = minConnections;\r\n    saveProperties();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.commands.SessionData.getData",
	"Comment": "returns a map with all the variables and values obtained during all the command stages.",
	"Method": "Map<String, List<String>> getData(){\r\n    Map<String, List<String>> data = new HashMap();\r\n    for (Map<String, List<String>> stageData : stagesData.values()) {\r\n        data.putAll(stageData);\r\n    }\r\n    return data;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getInstance",
	"Comment": "returns the instance of sessionmanagerimpl being used by the xmppserver.",
	"Method": "SessionManager getInstance(){\r\n    return XMPPServer.getInstance().getSessionManager();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.UpdateManager.setNotificationEnabled",
	"Comment": "sets if admins should be notified by im when new updates are available.",
	"Method": "void setNotificationEnabled(boolean enabled){\r\n    JiveGlobals.setProperty(\"update.notify-admins\", enabled ? \"true\" : \"false\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.commands.admin.GetUsersPresence.hasPermission",
	"Comment": "returns if the requester can access this command. admins and components are allowed toexecute this command.",
	"Method": "boolean hasPermission(JID requester){\r\n    return super.hasPermission(requester) || InternalComponentManager.getInstance().hasComponent(requester);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.isFollowAliasReferralsEnabled",
	"Comment": "returns true if ldap alias referrals will automatically be followed when found.",
	"Method": "boolean isFollowAliasReferralsEnabled(){\r\n    return followAliasReferrals;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.isPresenceBasedDelivery",
	"Comment": "returns true if notifications are going to be delivered only to available users.",
	"Method": "boolean isPresenceBasedDelivery(){\r\n    return presenceBasedDelivery;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.GroupJID.fromJID",
	"Comment": "returns a jid from the given jid. if the jid represents a group,returns an instance of this class. otherwise returns the given jid.",
	"Method": "JID fromJID(JID jid){\r\n    if (jid instanceof GroupJID || jid.getResource() == null || jid.getNode() == null) {\r\n        return jid;\r\n    } else {\r\n        return (isGroup(jid)) ? new GroupJID(jid) : jid;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.lockout.LockOutFlag.setEndTime",
	"Comment": "sets the end time for when the account will be reenabled, or null if manual reenable required.",
	"Method": "void setEndTime(Date endTime){\r\n    this.endTime = endTime;\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.getServerURL",
	"Comment": "returns the jdbc connection url used to make database connections.",
	"Method": "String getServerURL(){\r\n    return serverURL;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.GroupManager.getVisibleGroups",
	"Comment": "returns an unmodifiable collection of all shared groups in the system for a given username.",
	"Method": "Collection<Group> getVisibleGroups(Group groupToCheck){\r\n    HashSet<String> groupNames = getPublicGroupsFromCache();\r\n    if (groupNames == null) {\r\n        synchronized (PUBLIC_GROUPS) {\r\n            groupNames = getPublicGroupsFromCache();\r\n            if (groupNames == null) {\r\n                groupNames = new HashSet(provider.getPublicSharedGroupNames());\r\n                savePublicGroupsInCache(groupNames);\r\n            }\r\n        }\r\n    }\r\n    groupNames.addAll(provider.getVisibleGroupNames(groupToCheck.getName()));\r\n    return new GroupCollection(groupNames);\r\n}"
}, {
	"Path": "org.jivesoftware.util.EmailService.setPort",
	"Comment": "sets the port number that will be used when connecting to the smtpserver. the default is 25, the standard smtp port number.",
	"Method": "void setPort(int port){\r\n    if (port < 0) {\r\n        throw new IllegalArgumentException(\"Invalid port value: \" + port);\r\n    }\r\n    this.port = port;\r\n    JiveGlobals.setProperty(\"mail.smtp.port\", Integer.toString(port));\r\n    session = null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getOfflineMessageStrategy",
	"Comment": "returns the offlinemessagestrategy registered with this server. theofflinemessagestrategy was registered with the server as a module while startingup the server.",
	"Method": "OfflineMessageStrategy getOfflineMessageStrategy(){\r\n    return (OfflineMessageStrategy) modules.get(OfflineMessageStrategy.class);\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.writeStringMap",
	"Comment": "writes a map of string key and value pairs. this method handles thecase when the map is null.",
	"Method": "void writeStringMap(DataOutput out,Map<String, String> stringMap){\r\n    strategy.writeStringMap(out, stringMap);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.resultsetmanager.ResultSet.getUID",
	"Comment": "returns the uid of the object at the specified index in this result set.",
	"Method": "String getUID(int index){\r\n    return get(index).getUID();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapAuthorizationPolicy.authorize",
	"Comment": "returns if the principal is explicitly authorized to the jid, throwsan unauthorizedexception otherwise",
	"Method": "boolean authorize(String username,String principal){\r\n    return getAuthorized(username).contains(principal);\r\n}"
}, {
	"Path": "org.jivesoftware.util.EmailService.setDebugEnabled",
	"Comment": "enables or disables smtp transport layer debugging. debug information iswritten to system.out by the underlying javamail provider.",
	"Method": "void setDebugEnabled(boolean debugEnabled){\r\n    this.debugEnabled = debugEnabled;\r\n    JiveGlobals.setProperty(\"mail.debug\", Boolean.toString(debugEnabled));\r\n    session = null;\r\n}"
}, {
	"Path": "org.jivesoftware.util.StringUtils.stripTags",
	"Comment": "this method takes a string and strips out all tags excepttags while still leavingthe tag body intact.",
	"Method": "String stripTags(String in){\r\n    if (in == null) {\r\n        return null;\r\n    }\r\n    char ch;\r\n    int i = 0;\r\n    int last = 0;\r\n    char[] input = in.toCharArray();\r\n    int len = input.length;\r\n    StringBuilder out = new StringBuilder((int) (len * 1.3));\r\n    for (; i < len; i++) {\r\n        ch = input[i];\r\n        if (ch > '>') {\r\n        } else if (ch == '<') {\r\n            if (i + 3 < len && input[i + 1] == 'b' && input[i + 2] == 'r' && input[i + 3] == '>') {\r\n                i += 3;\r\n                continue;\r\n            }\r\n            if (i > last) {\r\n                out.append(input, last, i - last);\r\n            }\r\n            last = i + 1;\r\n        } else if (ch == '>') {\r\n            last = i + 1;\r\n        }\r\n    }\r\n    if (last == 0) {\r\n        return in;\r\n    }\r\n    if (i > last) {\r\n        out.append(input, last, i - last);\r\n    }\r\n    return out.toString();\r\n}"
}, {
	"Path": "org.jivesoftware.util.XMLProperties.addToList",
	"Comment": "adds the given value to the list of values represented by the property name.the property is created if it did not already exist.",
	"Method": "boolean addToList(String propertyName,String value){\r\n    List<String> properties = getProperties(propertyName, true);\r\n    boolean propertyWasAdded = properties.add(value);\r\n    if (propertyWasAdded) {\r\n        setProperties(propertyName, properties);\r\n    }\r\n    return propertyWasAdded;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.addAllowedRosterGroup",
	"Comment": "adds a new roster group that is allowed to subscribe and retrieve items.the new roster group is not going to be added to the database. instead it is justkept in memory.",
	"Method": "void addAllowedRosterGroup(String groupName){\r\n    rosterGroupsAllowed.add(groupName);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.User.getProperties",
	"Comment": "returns all extended properties of the user. users have an arbitrarynumber of extended properties. the returned collection can be modifiedto add new properties or remove existing ones.",
	"Method": "Map<String, String> getProperties(){\r\n    synchronized (this) {\r\n        if (properties == null) {\r\n            try {\r\n                properties = UserManager.getUserPropertyProvider().loadProperties(username);\r\n            } catch (UserNotFoundException e) {\r\n                Log.error(\"Unable to retrieve properties for user \" + username, e);\r\n            }\r\n        }\r\n    }\r\n    return new PropertiesMap();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.verifyHome",
	"Comment": "verifies that the given home guess is a real openfire home directory.we do the verification by checking for the openfire config file inthe config dir of jivehome.",
	"Method": "File verifyHome(String homeGuess,String jiveConfigName){\r\n    File openfireHome = new File(homeGuess);\r\n    File configFile = new File(openfireHome, jiveConfigName);\r\n    if (!configFile.exists()) {\r\n        throw new FileNotFoundException();\r\n    } else {\r\n        try {\r\n            return new File(openfireHome.getCanonicalPath());\r\n        } catch (Exception ex) {\r\n            throw new FileNotFoundException();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mitre.oauth2.model.OAuth2AccessTokenEntity.setIdToken",
	"Comment": "add the id token to the additionalinformation map for a token response.",
	"Method": "void setIdToken(JWT idToken){\r\n    if (idToken != null) {\r\n        additionalInformation.put(ID_TOKEN_FIELD_NAME, idToken.serialize());\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.ConcurrentGroupList.includes",
	"Comment": "returns true if the list contains the given jid. if the jidis not found in the list, search the list for groups and lookfor the jid in each of the corresponding groups.",
	"Method": "boolean includes(Object value){\r\n    boolean found = false;\r\n    if (contains(value)) {\r\n        found = true;\r\n    } else if (value instanceof JID) {\r\n        JID target = (JID) value;\r\n        Iterator<Group> iterator = getGroups().iterator();\r\n        while (!found && iterator.hasNext()) {\r\n            found = iterator.next().isUser(target);\r\n        }\r\n    }\r\n    return found;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalSession.incrementClientPacketCount",
	"Comment": "increments the number of packets sent from the client to the server.",
	"Method": "void incrementClientPacketCount(){\r\n    clientPacketCount.incrementAndGet();\r\n    lastActiveDate = System.currentTimeMillis();\r\n    streamManager.incrementServerProcessedStanzas();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.TLSWrapper.doTasks",
	"Comment": "do all the outstanding handshake tasks in the current thread.",
	"Method": "SSLEngineResult.HandshakeStatus doTasks(){\r\n    Runnable runnable;\r\n    while ((runnable = tlsEngine.getDelegatedTask()) != null) {\r\n        runnable.run();\r\n    }\r\n    return tlsEngine.getHandshakeStatus();\r\n}"
}, {
	"Path": "org.jivesoftware.util.ElementUtil.getProperty",
	"Comment": "returns the value of the specified property. a null answer does not necessarily meanthat the property does not exist.",
	"Method": "String getProperty(Element element,String name){\r\n    String value = null;\r\n    String[] propName = parsePropertyName(name);\r\n    String lastName = propName[propName.length - 1];\r\n    String attName = null;\r\n    int attributeIndex = lastName.indexOf(':');\r\n    if (attributeIndex >= 0) {\r\n        propName[propName.length - 1] = lastName.substring(0, attributeIndex);\r\n        attName = lastName.substring(attributeIndex + 1);\r\n    }\r\n    int i = propName[0].equals(element.getName()) ? 1 : 0;\r\n    for (; i < propName.length; i++) {\r\n        element = element.element(propName[i]);\r\n        if (element == null) {\r\n            break;\r\n        }\r\n    }\r\n    if (element != null) {\r\n        if (attName == null) {\r\n            value = element.getTextTrim();\r\n        } else {\r\n            value = element.attributeValue(attName);\r\n        }\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.addOutcast",
	"Comment": "sets that the specified entity is an outcast of the node. outcast entities are notable to publish or subscribe to the node. existing subscriptions will be deleted.",
	"Method": "NodeAffiliate addOutcast(JID jid){\r\n    NodeAffiliate nodeAffiliate = addAffiliation(jid, NodeAffiliate.Affiliation.outcast);\r\n    removeSubscriptions(jid);\r\n    return nodeAffiliate;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginMetadataHelper.getMinJavaVersion",
	"Comment": "returns the minimum java specification version this plugin needs to run. the value is retrieved from theplugin.xml file of the plugin. if the value could not be found, null will be returned.",
	"Method": "JavaSpecVersion getMinJavaVersion(Plugin plugin,JavaSpecVersion getMinJavaVersion,Path pluginDir){\r\n    final String value = getElementValue(pluginDir, \"/plugin/minJavaVersion\");\r\n    if (value == null || value.trim().isEmpty()) {\r\n        return null;\r\n    }\r\n    return new JavaSpecVersion(value);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.HistoryRequest.isConfigured",
	"Comment": "returns true if the history has been configured with some values.",
	"Method": "boolean isConfigured(){\r\n    return maxChars > -1 || maxStanzas > -1 || seconds > -1 || since != null;\r\n}"
}, {
	"Path": "org.jivesoftware.util.Base64.decodeToObject",
	"Comment": "attempts to decode base64 data and deserialize a javaobject within. returns null if there was an error.",
	"Method": "Object decodeToObject(String encodedObject){\r\n    byte[] objBytes = decode(encodedObject);\r\n    java.io.ByteArrayInputStream bais = null;\r\n    java.io.ObjectInputStream ois = null;\r\n    Object obj = null;\r\n    try {\r\n        bais = new java.io.ByteArrayInputStream(objBytes);\r\n        ois = new java.io.ObjectInputStream(bais);\r\n        obj = ois.readObject();\r\n    } catch (java.io.IOException e) {\r\n        e.printStackTrace();\r\n        obj = null;\r\n    } catch (java.lang.ClassNotFoundException e) {\r\n        e.printStackTrace();\r\n        obj = null;\r\n    } finally {\r\n        try {\r\n            bais.close();\r\n        } catch (Exception e) {\r\n        }\r\n        try {\r\n            ois.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.XMLSocketWriter.flush",
	"Comment": "flushes the underlying writer making sure that if the connection is dead then the threadthat is flushing does not end up in an endless wait.",
	"Method": "void flush(){\r\n    connection.writeStarted();\r\n    try {\r\n        super.flush();\r\n    } finally {\r\n        connection.writeFinished();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.addPresenceSubscriptions",
	"Comment": "unsubscribe from affiliates presences if node is only sending notifications toonly users or only unsubscribe from those subscribers that configured theirsubscription to send notifications based on their presence show value.",
	"Method": "void addPresenceSubscriptions(){\r\n    for (NodeAffiliate affiliate : affiliates) {\r\n        if (affiliate.getAffiliation() != NodeAffiliate.Affiliation.outcast && (isPresenceBasedDelivery() || (!affiliate.getSubscriptions().isEmpty()))) {\r\n            service.presenceSubscriptionRequired(this, affiliate.getJID());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginManager.addPluginListener",
	"Comment": "registers a pluginlistener, which will now start receiving events regarding plugin creation and destruction.when the listener was already registered, this method will have no effect.",
	"Method": "void addPluginListener(PluginListener listener){\r\n    pluginListeners.add(listener);\r\n}"
}, {
	"Path": "org.jivesoftware.util.LinkedList.addFirst",
	"Comment": "adds an object to the beginning of the list by automatically creating aa new node and adding it to the beginning of the list.",
	"Method": "LinkedListNode<E> addFirst(LinkedListNode<E> node,LinkedListNode<E> addFirst,E object){\r\n    return new LinkedListNode(object, head.next, head);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.privacy.PrivacyListManager.getDefaultPrivacyList",
	"Comment": "returns the default privacy list of the specified user or null ifnone was found.",
	"Method": "PrivacyList getDefaultPrivacyList(String username){\r\n    String cacheKey = getDefaultCacheKey(username);\r\n    PrivacyList list = listsCache.get(cacheKey);\r\n    if (list == null) {\r\n        synchronized ((username + MUTEX_SUFFIX).intern()) {\r\n            list = listsCache.get(cacheKey);\r\n            if (list == null) {\r\n                list = provider.loadDefaultPrivacyList(username);\r\n                if (list != null) {\r\n                    listsCache.put(cacheKey, list);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.component.ExternalComponentManager.deleteConfiguration",
	"Comment": "removes any existing defined permission and configuration for the specifiedexternal component.",
	"Method": "void deleteConfiguration(String subdomain){\r\n    for (ExternalComponentManagerListener listener : listeners) {\r\n        listener.componentConfigurationDeleted(subdomain);\r\n    }\r\n    deleteConfigurationFromDB(getConfiguration(subdomain, false));\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2AuthorizationCodeService.createAuthorizationCode",
	"Comment": "generate a random authorization code and create an authorizationcodeentity,\twhich will be stored in the repository.",
	"Method": "String createAuthorizationCode(OAuth2Authentication authentication){\r\n    String code = generator.generate();\r\n    AuthenticationHolderEntity authHolder = new AuthenticationHolderEntity();\r\n    authHolder.setAuthentication(authentication);\r\n    authHolder = authenticationHolderRepository.save(authHolder);\r\n    Date expiration = new Date(System.currentTimeMillis() + (getAuthCodeExpirationSeconds() * 1000L));\r\n    AuthorizationCodeEntity entity = new AuthorizationCodeEntity(code, authHolder, expiration);\r\n    repository.save(entity);\r\n    return code;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.changeParent",
	"Comment": "changes the parent node of this node. the node id of the node will not be modifiedbased on the new parent so pubsub implementations where node id has a semanticmeaning will end up affecting the meaning of the node hierarchy and possibly messingup the meaning of the hierarchy.no notifications are sent due to the new parent adoption process.",
	"Method": "void changeParent(CollectionNode newParent){\r\n    if (parent == newParent) {\r\n        return;\r\n    }\r\n    if (parent != null) {\r\n        parent.removeChildNode(this);\r\n    }\r\n    parent = newParent;\r\n    if (parent != null) {\r\n        parent.addChildNode(this);\r\n    }\r\n    if (savedToDB) {\r\n        PubSubPersistenceManager.updateNode(this);\r\n    }\r\n}"
}, {
	"Path": "org.mitre.jwt.signer.service.impl.SymmetricKeyJWTValidatorCacheService.getSymmetricValidtor",
	"Comment": "create a symmetric signing and validation service for the given client",
	"Method": "JWTSigningAndValidationService getSymmetricValidtor(ClientDetailsEntity client){\r\n    if (client == null) {\r\n        logger.error(\"Couldn't create symmetric validator for null client\");\r\n        return null;\r\n    }\r\n    if (Strings.isNullOrEmpty(client.getClientSecret())) {\r\n        logger.error(\"Couldn't create symmetric validator for client \" + client.getClientId() + \" without a client secret\");\r\n        return null;\r\n    }\r\n    try {\r\n        return validators.get(client.getClientSecret());\r\n    } catch (UncheckedExecutionException ue) {\r\n        logger.error(\"Problem loading client validator\", ue);\r\n        return null;\r\n    } catch (ExecutionException e) {\r\n        logger.error(\"Problem loading client validator\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.setMaxPollingInterval",
	"Comment": "sets the max interval within which a client can send polling requests. if more than onerequest occurs in the interval the session will be terminated.",
	"Method": "void setMaxPollingInterval(int maxPollingInterval){\r\n    this.maxPollingInterval = maxPollingInterval;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalSession.getNumServerPackets",
	"Comment": "obtain the number of packets sent from the server to the client.",
	"Method": "long getNumServerPackets(){\r\n    return serverPacketCount.get();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.isActive",
	"Comment": "returns true if the subscription is active. a subscription is considered active if ithas not expired, it has been approved and configured.",
	"Method": "boolean isActive(){\r\n    if (state != State.subscribed) {\r\n        return false;\r\n    }\r\n    if (expire != null && new Date().after(expire)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.LocalMUCRoom.shouldBroadcastPresence",
	"Comment": "checks the role of the sender and returns true if the given presence should be broadcasted",
	"Method": "boolean shouldBroadcastPresence(Presence presence){\r\n    if (presence == null) {\r\n        return false;\r\n    }\r\n    if (hasToCheckRoleToBroadcastPresence()) {\r\n        Element frag = presence.getChildElement(\"x\", \"http://jabber.org/protocol/muc#user\");\r\n        if (!canBroadcastPresence(frag.element(\"item\").attributeValue(\"role\"))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.OfflineMessage.getCreationDate",
	"Comment": "returns the date when the offline message was stored in the database.",
	"Method": "Date getCreationDate(){\r\n    return creationDate;\r\n}"
}, {
	"Path": "org.jivesoftware.util.StringUtils.encodeHex",
	"Comment": "turns an array of bytes into a string representing each byte as anunsigned hex number.",
	"Method": "String encodeHex(byte[] bytes){\r\n    return DatatypeConverter.printHexBinary(bytes).toLowerCase();\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.formatDateTime",
	"Comment": "formats a date object to return a date and time using the global locale.",
	"Method": "String formatDateTime(Date date){\r\n    if (dateTimeFormat == null) {\r\n        if (properties != null) {\r\n            dateTimeFormat = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM, getLocale());\r\n            dateTimeFormat.setTimeZone(getTimeZone());\r\n        } else {\r\n            DateFormat instance = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM, getLocale());\r\n            instance.setTimeZone(getTimeZone());\r\n            return instance.format(date);\r\n        }\r\n    }\r\n    return dateTimeFormat.format(date);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.rest.controller.UserServiceLegacyController.getInstance",
	"Comment": "gets the single instance of userservicelegacycontroller.",
	"Method": "UserServiceLegacyController getInstance(){\r\n    return INSTANCE;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalIncomingServerSession.validateSubsequentDomain",
	"Comment": "returns true if the request of a new domain was valid. sessions may receive subsequentdomain validation request. if the validation of the new domain fails then the session andthe underlying tcp connection will be closed.for optimization reasons, the same session may be servicing several domains of aremote server.",
	"Method": "boolean validateSubsequentDomain(Element dbResult){\r\n    ServerDialback method = new ServerDialback(getConnection(), getServerName());\r\n    if (method.validateRemoteDomain(dbResult, getStreamID())) {\r\n        addValidatedDomain(dbResult.attributeValue(\"from\"));\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.util.XMLProperties.getAllPropertyNames",
	"Comment": "returns a list of names for all properties found in the xml file.",
	"Method": "List<String> getAllPropertyNames(){\r\n    List<String> result = new ArrayList();\r\n    for (String propertyName : getChildPropertyNamesFor(document.getRootElement(), \"\")) {\r\n        if (getProperty(propertyName) != null) {\r\n            result.add(propertyName);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.TLSWrapper.close",
	"Comment": "signals that no more outbound application data will be sent on this tlshandler.",
	"Method": "void close(){\r\n    tlsEngine.closeOutbound();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.cluster.ClusterManager.isClusteringStarting",
	"Comment": "returns true is clustering is currently being started. once the clusteris started or failed to be started this value will be false.",
	"Method": "boolean isClusteringStarting(){\r\n    return CacheFactory.isClusteringStarting();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.ConversationLogEntry.getNickname",
	"Comment": "returns the nickname that the user had at the moment that the message was sent to the room.",
	"Method": "String getNickname(){\r\n    return nickname;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterManager.parseGroupNames",
	"Comment": "returns a collection of groups obtained by parsing a comma delimited string with the nameof groups.",
	"Method": "Collection<String> parseGroupNames(String groupNames){\r\n    Collection<String> answer = new HashSet();\r\n    if (groupNames != null) {\r\n        StringTokenizer tokenizer = new StringTokenizer(groupNames, \",\");\r\n        while (tokenizer.hasMoreTokens()) {\r\n            answer.add(tokenizer.nextToken());\r\n        }\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.unregisterIncomingServerSession",
	"Comment": "unregisters the specified remote server session originiated by the specified remote server.",
	"Method": "void unregisterIncomingServerSession(String hostname,IncomingServerSession session){\r\n    StreamID streamID = session.getStreamID();\r\n    localSessionManager.removeIncomingServerSessions(streamID);\r\n    incomingServerSessionsCache.remove(streamID);\r\n    Lock lock = CacheFactory.getLock(hostname, hostnameSessionsCache);\r\n    try {\r\n        lock.lock();\r\n        ArrayList<StreamID> streamIDs = hostnameSessionsCache.get(hostname);\r\n        if (streamIDs != null) {\r\n            streamIDs.remove(streamID);\r\n            if (streamIDs.isEmpty()) {\r\n                hostnameSessionsCache.remove(hostname);\r\n            } else {\r\n                hostnameSessionsCache.put(hostname, streamIDs);\r\n            }\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n    lock = CacheFactory.getLock(streamID, validatedDomainsCache);\r\n    try {\r\n        lock.lock();\r\n        HashSet<String> validatedDomains = validatedDomainsCache.get(streamID);\r\n        if (validatedDomains == null) {\r\n            validatedDomains = new HashSet();\r\n        }\r\n        validatedDomains.remove(hostname);\r\n        if (!validatedDomains.isEmpty()) {\r\n            validatedDomainsCache.put(streamID, validatedDomains);\r\n        } else {\r\n            validatedDomainsCache.remove(streamID);\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getRosterManager",
	"Comment": "returns the rostermanager registered with this server. therostermanager was registered with the server as a module while starting upthe server.",
	"Method": "RosterManager getRosterManager(){\r\n    return (RosterManager) modules.get(RosterManager.class);\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.setLocale",
	"Comment": "sets the global locale used by jive. a locale specifies languageand country codes, and is used for formatting dates and numbers.the default locale is locale.us.",
	"Method": "void setLocale(Locale newLocale){\r\n    locale = newLocale;\r\n    setXMLProperty(\"locale\", locale.toString());\r\n    timeFormat = null;\r\n    dateFormat = null;\r\n    dateTimeFormat = null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PublishedItem.setPayloadXML",
	"Comment": "sets the payload included when publishing the item. a published item may or may nothave a payload. transient nodes that are configured to not broadcast payloads may allowpublished items to have no payload.",
	"Method": "void setPayloadXML(String payloadXML){\r\n    this.payloadXML = payloadXML;\r\n    this.payload = null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MultiUserChatServiceImpl.removeExtraIdentity",
	"Comment": "removes an extra disco identity from the list of identities returned for the conference service.",
	"Method": "void removeExtraIdentity(String name){\r\n    final Iterator<Element> iter = extraDiscoIdentities.iterator();\r\n    while (iter.hasNext()) {\r\n        Element elem = iter.next();\r\n        if (name.equals(elem.attribute(\"name\").getStringValue())) {\r\n            iter.remove();\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.MUCEventDelegate.loadConfig",
	"Comment": "loads a delegate provided room configuration for the room specified.",
	"Method": "boolean loadConfig(MUCRoom room){\r\n    Map<String, String> roomConfig = getRoomConfig(room.getName());\r\n    if (roomConfig != null) {\r\n        room.setNaturalLanguageName(roomConfig.get(\"muc#roomconfig_roomname\"));\r\n        room.setDescription(roomConfig.get(\"muc#roomconfig_roomdesc\"));\r\n        room.setCanOccupantsChangeSubject(\"1\".equals(roomConfig.get(\"muc#roomconfig_changesubject\")));\r\n        room.setMaxUsers(Integer.parseInt(roomConfig.get(\"muc#roomconfig_maxusers\")));\r\n        room.setPublicRoom(\"1\".equals(roomConfig.get(\"muc#roomconfig_publicroom\")));\r\n        room.setCanOccupantsInvite(\"1\".equals(roomConfig.get(\"muc#roomconfig_allowinvites\")));\r\n        room.setCanAnyoneDiscoverJID(\"anyone\".equals(roomConfig.get(\"muc#roomconfig_whois\")));\r\n        room.setCanSendPrivateMessage(roomConfig.get(\"muc#roomconfig_allowpm\"));\r\n        room.setChangeNickname(\"1\".equals(roomConfig.get(\"x-muc#roomconfig_canchangenick\")));\r\n        room.setRegistrationEnabled(\"1\".equals(roomConfig.get(\"x-muc#roomconfig_registration\")));\r\n        room.setPersistent(\"1\".equals(roomConfig.get(\"muc#roomconfig_persistentroom\")));\r\n        final String property = roomConfig.get(\"muc#roomconfig_roomowners\");\r\n        if (property != null) {\r\n            String[] jids = property.split(\",\");\r\n            for (String jid : jids) {\r\n                if (jid != null && jid.trim().length() != 0) {\r\n                    room.addFirstOwner(new JID(jid.trim().toLowerCase()).asBareJID());\r\n                }\r\n            }\r\n        }\r\n        try {\r\n            room.unlock(room.getRole());\r\n        } catch (ForbiddenException e) {\r\n            return false;\r\n        }\r\n    }\r\n    return roomConfig != null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.LeafNode.isItemRequired",
	"Comment": "returns true if an item element is required to be included when publishing anitem to this node. when an item is included then the item will have an item idthat will be included when sending items to node subscribers.leaf nodes that are transient and do not deliver payloads with event notificationsdo not require an item element. if a user tries to publish an item to a nodethat does not require items then an error will be returned.",
	"Method": "boolean isItemRequired(){\r\n    return isPersistPublishedItems() || isPayloadDelivered();\r\n}"
}, {
	"Path": "org.jivesoftware.admin.LdapGroupTester.getGroups",
	"Comment": "returns fist n groups found in ldap. the returned groups are only able to return their name,description and count of members. count of members is considering all values that were foundin the member field.",
	"Method": "Collection<Group> getGroups(int maxGroups){\r\n    Collection<Group> groups = new ArrayList();\r\n    LdapContext ctx = null;\r\n    try {\r\n        ctx = manager.getContext();\r\n        Control[] searchControl = new Control[] { new SortControl(new String[] { manager.getGroupNameField() }, Control.NONCRITICAL) };\r\n        ctx.setRequestControls(searchControl);\r\n        SearchControls searchControls = new SearchControls();\r\n        if (manager.isSubTreeSearch()) {\r\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\r\n        } else {\r\n            searchControls.setSearchScope(SearchControls.ONELEVEL_SCOPE);\r\n        }\r\n        String[] standardAttributes = new String[3];\r\n        standardAttributes[0] = manager.getGroupNameField();\r\n        standardAttributes[1] = manager.getGroupDescriptionField();\r\n        standardAttributes[2] = manager.getGroupMemberField();\r\n        searchControls.setReturningAttributes(standardAttributes);\r\n        searchControls.setCountLimit(maxGroups);\r\n        String filter = MessageFormat.format(manager.getGroupSearchFilter(), \"*\");\r\n        NamingEnumeration answer = ctx.search(\"\", filter, searchControls);\r\n        while (answer.hasMoreElements()) {\r\n            Attributes attributes = ((SearchResult) answer.next()).getAttributes();\r\n            String groupName = (String) attributes.get(manager.getGroupNameField()).get();\r\n            String description = \"\";\r\n            int elements = 0;\r\n            try {\r\n                description = ((String) attributes.get(manager.getGroupDescriptionField()).get());\r\n            } catch (NullPointerException e) {\r\n            } catch (Exception e) {\r\n                Log.error(\"Error retrieving group description\", e);\r\n            }\r\n            Attribute memberField = attributes.get(manager.getGroupMemberField());\r\n            if (memberField != null) {\r\n                NamingEnumeration ne = memberField.getAll();\r\n                while (ne.hasMore()) {\r\n                    ne.next();\r\n                    elements = elements + 1;\r\n                }\r\n            }\r\n            groups.add(new Group(groupName, description, elements));\r\n        }\r\n        answer.close();\r\n    } catch (Exception e) {\r\n        Log.error(e.getMessage(), e);\r\n    } finally {\r\n        try {\r\n            if (ctx != null) {\r\n                ctx.setRequestControls(null);\r\n                ctx.close();\r\n            }\r\n        } catch (Exception ignored) {\r\n        }\r\n    }\r\n    return groups;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheFactory.isClusteringStarted",
	"Comment": "returns true if this node is currently a member of a cluster. the last step of applicationinitialization is to join a cluster, so this method returns false during most of application startup.",
	"Method": "boolean isClusteringStarted(){\r\n    return clusteringStarted;\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.setupPropertyEncryptionAlgorithm",
	"Comment": "this method is called early during the setup process toset the algorithm for encrypting property values",
	"Method": "void setupPropertyEncryptionAlgorithm(String alg){\r\n    String oldAlg = securityProperties.getProperty(ENCRYPTION_ALGORITHM);\r\n    String oldKey = securityProperties.getProperty(ENCRYPTION_KEY_CURRENT);\r\n    if (StringUtils.isNotEmpty(oldAlg) && !oldAlg.equals(alg) && StringUtils.isNotEmpty(oldKey)) {\r\n        updateEncryptionProperties(oldAlg, oldKey, alg, oldAlg);\r\n    }\r\n    if (ENCRYPTION_ALGORITHM_AES.equalsIgnoreCase(alg)) {\r\n        securityProperties.setProperty(ENCRYPTION_ALGORITHM, ENCRYPTION_ALGORITHM_AES);\r\n    } else {\r\n        securityProperties.setProperty(ENCRYPTION_ALGORITHM, ENCRYPTION_ALGORITHM_BLOWFISH);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.database.SequenceManager.setBlockSize",
	"Comment": "used to set the blocksize of a given sequencemanager. if no sequencemanager hasbeen registered for the type, the type is verified as valid and then a newsequence manager is created.",
	"Method": "void setBlockSize(int type,int blockSize){\r\n    if (managers.containsKey(type)) {\r\n        managers.get(type).blockSize = blockSize;\r\n    } else {\r\n        new SequenceManager(type, blockSize);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeAffiliate.sendPublishedNotifications",
	"Comment": "sends an event notification for the published items to the affiliate. the eventnotification may contain zero, one or many published items based on the itemsincluded in the original publication. if the affiliate has many subscriptions andmany items were published then the affiliate will get a notification for each setof items that affected the same subscriptions.",
	"Method": "void sendPublishedNotifications(Message notification,Element event,LeafNode leafNode,List<PublishedItem> publishedItems){\r\n    if (!publishedItems.isEmpty()) {\r\n        Map<List<NodeSubscription>, List<PublishedItem>> itemsBySubs = getItemsBySubscriptions(leafNode, publishedItems);\r\n        for (List<NodeSubscription> nodeSubscriptions : itemsBySubs.keySet()) {\r\n            Element items = event.addElement(\"items\");\r\n            items.addAttribute(\"node\", getNode().getNodeID());\r\n            for (PublishedItem publishedItem : itemsBySubs.get(nodeSubscriptions)) {\r\n                if (getNode().getNodeID().contains(\"@\")) {\r\n                    items.addAttribute(\"node\", publishedItem.getNodeID());\r\n                }\r\n                Element item = items.addElement(\"item\");\r\n                if (leafNode.isItemRequired()) {\r\n                    item.addAttribute(\"id\", publishedItem.getID());\r\n                }\r\n                if (leafNode.isPayloadDelivered()) {\r\n                    item.add(publishedItem.getPayload().createCopy());\r\n                }\r\n                if (leafNode != getNode()) {\r\n                    item.addAttribute(\"node\", leafNode.getNodeID());\r\n                }\r\n            }\r\n            sendEventNotification(notification, nodeSubscriptions);\r\n            event.remove(items);\r\n        }\r\n    } else {\r\n        List<NodeSubscription> affectedSubscriptions = new ArrayList();\r\n        for (NodeSubscription subscription : getSubscriptions()) {\r\n            if (subscription.canSendPublicationEvent(leafNode, null)) {\r\n                affectedSubscriptions.add(subscription);\r\n            }\r\n        }\r\n        Element items = event.addElement(\"items\");\r\n        items.addAttribute(\"node\", leafNode.getNodeID());\r\n        sendEventNotification(notification, affectedSubscriptions);\r\n        event.remove(items);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.XMLWriter.writeElementContent",
	"Comment": "outputs the content of the given element. if whitespace trimming isenabled then all adjacent text nodes are appended together beforethe whitespace trimming occurs to avoid problems with multipletext nodes being created due to text content that spans parser buffersin a sax parser.",
	"Method": "void writeElementContent(Element element){\r\n    boolean trim = format.isTrimText();\r\n    boolean oldPreserve = preserve;\r\n    if (trim) {\r\n        preserve = isElementSpacePreserved(element);\r\n        trim = !preserve;\r\n    }\r\n    if (trim) {\r\n        Text lastTextNode = null;\r\n        StringBuilder buffer = null;\r\n        boolean textOnly = true;\r\n        for (int i = 0, size = element.nodeCount(); i < size; i++) {\r\n            Node node = element.node(i);\r\n            if (node instanceof Text) {\r\n                if (lastTextNode == null) {\r\n                    lastTextNode = (Text) node;\r\n                } else {\r\n                    if (buffer == null) {\r\n                        buffer = new StringBuilder(lastTextNode.getText());\r\n                    }\r\n                    buffer.append(node.getText());\r\n                }\r\n            } else {\r\n                if (!textOnly && format.isPadText()) {\r\n                    writer.write(PAD_TEXT);\r\n                }\r\n                textOnly = false;\r\n                if (lastTextNode != null) {\r\n                    if (buffer != null) {\r\n                        writeString(buffer.toString());\r\n                        buffer = null;\r\n                    } else {\r\n                        writeString(lastTextNode.getText());\r\n                    }\r\n                    lastTextNode = null;\r\n                    if (format.isPadText()) {\r\n                        writer.write(PAD_TEXT);\r\n                    }\r\n                }\r\n                writeNode(node);\r\n            }\r\n        }\r\n        if (lastTextNode != null) {\r\n            if (!textOnly && format.isPadText()) {\r\n                writer.write(PAD_TEXT);\r\n            }\r\n            if (buffer != null) {\r\n                writeString(buffer.toString());\r\n                buffer = null;\r\n            } else {\r\n                writeString(lastTextNode.getText());\r\n            }\r\n            lastTextNode = null;\r\n        }\r\n    } else {\r\n        Node lastTextNode = null;\r\n        for (int i = 0, size = element.nodeCount(); i < size; i++) {\r\n            Node node = element.node(i);\r\n            if (node instanceof Text) {\r\n                writeNode(node);\r\n                lastTextNode = node;\r\n            } else {\r\n                if ((lastTextNode != null) && format.isPadText()) {\r\n                    writer.write(PAD_TEXT);\r\n                }\r\n                writeNode(node);\r\n                if ((lastTextNode != null) && format.isPadText()) {\r\n                    writer.write(PAD_TEXT);\r\n                }\r\n                lastTextNode = null;\r\n            }\r\n        }\r\n    }\r\n    preserve = oldPreserve;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sip.sipaccount.SipComponent.sessionDestroyed",
	"Comment": "sets the user sip presence to unregistered if his jabber account is disconnected.",
	"Method": "void sessionDestroyed(Session session){\r\n    String username = session.getAddress().toBareJID().split(\"@\")[0];\r\n    SipAccount sipAccount = SipAccountDAO.getAccountByUser(username);\r\n    if (sipAccount != null) {\r\n        try {\r\n            sipAccount.setStatus(SipRegisterStatus.Unregistered);\r\n            SipAccountDAO.update(sipAccount);\r\n        } catch (SQLException e) {\r\n            Log.error(e.getMessage(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sip.tester.security.CredentialsCache.remove",
	"Comment": "returns the credentials corresponding to the specified realm or null ifnone could be found and removes the entry from the cache.",
	"Method": "CredentialsCacheEntry remove(String realm){\r\n    return (CredentialsCacheEntry) this.authenticatedRealms.remove(realm);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.setGroupSearchFilter",
	"Comment": "sets the search filter appended to the default filter when searching for groups.",
	"Method": "void setGroupSearchFilter(String groupSearchFilter){\r\n    this.groupSearchFilter = groupSearchFilter;\r\n    properties.put(\"ldap.groupSearchFilter\", groupSearchFilter);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SocketReadingMode.compressClient",
	"Comment": "start using compression but first check if the connection can and should use compression.the connection will be closed if the requested method is not supported, if the connectionis already using compression or if client requested to use compression but this featureis disabled.",
	"Method": "boolean compressClient(Element doc){\r\n    String error = null;\r\n    if (socketReader.connection.getCompressionPolicy() == Connection.CompressionPolicy.disabled) {\r\n        error = \"<failure xmlns='http://jabber.org/protocol/compress'><setup-failed/><\/failure>\";\r\n        Log.warn(\"Client requested compression while compression is disabled. Closing \" + \"connection : \" + socketReader.connection);\r\n    } else if (socketReader.connection.isCompressed()) {\r\n        error = \"<failure xmlns='http://jabber.org/protocol/compress'><setup-failed/><\/failure>\";\r\n        Log.warn(\"Client requested compression and connection is already compressed. Closing \" + \"connection : \" + socketReader.connection);\r\n    } else {\r\n        String method = doc.elementText(\"method\");\r\n        if (!\"zlib\".equals(method)) {\r\n            error = \"<failure xmlns='http://jabber.org/protocol/compress'><unsupported-method/><\/failure>\";\r\n            Log.warn(\"Requested compression method is not supported: \" + method + \". Closing connection : \" + socketReader.connection);\r\n        }\r\n    }\r\n    if (error != null) {\r\n        socketReader.connection.deliverRawText(error);\r\n        return false;\r\n    } else {\r\n        socketReader.connection.addCompression();\r\n        socketReader.connection.deliverRawText(\"<compressed xmlns='http://jabber.org/protocol/compress'/>\");\r\n        socketReader.connection.startCompression();\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.writeExternalizableCollection",
	"Comment": "writes a collection of externalizable objects. the collection passed as a parametermust be a collection and not a null value.",
	"Method": "void writeExternalizableCollection(DataOutput out,Collection<? extends Externalizable> value){\r\n    strategy.writeExternalizableCollection(out, value);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.cluster.OccupantAddedEvent.isSendPresence",
	"Comment": "returns true if the room should broadcast presence of the new occupant to occupantshosted by this cluster node.",
	"Method": "boolean isSendPresence(){\r\n    return sendPresence;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sip.calllog.CallLogDAO.getLogCount",
	"Comment": "return the number of store calllogs for the given sqlcondition",
	"Method": "int getLogCount(int getLogCount,CallFilter filter){\r\n    int count = 0;\r\n    String sql = \"SELECT count(*) FROM ofSipPhoneLog\";\r\n    sql = filter != null && !filter.getSQL().equals(\"\") ? sql + \" WHERE \" + filter.getSQL() : sql;\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(sql);\r\n        int i = 1;\r\n        for (String value : filter.getValues()) {\r\n            pstmt.setString(i++, value);\r\n        }\r\n        ResultSet rs = pstmt.executeQuery();\r\n        if (rs.next()) {\r\n            count = rs.getInt(1);\r\n        }\r\n        rs.close();\r\n    } catch (SQLException e) {\r\n        Log.error(e.getMessage(), e);\r\n    } finally {\r\n        try {\r\n            if (pstmt != null) {\r\n                pstmt.close();\r\n            }\r\n        } catch (Exception e) {\r\n            Log.error(e.getMessage(), e);\r\n        }\r\n        try {\r\n            if (con != null) {\r\n                con.close();\r\n            }\r\n        } catch (Exception e) {\r\n            Log.error(e.getMessage(), e);\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.component.ExternalComponentManager.getConfiguration",
	"Comment": "returns the configuration for an external component. a query for the exact requestedsubdomain will be made. if nothing was found and using wildcards is requested thenanother query will be made but this time using wildcards.",
	"Method": "ExternalComponentConfiguration getConfiguration(String subdomain,boolean useWildcard){\r\n    ExternalComponentConfiguration configuration = null;\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(LOAD_CONFIGURATION);\r\n        pstmt.setString(1, subdomain);\r\n        rs = pstmt.executeQuery();\r\n        while (rs.next()) {\r\n            configuration = new ExternalComponentConfiguration(subdomain, false, Permission.valueOf(rs.getString(2)), rs.getString(1));\r\n        }\r\n    } catch (SQLException sqle) {\r\n        Log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    if (configuration == null && useWildcard) {\r\n        try {\r\n            con = DbConnectionManager.getConnection();\r\n            pstmt = con.prepareStatement(LOAD_WILDCARD_CONFIGURATION);\r\n            pstmt.setString(1, subdomain);\r\n            rs = pstmt.executeQuery();\r\n            while (rs.next()) {\r\n                configuration = new ExternalComponentConfiguration(subdomain, true, Permission.valueOf(rs.getString(2)), rs.getString(1));\r\n            }\r\n        } catch (SQLException sqle) {\r\n            Log.error(sqle.getMessage(), sqle);\r\n        } finally {\r\n            DbConnectionManager.closeConnection(rs, pstmt, con);\r\n        }\r\n    }\r\n    return configuration;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.setAssociationPolicy",
	"Comment": "sets the policy that defines who may associate leaf nodes with a collection.",
	"Method": "void setAssociationPolicy(CollectionNode.LeafNodeAssociationPolicy associationPolicy){\r\n    this.associationPolicy = associationPolicy;\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.migrateProperty",
	"Comment": "convenience routine to migrate an xml property into the databasestorage method.will check for the xml property being null beforemigrating.",
	"Method": "void migrateProperty(String name){\r\n    if (isSetupMode()) {\r\n        return;\r\n    }\r\n    if (openfireProperties == null) {\r\n        loadOpenfireProperties();\r\n    }\r\n    openfireProperties.migrateProperty(name);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.PresencePlugin.getPresence",
	"Comment": "returns the presence of the requested user or null if the user is offline. ifpresences are not public then the user presence will be returned if and only if the senderof the request is subscribed to the user presence.",
	"Method": "Presence getPresence(String sender,String jid){\r\n    if (jid == null) {\r\n        throw new UserNotFoundException(\"Target JID not found in request\");\r\n    }\r\n    JID targetJID = new JID(jid);\r\n    if (targetJID.getDomain() == null || XMPPServer.getInstance().isRemote(targetJID)) {\r\n        throw new UserNotFoundException(\"Domain does not matches local server domain\");\r\n    }\r\n    if (!hostname.equals(targetJID.getDomain())) {\r\n        presenceManager.probePresence(componentJID, targetJID);\r\n        int count = 0;\r\n        Presence presence = probedPresence.get(jid);\r\n        while (presence == null) {\r\n            if (count > 300) {\r\n                throw new UserNotFoundException(\"Request for component presence has timed-out.\");\r\n            }\r\n            try {\r\n                Thread.sleep(100);\r\n            } catch (InterruptedException e) {\r\n            }\r\n            presence = probedPresence.get(jid);\r\n            count++;\r\n        }\r\n        probedPresence.remove(jid);\r\n        return presence;\r\n    }\r\n    if (targetJID.getNode() == null || !UserManager.getInstance().isRegisteredUser(targetJID.getNode())) {\r\n        throw new UserNotFoundException(\"Username is null\");\r\n    }\r\n    if (!isPresencePublic()) {\r\n        if (sender == null) {\r\n            throw new UserNotFoundException(\"Sender is null\");\r\n        } else {\r\n            JID senderJID = new JID(sender);\r\n            if (!senderJID.getNode().equals(targetJID.getNode()) && !presenceManager.canProbePresence(new JID(sender), targetJID.getNode())) {\r\n                throw new UserNotFoundException(\"Sender is not allowed to probe this user\");\r\n            }\r\n        }\r\n    }\r\n    User user = userManager.getUser(targetJID.getNode());\r\n    return presenceManager.getPresence(user);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.setSubscriptionConfigurationRequired",
	"Comment": "sets whether new subscriptions should be configured to be active. inactivesubscriptions will not get event notifications. however, subscribers will benotified when a node is deleted no matter the subscription status.",
	"Method": "void setSubscriptionConfigurationRequired(boolean subscriptionConfigurationRequired){\r\n    this.subscriptionConfigurationRequired = subscriptionConfigurationRequired;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.setMaxPublishedItems",
	"Comment": "sets the maximum number of published items to persist. note that all nodes are goingto persist their published items. the only difference is the number of the last publisheditems to be persisted. even nodes that are configured to not use persitent items are goingto save the last published item.",
	"Method": "void setMaxPublishedItems(int maxPublishedItems){\r\n    this.maxPublishedItems = maxPublishedItems;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.mediaproxy.MediaProxyService.setKeepAliveDelay",
	"Comment": "set the keep alive delay of the mediaproxy agents.when an agent stay more then this delay, the agent is destroyed.",
	"Method": "void setKeepAliveDelay(long delay){\r\n    mediaProxy.setIdleTime(delay);\r\n}"
}, {
	"Path": "org.jivesoftware.util.BeanUtils.decode",
	"Comment": "decodes a string into an object of the specified type. if the objecttype is not supported, null will be returned.",
	"Method": "Object decode(Class type,String value){\r\n    if (type.getName().equals(\"java.lang.String\")) {\r\n        return value;\r\n    }\r\n    if (type.getName().equals(\"boolean\")) {\r\n        return Boolean.valueOf(value);\r\n    }\r\n    if (type.getName().equals(\"int\")) {\r\n        return Integer.valueOf(value);\r\n    }\r\n    if (type.getName().equals(\"long\")) {\r\n        return Long.valueOf(value);\r\n    }\r\n    if (type.getName().equals(\"float\")) {\r\n        return Float.valueOf(value);\r\n    }\r\n    if (type.getName().equals(\"double\")) {\r\n        return Double.valueOf(value);\r\n    }\r\n    if (type.getName().equals(\"java.util.Date\")) {\r\n        try {\r\n            return dateFormatter.parse(value);\r\n        } catch (Exception ignored) {\r\n        }\r\n    }\r\n    if (type.getName().equals(\"java.awt.Color\")) {\r\n        StringTokenizer tokens = new StringTokenizer(value, \",\");\r\n        int red = Integer.parseInt(tokens.nextToken());\r\n        int green = Integer.parseInt(tokens.nextToken());\r\n        int blue = Integer.parseInt(tokens.nextToken());\r\n        return new Color(red, green, blue);\r\n    }\r\n    if (type.getName().equals(\"java.lang.Class\")) {\r\n        return ClassUtils.forName(value);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.writeStringsMap",
	"Comment": "writes a map of string key and set of strings value pairs. this method does not handle thecase when the map is null.",
	"Method": "void writeStringsMap(DataOutput out,Map<String, Set<String>> map){\r\n    strategy.writeStringsMap(out, map);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.addOwner",
	"Comment": "adds a new affiliation or updates an existing affiliation of the specified entity jidto become a node owner.",
	"Method": "NodeAffiliate addOwner(JID jid){\r\n    NodeAffiliate nodeAffiliate = addAffiliation(jid, NodeAffiliate.Affiliation.owner);\r\n    for (NodeSubscription subscription : getSubscriptions(jid)) {\r\n        if (subscription.isAuthorizationPending()) {\r\n            subscription.approved();\r\n        }\r\n    }\r\n    return nodeAffiliate;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.EncryptionArtifactFactory.getTrustManagers",
	"Comment": "generates keymanager instances suitable for connections that are created based on a particular configuration.",
	"Method": "TrustManager[] getTrustManagers(){\r\n    return new TrustManager[] { new OpenfireX509TrustManager(configuration.getTrustStore().getStore(), configuration.isAcceptSelfSignedCertificates(), configuration.isVerifyCertificateValidity()) };\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MUCPersistenceManager.marshallRolesToBroadcast",
	"Comment": "returns an integer based on the binary representation of the roles to broadcast.",
	"Method": "int marshallRolesToBroadcast(MUCRoom room){\r\n    StringBuilder buffer = new StringBuilder();\r\n    buffer.append((room.canBroadcastPresence(\"moderator\") ? \"1\" : \"0\"));\r\n    buffer.append((room.canBroadcastPresence(\"participant\") ? \"1\" : \"0\"));\r\n    buffer.append((room.canBroadcastPresence(\"visitor\") ? \"1\" : \"0\"));\r\n    return Integer.parseInt(buffer.toString(), 2);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.UpdateManager.getNotInstalledPlugins",
	"Comment": "returns the list of available plugins, sorted alphabetically, to install as reported by igniterealtime.org.currently downloaded plugins will not be included, nor will plugins that require a newer or older server version.",
	"Method": "List<AvailablePlugin> getNotInstalledPlugins(){\r\n    final List<AvailablePlugin> result = new ArrayList(availablePlugins.values());\r\n    final PluginManager pluginManager = XMPPServer.getInstance().getPluginManager();\r\n    final Version currentServerVersion = XMPPServer.getInstance().getServerInfo().getVersion();\r\n    final Iterator<AvailablePlugin> iterator = result.iterator();\r\n    while (iterator.hasNext()) {\r\n        final AvailablePlugin availablePlugin = iterator.next();\r\n        if (pluginManager.isInstalled(availablePlugin.getCanonicalName())) {\r\n            iterator.remove();\r\n            continue;\r\n        }\r\n        if (availablePlugin.getMinServerVersion() != null && availablePlugin.getMinServerVersion().isNewerThan(currentServerVersion)) {\r\n            iterator.remove();\r\n        }\r\n        if (availablePlugin.getPriorToServerVersion() != null && !availablePlugin.getPriorToServerVersion().isNewerThan(currentServerVersion)) {\r\n            iterator.remove();\r\n        }\r\n    }\r\n    result.sort((o1, o2) -> o1.getName().compareToIgnoreCase(o2.getName()));\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.readExternalizableMap",
	"Comment": "reads a map of string key and value pairs. this method will returnnull if the map written to the stream was null.",
	"Method": "int readExternalizableMap(DataInput in,Map<String, ? extends Externalizable> map,ClassLoader loader){\r\n    return strategy.readExternalizableMap(in, map, loader);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.auth.AuthToken.generateUserToken",
	"Comment": "constructs a new authtoken that represents an authenticated user identified bythe provider username.",
	"Method": "AuthToken generateUserToken(String username){\r\n    if (username == null || username.isEmpty()) {\r\n        throw new IllegalArgumentException(\"Argument 'username' cannot be null.\");\r\n    }\r\n    return new AuthToken(username);\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.migratePropertyTree",
	"Comment": "convenience routine to migrate a tree of xml propertis into the databasestorage method.",
	"Method": "void migratePropertyTree(String name){\r\n    if (isSetupMode()) {\r\n        return;\r\n    }\r\n    if (openfireProperties == null) {\r\n        loadOpenfireProperties();\r\n    }\r\n    final String[] children = openfireProperties.getChildrenProperties(name);\r\n    if (children != null) {\r\n        for (final String child : children) {\r\n            migratePropertyTree(name + \".\" + child);\r\n        }\r\n    }\r\n    openfireProperties.migrateProperty(name);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.UpdateManager.isNotificationEnabled",
	"Comment": "returns true if admins should be notified by im when new updates are available.",
	"Method": "boolean isNotificationEnabled(){\r\n    return JiveGlobals.getBooleanProperty(\"update.notify-admins\", true);\r\n}"
}, {
	"Path": "org.mitre.openid.connect.web.UserInfoEndpoint.getInfo",
	"Comment": "get information about the user as specified in the accesstoken included in this request",
	"Method": "String getInfo(String claimsRequestJsonString,String acceptHeader,OAuth2Authentication auth,Model model){\r\n    if (auth == null) {\r\n        logger.error(\"getInfo failed; no principal. Requester is not authorized.\");\r\n        model.addAttribute(HttpCodeView.CODE, HttpStatus.FORBIDDEN);\r\n        return HttpCodeView.VIEWNAME;\r\n    }\r\n    String username = auth.getName();\r\n    UserInfo userInfo = userInfoService.getByUsernameAndClientId(username, auth.getOAuth2Request().getClientId());\r\n    if (userInfo == null) {\r\n        logger.error(\"getInfo failed; user not found: \" + username);\r\n        model.addAttribute(HttpCodeView.CODE, HttpStatus.NOT_FOUND);\r\n        return HttpCodeView.VIEWNAME;\r\n    }\r\n    model.addAttribute(UserInfoView.SCOPE, auth.getOAuth2Request().getScope());\r\n    model.addAttribute(UserInfoView.AUTHORIZED_CLAIMS, auth.getOAuth2Request().getExtensions().get(\"claims\"));\r\n    if (!Strings.isNullOrEmpty(claimsRequestJsonString)) {\r\n        model.addAttribute(UserInfoView.REQUESTED_CLAIMS, claimsRequestJsonString);\r\n    }\r\n    model.addAttribute(UserInfoView.USER_INFO, userInfo);\r\n    ClientDetailsEntity client = clientService.loadClientByClientId(auth.getOAuth2Request().getClientId());\r\n    model.addAttribute(UserInfoJWTView.CLIENT, client);\r\n    List<MediaType> mediaTypes = MediaType.parseMediaTypes(acceptHeader);\r\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\r\n    if (client.getUserInfoSignedResponseAlg() != null || client.getUserInfoEncryptedResponseAlg() != null || client.getUserInfoEncryptedResponseEnc() != null) {\r\n        for (MediaType m : mediaTypes) {\r\n            if (!m.isWildcardType() && m.isCompatibleWith(UserInfoJWTView.JOSE_MEDIA_TYPE)) {\r\n                return UserInfoJWTView.VIEWNAME;\r\n            } else if (!m.isWildcardType() && m.isCompatibleWith(MediaType.APPLICATION_JSON)) {\r\n                return UserInfoView.VIEWNAME;\r\n            }\r\n        }\r\n        return UserInfoJWTView.VIEWNAME;\r\n    } else {\r\n        for (MediaType m : mediaTypes) {\r\n            if (!m.isWildcardType() && m.isCompatibleWith(MediaType.APPLICATION_JSON)) {\r\n                return UserInfoView.VIEWNAME;\r\n            } else if (!m.isWildcardType() && m.isCompatibleWith(UserInfoJWTView.JOSE_MEDIA_TYPE)) {\r\n                return UserInfoJWTView.VIEWNAME;\r\n            }\r\n        }\r\n        return UserInfoView.VIEWNAME;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.HistoryStrategy.getMessageHistory",
	"Comment": "obtain the current history as an iterator of messages to play back to a new room member.",
	"Method": "Iterator<Message> getMessageHistory(){\r\n    LinkedList<Message> list = new LinkedList(history);\r\n    Collections.sort(list, new MessageComparator());\r\n    return list.iterator();\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheSizes.sizeOfAnything",
	"Comment": "returns the size of an object in bytes. determining size by serializationis only used as a last resort.",
	"Method": "int sizeOfAnything(Object object){\r\n    if (object == null) {\r\n        return 0;\r\n    }\r\n    if (object instanceof Cacheable) {\r\n        return ((Cacheable) object).getCachedSize();\r\n    } else if (object instanceof String) {\r\n        return sizeOfString((String) object);\r\n    } else if (object instanceof Long) {\r\n        return sizeOfLong();\r\n    } else if (object instanceof Integer) {\r\n        return sizeOfObject() + sizeOfInt();\r\n    } else if (object instanceof Double) {\r\n        return sizeOfObject() + sizeOfDouble();\r\n    } else if (object instanceof Boolean) {\r\n        return sizeOfObject() + sizeOfBoolean();\r\n    } else if (object instanceof Map) {\r\n        return sizeOfMap((Map) object);\r\n    } else if (object instanceof long[]) {\r\n        long[] array = (long[]) object;\r\n        return sizeOfObject() + array.length * sizeOfLong();\r\n    } else if (object instanceof Collection) {\r\n        return sizeOfCollection((Collection) object);\r\n    } else if (object instanceof byte[]) {\r\n        byte[] array = (byte[]) object;\r\n        return sizeOfObject() + array.length;\r\n    } else {\r\n        int size = 1;\r\n        try {\r\n            CacheSizes.NullOutputStream out = new NullOutputStream();\r\n            ObjectOutputStream outObj = new ObjectOutputStream(out);\r\n            outObj.writeObject(object);\r\n            size = out.size();\r\n        } catch (IOException ioe) {\r\n            throw new CannotCalculateSizeException(object);\r\n        }\r\n        return size;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PubSubPersistenceManager.purgeItems",
	"Comment": "purges all items from the database that exceed the defined item count onall nodes.",
	"Method": "void purgeItems(){\r\n    boolean abortTransaction = false;\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    PreparedStatement nodeConfig = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        con = DbConnectionManager.getTransactionConnection();\r\n        nodeConfig = con.prepareStatement(PERSISTENT_NODES);\r\n        rs = nodeConfig.executeQuery();\r\n        PreparedStatement purgeNode = con.prepareStatement(getPurgeStatement(DbConnectionManager.getDatabaseType()));\r\n        Boolean hasBatchItems = false;\r\n        while (rs.next()) {\r\n            hasBatchItems = true;\r\n            String svcId = rs.getString(1);\r\n            String nodeId = rs.getString(2);\r\n            int maxItems = rs.getInt(3);\r\n            setPurgeParams(DbConnectionManager.getDatabaseType(), purgeNode, svcId, nodeId, maxItems);\r\n            purgeNode.addBatch();\r\n        }\r\n        if (hasBatchItems)\r\n            purgeNode.executeBatch();\r\n    } catch (Exception sqle) {\r\n        log.error(sqle.getMessage(), sqle);\r\n        abortTransaction = true;\r\n    } finally {\r\n        DbConnectionManager.closeResultSet(rs);\r\n        DbConnectionManager.closeStatement(rs, nodeConfig);\r\n        DbConnectionManager.closeTransactionConnection(pstmt, con, abortTransaction);\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.assertion.JWTBearerClientAssertionTokenEndpointFilter.attemptAuthentication",
	"Comment": "pull the assertion out of the request and send it up to the auth manager for processing.",
	"Method": "Authentication attemptAuthentication(HttpServletRequest request,HttpServletResponse response){\r\n    String assertionType = request.getParameter(\"client_assertion_type\");\r\n    String assertion = request.getParameter(\"client_assertion\");\r\n    try {\r\n        JWT jwt = JWTParser.parse(assertion);\r\n        String clientId = jwt.getJWTClaimsSet().getSubject();\r\n        Authentication authRequest = new JWTBearerAssertionAuthenticationToken(jwt);\r\n        return this.getAuthenticationManager().authenticate(authRequest);\r\n    } catch (ParseException e) {\r\n        throw new BadCredentialsException(\"Invalid JWT credential: \" + assertion);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.MessageRouter.sendMessageToAdmins",
	"Comment": "forwards the received message to the list of users defined in the propertyxmpp.forward.admins. the property may include bare jids or just usernames separatedby commas or white spaces. when using bare jids the target user may belong to a remoteserver.if the property xmpp.forward.admins was not defined then the message will be sentto all the users allowed to enter the admin console.",
	"Method": "void sendMessageToAdmins(Message packet){\r\n    String jids = JiveGlobals.getProperty(\"xmpp.forward.admins\");\r\n    if (jids != null && jids.trim().length() > 0) {\r\n        StringTokenizer tokenizer = new StringTokenizer(jids, \", \");\r\n        while (tokenizer.hasMoreTokens()) {\r\n            String username = tokenizer.nextToken();\r\n            Message forward = packet.createCopy();\r\n            if (username.contains(\"@\")) {\r\n                forward.setTo(username);\r\n            } else {\r\n                forward.setTo(username + \"@\" + serverName);\r\n            }\r\n            route(forward);\r\n        }\r\n    } else {\r\n        for (JID jid : XMPPServer.getInstance().getAdmins()) {\r\n            Message forward = packet.createCopy();\r\n            forward.setTo(jid);\r\n            route(forward);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.cluster.ClusterManager.setClusteringEnabled",
	"Comment": "sets true if clustering support is enabled. an attempt to start or joinan existing cluster will be attempted in the service was enabled. on theother hand, if disabled then this jvm will leave or stop the cluster.",
	"Method": "void setClusteringEnabled(boolean enabled){\r\n    if (enabled) {\r\n        if (isClusteringEnabled() && isClusteringStarted()) {\r\n            return;\r\n        }\r\n    } else {\r\n        if (!isClusteringEnabled()) {\r\n            return;\r\n        }\r\n    }\r\n    JiveGlobals.setXMLProperty(CLUSTER_PROPERTY_NAME, Boolean.toString(enabled));\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheFactory.getMaxClusterNodes",
	"Comment": "returns the maximum number of cluster members allowed. a value of 0 willbe returned when clustering is not allowed.",
	"Method": "int getMaxClusterNodes(){\r\n    return cacheFactoryStrategy.getMaxClusterNodes();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SocketConnection.notifyCloseListeners",
	"Comment": "notifies all close listeners that the connection has been closed.used by subclasses to properly finish closing the connection.",
	"Method": "void notifyCloseListeners(){\r\n    synchronized (listeners) {\r\n        for (ConnectionCloseListener listener : listeners.keySet()) {\r\n            try {\r\n                listener.onConnectionClose(listeners.get(listener));\r\n            } catch (Exception e) {\r\n                Log.error(\"Error notifying listener: \" + listener, e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PublishedItem.getID",
	"Comment": "returns the id that uniquely identifies the published item in the node.",
	"Method": "String getID(){\r\n    return id;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.cluster.ClusterManager.isClusterMember",
	"Comment": "returns true if the specified node id belongs to a known cluster nodeof this cluster.",
	"Method": "boolean isClusterMember(byte[] nodeID){\r\n    for (ClusterNodeInfo nodeInfo : getNodesInfo()) {\r\n        if (nodeInfo.getNodeID().equals(nodeID)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.security.SecurityAuditEvent.getSummary",
	"Comment": "returns the summary, or short description of what transpired in the event.",
	"Method": "String getSummary(){\r\n    return summary;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.GroupJID.fromString",
	"Comment": "creates a jid from the given string. if the string represents a group,return an instance of this class. otherwise returns a regular jid.",
	"Method": "JID fromString(String jid){\r\n    Log.debug(\"Parsing JID from string: \" + jid);\r\n    return fromJID(new JID(jid));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.ServerSocketReader.processPresence",
	"Comment": "processes the packet in another thread if the packet has not been rejected.",
	"Method": "void processPresence(Presence packet){\r\n    try {\r\n        packetReceived(packet);\r\n        try {\r\n            super.processPresence(packet);\r\n        } catch (UnauthorizedException e) {\r\n            Log.error(\"Error processing packet\", e);\r\n        }\r\n    } catch (PacketRejectedException e) {\r\n        Log.debug(\"Presence rejected: \" + packet.toXML(), e);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.addPublisher",
	"Comment": "adds a new affiliation or updates an existing affiliation of the specified entity jidto become a node publisher.",
	"Method": "NodeAffiliate addPublisher(JID jid){\r\n    return addAffiliation(jid, NodeAffiliate.Affiliation.publisher);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterManager.isRosterServiceEnabled",
	"Comment": "returns true if the roster service is enabled. when disabled it is not possible toretrieve users rosters or broadcast presence packets to roster contacts.",
	"Method": "boolean isRosterServiceEnabled(){\r\n    return JiveGlobals.getBooleanProperty(\"xmpp.client.roster.active\", true);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.multiplex.Route.getStreamID",
	"Comment": "return the stream id that identifies the connection that is actually sendingthe wrapped stanza.",
	"Method": "StreamID getStreamID(){\r\n    final String value = element.attributeValue(\"streamid\");\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    return BasicStreamIDFactory.createStreamID(value);\r\n}"
}, {
	"Path": "org.jivesoftware.util.StringUtils.replaceIgnoreCase",
	"Comment": "replaces all instances of oldstring with newstring in line with theadded feature that matches of newstring in oldstring ignore case.the count paramater is set to the number of replaces performed.",
	"Method": "String replaceIgnoreCase(String line,String oldString,String newString,String replaceIgnoreCase,String line,String oldString,String newString,int[] count){\r\n    return replace(line, oldString, newString, true, count);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.handler.IQPrivacyHandler.declineActiveList",
	"Comment": "user has requested that no active list should be used for the current session. returnacknowledge of success.",
	"Method": "IQ declineActiveList(IQ packet,JID from){\r\n    ClientSession session = sessionManager.getSession(from);\r\n    session.setActiveList(null);\r\n    return IQ.createResultIQ(packet);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.UserServicePlugin.setSecret",
	"Comment": "sets the secret key that grants permission to use the userservice.",
	"Method": "void setSecret(String secret){\r\n    JiveGlobals.setProperty(\"plugin.userservice.secret\", secret);\r\n    this.secret = secret;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getIQPEPHandler",
	"Comment": "returns the iqpephandler registered with this server. theiqpephandler was registered with the server as a module while starting upthe server.",
	"Method": "IQPEPHandler getIQPEPHandler(){\r\n    return (IQPEPHandler) modules.get(IQPEPHandler.class);\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ProviderTokenService.createAccessToken_yesRefresh",
	"Comment": "tests the creation of access tokens for clients that are allowed to have refresh tokens.",
	"Method": "void createAccessToken_yesRefresh(){\r\n    OAuth2Request clientAuth = new OAuth2Request(null, clientId, null, true, newHashSet(SystemScopeService.OFFLINE_ACCESS), null, null, null, null);\r\n    when(authentication.getOAuth2Request()).thenReturn(clientAuth);\r\n    when(client.isAllowRefresh()).thenReturn(true);\r\n    OAuth2AccessTokenEntity token = service.createAccessToken(authentication);\r\n    verify(tokenRepository, atLeastOnce()).saveRefreshToken(any(OAuth2RefreshTokenEntity.class));\r\n    verify(scopeService, atLeastOnce()).removeReservedScopes(anySet());\r\n    assertThat(token.getRefreshToken(), is(notNullValue()));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.getMaxPublishedItems",
	"Comment": "returns the maximum number of published items to persist. note that all nodes are goingto persist their published items. the only difference is the number of the last publisheditems to be persisted. even nodes that are configured to not use persitent items are goingto save the last published item.",
	"Method": "int getMaxPublishedItems(){\r\n    return maxPublishedItems;\r\n}"
}, {
	"Path": "org.dom4j.io.XMPPPacketReader.addHandler",
	"Comment": "adds the elementhandler to be called when thespecified path is encounted.",
	"Method": "void addHandler(String path,ElementHandler handler){\r\n    getDispatchHandler().addHandler(path, handler);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.disco.DiscoItem.getElement",
	"Comment": "returns a dom4j element that represents this discoitem object.",
	"Method": "Element getElement(){\r\n    return element;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.TLSStreamHandler.doTasks",
	"Comment": "do all the outstanding handshake tasks in the current thread.",
	"Method": "SSLEngineResult.HandshakeStatus doTasks(){\r\n    Runnable runnable;\r\n    while ((runnable = tlsEngine.getDelegatedTask()) != null) {\r\n        runnable.run();\r\n    }\r\n    return tlsEngine.getHandshakeStatus();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalClientSession.getActiveList",
	"Comment": "returns the privacy list that overrides the default privacy list. this list affectsonly this session and only for the duration of the session.",
	"Method": "PrivacyList getActiveList(){\r\n    if (activeList != null) {\r\n        try {\r\n            return PrivacyListManager.getInstance().getPrivacyList(getUsername(), activeList);\r\n        } catch (UserNotFoundException e) {\r\n            Log.error(e.getMessage(), e);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.disco.IQDiscoInfoHandler.addServerFeature",
	"Comment": "adds one specific feature to the information returned whenever a disco for information ismade against the server.",
	"Method": "void addServerFeature(String namespace){\r\n    if (localServerFeatures.add(namespace)) {\r\n        Lock lock = CacheFactory.getLock(namespace, serverFeatures);\r\n        try {\r\n            lock.lock();\r\n            HashSet<NodeID> nodeIDs = serverFeatures.get(namespace);\r\n            if (nodeIDs == null) {\r\n                nodeIDs = new HashSet();\r\n            }\r\n            nodeIDs.add(XMPPServer.getInstance().getNodeID());\r\n            serverFeatures.put(namespace, nodeIDs);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.Channel.add",
	"Comment": "enqueus a message to be handled by this channel. after the channelhandler is doneprocessing the message, it will be sent to the next channel. messages with a higherpriority will be handled first.",
	"Method": "void add(T packet){\r\n    Runnable r = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                channelHandler.process(packet);\r\n            } catch (Exception e) {\r\n                Log.error(LocaleUtils.getLocalizedString(\"admin.error\"), e);\r\n                try {\r\n                    Session session = SessionManager.getInstance().getSession(packet.getFrom());\r\n                    if (session != null) {\r\n                        Log.debug(\"Closing session of '{}': {}\", packet.getFrom(), session);\r\n                        session.close();\r\n                    }\r\n                } catch (Exception e1) {\r\n                    Log.error(\"Unexpected exception while trying to close session of '{}'.\", packet.getFrom(), e1);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    executor.execute(r);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.Channel.add",
	"Comment": "enqueus a message to be handled by this channel. after the channelhandler is doneprocessing the message, it will be sent to the next channel. messages with a higherpriority will be handled first.",
	"Method": "void add(T packet){\r\n    try {\r\n        channelHandler.process(packet);\r\n    } catch (Exception e) {\r\n        Log.error(LocaleUtils.getLocalizedString(\"admin.error\"), e);\r\n        try {\r\n            Session session = SessionManager.getInstance().getSession(packet.getFrom());\r\n            if (session != null) {\r\n                Log.debug(\"Closing session of '{}': {}\", packet.getFrom(), session);\r\n                session.close();\r\n            }\r\n        } catch (Exception e1) {\r\n            Log.error(\"Unexpected exception while trying to close session of '{}'.\", packet.getFrom(), e1);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.UpdateManager.setCheckFrequency",
	"Comment": "sets the frequency to check for updates. by default, this will happen every 48 hours.",
	"Method": "void setCheckFrequency(int checkFrequency){\r\n    JiveGlobals.setProperty(\"update.frequency\", Integer.toString(checkFrequency));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.IQMUCSearchHandler.sortByUserAmount",
	"Comment": "sorts the provided list in such a way that the muc with the most userswill be the first one in the list.",
	"Method": "List<MUCRoom> sortByUserAmount(List<MUCRoom> mucs){\r\n    Collections.sort(mucs, new Comparator<MUCRoom>() {\r\n        @Override\r\n        public int compare(MUCRoom o1, MUCRoom o2) {\r\n            return o2.getOccupantsCount() - o1.getOccupantsCount();\r\n        }\r\n    });\r\n    return mucs;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.IQMUCSearchHandler.sortByUserAmount",
	"Comment": "sorts the provided list in such a way that the muc with the most userswill be the first one in the list.",
	"Method": "List<MUCRoom> sortByUserAmount(List<MUCRoom> mucs){\r\n    return o2.getOccupantsCount() - o1.getOccupantsCount();\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheFactory.getMaxCacheLifetime",
	"Comment": "if a local property is found for the supplied name which specifies a value for cache entry lifetime, itis returned. otherwise, the defaultlifetime argument is returned.",
	"Method": "long getMaxCacheLifetime(String cacheName){\r\n    return getCacheProperty(cacheName, \".maxLifetime\", DEFAULT_MAX_CACHE_LIFETIME);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.rules.RuleGroupEventListener.parseGroupNames",
	"Comment": "returns a collection of groups obtained by parsing a comma delimited string with the name of groups.",
	"Method": "Collection<String> parseGroupNames(String groupNames){\r\n    Collection<String> answer = new HashSet<String>();\r\n    if (groupNames != null) {\r\n        StringTokenizer tokenizer = new StringTokenizer(groupNames, \",\");\r\n        while (tokenizer.hasMoreTokens()) {\r\n            answer.add(tokenizer.nextToken());\r\n        }\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeAffiliate.sendDeletionNotifications",
	"Comment": "sends an event notification to the affiliate for the deleted items. the eventnotification may contain one or many published items based on the items includedin the original publication. if the affiliate has many subscriptions and manyitems were deleted then the affiliate will get a notification for each setof items that affected the same subscriptions.",
	"Method": "void sendDeletionNotifications(Message notification,Element event,LeafNode leafNode,List<PublishedItem> publishedItems){\r\n    if (!publishedItems.isEmpty()) {\r\n        Map<List<NodeSubscription>, List<PublishedItem>> itemsBySubs = getItemsBySubscriptions(leafNode, publishedItems);\r\n        for (List<NodeSubscription> nodeSubscriptions : itemsBySubs.keySet()) {\r\n            Element items = event.addElement(\"items\");\r\n            items.addAttribute(\"node\", leafNode.getNodeID());\r\n            for (PublishedItem publishedItem : itemsBySubs.get(nodeSubscriptions)) {\r\n                Element item = items.addElement(\"retract\");\r\n                if (leafNode.isItemRequired()) {\r\n                    item.addAttribute(\"id\", publishedItem.getID());\r\n                }\r\n            }\r\n            sendEventNotification(notification, nodeSubscriptions);\r\n            event.remove(items);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.setSubscriptionEnabled",
	"Comment": "sets whether users are allowed to subscribe and unsubscribe.",
	"Method": "void setSubscriptionEnabled(boolean subscriptionEnabled){\r\n    this.subscriptionEnabled = subscriptionEnabled;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.delete",
	"Comment": "deletes this node from memory and the database. subscribers are going to be notifiedthat the node has been deleted after the node was successfully deleted.",
	"Method": "boolean delete(){\r\n    if (PubSubPersistenceManager.removeNode(this)) {\r\n        if (parent != null) {\r\n            parent.removeChildNode(this);\r\n        }\r\n        deletingNode();\r\n        if (isNotifiedOfDelete()) {\r\n            Message message = new Message();\r\n            Element event = message.addChildElement(\"event\", \"http://jabber.org/protocol/pubsub#event\");\r\n            Element items = event.addElement(\"delete\");\r\n            items.addAttribute(\"node\", nodeID);\r\n            broadcastNodeEvent(message, true);\r\n        }\r\n        if (parent != null) {\r\n            parent.childNodeDeleted(this);\r\n        }\r\n        cancelPresenceSubscriptions();\r\n        service.removeNode(getNodeID());\r\n        CacheFactory.doClusterTask(new RemoveNodeTask(this));\r\n        affiliates.clear();\r\n        subscriptionsByID.clear();\r\n        subscriptionsByJID.clear();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.MessageRouter.routingFailed",
	"Comment": "notification message indicating that a packet has failed to be routed to the recipient.",
	"Method": "void routingFailed(JID recipient,Packet packet){\r\n    log.debug(\"Message sent to unreachable address: \" + packet.toXML());\r\n    final Message msg = (Message) packet;\r\n    boolean storeOffline = true;\r\n    if (msg.getType().equals(Message.Type.chat) && serverName.equals(recipient.getDomain()) && recipient.getResource() != null) {\r\n        for (JID address : routingTable.getRoutes(recipient.asBareJID(), packet.getFrom())) {\r\n            ClientSession session = routingTable.getClientRoute(address);\r\n            if (session != null && session.isInitialized()) {\r\n                if (session.getPresence().getPriority() >= 1) {\r\n                    storeOffline = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (!storeOffline) {\r\n        routingTable.routePacket(recipient.asBareJID(), packet, false);\r\n    } else {\r\n        messageStrategy.storeOffline((Message) packet);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.EncryptionArtifactFactoryTest.testHasDefaultProtocols",
	"Comment": "verifies that the collection of default encryption protocols is not empty.",
	"Method": "void testHasDefaultProtocols(){\r\n    final Collection<String> result = EncryptionArtifactFactory.getDefaultProtocols();\r\n    Assert.assertFalse(result.isEmpty());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.ConversationLogEntry.getDate",
	"Comment": "returns the date when the logged message was sent to the room.",
	"Method": "Date getDate(){\r\n    return date;\r\n}"
}, {
	"Path": "org.mitre.oauth2.introspectingfilter.IntrospectingTokenService.isCacheTokens",
	"Comment": "is the service caching tokens, or is it hitting the introspection end point every time",
	"Method": "boolean isCacheTokens(){\r\n    return cacheTokens;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.cluster.ClusterManager.isClusteringAvailable",
	"Comment": "returns true if clustering is installed and can be used by this jvmto join a cluster. a false value could mean that either clusteringsupport is not available or the license does not allow to have morethan 1 cluster node.",
	"Method": "boolean isClusteringAvailable(){\r\n    return CacheFactory.isClusteringAvailable();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.ConcurrentGroupList.syncGroups",
	"Comment": "this method is called from several of the mutators to keepthe group set in sync with the full list.",
	"Method": "boolean syncGroups(Object item,boolean addOrRemove){\r\n    boolean result = false;\r\n    if (knownGroupNamesInList != null) {\r\n        Group group = Group.resolveFrom(item);\r\n        if (group != null) {\r\n            result = true;\r\n            if (addOrRemove == ADD) {\r\n                knownGroupNamesInList.add(group.getName());\r\n            } else if (addOrRemove == REMOVE) {\r\n                knownGroupNamesInList.remove(group.getName());\r\n                if (knownGroupNamesInList.isEmpty()) {\r\n                    knownGroupNamesInList = null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.mediaproxy.MediaProxy.getPublicIP",
	"Comment": "get the public ip of this media proxy that listen for incomming packets.",
	"Method": "String getPublicIP(){\r\n    return ipAddress;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sip.tester.security.SipSecurityManager.setHeaderFactory",
	"Comment": "set the header factory to be used when creating authorization headers",
	"Method": "void setHeaderFactory(HeaderFactory headerFactory){\r\n    this.headerFactory = headerFactory;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.isMultipleSubscriptionsEnabled",
	"Comment": "returns true if a user may have more than one subscription with the node. whenmultiple subscriptions is enabled each subscription request, event notification andunsubscription request should include a subid attribute. by default multiplesubscriptions is enabled.",
	"Method": "boolean isMultipleSubscriptionsEnabled(){\r\n    return service.isMultipleSubscriptionsEnabled();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.isPresenceBasedDelivery",
	"Comment": "returns true if notifications to the specified user will be delivered when theuser is online.",
	"Method": "boolean isPresenceBasedDelivery(boolean isPresenceBasedDelivery,JID user){\r\n    Collection<NodeSubscription> subscriptions = getSubscriptions(user);\r\n    if (!subscriptions.isEmpty()) {\r\n        if (presenceBasedDelivery) {\r\n            return true;\r\n        } else {\r\n            for (NodeSubscription subscription : subscriptions) {\r\n                if (!subscription.getPresenceStates().isEmpty()) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.GroupJID.asBareJID",
	"Comment": "override the base class implementation to retain the resourceidentifier for group jids.",
	"Method": "JID asBareJID(){\r\n    return this;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheFactory.isClusteringAvailable",
	"Comment": "returns true if clustering is installed and can be used by this jvmto join a cluster. a false value could mean that either clusteringsupport is not available or the license does not allow to have morethan 1 cluster node.",
	"Method": "boolean isClusteringAvailable(){\r\n    if (clusteredCacheFactoryStrategy == null) {\r\n        try {\r\n            clusteredCacheFactoryStrategy = (CacheFactoryStrategy) Class.forName(clusteredCacheFactoryClass, true, getClusteredCacheStrategyClassLoader()).newInstance();\r\n        } catch (NoClassDefFoundError | Exception e) {\r\n            log.warn(\"Clustered cache factory strategy \" + clusteredCacheFactoryClass + \" not found\");\r\n        }\r\n    }\r\n    return (clusteredCacheFactoryStrategy != null);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PublishedItem.setPayload",
	"Comment": "sets the payload included when publishing the item. a published item may or may nothave a payload. transient nodes that are configured to not broadcast payloads may allowpublished items to have no payload.",
	"Method": "void setPayload(Element payload){\r\n    this.payload = payload;\r\n    if (payload == null) {\r\n        payloadXML = null;\r\n    } else {\r\n        payloadXML = payload.asXML();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.setHomeDirectory",
	"Comment": "sets the location of the home directory. the directory must exist and theuser running the application must have read and write permissions over the specifieddirectory.",
	"Method": "void setHomeDirectory(String pathname){\r\n    File mh = new File(pathname);\r\n    if (!mh.exists()) {\r\n        Log.error(\"Error - the specified home directory does not exist (\" + pathname + \")\");\r\n    } else if (!mh.canRead() || !mh.canWrite()) {\r\n        Log.error(\"Error - the user running this application can not read \" + \"and write to the specified home directory (\" + pathname + \"). \" + \"Please grant the executing user read and write permissions.\");\r\n    } else {\r\n        home = pathname;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PubSubPersistenceManager.loadNodes",
	"Comment": "loads all nodes from the database and adds them to the pubsub service.",
	"Method": "void loadNodes(PubSubService service){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    Map<String, Node> nodes = new HashMap();\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(LOAD_NODES);\r\n        pstmt.setString(1, service.getServiceID());\r\n        rs = pstmt.executeQuery();\r\n        Map<String, String> parentMappings = new HashMap();\r\n        while (rs.next()) {\r\n            loadNode(service, nodes, parentMappings, rs);\r\n        }\r\n        DbConnectionManager.fastcloseStmt(rs, pstmt);\r\n        if (nodes.size() == 0) {\r\n            log.info(\"No nodes found in pubsub\");\r\n            return;\r\n        }\r\n        for (Map.Entry<String, String> entry : parentMappings.entrySet()) {\r\n            Node child = nodes.get(entry.getKey());\r\n            CollectionNode parent = (CollectionNode) nodes.get(entry.getValue());\r\n            if (parent == null) {\r\n                log.error(\"Could not find parent node \" + entry.getValue() + \" for node \" + entry.getKey());\r\n            } else {\r\n                child.changeParent(parent);\r\n            }\r\n        }\r\n        pstmt = con.prepareStatement(LOAD_NODES_JIDS);\r\n        pstmt.setString(1, service.getServiceID());\r\n        rs = pstmt.executeQuery();\r\n        while (rs.next()) {\r\n            loadAssociatedJIDs(nodes, rs);\r\n        }\r\n        DbConnectionManager.fastcloseStmt(rs, pstmt);\r\n        pstmt = con.prepareStatement(LOAD_NODES_GROUPS);\r\n        pstmt.setString(1, service.getServiceID());\r\n        rs = pstmt.executeQuery();\r\n        while (rs.next()) {\r\n            loadAssociatedGroups(nodes, rs);\r\n        }\r\n        DbConnectionManager.fastcloseStmt(rs, pstmt);\r\n        pstmt = con.prepareStatement(LOAD_AFFILIATIONS);\r\n        pstmt.setString(1, service.getServiceID());\r\n        rs = pstmt.executeQuery();\r\n        while (rs.next()) {\r\n            loadAffiliations(nodes, rs);\r\n        }\r\n        DbConnectionManager.fastcloseStmt(rs, pstmt);\r\n        pstmt = con.prepareStatement(LOAD_SUBSCRIPTIONS);\r\n        pstmt.setString(1, service.getServiceID());\r\n        rs = pstmt.executeQuery();\r\n        while (rs.next()) {\r\n            loadSubscriptions(service, nodes, rs);\r\n        }\r\n        DbConnectionManager.fastcloseStmt(rs, pstmt);\r\n    } catch (SQLException sqle) {\r\n        log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    for (Node node : nodes.values()) {\r\n        node.setSavedToDB(true);\r\n        service.addNode(node);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterEventDispatcher.addingContact",
	"Comment": "notifies listeners that a contact is about to be added to a roster. new contactsmay be persisted to the database or not. listeners may indicate that contact aboutto be persisted should not be persisted. only one listener is needed to returnfalse so that the contact is not persisted.",
	"Method": "boolean addingContact(Roster roster,RosterItem item,boolean persistent){\r\n    boolean answer = persistent;\r\n    if (!listeners.isEmpty()) {\r\n        for (RosterEventListener listener : listeners) {\r\n            if (!listener.addingContact(roster, item, persistent)) {\r\n                answer = false;\r\n            }\r\n        }\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginManager.firePluginDestroyedEvent",
	"Comment": "notifies all registered pluginlistener instances that a plugin was destroyed.",
	"Method": "void firePluginDestroyedEvent(String name,Plugin plugin){\r\n    for (final PluginListener listener : pluginListeners) {\r\n        try {\r\n            listener.pluginDestroyed(name, plugin);\r\n        } catch (Exception ex) {\r\n            Log.warn(\"An exception was thrown when one of the pluginManagerListeners was notified of a 'destroyed' event for plugin '{}'!\", name, ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ClientDetailsEntityService.saveNewClient_yesOfflineAccess",
	"Comment": "makes sure client has offline access granted scope if allowed refresh tokens.",
	"Method": "void saveNewClient_yesOfflineAccess(){\r\n    ClientDetailsEntity client = new ClientDetailsEntity();\r\n    Set<String> grantTypes = new HashSet();\r\n    grantTypes.add(\"refresh_token\");\r\n    client.setGrantTypes(grantTypes);\r\n    client = service.saveNewClient(client);\r\n    assertThat(client.getScope().contains(SystemScopeService.OFFLINE_ACCESS), is(equalTo(true)));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.setSearchFilter",
	"Comment": "sets the search filter appended to the default filter when searching for users.",
	"Method": "void setSearchFilter(String searchFilter){\r\n    this.searchFilter = searchFilter;\r\n    properties.put(\"ldap.searchFilter\", searchFilter);\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.isPropertySensitive",
	"Comment": "flags certain properties as being sensitive, based onproperty naming conventions. values for matching propertynames are hidden from the openfire console.",
	"Method": "boolean isPropertySensitive(String name){\r\n    return name != null && (name.toLowerCase().contains(\"passwd\") || name.toLowerCase().contains(\"password\") || name.toLowerCase().contains(\"cookiekey\"));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.handler.PresenceUpdateHandler.removedExpiredPresences",
	"Comment": "removes directed presences sent to entities that are no longer available.",
	"Method": "void removedExpiredPresences(){\r\n    Map<String, Collection<DirectedPresence>> copy = new HashMap(localDirectedPresences);\r\n    for (Map.Entry<String, Collection<DirectedPresence>> entry : copy.entrySet()) {\r\n        for (DirectedPresence directedPresence : entry.getValue()) {\r\n            if (!routingTable.hasClientRoute(directedPresence.getHandler()) && !routingTable.hasComponentRoute(directedPresence.getHandler())) {\r\n                Collection<DirectedPresence> presences = localDirectedPresences.get(entry.getKey());\r\n                presences.remove(directedPresence);\r\n                if (presences.isEmpty()) {\r\n                    localDirectedPresences.remove(entry.getKey());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.Channel.getMaxThreadCount",
	"Comment": "returns the max number of threads the channel will use for processing messages. thechannel will automatically allocate new worker threads as the queue load grows, up to thedefined maximum. this lets the channel meet higher concurrency needs, but prevents toomany threads from being allocated, which decreases overall system performance.",
	"Method": "int getMaxThreadCount(){\r\n    return executor.getMaximumPoolSize();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.UserMultiProvider.getSearchFields",
	"Comment": "returns the combination of search fields supported by the backing providers. note that the returned fields mightnot be supported by every backing provider.",
	"Method": "Set<String> getSearchFields(){\r\n    int supportSearch = getUserProviders().size();\r\n    final Set<String> result = new HashSet();\r\n    for (final UserProvider provider : getUserProviders()) {\r\n        try {\r\n            result.addAll(provider.getSearchFields());\r\n        } catch (UnsupportedOperationException uoe) {\r\n            Log.warn(\"getSearchFields is not supported by this UserProvider: \" + provider.getClass().getName());\r\n            supportSearch--;\r\n        }\r\n    }\r\n    if (supportSearch == 0) {\r\n        throw new UnsupportedOperationException(\"None of the backing providers support this operation.\");\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.disco.IQDiscoItemsHandler.addUserItemsProvider",
	"Comment": "adds the items provided by the new service that implements the useritemsprovider interface. this information willbe used whenever a disco for items is made against users of the server.",
	"Method": "void addUserItemsProvider(UserItemsProvider provider){\r\n    this.userItemsProviders.add(provider);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.ServerSocketReader.packetReceived",
	"Comment": "make sure that the received packet has a to and from values defined and that it was sentfrom a previously validated domain. if the packet does not matches any of the aboveconditions then a packetrejectedexception will be thrown.",
	"Method": "void packetReceived(Packet packet){\r\n    if (packet.getTo() == null || packet.getFrom() == null) {\r\n        Log.debug(\"Closing IncomingServerSession due to packet with no TO or FROM: \" + packet.toXML());\r\n        StreamError error = new StreamError(StreamError.Condition.improper_addressing);\r\n        connection.deliverRawText(error.toXML());\r\n        connection.close();\r\n        open = false;\r\n        throw new PacketRejectedException(\"Packet with no TO or FROM attributes\");\r\n    } else if (!((LocalIncomingServerSession) session).isValidDomain(packet.getFrom().getDomain())) {\r\n        Log.debug(\"Closing IncomingServerSession due to packet with invalid domain: \" + packet.toXML());\r\n        StreamError error = new StreamError(StreamError.Condition.invalid_from);\r\n        connection.deliverRawText(error.toXML());\r\n        connection.close();\r\n        open = false;\r\n        throw new PacketRejectedException(\"Packet with no TO or FROM attributes\");\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.setNotifiedOfRetract",
	"Comment": "sets whether subscribers will be notified when items are removed from the node.",
	"Method": "void setNotifiedOfRetract(boolean notifyRetract){\r\n    this.notifyRetract = notifyRetract;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.IdentityStore.isForThisDomain",
	"Comment": "verifies that the subject of the certificate matches the domain of this xmpp service.",
	"Method": "boolean isForThisDomain(X509Certificate certificate){\r\n    final String domainName = XMPPServer.getInstance().getServerInfo().getXMPPDomain();\r\n    final List<String> serverIdentities = CertificateManager.getServerIdentities(certificate);\r\n    for (String identity : serverIdentities) {\r\n        if (DNSUtil.isNameCoveredByPattern(domainName, identity)) {\r\n            return true;\r\n        }\r\n    }\r\n    Log.info(\"The supplied certificate chain does not cover the domain of this XMPP service ('\" + domainName + \"'). Instead, it covers \" + Arrays.toString(serverIdentities.toArray(new String[serverIdentities.size()])));\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.cluster.OccupantAddedEvent.setSendPresence",
	"Comment": "sets if the room should broadcast presence of the new occupant to occupantshosted by this cluster node.",
	"Method": "void setSendPresence(boolean sendPresence){\r\n    this.sendPresence = sendPresence;\r\n}"
}, {
	"Path": "org.jivesoftware.util.WebManager.getAuthToken",
	"Comment": "returns the auth token redirects to the login page if an auth token is not found.",
	"Method": "AuthToken getAuthToken(){\r\n    return (AuthToken) session.getAttribute(\"jive.admin.authToken\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterItem.getID",
	"Comment": "returns the roster id associated with this particular roster item. a value of zeromeans that the roster item is not being persisted in the backend store.databases can use the roster id as the key in locating roster items.",
	"Method": "long getID(){\r\n    return rosterID;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.multiplex.ClientSessionConnection.closeVirtualConnection",
	"Comment": "if the connection manager or the client requested to close the connection then just donothing. but if the server originated the request to close the connection then we needto send to the connection manager a packet letting him know that the client session needsto be terminated.",
	"Method": "void closeVirtualConnection(){\r\n    StreamID streamID = session.getStreamID();\r\n    if (multiplexerManager.getClientSession(connectionManagerName, streamID) == null) {\r\n    } else {\r\n        ConnectionMultiplexerSession multiplexerSession = multiplexerManager.getMultiplexerSession(connectionManagerName, streamID);\r\n        if (multiplexerSession != null) {\r\n            IQ closeRequest = new IQ(IQ.Type.set);\r\n            closeRequest.setFrom(serverName);\r\n            closeRequest.setTo(connectionManagerName);\r\n            Element child = closeRequest.setChildElement(\"session\", \"http://jabber.org/protocol/connectionmanager\");\r\n            child.addAttribute(\"id\", streamID.getID());\r\n            child.addElement(\"close\");\r\n            multiplexerSession.process(closeRequest);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.MultiUserChatManager.unregisterMultiUserChatService",
	"Comment": "unregisters a multiuserchatservice from the manager.it can be usedto explicitly unregister services, and is also used internally to unregisterdatabase stored services.triggers the service to shut down.",
	"Method": "void unregisterMultiUserChatService(String subdomain){\r\n    Log.debug(\"MultiUserChatManager: Unregistering MUC service \" + subdomain);\r\n    MultiUserChatService service = mucServices.get(subdomain);\r\n    if (service != null) {\r\n        service.shutdown();\r\n        try {\r\n            ComponentManagerFactory.getComponentManager().removeComponent(subdomain);\r\n        } catch (ComponentException e) {\r\n            Log.error(\"MultiUserChatManager: Unable to remove \" + subdomain + \" from component manager.\", e);\r\n        }\r\n        mucServices.remove(subdomain);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSessionDeliverable.testNamespaceOnStanzaWithNamespace",
	"Comment": "verifies that the default namespace is not set on stanzas that already have defined a default namespace.",
	"Method": "void testNamespaceOnStanzaWithNamespace(){\r\n    final Message message = new Message();\r\n    message.getElement().setQName(QName.get(\"message\", \"unit:test:preexisting:namespace\"));\r\n    message.setTo(\"unittest@example.org/test\");\r\n    message.addChildElement(\"unittest\", \"unit:test:namespace\");\r\n    final List<Packet> packets = new ArrayList();\r\n    packets.add(message);\r\n    final HttpSession.Deliverable deliverable = new HttpSession.Deliverable(packets);\r\n    final String result = deliverable.getDeliverable();\r\n    assertEquals(\"<message xmlns=\\\"unit:test:preexisting:namespace\\\" to=\\\"unittest@example.org/test\\\"><unittest xmlns=\\\"unit:test:namespace\\\"/><\/message>\", result);\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.getMaxConnections",
	"Comment": "returns the maximum number of connections that the pool will use. theactual number of connections in the pool will vary between this valueand the minimum based on the current load.",
	"Method": "int getMaxConnections(){\r\n    return maxConnections;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.lockout.LockOutEventDispatcher.lockedAccountDenied",
	"Comment": "notifies the listeners that a locked out account attempted to log in.",
	"Method": "void lockedAccountDenied(String username){\r\n    if (!listeners.isEmpty()) {\r\n        for (LockOutEventListener listener : listeners) {\r\n            listener.lockedAccountDenied(username);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.models.PublisherModel.valueOf",
	"Comment": "returns the specific subclass of publishermodel as specified by the publishermodel name. if an unknown name is specified then an illegalargumentexceptionis going to be thrown.",
	"Method": "PublisherModel valueOf(String name){\r\n    if (\"open\".equals(name)) {\r\n        return open;\r\n    } else if (\"publishers\".equals(name)) {\r\n        return publishers;\r\n    } else if (\"subscribers\".equals(name)) {\r\n        return subscribers;\r\n    }\r\n    throw new IllegalArgumentException(\"Unknown publisher model: \" + name);\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.setMaxConnections",
	"Comment": "sets the maximum number of connections that the pool will use. theactual number of connections in the pool will vary between this valueand the minimum based on the current load.",
	"Method": "void setMaxConnections(int maxConnections){\r\n    this.maxConnections = maxConnections;\r\n    saveProperties();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.Channel.setMaxThreadCount",
	"Comment": "sets the max number of threads the channel will use for processing messages. the channelwill automatically allocate new worker threads as the queue size grows, up to the definedmaximum. this lets the channel meet higher concurrency needs, but prevents too many threadsfrom being allocated, which decreases overall system performance.",
	"Method": "void setMaxThreadCount(int maxThreadCount){\r\n    executor.setMaximumPoolSize(maxThreadCount);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.sendAffiliations",
	"Comment": "sends the list of affiliations with the node to the owner that sent the iqrequest.",
	"Method": "void sendAffiliations(IQ iqRequest){\r\n    IQ reply = IQ.createResultIQ(iqRequest);\r\n    Element childElement = iqRequest.getChildElement().createCopy();\r\n    reply.setChildElement(childElement);\r\n    Element affiliations = childElement.element(\"affiliations\");\r\n    for (NodeAffiliate affiliate : affiliates) {\r\n        if (affiliate.getAffiliation() == NodeAffiliate.Affiliation.none) {\r\n            continue;\r\n        }\r\n        Element entity = affiliations.addElement(\"affiliation\");\r\n        entity.addAttribute(\"jid\", affiliate.getJID().toString());\r\n        entity.addAttribute(\"affiliation\", affiliate.getAffiliation().name());\r\n    }\r\n    service.send(reply);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.component.InternalComponentManager.removeListener",
	"Comment": "removes the specified listener from the listeners being notified of componentevents.",
	"Method": "void removeListener(ComponentEventListener listener){\r\n    listeners.remove(listener);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SocketReader.closeNeverSecuredConnection",
	"Comment": "close the connection since tls was mandatory and the entity never negotiated tls. beforeclosing the connection a stream error will be sent to the entity.",
	"Method": "void closeNeverSecuredConnection(){\r\n    StreamError error = new StreamError(StreamError.Condition.not_authorized);\r\n    connection.deliverRawText(error.toXML());\r\n    connection.close();\r\n    Log.warn(\"TLS was required by the server and connection was never secured. \" + \"Closing connection : \" + connection);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.mediaproxy.MediaProxySession.addKeepAlive",
	"Comment": "add a keep alive detector.if the packet still more than the keep alive delay without receiving any packets. the session isstoped and remove from agents list.",
	"Method": "void addKeepAlive(long delay){\r\n    if (idleTimer != null)\r\n        return;\r\n    idleTimer = new Timer();\r\n    idleTimer.scheduleAtFixedRate(new TimerTask() {\r\n        long lastTimeStamp = getTimestamp();\r\n        @Override\r\n        public void run() {\r\n            if (lastTimeStamp == getTimestamp()) {\r\n                stopAgent();\r\n                return;\r\n            }\r\n            lastTimeStamp = getTimestamp();\r\n        }\r\n    }, delay, delay);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.mediaproxy.MediaProxySession.addKeepAlive",
	"Comment": "add a keep alive detector.if the packet still more than the keep alive delay without receiving any packets. the session isstoped and remove from agents list.",
	"Method": "void addKeepAlive(long delay){\r\n    if (lastTimeStamp == getTimestamp()) {\r\n        stopAgent();\r\n        return;\r\n    }\r\n    lastTimeStamp = getTimestamp();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalClientSession.getAuthToken",
	"Comment": "returns the authentication token associated with this session.",
	"Method": "AuthToken getAuthToken(){\r\n    return authToken;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PubSubEngine.getShowPresences",
	"Comment": "returns the show values of the last know presence of all connected resources of thespecified subscriber. when the subscriber jid is a bare jid then the answered collectionwill have many entries one for each connected resource. moreover, if the useris offline then an empty collectin is returned. available show status is representedby a online value. the rest of the possible show values as defined in rfc 3921.",
	"Method": "Collection<String> getShowPresences(PubSubService service,JID subscriber){\r\n    Map<String, String> fullPresences = service.getBarePresences().get(subscriber.toBareJID());\r\n    if (fullPresences == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    if (subscriber.getResource() == null) {\r\n        return fullPresences.values();\r\n    } else {\r\n        String show = fullPresences.get(subscriber.toString());\r\n        if (show == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return Collections.singletonList(show);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterManager.deleteRoster",
	"Comment": "removes the entire roster of a given user. this is necessary when a useraccount is being deleted from the server.",
	"Method": "void deleteRoster(JID user){\r\n    if (!server.isLocal(user)) {\r\n        return;\r\n    }\r\n    try {\r\n        String username = user.getNode();\r\n        Roster roster = getRoster(username);\r\n        for (RosterItem item : roster.getRosterItems()) {\r\n            try {\r\n                roster.deleteRosterItem(item.getJid(), false);\r\n            } catch (SharedGroupException e) {\r\n                Log.warn(\"Unexpected exception while deleting roster of user '{}' .\", user, e);\r\n            }\r\n        }\r\n        rosterCache.remove(username);\r\n        Iterator<String> usernames = provider.getUsernames(user.toBareJID());\r\n        while (usernames.hasNext()) {\r\n            username = usernames.next();\r\n            try {\r\n                roster = getRoster(username);\r\n                roster.deleteRosterItem(user, false);\r\n            } catch (SharedGroupException e) {\r\n                Log.warn(\"Unexpected exception while deleting roster of user '{}' .\", user, e);\r\n            } catch (UserNotFoundException e) {\r\n            }\r\n        }\r\n    } catch (UnsupportedOperationException | UserNotFoundException e) {\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.streammanagement.StreamManager.allowResume",
	"Comment": "should this session be allowed to resume?this is used while processedand",
	"Method": "boolean allowResume(){\r\n    boolean allow = false;\r\n    if (session instanceof ClientSession) {\r\n        AuthToken authToken = ((LocalClientSession) session).getAuthToken();\r\n        if (authToken != null) {\r\n            if (!authToken.isAnonymous()) {\r\n                allow = true;\r\n            }\r\n        }\r\n    }\r\n    return allow;\r\n}"
}, {
	"Path": "org.mitre.oauth2.model.OAuth2RefreshTokenEntity.getAuthenticationHolder",
	"Comment": "the authentication in place when the original access token was\tcreated",
	"Method": "AuthenticationHolderEntity getAuthenticationHolder(){\r\n    return authenticationHolder;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.UpdateManager.getProxyHost",
	"Comment": "returns the host of the proxy to use to connect to igniterealtime.org or nullif no proxy is used.",
	"Method": "String getProxyHost(){\r\n    return JiveGlobals.getProperty(\"update.proxy.host\", \"\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.isIncludingBody",
	"Comment": "returns whether an entity wants to receive an xmpp message body inaddition to the payload format.",
	"Method": "boolean isIncludingBody(){\r\n    return includingBody;\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.getXMLPropertyNames",
	"Comment": "return all property names as a list of strings, or an empty list if jivehome has not been loaded.",
	"Method": "List<String> getXMLPropertyNames(){\r\n    if (openfireProperties == null) {\r\n        loadOpenfireProperties();\r\n    }\r\n    return openfireProperties.getAllPropertyNames();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginMetadataHelper.getDatabaseKey",
	"Comment": "returns the database schema key of a plugin, if it exists. the value is retrieved from the plugin.xml file of theplugin. if the value could not be found, null will be returned.",
	"Method": "String getDatabaseKey(Plugin plugin,String getDatabaseKey,Path pluginDir){\r\n    return getElementValue(pluginDir, \"/plugin/databaseKey\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.CertificateStoreWatcher.unwatch",
	"Comment": "stop watching the file that backs a certificate store for changes",
	"Method": "void unwatch(CertificateStore store){\r\n    if (store == null) {\r\n        throw new IllegalArgumentException(\"Argument 'store' cannot be null.\");\r\n    }\r\n    synchronized (watchedStores) {\r\n        watchedStores.remove(store);\r\n        final Path dir = store.getConfiguration().getFile().toPath().normalize().getParent();\r\n        if (watchedStores.containsValue(dir)) {\r\n            return;\r\n        }\r\n        final WatchKey key = watchedPaths.remove(dir);\r\n        if (key != null) {\r\n            key.cancel();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.BlockingReadingMode.run",
	"Comment": "a dedicated thread loop for reading the stream and sending incomingpackets to the appropriate router.",
	"Method": "void run(){\r\n    try {\r\n        final InputStream inputStream;\r\n        if (socketReader.directTLS) {\r\n            inputStream = socketReader.connection.getTLSStreamHandler().getInputStream();\r\n        } else {\r\n            inputStream = socket.getInputStream();\r\n        }\r\n        socketReader.reader.getXPPParser().setInput(new InputStreamReader(ServerTrafficCounter.wrapInputStream(inputStream), CHARSET));\r\n        try {\r\n            socketReader.createSession();\r\n        } catch (IOException e) {\r\n            Log.debug(\"Error creating session\", e);\r\n            throw e;\r\n        }\r\n        if (socketReader.session != null) {\r\n            readStream();\r\n        }\r\n    } catch (EOFException eof) {\r\n    } catch (SocketException se) {\r\n    } catch (AsynchronousCloseException ace) {\r\n    } catch (XmlPullParserException ie) {\r\n    } catch (Exception e) {\r\n        if (socketReader.session != null) {\r\n            Log.warn(LocaleUtils.getLocalizedString(\"admin.error.stream\") + \". Session: \" + socketReader.session, e);\r\n        }\r\n    } finally {\r\n        if (socketReader.session != null) {\r\n            if (Log.isDebugEnabled()) {\r\n                Log.debug(\"Logging off \" + socketReader.session.getAddress() + \" on \" + socketReader.connection);\r\n            }\r\n            try {\r\n                Log.debug(\"Closing session: {}\", socketReader.session);\r\n                socketReader.session.close();\r\n            } catch (Exception e) {\r\n                Log.warn(LocaleUtils.getLocalizedString(\"admin.error.connection\") + socket.toString());\r\n            }\r\n        } else {\r\n            socketReader.connection.close();\r\n            Log.debug(LocaleUtils.getLocalizedString(\"admin.error.connection\") + socket.toString());\r\n        }\r\n        socketReader.shutdown();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.setSslEnabled",
	"Comment": "sets whether the connection to the ldap server should be made via ssl or not.",
	"Method": "void setSslEnabled(boolean sslEnabled){\r\n    this.sslEnabled = sslEnabled;\r\n    properties.put(\"ldap.sslEnabled\", Boolean.toString(sslEnabled));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.MultiUserChatManager.registerMultiUserChatService",
	"Comment": "registers a new multiuserchatservice implementation to the manager.this is typically used if you have a custom muc implementation that youwant to register with the manager.in other words, it may not be databasestored and may follow special rules, implementating multiuserchatservice.it is also used internally to register services from the database.triggersthe service to start up.",
	"Method": "void registerMultiUserChatService(MultiUserChatService service){\r\n    Log.debug(\"MultiUserChatManager: Registering MUC service \" + service.getServiceName());\r\n    try {\r\n        ComponentManagerFactory.getComponentManager().addComponent(service.getServiceName(), service);\r\n        mucServices.put(service.getServiceName(), service);\r\n    } catch (ComponentException e) {\r\n        Log.error(\"MultiUserChatManager: Unable to add \" + service.getServiceName() + \" as component.\", e);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SASLAuthentication.handle",
	"Comment": "handles the sasl authentication packet. the entity may be sending an initialauthentication request or a response to a challenge made by the server. the returnedvalue indicates whether the authentication has finished either successfully or not orif the entity is expected to send a response to a challenge.",
	"Method": "Status handle(LocalSession session,Element doc){\r\n    try {\r\n        if (!doc.getNamespaceURI().equals(SASL_NAMESPACE)) {\r\n            throw new IllegalStateException(\"Unexpected data received while negotiating SASL authentication. Name of the offending root element: \" + doc.getName() + \" Namespace: \" + doc.getNamespaceURI());\r\n        }\r\n        switch(ElementType.valueOfCaseInsensitive(doc.getName())) {\r\n            case ABORT:\r\n                throw new SaslFailureException(Failure.ABORTED);\r\n            case AUTH:\r\n                if (doc.attributeValue(\"mechanism\") == null) {\r\n                    throw new SaslFailureException(Failure.INVALID_MECHANISM, \"Peer did not specify a mechanism.\");\r\n                }\r\n                final String mechanismName = doc.attributeValue(\"mechanism\").toUpperCase();\r\n                if (!mechanisms.contains(mechanismName)) {\r\n                    throw new SaslFailureException(Failure.INVALID_MECHANISM, \"The configuration of Openfire does not contain or allow the mechanism.\");\r\n                }\r\n                final XMPPServerInfo serverInfo = XMPPServer.getInstance().getServerInfo();\r\n                final String serverName = (mechanismName.equals(\"DIGEST-MD5\") ? serverInfo.getXMPPDomain() : serverInfo.getHostname());\r\n                final Map<String, Object> props = new HashMap();\r\n                props.put(LocalSession.class.getCanonicalName(), session);\r\n                props.put(Sasl.POLICY_NOANONYMOUS, Boolean.toString(!JiveGlobals.getBooleanProperty(\"xmpp.auth.anonymous\")));\r\n                props.put(\"com.sun.security.sasl.digest.realm\", serverInfo.getXMPPDomain());\r\n                SaslServer saslServer = Sasl.createSaslServer(mechanismName, \"xmpp\", serverName, props, new XMPPCallbackHandler());\r\n                if (saslServer == null) {\r\n                    throw new SaslFailureException(Failure.INVALID_MECHANISM, \"There is no provider that can provide a SASL server for the desired mechanism and properties.\");\r\n                }\r\n                session.setSessionData(\"SaslServer\", saslServer);\r\n                if (mechanismName.equals(\"DIGEST-MD5\")) {\r\n                    doc.setText(\"\");\r\n                }\r\n            case RESPONSE:\r\n                saslServer = (SaslServer) session.getSessionData(\"SaslServer\");\r\n                if (saslServer == null) {\r\n                    throw new IllegalStateException(\"A SaslServer instance was not initialized and/or stored on the session.\");\r\n                }\r\n                final String encoded = doc.getTextTrim();\r\n                final byte[] decoded;\r\n                if (encoded == null || encoded.isEmpty() || encoded.equals(\"=\")) {\r\n                    decoded = new byte[0];\r\n                } else {\r\n                    if (!BASE64_ENCODED.matcher(encoded).matches()) {\r\n                        throw new SaslFailureException(Failure.INCORRECT_ENCODING);\r\n                    }\r\n                    decoded = StringUtils.decodeBase64(encoded);\r\n                }\r\n                final byte[] challenge = saslServer.evaluateResponse(decoded);\r\n                if (!saslServer.isComplete()) {\r\n                    sendChallenge(session, challenge);\r\n                    return Status.needResponse;\r\n                }\r\n                if (session instanceof IncomingServerSession) {\r\n                    final boolean verify = JiveGlobals.getBooleanProperty(ConnectionSettings.Server.TLS_CERTIFICATE_VERIFY, true);\r\n                    if (verify) {\r\n                        if (verifyCertificates(session.getConnection().getPeerCertificates(), saslServer.getAuthorizationID(), true)) {\r\n                            ((LocalIncomingServerSession) session).tlsAuth();\r\n                        } else {\r\n                            throw new SaslFailureException(Failure.NOT_AUTHORIZED, \"Server-to-Server certificate verification failed.\");\r\n                        }\r\n                    }\r\n                }\r\n                authenticationSuccessful(session, saslServer.getAuthorizationID(), challenge);\r\n                session.removeSessionData(\"SaslServer\");\r\n                return Status.authenticated;\r\n            default:\r\n                throw new IllegalStateException(\"Unexpected data received while negotiating SASL authentication. Name of the offending root element: \" + doc.getName() + \" Namespace: \" + doc.getNamespaceURI());\r\n        }\r\n    } catch (SaslException ex) {\r\n        Log.debug(\"SASL negotiation failed for session: {}\", session, ex);\r\n        final Failure failure;\r\n        if (ex instanceof SaslFailureException && ((SaslFailureException) ex).getFailure() != null) {\r\n            failure = ((SaslFailureException) ex).getFailure();\r\n        } else {\r\n            failure = Failure.NOT_AUTHORIZED;\r\n        }\r\n        authenticationFailed(session, failure);\r\n        session.removeSessionData(\"SaslServer\");\r\n        return Status.failed;\r\n    } catch (Exception ex) {\r\n        Log.warn(\"An unexpected exception occurred during SASL negotiation. Affected session: {}\", session, ex);\r\n        authenticationFailed(session, Failure.NOT_AUTHORIZED);\r\n        session.removeSessionData(\"SaslServer\");\r\n        return Status.failed;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.OfflineMessageStore.getMessage",
	"Comment": "returns the offline message of the specified user with the given creation date. thereturned message will not be deleted from the database.",
	"Method": "OfflineMessage getMessage(String username,Date creationDate){\r\n    OfflineMessage message = null;\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    SAXReader xmlReader = null;\r\n    try {\r\n        xmlReader = xmlReaders.take();\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(LOAD_OFFLINE_MESSAGE);\r\n        pstmt.setString(1, username);\r\n        pstmt.setString(2, StringUtils.dateToMillis(creationDate));\r\n        rs = pstmt.executeQuery();\r\n        while (rs.next()) {\r\n            String msgXML = rs.getString(1);\r\n            message = new OfflineMessage(creationDate, xmlReader.read(new StringReader(msgXML)).getRootElement());\r\n            Element delay = message.addChildElement(\"delay\", \"urn:xmpp:delay\");\r\n            delay.addAttribute(\"from\", XMPPServer.getInstance().getServerInfo().getXMPPDomain());\r\n            delay.addAttribute(\"stamp\", XMPPDateTimeFormat.format(creationDate));\r\n        }\r\n    } catch (Exception e) {\r\n        Log.error(\"Error retrieving offline messages of username: \" + username + \" creationDate: \" + creationDate, e);\r\n    } finally {\r\n        if (xmlReader != null) {\r\n            xmlReaders.add(xmlReader);\r\n        }\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n    return message;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.SearchPlugin.removeNull",
	"Comment": "returns the trimmed argument, or an empty string object of null was supplied as an argument.",
	"Method": "String removeNull(String s){\r\n    if (s == null) {\r\n        return \"\";\r\n    }\r\n    return s.trim();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.CollectionNode.getAssociationPolicy",
	"Comment": "returns the policy that defines who may associate leaf nodes with a collection.",
	"Method": "LeafNodeAssociationPolicy getAssociationPolicy(){\r\n    return associationPolicy;\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.getTestSQL",
	"Comment": "returns the sql statement used to test if a connection is valid.",
	"Method": "String getTestSQL(){\r\n    return testSQL;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MUCPersistenceManager.deleteFromDB",
	"Comment": "removes the room configuration and its affiliates from the database.",
	"Method": "void deleteFromDB(MUCRoom room){\r\n    if (!room.isPersistent() || !room.wasSavedToDB()) {\r\n        return;\r\n    }\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    boolean abortTransaction = false;\r\n    try {\r\n        con = DbConnectionManager.getTransactionConnection();\r\n        pstmt = con.prepareStatement(DELETE_AFFILIATIONS);\r\n        pstmt.setLong(1, room.getID());\r\n        pstmt.executeUpdate();\r\n        DbConnectionManager.fastcloseStmt(pstmt);\r\n        pstmt = con.prepareStatement(DELETE_MEMBERS);\r\n        pstmt.setLong(1, room.getID());\r\n        pstmt.executeUpdate();\r\n        DbConnectionManager.fastcloseStmt(pstmt);\r\n        pstmt = con.prepareStatement(DELETE_ROOM);\r\n        pstmt.setLong(1, room.getID());\r\n        pstmt.executeUpdate();\r\n        room.setSavedToDB(false);\r\n    } catch (SQLException sqle) {\r\n        Log.error(sqle.getMessage(), sqle);\r\n        abortTransaction = true;\r\n    } finally {\r\n        DbConnectionManager.closeStatement(pstmt);\r\n        DbConnectionManager.closeTransactionConnection(con, abortTransaction);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.writeLongArray",
	"Comment": "writes an array of long values. this method handles the case when thearray is null.",
	"Method": "void writeLongArray(DataOutput out,long[] array){\r\n    strategy.writeLongArray(out, array);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.multiplex.ConnectionMultiplexerManager.createClientSession",
	"Comment": "creates a new client session that was established to the specified connection manager.the new session will not be findable through its stream id.",
	"Method": "boolean createClientSession(String connectionManagerDomain,StreamID streamID,String hostName,String hostAddress){\r\n    Connection connection = new ClientSessionConnection(connectionManagerDomain, hostName, hostAddress);\r\n    byte[] address = null;\r\n    try {\r\n        address = connection.getAddress();\r\n    } catch (UnknownHostException e) {\r\n    }\r\n    if (address == null || LocalClientSession.isAllowed(connection)) {\r\n        LocalClientSession session = SessionManager.getInstance().createClientSession(connection, streamID);\r\n        streamIDs.put(streamID, connectionManagerDomain);\r\n        Map<StreamID, LocalClientSession> sessions = sessionsByManager.get(connectionManagerDomain);\r\n        if (sessions == null) {\r\n            synchronized (connectionManagerDomain.intern()) {\r\n                sessions = sessionsByManager.get(connectionManagerDomain);\r\n                if (sessions == null) {\r\n                    sessions = new ConcurrentHashMap();\r\n                    sessionsByManager.put(connectionManagerDomain, sessions);\r\n                }\r\n            }\r\n        }\r\n        sessions.put(streamID, session);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.mitre.oauth2.web.AuthenticationUtilities.ensureOAuthScope",
	"Comment": "makes sure the authentication contains the given scope, throws an exception otherwise",
	"Method": "void ensureOAuthScope(Authentication auth,String scope){\r\n    if (auth instanceof OAuth2Authentication) {\r\n        OAuth2Authentication oAuth2Authentication = (OAuth2Authentication) auth;\r\n        if (oAuth2Authentication.getOAuth2Request().getScope() == null || !oAuth2Authentication.getOAuth2Request().getScope().contains(scope)) {\r\n            throw new InsufficientScopeException(\"Insufficient scope\", ImmutableSet.of(scope));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.UpdateManager.setProxyHost",
	"Comment": "sets the host of the proxy to use to connect to igniterealtime.org or nullif no proxy is used.",
	"Method": "void setProxyHost(String host){\r\n    if (host == null) {\r\n        JiveGlobals.deleteProperty(\"update.proxy.host\");\r\n    } else {\r\n        JiveGlobals.setProperty(\"update.proxy.host\", host);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.Group.getJID",
	"Comment": "returns a jid for the group based on the group name. thisinstance will be of class groupjid to distinguish it fromother types of jids in the system.this method is synchronized to ensure each group has onlya single jid instance created via lazy instantiation.",
	"Method": "GroupJID getJID(){\r\n    if (jid == null) {\r\n        jid = new GroupJID(getName());\r\n    }\r\n    return jid;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.streammanagement.StreamManager.isEnabled",
	"Comment": "determines whether stream management enabled for session thismanager belongs to.",
	"Method": "boolean isEnabled(){\r\n    return namespace != null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.LegacyConnectionAcceptor.stop",
	"Comment": "stops this acceptor by unbinding the socket acceptor. does nothing when the instance is not started.",
	"Method": "void stop(){\r\n    if (socketAcceptThread != null) {\r\n        try {\r\n            socketAcceptThread.shutdown();\r\n        } finally {\r\n            socketAcceptThread = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.setDataformXSLT",
	"Comment": "sets the url of an xsl transformation which can be applied to the payload formatin order to generate a valid data forms result that the client could displayusing a generic data forms rendering engine.",
	"Method": "void setDataformXSLT(String dataformXSLT){\r\n    this.dataformXSLT = dataformXSLT;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.server.OutgoingServerSocketReader.getSession",
	"Comment": "returns the outgoingserversession for which this reader is working for or null ifa outgoingserversession was not created yet. while the outgoingserversession is beingcreated it is possible to have a reader with no session.",
	"Method": "OutgoingServerSession getSession(){\r\n    return session;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.getConfigurationForm",
	"Comment": "returns a data form with the subscription configuration. the data form can be used toedit the subscription configuration.",
	"Method": "DataForm getConfigurationForm(){\r\n    DataForm form = new DataForm(DataForm.Type.form);\r\n    form.setTitle(LocaleUtils.getLocalizedString(\"pubsub.form.subscription.title\"));\r\n    List<String> params = new ArrayList();\r\n    params.add(node.getNodeID());\r\n    form.addInstruction(LocaleUtils.getLocalizedString(\"pubsub.form.subscription.instruction\", params));\r\n    FormField formField = form.addField();\r\n    formField.setVariable(\"FORM_TYPE\");\r\n    formField.setType(FormField.Type.hidden);\r\n    formField.addValue(\"http://jabber.org/protocol/pubsub#subscribe_options\");\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#deliver\");\r\n    formField.setType(FormField.Type.boolean_type);\r\n    formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.subscription.deliver\"));\r\n    formField.addValue(deliverNotifications);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#digest\");\r\n    formField.setType(FormField.Type.boolean_type);\r\n    formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.subscription.digest\"));\r\n    formField.addValue(usingDigest);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#digest_frequency\");\r\n    formField.setType(FormField.Type.text_single);\r\n    formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.subscription.digest_frequency\"));\r\n    formField.addValue(digestFrequency);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#expire\");\r\n    formField.setType(FormField.Type.text_single);\r\n    formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.subscription.expire\"));\r\n    if (expire != null) {\r\n        formField.addValue(XMPPDateTimeFormat.format(expire));\r\n    }\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#include_body\");\r\n    formField.setType(FormField.Type.boolean_type);\r\n    formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.subscription.include_body\"));\r\n    formField.addValue(includingBody);\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#show-values\");\r\n    formField.setType(FormField.Type.list_multi);\r\n    formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.subscription.show-values\"));\r\n    formField.addOption(null, Presence.Show.away.name());\r\n    formField.addOption(null, Presence.Show.chat.name());\r\n    formField.addOption(null, Presence.Show.dnd.name());\r\n    formField.addOption(null, \"online\");\r\n    formField.addOption(null, Presence.Show.xa.name());\r\n    for (String value : presenceStates) {\r\n        formField.addValue(value);\r\n    }\r\n    if (node.isCollectionNode()) {\r\n        formField = form.addField();\r\n        formField.setVariable(\"pubsub#subscription_type\");\r\n        formField.setType(FormField.Type.list_single);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.subscription.subscription_type\"));\r\n        formField.addOption(null, Type.items.name());\r\n        formField.addOption(null, Type.nodes.name());\r\n        formField.addValue(type);\r\n        formField = form.addField();\r\n        formField.setVariable(\"pubsub#subscription_depth\");\r\n        formField.setType(FormField.Type.list_single);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.subscription.subscription_depth\"));\r\n        formField.addOption(null, \"1\");\r\n        formField.addOption(null, \"all\");\r\n        formField.addValue(depth == 1 ? \"1\" : \"all\");\r\n    }\r\n    if (!node.isCollectionNode() || type == Type.items) {\r\n        formField = form.addField();\r\n        formField.setVariable(\"x-pubsub#keywords\");\r\n        formField.setType(FormField.Type.text_single);\r\n        formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.subscription.keywords\"));\r\n        if (keyword != null) {\r\n            formField.addValue(keyword);\r\n        }\r\n    }\r\n    return form;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getPresenceUpdateHandler",
	"Comment": "returns the presenceupdatehandler registered with this server. thepresenceupdatehandler was registered with the server as a module while startingup the server.",
	"Method": "PresenceUpdateHandler getPresenceUpdateHandler(){\r\n    return (PresenceUpdateHandler) modules.get(PresenceUpdateHandler.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.startModules",
	"Comment": "following the loading and initialization of all the modulesthis method is called to iterate through the known modules andstart them.",
	"Method": "void startModules(){\r\n    for (Module module : modules.values()) {\r\n        try {\r\n            logger.debug(\"Starting module: \" + module.getName());\r\n            module.start();\r\n        } catch (Exception e) {\r\n            logger.error(\"An exception occurred while starting module '{}'.\", module.getName(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.cluster.ClusterManager.startup",
	"Comment": "starts the cluster service if clustering is enabled. the process of starting clusteringwill recreate caches as distributed caches.",
	"Method": "void startup(){\r\n    if (isClusteringEnabled() && !isClusteringStarted()) {\r\n        initEventDispatcher();\r\n        CacheFactory.startClustering();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.userBroadcast",
	"Comment": "broadcasts the given data to all connected sessions for a particularuser. excellent for updating all connected resources for users such asroster pushes.",
	"Method": "void userBroadcast(String username,Packet packet){\r\n    for (JID address : routingTable.getRoutes(new JID(username, serverName, null), null)) {\r\n        packet.setTo(address);\r\n        routingTable.routePacket(address, packet, true);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.Update.setDownloaded",
	"Comment": "sets if the plugin was downloaded. once a plugin has been downloadedit may take a couple of seconds to be installed. this flag only makes sense forplugins since we currently do not support download new openfire releases.",
	"Method": "void setDownloaded(boolean downloaded){\r\n    this.downloaded = downloaded;\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.setConnectionTimeout",
	"Comment": "sets the amount of time between connection recycles in days. forexample, a value of .5 would correspond to recycling the connectionsin the pool once every half day.",
	"Method": "void setConnectionTimeout(double connectionTimeout){\r\n    this.connectionTimeout = connectionTimeout;\r\n    saveProperties();\r\n}"
}, {
	"Path": "org.jivesoftware.util.EmailService.getPort",
	"Comment": "returns the port number used when connecting to the smtp server. the defaultport is 25.",
	"Method": "int getPort(){\r\n    return port;\r\n}"
}, {
	"Path": "org.jivesoftware.database.ProfiledConnection.getQueryCount",
	"Comment": "returns the total number database queries of a particular type performed.valid types are profiledconnection.select, profiledconnection.update,profiledconnection.insert, and profiledconnection.delete.",
	"Method": "long getQueryCount(Type type){\r\n    switch(type) {\r\n        case select:\r\n            return selectCount;\r\n        case update:\r\n            return updateCount;\r\n        case insert:\r\n            return insertCount;\r\n        case delete:\r\n            return deleteCount;\r\n        default:\r\n            throw new IllegalArgumentException(\"Invalid type\");\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.crowd.CrowdManager.authenticate",
	"Comment": "authenticates a user with crowd. if authentication failed, raises a remoteexception",
	"Method": "void authenticate(String username,String password){\r\n    username = JID.unescapeNode(username);\r\n    LOG.debug(\"authenticate '\" + String.valueOf(username) + \"'\");\r\n    final AuthenticatePost authenticatePost = new AuthenticatePost();\r\n    authenticatePost.value = password;\r\n    final StringWriter writer = new StringWriter();\r\n    JAXB.marshal(authenticatePost, writer);\r\n    final HttpUriRequest postRequest = RequestBuilder.post(crowdServer.resolve(\"authentication?username=\" + urlEncode(username))).setConfig(requestConfig).setEntity(new StringEntity(writer.toString(), StandardCharsets.UTF_8)).setHeader(HEADER_CONTENT_TYPE_APPLICATION_XML).build();\r\n    try (final CloseableHttpResponse response = client.execute(postRequest, clientContext)) {\r\n        if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {\r\n            handleHTTPError(response);\r\n        }\r\n    } catch (IOException ioe) {\r\n        handleError(ioe);\r\n    }\r\n    LOG.info(\"authenticated user:\" + username);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getMediaProxyService",
	"Comment": "returns the mediaproxyservice registered with this server. themediaproxyservice was registered with the server as a module while starting upthe server.",
	"Method": "MediaProxyService getMediaProxyService(){\r\n    return (MediaProxyService) modules.get(MediaProxyService.class);\r\n}"
}, {
	"Path": "org.mitre.jwt.encryption.service.impl.DefaultJWTEncryptionAndDecryptionService.buildEncryptersAndDecrypters",
	"Comment": "builds all the encrypters and decrypters for this service based on the key map.",
	"Method": "void buildEncryptersAndDecrypters(){\r\n    for (Map.Entry<String, JWK> jwkEntry : keys.entrySet()) {\r\n        String id = jwkEntry.getKey();\r\n        JWK jwk = jwkEntry.getValue();\r\n        if (jwk instanceof RSAKey) {\r\n            RSAEncrypter encrypter = new RSAEncrypter((RSAKey) jwk);\r\n            encrypter.getJCAContext().setProvider(BouncyCastleProviderSingleton.getInstance());\r\n            encrypters.put(id, encrypter);\r\n            if (jwk.isPrivate()) {\r\n                RSADecrypter decrypter = new RSADecrypter((RSAKey) jwk);\r\n                decrypter.getJCAContext().setProvider(BouncyCastleProviderSingleton.getInstance());\r\n                decrypters.put(id, decrypter);\r\n            } else {\r\n                logger.warn(\"No private key for key #\" + jwk.getKeyID());\r\n            }\r\n        } else if (jwk instanceof ECKey) {\r\n            ECDHEncrypter encrypter = new ECDHEncrypter((ECKey) jwk);\r\n            encrypter.getJCAContext().setProvider(BouncyCastleProviderSingleton.getInstance());\r\n            encrypters.put(id, encrypter);\r\n            if (jwk.isPrivate()) {\r\n                ECDHDecrypter decrypter = new ECDHDecrypter((ECKey) jwk);\r\n                decrypter.getJCAContext().setProvider(BouncyCastleProviderSingleton.getInstance());\r\n                decrypters.put(id, decrypter);\r\n            } else {\r\n                logger.warn(\"No private key for key # \" + jwk.getKeyID());\r\n            }\r\n        } else if (jwk instanceof OctetSequenceKey) {\r\n            DirectEncrypter encrypter = new DirectEncrypter((OctetSequenceKey) jwk);\r\n            encrypter.getJCAContext().setProvider(BouncyCastleProviderSingleton.getInstance());\r\n            DirectDecrypter decrypter = new DirectDecrypter((OctetSequenceKey) jwk);\r\n            decrypter.getJCAContext().setProvider(BouncyCastleProviderSingleton.getInstance());\r\n            encrypters.put(id, encrypter);\r\n            decrypters.put(id, decrypter);\r\n        } else {\r\n            logger.warn(\"Unknown key type: \" + jwk);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getIQHandlers",
	"Comment": "returns a list with all the modules registered with the server that inherit from iqhandler.",
	"Method": "List<IQHandler> getIQHandlers(){\r\n    List<IQHandler> answer = new ArrayList();\r\n    for (Module module : modules.values()) {\r\n        if (module instanceof IQHandler) {\r\n            answer.add((IQHandler) module);\r\n        }\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.getConfigurationForm",
	"Comment": "returns a data form used by the owner to edit the node configuration.",
	"Method": "DataForm getConfigurationForm(){\r\n    DataForm form = new DataForm(DataForm.Type.form);\r\n    form.setTitle(LocaleUtils.getLocalizedString(\"pubsub.form.conf.title\"));\r\n    List<String> params = new ArrayList();\r\n    params.add(getNodeID());\r\n    form.addInstruction(LocaleUtils.getLocalizedString(\"pubsub.form.conf.instruction\", params));\r\n    FormField formField = form.addField();\r\n    formField.setVariable(\"FORM_TYPE\");\r\n    formField.setType(FormField.Type.hidden);\r\n    formField.addValue(\"http://jabber.org/protocol/pubsub#node_config\");\r\n    addFormFields(form, true);\r\n    return form;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getActiveSessionCount",
	"Comment": "returns the number of sessions for a user that are available. for the countof all sessions for the user, including sessions that are just startingor closed.",
	"Method": "int getActiveSessionCount(String username){\r\n    return routingTable.getRoutes(new JID(username, serverName, null, true), null).size();\r\n}"
}, {
	"Path": "org.mitre.openid.connect.model.OIDCAuthenticationToken.getPrincipal",
	"Comment": "get the principal of this object, an immutable map of the subject and issuer.",
	"Method": "Object getPrincipal(){\r\n    return principal;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.setPresenceBasedDelivery",
	"Comment": "sets if notifications are going to be delivered only to available users.",
	"Method": "void setPresenceBasedDelivery(boolean presenceBasedDelivery){\r\n    this.presenceBasedDelivery = presenceBasedDelivery;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MUCPersistenceManager.loadFromDB",
	"Comment": "loads the room configuration from the database if the room was persistent.",
	"Method": "void loadFromDB(LocalMUCRoom room){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        Long serviceID = XMPPServer.getInstance().getMultiUserChatManager().getMultiUserChatServiceID(room.getMUCService().getServiceName());\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(LOAD_ROOM);\r\n        pstmt.setLong(1, serviceID);\r\n        pstmt.setString(2, room.getName());\r\n        rs = pstmt.executeQuery();\r\n        if (!rs.next()) {\r\n            throw new IllegalArgumentException(\"Room \" + room.getName() + \" was not found in the database.\");\r\n        }\r\n        room.setID(rs.getLong(1));\r\n        room.setCreationDate(new Date(Long.parseLong(rs.getString(2).trim())));\r\n        room.setModificationDate(new Date(Long.parseLong(rs.getString(3).trim())));\r\n        room.setNaturalLanguageName(rs.getString(4));\r\n        room.setDescription(rs.getString(5));\r\n        room.setLockedDate(new Date(Long.parseLong(rs.getString(6).trim())));\r\n        if (rs.getString(7) != null) {\r\n            room.setEmptyDate(new Date(Long.parseLong(rs.getString(7).trim())));\r\n        } else {\r\n            room.setEmptyDate(null);\r\n        }\r\n        room.setCanOccupantsChangeSubject(rs.getInt(8) == 1);\r\n        room.setMaxUsers(rs.getInt(9));\r\n        room.setPublicRoom(rs.getInt(10) == 1);\r\n        room.setModerated(rs.getInt(11) == 1);\r\n        room.setMembersOnly(rs.getInt(12) == 1);\r\n        room.setCanOccupantsInvite(rs.getInt(13) == 1);\r\n        room.setPassword(rs.getString(14));\r\n        room.setCanAnyoneDiscoverJID(rs.getInt(15) == 1);\r\n        room.setLogEnabled(rs.getInt(16) == 1);\r\n        room.setSubject(rs.getString(17));\r\n        List<String> rolesToBroadcast = new ArrayList();\r\n        String roles = StringUtils.zeroPadString(Integer.toBinaryString(rs.getInt(18)), 3);\r\n        if (roles.charAt(0) == '1') {\r\n            rolesToBroadcast.add(\"moderator\");\r\n        }\r\n        if (roles.charAt(1) == '1') {\r\n            rolesToBroadcast.add(\"participant\");\r\n        }\r\n        if (roles.charAt(2) == '1') {\r\n            rolesToBroadcast.add(\"visitor\");\r\n        }\r\n        room.setRolesToBroadcastPresence(rolesToBroadcast);\r\n        room.setLoginRestrictedToNickname(rs.getInt(19) == 1);\r\n        room.setChangeNickname(rs.getInt(20) == 1);\r\n        room.setRegistrationEnabled(rs.getInt(21) == 1);\r\n        switch(rs.getInt(22)) {\r\n            default:\r\n            case 0:\r\n                room.setCanSendPrivateMessage(\"anyone\");\r\n                break;\r\n            case 1:\r\n                room.setCanSendPrivateMessage(\"participants\");\r\n                break;\r\n            case 2:\r\n                room.setCanSendPrivateMessage(\"moderators\");\r\n                break;\r\n            case 3:\r\n                room.setCanSendPrivateMessage(\"none\");\r\n                break;\r\n        }\r\n        room.setPersistent(true);\r\n        DbConnectionManager.fastcloseStmt(rs, pstmt);\r\n        if (room.isLogEnabled()) {\r\n            pstmt = con.prepareStatement(LOAD_HISTORY);\r\n            int reloadLimitDays = JiveGlobals.getIntProperty(MUC_HISTORY_RELOAD_LIMIT, 2);\r\n            long from = System.currentTimeMillis() - (BigInteger.valueOf(86400000).multiply(BigInteger.valueOf(reloadLimitDays))).longValue();\r\n            pstmt.setString(1, StringUtils.dateToMillis(new Date(from)));\r\n            pstmt.setLong(2, room.getID());\r\n            rs = pstmt.executeQuery();\r\n            while (rs.next()) {\r\n                String senderJID = rs.getString(1);\r\n                String nickname = rs.getString(2);\r\n                Date sentDate = new Date(Long.parseLong(rs.getString(3).trim()));\r\n                String subject = rs.getString(4);\r\n                String body = rs.getString(5);\r\n                String stanza = rs.getString(6);\r\n                room.getRoomHistory().addOldMessage(senderJID, nickname, sentDate, subject, body, stanza);\r\n            }\r\n        }\r\n        DbConnectionManager.fastcloseStmt(rs, pstmt);\r\n        if (!room.getRoomHistory().hasChangedSubject() && room.getSubject() != null && room.getSubject().length() > 0) {\r\n            room.getRoomHistory().addOldMessage(room.getRole().getRoleAddress().toString(), null, room.getModificationDate(), room.getSubject(), null, null);\r\n        }\r\n        pstmt = con.prepareStatement(LOAD_AFFILIATIONS);\r\n        pstmt.setLong(1, room.getID());\r\n        rs = pstmt.executeQuery();\r\n        while (rs.next()) {\r\n            JID affiliationJID = GroupJID.fromString(rs.getString(1));\r\n            MUCRole.Affiliation affiliation = MUCRole.Affiliation.valueOf(rs.getInt(2));\r\n            try {\r\n                switch(affiliation) {\r\n                    case owner:\r\n                        room.addOwner(affiliationJID, room.getRole());\r\n                        break;\r\n                    case admin:\r\n                        room.addAdmin(affiliationJID, room.getRole());\r\n                        break;\r\n                    case outcast:\r\n                        room.addOutcast(affiliationJID, null, room.getRole());\r\n                        break;\r\n                    default:\r\n                        Log.error(\"Unkown affiliation value \" + affiliation + \" for user \" + affiliationJID.toBareJID() + \" in persistent room \" + room.getID());\r\n                }\r\n            } catch (Exception e) {\r\n                Log.error(e.getMessage(), e);\r\n            }\r\n        }\r\n        DbConnectionManager.fastcloseStmt(rs, pstmt);\r\n        pstmt = con.prepareStatement(LOAD_MEMBERS);\r\n        pstmt.setLong(1, room.getID());\r\n        rs = pstmt.executeQuery();\r\n        while (rs.next()) {\r\n            try {\r\n                room.addMember(new JID(rs.getString(1)), rs.getString(2), room.getRole());\r\n            } catch (Exception e) {\r\n                Log.error(e.getMessage(), e);\r\n            }\r\n        }\r\n        room.setSavedToDB(true);\r\n        if (room.getEmptyDate() == null) {\r\n            room.setEmptyDate(new Date());\r\n        }\r\n    } catch (SQLException sqle) {\r\n        Log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.handler.IQBlockingHandler.getBlocklist",
	"Comment": "retrieves all of the jids that are on the blocklist of the provided user.",
	"Method": "Set<JID> getBlocklist(User user){\r\n    Log.debug(\"Retrieving all JIDs that are on the blocklist of user '{}'.\", user.getUsername());\r\n    final PrivacyList defaultPrivacyList = PrivacyListManager.getInstance().getDefaultPrivacyList(user.getUsername());\r\n    if (defaultPrivacyList == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    return defaultPrivacyList.getBlockedJIDs();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.streammanagement.StreamManager.incrementServerProcessedStanzas",
	"Comment": "increments the count of stanzas processed by the server sincestream management was enabled.",
	"Method": "void incrementServerProcessedStanzas(){\r\n    if (isEnabled()) {\r\n        this.serverProcessedStanzas.incrementAndGet();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.admin.PluginFilter.removePluginFilter",
	"Comment": "removes a filter that is applied to a certain url.removing a filter does not destroy the plugin instance.",
	"Method": "void removePluginFilter(SimpleFilter filter,Filter removePluginFilter,String filterUrl,String filterClassName){\r\n    if (filterUrl == null || filterUrl.isEmpty() || filterClassName == null || filterClassName.isEmpty()) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    Filter result = null;\r\n    if (filters.containsKey(filterUrl)) {\r\n        final List<Filter> urlFilters = PluginFilter.filters.get(filterUrl);\r\n        final Iterator<Filter> iterator = urlFilters.iterator();\r\n        while (iterator.hasNext()) {\r\n            final Filter filter = iterator.next();\r\n            if (filter.getClass().getName().equals(filterClassName)) {\r\n                iterator.remove();\r\n                result = filter;\r\n            }\r\n        }\r\n        if (urlFilters.isEmpty()) {\r\n            filters.remove(filterUrl);\r\n        }\r\n    }\r\n    if (result == null) {\r\n        Log.warn(\"Unable to removed filter of class '{}' for URL '{}'. No such filter is present.\", filterClassName, filterUrl);\r\n    } else {\r\n        Log.debug(\"Removed filter '{}' for URL '{}'\", result, filterUrl);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getConnectionMultiplexerSessions",
	"Comment": "returns a collection with all the sessions originated from the connection managerwhose domain matches the specified domain. if there is no connection manager withthe specified domain then an empty list is going to be returned.",
	"Method": "List<ConnectionMultiplexerSession> getConnectionMultiplexerSessions(List<ConnectionMultiplexerSession> getConnectionMultiplexerSessions,String domain){\r\n    List<ConnectionMultiplexerSession> sessions = new ArrayList();\r\n    for (String address : localSessionManager.getConnnectionManagerSessions().keySet()) {\r\n        JID jid = new JID(address);\r\n        if (domain.equals(jid.getDomain())) {\r\n            sessions.add(localSessionManager.getConnnectionManagerSessions().get(address));\r\n        }\r\n    }\r\n    RemoteSessionLocator locator = server.getRemoteSessionLocator();\r\n    if (locator != null) {\r\n        for (Map.Entry<String, byte[]> entry : multiplexerSessionsCache.entrySet()) {\r\n            if (!server.getNodeID().equals(entry.getValue())) {\r\n                JID jid = new JID(entry.getKey());\r\n                if (domain.equals(jid.getDomain())) {\r\n                    sessions.add(locator.getConnectionMultiplexerSession(entry.getValue(), new JID(entry.getKey())));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return sessions;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.getDataformXSLT",
	"Comment": "returns the url of an xsl transformation which can be applied to the payload formatin order to generate a valid data forms result that the client could displayusing a generic data forms rendering engine.",
	"Method": "String getDataformXSLT(){\r\n    return dataformXSLT;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.client.model.IssuerServiceResponse.shouldRedirect",
	"Comment": "if the redirect url has been set, then we should send a redirect using it instead of processing things.",
	"Method": "boolean shouldRedirect(){\r\n    return this.redirectUrl != null;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.audit.SessionEvent.createConnectEvent",
	"Comment": "create an event associated with the initial connectionof a session before the stream is created.",
	"Method": "SessionEvent createConnectEvent(Session session){\r\n    return new SessionEvent(session, SESSION_CONNECT, null);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.resultsetmanager.ResultSet.indexOf",
	"Comment": "returns the index in the full resultset of the supplied argument.",
	"Method": "int indexOf(String uid,int indexOf,E element){\r\n    return indexOf(element.getUID());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MultiUserChatServiceImpl.getChatUser",
	"Comment": "obtain a chat user by xmppaddress. only returns users that are connected to this jvm.",
	"Method": "MUCUser getChatUser(JID userjid,String roomName){\r\n    if (router == null) {\r\n        throw new IllegalStateException(\"Not initialized\");\r\n    }\r\n    LocalMUCUser user;\r\n    synchronized (userjid.toString().intern()) {\r\n        user = users.get(userjid);\r\n        if (user == null) {\r\n            if (roomName != null) {\r\n                LocalMUCRoom localMUCRoom = localMUCRoomManager.getRoom(roomName);\r\n                if (localMUCRoom != null) {\r\n                    MUCRole occupant = localMUCRoom.getOccupantByFullJID(userjid);\r\n                    if (occupant != null && !occupant.isLocal()) {\r\n                        return new RemoteMUCUser(userjid, localMUCRoom);\r\n                    }\r\n                }\r\n            }\r\n            user = new LocalMUCUser(this, router, userjid);\r\n            users.put(userjid, user);\r\n        }\r\n    }\r\n    return user;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.server.RemoteServerManager.getConfiguration",
	"Comment": "returns the configuration for a remote server or null if none was found.",
	"Method": "RemoteServerConfiguration getConfiguration(String domain){\r\n    Object value = configurationsCache.get(domain);\r\n    if (\"null\".equals(value)) {\r\n        return null;\r\n    }\r\n    RemoteServerConfiguration configuration = (RemoteServerConfiguration) value;\r\n    if (configuration == null) {\r\n        java.sql.Connection con = null;\r\n        PreparedStatement pstmt = null;\r\n        ResultSet rs = null;\r\n        try {\r\n            con = DbConnectionManager.getConnection();\r\n            pstmt = con.prepareStatement(LOAD_CONFIGURATION);\r\n            pstmt.setString(1, domain);\r\n            rs = pstmt.executeQuery();\r\n            while (rs.next()) {\r\n                configuration = new RemoteServerConfiguration(domain);\r\n                configuration.setRemotePort(rs.getInt(1));\r\n                configuration.setPermission(Permission.valueOf(rs.getString(2)));\r\n            }\r\n        } catch (SQLException sqle) {\r\n            Log.error(sqle.getMessage(), sqle);\r\n        } finally {\r\n            DbConnectionManager.closeConnection(rs, pstmt, con);\r\n        }\r\n        if (configuration != null) {\r\n            configurationsCache.put(domain, configuration);\r\n        } else {\r\n            configurationsCache.put(domain, \"null\");\r\n        }\r\n    }\r\n    return configuration;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ServerPort.isServerPort",
	"Comment": "returns true if other servers can connect to this port for s2s communication.",
	"Method": "boolean isServerPort(){\r\n    return type == Type.server;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheFactory.setMaxSizeProperty",
	"Comment": "sets a local property which overrides the maximum cache size for thesupplied cache name.",
	"Method": "void setMaxSizeProperty(String cacheName,long size){\r\n    cacheName = cacheName.replaceAll(\" \", \"\");\r\n    if (!Long.toString(size).equals(JiveGlobals.getProperty(\"cache.\" + cacheName + \".size\"))) {\r\n        JiveGlobals.setProperty(\"cache.\" + cacheName + \".size\", Long.toString(size));\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.ServerSocketReader.processIQ",
	"Comment": "processes the packet in another thread if the packet has not been rejected.",
	"Method": "void processIQ(IQ packet){\r\n    try {\r\n        packetReceived(packet);\r\n        try {\r\n            super.processIQ(packet);\r\n        } catch (UnauthorizedException e) {\r\n            Log.error(\"Error processing packet\", e);\r\n        }\r\n    } catch (PacketRejectedException e) {\r\n        Log.debug(\"IQ rejected: \" + packet.toXML(), e);\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.web.DynamicClientRegistrationEndpoint.registerNewClient",
	"Comment": "create a new client, issue a client id, and create a registration access token.",
	"Method": "String registerNewClient(String jsonString,Model m){\r\n    ClientDetailsEntity newClient = null;\r\n    try {\r\n        newClient = ClientDetailsEntityJsonProcessor.parse(jsonString);\r\n    } catch (JsonSyntaxException e) {\r\n        logger.error(\"registerNewClient failed; submitted JSON is malformed\");\r\n        m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\r\n        return HttpCodeView.VIEWNAME;\r\n    }\r\n    if (newClient != null) {\r\n        newClient.setClientId(null);\r\n        newClient.setClientSecret(null);\r\n        try {\r\n            newClient = validateSoftwareStatement(newClient);\r\n            newClient = validateScopes(newClient);\r\n            newClient = validateResponseTypes(newClient);\r\n            newClient = validateGrantTypes(newClient);\r\n            newClient = validateRedirectUris(newClient);\r\n            newClient = validateAuth(newClient);\r\n        } catch (ValidationException ve) {\r\n            m.addAttribute(JsonErrorView.ERROR, ve.getError());\r\n            m.addAttribute(JsonErrorView.ERROR_MESSAGE, ve.getErrorDescription());\r\n            m.addAttribute(HttpCodeView.CODE, ve.getStatus());\r\n            return JsonErrorView.VIEWNAME;\r\n        }\r\n        if (newClient.getTokenEndpointAuthMethod() == null) {\r\n            newClient.setTokenEndpointAuthMethod(AuthMethod.SECRET_BASIC);\r\n        }\r\n        if (newClient.getTokenEndpointAuthMethod() == AuthMethod.SECRET_BASIC || newClient.getTokenEndpointAuthMethod() == AuthMethod.SECRET_JWT || newClient.getTokenEndpointAuthMethod() == AuthMethod.SECRET_POST) {\r\n            newClient = clientService.generateClientSecret(newClient);\r\n        }\r\n        if (config.isHeartMode()) {\r\n            if (newClient.getGrantTypes().contains(\"authorization_code\")) {\r\n                newClient.setAccessTokenValiditySeconds((int) TimeUnit.HOURS.toSeconds(1));\r\n                newClient.setIdTokenValiditySeconds((int) TimeUnit.MINUTES.toSeconds(5));\r\n                newClient.setRefreshTokenValiditySeconds((int) TimeUnit.HOURS.toSeconds(24));\r\n            } else if (newClient.getGrantTypes().contains(\"implicit\")) {\r\n                newClient.setAccessTokenValiditySeconds((int) TimeUnit.MINUTES.toSeconds(15));\r\n                newClient.setIdTokenValiditySeconds((int) TimeUnit.MINUTES.toSeconds(5));\r\n                newClient.setRefreshTokenValiditySeconds(0);\r\n            } else if (newClient.getGrantTypes().contains(\"client_credentials\")) {\r\n                newClient.setAccessTokenValiditySeconds((int) TimeUnit.HOURS.toSeconds(6));\r\n                // no id tokens\r\n                newClient.setIdTokenValiditySeconds(0);\r\n                newClient.setRefreshTokenValiditySeconds(0);\r\n            }\r\n        } else {\r\n            newClient.setAccessTokenValiditySeconds((int) TimeUnit.HOURS.toSeconds(1));\r\n            newClient.setIdTokenValiditySeconds((int) TimeUnit.MINUTES.toSeconds(10));\r\n            newClient.setRefreshTokenValiditySeconds(null);\r\n        }\r\n        newClient.setDynamicallyRegistered(true);\r\n        newClient.setAllowIntrospection(false);\r\n        try {\r\n            ClientDetailsEntity savedClient = clientService.saveNewClient(newClient);\r\n            OAuth2AccessTokenEntity token = connectTokenService.createRegistrationAccessToken(savedClient);\r\n            token = tokenService.saveAccessToken(token);\r\n            RegisteredClient registered = new RegisteredClient(savedClient, token.getValue(), config.getIssuer() + \"register/\" + UriUtils.encodePathSegment(savedClient.getClientId(), \"UTF-8\"));\r\n            m.addAttribute(\"client\", registered);\r\n            // http 201\r\n            m.addAttribute(HttpCodeView.CODE, HttpStatus.CREATED);\r\n            return ClientInformationResponseView.VIEWNAME;\r\n        } catch (UnsupportedEncodingException e) {\r\n            logger.error(\"Unsupported encoding\", e);\r\n            m.addAttribute(HttpCodeView.CODE, HttpStatus.INTERNAL_SERVER_ERROR);\r\n            return HttpCodeView.VIEWNAME;\r\n        } catch (IllegalArgumentException e) {\r\n            logger.error(\"Couldn't save client\", e);\r\n            m.addAttribute(JsonErrorView.ERROR, \"invalid_client_metadata\");\r\n            m.addAttribute(JsonErrorView.ERROR_MESSAGE, \"Unable to save client due to invalid or inconsistent metadata.\");\r\n            m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\r\n            return JsonErrorView.VIEWNAME;\r\n        }\r\n    } else {\r\n        logger.error(\"registerNewClient failed; submitted JSON is malformed\");\r\n        m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\r\n        return HttpCodeView.VIEWNAME;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.createJID",
	"Comment": "creates an xmppaddress local to this server. the construction of the new jidcan be optimized by skipping stringprep operations.",
	"Method": "JID createJID(String username,String resource,JID createJID,String username,String resource,boolean skipStringprep){\r\n    return new JID(username, xmppServerInfo.getXMPPDomain(), resource, skipStringprep);\r\n}"
}, {
	"Path": "org.jivesoftware.admin.AdminConsole.getElemnetByID",
	"Comment": "convenience method to select an element from the model by its id. if anelement with a matching id is not found, null will be returned.",
	"Method": "Element getElemnetByID(String id){\r\n    return (Element) generatedModel.selectSingleNode(\"//*[@id='\" + id + \"']\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.filetransfer.proxy.ProxyConnectionManager.activate",
	"Comment": "activates the stream, this method should be called when the initiator sends the activatepacket after both parties have connected to the proxy.",
	"Method": "void activate(JID initiator,JID target,String sid){\r\n    final String digest = createDigest(sid, initiator, target);\r\n    ProxyTransfer temp;\r\n    synchronized (connectionLock) {\r\n        temp = connectionMap.get(digest);\r\n    }\r\n    final ProxyTransfer transfer = temp;\r\n    if (transfer == null || !transfer.isActivatable()) {\r\n        throw new IllegalArgumentException(\"Transfer doesn't exist or is missing parameters\");\r\n    }\r\n    transfer.setInitiator(initiator.toString());\r\n    transfer.setTarget(target.toString());\r\n    transfer.setSessionID(sid);\r\n    transfer.setTransferFuture(executor.submit(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                transferManager.fireFileTransferStart(transfer.getSessionID(), true);\r\n            } catch (FileTransferRejectedException e) {\r\n                notifyFailure(transfer, e);\r\n                return;\r\n            }\r\n            try {\r\n                transfer.doTransfer();\r\n                transferManager.fireFileTransferCompleted(transfer.getSessionID(), true);\r\n            } catch (IOException e) {\r\n                Log.error(\"Error during file transfer\", e);\r\n                transferManager.fireFileTransferCompleted(transfer.getSessionID(), false);\r\n            } finally {\r\n                connectionMap.remove(digest);\r\n            }\r\n        }\r\n    }));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.filetransfer.proxy.ProxyConnectionManager.activate",
	"Comment": "activates the stream, this method should be called when the initiator sends the activatepacket after both parties have connected to the proxy.",
	"Method": "void activate(JID initiator,JID target,String sid){\r\n    try {\r\n        transferManager.fireFileTransferStart(transfer.getSessionID(), true);\r\n    } catch (FileTransferRejectedException e) {\r\n        notifyFailure(transfer, e);\r\n        return;\r\n    }\r\n    try {\r\n        transfer.doTransfer();\r\n        transferManager.fireFileTransferCompleted(transfer.getSessionID(), true);\r\n    } catch (IOException e) {\r\n        Log.error(\"Error during file transfer\", e);\r\n        transferManager.fireFileTransferCompleted(transfer.getSessionID(), false);\r\n    } finally {\r\n        connectionMap.remove(digest);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.database.bugfix.OF1515.transform",
	"Comment": "transforms xml data storage records into pubsub node records",
	"Method": "List<PubsubRecordData> transform(List<PrivateXmlRecord> oldRecords){\r\n    Log.info(\"Transforming all data from Private XML Storage into Pubsub entities.\");\r\n    String domain;\r\n    try {\r\n        domain = JiveGlobals.getProperty(\"xmpp.domain\", JiveGlobals.getXMLProperty(\"fqdn\", InetAddress.getLocalHost().getCanonicalHostName())).toLowerCase();\r\n    } catch (UnknownHostException e) {\r\n        domain = \"localhost\";\r\n    }\r\n    final List<PubsubRecordData> result = new ArrayList();\r\n    for (final PrivateXmlRecord oldRecord : oldRecords) {\r\n        final PubsubRecordData newRecord = new PubsubRecordData(oldRecord.username + '@' + domain, oldRecord.namespace, oldRecord.privateData);\r\n        result.add(newRecord);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.GroupManager.getSharedGroups",
	"Comment": "returns an unmodifiable collection of all shared groups in the system for a given username.",
	"Method": "Collection<Group> getSharedGroups(Collection<Group> getSharedGroups,String userName){\r\n    HashSet<String> groupNames = getSharedGroupsForUserFromCache(userName);\r\n    if (groupNames == null) {\r\n        synchronized ((userName + MUTEX_SUFFIX_USER).intern()) {\r\n            groupNames = getSharedGroupsForUserFromCache(userName);\r\n            if (groupNames == null) {\r\n                groupNames = new HashSet(provider.getSharedGroupNames(new JID(userName, XMPPServer.getInstance().getServerInfo().getXMPPDomain(), null)));\r\n                saveSharedGroupsForUserInCache(userName, groupNames);\r\n            }\r\n        }\r\n    }\r\n    return new GroupCollection(groupNames);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSessionManager.createSession",
	"Comment": "creates an http binding session which will allow a user to exchange packets with openfire.",
	"Method": "HttpSession createSession(InetAddress address,Element rootNode,HttpConnection connection,HttpSession createSession,long rid,InetAddress address,HttpConnection connection,Locale language){\r\n    StreamID streamID = SessionManager.getInstance().nextStreamID();\r\n    HttpSession session = sessionManager.createClientHttpSession(rid, address, streamID, connection, language);\r\n    sessionMap.put(streamID.getID(), session);\r\n    session.addSessionCloseListener(sessionListener);\r\n    return session;\r\n}"
}, {
	"Path": "org.jivesoftware.util.XMLProperties.removeFromList",
	"Comment": "removes the given value from the list of values represented by the property name.the property is deleted if it no longer contains any values.",
	"Method": "boolean removeFromList(String propertyName,String value){\r\n    List<String> properties = getProperties(propertyName, true);\r\n    boolean propertyWasRemoved = properties.remove(value);\r\n    if (propertyWasRemoved) {\r\n        setProperties(propertyName, properties);\r\n    }\r\n    return propertyWasRemoved;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.interceptor.InterceptorManager.getInterceptors",
	"Comment": "returns an unmodifiable list of global packet interceptors. globalinterceptors are applied to all packets read and sent by the server.",
	"Method": "List<PacketInterceptor> getInterceptors(){\r\n    return Collections.unmodifiableList(globalInterceptors);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.DefaultGroupPropertyMap.updateProperty",
	"Comment": "update the value of an existing group property for the current group",
	"Method": "void updateProperty(String key,String value,String originalValue){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(UPDATE_PROPERTY);\r\n        pstmt.setString(1, value);\r\n        pstmt.setString(2, key);\r\n        pstmt.setString(3, group.getName());\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException e) {\r\n        logger.error(e.getMessage(), e);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n    Map<String, Object> event = new HashMap();\r\n    event.put(\"propertyKey\", key);\r\n    event.put(\"type\", \"propertyModified\");\r\n    event.put(\"originalValue\", originalValue);\r\n    GroupEventDispatcher.dispatchEvent(group, GroupEventDispatcher.EventType.group_modified, event);\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheFactory.joinedCluster",
	"Comment": "notification message indicating that this jvm has joined a cluster.",
	"Method": "void joinedCluster(){\r\n    cacheFactoryStrategy = clusteredCacheFactoryStrategy;\r\n    for (Cache cache : getAllCaches()) {\r\n        if (localOnly.contains(cache.getName()))\r\n            continue;\r\n        CacheWrapper cacheWrapper = ((CacheWrapper) cache);\r\n        Cache clusteredCache = cacheFactoryStrategy.createCache(cacheWrapper.getName());\r\n        clusteredCache.putAll(cache);\r\n        cacheWrapper.setWrappedCache(clusteredCache);\r\n    }\r\n    clusteringStarting = false;\r\n    clusteringStarted = true;\r\n    log.info(\"Clustering started; cache migration complete\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.forwardRequest",
	"Comment": "forwards a client request, which is related to a session, to the server. a connection iscreated and queued up in the provided session. when a connection reaches the top of a queueany pending packets bound for the client will be forwarded to the client through theconnection.",
	"Method": "void forwardRequest(long rid,boolean isSecure,Element rootNode,AsyncContext context){\r\n    List<Element> elements = rootNode.elements();\r\n    boolean isPoll = (elements.size() == 0);\r\n    if (\"terminate\".equals(rootNode.attributeValue(\"type\")))\r\n        isPoll = false;\r\n    else if (\"true\".equals(rootNode.attributeValue(new QName(\"restart\", rootNode.getNamespaceForPrefix(\"xmpp\")))))\r\n        isPoll = false;\r\n    else if (rootNode.attributeValue(\"pause\") != null)\r\n        isPoll = false;\r\n    HttpConnection connection = this.createConnection(rid, isSecure, isPoll, context);\r\n    if (elements.size() > 0) {\r\n        packetsToSend.add(elements);\r\n        new HttpPacketSender(this).init();\r\n    }\r\n    final String type = rootNode.attributeValue(\"type\");\r\n    String restartStream = rootNode.attributeValue(new QName(\"restart\", rootNode.getNamespaceForPrefix(\"xmpp\")));\r\n    int pauseDuration = HttpBindServlet.getIntAttribute(rootNode.attributeValue(\"pause\"), -1);\r\n    if (\"terminate\".equals(type)) {\r\n        connection.deliverBody(createEmptyBody(true), true);\r\n        close();\r\n        lastRequestID = connection.getRequestId();\r\n    } else if (\"true\".equals(restartStream) && rootNode.elements().size() == 0) {\r\n        connection.deliverBody(createSessionRestartResponse(), true);\r\n        lastRequestID = connection.getRequestId();\r\n    } else if (pauseDuration > 0 && pauseDuration <= getMaxPause()) {\r\n        pause(pauseDuration);\r\n        connection.deliverBody(createEmptyBody(false), true);\r\n        lastRequestID = connection.getRequestId();\r\n        setLastResponseEmpty(true);\r\n    } else {\r\n        resetInactivityTimeout();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.setNodeID",
	"Comment": "sets an id that uniquely identifies this server in a cluster. when not running in cluster modethe returned value is always the same. however, when in cluster mode the value should be setwhen joining the cluster and must be unique even upon restarts of this node.",
	"Method": "void setNodeID(NodeID nodeID){\r\n    this.nodeID = nodeID;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalIncomingServerSession.getValidatedDomains",
	"Comment": "returns a collection with all the domains, subdomains and virtual hosts that wherevalidated. the remote server is allowed to send packets from any of these domains,subdomains and virtual hosts.",
	"Method": "Collection<String> getValidatedDomains(){\r\n    return Collections.unmodifiableCollection(validatedDomains);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getOfflineMessageStore",
	"Comment": "returns the offlinemessagestore registered with this server. theofflinemessagestore was registered with the server as a module while starting upthe server.",
	"Method": "OfflineMessageStore getOfflineMessageStore(){\r\n    return (OfflineMessageStore) modules.get(OfflineMessageStore.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sip.calllog.CallLogDAO.getCalls",
	"Comment": "return every stored calls that matches to the sqlcondition in the interval between startindex and endindex",
	"Method": "Collection<CallLog> getCalls(CallFilter filter,int startIndex,int numResults,Collection<CallLog> getCalls,int startIndex,int numResults){\r\n    return getCalls(emptyFilter, startIndex, numResults);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.PresenceEventDispatcher.unavailableSession",
	"Comment": "notification message indicating that a session that was available is no longeravailable. a session becomes unavailable when an unavailable presence is received.the entity may still be connected to the server and may send an available presencelater to indicate that communication can proceed.",
	"Method": "void unavailableSession(ClientSession session,Presence presence){\r\n    if (!listeners.isEmpty()) {\r\n        for (PresenceEventListener listener : listeners) {\r\n            listener.unavailableSession(session, presence);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.UserManager.getUsers",
	"Comment": "returns an unmodifiable collection of all users starting at startindexwith the given number of results. this is useful to support pagination in a guiwhere you may only want to display a certain number of results per page. it ispossible that the number of results returned will be less than that specifiedby numresults if numresults is greater than the number ofrecords left to display.",
	"Method": "Collection<User> getUsers(Collection<User> getUsers,int startIndex,int numResults){\r\n    return provider.getUsers(startIndex, numResults);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapVCardProvider.getLdapAttributes",
	"Comment": "creates a mapping of requested ldap attributes to their values for the given user.",
	"Method": "Map<String, String> getLdapAttributes(String username){\r\n    username = JID.unescapeNode(username);\r\n    Map<String, String> map = new HashMap();\r\n    DirContext ctx = null;\r\n    try {\r\n        String userDN = manager.findUserDN(username);\r\n        ctx = manager.getContext(manager.getUsersBaseDN(username));\r\n        Attributes attrs = ctx.getAttributes(userDN, template.getAttributes());\r\n        for (String attribute : template.getAttributes()) {\r\n            javax.naming.directory.Attribute attr = attrs.get(attribute);\r\n            String value;\r\n            if (attr == null) {\r\n                Log.debug(\"LdapVCardProvider: No ldap value found for attribute '\" + attribute + \"'\");\r\n                value = \"\";\r\n            } else {\r\n                Object ob = attrs.get(attribute).get();\r\n                Log.debug(\"LdapVCardProvider: Found attribute \" + attribute + \" of type: \" + ob.getClass());\r\n                if (ob instanceof String) {\r\n                    value = (String) ob;\r\n                } else {\r\n                    value = Base64.encodeBytes((byte[]) ob);\r\n                }\r\n            }\r\n            Log.debug(\"LdapVCardProvider: Ldap attribute '\" + attribute + \"'=>'\" + value + \"'\");\r\n            map.put(attribute, value);\r\n        }\r\n        return map;\r\n    } catch (Exception e) {\r\n        Log.error(e.getMessage(), e);\r\n        return Collections.emptyMap();\r\n    } finally {\r\n        try {\r\n            if (ctx != null) {\r\n                ctx.close();\r\n            }\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.isNotifyDelete",
	"Comment": "returns true if subscribers are going to be notified when node is deleted.",
	"Method": "boolean isNotifyDelete(){\r\n    return notifyDelete;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.component.ExternalComponentManager.addConfiguration",
	"Comment": "adds a new permission for the specified external component.",
	"Method": "void addConfiguration(ExternalComponentConfiguration configuration){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(ADD_CONFIGURATION);\r\n        pstmt.setString(1, configuration.getSubdomain() + (configuration.isWildcard() ? \"%\" : \"\"));\r\n        pstmt.setInt(2, configuration.isWildcard() ? 1 : 0);\r\n        pstmt.setString(3, configuration.getSecret());\r\n        pstmt.setString(4, configuration.getPermission().toString());\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException sqle) {\r\n        Log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.ServerTrafficCounter.wrapWritableChannel",
	"Comment": "wraps the specified writable channel to count the number of bytes that were written.",
	"Method": "WritableByteChannel wrapWritableChannel(WritableByteChannel originalChannel){\r\n    return new WritableByteChannelWrapper(originalChannel);\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.writeSerializableMap",
	"Comment": "writes a map of serializable key and value pairs. this method handles thecase when the map is null.",
	"Method": "void writeSerializableMap(DataOutput out,Map<? extends Serializable, ? extends Serializable> map){\r\n    strategy.writeSerializableMap(out, map);\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.formatDate",
	"Comment": "formats a date object to return a date using the global locale.",
	"Method": "String formatDate(Date date){\r\n    if (dateFormat == null) {\r\n        if (properties != null) {\r\n            dateFormat = DateFormat.getDateInstance(DateFormat.MEDIUM, getLocale());\r\n            dateFormat.setTimeZone(getTimeZone());\r\n        } else {\r\n            DateFormat instance = DateFormat.getDateInstance(DateFormat.MEDIUM, getLocale());\r\n            instance.setTimeZone(getTimeZone());\r\n            return instance.format(date);\r\n        }\r\n    }\r\n    return dateFormat.format(date);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.broadcastPresenceOfOtherResource",
	"Comment": "sends the presences of other connected resources to the resource that just connected.",
	"Method": "void broadcastPresenceOfOtherResource(LocalClientSession session){\r\n    if (!SessionManager.isOtherResourcePresenceEnabled()) {\r\n        return;\r\n    }\r\n    Presence presence;\r\n    JID searchJID = new JID(session.getAddress().getNode(), session.getAddress().getDomain(), null);\r\n    List<JID> addresses = routingTable.getRoutes(searchJID, null);\r\n    for (JID address : addresses) {\r\n        if (address.equals(session.getAddress())) {\r\n            continue;\r\n        }\r\n        ClientSession userSession = routingTable.getClientRoute(address);\r\n        presence = userSession.getPresence().createCopy();\r\n        presence.setTo(session.getAddress());\r\n        session.process(presence);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionPacketRouter.setSkipJIDValidation",
	"Comment": "sets if to addresses of elements being routed should be validated. doing stringprep operationsis very expensive and sometimes we already validated the to address so there is no need tovalidate again the address. for instance, when using connection managers the validationis done by the connection manager so we can just trust the to address. on the other hand,the from address is set by the server so there is no need to validate it.by default validation is enabled.",
	"Method": "void setSkipJIDValidation(boolean skipJIDValidation){\r\n    this.skipJIDValidation = skipJIDValidation;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.CollectionNode.isAssociationAllowed",
	"Comment": "returns true if the specified user is allowed to associate a leaf node with thisnode. the decision is taken based on the association policy that the node isusing.",
	"Method": "boolean isAssociationAllowed(JID user){\r\n    if (associationPolicy == LeafNodeAssociationPolicy.all) {\r\n        return true;\r\n    } else if (associationPolicy == LeafNodeAssociationPolicy.owners) {\r\n        return isAdmin(user);\r\n    } else {\r\n        return isAdmin(user) || associationTrusted.contains(user);\r\n    }\r\n}"
}, {
	"Path": "org.mitre.jwt.signer.service.impl.DefaultJWTSigningAndValidationService.buildSignersAndVerifiers",
	"Comment": "build all of the signers and verifiers for this based on the key map.",
	"Method": "void buildSignersAndVerifiers(){\r\n    for (Map.Entry<String, JWK> jwkEntry : keys.entrySet()) {\r\n        String id = jwkEntry.getKey();\r\n        JWK jwk = jwkEntry.getValue();\r\n        try {\r\n            if (jwk instanceof RSAKey) {\r\n                if (jwk.isPrivate()) {\r\n                    RSASSASigner signer = new RSASSASigner((RSAKey) jwk);\r\n                    signers.put(id, signer);\r\n                }\r\n                RSASSAVerifier verifier = new RSASSAVerifier((RSAKey) jwk);\r\n                verifiers.put(id, verifier);\r\n            } else if (jwk instanceof ECKey) {\r\n                if (jwk.isPrivate()) {\r\n                    ECDSASigner signer = new ECDSASigner((ECKey) jwk);\r\n                    signers.put(id, signer);\r\n                }\r\n                ECDSAVerifier verifier = new ECDSAVerifier((ECKey) jwk);\r\n                verifiers.put(id, verifier);\r\n            } else if (jwk instanceof OctetSequenceKey) {\r\n                if (jwk.isPrivate()) {\r\n                    MACSigner signer = new MACSigner((OctetSequenceKey) jwk);\r\n                    signers.put(id, signer);\r\n                }\r\n                MACVerifier verifier = new MACVerifier((OctetSequenceKey) jwk);\r\n                verifiers.put(id, verifier);\r\n            } else {\r\n                logger.warn(\"Unknown key type: \" + jwk);\r\n            }\r\n        } catch (JOSEException e) {\r\n            logger.warn(\"Exception loading signer/verifier\", e);\r\n        }\r\n    }\r\n    if (defaultSignerKeyId == null && keys.size() == 1) {\r\n        setDefaultSignerKeyId(keys.keySet().iterator().next());\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.MultiUserChatManager.loadServices",
	"Comment": "loads the list of configured services stored in the database.",
	"Method": "void loadServices(){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(LOAD_SERVICES);\r\n        rs = pstmt.executeQuery();\r\n        while (rs.next()) {\r\n            String subdomain = rs.getString(1);\r\n            String description = rs.getString(2);\r\n            Boolean isHidden = Boolean.valueOf(rs.getString(3));\r\n            MultiUserChatServiceImpl muc = new MultiUserChatServiceImpl(subdomain, description, isHidden);\r\n            mucServices.put(subdomain, muc);\r\n        }\r\n    } catch (Exception e) {\r\n        Log.error(e.getMessage(), e);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(rs, pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.TLSStreamReader.doRead",
	"Comment": "read tls encrpyted data from socketchannel, and use decrypt method to decypt.",
	"Method": "void doRead(){\r\n    final int cnt = rbc.read(inNetBB);\r\n    if (cnt > 0) {\r\n        inAppBB = decrypt(inNetBB, inAppBB);\r\n        if (lastStatus == TLSStatus.OK) {\r\n            inAppBB.flip();\r\n        } else {\r\n            doRead();\r\n        }\r\n    } else {\r\n        if (cnt == -1) {\r\n            inAppBB.flip();\r\n            rbc.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mitre.oauth2.model.OAuth2AccessTokenEntity.getAdditionalInformation",
	"Comment": "get all additional information to be sent to the serializer as part of the token response.\tthis map is not persisted to the database.",
	"Method": "Map<String, Object> getAdditionalInformation(){\r\n    return additionalInformation;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.mediaproxy.MediaProxy.getMaxPort",
	"Comment": "returns the maximum port value to listen for incoming packets.",
	"Method": "int getMaxPort(){\r\n    return maxPort;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ServerPort.isComponentPort",
	"Comment": "returns true if external components can connect to this port.",
	"Method": "boolean isComponentPort(){\r\n    return type == Type.component;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.filetransfer.proxy.FileTransferProxy.isProxyEnabled",
	"Comment": "returns true if the file transfer proxy is currently enabled and false if it is not.",
	"Method": "boolean isProxyEnabled(){\r\n    return connectionManager.isRunning() && JiveGlobals.getBooleanProperty(JIVEPROPERTY_PROXY_ENABLED, DEFAULT_IS_PROXY_ENABLED);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.Roster.isSubscriptionRejected",
	"Comment": "returns true if roster item represents a rejected subscription request.",
	"Method": "boolean isSubscriptionRejected(RosterItem item){\r\n    return item.getSubStatus() == RosterItem.SUB_NONE && item.getRecvStatus() == RosterItem.RECV_NONE && item.getAskStatus() == RosterItem.AskType.NONE;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.isRemote",
	"Comment": "returns true if the given address does not match the local server hostname and does notmatch a component service jid.",
	"Method": "boolean isRemote(JID jid){\r\n    return jid != null && !jid.getDomain().equals(xmppServerInfo.getXMPPDomain()) && !componentManager.hasComponent(jid);\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheFactory.setMaxLifetimeProperty",
	"Comment": "sets a local property which overrides the maximum cache entry lifetimefor the supplied cache name.",
	"Method": "void setMaxLifetimeProperty(String cacheName,long lifetime){\r\n    cacheName = cacheName.replaceAll(\" \", \"\");\r\n    if (!Long.toString(lifetime).equals(JiveGlobals.getProperty(\"cache.\" + cacheName + \".maxLifetime\"))) {\r\n        JiveGlobals.setProperty((\"cache.\" + cacheName + \".maxLifetime\"), Long.toString(lifetime));\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.util.CertificateManager.fireCertificateStoreChanged",
	"Comment": "notify listeners that a certificate store has been changed.",
	"Method": "void fireCertificateStoreChanged(CertificateStore store){\r\n    for (CertificateEventListener listener : listeners) {\r\n        try {\r\n            listener.storeContentChanged(store);\r\n        } catch (Exception e) {\r\n            Log.error(\"A listener threw an exception while processing a 'store changed' event.\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.database.SchemaManager.checkSchema",
	"Comment": "checks to see if the database needs to be upgraded. this method should becalled once every time the application starts up.",
	"Method": "boolean checkSchema(Connection con,String schemaKey,int requiredVersion,ResourceLoader resourceLoader){\r\n    int currentVersion = -1;\r\n    PreparedStatement pstmt = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        pstmt = con.prepareStatement(CHECK_VERSION);\r\n        pstmt.setString(1, schemaKey);\r\n        rs = pstmt.executeQuery();\r\n        if (rs.next()) {\r\n            currentVersion = rs.getInt(1);\r\n        }\r\n    } catch (SQLException sqle) {\r\n        Log.debug(\"SchemaManager: Error verifying \" + schemaKey + \" version, probably ignorable.\", sqle);\r\n        DbConnectionManager.closeStatement(rs, pstmt);\r\n        if (schemaKey.equals(\"openfire\")) {\r\n            try {\r\n                pstmt = con.prepareStatement(CHECK_VERSION_JIVE);\r\n                pstmt.setString(1, schemaKey);\r\n                rs = pstmt.executeQuery();\r\n                if (rs.next()) {\r\n                    currentVersion = rs.getInt(1);\r\n                }\r\n            } catch (SQLException sqlea) {\r\n                Log.debug(\"SchemaManager: Error verifying \" + schemaKey + \" version, probably ignorable.\", sqlea);\r\n                DbConnectionManager.closeStatement(rs, pstmt);\r\n                try {\r\n                    pstmt = con.prepareStatement(CHECK_VERSION_OLD);\r\n                    rs = pstmt.executeQuery();\r\n                    if (rs.next()) {\r\n                        currentVersion = rs.getInt(1);\r\n                    }\r\n                } catch (SQLException sqle2) {\r\n                    Log.debug(\"SchemaManager: Error verifying \" + schemaKey + \" version, probably ignorable\", sqle2);\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        DbConnectionManager.closeStatement(rs, pstmt);\r\n    }\r\n    if (currentVersion >= requiredVersion) {\r\n        return true;\r\n    } else if (currentVersion == -1) {\r\n        Log.info(LocaleUtils.getLocalizedString(\"upgrade.database.missing_schema\", Arrays.asList(schemaKey)));\r\n        System.out.println(LocaleUtils.getLocalizedString(\"upgrade.database.missing_schema\", Arrays.asList(schemaKey)));\r\n        String resourceName = schemaKey + \"_\" + DbConnectionManager.getDatabaseType() + \".sql\";\r\n        try (InputStream resource = resourceLoader.loadResource(resourceName)) {\r\n            if (resource == null) {\r\n                return false;\r\n            }\r\n            executeSQLScript(con, resource, !schemaKey.equals(\"openfire\") && !schemaKey.equals(\"wildfire\"));\r\n        } catch (Exception e) {\r\n            Log.error(e.getMessage(), e);\r\n            return false;\r\n        }\r\n        Log.info(LocaleUtils.getLocalizedString(\"upgrade.database.success\"));\r\n        System.out.println(LocaleUtils.getLocalizedString(\"upgrade.database.success\"));\r\n        return true;\r\n    } else {\r\n        Log.info(LocaleUtils.getLocalizedString(\"upgrade.database.old_schema\", Arrays.asList(currentVersion, schemaKey, requiredVersion)));\r\n        System.out.println(LocaleUtils.getLocalizedString(\"upgrade.database.old_schema\", Arrays.asList(currentVersion, schemaKey, requiredVersion)));\r\n        if (DbConnectionManager.getDatabaseType() == DbConnectionManager.DatabaseType.unknown) {\r\n            Log.info(LocaleUtils.getLocalizedString(\"upgrade.database.unknown_db\"));\r\n            System.out.println(LocaleUtils.getLocalizedString(\"upgrade.database.unknown_db\"));\r\n            return false;\r\n        } else if (DbConnectionManager.getDatabaseType() == DbConnectionManager.DatabaseType.interbase) {\r\n            Log.info(LocaleUtils.getLocalizedString(\"upgrade.database.interbase_db\"));\r\n            System.out.println(LocaleUtils.getLocalizedString(\"upgrade.database.interbase_db\"));\r\n            return false;\r\n        }\r\n        for (int i = currentVersion + 1; i <= requiredVersion; i++) {\r\n            try (InputStream resource = getUpgradeResource(resourceLoader, i, schemaKey)) {\r\n                try {\r\n                    if (i == 21 && schemaKey.equals(\"openfire\")) {\r\n                        OF33.executeFix(con);\r\n                    }\r\n                    if (i == 27 && schemaKey.equals(\"openfire\")) {\r\n                        OF1515.executeFix();\r\n                    }\r\n                } catch (Exception e) {\r\n                    Log.error(e.getMessage(), e);\r\n                    return false;\r\n                }\r\n                if (resource == null) {\r\n                    continue;\r\n                }\r\n                executeSQLScript(con, resource, !schemaKey.equals(\"openfire\") && !schemaKey.equals(\"wildfire\"));\r\n            } catch (Exception e) {\r\n                Log.error(e.getMessage(), e);\r\n                return false;\r\n            }\r\n        }\r\n        Log.info(LocaleUtils.getLocalizedString(\"upgrade.database.success\"));\r\n        System.out.println(LocaleUtils.getLocalizedString(\"upgrade.database.success\"));\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.isRootCollectionNode",
	"Comment": "returns true if this node is the root node of the pubsub service.",
	"Method": "boolean isRootCollectionNode(){\r\n    return service.getRootCollectionNode() == this;\r\n}"
}, {
	"Path": "org.jivesoftware.util.Log.getLogDirectory",
	"Comment": "returns the directory that log files exist in. the directory name willhave a file.separator as the last character in the string.",
	"Method": "String getLogDirectory(){\r\n    final StringBuilder sb = new StringBuilder();\r\n    sb.append(JiveGlobals.getHomeDirectory());\r\n    if (!sb.substring(sb.length() - 1).startsWith(File.separator)) {\r\n        sb.append(File.separator);\r\n    }\r\n    sb.append(\"logs\");\r\n    sb.append(File.separator);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.isSendItemSubscribe",
	"Comment": "returns true if new subscribers are going to receive new items once subscribed.",
	"Method": "boolean isSendItemSubscribe(){\r\n    return sendItemSubscribe;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.LocalRoutingTable.getComponentRoute",
	"Comment": "returns the external component sessions that are connected to this jvm.",
	"Method": "Collection<RoutableChannelHandler> getComponentRoute(){\r\n    List<RoutableChannelHandler> sessions = new ArrayList();\r\n    for (RoutableChannelHandler route : routes.values()) {\r\n        if (!(route instanceof LocalOutgoingServerSession || route instanceof LocalClientSession)) {\r\n            sessions.add(route);\r\n        }\r\n    }\r\n    return sessions;\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.getPassword",
	"Comment": "returns the password used to connect to the database. in some cases,a password is not needed so this method will return null.",
	"Method": "String getPassword(){\r\n    return password;\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.setupPropertyEncryptionKey",
	"Comment": "this method is called early during the setup process toset a custom key for encrypting property values",
	"Method": "void setupPropertyEncryptionKey(String key){\r\n    String oldAlg = securityProperties.getProperty(ENCRYPTION_ALGORITHM);\r\n    String oldKey = securityProperties.getProperty(ENCRYPTION_KEY_CURRENT);\r\n    if (StringUtils.isNotEmpty(oldKey) && !oldKey.equals(key) && StringUtils.isNotEmpty(oldAlg)) {\r\n        updateEncryptionProperties(oldAlg, oldKey, oldAlg, key);\r\n    }\r\n    securityProperties.setProperty(ENCRYPTION_KEY_CURRENT, new AesEncryptor().encrypt(currentKey));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sip.tester.security.CredentialsCache.get",
	"Comment": "returns the credentials corresponding to the specified realm or null ifnone could be found.",
	"Method": "CredentialsCacheEntry get(String realm){\r\n    return (CredentialsCacheEntry) this.authenticatedRealms.get(realm);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.audit.SessionEvent.createStreamEvent",
	"Comment": "create an event associated with the establishment of an xmpp session.a connect event that is not followed by a stream event indicatesthe connection was rejected.",
	"Method": "SessionEvent createStreamEvent(Session session){\r\n    return new SessionEvent(session, SESSION_STREAM, null);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.Roster.getRosterItem",
	"Comment": "returns the roster item that is associated with the specified jid. if no roster itemwas found then a usernotfoundexception will be thrown.",
	"Method": "RosterItem getRosterItem(JID user){\r\n    RosterItem item = rosterItems.get(user.toBareJID());\r\n    if (item == null) {\r\n        item = getImplicitRosterItem(user);\r\n        if (item == null) {\r\n            throw new UserNotFoundException(user.toBareJID());\r\n        }\r\n    }\r\n    return item;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.getAuthRequestForm",
	"Comment": "returns the data form to be included in the authorization request to be sent tonode owners when a new subscription needs to be approved.",
	"Method": "DataForm getAuthRequestForm(NodeSubscription subscription){\r\n    DataForm form = new DataForm(DataForm.Type.form);\r\n    form.setTitle(LocaleUtils.getLocalizedString(\"pubsub.form.authorization.title\"));\r\n    form.addInstruction(LocaleUtils.getLocalizedString(\"pubsub.form.authorization.instruction\"));\r\n    FormField formField = form.addField();\r\n    formField.setVariable(\"FORM_TYPE\");\r\n    formField.setType(FormField.Type.hidden);\r\n    formField.addValue(\"http://jabber.org/protocol/pubsub#subscribe_authorization\");\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#subid\");\r\n    formField.setType(FormField.Type.hidden);\r\n    formField.addValue(subscription.getID());\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#node\");\r\n    formField.setType(FormField.Type.text_single);\r\n    formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.authorization.node\"));\r\n    formField.addValue(getNodeID());\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#subscriber_jid\");\r\n    formField.setType(FormField.Type.jid_single);\r\n    formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.authorization.subscriber\"));\r\n    formField.addValue(subscription.getJID().toString());\r\n    formField = form.addField();\r\n    formField.setVariable(\"pubsub#allow\");\r\n    formField.setType(FormField.Type.boolean_type);\r\n    formField.setLabel(LocaleUtils.getLocalizedString(\"pubsub.form.authorization.allow\"));\r\n    formField.addValue(Boolean.FALSE);\r\n    return form;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.setAccessModel",
	"Comment": "sets the access model that specifies who is allowed to subscribe and retrieve items.",
	"Method": "void setAccessModel(AccessModel accessModel){\r\n    this.accessModel = accessModel;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.AdminConsolePlugin.isRestartNeeded",
	"Comment": "returns true if the jetty server needs to be restarted. this is usually required whencertificates are added, deleted or modified or when server ports were modified.",
	"Method": "boolean isRestartNeeded(){\r\n    return restartNeeded;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.disco.IQDiscoItemsHandler.removeComponentItem",
	"Comment": "removes a disco item for a component that has been removed from the server.",
	"Method": "void removeComponentItem(String jid){\r\n    if (serverItems == null) {\r\n        return;\r\n    }\r\n    Lock lock = CacheFactory.getLock(jid, serverItems);\r\n    try {\r\n        lock.lock();\r\n        ClusteredServerItem item = serverItems.get(jid);\r\n        if (item != null && item.nodes.remove(XMPPServer.getInstance().getNodeID())) {\r\n            if (item.nodes.isEmpty()) {\r\n                serverItems.remove(jid);\r\n            } else {\r\n                serverItems.put(jid, item);\r\n            }\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n    localServerItems.remove(jid);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.entitycaps.EntityCapabilities.containsFeature",
	"Comment": "determines whether or not a given feature is included in these entitycapabilities.",
	"Method": "boolean containsFeature(String feature){\r\n    return features.contains(feature);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.IQRouter.routingFailed",
	"Comment": "notification message indicating that a packet has failed to be routed to the recipient.",
	"Method": "void routingFailed(JID recipient,Packet packet){\r\n    Log.debug(\"IQ sent to unreachable address: \" + packet.toXML());\r\n    final IQ iq = (IQ) packet;\r\n    if (iq.isRequest()) {\r\n        sendErrorPacket(iq, PacketError.Condition.service_unavailable);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.interceptor.InterceptorManager.removeUserInterceptor",
	"Comment": "removes the interceptor from the list of interceptors that are related to a specificusername.",
	"Method": "boolean removeUserInterceptor(String username,PacketInterceptor interceptor){\r\n    boolean answer = false;\r\n    List<PacketInterceptor> userInterceptors = usersInterceptors.get(username);\r\n    if (userInterceptors != null) {\r\n        answer = userInterceptors.remove(interceptor);\r\n        if (userInterceptors.isEmpty()) {\r\n            usersInterceptors.remove(username);\r\n        }\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "org.jivesoftware.util.LocaleUtils.getLocalizedString",
	"Comment": "returns an internationalized string loaded from a resource bundle fromthe passed in plugin, using the passed in locale.if the plugin name is null, the key will be looked up using thestandard resource bundle.if the locale is null, the jive global locale will be used.",
	"Method": "String getLocalizedString(String key,String getLocalizedString,String key,Locale locale,String getLocalizedString,String key,List<?> arguments,String getLocalizedString,String key,String pluginName,String getLocalizedString,String key,String pluginName,List arguments,String getLocalizedString,String key,String pluginName,List<?> arguments,Locale locale,boolean fallback,String getLocalizedString,String key,Locale locale,List arguments,ResourceBundle bundle){\r\n    if (key == null) {\r\n        throw new NullPointerException(\"Key cannot be null\");\r\n    }\r\n    if (locale == null) {\r\n        locale = JiveGlobals.getLocale();\r\n    }\r\n    String value;\r\n    try {\r\n        value = bundle.getString(key);\r\n        if (arguments != null) {\r\n            MessageFormat messageFormat = new MessageFormat(\"\");\r\n            messageFormat.setLocale(bundle.getLocale());\r\n            messageFormat.applyPattern(value);\r\n            try {\r\n                Format[] formats = messageFormat.getFormats();\r\n                for (int i = 0; i < formats.length; i++) {\r\n                    Format format = formats[i];\r\n                    if (format != null) {\r\n                        if (format instanceof DateFormat) {\r\n                            if (arguments.size() > i) {\r\n                                Object val = arguments.get(i);\r\n                                if (val instanceof String) {\r\n                                    DateFormat dateFmt = (DateFormat) format;\r\n                                    try {\r\n                                        val = dateFmt.parse((String) val);\r\n                                        arguments.set(i, val);\r\n                                    } catch (ParseException e) {\r\n                                        Log.error(e.getMessage(), e);\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else if (format instanceof NumberFormat) {\r\n                            if (arguments.size() > i) {\r\n                                Object val = arguments.get(i);\r\n                                if (val instanceof String) {\r\n                                    NumberFormat nbrFmt = (NumberFormat) format;\r\n                                    try {\r\n                                        val = nbrFmt.parse((String) val);\r\n                                        arguments.set(i, val);\r\n                                    } catch (ParseException e) {\r\n                                        Log.error(e.getMessage(), e);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                value = messageFormat.format(arguments.toArray());\r\n            } catch (IllegalArgumentException e) {\r\n                Log.error(\"Unable to format resource string for key: \" + key + \", argument type not supported\");\r\n                value = \"\";\r\n            }\r\n        }\r\n    } catch (java.util.MissingResourceException mre) {\r\n        Log.warn(\"Missing resource for key: \" + key + \" in locale \" + locale.toString());\r\n        value = \"\";\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.shouldDeliverNotifications",
	"Comment": "returns whether an entity wants to receive or has disabled notifications.",
	"Method": "boolean shouldDeliverNotifications(){\r\n    return deliverNotifications;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.DummyExternalizableUtil.readStringMap",
	"Comment": "reads a map of string key and value pairs. this method will returnnull if the map written to the stream was null.",
	"Method": "Map<String, String> readStringMap(DataInput in){\r\n    return Collections.emptyMap();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.ServerTrafficCounter.wrapOutputStream",
	"Comment": "wraps the specified output stream to count the number of bytes that were written.",
	"Method": "OutputStream wrapOutputStream(OutputStream originalStream){\r\n    return new OutputStreamWrapper(originalStream);\r\n}"
}, {
	"Path": "org.jivesoftware.admin.SubnavTag.getCss",
	"Comment": "returns the value of the css class to be used for tab decoration. if not set will return a blank string.",
	"Method": "String getCss(){\r\n    return clean(css);\r\n}"
}, {
	"Path": "org.mitre.oauth2.model.ClientDetailsEntity.getIdTokenValiditySeconds",
	"Comment": "number of seconds id token is valid for. must be a positive integer, can not be null.",
	"Method": "Integer getIdTokenValiditySeconds(){\r\n    return idTokenValiditySeconds;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.SearchPlugin.setExcludedFields",
	"Comment": "restricts which fields can be searched on and shown to clients. this can be used in the case of preventing users email addresses frombeing revealed as part of the search results.",
	"Method": "void setExcludedFields(Collection<String> excludedFields){\r\n    this.excludedFields = excludedFields;\r\n    JiveGlobals.setProperty(EXCLUDEDFIELDS, StringUtils.collectionToString(excludedFields));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.LocalMUCUser.isJoined",
	"Comment": "returns true if the user is currently present in one or more rooms.",
	"Method": "boolean isJoined(){\r\n    return !roles.isEmpty();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.cluster.ClusterManager.isClusteringStarted",
	"Comment": "returns true if this jvm is part of a cluster. the cluster may have many nodesor this jvm could be the only node.",
	"Method": "boolean isClusteringStarted(){\r\n    return CacheFactory.isClusteringStarted();\r\n}"
}, {
	"Path": "org.jivesoftware.admin.LdapUserTester.getSample",
	"Comment": "returns a list of usernames with a sample of the users found in ldap.",
	"Method": "List<String> getSample(int maxSample){\r\n    List<String> usernames = new ArrayList();\r\n    LdapContext ctx = null;\r\n    try {\r\n        ctx = manager.getContext();\r\n        Control[] searchControl;\r\n        try {\r\n            searchControl = new Control[] { new SortControl(new String[] { manager.getUsernameField() }, Control.NONCRITICAL) };\r\n        } catch (IOException e) {\r\n            Log.error(e.getMessage(), e);\r\n            return Collections.emptyList();\r\n        }\r\n        ctx.setRequestControls(searchControl);\r\n        SearchControls searchControls = new SearchControls();\r\n        if (manager.isSubTreeSearch()) {\r\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\r\n        } else {\r\n            searchControls.setSearchScope(SearchControls.ONELEVEL_SCOPE);\r\n        }\r\n        searchControls.setReturningAttributes(new String[] { manager.getUsernameField() });\r\n        searchControls.setCountLimit(maxSample);\r\n        String filter = MessageFormat.format(manager.getSearchFilter(), \"*\");\r\n        NamingEnumeration answer = ctx.search(\"\", filter, searchControls);\r\n        while (answer.hasMoreElements()) {\r\n            String username = (String) ((SearchResult) answer.next()).getAttributes().get(manager.getUsernameField()).get();\r\n            usernames.add(JID.escapeNode(username));\r\n        }\r\n        answer.close();\r\n    } finally {\r\n        try {\r\n            if (ctx != null) {\r\n                ctx.setRequestControls(null);\r\n                ctx.close();\r\n            }\r\n        } catch (Exception ignored) {\r\n        }\r\n    }\r\n    return usernames;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.SearchPlugin.replyNonDataFormResult",
	"Comment": "constructs a query that is returned as an iq packet that contains the search results.",
	"Method": "IQ replyNonDataFormResult(Collection<User> users,IQ packet){\r\n    IQ replyPacket = IQ.createResultIQ(packet);\r\n    Element replyQuery = replyPacket.setChildElement(\"query\", NAMESPACE_JABBER_IQ_SEARCH);\r\n    for (User user : users) {\r\n        Element item = replyQuery.addElement(\"item\");\r\n        String username = JID.unescapeNode(user.getUsername());\r\n        item.addAttribute(\"jid\", username + \"@\" + serverName);\r\n        for (String field : reverseFieldLookup.keySet()) {\r\n            if (\"Username\".equals(field)) {\r\n                Element element = item.addElement(reverseFieldLookup.get(field));\r\n                element.addText(username);\r\n            }\r\n            if (\"Name\".equals(field)) {\r\n                Element element = item.addElement(reverseFieldLookup.get(field));\r\n                element.addText(user.isNameVisible() ? removeNull(user.getName()) : \"\");\r\n            }\r\n            if (\"Email\".equals(field)) {\r\n                Element element = item.addElement(reverseFieldLookup.get(field));\r\n                element.addText(user.isEmailVisible() ? removeNull(user.getEmail()) : \"\");\r\n            }\r\n        }\r\n    }\r\n    return replyPacket;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.setNotifyRetract",
	"Comment": "sets if subscribers are going to be notified when items are removed from the node.",
	"Method": "void setNotifyRetract(boolean notifyRetract){\r\n    this.notifyRetract = notifyRetract;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.readStrings",
	"Comment": "reads the string array from the input stream and adds them to the specified collection.",
	"Method": "int readStrings(DataInput in,Collection<String> collection){\r\n    return strategy.readStrings(in, collection);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.handler.IQPrivacyHandler.getPrivacyListsNames",
	"Comment": "returns the iq packet containing the active and default lists and the listsdefined by the user.",
	"Method": "IQ getPrivacyListsNames(IQ packet,JID from){\r\n    IQ result = IQ.createResultIQ(packet);\r\n    Element childElement = packet.getChildElement().createCopy();\r\n    result.setChildElement(childElement);\r\n    Map<String, Boolean> privacyLists = provider.getPrivacyLists(from.getNode());\r\n    for (String listName : privacyLists.keySet()) {\r\n        if (privacyLists.get(listName)) {\r\n            childElement.addElement(\"default\").addAttribute(\"name\", listName);\r\n        }\r\n    }\r\n    ClientSession session = sessionManager.getSession(from);\r\n    if (session != null && session.getActiveList() != null) {\r\n        childElement.addElement(\"active\").addAttribute(\"name\", session.getActiveList().getName());\r\n    }\r\n    for (String listName : privacyLists.keySet()) {\r\n        childElement.addElement(\"list\").addAttribute(\"name\", listName);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.dom4j.io.XMPPPacketReader.removeHandler",
	"Comment": "removes the elementhandler from the event basedprocessor, for the specified path.",
	"Method": "void removeHandler(String path){\r\n    getDispatchHandler().removeHandler(path);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpBindManager.isHttpsBindActive",
	"Comment": "returns true if a listener on the https binding port is running.",
	"Method": "boolean isHttpsBindActive(){\r\n    if (isHttpBindEnabled()) {\r\n        final int configuredPort = getHttpBindSecurePort();\r\n        for (final Connector connector : httpBindServer.getConnectors()) {\r\n            if (!(connector instanceof ServerConnector)) {\r\n                continue;\r\n            }\r\n            final int activePort = ((ServerConnector) connector).getLocalPort();\r\n            if (activePort == configuredPort) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.mitre.oauth2.model.ClientDetailsEntity.isScoped",
	"Comment": "if the scope list is not null or empty, then this client has been scoped.",
	"Method": "boolean isScoped(){\r\n    return getScope() != null && !getScope().isEmpty();\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2AuthorizationCodeService.consumeAuthorizationCode",
	"Comment": "consume a given authorization code.\tmatch the provided string to an authorizationcodeentity. if one is found, return\tthe authentication associated with the code. if one is not found, throw an\tinvalidgrantexception.",
	"Method": "OAuth2Authentication consumeAuthorizationCode(String code){\r\n    AuthorizationCodeEntity result = repository.getByCode(code);\r\n    if (result == null) {\r\n        throw new InvalidGrantException(\"JpaAuthorizationCodeRepository: no authorization code found for value \" + code);\r\n    }\r\n    OAuth2Authentication auth = result.getAuthenticationHolder().getAuthentication();\r\n    repository.remove(result);\r\n    return auth;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.group.DefaultGroupPropertyMap.deleteAllProperties",
	"Comment": "delete all properties from the database for the current group",
	"Method": "void deleteAllProperties(){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(DELETE_ALL_PROPERTIES);\r\n        pstmt.setString(1, group.getName());\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException e) {\r\n        logger.error(e.getMessage(), e);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n    Map<String, Object> event = new HashMap();\r\n    event.put(\"type\", \"propertyDeleted\");\r\n    event.put(\"propertyKey\", \"*\");\r\n    GroupEventDispatcher.dispatchEvent(group, GroupEventDispatcher.EventType.group_modified, event);\r\n}"
}, {
	"Path": "org.jivesoftware.util.XMLWriter.writePrintln",
	"Comment": "this will print a new line only if the newlines flag was set to true",
	"Method": "void writePrintln(){\r\n    if (format.isNewlines()) {\r\n        writer.write(format.getLineSeparator());\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.plugin.rest.RESTServicePlugin.setEnabled",
	"Comment": "enables or disables the user service. if not enabled, it will not acceptrequests to create new accounts.",
	"Method": "void setEnabled(boolean enabled){\r\n    this.enabled = enabled;\r\n    JiveGlobals.setProperty(\"plugin.restapi.enabled\", enabled ? \"true\" : \"false\");\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.setPosixMode",
	"Comment": "sets whether the ldap server is operating in posix mode. when in posix mode,users are stored within a group by their username alone. when not enabled,users are stored in a group using their entire dn.",
	"Method": "void setPosixMode(boolean posixMode){\r\n    this.posixMode = posixMode;\r\n    properties.put(\"ldap.posixMode\", String.valueOf(posixMode));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.CollectionNode.setAssociationPolicy",
	"Comment": "sets the policy that defines who may associate leaf nodes with a collection.",
	"Method": "void setAssociationPolicy(LeafNodeAssociationPolicy associationPolicy){\r\n    this.associationPolicy = associationPolicy;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.approved",
	"Comment": "the subscription has been approved by a node owner. the subscription is now active sothe subscriber is now allowed to get event notifications.",
	"Method": "void approved(){\r\n    if (state == State.subscribed) {\r\n        return;\r\n    }\r\n    state = State.subscribed;\r\n    if (savedToDB) {\r\n        PubSubPersistenceManager.saveSubscription(node, this, false);\r\n    }\r\n    if (node.isSendItemSubscribe() && isActive()) {\r\n        PublishedItem lastItem = node.getLastPublishedItem();\r\n        if (lastItem != null) {\r\n            sendLastPublishedItem(lastItem);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterManager.getPublicSharedGroups",
	"Comment": "returns the list of shared groups whose visibility is public.",
	"Method": "Collection<Group> getPublicSharedGroups(){\r\n    return GroupManager.getInstance().getPublicSharedGroups();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.sip.tester.security.SipSecurityManager.getAuthorization",
	"Comment": "generates an authorisation header in response to wwwauthheader.",
	"Method": "AuthorizationHeader getAuthorization(String method,String uri,String requestBody,WWWAuthenticateHeader authHeader,UserCredentials userCredentials){\r\n    String response = null;\r\n    try {\r\n        Log.debug(\"getAuthorization\", userCredentials.getAuthUserName());\r\n        response = // nc-value\r\n        MessageDigestAlgorithm.calculateResponse(// nc-value\r\n        authHeader.getAlgorithm(), // nc-value\r\n        userCredentials.getAuthUserName(), // nc-value\r\n        authHeader.getRealm(), // nc-value\r\n        new String(userCredentials.getPassword()), authHeader.getNonce(), null, null, method, uri, requestBody, authHeader.getQop());\r\n    } catch (NullPointerException exc) {\r\n        throw new SecurityException(\"The authenticate header was malformatted\");\r\n    }\r\n    AuthorizationHeader authorization = null;\r\n    try {\r\n        if (authHeader instanceof ProxyAuthenticateHeader) {\r\n            authorization = headerFactory.createProxyAuthorizationHeader(authHeader.getScheme());\r\n        } else {\r\n            authorization = headerFactory.createAuthorizationHeader(authHeader.getScheme());\r\n        }\r\n        authorization.setUsername(userCredentials.getAuthUserName());\r\n        authorization.setRealm(authHeader.getRealm());\r\n        authorization.setNonce(authHeader.getNonce());\r\n        authorization.setParameter(\"uri\", uri);\r\n        authorization.setResponse(response);\r\n        if (authHeader.getAlgorithm() != null)\r\n            authorization.setAlgorithm(authHeader.getAlgorithm());\r\n        if (authHeader.getOpaque() != null)\r\n            authorization.setOpaque(authHeader.getOpaque());\r\n        authorization.setResponse(response);\r\n    } catch (ParseException ex) {\r\n        throw new SecurityException(\"Failed to create an authorization header!\");\r\n    }\r\n    return authorization;\r\n}"
}, {
	"Path": "org.jivesoftware.database.ProfiledConnection.getQueriesPerSecond",
	"Comment": "returns the average number of queries of a certain type that have beenperformed per second since profiling started. if profiling has beenstopped, that moment in time is used for the calculation. otherwise,the current moment in time is used.",
	"Method": "double getQueriesPerSecond(Type type){\r\n    long count, start, end;\r\n    switch(type) {\r\n        case select:\r\n            count = selectCount;\r\n            start = startSelectTime;\r\n            end = endSelectTime;\r\n            break;\r\n        case update:\r\n            count = updateCount;\r\n            start = startUpdateTime;\r\n            end = endUpdateTime;\r\n            break;\r\n        case insert:\r\n            count = insertCount;\r\n            start = startInsertTime;\r\n            end = endInsertTime;\r\n            break;\r\n        case delete:\r\n            count = deleteCount;\r\n            start = startDeleteTime;\r\n            end = endDeleteTime;\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Invalid type\");\r\n    }\r\n    if (count == 0) {\r\n        return 0;\r\n    }\r\n    if (end == 0) {\r\n        end = System.currentTimeMillis();\r\n    }\r\n    double time = (end - start) / 1000.0;\r\n    return count / time;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalIncomingServerSession.setLocalDomain",
	"Comment": "sets the domain or subdomain of the local server used by the remote server when askingto validate the session. this information is only used to prevent many connections fromthe same remote server to the same domain or subdomain of the local server.",
	"Method": "void setLocalDomain(String domain){\r\n    localDomain = domain;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.getMajorVersion",
	"Comment": "returns the major version of bosh which this session utilizes. the version refers to theversion of the xep which the connecting client implements. if the client did not specifya version 1 is returned as 1.5 is the last version of the xep that the client was notrequired to pass along its version information when creating a session.",
	"Method": "int getMajorVersion(){\r\n    if (this.majorVersion != -1) {\r\n        return this.majorVersion;\r\n    } else {\r\n        return 1;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.BlockingAcceptingMode.run",
	"Comment": "about as simple as it gets.the thread spins around an acceptcall getting sockets and creating new reading threads for each new connection.",
	"Method": "void run(){\r\n    while (notTerminated) {\r\n        try {\r\n            Socket sock = serverSocket.accept();\r\n            if (sock != null) {\r\n                Log.debug(\"Connect \" + sock.toString());\r\n                SocketReader reader = createServerSocketReader(sock, false, true);\r\n                Thread thread = new Thread(reader, reader.getName());\r\n                thread.setDaemon(true);\r\n                thread.setPriority(Thread.NORM_PRIORITY);\r\n                thread.start();\r\n            }\r\n        } catch (IOException ie) {\r\n            if (notTerminated) {\r\n                Log.error(LocaleUtils.getLocalizedString(\"admin.error.accept\"), ie);\r\n            }\r\n        } catch (Throwable e) {\r\n            Log.error(LocaleUtils.getLocalizedString(\"admin.error.accept\"), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginManager.firePluginCreatedEvent",
	"Comment": "notifies all registered pluginlistener instances that a new plugin was created.",
	"Method": "void firePluginCreatedEvent(String name,Plugin plugin){\r\n    for (final PluginListener listener : pluginListeners) {\r\n        try {\r\n            listener.pluginCreated(name, plugin);\r\n        } catch (Exception ex) {\r\n            Log.warn(\"An exception was thrown when one of the pluginManagerListeners was notified of a 'created' event for plugin '{}'!\", name, ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.mediaproxy.MediaProxySession.getPass",
	"Comment": "get the pass of this sessiona pass can be used to authorize an session modification",
	"Method": "String getPass(){\r\n    return pass;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.getInactivityTimeout",
	"Comment": "returns the time, in seconds, after which this session will be considered inactive andterminated.",
	"Method": "int getInactivityTimeout(){\r\n    return inactivityTimeout;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.audit.SessionEvent.createAuthFailureEvent",
	"Comment": "create an event associated with the failure of a session to authenticate.",
	"Method": "SessionEvent createAuthFailureEvent(Session session,String user,String resource){\r\n    return new SessionEvent(session, SESSION_AUTH_FAILURE, \"User: \" + user + \" Resource: \" + resource);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getComponentManager",
	"Comment": "returns the internalcomponentmanager registered with this server. theinternalcomponentmanager was registered with the server as a module while starting upthe server.",
	"Method": "InternalComponentManager getComponentManager(){\r\n    return (InternalComponentManager) modules.get(InternalComponentManager.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.sessionUnavailable",
	"Comment": "notification message sent when a client sent an unavailable presence for the session. makingthe session unavailable means that the session is not eligible for receiving messages fromother clients.",
	"Method": "void sessionUnavailable(LocalClientSession session){\r\n    if (session.getAddress() != null && routingTable != null && session.getAddress().toBareJID().trim().length() != 0) {\r\n        routingTable.addClientRoute(session.getAddress(), session);\r\n    }\r\n}"
}, {
	"Path": "org.mitre.oauth2.introspectingfilter.IntrospectingTokenService.parseToken",
	"Comment": "validate a token string against the introspection endpoint,\tthen parse it and store it in the local cache if caching is enabled.",
	"Method": "TokenCacheObject parseToken(String accessToken){\r\n    String introspectionUrl;\r\n    RegisteredClient client;\r\n    try {\r\n        introspectionUrl = introspectionConfigurationService.getIntrospectionUrl(accessToken);\r\n        client = introspectionConfigurationService.getClientConfiguration(accessToken);\r\n    } catch (IllegalArgumentException e) {\r\n        logger.error(\"Unable to load introspection URL or client configuration\", e);\r\n        return null;\r\n    }\r\n    String validatedToken = null;\r\n    RestTemplate restTemplate;\r\n    MultiValueMap<String, String> form = new LinkedMultiValueMap();\r\n    final String clientId = client.getClientId();\r\n    final String clientSecret = client.getClientSecret();\r\n    if (SECRET_BASIC.equals(client.getTokenEndpointAuthMethod())) {\r\n        restTemplate = new RestTemplate(factory) {\r\n            @Override\r\n            protected ClientHttpRequest createRequest(URI url, HttpMethod method) throws IOException {\r\n                ClientHttpRequest httpRequest = super.createRequest(url, method);\r\n                httpRequest.getHeaders().add(\"Authorization\", String.format(\"Basic %s\", Base64.encode(String.format(\"%s:%s\", clientId, clientSecret))));\r\n                return httpRequest;\r\n            }\r\n        };\r\n    } else {\r\n        restTemplate = new RestTemplate(factory);\r\n        form.add(\"client_id\", clientId);\r\n        form.add(\"client_secret\", clientSecret);\r\n    }\r\n    form.add(\"token\", accessToken);\r\n    try {\r\n        validatedToken = restTemplate.postForObject(introspectionUrl, form, String.class);\r\n    } catch (RestClientException rce) {\r\n        logger.error(\"validateToken\", rce);\r\n        return null;\r\n    }\r\n    if (validatedToken != null) {\r\n        JsonElement jsonRoot = new JsonParser().parse(validatedToken);\r\n        if (!jsonRoot.isJsonObject()) {\r\n            return null;\r\n        }\r\n        JsonObject tokenResponse = jsonRoot.getAsJsonObject();\r\n        if (tokenResponse.get(\"error\") != null) {\r\n            logger.error(\"Got an error back: \" + tokenResponse.get(\"error\") + \", \" + tokenResponse.get(\"error_description\"));\r\n            return null;\r\n        }\r\n        if (!tokenResponse.get(\"active\").getAsBoolean()) {\r\n            logger.info(\"Server returned non-active token\");\r\n            return null;\r\n        }\r\n        OAuth2Authentication auth = new OAuth2Authentication(createStoredRequest(tokenResponse), createUserAuthentication(tokenResponse));\r\n        OAuth2AccessToken token = createAccessToken(tokenResponse, accessToken);\r\n        if (token.getExpiration() == null || token.getExpiration().after(new Date())) {\r\n            TokenCacheObject tco = new TokenCacheObject(token, auth);\r\n            if (cacheTokens && (cacheNonExpiringTokens || token.getExpiration() != null)) {\r\n                authCache.put(accessToken, tco);\r\n            }\r\n            return tco;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.mitre.oauth2.introspectingfilter.IntrospectingTokenService.parseToken",
	"Comment": "validate a token string against the introspection endpoint,\tthen parse it and store it in the local cache if caching is enabled.",
	"Method": "TokenCacheObject parseToken(String accessToken){\r\n    ClientHttpRequest httpRequest = super.createRequest(url, method);\r\n    httpRequest.getHeaders().add(\"Authorization\", String.format(\"Basic %s\", Base64.encode(String.format(\"%s:%s\", clientId, clientSecret))));\r\n    return httpRequest;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.container.PluginServlet.handleServlet",
	"Comment": "handles a request for a servlet. if one is found, request handling is passed to it.if no servlet is found, a 404 error is returned.",
	"Method": "void handleServlet(String pathInfo,HttpServletRequest request,HttpServletResponse response){\r\n    GenericServlet servlet = getServlet(pathInfo);\r\n    if (servlet != null) {\r\n        servlet.service(request, response);\r\n    } else {\r\n        response.setStatus(HttpServletResponse.SC_NOT_FOUND);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getPacketDeliverer",
	"Comment": "returns the packetdeliverer registered with this server. thepacketdeliverer was registered with the server as a module while starting upthe server.",
	"Method": "PacketDeliverer getPacketDeliverer(){\r\n    return (PacketDeliverer) modules.get(PacketDelivererImpl.class);\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.getConnectionTimeout",
	"Comment": "returns the amount of time between connection recycles in days. forexample, a value of .5 would correspond to recycling the connectionsin the pool once every half day.",
	"Method": "double getConnectionTimeout(){\r\n    return connectionTimeout;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.IQRouter.addHandler",
	"Comment": "adds a new iqhandler to the list of registered handler. the new iqhandler will beresponsible for handling iq packet whose namespace matches the namespace of theiqhandler.an illegalargumentexception may be thrown if the iqhandler to register was already providedby the server. the server provides a certain list of iqhandlers when the server isstarted up.",
	"Method": "void addHandler(IQHandler handler){\r\n    if (iqHandlers.contains(handler)) {\r\n        throw new IllegalArgumentException(\"IQHandler already provided by the server\");\r\n    }\r\n    handler.initialize(XMPPServer.getInstance());\r\n    namespace2Handlers.put(handler.getInfo().getNamespace(), handler);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalClientSession.getUsername",
	"Comment": "returns the username associated with this session. use this informationwith the user manager to obtain the user based on username.",
	"Method": "String getUsername(){\r\n    if (authToken == null) {\r\n        throw new UserNotFoundException();\r\n    }\r\n    return getAddress().getNode();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.sendSubscriptionState",
	"Comment": "sends the current subscription status to the user that tried to create a subscription tothe node. the subscription status is sent to the subsciber after the subscription wascreated or if the subscriber tries to subscribe many times and the node does not supportmultpiple subscriptions.",
	"Method": "void sendSubscriptionState(IQ originalRequest){\r\n    IQ result = IQ.createResultIQ(originalRequest);\r\n    Element child = result.setChildElement(\"pubsub\", \"http://jabber.org/protocol/pubsub\");\r\n    Element entity = child.addElement(\"subscription\");\r\n    if (!node.isRootCollectionNode()) {\r\n        entity.addAttribute(\"node\", node.getNodeID());\r\n    }\r\n    entity.addAttribute(\"jid\", getJID().toString());\r\n    if (node.isMultipleSubscriptionsEnabled()) {\r\n        entity.addAttribute(\"subid\", getID());\r\n    }\r\n    entity.addAttribute(\"subscription\", getState().name());\r\n    Element subscribeOptions = entity.addElement(\"subscribe-options\");\r\n    if (node.isSubscriptionConfigurationRequired() && isConfigurationPending()) {\r\n        subscribeOptions.addElement(\"required\");\r\n    }\r\n    node.getService().send(result);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.update.Update.getURL",
	"Comment": "returns the url from where the latest version of the component can be downloaded.",
	"Method": "String getURL(){\r\n    return url;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.TestDefaultStatsService.prepare",
	"Comment": "prepares a collection of approvedsite mocks to be returned from the approvedsiteservice\tand a collection of clientdetailentity mocks to be returned from the clientservice.",
	"Method": "void prepare(){\r\n    Mockito.reset(approvedSiteService);\r\n    Mockito.when(ap1.getUserId()).thenReturn(userId1);\r\n    Mockito.when(ap1.getClientId()).thenReturn(clientId1);\r\n    Mockito.when(ap2.getUserId()).thenReturn(userId1);\r\n    Mockito.when(ap2.getClientId()).thenReturn(clientId1);\r\n    Mockito.when(ap3.getUserId()).thenReturn(userId2);\r\n    Mockito.when(ap3.getClientId()).thenReturn(clientId2);\r\n    Mockito.when(ap4.getUserId()).thenReturn(userId2);\r\n    Mockito.when(ap4.getClientId()).thenReturn(clientId3);\r\n    Mockito.when(ap5.getUserId()).thenReturn(userId2);\r\n    Mockito.when(ap5.getClientId()).thenReturn(clientId1);\r\n    Mockito.when(ap6.getUserId()).thenReturn(userId1);\r\n    Mockito.when(ap6.getClientId()).thenReturn(clientId4);\r\n    Mockito.when(approvedSiteService.getAll()).thenReturn(Sets.newHashSet(ap1, ap2, ap3, ap4));\r\n    Mockito.when(client1.getId()).thenReturn(1L);\r\n    Mockito.when(client2.getId()).thenReturn(2L);\r\n    Mockito.when(client3.getId()).thenReturn(3L);\r\n    Mockito.when(client4.getId()).thenReturn(4L);\r\n    Mockito.when(approvedSiteService.getByClientId(clientId1)).thenReturn(Sets.newHashSet(ap1, ap2));\r\n    Mockito.when(approvedSiteService.getByClientId(clientId2)).thenReturn(Sets.newHashSet(ap3));\r\n    Mockito.when(approvedSiteService.getByClientId(clientId3)).thenReturn(Sets.newHashSet(ap4));\r\n    Mockito.when(approvedSiteService.getByClientId(clientId4)).thenReturn(Sets.newHashSet());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.PresenceRouter.routingFailed",
	"Comment": "notification message indicating that a packet has failed to be routed to the recipient.",
	"Method": "void routingFailed(JID recipient,Packet packet){\r\n    Log.debug(\"Presence sent to unreachable address: \" + packet.toXML());\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.setNotifyDelete",
	"Comment": "sets if subscribers are going to be notified when node is deleted.",
	"Method": "void setNotifyDelete(boolean notifyDelete){\r\n    this.notifyDelete = notifyDelete;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.StanzaHandler.getAddress",
	"Comment": "obtain the address of the xmpp entity for which this stanzahandlerhandles stanzas.note that the value that is returned for this method canchange over time. for example, if no session has been established yet,this method will return null, or, if resource binding occurs,the returned value might change. values obtained from this method aretherefore best not cached.",
	"Method": "JID getAddress(){\r\n    if (session == null) {\r\n        return null;\r\n    }\r\n    return session.getAddress();\r\n}"
}, {
	"Path": "org.jivesoftware.admin.LdapUserProfile.initForActiveDirectory",
	"Comment": "sets default mapping values when using an active directory server.",
	"Method": "void initForActiveDirectory(){\r\n    name = \"{cn}\";\r\n    email = \"{mail}\";\r\n    fullName = \"{displayName}\";\r\n    nickname = \"\";\r\n    birthday = \"\";\r\n    photo = \"{jpegPhoto}\";\r\n    homeStreet = \"{homePostalAddress}\";\r\n    homeCity = \"\";\r\n    homeState = \"\";\r\n    homeZip = \"{homeZip}\";\r\n    homeCountry = \"{co}\";\r\n    homePhone = \"{homePhone}\";\r\n    homeMobile = \"{mobile}\";\r\n    homeFax = \"\";\r\n    homePager = \"\";\r\n    businessStreet = \"{streetAddress}\";\r\n    businessCity = \"{l}\";\r\n    businessState = \"{st}\";\r\n    businessZip = \"{postalCode}\";\r\n    businessCountry = \"{co}\";\r\n    businessJobTitle = \"{title}\";\r\n    businessDepartment = \"{department}\";\r\n    businessPhone = \"{telephoneNumber}\";\r\n    businessMobile = \"{mobile}\";\r\n    businessFax = \"{facsimileTelephoneNumber}\";\r\n    businessPager = \"{pager}\";\r\n    avatarStoredInDB = false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getUpdateManager",
	"Comment": "returns the updatemanager registered with this server. theupdatemanager was registered with the server as a module while starting upthe server.",
	"Method": "UpdateManager getUpdateManager(){\r\n    return (UpdateManager) modules.get(UpdateManager.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.disco.IQDiscoItemsHandler.getProvider",
	"Comment": "returns the discoitemsprovider responsible for providing the items related to a given entityor null if none was found.",
	"Method": "DiscoItemsProvider getProvider(String name){\r\n    return entities.get(name);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getMessageRouter",
	"Comment": "returns the messagerouter registered with this server. themessagerouter was registered with the server as a module while starting upthe server.",
	"Method": "MessageRouter getMessageRouter(){\r\n    return (MessageRouter) modules.get(MessageRouter.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.setLastResponseEmpty",
	"Comment": "lastresponseempty true if last response of this session is an empty body element. thisis used in overactivity checking.",
	"Method": "void setLastResponseEmpty(boolean lastResponseEmpty){\r\n    this.lastResponseEmpty = lastResponseEmpty;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.RoutingTableImpl.routeOnlyAvailable",
	"Comment": "returns true if the specified packet must only be route to available client sessions.",
	"Method": "boolean routeOnlyAvailable(Packet packet,boolean fromServer){\r\n    if (fromServer) {\r\n        return false;\r\n    }\r\n    boolean onlyAvailable = true;\r\n    JID from = packet.getFrom();\r\n    boolean hasSender = from != null;\r\n    if (packet instanceof IQ) {\r\n        onlyAvailable = hasSender && !(serverName.equals(from.getDomain()) && from.getResource() == null) && !componentsCache.containsKey(from.getDomain());\r\n    } else if (packet instanceof Message || packet instanceof Presence) {\r\n        onlyAvailable = !hasSender || (!serverName.equals(from.toString()) && !componentsCache.containsKey(from.getDomain()));\r\n    }\r\n    return onlyAvailable;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.security.DefaultSecurityAuditProvider.logEvent",
	"Comment": "the default provider logs events into a ofsecurityauditlog table in the database.",
	"Method": "void logEvent(String username,String summary,String details){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        long msgID = SequenceManager.nextID(JiveConstants.SECURITY_AUDIT);\r\n        con = DbConnectionManager.getConnection();\r\n        pstmt = con.prepareStatement(LOG_ENTRY);\r\n        pstmt.setLong(1, msgID);\r\n        pstmt.setString(2, username);\r\n        pstmt.setLong(3, new Date().getTime());\r\n        pstmt.setString(4, StringUtils.abbreviate(summary, 250));\r\n        pstmt.setString(5, XMPPServer.getInstance().getServerInfo().getHostname());\r\n        pstmt.setString(6, details);\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException e) {\r\n        Log.warn(\"Error trying to insert a new row in ofSecurityAuditLog: \", e);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SocketConnection.getTLSStreamHandler",
	"Comment": "returns the stream handler responsible for securing the plain connection and providingthe corresponding input and output streams.",
	"Method": "TLSStreamHandler getTLSStreamHandler(){\r\n    return tlsStreamHandler;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.multiplex.MultiplexerPacketHandler.route",
	"Comment": "processes a route packet that is wrapping a stanza sent by a client that is connectedto the connection manager.",
	"Method": "void route(Route route){\r\n    StreamID streamID = route.getStreamID();\r\n    if (streamID == null) {\r\n        Element extraError = DocumentHelper.createElement(QName.get(\"id-required\", \"http://jabber.org/protocol/connectionmanager#errors\"));\r\n        sendErrorPacket(route, PacketError.Condition.bad_request, extraError);\r\n    }\r\n    LocalClientSession session = multiplexerManager.getClientSession(connectionManagerDomain, streamID);\r\n    if (session == null) {\r\n        sendErrorPacket(route, PacketError.Condition.item_not_found, null);\r\n        return;\r\n    }\r\n    SessionPacketRouter router = new SessionPacketRouter(session);\r\n    router.setSkipJIDValidation(true);\r\n    try {\r\n        router.route(route.getChildElement());\r\n    } catch (UnknownStanzaException use) {\r\n        Element extraError = DocumentHelper.createElement(QName.get(\"unknown-stanza\", \"http://jabber.org/protocol/connectionmanager#errors\"));\r\n        sendErrorPacket(route, PacketError.Condition.bad_request, extraError);\r\n    } catch (Exception e) {\r\n        Log.error(\"Error processing wrapped packet: \" + route.getChildElement().asXML(), e);\r\n        sendErrorPacket(route, PacketError.Condition.internal_server_error, null);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.setPublisherModel",
	"Comment": "sets the publisher model that specifies who is allowed to publish items to the node.",
	"Method": "void setPublisherModel(PublisherModel publisherModel){\r\n    this.publisherModel = publisherModel;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.http.HttpSession.getMaxPollingInterval",
	"Comment": "returns the max interval within which a client can send polling requests. if more than onerequest occurs in the interval the session will be terminated.",
	"Method": "int getMaxPollingInterval(){\r\n    return this.maxPollingInterval;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.client.OIDCAuthenticationFilter.getStoredSessionString",
	"Comment": "get the named stored session variable as a string. return null if not found or not a string.",
	"Method": "String getStoredSessionString(HttpSession session,String key){\r\n    Object o = session.getAttribute(key);\r\n    if (o != null && o instanceof String) {\r\n        return o.toString();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.admin.AdminManager.setAdminUsers",
	"Comment": "sets the list of admin users based off of a list of usernames.clears list first.",
	"Method": "void setAdminUsers(List<String> usernames){\r\n    if (adminList == null) {\r\n        adminList = new ArrayList();\r\n    } else {\r\n        adminList.clear();\r\n    }\r\n    List<JID> admins = new ArrayList();\r\n    for (String username : usernames) {\r\n        admins.add(XMPPServer.getInstance().createJID(username, null));\r\n    }\r\n    adminList.addAll(admins);\r\n    provider.setAdmins(admins);\r\n}"
}, {
	"Path": "org.jivesoftware.util.JiveGlobals.isPropertyEncrypted",
	"Comment": "determines whether a property is configured for encryption.",
	"Method": "boolean isPropertyEncrypted(String name){\r\n    if (properties == null) {\r\n        if (isSetupMode()) {\r\n            return false;\r\n        }\r\n        properties = JiveProperties.getInstance();\r\n    }\r\n    return properties.isEncrypted(name);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SocketReader.getLastActive",
	"Comment": "returns the last time a full document was read or a heartbeat was received. hearbeatsare represented as whitespaces received while a document is not being parsed.",
	"Method": "long getLastActive(){\r\n    return reader.getLastActive();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.setAccessModel",
	"Comment": "sets the access model that specifies who is allowed to subscribe and retrieve items.",
	"Method": "void setAccessModel(AccessModel accessModel){\r\n    this.accessModel = accessModel;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.LeafNode.sendPublishedItems",
	"Comment": "sends an iq result with the list of items published to the node. item id and payloadmay be included in the result based on the node configuration.",
	"Method": "void sendPublishedItems(IQ originalRequest,List<PublishedItem> publishedItems,boolean forceToIncludePayload){\r\n    IQ result = IQ.createResultIQ(originalRequest);\r\n    Element pubsubElem = result.setChildElement(\"pubsub\", \"http://jabber.org/protocol/pubsub\");\r\n    Element items = pubsubElem.addElement(\"items\");\r\n    items.addAttribute(\"node\", getNodeID());\r\n    for (PublishedItem publishedItem : publishedItems) {\r\n        Element item = items.addElement(\"item\");\r\n        if (isItemRequired()) {\r\n            item.addAttribute(\"id\", publishedItem.getID());\r\n        }\r\n        if ((forceToIncludePayload || isPayloadDelivered()) && publishedItem.getPayload() != null) {\r\n            item.add(publishedItem.getPayload().createCopy());\r\n        }\r\n    }\r\n    service.send(result);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.handler.IQBlockingHandler.removeAllFromBlocklist",
	"Comment": "removes all jids from the blocklist of the provided user.this method removes the jids to the default privacy list. when no default privacy list exists for this user, thismethod does nothing.",
	"Method": "Set<JID> removeAllFromBlocklist(User user){\r\n    Log.debug(\"Obtain the default privacy list for '{}'\", user.getUsername());\r\n    final Set<JID> result = new HashSet();\r\n    PrivacyList defaultPrivacyList = PrivacyListManager.getInstance().getDefaultPrivacyList(user.getUsername());\r\n    if (defaultPrivacyList == null) {\r\n        return result;\r\n    }\r\n    Log.debug(\"Removing all JIDs from blocklist '{}' (belonging to '{}')\", defaultPrivacyList.getName(), user.getUsername());\r\n    final Element listElement = defaultPrivacyList.asElement();\r\n    final Set<Element> toRemove = new HashSet();\r\n    for (final Element element : listElement.elements(\"item\")) {\r\n        if (\"jid\".equals(element.attributeValue(\"type\")) && \"deny\".equals(element.attributeValue(\"action\"))) {\r\n            toRemove.add(element);\r\n            result.add(new JID(element.attributeValue(\"value\")));\r\n        }\r\n    }\r\n    if (!toRemove.isEmpty()) {\r\n        for (final Element remove : toRemove) {\r\n            listElement.remove(remove);\r\n        }\r\n        defaultPrivacyList.updateList(listElement);\r\n        PrivacyListProvider.getInstance().updatePrivacyList(user.getUsername(), defaultPrivacyList);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.CollectionNode.isMaxLeafNodeReached",
	"Comment": "returns true if the max number of leaf nodes associated with this node hasreached to the maximum allowed.",
	"Method": "boolean isMaxLeafNodeReached(){\r\n    if (maxLeafNodes < 0) {\r\n        return false;\r\n    }\r\n    int counter = 0;\r\n    for (Node node : getNodes()) {\r\n        if (!node.isCollectionNode()) {\r\n            counter = counter + 1;\r\n        }\r\n    }\r\n    return counter >= maxLeafNodes;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.addNoneAffiliation",
	"Comment": "adds a new affiliation or updates an existing affiliation of the specified entity jidto become a none affiliate. affiliates of type none are allowed to subscribe to the node.",
	"Method": "NodeAffiliate addNoneAffiliation(JID jid){\r\n    return addAffiliation(jid, NodeAffiliate.Affiliation.none);\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.ExternalizableUtil.getStrategy",
	"Comment": "returns the implementation to use for serializing and deserializingobjects.",
	"Method": "ExternalizableUtilStrategy getStrategy(){\r\n    return strategy;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.getIncomingServerSessions",
	"Comment": "returns the list of sessions that were originated by a remote server. the list will beordered chronologically.incomingserversession can only receive packets from the remoteserver but are not capable of sending packets to the remote server.",
	"Method": "List<IncomingServerSession> getIncomingServerSessions(String hostname){\r\n    List<StreamID> streamIDs;\r\n    Lock lock = CacheFactory.getLock(hostname, hostnameSessionsCache);\r\n    try {\r\n        lock.lock();\r\n        streamIDs = hostnameSessionsCache.get(hostname);\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n    if (streamIDs == null) {\r\n        return Collections.emptyList();\r\n    } else {\r\n        List<IncomingServerSession> sessions = new ArrayList();\r\n        for (StreamID streamID : streamIDs) {\r\n            IncomingServerSession session = localSessionManager.getIncomingServerSession(streamID);\r\n            RemoteSessionLocator locator = server.getRemoteSessionLocator();\r\n            if (session == null && locator != null) {\r\n                byte[] nodeID = incomingServerSessionsCache.get(streamID);\r\n                if (nodeID != null) {\r\n                    session = locator.getIncomingServerSession(nodeID, streamID);\r\n                }\r\n            }\r\n            if (session != null) {\r\n                sessions.add(session);\r\n            }\r\n        }\r\n        return sessions;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.ConnectionListener.enable",
	"Comment": "activates or deactivates the listener, and changes the configuration accordingly. this configuration change ispersisted. an invocation of this method has no effect if the listener is already in the provided state.",
	"Method": "void enable(boolean enable){\r\n    if (isEnabledPropertyName == null && !enable) {\r\n        throw new IllegalArgumentException(\"This listener cannot be disabled!\");\r\n    }\r\n    final boolean isRunning = connectionAcceptor != null;\r\n    if (enable == isRunning) {\r\n        Log.debug(\"Ignoring enable({}): listener already in this state.\", enable);\r\n        return;\r\n    }\r\n    JiveGlobals.setProperty(isEnabledPropertyName, Boolean.toString(enable));\r\n    restart();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.admin.AdminManager.setAdminJIDs",
	"Comment": "sets the list of admin users based off of a list of jids.clears list first.",
	"Method": "void setAdminJIDs(List<JID> jids){\r\n    if (adminList == null) {\r\n        adminList = new ArrayList();\r\n    } else {\r\n        adminList.clear();\r\n    }\r\n    List<JID> admins = new ArrayList();\r\n    for (JID jid : jids) {\r\n        if (jid != null) {\r\n            admins.add(jid.asBareJID());\r\n        }\r\n    }\r\n    adminList.addAll(admins);\r\n    provider.setAdmins(admins);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.removeDetached",
	"Comment": "remove a session as being detached. this is idempotent.this should be called by the localsession itself either when resumed or whenclosed.",
	"Method": "void removeDetached(LocalSession localSession){\r\n    LocalSession other = this.detachedSessions.get(localSession.getStreamID());\r\n    if (other == localSession) {\r\n        this.detachedSessions.remove(localSession.getStreamID());\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.lockout.LockOutManager.getDisabledStatus",
	"Comment": "returns a lockoutflag for a given username, which contains information about the timeperiod that the specified account is going to be disabled.",
	"Method": "LockOutFlag getDisabledStatus(String username){\r\n    if (username == null) {\r\n        throw new UnsupportedOperationException(\"Null username not allowed!\");\r\n    }\r\n    LockOutFlag lockOutFlag = getUserLockOut(username);\r\n    return getUnExpiredLockout(lockOutFlag);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getConnectionManager",
	"Comment": "returns the connectionmanager registered with this server. theconnectionmanager was registered with the server as a module while starting upthe server.",
	"Method": "ConnectionManager getConnectionManager(){\r\n    return (ConnectionManager) modules.get(ConnectionManagerImpl.class);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.setDescription",
	"Comment": "sets the description of the node. this information is really optional and can bemodified by submiting a completed data form with the new node configuration.",
	"Method": "void setDescription(String description){\r\n    this.description = description;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.spi.MultiUserChatServiceImpl.chatRoomAdded",
	"Comment": "notification message indicating that a chat room has been createdin another cluster member.",
	"Method": "void chatRoomAdded(LocalMUCRoom room){\r\n    localMUCRoomManager.addRoom(room.getName(), room);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.MulticastRouter.sendToRemoteEntity",
	"Comment": "sends pending packets of the requested domain but first try to discover if remote serversupports multicast service. if we already have cached information about the requesteddomain then just deliver the packet.",
	"Method": "void sendToRemoteEntity(String domain){\r\n    String multicastService = cache.get(domain);\r\n    if (multicastService != null) {\r\n        sendToRemoteServer(domain, multicastService);\r\n    } else {\r\n        IQ iq = new IQ(IQ.Type.get);\r\n        iq.setFrom(server.getServerInfo().getXMPPDomain());\r\n        iq.setTo(domain);\r\n        iq.setChildElement(\"query\", \"http://jabber.org/protocol/disco#info\");\r\n        nodes.put(domain, new CopyOnWriteArrayList<String>());\r\n        iqRouter.addIQResultListener(iq.getID(), this);\r\n        iqRouter.route(iq);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.getUserManager",
	"Comment": "returns the usermanager registered with this server. theusermanager was registered with the server as a module while starting upthe server.",
	"Method": "UserManager getUserManager(){\r\n    return UserManager.getInstance();\r\n}"
}, {
	"Path": "org.jivesoftware.database.DbConnectionManager.getLargeTextField",
	"Comment": "retrives a large text column from a result set, automatically performingstreaming if the jdbc driver requires it. this is necessary becausedifferent jdbc drivers have different capabilities and methods forretrieving large text values.",
	"Method": "String getLargeTextField(ResultSet rs,int columnIndex){\r\n    if (isStreamTextRequired()) {\r\n        String value;\r\n        try (Reader bodyReader = rs.getCharacterStream(columnIndex)) {\r\n            if (bodyReader == null) {\r\n                return null;\r\n            }\r\n            char[] buf = new char[256];\r\n            int len;\r\n            StringWriter out = new StringWriter(256);\r\n            while ((len = bodyReader.read(buf)) >= 0) {\r\n                out.write(buf, 0, len);\r\n            }\r\n            value = out.toString();\r\n            out.close();\r\n        } catch (Exception e) {\r\n            Log.error(e.getMessage(), e);\r\n            throw new SQLException(\"Failed to load text field\");\r\n        }\r\n        return value;\r\n    } else {\r\n        return rs.getString(columnIndex);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.database.DbConnectionManager.getSchemaManager",
	"Comment": "returns a schemamanager instance, which can be used to manage the databaseschema information for openfire and plugins.",
	"Method": "SchemaManager getSchemaManager(){\r\n    return schemaManager;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.roster.RosterManager.parseGroups",
	"Comment": "returns a collection of groups obtained by parsing a comma delimited string with the nameof groups.",
	"Method": "Collection<Group> parseGroups(String groupNames){\r\n    Collection<Group> answer = new HashSet();\r\n    for (String groupName : parseGroupNames(groupNames)) {\r\n        try {\r\n            answer.add(GroupManager.getInstance().getGroup(groupName));\r\n        } catch (GroupNotFoundException e) {\r\n        }\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ProviderTokenService.refreshAccessToken_requestingMixedScope",
	"Comment": "tests the case where only some of the valid scope values are being requested along with\tother extra unauthorized scope values.",
	"Method": "void refreshAccessToken_requestingMixedScope(){\r\n    Set<String> mixedScope = newHashSet(\"openid\", \"profile\", \"address\", \"phone\");\r\n    tokenRequest.setScope(mixedScope);\r\n    service.refreshAccessToken(refreshTokenValue, tokenRequest);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.filetransfer.proxy.ProxyConnectionManager.processConnections",
	"Comment": "processes the clients connecting to the proxy matching the initiator and target together. this is the main loop of the manager which will run until the process is canceled.",
	"Method": "void processConnections(InetAddress bindInterface,int port){\r\n    if (socketProcess != null) {\r\n        if (proxyPort == port) {\r\n            return;\r\n        }\r\n    }\r\n    reset();\r\n    socketProcess = executor.submit(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                serverSocket = new ServerSocket(port, -1, bindInterface);\r\n            } catch (IOException e) {\r\n                Log.error(\"Error creating server socket\", e);\r\n                return;\r\n            }\r\n            while (serverSocket.isBound()) {\r\n                final Socket socket;\r\n                try {\r\n                    socket = serverSocket.accept();\r\n                } catch (IOException e) {\r\n                    if (!serverSocket.isClosed()) {\r\n                        Log.error(\"Error accepting proxy connection\", e);\r\n                        continue;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                executor.submit(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        try {\r\n                            processConnection(socket);\r\n                        } catch (IOException ie) {\r\n                            Log.error(\"Error processing file transfer proxy connection\", ie);\r\n                            try {\r\n                                socket.close();\r\n                            } catch (IOException e) {\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n    proxyPort = port;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.filetransfer.proxy.ProxyConnectionManager.processConnections",
	"Comment": "processes the clients connecting to the proxy matching the initiator and target together. this is the main loop of the manager which will run until the process is canceled.",
	"Method": "void processConnections(InetAddress bindInterface,int port){\r\n    try {\r\n        serverSocket = new ServerSocket(port, -1, bindInterface);\r\n    } catch (IOException e) {\r\n        Log.error(\"Error creating server socket\", e);\r\n        return;\r\n    }\r\n    while (serverSocket.isBound()) {\r\n        final Socket socket;\r\n        try {\r\n            socket = serverSocket.accept();\r\n        } catch (IOException e) {\r\n            if (!serverSocket.isClosed()) {\r\n                Log.error(\"Error accepting proxy connection\", e);\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        executor.submit(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    processConnection(socket);\r\n                } catch (IOException ie) {\r\n                    Log.error(\"Error processing file transfer proxy connection\", ie);\r\n                    try {\r\n                        socket.close();\r\n                    } catch (IOException e) {\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.filetransfer.proxy.ProxyConnectionManager.processConnections",
	"Comment": "processes the clients connecting to the proxy matching the initiator and target together. this is the main loop of the manager which will run until the process is canceled.",
	"Method": "void processConnections(InetAddress bindInterface,int port){\r\n    try {\r\n        processConnection(socket);\r\n    } catch (IOException ie) {\r\n        Log.error(\"Error processing file transfer proxy connection\", ie);\r\n        try {\r\n            socket.close();\r\n        } catch (IOException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.admin.TabsTag.getCss",
	"Comment": "returns the value of the css class to be used for tab decoration. if not set will return a blank string.",
	"Method": "String getCss(){\r\n    return clean(css);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.setDebugEnabled",
	"Comment": "sets whether ldap connection debugging is turned on. when on, traceinformation about ber buffers sent and received by the ldap provider iswritten to system.out. debugging is turned off by default.",
	"Method": "void setDebugEnabled(boolean debugEnabled){\r\n    this.ldapDebugEnabled = debugEnabled;\r\n    properties.put(\"ldap.ldapDebugEnabled\", Boolean.toString(debugEnabled));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.outgoingServerSessionCreated",
	"Comment": "notification message that a new outgoingserversession has been created. register a listenerthat will react when the connection gets closed.",
	"Method": "void outgoingServerSessionCreated(LocalOutgoingServerSession session){\r\n    session.getConnection().registerCloseListener(outgoingServerListener, session);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.user.HybridUserProvider.setEmail",
	"Comment": "changes the email address of a user in the first provider that contains the user.",
	"Method": "void setEmail(String username,String email){\r\n    getUserProvider(username).setEmail(username, email);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.keystore.CheckChainTrustedTest.testNullSelectorArgument",
	"Comment": "verifies that providing a null value for the first argument causes a runtime exception to be thrown.",
	"Method": "void testNullSelectorArgument(){\r\n    final CertSelector selector = null;\r\n    final X509Certificate[] chain = validChain;\r\n    trustManager.checkChainTrusted(selector, chain);\r\n}"
}, {
	"Path": "org.mitre.openid.connect.client.OIDCAuthenticationFilter.createState",
	"Comment": "create a cryptographically random state and store it in the session",
	"Method": "String createState(HttpSession session){\r\n    String state = new BigInteger(50, new SecureRandom()).toString(16);\r\n    session.setAttribute(STATE_SESSION_VARIABLE, state);\r\n    return state;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.net.SocketReader.run",
	"Comment": "a dedicated thread loop for reading the stream and sending incomingpackets to the appropriate router.",
	"Method": "void run(){\r\n    readingMode.run();\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheFactory.getMaxCacheSize",
	"Comment": "if a local property is found for the supplied name which specifies a value for cache size, it is returned.otherwise, the defaultsize argument is returned.",
	"Method": "long getMaxCacheSize(String cacheName){\r\n    return getCacheProperty(cacheName, \".size\", DEFAULT_MAX_CACHE_SIZE);\r\n}"
}, {
	"Path": "org.jivesoftware.database.DbConnectionManager.setLargeTextField",
	"Comment": "sets a large text column in a result set, automatically performingstreaming if the jdbc driver requires it. this is necessary becausedifferent jdbc drivers have different capabilities and methods forsetting large text values.",
	"Method": "void setLargeTextField(PreparedStatement pstmt,int parameterIndex,String value){\r\n    if (isStreamTextRequired()) {\r\n        Reader bodyReader;\r\n        try {\r\n            bodyReader = new StringReader(value);\r\n            pstmt.setCharacterStream(parameterIndex, bodyReader, value.length());\r\n        } catch (Exception e) {\r\n            Log.error(e.getMessage(), e);\r\n            throw new SQLException(\"Failed to set text field.\");\r\n        }\r\n    } else {\r\n        pstmt.setString(parameterIndex, value);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.NodeSubscription.isConfigurationPending",
	"Comment": "returns true if configuration is required by the node and is still pending tobe configured by the subscriber. otherwise return false. once a subscription isconfigured it might need to be approved by a node owner to become active.",
	"Method": "boolean isConfigurationPending(){\r\n    return state == State.unconfigured;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.muc.HistoryStrategy.setTypeFromString",
	"Comment": "obtain the strategy type from string name. see the type enumeration namestrings for the names strings supported. if nothing matchesand parent is not null, then the default strategy is used. otherwise the numberstrategy is used.",
	"Method": "void setTypeFromString(String typeName){\r\n    try {\r\n        type = Type.valueOf(typeName);\r\n    } catch (Exception e) {\r\n        if (parent != null) {\r\n            type = Type.defaulType;\r\n        } else {\r\n            type = Type.number;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.CollectionNode.addAssociationTrusted",
	"Comment": "adds a new trusted user that is allowed to associate leaf nodes with this collection node.the new user is not going to be added to the database. instead it is just kept in memory.",
	"Method": "void addAssociationTrusted(JID user){\r\n    associationTrusted.add(user);\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PubSubEngine.isRemoteServer",
	"Comment": "checks to see if the supplied jid is that of a connected remote server",
	"Method": "boolean isRemoteServer(JID jid){\r\n    final String jidString = jid.toString();\r\n    final SessionManager sessionManager = SessionManager.getInstance();\r\n    for (final String incomingServer : sessionManager.getIncomingServers()) {\r\n        if (incomingServer.equals(jidString)) {\r\n            return true;\r\n        }\r\n    }\r\n    for (final String outgoingServer : sessionManager.getOutgoingServers()) {\r\n        if (outgoingServer.equals(jidString)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.auth.AuthToken.getUsername",
	"Comment": "returns the username associated with this authtoken. a null valuemeans that the authenticated user is anonymous.",
	"Method": "String getUsername(){\r\n    return username;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.MITREidDataService_1_0.readSystemScopes",
	"Comment": "read the list of system scopes from the reader and insert them into the\tscope repository.",
	"Method": "void readSystemScopes(JsonReader reader){\r\n    reader.beginArray();\r\n    while (reader.hasNext()) {\r\n        SystemScope scope = new SystemScope();\r\n        reader.beginObject();\r\n        while (reader.hasNext()) {\r\n            switch(reader.peek()) {\r\n                case END_OBJECT:\r\n                    continue;\r\n                case NAME:\r\n                    String name = reader.nextName();\r\n                    if (reader.peek() == JsonToken.NULL) {\r\n                        reader.skipValue();\r\n                    } else if (name.equals(\"value\")) {\r\n                        scope.setValue(reader.nextString());\r\n                    } else if (name.equals(\"description\")) {\r\n                        scope.setDescription(reader.nextString());\r\n                    } else if (name.equals(\"allowDynReg\")) {\r\n                        scope.setRestricted(!reader.nextBoolean());\r\n                    } else if (name.equals(\"defaultScope\")) {\r\n                        scope.setDefaultScope(reader.nextBoolean());\r\n                    } else if (name.equals(\"icon\")) {\r\n                        scope.setIcon(reader.nextString());\r\n                    } else {\r\n                        logger.debug(\"found unexpected entry\");\r\n                        reader.skipValue();\r\n                    }\r\n                    break;\r\n                default:\r\n                    logger.debug(\"Found unexpected entry\");\r\n                    reader.skipValue();\r\n                    continue;\r\n            }\r\n        }\r\n        reader.endObject();\r\n        sysScopeRepository.save(scope);\r\n    }\r\n    reader.endArray();\r\n    logger.info(\"Done reading system scopes\");\r\n}"
}, {
	"Path": "org.dom4j.io.XMPPPacketReader.createReader",
	"Comment": "factory method to create a reader from the given inputstream.",
	"Method": "Reader createReader(InputStream in,Reader createReader,InputStream in,String charSet){\r\n    return new BufferedReader(new InputStreamReader(in, charSet));\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.DefaultNodeConfiguration.getPublisherModel",
	"Comment": "returnes the publisher model that specifies who is allowed to publish items to the node.",
	"Method": "PublisherModel getPublisherModel(){\r\n    return publisherModel;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.spi.ConnectionListener.getServerPort",
	"Comment": "constructs and returns a serverport instance that reflects the state of this listener.",
	"Method": "ServerPort getServerPort(){\r\n    if (connectionAcceptor == null) {\r\n        return null;\r\n    }\r\n    final int port = getPort();\r\n    final String name = getBindAddress().getHostName();\r\n    final String address = getBindAddress().getHostAddress();\r\n    final boolean isSecure = getTLSPolicy() != Connection.TLSPolicy.disabled;\r\n    final String algorithm = null;\r\n    switch(type) {\r\n        case SOCKET_C2S:\r\n            return new ServerPort(port, name, address, isSecure, algorithm, ServerPort.Type.client);\r\n        case SOCKET_S2S:\r\n            return new ServerPort(port, name, address, isSecure, algorithm, ServerPort.Type.server);\r\n        case COMPONENT:\r\n            return new ServerPort(port, name, address, isSecure, algorithm, ServerPort.Type.component);\r\n        case CONNECTION_MANAGER:\r\n            return new ServerPort(port, name, address, isSecure, algorithm, ServerPort.Type.connectionManager);\r\n        default:\r\n            throw new IllegalStateException(\"Unrecognized type: \" + type);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.SessionManager.changePriority",
	"Comment": "change the priority of a session, that was already available, associated with the sender.",
	"Method": "void changePriority(LocalClientSession session,int oldPriority){\r\n    if (session.getAuthToken().isAnonymous()) {\r\n        return;\r\n    }\r\n    int newPriority = session.getPresence().getPriority();\r\n    if (newPriority < 0 || oldPriority >= 0) {\r\n        return;\r\n    }\r\n    JID searchJID = session.getAddress().asBareJID();\r\n    for (JID address : routingTable.getRoutes(searchJID, null)) {\r\n        if (address.equals(session.getAddress())) {\r\n            continue;\r\n        }\r\n        ClientSession otherSession = routingTable.getClientRoute(address);\r\n        if (otherSession.getPresence().getPriority() >= 0) {\r\n            return;\r\n        }\r\n    }\r\n    if (!session.isAnonymousUser() && session.canFloodOfflineMessages()) {\r\n        OfflineMessageStore messageStore = server.getOfflineMessageStore();\r\n        Collection<OfflineMessage> messages = messageStore.getMessages(session.getAuthToken().getUsername(), true);\r\n        for (Message message : messages) {\r\n            session.process(message);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.database.DefaultConnectionProvider.getTestAfterUse",
	"Comment": "returns whether returned connections will be tested after being returned tothe pool.",
	"Method": "Boolean getTestAfterUse(){\r\n    return testAfterUse;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.PubSubPersistenceManager.saveAffiliation",
	"Comment": "update the db with the new affiliation of the user in the node.",
	"Method": "void saveAffiliation(Node node,NodeAffiliate affiliate,boolean create){\r\n    Connection con = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        con = DbConnectionManager.getConnection();\r\n        if (create) {\r\n            pstmt = con.prepareStatement(ADD_AFFILIATION);\r\n            pstmt.setString(1, node.getService().getServiceID());\r\n            pstmt.setString(2, encodeNodeID(node.getNodeID()));\r\n            pstmt.setString(3, affiliate.getJID().toString());\r\n            pstmt.setString(4, affiliate.getAffiliation().name());\r\n            pstmt.executeUpdate();\r\n        } else {\r\n            pstmt = con.prepareStatement(UPDATE_AFFILIATION);\r\n            pstmt.setString(1, affiliate.getAffiliation().name());\r\n            pstmt.setString(2, node.getService().getServiceID());\r\n            pstmt.setString(3, encodeNodeID(node.getNodeID()));\r\n            pstmt.setString(4, affiliate.getJID().toString());\r\n            pstmt.executeUpdate();\r\n        }\r\n    } catch (SQLException sqle) {\r\n        log.error(sqle.getMessage(), sqle);\r\n    } finally {\r\n        DbConnectionManager.closeConnection(pstmt, con);\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.session.LocalSession.getNumClientPackets",
	"Comment": "obtain the number of packets sent from the client to the server.",
	"Method": "long getNumClientPackets(){\r\n    return clientPacketCount.get();\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.admin.DefaultAdminProvider.getAdmins",
	"Comment": "the default provider retrieves the comma separated list from the system propertyadmin.authorizedjids",
	"Method": "List<JID> getAdmins(){\r\n    List<JID> adminList = new ArrayList();\r\n    String jids = JiveGlobals.getProperty(\"admin.authorizedJIDs\");\r\n    jids = (jids == null || jids.trim().length() == 0) ? \"\" : jids;\r\n    StringTokenizer tokenizer = new StringTokenizer(jids, \",\");\r\n    while (tokenizer.hasMoreTokens()) {\r\n        String jid = tokenizer.nextToken().toLowerCase().trim();\r\n        try {\r\n            adminList.add(new JID(jid));\r\n        } catch (IllegalArgumentException e) {\r\n            Log.warn(\"Invalid JID found in admin.authorizedJIDs system property: \" + jid, e);\r\n        }\r\n    }\r\n    if (adminList.isEmpty()) {\r\n        adminList.add(new JID(\"admin\", XMPPServer.getInstance().getServerInfo().getXMPPDomain(), null, true));\r\n    }\r\n    return adminList;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.pubsub.Node.getNodeID",
	"Comment": "returns the unique identifier for a node within the context of a pubsub service.",
	"Method": "String getNodeID(){\r\n    return nodeID;\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.finishSetup",
	"Comment": "finish the setup process. because this method is meant to be called from insidethe admin console plugin, it spawns its own thread to do the work so that theclass loader is correct.",
	"Method": "void finishSetup(){\r\n    if (!setupMode) {\r\n        return;\r\n    }\r\n    this.finalSetupSteps();\r\n    if (\"true\".equals(JiveGlobals.getXMLProperty(\"setup\"))) {\r\n        Thread finishSetup = new Thread() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    if (isStandAlone()) {\r\n                        Thread.sleep(1000);\r\n                        ((AdminConsolePlugin) pluginManager.getPlugin(\"admin\")).restart();\r\n                    }\r\n                    verifyDataSource();\r\n                    loadModules();\r\n                    initModules();\r\n                    startModules();\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                    logger.error(e.getMessage(), e);\r\n                    shutdownServer();\r\n                }\r\n            }\r\n        };\r\n        finishSetup.setContextClassLoader(loader);\r\n        finishSetup.start();\r\n        setupMode = false;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.XMPPServer.finishSetup",
	"Comment": "finish the setup process. because this method is meant to be called from insidethe admin console plugin, it spawns its own thread to do the work so that theclass loader is correct.",
	"Method": "void finishSetup(){\r\n    try {\r\n        if (isStandAlone()) {\r\n            Thread.sleep(1000);\r\n            ((AdminConsolePlugin) pluginManager.getPlugin(\"admin\")).restart();\r\n        }\r\n        verifyDataSource();\r\n        loadModules();\r\n        initModules();\r\n        startModules();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        logger.error(e.getMessage(), e);\r\n        shutdownServer();\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.database.DbConnectionManager.setMetaData",
	"Comment": "uses a connection from the database to set meta data information aboutwhat different jdbc drivers and databases support.",
	"Method": "void setMetaData(Connection con){\r\n    DatabaseMetaData metaData = con.getMetaData();\r\n    transactionsSupported = metaData.supportsTransactions();\r\n    subqueriesSupported = metaData.supportsCorrelatedSubqueries();\r\n    try {\r\n        scrollResultsSupported = metaData.supportsResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE);\r\n    } catch (Exception e) {\r\n        scrollResultsSupported = false;\r\n    }\r\n    batchUpdatesSupported = metaData.supportsBatchUpdates();\r\n    streamTextRequired = false;\r\n    maxRowsSupported = true;\r\n    fetchSizeSupported = true;\r\n    identifierQuoteString = metaData.getIdentifierQuoteString();\r\n    String dbName = metaData.getDatabaseProductName().toLowerCase();\r\n    String driverName = metaData.getDriverName().toLowerCase();\r\n    if (dbName.indexOf(\"oracle\") != -1) {\r\n        databaseType = DatabaseType.oracle;\r\n        streamTextRequired = true;\r\n        scrollResultsSupported = false;\r\n        if (driverName.indexOf(\"auguro\") != -1) {\r\n            streamTextRequired = false;\r\n            fetchSizeSupported = true;\r\n            maxRowsSupported = false;\r\n        }\r\n    } else if (dbName.indexOf(\"postgres\") != -1) {\r\n        databaseType = DatabaseType.postgresql;\r\n        scrollResultsSupported = false;\r\n        fetchSizeSupported = false;\r\n    } else if (dbName.indexOf(\"interbase\") != -1) {\r\n        databaseType = DatabaseType.interbase;\r\n        fetchSizeSupported = false;\r\n        maxRowsSupported = false;\r\n    } else if (dbName.indexOf(\"sql server\") != -1) {\r\n        databaseType = DatabaseType.sqlserver;\r\n        if (driverName.indexOf(\"una\") != -1) {\r\n            fetchSizeSupported = true;\r\n            maxRowsSupported = false;\r\n        }\r\n    } else if (dbName.indexOf(\"mysql\") != -1) {\r\n        databaseType = DatabaseType.mysql;\r\n        transactionsSupported = false;\r\n    } else if (dbName.indexOf(\"hsql\") != -1) {\r\n        databaseType = DatabaseType.hsqldb;\r\n    } else if (dbName.indexOf(\"db2\") != 1) {\r\n        databaseType = DatabaseType.db2;\r\n    }\r\n}"
}, {
	"Path": "org.jivesoftware.openfire.ldap.LdapManager.isStartTlsEnabled",
	"Comment": "returns true if ldap connection is via start or not. tls is turned off by default.",
	"Method": "boolean isStartTlsEnabled(){\r\n    return startTlsEnabled;\r\n}"
}, {
	"Path": "org.jivesoftware.util.cache.CacheFactory.leftCluster",
	"Comment": "notification message indicating that this jvm has left the cluster.",
	"Method": "void leftCluster(){\r\n    clusteringStarted = false;\r\n    cacheFactoryStrategy = localCacheFactoryStrategy;\r\n    for (Cache cache : getAllCaches()) {\r\n        if (localOnly.contains(cache.getName()))\r\n            continue;\r\n        CacheWrapper cacheWrapper = ((CacheWrapper) cache);\r\n        Cache standaloneCache = cacheFactoryStrategy.createCache(cacheWrapper.getName());\r\n        standaloneCache.putAll(cache);\r\n        cacheWrapper.setWrappedCache(standaloneCache);\r\n    }\r\n    log.info(\"Clustering stopped; cache migration complete\");\r\n}"
}]