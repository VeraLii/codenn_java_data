[{
	"Path": "org.roaringbitmap.Util.fillArrayXOR",
	"Comment": "compute the bitwise xor between two long arrays and write the set bits in the container.",
	"Method": "void fillArrayXOR(short[] container,long[] bitmap1,long[] bitmap2){\r\n    int pos = 0;\r\n    if (bitmap1.length != bitmap2.length) {\r\n        throw new IllegalArgumentException(\"not supported\");\r\n    }\r\n    for (int k = 0; k < bitmap1.length; ++k) {\r\n        long bitset = bitmap1[k] ^ bitmap2[k];\r\n        while (bitset != 0) {\r\n            container[pos++] = (short) (k * 64 + numberOfTrailingZeros(bitset));\r\n            bitset &= (bitset - 1);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.roaringbitmap.Util.hybridUnsignedBinarySearch",
	"Comment": "starts with binary search and finishes with a sequential search",
	"Method": "int hybridUnsignedBinarySearch(short[] array,int begin,int end,short k){\r\n    int ikey = toIntUnsigned(k);\r\n    if ((end > 0) && (toIntUnsigned(array[end - 1]) < ikey)) {\r\n        return -end - 1;\r\n    }\r\n    int low = begin;\r\n    int high = end - 1;\r\n    while (low + 32 <= high) {\r\n        final int middleIndex = (low + high) >>> 1;\r\n        final int middleValue = toIntUnsigned(array[middleIndex]);\r\n        if (middleValue < ikey) {\r\n            low = middleIndex + 1;\r\n        } else if (middleValue > ikey) {\r\n            high = middleIndex - 1;\r\n        } else {\r\n            return middleIndex;\r\n        }\r\n    }\r\n    int x = low;\r\n    for (; x <= high; ++x) {\r\n        final int val = toIntUnsigned(array[x]);\r\n        if (val >= ikey) {\r\n            if (val == ikey) {\r\n                return x;\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return -(x + 1);\r\n}"
}, {
	"Path": "org.roaringbitmap.RunContainer.toShortBuffer",
	"Comment": "return the content of this container as a shortbuffer. this creates a copy and might berelatively slow.",
	"Method": "ShortBuffer toShortBuffer(){\r\n    ShortBuffer sb = ShortBuffer.allocate(this.nbrruns * 2);\r\n    sb.put(this.valueslength, 0, this.nbrruns * 2);\r\n    return sb;\r\n}"
}, {
	"Path": "org.roaringbitmap.longlong.TestRoaring64NavigableMap.testDefaultBehaviorLikeRoaring",
	"Comment": "roaring64navigablemap. typically ensures longs are managed as unsigned longs",
	"Method": "void testDefaultBehaviorLikeRoaring(){\r\n    Roaring64NavigableMap longBitmap = newDefaultCtor();\r\n    RoaringBitmap bitmap = new RoaringBitmap();\r\n    longBitmap.addLong(-1);\r\n    bitmap.add(-1);\r\n    longBitmap.addLong(1);\r\n    bitmap.add(1);\r\n    int[] bitmapAsIntArray = bitmap.toArray();\r\n    long[] longBitmapAsArray = longBitmap.toArray();\r\n    Assert.assertArrayEquals(bitmapAsIntArray, Ints.toArray(Longs.asList(longBitmapAsArray)));\r\n    Assert.assertArrayEquals(Longs.toArray(Ints.asList(bitmapAsIntArray)), longBitmapAsArray);\r\n    long[] bitmapAsLongArray = new long[bitmapAsIntArray.length];\r\n    for (int i = 0; i < bitmapAsIntArray.length; i++) {\r\n        bitmapAsLongArray[i] = Util.toUnsignedLong(bitmapAsIntArray[i]);\r\n    }\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.BufferParallelAggregation.xor",
	"Comment": "computes the bitwise symmetric difference of the input bitmaps",
	"Method": "MutableRoaringBitmap xor(ImmutableRoaringBitmap bitmaps,MappeableContainer xor,List<MappeableContainer> containers){\r\n    MappeableContainer result = containers.get(0).clone();\r\n    for (int i = 1; i < containers.size(); ++i) {\r\n        result = result.ixor(containers.get(i));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.salesmanager.core.business.repositories.catalog.product.ProductRepositoryImpl.listByStore",
	"Comment": "this query is used for filtering products based on criterias",
	"Method": "ProductList listByStore(MerchantStore store,Language language,ProductCriteria criteria,List<Product> listByStore,MerchantStore store){\r\n    StringBuilder qs = new StringBuilder();\r\n    qs.append(\"select p from Product as p \");\r\n    qs.append(\"join fetch p.merchantStore merch \");\r\n    qs.append(\"join fetch p.availabilities pa \");\r\n    qs.append(\"left join fetch pa.prices pap \");\r\n    qs.append(\"join fetch p.descriptions pd \");\r\n    qs.append(\"left join fetch p.categories categs \");\r\n    qs.append(\"left join fetch pap.descriptions papd \");\r\n    qs.append(\"left join fetch p.images images \");\r\n    qs.append(\"left join fetch p.attributes pattr \");\r\n    qs.append(\"left join fetch pattr.productOption po \");\r\n    qs.append(\"left join fetch po.descriptions pod \");\r\n    qs.append(\"left join fetch pattr.productOptionValue pov \");\r\n    qs.append(\"left join fetch pov.descriptions povd \");\r\n    qs.append(\"left join fetch p.manufacturer manuf \");\r\n    qs.append(\"left join fetch manuf.descriptions manufd \");\r\n    qs.append(\"left join fetch p.type type \");\r\n    qs.append(\"left join fetch p.taxClass tx \");\r\n    qs.append(\"left join fetch p.owner owner \");\r\n    qs.append(\"where merch.id=:mid\");\r\n    String hql = qs.toString();\r\n    Query q = this.em.createQuery(hql);\r\n    q.setParameter(\"mid\", store.getId());\r\n    @SuppressWarnings(\"unchecked\")\r\n    List<Product> products = q.getResultList();\r\n    return products;\r\n}"
}, {
	"Path": "org.roaringbitmap.RoaringBitmap.limit",
	"Comment": "create a new roaring bitmap containing at most maxcardinality integers.",
	"Method": "RoaringBitmap limit(int maxcardinality){\r\n    RoaringBitmap answer = new RoaringBitmap();\r\n    int currentcardinality = 0;\r\n    for (int i = 0; (currentcardinality < maxcardinality) && (i < this.highLowContainer.size()); i++) {\r\n        Container c = this.highLowContainer.getContainerAtIndex(i);\r\n        if (c.getCardinality() + currentcardinality <= maxcardinality) {\r\n            answer.highLowContainer.appendCopy(this.highLowContainer, i);\r\n            currentcardinality += c.getCardinality();\r\n        } else {\r\n            int leftover = maxcardinality - currentcardinality;\r\n            Container limited = c.limit(leftover);\r\n            answer.highLowContainer.append(this.highLowContainer.getKeyAtIndex(i), limited);\r\n            break;\r\n        }\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.MutableRoaringBitmap.addOffset",
	"Comment": "generate a new bitmap that has the same cardinality as x, but withall its values incremented by offset.",
	"Method": "MutableRoaringBitmap addOffset(ImmutableRoaringBitmap x,int offset){\r\n    int container_offset = offset >>> 16;\r\n    int in_container_offset = offset % (1 << 16);\r\n    if (in_container_offset == 0) {\r\n        MutableRoaringBitmap answer = x.toMutableRoaringBitmap();\r\n        for (int pos = 0; pos < answer.highLowContainer.size(); pos++) {\r\n            int key = BufferUtil.toIntUnsigned(answer.getMappeableRoaringArray().getKeyAtIndex(pos));\r\n            key += container_offset;\r\n            if (key > 0xFFFF) {\r\n                throw new IllegalArgumentException(\"Offset too large.\");\r\n            }\r\n            answer.getMappeableRoaringArray().keys[pos] = (short) key;\r\n        }\r\n        return answer;\r\n    } else {\r\n        MutableRoaringBitmap answer = new MutableRoaringBitmap();\r\n        for (int pos = 0; pos < x.highLowContainer.size(); pos++) {\r\n            int key = BufferUtil.toIntUnsigned(x.highLowContainer.getKeyAtIndex(pos));\r\n            key += container_offset;\r\n            if (key > 0xFFFF) {\r\n                throw new IllegalArgumentException(\"Offset too large.\");\r\n            }\r\n            MappeableContainer c = x.highLowContainer.getContainerAtIndex(pos);\r\n            MappeableContainer[] offsetted = BufferUtil.addOffset(c, (short) in_container_offset);\r\n            if (!offsetted[0].isEmpty()) {\r\n                int current_size = answer.highLowContainer.size();\r\n                int lastkey = 0;\r\n                if (current_size > 0) {\r\n                    lastkey = answer.highLowContainer.getKeyAtIndex(current_size - 1);\r\n                }\r\n                if ((current_size > 0) && (lastkey == key)) {\r\n                    MappeableContainer prev = answer.highLowContainer.getContainerAtIndex(current_size - 1);\r\n                    MappeableContainer orresult = prev.ior(offsetted[0]);\r\n                    answer.getMappeableRoaringArray().setContainerAtIndex(current_size - 1, orresult);\r\n                } else {\r\n                    answer.getMappeableRoaringArray().append((short) key, offsetted[0]);\r\n                }\r\n            }\r\n            if (!offsetted[1].isEmpty()) {\r\n                if (key == 0xFFFF) {\r\n                    throw new IllegalArgumentException(\"Offset too large.\");\r\n                }\r\n                answer.getMappeableRoaringArray().append((short) (key + 1), offsetted[1]);\r\n            }\r\n        }\r\n        answer.repairAfterLazy();\r\n        return answer;\r\n    }\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.BufferUtil.getSizeInBytesFromCardinalityEtc",
	"Comment": "from the cardinality of a container, compute the corresponding size in bytes of the container.additional information is required if the container is run encoded.",
	"Method": "int getSizeInBytesFromCardinalityEtc(int card,int numRuns,boolean isRunEncoded){\r\n    if (isRunEncoded) {\r\n        return 2 + numRuns * 2 * 2;\r\n    }\r\n    boolean isBitmap = card > MappeableArrayContainer.DEFAULT_MAX_SIZE;\r\n    if (isBitmap) {\r\n        return MappeableBitmapContainer.MAX_CAPACITY / 8;\r\n    } else {\r\n        return card * 2;\r\n    }\r\n}"
}, {
	"Path": "com.salesmanager.core.business.configuration.DroolsConfiguration.kieShippingCustomContainer",
	"Comment": "this container goes along with shipping custom payment module determines pricing based ondifferent criterias",
	"Method": "KieContainer kieShippingCustomContainer(){\r\n    KieServices kieServices = KieServices.Factory.get();\r\n    KieFileSystem kieFileSystem = kieServices.newKieFileSystem();\r\n    kieFileSystem.write(ResourceFactory.newClassPathResource(SHIPPING_CUSTOM));\r\n    KieBuilder kieBuilder = kieServices.newKieBuilder(kieFileSystem);\r\n    kieBuilder.buildAll();\r\n    KieModule kieModule = kieBuilder.getKieModule();\r\n    return kieServices.newKieContainer(kieModule.getReleaseId());\r\n}"
}, {
	"Path": "com.vip.saturn.job.sharding.service.NamespaceShardingService.shutdownInner",
	"Comment": "firstly, shutdown thread pool. secondly, release my leadership.",
	"Method": "void shutdownInner(boolean shutdownNow){\r\n    lock.lockInterruptibly();\r\n    try {\r\n        if (executorService != null) {\r\n            if (shutdownNow) {\r\n                executorService.shutdownNow();\r\n            } else {\r\n                executorService.shutdown();\r\n            }\r\n        }\r\n        try {\r\n            if (curatorFramework.getZookeeperClient().isConnected()) {\r\n                releaseMyLeadership();\r\n            }\r\n        } catch (Exception e) {\r\n            log.error(namespace + \"-\" + hostValue + \" delete leadership error\", e);\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.MappeableRunContainer.prependValueLength",
	"Comment": "prepend a value length with all values starting from a given value",
	"Method": "void prependValueLength(int value,int index){\r\n    int initialValue = toIntUnsigned(getValue(index));\r\n    int length = toIntUnsigned(getLength(index));\r\n    setValue(index, (short) value);\r\n    setLength(index, (short) (initialValue - value + length));\r\n}"
}, {
	"Path": "com.vip.saturn.job.springboot.GenericSpringBootSaturnApplication.source",
	"Comment": "if you use the springapplication defaults, maybe you could override this method to load the source",
	"Method": "Object source(){\r\n    return this.getClass();\r\n}"
}, {
	"Path": "com.salesmanager.core.business.services.order.OrderServiceImpl.calculateShoppingCartTotal",
	"Comment": "method will be used to calculate shopping cart total as well will update price for eachline items.",
	"Method": "OrderTotalSummary calculateShoppingCartTotal(ShoppingCart shoppingCart,Customer customer,MerchantStore store,Language language,OrderTotalSummary calculateShoppingCartTotal,ShoppingCart shoppingCart,MerchantStore store,Language language){\r\n    Validate.notNull(shoppingCart, \"Order summary cannot be null\");\r\n    Validate.notNull(store, \"MerchantStore cannot be null\");\r\n    try {\r\n        return caculateShoppingCart(shoppingCart, null, store, language);\r\n    } catch (Exception e) {\r\n        LOGGER.error(\"Error while calculating shopping cart total\" + e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.ImmutableRoaringBitmap.isHammingSimilar",
	"Comment": "returns true if the other bitmap has no more than tolerance bitsdiffering from this bitmap. the other may be transformed into a bitmap equalto this bitmap in no more than tolerance bit flips if this method returns true.",
	"Method": "boolean isHammingSimilar(ImmutableRoaringBitmap other,int tolerance){\r\n    final int size1 = highLowContainer.size();\r\n    final int size2 = other.highLowContainer.size();\r\n    int pos1 = 0;\r\n    int pos2 = 0;\r\n    int budget = tolerance;\r\n    while (budget >= 0 && pos1 < size1 && pos2 < size2) {\r\n        final short key1 = highLowContainer.getKeyAtIndex(pos1);\r\n        final short key2 = other.highLowContainer.getKeyAtIndex(pos2);\r\n        MappeableContainer left = highLowContainer.getContainerAtIndex(pos1);\r\n        MappeableContainer right = other.highLowContainer.getContainerAtIndex(pos2);\r\n        if (key1 == key2) {\r\n            budget -= left.xorCardinality(right);\r\n            ++pos1;\r\n            ++pos2;\r\n        } else if (Util.compareUnsigned(key1, key2) < 0) {\r\n            budget -= left.getCardinality();\r\n            ++pos1;\r\n        } else {\r\n            budget -= right.getCardinality();\r\n            ++pos2;\r\n        }\r\n    }\r\n    while (budget >= 0 && pos1 < size1) {\r\n        MappeableContainer container = highLowContainer.getContainerAtIndex(pos1++);\r\n        budget -= container.getCardinality();\r\n    }\r\n    while (budget >= 0 && pos2 < size2) {\r\n        MappeableContainer container = other.highLowContainer.getContainerAtIndex(pos2++);\r\n        budget -= container.getCardinality();\r\n    }\r\n    return budget >= 0;\r\n}"
}, {
	"Path": "com.salesmanager.core.business.modules.cms.content.infinispan.CmsStaticContentFileManagerImpl.addFiles",
	"Comment": "method to add files for given store.files will be stored in infinispan and will be retrievedbased on the storeid. following steps will be performed to store static content filesmerchant node will be retrieved from the cachetree if it exists else new node will becreated.files will be stored in staticcontentcacheattribute , which eventually will be stored ininfinispan",
	"Method": "void addFiles(String merchantStoreCode,List<InputContentFile> inputStaticContentDataList){\r\n    if (cacheManager.getTreeCache() == null) {\r\n        LOGGER.error(\"Unable to find cacheManager.getTreeCache() in Infinispan..\");\r\n        throw new ServiceException(\"CmsStaticContentFileManagerInfinispanImpl has a null cacheManager.getTreeCache()\");\r\n    }\r\n    try {\r\n        for (final InputContentFile inputStaticContentData : inputStaticContentDataList) {\r\n            String nodePath = this.getNodePath(merchantStoreCode, inputStaticContentData.getFileContentType());\r\n            final Node<String, Object> merchantNode = this.getNode(nodePath);\r\n            merchantNode.put(inputStaticContentData.getFileName(), IOUtils.toByteArray(inputStaticContentData.getFile()));\r\n        }\r\n        LOGGER.info(\"Total {} files added successfully.\", inputStaticContentDataList.size());\r\n    } catch (final Exception e) {\r\n        LOGGER.error(\"Error while saving content image\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "com.vip.saturn.job.console.domain.RegistryCenterConfiguration.initNameAndNamespace",
	"Comment": "before invoke this method, be sure that the name and namespace are set, and the namespace cannot be null",
	"Method": "void initNameAndNamespace(){\r\n    if (name != null) {\r\n        this.nameAndNamespace = name + SLASH + namespace;\r\n    } else {\r\n        this.nameAndNamespace = SLASH + namespace;\r\n    }\r\n}"
}, {
	"Path": "org.roaringbitmap.ContainerAppender.flush",
	"Comment": "ensures that any buffered additions are flushed to the underlying bitmap.",
	"Method": "void flush(){\r\n    currentKey += appendToUnderlying();\r\n}"
}, {
	"Path": "org.roaringbitmap.longlong.Roaring64NavigableMap.flip",
	"Comment": "add the value if it is not already present, otherwise remove it.",
	"Method": "void flip(long x){\r\n    int high = RoaringIntPacking.high(x);\r\n    BitmapDataProvider lowBitmap = highToBitmap.get(high);\r\n    if (lowBitmap == null) {\r\n        addLong(x);\r\n    } else {\r\n        int low = RoaringIntPacking.low(x);\r\n        if (lowBitmap instanceof RoaringBitmap) {\r\n            ((RoaringBitmap) lowBitmap).flip(low);\r\n        } else if (lowBitmap instanceof MutableRoaringBitmap) {\r\n            ((MutableRoaringBitmap) lowBitmap).flip(low);\r\n        } else {\r\n            if (lowBitmap.contains(low)) {\r\n                lowBitmap.remove(low);\r\n            } else {\r\n                lowBitmap.add(low);\r\n            }\r\n        }\r\n    }\r\n    invalidateAboveHigh(high);\r\n}"
}, {
	"Path": "org.roaringbitmap.longlong.TestRoaring64NavigableMap.newDefaultCtor",
	"Comment": "used to compare roaring64navigablemap behavior with roaringbitmap",
	"Method": "Roaring64NavigableMap newDefaultCtor(){\r\n    return new Roaring64NavigableMap();\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.ImmutableRoaringBitmap.limit",
	"Comment": "create a new roaring bitmap containing at most maxcardinality integers.",
	"Method": "MutableRoaringBitmap limit(int maxcardinality){\r\n    MutableRoaringBitmap answer = new MutableRoaringBitmap();\r\n    int currentcardinality = 0;\r\n    for (int i = 0; (currentcardinality < maxcardinality) && (i < this.highLowContainer.size()); i++) {\r\n        MappeableContainer c = this.highLowContainer.getContainerAtIndex(i);\r\n        if (c.getCardinality() + currentcardinality <= maxcardinality) {\r\n            ((MutableRoaringArray) answer.highLowContainer).append(this.highLowContainer.getKeyAtIndex(i), c.clone());\r\n            currentcardinality += c.getCardinality();\r\n        } else {\r\n            int leftover = maxcardinality - currentcardinality;\r\n            MappeableContainer limited = c.limit(leftover);\r\n            ((MutableRoaringArray) answer.highLowContainer).append(this.highLowContainer.getKeyAtIndex(i), limited);\r\n            break;\r\n        }\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "com.jiang.android.rxjavaapp.adapter.fragmentadapter.ViewPager.addFocusables",
	"Comment": "we only want the current page that is being shown to be focusable.",
	"Method": "void addFocusables(ArrayList<View> views,int direction,int focusableMode){\r\n    final int focusableCount = views.size();\r\n    final int descendantFocusability = getDescendantFocusability();\r\n    if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {\r\n        for (int i = 0; i < getChildCount(); i++) {\r\n            final View child = getChildAt(i);\r\n            if (child.getVisibility() == VISIBLE) {\r\n                ItemInfo ii = infoForChild(child);\r\n                if (ii != null && ii.position == mCurItem) {\r\n                    child.addFocusables(views, direction, focusableMode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (descendantFocusability != FOCUS_AFTER_DESCENDANTS || (focusableCount == views.size())) {\r\n        if (!isFocusable()) {\r\n            return;\r\n        }\r\n        if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && isInTouchMode() && !isFocusableInTouchMode()) {\r\n            return;\r\n        }\r\n        if (views != null) {\r\n            views.add(this);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.salesmanager.core.business.utils.ProductPriceUtils.getAdminFormatedAmount",
	"Comment": "this is the format that will be displayed\tin the admin input text fields when editing\tan entity having a bigdecimal to be displayed\tas a raw amount 1,299.99\tthe admin user will also be force to input\tthe amount using that format",
	"Method": "String getAdminFormatedAmount(MerchantStore store,BigDecimal amount){\r\n    if (amount == null) {\r\n        return \"\";\r\n    }\r\n    NumberFormat nf = null;\r\n    nf = NumberFormat.getInstance(Constants.DEFAULT_LOCALE);\r\n    nf.setMaximumFractionDigits(Integer.parseInt(Character.toString(DECIMALCOUNT)));\r\n    nf.setMinimumFractionDigits(Integer.parseInt(Character.toString(DECIMALCOUNT)));\r\n    return nf.format(amount);\r\n}"
}, {
	"Path": "org.roaringbitmap.BitSetUtil.equals",
	"Comment": "compares a roaringbitmap and a bitset. they are equal if and only if they contain the same setof integers.",
	"Method": "boolean equals(BitSet bitset,RoaringBitmap bitmap){\r\n    if (bitset.cardinality() != bitmap.getCardinality()) {\r\n        return false;\r\n    }\r\n    final IntIterator it = bitmap.getIntIterator();\r\n    while (it.hasNext()) {\r\n        int val = it.next();\r\n        if (!bitset.get(val)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.roaringbitmap.RoaringBitmapWriter.get",
	"Comment": "flushes any pending changes to the bitmap and returns the bitmap",
	"Method": "RoaringBitmapWriter<T> get(RoaringBitmapWriter<T> get,T get){\r\n    flush();\r\n    return getUnderlying();\r\n}"
}, {
	"Path": "org.roaringbitmap.ParallelAggregation.xor",
	"Comment": "computes the bitwise symmetric difference of the input bitmaps",
	"Method": "RoaringBitmap xor(RoaringBitmap bitmaps,Container xor,List<Container> containers){\r\n    Container result = containers.get(0).clone();\r\n    for (int i = 1; i < containers.size(); ++i) {\r\n        result = result.ixor(containers.get(i));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.MappeableContainer.xorCardinality",
	"Comment": "returns the cardinality of the xor between the passed container and thiscontainer without materialising a temporary container.",
	"Method": "int xorCardinality(MappeableContainer other){\r\n    return getCardinality() + other.getCardinality() - 2 * andCardinality(other);\r\n}"
}, {
	"Path": "com.salesmanager.core.business.repositories.catalog.product.ProductRepositoryImpl.getProductsListForLocale",
	"Comment": "this query is used for category listings. all collections are not fully loaded, only the required objects\tso the listing page can display everything related to all products",
	"Method": "ProductList getProductsListForLocale(MerchantStore store,Set categoryIds,Language language,Locale locale,int first,int max){\r\n    List regionList = new ArrayList();\r\n    regionList.add(Constants.ALL_REGIONS);\r\n    if (locale != null) {\r\n        regionList.add(locale.getCountry());\r\n    }\r\n    ProductList productList = new ProductList();\r\n    Query countQ = this.em.createQuery(\"select count(p) from Product as p INNER JOIN p.availabilities pa INNER JOIN p.categories categs where p.merchantStore.id=:mId and categs.id in (:cid) and pa.region in (:lid) and p.available=1 and p.dateAvailable<=:dt\");\r\n    countQ.setParameter(\"cid\", categoryIds);\r\n    countQ.setParameter(\"lid\", regionList);\r\n    countQ.setParameter(\"dt\", new Date());\r\n    countQ.setParameter(\"mId\", store.getId());\r\n    Number count = (Number) countQ.getSingleResult();\r\n    productList.setTotalCount(count.intValue());\r\n    if (count.intValue() == 0)\r\n        return productList;\r\n    StringBuilder qs = new StringBuilder();\r\n    qs.append(\"select p from Product as p \");\r\n    qs.append(\"join fetch p.merchantStore merch \");\r\n    qs.append(\"join fetch p.availabilities pa \");\r\n    qs.append(\"left join fetch pa.prices pap \");\r\n    qs.append(\"join fetch p.descriptions pd \");\r\n    qs.append(\"join fetch p.categories categs \");\r\n    qs.append(\"left join fetch p.images images \");\r\n    qs.append(\"left join fetch p.manufacturer manuf \");\r\n    qs.append(\"left join fetch manuf.descriptions manufd \");\r\n    qs.append(\"left join fetch p.type type \");\r\n    qs.append(\"left join fetch p.taxClass tx \");\r\n    qs.append(\"left join fetch p.owner owner \");\r\n    qs.append(\"where p.merchantStore.id=mId and categs.id in (:cid) and pa.region in (:lid) \");\r\n    qs.append(\"and p.available=true and p.dateAvailable<=:dt and pd.language.id=:lang\");\r\n    qs.append(\" order by p.sortOrder asc\");\r\n    String hql = qs.toString();\r\n    Query q = this.em.createQuery(hql);\r\n    q.setParameter(\"cid\", categoryIds);\r\n    q.setParameter(\"lid\", regionList);\r\n    q.setParameter(\"dt\", new Date());\r\n    q.setParameter(\"lang\", language.getId());\r\n    q.setParameter(\"mId\", store.getId());\r\n    q.setFirstResult(first);\r\n    if (max > 0) {\r\n        int maxCount = first + max;\r\n        if (maxCount < count.intValue()) {\r\n            q.setMaxResults(maxCount);\r\n        } else {\r\n            q.setMaxResults(count.intValue());\r\n        }\r\n    }\r\n    List<Product> products = q.getResultList();\r\n    productList.setProducts(products);\r\n    return productList;\r\n}"
}, {
	"Path": "org.roaringbitmap.ArrayContainer.toShortBuffer",
	"Comment": "return the content of this container as a shortbuffer. this creates a copy and might berelatively slow.",
	"Method": "ShortBuffer toShortBuffer(){\r\n    ShortBuffer sb = ShortBuffer.allocate(this.cardinality);\r\n    sb.put(this.content, 0, this.cardinality);\r\n    return sb;\r\n}"
}, {
	"Path": "com.vip.saturn.job.console.utils.CronExpression.setCalendarHour",
	"Comment": "advance the calendar to the particular hour paying particular attention to daylight saving problems.",
	"Method": "void setCalendarHour(Calendar cal,int hour){\r\n    cal.set(java.util.Calendar.HOUR_OF_DAY, hour);\r\n    if (cal.get(java.util.Calendar.HOUR_OF_DAY) != hour && hour != 24) {\r\n        cal.set(java.util.Calendar.HOUR_OF_DAY, hour + 1);\r\n    }\r\n}"
}, {
	"Path": "com.jiang.android.rxjavaapp.database.operatorsDao.loadAllDeepFromCursor",
	"Comment": "reads all available rows from the given cursor and returns a list of new imageto objects.",
	"Method": "List<operators> loadAllDeepFromCursor(Cursor cursor){\r\n    int count = cursor.getCount();\r\n    List<operators> list = new ArrayList<operators>(count);\r\n    if (cursor.moveToFirst()) {\r\n        if (identityScope != null) {\r\n            identityScope.lock();\r\n            identityScope.reserveRoom(count);\r\n        }\r\n        try {\r\n            do {\r\n                list.add(loadCurrentDeep(cursor, false));\r\n            } while (cursor.moveToNext());\r\n        } finally {\r\n            if (identityScope != null) {\r\n                identityScope.unlock();\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "com.jiang.android.rxjavaapp.adapter.fragmentadapter.ViewPager.getOffscreenPageLimit",
	"Comment": "returns the number of pages that will be retained to either side of thecurrent page in the view hierarchy in an idle state. defaults to 1.",
	"Method": "int getOffscreenPageLimit(){\r\n    return mOffscreenPageLimit;\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.ImmutableRoaringBitmap.contains",
	"Comment": "checks whether the parameter is a subset of this roaringbitmap or not",
	"Method": "boolean contains(int x,boolean contains,long minimum,long supremum,boolean contains,ImmutableRoaringBitmap subset){\r\n    if (subset.getCardinality() > getCardinality()) {\r\n        return false;\r\n    }\r\n    final int length1 = this.highLowContainer.size();\r\n    final int length2 = subset.highLowContainer.size();\r\n    int pos1 = 0, pos2 = 0;\r\n    while (pos1 < length1 && pos2 < length2) {\r\n        final short s1 = this.highLowContainer.getKeyAtIndex(pos1);\r\n        final short s2 = subset.highLowContainer.getKeyAtIndex(pos2);\r\n        if (s1 == s2) {\r\n            MappeableContainer c1 = this.highLowContainer.getContainerAtIndex(pos1);\r\n            MappeableContainer c2 = subset.highLowContainer.getContainerAtIndex(pos2);\r\n            if (!c1.contains(c2)) {\r\n                return false;\r\n            }\r\n            ++pos1;\r\n            ++pos2;\r\n        } else if (compareUnsigned(s1, s2) > 0) {\r\n            return false;\r\n        } else {\r\n            pos1 = subset.highLowContainer.advanceUntil(s2, pos1);\r\n        }\r\n    }\r\n    return pos2 == length2;\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.ImmutableRoaringBitmap.toArray",
	"Comment": "return the set values as an array if the cardinality is lessthan 2147483648. the integer values are in sorted order.",
	"Method": "int[] toArray(){\r\n    final int[] array = new int[this.getCardinality()];\r\n    int pos = 0, pos2 = 0;\r\n    while (pos < this.highLowContainer.size()) {\r\n        final int hs = BufferUtil.toIntUnsigned(this.highLowContainer.getKeyAtIndex(pos)) << 16;\r\n        final MappeableContainer c = this.highLowContainer.getContainerAtIndex(pos++);\r\n        c.fillLeastSignificant16bits(array, pos2, hs);\r\n        pos2 += c.getCardinality();\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.ImmutableRoaringBitmap.toMutableRoaringBitmap",
	"Comment": "copies the content of this bitmap to a bitmap that can be modified.",
	"Method": "MutableRoaringBitmap toMutableRoaringBitmap(){\r\n    MutableRoaringBitmap c = new MutableRoaringBitmap();\r\n    MappeableContainerPointer mcp = highLowContainer.getContainerPointer();\r\n    while (mcp.hasContainer()) {\r\n        c.getMappeableRoaringArray().appendCopy(mcp.key(), mcp.getContainer());\r\n        mcp.advance();\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.MappeableContainer.rangeOfOnes",
	"Comment": "create a container initialized with a range of consecutive values",
	"Method": "MappeableContainer rangeOfOnes(int start,int last){\r\n    final int arrayContainerOverRunThreshold = 2;\r\n    final int cardinality = last - start;\r\n    if (cardinality <= arrayContainerOverRunThreshold) {\r\n        return new MappeableArrayContainer(start, last);\r\n    }\r\n    return new MappeableRunContainer(start, last);\r\n}"
}, {
	"Path": "com.salesmanager.core.business.utils.ProductPriceUtils.getFinalPrice",
	"Comment": "this is the final price calculated from all configured prices\tand all possibles discounts. this price does not calculate the attributes\tor other prices than the default one",
	"Method": "FinalPrice getFinalPrice(Product product){\r\n    FinalPrice finalPrice = calculateFinalPrice(product);\r\n    BigDecimal attributePrice = null;\r\n    if (product.getAttributes() != null && product.getAttributes().size() > 0) {\r\n        for (ProductAttribute attribute : product.getAttributes()) {\r\n            if (attribute.getAttributeDefault()) {\r\n                if (attribute.getProductAttributePrice() != null && attribute.getProductAttributePrice().doubleValue() > 0) {\r\n                    if (attributePrice == null) {\r\n                        attributePrice = new BigDecimal(0);\r\n                    }\r\n                    attributePrice = attributePrice.add(attribute.getProductAttributePrice());\r\n                }\r\n            }\r\n        }\r\n        if (attributePrice != null && attributePrice.doubleValue() > 0) {\r\n            BigDecimal fp = finalPrice.getFinalPrice();\r\n            fp = fp.add(attributePrice);\r\n            finalPrice.setFinalPrice(fp);\r\n            BigDecimal op = finalPrice.getOriginalPrice();\r\n            op = op.add(attributePrice);\r\n            finalPrice.setOriginalPrice(op);\r\n        }\r\n    }\r\n    return finalPrice;\r\n}"
}, {
	"Path": "com.salesmanager.core.business.utils.ProductPriceUtils.getAdminFormatedAmountWithCurrency",
	"Comment": "this method will return the required formated amount\twith the appropriate currency",
	"Method": "String getAdminFormatedAmountWithCurrency(MerchantStore store,BigDecimal amount){\r\n    if (amount == null) {\r\n        return \"\";\r\n    }\r\n    NumberFormat nf = null;\r\n    Currency currency = store.getCurrency().getCurrency();\r\n    nf = NumberFormat.getInstance(Constants.DEFAULT_LOCALE);\r\n    nf.setMaximumFractionDigits(Integer.parseInt(Character.toString(DECIMALCOUNT)));\r\n    nf.setMinimumFractionDigits(Integer.parseInt(Character.toString(DECIMALCOUNT)));\r\n    nf.setCurrency(currency);\r\n    return nf.format(amount);\r\n}"
}, {
	"Path": "com.vip.saturn.job.console.service.impl.RegistryCenterServiceImpl.closeZkCluster",
	"Comment": "close dashboardleadertreecache, registrycenterclient, namespaceshardinglistenermanager with this zkcluster",
	"Method": "void closeZkCluster(ZkCluster zkCluster){\r\n    try {\r\n        try {\r\n            DashboardLeaderHandler dashboardLeaderHandler = dashboardLeaderTreeCacheMap.remove(zkCluster.getZkClusterKey());\r\n            if (dashboardLeaderHandler != null) {\r\n                dashboardLeaderHandler.shutdown();\r\n            }\r\n        } catch (Exception e) {\r\n            log.error(e.getMessage(), e);\r\n        }\r\n        ArrayList<RegistryCenterConfiguration> regCenterConfList = zkCluster.getRegCenterConfList();\r\n        if (regCenterConfList != null) {\r\n            for (RegistryCenterConfiguration conf : regCenterConfList) {\r\n                String nns = conf.getNameAndNamespace();\r\n                synchronized (getNnsLock(nns)) {\r\n                    closeNamespace(nns);\r\n                }\r\n            }\r\n        }\r\n        if (zkCluster.getConnectionListener() != null) {\r\n            zkCluster.getConnectionListener().shutdownNowUntilTerminated();\r\n            zkCluster.setConnectionListener(null);\r\n        }\r\n        if (zkCluster.getCuratorFrameworkOp() != null && zkCluster.getCuratorFrameworkOp().getCuratorFramework() != null) {\r\n            zkCluster.getCuratorFrameworkOp().getCuratorFramework().close();\r\n        }\r\n    } catch (Exception e) {\r\n        log.error(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.roaringbitmap.Util.unsignedIntersect2by2",
	"Comment": "intersect two sorted lists and write the result to the provided output array",
	"Method": "int unsignedIntersect2by2(short[] set1,int length1,short[] set2,int length2,short[] buffer){\r\n    final int THRESHOLD = 25;\r\n    if (set1.length * THRESHOLD < set2.length) {\r\n        return unsignedOneSidedGallopingIntersect2by2(set1, length1, set2, length2, buffer);\r\n    } else if (set2.length * THRESHOLD < set1.length) {\r\n        return unsignedOneSidedGallopingIntersect2by2(set2, length2, set1, length1, buffer);\r\n    } else {\r\n        return unsignedLocalIntersect2by2(set1, length1, set2, length2, buffer);\r\n    }\r\n}"
}, {
	"Path": "org.roaringbitmap.RoaringBitmap.toArray",
	"Comment": "return the set values as an array, if the cardinality is smaller than 2147483648.the integer values are in sorted order.",
	"Method": "int[] toArray(){\r\n    final int[] array = new int[this.getCardinality()];\r\n    int pos = 0, pos2 = 0;\r\n    while (pos < this.highLowContainer.size()) {\r\n        final int hs = this.highLowContainer.getKeyAtIndex(pos) << 16;\r\n        Container c = this.highLowContainer.getContainerAtIndex(pos++);\r\n        c.fillLeastSignificant16bits(array, pos2, hs);\r\n        pos2 += c.getCardinality();\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "com.jiang.android.rxjavaapp.adapter.fragmentadapter.PagerAdapter.getPageTitle",
	"Comment": "this method may be called by the viewpager to obtain a title stringto describe the specified page. this method may return nullindicating no title for this page. the default implementation returnsnull.",
	"Method": "CharSequence getPageTitle(int position){\r\n    return null;\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.BufferFastAggregation.convertToImmutable",
	"Comment": "convenience method converting one type of iterator into another, to avoid unnecessary warnings.",
	"Method": "Iterator<ImmutableRoaringBitmap> convertToImmutable(Iterator<MutableRoaringBitmap> i,ImmutableRoaringBitmap[] convertToImmutable,MutableRoaringBitmap[] array){\r\n    ImmutableRoaringBitmap[] answer = new ImmutableRoaringBitmap[array.length];\r\n    System.arraycopy(array, 0, answer, 0, answer.length);\r\n    return answer;\r\n}"
}, {
	"Path": "com.salesmanager.core.business.utils.ProductPriceUtils.getFormatedAmountWithCurrency",
	"Comment": "returns a formatted amount using shopizer currency\trequires internal java.util.currency populated",
	"Method": "String getFormatedAmountWithCurrency(Locale locale,com.salesmanager.core.model.reference.currency.Currency currency,BigDecimal amount,String getFormatedAmountWithCurrency,com.salesmanager.core.model.reference.currency.Currency currency,BigDecimal amount,String getFormatedAmountWithCurrency,MerchantStore store,BigDecimal amount,Locale locale){\r\n    NumberFormat nf = null;\r\n    Currency currency = store.getCurrency().getCurrency();\r\n    nf = NumberFormat.getInstance(locale);\r\n    nf.setCurrency(currency);\r\n    nf.setMaximumFractionDigits(Integer.parseInt(Character.toString(DECIMALCOUNT)));\r\n    nf.setMinimumFractionDigits(Integer.parseInt(Character.toString(DECIMALCOUNT)));\r\n    return nf.format(amount);\r\n}"
}, {
	"Path": "org.roaringbitmap.RoaringBitmap.addOffset",
	"Comment": "generate a new bitmap that has the same cardinality as x, but withall its values incremented by offset.",
	"Method": "RoaringBitmap addOffset(RoaringBitmap x,int offset){\r\n    int container_offset = offset >>> 16;\r\n    int in_container_offset = offset % (1 << 16);\r\n    if (in_container_offset == 0) {\r\n        RoaringBitmap answer = x.clone();\r\n        for (int pos = 0; pos < answer.highLowContainer.size(); pos++) {\r\n            int key = Util.toIntUnsigned(answer.highLowContainer.getKeyAtIndex(pos));\r\n            key += container_offset;\r\n            if (key > 0xFFFF) {\r\n                throw new IllegalArgumentException(\"Offset too large.\");\r\n            }\r\n            answer.highLowContainer.keys[pos] = (short) key;\r\n        }\r\n        return answer;\r\n    } else {\r\n        RoaringBitmap answer = new RoaringBitmap();\r\n        for (int pos = 0; pos < x.highLowContainer.size(); pos++) {\r\n            int key = Util.toIntUnsigned(x.highLowContainer.getKeyAtIndex(pos));\r\n            key += container_offset;\r\n            if (key > 0xFFFF) {\r\n                throw new IllegalArgumentException(\"Offset too large.\");\r\n            }\r\n            Container c = x.highLowContainer.getContainerAtIndex(pos);\r\n            Container[] offsetted = Util.addOffset(c, (short) in_container_offset);\r\n            if (!offsetted[0].isEmpty()) {\r\n                int current_size = answer.highLowContainer.size();\r\n                int lastkey = 0;\r\n                if (current_size > 0) {\r\n                    lastkey = answer.highLowContainer.getKeyAtIndex(current_size - 1);\r\n                }\r\n                if ((current_size > 0) && (lastkey == key)) {\r\n                    Container prev = answer.highLowContainer.getContainerAtIndex(current_size - 1);\r\n                    Container orresult = prev.ior(offsetted[0]);\r\n                    answer.highLowContainer.setContainerAtIndex(current_size - 1, orresult);\r\n                } else {\r\n                    answer.highLowContainer.append((short) key, offsetted[0]);\r\n                }\r\n            }\r\n            if (!offsetted[1].isEmpty()) {\r\n                if (key == 0xFFFF) {\r\n                    throw new IllegalArgumentException(\"Offset too large.\");\r\n                }\r\n                answer.highLowContainer.append((short) (key + 1), offsetted[1]);\r\n            }\r\n        }\r\n        answer.repairAfterLazy();\r\n        return answer;\r\n    }\r\n}"
}, {
	"Path": "com.salesmanager.core.business.utils.ProductPriceUtils.getFinalProductPrice",
	"Comment": "this method calculates the final price taking into account\tall attributes included having a specified default attribute with an attribute price gt 0\tin the product object. the calculation is based\ton the default price.\tattributes may be null",
	"Method": "FinalPrice getFinalProductPrice(Product product,List<ProductAttribute> attributes){\r\n    FinalPrice finalPrice = calculateFinalPrice(product);\r\n    BigDecimal attributePrice = null;\r\n    if (attributes != null && attributes.size() > 0) {\r\n        for (ProductAttribute attribute : attributes) {\r\n            if (attribute.getProductAttributePrice() != null && attribute.getProductAttributePrice().doubleValue() > 0) {\r\n                if (attributePrice == null) {\r\n                    attributePrice = new BigDecimal(0);\r\n                }\r\n                attributePrice = attributePrice.add(attribute.getProductAttributePrice());\r\n            }\r\n        }\r\n        if (attributePrice != null && attributePrice.doubleValue() > 0) {\r\n            BigDecimal fp = finalPrice.getFinalPrice();\r\n            fp = fp.add(attributePrice);\r\n            finalPrice.setFinalPrice(fp);\r\n            BigDecimal op = finalPrice.getOriginalPrice();\r\n            op = op.add(attributePrice);\r\n            finalPrice.setOriginalPrice(op);\r\n            BigDecimal dp = finalPrice.getDiscountedPrice();\r\n            if (dp != null) {\r\n                dp = dp.add(attributePrice);\r\n                finalPrice.setDiscountedPrice(dp);\r\n            }\r\n        }\r\n    }\r\n    return finalPrice;\r\n}"
}, {
	"Path": "org.roaringbitmap.RunContainer.hybridUnsignedInterleavedBinarySearch",
	"Comment": "starts with binary search and finishes with a sequential search",
	"Method": "int hybridUnsignedInterleavedBinarySearch(short[] array,int begin,int end,short k){\r\n    int ikey = toIntUnsigned(k);\r\n    int low = begin;\r\n    int high = end - 1;\r\n    while (low + 16 <= high) {\r\n        final int middleIndex = (low + high) >>> 1;\r\n        final int middleValue = toIntUnsigned(array[2 * middleIndex]);\r\n        if (middleValue < ikey) {\r\n            low = middleIndex + 1;\r\n        } else if (middleValue > ikey) {\r\n            high = middleIndex - 1;\r\n        } else {\r\n            return middleIndex;\r\n        }\r\n    }\r\n    int x = low;\r\n    for (; x <= high; ++x) {\r\n        final int val = toIntUnsigned(array[2 * x]);\r\n        if (val >= ikey) {\r\n            if (val == ikey) {\r\n                return x;\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return -(x + 1);\r\n}"
}, {
	"Path": "org.roaringbitmap.RoaringBitmap.select",
	"Comment": "return the jth value stored in this bitmap. the provided valueneeds to be smaller than the cardinality otherwise anillegalargumentexceptionexception is thrown.",
	"Method": "int select(int j){\r\n    long leftover = Util.toUnsignedLong(j);\r\n    for (int i = 0; i < this.highLowContainer.size(); i++) {\r\n        Container c = this.highLowContainer.getContainerAtIndex(i);\r\n        int thiscard = c.getCardinality();\r\n        if (thiscard > leftover) {\r\n            int keycontrib = this.highLowContainer.getKeyAtIndex(i) << 16;\r\n            int lowcontrib = Util.toIntUnsigned(c.select((int) leftover));\r\n            return lowcontrib + keycontrib;\r\n        }\r\n        leftover -= thiscard;\r\n    }\r\n    throw new IllegalArgumentException(\"You are trying to select the \" + j + \"th value when the cardinality is \" + this.getCardinality() + \".\");\r\n}"
}, {
	"Path": "com.vip.saturn.job.console.utils.CronExpression.isSatisfiedBy",
	"Comment": "indicates whether the given date satisfies the cron expression. note that milliseconds are ignored, so two dates\tfalling on different milliseconds of the same second will always have the same result here.",
	"Method": "boolean isSatisfiedBy(Date date){\r\n    Calendar testDateCal = Calendar.getInstance(getTimeZone());\r\n    testDateCal.setTime(date);\r\n    testDateCal.set(Calendar.MILLISECOND, 0);\r\n    Date originalDate = testDateCal.getTime();\r\n    testDateCal.add(Calendar.SECOND, -1);\r\n    Date timeAfter = getTimeAfter(testDateCal.getTime());\r\n    return ((timeAfter != null) && (timeAfter.equals(originalDate)));\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.MutableRoaringArray.appendCopiesUntil",
	"Comment": "append copies of the values from another array, from the start",
	"Method": "void appendCopiesUntil(PointableRoaringArray highLowContainer,short stoppingKey){\r\n    final int stopKey = toIntUnsigned(stoppingKey);\r\n    MappeableContainerPointer cp = highLowContainer.getContainerPointer();\r\n    while (cp.hasContainer()) {\r\n        if (toIntUnsigned(cp.key()) >= stopKey) {\r\n            break;\r\n        }\r\n        extendArray(1);\r\n        this.keys[this.size] = cp.key();\r\n        this.values[this.size] = cp.getContainer().clone();\r\n        this.size++;\r\n        cp.advance();\r\n    }\r\n}"
}, {
	"Path": "org.roaringbitmap.RoaringBitmap.contains",
	"Comment": "checks whether the parameter is a subset of this roaringbitmap or not",
	"Method": "boolean contains(int x,boolean contains,long minimum,long supremum,boolean contains,RoaringBitmap subset){\r\n    if (subset.getCardinality() > getCardinality()) {\r\n        return false;\r\n    }\r\n    final int length1 = this.highLowContainer.size;\r\n    final int length2 = subset.highLowContainer.size;\r\n    int pos1 = 0, pos2 = 0;\r\n    while (pos1 < length1 && pos2 < length2) {\r\n        final short s1 = this.highLowContainer.getKeyAtIndex(pos1);\r\n        final short s2 = subset.highLowContainer.getKeyAtIndex(pos2);\r\n        if (s1 == s2) {\r\n            Container c1 = this.highLowContainer.getContainerAtIndex(pos1);\r\n            Container c2 = subset.highLowContainer.getContainerAtIndex(pos2);\r\n            if (!c1.contains(c2)) {\r\n                return false;\r\n            }\r\n            ++pos1;\r\n            ++pos2;\r\n        } else if (Util.compareUnsigned(s1, s2) > 0) {\r\n            return false;\r\n        } else {\r\n            pos1 = subset.highLowContainer.advanceUntil(s2, pos1);\r\n        }\r\n    }\r\n    return pos2 == length2;\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.MappeableRunContainer.toBitmapOrArrayContainer",
	"Comment": "convert the container to either a bitmap or an array container, depending on the cardinality.",
	"Method": "MappeableContainer toBitmapOrArrayContainer(int card){\r\n    if (card <= MappeableArrayContainer.DEFAULT_MAX_SIZE) {\r\n        MappeableArrayContainer answer = new MappeableArrayContainer(card);\r\n        answer.cardinality = 0;\r\n        for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {\r\n            int runStart = toIntUnsigned(this.getValue(rlepos));\r\n            int runEnd = runStart + toIntUnsigned(this.getLength(rlepos));\r\n            for (int runValue = runStart; runValue <= runEnd; ++runValue) {\r\n                answer.content.put(answer.cardinality++, (short) runValue);\r\n            }\r\n        }\r\n        return answer;\r\n    }\r\n    MappeableBitmapContainer answer = new MappeableBitmapContainer();\r\n    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {\r\n        int start = toIntUnsigned(this.getValue(rlepos));\r\n        int end = start + toIntUnsigned(this.getLength(rlepos)) + 1;\r\n        BufferUtil.setBitmapRange(answer.bitmap, start, end);\r\n    }\r\n    answer.cardinality = card;\r\n    return answer;\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.MappeableRunContainer.toShortArray",
	"Comment": "create a copy of the content of this container as a short array. this creates a copy.",
	"Method": "short[] toShortArray(){\r\n    short[] answer = new short[2 * nbrruns];\r\n    valueslength.rewind();\r\n    valueslength.get(answer);\r\n    return answer;\r\n}"
}, {
	"Path": "com.salesmanager.core.business.modules.cms.content.infinispan.CmsStaticContentFileManagerImpl.addFile",
	"Comment": "method to add static content data for given merchant.static content data can be of followingtype1. css and js files2. digital data like audio or videomerchant store code will be used to create cache node where merchant data will be stored,inputdata will contain name, file as well type of data being stored.",
	"Method": "void addFile(String merchantStoreCode,InputContentFile inputStaticContentData){\r\n    if (cacheManager.getTreeCache() == null) {\r\n        LOGGER.error(\"Unable to find cacheManager.getTreeCache() in Infinispan..\");\r\n        throw new ServiceException(\"CmsStaticContentFileManagerInfinispanImpl has a null cacheManager.getTreeCache()\");\r\n    }\r\n    try {\r\n        String nodePath = this.getNodePath(merchantStoreCode, inputStaticContentData.getFileContentType());\r\n        final Node<String, Object> merchantNode = this.getNode(nodePath);\r\n        merchantNode.put(inputStaticContentData.getFileName(), IOUtils.toByteArray(inputStaticContentData.getFile()));\r\n        LOGGER.info(\"Content data added successfully.\");\r\n    } catch (final Exception e) {\r\n        LOGGER.error(\"Error while saving static content data\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.roaringbitmap.Container.intersects",
	"Comment": "returns true if the current container intersects the other container.",
	"Method": "boolean intersects(ArrayContainer x,boolean intersects,BitmapContainer x,boolean intersects,Container x,boolean intersects,RunContainer x,boolean intersects,int minimum,int supremum){\r\n    if (x instanceof ArrayContainer) {\r\n        return intersects((ArrayContainer) x);\r\n    } else if (x instanceof BitmapContainer) {\r\n        return intersects((BitmapContainer) x);\r\n    }\r\n    return intersects((RunContainer) x);\r\n}"
}, {
	"Path": "org.roaringbitmap.Util.unsignedUnion2by2",
	"Comment": "unite two sorted lists and write the result to the provided output array",
	"Method": "int unsignedUnion2by2(short[] set1,int offset1,int length1,short[] set2,int offset2,int length2,short[] buffer){\r\n    if (0 == length2) {\r\n        System.arraycopy(set1, offset1, buffer, 0, length1);\r\n        return length1;\r\n    }\r\n    if (0 == length1) {\r\n        System.arraycopy(set2, offset2, buffer, 0, length2);\r\n        return length2;\r\n    }\r\n    int pos = 0;\r\n    int k1 = offset1, k2 = offset2;\r\n    short s1 = set1[k1];\r\n    short s2 = set2[k2];\r\n    while (true) {\r\n        int v1 = toIntUnsigned(s1);\r\n        int v2 = toIntUnsigned(s2);\r\n        if (v1 < v2) {\r\n            buffer[pos++] = s1;\r\n            ++k1;\r\n            if (k1 >= length1 + offset1) {\r\n                System.arraycopy(set2, k2, buffer, pos, length2 - k2 + offset2);\r\n                return pos + length2 - k2 + offset2;\r\n            }\r\n            s1 = set1[k1];\r\n        } else if (v1 == v2) {\r\n            buffer[pos++] = s1;\r\n            ++k1;\r\n            ++k2;\r\n            if (k1 >= length1 + offset1) {\r\n                System.arraycopy(set2, k2, buffer, pos, length2 - k2 + offset2);\r\n                return pos + length2 - k2 + offset2;\r\n            }\r\n            if (k2 >= length2 + offset2) {\r\n                System.arraycopy(set1, k1, buffer, pos, length1 - k1 + offset1);\r\n                return pos + length1 - k1 + offset1;\r\n            }\r\n            s1 = set1[k1];\r\n            s2 = set2[k2];\r\n        } else {\r\n            buffer[pos++] = s2;\r\n            ++k2;\r\n            if (k2 >= length2 + offset2) {\r\n                System.arraycopy(set1, k1, buffer, pos, length1 - k1 + offset1);\r\n                return pos + length1 - k1 + offset1;\r\n            }\r\n            s2 = set2[k2];\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.jiang.android.rxjavaapp.adapter.fragmentadapter.ViewPager.addTouchables",
	"Comment": "we only want the current page that is being shown to be touchable.",
	"Method": "void addTouchables(ArrayList<View> views){\r\n    for (int i = 0; i < getChildCount(); i++) {\r\n        final View child = getChildAt(i);\r\n        if (child.getVisibility() == VISIBLE) {\r\n            ItemInfo ii = infoForChild(child);\r\n            if (ii != null && ii.position == mCurItem) {\r\n                child.addTouchables(views);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.jiang.android.rxjavaapp.adapter.fragmentadapter.ViewPager.clearOnPageChangeListeners",
	"Comment": "remove all listeners that are notified of any changes in scroll state or position.",
	"Method": "void clearOnPageChangeListeners(){\r\n    if (mOnPageChangeListeners != null) {\r\n        mOnPageChangeListeners.clear();\r\n    }\r\n}"
}, {
	"Path": "com.vip.saturn.job.console.utils.CronExpression.isValidExpression",
	"Comment": "indicates whether the specified cron expression can be parsed into a valid cron expression",
	"Method": "boolean isValidExpression(String cronExpression){\r\n    try {\r\n        new CronExpression(cronExpression);\r\n    } catch (ParseException pe) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.jiang.android.rxjavaapp.adapter.fragmentadapter.PagerAdapter.saveState",
	"Comment": "save any instance state associated with this adapter and its pages that should berestored if the current ui state needs to be reconstructed.",
	"Method": "Parcelable saveState(){\r\n    return null;\r\n}"
}, {
	"Path": "com.jiang.android.rxjavaapp.database.alloperatorsDao.loadAllDeepFromCursor",
	"Comment": "reads all available rows from the given cursor and returns a list of new imageto objects.",
	"Method": "List<alloperators> loadAllDeepFromCursor(Cursor cursor){\r\n    int count = cursor.getCount();\r\n    List<alloperators> list = new ArrayList<alloperators>(count);\r\n    if (cursor.moveToFirst()) {\r\n        if (identityScope != null) {\r\n            identityScope.lock();\r\n            identityScope.reserveRoom(count);\r\n        }\r\n        try {\r\n            do {\r\n                list.add(loadCurrentDeep(cursor, false));\r\n            } while (cursor.moveToNext());\r\n        } finally {\r\n            if (identityScope != null) {\r\n                identityScope.unlock();\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.MappeableBitmapContainer.serializedSizeInBytes",
	"Comment": "the parameter is for overloading and symmetry with arraycontainer",
	"Method": "int serializedSizeInBytes(int unusedCardinality,int serializedSizeInBytes){\r\n    return serializedSizeInBytes(0);\r\n}"
}, {
	"Path": "com.salesmanager.core.business.modules.cms.content.local.CmsStaticContentFileManagerImpl.addFile",
	"Comment": "method to add static content data for given merchant.static content data can be of followingtype1. css and js files2. digital data like audio or videomerchant store code will be used to create cache node where merchant data will be stored,inputdata will contain name, file as well type of data being stored.",
	"Method": "void addFile(String merchantStoreCode,InputContentFile inputStaticContentData){\r\n    try {\r\n        String rootPath = this.buildRootPath();\r\n        Path confDir = Paths.get(rootPath);\r\n        this.createDirectoryIfNorExist(confDir);\r\n        StringBuilder nodePath = new StringBuilder();\r\n        nodePath.append(rootPath).append(merchantStoreCode);\r\n        Path merchantPath = Paths.get(nodePath.toString());\r\n        this.createDirectoryIfNorExist(merchantPath);\r\n        nodePath.append(Constants.SLASH).append(inputStaticContentData.getFileContentType()).append(Constants.SLASH);\r\n        Path dirPath = Paths.get(nodePath.toString());\r\n        this.createDirectoryIfNorExist(dirPath);\r\n        nodePath.append(inputStaticContentData.getFileName());\r\n        Path path = Paths.get(nodePath.toString());\r\n        Files.copy(inputStaticContentData.getFile(), path, StandardCopyOption.REPLACE_EXISTING);\r\n        LOGGER.info(\"Content data added successfully.\");\r\n    } catch (final Exception e) {\r\n        LOGGER.error(\"Error while saving static content data\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.roaringbitmap.FastRankRoaringBitmap.getIntRankIterator",
	"Comment": "get a special iterator that allows .peeknextrank efficiently",
	"Method": "PeekableIntRankIterator getIntRankIterator(){\r\n    preComputeCardinalities();\r\n    return new FastRoaringIntRankIterator();\r\n}"
}, {
	"Path": "com.jiang.android.rxjavaapp.adapter.fragmentadapter.ViewPager.setAdapter",
	"Comment": "set a pageradapter that will supply views for this pager as needed.",
	"Method": "void setAdapter(PagerAdapter adapter){\r\n    if (mAdapter != null) {\r\n        mAdapter.unregisterDataSetObserver(mObserver);\r\n        mAdapter.startUpdate(this);\r\n        for (int i = 0; i < mItems.size(); i++) {\r\n            final ItemInfo ii = mItems.get(i);\r\n            mAdapter.destroyItem(this, ii.position, ii.object);\r\n        }\r\n        mAdapter.finishUpdate(this);\r\n        mItems.clear();\r\n        removeNonDecorViews();\r\n        mCurItem = 0;\r\n        scrollTo(0, 0);\r\n    }\r\n    final PagerAdapter oldAdapter = mAdapter;\r\n    mAdapter = adapter;\r\n    mExpectedAdapterCount = 0;\r\n    if (mAdapter != null) {\r\n        if (mObserver == null) {\r\n            mObserver = new PagerObserver();\r\n        }\r\n        mAdapter.registerDataSetObserver(mObserver);\r\n        mPopulatePending = false;\r\n        final boolean wasFirstLayout = mFirstLayout;\r\n        mFirstLayout = true;\r\n        mExpectedAdapterCount = mAdapter.getCount();\r\n        if (mRestoredCurItem >= 0) {\r\n            mAdapter.restoreState(mRestoredAdapterState, mRestoredClassLoader);\r\n            setCurrentItemInternal(mRestoredCurItem, false, true);\r\n            mRestoredCurItem = -1;\r\n            mRestoredAdapterState = null;\r\n            mRestoredClassLoader = null;\r\n        } else if (!wasFirstLayout) {\r\n            populate();\r\n        } else {\r\n            requestLayout();\r\n        }\r\n    }\r\n    if (mAdapterChangeListener != null && oldAdapter != adapter) {\r\n        mAdapterChangeListener.onAdapterChanged(oldAdapter, adapter);\r\n    }\r\n}"
}, {
	"Path": "com.vip.saturn.job.sharding.task.AbstractAsyncShardingTask.notifyEnableJobsPrior",
	"Comment": "special enable jobs that need to be notified prior, not consider whether whose shards are changed.\tby default, notify enable jobs whose shards are changed.",
	"Method": "List<String> notifyEnableJobsPrior(){\r\n    return null;\r\n}"
}, {
	"Path": "com.jiang.android.rxjavaapp.adapter.fragmentadapter.FragmentPagerAdapter.getItemId",
	"Comment": "return a unique identifier for the item at the given position.the default implementation returns the given position.subclasses should override this method if the positions of items can change.",
	"Method": "long getItemId(int position){\r\n    return position;\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.MappeableArrayContainer.toShortArray",
	"Comment": "create a copy of the content of this container as a short array. this creates a copy.",
	"Method": "short[] toShortArray(){\r\n    short[] answer = new short[cardinality];\r\n    content.rewind();\r\n    content.get(answer);\r\n    return answer;\r\n}"
}, {
	"Path": "com.salesmanager.core.business.utils.ProductPriceUtils.getAmount",
	"Comment": "transformation of an amount of money submited by the admin\tuser to be inserted as a bigdecimal in the database",
	"Method": "BigDecimal getAmount(String amount){\r\n    StringBuffer newAmount = new StringBuffer();\r\n    for (int i = 0; i < amount.length(); i++) {\r\n        if (amount.charAt(i) != DECIMALPOINT && amount.charAt(i) != THOUSANDPOINT) {\r\n            newAmount.append(amount.charAt(i));\r\n        }\r\n    }\r\n    try {\r\n        Integer.parseInt(newAmount.toString());\r\n    } catch (Exception e) {\r\n        throw new Exception(\"Cannot parse \" + amount);\r\n    }\r\n    if (!amount.contains(Character.toString(DECIMALPOINT)) && !amount.contains(Character.toString(THOUSANDPOINT)) && !amount.contains(\" \")) {\r\n        if (matchPositiveInteger(amount)) {\r\n            BigDecimalValidator validator = CurrencyValidator.getInstance();\r\n            BigDecimal bdamount = validator.validate(amount, Locale.US);\r\n            if (bdamount == null) {\r\n                throw new Exception(\"Cannot parse \" + amount);\r\n            } else {\r\n                return bdamount;\r\n            }\r\n        } else {\r\n            throw new Exception(\"Not a positive integer \" + amount);\r\n        }\r\n    } else {\r\n        StringBuffer pat = new StringBuffer();\r\n        if (!StringUtils.isBlank(Character.toString(THOUSANDPOINT))) {\r\n            pat.append(\"\\\\d{1,3}(\" + THOUSANDPOINT + \"?\\\\d{3})*\");\r\n        }\r\n        pat.append(\"(\\\\\" + DECIMALPOINT + \"\\\\d{1,\" + DECIMALCOUNT + \"})\");\r\n        Pattern pattern = Pattern.compile(pat.toString());\r\n        Matcher matcher = pattern.matcher(amount);\r\n        if (matcher.matches()) {\r\n            Locale locale = Constants.DEFAULT_LOCALE;\r\n            if (DECIMALPOINT == ',') {\r\n                locale = Locale.GERMAN;\r\n            }\r\n            BigDecimalValidator validator = CurrencyValidator.getInstance();\r\n            BigDecimal bdamount = validator.validate(amount, locale);\r\n            return bdamount;\r\n        } else {\r\n            throw new Exception(\"Cannot parse \" + amount);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.roaringbitmap.BitmapContainer.toLongBuffer",
	"Comment": "return the content of this container as a longbuffer. this creates a copy and might berelatively slow.",
	"Method": "LongBuffer toLongBuffer(){\r\n    LongBuffer lb = LongBuffer.allocate(bitmap.length);\r\n    lb.put(bitmap);\r\n    return lb;\r\n}"
}, {
	"Path": "org.roaringbitmap.Util.fillArrayANDNOT",
	"Comment": "compute the bitwise andnot between two long arrays and write the set bits in the container.",
	"Method": "void fillArrayANDNOT(short[] container,long[] bitmap1,long[] bitmap2){\r\n    int pos = 0;\r\n    if (bitmap1.length != bitmap2.length) {\r\n        throw new IllegalArgumentException(\"not supported\");\r\n    }\r\n    for (int k = 0; k < bitmap1.length; ++k) {\r\n        long bitset = bitmap1[k] & (~bitmap2[k]);\r\n        while (bitset != 0) {\r\n            container[pos++] = (short) (k * 64 + numberOfTrailingZeros(bitset));\r\n            bitset &= (bitset - 1);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.jiang.android.rxjavaapp.adapter.fragmentadapter.PagerAdapter.notifyDataSetChanged",
	"Comment": "this method should be called by the application if the data backing this adapter has changedand associated views should update.",
	"Method": "void notifyDataSetChanged(){\r\n    mObservable.notifyChanged();\r\n}"
}, {
	"Path": "org.roaringbitmap.buffer.MappeableBitmapContainer.toLongArray",
	"Comment": "create a copy of the content of this container as a long array. this creates a copy.",
	"Method": "long[] toLongArray(){\r\n    long[] answer = new long[bitmap.limit()];\r\n    bitmap.rewind();\r\n    bitmap.get(answer);\r\n    return answer;\r\n}"
}, {
	"Path": "org.roaringbitmap.ConstantMemoryContainerAppender.flush",
	"Comment": "ensures that any buffered additions are flushed to the underlying bitmap.",
	"Method": "void flush(){\r\n    currentKey += appendToUnderlying();\r\n}"
}, {
	"Path": "com.salesmanager.core.business.modules.cms.content.local.CmsStaticContentFileManagerImpl.getFileNames",
	"Comment": "queries the cms to retrieve all static content files. only the name of the file will bereturned to the client",
	"Method": "List<String> getFileNames(String merchantStoreCode,FileContentType staticContentType){\r\n    try {\r\n        StringBuilder merchantPath = new StringBuilder();\r\n        merchantPath.append(buildRootPath()).append(merchantStoreCode).append(Constants.SLASH).append(staticContentType);\r\n        Path path = Paths.get(merchantPath.toString());\r\n        List<String> fileNames = null;\r\n        if (Files.exists(path)) {\r\n            fileNames = new ArrayList<String>();\r\n            DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path);\r\n            for (Path dirPath : directoryStream) {\r\n                String fileName = dirPath.getFileName().toString();\r\n                if (staticContentType.name().equals(FileContentType.IMAGE.name())) {\r\n                    String mimetype = URLConnection.guessContentTypeFromName(fileName);\r\n                    if (!StringUtils.isBlank(mimetype)) {\r\n                        String type = mimetype.split(\"/\")[0];\r\n                        if (type.equals(\"image\")) {\r\n                            fileNames.add(fileName);\r\n                        }\r\n                    }\r\n                } else {\r\n                    fileNames.add(fileName);\r\n                }\r\n            }\r\n        }\r\n        return fileNames;\r\n    } catch (final Exception e) {\r\n        LOGGER.error(\"Error while fetching file for {} merchant \", merchantStoreCode);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.roaringbitmap.BitmapContainer.serializedSizeInBytes",
	"Comment": "the parameter is for overloading and symmetry with arraycontainer",
	"Method": "int serializedSizeInBytes(int unusedCardinality,int serializedSizeInBytes){\r\n    return serializedSizeInBytes(0);\r\n}"
}, {
	"Path": "com.salesmanager.core.business.utils.DataUtils.getMeasure",
	"Comment": "get the measure according to the appropriate measure base. if the measure\tconfigured in store is in and it needs cm or vise versa then the\tappropriate calculation is done",
	"Method": "double getMeasure(double measure,MerchantStore store,String base){\r\n    if (base.equals(MeasureUnit.IN.name())) {\r\n        if (store.getSeizeunitcode().equals(MeasureUnit.IN.name())) {\r\n            return new BigDecimal(String.valueOf(measure)).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();\r\n        } else {\r\n            double measureConstant = 2.54;\r\n            double answer = measure * measureConstant;\r\n            BigDecimal w = new BigDecimal(answer);\r\n            return w.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();\r\n        }\r\n    } else {\r\n        if (store.getSeizeunitcode().equals(MeasureUnit.CM.name())) {\r\n            return new BigDecimal(String.valueOf(measure)).setScale(2).doubleValue();\r\n        } else {\r\n            double measureConstant = 0.39;\r\n            double answer = measure * measureConstant;\r\n            BigDecimal w = new BigDecimal(answer);\r\n            return w.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();\r\n        }\r\n    }\r\n}"
}]