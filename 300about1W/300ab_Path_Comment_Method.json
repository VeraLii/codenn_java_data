[{
	"Path": "io.atomix.utils.time.Timestamp.isOlderThan",
	"Comment": "tests if this timestamp is older than the specified timestamp.",
	"Method": "boolean isOlderThan(Timestamp other){\r\n    return this.compareTo(Preconditions.checkNotNull(other)) < 0;\r\n}"
}, {
	"Path": "io.atomix.core.iterator.impl.IteratorBatch.complete",
	"Comment": "returns a boolean indicating whether the batch is complete.",
	"Method": "boolean complete(){\r\n    return complete;\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.ReplyMessage.getSerializedException",
	"Comment": "returns the serialized exception of the serialized reply message.",
	"Method": "byte[] getSerializedException(){\r\n    return serializedException;\r\n}"
}, {
	"Path": "io.atomix.protocols.gossip.CrdtProtocol.instance",
	"Comment": "returns an instance of the crdt protocol with the default configuration.",
	"Method": "CrdtProtocol instance(){\r\n    return new CrdtProtocol(new CrdtProtocolConfig());\r\n}"
}, {
	"Path": "io.atomix.protocols.backup.roles.PrimaryRole.heartbeat",
	"Comment": "applies a heartbeat to the service to ensure timers can be triggered.",
	"Method": "void heartbeat(){\r\n    long index = context.nextIndex();\r\n    long timestamp = System.currentTimeMillis();\r\n    replicator.replicate(new HeartbeatOperation(index, timestamp)).thenRun(() -> context.setTimestamp(timestamp));\r\n}"
}, {
	"Path": "brave.http.HttpParser.error",
	"Comment": "called by default. unfortunately, this implies boxing until we can change it.",
	"Method": "void error(Integer httpStatus,Throwable error,SpanCustomizer customizer){\r\n    if (error != null) {\r\n        errorParser().error(error, customizer);\r\n    } else if (httpStatus != null) {\r\n        String maybeErrorStatus = maybeStatusAsString(httpStatus, 399);\r\n        if (maybeErrorStatus != null)\r\n            customizer.tag(\"error\", maybeErrorStatus);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.core.multimap.DistributedMultimapTest.stringArrayCollectionIsEqual",
	"Comment": "compares two collections of strings returns true if they contain the same strings, false otherwise.",
	"Method": "boolean stringArrayCollectionIsEqual(Collection<? extends String> s1,Collection<? extends String> s2){\r\n    if (s1 == null || s2 == null || s1.size() != s2.size()) {\r\n        return false;\r\n    }\r\n    for (String string1 : s1) {\r\n        boolean matched = false;\r\n        for (String string2 : s2) {\r\n            if (string1.equals(string2)) {\r\n                matched = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!matched) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.atomix.utils.time.WallClockTimestamp.from",
	"Comment": "returns a new wall clock timestamp for the given unix timestamp.",
	"Method": "WallClockTimestamp from(long unixTimestamp){\r\n    return new WallClockTimestamp(unixTimestamp);\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.jpa.JpaEventStorageEngine.setGapCleaningThreshold",
	"Comment": "sets the threshold of number of gaps in a token before an attempt to clean gaps up is taken. defaults to 250.",
	"Method": "void setGapCleaningThreshold(int gapCleaningThreshold){\r\n    this.gapCleaningThreshold = gapCleaningThreshold;\r\n}"
}, {
	"Path": "brave.grpc.GrpcClientParser.onStart",
	"Comment": "override the customize the span based on the start of a request.",
	"Method": "void onStart(MethodDescriptor<ReqT, RespT> method,CallOptions options,Metadata headers,SpanCustomizer span){\r\n    span.name(spanName(method));\r\n}"
}, {
	"Path": "org.axonframework.config.DefaultConfigurer.defaultHandlerDefinition",
	"Comment": "provides the default handlerdefinition. subclasses may override this method to provide their own default.",
	"Method": "HandlerDefinition defaultHandlerDefinition(Class<?> inspectedClass){\r\n    return ClasspathHandlerDefinition.forClass(inspectedClass);\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.DispatchMessage.getPayloadType",
	"Comment": "returns the payload type of the serialized payload of the command carried by this instance.",
	"Method": "String getPayloadType(){\r\n    return payloadType;\r\n}"
}, {
	"Path": "org.awaitility.core.ConditionFactory.ignoreExceptionsMatching",
	"Comment": "instruct awaitility to ignore exceptions that occur during evaluation and matches the supplied predicate.exceptions will be treated as evaluating tofalse. this is useful in situations where the evaluated conditions may temporarily throw exceptions.",
	"Method": "ConditionFactory ignoreExceptionsMatching(Matcher<? super Throwable> matcher,ConditionFactory ignoreExceptionsMatching,Predicate<? super Throwable> predicate){\r\n    return new ConditionFactory(alias, timeoutConstraint, pollInterval, pollDelay, catchUncaughtExceptions, new PredicateExceptionIgnorer(predicate), conditionEvaluationListener, executorLifecycle);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.cluster.impl.RaftMemberContext.canConfigure",
	"Comment": "returns a boolean indicating whether a configure request can be sent to the member.",
	"Method": "boolean canConfigure(){\r\n    return !configuring;\r\n}"
}, {
	"Path": "io.atomix.core.tree.AtomicDocumentTree.createRecursive",
	"Comment": "creates a document tree node by first creating any missing intermediate nodes in the path.",
	"Method": "boolean createRecursive(String path,V value,boolean createRecursive,DocumentPath path,V value){\r\n    return createRecursive(DocumentPath.from(path), value);\r\n}"
}, {
	"Path": "org.axonframework.config.DefaultConfigurer.getConfig",
	"Comment": "returns the current configuration object being built by this configurer, without initializing it. note thatretrieving objects from this configuration may lead to premature initialization of certain components.",
	"Method": "Configuration getConfig(){\r\n    return config;\r\n}"
}, {
	"Path": "io.atomix.core.tree.AsyncAtomicDocumentTree.replace",
	"Comment": "conditionally updates a tree node if the current node value matches a specified version.",
	"Method": "CompletableFuture<Boolean> replace(String path,V newValue,long version,CompletableFuture<Boolean> replace,DocumentPath path,V newValue,long version,CompletableFuture<Boolean> replace,String path,V newValue,V currentValue,CompletableFuture<Boolean> replace,DocumentPath path,V newValue,V currentValue){\r\n    return replace(DocumentPath.from(path), newValue, currentValue);\r\n}"
}, {
	"Path": "brave.test.util.ClassLoaders.assertRunIsUnloadable",
	"Comment": "runs the type in a new classloader that recreates brave classes",
	"Method": "void assertRunIsUnloadable(Class<? extends Runnable> runnable,ClassLoader parent){\r\n    System.setProperty(\"java.util.logging.manager\", LogManager.class.getName());\r\n    assertThat(LogManager.getLogManager().getClass()).isSameAs(LogManager.class);\r\n    WeakReference<ClassLoader> loader;\r\n    try {\r\n        loader = invokeRunFromNewClassLoader(runnable, parent);\r\n    } catch (Exception e) {\r\n        throw new AssertionError(e);\r\n    }\r\n    blockOnGC();\r\n    assertThat(loader.get()).withFailMessage(runnable + \" includes state that couldn't be garbage collected\").isNull();\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.EmbeddedEventStore.shutDown",
	"Comment": "method to invoke when the application shuts down. this closes all event streams used for event store tracking.",
	"Method": "void shutDown(){\r\n    tailingConsumers.forEach(IOUtils::closeQuietly);\r\n    IOUtils.closeQuietly(producer);\r\n    cleanupService.shutdownNow();\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.SimpleCommandBus.registerDispatchInterceptor",
	"Comment": "registers the given list of dispatch interceptors to the command bus. all incoming commands will pass throughthe interceptors at the given order before the command is dispatched toward the command handler.",
	"Method": "Registration registerDispatchInterceptor(MessageDispatchInterceptor<? super CommandMessage<?>> dispatchInterceptor){\r\n    dispatchInterceptors.add(dispatchInterceptor);\r\n    return () -> dispatchInterceptors.remove(dispatchInterceptor);\r\n}"
}, {
	"Path": "io.atomix.core.AtomixConfig.isTypeRegistrationRequired",
	"Comment": "returns whether serializable type registration is required for user types.",
	"Method": "boolean isTypeRegistrationRequired(){\r\n    return typeRegistrationRequired;\r\n}"
}, {
	"Path": "org.awaitility.Awaitility.ignoreExceptionsByDefault",
	"Comment": "instruct awaitility to ignore caught or uncaught exceptions during condition evaluation.exceptions will be treated as evaluating to false. your test will not failupon an exception, unless it times out.",
	"Method": "void ignoreExceptionsByDefault(){\r\n    defaultExceptionIgnorer = new PredicateExceptionIgnorer(new Predicate<Throwable>() {\r\n        public boolean matches(Throwable e) {\r\n            return true;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.awaitility.Awaitility.ignoreExceptionsByDefault",
	"Comment": "instruct awaitility to ignore caught or uncaught exceptions during condition evaluation.exceptions will be treated as evaluating to false. your test will not failupon an exception, unless it times out.",
	"Method": "void ignoreExceptionsByDefault(){\r\n    return true;\r\n}"
}, {
	"Path": "io.atomix.storage.journal.MappableJournalSegmentReader.map",
	"Comment": "converts the reader to a mapped reader using the given buffer.",
	"Method": "void map(ByteBuffer buffer){\r\n    if (!(reader instanceof MappedJournalSegmentReader)) {\r\n        JournalReader<E> reader = this.reader;\r\n        this.reader = new MappedJournalSegmentReader(buffer, segment, maxEntrySize, index, namespace);\r\n        this.reader.reset(reader.getNextIndex());\r\n        reader.close();\r\n    }\r\n}"
}, {
	"Path": "org.awaitility.Awaitility.setDefaultConditionEvaluationListener",
	"Comment": "sets the default condition evaluation listener that all await statements will use.",
	"Method": "void setDefaultConditionEvaluationListener(ConditionEvaluationListener defaultConditionEvaluationListener){\r\n    Awaitility.defaultConditionEvaluationListener = defaultConditionEvaluationListener;\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.callbacks.FutureCallback.awaitCompletion",
	"Comment": "wait for completion of the command, or for the timeout to expire.",
	"Method": "boolean awaitCompletion(long timeout,TimeUnit unit){\r\n    try {\r\n        get(timeout, unit);\r\n        return true;\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n        return false;\r\n    } catch (ExecutionException e) {\r\n        return true;\r\n    } catch (TimeoutException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "io.atomix.core.AtomixRegistry.registry",
	"Comment": "creates a new registry instance using the given class loader.",
	"Method": "AtomixRegistry registry(AtomixRegistry registry,ClassLoader classLoader){\r\n    return ClasspathScanningRegistry.builder().withClassLoader(classLoader).build();\r\n}"
}, {
	"Path": "org.axonframework.queryhandling.SimpleQueryBus.getSubscriptions",
	"Comment": "returns the subscriptions for this query bus. while the returned map is unmodifiable, it may or may not reflectchanges made to the subscriptions after the call was made.",
	"Method": "Map<String, Collection<QuerySubscription>> getSubscriptions(){\r\n    return Collections.unmodifiableMap(subscriptions);\r\n}"
}, {
	"Path": "io.atomix.core.Atomix.start",
	"Comment": "starts the atomix instance.the returned future will be completed once this instance completes startup. note that in order to complete startup,all partitions must be able to form. for raft partitions, that requires that a majority of the nodes in eachpartition be started concurrently.",
	"Method": "CompletableFuture<Void> start(){\r\n    if (closeFuture != null) {\r\n        return Futures.exceptionalFuture(new IllegalStateException(\"Atomix instance \" + (closeFuture.isDone() ? \"shutdown\" : \"shutting down\")));\r\n    }\r\n    LOGGER.info(BUILD);\r\n    return super.start().thenRun(() -> {\r\n        if (enableShutdownHook) {\r\n            if (shutdownHook == null) {\r\n                shutdownHook = new Thread(() -> super.stop().join());\r\n                Runtime.getRuntime().addShutdownHook(shutdownHook);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.atomix.storage.journal.JournalSegmentFile.isSegmentFile",
	"Comment": "returns a boolean value indicating whether the given file appears to be a parsable segment file.",
	"Method": "boolean isSegmentFile(String name,File file,boolean isSegmentFile,String journalName,String fileName){\r\n    checkNotNull(journalName, \"journalName cannot be null\");\r\n    checkNotNull(fileName, \"fileName cannot be null\");\r\n    int partSeparator = fileName.lastIndexOf(PART_SEPARATOR);\r\n    int extensionSeparator = fileName.lastIndexOf(EXTENSION_SEPARATOR);\r\n    if (extensionSeparator == -1 || partSeparator == -1 || extensionSeparator < partSeparator || !fileName.endsWith(EXTENSION)) {\r\n        return false;\r\n    }\r\n    for (int i = partSeparator + 1; i < extensionSeparator; i++) {\r\n        if (!Character.isDigit(fileName.charAt(i))) {\r\n            return false;\r\n        }\r\n    }\r\n    return fileName.startsWith(journalName);\r\n}"
}, {
	"Path": "io.atomix.primitive.event.Events.getMethodMap",
	"Comment": "returns the collection of events provided by the given service interface.",
	"Method": "Map<Method, EventType> getMethodMap(Class<?> serviceInterface){\r\n    if (!serviceInterface.isInterface()) {\r\n        Map<Method, EventType> events = new HashMap();\r\n        for (Class<?> iface : serviceInterface.getInterfaces()) {\r\n            events.putAll(findMethods(iface));\r\n        }\r\n        return events;\r\n    }\r\n    return findMethods(serviceInterface);\r\n}"
}, {
	"Path": "org.axonframework.disruptor.commandhandling.CommandHandlingEntry.registerAggregateIdentifier",
	"Comment": "registers the identifier of the aggregate that will process the next command.",
	"Method": "void registerAggregateIdentifier(String aggregateIdentifier){\r\n    if (this.aggregateIdentifier != null && !this.aggregateIdentifier.equals(aggregateIdentifier)) {\r\n        throw new IllegalStateException(\"Cannot load multiple aggregates in the same unit of work when using\" + \"DisruptorCommandBus! Already loaded \" + this.aggregateIdentifier + \", attempted to load \" + aggregateIdentifier);\r\n    }\r\n    this.aggregateIdentifier = aggregateIdentifier;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.storage.snapshot.FileSnapshotStoreTest.testStreamSnapshot",
	"Comment": "tests writing multiple times to a snapshot designed to mimic chunked snapshots from leaders.",
	"Method": "void testStreamSnapshot(){\r\n    SnapshotStore store = createSnapshotStore();\r\n    Snapshot snapshot = store.newSnapshot(1, new WallClockTimestamp());\r\n    for (long i = 1; i <= 10; i++) {\r\n        try (SnapshotWriter writer = snapshot.openWriter()) {\r\n            writer.writeLong(i);\r\n        }\r\n    }\r\n    snapshot.complete();\r\n    snapshot = store.getSnapshot(1);\r\n    try (SnapshotReader reader = snapshot.openReader()) {\r\n        for (long i = 1; i <= 10; i++) {\r\n            assertEquals(i, reader.readLong());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.atomix.core.map.AtomicCounterMapConfig.setRegistrationRequired",
	"Comment": "sets whether registration is required for serializable types.",
	"Method": "AtomicCounterMapConfig setRegistrationRequired(boolean registrationRequired){\r\n    this.registrationRequired = registrationRequired;\r\n    return this;\r\n}"
}, {
	"Path": "brave.TracerTest.join_setsShared",
	"Comment": "when we join a sampled request, we are sharing the same trace identifiers.",
	"Method": "void join_setsShared(){\r\n    TraceContext fromIncomingRequest = tracer.newTrace().context();\r\n    TraceContext joined = tracer.joinSpan(fromIncomingRequest).context();\r\n    assertThat(joined.shared()).isTrue();\r\n    assertThat(joined).isEqualToComparingFieldByField(fromIncomingRequest.toBuilder().shared(true).build());\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.ReplayToken.getTokenAtReset",
	"Comment": "gets the token representing the position at which the reset was triggered.",
	"Method": "TrackingToken getTokenAtReset(){\r\n    return tokenAtReset;\r\n}"
}, {
	"Path": "org.axonframework.monitoring.MessageMonitor.onMessagesIngested",
	"Comment": "takes a collection of messages and returns a map containing events along with their callbacks",
	"Method": "Map<? super T, MonitorCallback> onMessagesIngested(Collection<? extends T> messages){\r\n    return messages.stream().collect(Collectors.toMap(msg -> msg, this::onMessageIngested));\r\n}"
}, {
	"Path": "io.atomix.cluster.NodeId.anonymous",
	"Comment": "creates a new cluster node identifier from the specified string.",
	"Method": "NodeId anonymous(){\r\n    return new NodeId(UUID.randomUUID().toString());\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.RaftTest.testPassiveJoinLate",
	"Comment": "tests joining a server after many entries have been committed.",
	"Method": "void testPassiveJoinLate(){\r\n    testServerJoinLate(RaftMember.Type.PASSIVE, RaftServer.Role.PASSIVE);\r\n}"
}, {
	"Path": "io.atomix.utils.concurrent.Futures.exceptionalFuture",
	"Comment": "creates a future that is synchronously completed exceptionally.",
	"Method": "CompletableFuture<T> exceptionalFuture(Throwable t){\r\n    CompletableFuture<T> future = new CompletableFuture();\r\n    future.completeExceptionally(t);\r\n    return future;\r\n}"
}, {
	"Path": "org.awaitility.Awaitility.catchUncaughtExceptions",
	"Comment": "catching uncaught exceptions in other threads. this will make the awaitstatement fail even if exceptions occur in other threads. this is thedefault behavior.",
	"Method": "ConditionFactory catchUncaughtExceptions(){\r\n    return new ConditionFactory(null, defaultWaitConstraint, defaultPollInterval, defaultPollDelay, defaultCatchUncaughtExceptions, defaultExceptionIgnorer, defaultConditionEvaluationListener, defaultExecutorLifecycle);\r\n}"
}, {
	"Path": "brave.internal.handler.MutableSpanConverterTest.writeTo_sharedStatus",
	"Comment": "this prevents the server starttimestamp from overwriting the client one on the collector",
	"Method": "void writeTo_sharedStatus(){\r\n    MutableSpan span = new MutableSpan();\r\n    span.setShared();\r\n    span.startTimestamp(1L);\r\n    span.kind(SERVER);\r\n    span.finishTimestamp(2L);\r\n    assertThat(convert(span).shared()).isTrue();\r\n}"
}, {
	"Path": "io.atomix.core.map.AtomicCounterMapBuilder.withRegistrationRequired",
	"Comment": "sets whether registration is required for serializable types.",
	"Method": "AtomicCounterMapBuilder<K> withRegistrationRequired(AtomicCounterMapBuilder<K> withRegistrationRequired,boolean registrationRequired){\r\n    config.setRegistrationRequired(registrationRequired);\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.test.AtomicMapPerformanceTest.createStrings",
	"Comment": "creates a deterministic array of strings to write to the cluster.",
	"Method": "String[] createStrings(int length,int count){\r\n    Random random = new Random(length);\r\n    List<String> stringsList = new ArrayList(count);\r\n    for (int i = 0; i < count; i++) {\r\n        stringsList.add(randomString(length, random));\r\n    }\r\n    return stringsList.toArray(new String[0]);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.RaftSessionRegistry.getSessions",
	"Comment": "returns a set of sessions associated with the given service.",
	"Method": "Collection<RaftSession> getSessions(Collection<RaftSession> getSessions,PrimitiveId primitiveId){\r\n    return sessions.values().stream().filter(session -> session.getService().serviceId().equals(primitiveId)).filter(session -> session.getState().active()).collect(Collectors.toSet());\r\n}"
}, {
	"Path": "brave.kafka.clients.TracingProducer.send",
	"Comment": "send with a callback is always called for kafkaproducer. we do the same here to enabletracing.",
	"Method": "Future<RecordMetadata> send(ProducerRecord<K, V> record,Future<RecordMetadata> send,ProducerRecord<K, V> record,Callback callback){\r\n    TraceContext maybeParent = current.get();\r\n    Span span;\r\n    if (maybeParent == null) {\r\n        span = tracer.nextSpan(kafkaTracing.extractAndClearHeaders(record.headers()));\r\n    } else {\r\n        span = tracer.newChild(maybeParent);\r\n    }\r\n    if (!span.isNoop()) {\r\n        span.kind(Span.Kind.PRODUCER).name(\"send\");\r\n        if (remoteServiceName != null)\r\n            span.remoteServiceName(remoteServiceName);\r\n        if (record.key() instanceof String && !\"\".equals(record.key())) {\r\n            span.tag(KafkaTags.KAFKA_KEY_TAG, record.key().toString());\r\n        }\r\n        span.tag(KafkaTags.KAFKA_TOPIC_TAG, record.topic());\r\n        span.start();\r\n    }\r\n    injector.inject(span.context(), record.headers());\r\n    try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {\r\n        return delegate.send(record, TracingCallback.create(callback, span, current));\r\n    } catch (RuntimeException | Error e) {\r\n        span.error(e).finish();\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "io.atomix.utils.concurrent.AbstractAccumulator.maxBatchMillis",
	"Comment": "returns the maximum number of millis allowed to expire since the firstitem before processing is triggered.",
	"Method": "int maxBatchMillis(){\r\n    return maxBatchMillis;\r\n}"
}, {
	"Path": "io.atomix.primitive.partition.PartitionService.getPartitionGroup",
	"Comment": "returns the first partition group that matches the given primitive protocol.",
	"Method": "PartitionGroup getPartitionGroup(String name,PartitionGroup getPartitionGroup,PrimitiveProtocol.Type type,PartitionGroup getPartitionGroup,ProxyProtocol protocol){\r\n    if (protocol.group() != null) {\r\n        PartitionGroup group = getPartitionGroup(protocol.group());\r\n        if (group != null) {\r\n            return group;\r\n        }\r\n        PartitionGroup systemGroup = getSystemPartitionGroup();\r\n        if (systemGroup != null && systemGroup.name().equals(protocol.group())) {\r\n            return systemGroup;\r\n        }\r\n        return null;\r\n    }\r\n    for (PartitionGroup partitionGroup : getPartitionGroups()) {\r\n        if (partitionGroup.protocol().name().equals(protocol.type().name())) {\r\n            return partitionGroup;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.atomix.core.map.AtomicMap.putIfAbsent",
	"Comment": "if the specified key is not already associated with a valueassociates it with the given value and returns null, else returns the current value.",
	"Method": "Versioned<V> putIfAbsent(K key,V value,Versioned<V> putIfAbsent,K key,V value,Duration ttl){\r\n    return putIfAbsent(key, value, Duration.ZERO);\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.EventSourcedAggregate.getSnapshotTrigger",
	"Comment": "the trigger instance that monitors this aggregate to trigger a snapshot",
	"Method": "SnapshotTrigger getSnapshotTrigger(){\r\n    return snapshotTrigger;\r\n}"
}, {
	"Path": "org.axonframework.modelling.command.inspection.AnnotatedAggregate.publishOnEventBus",
	"Comment": "publish an event to external event handlers using the given event bus.",
	"Method": "void publishOnEventBus(EventMessage<?> msg){\r\n    if (eventBus != null) {\r\n        eventBus.publish(msg);\r\n    }\r\n}"
}, {
	"Path": "brave.context.rxjava2.internal.TraceContextSingle.subscribeActual",
	"Comment": "wraps the observer so that its callbacks run in the assembly context. this does not affect anysubscription callbacks.",
	"Method": "void subscribeActual(SingleObserver<? super T> o){\r\n    source.subscribe(new TraceContextSingleObserver(o, contextScoper, assembled));\r\n}"
}, {
	"Path": "org.axonframework.springboot.SerializerProperties.setMessages",
	"Comment": "the type of serializer to use to serialize the payload and meta data of messages. defaults to the messageserializer, or otherwise the general serializer.",
	"Method": "void setMessages(SerializerType serializerType){\r\n    this.messages = serializerType;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.roles.LeaderRole.configuring",
	"Comment": "returns a boolean value indicating whether a configuration is currently being committed.",
	"Method": "boolean configuring(){\r\n    return configuring > 0;\r\n}"
}, {
	"Path": "io.crossbar.autobahn.wamp.utils.Platform.getAndroidAPIVersion",
	"Comment": "checks if the underlying platform is android and if theapi level is greater than equal to the requested value.returns 0 if the platform is not android.",
	"Method": "int getAndroidAPIVersion(){\r\n    if (isAndroid()) {\r\n        try {\r\n            Class<?> klass = Class.forName(\"android.os.Build$VERSION\");\r\n            return klass.getField(\"SDK_INT\").getInt(null);\r\n        } catch (ClassNotFoundException | NoSuchFieldException | IllegalAccessException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "io.atomix.core.AtomixBuilder.withShutdownHook",
	"Comment": "sets whether the shutdown hook is enabled.when the shutdown hook is enabled, the instance will be shutdown when the jvm exits.",
	"Method": "AtomixBuilder withShutdownHook(boolean enabled){\r\n    config.setEnableShutdownHook(enabled);\r\n    return this;\r\n}"
}, {
	"Path": "org.awaitility.core.ConditionFactory.then",
	"Comment": "a method to increase the readability of the awaitility dsl. it simplyreturns the same condition factory instance.",
	"Method": "ConditionFactory then(){\r\n    return this;\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.DispatchMessage.getCommandName",
	"Comment": "returns the command name of the command carried by this instance.",
	"Method": "String getCommandName(){\r\n    return commandName;\r\n}"
}, {
	"Path": "io.atomix.storage.journal.SegmentedJournal.storageLevel",
	"Comment": "returns the storage level.the storage level dictates how entries within individual journal segments should be stored.",
	"Method": "StorageLevel storageLevel(){\r\n    return storageLevel;\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.CommandCallbackRepository.fetchAndRemove",
	"Comment": "fetches and removes a callback. the callback will not be used a second time, so removal should be fine",
	"Method": "CommandCallbackWrapper<E, C, R> fetchAndRemove(String callbackId){\r\n    return callbacks.remove(callbackId);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.test.RaftPerformanceTest.runIteration",
	"Comment": "runs a single performance test iteration, returning the iteration run time.",
	"Method": "long runIteration(){\r\n    reset();\r\n    createServers(3);\r\n    CompletableFuture<Void>[] futures = new CompletableFuture[NUM_CLIENTS];\r\n    RaftClient[] clients = new RaftClient[NUM_CLIENTS];\r\n    SessionClient[] proxies = new SessionClient[NUM_CLIENTS];\r\n    for (int i = 0; i < NUM_CLIENTS; i++) {\r\n        CompletableFuture<Void> future = new CompletableFuture();\r\n        clients[i] = createClient();\r\n        proxies[i] = createProxy(clients[i]).connect().join();\r\n        futures[i] = future;\r\n    }\r\n    long startTime = System.currentTimeMillis();\r\n    for (int i = 0; i < clients.length; i++) {\r\n        runProxy(proxies[i], futures[i]);\r\n    }\r\n    CompletableFuture.allOf(futures).join();\r\n    long endTime = System.currentTimeMillis();\r\n    long runTime = endTime - startTime;\r\n    System.out.println(String.format(\"readCount: %d/%d, writeCount: %d/%d, runTime: %dms\", readCount.get(), TOTAL_OPERATIONS, writeCount.get(), TOTAL_OPERATIONS, runTime));\r\n    return runTime;\r\n}"
}, {
	"Path": "io.crossbar.autobahn.websocket.WebSocketReader.onBinaryMessage",
	"Comment": "websockets binary message received, default notifies master.",
	"Method": "void onBinaryMessage(byte[] payload){\r\n    notify(new BinaryMessage(payload));\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.RaftTest.testResize",
	"Comment": "tests joining and leaving the cluster, resizing the quorum.",
	"Method": "void testResize(){\r\n    RaftServer server = createServers(1).get(0);\r\n    RaftServer joiner = createServer(nextNodeId());\r\n    joiner.join(members.stream().map(RaftMember::memberId).collect(Collectors.toList())).thenRun(this::resume);\r\n    await(15000);\r\n    server.leave().thenRun(this::resume);\r\n    await(15000);\r\n    joiner.leave().thenRun(this::resume);\r\n}"
}, {
	"Path": "io.atomix.utils.serializer.SerializerBuilder.withRegistrationRequired",
	"Comment": "sets whether serializable type registration is required for serializable types.",
	"Method": "SerializerBuilder withRegistrationRequired(SerializerBuilder withRegistrationRequired,boolean registrationRequired){\r\n    namespaceBuilder.setRegistrationRequired(registrationRequired);\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.core.multimap.MultimapConfig.isRegistrationRequired",
	"Comment": "returns whether registration is required for serializable types.",
	"Method": "boolean isRegistrationRequired(){\r\n    return registrationRequired;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.test.RaftFuzzTest.scheduleRestart",
	"Comment": "schedules the given server to be shutdown for a period of time and then restarted.",
	"Method": "void scheduleRestart(boolean remove,int serverIndex,ThreadContext context){\r\n    shutdownTimers.put(serverIndex, context.schedule(Duration.ofSeconds(randomNumber(120) + 10), () -> {\r\n        shutdownTimers.remove(serverIndex);\r\n        RaftServer server = servers.get(serverIndex);\r\n        CompletableFuture<Void> leaveFuture;\r\n        if (remove) {\r\n            System.out.println(\"Removing server: \" + server.cluster().getMember().memberId());\r\n            leaveFuture = server.leave();\r\n        } else {\r\n            System.out.println(\"Shutting down server: \" + server.cluster().getMember().memberId());\r\n            leaveFuture = server.shutdown();\r\n        }\r\n        leaveFuture.whenComplete((result, error) -> {\r\n            restartTimers.put(serverIndex, context.schedule(Duration.ofSeconds(randomNumber(120) + 10), () -> {\r\n                restartTimers.remove(serverIndex);\r\n                RaftServer newServer = createServer(server.cluster().getMember());\r\n                servers.set(serverIndex, newServer);\r\n                CompletableFuture<RaftServer> joinFuture;\r\n                if (remove) {\r\n                    System.out.println(\"Adding server: \" + newServer.cluster().getMember().memberId());\r\n                    joinFuture = newServer.join(members.get(members.size() - 1).memberId());\r\n                } else {\r\n                    System.out.println(\"Bootstrapping server: \" + newServer.cluster().getMember().memberId());\r\n                    joinFuture = newServer.bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()));\r\n                }\r\n                joinFuture.whenComplete((result2, error2) -> {\r\n                    scheduleRestarts(context);\r\n                });\r\n            }));\r\n        });\r\n    }));\r\n}"
}, {
	"Path": "brave.context.rxjava2.internal.TraceContextCallableCompletable.subscribeActual",
	"Comment": "wraps the observer so that its callbacks run in the assembly context. this does not affect anysubscription callbacks.",
	"Method": "void subscribeActual(CompletableObserver s){\r\n    source.subscribe(Wrappers.wrap(s, contextScoper, assembled));\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.AbstractSnapshotter.getEventStore",
	"Comment": "returns the event store this snapshotter uses to load domain events and store snapshot events.",
	"Method": "EventStore getEventStore(){\r\n    return eventStore;\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.tokenstore.jdbc.JdbcTokenStore.createSchema",
	"Comment": "performs the ddl queries to create the schema necessary for this token store implementation.",
	"Method": "void createSchema(TokenTableFactory schemaFactory){\r\n    Connection c = getConnection();\r\n    try {\r\n        executeUpdates(c, e -> {\r\n            throw new JdbcException(\"Failed to create token tables\", e);\r\n        }, connection -> schemaFactory.createTable(connection, schema));\r\n    } finally {\r\n        closeQuietly(c);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.RaftSessionState.setEventIndex",
	"Comment": "sets the highest index for which an event has been received in sequence.",
	"Method": "void setEventIndex(long eventIndex){\r\n    this.eventIndex = eventIndex;\r\n}"
}, {
	"Path": "org.axonframework.spring.config.annotation.SpringHandlerDefinitionBean.setAdditionalHandlers",
	"Comment": "defines any additional handler definitions that should be used. by default, the handlerdefinitions are found onthe classpath, as well as a springbeanparameterresolverfactory are registered.",
	"Method": "void setAdditionalHandlers(List<HandlerDefinition> additionalFactories){\r\n    this.definitions.addAll(additionalFactories);\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.gateway.AbstractCommandGateway.sendAndForget",
	"Comment": "dispatches a command without callback. when dispatching fails, since there is no callback, the command willnot be retried.",
	"Method": "void sendAndForget(Object command){\r\n    if (retryScheduler == null) {\r\n        commandBus.dispatch(processInterceptors(asCommandMessage(command)));\r\n    } else {\r\n        CommandMessage<?> commandMessage = asCommandMessage(command);\r\n        send(commandMessage, LoggingCallback.INSTANCE);\r\n    }\r\n}"
}, {
	"Path": "org.axonframework.spring.config.annotation.SpringContextHandlerDefinitionBuilder.getBeanReference",
	"Comment": "create, if necessary, a bean definition for a handlerdefinition and returns the reference to bean for use inother bean definitions.",
	"Method": "RuntimeBeanReference getBeanReference(BeanDefinitionRegistry registry){\r\n    if (!registry.containsBeanDefinition(HANDLER_DEFINITION_BEAN_NAME)) {\r\n        BeanDefinition definition = BeanDefinitionBuilder.genericBeanDefinition(SpringHandlerDefinitionBean.class).getBeanDefinition();\r\n        BeanDefinition enhancer = BeanDefinitionBuilder.genericBeanDefinition(SpringHandlerEnhancerDefinitionBean.class).getBeanDefinition();\r\n        AbstractBeanDefinition def = BeanDefinitionBuilder.genericBeanDefinition(MultiHandlerDefinition.class).addConstructorArgValue(definition).addConstructorArgValue(enhancer).getBeanDefinition();\r\n        def.setPrimary(true);\r\n        registry.registerBeanDefinition(HANDLER_DEFINITION_BEAN_NAME, def);\r\n    }\r\n    return new RuntimeBeanReference(HANDLER_DEFINITION_BEAN_NAME);\r\n}"
}, {
	"Path": "brave.propagation.SamplingFlags.toSamplingFlags",
	"Comment": "this ensures constants are always used, in order to reduce allocation overhead",
	"Method": "SamplingFlags toSamplingFlags(int flags){\r\n    switch(flags) {\r\n        case 0:\r\n            return EMPTY;\r\n        case FLAG_SAMPLED_SET:\r\n            return NOT_SAMPLED;\r\n        case FLAG_SAMPLED_SET | FLAG_SAMPLED:\r\n            return SAMPLED;\r\n        case FLAG_SAMPLED_SET | FLAG_SAMPLED | FLAG_DEBUG:\r\n            return DEBUG;\r\n        case FLAG_SAMPLED_LOCAL:\r\n            return EMPTY_SAMPLED_LOCAL;\r\n        case FLAG_SAMPLED_LOCAL | FLAG_SAMPLED_SET:\r\n            return NOT_SAMPLED_SAMPLED_LOCAL;\r\n        case FLAG_SAMPLED_LOCAL | FLAG_SAMPLED_SET | FLAG_SAMPLED:\r\n            return SAMPLED_SAMPLED_LOCAL;\r\n        case FLAG_SAMPLED_LOCAL | FLAG_SAMPLED_SET | FLAG_SAMPLED | FLAG_DEBUG:\r\n            return DEBUG_SAMPLED_LOCAL;\r\n        default:\r\n            assert false;\r\n            return new SamplingFlags(flags);\r\n    }\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.TrackingEventProcessorConfiguration.andInitialTrackingToken",
	"Comment": "sets the builder to use to create the initial tracking token. this token is used by the processor as a startingpoint.",
	"Method": "TrackingEventProcessorConfiguration andInitialTrackingToken(Function<StreamableMessageSource, TrackingToken> initialTrackingTokenBuilder){\r\n    this.initialTrackingTokenBuilder = initialTrackingTokenBuilder;\r\n    return this;\r\n}"
}, {
	"Path": "org.axonframework.modelling.saga.repository.jdbc.JdbcSagaStore.setSerializer",
	"Comment": "sets the serializer instance to serialize sagas with. defaults to the xstream serializer.",
	"Method": "void setSerializer(Serializer serializer){\r\n    this.serializer = serializer;\r\n}"
}, {
	"Path": "io.atomix.cluster.protocol.SwimMembershipProtocol.selectRandomMembers",
	"Comment": "selects a set of random members, excluding the local member and a given member.",
	"Method": "Collection<SwimMember> selectRandomMembers(int count,ImmutableMember exclude){\r\n    List<SwimMember> members = this.members.values().stream().filter(member -> !member.id().equals(localMember.id()) && !member.id().equals(exclude.id())).collect(Collectors.toList());\r\n    Collections.shuffle(members);\r\n    return members.subList(0, Math.min(members.size(), count));\r\n}"
}, {
	"Path": "io.atomix.protocols.backup.service.impl.PrimaryBackupServiceContext.nextIndex",
	"Comment": "increments the current index and returns true if the given index is the next index.",
	"Method": "long nextIndex(boolean nextIndex,long index){\r\n    if (operationIndex + 1 == index) {\r\n        currentOperation = OperationType.COMMAND;\r\n        operationIndex++;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.impl.RaftServiceManager.completeSnapshot",
	"Comment": "determines whether to complete the snapshot at the given index.",
	"Method": "boolean completeSnapshot(long index){\r\n    long lastCompleted = index;\r\n    for (RaftSession session : raft.getSessions().getSessions()) {\r\n        lastCompleted = Math.min(lastCompleted, session.getLastCompleted());\r\n    }\r\n    return lastCompleted >= index;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.RaftSessionState.getEventIndex",
	"Comment": "returns the highest index for which an event has been received in sequence.",
	"Method": "long getEventIndex(){\r\n    return eventIndex;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.RaftSessionSequencer.sequenceEvent",
	"Comment": "sequences an event.this method relies on the session event protocol to ensure that events are applied in sequential order.when an event is received, if no operations are outstanding, the event is immediately completed sincethe event could not have occurred concurrently with any other operation. otherwise, the event is queuedand the next response in the sequence of responses is checked to determine whether the event can becompleted.",
	"Method": "void sequenceEvent(PublishRequest request,Runnable callback){\r\n    if (requestSequence == responseSequence) {\r\n        log.trace(\"Completing {}\", request);\r\n        callback.run();\r\n        eventIndex = request.eventIndex();\r\n    } else {\r\n        eventCallbacks.add(new EventCallback(request, callback));\r\n        completeResponses();\r\n    }\r\n}"
}, {
	"Path": "brave.http.HttpServerHandler.handleReceive",
	"Comment": "conditionally joins a span, or starts a new trace, depending on if a trace context wasextracted from the request. tags are added before the span is started.this is typically called before the request is processed by the actual library.",
	"Method": "Span handleReceive(TraceContext.Extractor<Req> extractor,Req request,Span handleReceive,TraceContext.Extractor<C> extractor,C carrier,Req request){\r\n    Span span = nextSpan(extractor.extract(carrier), request);\r\n    return handleStart(request, span);\r\n}"
}, {
	"Path": "io.atomix.cluster.messaging.impl.DefaultClusterEventService.getSubscriberNodes",
	"Comment": "returns a collection of nodes that subscribe to the given topic.",
	"Method": "Stream<MemberId> getSubscriberNodes(String topicName){\r\n    InternalTopic topic = topics.get(topicName);\r\n    if (topic == null) {\r\n        return Stream.empty();\r\n    }\r\n    return topic.remoteSubscriptions().stream().filter(s -> !s.isTombstone()).map(s -> s.memberId()).distinct();\r\n}"
}, {
	"Path": "io.atomix.core.semaphore.DistributedSemaphoreConfig.setInitialCapacity",
	"Comment": "initialize this semaphore with the given permit count.only the first initialization will be accepted.",
	"Method": "DistributedSemaphoreConfig setInitialCapacity(int permits){\r\n    initialCapacity = permits;\r\n    return this;\r\n}"
}, {
	"Path": "org.axonframework.deadline.AbstractDeadlineManager.dispatchInterceptors",
	"Comment": "provides a list of registered dispatch interceptors. do note that this list is not modifiable, and that changesin the internal structure for dispatch interceptors will be reflected in this list.",
	"Method": "List<MessageDispatchInterceptor<? super DeadlineMessage<?>>> dispatchInterceptors(){\r\n    return Collections.unmodifiableList(dispatchInterceptors);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.RaftSessionState.getCommandRequest",
	"Comment": "returns the last command request sequence number for the session.",
	"Method": "long getCommandRequest(){\r\n    return commandRequest;\r\n}"
}, {
	"Path": "io.atomix.storage.journal.MappableJournalSegmentWriter.map",
	"Comment": "maps the segment writer into memory, returning the mapped buffer.",
	"Method": "MappedByteBuffer map(){\r\n    if (writer instanceof MappedJournalSegmentWriter) {\r\n        return ((MappedJournalSegmentWriter<E>) writer).buffer();\r\n    }\r\n    try {\r\n        JournalWriter<E> writer = this.writer;\r\n        MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, segment.descriptor().maxSegmentSize());\r\n        this.writer = new MappedJournalSegmentWriter(buffer, segment, maxEntrySize, index, namespace);\r\n        writer.close();\r\n        return buffer;\r\n    } catch (IOException e) {\r\n        throw new StorageException(e);\r\n    }\r\n}"
}, {
	"Path": "brave.internal.PlatformTest.linkLocalIp_provisionsOnce",
	"Comment": "getting an endpoint is expensive. this tests it is provisioned only once.test inspired by dagger.internal.doublechecktest",
	"Method": "void linkLocalIp_provisionsOnce(){\r\n    List<Callable<String>> tasks = new ArrayList();\r\n    for (int i = 0; i < 10; i++) {\r\n        tasks.add(() -> platform.linkLocalIp());\r\n    }\r\n    ExecutorService executor = Executors.newFixedThreadPool(tasks.size());\r\n    List<Future<String>> futures = executor.invokeAll(tasks);\r\n    Set<Object> results = Sets.newIdentityHashSet();\r\n    for (Future<String> future : futures) {\r\n        results.add(future.get());\r\n    }\r\n    assertThat(results).hasSize(1);\r\n    executor.shutdownNow();\r\n}"
}, {
	"Path": "org.axonframework.messaging.unitofwork.MessageProcessingContext.addHandler",
	"Comment": "adds a handler to the collection. note that the order in which you register the handlers determines the orderin which they will be handled during the various stages of a unit of work.",
	"Method": "void addHandler(Phase phase,Consumer<UnitOfWork<T>> handler){\r\n    if (LOGGER.isDebugEnabled()) {\r\n        LOGGER.debug(\"Adding handler {} for phase {}\", handler.getClass().getName(), phase.toString());\r\n    }\r\n    final Deque<Consumer<UnitOfWork<T>>> consumers = handlers.computeIfAbsent(phase, p -> new ArrayDeque());\r\n    if (phase.isReverseCallbackOrder()) {\r\n        consumers.addFirst(handler);\r\n    } else {\r\n        consumers.add(handler);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.storage.RaftStorage.deleteFiles",
	"Comment": "deletes file in the storage directory that match the given predicate.",
	"Method": "void deleteFiles(Predicate<File> predicate){\r\n    directory.mkdirs();\r\n    for (File file : directory.listFiles(f -> f.isFile() && predicate.test(f))) {\r\n        try {\r\n            Files.delete(file.toPath());\r\n        } catch (IOException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.atomix.core.map.AsyncDistributedMap.addListener",
	"Comment": "registers the specified listener to be notified whenever the map is updated.",
	"Method": "CompletableFuture<Void> addListener(MapEventListener<K, V> listener,CompletableFuture<Void> addListener,MapEventListener<K, V> listener,Executor executor){\r\n    return addListener(listener, MoreExecutors.directExecutor());\r\n}"
}, {
	"Path": "io.atomix.core.map.DistributedNavigableMapTest.stringArrayCollectionIsEqual",
	"Comment": "compares two collections of strings returns true if they contain the same strings, false otherwise.",
	"Method": "boolean stringArrayCollectionIsEqual(Collection<? extends String> s1,Collection<? extends String> s2){\r\n    if (s1 == null || s2 == null || s1.size() != s2.size()) {\r\n        return false;\r\n    }\r\n    for (String string1 : s1) {\r\n        boolean matched = false;\r\n        for (String string2 : s2) {\r\n            if (string1.equals(string2)) {\r\n                matched = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!matched) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.atomix.primitive.event.Events.findEvents",
	"Comment": "recursively finds events defined by the given type and its implemented interfaces.",
	"Method": "Map<EventType, Method> findEvents(Class<?> type){\r\n    Map<EventType, Method> events = new HashMap();\r\n    for (Method method : type.getDeclaredMethods()) {\r\n        Event event = method.getAnnotation(Event.class);\r\n        if (event != null) {\r\n            String name = event.value().equals(\"\") ? method.getName() : event.value();\r\n            events.put(EventType.from(name), method);\r\n        }\r\n    }\r\n    for (Class<?> iface : type.getInterfaces()) {\r\n        events.putAll(findEvents(iface));\r\n    }\r\n    return events;\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.jdbc.EventSchema.aggregateIdentifierColumn",
	"Comment": "get the name of the column containing the aggregate identifier of the event.",
	"Method": "String aggregateIdentifierColumn(Builder aggregateIdentifierColumn,String aggregateIdentifierColumn){\r\n    return aggregateIdentifierColumn;\r\n}"
}, {
	"Path": "io.atomix.utils.time.VersionedTest.testEquals",
	"Comment": "tests the equals, hashcode and tostring methods using guava equalstester.",
	"Method": "void testEquals(){\r\n    new EqualsTester().addEqualityGroup(stats1, stats1).addEqualityGroup(stats2).testEquals();\r\n}"
}, {
	"Path": "brave.internal.Platform.findPlatform",
	"Comment": "attempt to match the host runtime to a capable platform implementation.",
	"Method": "Platform findPlatform(){\r\n    Platform jre9 = Jre9.buildIfSupported();\r\n    if (jre9 != null)\r\n        return jre9;\r\n    Platform jre7 = Jre7.buildIfSupported();\r\n    if (jre7 != null)\r\n        return jre7;\r\n    return new Jre6();\r\n}"
}, {
	"Path": "brave.context.rxjava2.CurrentTraceContextAssemblyTracking.enableAndChain",
	"Comment": "enable the protocol violation hooks by chaining it before any existing hook.",
	"Method": "SavedHooks enableAndChain(){\r\n    return enable(true);\r\n}"
}, {
	"Path": "brave.internal.recorder.PendingSpan.state",
	"Comment": "returns the state currently accumulated for this trace id and span id",
	"Method": "MutableSpan state(){\r\n    return state;\r\n}"
}, {
	"Path": "io.atomix.primitive.proxy.ProxyClient.applyBy",
	"Comment": "submits an empty operation to the owning partition for the given key.",
	"Method": "CompletableFuture<R> applyBy(String key,Function<S, R> operation,CompletableFuture<R> applyBy,Object key,Function<S, R> operation){\r\n    return getPartition(key).apply(operation);\r\n}"
}, {
	"Path": "io.crossbar.autobahn.websocket.WebSocketWriter.processAppMessage",
	"Comment": "process message other than plain websockets or control message.this is intended to be overridden in derived classes.",
	"Method": "void processAppMessage(Object msg){\r\n    throw new WebSocketException(\"unknown message received by WebSocketWriter\");\r\n}"
}, {
	"Path": "io.atomix.core.map.impl.AtomicMapService.putIfAbsent",
	"Comment": "if the specified key is not already associated with a value associates it with the given value and returns null,else returns the current value.",
	"Method": "MapEntryUpdateResult<K, byte[]> putIfAbsent(K key,byte[] value,MapEntryUpdateResult<K, byte[]> putIfAbsent,K key,byte[] value,long ttl){\r\n    return putIfAbsent(key, value, 0);\r\n}"
}, {
	"Path": "io.atomix.utils.serializer.Namespace.deserialize",
	"Comment": "deserializes given inputstream to an object using kryo instance in pool.",
	"Method": "T deserialize(byte[] bytes,T deserialize,ByteBuffer buffer,T deserialize,InputStream stream,T deserialize,InputStream stream,int bufferSize){\r\n    ByteBufferInput in = new ByteBufferInput(stream, bufferSize);\r\n    Kryo kryo = borrow();\r\n    try {\r\n        @SuppressWarnings(\"unchecked\")\r\n        T obj = (T) kryo.readClassAndObject(in);\r\n        return obj;\r\n    } finally {\r\n        release(kryo);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.storage.journal.SegmentedJournal.getNextSegment",
	"Comment": "returns the segment following the segment with the given id.",
	"Method": "JournalSegment<E> getNextSegment(JournalSegment<E> getNextSegment,long index){\r\n    Map.Entry<Long, JournalSegment<E>> nextSegment = segments.higherEntry(index);\r\n    return nextSegment != null ? nextSegment.getValue() : null;\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.ReplayToken.createReplayToken",
	"Comment": "creates a new trackingtoken that represents the tail position of a stream, in reset state, when appropriate.",
	"Method": "TrackingToken createReplayToken(TrackingToken tokenAtReset,TrackingToken startPosition,TrackingToken createReplayToken,TrackingToken tokenAtReset){\r\n    return createReplayToken(tokenAtReset, null);\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.tokenstore.jdbc.TokenSchema.ownerColum",
	"Comment": "returns the name of the column containing the name of the machine that is currently the owner of this token.",
	"Method": "String ownerColum(){\r\n    return ownerColum;\r\n}"
}, {
	"Path": "io.atomix.utils.concurrent.ThreadContext.isCurrentContext",
	"Comment": "returns a boolean indicating whether the current thread is in this context.",
	"Method": "boolean isCurrentContext(){\r\n    return currentContext() == this;\r\n}"
}, {
	"Path": "org.axonframework.modelling.command.ConflictingAggregateVersionException.getAggregateIdentifier",
	"Comment": "returns the identifier of the aggregate which version is not as expected.",
	"Method": "Object getAggregateIdentifier(){\r\n    return aggregateIdentifier;\r\n}"
}, {
	"Path": "io.atomix.cluster.messaging.impl.TestBroadcastServiceFactory.newBroadcastService",
	"Comment": "returns a new test broadcast service for the given endpoint.",
	"Method": "ManagedBroadcastService newBroadcastService(){\r\n    return new TestBroadcastService(services);\r\n}"
}, {
	"Path": "io.atomix.core.semaphore.impl.BlockingAtomicSemaphore.complete",
	"Comment": "use for complete acquire or tryacquire.if interrupt or timeout before the future completed, set needrelease to true.when the future completes, release these permits.",
	"Method": "T complete(CompletableFuture<T> future,T complete,CompletableFuture<T> future,int acquirePermits){\r\n    AtomicBoolean needRelease = new AtomicBoolean(false);\r\n    try {\r\n        return future.thenApply(version -> {\r\n            if (needRelease.get() && version != null) {\r\n                if (acquirePermits > 0) {\r\n                    asyncSemaphore.release(acquirePermits);\r\n                }\r\n            }\r\n            return version;\r\n        }).get(timeout.toMillis(), TimeUnit.MILLISECONDS);\r\n    } catch (InterruptedException e) {\r\n        needRelease.set(acquirePermits > 0);\r\n        Thread.currentThread().interrupt();\r\n        throw new PrimitiveException.Interrupted();\r\n    } catch (TimeoutException e) {\r\n        needRelease.set(acquirePermits > 0);\r\n        throw new PrimitiveException.Timeout();\r\n    } catch (ExecutionException e) {\r\n        needRelease.set(acquirePermits > 0);\r\n        Throwable cause = Throwables.getRootCause(e);\r\n        if (cause instanceof PrimitiveException) {\r\n            throw (PrimitiveException) cause;\r\n        } else {\r\n            throw new PrimitiveException(cause);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "brave.context.rxjava2.CurrentTraceContextAssemblyTracking.disable",
	"Comment": "disables the validation hooks be resetting the assembled hooks to none.",
	"Method": "void disable(){\r\n    RxJavaPlugins.setOnCompletableAssembly(null);\r\n    RxJavaPlugins.setOnSingleAssembly(null);\r\n    RxJavaPlugins.setOnMaybeAssembly(null);\r\n    RxJavaPlugins.setOnObservableAssembly(null);\r\n    RxJavaPlugins.setOnFlowableAssembly(null);\r\n    RxJavaPlugins.setOnConnectableObservableAssembly(null);\r\n    RxJavaPlugins.setOnConnectableFlowableAssembly(null);\r\n    RxJavaPlugins.setOnParallelAssembly(null);\r\n    enabled = false;\r\n}"
}, {
	"Path": "io.atomix.core.test.messaging.TestUnicastService.isPartitioned",
	"Comment": "returns a boolean indicating whether this node is partitioned from the given address.",
	"Method": "boolean isPartitioned(Address address){\r\n    return partitions.contains(address);\r\n}"
}, {
	"Path": "org.axonframework.springboot.SerializerProperties.getMessages",
	"Comment": "the type of serializer to use to serialize the payload and meta data of messages. defaults to the generalserializer.",
	"Method": "SerializerType getMessages(){\r\n    return messages;\r\n}"
}, {
	"Path": "io.atomix.utils.Generics.getGenericInterfaceType",
	"Comment": "returns the generic type at the given position for the given interface.",
	"Method": "Type getGenericInterfaceType(Object instance,Class<?> iface,int position){\r\n    Class<?> type = instance.getClass();\r\n    while (type != Object.class) {\r\n        for (Type genericType : type.getGenericInterfaces()) {\r\n            if (genericType instanceof ParameterizedType) {\r\n                ParameterizedType parameterizedType = (ParameterizedType) genericType;\r\n                if (parameterizedType.getRawType() == iface) {\r\n                    return parameterizedType.getActualTypeArguments()[position];\r\n                }\r\n            }\r\n        }\r\n        type = type.getSuperclass();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.assertj.core.api.SoftAssertionsTest.object_array_soft_assertions_should_report_errors_on_final_methods_and_methods_that_switch_the_object_under_test",
	"Comment": "the test would fail if any method was not proxyable as the assertion error would not be softly caught",
	"Method": "void object_array_soft_assertions_should_report_errors_on_final_methods_and_methods_that_switch_the_object_under_test(){\r\n    Name[] names = array(name(\"John\", \"Doe\"), name(\"Jane\", \"Doe\"));\r\n    CartoonCharacter[] characters = array(homer, fred);\r\n    softly.assertThat(names).as(\"extracting(Name::getFirst)\").overridingErrorMessage(\"error message\").extracting(Name::getFirst).contains(\"gandalf\").contains(\"frodo\");\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"extracting(\\\"last\\\")\").extracting(\"last\").containsExactly(\"foo\", \"bar\");\r\n    softly.assertThat(characters).as(\"using flatExtracting on Iterable\").overridingErrorMessage(\"error message\").flatExtracting(CartoonCharacter::getChildren).hasSize(1).containsAnyOf(homer, fred);\r\n    softly.assertThat(characters).overridingErrorMessage(\"error message\").as(\"using flatExtracting on Iterable with exception\").flatExtracting(CartoonCharacter::getChildrenWithException).containsExactlyInAnyOrder(homer, fred);\r\n    softly.assertThat(characters).containsOnly(bart);\r\n    softly.assertThat(characters).containsOnlyOnce(maggie, bart);\r\n    softly.assertThat(characters).containsSequence(homer, bart);\r\n    softly.assertThat(characters).containsSubsequence(homer, maggie);\r\n    softly.assertThat(characters).doesNotContain(homer, maggie);\r\n    softly.assertThat(characters).doesNotContainSequence(fred);\r\n    softly.assertThat(characters).doesNotContainSubsequence(homer, fred);\r\n    softly.assertThat(characters).isSubsetOf(homer, bart);\r\n    softly.assertThat(characters).startsWith(fred);\r\n    softly.assertThat(characters).endsWith(bart);\r\n    softly.assertThat(names).as(\"extracting(Name::getFirst, Name::getLast)\").overridingErrorMessage(\"error message\").extracting(Name::getFirst, Name::getLast).contains(tuple(\"John\", \"Doe\")).contains(tuple(\"Frodo\", \"Baggins\"));\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"extracting(\\\"first\\\", \\\"last\\\")\").extracting(\"first\", \"last\").contains(tuple(\"John\", \"Doe\")).contains(tuple(\"Bilbo\", \"Baggins\"));\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"extracting(firstNameFunction)\").extracting(firstNameFunction).contains(\"John\").contains(\"sam\");\r\n    softly.assertThat(names).as(\"extracting(\\\"first\\\", String.class)\").overridingErrorMessage(\"error message\").extracting(\"first\", String.class).contains(\"John\").contains(\"Aragorn\");\r\n    softly.assertThat(names).as(\"filteredOn(name -> name.first.startsWith(\\\"Jo\\\"))\").overridingErrorMessage(\"error message\").filteredOn(name -> name.first.startsWith(\"Jo\")).hasSize(123);\r\n    softly.assertThat(names).as(\"filteredOn + extracting\").overridingErrorMessage(\"error message\").filteredOn(name -> name.first.startsWith(\"Jo\")).extracting(firstNameFunction).contains(\"Sauron\");\r\n    softly.assertThat(names).as(\"extractingResultOf(\\\"getFirst\\\")\").overridingErrorMessage(\"error message\").extractingResultOf(\"getFirst\").contains(\"John\", \"Jane\").contains(\"Sam\", \"Aragorn\");\r\n    softly.assertThat(names).as(\"extractingResultOf(\\\"getFirst\\\", String.class)\").overridingErrorMessage(\"error message\").extractingResultOf(\"getFirst\", String.class).contains(\"John\", \"Jane\").contains(\"Messi\", \"Ronaldo\");\r\n    softly.assertThat(names).as(\"filteredOn with condition\").overridingErrorMessage(\"error message\").filteredOn(new Condition(name -> name.first.startsWith(\"Jo\"), \"startsWith Jo\")).hasSize(5);\r\n    softly.assertThat(names).as(\"filteredOn firstName in {John, Frodo}\").overridingErrorMessage(\"error message\").filteredOn(\"first\", in(\"John\", \"Frodo\")).isEmpty();\r\n    softly.assertThat(names).as(\"filteredOn firstName = John\").overridingErrorMessage(\"error message\").filteredOn(\"first\", \"John\").isEmpty();\r\n    softly.assertThat(names).as(\"filteredOn firstName = null\").overridingErrorMessage(\"error message\").filteredOnNull(\"first\").isNotEmpty();\r\n    softly.assertThat(characters).as(\"using flatExtracting(String fieldOrPropertyName)\").overridingErrorMessage(\"error message\").flatExtracting(\"children\").contains(bart, maggie).contains(\"Sauron\");\r\n    softly.assertThat(names).filteredOnAssertions(name -> assertThat(name.first).startsWith(\"Jo\")).as(\"filteredOn with consumer\").hasSize(5);\r\n    List<Throwable> errorsCollected = softly.errorsCollected();\r\n    assertThat(errorsCollected).hasSize(30);\r\n    assertThat(errorsCollected.get(0)).hasMessage(\"[extracting(Name::getFirst)] error message\");\r\n    assertThat(errorsCollected.get(1)).hasMessage(\"[extracting(Name::getFirst)] error message\");\r\n    assertThat(errorsCollected.get(2)).hasMessage(\"[extracting(\\\"last\\\")] error message\").hasMessage(\"[extracting(\\\"last\\\")] error message\");\r\n    assertThat(errorsCollected.get(3)).hasMessage(\"[using flatExtracting on Iterable] error message\");\r\n    assertThat(errorsCollected.get(4)).hasMessage(\"[using flatExtracting on Iterable] error message\");\r\n    assertThat(errorsCollected.get(5)).hasMessage(\"[using flatExtracting on Iterable with exception] error message\");\r\n    assertThat(errorsCollected.get(6)).hasMessageContaining(bart.toString());\r\n    assertThat(errorsCollected.get(7)).hasMessageContaining(maggie.toString());\r\n    assertThat(errorsCollected.get(8)).hasMessageContaining(bart.toString());\r\n    assertThat(errorsCollected.get(9)).hasMessageContaining(maggie.toString());\r\n    assertThat(errorsCollected.get(10)).hasMessageContaining(homer.toString());\r\n    assertThat(errorsCollected.get(11)).hasMessageContaining(fred.toString());\r\n    assertThat(errorsCollected.get(12)).hasMessageContaining(homer.toString());\r\n    assertThat(errorsCollected.get(13)).hasMessageContaining(bart.toString());\r\n    assertThat(errorsCollected.get(14)).hasMessageContaining(fred.toString());\r\n    assertThat(errorsCollected.get(15)).hasMessageContaining(bart.toString());\r\n    assertThat(errorsCollected.get(16)).hasMessage(\"[extracting(Name::getFirst, Name::getLast)] error message\");\r\n    assertThat(errorsCollected.get(17)).hasMessage(\"[extracting(\\\"first\\\", \\\"last\\\")] error message\");\r\n    assertThat(errorsCollected.get(18)).hasMessage(\"[extracting(firstNameFunction)] error message\");\r\n    assertThat(errorsCollected.get(19)).hasMessage(\"[extracting(\\\"first\\\", String.class)] error message\");\r\n    assertThat(errorsCollected.get(20)).hasMessage(\"[filteredOn(name -> name.first.startsWith(\\\"Jo\\\"))] error message\");\r\n    assertThat(errorsCollected.get(21)).hasMessage(\"[filteredOn + extracting] error message\");\r\n    assertThat(errorsCollected.get(22)).hasMessage(\"[extractingResultOf(\\\"getFirst\\\")] error message\");\r\n    assertThat(errorsCollected.get(23)).hasMessage(\"[extractingResultOf(\\\"getFirst\\\", String.class)] error message\");\r\n    assertThat(errorsCollected.get(24)).hasMessage(\"[filteredOn with condition] error message\");\r\n    assertThat(errorsCollected.get(25)).hasMessage(\"[filteredOn firstName in {John, Frodo}] error message\");\r\n    assertThat(errorsCollected.get(26)).hasMessage(\"[filteredOn firstName = John] error message\");\r\n    assertThat(errorsCollected.get(27)).hasMessage(\"[filteredOn firstName = null] error message\");\r\n    assertThat(errorsCollected.get(28)).hasMessage(\"[using flatExtracting(String fieldOrPropertyName)] error message\");\r\n    assertThat(errorsCollected.get(29)).hasMessageContaining(\"filteredOn with consumer\");\r\n}"
}, {
	"Path": "io.atomix.cluster.messaging.impl.TestUnicastService.isPartitioned",
	"Comment": "returns a boolean indicating whether this node is partitioned from the given address.",
	"Method": "boolean isPartitioned(Address address){\r\n    return partitions.contains(address);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.RaftSessionSequencerTest.testSequenceEventAtCommand",
	"Comment": "tests sequencing an event that arrives before a command response.",
	"Method": "void testSequenceEventAtCommand(){\r\n    RaftSessionSequencer sequencer = new RaftSessionSequencer(new RaftSessionState(\"test\", SessionId.from(1), UUID.randomUUID().toString(), TestPrimitiveType.instance(), 1000));\r\n    long sequence = sequencer.nextRequest();\r\n    PublishRequest request = PublishRequest.builder().withSession(1).withEventIndex(2).withPreviousIndex(0).withEvents(Collections.emptyList()).build();\r\n    CommandResponse response = CommandResponse.builder().withStatus(RaftResponse.Status.OK).withIndex(2).withEventIndex(2).build();\r\n    AtomicInteger run = new AtomicInteger();\r\n    sequencer.sequenceResponse(sequence, response, () -> assertEquals(1, run.getAndIncrement()));\r\n    sequencer.sequenceEvent(request, () -> assertEquals(0, run.getAndIncrement()));\r\n    assertEquals(2, run.get());\r\n}"
}, {
	"Path": "org.axonframework.common.TypeReflectionUtils.getExactDirectSuperTypes",
	"Comment": "returns the direct supertypes of the given type. resolves type parameters.",
	"Method": "Type[] getExactDirectSuperTypes(Type type){\r\n    if (type instanceof ParameterizedType || type instanceof Class) {\r\n        return getExactDirectSuperTypesOfParameterizedTypeOrClass(type);\r\n    } else if (type instanceof TypeVariable) {\r\n        return ((TypeVariable<?>) type).getBounds();\r\n    } else if (type instanceof WildcardType) {\r\n        return ((WildcardType) type).getUpperBounds();\r\n    } else if (type instanceof GenericArrayType) {\r\n        return getExactDirectSuperTypes(((GenericArrayType) type).getGenericComponentType());\r\n    } else if (type == null) {\r\n        throw new IllegalArgumentException(\"Cannot handle given Type of null\");\r\n    }\r\n    logger.debug(type.getClass() + \" is not supported for retrieving the exact direct super types from. Will by \" + \"default return the type contained in an Type[]\");\r\n    return new Type[] { type };\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.EventSourcingRepository.readEvents",
	"Comment": "reads the events for the given aggregateidentifier from the eventstore. this method may be overridden toadd pre or postprocessing to the loading of an event stream",
	"Method": "DomainEventStream readEvents(String aggregateIdentifier){\r\n    return eventStore.readEvents(aggregateIdentifier);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.RaftSession.clearResults",
	"Comment": "clears command results up to the given sequence number.command output is removed from memory up to the given sequence number. additionally, since we know theclient received a response for all commands up to the given sequence number, command futures are removedfrom memory as well.",
	"Method": "void clearResults(long sequence){\r\n    if (sequence > commandLowWaterMark) {\r\n        for (long i = commandLowWaterMark + 1; i <= sequence; i++) {\r\n            results.remove(i);\r\n            commandLowWaterMark = i;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "brave.context.rxjava2.internal.TraceContextObservable.subscribeActual",
	"Comment": "wraps the observer so that its callbacks run in the assembly context. this does not affect anysubscription callbacks.",
	"Method": "void subscribeActual(Observer<? super T> o){\r\n    source.subscribe(new TraceContextObserver(o, contextScoper, assembled));\r\n}"
}, {
	"Path": "io.atomix.core.election.Leader.map",
	"Comment": "converts the leader identifier using the given mapping function.",
	"Method": "Leader<U> map(Function<T, U> mapper){\r\n    return new Leader(mapper.apply(id), term, termStartTime);\r\n}"
}, {
	"Path": "brave.Tracer.toSpan",
	"Comment": "converts the context to a span object after decorating it for propagation",
	"Method": "Span toSpan(TraceContext context){\r\n    if (context == null)\r\n        throw new NullPointerException(\"context == null\");\r\n    if (alwaysSampleLocal) {\r\n        int flags = InternalPropagation.instance.flags(context);\r\n        if ((flags & FLAG_SAMPLED_LOCAL) != FLAG_SAMPLED_LOCAL) {\r\n            context = InternalPropagation.instance.withFlags(context, flags | FLAG_SAMPLED_LOCAL);\r\n        }\r\n    }\r\n    return _toSpan(propagationFactory.decorate(context));\r\n}"
}, {
	"Path": "brave.dubbo.rpc.ITTracingFilter_Consumer.usesParentFromInvocationTime",
	"Comment": "this tests that the parent is determined at the time the request was made, not when the requestwas executed.",
	"Method": "void usesParentFromInvocationTime(){\r\n    server.enqueueDelay(TimeUnit.SECONDS.toMillis(1));\r\n    ScopedSpan parent = tracing.tracer().startScopedSpan(\"test\");\r\n    try {\r\n        RpcContext.getContext().asyncCall(() -> client.get().sayHello(\"jorge\"));\r\n        RpcContext.getContext().asyncCall(() -> client.get().sayHello(\"romeo\"));\r\n    } finally {\r\n        parent.finish();\r\n    }\r\n    ScopedSpan otherSpan = tracing.tracer().startScopedSpan(\"test2\");\r\n    try {\r\n        for (int i = 0; i < 2; i++) {\r\n            TraceContext context = server.takeRequest().context();\r\n            assertThat(context.traceId()).isEqualTo(parent.context().traceId());\r\n            assertThat(context.parentId()).isEqualTo(parent.context().spanId());\r\n        }\r\n    } finally {\r\n        otherSpan.finish();\r\n    }\r\n    assertThat(Arrays.asList(takeSpan(), takeSpan(), takeSpan(), takeSpan())).extracting(Span::kind).containsOnly(null, Span.Kind.CLIENT);\r\n}"
}, {
	"Path": "io.atomix.utils.misc.StringUtils.split",
	"Comment": "splits the input string with the given regex and filters empty strings.",
	"Method": "String[] split(String input,String regex){\r\n    if (input == null) {\r\n        return null;\r\n    }\r\n    String[] arr = input.split(regex);\r\n    List<String> results = new ArrayList(arr.length);\r\n    for (String a : arr) {\r\n        if (!a.trim().isEmpty()) {\r\n            results.add(a);\r\n        }\r\n    }\r\n    return results.toArray(new String[0]);\r\n}"
}, {
	"Path": "brave.Tracer.startScopedSpanWithParent",
	"Comment": "this api is needed to make tools such as executors which need to carry the invocation context",
	"Method": "ScopedSpan startScopedSpanWithParent(String name,TraceContext parent){\r\n    if (name == null)\r\n        throw new NullPointerException(\"name == null\");\r\n    if (parent == null)\r\n        parent = currentTraceContext.get();\r\n    TraceContext context = parent != null ? nextContext(parent) : newRootContext();\r\n    Scope scope = currentTraceContext.newScope(context);\r\n    if (isNoop(context))\r\n        return new NoopScopedSpan(context, scope);\r\n    PendingSpan pendingSpan = pendingSpans.getOrCreate(context, true);\r\n    Clock clock = pendingSpan.clock();\r\n    MutableSpan state = pendingSpan.state();\r\n    state.name(name);\r\n    return new RealScopedSpan(context, scope, state, clock, pendingSpans, finishedSpanHandler);\r\n}"
}, {
	"Path": "org.axonframework.disruptor.commandhandling.DisruptorCommandBus.stop",
	"Comment": "shuts down the command bus. it no longer accepts new commands, and finishes processing commands that havealready been published. this method will not shut down any executor that has been provided as part of thebuilder process.",
	"Method": "void stop(){\r\n    if (!started) {\r\n        return;\r\n    }\r\n    started = false;\r\n    long lastChangeDetected = System.currentTimeMillis();\r\n    long lastKnownCursor = disruptor.getRingBuffer().getCursor();\r\n    while (System.currentTimeMillis() - lastChangeDetected < coolingDownPeriod && !Thread.interrupted()) {\r\n        if (disruptor.getRingBuffer().getCursor() != lastKnownCursor) {\r\n            lastChangeDetected = System.currentTimeMillis();\r\n            lastKnownCursor = disruptor.getRingBuffer().getCursor();\r\n        }\r\n    }\r\n    disruptorShutDown = true;\r\n    disruptor.shutdown();\r\n    if (executorService != null) {\r\n        executorService.shutdown();\r\n    }\r\n}"
}, {
	"Path": "org.axonframework.test.utils.RecordingCommandBus.getSubscriptions",
	"Comment": "returns a map will all command names and their command handler that have been subscribed to this command bus.",
	"Method": "Map<String, MessageHandler<? super CommandMessage<?>>> getSubscriptions(){\r\n    return subscriptions;\r\n}"
}, {
	"Path": "org.axonframework.serialization.SerializedMessage.isPayloadDeserialized",
	"Comment": "indicates whether the payload of this message has already been deserialized.",
	"Method": "boolean isPayloadDeserialized(){\r\n    return payload.isDeserialized();\r\n}"
}, {
	"Path": "org.axonframework.messaging.MessageHandler.canHandle",
	"Comment": "indicates whether this handler can handle the given message",
	"Method": "boolean canHandle(T message){\r\n    return true;\r\n}"
}, {
	"Path": "org.axonframework.spring.config.AxonConfiguration.commandGateway",
	"Comment": "returns the commandgateway used to send commands to command handlers.",
	"Method": "CommandGateway commandGateway(CommandBus commandBus){\r\n    return DefaultCommandGateway.builder().commandBus(commandBus).build();\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.DispatchMessage.getPayloadRevision",
	"Comment": "returns the payload revision of the serialized payload of the command carried by this instance.",
	"Method": "String getPayloadRevision(){\r\n    return payloadRevision;\r\n}"
}, {
	"Path": "org.awaitility.reflect.WhiteboxImpl.getFieldAnnotatedWith",
	"Comment": "get field annotated with a particular annotation. this method traversesthe class hierarchy when checking for the annotation.",
	"Method": "Field getFieldAnnotatedWith(Object object,Class<? extends Annotation> annotationType){\r\n    return findSingleFieldUsingStrategy(new FieldAnnotationMatcherStrategy(annotationType), object, true, getType(object));\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.impl.RaftServiceManager.scheduleCompletion",
	"Comment": "schedules a completion check for the snapshot at the given index.",
	"Method": "void scheduleCompletion(Snapshot snapshot){\r\n    stateContext.schedule(SNAPSHOT_COMPLETION_DELAY, () -> {\r\n        if (completeSnapshot(snapshot.index())) {\r\n            logger.debug(\"Completing snapshot {}\", snapshot.index());\r\n            snapshot.complete();\r\n            if (!raft.getLoadMonitor().isUnderHighLoad() || isRunningOutOfDiskSpace() || isRunningOutOfMemory()) {\r\n                compactLogs(snapshot.index());\r\n            } else {\r\n                scheduleCompaction(snapshot.index());\r\n            }\r\n        } else {\r\n            scheduleCompletion(snapshot);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "brave.context.rxjava2.CurrentTraceContextAssemblyTrackingTest.newObservableThatErrs",
	"Comment": "if we have a span in scope, the message will be the current trace id",
	"Method": "Observable<Integer> newObservableThatErrs(){\r\n    return Observable.range(1, 5).concatWith(Observable.fromCallable(() -> {\r\n        TraceContext ctx = currentTraceContext.get();\r\n        String message = ctx != null ? ctx.traceIdString() : null;\r\n        throw new IOException(message);\r\n    }));\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.ReplyMessage.getExceptionRevision",
	"Comment": "returns the exception revision of the serialized reply message.",
	"Method": "String getExceptionRevision(){\r\n    return exceptionRevision;\r\n}"
}, {
	"Path": "io.atomix.protocols.backup.PrimaryBackupTest.testManyEvents",
	"Comment": "tests submitting a linearizable event that publishes to all sessions.",
	"Method": "void testManyEvents(int nodes,int backups,Replication replication){\r\n    createServers(nodes);\r\n    PrimaryBackupClient client = createClient();\r\n    SessionClient session = createProxy(client, backups, replication);\r\n    session.addEventListener(CHANGE_EVENT, message -> {\r\n        threadAssertNotNull(message);\r\n        resume();\r\n    });\r\n    for (int i = 0; i < 10; i++) {\r\n        session.execute(operation(EVENT, SERIALIZER.encode(true))).thenRun(this::resume);\r\n        await(5000, 2);\r\n    }\r\n}"
}, {
	"Path": "org.axonframework.config.Configuration.parameterResolverFactory",
	"Comment": "returns the parameter resolver factory defined in this configuration",
	"Method": "ParameterResolverFactory parameterResolverFactory(){\r\n    return getComponent(ParameterResolverFactory.class);\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.DistributedCommandBus.registerDispatchInterceptor",
	"Comment": "registers the given list of dispatch interceptors to the command bus. all incoming commands will pass throughthe interceptors at the given order before the command is dispatched toward the command handler.",
	"Method": "Registration registerDispatchInterceptor(MessageDispatchInterceptor<? super CommandMessage<?>> dispatchInterceptor){\r\n    dispatchInterceptors.add(dispatchInterceptor);\r\n    return () -> dispatchInterceptors.remove(dispatchInterceptor);\r\n}"
}, {
	"Path": "io.atomix.core.election.Leader.timestamp",
	"Comment": "returns the system time when the current leadership term started.",
	"Method": "long timestamp(){\r\n    return termStartTime;\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.AbstractEventBus.queuedMessages",
	"Comment": "returns a list of all the events staged for publication in this unit of work. changing this list willnot affect the publication of events.",
	"Method": "List<EventMessage<?>> queuedMessages(){\r\n    if (!CurrentUnitOfWork.isStarted()) {\r\n        return Collections.emptyList();\r\n    }\r\n    List<EventMessage<?>> messages = new ArrayList();\r\n    for (UnitOfWork<?> uow = CurrentUnitOfWork.get(); uow != null; uow = uow.parent().orElse(null)) {\r\n        messages.addAll(0, uow.getOrDefaultResource(eventsKey, Collections.emptyList()));\r\n    }\r\n    return messages;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.RaftTest.testSequenceBoundedLinearizableOperations",
	"Comment": "tests that operations are properly sequenced on the client.",
	"Method": "void testSequenceBoundedLinearizableOperations(){\r\n    testSequenceOperations(5, ReadConsistency.LINEARIZABLE_LEASE);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.RaftSession.isTimedOut",
	"Comment": "returns a boolean indicating whether the session is timed out.",
	"Method": "boolean isTimedOut(long timestamp){\r\n    long lastUpdated = this.lastUpdated;\r\n    return lastUpdated > 0 && timestamp - lastUpdated > maxTimeout;\r\n}"
}, {
	"Path": "io.atomix.cluster.messaging.impl.MessageEncoderV1.acceptOutboundMessage",
	"Comment": "effectively same result as one generated by messagetobyteencoder",
	"Method": "boolean acceptOutboundMessage(Object msg){\r\n    return msg instanceof ProtocolMessage;\r\n}"
}, {
	"Path": "org.assertj.core.internal.strings.Strings_assertContainsOnlyDigits_Test.should_fail_if_actual_is_empty",
	"Comment": "see discussion on failing the assertion for empty charsequence",
	"Method": "void should_fail_if_actual_is_empty(){\r\n    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> strings.assertContainsOnlyDigits(someInfo(), \"\")).withMessage(shouldContainOnlyDigits(\"\").create());\r\n}"
}, {
	"Path": "io.atomix.core.multimap.AsyncDistributedMultimap.addListener",
	"Comment": "registers the specified listener to be notified whenever the map is updated.",
	"Method": "CompletableFuture<Void> addListener(MultimapEventListener<K, V> listener,CompletableFuture<Void> addListener,MultimapEventListener<K, V> listener,Executor executor){\r\n    return addListener(listener, MoreExecutors.directExecutor());\r\n}"
}, {
	"Path": "io.atomix.primitive.event.Events.getEventMap",
	"Comment": "returns the collection of events provided by the given service interface.",
	"Method": "Map<EventType, Method> getEventMap(Class<?> serviceInterface){\r\n    if (!serviceInterface.isInterface()) {\r\n        Class type = serviceInterface;\r\n        Map<EventType, Method> events = new HashMap();\r\n        while (type != Object.class) {\r\n            for (Class<?> iface : type.getInterfaces()) {\r\n                events.putAll(findEvents(iface));\r\n            }\r\n            type = type.getSuperclass();\r\n        }\r\n        return events;\r\n    }\r\n    return findEvents(serviceInterface);\r\n}"
}, {
	"Path": "org.axonframework.modelling.command.ConflictingAggregateVersionException.getExpectedVersion",
	"Comment": "returns the version expected by the component loading the aggregate.",
	"Method": "long getExpectedVersion(){\r\n    return expectedVersion;\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.jdbc.EventSchema.timestampColumn",
	"Comment": "get the name of the column containing the timestamp of the event.",
	"Method": "String timestampColumn(Builder timestampColumn,String timestampColumn){\r\n    return timestampColumn;\r\n}"
}, {
	"Path": "io.atomix.cluster.AtomixClusterBuilder.withMembershipProvider",
	"Comment": "sets the cluster membership provider.the membership provider determines how peers are located and the cluster is bootstrapped.",
	"Method": "AtomixClusterBuilder withMembershipProvider(NodeDiscoveryProvider locationProvider){\r\n    config.setDiscoveryConfig(locationProvider.config());\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.RaftSessionState.nextCommandRequest",
	"Comment": "returns the next command request sequence number for the session.",
	"Method": "long nextCommandRequest(){\r\n    return ++commandRequest;\r\n}"
}, {
	"Path": "brave.propagation.CurrentTraceContext.wrap",
	"Comment": "wraps the input so that it executes with the same context as now.",
	"Method": "Callable<C> wrap(Callable<C> task,Runnable wrap,Runnable task){\r\n    final TraceContext invocationContext = get();\r\n    class CurrentTraceContextRunnable implements Runnable {\r\n        @Override\r\n        public void run() {\r\n            try (Scope scope = maybeScope(invocationContext)) {\r\n                task.run();\r\n            }\r\n        }\r\n    }\r\n    return new CurrentTraceContextRunnable();\r\n}"
}, {
	"Path": "brave.propagation.CurrentTraceContext.wrap",
	"Comment": "wraps the input so that it executes with the same context as now.",
	"Method": "Callable<C> wrap(Callable<C> task,Runnable wrap,Runnable task){\r\n    try (Scope scope = maybeScope(invocationContext)) {\r\n        task.run();\r\n    }\r\n}"
}, {
	"Path": "brave.context.rxjava2.internal.TraceContextConnectableObservable.subscribeActual",
	"Comment": "wraps the observer so that its callbacks run in the assembly context. this does not affect anysubscription callbacks.",
	"Method": "void subscribeActual(Observer<? super T> o){\r\n    source.subscribe(new TraceContextObserver(o, contextScoper, assembled));\r\n}"
}, {
	"Path": "io.atomix.storage.journal.SegmentedJournal.maxEntrySize",
	"Comment": "returns the maximum journal entry size.the maximum entry size dictates the maximum size any entry in the segment may consume in bytes.",
	"Method": "int maxEntrySize(){\r\n    return maxEntrySize;\r\n}"
}, {
	"Path": "brave.propagation.StrictScopeDecorator.decorateScope",
	"Comment": "identifies problems by throwing assertion errors when a scope is closed on a different thread.",
	"Method": "Scope decorateScope(TraceContext currentSpan,Scope scope){\r\n    return new StrictScope(scope, new Error(String.format(\"Thread %s opened scope for %s here:\", Thread.currentThread().getName(), currentSpan)));\r\n}"
}, {
	"Path": "io.atomix.protocols.gossip.map.AntiEntropyMapDelegate.handleBootstrap",
	"Comment": "handles a bootstrap request from a peer.when handling a bootstrap request from a peer, the node sends batches of entries back to the peer and completes thebootstrap request once all batches have been received and processed.",
	"Method": "CompletableFuture<Void> handleBootstrap(MemberId peer){\r\n    log.trace(\"Received bootstrap request from {} for {}\", peer, bootstrapMessageSubject);\r\n    Function<List<UpdateEntry>, CompletableFuture<Void>> sendUpdates = updates -> {\r\n        log.trace(\"Initializing {} with {} entries\", peer, updates.size());\r\n        return clusterCommunicator.<List<UpdateEntry>, Void>send(initializeMessageSubject, ImmutableList.copyOf(updates), serializer::encode, serializer::decode, peer).whenComplete((result, error) -> {\r\n            if (error != null) {\r\n                log.debug(\"Failed to initialize {}\", peer, error);\r\n            }\r\n        });\r\n    };\r\n    List<CompletableFuture<Void>> futures = Lists.newArrayList();\r\n    List<UpdateEntry> updates = Lists.newArrayList();\r\n    for (Map.Entry<String, MapValue> entry : items.entrySet()) {\r\n        String key = entry.getKey();\r\n        MapValue value = entry.getValue();\r\n        if (value.isAlive()) {\r\n            updates.add(new UpdateEntry(key, value));\r\n            if (updates.size() == DEFAULT_MAX_EVENTS) {\r\n                futures.add(sendUpdates.apply(updates));\r\n                updates = new ArrayList();\r\n            }\r\n        }\r\n    }\r\n    if (!updates.isEmpty()) {\r\n        futures.add(sendUpdates.apply(updates));\r\n    }\r\n    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()]));\r\n}"
}, {
	"Path": "org.axonframework.serialization.ChainedConverterTest.testAnotherInexistentRoute",
	"Comment": "detects an issue where the chainedconverter hangs as it evaluates a recursive route",
	"Method": "void testAnotherInexistentRoute(){\r\n    target = Number.class;\r\n    source = \"hello\";\r\n    assertFalse(ChainedConverter.canConvert(String.class, target, candidates));\r\n    testSubject = ChainedConverter.calculateChain(String.class, target, candidates);\r\n}"
}, {
	"Path": "io.atomix.utils.concurrent.Futures.exceptionalFutureAsync",
	"Comment": "creates a future that is asynchronously completed exceptionally.",
	"Method": "CompletableFuture<T> exceptionalFutureAsync(Throwable t,Executor executor){\r\n    CompletableFuture<T> future = new CompletableFuture();\r\n    executor.execute(() -> {\r\n        future.completeExceptionally(t);\r\n    });\r\n    return future;\r\n}"
}, {
	"Path": "brave.context.rxjava2.internal.TraceContextParallelFlowable.subscribe",
	"Comment": "wraps the subscribers so that their callbacks run in the assembly context. this does not affectany subscription callbacks.",
	"Method": "void subscribe(Subscriber<? super T>[] s){\r\n    if (!validate(s))\r\n        return;\r\n    int n = s.length;\r\n    @SuppressWarnings(\"unchecked\")\r\n    Subscriber<? super T>[] parents = new Subscriber[n];\r\n    for (int i = 0; i < n; i++) {\r\n        Subscriber<? super T> z = s[i];\r\n        parents[i] = Wrappers.wrap(z, contextScoper, assembled);\r\n    }\r\n    source.subscribe(parents);\r\n}"
}, {
	"Path": "org.axonframework.test.aggregate.Reporter.reportDifferentMetaData",
	"Comment": "report an error due to a difference in the metadata of a message",
	"Method": "void reportDifferentMetaData(Class<?> messageType,Map<String, Object> missingEntries,Map<String, Object> additionalEntries){\r\n    StringBuilder sb = new StringBuilder(\"One of the messages contained different metadata than expected\");\r\n    sb.append(NEWLINE).append(NEWLINE).append(\"In a message of type [\").append(messageType.getSimpleName()).append(\"], \");\r\n    if (!additionalEntries.isEmpty()) {\r\n        sb.append(\"metadata entries\" + NEWLINE).append(\"[\");\r\n        for (Map.Entry<String, Object> entry : additionalEntries.entrySet()) {\r\n            sb.append(entryAsString(entry) + \", \");\r\n        }\r\n        sb.delete(sb.lastIndexOf(\", \"), sb.lastIndexOf(\",\") + 2);\r\n        sb.append(\"] \" + NEWLINE);\r\n        sb.append(\"were not expected. \");\r\n    }\r\n    if (!missingEntries.isEmpty()) {\r\n        sb.append(\"metadata entries \" + NEWLINE).append(\"[\");\r\n        for (Map.Entry<String, Object> entry : missingEntries.entrySet()) {\r\n            sb.append(entryAsString(entry) + \", \");\r\n        }\r\n        sb.delete(sb.lastIndexOf(\",\"), sb.lastIndexOf(\",\") + 2);\r\n        sb.append(\"] \" + NEWLINE);\r\n        sb.append(\"were expected but not seen.\");\r\n    }\r\n    throw new AxonAssertionError(sb.toString());\r\n}"
}, {
	"Path": "io.atomix.cluster.protocol.SwimMembershipProtocolBuilder.withFailureTimeout",
	"Comment": "sets the failure timeout to use prior to phi failure detectors being populated.",
	"Method": "SwimMembershipProtocolBuilder withFailureTimeout(Duration failureTimeout){\r\n    config.setFailureTimeout(failureTimeout);\r\n    return this;\r\n}"
}, {
	"Path": "brave.http.HttpParser.request",
	"Comment": "very limited cardinality. moreover, users who care strictly about size can override this.",
	"Method": "void request(HttpAdapter<Req, ?> adapter,Req req,SpanCustomizer customizer){\r\n    customizer.name(spanName(adapter, req));\r\n    String method = adapter.method(req);\r\n    if (method != null)\r\n        customizer.tag(\"http.method\", method);\r\n    String path = adapter.path(req);\r\n    if (path != null)\r\n        customizer.tag(\"http.path\", path);\r\n}"
}, {
	"Path": "org.axonframework.queryhandling.SimpleQueryUpdateEmitter.activeSubscriptions",
	"Comment": "provides the set of running subscription queries. if there are changes to subscriptions they will be reflected inthe returned set of this method.",
	"Method": "Set<SubscriptionQueryMessage<?, ?, ?>> activeSubscriptions(){\r\n    return Collections.unmodifiableSet(updateHandlers.keySet());\r\n}"
}, {
	"Path": "io.atomix.storage.journal.JournalSegmentDescriptor.builder",
	"Comment": "returns a descriptor builder for the given descriptor buffer.",
	"Method": "Builder builder(Builder builder,ByteBuffer buffer){\r\n    return new Builder(buffer);\r\n}"
}, {
	"Path": "io.atomix.core.map.MapBuilder.withRegistrationRequired",
	"Comment": "sets whether registration is required for serializable types.",
	"Method": "B withRegistrationRequired(B withRegistrationRequired,boolean registrationRequired){\r\n    config.setRegistrationRequired(registrationRequired);\r\n    return (B) this;\r\n}"
}, {
	"Path": "brave.propagation.ExtraFieldPropagationTest.extraKeysDontIncludeTraceContextKeys",
	"Comment": "ensures opentracing 0.31 can read the extra keys, as its textmap has no get by name function.",
	"Method": "void extraKeysDontIncludeTraceContextKeys(){\r\n    assertThat(factory.create(Propagation.KeyFactory.STRING).extraKeys()).containsExactly(\"x-vcap-request-id\", \"x-amzn-trace-id\");\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.jdbc.EventSchema.metaDataColumn",
	"Comment": "get the name of the column containing the serialized metadata of the event.",
	"Method": "String metaDataColumn(Builder metaDataColumn,String metaDataColumn){\r\n    return metaDataColumn;\r\n}"
}, {
	"Path": "io.atomix.core.multimap.AtomicMultimapTest.addAndRemoveTest",
	"Comment": "contains tests for put, putall, remove, removeall and replace.",
	"Method": "void addAndRemoveTest(){\r\n    AtomicMultimap<String, String> multimap = atomix().<String, String>atomicMultimapBuilder(\"testThreeMap\").withProtocol(protocol()).build();\r\n    all.forEach(key -> all.forEach(value -> {\r\n        assertTrue(multimap.put(key, value));\r\n        assertFalse(multimap.put(key, value));\r\n    }));\r\n    all.forEach(key -> all.forEach(value -> {\r\n        assertTrue(multimap.remove(key, value));\r\n        assertFalse(multimap.remove(key, value));\r\n    }));\r\n    assertTrue(multimap.isEmpty());\r\n    all.forEach(key -> {\r\n        assertTrue(multimap.putAll(key, Lists.newArrayList(all.subList(0, 2))));\r\n        assertFalse(multimap.putAll(key, Lists.newArrayList(all.subList(0, 2))));\r\n        assertTrue(multimap.putAll(key, Lists.newArrayList(all.subList(2, 4))));\r\n        assertFalse(multimap.putAll(key, Lists.newArrayList(all.subList(2, 4))));\r\n    });\r\n    multimap.clear();\r\n    all.forEach(key -> assertTrue(multimap.putAll(key, all)));\r\n    assertEquals(16, multimap.size());\r\n    all.forEach(key -> {\r\n        assertTrue(stringArrayCollectionIsEqual(all, multimap.removeAll(key).value()));\r\n        assertNotEquals(all, multimap.removeAll(key));\r\n    });\r\n    assertTrue(multimap.isEmpty());\r\n    all.forEach(key -> assertTrue(multimap.putAll(key, all)));\r\n    assertEquals(16, multimap.size());\r\n    all.forEach(key -> {\r\n        assertTrue(stringArrayCollectionIsEqual(all, multimap.replaceValues(key, all).value()));\r\n        assertTrue(stringArrayCollectionIsEqual(all, multimap.replaceValues(key, Lists.newArrayList()).value()));\r\n        assertTrue(multimap.replaceValues(key, all).value().isEmpty());\r\n    });\r\n    assertEquals(16, multimap.size());\r\n    all.forEach(key -> {\r\n        assertTrue(multimap.remove(key, one));\r\n        assertTrue(stringArrayCollectionIsEqual(Lists.newArrayList(two, three, four), multimap.replaceValues(key, Lists.newArrayList()).value()));\r\n        assertTrue(multimap.replaceValues(key, all).value().isEmpty());\r\n    });\r\n}"
}, {
	"Path": "io.atomix.rest.impl.EventLog.open",
	"Comment": "returns a boolean indicating whether the event consumer needs to be registered.",
	"Method": "boolean open(){\r\n    return open.compareAndSet(false, true);\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.SimpleCommandBus.doDispatch",
	"Comment": "performs the actual dispatching logic. the dispatch interceptors must have been invoked at this point.",
	"Method": "void doDispatch(CommandMessage<C> command,CommandCallback<? super C, ? super R> callback){\r\n    MessageMonitor.MonitorCallback monitorCallback = messageMonitor.onMessageIngested(command);\r\n    Optional<MessageHandler<? super CommandMessage<?>>> optionalHandler = findCommandHandlerFor(command);\r\n    if (optionalHandler.isPresent()) {\r\n        handle(command, optionalHandler.get(), new MonitorAwareCallback(callback, monitorCallback));\r\n    } else {\r\n        NoHandlerForCommandException exception = new NoHandlerForCommandException(format(\"No handler was subscribed to command [%s]\", command.getCommandName()));\r\n        monitorCallback.reportFailure(exception);\r\n        callback.onResult(command, asCommandResultMessage(exception));\r\n    }\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.tokenstore.jdbc.TokenSchema.segmentColumn",
	"Comment": "returns the name of the column containing the segment of the processor to which the token belongs.",
	"Method": "String segmentColumn(){\r\n    return segmentColumn;\r\n}"
}, {
	"Path": "brave.propagation.PropagationFactoryTest.requires128BitTraceId_defaultsToFalse",
	"Comment": "64 bit trace ids are not consistently mandatory across propagation, yet.",
	"Method": "void requires128BitTraceId_defaultsToFalse(){\r\n    assertThat(factory.requires128BitTraceId()).isFalse();\r\n}"
}, {
	"Path": "io.atomix.core.Atomix.config",
	"Comment": "returns a new atomix configuration from the given resources.",
	"Method": "AtomixConfig config(AtomixConfig config,ClassLoader classLoader,AtomixConfig config,AtomixRegistry registry,AtomixConfig config,String files,AtomixConfig config,ClassLoader classLoader,String files,AtomixConfig config,AtomixRegistry registry,String files,AtomixConfig config,File configFiles,AtomixConfig config,List<File> files,AtomixConfig config,ClassLoader classLoader,List<File> files,AtomixConfig config,AtomixRegistry registry,List<File> files,AtomixConfig config,ClassLoader classLoader,List<File> files,AtomixRegistry registry){\r\n    ConfigMapper mapper = new PolymorphicConfigMapper(classLoader, registry, new PolymorphicTypeMapper(\"type\", PartitionGroupConfig.class, PartitionGroup.Type.class), new PolymorphicTypeMapper(\"type\", PrimitiveConfig.class, PrimitiveType.class), new PolymorphicTypeMapper(null, PrimitiveConfig.class, PrimitiveType.class), new PolymorphicTypeMapper(\"type\", PrimitiveProtocolConfig.class, PrimitiveProtocol.Type.class), new PolymorphicTypeMapper(\"type\", ProfileConfig.class, Profile.Type.class), new PolymorphicTypeMapper(\"type\", NodeDiscoveryConfig.class, NodeDiscoveryProvider.Type.class), new PolymorphicTypeMapper(\"type\", GroupMembershipProtocolConfig.class, GroupMembershipProtocol.Type.class));\r\n    return mapper.loadFiles(AtomixConfig.class, files, Lists.newArrayList(RESOURCES));\r\n}"
}, {
	"Path": "io.atomix.core.tree.AtomicDocumentTreeConfig.isRegistrationRequired",
	"Comment": "returns whether registration is required for serializable types.",
	"Method": "boolean isRegistrationRequired(){\r\n    return registrationRequired;\r\n}"
}, {
	"Path": "io.atomix.cluster.AtomixCluster.config",
	"Comment": "returns a new atomix configuration from the given resources.",
	"Method": "ClusterConfig config(String[] resources,ClassLoader classLoader){\r\n    return new ConfigMapper(classLoader).loadResources(ClusterConfig.class, resources);\r\n}"
}, {
	"Path": "org.axonframework.messaging.annotation.UnsupportedHandlerException.getViolatingMethod",
	"Comment": "a reference to the method that violated the event handler rules.",
	"Method": "Member getViolatingMethod(){\r\n    return violatingMethod;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.RaftTest.testManySessionsManyEvents",
	"Comment": "tests submitting a linearizable event that publishes to all sessions.",
	"Method": "void testManySessionsManyEvents(int nodes){\r\n    createServers(nodes);\r\n    RaftClient client = createClient();\r\n    TestPrimitive primitive = createPrimitive(client);\r\n    primitive.onEvent(event -> {\r\n        threadAssertNotNull(event);\r\n        resume();\r\n    });\r\n    createPrimitive(createClient()).onEvent(event -> {\r\n        threadAssertNotNull(event);\r\n        resume();\r\n    });\r\n    createPrimitive(createClient()).onEvent(event -> {\r\n        threadAssertNotNull(event);\r\n        resume();\r\n    });\r\n    for (int i = 0; i < 10; i++) {\r\n        primitive.sendEvent(false).thenRun(this::resume);\r\n        await(10000, 4);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.protocols.gossip.set.SetElement.isTombstone",
	"Comment": "returns a boolean indicating whether this element is a tombstone.",
	"Method": "boolean isTombstone(){\r\n    return tombstone;\r\n}"
}, {
	"Path": "org.axonframework.serialization.json.JacksonSerializer.getObjectMapper",
	"Comment": "returns the objectmapper used by this serializer, allowing for configuration of the serialization settings.",
	"Method": "ObjectMapper getObjectMapper(){\r\n    return objectMapper;\r\n}"
}, {
	"Path": "brave.internal.PropagationFields.tryToClaim",
	"Comment": "fields are extracted before a context is created. we need to lazy set the context",
	"Method": "boolean tryToClaim(long traceId,long spanId){\r\n    synchronized (this) {\r\n        if (this.traceId == 0L) {\r\n            this.traceId = traceId;\r\n            this.spanId = spanId;\r\n            return true;\r\n        }\r\n        return this.traceId == traceId && this.spanId == spanId;\r\n    }\r\n}"
}, {
	"Path": "io.atomix.protocols.gossip.map.AntiEntropyMapDelegate.requestBootstrapFromPeers",
	"Comment": "requests all updates from each peer in the provided list of peers.the returned future will be completed once at least one peer bootstraps this map or bootstrap requests to all peersfail.",
	"Method": "CompletableFuture<Void> requestBootstrapFromPeers(List<MemberId> peers){\r\n    if (peers.isEmpty()) {\r\n        return CompletableFuture.completedFuture(null);\r\n    }\r\n    CompletableFuture<Void> future = new CompletableFuture();\r\n    final int totalPeers = peers.size();\r\n    AtomicBoolean successful = new AtomicBoolean();\r\n    AtomicInteger totalCount = new AtomicInteger();\r\n    AtomicReference<Throwable> lastError = new AtomicReference();\r\n    for (MemberId peer : peers) {\r\n        requestBootstrapFromPeer(peer).whenComplete((result, error) -> {\r\n            if (error == null) {\r\n                if (successful.compareAndSet(false, true)) {\r\n                    future.complete(null);\r\n                } else if (totalCount.incrementAndGet() == totalPeers) {\r\n                    Throwable e = lastError.get();\r\n                    if (e != null) {\r\n                        future.completeExceptionally(e);\r\n                    }\r\n                }\r\n            } else {\r\n                if (!successful.get() && totalCount.incrementAndGet() == totalPeers) {\r\n                    future.completeExceptionally(error);\r\n                } else {\r\n                    lastError.set(error);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return future;\r\n}"
}, {
	"Path": "io.atomix.core.lock.AtomicLockTest.testBlockingUnlock",
	"Comment": "tests unlocking a lock with a blocking call in the event thread.",
	"Method": "void testBlockingUnlock(){\r\n    AtomicLock lock1 = atomix().atomicLockBuilder(\"test-blocking-unlock\").withProtocol(protocol()).build();\r\n    AtomicLock lock2 = atomix().atomicLockBuilder(\"test-blocking-unlock\").withProtocol(protocol()).build();\r\n    lock1.async().lock().thenRun(() -> lock1.unlock());\r\n    lock2.lock();\r\n}"
}, {
	"Path": "io.atomix.protocols.log.DistributedLogProtocolBuilder.withMaxRetries",
	"Comment": "sets the maximum number of retries before an operation can be failed.",
	"Method": "DistributedLogProtocolBuilder withMaxRetries(int maxRetries){\r\n    config.setMaxRetries(maxRetries);\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.core.multimap.AtomicMultimapTest.stringArrayCollectionIsEqual",
	"Comment": "compares two collections of strings returns true if they contain the same strings, false otherwise.",
	"Method": "boolean stringArrayCollectionIsEqual(Collection<? extends String> s1,Collection<? extends String> s2){\r\n    if (s1 == null || s2 == null || s1.size() != s2.size()) {\r\n        return false;\r\n    }\r\n    for (String string1 : s1) {\r\n        boolean matched = false;\r\n        for (String string2 : s2) {\r\n            if (string1.equals(string2)) {\r\n                matched = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!matched) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.axonframework.spring.config.annotation.SpringContextParameterResolverFactoryBuilder.getBeanReference",
	"Comment": "create, if necessary, a bean definition for a parameterresolverfactory and returns the reference to bean for usein other bean definitions.",
	"Method": "RuntimeBeanReference getBeanReference(BeanDefinitionRegistry registry){\r\n    if (!registry.containsBeanDefinition(PARAMETER_RESOLVER_FACTORY_BEAN_NAME)) {\r\n        final ManagedList<BeanDefinition> factories = new ManagedList();\r\n        factories.add(BeanDefinitionBuilder.genericBeanDefinition(ClasspathParameterResolverFactoryBean.class).getBeanDefinition());\r\n        factories.add(BeanDefinitionBuilder.genericBeanDefinition(SpringBeanParameterResolverFactory.class).getBeanDefinition());\r\n        AbstractBeanDefinition def = BeanDefinitionBuilder.genericBeanDefinition(ApplicationContextLookupParameterResolverFactory.class).addConstructorArgValue(factories).getBeanDefinition();\r\n        def.setPrimary(true);\r\n        registry.registerBeanDefinition(PARAMETER_RESOLVER_FACTORY_BEAN_NAME, def);\r\n    }\r\n    return new RuntimeBeanReference(PARAMETER_RESOLVER_FACTORY_BEAN_NAME);\r\n}"
}, {
	"Path": "io.atomix.core.tree.AtomicDocumentTreeBuilder.withRegistrationRequired",
	"Comment": "sets whether registration is required for serializable types.",
	"Method": "AtomicDocumentTreeBuilder<V> withRegistrationRequired(AtomicDocumentTreeBuilder<V> withRegistrationRequired,boolean registrationRequired){\r\n    config.setRegistrationRequired(registrationRequired);\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.core.tree.DocumentPath.leastCommonAncestor",
	"Comment": "returns the path that points to the least common ancestor of the specifiedcollection of paths.",
	"Method": "DocumentPath leastCommonAncestor(Collection<DocumentPath> paths){\r\n    if (paths.isEmpty()) {\r\n        return null;\r\n    }\r\n    return DocumentPath.from(StringUtils.getCommonPrefix(paths.stream().map(DocumentPath::toString).toArray(String[]::new)));\r\n}"
}, {
	"Path": "io.atomix.utils.Generics.getGenericClassType",
	"Comment": "returns the generic type at the given position for the given class.",
	"Method": "Type getGenericClassType(Object instance,Class<?> clazz,int position){\r\n    Class<?> type = instance.getClass();\r\n    while (type != Object.class) {\r\n        if (type.getGenericSuperclass() instanceof ParameterizedType) {\r\n            ParameterizedType genericSuperclass = (ParameterizedType) type.getGenericSuperclass();\r\n            if (genericSuperclass.getRawType() == clazz) {\r\n                return genericSuperclass.getActualTypeArguments()[position];\r\n            } else {\r\n                type = type.getSuperclass();\r\n            }\r\n        } else {\r\n            type = type.getSuperclass();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.axonframework.messaging.annotation.MultiHandlerDefinition.getHandlerEnhancerDefinition",
	"Comment": "returns handler enhancer definition used to wrap handlers.",
	"Method": "HandlerEnhancerDefinition getHandlerEnhancerDefinition(){\r\n    return handlerEnhancerDefinition;\r\n}"
}, {
	"Path": "org.axonframework.modelling.command.AggregateNotFoundException.getAggregateIdentifier",
	"Comment": "returns the identifier of the aggregate that could not be found.",
	"Method": "Object getAggregateIdentifier(){\r\n    return aggregateIdentifier;\r\n}"
}, {
	"Path": "org.axonframework.monitoring.MultiMessageMonitor.onMessageIngested",
	"Comment": "calls the message monitors with the given message and returns a callbackthat will trigger all the message monitor callbacks",
	"Method": "MonitorCallback onMessageIngested(T message){\r\n    final List<MonitorCallback> monitorCallbacks = messageMonitors.stream().map(messageMonitor -> messageMonitor.onMessageIngested(message)).collect(Collectors.toList());\r\n    return new MonitorCallback() {\r\n        @Override\r\n        public void reportSuccess() {\r\n            monitorCallbacks.forEach(MonitorCallback::reportSuccess);\r\n        }\r\n        @Override\r\n        public void reportFailure(Throwable cause) {\r\n            monitorCallbacks.forEach(resultCallback -> resultCallback.reportFailure(cause));\r\n        }\r\n        @Override\r\n        public void reportIgnored() {\r\n            monitorCallbacks.forEach(MonitorCallback::reportIgnored);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.axonframework.monitoring.MultiMessageMonitor.onMessageIngested",
	"Comment": "calls the message monitors with the given message and returns a callbackthat will trigger all the message monitor callbacks",
	"Method": "MonitorCallback onMessageIngested(T message){\r\n    monitorCallbacks.forEach(MonitorCallback::reportSuccess);\r\n}"
}, {
	"Path": "org.axonframework.monitoring.MultiMessageMonitor.onMessageIngested",
	"Comment": "calls the message monitors with the given message and returns a callbackthat will trigger all the message monitor callbacks",
	"Method": "MonitorCallback onMessageIngested(T message){\r\n    monitorCallbacks.forEach(resultCallback -> resultCallback.reportFailure(cause));\r\n}"
}, {
	"Path": "org.axonframework.monitoring.MultiMessageMonitor.onMessageIngested",
	"Comment": "calls the message monitors with the given message and returns a callbackthat will trigger all the message monitor callbacks",
	"Method": "MonitorCallback onMessageIngested(T message){\r\n    monitorCallbacks.forEach(MonitorCallback::reportIgnored);\r\n}"
}, {
	"Path": "org.axonframework.modelling.saga.AnnotatedSaga.doAssociateWith",
	"Comment": "registers a associationvalue with the given saga. when the saga is committed, it can be found using theregistered property.",
	"Method": "void doAssociateWith(AssociationValue property){\r\n    associationValues.add(property);\r\n}"
}, {
	"Path": "io.atomix.core.profile.Profile.dataGrid",
	"Comment": "creates a new data grid profile with the given number of partitions.",
	"Method": "Profile dataGrid(Profile dataGrid,int numPartitions){\r\n    return new DataGridProfile(numPartitions);\r\n}"
}, {
	"Path": "io.atomix.storage.buffer.FileBytes.allocate",
	"Comment": "allocates a randomaccessfile buffer.if the underlying randomaccessfile is empty, the randomaccessfile count will expand dynamically as bytes are written to the randomaccessfile.",
	"Method": "FileBytes allocate(File file,FileBytes allocate,File file,int size,FileBytes allocate,File file,String mode,int size){\r\n    return new FileBytes(file, mode, (int) Math.min(Memory.Util.toPow2(size), Integer.MAX_VALUE));\r\n}"
}, {
	"Path": "org.axonframework.spring.config.annotation.SpringHandlerEnhancerDefinitionBean.setAdditionalHandlers",
	"Comment": "defines any additional handler enhancer definitions that should be used. by default, thehandlerenhancerdefinitions are found on the classpath, as well as a springbeanparameterresolverfactory areregistered.",
	"Method": "void setAdditionalHandlers(List<HandlerEnhancerDefinition> additionalFactories){\r\n    this.enhancers.addAll(additionalFactories);\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.DispatchMessage.getSerializedPayload",
	"Comment": "returns the serialized payload of the command carried by this instance.",
	"Method": "byte[] getSerializedPayload(){\r\n    return serializedPayload;\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.ConsistentHash.version",
	"Comment": "returns the version of this consistent hash instance. the version is increased by one each time a change is made.",
	"Method": "int version(){\r\n    return modCount;\r\n}"
}, {
	"Path": "io.atomix.utils.concurrent.Retries.randomDelay",
	"Comment": "suspends the current thread for a random number of millis between 0 andthe indicated limit.",
	"Method": "void randomDelay(int ms){\r\n    try {\r\n        Thread.sleep(ThreadLocalRandom.current().nextInt(ms));\r\n    } catch (InterruptedException e) {\r\n        throw new RuntimeException(\"Interrupted\", e);\r\n    }\r\n}"
}, {
	"Path": "brave.internal.recorder.PendingSpan.clock",
	"Comment": "returns a clock that ensures starttimestamp consistency across the trace",
	"Method": "Clock clock(){\r\n    return clock;\r\n}"
}, {
	"Path": "io.atomix.primitive.proxy.ProxyClient.acceptBy",
	"Comment": "submits an empty operation to the owning partition for the given key.",
	"Method": "CompletableFuture<Void> acceptBy(String key,Consumer<S> operation){\r\n    return getPartition(key).accept(operation);\r\n}"
}, {
	"Path": "brave.handler.MutableSpanTest.forEachTag_consumer_usageExplained",
	"Comment": "this is a compile test to show how the signature is intended to be used",
	"Method": "void forEachTag_consumer_usageExplained(){\r\n    MutableSpan span = new MutableSpan();\r\n    span.tag(\"a\", \"1\");\r\n    span.tag(\"b\", \"2\");\r\n    span.tag(\"c\", \"3\");\r\n    class Tag {\r\n        final String name, value;\r\n        Tag(String name, String value) {\r\n            this.name = name;\r\n            this.value = value;\r\n        }\r\n        @Override\r\n        public boolean equals(Object o) {\r\n            if (!(o instanceof Tag))\r\n                return false;\r\n            Tag that = (Tag) o;\r\n            return name.equals(that.name) && value.equals(that.value);\r\n        }\r\n    }\r\n    List<Tag> listTarget = new ArrayList();\r\n    span.forEachTag((target, key, value) -> target.add(new Tag(key, value)), listTarget);\r\n    assertThat(listTarget).containsExactly(new Tag(\"a\", \"1\"), new Tag(\"b\", \"2\"), new Tag(\"c\", \"3\"));\r\n}"
}, {
	"Path": "brave.handler.MutableSpanTest.forEachTag_consumer_usageExplained",
	"Comment": "this is a compile test to show how the signature is intended to be used",
	"Method": "void forEachTag_consumer_usageExplained(){\r\n    if (!(o instanceof Tag))\r\n        return false;\r\n    Tag that = (Tag) o;\r\n    return name.equals(that.name) && value.equals(that.value);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.impl.RaftServiceManager.isRunningOutOfDiskSpace",
	"Comment": "returns a boolean indicating whether the node is running out of disk space.",
	"Method": "boolean isRunningOutOfDiskSpace(){\r\n    return raft.getStorage().statistics().getUsableSpace() < raft.getStorage().maxLogSegmentSize() * SEGMENT_BUFFER_FACTOR || raft.getStorage().statistics().getUsableSpace() / (double) raft.getStorage().statistics().getTotalSpace() < raft.getStorage().freeDiskBuffer();\r\n}"
}, {
	"Path": "io.atomix.primitive.event.Events.findMethods",
	"Comment": "recursively finds events defined by the given type and its implemented interfaces.",
	"Method": "Map<Method, EventType> findMethods(Class<?> type){\r\n    Map<Method, EventType> events = new HashMap();\r\n    for (Method method : type.getDeclaredMethods()) {\r\n        Event event = method.getAnnotation(Event.class);\r\n        if (event != null) {\r\n            String name = event.value().equals(\"\") ? method.getName() : event.value();\r\n            events.put(method, EventType.from(name));\r\n        }\r\n    }\r\n    for (Class<?> iface : type.getInterfaces()) {\r\n        events.putAll(findMethods(iface));\r\n    }\r\n    return events;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.RaftTest.testSequenceSequentialOperations",
	"Comment": "tests that operations are properly sequenced on the client.",
	"Method": "void testSequenceSequentialOperations(){\r\n    testSequenceOperations(5, ReadConsistency.SEQUENTIAL);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.storage.RaftStorage.freeDiskBuffer",
	"Comment": "returns the percentage of disk space that must be available before log compaction is forced.",
	"Method": "double freeDiskBuffer(){\r\n    return freeDiskBuffer;\r\n}"
}, {
	"Path": "io.atomix.cluster.NodeId.from",
	"Comment": "creates a new cluster node identifier from the specified string.",
	"Method": "NodeId from(String id){\r\n    return new NodeId(id);\r\n}"
}, {
	"Path": "org.axonframework.config.Configurer.start",
	"Comment": "builds the configuration and starts it immediately. it is not recommended to change any configuration on thisconfigurer once this method is called.",
	"Method": "Configuration start(){\r\n    Configuration configuration = buildConfiguration();\r\n    configuration.start();\r\n    return configuration;\r\n}"
}, {
	"Path": "brave.grpc.ITTracingClientInterceptor.usesParentFromInvocationTime",
	"Comment": "this tests that the parent is determined at the time the request was made, not when the requestwas executed.",
	"Method": "void usesParentFromInvocationTime(){\r\n    server.enqueueDelay(TimeUnit.SECONDS.toMillis(1));\r\n    GreeterGrpc.GreeterFutureStub futureStub = GreeterGrpc.newFutureStub(client);\r\n    ScopedSpan parent = tracer.startScopedSpan(\"test\");\r\n    try {\r\n        futureStub.sayHello(HELLO_REQUEST);\r\n        futureStub.sayHello(HELLO_REQUEST);\r\n    } finally {\r\n        parent.finish();\r\n    }\r\n    ScopedSpan otherSpan = tracer.startScopedSpan(\"test2\");\r\n    try {\r\n        for (int i = 0; i < 2; i++) {\r\n            TraceContext context = server.takeRequest().context();\r\n            assertThat(context.traceId()).isEqualTo(parent.context().traceId());\r\n            assertThat(context.parentId()).isEqualTo(parent.context().spanId());\r\n        }\r\n    } finally {\r\n        otherSpan.finish();\r\n    }\r\n    assertThat(Arrays.asList(takeSpan(), takeSpan(), takeSpan(), takeSpan())).extracting(Span::kind).containsOnly(null, Span.Kind.CLIENT);\r\n}"
}, {
	"Path": "org.axonframework.spring.eventsourcing.SpringAggregateSnapshotterFactoryBean.setHandlerDefinition",
	"Comment": "sets handler definition to be able to create concrete handlers.",
	"Method": "void setHandlerDefinition(HandlerDefinition handlerDefinition){\r\n    this.handlerDefinition = handlerDefinition;\r\n}"
}, {
	"Path": "org.axonframework.modelling.saga.SagaMethodMessageHandlingMember.isEndingHandler",
	"Comment": "indicates whether this handler is one that ends the saga lifecycle",
	"Method": "boolean isEndingHandler(){\r\n    return endingHandler;\r\n}"
}, {
	"Path": "org.axonframework.test.aggregate.StubAggregateLifecycle.close",
	"Comment": "closes this lifecycle instance, restoring to the situation prior to this lifecycle being started. if anylifecycle instance was active before this one started, it will be reactivated.",
	"Method": "void close(){\r\n    if (registration != null) {\r\n        registration.run();\r\n    }\r\n    registration = null;\r\n}"
}, {
	"Path": "io.atomix.cluster.AtomixClusterBuilder.setBroadcastInterval",
	"Comment": "sets the reachability broadcast interval.the broadcast interval is the interval at which heartbeats are sent to peers in the cluster.",
	"Method": "AtomixClusterBuilder setBroadcastInterval(Duration interval){\r\n    GroupMembershipProtocolConfig protocolConfig = config.getProtocolConfig();\r\n    if (protocolConfig instanceof HeartbeatMembershipProtocolConfig) {\r\n        ((HeartbeatMembershipProtocolConfig) protocolConfig).setHeartbeatInterval(interval);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.axonframework.spring.eventsourcing.SpringAggregateSnapshotterFactoryBean.setTransactionManager",
	"Comment": "sets the transaction manager to manager underlying transaction with. if none is provided, an attempt is made toauto detect is from the application context. if a single transaction manager is found, it is used to managetransactions. of none or more than one is found, they are ignored.",
	"Method": "void setTransactionManager(PlatformTransactionManager transactionManager){\r\n    this.transactionManager = transactionManager;\r\n}"
}, {
	"Path": "io.atomix.primitive.operation.Operations.getMethodMap",
	"Comment": "returns the collection of operations provided by the given service interface.",
	"Method": "Map<Method, OperationId> getMethodMap(Class<?> serviceInterface){\r\n    if (!serviceInterface.isInterface()) {\r\n        Map<Method, OperationId> operations = new HashMap();\r\n        for (Class<?> iface : serviceInterface.getInterfaces()) {\r\n            operations.putAll(findMethods(iface));\r\n        }\r\n        return operations;\r\n    }\r\n    return findMethods(serviceInterface);\r\n}"
}, {
	"Path": "org.assertj.core.api.SoftAssertionsTest.map_soft_assertions_should_report_errors_on_final_methods_and_methods_that_switch_the_object_under_test",
	"Comment": "the test would fail if any method was not proxyable as the assertion error would not be softly caught",
	"Method": "void map_soft_assertions_should_report_errors_on_final_methods_and_methods_that_switch_the_object_under_test(){\r\n    Map<String, String> map = mapOf(entry(\"a\", \"1\"), entry(\"b\", \"2\"), entry(\"c\", \"3\"));\r\n    softly.assertThat(map).contains(entry(\"abc\", \"ABC\"), entry(\"def\", \"DEF\")).isEmpty();\r\n    softly.assertThat(map).containsAnyOf(entry(\"gh\", \"GH\"), entry(\"ij\", \"IJ\"));\r\n    softly.assertThat(map).containsExactly(entry(\"kl\", \"KL\"), entry(\"mn\", \"MN\"));\r\n    softly.assertThat(map).containsKeys(\"K1\", \"K2\");\r\n    softly.assertThat(map).containsOnly(entry(\"op\", \"OP\"), entry(\"qr\", \"QR\"));\r\n    softly.assertThat(map).containsOnlyKeys(\"K3\", \"K4\");\r\n    softly.assertThat(map).containsValues(\"V1\", \"V2\");\r\n    softly.assertThat(map).doesNotContain(entry(\"a\", \"1\"), entry(\"abc\", \"ABC\"));\r\n    softly.assertThat(map).doesNotContainKeys(\"a\", \"b\");\r\n    softly.assertThat(map).as(\"extracting(\\\"a\\\", \\\"b\\\")\").overridingErrorMessage(\"error message\").extracting(\"a\", \"b\").contains(\"456\");\r\n    softly.assertThat(iterableMap).as(\"flatExtracting(\\\"name\\\", \\\"job\\\", \\\"city\\\", \\\"rank\\\")\").overridingErrorMessage(\"error message\").flatExtracting(\"name\", \"job\", \"city\", \"rank\").contains(\"Unexpected\", \"Builder\", \"Dover\", \"Boston\", \"Paris\", 1, 2, 3);\r\n    softly.assertThat(map).as(\"size()\").overridingErrorMessage(\"error message\").size().isGreaterThan(1000);\r\n    List<Throwable> errors = softly.errorsCollected();\r\n    assertThat(errors).hasSize(13);\r\n    assertThat(errors.get(0)).hasMessageContaining(\"MapEntry[key=\\\"abc\\\", value=\\\"ABC\\\"]\");\r\n    assertThat(errors.get(1)).hasMessageContaining(\"empty\");\r\n    assertThat(errors.get(2)).hasMessageContaining(\"gh\").hasMessageContaining(\"IJ\");\r\n    assertThat(errors.get(3)).hasMessageContaining(\"\\\"a\\\"=\\\"1\\\"\");\r\n    assertThat(errors.get(4)).hasMessageContaining(\"K2\");\r\n    assertThat(errors.get(5)).hasMessageContaining(\"OP\");\r\n    assertThat(errors.get(6)).hasMessageContaining(\"K4\");\r\n    assertThat(errors.get(7)).hasMessageContaining(\"V2\");\r\n    assertThat(errors.get(8)).hasMessageContaining(\"ABC\");\r\n    assertThat(errors.get(9)).hasMessageContaining(\"b\");\r\n    assertThat(errors.get(10)).hasMessage(\"[extracting(\\\"a\\\", \\\"b\\\")] error message\");\r\n    assertThat(errors.get(11)).hasMessage(\"[flatExtracting(\\\"name\\\", \\\"job\\\", \\\"city\\\", \\\"rank\\\")] error message\");\r\n    assertThat(errors.get(12)).hasMessage(\"[size()] error message\");\r\n}"
}, {
	"Path": "org.axonframework.config.DefaultConfigurer.defaultParameterResolverFactory",
	"Comment": "provides the default parameterresolverfactory. subclasses may override this method to provide their own default.",
	"Method": "ParameterResolverFactory defaultParameterResolverFactory(Configuration config){\r\n    return MultiParameterResolverFactory.ordered(ClasspathParameterResolverFactory.forClass(getClass()), new ConfigurationParameterResolverFactory(config));\r\n}"
}, {
	"Path": "org.axonframework.config.EventProcessingConfigurer.registerSaga",
	"Comment": "registers a saga, allowing specific configuration to use for this saga type.",
	"Method": "EventProcessingConfigurer registerSaga(Class<T> sagaType,EventProcessingConfigurer registerSaga,Class<T> sagaType,Consumer<SagaConfigurer<T>> sagaConfigurer){\r\n    return registerSaga(sagaType, c -> {\r\n    });\r\n}"
}, {
	"Path": "io.atomix.cluster.messaging.MessagingService.sendAsync",
	"Comment": "sends a message asynchronously to the specified communication address.the message is specified using the type and payload.",
	"Method": "CompletableFuture<Void> sendAsync(Address address,String type,byte[] payload,CompletableFuture<Void> sendAsync,Address address,String type,byte[] payload,boolean keepAlive){\r\n    return sendAsync(address, type, payload, true);\r\n}"
}, {
	"Path": "io.atomix.core.AtomixConfig.isCompatibleSerialization",
	"Comment": "returns whether compatible serialization is enabled for user types.",
	"Method": "boolean isCompatibleSerialization(){\r\n    return compatibleSerialization;\r\n}"
}, {
	"Path": "io.atomix.core.tree.AsyncAtomicDocumentTree.addListener",
	"Comment": "registers a listener to be notified when the tree is modified.",
	"Method": "CompletableFuture<Void> addListener(DocumentPath path,DocumentTreeEventListener<V> listener,CompletableFuture<Void> addListener,DocumentPath path,DocumentTreeEventListener<V> listener,Executor executor,CompletableFuture<Void> addListener,DocumentTreeEventListener<V> listener,CompletableFuture<Void> addListener,DocumentTreeEventListener<V> listener,Executor executor){\r\n    return addListener(root(), listener, executor);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.storage.snapshot.Snapshot.persist",
	"Comment": "persists the snapshot to disk if necessary.if the snapshot store is backed by disk, the snapshot will be persisted.",
	"Method": "Snapshot persist(){\r\n    return this;\r\n}"
}, {
	"Path": "org.awaitility.core.SameThreadExecutorService.startTask",
	"Comment": "checks if the executor has been shut down and increments the runningtask count.",
	"Method": "void startTask(){\r\n    lock.lock();\r\n    try {\r\n        if (isShutdown()) {\r\n            throw new RejectedExecutionException(\"Executor already shutdown\");\r\n        }\r\n        runningTasks++;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.axonframework.serialization.AbstractXStreamSerializer.getConverter",
	"Comment": "returns the converter used by this serialized. the converter factory allows registration ofcontenttypeconverters needed by the upcasters.",
	"Method": "Converter getConverter(){\r\n    return converter;\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.tokenstore.AbstractTokenEntry.timestampAsString",
	"Comment": "returns the storage timestamp of this token entry as a string.",
	"Method": "String timestampAsString(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "io.atomix.core.value.ValueConfig.setRegistrationRequired",
	"Comment": "sets whether registration is required for serializable types.",
	"Method": "C setRegistrationRequired(boolean registrationRequired){\r\n    this.registrationRequired = registrationRequired;\r\n    return (C) this;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.roles.LeaderRole.initializing",
	"Comment": "returns a boolean value indicating whether the leader is still being initialized.",
	"Method": "boolean initializing(){\r\n    return appender.getIndex() == 0 || raft.getCommitIndex() < appender.getIndex();\r\n}"
}, {
	"Path": "org.awaitility.core.ConditionFactory.ignoreNoExceptions",
	"Comment": "instruct awaitility to not ignore any exceptions that occur during evaluation.this is only useful if awaitility is configured to ignore exceptions by default but you want tohave a different behavior for a single test case.",
	"Method": "ConditionFactory ignoreNoExceptions(){\r\n    return ignoreExceptionsMatching(new Predicate<Throwable>() {\r\n        public boolean matches(Throwable e) {\r\n            return false;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.awaitility.core.ConditionFactory.ignoreNoExceptions",
	"Comment": "instruct awaitility to not ignore any exceptions that occur during evaluation.this is only useful if awaitility is configured to ignore exceptions by default but you want tohave a different behavior for a single test case.",
	"Method": "ConditionFactory ignoreNoExceptions(){\r\n    return false;\r\n}"
}, {
	"Path": "org.axonframework.test.eventscheduler.StubEventScheduler.getScheduledItems",
	"Comment": "returns a view of all the scheduled events at the time this method is called.",
	"Method": "List<ScheduledItem> getScheduledItems(){\r\n    return new ArrayList(scheduledEvents);\r\n}"
}, {
	"Path": "org.axonframework.test.utils.RecordingCommandBus.setCallbackBehavior",
	"Comment": "sets the instance that defines the behavior of the command bus when a command is dispatched with a callback.",
	"Method": "void setCallbackBehavior(CallbackBehavior callbackBehavior){\r\n    this.callbackBehavior = callbackBehavior;\r\n}"
}, {
	"Path": "org.axonframework.test.matchers.ListMatcher.failedMatcherMessage",
	"Comment": "the message to append behind a failing matcher. defaults to failed!.",
	"Method": "String failedMatcherMessage(){\r\n    return \"FAILED!\";\r\n}"
}, {
	"Path": "io.atomix.agent.AtomixAgent.main",
	"Comment": "runs a standalone atomix agent from the given command line arguments.",
	"Method": "void main(String[] args){\r\n    final List<String> unknown = new ArrayList();\r\n    final Namespace namespace = parseArgs(args, unknown);\r\n    final Namespace extraArgs = parseUnknown(unknown);\r\n    extraArgs.getAttrs().forEach((key, value) -> System.setProperty(key, value.toString()));\r\n    final Logger logger = createLogger(namespace);\r\n    final Atomix atomix = buildAtomix(namespace);\r\n    atomix.start().join();\r\n    logger.info(\"Atomix listening at {}\", atomix.getMembershipService().getLocalMember().address());\r\n    final ManagedRestService rest = buildRestService(atomix, namespace);\r\n    rest.start().join();\r\n    logger.warn(\"The Atomix HTTP API is BETA and is intended for development and debugging purposes only!\");\r\n    logger.info(\"HTTP server listening at {}\", rest.address());\r\n    synchronized (Atomix.class) {\r\n        while (atomix.isRunning()) {\r\n            Atomix.class.wait();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.impl.RaftServiceManager.isRunningOutOfMemory",
	"Comment": "returns a boolean indicating whether the node is running out of memory.",
	"Method": "boolean isRunningOutOfMemory(){\r\n    StorageLevel level = raft.getStorage().storageLevel();\r\n    if (level == StorageLevel.MEMORY || level == StorageLevel.MAPPED) {\r\n        long freeMemory = raft.getStorage().statistics().getFreeMemory();\r\n        long totalMemory = raft.getStorage().statistics().getTotalMemory();\r\n        if (freeMemory > 0 && totalMemory > 0) {\r\n            return freeMemory / (double) totalMemory < raft.getStorage().freeMemoryBuffer();\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "brave.propagation.ExtraFieldPropagation.get",
	"Comment": "returns the value of the field with the specified key or null if not available",
	"Method": "String get(String name,String get,TraceContext context,String name){\r\n    return PropagationFields.get(context, lowercase(name), Extra.class);\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.GapAwareTrackingToken.getIndex",
	"Comment": "get the highest global sequence of events seen up until the point of this tracking token.",
	"Method": "long getIndex(){\r\n    return index;\r\n}"
}, {
	"Path": "org.axonframework.modelling.command.AbstractRepository.managedAggregates",
	"Comment": "returns the map of aggregates currently managed by this repository under the given unit of work. note that therepository keeps the managed aggregates in the root unit of work, to guarantee each unit of work works with thestate left by the parent unit of work.the returns map is mutable and reflects any changes made during processing.",
	"Method": "Map<String, A> managedAggregates(UnitOfWork<?> uow){\r\n    return uow.root().getOrComputeResource(aggregatesKey, s -> new HashMap());\r\n}"
}, {
	"Path": "io.atomix.core.impl.CoreTransactionService.recoverTransactions",
	"Comment": "recursively recovers transactions using the given iterator.",
	"Method": "void recoverTransactions(AsyncIterator<Map.Entry<TransactionId, Versioned<TransactionInfo>>> iterator,MemberId memberId){\r\n    iterator.next().thenAccept(entry -> {\r\n        if (entry.getValue().value().coordinator.equals(memberId)) {\r\n            recoverTransaction(entry.getKey(), entry.getValue().value());\r\n        }\r\n        recoverTransactions(iterator, memberId);\r\n    });\r\n}"
}, {
	"Path": "brave.CurrentSpanCustomizer.create",
	"Comment": "creates a span customizer that will affect the current span in scope if present",
	"Method": "CurrentSpanCustomizer create(Tracing tracing){\r\n    return new CurrentSpanCustomizer(tracing);\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.async.AsynchronousEventProcessingStrategy.newProcessingScheduler",
	"Comment": "creates a new scheduler instance that schedules tasks on the executor service for the managed eventlistener.",
	"Method": "EventProcessorTask newProcessingScheduler(EventProcessorTask.ShutdownCallback shutDownCallback){\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Initializing new processing scheduler.\");\r\n    }\r\n    return new EventProcessorTask(executor, shutDownCallback);\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.jdbc.EventSchema.payloadTypeColumn",
	"Comment": "get the name of the column containing the event payload type.",
	"Method": "String payloadTypeColumn(Builder payloadTypeColumn,String payloadTypeColumn){\r\n    return payloadTypeColumn;\r\n}"
}, {
	"Path": "org.axonframework.common.DateTimeUtils.formatInstant",
	"Comment": "formats the given instant to iso8601 format including at least 3 positions for milliseconds. this is to providefor a string representation of an instant that is sortable by a textual sorting algorithm.",
	"Method": "String formatInstant(TemporalAccessor instant){\r\n    return ISO_UTC_DATE_TIME.format(instant);\r\n}"
}, {
	"Path": "io.atomix.utils.concurrent.AbstractAccumulator.finalizeCurrentBatch",
	"Comment": "returns an immutable copy of the existing items and clear the list.",
	"Method": "List<T> finalizeCurrentBatch(){\r\n    List<T> finalizedList;\r\n    synchronized (items) {\r\n        finalizedList = ImmutableList.copyOf(items);\r\n        items.clear();\r\n        cancelTask(maxTask);\r\n        cancelTask(idleTask);\r\n    }\r\n    return finalizedList;\r\n}"
}, {
	"Path": "io.atomix.core.Atomix.getPartitionService",
	"Comment": "returns the partition service.the partition service is responsible for managing the lifecycle of primitive partitions and can provide informationabout active partition groups and partitions in the cluster.",
	"Method": "PartitionService getPartitionService(){\r\n    return partitions;\r\n}"
}, {
	"Path": "org.axonframework.modelling.command.AggregateLifecycle.markDeleted",
	"Comment": "marks this aggregate as deleted, instructing a repository to remove that aggregate at an appropriate time.note that different repository implementations may react differently to aggregates marked for deletion.typically, event sourced repositories will ignore the marking and expect deletion to be provided as part of eventinformation.",
	"Method": "void markDeleted(){\r\n    getInstance().doMarkDeleted();\r\n}"
}, {
	"Path": "io.atomix.core.transaction.ParticipantInfo.group",
	"Comment": "returns the partition group in which the participant is stored.",
	"Method": "String group(){\r\n    return group;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.impl.RaftServiceManager.takeSnapshots",
	"Comment": "takes a snapshot of all services and compacts logs if the server is not under high load or disk needs to be freed.",
	"Method": "CompletableFuture<Void> takeSnapshots(boolean rescheduleAfterCompletion,boolean force,CompletableFuture<Snapshot> takeSnapshots){\r\n    ComposableFuture<Snapshot> future = new ComposableFuture();\r\n    stateContext.execute(() -> {\r\n        try {\r\n            future.complete(snapshot());\r\n        } catch (Exception e) {\r\n            future.completeExceptionally(e);\r\n        }\r\n    });\r\n    return future;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.RaftSession.getService",
	"Comment": "returns the state machine context associated with the session.",
	"Method": "RaftServiceContext getService(){\r\n    return context;\r\n}"
}, {
	"Path": "org.awaitility.core.ConditionFactory.pollExecutorService",
	"Comment": "specify the executor service whose threads will be used to evaluate the poll condition in awaitility.note that the executor service must be shutdown manually!this is an advanced feature and it should only be used sparingly.",
	"Method": "ConditionFactory pollExecutorService(ExecutorService executorService){\r\n    if (executorService != null && executorService instanceof ScheduledExecutorService) {\r\n        throw new IllegalArgumentException(\"Poll executor service cannot be an instance of \" + ScheduledExecutorService.class.getName());\r\n    }\r\n    return new ConditionFactory(alias, timeoutConstraint, pollInterval, pollDelay, false, exceptionsIgnorer, conditionEvaluationListener, ExecutorLifecycle.withoutCleanup(executorService));\r\n}"
}, {
	"Path": "io.atomix.core.map.AsyncAtomicMap.addListener",
	"Comment": "registers the specified listener to be notified whenever the map is updated.",
	"Method": "CompletableFuture<Void> addListener(AtomicMapEventListener<K, V> listener,CompletableFuture<Void> addListener,AtomicMapEventListener<K, V> listener,Executor executor){\r\n    return addListener(listener, MoreExecutors.directExecutor());\r\n}"
}, {
	"Path": "org.awaitility.Awaitility.pollExecutorService",
	"Comment": "specify the executor service whose threads will be used to evaluate the poll condition in awaitility.note that the executor service must be shutdown manually!this is an advanced feature and it should only be used sparingly.",
	"Method": "void pollExecutorService(ExecutorService executorService){\r\n    defaultExecutorLifecycle = ExecutorLifecycle.withoutCleanup(executorService);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.storage.RaftStorage.freeMemoryBuffer",
	"Comment": "returns the percentage of memory space that must be available before log compaction is forced.",
	"Method": "double freeMemoryBuffer(){\r\n    return freeMemoryBuffer;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.cluster.impl.RaftMemberContext.canAppend",
	"Comment": "returns a boolean indicating whether an append request can be sent to the member.",
	"Method": "boolean canAppend(){\r\n    return appending == 0 || (appendSucceeded && appending < MAX_APPENDS && System.currentTimeMillis() - (timeStats.getMean() / MAX_APPENDS) >= appendTime);\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.TrackingEventProcessorConfiguration.getTokenClaimInterval",
	"Comment": "returns the time, in milliseconds, the processor should wait after a failed attempt to claim any segments forprocessing. generally, this means all segments are claimed.",
	"Method": "long getTokenClaimInterval(){\r\n    return tokenClaimInterval;\r\n}"
}, {
	"Path": "brave.internal.recorder.PendingSpansTest.toString_saysWhatReferentsAre",
	"Comment": "debugging should show what the spans are, as well any references pending clear.",
	"Method": "void toString_saysWhatReferentsAre(){\r\n    assertThat(pendingSpans.toString()).isEqualTo(\"PendingSpans[]\");\r\n    pendingSpans.getOrCreate(context, false);\r\n    assertThat(pendingSpans.toString()).isEqualTo(\"PendingSpans[WeakReference(\" + context + \")]\");\r\n    pretendGCHappened();\r\n    assertThat(pendingSpans.toString()).isEqualTo(\"PendingSpans[ClearedReference()]\");\r\n}"
}, {
	"Path": "io.crossbar.autobahn.websocket.types.WebSocketOptions.getMaxFramePayloadSize",
	"Comment": "get maxium frame payload size that will be acceptedwhen receiving.",
	"Method": "int getMaxFramePayloadSize(){\r\n    return mMaxFramePayloadSize;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.protocol.InstallRequest.complete",
	"Comment": "returns a boolean value indicating whether this is the last chunk of the snapshot.",
	"Method": "boolean complete(){\r\n    return complete;\r\n}"
}, {
	"Path": "org.axonframework.test.aggregate.Reporter.reportUnexpectedException",
	"Comment": "reports an error due to an unexpected exception. this means a return value was expected, but an exception wasthrown by the command handler",
	"Method": "void reportUnexpectedException(Throwable actualException,Description expectation){\r\n    StringBuilder sb = new StringBuilder(\"The command handler threw an unexpected exception\");\r\n    // NOSONAR\r\n    sb.append(NEWLINE).append(NEWLINE).append(\"Expected <\").append(expectation.toString()).append(\"> but got <exception of type [\").append(actualException.getClass().getSimpleName()).append(\"]>. Stack trace follows:\").append(NEWLINE);\r\n    writeStackTrace(actualException, sb);\r\n    sb.append(NEWLINE);\r\n    throw new AxonAssertionError(sb.toString());\r\n}"
}, {
	"Path": "brave.internal.PropagationFields.get",
	"Comment": "returns the value of the field with the specified key or null if not available",
	"Method": "String get(String name,String get,TraceContext context,String name,Class<? extends PropagationFields> type){\r\n    if (context == null)\r\n        throw new NullPointerException(\"context == null\");\r\n    if (name == null)\r\n        throw new NullPointerException(\"name == null\");\r\n    PropagationFields fields = context.findExtra(type);\r\n    return fields != null ? fields.get(name) : null;\r\n}"
}, {
	"Path": "org.axonframework.messaging.annotation.AnnotatedHandlerInspector.inspect",
	"Comment": "inspect another handler type and register the result to the inspector registry of this inspector. this is usedby axon to inspect child entities of an aggregate.",
	"Method": "AnnotatedHandlerInspector<C> inspect(Class<? extends C> entityType){\r\n    return AnnotatedHandlerInspector.createInspector(entityType, parameterResolverFactory, handlerDefinition, registry);\r\n}"
}, {
	"Path": "io.atomix.primitive.operation.Operations.findMethods",
	"Comment": "recursively finds operations defined by the given type and its implemented interfaces.",
	"Method": "Map<Method, OperationId> findMethods(Class<?> type){\r\n    Map<Method, OperationId> operations = new HashMap();\r\n    for (Method method : type.getDeclaredMethods()) {\r\n        OperationId operationId = getOperationId(method);\r\n        if (operationId != null) {\r\n            if (operations.values().stream().anyMatch(operation -> operation.id().equals(operationId.id()))) {\r\n                throw new IllegalStateException(\"Duplicate operation name '\" + operationId.id() + \"'\");\r\n            }\r\n            operations.put(method, operationId);\r\n        }\r\n    }\r\n    for (Class<?> iface : type.getInterfaces()) {\r\n        operations.putAll(findMethods(iface));\r\n    }\r\n    return operations;\r\n}"
}, {
	"Path": "brave.kafka.clients.KafkaTracing.addTags",
	"Comment": "when an upstream context was not present, lookup keys are unlikely added",
	"Method": "void addTags(ConsumerRecord<?, ?> record,SpanCustomizer result){\r\n    if (record.key() instanceof String && !\"\".equals(record.key())) {\r\n        result.tag(KafkaTags.KAFKA_KEY_TAG, record.key().toString());\r\n    }\r\n    result.tag(KafkaTags.KAFKA_TOPIC_TAG, record.topic());\r\n}"
}, {
	"Path": "io.atomix.cluster.Member.isActive",
	"Comment": "returns a boolean indicating whether this member is an active member of the cluster.",
	"Method": "boolean isActive(){\r\n    return false;\r\n}"
}, {
	"Path": "org.axonframework.spring.eventhandling.scheduling.java.SimpleEventSchedulerFactoryBean.setEventBus",
	"Comment": "sets the eventbus that scheduled events should be published to. defaults to the eventbus found in theapplication context. if there is more than one eventbus in the application context, you must specify which oneto use.",
	"Method": "void setEventBus(EventBus eventBus){\r\n    this.eventBus = eventBus;\r\n}"
}, {
	"Path": "brave.http.HttpAdapter.route",
	"Comment": "sampling and parsing could be changed to make it more convenient.",
	"Method": "String route(Resp response){\r\n    return null;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.RaftSessionState.setCommandResponse",
	"Comment": "sets the last command sequence number for which a response has been received.",
	"Method": "void setCommandResponse(long commandResponse){\r\n    this.commandResponse = commandResponse;\r\n}"
}, {
	"Path": "org.axonframework.config.AggregateConfigurer.configureRepository",
	"Comment": "defines the repository to use to load and store aggregates of this type. the builder function receives theglobal configuration object from which it can retrieve components the repository depends on.",
	"Method": "AggregateConfigurer<A> configureRepository(Function<Configuration, Repository<A>> repositoryBuilder){\r\n    repository.update(repositoryBuilder);\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.storage.RaftStorage.isFlushOnCommit",
	"Comment": "returns whether to flush buffers to disk when entries are committed.",
	"Method": "boolean isFlushOnCommit(){\r\n    return flushOnCommit;\r\n}"
}, {
	"Path": "org.axonframework.config.DefaultConfigurer.defaultQueryBus",
	"Comment": "provides the default querybus implementations. subclasses may override this method to provide their own default.",
	"Method": "QueryBus defaultQueryBus(Configuration config){\r\n    return SimpleQueryBus.builder().messageMonitor(config.messageMonitor(SimpleQueryBus.class, \"queryBus\")).transactionManager(config.getComponent(TransactionManager.class, NoTransactionManager::instance)).errorHandler(config.getComponent(QueryInvocationErrorHandler.class, () -> LoggingQueryInvocationErrorHandler.builder().build())).queryUpdateEmitter(config.getComponent(QueryUpdateEmitter.class)).build();\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.storage.snapshot.SnapshotFile.isNumeric",
	"Comment": "returns a boolean indicating whether the given string value is numeric.",
	"Method": "boolean isNumeric(String value){\r\n    for (char c : value.toCharArray()) {\r\n        if (!Character.isDigit(c)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "brave.context.rxjava2.internal.TraceContextCallableFlowable.subscribeActual",
	"Comment": "wraps the subscriber so that its callbacks run in the assembly context. this does not affectany subscription callbacks.",
	"Method": "void subscribeActual(Subscriber<? super T> s){\r\n    source.subscribe(Wrappers.wrap(s, contextScoper, assembled));\r\n}"
}, {
	"Path": "org.awaitility.reflect.WhiteboxImpl.getInternalState",
	"Comment": "get the value of a field using reflection. this method will traverse thesuper class hierarchy until the first field of type fieldtype isfound. the value of this field will be returned.",
	"Method": "T getInternalState(Object object,String fieldName,T getInternalState,Object object,Class<T> fieldType){\r\n    Field foundField = findFieldInHierarchy(object, new AssignableToFieldTypeMatcherStrategy(fieldType));\r\n    try {\r\n        return (T) foundField.get(object);\r\n    } catch (IllegalAccessException e) {\r\n        throw new RuntimeException(\"Internal error: Failed to get field in method getInternalState.\", e);\r\n    }\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.ConsistentHash.getMembers",
	"Comment": "returns the set of members registered with this consistent hash instance.",
	"Method": "Set<Member> getMembers(){\r\n    return new HashSet(members.values());\r\n}"
}, {
	"Path": "org.awaitility.core.ConditionFactory.with",
	"Comment": "a method to increase the readability of the awaitility dsl. it simplyreturns the same condition factory instance.",
	"Method": "ConditionFactory with(){\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.utils.misc.Match.ifNotValue",
	"Comment": "returns a match that matches any value except the specified value.",
	"Method": "Match<T> ifNotValue(T value){\r\n    return new Match(value, true);\r\n}"
}, {
	"Path": "io.crossbar.autobahn.websocket.WebSocketWriter.processMessage",
	"Comment": "process websockets or control message from master. normally,there should be no reason to override this. if you do, youneed to know what you are doing.",
	"Method": "void processMessage(Object msg){\r\n    if (msg instanceof TextMessage) {\r\n        sendTextMessage((TextMessage) msg);\r\n    } else if (msg instanceof RawTextMessage) {\r\n        sendRawTextMessage((RawTextMessage) msg);\r\n    } else if (msg instanceof BinaryMessage) {\r\n        sendBinaryMessage((BinaryMessage) msg);\r\n    } else if (msg instanceof Ping) {\r\n        sendPing((Ping) msg);\r\n    } else if (msg instanceof Pong) {\r\n        sendPong((Pong) msg);\r\n    } else if (msg instanceof Close) {\r\n        sendClose((Close) msg);\r\n    } else if (msg instanceof ClientHandshake) {\r\n        sendClientHandshake((ClientHandshake) msg);\r\n    } else if (msg instanceof Quit) {\r\n        mLooper.quit();\r\n        mActive = false;\r\n        LOGGER.d(\"Ended\");\r\n    } else {\r\n        processAppMessage(msg);\r\n    }\r\n}"
}, {
	"Path": "org.axonframework.messaging.unitofwork.CurrentUnitOfWork.isStarted",
	"Comment": "indicates whether a unit of work has already been started. this method can be used by interceptors to preventnesting of unitofwork instances.",
	"Method": "boolean isStarted(){\r\n    return CURRENT.get() != null && !CURRENT.get().isEmpty();\r\n}"
}, {
	"Path": "io.atomix.core.multimap.DistributedMultimapTest.addAndRemoveTest",
	"Comment": "contains tests for put, putall, remove, removeall and replace.",
	"Method": "void addAndRemoveTest(){\r\n    DistributedMultimap<String, String> multimap = atomix().<String, String>multimapBuilder(\"testThreeMap\").withProtocol(protocol()).build();\r\n    all.forEach(key -> all.forEach(value -> {\r\n        assertTrue(multimap.put(key, value));\r\n        assertFalse(multimap.put(key, value));\r\n    }));\r\n    all.forEach(key -> all.forEach(value -> {\r\n        assertTrue(multimap.remove(key, value));\r\n        assertFalse(multimap.remove(key, value));\r\n    }));\r\n    assertTrue(multimap.isEmpty());\r\n    all.forEach(key -> {\r\n        assertTrue(multimap.putAll(key, Lists.newArrayList(all.subList(0, 2))));\r\n        assertFalse(multimap.putAll(key, Lists.newArrayList(all.subList(0, 2))));\r\n        assertTrue(multimap.putAll(key, Lists.newArrayList(all.subList(2, 4))));\r\n        assertFalse(multimap.putAll(key, Lists.newArrayList(all.subList(2, 4))));\r\n    });\r\n    multimap.clear();\r\n    all.forEach(key -> assertTrue(multimap.putAll(key, all)));\r\n    assertEquals(16, multimap.size());\r\n    all.forEach(key -> {\r\n        assertTrue(stringArrayCollectionIsEqual(all, multimap.removeAll(key)));\r\n        assertNotEquals(all, multimap.removeAll(key));\r\n    });\r\n    assertTrue(multimap.isEmpty());\r\n    all.forEach(key -> assertTrue(multimap.putAll(key, all)));\r\n    assertEquals(16, multimap.size());\r\n    all.forEach(key -> {\r\n        assertTrue(stringArrayCollectionIsEqual(all, multimap.replaceValues(key, all)));\r\n        assertTrue(stringArrayCollectionIsEqual(all, multimap.replaceValues(key, Lists.newArrayList())));\r\n        assertTrue(multimap.replaceValues(key, all).isEmpty());\r\n    });\r\n    assertEquals(16, multimap.size());\r\n    all.forEach(key -> {\r\n        assertTrue(multimap.remove(key, one));\r\n        assertTrue(stringArrayCollectionIsEqual(Lists.newArrayList(two, three, four), multimap.replaceValues(key, Lists.newArrayList())));\r\n        assertTrue(multimap.replaceValues(key, all).isEmpty());\r\n    });\r\n}"
}, {
	"Path": "org.axonframework.messaging.correlation.MessageOriginProvider.getDefaultTraceKey",
	"Comment": "returns the default metadata key for the trace id of a message.",
	"Method": "String getDefaultTraceKey(){\r\n    return DEFAULT_TRACE_KEY;\r\n}"
}, {
	"Path": "io.atomix.utils.time.Versioned.map",
	"Comment": "maps this instance into another after transforming itsvalue while retaining the same version and creationtime.",
	"Method": "Versioned<U> map(Function<V, U> transformer){\r\n    return new Versioned(value != null ? transformer.apply(value) : null, version, creationTime);\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.ReplyMessage.getPayloadRevision",
	"Comment": "returns the payload revision of the serialized reply message.",
	"Method": "String getPayloadRevision(){\r\n    return payloadRevision;\r\n}"
}, {
	"Path": "org.axonframework.messaging.correlation.MessageOriginProvider.getDefaultCorrelationKey",
	"Comment": "returns the default metadata key for the correlation id of a message.",
	"Method": "String getDefaultCorrelationKey(){\r\n    return DEFAULT_CORRELATION_KEY;\r\n}"
}, {
	"Path": "brave.jersey.server.ITTracingApplicationEventListener.managedAsync",
	"Comment": "tests that the span propagates between under asynchronous callbacks managed by jersey.",
	"Method": "void managedAsync(){\r\n    Response response = get(\"/managedAsync\");\r\n    assertThat(response.isSuccessful()).withFailMessage(\"not successful: \" + response).isTrue();\r\n    takeSpan();\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.roles.LeaderRole.appendAndCompact",
	"Comment": "appends an entry to the raft log and compacts logs if necessary.",
	"Method": "CompletableFuture<Indexed<E>> appendAndCompact(E entry,CompletableFuture<Indexed<E>> appendAndCompact,E entry,int attempt){\r\n    if (attempt == MAX_APPEND_ATTEMPTS) {\r\n        return Futures.exceptionalFuture(new StorageException.OutOfDiskSpace(\"Not enough space to append entry\"));\r\n    } else {\r\n        try {\r\n            return CompletableFuture.completedFuture(raft.getLogWriter().append(entry)).thenApply(indexed -> {\r\n                log.trace(\"Appended {}\", indexed);\r\n                return indexed;\r\n            });\r\n        } catch (StorageException.TooLarge e) {\r\n            return Futures.exceptionalFuture(e);\r\n        } catch (StorageException.OutOfDiskSpace e) {\r\n            log.warn(\"Caught OutOfDiskSpace error! Force compacting logs...\");\r\n            return raft.getServiceManager().compact().thenCompose(v -> appendAndCompact(entry, attempt + 1));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.RaftTest.testEventsAfterLeaderKill",
	"Comment": "tests submitting a linearizable event that publishes to all sessions.",
	"Method": "void testEventsAfterLeaderKill(int nodes){\r\n    List<RaftServer> servers = createServers(nodes);\r\n    RaftClient client = createClient();\r\n    TestPrimitive primitive = createPrimitive(client);\r\n    primitive.onEvent(event -> {\r\n        threadAssertNotNull(event);\r\n        resume();\r\n    });\r\n    for (int i = 0; i < 10; i++) {\r\n        primitive.sendEvent(true).thenRun(this::resume);\r\n        await(30000, 2);\r\n    }\r\n    primitive.sendEvent(true).thenRun(this::resume);\r\n    RaftServer leader = servers.stream().filter(s -> s.getRole() == RaftServer.Role.LEADER).findFirst().get();\r\n    leader.shutdown().get(10, TimeUnit.SECONDS);\r\n    await(30000);\r\n    for (int i = 0; i < 10; i++) {\r\n        primitive.sendEvent(true).thenRun(this::resume);\r\n        await(30000, 2);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.RaftSessionSequencerTest.testSequenceEventBeforeCommand",
	"Comment": "tests sequencing an event that arrives before a command response.",
	"Method": "void testSequenceEventBeforeCommand(){\r\n    RaftSessionSequencer sequencer = new RaftSessionSequencer(new RaftSessionState(\"test\", SessionId.from(1), UUID.randomUUID().toString(), TestPrimitiveType.instance(), 1000));\r\n    long sequence = sequencer.nextRequest();\r\n    PublishRequest request = PublishRequest.builder().withSession(1).withEventIndex(1).withPreviousIndex(0).withEvents(Collections.emptyList()).build();\r\n    CommandResponse response = CommandResponse.builder().withStatus(RaftResponse.Status.OK).withIndex(2).withEventIndex(1).build();\r\n    AtomicInteger run = new AtomicInteger();\r\n    sequencer.sequenceEvent(request, () -> assertEquals(0, run.getAndIncrement()));\r\n    sequencer.sequenceResponse(sequence, response, () -> assertEquals(1, run.getAndIncrement()));\r\n    assertEquals(2, run.get());\r\n}"
}, {
	"Path": "io.atomix.cluster.discovery.BootstrapDiscoveryBuilder.withFailureTimeout",
	"Comment": "sets the failure timeout to use prior to phi failure detectors being populated.",
	"Method": "BootstrapDiscoveryBuilder withFailureTimeout(Duration failureTimeout){\r\n    config.setFailureTimeout(failureTimeout);\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.protocols.gossip.map.MapValue.isTombstone",
	"Comment": "tests if this value is tombstone value with the specified timestamp.",
	"Method": "boolean isTombstone(boolean isTombstone){\r\n    return value == null;\r\n}"
}, {
	"Path": "brave.jersey.server.ITSpanCustomizingApplicationEventListener.managedAsync",
	"Comment": "tests that the span propagates between under asynchronous callbacks managed by jersey.",
	"Method": "void managedAsync(){\r\n    get(\"/managedAsync\");\r\n    takeSpan();\r\n}"
}, {
	"Path": "io.atomix.core.impl.CoreTransactionService.completeTransaction",
	"Comment": "completes a transaction by modifying the transaction state to change ownership to this member and then completingthe transaction based on the existing transaction state.",
	"Method": "CompletableFuture<Void> completeTransaction(TransactionId transactionId,TransactionState expectState,Function<TransactionInfo, TransactionInfo> updateFunction,Predicate<TransactionInfo> updatedPredicate,BiFunction<TransactionId, Transactional<?>, CompletableFuture<Void>> completionFunction){\r\n    return transactions.compute(transactionId, (id, info) -> {\r\n        if (info == null) {\r\n            return null;\r\n        } else if (info.state == expectState) {\r\n            return updateFunction.apply(info);\r\n        } else {\r\n            return info;\r\n        }\r\n    }).thenCompose(value -> {\r\n        if (value != null && updatedPredicate.test(value.value())) {\r\n            return Futures.allOf(value.value().participants.stream().map(participantInfo -> completeParticipant(participantInfo, info -> completionFunction.apply(transactionId, info)))).thenApply(v -> null);\r\n        }\r\n        return Futures.exceptionalFuture(new TransactionException(\"Failed to acquire transaction lock\"));\r\n    });\r\n}"
}, {
	"Path": "org.axonframework.serialization.SerializedMessage.isMetaDataDeserialized",
	"Comment": "indicates whether the metadata of this message has already been deserialized.",
	"Method": "boolean isMetaDataDeserialized(){\r\n    return metaData.isDeserialized();\r\n}"
}, {
	"Path": "org.axonframework.config.AggregateConfigurer.configureSnapshotTrigger",
	"Comment": "configures snapshotting for the aggregate type under configuration.note that this configuration is ignored if a custom repository instance is configured.",
	"Method": "AggregateConfigurer<A> configureSnapshotTrigger(Function<Configuration, SnapshotTriggerDefinition> snapshotTriggerDefinition){\r\n    this.snapshotTriggerDefinition.update(snapshotTriggerDefinition);\r\n    return this;\r\n}"
}, {
	"Path": "org.axonframework.common.lock.PessimisticLockFactory.builder",
	"Comment": "creates a builder to construct an instance of this lockfactory.",
	"Method": "Builder builder(){\r\n    return new Builder();\r\n}"
}, {
	"Path": "io.atomix.core.map.impl.MapUpdate.version",
	"Comment": "returns the expected current version in the database for the key.",
	"Method": "long version(){\r\n    return version;\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.AbstractAggregateFactory.postProcessInstance",
	"Comment": "perform any processing that must be done on an aggregate instance that was reconstructed from a snapshotevent. implementations may choose to modify the existing instance, or return a new instance.this method can be safely overridden. this implementation does nothing.",
	"Method": "T postProcessInstance(T aggregate){\r\n    return aggregate;\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.jdbc.JdbcEventStorageEngine.domainEventFields",
	"Comment": "returns a comma separated list of domain event column names to select from an event or snapshot entry.",
	"Method": "String domainEventFields(){\r\n    return String.join(\", \", schema.eventIdentifierColumn(), schema.timestampColumn(), schema.payloadTypeColumn(), schema.payloadRevisionColumn(), schema.payloadColumn(), schema.metaDataColumn(), schema.typeColumn(), schema.aggregateIdentifierColumn(), schema.sequenceNumberColumn());\r\n}"
}, {
	"Path": "org.axonframework.messaging.unitofwork.AbstractUnitOfWork.correlationDataProviders",
	"Comment": "provides the collection of registered correlation data providers of this unit of work. the returned collection is a live view of the providersregistered. any changes in the registration are reflected in the returned collection.",
	"Method": "Collection<CorrelationDataProvider> correlationDataProviders(){\r\n    return correlationDataProviders;\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.DispatchMessage.isExpectReply",
	"Comment": "indicates whether the sender of this message requests a reply.",
	"Method": "boolean isExpectReply(){\r\n    return expectReply;\r\n}"
}, {
	"Path": "io.atomix.primitive.operation.Operations.findOperations",
	"Comment": "recursively finds operations defined by the given type and its implemented interfaces.",
	"Method": "Map<OperationId, Method> findOperations(Class<?> type){\r\n    Map<OperationId, Method> operations = new HashMap();\r\n    for (Method method : type.getDeclaredMethods()) {\r\n        OperationId operationId = getOperationId(method);\r\n        if (operationId != null) {\r\n            if (operations.keySet().stream().anyMatch(operation -> operation.id().equals(operationId.id()))) {\r\n                throw new IllegalStateException(\"Duplicate operation name '\" + operationId.id() + \"'\");\r\n            }\r\n            operations.put(operationId, method);\r\n        }\r\n    }\r\n    for (Class<?> iface : type.getInterfaces()) {\r\n        operations.putAll(findOperations(iface));\r\n    }\r\n    return operations;\r\n}"
}, {
	"Path": "io.atomix.cluster.messaging.impl.AbstractClientConnection.getTimeoutMillis",
	"Comment": "returns the timeout in milliseconds for the given timeout duration",
	"Method": "long getTimeoutMillis(String type,Duration timeout){\r\n    return timeout != null ? timeout.toMillis() : computeTimeoutMillis(type);\r\n}"
}, {
	"Path": "brave.handler.MutableSpan.remoteIp",
	"Comment": "the text representation of the primary ipv4 or ipv6 address associated with the remote side ofthis connection. ex. 192.168.99.100 null if unknown.",
	"Method": "String remoteIp(){\r\n    return remoteIp;\r\n}"
}, {
	"Path": "org.assertj.core.api.SoftAssertionsTest.object_soft_assertions_should_report_errors_on_final_methods_and_methods_that_switch_the_object_under_test",
	"Comment": "the test would fail if any method was not proxyable as the assertion error would not be softly caught",
	"Method": "void object_soft_assertions_should_report_errors_on_final_methods_and_methods_that_switch_the_object_under_test(){\r\n    Name name = name(\"John\", \"Doe\");\r\n    Object alphabet = \"abcdefghijklmnopqrstuvwxyz\";\r\n    Object vowels = asList(\"a\", \"e\", \"i\", \"o\", \"u\");\r\n    softly.assertThat(name).as(\"extracting(\\\"first\\\", \\\"last\\\")\").overridingErrorMessage(\"error message\").extracting(\"first\", \"last\").contains(\"John\").contains(\"gandalf\");\r\n    softly.assertThat(name).as(\"extracting(Name::getFirst, Name::getLast)\").overridingErrorMessage(\"error message\").extracting(Name::getFirst, Name::getLast).contains(\"John\").contains(\"frodo\");\r\n    softly.assertThat(alphabet).overridingErrorMessage(\"error message\").as(\"asString()\").asString().startsWith(\"abc\").startsWith(\"123\");\r\n    softly.assertThat(vowels).as(\"asList()\").overridingErrorMessage(\"error message\").asList().startsWith(\"a\", \"e\").startsWith(\"1\", \"2\");\r\n    softly.assertThat(name).as(\"extracting(Name::getFirst)\").overridingErrorMessage(\"error message\").extracting(Name::getFirst).isEqualTo(\"Jack\");\r\n    List<Throwable> errorsCollected = softly.errorsCollected();\r\n    assertThat(errorsCollected).hasSize(5);\r\n    assertThat(errorsCollected.get(0)).hasMessage(\"[extracting(\\\"first\\\", \\\"last\\\")] error message\");\r\n    assertThat(errorsCollected.get(1)).hasMessage(\"[extracting(Name::getFirst, Name::getLast)] error message\");\r\n    assertThat(errorsCollected.get(2)).hasMessage(\"[asString()] error message\");\r\n    assertThat(errorsCollected.get(3)).hasMessage(\"[asList()] error message\");\r\n    assertThat(errorsCollected.get(4)).hasMessage(\"[extracting(Name::getFirst)] error message\");\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.storage.log.RaftLog.compact",
	"Comment": "compacts the journal up to the given index.the semantics of compaction are not specified by this interface.",
	"Method": "void compact(long index){\r\n    journal.compact(index);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.protocol.PollResponse.accepted",
	"Comment": "returns a boolean indicating whether the poll was accepted.",
	"Method": "boolean accepted(){\r\n    return accepted;\r\n}"
}, {
	"Path": "io.atomix.utils.time.MultiValuedTimestampTest.testSerializerConstructor",
	"Comment": "tests that the empty argument list constructor for serializationis present and creates a proper object.",
	"Method": "void testSerializerConstructor(){\r\n    try {\r\n        Constructor[] constructors = MultiValuedTimestamp.class.getDeclaredConstructors();\r\n        assertThat(constructors, notNullValue());\r\n        Arrays.stream(constructors).filter(ctor -> ctor.getParameterTypes().length == 0).forEach(noParamsCtor -> {\r\n            try {\r\n                noParamsCtor.setAccessible(true);\r\n                MultiValuedTimestamp stats = (MultiValuedTimestamp) noParamsCtor.newInstance();\r\n                assertThat(stats, notNullValue());\r\n            } catch (Exception e) {\r\n                Assert.fail(\"Exception instantiating no parameters constructor\");\r\n            }\r\n        });\r\n    } catch (Exception e) {\r\n        Assert.fail(\"Exception looking up constructors\");\r\n    }\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.jdbc.JdbcEventStorageEngine.trackedEventFields",
	"Comment": "returns a comma separated list of tracked domain event column names to select from an event entry.",
	"Method": "String trackedEventFields(){\r\n    return schema.globalIndexColumn() + \", \" + domainEventFields();\r\n}"
}, {
	"Path": "io.atomix.core.semaphore.impl.BlockingDistributedSemaphore.complete",
	"Comment": "use for complete acquire or tryacquire.if interrupt or timeout before the future completed, set needrelease to true.when the future completes, release these permits.",
	"Method": "T complete(CompletableFuture<T> future,T complete,CompletableFuture<T> future,int acquirePermits){\r\n    AtomicBoolean needRelease = new AtomicBoolean(false);\r\n    try {\r\n        return future.thenApply(value -> {\r\n            if (needRelease.get()) {\r\n                if (acquirePermits > 0) {\r\n                    asyncSemaphore.release(acquirePermits);\r\n                }\r\n            }\r\n            return value;\r\n        }).get(timeout.toMillis(), TimeUnit.MILLISECONDS);\r\n    } catch (InterruptedException | PrimitiveException.Interrupted e) {\r\n        needRelease.set(acquirePermits > 0);\r\n        Thread.currentThread().interrupt();\r\n        throw new PrimitiveException.Interrupted();\r\n    } catch (TimeoutException | PrimitiveException.Timeout e) {\r\n        needRelease.set(acquirePermits > 0);\r\n        throw new PrimitiveException.Timeout();\r\n    } catch (ExecutionException e) {\r\n        needRelease.set(acquirePermits > 0);\r\n        Throwable cause = Throwables.getRootCause(e);\r\n        if (cause instanceof PrimitiveException) {\r\n            throw (PrimitiveException) cause;\r\n        } else {\r\n            throw new PrimitiveException(cause);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.RaftTest.testManyEvents",
	"Comment": "tests submitting a linearizable event that publishes to all sessions.",
	"Method": "void testManyEvents(int nodes){\r\n    createServers(nodes);\r\n    RaftClient client = createClient();\r\n    TestPrimitive primitive = createPrimitive(client);\r\n    primitive.onEvent(message -> {\r\n        threadAssertNotNull(message);\r\n        resume();\r\n    });\r\n    for (int i = 0; i < 10; i++) {\r\n        primitive.sendEvent(true).thenRun(this::resume);\r\n        await(30000, 2);\r\n    }\r\n}"
}, {
	"Path": "brave.internal.recorder.PendingSpansTest.pretendGCHappened",
	"Comment": "in reality, this clears a reference even if it is strongly held by the test!",
	"Method": "void pretendGCHappened(){\r\n    ((PendingSpans.RealKey) pendingSpans.delegate.keySet().iterator().next()).clear();\r\n}"
}, {
	"Path": "io.atomix.utils.concurrent.Retries.delay",
	"Comment": "suspends the current thread for a specified number of millis and nanos.",
	"Method": "void delay(int ms,int nanos){\r\n    try {\r\n        Thread.sleep(ms, nanos);\r\n    } catch (InterruptedException e) {\r\n        throw new RuntimeException(\"Interrupted\", e);\r\n    }\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.tokenstore.jdbc.TokenSchema.tokenTypeColumn",
	"Comment": "returns the name of the column containing the name of the type to which the token should be deserialized.",
	"Method": "String tokenTypeColumn(){\r\n    return tokenTypeColumn;\r\n}"
}, {
	"Path": "org.axonframework.test.saga.CommandValidator.assertDispatchedEqualTo",
	"Comment": "assert that the given commands have been dispatched in the exact sequence provided.",
	"Method": "void assertDispatchedEqualTo(Object expected){\r\n    List<CommandMessage<?>> actual = commandBus.getDispatchedCommands();\r\n    if (actual.size() != expected.length) {\r\n        throw new AxonAssertionError(format(\"Got wrong number of commands dispatched. Expected <%s>, got <%s>\", expected.length, actual.size()));\r\n    }\r\n    Iterator<CommandMessage<?>> actualIterator = actual.iterator();\r\n    Iterator<Object> expectedIterator = Arrays.asList(expected).iterator();\r\n    int counter = 0;\r\n    while (actualIterator.hasNext()) {\r\n        CommandMessage<?> actualItem = actualIterator.next();\r\n        Object expectedItem = expectedIterator.next();\r\n        if (expectedItem instanceof CommandMessage) {\r\n            CommandMessage<?> expectedMessage = (CommandMessage<?>) expectedItem;\r\n            if (!expectedMessage.getPayloadType().equals(actualItem.getPayloadType())) {\r\n                throw new AxonAssertionError(format(\"Unexpected payload type of command at position %s (0-based). Expected <%s>, got <%s>\", counter, expectedMessage.getPayloadType(), actualItem.getPayloadType()));\r\n            }\r\n            assertCommandEquality(counter, expectedMessage.getPayload(), actualItem.getPayload());\r\n            if (!expectedMessage.getMetaData().equals(actualItem.getMetaData())) {\r\n                throw new AxonAssertionError(format(\"Unexpected Meta Data of command at position %s (0-based). Expected <%s>, got <%s>\", counter, expectedMessage.getMetaData(), actualItem.getMetaData()));\r\n            }\r\n        } else {\r\n            assertCommandEquality(counter, expectedItem, actualItem.getPayload());\r\n        }\r\n        counter++;\r\n    }\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.MultiRaftProtocolBuilder.withMaxRetries",
	"Comment": "sets the maximum number of retries before an operation can be failed.",
	"Method": "MultiRaftProtocolBuilder withMaxRetries(int maxRetries){\r\n    config.setMaxRetries(maxRetries);\r\n    return this;\r\n}"
}, {
	"Path": "org.axonframework.messaging.unitofwork.MessageProcessingContext.transformMessage",
	"Comment": "transform the message being processed using the given operator.",
	"Method": "void transformMessage(Function<T, ? extends Message<?>> transformOperator){\r\n    message = (T) transformOperator.apply(message);\r\n}"
}, {
	"Path": "io.crossbar.autobahn.websocket.WebSocketReader.onHandshake",
	"Comment": "websockets handshake reply from server received, default notifies master.",
	"Method": "void onHandshake(Map<String, String> handshakeParams,boolean success){\r\n    notify(new ServerHandshake(handshakeParams, success));\r\n}"
}, {
	"Path": "org.axonframework.modelling.command.ConflictingAggregateVersionException.getActualVersion",
	"Comment": "returns the actual version of the aggregate, as loaded by the repository.",
	"Method": "long getActualVersion(){\r\n    return actualVersion;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.service.RaftServiceContext.indexQuery",
	"Comment": "ensures the given query is applied after the appropriate index.",
	"Method": "void indexQuery(long index,long timestamp,RaftSession session,PrimitiveOperation operation,CompletableFuture<OperationResult> future){\r\n    if (index > currentIndex) {\r\n        log.trace(\"Registering query with index \" + index + \" > \" + currentIndex);\r\n        session.registerIndexQuery(index, () -> applyQuery(timestamp, session, operation, future));\r\n    } else {\r\n        applyQuery(timestamp, session, operation, future);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.agent.AtomixAgent.parseArgs",
	"Comment": "parses the command line arguments, returning an argparse4j namespace.",
	"Method": "Namespace parseArgs(String[] args,List<String> unknown){\r\n    ArgumentParser parser = createParser();\r\n    Namespace namespace = null;\r\n    try {\r\n        namespace = parser.parseKnownArgs(args, unknown);\r\n    } catch (ArgumentParserException e) {\r\n        parser.handleError(e);\r\n        System.exit(1);\r\n    }\r\n    return namespace;\r\n}"
}, {
	"Path": "org.axonframework.springboot.SerializerProperties.setEvents",
	"Comment": "the type of serializer to use to serialize the payload and meta data of event messages. defaults to the messageserializer, or otherwise the general serializer.",
	"Method": "void setEvents(SerializerType serializerType){\r\n    this.events = serializerType;\r\n}"
}, {
	"Path": "io.atomix.core.lock.DistributedLockTest.testBlockingUnlock",
	"Comment": "tests unlocking a lock with a blocking call in the event thread.",
	"Method": "void testBlockingUnlock(){\r\n    DistributedLock lock1 = atomix().lockBuilder(\"test-blocking-unlock\").withProtocol(protocol()).build();\r\n    DistributedLock lock2 = atomix().lockBuilder(\"test-blocking-unlock\").withProtocol(protocol()).build();\r\n    lock1.async().lock().thenRun(() -> lock1.unlock());\r\n    lock2.lock();\r\n}"
}, {
	"Path": "brave.http.HttpTracing.create",
	"Comment": "not final as it previously was not. this allows mocks and similar.",
	"Method": "HttpTracing create(Tracing tracing){\r\n    return newBuilder(tracing).build();\r\n}"
}, {
	"Path": "io.atomix.primitive.operation.PrimitiveOperation.operation",
	"Comment": "creates a new primitive operation with a simplified identifier.",
	"Method": "PrimitiveOperation operation(OperationId id,PrimitiveOperation operation,OperationId id,byte[] value){\r\n    return new PrimitiveOperation(OperationId.simplify(id), value);\r\n}"
}, {
	"Path": "io.atomix.core.collection.DistributedCollectionConfig.setRegistrationRequired",
	"Comment": "sets whether registration is required for serializable types.",
	"Method": "C setRegistrationRequired(boolean registrationRequired){\r\n    this.registrationRequired = registrationRequired;\r\n    return (C) this;\r\n}"
}, {
	"Path": "io.atomix.agent.AtomixAgent.buildRestService",
	"Comment": "builds a rest service for the given atomix instance from the given namespace.",
	"Method": "ManagedRestService buildRestService(Atomix atomix,Namespace namespace){\r\n    final String httpHost = namespace.getString(\"http_host\");\r\n    final Integer httpPort = namespace.getInt(\"http_port\");\r\n    return RestService.builder().withAtomix(atomix).withAddress(Address.from(httpHost, httpPort)).build();\r\n}"
}, {
	"Path": "io.atomix.core.AtomixBuilder.withShutdownHookEnabled",
	"Comment": "enables the shutdown hook.when the shutdown hook is enabled, the instance will be shutdown when the jvm exits.",
	"Method": "AtomixBuilder withShutdownHookEnabled(){\r\n    return withShutdownHook(true);\r\n}"
}, {
	"Path": "brave.context.rxjava2.internal.TraceContextConnectableFlowable.subscribeActual",
	"Comment": "wraps the subscriber so that its callbacks run in the assembly context. this does not affectany subscription callbacks.",
	"Method": "void subscribeActual(Subscriber<? super T> s){\r\n    source.subscribe(Wrappers.wrap(s, contextScoper, assembled));\r\n}"
}, {
	"Path": "io.atomix.core.AtomixBuilder.withTypeRegistrationRequired",
	"Comment": "sets whether serializable type registration is required for user types.",
	"Method": "AtomixBuilder withTypeRegistrationRequired(AtomixBuilder withTypeRegistrationRequired,boolean required){\r\n    config.setTypeRegistrationRequired(required);\r\n    return this;\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.TrackingEventProcessor.activeProcessorThreads",
	"Comment": "returns an approximation of the number of threads currently processing events.",
	"Method": "int activeProcessorThreads(){\r\n    return this.activeSegments.size();\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.AbstractEventStorageEngine.getSnapshotSerializer",
	"Comment": "get the serializer used by this storage engine when storing and retrieving snapshots.",
	"Method": "Serializer getSnapshotSerializer(){\r\n    return snapshotSerializer;\r\n}"
}, {
	"Path": "io.atomix.protocols.gossip.map.MapValue.isNewerThan",
	"Comment": "tests if this timestamp is newer than the specified timestamp.",
	"Method": "boolean isNewerThan(MapValue other,boolean isNewerThan,Timestamp timestamp,boolean isNewerThan,Digest other){\r\n    return this.timestamp.isNewerThan(timestamp);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.RaftTest.testManyEventsAfterLeaderShutdown",
	"Comment": "tests submitting a linearizable event that publishes to all sessions.",
	"Method": "void testManyEventsAfterLeaderShutdown(int nodes){\r\n    List<RaftServer> servers = createServers(nodes);\r\n    RaftClient client = createClient();\r\n    TestPrimitive primitive = createPrimitive(client);\r\n    primitive.onEvent(event -> {\r\n        threadAssertNotNull(event);\r\n        resume();\r\n    });\r\n    for (int i = 0; i < 10; i++) {\r\n        primitive.sendEvent(true).thenRun(this::resume);\r\n        await(30000, 2);\r\n    }\r\n    RaftServer leader = servers.stream().filter(s -> s.getRole() == RaftServer.Role.LEADER).findFirst().get();\r\n    leader.shutdown().get(10, TimeUnit.SECONDS);\r\n    for (int i = 0; i < 10; i++) {\r\n        primitive.sendEvent(true).thenRun(this::resume);\r\n        await(30000, 2);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.utils.concurrent.AbstractAccumulator.rescheduleTask",
	"Comment": "reschedules the specified task, cancelling existing one if applicable.",
	"Method": "void rescheduleTask(AtomicReference<TimerTask> taskRef,long millis){\r\n    ProcessorTask newTask = new ProcessorTask();\r\n    timer.schedule(newTask, millis);\r\n    swapAndCancelTask(taskRef, newTask);\r\n}"
}, {
	"Path": "io.atomix.utils.concurrent.Futures.allOf",
	"Comment": "returns a new completablefuture completed by reducing a list of computed valueswhen all of the given completablefuture complete.",
	"Method": "CompletableFuture<Stream<T>> allOf(Stream<CompletableFuture<T>> futures,CompletableFuture<List<T>> allOf,List<CompletableFuture<T>> futures,CompletableFuture<T> allOf,List<CompletableFuture<T>> futures,BinaryOperator<T> reducer,T emptyValue){\r\n    return allOf(futures).thenApply(resultList -> resultList.stream().reduce(reducer).orElse(emptyValue));\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.AbstractEventProcessor.eventHandlerInvoker",
	"Comment": "returns the invoker assigned to this processor. the invoker is responsible for invoking the correct handlermethods for any given message.",
	"Method": "EventHandlerInvoker eventHandlerInvoker(Builder eventHandlerInvoker,EventHandlerInvoker eventHandlerInvoker){\r\n    return eventHandlerInvoker;\r\n}"
}, {
	"Path": "org.axonframework.axonserver.connector.event.axon.EventBuffer.registerConsumeListener",
	"Comment": "registers the callback to invoke when a raw input message was consumed from the buffer.",
	"Method": "void registerConsumeListener(Consumer<Integer> consumeListener){\r\n    this.consumeListener = consumeListener;\r\n}"
}, {
	"Path": "org.axonframework.config.DefaultConfigurer.invokeInitHandlers",
	"Comment": "calls all registered init handlers. registration of init handlers after this invocation will result in animmediate invocation of that handler.",
	"Method": "void invokeInitHandlers(){\r\n    initialized = true;\r\n    initHandlers.stream().sorted(comparingInt(ConsumerHandler::phase)).forEach(h -> h.accept(config));\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.gateway.AbstractCommandGateway.getCommandBus",
	"Comment": "returns the commandbus used by this gateway. should be used to monitoring or testing.",
	"Method": "CommandBus getCommandBus(){\r\n    return commandBus;\r\n}"
}, {
	"Path": "org.axonframework.test.aggregate.ResultValidatorImpl.assertValidRecording",
	"Comment": "makes sure the execution phase has finishes without any errors ir fixtureexecutionexceptions. if an error wasrecorded, it will be thrown immediately. this allow one to distinguish between failed tests, and tests in error.",
	"Method": "void assertValidRecording(){\r\n    if (actualException instanceof Error) {\r\n        throw (Error) actualException;\r\n    } else if (actualException instanceof FixtureExecutionException) {\r\n        throw (FixtureExecutionException) actualException;\r\n    }\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.ReplyMessage.getSerializedMetaData",
	"Comment": "returns the serialized meta data of the serialized reply message.",
	"Method": "byte[] getSerializedMetaData(){\r\n    return serializedMetaData;\r\n}"
}, {
	"Path": "org.awaitility.core.ConditionFactory.and",
	"Comment": "a method to increase the readability of the awaitility dsl. it simplyreturns the same condition factory instance.",
	"Method": "ConditionFactory and(){\r\n    return this;\r\n}"
}, {
	"Path": "brave.kafka.clients.KafkaTracingTest.nextSpan_shouldnt_tag_topic_and_key_when_incoming_context",
	"Comment": "we assume topic and key are already tagged by the producer span. however, we can change thispolicy now, or later when dynamic policy is added to kafkatracing",
	"Method": "void nextSpan_shouldnt_tag_topic_and_key_when_incoming_context(){\r\n    addB3Headers(fakeRecord);\r\n    kafkaTracing.nextSpan(fakeRecord).start().finish();\r\n    assertThat(spans).flatExtracting(s -> s.tags().entrySet()).isEmpty();\r\n}"
}, {
	"Path": "brave.context.rxjava2.internal.TraceContextMaybe.subscribeActual",
	"Comment": "wraps the observer so that its callbacks run in the assembly context. this does not affect anysubscription callbacks.",
	"Method": "void subscribeActual(MaybeObserver<? super T> o){\r\n    source.subscribe(new TraceContextMaybeObserver(o, contextScoper, assembled));\r\n}"
}, {
	"Path": "io.atomix.utils.serializer.Namespace.size",
	"Comment": "gets the number of classes registered in this kryo namespace.",
	"Method": "int size(){\r\n    return (int) registeredBlocks.stream().flatMap(block -> block.types().stream()).count();\r\n}"
}, {
	"Path": "io.crossbar.autobahn.websocket.WebSocketWriter.handleMessage",
	"Comment": "process message received from foreground thread. this is called fromthe message looper set up for the background thread running this writer.",
	"Method": "void handleMessage(Message msg){\r\n    try {\r\n        processMessage(msg.obj);\r\n        if (mActive && mSocket.isConnected() && !mSocket.isClosed()) {\r\n            mBufferedOutputStream.flush();\r\n        }\r\n        if (msg.obj instanceof Close) {\r\n            Close closeMessage = (Close) msg.obj;\r\n            if (closeMessage.mIsReply) {\r\n                notify(new Close(closeMessage.mCode, closeMessage.mReason, true));\r\n            }\r\n        }\r\n    } catch (SocketException e) {\r\n        LOGGER.d(\"run() : SocketException (\" + e.toString() + \")\");\r\n        notify(new ConnectionLost(null));\r\n    } catch (Exception e) {\r\n        LOGGER.w(e.getMessage(), e);\r\n        notify(new Error(e));\r\n    }\r\n}"
}, {
	"Path": "io.atomix.primitive.session.impl.RecoveringSessionClient.openProxy",
	"Comment": "opens a new client, completing the provided future only once the client has been opened.",
	"Method": "void openProxy(CompletableFuture<SessionClient> future){\r\n    log.debug(\"Opening proxy session\");\r\n    proxyFactory.get().thenCompose(proxy -> proxy.connect()).whenComplete((proxy, error) -> {\r\n        if (error == null) {\r\n            synchronized (this) {\r\n                this.log = ContextualLoggerFactory.getLogger(getClass(), LoggerContext.builder(SessionClient.class).addValue(proxy.sessionId()).add(\"type\", proxy.type()).add(\"name\", proxy.name()).build());\r\n                this.session = proxy;\r\n                proxy.addStateChangeListener(this::onStateChange);\r\n                eventListeners.forEach(proxy::addEventListener);\r\n                onStateChange(PrimitiveState.CONNECTED);\r\n            }\r\n            future.complete(this);\r\n        } else {\r\n            recoverTask = context.schedule(Duration.ofSeconds(1), () -> openProxy(future));\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.scheduling.quartz.FireEventJob.createMessage",
	"Comment": "creates a new message for the scheduled event. this ensures that a new identifier and timestamp will alwaysbe generated, so that the timestamp will reflect the actual moment the trigger occurred.",
	"Method": "EventMessage<?> createMessage(Object event){\r\n    EventMessage<?> eventMessage;\r\n    if (event instanceof EventMessage) {\r\n        eventMessage = new GenericEventMessage(((EventMessage) event).getPayload(), ((EventMessage) event).getMetaData());\r\n    } else {\r\n        eventMessage = new GenericEventMessage(event, MetaData.emptyInstance());\r\n    }\r\n    return eventMessage;\r\n}"
}, {
	"Path": "io.atomix.core.iterator.impl.ProxyIterator.batch",
	"Comment": "returns the current batch iterator or lazily fetches the next batch from the cluster.",
	"Method": "CompletableFuture<Iterator<T>> batch(){\r\n    return batch.thenCompose(iterator -> {\r\n        if (iterator != null && !iterator.hasNext()) {\r\n            batch = fetch(iterator.position());\r\n            return batch.thenApply(Function.identity());\r\n        }\r\n        return CompletableFuture.completedFuture(iterator);\r\n    });\r\n}"
}, {
	"Path": "brave.grpc.ITTracingClientInterceptor.propagates_sampledFalse",
	"Comment": "unlike brave 3, brave 4 propagates trace ids even when unsampled",
	"Method": "void propagates_sampledFalse(){\r\n    tracing = GrpcTracing.create(tracingBuilder(Sampler.NEVER_SAMPLE).build());\r\n    closeClient(client);\r\n    client = newClient();\r\n    GreeterGrpc.newBlockingStub(client).sayHello(HELLO_REQUEST);\r\n    TraceContextOrSamplingFlags extracted = server.takeRequest();\r\n    assertThat(extracted.sampled()).isFalse();\r\n}"
}, {
	"Path": "org.axonframework.common.jdbc.Oracle11Utils.simulateAutoIncrement",
	"Comment": "oracle11 does not have auto incremented values. this method uses a sequence and a trigger to create the samebehavior.",
	"Method": "void simulateAutoIncrement(Connection connection,String tableName,String columnName){\r\n    String sequenceName = tableName + \"_seq\";\r\n    String triggerName = tableName + \"_id\";\r\n    try (PreparedStatement pst = connection.prepareStatement(\"CREATE sequence \" + sequenceName + \" start with 1 increment by 1 nocycle\")) {\r\n        pst.executeUpdate();\r\n    }\r\n    try (Statement st = connection.createStatement()) {\r\n        st.execute(\"create or replace trigger \" + triggerName + \"        before insert on \" + tableName + \"        for each row \" + \"        begin \" + \"                :new.\" + columnName + \" := \" + sequenceName + \".nextval; \" + \"        end;\");\r\n    }\r\n}"
}, {
	"Path": "io.atomix.utils.serializer.SerializerBuilder.withCompatibleSerialization",
	"Comment": "sets whether compatible serialization is enabled for serializable types.",
	"Method": "SerializerBuilder withCompatibleSerialization(SerializerBuilder withCompatibleSerialization,boolean compatibleSerialization){\r\n    namespaceBuilder.setCompatible(compatibleSerialization);\r\n    return this;\r\n}"
}, {
	"Path": "org.axonframework.modelling.saga.repository.jdbc.JdbcSagaStore.createSchema",
	"Comment": "creates the sql schema required to store sagas and their associations,.",
	"Method": "void createSchema(){\r\n    final Connection connection = connectionProvider.getConnection();\r\n    try {\r\n        sqlSchema.sql_createTableSagaEntry(connection).executeUpdate();\r\n        sqlSchema.sql_createTableAssocValueEntry(connection).executeUpdate();\r\n    } finally {\r\n        closeQuietly(connection);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.core.workqueue.WorkQueueStats.totalInProgress",
	"Comment": "returns the total in progress tasks. these are the tasks that are currently being worked on.",
	"Method": "long totalInProgress(){\r\n    return this.totalInProgress;\r\n}"
}, {
	"Path": "org.axonframework.springboot.util.jpa.ContainerManagedEntityManagerProvider.setEntityManager",
	"Comment": "sets the container managed entitymanager to use. is generally injected by the application container.",
	"Method": "void setEntityManager(EntityManager entityManager){\r\n    this.entityManager = entityManager;\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.ReplyMessage.getSerializedPayload",
	"Comment": "returns the serialized payload of the serialized reply message.",
	"Method": "byte[] getSerializedPayload(){\r\n    return serializedPayload;\r\n}"
}, {
	"Path": "org.axonframework.test.matchers.Matchers.listWithAllOf",
	"Comment": "matches a list where all the given matchers must match with at least one of the items in that list.",
	"Method": "Matcher<List<T>> listWithAllOf(Matcher<T> matchers){\r\n    return new ListWithAllOfMatcher(matchers);\r\n}"
}, {
	"Path": "io.atomix.utils.config.ConfigMapper.loadFiles",
	"Comment": "loads the given configuration file using the mapper, falling back to the given resources.",
	"Method": "T loadFiles(Class<T> type,List<File> files,List<String> resources){\r\n    if (files == null) {\r\n        return loadResources(type, resources);\r\n    }\r\n    Config config = ConfigFactory.systemProperties();\r\n    for (File file : files) {\r\n        config = config.withFallback(ConfigFactory.parseFile(file, ConfigParseOptions.defaults().setAllowMissing(false)));\r\n    }\r\n    for (String resource : resources) {\r\n        config = config.withFallback(ConfigFactory.load(classLoader, resource));\r\n    }\r\n    return map(checkNotNull(config, \"config cannot be null\").resolve(), type);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.test.AtomicMapPerformanceTest.runIteration",
	"Comment": "runs a single performance test iteration, returning the iteration run time.",
	"Method": "long runIteration(){\r\n    reset();\r\n    createServers(3);\r\n    Atomix[] clients = new Atomix[NUM_CLIENTS];\r\n    for (int i = 0; i < NUM_CLIENTS; i++) {\r\n        clients[i] = createClient();\r\n    }\r\n    CompletableFuture<Void>[] futures = new CompletableFuture[NUM_MAPS];\r\n    AsyncAtomicMap<String, String>[] maps = new AsyncAtomicMap[NUM_MAPS];\r\n    for (int i = 0; i < NUM_MAPS; i++) {\r\n        maps[i] = createMap(clients[i % clients.length]);\r\n        futures[i] = new CompletableFuture();\r\n    }\r\n    long startTime = System.currentTimeMillis();\r\n    System.out.println(String.format(\"Starting test to perform %d operations with %d maps\", TOTAL_OPERATIONS, maps.length));\r\n    for (int i = 0; i < maps.length; i++) {\r\n        run(maps[i], futures[i]);\r\n    }\r\n    CompletableFuture.allOf(futures).join();\r\n    long endTime = System.currentTimeMillis();\r\n    long runTime = endTime - startTime;\r\n    System.out.println(String.format(\"readCount: %d/%d, writeCount: %d/%d, runTime: %dms\", readCount.get(), TOTAL_OPERATIONS, writeCount.get(), TOTAL_OPERATIONS, runTime));\r\n    return runTime;\r\n}"
}, {
	"Path": "org.axonframework.common.jdbc.JdbcUtilsTest.testNextAndExtract_NonNullValue",
	"Comment": "reads a value from the results set. the method should return the value thatwas read.",
	"Method": "void testNextAndExtract_NonNullValue(){\r\n    ResultSet resultSet = mock(ResultSet.class);\r\n    when(resultSet.next()).thenReturn(true);\r\n    when(resultSet.getObject(eq(1), eq(Long.class))).thenReturn(10L);\r\n    assertEquals(Long.valueOf(10L), JdbcUtils.nextAndExtract(resultSet, 1, Long.class));\r\n}"
}, {
	"Path": "org.axonframework.springboot.SerializerProperties.setGeneral",
	"Comment": "sets the type of serializer to use to serialize any type of object, for which no more specific serializer isconfigured. defaults to an xstream based serializer.",
	"Method": "void setGeneral(SerializerType serializerType){\r\n    this.general = serializerType;\r\n}"
}, {
	"Path": "io.atomix.utils.time.MultiValuedTimestampTest.testEquals",
	"Comment": "tests the equals, hashcode and tostring methods using guava equalstester.",
	"Method": "void testEquals(){\r\n    new EqualsTester().addEqualityGroup(stats1, stats1).addEqualityGroup(stats2).testEquals();\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.RaftSession.getResult",
	"Comment": "returns the session response for the given sequence number.",
	"Method": "OperationResult getResult(long sequence){\r\n    return results.get(sequence);\r\n}"
}, {
	"Path": "brave.http.HttpClientHandler.nextSpan",
	"Comment": "creates a potentially noop span representing this request. this is used when you need toprovision a span in a different scope than where the request is executed.",
	"Method": "Span nextSpan(Req request){\r\n    Sampler override = httpSampler.toSampler(adapter, request, sampler);\r\n    return tracer.withSampler(override).nextSpan();\r\n}"
}, {
	"Path": "org.awaitility.Awaitility.pollThread",
	"Comment": "specify a thread supplier whose thread will be used to evaluate the poll condition in awaitility.the supplier will be called only once and the thread it returns will be reused during all condition evaluations.this is an advanced feature and it should only be used sparingly.",
	"Method": "void pollThread(Function<Runnable, Thread> threadSupplier){\r\n    defaultExecutorLifecycle = ExecutorLifecycle.withNormalCleanupBehavior(new Supplier<ExecutorService>() {\r\n        @Override\r\n        public ExecutorService get() {\r\n            return InternalExecutorServiceFactory.create(threadSupplier);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.awaitility.Awaitility.pollThread",
	"Comment": "specify a thread supplier whose thread will be used to evaluate the poll condition in awaitility.the supplier will be called only once and the thread it returns will be reused during all condition evaluations.this is an advanced feature and it should only be used sparingly.",
	"Method": "void pollThread(Function<Runnable, Thread> threadSupplier){\r\n    return InternalExecutorServiceFactory.create(threadSupplier);\r\n}"
}, {
	"Path": "io.atomix.core.semaphore.impl.BlockingDistributedSemaphore.completeInterruptibly",
	"Comment": "use for complete acquire or tryacquire.if interrupt or timeout before the future completed, set needrelease to true.when the future completes, release these permits.",
	"Method": "T completeInterruptibly(CompletableFuture<T> future,int acquirePermits){\r\n    AtomicBoolean needRelease = new AtomicBoolean(false);\r\n    try {\r\n        return future.thenApply(value -> {\r\n            if (needRelease.get()) {\r\n                if (acquirePermits > 0) {\r\n                    asyncSemaphore.release(acquirePermits);\r\n                }\r\n            }\r\n            return value;\r\n        }).get(timeout.toMillis(), TimeUnit.MILLISECONDS);\r\n    } catch (InterruptedException | PrimitiveException.Interrupted e) {\r\n        needRelease.set(acquirePermits > 0);\r\n        throw e;\r\n    } catch (TimeoutException | PrimitiveException.Timeout e) {\r\n        needRelease.set(acquirePermits > 0);\r\n        throw new PrimitiveException.Timeout();\r\n    } catch (ExecutionException e) {\r\n        needRelease.set(acquirePermits > 0);\r\n        Throwable cause = Throwables.getRootCause(e);\r\n        if (cause instanceof PrimitiveException) {\r\n            throw (PrimitiveException) cause;\r\n        } else {\r\n            throw new PrimitiveException(cause);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.atomix.storage.journal.JournalSegmentDescriptor.maxEntries",
	"Comment": "returns the maximum number of entries allowed in the segment.",
	"Method": "int maxEntries(){\r\n    return maxEntries;\r\n}"
}, {
	"Path": "io.atomix.storage.journal.JournalSegment.isEmpty",
	"Comment": "returns a boolean value indicating whether the segment is empty.",
	"Method": "boolean isEmpty(){\r\n    return length() == 0;\r\n}"
}, {
	"Path": "io.atomix.core.semaphore.AtomicSemaphoreConfig.setInitialCapacity",
	"Comment": "initialize this semaphore with the given permit count.only the first initialization will be accepted.",
	"Method": "AtomicSemaphoreConfig setInitialCapacity(int permits){\r\n    initialCapacity = permits;\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.roles.LeaderRole.queryBoundedLinearizable",
	"Comment": "executes a bounded linearizable query.bounded linearizable queries succeed as long as this server remains the leader. this is possiblesince the leader will step down in the event it fails to contact a majority of the cluster.",
	"Method": "CompletableFuture<QueryResponse> queryBoundedLinearizable(Indexed<QueryEntry> entry){\r\n    return applyQuery(entry);\r\n}"
}, {
	"Path": "org.axonframework.axonserver.connector.event.axon.EventBuffer.registerCloseListener",
	"Comment": "registers the callback to invoke when the reader wishes to close the stream.",
	"Method": "void registerCloseListener(Consumer<EventBuffer> closeCallback){\r\n    this.closeCallback = closeCallback;\r\n}"
}, {
	"Path": "org.axonframework.messaging.annotation.AnnotatedHandlerInspector.getHandlers",
	"Comment": "returns a list of detected members of the inspected entity that are capable of handling certain messages.",
	"Method": "List<MessageHandlingMember<? super T>> getHandlers(){\r\n    return handlers;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.RaftSessionState.getCommandResponse",
	"Comment": "returns the last command sequence number for which a response has been received.",
	"Method": "long getCommandResponse(){\r\n    return commandResponse;\r\n}"
}, {
	"Path": "brave.propagation.B3SingleFormat.tryParseParentId",
	"Comment": "returns zero if truncated, malformed, or too big after logging",
	"Method": "long tryParseParentId(CharSequence b3,int pos,int endIndex){\r\n    if (endIndex < pos + 16) {\r\n        Platform.get().log(\"Invalid input: truncated\", null);\r\n        return 0L;\r\n    }\r\n    long parentId = tryParse16HexCharacters(b3, pos, endIndex);\r\n    if (parentId == 0L) {\r\n        Platform.get().log(\"Invalid input: expected a 16 lower hex parent ID at offset {0}\", pos, null);\r\n        return 0L;\r\n    }\r\n    pos += 16;\r\n    if (endIndex != pos) {\r\n        Platform.get().log(\"Invalid input: parent ID is too long\", null);\r\n        return 0L;\r\n    }\r\n    return parentId;\r\n}"
}, {
	"Path": "org.axonframework.messaging.unitofwork.DefaultUnitOfWork.startAndGet",
	"Comment": "starts a new defaultunitofwork instance, registering it a currentunitofwork. this methods returns the startedunitofwork instance.note that this unit of work type is not meant to be shared among different threads. a single defaultunitofworkinstance should be used exclusively by the thread that created it.",
	"Method": "DefaultUnitOfWork<T> startAndGet(T message){\r\n    DefaultUnitOfWork<T> uow = new DefaultUnitOfWork(message);\r\n    uow.start();\r\n    return uow;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.RaftTest.testEventsAfterFollowerKill",
	"Comment": "tests submitting a sequential event that publishes to all sessions.",
	"Method": "void testEventsAfterFollowerKill(int nodes){\r\n    List<RaftServer> servers = createServers(nodes);\r\n    RaftClient client = createClient();\r\n    TestPrimitive primitive = createPrimitive(client);\r\n    primitive.onEvent(event -> {\r\n        threadAssertNotNull(event);\r\n        resume();\r\n    });\r\n    for (int i = 0; i < 10; i++) {\r\n        primitive.sendEvent(true).thenRun(this::resume);\r\n        await(30000, 2);\r\n    }\r\n    primitive.sendEvent(true).thenRun(this::resume);\r\n    RaftServer follower = servers.stream().filter(s -> s.getRole() == RaftServer.Role.FOLLOWER).findFirst().get();\r\n    follower.shutdown().get(10, TimeUnit.SECONDS);\r\n    await(30000, 2);\r\n    for (int i = 0; i < 10; i++) {\r\n        primitive.sendEvent(true).thenRun(this::resume);\r\n        await(30000, 2);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.storage.snapshot.SnapshotFile.createSnapshotFile",
	"Comment": "creates a snapshot file for the given directory, log name, and snapshot index.",
	"Method": "File createSnapshotFile(File directory,String serverName,long index){\r\n    return new File(directory, createSnapshotFileName(serverName, index));\r\n}"
}, {
	"Path": "brave.test.http.ITHttpClient.propagates_sampledFalse",
	"Comment": "unlike brave 3, brave 4 propagates trace ids even when unsampled",
	"Method": "void propagates_sampledFalse(){\r\n    close();\r\n    httpTracing = HttpTracing.create(tracingBuilder(Sampler.NEVER_SAMPLE).build());\r\n    client = newClient(server.getPort());\r\n    server.enqueue(new MockResponse());\r\n    get(client, \"/foo\");\r\n    RecordedRequest request = server.takeRequest();\r\n    assertThat(request.getHeaders().toMultimap()).containsKeys(\"x-b3-traceId\", \"x-b3-spanId\").doesNotContainKey(\"x-b3-parentSpanId\").containsEntry(\"x-b3-sampled\", asList(\"0\"));\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.TrackingEventProcessor.getState",
	"Comment": "get the state of the event processor. this will indicate whether or not the processor has started or is shuttingdown.",
	"Method": "State getState(){\r\n    return state.get();\r\n}"
}, {
	"Path": "org.awaitility.core.ConditionFactory.pollThread",
	"Comment": "specify a thread supplier whose thread will be used to evaluate the poll condition in awaitility.the supplier will be called only once and the thread it returns will be reused during all condition evaluations.this is an advanced feature and it should only be used sparingly.",
	"Method": "ConditionFactory pollThread(Function<Runnable, Thread> threadSupplier){\r\n    return new ConditionFactory(alias, timeoutConstraint, pollInterval, pollDelay, false, exceptionsIgnorer, conditionEvaluationListener, ExecutorLifecycle.withNormalCleanupBehavior(new Supplier<ExecutorService>() {\r\n        @Override\r\n        public ExecutorService get() {\r\n            return InternalExecutorServiceFactory.create(threadSupplier);\r\n        }\r\n    }));\r\n}"
}, {
	"Path": "org.awaitility.core.ConditionFactory.pollThread",
	"Comment": "specify a thread supplier whose thread will be used to evaluate the poll condition in awaitility.the supplier will be called only once and the thread it returns will be reused during all condition evaluations.this is an advanced feature and it should only be used sparingly.",
	"Method": "ConditionFactory pollThread(Function<Runnable, Thread> threadSupplier){\r\n    return InternalExecutorServiceFactory.create(threadSupplier);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.storage.log.RaftLog.isCompactable",
	"Comment": "returns a boolean indicating whether a segment can be removed from the journal prior to the given index.",
	"Method": "boolean isCompactable(long index){\r\n    return journal.isCompactable(index);\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.EventMessageHandler.supportsReset",
	"Comment": "indicates whether the handlers managed by this invoker support a reset.",
	"Method": "boolean supportsReset(){\r\n    return true;\r\n}"
}, {
	"Path": "org.axonframework.serialization.AbstractXStreamSerializer.addAlias",
	"Comment": "adds an alias to use instead of the fully qualified class name.",
	"Method": "void addAlias(String name,Class type){\r\n    xStream.alias(name, type);\r\n}"
}, {
	"Path": "io.atomix.core.multimap.MultimapBuilder.withRegistrationRequired",
	"Comment": "sets whether registration is required for serializable types.",
	"Method": "B withRegistrationRequired(B withRegistrationRequired,boolean registrationRequired){\r\n    config.setRegistrationRequired(registrationRequired);\r\n    return (B) this;\r\n}"
}, {
	"Path": "org.axonframework.mongo.eventsourcing.eventstore.MongoTrackingToken.getTrackedEvents",
	"Comment": "gets tracked events. the key is the event identifier, and the value is the timestamp.",
	"Method": "Map<String, Long> getTrackedEvents(){\r\n    return Collections.unmodifiableMap(trackedEvents);\r\n}"
}, {
	"Path": "io.crossbar.autobahn.websocket.WebSocketWriter.sendPong",
	"Comment": "send websockets pong. normally, unsolicited pongs are not used,but pongs are only send in response to a ping from the peer.",
	"Method": "void sendPong(Pong message){\r\n    if (message.mPayload != null && message.mPayload.length > 125) {\r\n        throw new WebSocketException(\"pong payload exceeds 125 octets\");\r\n    }\r\n    sendFrame(10, true, message.mPayload);\r\n    LOGGER.d(\"WebSockets Pong Sent\");\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.roles.PassiveRole.checkPreviousEntry",
	"Comment": "checks the previous index of the given appendrequest, returning a boolean indicating whether to continuehandling the request.",
	"Method": "boolean checkPreviousEntry(AppendRequest request,CompletableFuture<AppendResponse> future){\r\n    RaftLogWriter writer = raft.getLogWriter();\r\n    RaftLogReader reader = raft.getLogReader();\r\n    if (request.prevLogTerm() != 0) {\r\n        Indexed<RaftLogEntry> lastEntry = writer.getLastEntry();\r\n        if (lastEntry != null) {\r\n            if (request.prevLogIndex() > lastEntry.index()) {\r\n                log.debug(\"Rejected {}: Previous index ({}) is greater than the local log's last index ({})\", request, request.prevLogIndex(), lastEntry.index());\r\n                return failAppend(lastEntry.index(), future);\r\n            }\r\n            if (request.prevLogIndex() < lastEntry.index()) {\r\n                if (reader.getNextIndex() != request.prevLogIndex()) {\r\n                    reader.reset(request.prevLogIndex());\r\n                }\r\n                if (!reader.hasNext()) {\r\n                    log.debug(\"Rejected {}: Previous entry does not exist in the local log\", request);\r\n                    return failAppend(lastEntry.index(), future);\r\n                }\r\n                Indexed<RaftLogEntry> previousEntry = reader.next();\r\n                if (request.prevLogTerm() != previousEntry.entry().term()) {\r\n                    log.debug(\"Rejected {}: Previous entry term ({}) does not match local log's term for the same entry ({})\", request, request.prevLogTerm(), previousEntry.entry().term());\r\n                    return failAppend(request.prevLogIndex() - 1, future);\r\n                }\r\n            } else if (request.prevLogTerm() != lastEntry.entry().term()) {\r\n                log.debug(\"Rejected {}: Previous entry term ({}) does not equal the local log's last term ({})\", request, request.prevLogTerm(), lastEntry.entry().term());\r\n                return failAppend(request.prevLogIndex() - 1, future);\r\n            }\r\n        } else {\r\n            if (request.prevLogIndex() > 0) {\r\n                log.debug(\"Rejected {}: Previous index ({}) is greater than the local log's last index (0)\", request, request.prevLogIndex());\r\n                return failAppend(0, future);\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "brave.test.http.ITHttpServer.notFound",
	"Comment": "if http route is supported, then the span name should include it",
	"Method": "void notFound(){\r\n    assertThat(call(\"GET\", \"/foo/bark\").code()).isEqualTo(404);\r\n    Span span = takeSpan();\r\n    // as 404 is an error\r\n    assertThat(span.tags()).hasSize(4).containsEntry(\"http.method\", \"GET\").containsEntry(\"http.path\", \"/foo/bark\").containsEntry(\"http.status_code\", \"404\").containsKey(\"error\");\r\n    String name = span.name();\r\n    if (name != null && !\"get\".equals(name)) {\r\n        assertThat(name).isEqualTo(\"get not_found\");\r\n    }\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.TrackingEventProcessorConfiguration.andTokenClaimInterval",
	"Comment": "sets the time to wait after a failed attempt to claim any token, before making another attempt.",
	"Method": "TrackingEventProcessorConfiguration andTokenClaimInterval(long tokenClaimInterval,TimeUnit timeUnit){\r\n    this.tokenClaimInterval = timeUnit.toMillis(tokenClaimInterval);\r\n    return this;\r\n}"
}, {
	"Path": "brave.grpc.TagContextBinaryMarshaller.sizeInBytes",
	"Comment": "like census, this currently assumes both key and value are ascii",
	"Method": "int sizeInBytes(Map<String, String> tagContext){\r\n    int sizeInBytes = 1;\r\n    for (Map.Entry<String, String> entry : tagContext.entrySet()) {\r\n        sizeInBytes++;\r\n        int keyLength = entry.getKey().length();\r\n        int valLength = entry.getValue().length();\r\n        if (keyLength > 16383 || valLength > 16383)\r\n            return sizeInBytes;\r\n        sizeInBytes += sizeOfLengthPrefixedString(keyLength);\r\n        sizeInBytes += sizeOfLengthPrefixedString(valLength);\r\n    }\r\n    return sizeInBytes;\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.inmemory.InMemoryEventStorageEngine.nextTrackingToken",
	"Comment": "returns the tracking token to use for the next event to be stored.",
	"Method": "GlobalSequenceTrackingToken nextTrackingToken(){\r\n    return events.isEmpty() ? new GlobalSequenceTrackingToken(0) : ((GlobalSequenceTrackingToken) events.lastKey()).next();\r\n}"
}, {
	"Path": "org.axonframework.config.DefaultConfigurer.defaultEventBus",
	"Comment": "provides the default eventbus implementation. subclasses may override this method to provide their own default.",
	"Method": "EventBus defaultEventBus(Configuration config){\r\n    return SimpleEventBus.builder().messageMonitor(config.messageMonitor(EventBus.class, \"eventBus\")).build();\r\n}"
}, {
	"Path": "io.atomix.core.map.impl.MapUpdate.map",
	"Comment": "transforms this instance into an instance of different parameterized types.",
	"Method": "MapUpdate<S, T> map(Function<K, S> keyMapper,Function<V, T> valueMapper){\r\n    return MapUpdate.<S, T>builder().withType(type).withKey(keyMapper.apply(key)).withValue(value == null ? null : valueMapper.apply(value)).withVersion(version).build();\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.tokenstore.jdbc.TokenSchema.processorNameColumn",
	"Comment": "returns the name of the column containing the name of the processor to which the token belongs.",
	"Method": "String processorNameColumn(){\r\n    return processorNameColumn;\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.conflictresolution.ConflictResolution.initialize",
	"Comment": "initialize conflict resolution in the context of the current unit of work dealing with a command on an eventsourced aggregate.",
	"Method": "void initialize(ConflictResolver conflictResolver){\r\n    Assert.state(CurrentUnitOfWork.isStarted(), () -> \"An active Unit of Work is required for conflict resolution\");\r\n    CurrentUnitOfWork.get().getOrComputeResource(CONFLICT_RESOLUTION_KEY, key -> conflictResolver);\r\n}"
}, {
	"Path": "org.axonframework.messaging.annotation.MultiHandlerDefinition.getDelegates",
	"Comment": "returns the delegates of this instance, in the order they are evaluated to resolve parameters.",
	"Method": "List<HandlerDefinition> getDelegates(){\r\n    return Collections.unmodifiableList(handlerDefinitions);\r\n}"
}, {
	"Path": "org.axonframework.config.Configuration.resourceInjector",
	"Comment": "returns the resourceinjector used to provide resources to saga instances.",
	"Method": "ResourceInjector resourceInjector(){\r\n    return getComponent(ResourceInjector.class, () -> NoResourceInjector.INSTANCE);\r\n}"
}, {
	"Path": "io.crossbar.autobahn.websocket.WebSocketReader.onTextMessage",
	"Comment": "websockets text message received, default notifies master.this will only be called when the option receivetextmessagesrawhas not been set.",
	"Method": "void onTextMessage(String payload){\r\n    notify(new TextMessage(payload));\r\n}"
}, {
	"Path": "org.axonframework.disruptor.commandhandling.BlacklistDetectingCallback.hasDelegate",
	"Comment": "indicates whether this callback has a delegate that needs to be notified of the command handling result",
	"Method": "boolean hasDelegate(){\r\n    return delegate != null;\r\n}"
}, {
	"Path": "io.atomix.storage.journal.SegmentedJournal.resetCurrentSegment",
	"Comment": "resets the current segment, creating a new segment if necessary.",
	"Method": "void resetCurrentSegment(){\r\n    JournalSegment<E> lastSegment = getLastSegment();\r\n    if (lastSegment != null) {\r\n        currentSegment = lastSegment;\r\n    } else {\r\n        JournalSegmentDescriptor descriptor = JournalSegmentDescriptor.builder().withId(1).withIndex(1).withMaxSegmentSize(maxSegmentSize).withMaxEntries(maxEntriesPerSegment).build();\r\n        currentSegment = createSegment(descriptor);\r\n        segments.put(1L, currentSegment);\r\n    }\r\n}"
}, {
	"Path": "brave.grpc.GrpcParser.spanName",
	"Comment": "returns the span name of the request. defaults to the full grpc method name.",
	"Method": "String spanName(MethodDescriptor<ReqT, RespT> methodDescriptor){\r\n    return methodDescriptor.getFullMethodName();\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.storage.snapshot.SnapshotDescriptor.isLocked",
	"Comment": "returns whether the snapshot has been locked by commitment.a snapshot will be locked once it has been fully written.",
	"Method": "boolean isLocked(){\r\n    return locked;\r\n}"
}, {
	"Path": "io.atomix.storage.journal.SegmentedJournal.maxEntriesPerSegment",
	"Comment": "returns the maximum number of entries per segment.the maximum entries per segment dictates the maximum number of entries that are allowed to be stored in any segmentin a journal.",
	"Method": "int maxEntriesPerSegment(){\r\n    return maxEntriesPerSegment;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.protocol.OperationResponse.lastSequenceNumber",
	"Comment": "returns the last in sequence command.this argument is only populated if the command request failed.",
	"Method": "long lastSequenceNumber(){\r\n    return lastSequence;\r\n}"
}, {
	"Path": "org.axonframework.spring.config.AbstractAnnotationHandlerBeanPostProcessor.setParameterResolverFactory",
	"Comment": "sets the parameterresolverfactory to create the parameter resolvers with that provide the parameter values forthe handler methods.",
	"Method": "void setParameterResolverFactory(ParameterResolverFactory parameterResolverFactory){\r\n    this.parameterResolverFactory = parameterResolverFactory;\r\n}"
}, {
	"Path": "org.axonframework.spring.eventhandling.scheduling.java.SimpleEventSchedulerFactoryBean.setTransactionManager",
	"Comment": "sets the transaction manager that manages the transaction around the publication of an event. if a transactionmanager is not specified, no transactions are managed around the event publication.",
	"Method": "void setTransactionManager(PlatformTransactionManager transactionManager){\r\n    this.transactionManager = transactionManager;\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.AbstractEventStorageEngine.handlePersistenceException",
	"Comment": "invoke when an exception is raised while persisting an event or snapshot.",
	"Method": "void handlePersistenceException(Exception exception,EventMessage<?> failedEvent){\r\n    String eventDescription;\r\n    if (failedEvent instanceof DomainEventMessage<?>) {\r\n        DomainEventMessage<?> failedDomainEvent = (DomainEventMessage<?>) failedEvent;\r\n        eventDescription = format(\"An event for aggregate [%s] at sequence [%d]\", failedDomainEvent.getAggregateIdentifier(), failedDomainEvent.getSequenceNumber());\r\n    } else {\r\n        eventDescription = format(\"An event with identifier [%s]\", failedEvent.getIdentifier());\r\n    }\r\n    if (persistenceExceptionResolver != null && persistenceExceptionResolver.isDuplicateKeyViolation(exception)) {\r\n        throw new ConcurrencyException(eventDescription + \" was already inserted\", exception);\r\n    } else {\r\n        throw new EventStoreException(eventDescription + \" could not be persisted\", exception);\r\n    }\r\n}"
}, {
	"Path": "brave.jms.JmsTracing.messageListener",
	"Comment": "returns a message listener that optionally starts a consumer span for the message receivedbefore wrapping the listener in a separate span.",
	"Method": "MessageListener messageListener(MessageListener messageListener,boolean addConsumerSpan){\r\n    if (messageListener instanceof TracingMessageListener)\r\n        return messageListener;\r\n    return new TracingMessageListener(messageListener, this, addConsumerSpan);\r\n}"
}, {
	"Path": "org.axonframework.springboot.SerializerProperties.getEvents",
	"Comment": "the type of serializer to use to serialize the payload and meta data of event messages. defaults to the messageserializer, or otherwise the general serializer.",
	"Method": "SerializerType getEvents(){\r\n    return events;\r\n}"
}, {
	"Path": "io.atomix.core.map.AtomicMapEvent.oldValue",
	"Comment": "returns the value associated with the key, before it was updated.",
	"Method": "Versioned<V> oldValue(){\r\n    return oldValue;\r\n}"
}, {
	"Path": "io.atomix.cluster.protocol.HeartbeatMembershipProtocolBuilder.withFailureTimeout",
	"Comment": "sets the failure timeout to use prior to phi failure detectors being populated.",
	"Method": "HeartbeatMembershipProtocolBuilder withFailureTimeout(Duration failureTimeout){\r\n    config.setFailureTimeout(failureTimeout);\r\n    return this;\r\n}"
}, {
	"Path": "org.axonframework.common.IdentifierValidator.getInstance",
	"Comment": "returns the singleton instance of the identifiervalidator.",
	"Method": "IdentifierValidator getInstance(){\r\n    return INSTANCE;\r\n}"
}, {
	"Path": "brave.features.advanced.CustomScopedClockTracingTest.customClock",
	"Comment": "here, we speculatively start a trace based on a connection, which is abandoned of there are noqueries. as each query will be in a separate trace, we need to manually control timestamps.this allows alignment of timestamps at microsecond granularity, but still expire when theconnection does.",
	"Method": "void customClock(){\r\n    class TracedConnection extends Connection {\r\n        final brave.Span span;\r\n        final brave.Clock clock;\r\n        TracedConnection() {\r\n            span = tracing.tracer().nextSpan().name(\"connection\").start().tag(\"connection.id\", id.toString());\r\n            clock = tracing.clock(span.context());\r\n        }\r\n        @Override\r\n        void destroy() {\r\n            if (!used) {\r\n                span.abandon();\r\n            } else {\r\n                span.finish();\r\n            }\r\n        }\r\n    }\r\n    class TracedQuery extends Query {\r\n        final Clock clock;\r\n        TracedQuery(TracedConnection connection) {\r\n            super(connection);\r\n            clock = connection.clock;\r\n        }\r\n        @Override\r\n        void execute() {\r\n            brave.Span span = tracing.tracer().nextSpan().name(\"query\").tag(\"connection.id\", connection.id.toString()).start(clock.currentTimeMicroseconds());\r\n            super.execute();\r\n            span.finish(clock.currentTimeMicroseconds());\r\n        }\r\n    }\r\n    TracedConnection connection = new TracedConnection();\r\n    new TracedQuery(connection);\r\n    connection.destroy();\r\n    assertThat(spans).isEmpty();\r\n    TracedConnection connection2 = new TracedConnection();\r\n    new TracedQuery(connection2).execute();\r\n    new TracedQuery(connection2).execute();\r\n    connection2.destroy();\r\n    // we expect to be able to correlate all traces by the connection ID\r\n    assertThat(spans).hasSize(3).allSatisfy(s -> assertThat(s.tags()).containsEntry(\"connection.id\", connection2.id.toString()));\r\n}"
}, {
	"Path": "brave.features.advanced.CustomScopedClockTracingTest.customClock",
	"Comment": "here, we speculatively start a trace based on a connection, which is abandoned of there are noqueries. as each query will be in a separate trace, we need to manually control timestamps.this allows alignment of timestamps at microsecond granularity, but still expire when theconnection does.",
	"Method": "void customClock(){\r\n    if (!used) {\r\n        span.abandon();\r\n    } else {\r\n        span.finish();\r\n    }\r\n}"
}, {
	"Path": "brave.features.advanced.CustomScopedClockTracingTest.customClock",
	"Comment": "here, we speculatively start a trace based on a connection, which is abandoned of there are noqueries. as each query will be in a separate trace, we need to manually control timestamps.this allows alignment of timestamps at microsecond granularity, but still expire when theconnection does.",
	"Method": "void customClock(){\r\n    brave.Span span = tracing.tracer().nextSpan().name(\"query\").tag(\"connection.id\", connection.id.toString()).start(clock.currentTimeMicroseconds());\r\n    super.execute();\r\n    span.finish(clock.currentTimeMicroseconds());\r\n}"
}, {
	"Path": "org.axonframework.disruptor.commandhandling.CommandHandlingEntry.getPublisherId",
	"Comment": "returns the identifier of the publisher that is chosen to handle this entry.",
	"Method": "int getPublisherId(){\r\n    return publisherSegmentId;\r\n}"
}, {
	"Path": "io.atomix.utils.time.Timestamp.isNewerThan",
	"Comment": "tests if this timestamp is newer than the specified timestamp.",
	"Method": "boolean isNewerThan(Timestamp other){\r\n    return this.compareTo(Preconditions.checkNotNull(other)) > 0;\r\n}"
}, {
	"Path": "io.atomix.rest.resources.LeaderElectionResource.consumeNextEvent",
	"Comment": "recursively consumes events from the given event log until the next event for the given id is located.",
	"Method": "void consumeNextEvent(EventLog<LeadershipEventListener<String>, LeadershipEvent<String>> eventLog,String name,String id,AsyncResponse response){\r\n    eventLog.nextEvent().whenComplete((event, error) -> {\r\n        if (error == null) {\r\n            if (event.newLeadership().leader() != null && event.newLeadership().leader().id().equals(id)) {\r\n                response.resume(Response.ok(new LeadershipResponse(event.newLeadership())).build());\r\n            } else if (event.newLeadership().candidates().stream().noneMatch(c -> c.equals(id))) {\r\n                getPrimitive(name).thenCompose(election -> election.removeListener(eventLog.listener())).whenComplete((removeResult, removeError) -> {\r\n                    response.resume(Response.status(Status.NOT_FOUND).build());\r\n                });\r\n            }\r\n        } else {\r\n            response.resume(Response.status(Status.NOT_FOUND).build());\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.atomix.storage.journal.SegmentedJournal.assertDiskSpace",
	"Comment": "asserts that enough disk space is available to allocate a new segment.",
	"Method": "void assertDiskSpace(){\r\n    if (directory().getUsableSpace() < maxSegmentSize() * SEGMENT_BUFFER_FACTOR) {\r\n        throw new StorageException.OutOfDiskSpace(\"Not enough space to allocate a new journal segment\");\r\n    }\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.gateway.AbstractCommandGateway.processInterceptors",
	"Comment": "invokes all the dispatch interceptors and returns the commandmessage instance that should be dispatched.",
	"Method": "CommandMessage<? extends C> processInterceptors(CommandMessage<C> commandMessage){\r\n    CommandMessage<? extends C> message = commandMessage;\r\n    for (MessageDispatchInterceptor<? super CommandMessage<?>> dispatchInterceptor : dispatchInterceptors) {\r\n        message = (CommandMessage) dispatchInterceptor.handle(message);\r\n    }\r\n    return message;\r\n}"
}, {
	"Path": "io.crossbar.autobahn.wamp.types.TransportOptions.getMaxFramePayloadSize",
	"Comment": "get maximum frame payload size that will be acceptedwhen receiving.",
	"Method": "int getMaxFramePayloadSize(){\r\n    return mMaxFramePayloadSize;\r\n}"
}, {
	"Path": "brave.TracerTest.newChild_isntShared",
	"Comment": "a child span is not sharing a span id with its parent by definition",
	"Method": "void newChild_isntShared(){\r\n    TraceContext parent = tracer.newTrace().context();\r\n    assertThat(tracer.newChild(parent).context().shared()).isFalse();\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.storage.snapshot.SnapshotDescriptor.builder",
	"Comment": "returns a descriptor builder for the given descriptor buffer.",
	"Method": "Builder builder(Builder builder,Buffer buffer){\r\n    return new Builder(buffer);\r\n}"
}, {
	"Path": "org.axonframework.springboot.EventProcessorProperties.getProcessors",
	"Comment": "returns the settings for each of the configured processors, by name.",
	"Method": "Map<String, ProcessorSettings> getProcessors(){\r\n    return processors;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.RaftSessionSequencerTest.testSequenceEventAfterAllCommands",
	"Comment": "tests sequencing an event that arrives before a command response.",
	"Method": "void testSequenceEventAfterAllCommands(){\r\n    RaftSessionSequencer sequencer = new RaftSessionSequencer(new RaftSessionState(\"test\", SessionId.from(1), UUID.randomUUID().toString(), TestPrimitiveType.instance(), 1000));\r\n    long sequence = sequencer.nextRequest();\r\n    PublishRequest request1 = PublishRequest.builder().withSession(1).withEventIndex(2).withPreviousIndex(0).withEvents(Collections.emptyList()).build();\r\n    PublishRequest request2 = PublishRequest.builder().withSession(1).withEventIndex(3).withPreviousIndex(2).withEvents(Collections.emptyList()).build();\r\n    CommandResponse response = CommandResponse.builder().withStatus(RaftResponse.Status.OK).withIndex(2).withEventIndex(2).build();\r\n    AtomicInteger run = new AtomicInteger();\r\n    sequencer.sequenceEvent(request1, () -> assertEquals(0, run.getAndIncrement()));\r\n    sequencer.sequenceEvent(request2, () -> assertEquals(2, run.getAndIncrement()));\r\n    sequencer.sequenceResponse(sequence, response, () -> assertEquals(1, run.getAndIncrement()));\r\n    assertEquals(3, run.get());\r\n}"
}, {
	"Path": "io.atomix.storage.buffer.HeapBuffer.wrap",
	"Comment": "wraps the given bytes in a heap buffer.the buffer will be created with an initial capacity and maximum capacity equal to the byte array count.",
	"Method": "HeapBuffer wrap(byte[] bytes){\r\n    return new HeapBuffer(HeapBytes.wrap(bytes), 0, bytes.length, bytes.length);\r\n}"
}, {
	"Path": "org.axonframework.test.matchers.Matchers.equalTo",
	"Comment": "matches against each event of the same runtime type that has all field values equal to the fields in theexpectedevent. all fields are compared, except for the aggregate identifier and sequence number, as they are generallynot set on the expected event.",
	"Method": "EqualFieldsMatcher<T> equalTo(T expected,EqualFieldsMatcher<T> equalTo,T expected,FieldFilter filter){\r\n    return new EqualFieldsMatcher(expected, filter);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.roles.LeaderRole.startAppendTimer",
	"Comment": "starts sending appendentries requests to all cluster members.",
	"Method": "void startAppendTimer(){\r\n    log.trace(\"Starting append timer\");\r\n    appendTimer = raft.getThreadContext().schedule(Duration.ZERO, raft.getHeartbeatInterval(), this::appendMembers);\r\n}"
}, {
	"Path": "io.atomix.cluster.AtomixClusterBuilder.withBroadcastInterval",
	"Comment": "sets the reachability broadcast interval.the broadcast interval is the interval at which heartbeats are sent to peers in the cluster.",
	"Method": "AtomixClusterBuilder withBroadcastInterval(Duration interval){\r\n    GroupMembershipProtocolConfig protocolConfig = config.getProtocolConfig();\r\n    if (protocolConfig instanceof HeartbeatMembershipProtocolConfig) {\r\n        ((HeartbeatMembershipProtocolConfig) protocolConfig).setHeartbeatInterval(interval);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.core.collection.DistributedCollectionConfig.isRegistrationRequired",
	"Comment": "returns whether registration is required for serializable types.",
	"Method": "boolean isRegistrationRequired(){\r\n    return registrationRequired;\r\n}"
}, {
	"Path": "org.axonframework.messaging.StreamableMessageSource.createHeadToken",
	"Comment": "creates the token at the end of an event stream. the end of an event stream in this context means the token ofvery last event in the stream.",
	"Method": "TrackingToken createHeadToken(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.ReplyMessage.getCommandIdentifier",
	"Comment": "returns the identifier of the command for which this message is a reply.",
	"Method": "String getCommandIdentifier(){\r\n    return commandIdentifier;\r\n}"
}, {
	"Path": "io.atomix.cluster.AtomixClusterBuilder.withTrustStorePassword",
	"Comment": "sets the trust store password for the atomix messaging service.",
	"Method": "AtomixClusterBuilder withTrustStorePassword(String trustStorePassword){\r\n    config.getMessagingConfig().getTlsConfig().setTrustStorePassword(trustStorePassword);\r\n    return this;\r\n}"
}, {
	"Path": "org.axonframework.config.MessageMonitorFactoryBuilder.getFactoryForType",
	"Comment": "iterates through the keys in the given map, and returns the factory associated with the type that matches thegiven type, or null if no key matches. the given type matches a key if the given type is assignable to the key.if multiple keys match, and the matching classes derive from each other, the factory associated with the mostderived class is returned. if the matching classes do not derive from each other, the result is unspecified.",
	"Method": "MessageMonitorFactory getFactoryForType(SortedMap<Class<?>, MessageMonitorFactory> map,Class<?> type){\r\n    if (map == null) {\r\n        return null;\r\n    }\r\n    Class<?> match = null;\r\n    for (Class<?> key : map.keySet()) {\r\n        if (key.isAssignableFrom(type)) {\r\n            if (match != null) {\r\n                if (match.isAssignableFrom(key)) {\r\n                    match = key;\r\n                }\r\n            } else {\r\n                match = key;\r\n            }\r\n        }\r\n    }\r\n    if (match == null) {\r\n        return null;\r\n    }\r\n    return map.get(match);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.RaftSessionState.setResponseIndex",
	"Comment": "sets the highest index for which a response has been received.",
	"Method": "void setResponseIndex(long responseIndex){\r\n    this.responseIndex = Math.max(this.responseIndex, responseIndex);\r\n}"
}, {
	"Path": "org.axonframework.messaging.unitofwork.BatchingUnitOfWork.isLastMessage",
	"Comment": "checks if the message being processed now is the last of the batch being processed in this unit of work.",
	"Method": "boolean isLastMessage(Message<?> message,boolean isLastMessage){\r\n    return isLastMessage(getMessage());\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.roles.AbstractAppender.buildAppendEmptyRequest",
	"Comment": "builds an empty appendentries request.empty append requests are used as heartbeats to followers.",
	"Method": "AppendRequest buildAppendEmptyRequest(RaftMemberContext member){\r\n    final RaftLogReader reader = member.getLogReader();\r\n    Indexed<RaftLogEntry> prevEntry = reader != null ? reader.getCurrentEntry() : null;\r\n    DefaultRaftMember leader = raft.getLeader();\r\n    return AppendRequest.builder().withTerm(raft.getTerm()).withLeader(leader != null ? leader.memberId() : null).withPrevLogIndex(prevEntry != null ? prevEntry.index() : reader != null ? reader.getFirstIndex() - 1 : 0).withPrevLogTerm(prevEntry != null ? prevEntry.entry().term() : 0).withEntries(Collections.emptyList()).withCommitIndex(raft.getCommitIndex()).build();\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.RaftTest.testSubmitQuery",
	"Comment": "tests submitting a query with a configured consistency level.",
	"Method": "void testSubmitQuery(int nodes,ReadConsistency consistency){\r\n    createServers(nodes);\r\n    RaftClient client = createClient();\r\n    TestPrimitive primitive = createPrimitive(client, consistency);\r\n    primitive.read().thenRun(this::resume);\r\n    await(30000);\r\n}"
}, {
	"Path": "io.atomix.core.semaphore.impl.AtomicSemaphoreServiceConfig.setInitialCapacity",
	"Comment": "initialize this semaphore with the given permit count.only the first initialization will be accepted.",
	"Method": "AtomicSemaphoreServiceConfig setInitialCapacity(int permits){\r\n    initialCapacity = permits;\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.RaftSessionSequencerTest.testSequenceEventAfterCommand",
	"Comment": "tests sequencing an event that arrives before a command response.",
	"Method": "void testSequenceEventAfterCommand(){\r\n    RaftSessionSequencer sequencer = new RaftSessionSequencer(new RaftSessionState(\"test\", SessionId.from(1), UUID.randomUUID().toString(), TestPrimitiveType.instance(), 1000));\r\n    long sequence = sequencer.nextRequest();\r\n    PublishRequest request = PublishRequest.builder().withSession(1).withEventIndex(1).withPreviousIndex(0).withEvents(Collections.emptyList()).build();\r\n    CommandResponse response = CommandResponse.builder().withStatus(RaftResponse.Status.OK).withIndex(2).withEventIndex(1).build();\r\n    AtomicInteger run = new AtomicInteger();\r\n    sequencer.sequenceResponse(sequence, response, () -> assertEquals(0, run.getAndIncrement()));\r\n    sequencer.sequenceEvent(request, () -> assertEquals(1, run.getAndIncrement()));\r\n    assertEquals(2, run.get());\r\n}"
}, {
	"Path": "brave.kafka.clients.TracingConsumer.poll",
	"Comment": "this uses a single timestamp for all records polled, to reduce overhead.",
	"Method": "ConsumerRecords<K, V> poll(Duration timeout,ConsumerRecords<K, V> poll,long timeout){\r\n    ConsumerRecords<K, V> records = delegate.poll(timeout);\r\n    if (records.isEmpty() || tracing.isNoop())\r\n        return records;\r\n    long timestamp = 0L;\r\n    Map<String, Span> consumerSpansForTopic = new LinkedHashMap();\r\n    for (TopicPartition partition : records.partitions()) {\r\n        String topic = partition.topic();\r\n        List<ConsumerRecord<K, V>> recordsInPartition = records.records(partition);\r\n        for (int i = 0, length = recordsInPartition.size(); i < length; i++) {\r\n            ConsumerRecord<K, V> record = recordsInPartition.get(i);\r\n            TraceContextOrSamplingFlags extracted = kafkaTracing.extractAndClearHeaders(record.headers());\r\n            if (extracted.samplingFlags() != null && extracted.extra().isEmpty()) {\r\n                Span span = consumerSpansForTopic.get(topic);\r\n                if (span == null) {\r\n                    span = tracing.tracer().nextSpan(extracted);\r\n                    if (!span.isNoop()) {\r\n                        setConsumerSpan(topic, span);\r\n                        if (timestamp == 0L) {\r\n                            timestamp = tracing.clock(span.context()).currentTimeMicroseconds();\r\n                        }\r\n                        span.start(timestamp);\r\n                    }\r\n                    consumerSpansForTopic.put(topic, span);\r\n                }\r\n                injector.inject(span.context(), record.headers());\r\n            } else {\r\n                Span span = tracing.tracer().nextSpan(extracted);\r\n                if (!span.isNoop()) {\r\n                    setConsumerSpan(topic, span);\r\n                    if (timestamp == 0L) {\r\n                        timestamp = tracing.clock(span.context()).currentTimeMicroseconds();\r\n                    }\r\n                    span.start(timestamp).finish(timestamp);\r\n                }\r\n                injector.inject(span.context(), record.headers());\r\n            }\r\n        }\r\n    }\r\n    for (Span span : consumerSpansForTopic.values()) span.finish(timestamp);\r\n    return records;\r\n}"
}, {
	"Path": "io.atomix.core.collection.AsyncDistributedCollection.addListener",
	"Comment": "registers the specified listener to be notified wheneverthe collection is updated.",
	"Method": "CompletableFuture<Void> addListener(CollectionEventListener<E> listener,CompletableFuture<Void> addListener,CollectionEventListener<E> listener,Executor executor){\r\n    return addListener(listener, MoreExecutors.directExecutor());\r\n}"
}, {
	"Path": "io.atomix.storage.journal.SegmentedJournal.isCompactable",
	"Comment": "returns a boolean indicating whether a segment can be removed from the journal prior to the given index.",
	"Method": "boolean isCompactable(long index){\r\n    Map.Entry<Long, JournalSegment<E>> segmentEntry = segments.floorEntry(index);\r\n    return segmentEntry != null && segments.headMap(segmentEntry.getValue().index()).size() > 0;\r\n}"
}, {
	"Path": "org.awaitility.core.ConditionFactory.given",
	"Comment": "a method to increase the readability of the awaitility dsl. it simplyreturns the same condition factory instance.",
	"Method": "ConditionFactory given(){\r\n    return this;\r\n}"
}, {
	"Path": "org.axonframework.disruptor.commandhandling.CommandHandlingEntry.getCallback",
	"Comment": "returns the commandcallback instance for the executed command.",
	"Method": "BlacklistDetectingCallback getCallback(){\r\n    return callback;\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.jdbc.JdbcEventStorageEngine.readSnapshotData",
	"Comment": "creates a statement to read the snapshot entry of an aggregate with given identifier.",
	"Method": "Stream<? extends DomainEventData<?>> readSnapshotData(String aggregateIdentifier,PreparedStatement readSnapshotData,Connection connection,String identifier){\r\n    final String s = \"SELECT \" + domainEventFields() + \" FROM \" + schema.snapshotTable() + \" WHERE \" + schema.aggregateIdentifierColumn() + \" = ? ORDER BY \" + schema.sequenceNumberColumn() + \" DESC\";\r\n    PreparedStatement statement = connection.prepareStatement(s);\r\n    statement.setString(1, identifier);\r\n    return statement;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.protocol.AppendResponse.succeeded",
	"Comment": "returns a boolean indicating whether the append was successful.",
	"Method": "boolean succeeded(){\r\n    return succeeded;\r\n}"
}, {
	"Path": "brave.propagation.ExtraFieldPropagation.newFactory",
	"Comment": "wraps an underlying propagation implementation, pushing one or more fields",
	"Method": "Factory newFactory(Propagation.Factory delegate,String fieldNames,Factory newFactory,Propagation.Factory delegate,Collection<String> fieldNames){\r\n    if (delegate == null)\r\n        throw new NullPointerException(\"delegate == null\");\r\n    if (fieldNames == null)\r\n        throw new NullPointerException(\"fieldNames == null\");\r\n    String[] validated = ensureLowerCase(fieldNames);\r\n    return new Factory(delegate, validated, validated);\r\n}"
}, {
	"Path": "brave.context.rxjava2.internal.TraceContextCallableObservable.subscribeActual",
	"Comment": "wraps the observer so that its callbacks run in the assembly context. this does not affect anysubscription callbacks.",
	"Method": "void subscribeActual(Observer<? super T> o){\r\n    source.subscribe(Wrappers.wrap(o, contextScoper, assembled));\r\n}"
}, {
	"Path": "brave.grpc.GrpcServerParser.onStart",
	"Comment": "override the customize the span based on the start of a request.",
	"Method": "void onStart(ServerCall<ReqT, RespT> call,Metadata headers,SpanCustomizer span){\r\n    span.name(spanName(call.getMethodDescriptor()));\r\n}"
}, {
	"Path": "io.atomix.core.tree.impl.NodeUpdate.version",
	"Comment": "returns the expected current version in the database for the key.",
	"Method": "long version(){\r\n    return version;\r\n}"
}, {
	"Path": "io.atomix.core.tree.impl.DefaultDocumentTreeService.isLocked",
	"Comment": "returns a boolean indicating whether the given path is currently locked by a transaction.",
	"Method": "boolean isLocked(DocumentPath path){\r\n    return preparedKeys.contains(path);\r\n}"
}, {
	"Path": "io.atomix.primitive.partition.impl.DefaultPartitionGroupMembershipService.bootstrap",
	"Comment": "recursively bootstraps the service, retrying if necessary until a system partition group is found.",
	"Method": "CompletableFuture<Void> bootstrap(CompletableFuture<Void> bootstrap,int attempt,CompletableFuture<Void> future,CompletableFuture<Void> bootstrap,Member member,CompletableFuture<Void> bootstrap,Member member,CompletableFuture<Void> future){\r\n    LOGGER.debug(\"{} - Bootstrapping from member {}\", membershipService.getLocalMember().id(), member);\r\n    messagingService.<PartitionGroupInfo, PartitionGroupInfo>send(BOOTSTRAP_SUBJECT, new PartitionGroupInfo(membershipService.getLocalMember().id(), systemGroup, Lists.newArrayList(groups.values())), serializer::encode, serializer::decode, member.id()).whenCompleteAsync((info, error) -> {\r\n        if (error == null) {\r\n            try {\r\n                updatePartitionGroups(info);\r\n                future.complete(null);\r\n            } catch (Exception e) {\r\n                future.completeExceptionally(e);\r\n            }\r\n        } else {\r\n            error = Throwables.getRootCause(error);\r\n            if (error instanceof MessagingException.NoRemoteHandler || error instanceof TimeoutException) {\r\n                threadContext.schedule(Duration.ofSeconds(1), () -> bootstrap(member, future));\r\n            } else {\r\n                LOGGER.debug(\"{} - Failed to bootstrap from member {}\", membershipService.getLocalMember().id(), member, error);\r\n                future.complete(null);\r\n            }\r\n        }\r\n    }, threadContext);\r\n    return future;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.service.RaftServiceContext.sequenceCommand",
	"Comment": "loads and returns a cached command result according to the sequence number.",
	"Method": "OperationResult sequenceCommand(long index,long sequence,RaftSession session){\r\n    OperationResult result = session.getResult(sequence);\r\n    if (result == null) {\r\n        log.debug(\"Missing command result at index {}\", index);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.atomix.utils.event.EventFilter.isRelevant",
	"Comment": "indicates whether the specified event is of interest or not.default implementation always returns true.",
	"Method": "boolean isRelevant(E event){\r\n    return true;\r\n}"
}, {
	"Path": "io.atomix.utils.concurrent.AbstractAccumulator.maxIdleMillis",
	"Comment": "returns the maximum number of millis allowed to expire since the lastitem arrival before processing is triggered.",
	"Method": "int maxIdleMillis(){\r\n    return maxIdleMillis;\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.DispatchMessage.getSerializedMetaData",
	"Comment": "returns the serialized metadata of the command carried by this instance.",
	"Method": "byte[] getSerializedMetaData(){\r\n    return serializedMetaData;\r\n}"
}, {
	"Path": "io.atomix.core.map.MapConfig.isRegistrationRequired",
	"Comment": "returns whether registration is required for serializable types.",
	"Method": "boolean isRegistrationRequired(){\r\n    return registrationRequired;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.impl.RaftContext.isLeader",
	"Comment": "returns a boolean indicating whether this server is the current leader.",
	"Method": "boolean isLeader(){\r\n    MemberId leader = this.leader;\r\n    return leader != null && leader.equals(cluster.getMember().memberId());\r\n}"
}, {
	"Path": "org.axonframework.messaging.annotation.MultiHandlerEnhancerDefinition.getDelegates",
	"Comment": "returns the delegates of this instance, in the order they are evaluated to resolve parameters.",
	"Method": "List<HandlerEnhancerDefinition> getDelegates(){\r\n    return Arrays.asList(enhancers);\r\n}"
}, {
	"Path": "org.axonframework.modelling.command.LockingRepository.doLoad",
	"Comment": "perform the actual loading of an aggregate. the necessary locks have been obtained.",
	"Method": "LockAwareAggregate<T, A> doLoad(String aggregateIdentifier,Long expectedVersion){\r\n    Lock lock = lockFactory.obtainLock(aggregateIdentifier);\r\n    try {\r\n        final A aggregate = doLoadWithLock(aggregateIdentifier, expectedVersion);\r\n        CurrentUnitOfWork.get().onCleanup(u -> lock.release());\r\n        return new LockAwareAggregate(aggregate, lock);\r\n    } catch (Throwable ex) {\r\n        logger.debug(\"Exception occurred while trying to load an aggregate. Releasing lock.\", ex);\r\n        lock.release();\r\n        throw ex;\r\n    }\r\n}"
}, {
	"Path": "io.atomix.primitive.partition.PartitionGroupConfig.getDefaultPartitions",
	"Comment": "returns the default number of partitions.partition group configurations should override this method to provide a default number of partitions.",
	"Method": "int getDefaultPartitions(){\r\n    return 1;\r\n}"
}, {
	"Path": "io.atomix.cluster.messaging.impl.ChannelPool.getChannel",
	"Comment": "gets or creates a pooled channel to the given address for the given message type.",
	"Method": "CompletableFuture<Channel> getChannel(Address address,String messageType){\r\n    List<CompletableFuture<Channel>> channelPool = getChannelPool(address);\r\n    int offset = getChannelOffset(messageType);\r\n    CompletableFuture<Channel> channelFuture = channelPool.get(offset);\r\n    if (channelFuture == null || channelFuture.isCompletedExceptionally()) {\r\n        synchronized (channelPool) {\r\n            channelFuture = channelPool.get(offset);\r\n            if (channelFuture == null || channelFuture.isCompletedExceptionally()) {\r\n                LOGGER.debug(\"Connecting to {}\", address);\r\n                channelFuture = factory.apply(address);\r\n                channelFuture.whenComplete((channel, error) -> {\r\n                    if (error == null) {\r\n                        LOGGER.debug(\"Connected to {}\", channel.remoteAddress());\r\n                    } else {\r\n                        LOGGER.debug(\"Failed to connect to {}\", address, error);\r\n                    }\r\n                });\r\n                channelPool.set(offset, channelFuture);\r\n            }\r\n        }\r\n    }\r\n    final CompletableFuture<Channel> future = new CompletableFuture();\r\n    final CompletableFuture<Channel> finalFuture = channelFuture;\r\n    finalFuture.whenComplete((channel, error) -> {\r\n        if (error == null) {\r\n            if (!channel.isActive()) {\r\n                CompletableFuture<Channel> currentFuture;\r\n                synchronized (channelPool) {\r\n                    currentFuture = channelPool.get(offset);\r\n                    if (currentFuture == finalFuture) {\r\n                        channelPool.set(offset, null);\r\n                    } else if (currentFuture == null) {\r\n                        currentFuture = factory.apply(address);\r\n                        currentFuture.whenComplete((c, e) -> {\r\n                            if (e == null) {\r\n                                LOGGER.debug(\"Connected to {}\", channel.remoteAddress());\r\n                            } else {\r\n                                LOGGER.debug(\"Failed to connect to {}\", channel.remoteAddress(), e);\r\n                            }\r\n                        });\r\n                        channelPool.set(offset, currentFuture);\r\n                    }\r\n                }\r\n                if (currentFuture == finalFuture) {\r\n                    getChannel(address, messageType).whenComplete((recursiveResult, recursiveError) -> {\r\n                        if (recursiveError == null) {\r\n                            future.complete(recursiveResult);\r\n                        } else {\r\n                            future.completeExceptionally(recursiveError);\r\n                        }\r\n                    });\r\n                } else {\r\n                    currentFuture.whenComplete((recursiveResult, recursiveError) -> {\r\n                        if (recursiveError == null) {\r\n                            future.complete(recursiveResult);\r\n                        } else {\r\n                            future.completeExceptionally(recursiveError);\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                future.complete(channel);\r\n            }\r\n        } else {\r\n            future.completeExceptionally(error);\r\n        }\r\n    });\r\n    return future;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.RaftSessionConnection.retryRequest",
	"Comment": "resends a request due to a request failure, resetting the connection if necessary.",
	"Method": "void retryRequest(Throwable cause,T request,BiFunction sender,int count,int selectionId,CompletableFuture future){\r\n    if (this.selectionId == selectionId) {\r\n        log.trace(\"Resetting connection. Reason: {}\", cause.getMessage());\r\n        this.currentNode = null;\r\n    }\r\n    sendRequest(request, sender, count, future);\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.TrackingEventProcessorConfiguration.forSingleThreadedProcessing",
	"Comment": "initialize a configuration with single threaded processing.",
	"Method": "TrackingEventProcessorConfiguration forSingleThreadedProcessing(){\r\n    return new TrackingEventProcessorConfiguration(DEFAULT_THREAD_COUNT);\r\n}"
}, {
	"Path": "io.atomix.core.tree.AtomicDocumentTree.replace",
	"Comment": "conditionally updates a tree node if the current value matches a specified value.",
	"Method": "boolean replace(String path,V newValue,long version,boolean replace,DocumentPath path,V newValue,long version,boolean replace,String path,V newValue,V currentValue,boolean replace,DocumentPath path,V newValue,V currentValue){\r\n    return replace(DocumentPath.from(path), newValue, currentValue);\r\n}"
}, {
	"Path": "io.atomix.core.map.impl.AbstractAtomicMapService.valuesEqual",
	"Comment": "returns a boolean indicating whether the given entry values are equal.",
	"Method": "boolean valuesEqual(MapEntryValue oldValue,MapEntryValue newValue,boolean valuesEqual,byte[] oldValue,byte[] newValue){\r\n    return (oldValue == null && newValue == null) || (oldValue != null && newValue != null && Arrays.equals(oldValue, newValue));\r\n}"
}, {
	"Path": "io.crossbar.autobahn.wamp.utils.Platform.autoSelectTransport",
	"Comment": "automatically returns a websocket based transport for wamp based on theunderlying platform.",
	"Method": "ITransport autoSelectTransport(String webSocketURL){\r\n    Class<?> transportClass;\r\n    try {\r\n        if (isAndroid()) {\r\n            transportClass = Class.forName(\"io.crossbar.autobahn.wamp.transports.AndroidWebSocket\");\r\n        } else {\r\n            transportClass = Class.forName(\"io.crossbar.autobahn.wamp.transports.NettyWebSocket\");\r\n        }\r\n        return (ITransport) transportClass.getConstructor(String.class).newInstance(webSocketURL);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.utils.time.LogicalClock.incrementAndUpdate",
	"Comment": "increments the clock and updates it using the given timestamp.",
	"Method": "LogicalTimestamp incrementAndUpdate(LogicalTimestamp timestamp){\r\n    long nextValue = currentTimestamp.value() + 1;\r\n    if (timestamp.value() > nextValue) {\r\n        return update(timestamp);\r\n    }\r\n    return increment();\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.ErrorContext.eventProcessor",
	"Comment": "returns the name of the event processor where the error occurred.",
	"Method": "String eventProcessor(){\r\n    return eventProcessor;\r\n}"
}, {
	"Path": "io.atomix.storage.buffer.AbstractBuffer.calculateCapacity",
	"Comment": "calculates the next capacity that meets the given minimum capacity.",
	"Method": "int calculateCapacity(int minimumCapacity){\r\n    int newCapacity = Math.min(Math.max(capacity, 2), minimumCapacity);\r\n    while (newCapacity < Math.min(minimumCapacity, maxCapacity)) {\r\n        newCapacity <<= 1;\r\n    }\r\n    return Math.min(newCapacity, maxCapacity);\r\n}"
}, {
	"Path": "io.atomix.protocols.backup.PrimaryBackupTest.testManySessionsManyEvents",
	"Comment": "tests submitting a linearizable event that publishes to all sessions.",
	"Method": "void testManySessionsManyEvents(Replication replication){\r\n    createServers(3);\r\n    PrimaryBackupClient client = createClient();\r\n    SessionClient session = createProxy(client, 2, replication);\r\n    session.addEventListener(CHANGE_EVENT, event -> {\r\n        threadAssertNotNull(event);\r\n        resume();\r\n    });\r\n    SessionClient session1 = createProxy(createClient(), 2, replication);\r\n    session1.execute(operation(READ)).thenRun(this::resume);\r\n    session1.addEventListener(CHANGE_EVENT, event -> {\r\n        threadAssertNotNull(event);\r\n        resume();\r\n    });\r\n    SessionClient session2 = createProxy(createClient(), 2, replication);\r\n    session2.execute(operation(READ)).thenRun(this::resume);\r\n    session2.addEventListener(CHANGE_EVENT, event -> {\r\n        threadAssertNotNull(event);\r\n        resume();\r\n    });\r\n    await(5000, 2);\r\n    for (int i = 0; i < 10; i++) {\r\n        session.execute(operation(EVENT, SERIALIZER.encode(false))).thenRun(this::resume);\r\n        await(10000, 4);\r\n    }\r\n}"
}, {
	"Path": "org.axonframework.messaging.MetaData.readResolve",
	"Comment": "java serialization specification method that will ensure that deserialization will maintain a single instance ofempty metadata.",
	"Method": "Object readResolve(){\r\n    if (isEmpty()) {\r\n        return MetaData.emptyInstance();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.MemberSelector.changed",
	"Comment": "returns a boolean value indicating whether the selector state would be changed by the given members.",
	"Method": "boolean changed(MemberId leader,Collection<MemberId> members){\r\n    checkNotNull(members, \"members\");\r\n    checkArgument(!members.isEmpty(), \"members cannot be empty\");\r\n    if (leader != null && !members.contains(leader)) {\r\n        leader = null;\r\n    }\r\n    if (!Objects.equals(this.leader, leader)) {\r\n        return true;\r\n    } else if (!matches(this.members, members)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.axonframework.config.Configuration.deadlineManager",
	"Comment": "returns the deadline manager defined in this configuration.",
	"Method": "DeadlineManager deadlineManager(){\r\n    return getComponent(DeadlineManager.class);\r\n}"
}, {
	"Path": "io.atomix.storage.journal.JournalSegmentDescriptor.index",
	"Comment": "returns the segment index.the index indicates the index at which the first entry should be written to the segment. indexes are monotonicallyincreasing thereafter.",
	"Method": "long index(){\r\n    return index;\r\n}"
}, {
	"Path": "org.axonframework.config.ModuleConfiguration.unwrap",
	"Comment": "returns the actual module configuration instance. usually, it is the instance itself. however, in case of moduleconfiguration wrappers, we would like to provide the wrapped module configuration as the instance.",
	"Method": "ModuleConfiguration unwrap(){\r\n    return this;\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.jdbc.EventSchema.sequenceNumberColumn",
	"Comment": "get the name of the column containing the aggregate sequence number of the event.",
	"Method": "String sequenceNumberColumn(Builder sequenceNumberColumn,String sequenceNumberColumn){\r\n    return sequenceNumberColumn;\r\n}"
}, {
	"Path": "io.atomix.utils.concurrent.Futures.asyncFuture",
	"Comment": "returns a wrapped future that will be completed on the given executor.",
	"Method": "CompletableFuture<T> asyncFuture(CompletableFuture<T> future,Executor executor){\r\n    CompletableFuture<T> newFuture = new AtomixFuture();\r\n    future.whenComplete((result, error) -> {\r\n        executor.execute(() -> {\r\n            if (error == null) {\r\n                newFuture.complete(result);\r\n            } else {\r\n                newFuture.completeExceptionally(error);\r\n            }\r\n        });\r\n    });\r\n    return newFuture;\r\n}"
}, {
	"Path": "io.atomix.core.utils.config.PolymorphicConfigMapper.isPolymorphicType",
	"Comment": "returns a boolean indicating whether the given class is a polymorphic type.",
	"Method": "boolean isPolymorphicType(Class<?> clazz){\r\n    return polymorphicTypes.stream().anyMatch(polymorphicType -> polymorphicType.getConfigClass() == clazz);\r\n}"
}, {
	"Path": "org.axonframework.config.DefaultConfigurer.defaultSerializer",
	"Comment": "provides the default serializer implementation. subclasses may override this method to provide their own default.",
	"Method": "Serializer defaultSerializer(Configuration config){\r\n    return XStreamSerializer.builder().revisionResolver(config.getComponent(RevisionResolver.class, AnnotationRevisionResolver::new)).build();\r\n}"
}, {
	"Path": "brave.internal.handler.MutableSpanConverterBenchmarks.convertServerSpan",
	"Comment": "tests converting into a builder type. this isolates the performance of walking over the mutabledata.",
	"Method": "Span.Builder convertServerSpan(){\r\n    Span.Builder builder = Span.newBuilder();\r\n    converter.convert(serverMutableSpan, builder);\r\n    return builder;\r\n}"
}, {
	"Path": "org.axonframework.serialization.json.JacksonSerializer.getWriter",
	"Comment": "provides the objectwriter, with which objects are serialized to json form. this method may be overridden tochange the configuration of the writer to use.",
	"Method": "ObjectWriter getWriter(){\r\n    return objectMapper.writer();\r\n}"
}, {
	"Path": "org.axonframework.spring.eventhandling.scheduling.quartz.QuartzEventSchedulerFactoryBean.setTransactionManager",
	"Comment": "sets the transaction manager that manages the transaction around the publication of an event. if a transactionmanager is not specified, no transactions are managed around the event publication.",
	"Method": "void setTransactionManager(PlatformTransactionManager transactionManager){\r\n    this.transactionManager = transactionManager;\r\n}"
}, {
	"Path": "org.axonframework.config.DefaultConfigurer.defaultCommandBus",
	"Comment": "provides the default commandbus implementation. subclasses may override this method to provide their own default.",
	"Method": "CommandBus defaultCommandBus(Configuration config){\r\n    SimpleCommandBus commandBus = SimpleCommandBus.builder().transactionManager(config.getComponent(TransactionManager.class, () -> NoTransactionManager.INSTANCE)).messageMonitor(config.messageMonitor(SimpleCommandBus.class, \"commandBus\")).build();\r\n    commandBus.registerHandlerInterceptor(new CorrelationDataInterceptor(config.correlationDataProviders()));\r\n    return commandBus;\r\n}"
}, {
	"Path": "org.axonframework.spring.eventsourcing.SpringAggregateSnapshotterFactoryBean.setRepositoryProvider",
	"Comment": "sets repository provider in order to have possibility to spawn new aggregates from the aggregate.",
	"Method": "void setRepositoryProvider(RepositoryProvider repositoryProvider){\r\n    this.repositoryProvider = repositoryProvider;\r\n}"
}, {
	"Path": "org.axonframework.test.deadline.ScheduledDeadlineInfo.getCounter",
	"Comment": "retrieve the counter used to differentiate two deadlines scheduled at the same time.",
	"Method": "int getCounter(){\r\n    return counter;\r\n}"
}, {
	"Path": "org.axonframework.serialization.UnknownSerializedType.serializedType",
	"Comment": "returns the type of the serialized object, for which no class could be resolved.",
	"Method": "SerializedType serializedType(){\r\n    return serializedObject.getType();\r\n}"
}, {
	"Path": "io.atomix.core.tree.AsyncAtomicDocumentTree.createRecursive",
	"Comment": "creates a document tree node recursively by creating all missing intermediate nodes in the path.",
	"Method": "CompletableFuture<Boolean> createRecursive(String path,V value,CompletableFuture<Boolean> createRecursive,DocumentPath path,V value){\r\n    return createRecursive(DocumentPath.from(path), value);\r\n}"
}, {
	"Path": "io.atomix.cluster.AtomixClusterBuilder.withReachabilityTimeout",
	"Comment": "sets the reachability failure timeout.the reachability timeout determines the maximum time after which a member will be marked unreachable if heartbeatshave failed.",
	"Method": "AtomixClusterBuilder withReachabilityTimeout(Duration timeout){\r\n    GroupMembershipProtocolConfig protocolConfig = config.getProtocolConfig();\r\n    if (protocolConfig instanceof HeartbeatMembershipProtocolConfig) {\r\n        ((HeartbeatMembershipProtocolConfig) protocolConfig).setFailureTimeout(timeout);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.core.value.ValueConfig.isRegistrationRequired",
	"Comment": "returns whether registration is required for serializable types.",
	"Method": "boolean isRegistrationRequired(){\r\n    return registrationRequired;\r\n}"
}, {
	"Path": "io.atomix.primitive.partition.PartitionGroupMembership.system",
	"Comment": "returns whether this partition group is the system partition group.",
	"Method": "boolean system(){\r\n    return system;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.RaftTest.testSequenceLinearizableOperations",
	"Comment": "tests that operations are properly sequenced on the client.",
	"Method": "void testSequenceLinearizableOperations(){\r\n    testSequenceOperations(5, ReadConsistency.LINEARIZABLE);\r\n}"
}, {
	"Path": "org.axonframework.messaging.annotation.HandlerComparator.instance",
	"Comment": "returns the singleton comparator managed by the handlercomparator class.",
	"Method": "Comparator<MessageHandlingMember<?>> instance(){\r\n    return INSTANCE;\r\n}"
}, {
	"Path": "brave.features.propagation.SecondarySamplingTest.integrationTest",
	"Comment": "this shows when primary trace status is not sampled, we can send to handlers anyway.",
	"Method": "void integrationTest(){\r\n    map.put(\"b3\", \"0\");\r\n    map.put(\"sampling\", \"zeus:rate=1.0,ttl=3;apollo:sampled=1;wookie:rate=0.05\");\r\n    Tracer tracer = tracing.tracer();\r\n    Span span1 = tracer.nextSpan(extractor.extract(map)).name(\"span1\").kind(Kind.SERVER).start();\r\n    Span span2 = tracer.newChild(span1.context()).kind(Kind.CLIENT).name(\"span2\").start();\r\n    injector.inject(span2.context(), map);\r\n    assertThat(map).containsEntry(\"sampling\", \"zeus:ttl=3,sampled=1;apollo:sampled=1;wookie:rate=0.05\");\r\n    Span span3 = tracer.joinSpan(extractor.extract(map).context()).kind(Kind.SERVER).start();\r\n    Span span4 = tracer.newChild(span3.context()).kind(Kind.CLIENT).name(\"span3\").start();\r\n    injector.inject(span4.context(), map);\r\n    assertThat(map).containsEntry(\"sampling\", \"zeus:sampled=1,ttl=2;apollo:sampled=1;wookie:rate=0.05\");\r\n    Span span5 = tracer.joinSpan(extractor.extract(map).context()).kind(Kind.SERVER).start();\r\n    Span span6 = tracer.newChild(span5.context()).kind(Kind.CLIENT).name(\"span4\").start();\r\n    injector.inject(span6.context(), map);\r\n    assertThat(map).containsEntry(\"sampling\", \"zeus:sampled=1,ttl=1;apollo:sampled=1;wookie:rate=0.05\");\r\n    Span span7 = tracer.joinSpan(extractor.extract(map).context()).kind(Kind.SERVER).start();\r\n    Span span8 = tracer.newChild(span7.context()).kind(Kind.CLIENT).name(\"span5\").start();\r\n    injector.inject(span8.context(), map);\r\n    assertThat(map).containsEntry(\"sampling\", \"apollo:sampled=1;wookie:rate=0.05\");\r\n    Span span9 = tracer.joinSpan(extractor.extract(map).context()).kind(Kind.SERVER).start();\r\n    Span span10 = tracer.newChild(span9.context()).kind(Kind.CLIENT).name(\"span6\").start();\r\n    injector.inject(span10.context(), map);\r\n    assertThat(map).containsEntry(\"sampling\", \"apollo:sampled=1;wookie:rate=0.05\");\r\n    asList(span1, span2, span3, span4, span5, span6, span7, span8, span9, span10).forEach(Span::finish);\r\n    assertThat(zipkin).isEmpty();\r\n    assertThat(zeus).filteredOn(s -> s.kind() == Kind.SERVER).hasSize(4);\r\n    assertThat(apollo).filteredOn(s -> s.kind() == Kind.SERVER).hasSize(5);\r\n}"
}, {
	"Path": "io.atomix.protocols.log.DistributedLogProtocol.instance",
	"Comment": "returns an instance of the log protocol with the default configuration.",
	"Method": "DistributedLogProtocol instance(){\r\n    return new DistributedLogProtocol(new DistributedLogProtocolConfig());\r\n}"
}, {
	"Path": "io.atomix.storage.journal.SegmentedJournal.maxSegmentSize",
	"Comment": "returns the maximum journal segment size.the maximum segment size dictates the maximum size any segment in a segment may consume in bytes.",
	"Method": "int maxSegmentSize(){\r\n    return maxSegmentSize;\r\n}"
}, {
	"Path": "org.axonframework.deadline.AbstractDeadlineManager.handlerInterceptors",
	"Comment": "provides a list of registered handler interceptors. do note that this list is not modifiable, and that changesin the internal structure for handler interceptors will be reflected in this list.",
	"Method": "List<MessageHandlerInterceptor<? super DeadlineMessage<?>>> handlerInterceptors(){\r\n    return Collections.unmodifiableList(handlerInterceptors);\r\n}"
}, {
	"Path": "io.atomix.cluster.AtomixClusterBuilder.withKeyStorePassword",
	"Comment": "sets the key store password for the atomix messaging service.",
	"Method": "AtomixClusterBuilder withKeyStorePassword(String keyStorePassword){\r\n    config.getMessagingConfig().getTlsConfig().setKeyStorePassword(keyStorePassword);\r\n    return this;\r\n}"
}, {
	"Path": "brave.test.propagation.PropagationTest.verifyRoundTrip_externallyProvidedIds",
	"Comment": "when the caller propagates ids, but not a sampling decision, the current process shoulddecide.",
	"Method": "void verifyRoundTrip_externallyProvidedIds(){\r\n    inject(map, \"0000000000000001\", null, \"0000000000000001\", null, null);\r\n    verifyRoundTrip(TraceContextOrSamplingFlags.create(rootSpan.toBuilder().sampled(null).build()));\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.impl.DefaultRaftServer.isRunning",
	"Comment": "returns a boolean indicating whether the server is running.",
	"Method": "boolean isRunning(){\r\n    return started;\r\n}"
}, {
	"Path": "io.atomix.cluster.AtomixClusterBuilder.withKeyStore",
	"Comment": "sets the key store to use for tls in the atomix messaging service.",
	"Method": "AtomixClusterBuilder withKeyStore(String keyStore){\r\n    config.getMessagingConfig().getTlsConfig().setKeyStore(keyStore);\r\n    return this;\r\n}"
}, {
	"Path": "org.axonframework.config.DefaultConfigurer.prepareModules",
	"Comment": "prepare the registered modules for initialization. this ensures all lifecycle handlers are registered.",
	"Method": "void prepareModules(){\r\n    modules.forEach(module -> {\r\n        initHandlers.add(new ConsumerHandler(module.phase(), module::initialize));\r\n        startHandlers.add(new RunnableHandler(module.phase(), module::start));\r\n        shutdownHandlers.add(new RunnableHandler(module.phase(), module::shutdown));\r\n    });\r\n}"
}, {
	"Path": "org.axonframework.test.aggregate.Reporter.reportDifferentPayloads",
	"Comment": "report an error due to a difference in one of the fields of the message payload.",
	"Method": "void reportDifferentPayloads(Class<?> messageType,Field field,Object actual,Object expected){\r\n    StringBuilder sb = new StringBuilder(\"One of the messages contained different values than expected\");\r\n    sb.append(NEWLINE).append(NEWLINE).append(\"In a message of type [\").append(messageType.getSimpleName()).append(\"], the property [\").append(field.getName()).append(\"] \");\r\n    if (!messageType.equals(field.getDeclaringClass())) {\r\n        sb.append(\"(declared in [\").append(field.getDeclaringClass().getSimpleName()).append(\"]) \");\r\n    }\r\n    // NOSONAR\r\n    sb.append(\"was not as expected.\").append(NEWLINE).append(\"Expected <\").append(nullSafeToString(expected)).append(\"> but got <\").append(nullSafeToString(actual)).append(\">\").append(NEWLINE);\r\n    throw new AxonAssertionError(sb.toString());\r\n}"
}, {
	"Path": "org.axonframework.test.utils.RecordingCommandBus.getDispatchedCommands",
	"Comment": "returns a list with all commands that have been dispatched by this command bus.",
	"Method": "List<CommandMessage<?>> getDispatchedCommands(){\r\n    return dispatchedCommands;\r\n}"
}, {
	"Path": "io.atomix.utils.concurrent.ThreadContext.checkThread",
	"Comment": "checks that the current thread is the correct context thread.",
	"Method": "void checkThread(){\r\n    checkState(currentContext() == this, \"not on a Catalyst thread\");\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.storage.snapshot.Snapshot.index",
	"Comment": "returns the snapshot index.the snapshot index is the index of the state machine at the point at which the snapshot was written.",
	"Method": "long index(){\r\n    return descriptor.index();\r\n}"
}, {
	"Path": "io.atomix.core.workqueue.WorkQueueStats.totalPending",
	"Comment": "returns the total pending tasks. these are the tasks that are added but not yet picked up.",
	"Method": "long totalPending(){\r\n    return this.totalPending;\r\n}"
}, {
	"Path": "brave.http.HttpHandler.finishInNullScope",
	"Comment": "clears the scope to prevent remote reporters from accidentally tracing",
	"Method": "void finishInNullScope(Span span){\r\n    Scope ws = currentTraceContext.maybeScope(null);\r\n    try {\r\n        span.finish();\r\n    } finally {\r\n        ws.close();\r\n    }\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.MemberSelector.matches",
	"Comment": "returns a boolean value indicating whether the servers in the first list match the servers in the second list.",
	"Method": "boolean matches(Collection<MemberId> left,Collection<MemberId> right){\r\n    if (left.size() != right.size())\r\n        return false;\r\n    for (MemberId address : left) {\r\n        if (!right.contains(address)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.jdbc.EventSchema.eventIdentifierColumn",
	"Comment": "get the name of the column containing the identifier of the event.",
	"Method": "String eventIdentifierColumn(Builder eventIdentifierColumn,String eventIdentifierColumn){\r\n    return eventIdentifierColumn;\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.SimpleCommandBus.registerHandlerInterceptor",
	"Comment": "registers the given interceptor to the command bus. all incoming commands will pass through theregistered interceptors at the given order before the command is passed to the handler for processing.",
	"Method": "Registration registerHandlerInterceptor(MessageHandlerInterceptor<? super CommandMessage<?>> handlerInterceptor){\r\n    handlerInterceptors.add(handlerInterceptor);\r\n    return () -> handlerInterceptors.remove(handlerInterceptor);\r\n}"
}, {
	"Path": "org.axonframework.disruptor.commandhandling.CommandHandlingEntry.reset",
	"Comment": "resets this entry, preparing it for use for another command.",
	"Method": "void reset(CommandMessage<?> newCommand,MessageHandler<? super CommandMessage<?>> newCommandHandler,int newInvokerSegmentId,int newPublisherSegmentId,BlacklistDetectingCallback newCallback,List<MessageHandlerInterceptor<? super CommandMessage<?>>> invokerInterceptors,List<MessageHandlerInterceptor<? super CommandMessage<?>>> publisherInterceptors){\r\n    this.invokerSegmentId = newInvokerSegmentId;\r\n    this.publisherSegmentId = newPublisherSegmentId;\r\n    this.callback = newCallback;\r\n    this.isRecoverEntry = false;\r\n    this.result = null;\r\n    this.aggregateIdentifier = null;\r\n    this.invocationInterceptorChain = new DefaultInterceptorChain(this, invokerInterceptors, newCommandHandler);\r\n    this.publisherInterceptorChain = new DefaultInterceptorChain(this, publisherInterceptors, repeatingCommandHandler);\r\n    reset(newCommand);\r\n}"
}, {
	"Path": "io.atomix.utils.concurrent.ComposableFuture.exceptAsync",
	"Comment": "sets a consumer to be called asynchronously when the future is failed.",
	"Method": "CompletableFuture<T> exceptAsync(Consumer<Throwable> consumer,CompletableFuture<T> exceptAsync,Consumer<Throwable> consumer,Executor executor){\r\n    return whenCompleteAsync((result, error) -> {\r\n        if (error != null) {\r\n            consumer.accept(error);\r\n        }\r\n    }, executor);\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.AbstractSnapshotter.createSnapshotterTask",
	"Comment": "creates an instance of a task that contains the actual snapshot creation logic.",
	"Method": "Runnable createSnapshotterTask(Class<?> aggregateType,String aggregateIdentifier){\r\n    return new CreateSnapshotTask(aggregateType, aggregateIdentifier);\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.DispatchMessage.getCommandIdentifier",
	"Comment": "returns the identifier of the command carried by this instance.",
	"Method": "String getCommandIdentifier(){\r\n    return commandIdentifier;\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.jdbc.JdbcEventStorageEngine.setGapCleaningThreshold",
	"Comment": "sets the threshold of number of gaps in a token before an attempt to clean gaps up is taken. defaults to 250.",
	"Method": "void setGapCleaningThreshold(int gapCleaningThreshold){\r\n    this.gapCleaningThreshold = gapCleaningThreshold;\r\n}"
}, {
	"Path": "org.axonframework.config.DefaultConfigurer.defaultQueryUpdateEmitter",
	"Comment": "provides the default queryupdateemitter implementation. subclasses may override this method to provide their owndefault.",
	"Method": "QueryUpdateEmitter defaultQueryUpdateEmitter(Configuration config){\r\n    MessageMonitor<? super SubscriptionQueryUpdateMessage<?>> updateMessageMonitor = config.messageMonitor(QueryUpdateEmitter.class, \"queryUpdateEmitter\");\r\n    return SimpleQueryUpdateEmitter.builder().updateMessageMonitor(updateMessageMonitor).build();\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.tokenstore.jdbc.TokenSchema.tokenColumn",
	"Comment": "returns the name of the column containing the serialized token.",
	"Method": "String tokenColumn(){\r\n    return tokenColumn;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.impl.RaftSessionSequencerTest.testSequenceEventAbsentCommand",
	"Comment": "tests sequencing an event that arrives before a command response.",
	"Method": "void testSequenceEventAbsentCommand(){\r\n    RaftSessionSequencer sequencer = new RaftSessionSequencer(new RaftSessionState(\"test\", SessionId.from(1), UUID.randomUUID().toString(), TestPrimitiveType.instance(), 1000));\r\n    PublishRequest request1 = PublishRequest.builder().withSession(1).withEventIndex(2).withPreviousIndex(0).withEvents(Collections.emptyList()).build();\r\n    PublishRequest request2 = PublishRequest.builder().withSession(1).withEventIndex(3).withPreviousIndex(2).withEvents(Collections.emptyList()).build();\r\n    AtomicInteger run = new AtomicInteger();\r\n    sequencer.sequenceEvent(request1, () -> assertEquals(0, run.getAndIncrement()));\r\n    sequencer.sequenceEvent(request2, () -> assertEquals(1, run.getAndIncrement()));\r\n    assertEquals(2, run.get());\r\n}"
}, {
	"Path": "io.atomix.cluster.MemberId.anonymous",
	"Comment": "creates a new cluster node identifier from the specified string.",
	"Method": "MemberId anonymous(){\r\n    return new MemberId(UUID.randomUUID().toString());\r\n}"
}, {
	"Path": "org.axonframework.test.aggregate.StubAggregateLifecycle.getAppliedEvents",
	"Comment": "returns the list of applied events for this lifecycle instance.note that this list is not reset when activating or deactivating the lifecycle.",
	"Method": "List<EventMessage<?>> getAppliedEvents(){\r\n    return appliedMessages;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.service.RaftServiceContext.deleted",
	"Comment": "returns a boolean indicating whether the service has been deleted.",
	"Method": "boolean deleted(){\r\n    return deleted;\r\n}"
}, {
	"Path": "org.axonframework.messaging.interceptors.JSR303ViolationException.getViolations",
	"Comment": "returns the violations that were detected when this exception was thrown.",
	"Method": "Set<ConstraintViolation<Object>> getViolations(){\r\n    return violations;\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.SimpleEventHandlerInvoker.eventHandlers",
	"Comment": "gets the list of event handler delegates. this delegates are the end point of event handling.",
	"Method": "List<?> eventHandlers(Builder eventHandlers,Object eventHandlers,Builder eventHandlers,List<?> eventHandlers){\r\n    return Collections.unmodifiableList(eventHandlers);\r\n}"
}, {
	"Path": "org.axonframework.modelling.saga.repository.inmemory.InMemorySagaStore.size",
	"Comment": "returns the number of sagas currently contained in this repository.",
	"Method": "int size(){\r\n    return managedSagas.size();\r\n}"
}, {
	"Path": "brave.internal.propagation.CorrelationFieldScopeDecorator.maybeReplaceTraceContext",
	"Comment": "idempotently sets correlation properties to hex representation of trace identifiers in thiscontext.",
	"Method": "void maybeReplaceTraceContext(TraceContext currentSpan,String previousTraceId,String previousParentId,String previousSpanId){\r\n    boolean sameTraceId = lowerHexEqualsTraceId(previousTraceId, currentSpan);\r\n    if (!sameTraceId)\r\n        put(\"traceId\", currentSpan.traceIdString());\r\n    long parentId = currentSpan.parentIdAsLong();\r\n    if (parentId == 0L) {\r\n        remove(\"parentId\");\r\n    } else {\r\n        boolean sameParentId = lowerHexEqualsUnsignedLong(previousParentId, parentId);\r\n        if (!sameParentId)\r\n            put(\"parentId\", HexCodec.toLowerHex(parentId));\r\n    }\r\n    boolean sameSpanId = lowerHexEqualsUnsignedLong(previousSpanId, currentSpan.spanId());\r\n    if (!sameSpanId)\r\n        put(\"spanId\", HexCodec.toLowerHex(currentSpan.spanId()));\r\n}"
}, {
	"Path": "org.awaitility.Awaitility.doNotCatchUncaughtExceptionsByDefault",
	"Comment": "instruct awaitility not to catch uncaught exceptions from other threads.your test will not fail if another thread throws an exception.",
	"Method": "void doNotCatchUncaughtExceptionsByDefault(){\r\n    defaultCatchUncaughtExceptions = false;\r\n}"
}, {
	"Path": "io.atomix.primitive.PrimitiveBuilder.build",
	"Comment": "builds a new instance of the primitive.the returned instance will be distinct from all other instances of the same primitive on this node, with adistinct session, ordering guarantees, memory, etc.",
	"Method": "P build(){\r\n    try {\r\n        return buildAsync().join();\r\n    } catch (Exception e) {\r\n        if (e instanceof CompletionException && e.getCause() instanceof RuntimeException) {\r\n            throw (RuntimeException) e.getCause();\r\n        } else {\r\n            throw e;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.assertj.core.api.SoftAssertionsTest.iterable_soft_assertions_should_report_errors_on_final_methods_and_methods_that_switch_the_object_under_test",
	"Comment": "the test would fail if any method was not proxyable as the assertion error would not be softly caught",
	"Method": "void iterable_soft_assertions_should_report_errors_on_final_methods_and_methods_that_switch_the_object_under_test(){\r\n    Iterable<Name> names = asList(name(\"John\", \"Doe\"), name(\"Jane\", \"Doe\"));\r\n    Iterable<CartoonCharacter> characters = asList(homer, fred);\r\n    softly.assertThat(names).as(\"extracting(throwingFirstNameFunction)\").overridingErrorMessage(\"error message\").extracting(throwingFirstNameFunction).contains(\"gandalf\").contains(\"frodo\");\r\n    softly.assertThat(names).as(\"extracting(\\\"last\\\")\").overridingErrorMessage(\"error message\").extracting(\"last\").containsExactly(\"foo\", \"bar\");\r\n    softly.assertThat(characters).as(\"using flatExtracting on Iterable\").overridingErrorMessage(\"error message\").flatExtracting(childrenExtractor).hasSize(1).containsAnyOf(homer, fred);\r\n    softly.assertThat(characters).as(\"using flatExtracting on Iterable with exception\").overridingErrorMessage(\"error message\").flatExtracting(CartoonCharacter::getChildrenWithException).containsExactlyInAnyOrder(homer, fred);\r\n    softly.assertThat(characters).containsOnly(bart);\r\n    softly.assertThat(characters).containsOnlyOnce(maggie, bart);\r\n    softly.assertThat(characters).containsSequence(homer, bart);\r\n    softly.assertThat(characters).containsSubsequence(homer, maggie);\r\n    softly.assertThat(characters).doesNotContain(homer, maggie);\r\n    softly.assertThat(characters).doesNotContainSequence(fred);\r\n    softly.assertThat(characters).doesNotContainSubsequence(homer, fred);\r\n    softly.assertThat(characters).isSubsetOf(homer, bart);\r\n    softly.assertThat(characters).startsWith(fred);\r\n    softly.assertThat(characters).endsWith(bart);\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"extracting(firstNameFunction, lastNameFunction)\").extracting(firstNameFunction, lastNameFunction).contains(tuple(\"John\", \"Doe\")).contains(tuple(\"Frodo\", \"Baggins\"));\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"extracting(\\\"first\\\", \\\"last\\\")\").extracting(\"first\", \"last\").contains(tuple(\"John\", \"Doe\")).contains(tuple(\"Bilbo\", \"Baggins\"));\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"extracting(firstNameFunction)\").extracting(firstNameFunction).contains(\"John\").contains(\"sam\");\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"extracting(\\\"first\\\", String.class)\").extracting(\"first\", String.class).contains(\"John\").contains(\"Aragorn\");\r\n    softly.assertThat(names).as(\"filteredOn(name -> name.first.startsWith(\\\"Jo\\\"))\").overridingErrorMessage(\"error message\").filteredOn(name -> name.first.startsWith(\"Jo\")).hasSize(123);\r\n    softly.assertThat(names).as(\"name.first.startsWith(\\\"Jo\\\")\").overridingErrorMessage(\"error message\").filteredOn(name -> name.first.startsWith(\"Jo\")).extracting(firstNameFunction).contains(\"Sauron\");\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"flatExtracting with multiple Extractors\").flatExtracting(firstNameFunction, lastNameFunction).contains(\"John\", \"Jane\", \"Doe\").contains(\"Sauron\");\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"flatExtracting with multiple ThrowingExtractors\").flatExtracting(throwingFirstNameFunction, throwingLastNameFunction).contains(\"John\", \"Jane\", \"Doe\").contains(\"Sauron\");\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"extractingResultOf(\\\"getFirst\\\")\").extractingResultOf(\"getFirst\").contains(\"John\", \"Jane\").contains(\"Sam\", \"Aragorn\");\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"extractingResultOf(\\\"getFirst\\\", String.class)\").extractingResultOf(\"getFirst\", String.class).contains(\"John\", \"Jane\").contains(\"Messi\", \"Ronaldo\");\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"filteredOn with condition\").filteredOn(new Condition(name -> name.first.startsWith(\"Jo\"), \"startsWith Jo\")).hasSize(5);\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"filteredOn firstName in {John, Frodo}\").filteredOn(\"first\", in(\"John\", \"Frodo\")).isEmpty();\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"filteredOn firstName = John\").filteredOn(\"first\", \"John\").isEmpty();\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"filteredOn firstName = null\").filteredOnNull(\"first\").isNotEmpty();\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").as(\"using flatExtracting(String... fieldOrPropertyNames)\").flatExtracting(\"first\", \"last\").contains(\"John\", \"Jane\", \"Doe\").contains(\"Sauron\");\r\n    softly.assertThat(characters).as(\"using flatExtracting(String fieldOrPropertyName)\").overridingErrorMessage(\"error message\").flatExtracting(\"children\").contains(bart, maggie).contains(\"Sauron\");\r\n    softly.assertThat(names).overridingErrorMessage(\"error message\").filteredOnAssertions(name -> assertThat(name.first).startsWith(\"Jo\")).as(\"filteredOn with consumer\").hasSize(5);\r\n    List<Throwable> errorsCollected = softly.errorsCollected();\r\n    assertThat(errorsCollected).hasSize(33);\r\n    assertThat(errorsCollected.get(0)).hasMessage(\"[extracting(throwingFirstNameFunction)] error message\");\r\n    assertThat(errorsCollected.get(1)).hasMessage(\"[extracting(throwingFirstNameFunction)] error message\");\r\n    assertThat(errorsCollected.get(2)).hasMessage(\"[extracting(\\\"last\\\")] error message\");\r\n    assertThat(errorsCollected.get(3)).hasMessage(\"[using flatExtracting on Iterable] error message\");\r\n    assertThat(errorsCollected.get(4)).hasMessage(\"[using flatExtracting on Iterable] error message\");\r\n    assertThat(errorsCollected.get(5)).hasMessage(\"[using flatExtracting on Iterable with exception] error message\");\r\n    assertThat(errorsCollected.get(6)).hasMessageContaining(bart.toString());\r\n    assertThat(errorsCollected.get(7)).hasMessageContaining(maggie.toString());\r\n    assertThat(errorsCollected.get(8)).hasMessageContaining(bart.toString());\r\n    assertThat(errorsCollected.get(9)).hasMessageContaining(maggie.toString());\r\n    assertThat(errorsCollected.get(10)).hasMessageContaining(homer.toString());\r\n    assertThat(errorsCollected.get(11)).hasMessageContaining(fred.toString());\r\n    assertThat(errorsCollected.get(12)).hasMessageContaining(homer.toString());\r\n    assertThat(errorsCollected.get(13)).hasMessageContaining(bart.toString());\r\n    assertThat(errorsCollected.get(14)).hasMessageContaining(fred.toString());\r\n    assertThat(errorsCollected.get(15)).hasMessageContaining(bart.toString());\r\n    assertThat(errorsCollected.get(16)).hasMessage(\"[extracting(firstNameFunction, lastNameFunction)] error message\");\r\n    assertThat(errorsCollected.get(17)).hasMessage(\"[extracting(\\\"first\\\", \\\"last\\\")] error message\");\r\n    assertThat(errorsCollected.get(18)).hasMessage(\"[extracting(firstNameFunction)] error message\");\r\n    assertThat(errorsCollected.get(19)).hasMessage(\"[extracting(\\\"first\\\", String.class)] error message\");\r\n    assertThat(errorsCollected.get(20)).hasMessage(\"[filteredOn(name -> name.first.startsWith(\\\"Jo\\\"))] error message\");\r\n    assertThat(errorsCollected.get(21)).hasMessage(\"[name.first.startsWith(\\\"Jo\\\")] error message\");\r\n    assertThat(errorsCollected.get(22)).hasMessage(\"[flatExtracting with multiple Extractors] error message\");\r\n    assertThat(errorsCollected.get(23)).hasMessage(\"[flatExtracting with multiple ThrowingExtractors] error message\");\r\n    assertThat(errorsCollected.get(24)).hasMessage(\"[extractingResultOf(\\\"getFirst\\\")] error message\");\r\n    assertThat(errorsCollected.get(25)).hasMessage(\"[extractingResultOf(\\\"getFirst\\\", String.class)] error message\");\r\n    assertThat(errorsCollected.get(26)).hasMessage(\"[filteredOn with condition] error message\");\r\n    assertThat(errorsCollected.get(27)).hasMessage(\"[filteredOn firstName in {John, Frodo}] error message\");\r\n    assertThat(errorsCollected.get(28)).hasMessage(\"[filteredOn firstName = John] error message\");\r\n    assertThat(errorsCollected.get(29)).hasMessage(\"[filteredOn firstName = null] error message\");\r\n    assertThat(errorsCollected.get(30)).hasMessage(\"[using flatExtracting(String... fieldOrPropertyNames)] error message\");\r\n    assertThat(errorsCollected.get(31)).hasMessage(\"[using flatExtracting(String fieldOrPropertyName)] error message\");\r\n    assertThat(errorsCollected.get(32)).hasMessage(\"[filteredOn with consumer] error message\");\r\n}"
}, {
	"Path": "org.awaitility.core.ConditionFactory.ignoreExceptions",
	"Comment": "instruct awaitility to ignore all exceptions that occur during evaluation.exceptions will be treated as evaluating tofalse. this is useful in situations where the evaluatedconditions may temporarily throw exceptions.",
	"Method": "ConditionFactory ignoreExceptions(){\r\n    return ignoreExceptionsMatching(new Predicate<Throwable>() {\r\n        public boolean matches(Throwable e) {\r\n            return true;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.awaitility.core.ConditionFactory.ignoreExceptions",
	"Comment": "instruct awaitility to ignore all exceptions that occur during evaluation.exceptions will be treated as evaluating tofalse. this is useful in situations where the evaluatedconditions may temporarily throw exceptions.",
	"Method": "ConditionFactory ignoreExceptions(){\r\n    return true;\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.async.EventProcessorTask.scheduleEvents",
	"Comment": "schedules a batch of events for processing. will schedule a new invoker task if none is currently active.if the current scheduler is in the process of being shut down, this method will return false.this method is thread safe.",
	"Method": "boolean scheduleEvents(List<? extends EventMessage<?>> events,Consumer<List<? extends EventMessage<?>>> processor){\r\n    if (cleanedUp) {\r\n        return false;\r\n    }\r\n    taskQueue.add(new ProcessingTask(events, processor));\r\n    if (!isScheduled) {\r\n        isScheduled = true;\r\n        executor.execute(this);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.atomix.core.test.messaging.TestBroadcastServiceFactory.newBroadcastService",
	"Comment": "returns a new test broadcast service for the given endpoint.",
	"Method": "ManagedBroadcastService newBroadcastService(){\r\n    return new TestBroadcastService(services);\r\n}"
}, {
	"Path": "org.axonframework.modelling.saga.repository.AnnotatedSagaRepository.deleteSaga",
	"Comment": "remove the given saga as well as all known association values pointing to it from the repository. if no suchsaga exists, nothing happens.",
	"Method": "void deleteSaga(AnnotatedSaga<T> saga){\r\n    Set<AssociationValue> associationValues = CollectionUtils.merge(saga.getAssociationValues().asSet(), saga.getAssociationValues().removedAssociations(), HashSet::new);\r\n    sagaStore.deleteSaga(sagaType, saga.getSagaIdentifier(), associationValues);\r\n}"
}, {
	"Path": "org.axonframework.queryhandling.SimpleQueryBusTest.testQueryResultContainsCorrelationData",
	"Comment": "this test ensures that the queryresponsemessage is created inside the scope of the unit of work, and thereforecontains the correlation data registered with the unit of work",
	"Method": "void testQueryResultContainsCorrelationData(){\r\n    testSubject.subscribe(String.class.getName(), String.class, (q) -> q.getPayload() + \"1234\");\r\n    QueryMessage<String, String> testQueryMessage = new GenericQueryMessage(\"hello\", singleStringResponse).andMetaData(Collections.singletonMap(TRACE_ID, \"fakeTraceId\"));\r\n    CompletableFuture<QueryResponseMessage<String>> result = testSubject.query(testQueryMessage);\r\n    assertTrue(\"SimpleQueryBus should resolve CompletableFutures directly\", result.isDone());\r\n    assertEquals(\"hello1234\", result.get().getPayload());\r\n    assertEquals(MetaData.with(CORRELATION_ID, testQueryMessage.getIdentifier()).and(TRACE_ID, \"fakeTraceId\"), result.get().getMetaData());\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.jdbc.EventSchema.payloadRevisionColumn",
	"Comment": "get the name of the column containing the revision number of the serialized payload.",
	"Method": "String payloadRevisionColumn(Builder payloadRevisionColumn,String payloadRevisionColumn){\r\n    return payloadRevisionColumn;\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.session.RaftSession.getLastCompleted",
	"Comment": "returns the index of the highest event acked for the session.",
	"Method": "long getLastCompleted(){\r\n    EventHolder event = events.peek();\r\n    if (event != null && event.eventIndex > completeIndex) {\r\n        return event.eventIndex - 1;\r\n    }\r\n    return lastApplied;\r\n}"
}, {
	"Path": "org.axonframework.config.AggregateConfigurer.configureCommandHandler",
	"Comment": "defines the aggregateannotationcommandhandler instance to use.",
	"Method": "AggregateConfigurer<A> configureCommandHandler(Function<Configuration, AggregateAnnotationCommandHandler> aggregateCommandHandlerBuilder){\r\n    commandHandler.update(aggregateCommandHandlerBuilder);\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.utils.concurrent.AbstractAccumulator.cancelTask",
	"Comment": "cancels the specified task if it has not run or is not running.",
	"Method": "void cancelTask(AtomicReference<TimerTask> taskRef){\r\n    swapAndCancelTask(taskRef, null);\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.CachingEventSourcingRepository.doLoadWithLock",
	"Comment": "perform the actual loading of an aggregate. the necessary locks have been obtained. if the aggregate isavailable in the cache, it is returned from there. otherwise the underlying persistence logic is called toretrieve the aggregate.",
	"Method": "EventSourcedAggregate<T> doLoadWithLock(String aggregateIdentifier,Long expectedVersion){\r\n    EventSourcedAggregate<T> aggregate = null;\r\n    AggregateCacheEntry<T> cacheEntry = cache.get(aggregateIdentifier);\r\n    if (cacheEntry != null) {\r\n        aggregate = cacheEntry.recreateAggregate(aggregateModel(), eventStore, repositoryProvider, snapshotTriggerDefinition);\r\n    }\r\n    if (aggregate == null) {\r\n        aggregate = super.doLoadWithLock(aggregateIdentifier, expectedVersion);\r\n    } else if (aggregate.isDeleted()) {\r\n        throw new AggregateDeletedException(aggregateIdentifier);\r\n    }\r\n    return aggregate;\r\n}"
}, {
	"Path": "io.atomix.core.Atomix.builder",
	"Comment": "returns a new atomix builder.the returned builder will be initialized with the provided configuration.",
	"Method": "AtomixBuilder builder(AtomixBuilder builder,ClassLoader classLoader,AtomixBuilder builder,AtomixRegistry registry,AtomixBuilder builder,String config,AtomixBuilder builder,String configFile,ClassLoader classLoader,AtomixBuilder builder,String configFile,AtomixRegistry registry,AtomixBuilder builder,AtomixConfig config,AtomixBuilder builder,AtomixConfig config,ClassLoader classLoader,AtomixBuilder builder,AtomixConfig config,AtomixRegistry registry){\r\n    return new AtomixBuilder(config, registry);\r\n}"
}, {
	"Path": "brave.Tracer.nextSpan",
	"Comment": "we manually code some things to keep the cpu and allocations low, at the cost of readability.",
	"Method": "Span nextSpan(TraceContextOrSamplingFlags extracted,Span nextSpan){\r\n    TraceContext parent = currentTraceContext.get();\r\n    return parent != null ? newChild(parent) : newTrace();\r\n}"
}, {
	"Path": "io.atomix.core.tree.AtomicDocumentTreeConfig.setRegistrationRequired",
	"Comment": "sets whether registration is required for serializable types.",
	"Method": "AtomicDocumentTreeConfig setRegistrationRequired(boolean registrationRequired){\r\n    this.registrationRequired = registrationRequired;\r\n    return this;\r\n}"
}, {
	"Path": "brave.handler.MutableSpanTest.forEachTag_updater_usageExplained",
	"Comment": "this is a compile test to show how the signature is intended to be used",
	"Method": "void forEachTag_updater_usageExplained(){\r\n    MutableSpan span = new MutableSpan();\r\n    span.tag(\"a\", \"1\");\r\n    span.tag(\"ssn\", \"912-23-1433\");\r\n    span.tag(\"ssn-suffix\", \"SSN=912-23-1433\");\r\n    span.tag(\"c\", \"3\");\r\n    span.forEachTag((key, value) -> {\r\n        Matcher matcher = SSN.matcher(value);\r\n        if (matcher.find()) {\r\n            String matched = matcher.group(0);\r\n            if (matched.equals(value))\r\n                return null;\r\n            return value.replace(matched, \"xxx-xx-xxxx\");\r\n        }\r\n        return value;\r\n    });\r\n    assertThat(tagsToMap(span)).containsExactly(entry(\"a\", \"1\"), entry(\"ssn-suffix\", \"SSN=xxx-xx-xxxx\"), entry(\"c\", \"3\"));\r\n}"
}, {
	"Path": "io.atomix.protocols.backup.PrimaryBackupTest.testSubmitQuery",
	"Comment": "tests submitting a query with a configured consistency level.",
	"Method": "void testSubmitQuery(int nodes,int backups,Replication replication){\r\n    createServers(nodes);\r\n    PrimaryBackupClient client = createClient();\r\n    SessionClient session = createProxy(client, backups, replication);\r\n    session.execute(operation(READ)).thenRun(this::resume);\r\n    await(5000);\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.TrackingEventProcessor.processingStatus",
	"Comment": "returns the status for each of the segments processed by the current processor. the key of the map representsthe segmentid processed by this instance. the values of the returned map represent the last known status of thatsegment.note that the returned map in unmodifiable, but does reflect any changes made to the status as the processoris processing events.",
	"Method": "Map<Integer, EventTrackerStatus> processingStatus(){\r\n    return Collections.unmodifiableMap(activeSegments);\r\n}"
}, {
	"Path": "io.atomix.storage.journal.SegmentedJournal.compact",
	"Comment": "compacts the journal up to the given index.the semantics of compaction are not specified by this interface.",
	"Method": "void compact(long index){\r\n    Map.Entry<Long, JournalSegment<E>> segmentEntry = segments.floorEntry(index);\r\n    if (segmentEntry != null) {\r\n        SortedMap<Long, JournalSegment<E>> compactSegments = segments.headMap(segmentEntry.getValue().index());\r\n        if (!compactSegments.isEmpty()) {\r\n            log.debug(\"{} - Compacting {} segment(s)\", name, compactSegments.size());\r\n            for (JournalSegment segment : compactSegments.values()) {\r\n                log.trace(\"Deleting segment: {}\", segment);\r\n                segment.close();\r\n                segment.delete();\r\n            }\r\n            compactSegments.clear();\r\n            resetHead(segmentEntry.getValue().index());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.roles.FollowerRole.sendPollRequests",
	"Comment": "polls all members of the cluster to determine whether this member should transition to the candidate state.",
	"Method": "void sendPollRequests(){\r\n    heartbeatTimer = raft.getThreadContext().schedule(raft.getElectionTimeout(), () -> {\r\n        log.debug(\"Failed to poll a majority of the cluster in {}\", raft.getElectionTimeout());\r\n        resetHeartbeatTimeout();\r\n    });\r\n    final AtomicBoolean complete = new AtomicBoolean();\r\n    final Set<DefaultRaftMember> votingMembers = raft.getCluster().getActiveMemberStates().stream().map(RaftMemberContext::getMember).collect(Collectors.toSet());\r\n    if (votingMembers.isEmpty()) {\r\n        raft.transition(RaftServer.Role.CANDIDATE);\r\n        return;\r\n    }\r\n    final Quorum quorum = new Quorum(raft.getCluster().getQuorum(), (elected) -> {\r\n        complete.set(true);\r\n        if (raft.getLeader() == null && elected) {\r\n            raft.transition(RaftServer.Role.CANDIDATE);\r\n        } else {\r\n            resetHeartbeatTimeout();\r\n        }\r\n    });\r\n    final Indexed<RaftLogEntry> lastEntry = raft.getLogWriter().getLastEntry();\r\n    final long lastTerm;\r\n    if (lastEntry != null) {\r\n        lastTerm = lastEntry.entry().term();\r\n    } else {\r\n        lastTerm = 0;\r\n    }\r\n    log.debug(\"Polling members {}\", votingMembers);\r\n    for (DefaultRaftMember member : votingMembers) {\r\n        log.debug(\"Polling {} for next term {}\", member, raft.getTerm() + 1);\r\n        PollRequest request = PollRequest.builder().withTerm(raft.getTerm()).withCandidate(raft.getCluster().getMember().memberId()).withLastLogIndex(lastEntry != null ? lastEntry.index() : 0).withLastLogTerm(lastTerm).build();\r\n        raft.getProtocol().poll(member.memberId(), request).whenCompleteAsync((response, error) -> {\r\n            raft.checkThread();\r\n            if (isRunning() && !complete.get()) {\r\n                if (error != null) {\r\n                    log.warn(\"{}\", error.getMessage());\r\n                    quorum.fail();\r\n                } else {\r\n                    if (response.term() > raft.getTerm()) {\r\n                        raft.setTerm(response.term());\r\n                    }\r\n                    if (!response.accepted()) {\r\n                        log.debug(\"Received rejected poll from {}\", member);\r\n                        quorum.fail();\r\n                    } else if (response.term() != raft.getTerm()) {\r\n                        log.debug(\"Received accepted poll for a different term from {}\", member);\r\n                        quorum.fail();\r\n                    } else {\r\n                        log.debug(\"Received accepted poll from {}\", member);\r\n                        quorum.succeed();\r\n                    }\r\n                }\r\n            }\r\n        }, raft.getThreadContext());\r\n    }\r\n}"
}, {
	"Path": "org.assertj.core.api.SoftAssertionsTest.class_soft_assertions_should_report_errors_on_final_methods",
	"Comment": "the test would fail if any method was not proxyable as the assertion error would not be softly caught",
	"Method": "void class_soft_assertions_should_report_errors_on_final_methods(){\r\n    Class<AnnotatedClass> actual = AnnotatedClass.class;\r\n    softly.assertThat(actual).hasAnnotations(MyAnnotation.class, AnotherAnnotation.class).hasAnnotations(SafeVarargs.class, VisibleForTesting.class);\r\n    List<Throwable> errorsCollected = softly.errorsCollected();\r\n    assertThat(errorsCollected).hasSize(1);\r\n    assertThat(errorsCollected.get(0)).hasMessageContaining(\"SafeVarargs\").hasMessageContaining(\"VisibleForTesting\");\r\n}"
}, {
	"Path": "org.axonframework.serialization.AbstractXStreamSerializer.getCharset",
	"Comment": "returns the character set used to convert character to bytes and vice versa.",
	"Method": "Charset getCharset(){\r\n    return charset;\r\n}"
}, {
	"Path": "org.axonframework.config.AggregateConfigurer.configureCommandTargetResolver",
	"Comment": "defines the commandtargetresolver to use for the aggregate type under configuration. the commandtargetresolverdefines which aggregate instance must be loaded to handle a specific command.",
	"Method": "AggregateConfigurer<A> configureCommandTargetResolver(Function<Configuration, CommandTargetResolver> commandTargetResolverBuilder){\r\n    commandTargetResolver.update(commandTargetResolverBuilder);\r\n    return this;\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.jdbc.EventSchema.payloadColumn",
	"Comment": "get the name of the column containing the serialized payload of the event.",
	"Method": "String payloadColumn(Builder payloadColumn,String payloadColumn){\r\n    return payloadColumn;\r\n}"
}, {
	"Path": "org.axonframework.config.AggregateConfigurer.configureAggregateFactory",
	"Comment": "defines the factory to use to to create new aggregates instances of the type under configuration.",
	"Method": "AggregateConfigurer<A> configureAggregateFactory(Function<Configuration, AggregateFactory<A>> aggregateFactoryBuilder){\r\n    aggregateFactory.update(aggregateFactoryBuilder);\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.protocols.backup.MultiPrimaryProtocolBuilder.withMaxRetries",
	"Comment": "sets the maximum number of retries before an operation can be failed.",
	"Method": "MultiPrimaryProtocolBuilder withMaxRetries(int maxRetries){\r\n    config.setMaxRetries(maxRetries);\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.storage.journal.JournalSegmentFile.createSegmentFile",
	"Comment": "creates a segment file for the given directory, log name, segment id, and segment version.",
	"Method": "File createSegmentFile(String name,File directory,long id){\r\n    return new File(directory, String.format(\"%s-%d.log\", checkNotNull(name, \"name cannot be null\"), id));\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.impl.RaftServiceManager.applyConfiguration",
	"Comment": "applies a configuration entry to the internal state machine.configuration entries are applied to internal server state when written to the log. thus, no significant logicneeds to take place in the handling of configuration entries. we simply release the previous configuration entrysince it was overwritten by a more recent committed configuration entry.",
	"Method": "CompletableFuture<Void> applyConfiguration(Indexed<ConfigurationEntry> entry){\r\n    for (RaftServiceContext service : raft.getServices()) {\r\n        service.keepAliveSessions(entry.index(), entry.entry().timestamp());\r\n    }\r\n    return CompletableFuture.completedFuture(null);\r\n}"
}, {
	"Path": "org.axonframework.disruptor.commandhandling.DisruptorCommandBus.doDispatch",
	"Comment": "forces a dispatch of a command. this method should be used with caution. it allows commands to be retried duringthe cooling down period of the disruptor.",
	"Method": "void doDispatch(CommandMessage<? extends C> command,CommandCallback<? super C, R> callback){\r\n    Assert.state(!disruptorShutDown, () -> \"Disruptor has been shut down. Cannot dispatch or re-dispatch commands\");\r\n    final MessageHandler<? super CommandMessage<?>> commandHandler = commandHandlers.get(command.getCommandName());\r\n    if (commandHandler == null) {\r\n        callback.onResult(command, asCommandResultMessage(new NoHandlerForCommandException(format(\"No handler was subscribed to command [%s]\", command.getCommandName()))));\r\n        return;\r\n    }\r\n    RingBuffer<CommandHandlingEntry> ringBuffer = disruptor.getRingBuffer();\r\n    int invokerSegment = 0;\r\n    int publisherSegment = 0;\r\n    if (commandHandlerInvokers.length > 1 || publisherCount > 1) {\r\n        String aggregateIdentifier = commandTargetResolver.resolveTarget(command).getIdentifier();\r\n        if (aggregateIdentifier != null) {\r\n            int idHash = aggregateIdentifier.hashCode() & Integer.MAX_VALUE;\r\n            if (commandHandlerInvokers.length > 1) {\r\n                invokerSegment = idHash % commandHandlerInvokers.length;\r\n            }\r\n            if (publisherCount > 1) {\r\n                publisherSegment = idHash % publisherCount;\r\n            }\r\n        }\r\n    }\r\n    long sequence = ringBuffer.next();\r\n    try {\r\n        CommandHandlingEntry event = ringBuffer.get(sequence);\r\n        event.reset(command, commandHandler, invokerSegment, publisherSegment, new BlacklistDetectingCallback<C, R>(callback, disruptor.getRingBuffer(), this::doDispatch, rescheduleOnCorruptState), invokerInterceptors, publisherInterceptors);\r\n    } finally {\r\n        ringBuffer.publish(sequence);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.agent.AtomixAgent.createLogger",
	"Comment": "configures and creates a new logger for the given namespace.",
	"Method": "Logger createLogger(Namespace namespace){\r\n    String logConfig = namespace.getString(\"log_config\");\r\n    if (logConfig != null) {\r\n        System.setProperty(\"logback.configurationFile\", logConfig);\r\n    }\r\n    System.setProperty(\"atomix.log.directory\", namespace.getString(\"log_dir\"));\r\n    System.setProperty(\"atomix.log.level\", namespace.getString(\"log_level\"));\r\n    System.setProperty(\"atomix.log.console.level\", namespace.getString(\"console_log_level\"));\r\n    System.setProperty(\"atomix.log.file.level\", namespace.getString(\"file_log_level\"));\r\n    return LoggerFactory.getLogger(AtomixAgent.class);\r\n}"
}, {
	"Path": "org.axonframework.serialization.Converter.convert",
	"Comment": "converts the given object into another using the source type to find the conversion path.",
	"Method": "T convert(Object original,Class<T> targetType,T convert,Object original,Class<?> sourceType,Class<T> targetType,SerializedObject<T> convert,SerializedObject<?> original,Class<T> targetType){\r\n    if (original.getContentType().equals(targetType)) {\r\n        return (SerializedObject<T>) original;\r\n    }\r\n    return new SimpleSerializedObject(convert(original.getData(), original.getContentType(), targetType), targetType, original.getType());\r\n}"
}, {
	"Path": "io.atomix.utils.time.Versioned.creationTime",
	"Comment": "returns the system time when this version was created.care should be taken when relying on creationtime toimplement any behavior in a distributed setting. dueto the possibility of clock skew it is likely thateven creationtimes of causally related versions can beout or order.",
	"Method": "long creationTime(){\r\n    return creationTime;\r\n}"
}, {
	"Path": "org.awaitility.core.SameThreadExecutorService.shutdownNow",
	"Comment": "see samethreadexecutor javadoc for unusual behavior of this method.",
	"Method": "List<Runnable> shutdownNow(){\r\n    shutdown();\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "org.axonframework.common.property.PropertyAccessStrategy.register",
	"Comment": "registers a propertyaccessstrategy implementation at runtime.annotated handlers that have already been inspected will not be able to use the newly added strategy.",
	"Method": "void register(PropertyAccessStrategy strategy){\r\n    STRATEGIES.add(strategy);\r\n}"
}, {
	"Path": "org.axonframework.serialization.json.JacksonSerializer.getReader",
	"Comment": "provides the objectreader, with which objects are read from the json form. this method may be overridden tochange the configuration of the reader to use.",
	"Method": "ObjectReader getReader(Class<?> type){\r\n    return objectMapper.readerFor(type);\r\n}"
}, {
	"Path": "org.axonframework.eventhandling.EventHandlerInvoker.supportsReset",
	"Comment": "indicates whether the handlers managed by this invoker support a reset.",
	"Method": "boolean supportsReset(){\r\n    return true;\r\n}"
}, {
	"Path": "io.atomix.core.tree.DocumentPath.pathElements",
	"Comment": "returns the list of path elements representing this path in correctorder.",
	"Method": "List<String> pathElements(){\r\n    return ImmutableList.copyOf(pathElements);\r\n}"
}, {
	"Path": "io.atomix.core.collection.DistributedCollectionBuilder.withRegistrationRequired",
	"Comment": "sets whether registration is required for serializable types.",
	"Method": "B withRegistrationRequired(B withRegistrationRequired,boolean registrationRequired){\r\n    config.setRegistrationRequired(registrationRequired);\r\n    return (B) this;\r\n}"
}, {
	"Path": "io.crossbar.autobahn.websocket.WebSocketReader.onRawTextMessage",
	"Comment": "websockets text message received, default notifies master.this will only be called when the option receivetextmessagesrawhas been set.",
	"Method": "void onRawTextMessage(byte[] payload){\r\n    notify(new RawTextMessage(payload));\r\n}"
}, {
	"Path": "org.axonframework.commandhandling.distributed.ReplyMessage.getExceptionType",
	"Comment": "returns the exception type of the serialized reply message.",
	"Method": "String getExceptionType(){\r\n    return exceptionType;\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.EventSourcingRepository.doLoadWithLock",
	"Comment": "perform the actual loading of an aggregate. the necessary locks have been obtained.",
	"Method": "EventSourcedAggregate<T> doLoadWithLock(String aggregateIdentifier,Long expectedVersion){\r\n    DomainEventStream eventStream = readEvents(aggregateIdentifier);\r\n    SnapshotTrigger trigger = snapshotTriggerDefinition.prepareTrigger(aggregateFactory.getAggregateType());\r\n    if (!eventStream.hasNext()) {\r\n        throw new AggregateNotFoundException(aggregateIdentifier, \"The aggregate was not found in the event store\");\r\n    }\r\n    EventSourcedAggregate<T> aggregate = EventSourcedAggregate.initialize(aggregateFactory.createAggregateRoot(aggregateIdentifier, eventStream.peek()), aggregateModel(), eventStore, repositoryProvider, trigger);\r\n    aggregate.initializeState(eventStream);\r\n    if (aggregate.isDeleted()) {\r\n        throw new AggregateDeletedException(aggregateIdentifier);\r\n    }\r\n    return aggregate;\r\n}"
}, {
	"Path": "io.atomix.cluster.discovery.MulticastDiscoveryBuilder.withFailureTimeout",
	"Comment": "sets the failure timeout to use prior to phi failure detectors being populated.",
	"Method": "MulticastDiscoveryBuilder withFailureTimeout(Duration failureTimeout){\r\n    config.setFailureTimeout(failureTimeout);\r\n    return this;\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.jdbc.JdbcEventStorageEngine.createSchema",
	"Comment": "performs the ddl queries to create the schema necessary for this storage engine implementation.",
	"Method": "void createSchema(EventTableFactory schemaFactory){\r\n    executeUpdates(getConnection(), e -> {\r\n        throw new EventStoreException(\"Failed to create event tables\", e);\r\n    }, connection -> schemaFactory.createDomainEventTable(connection, schema), connection -> schemaFactory.createSnapshotEventTable(connection, schema));\r\n}"
}, {
	"Path": "org.axonframework.eventsourcing.eventstore.BatchingEventStorageEngine.batchSize",
	"Comment": "returns the maximum number of event entries to be fetched per batch.",
	"Method": "int batchSize(Builder batchSize,int batchSize){\r\n    return batchSize;\r\n}"
}, {
	"Path": "org.axonframework.queryhandling.SubscriptionQueryResult.handle",
	"Comment": "delegates handling of initial result and incremental updates to the provided consumers. subscription to theincremental updates is done after the initial result is retrieved and its consumer is invoked. if anything goeswrong during invoking or consuming initial result or incremental updates, subscription is cancelled.",
	"Method": "void handle(Consumer<? super I> initialResultConsumer,Consumer<? super U> updateConsumer){\r\n    initialResult().subscribe(initialResult -> {\r\n        try {\r\n            initialResultConsumer.accept(initialResult);\r\n            updates().subscribe(updateConsumer::accept);\r\n        } catch (Exception e) {\r\n            cancel();\r\n        }\r\n    }, t -> cancel());\r\n}"
}, {
	"Path": "brave.test.http.ITHttpAsyncClient.usesParentFromInvocationTime",
	"Comment": "this tests that the parent is determined at the time the request was made, not when the requestwas executed.",
	"Method": "void usesParentFromInvocationTime(){\r\n    Tracer tracer = httpTracing.tracing().tracer();\r\n    server.enqueue(new MockResponse().setBodyDelay(300, TimeUnit.MILLISECONDS));\r\n    server.enqueue(new MockResponse());\r\n    ScopedSpan parent = tracer.startScopedSpan(\"test\");\r\n    try {\r\n        getAsync(client, \"/items/1\");\r\n        getAsync(client, \"/items/2\");\r\n    } finally {\r\n        parent.finish();\r\n    }\r\n    ScopedSpan otherSpan = tracer.startScopedSpan(\"test2\");\r\n    try {\r\n        for (int i = 0; i < 2; i++) {\r\n            RecordedRequest request = server.takeRequest();\r\n            assertThat(request.getHeader(\"x-b3-traceId\")).isEqualTo(parent.context().traceIdString());\r\n            assertThat(request.getHeader(\"x-b3-parentspanid\")).isEqualTo(HexCodec.toLowerHex(parent.context().spanId()));\r\n        }\r\n    } finally {\r\n        otherSpan.finish();\r\n    }\r\n    assertThat(Arrays.asList(takeSpan(), takeSpan(), takeSpan(), takeSpan())).extracting(Span::kind).containsOnly(null, Span.Kind.CLIENT);\r\n}"
}, {
	"Path": "io.atomix.protocols.raft.storage.system.Configuration.term",
	"Comment": "returns the configuration term.the term is the term of the leader at the time the configuration change was committed.",
	"Method": "long term(){\r\n    return term;\r\n}"
}, {
	"Path": "io.atomix.cluster.messaging.impl.TestMessagingService.isPartitioned",
	"Comment": "returns a boolean indicating whether this node is partitioned from the given address.",
	"Method": "boolean isPartitioned(Address address){\r\n    return partitions.contains(address);\r\n}"
}]