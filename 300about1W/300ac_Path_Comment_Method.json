[{
	"Path": "com.vaadin.v7.ui.Form.registerField",
	"Comment": "register the field with the form. all registered fields are validatedwhen the form is validated and also committed when the form is committed.the property id must not be already used in the form.",
	"Method": "void registerField(Object propertyId,Field<?> field){\r\n    if (propertyId == null || field == null) {\r\n        return;\r\n    }\r\n    fields.put(propertyId, field);\r\n    field.addListener(fieldValueChangeListener);\r\n    if (!propertyIds.contains(propertyId)) {\r\n        propertyIds.addLast(propertyId);\r\n    }\r\n    field.setBuffered(buffered);\r\n    if (isImmediate() && field instanceof AbstractLegacyComponent) {\r\n        ((AbstractLegacyComponent) field).setImmediate(true);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponentContainer.fireComponentDetachEvent",
	"Comment": "fires the component detached event. this should be called by theremovecomponent methods after the component have been removed from thiscontainer.",
	"Method": "void fireComponentDetachEvent(Component component){\r\n    fireEvent(new ComponentDetachEvent(this, component));\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.filter.SimpleStringFilter.getPropertyId",
	"Comment": "returns the property identifier to which this filter applies.",
	"Method": "Object getPropertyId(){\r\n    return propertyId;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.isColumnReorderingAllowed",
	"Comment": "returns whether columns can be reordered with drag and drop.",
	"Method": "boolean isColumnReorderingAllowed(){\r\n    return columnReorderingAllowed;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.getEndOfDay",
	"Comment": "calculates the end time of the day using the given calendar and date",
	"Method": "Date getEndOfDay(java.util.Calendar calendar,Date date){\r\n    java.util.Calendar calendarClone = (java.util.Calendar) calendar.clone();\r\n    calendarClone.setTime(date);\r\n    calendarClone.set(java.util.Calendar.MILLISECOND, calendarClone.getActualMaximum(java.util.Calendar.MILLISECOND));\r\n    calendarClone.set(java.util.Calendar.SECOND, calendarClone.getActualMaximum(java.util.Calendar.SECOND));\r\n    calendarClone.set(java.util.Calendar.MINUTE, calendarClone.getActualMaximum(java.util.Calendar.MINUTE));\r\n    calendarClone.set(java.util.Calendar.HOUR, calendarClone.getActualMaximum(java.util.Calendar.HOUR));\r\n    calendarClone.set(java.util.Calendar.HOUR_OF_DAY, calendarClone.getActualMaximum(java.util.Calendar.HOUR_OF_DAY));\r\n    return calendarClone.getTime();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendar.getEventComparator",
	"Comment": "returns the default comparator which can compare calendar events byduration.",
	"Method": "Comparator<CalendarEvent> getEventComparator(){\r\n    return DEFAULT_COMPARATOR;\r\n}"
}, {
	"Path": "com.vaadin.v7.tests.server.component.calendar.ContainerDataSourceTest.testRemoveEventConvinienceMethod",
	"Comment": "test the removeevent convenience method with the default event provider",
	"Method": "void testRemoveEventConvinienceMethod(){\r\n    java.util.Calendar cal = java.util.Calendar.getInstance();\r\n    Date start = cal.getTime();\r\n    cal.add(java.util.Calendar.MONTH, 1);\r\n    Date end = cal.getTime();\r\n    assertEquals(0, calendar.getEvents(start, end).size());\r\n    CalendarEvent event = new BasicEvent(\"Test\", \"Test\", start);\r\n    calendar.addEvent(event);\r\n    assertEquals(1, calendar.getEvents(start, end).size());\r\n    calendar.removeEvent(event);\r\n    assertEquals(0, calendar.getEvents(start, end).size());\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.getAssistiveDescription",
	"Comment": "gets the connectors that are used as assistive description. textcontained in these connectors will be read by assistive devices when thewindow is opened.",
	"Method": "List<Connector> getAssistiveDescription(){\r\n    return Collections.unmodifiableList(Arrays.asList(assistiveConnectors));\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConnection.getLoadingIndicator",
	"Comment": "returns the loading indicator used by this applicationconnection.",
	"Method": "VLoadingIndicator getLoadingIndicator(){\r\n    return loadingIndicator;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.setEditorErrorHandler",
	"Comment": "sets the error handler for the editor.the error handler is called whenever there is an exception in the editor.",
	"Method": "void setEditorErrorHandler(EditorErrorHandler editorErrorHandler){\r\n    if (editorErrorHandler == null) {\r\n        throw new IllegalArgumentException(\"The error handler cannot be null\");\r\n    }\r\n    this.editorErrorHandler = editorErrorHandler;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.DataCommunicator.getFilter",
	"Comment": "get the object used for filtering in this data communicator.",
	"Method": "Object getFilter(){\r\n    return filter;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.ensureAccessQueuePurged",
	"Comment": "makes sure the pending access queue is purged for the provided session.if the session is currently locked by the current thread or some otherthread, the queue will be purged when the session is unlocked. if thelock is not held by any thread, it is acquired and the queue is purgedright away.",
	"Method": "void ensureAccessQueuePurged(VaadinSession session){\r\n    try {\r\n        if (session.getLockInstance().tryLock(0, TimeUnit.SECONDS)) {\r\n            session.unlock();\r\n        }\r\n    } catch (InterruptedException e) {\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.Upload.getButtonStyleName",
	"Comment": "returns the stylename rendered into button that fires uploading.",
	"Method": "String getButtonStyleName(){\r\n    return buttonStyleName;\r\n}"
}, {
	"Path": "com.vaadin.client.VCaption.mightChange",
	"Comment": "checks whether anything in a given state change might cause the captionto change.",
	"Method": "boolean mightChange(StateChangeEvent event){\r\n    if (event.hasPropertyChanged(\"caption\")) {\r\n        return true;\r\n    }\r\n    if (event.hasPropertyChanged(\"resources\")) {\r\n        return true;\r\n    }\r\n    if (event.hasPropertyChanged(\"errorMessage\")) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.ui.DateField.setTextFieldEnabled",
	"Comment": "enables or disables the text field. by default the text field is enabled.disabling it causes only the button for date selection to be active, thuspreventing the user from entering invalid dates.see issue 6790.",
	"Method": "void setTextFieldEnabled(boolean state){\r\n    getState().textFieldEnabled = state;\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConnection.addGetParameters",
	"Comment": "adds the get parameters to the uri and returns the new uri that containsthe parameters.",
	"Method": "String addGetParameters(String uri,String extraParams){\r\n    return SharedUtil.addGetParameters(uri, extraParams);\r\n}"
}, {
	"Path": "com.vaadin.shared.Range.startsBefore",
	"Comment": "checks whether this range starts before the start of another range.",
	"Method": "boolean startsBefore(Range other){\r\n    return getStart() < other.getStart();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.handleNavigationYearMode",
	"Comment": "handles the keyboard navigation when the resolution is set to years.",
	"Method": "boolean handleNavigationYearMode(int keycode,boolean ctrl,boolean shift){\r\n    if (ctrl || shift) {\r\n        return false;\r\n    } else if (keycode == getPreviousKey()) {\r\n        focusNextYear(10);\r\n        return true;\r\n    } else if (keycode == getForwardKey()) {\r\n        focusNextYear(1);\r\n        return true;\r\n    } else if (keycode == getNextKey()) {\r\n        focusPreviousYear(10);\r\n        return true;\r\n    } else if (keycode == getBackwardKey()) {\r\n        focusPreviousYear(1);\r\n        return true;\r\n    } else if (keycode == getSelectKey()) {\r\n        value = (Date) focusedDate.clone();\r\n        onSubmit();\r\n        return true;\r\n    } else if (keycode == getResetKey()) {\r\n        focusedDate.setTime(value.getTime());\r\n        renderCalendar();\r\n        return true;\r\n    } else if (keycode == getCloseKey()) {\r\n        onCancel();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VSlider.buildBase",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void buildBase(){\r\n    final String styleAttribute = isVertical() ? \"height\" : \"width\";\r\n    final String oppositeStyleAttribute = isVertical() ? \"width\" : \"height\";\r\n    final String domProperty = isVertical() ? \"offsetHeight\" : \"offsetWidth\";\r\n    base.getStyle().clearProperty(oppositeStyleAttribute);\r\n    if (getElement().hasParentElement()) {\r\n        final Element p = getElement();\r\n        if (p.getPropertyInt(domProperty) > MIN_SIZE) {\r\n            if (isVertical()) {\r\n                setHeight();\r\n            } else {\r\n                base.getStyle().clearProperty(styleAttribute);\r\n            }\r\n        } else {\r\n            base.getStyle().setPropertyPx(styleAttribute, MIN_SIZE);\r\n            Scheduler.get().scheduleDeferred(new Command() {\r\n                @Override\r\n                public void execute() {\r\n                    final Element p = getElement();\r\n                    if (p.getPropertyInt(domProperty) > MIN_SIZE + 5 || propertyNotNullOrEmpty(styleAttribute, p)) {\r\n                        if (isVertical()) {\r\n                            setHeight();\r\n                        } else {\r\n                            base.getStyle().clearProperty(styleAttribute);\r\n                        }\r\n                        setValue(value, false);\r\n                    }\r\n                }\r\n                private boolean propertyNotNullOrEmpty(final String styleAttribute, final Element p) {\r\n                    return p.getStyle().getProperty(styleAttribute) != null && !p.getStyle().getProperty(styleAttribute).isEmpty();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    if (!isVertical()) {\r\n        Scheduler.get().scheduleDeferred(() -> {\r\n            buildHandle();\r\n            setValue(value, false);\r\n        });\r\n    } else {\r\n        buildHandle();\r\n        setValue(value, false);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VSlider.buildBase",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void buildBase(){\r\n    final Element p = getElement();\r\n    if (p.getPropertyInt(domProperty) > MIN_SIZE + 5 || propertyNotNullOrEmpty(styleAttribute, p)) {\r\n        if (isVertical()) {\r\n            setHeight();\r\n        } else {\r\n            base.getStyle().clearProperty(styleAttribute);\r\n        }\r\n        setValue(value, false);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VSlider.buildBase",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void buildBase(){\r\n    return p.getStyle().getProperty(styleAttribute) != null && !p.getStyle().getProperty(styleAttribute).isEmpty();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTree.nodeIsInBranch",
	"Comment": "examines the children of the branch node and returns true if a node is inthat branch",
	"Method": "boolean nodeIsInBranch(TreeNode node,TreeNode branch){\r\n    if (node == branch) {\r\n        return true;\r\n    }\r\n    for (TreeNode child : branch.getChildren()) {\r\n        if (child == node) {\r\n            return true;\r\n        }\r\n        if (!child.isLeaf() && child.getState()) {\r\n            if (nodeIsInBranch(node, child)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.getEditorWidget",
	"Comment": "returns the editor widget associated with the given column. if the editoris not active, returns null.",
	"Method": "Widget getEditorWidget(Widget getEditorWidget,Column<?, T> column){\r\n    return editor.getWidget(column);\r\n}"
}, {
	"Path": "com.github.dozermapper.core.converters.XMLGregorianCalendarConverter.dataTypeFactory",
	"Comment": "returns a new instance of datatypefactory, or the cached one if previously created.",
	"Method": "DatatypeFactory dataTypeFactory(){\r\n    if (dataTypeFactory == null) {\r\n        try {\r\n            dataTypeFactory = DatatypeFactory.newInstance();\r\n        } catch (DatatypeConfigurationException e) {\r\n            throw new MappingException(e);\r\n        }\r\n    }\r\n    return dataTypeFactory;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinPortletService.getCurrentResponse",
	"Comment": "gets the currently processed vaadin portlet response. the currentresponse is automatically defined when the request is started. thecurrent response can not be used in e.g. background threads because ofthe way server implementations reuse response instances.",
	"Method": "VaadinPortletResponse getCurrentResponse(){\r\n    return (VaadinPortletResponse) VaadinService.getCurrentResponse();\r\n}"
}, {
	"Path": "com.vaadin.client.communication.DefaultConnectionStateHandler.handleRecoverableError",
	"Comment": "called whenever an error occurs in communication which should be handledby showing the reconnect dialog and retrying communication untilsuccessful again.",
	"Method": "void handleRecoverableError(Type type,JsonObject payload){\r\n    debug(\"handleTemporaryError(\" + type + \")\");\r\n    if (!connection.isApplicationRunning()) {\r\n        return;\r\n    }\r\n    if (!isReconnecting()) {\r\n        reconnectionCause = type;\r\n        getLogger().warning(\"Reconnecting because of \" + type + \" failure\");\r\n        stopDialogTimer();\r\n        if (isDialogVisible()) {\r\n            hideDialog();\r\n        }\r\n        dialogShowTimer.schedule(getConfiguration().dialogGracePeriod);\r\n    } else {\r\n        if (type.isHigherPriorityThan(reconnectionCause)) {\r\n            getLogger().warning(\"Now reconnecting because of \" + type + \" failure\");\r\n            reconnectionCause = type;\r\n        }\r\n    }\r\n    if (reconnectionCause != type) {\r\n        return;\r\n    }\r\n    reconnectAttempt++;\r\n    getLogger().info(\"Reconnect attempt \" + reconnectAttempt + \" for \" + type);\r\n    if (reconnectAttempt >= getConfiguration().reconnectAttempts) {\r\n        giveUp();\r\n    } else {\r\n        updateDialog();\r\n        scheduleReconnect(payload);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.getNavigationDownKey",
	"Comment": "get the key that moves the selection head downwards. by default it is thedown arrow key but by overriding this you can change the key to whateveryou want.",
	"Method": "int getNavigationDownKey(){\r\n    return KeyCodes.KEY_DOWN;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractColorPicker.fireColorChanged",
	"Comment": "notifies the listeners that the selected color has changed.",
	"Method": "void fireColorChanged(){\r\n    fireEvent(new ColorChangeEvent(this, color));\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.isSortDisabled",
	"Comment": "is sorting disabled altogether.true if no sortable columns are given even in the case where data sourcewould support this.",
	"Method": "boolean isSortDisabled(){\r\n    return !isSortEnabled();\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignAttributeHandler.findSetterForAttribute",
	"Comment": "returns a setter that can be used for assigning the given designattribute to the class",
	"Method": "Method findSetterForAttribute(Class<?> clazz,String attribute){\r\n    resolveSupportedAttributes(clazz);\r\n    return CACHE.get(clazz).getSetter(attribute);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Tree.writeItem",
	"Comment": "recursively writes a data source item and its children to a design.",
	"Method": "Element writeItem(Element design,Object itemId,DesignContext context){\r\n    Element element = design.appendElement(\"node\");\r\n    element.attr(\"text\", itemId.toString());\r\n    Resource icon = getItemIcon(itemId);\r\n    if (icon != null) {\r\n        DesignAttributeHandler.writeAttribute(\"icon\", element.attributes(), icon, null, Resource.class, context);\r\n    }\r\n    if (isSelected(itemId)) {\r\n        element.attr(\"selected\", \"\");\r\n    }\r\n    Collection<?> children = getChildren(itemId);\r\n    if (children != null) {\r\n        for (Object childItemId : children) {\r\n            writeItem(element, childItemId, context);\r\n        }\r\n    }\r\n    return element;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.getNextKey",
	"Comment": "the key that selects the next week in the calendar. by default this isthe down arrow key but by overriding this method it can be changed towhatever you like.",
	"Method": "int getNextKey(){\r\n    return KeyCodes.KEY_DOWN;\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridSingleSelect.addSingleSelectionListener",
	"Comment": "adds a single selection listener that is called when the value of thisselect is changed either by the user or programmatically.",
	"Method": "Registration addSingleSelectionListener(SingleSelectionListener<T> listener){\r\n    return model.addSingleSelectionListener(listener);\r\n}"
}, {
	"Path": "com.vaadin.ui.Upload.isImmediateMode",
	"Comment": "returns the immediate mode of the upload.the default mode of an upload component is immediate.",
	"Method": "boolean isImmediateMode(){\r\n    return getState(false).immediateMode;\r\n}"
}, {
	"Path": "com.vaadin.ui.CheckBoxGroup.isHtmlContentAllowed",
	"Comment": "checks whether captions are interpreted as html or plain text.",
	"Method": "boolean isHtmlContentAllowed(){\r\n    return getState(false).htmlContentAllowed;\r\n}"
}, {
	"Path": "com.vaadin.ui.LoginForm.createUsernameField",
	"Comment": "customize the user name field. only for overriding, do not call.",
	"Method": "TextField createUsernameField(){\r\n    throwIfInitialized();\r\n    TextField field = new TextField(getUsernameCaption());\r\n    field.focus();\r\n    return field;\r\n}"
}, {
	"Path": "com.vaadin.client.ComputedStyle.getHeightIncludingBorderPadding",
	"Comment": "returns the current height, padding and border from the dom.",
	"Method": "double getHeightIncludingBorderPadding(){\r\n    double h = getHeight();\r\n    if (BrowserInfo.get().isIE() || isContentBox()) {\r\n        h += getBorderHeight() + getPaddingHeight();\r\n    }\r\n    return h;\r\n}"
}, {
	"Path": "com.vaadin.ui.CheckBoxGroup.setHtmlContentAllowed",
	"Comment": "sets whether html is allowed in the item captions. if set to true, thecaptions are passed to the browser as html and the developer isresponsible for ensuring no harmful html is used. if set to false, thecontent is passed to the browser as plain text.",
	"Method": "void setHtmlContentAllowed(boolean htmlContentAllowed){\r\n    getState().htmlContentAllowed = htmlContentAllowed;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.PopupDateField.setAssistiveText",
	"Comment": "set a description that explains the usage of the widget for users ofassistive devices.",
	"Method": "void setAssistiveText(String description){\r\n    getState().descriptionForAssistiveDevices = description;\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.removeUnregisteredConnector",
	"Comment": "removes all references and information about the given connector, whichmust not be registered.",
	"Method": "void removeUnregisteredConnector(ClientConnector connector,GlobalResourceHandler globalResourceHandler){\r\n    ClientConnector removedConnector = connectorIdToConnector.remove(connector.getConnectorId());\r\n    assert removedConnector == connector;\r\n    if (globalResourceHandler != null) {\r\n        globalResourceHandler.unregisterConnector(connector);\r\n    }\r\n    uninitializedConnectors.remove(connector);\r\n    diffStates.remove(connector);\r\n}"
}, {
	"Path": "com.vaadin.client.connectors.grid.GridConnector.singleDetailsOpened",
	"Comment": "method target for when one single details has been updated and we mightneed to scroll it into view.",
	"Method": "void singleDetailsOpened(int rowIndex){\r\n    addDetailsRefreshCallback(() -> {\r\n        if (rowHasDetails(rowIndex)) {\r\n            getWidget().scrollToRow(rowIndex);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.folioreader.view.DirectionalViewpager.clearOnPageChangeListeners",
	"Comment": "remove all listeners that are notified of any changes in scroll state or position.",
	"Method": "void clearOnPageChangeListeners(){\r\n    if (mOnPageChangeListeners != null) {\r\n        mOnPageChangeListeners.clear();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.AbstractComponentConnector.cancelParentTouchTimers",
	"Comment": "cancel the timer recursively for parent components that have timersrunning",
	"Method": "void cancelParentTouchTimers(){\r\n    ServerConnector parent = getParent();\r\n    while (parent != null) {\r\n        if (parent instanceof AbstractComponentConnector) {\r\n            ((AbstractComponentConnector) parent).cancelTouchTimer();\r\n        }\r\n        parent = parent.getParent();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.setColumnReorderingAllowed",
	"Comment": "sets whether column reordering with drag and drop is allowed or not.",
	"Method": "void setColumnReorderingAllowed(boolean columnReorderingAllowed){\r\n    this.columnReorderingAllowed = columnReorderingAllowed;\r\n}"
}, {
	"Path": "com.vaadin.server.communication.AtmospherePushConnection.getResource",
	"Comment": "gets the atmosphere resource associated with this connection.",
	"Method": "AtmosphereResource getResource(){\r\n    return resource;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.setDefaultHeaderRow",
	"Comment": "sets the default row of the header. the default row is a special headerrow providing a user interface for sorting columns.",
	"Method": "void setDefaultHeaderRow(HeaderRow row){\r\n    header.setDefaultRow(row);\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.getApplicationUrl",
	"Comment": "get the base url that should be used for sending requests back to thisservice.this is only used to support legacy cases.",
	"Method": "URL getApplicationUrl(VaadinRequest request){\r\n    return null;\r\n}"
}, {
	"Path": "com.vaadin.ui.TabSheet.isTabCaptionsAsHtml",
	"Comment": "checks whether html is allowed in the tab captions.the default is false, i.e. render tab captions as plain text",
	"Method": "boolean isTabCaptionsAsHtml(){\r\n    return getState(false).tabCaptionsAsHtml;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Slider.setMin",
	"Comment": "set the minimum slider value. if the current value of the slider issmaller than this, the value is set to the new minimum.",
	"Method": "void setMin(double min){\r\n    double roundedMin = getRoundedValue(min);\r\n    getState().minValue = roundedMin;\r\n    if (getMax() < roundedMin) {\r\n        getState().maxValue = roundedMin;\r\n    }\r\n    if (getValue() < roundedMin) {\r\n        setValue(roundedMin);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.extensions.DropTargetExtensionConnector.addDropListeners",
	"Comment": "adds dragenter, dragover, dragleave and drop event listeners to the givendom element.",
	"Method": "void addDropListeners(Element element){\r\n    EventTarget target = element.cast();\r\n    target.addEventListener(Event.DRAGENTER, dragEnterListener);\r\n    target.addEventListener(Event.DRAGOVER, dragOverListener);\r\n    target.addEventListener(Event.DRAGLEAVE, dragLeaveListener);\r\n    target.addEventListener(Event.DROP, dropListener);\r\n}"
}, {
	"Path": "com.vaadin.client.VCaption.isCaptionAsHtml",
	"Comment": "checks whether captions are rendered as html.default is false",
	"Method": "boolean isCaptionAsHtml(){\r\n    return captionAsHtml;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VDateField.resolutionToString",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "String resolutionToString(Resolution res){\r\n    if (res.getCalendarField() > Resolution.DAY.getCalendarField()) {\r\n        return \"full\";\r\n    }\r\n    if (res == Resolution.DAY) {\r\n        return \"day\";\r\n    }\r\n    if (res == Resolution.MONTH) {\r\n        return \"month\";\r\n    }\r\n    return \"year\";\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.hideScrollPositionAnnotation",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void hideScrollPositionAnnotation(){\r\n    if (scrollPositionElement != null) {\r\n        scrollPositionElement.getStyle().setDisplay(Display.NONE);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.event.ListenerMethod.receiveEvent",
	"Comment": "receives one event from the eventrouter and calls thetrigger method if it matches with the criteria defined for the listener.only the events of the same or subclass of the specified event classresult in the trigger method to be called.",
	"Method": "void receiveEvent(EventObject event){\r\n    if (eventType.isAssignableFrom(event.getClass())) {\r\n        try {\r\n            if (eventArgumentIndex >= 0) {\r\n                if (eventArgumentIndex == 0 && arguments.length == 1) {\r\n                    method.invoke(target, event);\r\n                } else {\r\n                    final Object[] arg = new Object[arguments.length];\r\n                    System.arraycopy(arguments, 0, arg, 0, arg.length);\r\n                    arg[eventArgumentIndex] = event;\r\n                    method.invoke(target, arg);\r\n                }\r\n            } else {\r\n                method.invoke(target, arguments);\r\n            }\r\n        } catch (final IllegalAccessException e) {\r\n            throw new RuntimeException(\"Internal error - please report\", e);\r\n        } catch (final InvocationTargetException e) {\r\n            throw new MethodException(\"Invocation of method \" + method.getName() + \" in \" + target.getClass().getName() + \" failed.\", e.getTargetException());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.Image.addClickListener",
	"Comment": "add a click listener to the component. the listener is called wheneverthe user clicks inside the component. depending on the content the eventmay be blocked and in that case no event is fired.",
	"Method": "Registration addClickListener(ClickListener listener){\r\n    return addListener(EventId.CLICK_EVENT_IDENTIFIER, ClickEvent.class, listener, ClickListener.clickMethod);\r\n}"
}, {
	"Path": "com.vaadin.shared.ui.MarginInfo.hasAll",
	"Comment": "checks if this margininfo object has margins on all edges enabled.",
	"Method": "boolean hasAll(){\r\n    return (bitMask & ALL) == ALL;\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridSingleSelect.deselect",
	"Comment": "selects the given item. depending on the implementation, may cause otheritems to be deselected. if the item is already selected, does nothing.",
	"Method": "void deselect(T item){\r\n    model.deselect(item);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.getEditorSaveCaption",
	"Comment": "gets the current caption on the save button in the grid editor.",
	"Method": "String getEditorSaveCaption(){\r\n    return editor.getSaveCaption();\r\n}"
}, {
	"Path": "org.greenrobot.essentials.io.CircularByteBuffer.available",
	"Comment": "returns the number of bytes available and can be get without additional puts.",
	"Method": "int available(){\r\n    return available;\r\n}"
}, {
	"Path": "bt.test.protocol.ProtocolTest.assertDecoded",
	"Comment": "assert that the provided data contains sufficient bytes for successful decodingand that the decoded message matches the expected message.",
	"Method": "void assertDecoded(int expectedBytesConsumed,Message expectedMessage,byte[] data){\r\n    ByteBuffer in = ByteBuffer.wrap(data).asReadOnlyBuffer();\r\n    in.mark();\r\n    assertEquals(expectedMessage.getClass(), protocol.readMessageType(in));\r\n    in.reset();\r\n    DecodingContext context = decodingContextSupplier.get();\r\n    int consumed = protocol.decode(context, in);\r\n    in.reset();\r\n    assertEquals(expectedBytesConsumed, consumed);\r\n    Message decodedMessage = context.getMessage();\r\n    assertMessageEquals(expectedMessage, decodedMessage);\r\n    ByteBuffer out = ByteBuffer.allocate(expectedBytesConsumed);\r\n    out.mark();\r\n    assertTrue(\"Protocol failed to serialize message of length: \" + expectedBytesConsumed, protocol.encode(new EncodingContext(null), decodedMessage, out));\r\n    assertEquals(expectedBytesConsumed, out.position());\r\n    byte[] encoded = new byte[expectedBytesConsumed];\r\n    out.reset();\r\n    out.get(encoded);\r\n    if (data.length > expectedBytesConsumed) {\r\n        data = Arrays.copyOfRange(data, 0, expectedBytesConsumed);\r\n    }\r\n    assertArrayEquals(data, encoded);\r\n}"
}, {
	"Path": "com.vaadin.client.connectors.grid.AbstractGridRendererConnector.getColumnId",
	"Comment": "gets the column id for a column.in case this renderer wants be able to identify a column in such a waythat the server also understands it, the column id is used for that.columns are identified by unified ids between the client and the server.",
	"Method": "String getColumnId(Column<?, JsonObject> column){\r\n    return getGridConnector().getColumnId(column);\r\n}"
}, {
	"Path": "com.vaadin.data.provider.HierarchyMapper.doExpand",
	"Comment": "expands the given item if it is collapsed and has children, and returnswhether this method expanded the item.",
	"Method": "Range doExpand(T item,Optional<Integer> position,boolean doExpand,T item){\r\n    boolean expanded = false;\r\n    if (!isExpanded(item) && hasChildren(item)) {\r\n        expandedItemIds.add(getDataProvider().getId(item));\r\n        expanded = true;\r\n    }\r\n    return expanded;\r\n}"
}, {
	"Path": "com.vaadin.client.Util.browserDebugger",
	"Comment": "helper method for debugging purposes.stops execution on firefox browsers on a breakpoint.",
	"Method": "void browserDebugger(){\r\n    WidgetUtil.browserDebugger();\r\n}"
}, {
	"Path": "com.vaadin.ui.dnd.DragSourceExtension.getDragData",
	"Comment": "get server side drag data. this data is available in the drop event andcan be used to transfer data between drag source and drop target if theyare in the same ui.",
	"Method": "Object getDragData(){\r\n    return dragData;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.GeneratedPropertyContainer.addContainerProperty",
	"Comment": "adds a previously removed property back to generatedpropertycontainer.adding a property that is not previously removed causes anunsupportedoperationexception.",
	"Method": "boolean addContainerProperty(Object propertyId,Class<?> type,Object defaultValue){\r\n    if (!removedProperties.contains(propertyId)) {\r\n        throw new UnsupportedOperationException(\"GeneratedPropertyContainer does not support adding properties.\");\r\n    }\r\n    removedProperties.remove(propertyId);\r\n    fireContainerPropertySetChange();\r\n    return true;\r\n}"
}, {
	"Path": "com.vaadin.client.WidgetUtil.isTouchEventOrLeftMouseButton",
	"Comment": "checks if the given event is either a touch event or caused by the leftmouse button.",
	"Method": "boolean isTouchEventOrLeftMouseButton(Event event){\r\n    boolean touchEvent = WidgetUtil.isTouchEvent(event);\r\n    return touchEvent || event.getButton() == Event.BUTTON_LEFT;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VDateField.isShowISOWeekNumbers",
	"Comment": "returns whether iso 8601 week numbers should be shown in the dateselector or not. iso 8601 defines that a week always starts with a mondayso the week numbers are only shown if this is the case.",
	"Method": "boolean isShowISOWeekNumbers(){\r\n    return showISOWeekNumbers;\r\n}"
}, {
	"Path": "com.vaadin.ui.TabSheet.setTabCaptionsAsHtml",
	"Comment": "sets whether html is allowed in the tab captions.if set to true, the captions are rendered in the browser as html and thedeveloper is responsible for ensuring no harmful html is used. if set tofalse, the content is rendered in the browser as plain text.the default is false, i.e. render tab captions as plain text",
	"Method": "void setTabCaptionsAsHtml(boolean tabCaptionsAsHtml){\r\n    getState().tabCaptionsAsHtml = tabCaptionsAsHtml;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.selectSelectedRows",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "boolean selectSelectedRows(UIDL uidl){\r\n    boolean keyboardSelectionOverRowFetchInProgress = false;\r\n    if (uidl.hasVariable(\"selected\")) {\r\n        final Set<String> selectedKeys = uidl.getStringArrayVariableAsSet(\"selected\");\r\n        boolean rowsUnSelected = removeUnselectedRowKeys(selectedKeys);\r\n        boolean updateFocus = rowsUnSelected || selectedRowKeys.isEmpty() || focusedRow == null;\r\n        if (scrollBody != null) {\r\n            for (Widget w : scrollBody) {\r\n                VScrollTableRow row = (VScrollTableRow) w;\r\n                boolean selected = selectedKeys.contains(row.getKey());\r\n                if (!selected && unSyncedselectionsBeforeRowFetch != null && unSyncedselectionsBeforeRowFetch.contains(row.getKey())) {\r\n                    selected = true;\r\n                    keyboardSelectionOverRowFetchInProgress = true;\r\n                }\r\n                if (selected && selectedKeys.size() == 1 && updateFocus) {\r\n                    setRowFocus(row);\r\n                }\r\n                if (selected != row.isSelected()) {\r\n                    row.toggleSelection();\r\n                    if (!isSingleSelectMode() && !selected) {\r\n                        removeRowFromUnsentSelectionRanges(row);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    unSyncedselectionsBeforeRowFetch = null;\r\n    return keyboardSelectionOverRowFetchInProgress;\r\n}"
}, {
	"Path": "com.vaadin.ui.Upload.setImmediateMode",
	"Comment": "sets the immediate mode of the upload.if the upload is in immediate mode, the file upload is startedimmediately after the user has selected the file.if the upload is not in immediate mode, after selecting the file the usermust click another button to start the upload.the default mode of an upload component is immediate.",
	"Method": "void setImmediateMode(boolean immediateMode){\r\n    getState().immediateMode = immediateMode;\r\n}"
}, {
	"Path": "com.vaadin.data.BindingValidationStatus.getValidationResults",
	"Comment": "gets all the validation results related to this binding validationstatus.",
	"Method": "List<ValidationResult> getValidationResults(){\r\n    return Collections.unmodifiableList(results);\r\n}"
}, {
	"Path": "com.github.dozermapper.core.functional_tests.WildcardWrapperTypeTest.testCanMapPrimitiveFieldAndWrapperSetterAndGetter",
	"Comment": "mapping should work without configuration when field is primitive andboth getter and setters are of wrapper type.",
	"Method": "void testCanMapPrimitiveFieldAndWrapperSetterAndGetter(){\r\n    PrimitiveFieldWrapperGetterAndSetter source = new PrimitiveFieldWrapperGetterAndSetter();\r\n    source.setPrimitive(Integer.MIN_VALUE);\r\n    PrimitiveFieldWrapperGetterAndSetter target = mapper.map(source, PrimitiveFieldWrapperGetterAndSetter.class);\r\n    assertThat(target.getPrimitive(), equalTo(Integer.MIN_VALUE));\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.escalator.ScrollbarBundle.updateScrollPosFromDom",
	"Comment": "this is a method that jsni can call to synchronize the object state fromthe dom.",
	"Method": "void updateScrollPosFromDom(){\r\n    int newScrollPos = internalGetScrollPos();\r\n    if (!isLocked()) {\r\n        scrollPos = newScrollPos;\r\n        scrollEventFirer.scheduleEvent();\r\n    } else if (scrollPos != newScrollPos) {\r\n        internalSetScrollPos(toInt32(scrollPos));\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractField.isReadOnly",
	"Comment": "the abstract field is read only also if the data source is in read onlymode.",
	"Method": "boolean isReadOnly(){\r\n    return super.isReadOnly() || dataSource != null && dataSource.isReadOnly();\r\n}"
}, {
	"Path": "net.openhft.chronicle.queue.stateless.StatelessTailer.wire",
	"Comment": "the wire associated with the current index, calling this method moves on the index",
	"Method": "WireIn wire(){\r\n    if (index == -1) {\r\n        index = statelessRawBytesTailer.lastWrittenIndex();\r\n    }\r\n    final Bytes bytes = statelessRawBytesTailer.readExcept(index);\r\n    index++;\r\n    return wireFunction.apply(bytes);\r\n}"
}, {
	"Path": "com.vaadin.ui.PopupView.setContent",
	"Comment": "this method will replace the current content of the panel with a new one.",
	"Method": "void setContent(PopupView.Content newContent){\r\n    if (newContent == null) {\r\n        throw new IllegalArgumentException(\"Content must not be null\");\r\n    }\r\n    content = newContent;\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.updateRowsInBody",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void updateRowsInBody(UIDL partialRowUpdates){\r\n    if (partialRowUpdates == null) {\r\n        return;\r\n    }\r\n    int firstRowIx = partialRowUpdates.getIntAttribute(\"firsturowix\");\r\n    int count = partialRowUpdates.getIntAttribute(\"numurows\");\r\n    scrollBody.unlinkRows(firstRowIx, count);\r\n    scrollBody.insertRows(partialRowUpdates, firstRowIx, count);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.connectors.GridConnector.purgeRemovedColumns",
	"Comment": "removes any orphan columns that has been removed from the state from thegrid",
	"Method": "void purgeRemovedColumns(){\r\n    Set<String> columnsInState = new HashSet<String>();\r\n    for (GridColumnState columnState : getState().columns) {\r\n        columnsInState.add(columnState.id);\r\n    }\r\n    Iterator<String> columnIdIterator = columnIdToColumn.keySet().iterator();\r\n    while (columnIdIterator.hasNext()) {\r\n        String id = columnIdIterator.next();\r\n        if (!columnsInState.contains(id)) {\r\n            CustomGridColumn column = columnIdToColumn.get(id);\r\n            columnIdIterator.remove();\r\n            getWidget().removeColumn(column);\r\n            columnOrder.remove(id);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.AbstractClickEventHandler.shouldFireEvent",
	"Comment": "called before firing a click event. allows sub classes to decide if thisin an event that should cause an event or not.",
	"Method": "boolean shouldFireEvent(DomEvent<?> event){\r\n    return true;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.HierarchyMapper.removeChildren",
	"Comment": "removes all children of an item identified by a given id. items removedby this method as well as the original item are all marked to becollapsed. may be overridden in subclasses for removing obsolete data toavoid memory leaks.",
	"Method": "void removeChildren(Object id){\r\n    Iterator<Entry<T, Set<T>>> iterator = childMap.entrySet().iterator();\r\n    Set<T> invalidatedChildren = new HashSet();\r\n    while (iterator.hasNext()) {\r\n        Entry<T, Set<T>> entry = iterator.next();\r\n        T key = entry.getKey();\r\n        if (key != null && getDataProvider().getId(key).equals(id)) {\r\n            invalidatedChildren.addAll(entry.getValue());\r\n            iterator.remove();\r\n        }\r\n    }\r\n    expandedItemIds.remove(id);\r\n    invalidatedChildren.stream().map(getDataProvider()::getId).forEach(x -> {\r\n        removeChildren(x);\r\n        parentIdMap.remove(x);\r\n    });\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.bringToFront",
	"Comment": "if there are currently several windows visible, calling this method makesthis window topmost.this method can only be called if this window connected a ui. else anillegal state exception is thrown. also if there are modal windows andthis window is not modal, and illegal state exception is thrown.",
	"Method": "void bringToFront(){\r\n    UI uI = getUI();\r\n    if (uI == null) {\r\n        throw new IllegalStateException(\"Window must be attached to parent before calling bringToFront method.\");\r\n    }\r\n    int maxBringToFront = -1;\r\n    for (Window w : uI.getWindows()) {\r\n        if (!isModal() && w.isModal()) {\r\n            throw new IllegalStateException(\"The UI contains modal windows, non-modal window cannot be brought to front.\");\r\n        }\r\n        if (w.bringToFront != null) {\r\n            maxBringToFront = Math.max(maxBringToFront, w.bringToFront.intValue());\r\n        }\r\n    }\r\n    bringToFront = Integer.valueOf(maxBringToFront + 1);\r\n    markAsDirty();\r\n}"
}, {
	"Path": "org.greenrobot.essentials.io.IoUtils.copyAllBytes",
	"Comment": "copies all available data from in to out without closing any stream.",
	"Method": "int copyAllBytes(InputStream in,OutputStream out){\r\n    int byteCount = 0;\r\n    byte[] buffer = new byte[BUFFER_SIZE];\r\n    while (true) {\r\n        int read = in.read(buffer);\r\n        if (read == -1) {\r\n            break;\r\n        }\r\n        out.write(buffer, 0, read);\r\n        byteCount += read;\r\n    }\r\n    return byteCount;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractField.getConversionError",
	"Comment": "gets the error that is shown if the field value cannot be converted tothe data source type.",
	"Method": "String getConversionError(Class<?> dataSourceType,ConversionException e,String getConversionError){\r\n    return conversionError;\r\n}"
}, {
	"Path": "com.vaadin.server.ComponentSizeValidator.validateComponentRelativeSizes",
	"Comment": "recursively checks given component and its subtree for invalid layoutsetups. prints errors to std err stream.",
	"Method": "List<InvalidLayout> validateComponentRelativeSizes(Component component,List<InvalidLayout> errors,InvalidLayout parent){\r\n    if (component != null) {\r\n        boolean invalidHeight = !checkHeights(component);\r\n        boolean invalidWidth = !checkWidths(component);\r\n        if (invalidHeight || invalidWidth) {\r\n            InvalidLayout error = new InvalidLayout(component, invalidHeight, invalidWidth);\r\n            if (parent != null) {\r\n                parent.addError(error);\r\n            } else {\r\n                if (errors == null) {\r\n                    errors = new LinkedList();\r\n                }\r\n                errors.add(error);\r\n            }\r\n            parent = error;\r\n        }\r\n    }\r\n    if (component instanceof Panel) {\r\n        Panel panel = (Panel) component;\r\n        errors = validateComponentRelativeSizes(panel.getContent(), errors, parent);\r\n    } else if (component instanceof ComponentContainer) {\r\n        ComponentContainer lo = (ComponentContainer) component;\r\n        Iterator<Component> it = lo.getComponentIterator();\r\n        while (it.hasNext()) {\r\n            errors = validateComponentRelativeSizes(it.next(), errors, parent);\r\n        }\r\n    } else if (isForm(component)) {\r\n        HasComponents form = (HasComponents) component;\r\n        for (Component child : form) {\r\n            errors = validateComponentRelativeSizes(child, errors, parent);\r\n        }\r\n    }\r\n    return errors;\r\n}"
}, {
	"Path": "com.vaadin.client.ConnectorMap.getConnector",
	"Comment": "retrieves the connector whose widget matches the parameter.",
	"Method": "ServerConnector getConnector(String connectorId,ComponentConnector getConnector,Element element,ComponentConnector getConnector,Widget widget){\r\n    return widget == null ? null : getConnector(widget.getElement());\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.isDraggable",
	"Comment": "indicates whether a window can be dragged or not. by default a window isdraggable.",
	"Method": "boolean isDraggable(){\r\n    return getState(false).draggable;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.ContainerOrderedWrapper.addItem",
	"Comment": "registers a new item by its id to the underlying container and to theordering.",
	"Method": "Object addItem(Item addItem,Object itemId){\r\n    final Item item = container.addItem(itemId);\r\n    if (!ordered && item != null) {\r\n        addToOrderWrapper(itemId);\r\n    }\r\n    return item;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.TouchScrollDelegate.detectScrolledElement",
	"Comment": "detects if a touch happens on a predefined element and the element hassomething to scroll.",
	"Method": "boolean detectScrolledElement(Touch touch){\r\n    Element target = touch.getTarget().cast();\r\n    for (Element el : scrollableElements) {\r\n        if (el.isOrHasChild(target) && el.getScrollHeight() > el.getClientHeight()) {\r\n            scrolledElement = el;\r\n            layers = getElements(scrolledElement);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.getUIs",
	"Comment": "gets all the uis of this session. this includes uis that have beenrequested but not yet initialized. uis that receive no heartbeat requestsfrom the client are eventually removed from the session.",
	"Method": "Collection<UI> getUIs(){\r\n    assert hasLock();\r\n    return Collections.unmodifiableCollection(uIs.values());\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addBodyClickHandler",
	"Comment": "register a bodyclickhandler to this grid. the event for this handler isfired when a click event occurs in the body of this grid.",
	"Method": "HandlerRegistration addBodyClickHandler(BodyClickHandler handler){\r\n    return addHandler(handler, GridClickEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.grid.sort.Sort.then",
	"Comment": "continue building a sort order. the provided column is sorted inspecified order if the previously added columns have been evaluated asequals.",
	"Method": "Sort then(Grid.Column<?, ?> column,Sort then,Grid.Column<?, ?> column,SortDirection direction){\r\n    return new Sort(this, column, direction);\r\n}"
}, {
	"Path": "com.vaadin.ui.ComponentTest.syncToClient",
	"Comment": "perform operations on the component similar to what would be done whenthe component state is communicated to the client, e.g. update diff stateand mark as clean.",
	"Method": "void syncToClient(AbstractComponent component){\r\n    updateDiffState(component);\r\n    component.getUI().getConnectorTracker().markClean(component);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.getPropertyValue",
	"Comment": "gets the value of property.by default if the table is editable the fieldfactory is used to createeditors for table cells. otherwise formatpropertyvalue is used to formatthe value representation.",
	"Method": "Object getPropertyValue(Object rowId,Object colId,Property property){\r\n    if (isEditable() && fieldFactory != null) {\r\n        final Field<?> f = fieldFactory.createField(getContainerDataSource(), rowId, colId, this);\r\n        if (f != null) {\r\n            associatedProperties.put(f, property);\r\n            bindPropertyToField(rowId, colId, property, f);\r\n            return f;\r\n        }\r\n    }\r\n    return formatPropertyValue(rowId, colId, property);\r\n}"
}, {
	"Path": "com.vaadin.client.communication.DefaultConnectionStateHandler.stopDialogTimer",
	"Comment": "ensures the reconnect dialog does not popup some time from now",
	"Method": "void stopDialogTimer(){\r\n    if (dialogShowTimer.isRunning()) {\r\n        dialogShowTimer.cancel();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.Design.setComponentFactory",
	"Comment": "sets the component factory that is used for creating component instancesbased on fully qualified class names derived from a design file.please note that this setting is global, so care should be taken to avoidconflicting changes.",
	"Method": "void setComponentFactory(ComponentFactory componentFactory){\r\n    if (componentFactory == null) {\r\n        throw new IllegalArgumentException(\"Cannot set null component factory\");\r\n    }\r\n    Design.componentFactory = componentFactory;\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.events.SelectAllEvent.isAllSelected",
	"Comment": "returns whether all the rows were selected, or deselected. deselectioncan only happen if all rows were previously selected.",
	"Method": "boolean isAllSelected(){\r\n    return allSelected;\r\n}"
}, {
	"Path": "com.vaadin.server.communication.PushHandler.callWithUi",
	"Comment": "find the ui for the atmosphere resource, lock it and invoke the callback.",
	"Method": "void callWithUi(AtmosphereResource resource,PushEventCallback callback,boolean websocket){\r\n    AtmosphereRequest req = resource.getRequest();\r\n    VaadinServletRequest vaadinRequest = new VaadinServletRequest(req, service);\r\n    VaadinSession session = null;\r\n    if (websocket) {\r\n        service.requestStart(vaadinRequest, null);\r\n    }\r\n    try {\r\n        try {\r\n            session = service.findVaadinSession(vaadinRequest);\r\n            assert VaadinSession.getCurrent() == session;\r\n        } catch (ServiceException e) {\r\n            getLogger().log(Level.SEVERE, \"Could not get session. This should never happen\", e);\r\n            return;\r\n        } catch (SessionExpiredException e) {\r\n            SystemMessages msg = service.getSystemMessages(ServletPortletHelper.findLocale(null, null, vaadinRequest), vaadinRequest);\r\n            sendNotificationAndDisconnect(resource, VaadinService.createCriticalNotificationJSON(msg.getSessionExpiredCaption(), msg.getSessionExpiredMessage(), null, msg.getSessionExpiredURL()));\r\n            return;\r\n        }\r\n        UI ui = null;\r\n        session.lock();\r\n        try {\r\n            ui = service.findUI(vaadinRequest);\r\n            assert UI.getCurrent() == ui;\r\n            if (ui == null) {\r\n                sendNotificationAndDisconnect(resource, UidlRequestHandler.getUINotFoundErrorJSON(service, vaadinRequest));\r\n            } else {\r\n                callback.run(resource, ui);\r\n            }\r\n        } catch (final IOException e) {\r\n            callErrorHandler(session, e);\r\n        } catch (final Exception e) {\r\n            SystemMessages msg = service.getSystemMessages(ServletPortletHelper.findLocale(null, null, vaadinRequest), vaadinRequest);\r\n            AtmosphereResource errorResource = resource;\r\n            if (ui != null && ui.getPushConnection() != null) {\r\n                errorResource = ((AtmospherePushConnection) ui.getPushConnection()).getResource();\r\n            }\r\n            sendNotificationAndDisconnect(errorResource, VaadinService.createCriticalNotificationJSON(msg.getInternalErrorCaption(), msg.getInternalErrorMessage(), null, msg.getInternalErrorURL()));\r\n            callErrorHandler(session, e);\r\n        } finally {\r\n            try {\r\n                session.unlock();\r\n            } catch (Exception e) {\r\n                getLogger().log(Level.WARNING, \"Error while unlocking session\", e);\r\n            }\r\n        }\r\n    } finally {\r\n        try {\r\n            if (websocket) {\r\n                service.requestEnd(vaadinRequest, null, session);\r\n            }\r\n        } catch (Exception e) {\r\n            getLogger().log(Level.WARNING, \"Error while ending request\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.Tree.isAutoRecalculateWidth",
	"Comment": "returns the current state of automatic width recalculation.",
	"Method": "boolean isAutoRecalculateWidth(){\r\n    return autoRecalculateWidth;\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.StaticSection.addColumn",
	"Comment": "adds a cell corresponding to the given column id to this section.",
	"Method": "void addColumn(String columnId){\r\n    for (ROW row : rows) {\r\n        row.internalAddCell(columnId);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.filter.IsNull.getPropertyId",
	"Comment": "returns the property id of the property tested by the filter, not nullfor valid filters.",
	"Method": "Object getPropertyId(){\r\n    return propertyId;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheetBase.setClient",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setClient(ApplicationConnection client){\r\n    this.client = client;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.setFocusChangeListener",
	"Comment": "the given focuschangelistener is notified when the focused date changesby user either clicking on a new date or by using the keyboard.",
	"Method": "void setFocusChangeListener(FocusChangeListener listener){\r\n    focusChangeListener = listener;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.ProgressBar.setIndeterminate",
	"Comment": "sets whether or not this progress indicator is indeterminate. inindeterminate mode there is an animation indicating that the task isrunning but without providing any information about the current progress.",
	"Method": "void setIndeterminate(boolean indeterminate){\r\n    getState().indeterminate = indeterminate;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.getCellStyleGenerator",
	"Comment": "gets the style generator that is used for generating styles for cells.",
	"Method": "CellStyleGenerator<T> getCellStyleGenerator(){\r\n    return cellStyleGenerator;\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.setAssistiveDescription",
	"Comment": "allows to specify which components contain the description for thewindow. text contained in these components will be read by assistivedevices when it is opened.",
	"Method": "void setAssistiveDescription(Component components){\r\n    if (components == null) {\r\n        throw new IllegalArgumentException(\"Parameter connectors must be non-null\");\r\n    } else {\r\n        getState().contentDescription = components;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.schedule.CalendarEvent.getDescription",
	"Comment": "get the description of the event. the description is the text displayedwhen hovering over the event with the mouse",
	"Method": "String getDescription(){\r\n    return description;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.setRowStyleGenerator",
	"Comment": "sets the style generator that is used for generating styles for rows.",
	"Method": "void setRowStyleGenerator(RowStyleGenerator rowStyleGenerator){\r\n    this.rowStyleGenerator = rowStyleGenerator;\r\n    datasourceExtension.refreshCache();\r\n}"
}, {
	"Path": "com.vaadin.data.validator.RangeValidator.isMaxValueIncluded",
	"Comment": "returns whether the maximum value is part of the accepted range.",
	"Method": "boolean isMaxValueIncluded(){\r\n    return maxValueIncluded;\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignContext.getPackagePrefix",
	"Comment": "gets the prefix mapping for a given package, or null ifthere is no mapping for the package.",
	"Method": "String getPackagePrefix(String packageName){\r\n    if (VAADIN_UI_PACKAGE.equals(packageName)) {\r\n        return isLegacyPrefixEnabled() ? LEGACY_PREFIX : VAADIN_PREFIX;\r\n    } else {\r\n        return packageToPrefix.get(packageName);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.communication.MessageHandler.resumeResponseHandling",
	"Comment": "resumes the rendering process once all locks have been removed.",
	"Method": "void resumeResponseHandling(Object lock){\r\n    responseHandlingLocks.remove(lock);\r\n    if (responseHandlingLocks.isEmpty()) {\r\n        forceHandleMessage.cancel();\r\n        if (!pendingUIDLMessages.isEmpty()) {\r\n            getLogger().info(\"No more response handling locks, handling pending requests.\");\r\n            handlePendingMessages();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.isColumnReorderingAllowed",
	"Comment": "returns whether column reordering is allowed. default value isfalse.",
	"Method": "boolean isColumnReorderingAllowed(){\r\n    return getState(false).columnReorderingAllowed;\r\n}"
}, {
	"Path": "com.vaadin.client.communication.MessageHandler.stripJSONWrapping",
	"Comment": "strips the json wrapping from the given json string with wrapping.if the given string is not wrapped as expected, returns null",
	"Method": "String stripJSONWrapping(String jsonWithWrapping){\r\n    if (jsonWithWrapping == null) {\r\n        return null;\r\n    }\r\n    if (!jsonWithWrapping.startsWith(JSON_COMMUNICATION_PREFIX) || !jsonWithWrapping.endsWith(JSON_COMMUNICATION_SUFFIX)) {\r\n        return null;\r\n    }\r\n    return jsonWithWrapping.substring(JSON_COMMUNICATION_PREFIX.length(), jsonWithWrapping.length() - JSON_COMMUNICATION_SUFFIX.length());\r\n}"
}, {
	"Path": "com.vaadin.client.Util.mayHaveScrollBars",
	"Comment": "detects what is currently the overflow style attribute in given element.",
	"Method": "boolean mayHaveScrollBars(com.google.gwt.dom.client.Element pe){\r\n    return WidgetUtil.mayHaveScrollBars(pe);\r\n}"
}, {
	"Path": "com.vdurmont.emoji.Emoji.supportsFitzpatrick",
	"Comment": "returns wether the emoji supports the fitzpatrick modifiers or not",
	"Method": "boolean supportsFitzpatrick(){\r\n    return this.supportsFitzpatrick;\r\n}"
}, {
	"Path": "com.github.dozermapper.core.builder.xml.SchemaLSResourceResolver.resolveFromURL",
	"Comment": "attempts to open a http connection for the systemid resource, and follows the first redirect",
	"Method": "InputStream resolveFromURL(String systemId){\r\n    LOG.debug(\"Trying to download [{}]\", systemId);\r\n    URL obj = new URL(systemId);\r\n    HttpURLConnection conn = (HttpURLConnection) obj.openConnection();\r\n    int status = conn.getResponseCode();\r\n    if ((status != HttpURLConnection.HTTP_OK) && (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER)) {\r\n        LOG.debug(\"Received status of {}, attempting to follow Location header\", status);\r\n        String newUrl = conn.getHeaderField(\"Location\");\r\n        conn = (HttpURLConnection) new URL(newUrl).openConnection();\r\n    }\r\n    return conn.getInputStream();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.containerPropertySetChange",
	"Comment": "notifies this listener that the containers contents has changed.",
	"Method": "void containerPropertySetChange(Container.PropertySetChangeEvent event){\r\n    firePropertySetChange();\r\n}"
}, {
	"Path": "com.vaadin.client.communication.JsonEncoder.getTransportType",
	"Comment": "returns the transport type for the given value. only returns a transporttype for internally handled values.",
	"Method": "String getTransportType(Object value){\r\n    if (value == null) {\r\n        return JsonConstants.VTYPE_NULL;\r\n    } else if (value instanceof String) {\r\n        return JsonConstants.VTYPE_STRING;\r\n    } else if (value instanceof Connector) {\r\n        return JsonConstants.VTYPE_CONNECTOR;\r\n    } else if (value instanceof Boolean) {\r\n        return JsonConstants.VTYPE_BOOLEAN;\r\n    } else if (value instanceof Integer) {\r\n        return JsonConstants.VTYPE_INTEGER;\r\n    } else if (value instanceof Float) {\r\n        return JsonConstants.VTYPE_FLOAT;\r\n    } else if (value instanceof Double) {\r\n        return JsonConstants.VTYPE_DOUBLE;\r\n    } else if (value instanceof Long) {\r\n        return JsonConstants.VTYPE_LONG;\r\n    } else if (value instanceof List) {\r\n        return JsonConstants.VTYPE_LIST;\r\n    } else if (value instanceof Set) {\r\n        return JsonConstants.VTYPE_SET;\r\n    } else if (value instanceof String[]) {\r\n        return JsonConstants.VTYPE_STRINGARRAY;\r\n    } else if (value instanceof Object[]) {\r\n        return JsonConstants.VTYPE_ARRAY;\r\n    } else if (value instanceof Map) {\r\n        return JsonConstants.VTYPE_MAP;\r\n    } else if (value instanceof Enum<?>) {\r\n        return JsonConstants.VTYPE_STRING;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.aria.AriaHelper.ensureHasId",
	"Comment": "makes sure that the provided element has an id attribute. adds a newunique id if not.",
	"Method": "String ensureHasId(Element element){\r\n    assert element != null : \"Valid Element required\";\r\n    String id = element.getId();\r\n    if (null == id || id.isEmpty()) {\r\n        id = DOM.createUniqueId();\r\n        element.setId(id);\r\n    }\r\n    return id;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.getTableFieldFactory",
	"Comment": "gets the tablefieldfactory that is used to create editor for table cells.the fieldfactory is only used if the table is editable.",
	"Method": "TableFieldFactory getTableFieldFactory(){\r\n    return fieldFactory;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.getForSession",
	"Comment": "loads the vaadinsession for the given service and wrappedsession from thehttp session.",
	"Method": "VaadinSession getForSession(VaadinService service,WrappedSession underlyingSession){\r\n    return service.loadSession(underlyingSession);\r\n}"
}, {
	"Path": "com.github.dozermapper.core.DozerConverter.getParameter",
	"Comment": "retrieves the static parameter configured for this particular converter instance.it is not advisable to call this method from converter constructor as the parameter is not yet there.",
	"Method": "String getParameter(){\r\n    if (parameter == null) {\r\n        throw new IllegalStateException(\"Custom Converter Parameter has not yet been set!\");\r\n    }\r\n    return parameter;\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignAttributeHandler.getSupportedAttributes",
	"Comment": "searches for supported setter and getter types from the specified classand returns the list of corresponding design attributes.",
	"Method": "Collection<String> getSupportedAttributes(Class<?> clazz){\r\n    resolveSupportedAttributes(clazz);\r\n    return CACHE.get(clazz).getAttributes();\r\n}"
}, {
	"Path": "com.vaadin.client.LayoutManager.delayOverflowFix",
	"Comment": "delay the overflow fix if the involved connectors might still change",
	"Method": "boolean delayOverflowFix(ComponentConnector componentConnector){\r\n    if (!currentDependencyTree.noMoreChangesExpected(componentConnector)) {\r\n        return true;\r\n    }\r\n    ServerConnector parent = componentConnector.getParent();\r\n    if (parent instanceof ComponentConnector && !currentDependencyTree.noMoreChangesExpected((ComponentConnector) parent)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTreeTable.handleNavigation",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "boolean handleNavigation(int keycode,boolean ctrl,boolean shift){\r\n    if (collapseRequest || focusParentResponsePending) {\r\n        if (pendingNavigationEvents.size() < 10) {\r\n            PendingNavigationEvent pendingNavigationEvent = new PendingNavigationEvent(keycode, ctrl, shift);\r\n            pendingNavigationEvents.add(pendingNavigationEvent);\r\n        }\r\n        return true;\r\n    }\r\n    VTreeTableRow focusedRow = (VTreeTableRow) getFocusedRow();\r\n    if (focusedRow != null) {\r\n        if (focusedRow.canHaveChildren && ((keycode == KeyCodes.KEY_RIGHT && !focusedRow.open) || (keycode == KeyCodes.KEY_LEFT && focusedRow.open))) {\r\n            if (!ctrl) {\r\n                client.updateVariable(paintableId, \"selectCollapsed\", true, false);\r\n            }\r\n            sendSelectedRows(false);\r\n            sendToggleCollapsedUpdate(focusedRow.getKey());\r\n            return true;\r\n        } else if (keycode == KeyCodes.KEY_RIGHT && focusedRow.open) {\r\n            VTreeTableScrollBody body = (VTreeTableScrollBody) focusedRow.getParent();\r\n            Iterator<Widget> iterator = body.iterator();\r\n            VTreeTableRow next = null;\r\n            while (iterator.hasNext()) {\r\n                next = (VTreeTableRow) iterator.next();\r\n                if (next == focusedRow) {\r\n                    next = (VTreeTableRow) iterator.next();\r\n                    break;\r\n                }\r\n            }\r\n            if (next != null) {\r\n                if (next.depth > focusedRow.depth) {\r\n                    selectionPending = true;\r\n                    return super.handleNavigation(getNavigationDownKey(), ctrl, shift);\r\n                }\r\n            } else {\r\n                selectionPending = true;\r\n                return super.handleNavigation(getNavigationDownKey(), ctrl, shift);\r\n            }\r\n        } else if (keycode == KeyCodes.KEY_LEFT) {\r\n            client.updateVariable(paintableId, \"focusParent\", focusedRow.getKey(), true);\r\n            focusParentResponsePending = true;\r\n            return true;\r\n        }\r\n    }\r\n    return super.handleNavigation(keycode, ctrl, shift);\r\n}"
}, {
	"Path": "lbms.plugins.mldht.kad.Database.genToken",
	"Comment": "generate a write token, which will give peers write access to the db.",
	"Method": "ByteWrapper genToken(Key nodeId,InetAddress ip,int port,Key lookupKey){\r\n    updateTokenTimestamps();\r\n    byte[] tdata = new byte[Key.SHA1_HASH_LENGTH + ip.getAddress().length + 2 + 8 + Key.SHA1_HASH_LENGTH + sessionSecret.length];\r\n    ByteBuffer bb = ByteBuffer.wrap(tdata);\r\n    nodeId.toBuffer(bb);\r\n    bb.put(ip.getAddress());\r\n    bb.putShort((short) port);\r\n    bb.putLong(timestampCurrent.get());\r\n    lookupKey.toBuffer(bb);\r\n    bb.put(sessionSecret);\r\n    byte[] token = Arrays.copyOf(ThreadLocalUtils.getThreadLocalSHA1().digest(tdata), 4);\r\n    return new ByteWrapper(token);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.grid.AutoScroller.getScrollArea",
	"Comment": "returns the size of the auto scroll area in pixels.defaults to 100px.",
	"Method": "int getScrollArea(){\r\n    return scrollAreaPX;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.setItemCaption",
	"Comment": "override the caption of an item. setting caption explicitly overrides id,item and index captions.",
	"Method": "void setItemCaption(Object itemId,String caption){\r\n    if (itemId != null) {\r\n        itemCaptions.put(itemId, caption);\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.addFooterClickListener",
	"Comment": "adds a footer click listener which handles the click events when the userclicks on a column footer cell in the table.the listener will receive events which contain information about whichcolumn was clicked and some details about the mouse event.",
	"Method": "void addFooterClickListener(FooterClickListener listener){\r\n    addListener(TableConstants.FOOTER_CLICK_EVENT_ID, FooterClickEvent.class, listener, FooterClickEvent.FOOTER_CLICK_METHOD);\r\n}"
}, {
	"Path": "com.vaadin.ui.ComponentTest.updateDiffState",
	"Comment": "updates the stored diff state from the current component state.",
	"Method": "void updateDiffState(AbstractComponent component){\r\n    LegacyCommunicationManager.encodeState(component, component.getState());\r\n}"
}, {
	"Path": "brave.servlet.HttpServletAdapter.adaptResponse",
	"Comment": "not static so that this can be overridden by implementations as needed.",
	"Method": "HttpServletResponse adaptResponse(HttpServletRequest req,HttpServletResponse resp){\r\n    String httpRoute = (String) req.getAttribute(\"http.route\");\r\n    return httpRoute != null ? new DecoratedHttpServletResponse(resp, req.getMethod(), httpRoute) : resp;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.CacheFlushNotifier.notifyOfCacheFlush",
	"Comment": "iterates through the instances and notifies containers which areconnected to the same table or are using the same query string.",
	"Method": "void notifyOfCacheFlush(SQLContainer c){\r\n    removeDeadReferences();\r\n    for (WeakReference<SQLContainer> wr : allInstances) {\r\n        if (wr.get() != null) {\r\n            SQLContainer wrc = wr.get();\r\n            if (wrc == null) {\r\n                continue;\r\n            }\r\n            if (wrc.equals(c)) {\r\n                continue;\r\n            }\r\n            QueryDelegate wrQd = wrc.getQueryDelegate();\r\n            QueryDelegate qd = c.getQueryDelegate();\r\n            if (wrQd instanceof TableQuery && qd instanceof TableQuery && ((TableQuery) wrQd).getTableName().equals(((TableQuery) qd).getTableName())) {\r\n                wrc.refresh();\r\n            } else if (wrQd instanceof FreeformQuery && qd instanceof FreeformQuery && ((FreeformQuery) wrQd).getQueryString().equals(((FreeformQuery) qd).getQueryString())) {\r\n                wrc.refresh();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridRowDragger.getGridDragSource",
	"Comment": "returns the drag source grid, exposing it for customizations.",
	"Method": "GridDragSource<T> getGridDragSource(){\r\n    return gridDragSource;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponentContainer.addComponent",
	"Comment": "this only implements the events and component parent calls. the extendingclasses must implement component list maintenance and call this methodafter component list maintenance.",
	"Method": "void addComponent(Component c){\r\n    if (isOrHasAncestor(c)) {\r\n        throw new IllegalArgumentException(\"Component cannot be added inside it's own content\");\r\n    }\r\n    if (c.getParent() != null) {\r\n        AbstractSingleComponentContainer.removeFromParent(c);\r\n    }\r\n    c.setParent(this);\r\n    fireComponentAttachEvent(c);\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.client.BrowserInfo.getBrowserMajorVersion",
	"Comment": "returns the browser major version e.g., 3 for firefox 3.5, 4 for chrome4, 8 for internet explorer 8.note that internet explorer 8 and newer will return the document mode soie8 rendering as ie7 will return 7.",
	"Method": "int getBrowserMajorVersion(){\r\n    return browserDetails.getBrowserMajorVersion();\r\n}"
}, {
	"Path": "com.vaadin.data.provider.InMemoryDataProvider.addSortOrder",
	"Comment": "adds a property and direction to the default sorting for this dataprovider. if no default sorting has been defined, then the provided sortorder will be used as the default sorting. if a default sorting has beendefined, then the provided sort order will be used to determine theordering of items that are considered equal by the previously defineddefault sorting.the default sorting is used if the query defines no sorting. the defaultsorting is also used to determine the ordering of items that areconsidered equal by the sorting defined in the query.",
	"Method": "void addSortOrder(ValueProvider<T, V> valueProvider,SortDirection sortDirection){\r\n    addSortComparator(InMemoryDataProviderHelpers.propertyComparator(valueProvider, sortDirection));\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VDateField.isShowISOWeekNumbers",
	"Comment": "returns whether iso 8601 week numbers should be shown in the dateselector or not. iso 8601 defines that a week always starts with a mondayso the week numbers are only shown if this is the case.",
	"Method": "boolean isShowISOWeekNumbers(){\r\n    return showISOWeekNumbers;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.writeItem",
	"Comment": "writes a data source item to a design. hierarchical select componentsshould override this method to recursively write any child items as well.",
	"Method": "Element writeItem(Element design,Object itemId,DesignContext context){\r\n    Element element = design.appendElement(\"option\");\r\n    String caption = getItemCaption(itemId);\r\n    if (caption != null && !caption.equals(itemId.toString())) {\r\n        element.html(DesignFormatter.encodeForTextNode(caption));\r\n        element.attr(\"item-id\", itemId.toString());\r\n    } else {\r\n        element.html(DesignFormatter.encodeForTextNode(itemId.toString()));\r\n    }\r\n    Resource icon = getItemIcon(itemId);\r\n    if (icon != null) {\r\n        DesignAttributeHandler.writeAttribute(\"icon\", element.attributes(), icon, null, Resource.class, context);\r\n    }\r\n    if (isSelected(itemId)) {\r\n        element.attr(\"selected\", \"\");\r\n    }\r\n    return element;\r\n}"
}, {
	"Path": "com.vaadin.client.BrowserInfo.requiresTouchScrollDelegate",
	"Comment": "checks if the browser is capable of handling scrolling natively or if atouch scroll helper is needed for scrolling.",
	"Method": "boolean requiresTouchScrollDelegate(){\r\n    if (!isTouchDevice()) {\r\n        return false;\r\n    }\r\n    if (isAndroid() && isWebkit() && getWebkitVersion() >= 534) {\r\n        return false;\r\n    }\r\n    if (isIOS() && isWebkit() && getOperatingSystemMajorVersion() >= 6) {\r\n        return false;\r\n    }\r\n    if (isIE()) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VUpload.disableTitle",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void disableTitle(boolean disable){\r\n    if (disable) {\r\n        if (BrowserInfo.get().isChrome()) {\r\n            fu.setTitle(\" \");\r\n        } else if (BrowserInfo.get().isFirefox()) {\r\n            fu.getElement().setAttribute(\"title\", \"\");\r\n        }\r\n    } else {\r\n        fu.setTitle(null);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.fireColumnResizeEvent",
	"Comment": "fires a column resize event which sends the resize information to theserver.",
	"Method": "void fireColumnResizeEvent(String columnId,int originalWidth,int newWidth){\r\n    client.updateVariable(paintableId, \"columnResizeEventColumn\", columnId, false);\r\n    client.updateVariable(paintableId, \"columnResizeEventPrev\", originalWidth, false);\r\n    client.updateVariable(paintableId, \"columnResizeEventCurr\", newWidth, immediate);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.onTabOut",
	"Comment": "if true should be returned if the panel will not be used after thisevent.",
	"Method": "boolean onTabOut(DomEvent<?> event){\r\n    if (focusOutListener != null) {\r\n        return focusOutListener.onFocusOut(event);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.v7.event.SortEvent.isUserOriginated",
	"Comment": "returns whether this event originated from actions done by the user.",
	"Method": "boolean isUserOriginated(){\r\n    return userOriginated;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendar.getForwardListener",
	"Comment": "get the listener which listens to forward events from the calendar.",
	"Method": "ForwardListener getForwardListener(){\r\n    return forwardListener;\r\n}"
}, {
	"Path": "com.vaadin.client.communication.DefaultConnectionStateHandler.updateDialog",
	"Comment": "called whenever a reconnect attempt fails to allow updating of dialogcontents.",
	"Method": "void updateDialog(){\r\n    reconnectDialog.setText(getDialogText(reconnectAttempt));\r\n}"
}, {
	"Path": "com.vaadin.ui.LegacyWindow.getURL",
	"Comment": "gets the full url of the window. the returned url is window specific andcan be used to directly refer to the window.note! this method can not be used for portlets.",
	"Method": "URL getURL(){\r\n    LegacyApplication application = getApplication();\r\n    if (application == null) {\r\n        return null;\r\n    }\r\n    try {\r\n        return new URL(application.getURL(), getName() + \"/\");\r\n    } catch (MalformedURLException e) {\r\n        throw new RuntimeException(\"Internal problem getting window URL, please report\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.getDefaultHeaderRow",
	"Comment": "returns the current default row of the header section. the default row isa special header row providing a user interface for sorting columns.setting a header text for column updates cells in the default header.",
	"Method": "HeaderRow getDefaultHeaderRow(){\r\n    return header.getDefaultRow();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Tree.readItem",
	"Comment": "reads an item from a design and inserts it into the data source.recursively handles any children of the item as well.",
	"Method": "String readItem(Element node,Set<String> selected,DesignContext context){\r\n    if (!\"node\".equals(node.tagName())) {\r\n        throw new DesignException(\"Unrecognized child element in \" + getClass().getSimpleName() + \": \" + node.tagName());\r\n    }\r\n    String itemId = node.attr(\"text\");\r\n    addItem(itemId);\r\n    if (node.hasAttr(\"icon\")) {\r\n        Resource icon = DesignAttributeHandler.readAttribute(\"icon\", node.attributes(), Resource.class);\r\n        setItemIcon(itemId, icon);\r\n    }\r\n    if (node.hasAttr(\"selected\")) {\r\n        selected.add(itemId);\r\n    }\r\n    for (Element child : node.children()) {\r\n        String childItemId = readItem(child, selected, context);\r\n        setParent(childItemId, itemId);\r\n    }\r\n    return itemId;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.createBodyUpdater",
	"Comment": "creates the escalator updater used to update the body rows in this grid.the updater is invoked when body rows or columns are added or removed,the content of body cells is changed, or the body is scrolled to exposepreviously hidden content.",
	"Method": "EscalatorUpdater createBodyUpdater(){\r\n    return new BodyUpdater();\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.fireSessionDestroy",
	"Comment": "handles destruction of the given session. internally ensures properlocking is done.",
	"Method": "void fireSessionDestroy(VaadinSession vaadinSession){\r\n    final VaadinSession session = vaadinSession;\r\n    session.access(() -> {\r\n        if (session.getState() == State.CLOSED) {\r\n            return;\r\n        }\r\n        if (session.getState() == State.OPEN) {\r\n            closeSession(session);\r\n        }\r\n        List<UI> uis = new ArrayList(session.getUIs());\r\n        for (final UI ui : uis) {\r\n            ui.accessSynchronously(() -> {\r\n                if (!ui.isClosing()) {\r\n                    ui.close();\r\n                }\r\n                session.removeUI(ui);\r\n            });\r\n        }\r\n        SessionDestroyEvent event = new SessionDestroyEvent(VaadinService.this, session);\r\n        for (SessionDestroyListener listener : sessionDestroyListeners) {\r\n            try {\r\n                listener.sessionDestroy(event);\r\n            } catch (Exception e) {\r\n                session.getErrorHandler().error(new ErrorEvent(e));\r\n            }\r\n        }\r\n        session.setState(State.CLOSED);\r\n    });\r\n}"
}, {
	"Path": "bt.data.Bitfield.isVerified",
	"Comment": "shortcut method to find out if the piece has been downloaded and verified.",
	"Method": "boolean isVerified(int pieceIndex){\r\n    PieceStatus pieceStatus = getPieceStatus(pieceIndex);\r\n    return pieceStatus == PieceStatus.COMPLETE_VERIFIED;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VBrowserFrame.createIFrameElement",
	"Comment": "always creates new iframe inside widget. will replace previous iframe.",
	"Method": "IFrameElement createIFrameElement(String src){\r\n    String name = null;\r\n    if (altElement != null) {\r\n        getElement().removeChild(altElement);\r\n        altElement = null;\r\n    }\r\n    if (iframe != null) {\r\n        name = iframe.getAttribute(\"name\");\r\n        getElement().removeChild(iframe);\r\n        iframe = null;\r\n    }\r\n    iframe = Document.get().createIFrameElement();\r\n    iframe.setSrc(src);\r\n    iframe.setFrameBorder(0);\r\n    iframe.setAttribute(\"width\", \"100%\");\r\n    iframe.setAttribute(\"height\", \"100%\");\r\n    iframe.setAttribute(\"allowTransparency\", \"true\");\r\n    getElement().appendChild(iframe);\r\n    if (name != null) {\r\n        iframe.setName(name);\r\n    }\r\n    return iframe;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VUpload.ensureTargetFrame",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void ensureTargetFrame(){\r\n    if (synthesizedFrame == null) {\r\n        DivElement dummy = Document.get().createDivElement();\r\n        dummy.setInnerHTML(\"<iframe src=\\\"javascript:''\\\" name='\" + getFrameName() + \"' style='position:absolute;width:0;height:0;border:0'>\");\r\n        synthesizedFrame = dummy.getFirstChildElement();\r\n        Document.get().getBody().appendChild(synthesizedFrame);\r\n        element.setTarget(getFrameName());\r\n        onloadstrategy.hookEvents(synthesizedFrame, this);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.getCellReference",
	"Comment": "returns a cellreference for the cell to which the given element belongsto.",
	"Method": "CellReference<T> getCellReference(Element element){\r\n    RowContainer container = getEscalator().findRowContainer(element);\r\n    if (container != null) {\r\n        Cell cell = container.getCell(element);\r\n        if (cell != null) {\r\n            EventCellReference<T> cellRef = new EventCellReference(this);\r\n            cellRef.set(cell, getSectionFromContainer(container));\r\n            return cellRef;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Overlay.needsShimElement",
	"Comment": "returns true if we should add a shim iframe below the overlay to dealwith zindex issues with pdfs and applets. can be overridden to disableshim iframes if they are not needed.",
	"Method": "boolean needsShimElement(){\r\n    BrowserInfo info = BrowserInfo.get();\r\n    return info.isIE() && info.isBrowserVersionNewerOrEqual(8, 0);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheetBase.setConnector",
	"Comment": "sets the connector that should be notified of events etc.for internal use only. this method may be removed or replaced in thefuture.",
	"Method": "void setConnector(AbstractComponentConnector connector){\r\n    this.connector = connector;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.handleNavigationMonthMode",
	"Comment": "handle the keyboard navigation when the resolution is set to month.",
	"Method": "boolean handleNavigationMonthMode(int keycode,boolean ctrl,boolean shift){\r\n    if (ctrl) {\r\n        return false;\r\n    } else if (keycode == getPreviousKey()) {\r\n        focusNextYear(1);\r\n        return true;\r\n    } else if (keycode == getForwardKey()) {\r\n        focusNextMonth();\r\n        return true;\r\n    } else if (keycode == getNextKey()) {\r\n        focusPreviousYear(1);\r\n        return true;\r\n    } else if (keycode == getBackwardKey()) {\r\n        focusPreviousMonth();\r\n        return true;\r\n    } else if (keycode == getSelectKey()) {\r\n        value = (Date) focusedDate.clone();\r\n        onSubmit();\r\n        return true;\r\n    } else if (keycode == getResetKey()) {\r\n        focusedDate.setTime(value.getTime());\r\n        renderCalendar();\r\n        return true;\r\n    } else if (keycode == getCloseKey() || keycode == KeyCodes.KEY_TAB) {\r\n        onCancel();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.client.widget.escalator.FlyweightCell.getElement",
	"Comment": "returns the element of the cell. can be either a td elementor a th element.",
	"Method": "TableCellElement getElement(){\r\n    assertSetup();\r\n    return element;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.attach",
	"Comment": "notifies the component that it is connected to an application.",
	"Method": "void attach(){\r\n    super.attach();\r\n}"
}, {
	"Path": "com.vaadin.ui.Alignment.isTop",
	"Comment": "checks if component is aligned to the top of the available space.",
	"Method": "boolean isTop(){\r\n    return (bitMask & Bits.ALIGNMENT_TOP) == Bits.ALIGNMENT_TOP;\r\n}"
}, {
	"Path": "com.github.dozermapper.core.loader.xml.XMLParserTest.testParseCustomConverterParam",
	"Comment": "this tests checks that the customconverterparam reaches thefieldmapping.",
	"Method": "void testParseCustomConverterParam(){\r\n    URL url = loader.getResource(\"mappings/fieldCustomConverterParam.xml\");\r\n    Document document = new XMLParserFactory(beanContainer).createParser().parse(url.openStream());\r\n    parser = new XMLParser(beanContainer, destBeanCreator, propertyDescriptorFactory);\r\n    MappingFileData mappings = parser.read(document);\r\n    assertNotNull(\"The mappings should not be null\", mappings);\r\n    List<ClassMap> mapping = mappings.getClassMaps();\r\n    assertNotNull(\"The list of mappings should not be null\", mapping);\r\n    assertEquals(\"There should be one mapping\", 3, mapping.size());\r\n    ClassMap classMap = mapping.get(0);\r\n    assertNotNull(\"The classmap should not be null\", classMap);\r\n    List<FieldMap> fieldMaps = classMap.getFieldMaps();\r\n    assertNotNull(\"The fieldmaps should not be null\", fieldMaps);\r\n    assertEquals(\"The fieldmap should have one mapping\", 1, fieldMaps.size());\r\n    FieldMap fieldMap = fieldMaps.get(0);\r\n    assertNotNull(\"The fieldmap should not be null\", fieldMap);\r\n    assertEquals(\"The customconverterparam should be correct\", \"CustomConverterParamTest\", fieldMap.getCustomConverterParam());\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignContext.shouldWriteChildren",
	"Comment": "helper method for component write implementors to determine whether theirchildren should be written out or not.",
	"Method": "boolean shouldWriteChildren(Component c,Component defaultC){\r\n    if (c == getRootComponent()) {\r\n        return true;\r\n    }\r\n    if (defaultC instanceof HasComponents && ((HasComponents) defaultC).iterator().hasNext()) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.vaadin.ui.VerticalLayout.addComponentsAndExpand",
	"Comment": "adds the given components to this layout and sets them as expanded. theheight of all added child components are set to 100% so that theexpansion will be effective. the height of this layout is also set to100% if it is currently undefined.the components are added in the provided order to the end of this layout.any components that are already children of this layout will be moved tonew positions.",
	"Method": "void addComponentsAndExpand(Component components){\r\n    addComponents(components);\r\n    if (getHeight() < 0) {\r\n        setHeight(100, Unit.PERCENTAGE);\r\n    }\r\n    for (Component child : components) {\r\n        child.setHeight(100, Unit.PERCENTAGE);\r\n        setExpandRatio(child, 1);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.grid.AutoScroller.setScrollArea",
	"Comment": "set the auto scroll area height or width depending on the scrolling axis.this is the amount of pixels from the edge of the grid that the scroll istriggered.defaults to 100px.",
	"Method": "void setScrollArea(int px){\r\n    scrollAreaPX = px;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Slider.setMax",
	"Comment": "set the maximum slider value. if the current value of the slider islarger than this, the value is set to the new maximum.",
	"Method": "void setMax(double max){\r\n    double roundedMax = getRoundedValue(max);\r\n    getState().maxValue = roundedMax;\r\n    if (getMin() > roundedMax) {\r\n        getState().minValue = roundedMax;\r\n    }\r\n    if (getValue() > roundedMax) {\r\n        setValue(roundedMax);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.EventCellReference.set",
	"Comment": "sets the rowreference and cellreference to point to given cell.",
	"Method": "void set(Cell targetCell,Section section){\r\n    Grid<T> grid = getGrid();\r\n    int columnIndexDOM = targetCell.getColumn();\r\n    Column<?, T> column = null;\r\n    if (columnIndexDOM >= 0 && columnIndexDOM < grid.getVisibleColumns().size()) {\r\n        column = grid.getVisibleColumns().get(columnIndexDOM);\r\n    }\r\n    int row = targetCell.getRow();\r\n    T rowObject;\r\n    if (section == Section.BODY && row >= 0 && row < grid.getDataSource().size()) {\r\n        rowObject = grid.getDataSource().getRow(row);\r\n    } else {\r\n        rowObject = null;\r\n    }\r\n    getRowReference().set(row, rowObject, null);\r\n    int columnIndex = grid.getColumns().indexOf(column);\r\n    set(columnIndexDOM, columnIndex, column);\r\n    this.element = targetCell.getElement();\r\n    this.section = section;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.getFooter",
	"Comment": "returns the footer section of this grid. the default header contains asingle row displaying the column captions.",
	"Method": "Footer getFooter(){\r\n    return footer;\r\n}"
}, {
	"Path": "com.vaadin.server.SystemMessages.getCookiesDisabledMessage",
	"Comment": "returns the message shown to the user when cookies are disabled in thebrowser.",
	"Method": "String getCookiesDisabledMessage(){\r\n    return (cookiesDisabledNotificationEnabled ? cookiesDisabledMessage : null);\r\n}"
}, {
	"Path": "com.folioreader.view.VerticalViewPager.setInternalPageChangeListener",
	"Comment": "set a separate onpagechangelistener for internaluse by the support library.",
	"Method": "OnPageChangeListener setInternalPageChangeListener(OnPageChangeListener listener){\r\n    OnPageChangeListener oldListener = mInternalPageChangeListener;\r\n    mInternalPageChangeListener = listener;\r\n    return oldListener;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.fieldgroup.FieldGroup.commitFields",
	"Comment": "tries to commit all bound fields one by one and gathers any validationexceptions in a map, which is returned to the caller",
	"Method": "Map<Field<?>, InvalidValueException> commitFields(){\r\n    Map<Field<?>, InvalidValueException> invalidValueExceptions = new HashMap<Field<?>, InvalidValueException>();\r\n    for (Field<?> f : fieldToPropertyId.keySet()) {\r\n        try {\r\n            f.commit();\r\n        } catch (InvalidValueException e) {\r\n            invalidValueExceptions.put(f, e);\r\n        }\r\n    }\r\n    return invalidValueExceptions;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.ColumnProperty.isPersistent",
	"Comment": "return whether the value of this property should be persisted to thedatabase.",
	"Method": "boolean isPersistent(){\r\n    if (isVersionColumn()) {\r\n        return false;\r\n    }\r\n    return isReadOnlyChangeAllowed() && !isReadOnly();\r\n}"
}, {
	"Path": "com.vaadin.data.validator.BeanValidator.getMessage",
	"Comment": "returns the interpolated error message for the given constraint violationusing the locale specified for this validator.",
	"Method": "String getMessage(ConstraintViolation<?> violation,Locale locale){\r\n    return getJavaxBeanValidatorFactory().getMessageInterpolator().interpolate(violation.getMessageTemplate(), createContext(violation), locale);\r\n}"
}, {
	"Path": "com.github.dozermapper.core.functional_tests.WildcardWrapperTypeTest.testCanMapPrimitiveFieldAndWrapperSetter",
	"Comment": "mapping should work without configuration when field is primitive andsetter takes a wrapper class.",
	"Method": "void testCanMapPrimitiveFieldAndWrapperSetter(){\r\n    PrimitiveFieldWrapperSetter source = new PrimitiveFieldWrapperSetter();\r\n    source.setPrimitive(Long.MAX_VALUE);\r\n    PrimitiveFieldWrapperSetter target = mapper.map(source, PrimitiveFieldWrapperSetter.class);\r\n    assertThat(target.getPrimitive(), equalTo(Long.MAX_VALUE));\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Upload.getUploadSize",
	"Comment": "returns size of file currently being uploaded. value sane only duringupload.",
	"Method": "long getUploadSize(){\r\n    return contentLength;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.optiongroup.RadioButtonGroupConnector.onDataChange",
	"Comment": "a data change handler registered to the data source. updates the dataitems and selection status when the data source notifies of new changesfrom the server side.",
	"Method": "void onDataChange(Range range){\r\n    assert range.getStart() == 0 && range.getEnd() == getDataSource().size() : \"RadioButtonGroup only supports full updates, but \" + \"got range \" + range;\r\n    final VRadioButtonGroup select = getWidget();\r\n    DataSource<JsonObject> dataSource = getDataSource();\r\n    int size = dataSource.size();\r\n    List<JsonObject> options = new ArrayList();\r\n    for (int i = 0; i < size; i++) {\r\n        options.add(dataSource.getRow(i));\r\n    }\r\n    select.buildOptions(options);\r\n    getLayoutManager().setNeedsMeasure(this);\r\n    updateSelectedItem();\r\n}"
}, {
	"Path": "com.vaadin.server.DragAndDropService.constructDragDropDetails",
	"Comment": "construct dragdropdetails based on variables from client drop target.uses dragdropdetailstranslator if available, otherwise a defaultdragdropdetails implementation is used.",
	"Method": "TargetDetails constructDragDropDetails(DropTarget dropTarget,Map<String, Object> variables){\r\n    Map<String, Object> rawDragDropDetails = (Map<String, Object>) variables.get(\"evt\");\r\n    TargetDetails dropData = dropTarget.translateDropTargetDetails(rawDragDropDetails);\r\n    if (dropData == null) {\r\n        dropData = new TargetDetailsImpl(rawDragDropDetails, dropTarget);\r\n    }\r\n    return dropData;\r\n}"
}, {
	"Path": "bt.tracker.TrackerRequestBuilder.downloaded",
	"Comment": "optionally set the amount of data downloaded during the current session.",
	"Method": "TrackerRequestBuilder downloaded(long downloaded){\r\n    if (downloaded < 0) {\r\n        throw new BtException(\"Invalid downloaded value: \" + downloaded);\r\n    }\r\n    this.downloaded = downloaded;\r\n    return this;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.SQLContainer.setPageLengthInternal",
	"Comment": "sets the page length internally, without refreshing the container.",
	"Method": "void setPageLengthInternal(int pageLength){\r\n    this.pageLength = pageLength > 0 ? pageLength : DEFAULT_PAGE_LENGTH;\r\n    cacheOverlap = getPageLength();\r\n    cachedItems.setCacheLimit(CACHE_RATIO * getPageLength() + cacheOverlap);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.setAssistivePrefix",
	"Comment": "setter for the text for assistive devices the window caption is prefixedwith.",
	"Method": "void setAssistivePrefix(String assistivePrefix){\r\n    this.assistivePrefix = assistivePrefix;\r\n}"
}, {
	"Path": "com.vaadin.client.event.PointerEvent.getWidth",
	"Comment": "gets the width of the contact geometry of the pointer in css pixels.",
	"Method": "int getWidth(int getWidth,NativeEvent e){\r\n    return getWidth(getNativeEvent());\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.notifyMarkedAsDirtyListeners",
	"Comment": "notify all registered markedasdirtylisteners the given client connectorhas been marked as dirty.",
	"Method": "void notifyMarkedAsDirtyListeners(ClientConnector connector){\r\n    MarkedAsDirtyConnectorEvent event = new MarkedAsDirtyConnectorEvent(connector, uI);\r\n    new ArrayList(markedDirtyListeners).forEach(listener -> {\r\n        listener.connectorMarkedAsDirty(event);\r\n    });\r\n}"
}, {
	"Path": "com.vaadin.client.extensions.DragSourceExtensionConnector.removeDragListeners",
	"Comment": "removes dragstart and dragend event listeners from the given dom element.",
	"Method": "void removeDragListeners(Element element){\r\n    EventTarget target = element.cast();\r\n    target.removeEventListener(Event.DRAGSTART, dragStartListener);\r\n    target.removeEventListener(Event.DRAGEND, dragEndListener);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.PropertysetItem.getItemPropertyIds",
	"Comment": "gets the collection of ids of all properties stored in the item.",
	"Method": "Collection<?> getItemPropertyIds(){\r\n    return Collections.unmodifiableCollection(list);\r\n}"
}, {
	"Path": "net.openhft.chronicle.queue.impl.single.SingleChronicleQueueTest.testAppendedSkipToEnd",
	"Comment": "if one appender if much further ahead than the other, then the new append should jumpstraight to the end rather than attempting to write a positions that are already occupied",
	"Method": "void testAppendedSkipToEnd(){\r\n    try (ChronicleQueue q = builder(getTmpDir(), this.wireType).build()) {\r\n        ExcerptAppender appender = q.acquireAppender();\r\n        ExcerptAppender appender2 = q.acquireAppender();\r\n        int indexCount = 100;\r\n        for (int i = 0; i < indexCount; i++) {\r\n            try (DocumentContext dc = appender.writingDocument()) {\r\n                dc.wire().write(\"key\").text(\"some more \" + 1);\r\n                Assert.assertEquals(i, q.rollCycle().toSequenceNumber(dc.index()));\r\n            }\r\n        }\r\n        try (DocumentContext dc = appender2.writingDocument()) {\r\n            dc.wire().write(\"key\").text(\"some data \" + indexCount);\r\n            Assert.assertEquals(indexCount, q.rollCycle().toSequenceNumber(dc.index()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.DefaultDeploymentConfiguration.checkResourceCacheTime",
	"Comment": "log a warning if resource cache time is set but is not an integer.",
	"Method": "void checkResourceCacheTime(){\r\n    try {\r\n        resourceCacheTime = Integer.parseInt(getApplicationOrSystemProperty(Constants.SERVLET_PARAMETER_RESOURCE_CACHE_TIME, Integer.toString(DEFAULT_RESOURCE_CACHE_TIME)));\r\n    } catch (NumberFormatException e) {\r\n        getLogger().warning(Constants.WARNING_RESOURCE_CACHING_TIME_NOT_NUMERIC);\r\n        resourceCacheTime = DEFAULT_RESOURCE_CACHE_TIME;\r\n    }\r\n}"
}, {
	"Path": "bt.runtime.BtRuntime.service",
	"Comment": "convenience method to get an instance of a shared di service.",
	"Method": "T service(Class<T> serviceType){\r\n    return injector.getInstance(serviceType);\r\n}"
}, {
	"Path": "com.vaadin.ui.LoginForm.createPasswordField",
	"Comment": "customize the password field. only for overriding, do not call.",
	"Method": "PasswordField createPasswordField(){\r\n    throwIfInitialized();\r\n    return new PasswordField(getPasswordCaption());\r\n}"
}, {
	"Path": "com.folioreader.android.sample.HomeActivity.getHighlightsAndSave",
	"Comment": "for testing purpose, we are getting dummy highlights from asset. but you can get highlights from your serveron success, you can save highlights to folioreader db.",
	"Method": "void getHighlightsAndSave(){\r\n    new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            ArrayList<HighLight> highlightList = null;\r\n            ObjectMapper objectMapper = new ObjectMapper();\r\n            try {\r\n                highlightList = objectMapper.readValue(loadAssetTextAsString(\"highlights/highlights_data.json\"), new TypeReference<List<HighlightData>>() {\r\n                });\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            if (highlightList == null) {\r\n                folioReader.saveReceivedHighLights(highlightList, new OnSaveHighlight() {\r\n                    @Override\r\n                    public void onFinished() {\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }).start();\r\n}"
}, {
	"Path": "com.folioreader.android.sample.HomeActivity.getHighlightsAndSave",
	"Comment": "for testing purpose, we are getting dummy highlights from asset. but you can get highlights from your serveron success, you can save highlights to folioreader db.",
	"Method": "void getHighlightsAndSave(){\r\n    ArrayList<HighLight> highlightList = null;\r\n    ObjectMapper objectMapper = new ObjectMapper();\r\n    try {\r\n        highlightList = objectMapper.readValue(loadAssetTextAsString(\"highlights/highlights_data.json\"), new TypeReference<List<HighlightData>>() {\r\n        });\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    if (highlightList == null) {\r\n        folioReader.saveReceivedHighLights(highlightList, new OnSaveHighlight() {\r\n            @Override\r\n            public void onFinished() {\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.folioreader.android.sample.HomeActivity.getHighlightsAndSave",
	"Comment": "for testing purpose, we are getting dummy highlights from asset. but you can get highlights from your serveron success, you can save highlights to folioreader db.",
	"Method": "void getHighlightsAndSave(){\r\n}"
}, {
	"Path": "com.ryanharter.viewpager.ViewPager.setInternalPageChangeListener",
	"Comment": "set a separate onpagechangelistener for internal use by the support library.",
	"Method": "OnPageChangeListener setInternalPageChangeListener(OnPageChangeListener listener){\r\n    OnPageChangeListener oldListener = mInternalPageChangeListener;\r\n    mInternalPageChangeListener = listener;\r\n    return oldListener;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VPopupCalendar.getOpenCalenderPanelKey",
	"Comment": "get the key code that opens the calendar panel. by default it is the downkey but you can override this to be whatever you like",
	"Method": "int getOpenCalenderPanelKey(){\r\n    return KeyCodes.KEY_DOWN;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.FocusUtil.focusOnFirstFocusableElement",
	"Comment": "moves the focus to the first focusable child of given parent element.",
	"Method": "void focusOnFirstFocusableElement(Element parent){\r\n    Element[] focusableChildren = getFocusableChildren(parent);\r\n    if (focusableChildren.length == 0) {\r\n        return;\r\n    }\r\n    for (int i = 0; i < focusableChildren.length; i++) {\r\n        Element element = focusableChildren[i];\r\n        String classes = element.getAttribute(\"class\");\r\n        if (classes == null || !classes.toLowerCase().contains(\"disabled\")) {\r\n            element.focus();\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinServlet.init",
	"Comment": "called by the servlet container to indicate to a servlet that the servletis being placed into service.",
	"Method": "void init(javax.servlet.ServletConfig servletConfig){\r\n    CurrentInstance.clearAll();\r\n    super.init(servletConfig);\r\n    try {\r\n        servletService = createServletService();\r\n    } catch (ServiceException e) {\r\n        throw new ServletException(\"Could not initialize VaadinServlet\", e);\r\n    }\r\n    servletService.setCurrentInstances(null, null);\r\n    servletInitialized();\r\n    CurrentInstance.clearAll();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.setTableFieldFactory",
	"Comment": "sets the tablefieldfactory that is used to create editor for table cells.the tablefieldfactory is only used if the table is editable. by defaultthe defaultfieldfactory is used.",
	"Method": "void setTableFieldFactory(TableFieldFactory fieldFactory){\r\n    this.fieldFactory = fieldFactory;\r\n    refreshRowCache();\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponent.setData",
	"Comment": "sets the data object, that can be used for any application specific data.the component does not use or modify this data.",
	"Method": "void setData(Object data){\r\n    applicationData = data;\r\n}"
}, {
	"Path": "com.vaadin.client.communication.MessageHandler.parseJson",
	"Comment": "unwraps and parses the given json, originating from the server.",
	"Method": "ValueMap parseJson(String jsonText){\r\n    if (jsonText == null) {\r\n        return null;\r\n    }\r\n    final double start = Profiler.getRelativeTimeMillis();\r\n    try {\r\n        ValueMap json = parseJSONResponse(jsonText);\r\n        getLogger().info(\"JSON parsing took \" + Util.round(Profiler.getRelativeTimeMillis() - start, 3) + \"ms\");\r\n        return json;\r\n    } catch (final Exception e) {\r\n        getLogger().severe(\"Unable to parse JSON: \" + jsonText);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.grid.EventCellReference.set",
	"Comment": "sets the rowreference and cellreference to point to given cell.",
	"Method": "void set(Cell targetCell,Section section){\r\n    Grid<T> grid = getGrid();\r\n    int columnIndexDOM = targetCell.getColumn();\r\n    Column<?, T> column = null;\r\n    if (columnIndexDOM >= 0 && columnIndexDOM < grid.getVisibleColumns().size()) {\r\n        column = grid.getVisibleColumns().get(columnIndexDOM);\r\n    }\r\n    int row = targetCell.getRow();\r\n    T rowObject;\r\n    if (section == Section.BODY && row >= 0 && row < grid.getDataSource().size()) {\r\n        rowObject = grid.getDataSource().getRow(row);\r\n    } else {\r\n        rowObject = null;\r\n    }\r\n    getRowReference().set(row, rowObject, null);\r\n    int columnIndex = grid.getColumns().indexOf(column);\r\n    set(columnIndexDOM, columnIndex, column);\r\n    this.element = targetCell.getElement();\r\n    this.section = section;\r\n}"
}, {
	"Path": "com.vaadin.server.BootstrapResponse.getUiClass",
	"Comment": "gets the class of the ui that will be displayed on the generatedbootstrap page.",
	"Method": "Class<? extends UI> getUiClass(){\r\n    return uiClass;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.DefaultFieldFactory.get",
	"Comment": "singleton method to get an instance of defaultfieldfactory.",
	"Method": "DefaultFieldFactory get(){\r\n    return INSTANCE;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractTextField.selectAll",
	"Comment": "selects all text in the field.as a side effect the field will become focused.",
	"Method": "void selectAll(){\r\n    getRpcProxy(AbstractTextFieldClientRpc.class).selectAll();\r\n    focus();\r\n}"
}, {
	"Path": "com.vaadin.ui.Tree.addContextClickListener",
	"Comment": "adds a context click listener that gets notified when a context clickhappens.",
	"Method": "Registration addContextClickListener(ContextClickEvent.ContextClickListener listener){\r\n    Registration registration = addListener(EventId.CONTEXT_CLICK, ContextClickEvent.class, listener, ContextClickEvent.CONTEXT_CLICK_METHOD);\r\n    setupContextClickListener();\r\n    return () -> {\r\n        registration.remove();\r\n        setupContextClickListener();\r\n    };\r\n}"
}, {
	"Path": "com.vaadin.server.LegacyApplication.getWindow",
	"Comment": "gets a ui by name. returns null if the application is notrunning or it does not contain a window corresponding to the name.",
	"Method": "LegacyWindow getWindow(String name){\r\n    return legacyUINames.get(name);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTwinColSelect.updateCaptions",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void updateCaptions(UIDL uidl){\r\n    String leftCaption = (uidl.hasAttribute(TwinColSelectConstants.ATTRIBUTE_LEFT_CAPTION) ? uidl.getStringAttribute(TwinColSelectConstants.ATTRIBUTE_LEFT_CAPTION) : null);\r\n    String rightCaption = (uidl.hasAttribute(TwinColSelectConstants.ATTRIBUTE_RIGHT_CAPTION) ? uidl.getStringAttribute(TwinColSelectConstants.ATTRIBUTE_RIGHT_CAPTION) : null);\r\n    boolean hasCaptions = (leftCaption != null || rightCaption != null);\r\n    if (leftCaption == null) {\r\n        removeOptionsCaption();\r\n    } else {\r\n        getOptionsCaption().setText(leftCaption);\r\n    }\r\n    if (rightCaption == null) {\r\n        removeSelectionsCaption();\r\n    } else {\r\n        getSelectionsCaption().setText(rightCaption);\r\n    }\r\n    captionWrapper.setVisible(hasCaptions);\r\n}"
}, {
	"Path": "com.vaadin.client.TooltipInfo.equals",
	"Comment": "indicates whether another tooltip info instance is equal to this one. twoinstances are equal if their title, error message, error level andidentifier are equal.",
	"Method": "boolean equals(TooltipInfo other){\r\n    return (other != null && SharedUtil.equals(other.title, title) && SharedUtil.equals(other.errorMessageHtml, errorMessageHtml) && SharedUtil.equals(other.errorLevel, errorLevel) && other.identifier == identifier);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.handleKeyPress",
	"Comment": "handles the keypress from both the onkeypress event and the onkeydownevent",
	"Method": "void handleKeyPress(DomEvent<?> event){\r\n    if (time != null && time.getElement().isOrHasChild((Node) event.getNativeEvent().getEventTarget().cast())) {\r\n        int nativeKeyCode = event.getNativeEvent().getKeyCode();\r\n        if (nativeKeyCode == getSelectKey()) {\r\n            onSubmit();\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n        }\r\n        if (nativeKeyCode == getCloseKey()) {\r\n            onCancel();\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n        }\r\n        return;\r\n    }\r\n    int keycode = event.getNativeEvent().getKeyCode();\r\n    if (keycode == KeyCodes.KEY_TAB && event.getNativeEvent().getShiftKey()) {\r\n        if (onTabOut(event)) {\r\n            return;\r\n        }\r\n    }\r\n    if (handleNavigation(keycode, event.getNativeEvent().getCtrlKey() || event.getNativeEvent().getMetaKey(), event.getNativeEvent().getShiftKey())) {\r\n        event.preventDefault();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.ComboBox.getPlaceholder",
	"Comment": "gets the current placeholder text shown when the combo box would beempty.",
	"Method": "String getPlaceholder(){\r\n    return getState(false).placeholder;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.readItem",
	"Comment": "reads an item from a design and inserts it into the data source.hierarchical select components should override this method to recursivelyrecursively read any child items as well.",
	"Method": "Object readItem(Element child,Set<String> selected,DesignContext context){\r\n    if (!\"option\".equals(child.tagName())) {\r\n        throw new DesignException(\"Unrecognized child element in \" + getClass().getSimpleName() + \": \" + child.tagName());\r\n    }\r\n    String itemId;\r\n    String caption = DesignFormatter.decodeFromTextNode(child.html());\r\n    if (child.hasAttr(\"item-id\")) {\r\n        itemId = child.attr(\"item-id\");\r\n        addItem(itemId);\r\n        setItemCaption(itemId, caption);\r\n    } else {\r\n        addItem(itemId = caption);\r\n    }\r\n    if (child.hasAttr(\"icon\")) {\r\n        setItemIcon(itemId, DesignAttributeHandler.readAttribute(\"icon\", child.attributes(), Resource.class));\r\n    }\r\n    if (child.hasAttr(\"selected\")) {\r\n        selected.add(itemId);\r\n    }\r\n    return itemId;\r\n}"
}, {
	"Path": "bt.torrent.messaging.ConnectionState.getPendingWrites",
	"Comment": "get pending block writes, mapped by keys of corresponding requests.",
	"Method": "Map<Object, CompletableFuture<BlockWrite>> getPendingWrites(){\r\n    return pendingWrites;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractInMemoryContainer.fireItemsRemoved",
	"Comment": "notify item set change listeners that items has been removed from thecontainer.",
	"Method": "void fireItemsRemoved(int firstPosition,Object firstItemId,int numberOfItems){\r\n    BaseItemRemoveEvent removeEvent = new BaseItemRemoveEvent(this, firstItemId, firstPosition, numberOfItems);\r\n    fireItemSetChange(removeEvent);\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.scrollIntoView",
	"Comment": "scrolls any component between the component and ui to a suitable positionso the component is visible to the user. the given component must belongto this ui.",
	"Method": "void scrollIntoView(Component component){\r\n    if (component.getUI() != this) {\r\n        throw new IllegalArgumentException(\"The component where to scroll must belong to this UI.\");\r\n    }\r\n    scrollIntoView = component;\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.github.dozermapper.core.DozerModule.getBeanFieldsDetectors",
	"Comment": "to be implemented by module if it provides any additional detectors of bean fields.",
	"Method": "Collection<BeanFieldsDetector> getBeanFieldsDetectors(){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendar.getScrollListener",
	"Comment": "get the listener that listens to when the calendar widget is scrolled.",
	"Method": "ScrollListener getScrollListener(){\r\n    return scrollListener;\r\n}"
}, {
	"Path": "com.vaadin.server.communication.PushHandler.sendNotificationAndDisconnect",
	"Comment": "tries to send a critical notification to the client and close theconnection. does nothing if the connection is already closed.",
	"Method": "void sendNotificationAndDisconnect(AtmosphereResource resource,String notificationJson){\r\n    try {\r\n        if (resource instanceof AtmosphereResourceImpl && !((AtmosphereResourceImpl) resource).isInScope()) {\r\n            getLogger().fine(\"sendNotificationAndDisconnect called for resource no longer in scope\");\r\n            return;\r\n        }\r\n        resource.getResponse().setContentType(JsonConstants.JSON_CONTENT_TYPE);\r\n        resource.getResponse().getWriter().write(notificationJson);\r\n        resource.resume();\r\n    } catch (Exception e) {\r\n        getLogger().log(Level.FINEST, \"Failed to send critical notification to client\", e);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VFilterSelect.updateSelectedIconPosition",
	"Comment": "positions the icon vertically in the middle. should be called after theicon has loaded",
	"Method": "void updateSelectedIconPosition(){\r\n    int availableHeight = 0;\r\n    availableHeight = getOffsetHeight();\r\n    int iconHeight = WidgetUtil.getRequiredHeight(selectedItemIcon);\r\n    int marginTop = (availableHeight - iconHeight) / 2;\r\n    selectedItemIcon.getElement().getStyle().setMarginTop(marginTop, Unit.PX);\r\n}"
}, {
	"Path": "com.vaadin.osgi.resources.impl.VaadinResourceServiceImpl.setBundleVersion",
	"Comment": "sets the version of the bundle managing this service.this needs to be called before any other method after the service iscreated.",
	"Method": "void setBundleVersion(String bundleVersion){\r\n    this.bundleVersion = bundleVersion;\r\n    pathPrefix = String.format(NAMESPACE_PREFIX, bundleVersion);\r\n}"
}, {
	"Path": "com.github.dozermapper.core.DozerBeanMapperBuilder.create",
	"Comment": "creates new builder. all the configuration has its default values.",
	"Method": "DozerBeanMapperBuilder create(){\r\n    return new DozerBeanMapperBuilder();\r\n}"
}, {
	"Path": "com.vaadin.data.BeanValidationBinder.findBeanType",
	"Comment": "finds the bean type containing the property the given definition refersto.",
	"Method": "Class<?> findBeanType(Class<BEAN> beanType,PropertyDefinition<BEAN, ?> definition){\r\n    if (definition instanceof NestedBeanPropertyDefinition) {\r\n        return ((NestedBeanPropertyDefinition) definition).getParent().getType();\r\n    } else {\r\n        return beanType;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.tests.server.component.gridlayout.GridLayoutTest.assertOrder",
	"Comment": "asserts that layout has the components in children in the order specifiedby indices.",
	"Method": "void assertOrder(Layout layout,int[] indices){\r\n    Iterator<?> i = layout.iterator();\r\n    try {\r\n        for (int index : indices) {\r\n            if (index != -1) {\r\n                assertSame(children[index], i.next());\r\n            } else {\r\n                i.next();\r\n            }\r\n        }\r\n        assertFalse(\"Too many components in layout\", i.hasNext());\r\n    } catch (NoSuchElementException e) {\r\n        fail(\"Too few components in layout\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbsoluteLayout.setWidgetPosition",
	"Comment": "set the position of the widget in the layout. the position is a cssproperty string using properties such as top,left,right,top",
	"Method": "void setWidgetPosition(Widget child,String position){\r\n    AbsoluteWrapper wrapper = getChildWrapper(child);\r\n    if (wrapper != null) {\r\n        wrapper.setPosition(position);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.ComboBox.setNewItemHandler",
	"Comment": "sets the handler that is called when user types a new item. the creationof new items is allowed when a new item handler has been set. if new itemprovider is also set, the new item handler is ignored.",
	"Method": "void setNewItemHandler(NewItemHandler newItemHandler){\r\n    getLogger().log(Level.WARNING, \"NewItemHandler is deprecated. Please use NewItemProvider instead.\");\r\n    this.newItemHandler = newItemHandler;\r\n    getState(true).allowNewItems = newItemProvider != null || newItemHandler != null;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.connectors.GridConnector.getDetailsListener",
	"Comment": "gets the listener used by this connector for tracking when row detailvisibility changes.",
	"Method": "DetailsListener getDetailsListener(){\r\n    return detailsListener;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VFlash.setSlotHeightAndWidth",
	"Comment": "set dimensions of the containing layout slot so that the size of theembed object can be calculated from percentages if needed.triggers embed resizing if percentage sizes are in use.",
	"Method": "void setSlotHeightAndWidth(int slotOffsetHeight,int slotOffsetWidth){\r\n    this.slotOffsetHeight = slotOffsetHeight;\r\n    this.slotOffsetWidth = slotOffsetWidth;\r\n    if (hasPercentageHeight() || hasPercentageWidth()) {\r\n        resizeEmbedElement();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.SQLContainer.setAutoCommit",
	"Comment": "set auto commit mode enabled or disabled. auto commit mode means that allchanges made to items of this container will be immediately written tothe underlying data source.",
	"Method": "void setAutoCommit(boolean autoCommitEnabled){\r\n    autoCommit = autoCommitEnabled;\r\n}"
}, {
	"Path": "com.vdurmont.emoji.EmojiParser.getNextUnicodeCandidate",
	"Comment": "finds the next unicodecandidate after a given starting index",
	"Method": "UnicodeCandidate getNextUnicodeCandidate(char[] chars,int start){\r\n    for (int i = start; i < chars.length; i++) {\r\n        int emojiEnd = getEmojiEndPos(chars, i);\r\n        if (emojiEnd != -1) {\r\n            Emoji emoji = EmojiManager.getByUnicode(new String(chars, i, emojiEnd - i));\r\n            String fitzpatrickString = (emojiEnd + 2 <= chars.length) ? new String(chars, emojiEnd, 2) : null;\r\n            return new UnicodeCandidate(emoji, fitzpatrickString, i);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.unregisterPropertiesAndComponents",
	"Comment": "helper method to remove listeners and maintain correct componenthierarchy. detaches properties and components if those are no morerendered in client.",
	"Method": "void unregisterPropertiesAndComponents(HashSet<Property<?>> oldListenedProperties,HashSet<Component> oldVisibleComponents){\r\n    if (oldVisibleComponents != null) {\r\n        for (final Component c : oldVisibleComponents) {\r\n            if (!visibleComponents.contains(c)) {\r\n                unregisterComponent(c);\r\n            }\r\n        }\r\n    }\r\n    if (oldListenedProperties != null) {\r\n        for (final Property<?> p : oldListenedProperties) {\r\n            Property.ValueChangeNotifier o = (ValueChangeNotifier) p;\r\n            if (!listenedProperties.contains(o)) {\r\n                o.removeListener(this);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ResourceLoader.runWhenHtmlImportsReady",
	"Comment": "executes a runnable when all html imports are ready. if the browser doesnot support triggering an event when html imports are ready, the runnableis executed immediately.",
	"Method": "void runWhenHtmlImportsReady(Runnable runnable){\r\n    if (GWT.isClient() && supportsHtmlWhenReady()) {\r\n        addHtmlImportsReadyHandler(() -> runnable.run());\r\n    } else {\r\n        runnable.run();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractInMemoryContainer.hasContainerFilters",
	"Comment": "returns true if any filters have been applied to the container.",
	"Method": "boolean hasContainerFilters(){\r\n    return !getContainerFilters().isEmpty();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Tree.getMultiselectMode",
	"Comment": "returns the mode the multiselect is in. the mode controls howmultiselection can be done.",
	"Method": "MultiSelectMode getMultiselectMode(){\r\n    return multiSelectMode;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VOptionGroup.buildOptions",
	"Comment": "try to update content of existing elements, rebuild panel entirelyotherwise",
	"Method": "void buildOptions(UIDL uidl){\r\n    Map<String, CheckBox> keysToOptions = new HashMap<String, CheckBox>();\r\n    for (Map.Entry<CheckBox, String> entry : optionsToKeys.entrySet()) {\r\n        keysToOptions.put(entry.getValue(), entry.getKey());\r\n    }\r\n    List<Widget> existingwidgets = new ArrayList<Widget>();\r\n    List<Widget> newwidgets = new ArrayList<Widget>();\r\n    for (Widget wid : panel) {\r\n        existingwidgets.add(wid);\r\n    }\r\n    optionsEnabled.clear();\r\n    if (isMultiselect()) {\r\n        Roles.getGroupRole().set(getElement());\r\n    } else {\r\n        Roles.getRadiogroupRole().set(getElement());\r\n    }\r\n    for (final Object child : uidl) {\r\n        final UIDL opUidl = (UIDL) child;\r\n        String itemHtml = opUidl.getStringAttribute(\"caption\");\r\n        if (!htmlContentAllowed) {\r\n            itemHtml = WidgetUtil.escapeHTML(itemHtml);\r\n        }\r\n        String iconUrl = opUidl.getStringAttribute(\"icon\");\r\n        if (iconUrl != null && !iconUrl.isEmpty()) {\r\n            Icon icon = client.getIcon(iconUrl);\r\n            itemHtml = icon.getElement().getString() + itemHtml;\r\n        }\r\n        String key = opUidl.getStringAttribute(\"key\");\r\n        CheckBox op = keysToOptions.get(key);\r\n        if ((op == null) || (htmlContentAllowed != wasHtmlContentAllowed) || (isMultiselect() != wasMultiselect)) {\r\n            if (isMultiselect()) {\r\n                op = new VCheckBox();\r\n            } else {\r\n                op = new RadioButton(paintableId);\r\n                op.setStyleName(\"v-radiobutton\");\r\n            }\r\n            if (iconUrl != null && !iconUrl.isEmpty()) {\r\n                WidgetUtil.sinkOnloadForImages(op.getElement());\r\n                op.addHandler(iconLoadHandler, LoadEvent.getType());\r\n            }\r\n            op.addStyleName(CLASSNAME_OPTION);\r\n            op.addClickHandler(this);\r\n            optionsToKeys.put(op, key);\r\n        }\r\n        op.setHTML(itemHtml);\r\n        op.setValue(opUidl.getBooleanAttribute(\"selected\"));\r\n        boolean optionEnabled = !opUidl.getBooleanAttribute(OptionGroupConstants.ATTRIBUTE_OPTION_DISABLED);\r\n        boolean enabled = optionEnabled && !isReadonly() && isEnabled();\r\n        op.setEnabled(enabled);\r\n        optionsEnabled.put(op, optionEnabled);\r\n        setStyleName(op.getElement(), StyleConstants.DISABLED, !(optionEnabled && isEnabled()));\r\n        newwidgets.add(op);\r\n    }\r\n    if (!newwidgets.equals(existingwidgets)) {\r\n        panel.clear();\r\n        for (Widget wid : newwidgets) {\r\n            panel.add(wid);\r\n        }\r\n    }\r\n    wasHtmlContentAllowed = htmlContentAllowed;\r\n    wasMultiselect = isMultiselect();\r\n}"
}, {
	"Path": "com.vaadin.client.communication.ServerRpcQueue.setConnection",
	"Comment": "sets the application connection this instance is connected to. calledinternally by the framework.",
	"Method": "void setConnection(ApplicationConnection connection){\r\n    this.connection = connection;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.createBodyUpdater",
	"Comment": "creates the escalator updater used to update the body rows in this grid.the updater is invoked when body rows or columns are added or removed,the content of body cells is changed, or the body is scrolled to exposepreviously hidden content.",
	"Method": "EscalatorUpdater createBodyUpdater(){\r\n    return new BodyUpdater();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.removeGeneratedColumn",
	"Comment": "removes a generated column previously added with addgeneratedcolumn.",
	"Method": "boolean removeGeneratedColumn(Object columnId){\r\n    if (columnGenerators.containsKey(columnId)) {\r\n        columnGenerators.remove(columnId);\r\n        if (!items.getContainerPropertyIds().contains(columnId)) {\r\n            visibleColumns.remove(columnId);\r\n        }\r\n        refreshRowCache();\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.dnd.event.DropEvent.getDragSourceComponent",
	"Comment": "returns the drag source component if the drag originated from a componentin the same ui as the drop target component, or an empty optional.",
	"Method": "Optional<AbstractComponent> getDragSourceComponent(){\r\n    return Optional.ofNullable(dragSource);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Slider.getResolution",
	"Comment": "get the current resolution of the slider. the resolution is the number ofdigits after the decimal point.",
	"Method": "int getResolution(){\r\n    return getState(false).resolution;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.setSubmitListener",
	"Comment": "the submit listener is called when the user selects a value from thecalendar either by clicking the day or selects it by keyboard.",
	"Method": "void setSubmitListener(SubmitListener submitListener){\r\n    this.submitListener = submitListener;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.sort.Sort.by",
	"Comment": "start building a sort order by sorting a provided column in ascendingorder.",
	"Method": "Sort by(Object propertyId,Sort by,Object propertyId,SortDirection direction){\r\n    return new Sort(propertyId, direction);\r\n}"
}, {
	"Path": "com.vaadin.server.CustomizedSystemMessages.setCookiesDisabledURL",
	"Comment": "sets the url to redirect to when the browser has cookies disabled.",
	"Method": "void setCookiesDisabledURL(String cookiesDisabledURL){\r\n    this.cookiesDisabledURL = cookiesDisabledURL;\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignAttributeHandler.readAttribute",
	"Comment": "reads the given attribute from a set of attributes. if attribute does notexist return a given default value.",
	"Method": "T readAttribute(String attribute,Attributes attributes,T defaultValue,Class<T> outputType,T readAttribute,String attribute,Attributes attributes,Class<T> outputType){\r\n    if (!getFormatter().canConvert(outputType)) {\r\n        throw new IllegalArgumentException(\"output type: \" + outputType.getName() + \" not supported\");\r\n    }\r\n    if (!attributes.hasKey(attribute)) {\r\n        return null;\r\n    } else {\r\n        try {\r\n            String value = attributes.get(attribute);\r\n            return getFormatter().parse(value, outputType);\r\n        } catch (Exception e) {\r\n            throw new DesignException(\"Failed to read attribute \" + attribute, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.renderers.HierarchyRenderer.setInnerRenderer",
	"Comment": "sets the renderer to be wrapped. this is the original renderer beforehierarchy is applied.",
	"Method": "void setInnerRenderer(Renderer innerRenderer){\r\n    this.innerRenderer = innerRenderer;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractField.getModelType",
	"Comment": "retrieves the type of the currently used data model. if the field has nodata source then the model type of the converter is used.",
	"Method": "Class<?> getModelType(){\r\n    Property<?> pd = getPropertyDataSource();\r\n    if (pd != null) {\r\n        return pd.getType();\r\n    } else if (getConverter() != null) {\r\n        return getConverter().getModelType();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractOrderedLayout.iterator",
	"Comment": "gets the component container iterator for going trough all the componentsin the container.",
	"Method": "Iterator<Component> iterator(){\r\n    return Collections.unmodifiableCollection(components).iterator();\r\n}"
}, {
	"Path": "com.vaadin.ui.RadioButtonGroup.setHtmlContentAllowed",
	"Comment": "sets whether html is allowed in the item captions. if set to true, thecaptions are passed to the browser as html and the developer isresponsible for ensuring no harmful html is used. if set to false, thecontent is passed to the browser as plain text.",
	"Method": "void setHtmlContentAllowed(boolean htmlContentAllowed){\r\n    getState().htmlContentAllowed = htmlContentAllowed;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTwinColSelect.clearInternalWidths",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void clearInternalWidths(){\r\n    int cols = -1;\r\n    if (getColumns() > 0) {\r\n        cols = getColumns();\r\n    } else {\r\n        cols = DEFAULT_COLUMN_COUNT;\r\n    }\r\n    if (cols >= 0) {\r\n        String colWidth = cols + \"em\";\r\n        String containerWidth = (2 * cols + 4) + \"em\";\r\n        String captionWrapperWidth = (2 * cols + 4 - 0.5) + \"em\";\r\n        options.setWidth(colWidth);\r\n        if (optionsCaption != null) {\r\n            optionsCaption.setWidth(colWidth);\r\n        }\r\n        selections.setWidth(colWidth);\r\n        if (selectionsCaption != null) {\r\n            selectionsCaption.setWidth(colWidth);\r\n        }\r\n        buttons.setWidth(\"3.5em\");\r\n        optionsContainer.setWidth(containerWidth);\r\n        captionWrapper.setWidth(captionWrapperWidth);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTree.getNavigationRightKey",
	"Comment": "get the key that scroll to the right on the table. by default it is theright arrow key but by overriding this you can change the key to whateveryou want.",
	"Method": "int getNavigationRightKey(){\r\n    return KeyCodes.KEY_RIGHT;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.addColumnReorderListener",
	"Comment": "adds a column reorder listener to the table. a column reorder listener iscalled when a user reorders columns.",
	"Method": "void addColumnReorderListener(ColumnReorderListener listener){\r\n    addListener(TableConstants.COLUMN_REORDER_EVENT_ID, ColumnReorderEvent.class, listener, ColumnReorderEvent.METHOD);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.setTimeZone",
	"Comment": "set time zone that this component will use. null value sets the defaulttime zone.",
	"Method": "void setTimeZone(TimeZone zone){\r\n    timezone = zone;\r\n    if (!currentCalendar.getTimeZone().equals(zone)) {\r\n        if (zone == null) {\r\n            zone = TimeZone.getDefault();\r\n        }\r\n        currentCalendar.setTimeZone(zone);\r\n        df_date_time.setTimeZone(zone);\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractTextualDate.checkGroupFocus",
	"Comment": "checks if the group focus has changed, and sends to the server if needed.",
	"Method": "void checkGroupFocus(boolean textFocus){\r\n    boolean newGroupFocus = textFocus | hasChildFocus();\r\n    if (getClient() != null && connector.hasEventListener(textFocus ? EventId.FOCUS : EventId.BLUR) && groupFocus != newGroupFocus) {\r\n        if (newGroupFocus) {\r\n            rpc.focus();\r\n        } else {\r\n            rpc.blur();\r\n        }\r\n        sendBufferedValues();\r\n        groupFocus = newGroupFocus;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.communication.MessageHandler.isNextExpectedMessage",
	"Comment": "checks if the given serverid is the one we are currently waiting for fromthe server",
	"Method": "boolean isNextExpectedMessage(int serverId){\r\n    if (serverId == -1) {\r\n        return true;\r\n    }\r\n    if (serverId == getExpectedServerId()) {\r\n        return true;\r\n    }\r\n    if (lastSeenServerSyncId == UNDEFINED_SYNC_ID) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.getSubmitListener",
	"Comment": "returns the submit listener that listens to selection made from thepanel.",
	"Method": "SubmitListener getSubmitListener(){\r\n    return submitListener;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.BeanItemContainer.addItemAt",
	"Comment": "adds a new bean at the given index.the bean is used both as the item contents and as the item identifier.",
	"Method": "BeanItem<BEANTYPE> addItemAt(int index,Object newItemId){\r\n    return super.addBeanAt(index, (BEANTYPE) newItemId);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.addContainerProperty",
	"Comment": "adds the new property to all items. adds a property with given id, typeand default value to all items in the container.this functionality is optional. if the function is unsupported, it alwaysreturns false.",
	"Method": "boolean addContainerProperty(Object propertyId,Class<?> type,Object defaultValue){\r\n    final boolean retval = items.addContainerProperty(propertyId, type, defaultValue);\r\n    if (retval && !(items instanceof Container.PropertySetChangeNotifier)) {\r\n        firePropertySetChange();\r\n    }\r\n    return retval;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.removeColumnVisibilityChangeListener",
	"Comment": "removes a previously registered column visibility change listener.",
	"Method": "void removeColumnVisibilityChangeListener(ColumnVisibilityChangeListener listener){\r\n    removeListener(ColumnVisibilityChangeEvent.class, listener, COLUMN_VISIBILITY_METHOD);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.expandStartDate",
	"Comment": "finds the first day of the week and returns a day representing the startof that day.",
	"Method": "Date expandStartDate(Date start,boolean expandToFullWeek){\r\n    if (expandToFullWeek) {\r\n        start = getFirstDateForWeek(start);\r\n    } else {\r\n        start = (Date) start.clone();\r\n    }\r\n    start = getStartOfDay(currentCalendar, start);\r\n    return start;\r\n}"
}, {
	"Path": "com.commafeed.backend.feed.FeedUtils.guessEncoding",
	"Comment": "detect feed encoding by using the declared encoding in the xml processing instruction and by detecting the characters used in the",
	"Method": "Charset guessEncoding(byte[] bytes){\r\n    String extracted = extractDeclaredEncoding(bytes);\r\n    if (StringUtils.startsWithIgnoreCase(extracted, \"iso-8859-\")) {\r\n        if (StringUtils.endsWith(extracted, \"1\") == false) {\r\n            return Charset.forName(extracted);\r\n        }\r\n    } else if (StringUtils.startsWithIgnoreCase(extracted, \"windows-\")) {\r\n        return Charset.forName(extracted);\r\n    }\r\n    return detectEncoding(bytes);\r\n}"
}, {
	"Path": "com.vaadin.client.Util.cloneNode",
	"Comment": "clones given element as in javascript.deprecate this if there appears similar method into gwt someday.",
	"Method": "com.google.gwt.user.client.Element cloneNode(Element element,boolean deep){\r\n    return DOM.asOld(WidgetUtil.cloneNode(element, deep));\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.getLocale",
	"Comment": "gets the default locale for this session.by default this is the preferred locale of the user using the session. inmost cases it is read from the browser defaults.",
	"Method": "Locale getLocale(){\r\n    assert hasLock();\r\n    if (locale != null) {\r\n        return locale;\r\n    }\r\n    return Locale.getDefault();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTwinColSelect.getCaptionWrapper",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "Widget getCaptionWrapper(){\r\n    return captionWrapper;\r\n}"
}, {
	"Path": "lbms.plugins.mldht.kad.Node.recievedConcurrent",
	"Comment": "an rpc message was received, the node must now update the right bucket.",
	"Method": "void recievedConcurrent(MessageBase msg){\r\n    InetAddress ip = msg.getOrigin().getAddress();\r\n    Key id = msg.getID();\r\n    Optional<RPCCall> associatedCall = Optional.ofNullable(msg.getAssociatedCall());\r\n    Optional<Key> expectedId = associatedCall.map(RPCCall::getExpectedID);\r\n    Optional<Pair<KBucket, KBucketEntry>> entryByIp = bucketForIP(ip);\r\n    if (associatedCall.isPresent() && !associatedCall.filter(c -> c.getRequest().getDestination().equals(c.getResponse().getOrigin())).isPresent()) {\r\n        return;\r\n    }\r\n    if (entryByIp.isPresent()) {\r\n        KBucket oldBucket = entryByIp.get().a;\r\n        KBucketEntry oldEntry = entryByIp.get().b;\r\n        if (oldEntry.getAddress().getPort() != msg.getOrigin().getPort())\r\n            return;\r\n        if (!oldEntry.getID().equals(id)) {\r\n            if (associatedCall.isPresent()) {\r\n                DHT.logInfo(\"force-removing routing table entry \" + oldEntry + \" because ID-change was detected; new ID:\" + msg.getID());\r\n                oldBucket.removeEntryIfBad(oldEntry, true);\r\n                RPCServer srv = msg.getServer();\r\n                tryPingMaintenance(oldBucket, \"checking sibling bucket entries after ID change was detected\", srv, (t) -> t.checkGoodEntries(true));\r\n                if (oldEntry.verifiedReachable()) {\r\n                    return;\r\n                }\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    KBucket bucketById = routingTableCOW.entryForId(id).bucket;\r\n    Optional<KBucketEntry> entryById = bucketById.findByIPorID(null, id);\r\n    if (entryById.isPresent() && !entryById.get().getAddress().getAddress().equals(ip))\r\n        return;\r\n    if (!entryById.isPresent() && expectedId.isPresent() && !expectedId.get().equals(id))\r\n        return;\r\n    KBucketEntry newEntry = new KBucketEntry(msg.getOrigin(), id);\r\n    msg.getVersion().ifPresent(newEntry::setVersion);\r\n    if (!associatedCall.isPresent() && updateAndCheckThrottle(newEntry.getAddress().getAddress())) {\r\n        refreshOnly(newEntry);\r\n        return;\r\n    }\r\n    associatedCall.ifPresent(c -> {\r\n        newEntry.signalResponse(c.getRTT());\r\n        newEntry.mergeRequestTime(c.getSentTime());\r\n    });\r\n    boolean trustedAndNotPresent = !entryById.isPresent() && msg.getType() == Type.RSP_MSG && trustedNodes.stream().anyMatch(mask -> mask.contains(ip));\r\n    Set<InsertOptions> opts = EnumSet.noneOf(InsertOptions.class);\r\n    if (trustedAndNotPresent)\r\n        opts.addAll(EnumSet.of(FORCE_INTO_MAIN_BUCKET, REMOVE_IF_FULL));\r\n    if (msg.getType() == Type.RSP_MSG)\r\n        opts.add(RELAXED_SPLIT);\r\n    insertEntry(newEntry, opts);\r\n    if (msg.getType() == Type.RSP_MSG) {\r\n        bucketById.notifyOfResponse(msg);\r\n    }\r\n    num_receives++;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.resetSizesFromDom",
	"Comment": "resets all cached pixel sizes and reads new values from the dom. thismethods should be used e.g. when styles affecting the dimensions ofelements in this grid have been changed.",
	"Method": "void resetSizesFromDom(){\r\n    getEscalator().resetSizesFromDom();\r\n}"
}, {
	"Path": "com.vaadin.ui.CssLayout.iterator",
	"Comment": "gets the component container iterator for going trough all the componentsin the container.",
	"Method": "Iterator<Component> iterator(){\r\n    return Collections.unmodifiableCollection(components).iterator();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.DateField.isShowISOWeekNumbers",
	"Comment": "checks whether iso 8601 week numbers are shown in the date selector.",
	"Method": "boolean isShowISOWeekNumbers(){\r\n    return showISOWeekNumbers;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.ui.UIConnector.scrollIntoView",
	"Comment": "tries to scroll the viewport so that the given connector is in view.",
	"Method": "void scrollIntoView(ComponentConnector componentConnector){\r\n    if (componentConnector == null) {\r\n        return;\r\n    }\r\n    Scheduler.get().scheduleDeferred(() -> componentConnector.getWidget().getElement().scrollIntoView());\r\n}"
}, {
	"Path": "com.vaadin.v7.server.communication.data.RpcDataProviderExtension.refreshCache",
	"Comment": "pushes a new version of all the rows in the active cache range.",
	"Method": "void refreshCache(){\r\n    if (!refreshCache) {\r\n        refreshCache = true;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Tree.setHtmlContentAllowed",
	"Comment": "sets whether html is allowed in the item captions. if set totrue, the captions are passed to the browser as html and thedeveloper is responsible for ensuring no harmful html is used. if set tofalse, the content is passed to the browser as plain text.the default setting is false",
	"Method": "void setHtmlContentAllowed(boolean htmlContentAllowed){\r\n    this.htmlContentAllowed = htmlContentAllowed;\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.server.BootstrapResponse.getUIProvider",
	"Comment": "gets the ui provider that is used to provide information about thebootstrapped ui.",
	"Method": "UIProvider getUIProvider(){\r\n    return uiProvider;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.setResizable",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setResizable(boolean resizability){\r\n    resizable = resizability;\r\n    if (resizability) {\r\n        DOM.setElementProperty(footer, \"className\", CLASSNAME + \"-footer\");\r\n        DOM.setElementProperty(resizeBox, \"className\", CLASSNAME + \"-resizebox\");\r\n    } else {\r\n        DOM.setElementProperty(footer, \"className\", CLASSNAME + \"-footer \" + CLASSNAME + \"-footer-noresize\");\r\n        DOM.setElementProperty(resizeBox, \"className\", CLASSNAME + \"-resizebox \" + CLASSNAME + \"-resizebox-disabled\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.dnd.event.DropEvent.getDragSourceExtension",
	"Comment": "returns the extension of the drag source component if the drag originatedfrom a component in the same ui as the drop target component, or an emptyoptional.",
	"Method": "Optional<DragSourceExtension<? extends AbstractComponent>> getDragSourceExtension(){\r\n    return Optional.ofNullable(dragSourceExtension);\r\n}"
}, {
	"Path": "com.vaadin.server.JsonPaintTarget.escapeJSON",
	"Comment": "escapes the given string so it can safely be used as a json string.",
	"Method": "String escapeJSON(String s){\r\n    if (s == null) {\r\n        return \"\";\r\n    }\r\n    final StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < s.length(); i++) {\r\n        final char ch = s.charAt(i);\r\n        switch(ch) {\r\n            case '\"':\r\n                sb.append(\"\\\\\\\"\");\r\n                break;\r\n            case '\\\\':\r\n                sb.append(\"\\\\\\\\\");\r\n                break;\r\n            case '\\b':\r\n                sb.append(\"\\\\b\");\r\n                break;\r\n            case '\\f':\r\n                sb.append(\"\\\\f\");\r\n                break;\r\n            case '\\n':\r\n                sb.append(\"\\\\n\");\r\n                break;\r\n            case '\\r':\r\n                sb.append(\"\\\\r\");\r\n                break;\r\n            case '\\t':\r\n                sb.append(\"\\\\t\");\r\n                break;\r\n            case '/':\r\n                sb.append(\"\\\\/\");\r\n                break;\r\n            default:\r\n                if (ch >= '' && ch <= '') {\r\n                    final String ss = Integer.toHexString(ch);\r\n                    sb.append(\"\\\%u\");\r\n                    for (int k = 0; k < 4 - ss.length(); k++) {\r\n                        sb.append('0');\r\n                    }\r\n                    sb.append(ss.toUpperCase(Locale.ROOT));\r\n                } else {\r\n                    sb.append(ch);\r\n                }\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTreeTable.addAndRemoveRows",
	"Comment": "overridden to allow animation of expands and collapses of nodes.",
	"Method": "void addAndRemoveRows(UIDL partialRowAdditions){\r\n    if (partialRowAdditions == null) {\r\n        return;\r\n    }\r\n    if (animationsEnabled) {\r\n        if (partialRowAdditions.hasAttribute(\"hide\")) {\r\n            scrollBody.unlinkRowsAnimatedAndUpdateCacheWhenFinished(partialRowAdditions.getIntAttribute(\"firstprowix\"), partialRowAdditions.getIntAttribute(\"numprows\"));\r\n        } else {\r\n            scrollBody.insertRowsAnimated(partialRowAdditions, partialRowAdditions.getIntAttribute(\"firstprowix\"), partialRowAdditions.getIntAttribute(\"numprows\"));\r\n            discardRowsOutsideCacheWindow();\r\n        }\r\n    } else {\r\n        super.addAndRemoveRows(partialRowAdditions);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.communication.SharedStateWriter.write",
	"Comment": "writes a json object containing the pending state changes of the dirtyconnectors of the given ui.",
	"Method": "Set<String> write(UI ui,Writer writer){\r\n    Collection<ClientConnector> dirtyVisibleConnectors = ui.getConnectorTracker().getDirtyVisibleConnectors();\r\n    Set<String> writtenConnectors = new HashSet();\r\n    JsonObject sharedStates = Json.createObject();\r\n    for (ClientConnector connector : dirtyVisibleConnectors) {\r\n        String connectorId = connector.getConnectorId();\r\n        try {\r\n            JsonObject stateJson = connector.encodeState();\r\n            if (stateJson != null && stateJson.keys().length != 0) {\r\n                sharedStates.put(connectorId, stateJson);\r\n                writtenConnectors.add(connectorId);\r\n            }\r\n        } catch (JsonException e) {\r\n            throw new PaintException(\"Failed to serialize shared state for connector \" + connector.getClass().getName() + \" (\" + connectorId + \"): \" + e.getMessage(), e);\r\n        }\r\n    }\r\n    writer.write(JsonUtil.stringify(sharedStates));\r\n    return writtenConnectors;\r\n}"
}, {
	"Path": "com.vaadin.client.BrowserInfo.getGeckoVersion",
	"Comment": "returns the gecko version if the browser is gecko based. the geckoversion for firefox 2 is 1.8 and 1.9 for firefox 3.",
	"Method": "float getGeckoVersion(){\r\n    if (!browserDetails.isGecko()) {\r\n        return -1;\r\n    }\r\n    return browserDetails.getBrowserEngineVersion();\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignContext.getComponentByCaption",
	"Comment": "returns a component having the specified caption. if no component isfound, returns null.",
	"Method": "Component getComponentByCaption(String caption){\r\n    return captionToComponent.get(caption);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.grid.sort.Sort.by",
	"Comment": "start building a sort order by sorting a provided column in ascendingorder.",
	"Method": "Sort by(Grid.Column<?, ?> column,Sort by,Grid.Column<?, ?> column,SortDirection direction){\r\n    return new Sort(column, direction);\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.getAssistivePostfix",
	"Comment": "gets the accessibility postfix for the window caption.this postfix is read to assistive device users after the window caption,but not visible on the page.",
	"Method": "String getAssistivePostfix(){\r\n    return getState(false).assistivePostfix;\r\n}"
}, {
	"Path": "com.vaadin.client.communication.XhrConnection.send",
	"Comment": "sends an asynchronous uidl request to the server using the given uri.",
	"Method": "void send(JsonObject payload){\r\n    RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, getUri());\r\n    addXsrfHeaderFromCookie(rb);\r\n    rb.setHeader(\"Content-Type\", JsonConstants.JSON_CONTENT_TYPE);\r\n    rb.setRequestData(payload.toJson());\r\n    XhrResponseHandler responseHandler = createResponseHandler();\r\n    responseHandler.setPayload(payload);\r\n    responseHandler.setRequestStartTime(Profiler.getRelativeTimeMillis());\r\n    rb.setCallback(responseHandler);\r\n    getLogger().info(\"Sending xhr message to server: \" + payload.toJson());\r\n    try {\r\n        final Request request = rb.send();\r\n        if (webkitMaybeIgnoringRequests && BrowserInfo.get().isWebkit()) {\r\n            final int retryTimeout = 250;\r\n            new Timer() {\r\n                @Override\r\n                public void run() {\r\n                    if (resendRequest(request) && webkitMaybeIgnoringRequests) {\r\n                        schedule(retryTimeout);\r\n                    }\r\n                }\r\n            }.schedule(retryTimeout);\r\n        }\r\n    } catch (RequestException e) {\r\n        getConnectionStateHandler().xhrException(new XhrConnectionError(null, payload, e));\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.communication.XhrConnection.send",
	"Comment": "sends an asynchronous uidl request to the server using the given uri.",
	"Method": "void send(JsonObject payload){\r\n    if (resendRequest(request) && webkitMaybeIgnoringRequests) {\r\n        schedule(retryTimeout);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.data.TreeData.addItems",
	"Comment": "adds the given items as root items and uses the given value provider torecursively populate children of the root items.",
	"Method": "TreeData<T> addItems(T parent,T items,TreeData<T> addItems,T parent,Collection<T> items,TreeData<T> addItems,T parent,Stream<T> items,TreeData<T> addItems,Collection<T> rootItems,ValueProvider<T, Collection<T>> childItemProvider,TreeData<T> addItems,Stream<T> rootItems,ValueProvider<T, Stream<T>> childItemProvider){\r\n    return addItems(rootItems.collect(Collectors.toList()), item -> childItemProvider.apply(item).collect(Collectors.toList()));\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.setCaption",
	"Comment": "setting the caption of a ui is not supported. to set the title of thehtml page, use page.settitle",
	"Method": "void setCaption(String caption){\r\n    throw new UnsupportedOperationException(\"You can not set the title of a UI. To set the title of the HTML page, use Page.setTitle\");\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.markDirty",
	"Comment": "mark the connector as dirty and notifies any marked as dirty listeners.this should not be done while the response is being written.",
	"Method": "void markDirty(ClientConnector connector){\r\n    if (isWritingResponse()) {\r\n        throw new IllegalStateException(\"A connector should not be marked as dirty while a response is being written.\");\r\n    }\r\n    if (getLogger().isLoggable(Level.FINE)) {\r\n        if (!isDirty(connector)) {\r\n            getLogger().log(Level.FINE, \"{0} is now dirty\", getConnectorAndParentInfo(connector));\r\n        }\r\n    }\r\n    if (!isDirty(connector)) {\r\n        notifyMarkedAsDirtyListeners(connector);\r\n    }\r\n    dirtyConnectors.add(connector);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.getSelectKey",
	"Comment": "returns the select key which selects the value. by default this is theenter key but it can be changed to whatever you like by overriding thismethod.",
	"Method": "int getSelectKey(){\r\n    return KeyCodes.KEY_ENTER;\r\n}"
}, {
	"Path": "com.vaadin.client.Util.getPossibleChildMeasurementHintParentConnector",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "HasChildMeasurementHintConnector getPossibleChildMeasurementHintParentConnector(ComponentConnector candidate){\r\n    ServerConnector parent = candidate.getParent();\r\n    if (parent instanceof HasChildMeasurementHintConnector) {\r\n        return (HasChildMeasurementHintConnector) parent;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VSlider.buildBase",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void buildBase(){\r\n    final String styleAttribute = isVertical() ? \"height\" : \"width\";\r\n    final String oppositeStyleAttribute = isVertical() ? \"width\" : \"height\";\r\n    final String domProperty = isVertical() ? \"offsetHeight\" : \"offsetWidth\";\r\n    base.getStyle().clearProperty(oppositeStyleAttribute);\r\n    if (getElement().hasParentElement()) {\r\n        final Element p = getElement();\r\n        if (p.getPropertyInt(domProperty) > MIN_SIZE) {\r\n            if (isVertical()) {\r\n                setHeight();\r\n            } else {\r\n                base.getStyle().clearProperty(styleAttribute);\r\n            }\r\n        } else {\r\n            base.getStyle().setPropertyPx(styleAttribute, MIN_SIZE);\r\n            Scheduler.get().scheduleDeferred(new Command() {\r\n                @Override\r\n                public void execute() {\r\n                    final Element p = getElement();\r\n                    if (p.getPropertyInt(domProperty) > MIN_SIZE + 5 || propertyNotNullOrEmpty(styleAttribute, p)) {\r\n                        if (isVertical()) {\r\n                            setHeight();\r\n                        } else {\r\n                            base.getStyle().clearProperty(styleAttribute);\r\n                        }\r\n                        setValue(value, false);\r\n                    }\r\n                }\r\n                private boolean propertyNotNullOrEmpty(final String styleAttribute, final Element p) {\r\n                    return p.getStyle().getProperty(styleAttribute) != null && !p.getStyle().getProperty(styleAttribute).isEmpty();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    if (!isVertical()) {\r\n        Scheduler.get().scheduleDeferred(new Command() {\r\n            @Override\r\n            public void execute() {\r\n                buildHandle();\r\n                setValue(value, false);\r\n            }\r\n        });\r\n    } else {\r\n        buildHandle();\r\n        setValue(value, false);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VSlider.buildBase",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void buildBase(){\r\n    final Element p = getElement();\r\n    if (p.getPropertyInt(domProperty) > MIN_SIZE + 5 || propertyNotNullOrEmpty(styleAttribute, p)) {\r\n        if (isVertical()) {\r\n            setHeight();\r\n        } else {\r\n            base.getStyle().clearProperty(styleAttribute);\r\n        }\r\n        setValue(value, false);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VSlider.buildBase",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void buildBase(){\r\n    return p.getStyle().getProperty(styleAttribute) != null && !p.getStyle().getProperty(styleAttribute).isEmpty();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VSlider.buildBase",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void buildBase(){\r\n    buildHandle();\r\n    setValue(value, false);\r\n}"
}, {
	"Path": "com.vaadin.ui.dnd.event.DragStartEvent.getComponent",
	"Comment": "returns the drag source component where the dragstart event occurred.",
	"Method": "T getComponent(){\r\n    return (T) super.getComponent();\r\n}"
}, {
	"Path": "com.vaadin.client.extensions.DropTargetExtensionConnector.removeDropTargetStyle",
	"Comment": "remove class name from the drop target element indication that data canbe dropped onto it.",
	"Method": "void removeDropTargetStyle(){\r\n    getDropTargetElement().removeClassName(getStylePrimaryName(getDropTargetElement()) + STYLE_SUFFIX_DROPTARGET);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VCheckBoxGroup.getItem",
	"Comment": "returns the jsonobject used to populate the checkbox widget that containsgiven element.",
	"Method": "JsonObject getItem(Element element){\r\n    return optionsToItems.entrySet().stream().filter(entry -> entry.getKey().getElement().isOrHasChild(element)).map(entry -> entry.getValue()).findFirst().orElse(null);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VUpload.enableUpload",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void enableUpload(){\r\n    setEnabledForSubmitButton(true);\r\n    fu.getElement().setPropertyBoolean(\"disabled\", false);\r\n    enabled = true;\r\n    if (submitted) {\r\n        cleanTargetFrame();\r\n        rebuildPanel();\r\n        submitted = false;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.Slider.setMax",
	"Comment": "sets the maximum slider value. if the current value of the slider islarger than this, the value is set to the new maximum.",
	"Method": "void setMax(double max){\r\n    double roundedMax = getRoundedValue(max);\r\n    getState().maxValue = roundedMax;\r\n    if (getMin() > roundedMax) {\r\n        getState().minValue = roundedMax;\r\n    }\r\n    if (getValue() > roundedMax) {\r\n        setValue(roundedMax);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.Upload.setButtonStyleName",
	"Comment": "in addition to the actual file chooser, upload components have buttonthat starts actual upload progress. this method is used to set astylename to that button.",
	"Method": "void setButtonStyleName(String buttonStyleName){\r\n    this.buttonStyleName = buttonStyleName;\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.setLocale",
	"Comment": "sets the default locale for this session.by default this is the preferred locale of the user using theapplication. in most cases it is read from the browser defaults.",
	"Method": "void setLocale(Locale locale){\r\n    assert hasLock();\r\n    this.locale = locale;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.ui.UIConnector.removeStylesheet",
	"Comment": "internal helper for removing any stylesheet with the given url",
	"Method": "void removeStylesheet(String url){\r\n    NodeList<Element> linkTags = getHead().getElementsByTagName(LinkElement.TAG);\r\n    for (int i = 0; i < linkTags.getLength(); i++) {\r\n        LinkElement link = LinkElement.as(linkTags.getItem(i));\r\n        if (!\"stylesheet\".equals(link.getRel())) {\r\n            continue;\r\n        }\r\n        if (!\"text/css\".equals(link.getType())) {\r\n            continue;\r\n        }\r\n        if (url.equals(link.getHref())) {\r\n            getHead().removeChild(link);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.getFirstDateForWeek",
	"Comment": "gets a date that is first day in the week that target given date belongsto.",
	"Method": "Date getFirstDateForWeek(Date date){\r\n    int firstDayOfWeek = currentCalendar.getFirstDayOfWeek();\r\n    currentCalendar.setTime(date);\r\n    while (firstDayOfWeek != currentCalendar.get(java.util.Calendar.DAY_OF_WEEK)) {\r\n        currentCalendar.add(java.util.Calendar.DATE, -1);\r\n    }\r\n    return currentCalendar.getTime();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheetBase.setActiveTabIndex",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setActiveTabIndex(int activeTabIndex){\r\n    this.activeTabIndex = activeTabIndex;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.getBackwardKey",
	"Comment": "the key that selects the previous day in the calendar. by default this isthe left arrow key but by overriding this method it can be changed towhatever you like.",
	"Method": "int getBackwardKey(){\r\n    return KeyCodes.KEY_LEFT;\r\n}"
}, {
	"Path": "com.vaadin.server.ClassResource.setCacheTime",
	"Comment": "sets the length of cache expiration time.this gives the adapter the possibility cache streams sent to the client.the caching may be made in adapter or at the client if the clientsupports caching. zero or negative value disables the caching of thisstream.",
	"Method": "void setCacheTime(long cacheTime){\r\n    this.cacheTime = cacheTime;\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConfiguration.runWhenDependenciesLoaded",
	"Comment": "runs the given command when all pending dependencies have been loaded, orimmediately if no dependencies are being loaded.",
	"Method": "void runWhenDependenciesLoaded(Command command){\r\n    if (dependenciesLoading == 0) {\r\n        command.execute();\r\n    } else {\r\n        callbacks.add(command);\r\n    }\r\n}"
}, {
	"Path": "bt.peer.PeerSourceFactory.getPeerSource",
	"Comment": "create a peer source for a given torrent.implementations are free to return the same instance for all torrents.",
	"Method": "PeerSource getPeerSource(Torrent torrent,PeerSource getPeerSource,TorrentId torrentId){\r\n    return getPeerSource(torrent.getTorrentId());\r\n}"
}, {
	"Path": "com.vaadin.server.communication.PushHandler.onConnect",
	"Comment": "called when a new push connection is requested to be opened by the client",
	"Method": "void onConnect(AtmosphereResource resource){\r\n    callWithUi(resource, establishCallback, false);\r\n}"
}, {
	"Path": "com.vaadin.server.AbstractExtension.getSupportedParentType",
	"Comment": "gets a type that the parent must be an instance of. override this if theextension only support certain targets, e.g. if only textfields can beextended.",
	"Method": "Class<? extends ClientConnector> getSupportedParentType(){\r\n    return ClientConnector.class;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.HierarchicalContainer.filterIncludingParents",
	"Comment": "scans the itemid and all its children for which items should be includedwhen filtering. all items which passes the filters are included.additionally all items that have a child node that should be included arealso themselves included.",
	"Method": "boolean filterIncludingParents(Object itemId,HashSet<Object> includedItems){\r\n    boolean toBeIncluded = passesFilters(itemId);\r\n    LinkedList<Object> childList = children.get(itemId);\r\n    if (childList != null) {\r\n        for (Object childItemId : children.get(itemId)) {\r\n            toBeIncluded |= filterIncludingParents(childItemId, includedItems);\r\n        }\r\n    }\r\n    if (toBeIncluded) {\r\n        includedItems.add(itemId);\r\n    }\r\n    return toBeIncluded;\r\n}"
}, {
	"Path": "com.vaadin.server.ServerRpcManager.getImplementation",
	"Comment": "returns the rpc interface implementation for the rpc target.",
	"Method": "T getImplementation(){\r\n    return implementation;\r\n}"
}, {
	"Path": "com.vaadin.server.StreamResource.getStreamSource",
	"Comment": "returns the source for this streamresource. streamsource isqueried when the resource is about to be streamed to the client.",
	"Method": "StreamSource getStreamSource(){\r\n    return streamSource;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.createFooterUpdater",
	"Comment": "creates the escalator updater used to update the footer rows in thisgrid. the updater is invoked when header rows or columns are added orremoved, or the content of existing header cells is changed.",
	"Method": "EscalatorUpdater createFooterUpdater(){\r\n    return new StaticSectionUpdater(footer, escalator.getFooter());\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridDragSource.getDraggedItems",
	"Comment": "collects the dragged items of a grid given the list of item keys.",
	"Method": "List<T> getDraggedItems(Grid<T> grid,List<String> draggedItemKeys){\r\n    if (draggedItemKeys == null || draggedItemKeys.isEmpty()) {\r\n        throw new IllegalStateException(\"The drag event does not contain dragged items\");\r\n    }\r\n    return draggedItemKeys.stream().map(key -> grid.getDataCommunicator().getKeyMapper().get(key)).collect(Collectors.toList());\r\n}"
}, {
	"Path": "com.vaadin.client.communication.MessageSender.getCommunicationMethodName",
	"Comment": "returns a human readable string representation of the method used tocommunicate with the server.",
	"Method": "String getCommunicationMethodName(){\r\n    String clientToServer = \"XHR\";\r\n    String serverToClient = \"-\";\r\n    if (push != null) {\r\n        serverToClient = push.getTransportType();\r\n        if (push.isBidirectional()) {\r\n            clientToServer = serverToClient;\r\n        }\r\n    }\r\n    return \"Client to server: \" + clientToServer + \", \" + \"server to client: \" + serverToClient;\r\n}"
}, {
	"Path": "com.vaadin.v7.tests.server.component.calendar.ContainerDataSourceTest.testAddEventConvinienceMethod",
	"Comment": "tests the addevent convenience method with the default event provider",
	"Method": "void testAddEventConvinienceMethod(){\r\n    java.util.Calendar cal = java.util.Calendar.getInstance();\r\n    Date start = cal.getTime();\r\n    cal.add(java.util.Calendar.MONTH, 1);\r\n    Date end = cal.getTime();\r\n    assertEquals(0, calendar.getEvents(start, end).size());\r\n    BasicEvent event = new BasicEvent(\"Test\", \"Test\", start);\r\n    calendar.addEvent(event);\r\n    List<CalendarEvent> events = calendar.getEvents(start, end);\r\n    assertEquals(1, events.size());\r\n    assertEquals(events.get(0).getCaption(), event.getCaption());\r\n    assertEquals(events.get(0).getDescription(), event.getDescription());\r\n    assertEquals(events.get(0).getStart(), event.getStart());\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.addColumnCollapseListener",
	"Comment": "adds a column collapse listener to the table. a column collapse listeneris called when the collapsed state of a column changes.",
	"Method": "void addColumnCollapseListener(ColumnCollapseListener listener){\r\n    addListener(TableConstants.COLUMN_COLLAPSE_EVENT_ID, ColumnCollapseEvent.class, listener, ColumnCollapseEvent.METHOD);\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.getDirtyConnectors",
	"Comment": "returns a collection of all connectors which have been marked as dirty.the state and pending rpc calls for dirty connectors are sent to theclient in the following request.",
	"Method": "Collection<ClientConnector> getDirtyConnectors(){\r\n    return dirtyConnectors;\r\n}"
}, {
	"Path": "com.vaadin.ui.MenuBar.isHtmlContentAllowed",
	"Comment": "checks whether item captions are interpreted as html or plain text.",
	"Method": "boolean isHtmlContentAllowed(){\r\n    return htmlContentAllowed;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractSplitPanel.setMaxSplitPosition",
	"Comment": "sets the maximum split position to the given position and unit. if thesplit position is reversed, maximum and minimum are also reversed.",
	"Method": "void setMaxSplitPosition(float pos,Unit unit){\r\n    setSplitPositionLimits(getSplitterState(false).minPosition, posMinUnit, pos, unit);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractField.fireValueChange",
	"Comment": "emits the value change event. the value contained in the field isvalidated before the event is created.",
	"Method": "void fireValueChange(boolean repaintIsNotNeeded){\r\n    fireEvent(new AbstractField.ValueChangeEvent(this));\r\n    if (!repaintIsNotNeeded) {\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.getValue",
	"Comment": "gets the selected item id or in multiselect mode a set of selected ids.",
	"Method": "Object getValue(){\r\n    final Object retValue = super.getValue();\r\n    if (isMultiSelect()) {\r\n        if (retValue == null) {\r\n            return new HashSet<Object>();\r\n        }\r\n        if (retValue instanceof Set) {\r\n            return Collections.unmodifiableSet((Set<?>) retValue);\r\n        } else if (retValue instanceof Collection) {\r\n            return new HashSet<Object>((Collection<?>) retValue);\r\n        } else {\r\n            final Set<Object> s = new HashSet<Object>();\r\n            if (items.containsId(retValue)) {\r\n                s.add(retValue);\r\n            }\r\n            return s;\r\n        }\r\n    } else {\r\n        return retValue;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractInMemoryContainer.internalAddItemAtEnd",
	"Comment": "add an item at the end of the container, and perform filtering ifnecessary. an event is fired if the filtered view changes.",
	"Method": "ITEMCLASS internalAddItemAtEnd(ITEMIDTYPE newItemId,ITEMCLASS item,boolean filter){\r\n    ITEMCLASS newItem = internalAddAt(getAllItemIds().size(), newItemId, item);\r\n    if (newItem != null && filter) {\r\n        filterAll();\r\n        if (!isFiltered()) {\r\n            fireItemAdded(indexOfId(newItemId), newItemId, item);\r\n        }\r\n    }\r\n    return newItem;\r\n}"
}, {
	"Path": "bt.TorrentClientBuilder.fileSelector",
	"Comment": "provide a file selector for partial download of the torrent.",
	"Method": "B fileSelector(TorrentFileSelector fileSelector){\r\n    Objects.requireNonNull(fileSelector, \"Missing file selector\");\r\n    this.fileSelector = fileSelector;\r\n    return (B) this;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VOptionGroupBase.getColumns",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "int getColumns(){\r\n    return cols;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractSplitPanel.setPositionReversed",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setPositionReversed(boolean reversed){\r\n    if (positionReversed != reversed) {\r\n        if (orientation == Orientation.HORIZONTAL) {\r\n            splitter.getStyle().clearRight();\r\n            splitter.getStyle().clearLeft();\r\n        } else if (orientation == Orientation.VERTICAL) {\r\n            splitter.getStyle().clearTop();\r\n            splitter.getStyle().clearBottom();\r\n        }\r\n        positionReversed = reversed;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractColorPicker.setHistoryVisibility",
	"Comment": "sets the visibility of the color history, displaying recently pickedcolors.",
	"Method": "void setHistoryVisibility(boolean visible){\r\n    historyVisible = visible;\r\n    if (window != null) {\r\n        window.setHistoryVisible(visible);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.DownloadStream.getParameter",
	"Comment": "gets a paramater for download stream. parameters are optional informationabout the downloadable stream and their meaning depends on the usedadapter. for example in webadapter they are interpreted as http responseheaders.",
	"Method": "String getParameter(String name){\r\n    if (params != null) {\r\n        return params.get(name);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinPortletSession.sendPortletEvent",
	"Comment": "sends a portlet event to the indicated destination.internally, an action may be created and opened, as an event cannot besent directly from all types of requests.sending portlet events from background threads is not supported.the event destinations and values need to be kept in the context untilsent. any memory leaks if the action fails are limited to the session.event names for events sent and received by a portlet need to be declaredin portlet.xml .",
	"Method": "void sendPortletEvent(UI uI,QName name,Serializable value){\r\n    PortletResponse response = getCurrentResponse();\r\n    if (response instanceof MimeResponse) {\r\n        String actionKey = \"\" + System.currentTimeMillis();\r\n        while (eventActionDestinationMap.containsKey(actionKey)) {\r\n            actionKey += \".\";\r\n        }\r\n        PortletURL actionUrl = generateActionURL(actionKey);\r\n        if (actionUrl != null) {\r\n            eventActionDestinationMap.put(actionKey, name);\r\n            eventActionValueMap.put(actionKey, value);\r\n            uI.getPage().setLocation(actionUrl.toString());\r\n        } else {\r\n            throw new IllegalStateException(\"Portlet events can only be sent from a portlet request\");\r\n        }\r\n    } else if (response instanceof StateAwareResponse) {\r\n        ((StateAwareResponse) response).setEvent(name, value);\r\n    } else {\r\n        throw new IllegalStateException(\"Portlet events can only be sent from a portlet request\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.grid.sort.SortEvent.isUserOriginated",
	"Comment": "returns whether this event originated from actions done by the user.",
	"Method": "boolean isUserOriginated(){\r\n    return userOriginated;\r\n}"
}, {
	"Path": "sundeepk.github.com.sample.ApplicationTest.testOpenedAndClosedListerCalledForCalendar",
	"Comment": "maybe a problem with espresso, for now manually check count.",
	"Method": "void testOpenedAndClosedListerCalledForCalendar(){\r\n    CompactCalendarAnimationListener listener = new CompactCalendarAnimationListener() {\r\n        @Override\r\n        public void onOpened() {\r\n            onOpenedCallCount = onOpenedCallCount + 1;\r\n        }\r\n        @Override\r\n        public void onClosed() {\r\n            onClosedCallCount++;\r\n        }\r\n    };\r\n    compactCalendarView.setAnimationListener(listener);\r\n    setDate(new Date(1423353600000L));\r\n    onView(withId(R.id.slide_calendar)).perform(click());\r\n    onView(withId(R.id.slide_calendar)).perform(click());\r\n    waitForAnimationFinish();\r\n    assertEquals(onClosedCallCount, 1);\r\n    assertEquals(onOpenedCallCount, 1);\r\n}"
}, {
	"Path": "sundeepk.github.com.sample.ApplicationTest.testOpenedAndClosedListerCalledForCalendar",
	"Comment": "maybe a problem with espresso, for now manually check count.",
	"Method": "void testOpenedAndClosedListerCalledForCalendar(){\r\n    onOpenedCallCount = onOpenedCallCount + 1;\r\n}"
}, {
	"Path": "sundeepk.github.com.sample.ApplicationTest.testOpenedAndClosedListerCalledForCalendar",
	"Comment": "maybe a problem with espresso, for now manually check count.",
	"Method": "void testOpenedAndClosedListerCalledForCalendar(){\r\n    onClosedCallCount++;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VSlider.getNavigationUpKey",
	"Comment": "get the key that increases the vertical slider. by default it is the uparrow key but by overriding this you can change the key to whatever youwant.",
	"Method": "int getNavigationUpKey(){\r\n    return KeyCodes.KEY_UP;\r\n}"
}, {
	"Path": "com.vaadin.event.ListenerMethod.matches",
	"Comment": "checks if the given object, event and method match with the ones storedin this listener.",
	"Method": "boolean matches(Class<?> eventType,Object target,boolean matches,Class<?> eventType,Object target,Method method){\r\n    return (this.target == target) && (eventType.equals(this.eventType) && method.equals(this.method));\r\n}"
}, {
	"Path": "com.vaadin.server.FileResource.getBufferSize",
	"Comment": "gets the size of the download buffer used for this resource.if the buffer size is 0, the buffer size is decided by the terminaladapter. the default value is 0.",
	"Method": "int getBufferSize(){\r\n    return bufferSize;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.GeneratedPropertyContainer.removeGeneratedProperty",
	"Comment": "removes any possible propertyvaluegenerator with given property id. firesa propertysetchangeevent.",
	"Method": "void removeGeneratedProperty(Object propertyId){\r\n    if (propertyGenerators.containsKey(propertyId)) {\r\n        propertyGenerators.remove(propertyId);\r\n        fireContainerPropertySetChange();\r\n    }\r\n}"
}, {
	"Path": "bt.torrent.messaging.ConnectionState.onCancel",
	"Comment": "signal that remote peer has cancelled a previously issued block request.",
	"Method": "void onCancel(Cancel cancel){\r\n    cancelledPeerRequests.add(Mapper.mapper().buildKey(cancel.getPieceIndex(), cancel.getOffset(), cancel.getLength()));\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.getForwardKey",
	"Comment": "the key that selects the next day in the calendar. by default this is theright arrow key but by overriding this method it can be changed towhatever you like.",
	"Method": "int getForwardKey(){\r\n    return KeyCodes.KEY_RIGHT;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.PropertysetItem.fireItemPropertySetChange",
	"Comment": "sends a property set change event to all interested listeners.",
	"Method": "void fireItemPropertySetChange(){\r\n    if (propertySetChangeListeners != null) {\r\n        final Item.PropertySetChangeEvent event = new PropertysetItem.PropertySetChangeEvent(this);\r\n        for (Object l : propertySetChangeListeners.toArray()) {\r\n            ((Item.PropertySetChangeListener) l).itemPropertySetChange(event);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.widget.escalator.ScrollbarBundle.getScrollSize",
	"Comment": "gets the amount of pixels the scrollbar needs to be able to scrollthrough.",
	"Method": "double getScrollSize(){\r\n    return parseCssDimensionToPixels(internalGetScrollSize());\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponent.fireComponentEvent",
	"Comment": "emits the component event. it is transmitted to all registered listenersinterested in such events.",
	"Method": "void fireComponentEvent(){\r\n    fireEvent(new Component.Event(this));\r\n}"
}, {
	"Path": "com.vaadin.shared.ui.MarginInfo.hasBottom",
	"Comment": "checks if this margininfo object has the bottom edge margin enabled.",
	"Method": "boolean hasBottom(){\r\n    return (bitMask & BOTTOM) == BOTTOM;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.orderedlayout.Slot.attachListeners",
	"Comment": "attaches resize listeners to the widget, caption and spacing elements",
	"Method": "void attachListeners(){\r\n    if (getWidget() != null && layout.getLayoutManager() != null) {\r\n        LayoutManager lm = layout.getLayoutManager();\r\n        if (getCaptionElement() != null && captionResizeListener != null) {\r\n            lm.addElementResizeListener(getCaptionElement(), captionResizeListener);\r\n        }\r\n        if (widgetResizeListener != null) {\r\n            lm.addElementResizeListener(getWidget().getElement(), widgetResizeListener);\r\n        }\r\n        if (getSpacingElement() != null && spacingResizeListener != null) {\r\n            lm.addElementResizeListener(getSpacingElement(), spacingResizeListener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VPopupView.showPopup",
	"Comment": "determines the correct position for a popup and displays the popup atthat position.by default, the popup is shown centered relative to its host component,ensuring it is visible on the screen if possible.can be overridden to customize the popup position.",
	"Method": "void showPopup(CustomPopup popup){\r\n    popup.setPopupPosition(0, 0);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.combobox.ComboBoxConnector.sendNewItem",
	"Comment": "send a message about a newly created item to the server.this method is for internal use only and may be removed in futureversions.",
	"Method": "void sendNewItem(String itemValue){\r\n    if (itemValue != null && !itemValue.equals(pendingNewItemValue)) {\r\n        clearNewItemHandling();\r\n    }\r\n    pendingNewItemValue = itemValue;\r\n    rpc.createNewItem(itemValue);\r\n    getDataReceivedHandler().clearPendingNavigation();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.ProgressBar.isIndeterminate",
	"Comment": "gets whether or not this progress indicator is indeterminate. inindeterminate mode there is an animation indicating that the task isrunning but without providing any information about the current progress.",
	"Method": "boolean isIndeterminate(){\r\n    return getState(false).indeterminate;\r\n}"
}, {
	"Path": "com.folioreader.view.DirectionalViewpager.canScroll",
	"Comment": "tests scrollability within child views of v given a delta of dx.",
	"Method": "boolean canScroll(View v,boolean checkV,int dx,int dy,int x,int y,boolean canScroll){\r\n    if (v instanceof ViewGroup) {\r\n        if (isHorizontal()) {\r\n            final ViewGroup group = (ViewGroup) v;\r\n            final int scrollX = v.getScrollX();\r\n            final int scrollY = v.getScrollY();\r\n            final int count = group.getChildCount();\r\n            for (int i = count - 1; i >= 0; i--) {\r\n                final View child = group.getChildAt(i);\r\n                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && canScroll(child, true, dx, 0, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                    return true;\r\n                }\r\n            }\r\n            return checkV && ViewCompat.canScrollHorizontally(v, -dx);\r\n        } else {\r\n            final ViewGroup group = (ViewGroup) v;\r\n            final int scrollX = v.getScrollX();\r\n            final int scrollY = v.getScrollY();\r\n            final int count = group.getChildCount();\r\n            for (int i = count - 1; i >= 0; i--) {\r\n                final View child = group.getChildAt(i);\r\n                if (y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && canScroll(child, true, 0, dy, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                    return true;\r\n                }\r\n            }\r\n            return checkV && ViewCompat.canScrollVertically(v, -dy);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.isClientChangeAllowed",
	"Comment": "is the user allowed to trigger events which alters the events.",
	"Method": "boolean isClientChangeAllowed(){\r\n    return !isReadOnly();\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.doFindOrCreateVaadinSession",
	"Comment": "finds or creates a vaadin session. assumes necessary synchronization hasbeen done by the caller to ensure this is not called simultaneously byseveral threads.",
	"Method": "VaadinSession doFindOrCreateVaadinSession(VaadinRequest request,boolean requestCanCreateSession){\r\n    assert ((ReentrantLock) getSessionLock(request.getWrappedSession())).isHeldByCurrentThread() : \"Session has not been locked by this thread\";\r\n    VaadinSession session = getExistingSession(request, requestCanCreateSession);\r\n    if (session != null) {\r\n        final boolean restartApplication = hasParameter(request, URL_PARAMETER_RESTART_APPLICATION) && !hasParameter(request, BootstrapHandler.IGNORE_RESTART_PARAM);\r\n        final boolean closeApplication = hasParameter(request, URL_PARAMETER_CLOSE_APPLICATION);\r\n        if (closeApplication) {\r\n            closeSession(session, request.getWrappedSession(false));\r\n            return null;\r\n        } else if (restartApplication) {\r\n            closeSession(session, request.getWrappedSession(false));\r\n            return createAndRegisterSession(request);\r\n        } else {\r\n            return session;\r\n        }\r\n    }\r\n    if (requestCanCreateSession) {\r\n        return createAndRegisterSession(request);\r\n    } else {\r\n        throw new SessionExpiredException();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.data.provider.HierarchyMapper.getIndexOf",
	"Comment": "finds the current index of given object. this is based on a search inflattened version of the hierarchy.",
	"Method": "Optional<Integer> getIndexOf(T target){\r\n    if (target == null) {\r\n        return Optional.empty();\r\n    }\r\n    final List<Object> collect = getHierarchy(null).map(provider::getId).collect(Collectors.toList());\r\n    int index = collect.indexOf(getDataProvider().getId(target));\r\n    return Optional.ofNullable(index < 0 ? null : index);\r\n}"
}, {
	"Path": "com.vaadin.server.SystemMessagesInfo.getService",
	"Comment": "returns the service this systemmessages request comes from.",
	"Method": "VaadinService getService(){\r\n    return service;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractSplitPanel.getFirstComponent",
	"Comment": "gets the first component of this split panel. depending on the directionthis is either the component shown at the top or to the left.",
	"Method": "Component getFirstComponent(){\r\n    return (Component) getState(false).firstChild;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.getItemDescriptionGenerator",
	"Comment": "get the item description generator which generates tooltips for cells androws in the table.",
	"Method": "ItemDescriptionGenerator getItemDescriptionGenerator(){\r\n    return itemDescriptionGenerator;\r\n}"
}, {
	"Path": "com.vaadin.server.AbstractClientConnector.getListeners",
	"Comment": "returns all listeners that are registered for the given event type or oneof its subclasses.",
	"Method": "Collection<?> getListeners(Class<?> eventType){\r\n    if (eventRouter == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    return eventRouter.getListeners(eventType);\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignAttributeHandler.findGetterForAttribute",
	"Comment": "returns a getter that can be used for reading the given design attributevalue from the class",
	"Method": "Method findGetterForAttribute(Class<?> clazz,String attribute){\r\n    resolveSupportedAttributes(clazz);\r\n    return CACHE.get(clazz).getGetter(attribute);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.PropertysetItem.removeItemProperty",
	"Comment": "removes the property identified by id from the item. this functionalityis optional. if the method is not implemented, the method always returnsfalse.",
	"Method": "boolean removeItemProperty(Object id){\r\n    if (map.remove(id) == null) {\r\n        return false;\r\n    }\r\n    list.remove(id);\r\n    fireItemPropertySetChange();\r\n    return true;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VFilterSelect.updateSuggestionPopupMinWidth",
	"Comment": "update minimum width for filterselect textarea based on input prompt andsuggestions.for internal use only. may be removed or replaced in the future.",
	"Method": "void updateSuggestionPopupMinWidth(){\r\n    String captions = WidgetUtil.escapeHTML(inputPrompt);\r\n    for (FilterSelectSuggestion suggestion : currentSuggestions) {\r\n        if (!captions.isEmpty()) {\r\n            captions += \"|\";\r\n        }\r\n        captions += WidgetUtil.escapeHTML(suggestion.getReplacementString());\r\n    }\r\n    suggestionPopupMinWidth = minWidth(captions);\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractSplitPanel.setFirstComponent",
	"Comment": "sets the first component of this split panel. depending on the directionthe first component is shown at the top or to the left.",
	"Method": "void setFirstComponent(Component c){\r\n    if (getFirstComponent() == c) {\r\n        return;\r\n    }\r\n    if (getFirstComponent() != null) {\r\n        removeComponent(getFirstComponent());\r\n    }\r\n    getState().firstChild = c;\r\n    if (c != null) {\r\n        super.addComponent(c);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.osgi.resources.impl.PathFormatHelper.getThemeAlias",
	"Comment": "returns the alias for the theme given a the theme name and a path prefix.",
	"Method": "String getThemeAlias(String themeName,String pathPrefix){\r\n    return String.format(VAADIN_THEME_ALIAS_FORMAT, pathPrefix, themeName);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.TouchScrollDelegate.getTimeStamp",
	"Comment": "long calculation are not very efficient in gwt, so this helper methodreturns timestamp in double.",
	"Method": "double getTimeStamp(){\r\n    return Duration.currentTimeMillis();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.combobox.ComboBoxConnector.sendFocusEvent",
	"Comment": "notify the server that the combo box received focus.for timing reasons, connectorfocusandblurhandler is not used at themoment.this method is for internal use only and may be removed in futureversions.",
	"Method": "void sendFocusEvent(){\r\n    boolean registeredListeners = hasEventListener(EventId.FOCUS);\r\n    if (registeredListeners) {\r\n        focusAndBlurRpc.focus();\r\n        getDataReceivedHandler().clearPendingNavigation();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.updateFirstVisibleAndScrollIfNeeded",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void updateFirstVisibleAndScrollIfNeeded(UIDL uidl){\r\n    firstvisible = uidl.hasVariable(\"firstvisible\") ? uidl.getIntVariable(\"firstvisible\") : 0;\r\n    firstvisibleOnLastPage = uidl.hasVariable(\"firstvisibleonlastpage\") ? uidl.getIntVariable(\"firstvisibleonlastpage\") : -1;\r\n    if (firstvisible != lastRequestedFirstvisible && scrollBody != null) {\r\n        lastRequestedFirstvisible = firstRowInViewPort;\r\n        enableLazyScroller();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.AbstractConnector.registerRpc",
	"Comment": "registers an implementation for a server to client rpc interface.multiple registrations can be made for a single interface, in which caseall of them receive corresponding rpc calls.",
	"Method": "void registerRpc(Class<T> rpcInterface,T implementation){\r\n    String rpcInterfaceId = rpcInterface.getName().replaceAll(\"\\\\$\", \".\");\r\n    if (null == rpcImplementations) {\r\n        rpcImplementations = FastStringMap.create();\r\n    }\r\n    if (null == rpcImplementations.get(rpcInterfaceId)) {\r\n        rpcImplementations.put(rpcInterfaceId, new ArrayList<ClientRpc>());\r\n    }\r\n    rpcImplementations.get(rpcInterfaceId).add(implementation);\r\n}"
}, {
	"Path": "com.vaadin.client.communication.ServerRpcQueue.getAll",
	"Comment": "returns a collection of all queued method invocations.the returned collection must not be modified in any way",
	"Method": "Collection<MethodInvocation> getAll(){\r\n    return pendingInvocations.values();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.setRowGenerator",
	"Comment": "assigns a row generator to the table. the row generator will be able toreplace rows in the table when it is rendered.",
	"Method": "void setRowGenerator(RowGenerator generator){\r\n    rowGenerator = generator;\r\n    refreshRowCache();\r\n}"
}, {
	"Path": "com.folioreader.view.VerticalViewPager.addTouchables",
	"Comment": "we only want the current page that is being shown to be touchable.",
	"Method": "void addTouchables(ArrayList<View> views){\r\n    for (int i = 0; i < getChildCount(); i++) {\r\n        final View child = getChildAt(i);\r\n        if (child.getVisibility() == VISIBLE) {\r\n            ItemInfo ii = infoForChild(child);\r\n            if (ii != null && ii.position == mCurItem) {\r\n                child.addTouchables(views);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractBeanContainer.setBeanIdResolver",
	"Comment": "sets the resolver that finds the item id for a bean, or null not to useautomatic resolving.methods that add a bean without specifying an id must not be called if noresolver has been set.note that methods taking an explicit id can be used whether a resolverhas been defined or not.",
	"Method": "void setBeanIdResolver(BeanIdResolver<IDTYPE, BEANTYPE> beanIdResolver){\r\n    this.beanIdResolver = beanIdResolver;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.HierarchicalContainer.setIncludeParentsWhenFiltering",
	"Comment": "controls how the filtering of the container works. set this to true tomake filtering include parents for all matched items in addition to theitems themselves. setting this to false causes the filtering to onlyinclude the matching items and make items with excluded parents into rootitems.",
	"Method": "void setIncludeParentsWhenFiltering(boolean includeParentsWhenFiltering){\r\n    this.includeParentsWhenFiltering = includeParentsWhenFiltering;\r\n    if (filteredRoots != null) {\r\n        doFilterContainer(true);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractSingleSelect.getSelectedItem",
	"Comment": "returns the currently selected item, or an empty optional if no item isselected.",
	"Method": "Optional<T> getSelectedItem(){\r\n    return Optional.ofNullable(selectedItem);\r\n}"
}, {
	"Path": "com.vaadin.ui.PopupView.createContent",
	"Comment": "creates a content from given text representation and popup content.",
	"Method": "Content createContent(String minimizedValue,Component popupContent){\r\n    return new Content() {\r\n        @Override\r\n        public String getMinimizedValueAsHTML() {\r\n            return minimizedValue;\r\n        }\r\n        @Override\r\n        public Component getPopupComponent() {\r\n            return popupContent;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.vaadin.ui.PopupView.createContent",
	"Comment": "creates a content from given text representation and popup content.",
	"Method": "Content createContent(String minimizedValue,Component popupContent){\r\n    return minimizedValue;\r\n}"
}, {
	"Path": "com.vaadin.ui.PopupView.createContent",
	"Comment": "creates a content from given text representation and popup content.",
	"Method": "Content createContent(String minimizedValue,Component popupContent){\r\n    return popupContent;\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.Design.setComponentMapper",
	"Comment": "sets the component mapper that is used for resolving between tag namesand component instances.please note that this setting is global, so care should be taken to avoidconflicting changes.",
	"Method": "void setComponentMapper(ComponentMapper componentMapper){\r\n    if (componentMapper == null) {\r\n        throw new IllegalArgumentException(\"Cannot set null component mapper\");\r\n    }\r\n    Design.componentMapper = componentMapper;\r\n}"
}, {
	"Path": "com.vaadin.client.data.AbstractRemoteDataSource.setCacheStrategy",
	"Comment": "sets the cache strategy that is used to determine how much data isfetched and cached.the new strategy is immediately used to evaluate whether currently cachedrows should be discarded or new rows should be fetched.",
	"Method": "void setCacheStrategy(CacheStrategy cacheStrategy){\r\n    if (cacheStrategy == null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (this.cacheStrategy != cacheStrategy) {\r\n        this.cacheStrategy = cacheStrategy;\r\n        checkCacheCoverage();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.SystemMessages.getCookiesDisabledCaption",
	"Comment": "returns the caption of the message shown to the user when cookies aredisabled in the browser.",
	"Method": "String getCookiesDisabledCaption(){\r\n    return (cookiesDisabledNotificationEnabled ? cookiesDisabledCaption : null);\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.init",
	"Comment": "initializes this service. the service should be initialized before it isused.",
	"Method": "void init(){\r\n    List<RequestHandler> handlers = createRequestHandlers();\r\n    ServiceInitEvent event = new ServiceInitEvent(this);\r\n    Iterator<VaadinServiceInitListener> initListeners = getServiceInitListeners();\r\n    while (initListeners.hasNext()) {\r\n        initListeners.next().serviceInit(event);\r\n    }\r\n    handlers.addAll(event.getAddedRequestHandlers());\r\n    Collections.reverse(handlers);\r\n    requestHandlers = Collections.unmodifiableCollection(handlers);\r\n    dependencyFilters = Collections.unmodifiableCollection(initDependencyFilters(event.getAddedDependencyFilters()));\r\n    connectorIdGenerator = initConnectorIdGenerator(event.getAddedConnectorIdGenerators());\r\n    assert connectorIdGenerator != null;\r\n    initialized = true;\r\n}"
}, {
	"Path": "com.vaadin.ui.DateTimeField.setAssistiveText",
	"Comment": "set a description that explains the usage of the widget for users ofassistive devices.",
	"Method": "void setAssistiveText(String description){\r\n    getState().descriptionForAssistiveDevices = description;\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.setTabStopBottomAssistiveText",
	"Comment": "sets the message that is provided to users of assistive devices when theuser reaches the bottom of the window when leaving a window with the tabkey is prevented.this message is not visible on the screen.",
	"Method": "void setTabStopBottomAssistiveText(String bottomMessage){\r\n    getState().assistiveTabStopBottomText = bottomMessage;\r\n}"
}, {
	"Path": "bt.torrent.messaging.ConnectionState.getCancelledPeerRequests",
	"Comment": "get keys of block requests, that have been cancelled by remote peer.",
	"Method": "Set<Object> getCancelledPeerRequests(){\r\n    return cancelledPeerRequests;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.DataCommunicator.reset",
	"Comment": "method for internal reset from a change in the component, requiring afull data update.",
	"Method": "void reset(){\r\n    if (!reset) {\r\n        getClientRpc().reset(getDataProviderSize());\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.debug.internal.VDebugWindow.addHandles",
	"Comment": "adds dummy handle elements to the bottom corners that might havescrollbars that interfere with resizing on some platforms.",
	"Method": "void addHandles(){\r\n    Element el = DOM.createDiv();\r\n    el.setClassName(VDebugWindow.STYLENAME + \"-handle \" + VDebugWindow.STYLENAME + \"-handle-sw\");\r\n    content.getElement().appendChild(el);\r\n    el = DOM.createDiv();\r\n    el.setClassName(VDebugWindow.STYLENAME + \"-handle \" + VDebugWindow.STYLENAME + \"-handle-se\");\r\n    content.getElement().appendChild(el);\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignAttributeHandler.readAlignment",
	"Comment": "read the alignment from the given child component attributes.",
	"Method": "Alignment readAlignment(Attributes attr){\r\n    int bitMask = 0;\r\n    if (attr.hasKey(\":middle\")) {\r\n        bitMask += AlignmentInfo.Bits.ALIGNMENT_VERTICAL_CENTER;\r\n    } else if (attr.hasKey(\":bottom\")) {\r\n        bitMask += AlignmentInfo.Bits.ALIGNMENT_BOTTOM;\r\n    } else {\r\n        bitMask += AlignmentInfo.Bits.ALIGNMENT_TOP;\r\n    }\r\n    if (attr.hasKey(\":center\")) {\r\n        bitMask += AlignmentInfo.Bits.ALIGNMENT_HORIZONTAL_CENTER;\r\n    } else if (attr.hasKey(\":right\")) {\r\n        bitMask += AlignmentInfo.Bits.ALIGNMENT_RIGHT;\r\n    } else {\r\n        bitMask += AlignmentInfo.Bits.ALIGNMENT_LEFT;\r\n    }\r\n    return new Alignment(bitMask);\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.setAssistivePostfix",
	"Comment": "sets the accessibility postfix for the window caption.this postfix is read to assistive device users after the window caption,but not visible on the page.",
	"Method": "void setAssistivePostfix(String assistivePostfix){\r\n    getState().assistivePostfix = assistivePostfix;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.DataCommunicator.addDataGenerator",
	"Comment": "adds a data generator to this data communicator. data generators can beused to insert custom data to the rows sent to the client. if the datagenerator is already added, does nothing.",
	"Method": "void addDataGenerator(DataGenerator<T> generator){\r\n    Objects.requireNonNull(generator, \"generator cannot be null\");\r\n    generators.add(generator);\r\n    reset();\r\n}"
}, {
	"Path": "com.vaadin.server.ClassResource.getBufferSize",
	"Comment": "gets the size of the download buffer used for this resource.if the buffer size is 0, the buffer size is decided by the terminaladapter. the default value is 0.",
	"Method": "int getBufferSize(){\r\n    return bufferSize;\r\n}"
}, {
	"Path": "com.vaadin.navigator.Navigator.performNavigateTo",
	"Comment": "internal method for activating a view, setting its parameters and callinglisteners.invoked after the current view has confirmed that leaving is ok.this method also verifies that the user is allowed to perform thenavigation operation.",
	"Method": "void performNavigateTo(View view,String viewName,String parameters){\r\n    ViewChangeEvent event = new ViewChangeEvent(this, currentView, view, viewName, parameters);\r\n    boolean navigationAllowed = beforeViewChange(event);\r\n    if (!navigationAllowed) {\r\n        revertNavigation();\r\n        return;\r\n    }\r\n    updateNavigationState(event);\r\n    if (getDisplay() != null) {\r\n        getDisplay().showView(view);\r\n    }\r\n    switchView(event);\r\n    view.enter(event);\r\n    fireAfterViewChange(event);\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponent.setCaptionAsHtml",
	"Comment": "sets whether the caption is rendered as html.if set to true, the captions are rendered in the browser as html and thedeveloper is responsible for ensuring no harmful html is used. if set tofalse, the caption is rendered in the browser as plain text.the default is false, i.e. to render that caption as plain text.",
	"Method": "void setCaptionAsHtml(boolean captionAsHtml){\r\n    getState().captionAsHtml = captionAsHtml;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.getTotalSuggestions",
	"Comment": "gets the total number of suggestions, excluding the null selection item.",
	"Method": "int getTotalSuggestions(){\r\n    return totalSuggestions;\r\n}"
}, {
	"Path": "com.vaadin.v7.server.communication.data.RpcDataProviderExtension.insertRowData",
	"Comment": "informs the client side that new rows have been inserted into the datasource.",
	"Method": "void insertRowData(int index,int count){\r\n    if (rowChanges == null) {\r\n        rowChanges = new ArrayList<Runnable>();\r\n    }\r\n    if (rowChanges.isEmpty()) {\r\n        markAsDirty();\r\n    }\r\n    rowChanges.add(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            rpc.insertRowData(index, count);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.vaadin.v7.server.communication.data.RpcDataProviderExtension.insertRowData",
	"Comment": "informs the client side that new rows have been inserted into the datasource.",
	"Method": "void insertRowData(int index,int count){\r\n    rpc.insertRowData(index, count);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Upload.interruptUpload",
	"Comment": "interrupts the upload currently being received. the interruption will bedone by the receiving thread so this method will return immediately andthe actual interrupt will happen a bit later.",
	"Method": "void interruptUpload(){\r\n    if (isUploading) {\r\n        interrupted = true;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractTextField.setPlaceholder",
	"Comment": "sets the placeholder text. the placeholder is text that is displayed whenthe field would otherwise be empty, to prompt the user for input.",
	"Method": "void setPlaceholder(String placeholder){\r\n    getState().placeholder = placeholder;\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.setResizeLazy",
	"Comment": "should resize operations be lazy, i.e. should there be a delay beforelayout sizes are recalculated. speeds up resize operations in slow uiswith the penalty of slightly decreased usability.note, some browser send false resize events for the browser window andare therefore always lazy.",
	"Method": "void setResizeLazy(boolean resizeLazy){\r\n    getState().resizeLazy = resizeLazy;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.ui.UIConnector.getSubWindows",
	"Comment": "return an iterator for current subwindows. this method is meant fortesting purposes only.",
	"Method": "List<WindowConnector> getSubWindows(){\r\n    List<WindowConnector> windows = new ArrayList();\r\n    for (ComponentConnector child : getChildComponents()) {\r\n        if (child instanceof WindowConnector) {\r\n            windows.add((WindowConnector) child);\r\n        }\r\n    }\r\n    return windows;\r\n}"
}, {
	"Path": "com.vaadin.server.ServerRpcMethodInvocation.doFindInvocationMethod",
	"Comment": "tries to find the method from the class by looping through availablemethods.",
	"Method": "Method doFindInvocationMethod(Class<?> targetType,String methodName,int parameterCount){\r\n    Method[] methods = targetType.getMethods();\r\n    for (Method method : methods) {\r\n        Class<?>[] parameterTypes = method.getParameterTypes();\r\n        if (method.getName().equals(methodName) && parameterTypes.length == parameterCount) {\r\n            return method;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.getUpdatedRowCount",
	"Comment": "subclass and override this to enable partial row updates, bypassing thenormal caching and lazy loading mechanism. this is useful for updatingthe state of certain rows, e.g. in the treetable the collapsed state of asingle node is updated using this mechanism.",
	"Method": "int getUpdatedRowCount(){\r\n    return 0;\r\n}"
}, {
	"Path": "com.vaadin.client.WidgetUtil.getElementUnderMouse",
	"Comment": "find the element corresponding to the coordinates in the passed mouseevent. please note that this is not always the same as the target of theevent e.g. if event capture is used.",
	"Method": "Element getElementUnderMouse(NativeEvent event){\r\n    int pageX = getTouchOrMouseClientX(event);\r\n    int pageY = getTouchOrMouseClientY(event);\r\n    return getElementFromPoint(pageX, pageY);\r\n}"
}, {
	"Path": "com.github.sundeepk.compactcalendarview.CompactCalendarView.addEvents",
	"Comment": "adds multiple events to the calendar and invalidates the view once all events are added.",
	"Method": "void addEvents(List<Event> events){\r\n    compactCalendarController.addEvents(events);\r\n    invalidate();\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.addBootstrapListener",
	"Comment": "adds a listener that will be invoked when the bootstrap html is about tobe generated. this can be used to modify the contents of the html thatloads the vaadin application in the browser and the http headers that areincluded in the response serving the html.",
	"Method": "Registration addBootstrapListener(BootstrapListener listener){\r\n    assert hasLock();\r\n    eventRouter.addListener(BootstrapFragmentResponse.class, listener, BOOTSTRAP_FRAGMENT_METHOD);\r\n    eventRouter.addListener(BootstrapPageResponse.class, listener, BOOTSTRAP_PAGE_METHOD);\r\n    return () -> {\r\n        eventRouter.removeListener(BootstrapFragmentResponse.class, listener, BOOTSTRAP_FRAGMENT_METHOD);\r\n        eventRouter.removeListener(BootstrapPageResponse.class, listener, BOOTSTRAP_PAGE_METHOD);\r\n    };\r\n}"
}, {
	"Path": "com.vaadin.ui.Embedded.setCodetype",
	"Comment": "this attribute specifies the content type of data expected whendownloading the object specified by classid. this attribute is optionalbut recommended when classid is specified since it allows the user agentto avoid loading information for unsupported content types. when absent,it defaults to the value of the type attribute.",
	"Method": "void setCodetype(String codetype){\r\n    String oldCodetype = getCodetype();\r\n    if (codetype != oldCodetype || (codetype != null && !codetype.equals(oldCodetype))) {\r\n        getState().codetype = codetype;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.AbstractComponentConnector.getWidget",
	"Comment": "returns the widget associated with this paintable. the widget returned bythis method must not changed during the life time of the paintable.",
	"Method": "Widget getWidget(){\r\n    if (widget == null) {\r\n        if (Profiler.isEnabled()) {\r\n            Profiler.enter(\"AbstractComponentConnector.createWidget for \" + getClass().getSimpleName());\r\n        }\r\n        widget = createWidget();\r\n        if (Profiler.isEnabled()) {\r\n            Profiler.leave(\"AbstractComponentConnector.createWidget for \" + getClass().getSimpleName());\r\n        }\r\n    }\r\n    return widget;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.getFirstVisibleHourOfDay",
	"Comment": "returns the first visible hour in the week view. returns the hour using a24h time format",
	"Method": "int getFirstVisibleHourOfDay(){\r\n    return firstHour;\r\n}"
}, {
	"Path": "com.vaadin.client.componentlocator.VaadinFinderLocatorStrategy.getElementsByPathStartingAtConnector",
	"Comment": "finds a list of elements by the specified path, starting traversal of theconnector hierarchy from the specified root.",
	"Method": "List<Element> getElementsByPathStartingAtConnector(String path,ComponentConnector root,Element actualRoot){\r\n    String[] pathComponents = path.split(SUBPART_SEPARATOR);\r\n    List<ComponentConnector> connectors;\r\n    if (!pathComponents[0].isEmpty()) {\r\n        connectors = findConnectorsByPath(pathComponents[0], Arrays.asList(root));\r\n    } else {\r\n        connectors = Arrays.asList(root);\r\n    }\r\n    List<Element> output = new ArrayList();\r\n    if (null != connectors && !connectors.isEmpty()) {\r\n        for (ComponentConnector connector : connectors) {\r\n            if (!actualRoot.isOrHasChild(connector.getWidget().getElement())) {\r\n                continue;\r\n            }\r\n            if (pathComponents.length > 1) {\r\n                if (connector.getWidget() instanceof SubPartAware) {\r\n                    output.add(((SubPartAware) connector.getWidget()).getSubPartElement(pathComponents[1]));\r\n                }\r\n            } else {\r\n                output.add(connector.getWidget().getElement());\r\n            }\r\n        }\r\n    }\r\n    return eliminateDuplicates(output);\r\n}"
}, {
	"Path": "com.vaadin.ui.ComboBox.getStyleGenerator",
	"Comment": "gets the currently used style generator that is used to generate cssclass names for items. the default item style provider returns null forall items, resulting in no custom item class names being set.",
	"Method": "StyleGenerator<T> getStyleGenerator(){\r\n    return itemStyleGenerator;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.PropertysetItem.toString",
	"Comment": "gets the string representation of the contents of the item.the format of the string is a space separated catenation of thestring representations of the properties contained by theitem.",
	"Method": "String toString(){\r\n    String retValue = \"\";\r\n    for (final Iterator<?> i = getItemPropertyIds().iterator(); i.hasNext(); ) {\r\n        final Object propertyId = i.next();\r\n        retValue += getItemProperty(propertyId).getValue();\r\n        if (i.hasNext()) {\r\n            retValue += \" \";\r\n        }\r\n    }\r\n    return retValue;\r\n}"
}, {
	"Path": "com.vaadin.ui.MenuBar.addItem",
	"Comment": "add a new item to the menu bar. icon and command can be null, but acaption must be given.",
	"Method": "MenuBar.MenuItem addItem(String caption,MenuBar.MenuItem addItem,String caption,MenuBar.Command command,MenuBar.MenuItem addItem,String caption,Resource icon,MenuBar.Command command,MenuBar.MenuItem addItem,String caption,MenuBar.MenuItem addItem,String caption,MenuBar.Command command,MenuBar.MenuItem addItem,String caption,Resource icon,MenuBar.Command command){\r\n    if (caption == null) {\r\n        throw new IllegalArgumentException(\"caption cannot be null\");\r\n    }\r\n    MenuItem newItem = new MenuItem(caption, icon, command);\r\n    menuItems.add(newItem);\r\n    markAsDirty();\r\n    return newItem;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.DateField.getRangeEnd",
	"Comment": "gets the end range for a certain resolution. the range is inclusive, soif rangeend is set to zero milliseconds past year n and resolution is setto year, any date in year n will be accepted. resolutions lower than daywill be interpreted on a day level. that is, everything below date iscleared",
	"Method": "Date getRangeEnd(Resolution forResolution,Date getRangeEnd){\r\n    return getState(false).rangeEnd;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.getSystemMessages",
	"Comment": "gets the system message to use for a specific locale. this method mayalso be implemented to use information from current instances of variousobjects, which means that this method might return different values forthe same locale under different circumstances.",
	"Method": "SystemMessages getSystemMessages(Locale locale,VaadinRequest request){\r\n    SystemMessagesInfo systemMessagesInfo = new SystemMessagesInfo();\r\n    systemMessagesInfo.setLocale(locale);\r\n    systemMessagesInfo.setService(this);\r\n    systemMessagesInfo.setRequest(request);\r\n    return getSystemMessagesProvider().getSystemMessages(systemMessagesInfo);\r\n}"
}, {
	"Path": "com.vaadin.shared.Range.expand",
	"Comment": "creates a range that is expanded the given amounts in both ends.",
	"Method": "Range expand(int startDelta,int endDelta){\r\n    return Range.between(getStart() - startDelta, getEnd() + endDelta);\r\n}"
}, {
	"Path": "com.vaadin.server.widgetsetutils.metadata.MethodProperty.getSetters",
	"Comment": "returns a list of all setters found in the beantype or its parent class",
	"Method": "List<JMethod> getSetters(JClassType beanType,Set<String> getters){\r\n    List<JMethod> setterMethods = new ArrayList();\r\n    while (beanType != null && !beanType.getQualifiedSourceName().equals(Object.class.getName())) {\r\n        for (JMethod method : beanType.getMethods()) {\r\n            if (!method.isPublic() || method.isStatic()) {\r\n                continue;\r\n            }\r\n            String methodName = method.getName();\r\n            if (methodName.startsWith(\"set\") && method.getParameterTypes().length == 1) {\r\n                setterMethods.add(method);\r\n            } else if (method.getParameterTypes().length == 0 && methodName.startsWith(\"is\") || methodName.startsWith(\"get\")) {\r\n                getters.add(methodName);\r\n            }\r\n        }\r\n        beanType = beanType.getSuperclass();\r\n    }\r\n    return setterMethods;\r\n}"
}, {
	"Path": "com.vaadin.server.KeyMapper.merge",
	"Comment": "merge objects into the mapper.this method will add the new objects to the mapper and remove inactiveobjects from it.",
	"Method": "void merge(Set<V> objects){\r\n    final Set<String> keys = new HashSet(keyObjectMap.size());\r\n    for (V object : objects) {\r\n        if (object == null) {\r\n            continue;\r\n        }\r\n        String key = key(object);\r\n        keys.add(key);\r\n    }\r\n    keyObjectMap.entrySet().removeIf(entry -> !keys.contains(entry.getKey()));\r\n    objectIdKeyMap.entrySet().removeIf(entry -> !keys.contains(entry.getValue()));\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addHeaderKeyPressHandler",
	"Comment": "register a headerkeypresshandler to this grid. the event for this handleris fired when a keypress event occurs while cell focus is in the headerof this grid.",
	"Method": "HandlerRegistration addHeaderKeyPressHandler(HeaderKeyPressHandler handler){\r\n    return addHandler(handler, GridKeyPressEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.client.VErrorMessage.updateErrorLevel",
	"Comment": "sets the correct error level style name for the error message and removesall previous style names.",
	"Method": "void updateErrorLevel(ErrorLevel errorLevel){\r\n    ErrorUtil.setErrorLevelStyle(getStyleElement(), CLASSNAME, errorLevel);\r\n}"
}, {
	"Path": "com.vaadin.tests.server.AtmosphereVersionTest.testAtmosphereVersion",
	"Comment": "test that the atmosphere version constant matches the version on ourclasspath",
	"Method": "void testAtmosphereVersion(){\r\n    assertEquals(Constants.REQUIRED_ATMOSPHERE_RUNTIME_VERSION, Version.getRawVersion());\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractDateField.setDateOutOfRangeMessage",
	"Comment": "sets the current error message if the range validation fails.",
	"Method": "void setDateOutOfRangeMessage(String dateOutOfRangeMessage){\r\n    this.dateOutOfRangeMessage = dateOutOfRangeMessage;\r\n}"
}, {
	"Path": "com.folioreader.ui.base.HtmlUtil.getHtmlContent",
	"Comment": "function modifies input html string by adding extra css,js and font information.",
	"Method": "String getHtmlContent(Context context,String htmlContent,Config config){\r\n    String cssPath = String.format(context.getString(R.string.css_tag), \"file:///android_asset/css/Style.css\");\r\n    String jsPath = String.format(context.getString(R.string.script_tag), \"file:///android_asset/js/jsface.min.js\") + \"\\n\";\r\n    jsPath = jsPath + String.format(context.getString(R.string.script_tag), \"file:///android_asset/js/jquery-3.1.1.min.js\") + \"\\n\";\r\n    jsPath = jsPath + String.format(context.getString(R.string.script_tag), \"file:///android_asset/js/rangy-core.js\") + \"\\n\";\r\n    jsPath = jsPath + String.format(context.getString(R.string.script_tag), \"file:///android_asset/js/rangy-highlighter.js\") + \"\\n\";\r\n    jsPath = jsPath + String.format(context.getString(R.string.script_tag), \"file:///android_asset/js/rangy-classapplier.js\") + \"\\n\";\r\n    jsPath = jsPath + String.format(context.getString(R.string.script_tag), \"file:///android_asset/js/rangy-serializer.js\") + \"\\n\";\r\n    jsPath = jsPath + String.format(context.getString(R.string.script_tag), \"file:///android_asset/js/Bridge.js\") + \"\\n\";\r\n    jsPath = jsPath + String.format(context.getString(R.string.script_tag), \"file:///android_asset/android.selection.js\") + \"\\n\";\r\n    jsPath = jsPath + String.format(context.getString(R.string.script_tag), \"file:///android_asset/js/rangefix.js\") + \"\\n\";\r\n    jsPath = jsPath + String.format(context.getString(R.string.script_tag_method_call), \"setMediaOverlayStyleColors('#C0ED72','#C0ED72')\") + \"\\n\";\r\n    jsPath = jsPath + \"<meta name=\\\"viewport\\\" content=\\\"height=device-height, user-scalable=no\\\" />\";\r\n    String toInject = \"\\n\" + cssPath + \"\\n\" + jsPath + \"\\n<\/head>\";\r\n    htmlContent = htmlContent.replace(\"<\/head>\", toInject);\r\n    String classes = \"\";\r\n    switch(config.getFont()) {\r\n        case Constants.FONT_ANDADA:\r\n            classes = \"andada\";\r\n            break;\r\n        case Constants.FONT_LATO:\r\n            classes = \"lato\";\r\n            break;\r\n        case Constants.FONT_LORA:\r\n            classes = \"lora\";\r\n            break;\r\n        case Constants.FONT_RALEWAY:\r\n            classes = \"raleway\";\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    if (config.isNightMode()) {\r\n        classes += \" nightMode\";\r\n    }\r\n    switch(config.getFontSize()) {\r\n        case 0:\r\n            classes += \" textSizeOne\";\r\n            break;\r\n        case 1:\r\n            classes += \" textSizeTwo\";\r\n            break;\r\n        case 2:\r\n            classes += \" textSizeThree\";\r\n            break;\r\n        case 3:\r\n            classes += \" textSizeFour\";\r\n            break;\r\n        case 4:\r\n            classes += \" textSizeFive\";\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    htmlContent = htmlContent.replace(\"<html\", \"<html class=\\\"\" + classes + \"\\\"\" + \" onclick=\\\"onClickHtml()\\\"\");\r\n    return htmlContent;\r\n}"
}, {
	"Path": "com.vaadin.client.BrowserInfo.getWebkitVersion",
	"Comment": "returns the webkit version if the browser is webkit based. the webkitversion returned is the major version e.g., 523.",
	"Method": "float getWebkitVersion(){\r\n    if (!browserDetails.isWebKit()) {\r\n        return -1;\r\n    }\r\n    return browserDetails.getBrowserEngineVersion();\r\n}"
}, {
	"Path": "com.vaadin.data.provider.InMemoryDataProvider.setSortOrder",
	"Comment": "sets the property and direction to use as the default sorting for thisdata provider. this overrides the sorting set by any other method thatmanipulates the default sorting of this data provider.the default sorting is used if the query defines no sorting. the defaultsorting is also used to determine the ordering of items that areconsidered equal by the sorting defined in the query.",
	"Method": "void setSortOrder(ValueProvider<T, V> valueProvider,SortDirection sortDirection){\r\n    setSortComparator(InMemoryDataProviderHelpers.propertyComparator(valueProvider, sortDirection));\r\n}"
}, {
	"Path": "com.vaadin.server.Page.getLocation",
	"Comment": "returns the location uri of this page, as reported by the browser. notethat this may not be consistent with the server uri the application isdeployed in due to potential proxies, redirections and similar.",
	"Method": "URI getLocation(){\r\n    if (location == null && !uI.getSession().getConfiguration().isSendUrlsAsParameters()) {\r\n        throw new IllegalStateException(\"Location is not available as the \" + Constants.SERVLET_PARAMETER_SENDURLSASPARAMETERS + \" parameter is configured as false\");\r\n    }\r\n    return location;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.ui.UIConnector.loadTheme",
	"Comment": "loads the given theme and replaces the given link element with the newtheme link element.",
	"Method": "void loadTheme(String newTheme,String newThemeUrl,LinkElement tagToReplace){\r\n    LinkElement newThemeLinkElement = Document.get().createLinkElement();\r\n    newThemeLinkElement.setRel(\"stylesheet\");\r\n    newThemeLinkElement.setType(\"text/css\");\r\n    newThemeLinkElement.setHref(newThemeUrl);\r\n    ResourceLoader.addOnloadHandler(newThemeLinkElement, new ResourceLoadListener() {\r\n        @Override\r\n        public void onLoad(ResourceLoadEvent event) {\r\n            getLogger().info(\"Loading of \" + newTheme + \" from \" + newThemeUrl + \" completed\");\r\n            if (tagToReplace != null) {\r\n                tagToReplace.getParentElement().removeChild(tagToReplace);\r\n            }\r\n            activateTheme(newTheme);\r\n        }\r\n        @Override\r\n        public void onError(ResourceLoadEvent event) {\r\n            getLogger().warning(\"Could not load theme from \" + getThemeUrl(newTheme));\r\n        }\r\n    }, null);\r\n    if (tagToReplace != null) {\r\n        getHead().insertBefore(newThemeLinkElement, tagToReplace);\r\n    } else {\r\n        getHead().appendChild(newThemeLinkElement);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.ui.UIConnector.loadTheme",
	"Comment": "loads the given theme and replaces the given link element with the newtheme link element.",
	"Method": "void loadTheme(String newTheme,String newThemeUrl,LinkElement tagToReplace){\r\n    getLogger().info(\"Loading of \" + newTheme + \" from \" + newThemeUrl + \" completed\");\r\n    if (tagToReplace != null) {\r\n        tagToReplace.getParentElement().removeChild(tagToReplace);\r\n    }\r\n    activateTheme(newTheme);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.ui.UIConnector.loadTheme",
	"Comment": "loads the given theme and replaces the given link element with the newtheme link element.",
	"Method": "void loadTheme(String newTheme,String newThemeUrl,LinkElement tagToReplace){\r\n    getLogger().warning(\"Could not load theme from \" + getThemeUrl(newTheme));\r\n}"
}, {
	"Path": "net.openhft.chronicle.queue.impl.single.SingleChronicleQueue.onRoll",
	"Comment": "allows the appenders to inform the queue that they have rolled",
	"Method": "void onRoll(int cycle){\r\n    if (lastCycle < cycle)\r\n        lastCycle = cycle;\r\n    if (firstCycle > cycle)\r\n        firstCycle = cycle;\r\n}"
}, {
	"Path": "bt.peer.lan.LocalServiceDiscoveryService.collectNextTorrents",
	"Comment": "collect next few ids to announce and additionally remove all inactive ids from the queue.",
	"Method": "Collection<TorrentId> collectNextTorrents(Map<TorrentId, StatusChange> statusChanges){\r\n    int k = config.getLocalServiceDiscoveryMaxTorrentsPerAnnounce();\r\n    List<TorrentId> ids = new ArrayList(k * 2);\r\n    Iterator<TorrentId> iter = announceQueue.iterator();\r\n    while (iter.hasNext()) {\r\n        TorrentId id = iter.next();\r\n        StatusChange statusChange = statusChanges.get(id);\r\n        if (statusChange == null) {\r\n            if (ids.size() < k) {\r\n                iter.remove();\r\n                ids.add(id);\r\n                announceQueue.add(id);\r\n            }\r\n        } else if (statusChange == StatusChange.STOPPED) {\r\n            iter.remove();\r\n        }\r\n    }\r\n    statusChanges.forEach((id, statusChange) -> {\r\n        if (statusChange == StatusChange.STARTED) {\r\n            announceQueue.add(id);\r\n            if (ids.size() < k) {\r\n                ids.add(id);\r\n            }\r\n        }\r\n    });\r\n    return ids;\r\n}"
}, {
	"Path": "com.vaadin.util.ReflectTools.findCommonBaseType",
	"Comment": "finds the most specific class that both provided classes extend from.",
	"Method": "Class<?> findCommonBaseType(Class<?> a,Class<?> b){\r\n    if (a.isInterface()) {\r\n        throw new IllegalArgumentException(\"a cannot be an interface\");\r\n    }\r\n    if (b.isInterface()) {\r\n        throw new IllegalArgumentException(\"b cannot be an interface\");\r\n    }\r\n    if (a.isAssignableFrom(b)) {\r\n        return a;\r\n    } else if (b.isAssignableFrom(a)) {\r\n        return b;\r\n    }\r\n    Class<?> currentClass = a;\r\n    while (!currentClass.isAssignableFrom(b)) {\r\n        currentClass = currentClass.getSuperclass();\r\n    }\r\n    return currentClass;\r\n}"
}, {
	"Path": "com.github.dozermapper.core.util.BridgedMethodFinder.findMethod",
	"Comment": "find the original method for the java5 bridge method. if the supplied methodis not a bridge method then the supplied method is returned.if the supplied method is a bridge method, the algorithm tries to find a morespecific method with parameters and return types that can be assigned to thethe supplied method parameters and return type.informally, method a is more specific than method b ifany invocation handled by method a can also be handled by method b.",
	"Method": "Method findMethod(Method bridgeMethod,Class<?> targetClass){\r\n    if (bridgeMethod == null || targetClass == null) {\r\n        return bridgeMethod;\r\n    }\r\n    if (!bridgeMethod.isBridge()) {\r\n        return bridgeMethod;\r\n    }\r\n    Method[] methods = bridgeMethod.getDeclaringClass().getDeclaredMethods();\r\n    for (Method method : methods) {\r\n        if (method.isBridge()) {\r\n            continue;\r\n        }\r\n        if (isAssignable(method, bridgeMethod)) {\r\n            return method;\r\n        }\r\n    }\r\n    return bridgeMethod;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VGridLayout.distributeColSpanWidths",
	"Comment": "iterates colspanned cells, ensures cols have enough space to accommodatethem",
	"Method": "void distributeColSpanWidths(){\r\n    for (SpanList list : colSpans) {\r\n        for (Cell cell : list.cells) {\r\n            int width = cell.hasRelativeWidth() ? 0 : cell.getWidth();\r\n            distributeSpanSize(columnWidths, cell.col, cell.colspan, getHorizontalSpacing(), width, colExpandRatioArray);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.debug.internal.OptimizedWidgetsetPanel.update",
	"Comment": "update the panel contents based on the connectors that have been used sofar on this execution of the application.",
	"Method": "void update(){\r\n    clear();\r\n    HTML h = new HTML(\"Getting used connectors\");\r\n    add(h);\r\n    String s = \"\";\r\n    for (ApplicationConnection ac : ApplicationConfiguration.getRunningApplications()) {\r\n        ApplicationConfiguration conf = ac.getConfiguration();\r\n        s += \"<h1>Used connectors for \" + Util.escapeHTML(conf.getServiceUrl()) + \"<\/h1>\";\r\n        for (String connectorName : getUsedConnectorNames(conf)) {\r\n            s += Util.escapeHTML(connectorName) + \"<br/>\";\r\n        }\r\n        s += \"<h2>To make an optimized widgetset based on these connectors:<\/h2>\";\r\n        s += \"<h3>1. Add the following <b>to the end<\/b> of your widgetset.gwt.xml file:<\/h3>\";\r\n        s += \"<textarea rows=\\\"3\\\" style=\\\"width:90%\\\">\";\r\n        s += \"<generate-with class=\\\"OptimizedConnectorBundleLoaderFactory\\\">\\n\";\r\n        s += \"      <when-type-assignable class=\\\"com.vaadin.client.metadata.ConnectorBundleLoader\\\" />\\n\";\r\n        s += \"<\/generate-with>\\n\";\r\n        s += \"<\/textarea>\";\r\n        s += \"<h3>2. Add the following code into OptimizedConnectorBundleLoaderFactory.java:<\/h3>\";\r\n        s += \"<textarea rows=\\\"5\\\" style=\\\"width:90%\\\">\";\r\n        s += generateOptimizedWidgetSet(getUsedConnectorNames(conf));\r\n        s += \"<\/textarea>\";\r\n        s += \"<h3>3. Recompile your widgetset. For example with Maven: 'mvn compile vaadin:compile'<\/h3>\";\r\n    }\r\n    h.setHTML(s);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheet.hasTabChangedVisibility",
	"Comment": "checks whether the tab is visible on server but is not visible on clientyet.",
	"Method": "boolean hasTabChangedVisibility(TabState tabState,Tab tab){\r\n    return !tab.isVisible() && tabState.visible;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.selectLastRenderedRowInViewPort",
	"Comment": "selects the last row visible in the tablefor internal use only. may be removed or replaced in the future.",
	"Method": "void selectLastRenderedRowInViewPort(boolean focusOnly){\r\n    int index = firstRowInViewPort + getFullyVisibleRowCount();\r\n    VScrollTableRow lastRowInViewport = scrollBody.getRowByRowIndex(index);\r\n    if (lastRowInViewport == null) {\r\n        lastRowInViewport = scrollBody.getRowByRowIndex(scrollBody.getLastRendered());\r\n        if (lastRowInViewport == null) {\r\n            return;\r\n        }\r\n    }\r\n    setRowFocus(lastRowInViewport);\r\n    if (!focusOnly) {\r\n        selectFocusedRow(false, multiselectPending);\r\n        sendSelectedRows();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.Embedded.addClickListener",
	"Comment": "add a click listener to the component. the listener is called wheneverthe user clicks inside the component. depending on the content the eventmay be blocked and in that case no event is fired.",
	"Method": "Registration addClickListener(ClickListener listener){\r\n    return addListener(EventId.CLICK_EVENT_IDENTIFIER, ClickEvent.class, listener, ClickListener.clickMethod);\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.doInit",
	"Comment": "internal initialization method, should not be overridden. this method isnot declared as final because that would break compatibility with e.g.cdi.",
	"Method": "void doInit(VaadinRequest request,int uiId,String embedId){\r\n    if (this.uiId != -1) {\r\n        String message = \"This UI instance is already initialized (as UI id \" + this.uiId + \") and can therefore not be initialized again (as UI id \" + uiId + \"). \";\r\n        if (getSession() != null && !getSession().equals(VaadinSession.getCurrent())) {\r\n            message += \"Furthermore, it is already attached to another VaadinSession. \";\r\n        }\r\n        message += \"Please make sure you are not accidentally reusing an old UI instance.\";\r\n        throw new IllegalStateException(message);\r\n    }\r\n    this.uiId = uiId;\r\n    this.embedId = embedId;\r\n    setTheme(request.getParameter(\"theme\"));\r\n    getPage().init(request);\r\n    String uiPathInfo = (String) request.getAttribute(ApplicationConstants.UI_ROOT_PATH);\r\n    if (uiPathInfo != null) {\r\n        setUiPathInfo(uiPathInfo);\r\n    }\r\n    if (getSession() != null && getSession().getConfiguration() != null && getSession().getConfiguration().isSendUrlsAsParameters() && getPage().getLocation() != null) {\r\n        String uiRootPath = getPage().getLocation().getPath();\r\n        if (uiPathInfo != null && uiRootPath.contains(uiPathInfo)) {\r\n            uiRootPath = uiRootPath.substring(0, uiRootPath.indexOf(uiPathInfo) + uiPathInfo.length());\r\n        } else if (request.getPathInfo() != null) {\r\n            String pathInfo = request.getPathInfo();\r\n            if (uiRootPath.endsWith(pathInfo)) {\r\n                uiRootPath = uiRootPath.substring(0, uiRootPath.length() - pathInfo.length());\r\n            }\r\n        }\r\n        setUiRootPath(uiRootPath);\r\n    }\r\n    init(request);\r\n    Navigator navigator = getNavigator();\r\n    if (navigator != null) {\r\n        navigator.navigateTo(navigator.getState());\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.focusDay",
	"Comment": "sets the focus to given date in the current view. used when moving in thecalendar with the keyboard.",
	"Method": "void focusDay(Date date){\r\n    if (resolution.getCalendarField() > Resolution.MONTH.getCalendarField()) {\r\n        if (focusedDay != null) {\r\n            focusedDay.removeStyleDependentName(CN_FOCUSED);\r\n        }\r\n        if (date != null && focusedDate != null) {\r\n            focusedDate.setTime(date.getTime());\r\n            int rowCount = days.getRowCount();\r\n            for (int i = 0; i < rowCount; i++) {\r\n                int cellCount = days.getCellCount(i);\r\n                for (int j = 0; j < cellCount; j++) {\r\n                    Widget widget = days.getWidget(i, j);\r\n                    if (widget != null && widget instanceof Day) {\r\n                        Day curday = (Day) widget;\r\n                        if (curday.getDate().equals(date)) {\r\n                            curday.addStyleDependentName(CN_FOCUSED);\r\n                            focusedDay = curday;\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VPopupView.isWorkPending",
	"Comment": "checks whether there are operations pending for this widget that must beexecuted before reaching a steady state.",
	"Method": "boolean isWorkPending(){\r\n    return popupShowInProgress;\r\n}"
}, {
	"Path": "com.vaadin.util.ReflectTools.setJavaFieldValue",
	"Comment": "sets the value of a java field.uses setter if present, otherwise tries to access even private fieldsdirectly.",
	"Method": "void setJavaFieldValue(Object object,Field field,Object value){\r\n    PropertyDescriptor pd;\r\n    try {\r\n        pd = new PropertyDescriptor(field.getName(), object.getClass());\r\n        Method setter = pd.getWriteMethod();\r\n        if (setter != null) {\r\n            setter.invoke(object, value);\r\n        }\r\n    } catch (IntrospectionException e1) {\r\n    }\r\n    if (!field.isAccessible()) {\r\n        field.setAccessible(true);\r\n    }\r\n    field.set(object, value);\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.removeFromHttpSession",
	"Comment": "performs the actual removal of the vaadinsession from the underlying httpsession after sanity checks have been performed.",
	"Method": "void removeFromHttpSession(WrappedSession wrappedSession){\r\n    wrappedSession.removeAttribute(getSessionAttributeName());\r\n}"
}, {
	"Path": "com.vaadin.data.provider.InMemoryDataProviderHelpers.filteringByCaseInsensitiveString",
	"Comment": "wraps a given data provider so that its filter tests the given predicatewith the lower case string provided by the given value provider.",
	"Method": "DataProvider<T, String> filteringByCaseInsensitiveString(InMemoryDataProvider<T> dataProvider,ValueProvider<T, String> valueProvider,SerializableBiPredicate<String, String> predicate,SerializableSupplier<Locale> localeSupplier){\r\n    assert predicate != null;\r\n    assert localeSupplier != null;\r\n    return filteringByIgnoreNull(dataProvider, valueProvider, (itemString, filterString) -> {\r\n        Locale locale = localeSupplier.get();\r\n        assert locale != null;\r\n        return predicate.test(itemString.toLowerCase(locale), filterString.toLowerCase(locale));\r\n    });\r\n}"
}, {
	"Path": "com.vaadin.client.ui.orderedlayout.Slot.detachListeners",
	"Comment": "detaches resize listeners from the widget, caption and spacing elements",
	"Method": "void detachListeners(){\r\n    if (getWidget() != null && layout.getLayoutManager() != null) {\r\n        LayoutManager lm = layout.getLayoutManager();\r\n        if (getCaptionElement() != null && captionResizeListener != null) {\r\n            lm.removeElementResizeListener(getCaptionElement(), captionResizeListener);\r\n        }\r\n        if (widgetResizeListener != null) {\r\n            lm.removeElementResizeListener(getWidget().getElement(), widgetResizeListener);\r\n        }\r\n        if (getSpacingElement() != null && spacingResizeListener != null) {\r\n            lm.removeElementResizeListener(getSpacingElement(), spacingResizeListener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.tests.design.LocaleTest.testHtmlGeneration",
	"Comment": "checks that when the html corresponding to a component hierarchy isconstructed, the result only contains locale attributes for a componentif its locale differs from that of its parent.",
	"Method": "void testHtmlGeneration(){\r\n    VerticalLayout vLayout = new VerticalLayout();\r\n    vLayout.setLocale(Locale.US);\r\n    HorizontalLayout hLayout = new HorizontalLayout();\r\n    hLayout.setLocale(Locale.ITALY);\r\n    vLayout.addComponent(hLayout);\r\n    Button b1 = new Button();\r\n    b1.setLocale(Locale.ITALY);\r\n    Button b2 = new Button();\r\n    b2.setLocale(Locale.US);\r\n    hLayout.addComponent(b1);\r\n    hLayout.addComponent(b2);\r\n    HorizontalLayout hlayout2 = new HorizontalLayout();\r\n    hlayout2.setLocale(Locale.US);\r\n    vLayout.addComponent(hlayout2);\r\n    Label l = new Label();\r\n    l.setLocale(Locale.US);\r\n    hlayout2.addComponent(l);\r\n    Label l2 = new Label();\r\n    l2.setLocale(Locale.CANADA);\r\n    hlayout2.addComponent(l2);\r\n    ctx.setRootComponent(vLayout);\r\n    Document doc = componentToDoc(ctx);\r\n    Element body = doc.body();\r\n    Element evLayout = body.child(0);\r\n    assertEquals(\"Wrong locale information.\", \"en_US\", evLayout.attr(\"locale\"));\r\n    Element ehLayout = evLayout.child(0);\r\n    assertEquals(\"Wrong locale information.\", \"it_IT\", ehLayout.attr(\"locale\"));\r\n    Element eb1 = ehLayout.child(0);\r\n    assertTrue(\"The element should not have a locale specification, found locale \" + eb1.attr(\"locale\"), eb1.attr(\"locale\").isEmpty());\r\n    Element eb2 = ehLayout.child(1);\r\n    assertEquals(\"Wrong locale information.\", \"en_US\", eb2.attr(\"locale\"));\r\n    Element ehLayout2 = evLayout.child(1);\r\n    assertTrue(\"The element should not have a locale specification, found locale \" + ehLayout2.attr(\"locale\"), ehLayout2.attr(\"locale\").isEmpty());\r\n    Element el1 = ehLayout2.child(0);\r\n    assertTrue(\"The element should not have a locale specification, found locale \" + el1.attr(\"locale\"), el1.attr(\"locale\").isEmpty());\r\n    Element el2 = ehLayout2.child(1);\r\n    assertEquals(\"Wrong locale information.\", \"en_CA\", el2.attr(\"locale\"));\r\n}"
}, {
	"Path": "com.vaadin.util.ReflectTools.getJavaFieldValue",
	"Comment": "returns the value of the java field that is assignable to the propertytype.uses getter if a getter for the correct return type is present, otherwisetries to access even private fields directly. if the java field is notassignable to the property type throws an illegalargumentexception.",
	"Method": "Object getJavaFieldValue(Object object,Field field,Object getJavaFieldValue,Object object,Field field,Class<?> propertyType){\r\n    PropertyDescriptor pd;\r\n    try {\r\n        pd = new PropertyDescriptor(field.getName(), object.getClass());\r\n        if (propertyType.isAssignableFrom(pd.getPropertyType())) {\r\n            Method getter = pd.getReadMethod();\r\n            if (getter != null) {\r\n                return getter.invoke(object, (Object[]) null);\r\n            }\r\n        }\r\n    } catch (IntrospectionException e1) {\r\n    }\r\n    if (!propertyType.isAssignableFrom(field.getType())) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (!field.isAccessible()) {\r\n        field.setAccessible(true);\r\n    }\r\n    return field.get(object);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Label.setConverter",
	"Comment": "sets the converter used to convert the label value to the property datasource type. the converter must have a presentation type of string.",
	"Method": "void setConverter(Converter<String, ?> converter){\r\n    this.converter = (Converter<String, Object>) converter;\r\n    markAsDirty();\r\n}"
}, {
	"Path": "edu.uci.ics.crawler4j.url.UrlResolver.resolveUrl",
	"Comment": "resolves a given relative url against a base url. seerfc1808section 4 for more details.",
	"Method": "String resolveUrl(String baseUrl,String relativeUrl,Url resolveUrl,Url baseUrl,String relativeUrl){\r\n    final Url url = parseUrl(relativeUrl);\r\n    if (baseUrl == null) {\r\n        return url;\r\n    }\r\n    if (relativeUrl.length() == 0) {\r\n        return new Url(baseUrl);\r\n    }\r\n    if (url.scheme_ != null) {\r\n        return url;\r\n    }\r\n    url.scheme_ = baseUrl.scheme_;\r\n    if (url.location_ != null) {\r\n        return url;\r\n    }\r\n    url.location_ = baseUrl.location_;\r\n    if ((url.path_ != null) && ((url.path_.length() > 0) && ('/' == url.path_.charAt(0)))) {\r\n        url.path_ = removeLeadingSlashPoints(url.path_);\r\n        return url;\r\n    }\r\n    if (url.path_ == null) {\r\n        url.path_ = baseUrl.path_;\r\n        if (url.parameters_ != null) {\r\n            return url;\r\n        }\r\n        url.parameters_ = baseUrl.parameters_;\r\n        if (url.query_ != null) {\r\n            return url;\r\n        }\r\n        url.query_ = baseUrl.query_;\r\n        return url;\r\n    }\r\n    final String basePath = baseUrl.path_;\r\n    String path = \"\";\r\n    if (basePath != null) {\r\n        final int lastSlashIndex = basePath.lastIndexOf('/');\r\n        if (lastSlashIndex >= 0) {\r\n            path = basePath.substring(0, lastSlashIndex + 1);\r\n        }\r\n    } else {\r\n        path = \"/\";\r\n    }\r\n    path = path.concat(url.path_);\r\n    int pathSegmentIndex;\r\n    while ((pathSegmentIndex = path.indexOf(\"/./\")) >= 0) {\r\n        path = path.substring(0, pathSegmentIndex + 1).concat(path.substring(pathSegmentIndex + 3));\r\n    }\r\n    if (path.endsWith(\"/.\")) {\r\n        path = path.substring(0, path.length() - 1);\r\n    }\r\n    while ((pathSegmentIndex = path.indexOf(\"/../\")) > 0) {\r\n        final String pathSegment = path.substring(0, pathSegmentIndex);\r\n        final int slashIndex = pathSegment.lastIndexOf('/');\r\n        if (slashIndex < 0) {\r\n            continue;\r\n        }\r\n        if (!\"..\".equals(pathSegment.substring(slashIndex))) {\r\n            path = path.substring(0, slashIndex + 1).concat(path.substring(pathSegmentIndex + 4));\r\n        }\r\n    }\r\n    if (path.endsWith(\"/..\")) {\r\n        final String pathSegment = path.substring(0, path.length() - 3);\r\n        final int slashIndex = pathSegment.lastIndexOf('/');\r\n        if (slashIndex >= 0) {\r\n            path = path.substring(0, slashIndex + 1);\r\n        }\r\n    }\r\n    path = removeLeadingSlashPoints(path);\r\n    url.path_ = path;\r\n    return url;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.initCalendarWithLocale",
	"Comment": "initialize the java calendar instance with the current locale andtimezone.",
	"Method": "void initCalendarWithLocale(){\r\n    if (timezone != null) {\r\n        currentCalendar = java.util.Calendar.getInstance(timezone, getLocale());\r\n    } else {\r\n        currentCalendar = java.util.Calendar.getInstance(getLocale());\r\n    }\r\n    if (customFirstDayOfWeek != null) {\r\n        currentCalendar.setFirstDayOfWeek(customFirstDayOfWeek);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VDragAndDropWrapper.initDragStartMode",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void initDragStartMode(){\r\n    Element div = getElement();\r\n    if (dragStartMode == HTML5) {\r\n        if (dragStartElement == null) {\r\n            dragStartElement = getDragStartElement();\r\n            dragStartElement.setPropertyBoolean(DRAGGABLE, true);\r\n            getLogger().info(\"draggable = \" + dragStartElement.getPropertyBoolean(DRAGGABLE));\r\n            hookHtml5DragStart(dragStartElement);\r\n            getLogger().info(\"drag start listeners hooked.\");\r\n        }\r\n    } else {\r\n        dragStartElement = null;\r\n        if (div.hasAttribute(DRAGGABLE)) {\r\n            div.removeAttribute(DRAGGABLE);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.TabSheet.setTabsVisible",
	"Comment": "sets whether the tab selection part should be shown in the ui.",
	"Method": "void setTabsVisible(boolean tabsVisible){\r\n    getState().tabsVisible = tabsVisible;\r\n}"
}, {
	"Path": "com.vaadin.ui.Slider.setMin",
	"Comment": "sets the minimum slider value. if the current value of the slider issmaller than this, the value is set to the new minimum.",
	"Method": "void setMin(double min){\r\n    double roundedMin = getRoundedValue(min);\r\n    getState().minValue = roundedMin;\r\n    if (getMax() < roundedMin) {\r\n        getState().maxValue = roundedMin;\r\n    }\r\n    if (getValue() < roundedMin) {\r\n        setValue(roundedMin);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.GridLayout.newLine",
	"Comment": "forces the next component to be added at the beginning of the next line.sets the cursor column to 0 and increments the cursor row by one.by calling this function you can ensure that no more components are addedright of the previous component.",
	"Method": "void newLine(){\r\n    cursorX = 0;\r\n    cursorY++;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractInMemoryContainer.getFilters",
	"Comment": "returns the internal collection of filters. the returned collectionshould not be modified by callers outside this class.",
	"Method": "Set<Filter> getFilters(){\r\n    return filters;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.select",
	"Comment": "keep this javadoc in sync with selectionmodel.single.select",
	"Method": "boolean select(Object itemIds,boolean select,Collection<?> itemIds,boolean select,Object itemId,boolean select,Object itemId,boolean select,Object itemId,boolean refresh,boolean select,Object itemIds,boolean select,Collection<?> itemIds,boolean select,Collection<?> itemIds,boolean refresh,boolean select,Object itemId){\r\n    if (selectionModel instanceof SelectionModel.Single) {\r\n        return ((SelectionModel.Single) selectionModel).select(itemId);\r\n    } else if (selectionModel instanceof SelectionModel.Multi) {\r\n        return ((SelectionModel.Multi) selectionModel).select(itemId);\r\n    } else if (selectionModel instanceof SelectionModel.None) {\r\n        throw new IllegalStateException(\"Cannot select row '\" + itemId + \"': Grid selection is disabled \" + \"(the current selection model is \" + selectionModel.getClass().getName() + \").\");\r\n    } else {\r\n        throw new IllegalStateException(\"Cannot select row '\" + itemId + \"': Grid selection model does not implement \" + SelectionModel.Single.class.getName() + \" or \" + SelectionModel.Multi.class.getName() + \"(the current model is \" + selectionModel.getClass().getName() + \").\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.extensions.FileDropTargetConnector.uploadNextFile",
	"Comment": "uploads a file from the waiting list in case there are no files beinguploaded.",
	"Method": "void uploadNextFile(){\r\n    Scheduler.get().scheduleDeferred(() -> {\r\n        if (!uploading && !uploadUrls.isEmpty()) {\r\n            uploading = true;\r\n            String nextId = uploadUrls.keySet().stream().findAny().get();\r\n            String url = uploadUrls.remove(nextId);\r\n            File file = filesToUpload.remove(nextId);\r\n            FileUploadXHR xhr = (FileUploadXHR) FileUploadXHR.create();\r\n            xhr.setOnReadyStateChange(xmlHttpRequest -> {\r\n                if (xmlHttpRequest.getReadyState() == XMLHttpRequest.DONE) {\r\n                    getRpcProxy(FileDropTargetRpc.class).poll();\r\n                    uploading = false;\r\n                    uploadNextFile();\r\n                    xmlHttpRequest.clearOnReadyStateChange();\r\n                }\r\n            });\r\n            xhr.open(\"POST\", getConnection().translateVaadinUri(url));\r\n            xhr.postFile(file);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.focusDay",
	"Comment": "sets the focus to given date in the current view. used when moving in thecalendar with the keyboard.",
	"Method": "void focusDay(Date date){\r\n    if (acceptDayFocus()) {\r\n        if (focusedDay != null) {\r\n            focusedDay.removeStyleDependentName(CN_FOCUSED);\r\n        }\r\n        if (date != null && focusedDate != null) {\r\n            focusedDate.setTime(date.getTime());\r\n            int rowCount = days.getRowCount();\r\n            for (int i = 0; i < rowCount; i++) {\r\n                int cellCount = days.getCellCount(i);\r\n                for (int j = 0; j < cellCount; j++) {\r\n                    Widget widget = days.getWidget(i, j);\r\n                    if (widget instanceof VAbstractCalendarPanel.Day) {\r\n                        Day curday = (Day) widget;\r\n                        if (curday.getDate().equals(date)) {\r\n                            curday.addStyleDependentName(CN_FOCUSED);\r\n                            focusedDay = curday;\r\n                            Roles.getGridRole().setAriaActivedescendantProperty(getElement(), Id.of(curday.getElement()));\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VCustomLayout.add",
	"Comment": "adding widget without specifying location is not supported.",
	"Method": "void add(Widget w){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinResponse.getCurrent",
	"Comment": "gets the currently processed vaadin response. the current response isautomatically defined when the request is started. the current responsecan not be used in e.g. background threads because of the way serverimplementations reuse response instances.",
	"Method": "VaadinResponse getCurrent(){\r\n    return CurrentInstance.get(VaadinResponse.class);\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.EditorImpl.doEdit",
	"Comment": "handles editor component generation and adding them to the hierarchy ofthe grid.",
	"Method": "void doEdit(T bean){\r\n    Objects.requireNonNull(bean, \"Editor can't edit null\");\r\n    if (!isEnabled()) {\r\n        throw new IllegalStateException(\"Editing is not allowed when Editor is disabled.\");\r\n    }\r\n    if (!isBuffered()) {\r\n        binder.setBean(bean);\r\n    } else {\r\n        binder.readBean(bean);\r\n    }\r\n    edited = bean;\r\n    getParent().getColumns().stream().filter(Column::isEditable).forEach(c -> {\r\n        Binding<T, ?> binding = c.getEditorBinding();\r\n        assert binding.getField() instanceof Component : \"Grid should enforce that the binding field is a component\";\r\n        Component component = (Component) binding.getField();\r\n        addComponentToGrid(component);\r\n        columnFields.put(c, component);\r\n        getState().columnFields.put(getInternalIdForColumn(c), component.getConnectorId());\r\n    });\r\n    eventRouter.fireEvent(new EditorOpenEvent<T>(this, edited));\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.updateHeight",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void updateHeight(){\r\n    setContainerHeight();\r\n    if (initializedAndAttached) {\r\n        updatePageLength();\r\n    }\r\n    triggerLazyColumnAdjustment(false);\r\n    setProperTabIndex();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.PropertysetItem.removePropertySetChangeListener",
	"Comment": "removes a previously registered property set change listener.",
	"Method": "void removePropertySetChangeListener(Item.PropertySetChangeListener listener){\r\n    if (propertySetChangeListeners != null) {\r\n        propertySetChangeListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractSplitPanel.setSecondComponent",
	"Comment": "sets the second component of this split panel. depending on the directionthe second component is shown at the bottom or to the right.",
	"Method": "void setSecondComponent(Component c){\r\n    if (getSecondComponent() == c) {\r\n        return;\r\n    }\r\n    if (getSecondComponent() != null) {\r\n        removeComponent(getSecondComponent());\r\n    }\r\n    getState().secondChild = c;\r\n    if (c != null) {\r\n        super.addComponent(c);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignContext.getRootComponent",
	"Comment": "returns the root component of a created component hierarchy.",
	"Method": "Component getRootComponent(){\r\n    return rootComponent;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VUpload.disableUpload",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void disableUpload(){\r\n    setEnabledForSubmitButton(false);\r\n    if (!submitted) {\r\n        fu.getElement().setPropertyBoolean(\"disabled\", true);\r\n    }\r\n    enabled = false;\r\n}"
}, {
	"Path": "com.vaadin.client.LayoutManager.removeElementResizeListener",
	"Comment": "removes an element resize listener from the provided element. this mightcause this layoutmanager to stop tracking the size of the element if noother sources are interested in the size.",
	"Method": "void removeElementResizeListener(Element element,ElementResizeListener listener){\r\n    Collection<ElementResizeListener> listeners = elementResizeListeners.get(element);\r\n    if (listeners != null) {\r\n        listeners.remove(listener);\r\n        if (listeners.isEmpty()) {\r\n            elementResizeListeners.remove(element);\r\n            stopMeasuringIfUnecessary(element);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractBeanContainer.addContainerProperty",
	"Comment": "adds a property for the container and all its items.primarily for internal use, may change in future versions.",
	"Method": "boolean addContainerProperty(Object propertyId,Class<?> type,Object defaultValue,boolean addContainerProperty,String propertyId,VaadinPropertyDescriptor<BEANTYPE> propertyDescriptor){\r\n    if (null == propertyId || null == propertyDescriptor) {\r\n        return false;\r\n    }\r\n    if (model.containsKey(propertyId)) {\r\n        return false;\r\n    }\r\n    model.put(propertyId, propertyDescriptor);\r\n    for (BeanItem<BEANTYPE> item : itemIdToItem.values()) {\r\n        item.addItemProperty(propertyId, propertyDescriptor.createProperty(item.getBean()));\r\n    }\r\n    fireContainerPropertySetChange();\r\n    return true;\r\n}"
}, {
	"Path": "org.greenrobot.essentials.StringUtils.join",
	"Comment": "joins the given strings using the given separator into a single string.",
	"Method": "String join(Iterable<?> iterable,String separator,String join,int[] array,String separator,String join,String[] array,String separator){\r\n    if (array != null) {\r\n        StringBuilder buf = new StringBuilder(Math.max(16, (separator.length() + 1) * array.length));\r\n        char singleChar = separator.length() == 1 ? separator.charAt(0) : 0;\r\n        for (int i = 0; i < array.length; i++) {\r\n            if (i != 0) {\r\n                if (singleChar != 0) {\r\n                    buf.append(singleChar);\r\n                } else {\r\n                    buf.append(separator);\r\n                }\r\n            }\r\n            buf.append(array[i]);\r\n        }\r\n        return buf.toString();\r\n    } else {\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinServlet.serveStaticResources",
	"Comment": "check if this is a request for a static resource and, if it is, serve theresource to the client.",
	"Method": "boolean serveStaticResources(HttpServletRequest request,HttpServletResponse response){\r\n    String filePath = getStaticFilePath(request);\r\n    if (filePath != null) {\r\n        serveStaticResourcesInVAADIN(filePath, request, response);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VCustomLayout.hasTemplate",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "boolean hasTemplate(){\r\n    return htmlInitialized;\r\n}"
}, {
	"Path": "bt.torrent.fileselector.TorrentFileSelector.selectFiles",
	"Comment": "returns a list of decisions on whether to download or skip each of the given files, in the same order.",
	"Method": "List<SelectionResult> selectFiles(List<TorrentFile> files){\r\n    return files.stream().map(this::select).collect(Collectors.toList());\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.writeObject",
	"Comment": "override default serialization logic to avoidconcurrentmodificationexception if the contents are modified whileserialization is reading them.",
	"Method": "void writeObject(ObjectOutputStream out){\r\n    Lock lock = this.lock;\r\n    if (lock != null) {\r\n        lock.lock();\r\n    }\r\n    try {\r\n        out.defaultWriteObject();\r\n    } finally {\r\n        if (lock != null) {\r\n            lock.unlock();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.data.validator.RangeValidator.setMaxValueIncluded",
	"Comment": "sets whether the maximum value is part of the accepted range.",
	"Method": "void setMaxValueIncluded(boolean maxValueIncluded){\r\n    this.maxValueIncluded = maxValueIncluded;\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignContext.setShouldWriteDataDelegate",
	"Comment": "sets the delegate that determines whether the container data of acomponent should be written out.",
	"Method": "void setShouldWriteDataDelegate(ShouldWriteDataDelegate shouldWriteDataDelegate){\r\n    if (shouldWriteDataDelegate == null) {\r\n        throw new IllegalArgumentException(\"Delegate cannot be null\");\r\n    }\r\n    this.shouldWriteDataDelegate = shouldWriteDataDelegate;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinPortletService.getPortlet",
	"Comment": "retrieves a reference to the portlet associated with this service.",
	"Method": "VaadinPortlet getPortlet(){\r\n    return portlet;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTwinColSelect.setInternalWidths",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setInternalWidths(){\r\n    getElement().getStyle().setPosition(Position.RELATIVE);\r\n    int bordersAndPaddings = WidgetUtil.measureHorizontalPaddingAndBorder(buttons.getElement(), 0);\r\n    int buttonWidth = WidgetUtil.getRequiredWidth(buttons);\r\n    int totalWidth = getOffsetWidth();\r\n    int spaceForSelect = (totalWidth - buttonWidth - bordersAndPaddings) / 2;\r\n    options.setWidth(spaceForSelect + \"px\");\r\n    if (optionsCaption != null) {\r\n        optionsCaption.setWidth(spaceForSelect + \"px\");\r\n    }\r\n    selections.setWidth(spaceForSelect + \"px\");\r\n    if (selectionsCaption != null) {\r\n        selectionsCaption.setWidth(spaceForSelect + \"px\");\r\n    }\r\n    captionWrapper.setWidth(\"100%\");\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VMenuBar.buildItemHTML",
	"Comment": "build the html content for a menu item.for internal use only. may be removed or replaced in the future.",
	"Method": "String buildItemHTML(UIDL item,String buildItemHTML,boolean separator,boolean subMenu,String iconUrl,String text){\r\n    StringBuilder itemHTML = new StringBuilder();\r\n    if (separator) {\r\n        itemHTML.append(\"<span>---<\/span>\");\r\n    } else {\r\n        if (subMenu) {\r\n            String bgStyle = \"\";\r\n            itemHTML.append(\"<span class=\\\"\" + getStylePrimaryName() + \"-submenu-indicator\\\"\" + bgStyle + \" aria-hidden=\\\"true\\\">&#x25BA;<\/span>\");\r\n        }\r\n        itemHTML.append(\"<span class=\\\"\" + getStylePrimaryName() + \"-menuitem-caption\\\">\");\r\n        Icon icon = client.getIcon(iconUrl);\r\n        if (icon != null) {\r\n            itemHTML.append(icon.getElement().getString());\r\n        }\r\n        String itemText = text;\r\n        if (!htmlContentAllowed) {\r\n            itemText = WidgetUtil.escapeHTML(itemText);\r\n        }\r\n        itemHTML.append(itemText);\r\n        itemHTML.append(\"<\/span>\");\r\n    }\r\n    return itemHTML.toString();\r\n}"
}, {
	"Path": "lbms.plugins.mldht.kad.Node.fillBuckets",
	"Comment": "check if a buckets needs to be refreshed, and refresh if necesarry",
	"Method": "void fillBuckets(){\r\n    RoutingTable table = routingTableCOW;\r\n    for (int i = 0; i < table.size(); i++) {\r\n        RoutingTableEntry entry = table.get(i);\r\n        int num = entry.bucket.getNumEntries();\r\n        if (num > 0 && num < DHTConstants.MAX_ENTRIES_PER_BUCKET) {\r\n            dht.fillBucket(entry.prefix.createRandomKeyFromPrefix(), entry.bucket, t -> {\r\n                t.setInfo(\"Filling Bucket #\" + entry.prefix);\r\n            });\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VPopupCalendar.setRangeEnd",
	"Comment": "sets the end range for this component. the end range is inclusive, and itdepends on the current resolution, what is considered inside the range.",
	"Method": "void setRangeEnd(Date rangeEnd){\r\n    calendar.setRangeEnd(rangeEnd);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.orderedlayout.VAbstractOrderedLayout.clearExpand",
	"Comment": "removes elements used to expand a slot.for internal use only. may be removed or replaced in the future.",
	"Method": "void clearExpand(){\r\n    if (expandWrapper != null) {\r\n        for (Widget widget : getChildren()) {\r\n            orphan(widget);\r\n        }\r\n        lastExpandSize = -1;\r\n        while (expandWrapper.getChildCount() > 0) {\r\n            Element el = expandWrapper.getChild(0).cast();\r\n            getElement().appendChild(el);\r\n            if (vertical) {\r\n                el.getStyle().clearHeight();\r\n                el.getStyle().clearMarginTop();\r\n            } else {\r\n                el.getStyle().clearWidth();\r\n                el.getStyle().clearMarginLeft();\r\n            }\r\n        }\r\n        expandWrapper.removeFromParent();\r\n        expandWrapper = null;\r\n        for (Widget widget : getChildren()) {\r\n            adopt(widget);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.GridLayout.setColumns",
	"Comment": "sets the number of columns in the grid. the column count can not bereduced if there are any areas that would be outside of the shrunk grid.",
	"Method": "void setColumns(int columns){\r\n    if (columns < 1) {\r\n        throw new IllegalArgumentException(\"The number of columns and rows in the grid must be at least 1\");\r\n    }\r\n    if (getColumns() == columns) {\r\n        return;\r\n    }\r\n    if (getColumns() > columns) {\r\n        for (Entry<Connector, ChildComponentData> entry : getState().childData.entrySet()) {\r\n            if (entry.getValue().column2 >= columns) {\r\n                throw new OutOfBoundsException(new Area(entry.getValue(), (Component) entry.getKey()));\r\n            }\r\n        }\r\n    }\r\n    if (columns < getColumns()) {\r\n        for (int i = columns; i < getColumns(); i++) {\r\n            columnExpandRatio.remove(i);\r\n            getState().explicitColRatios.remove(i);\r\n        }\r\n    }\r\n    getState().columns = columns;\r\n}"
}, {
	"Path": "lbms.plugins.mldht.kad.Key.distance",
	"Comment": "calculates the distance between two keys.\tthe distance is basically a xor of both key hashes.",
	"Method": "Key distance(Key x,Key distance,Key a,Key b){\r\n    Key x = new Key();\r\n    for (int i = 0; i < a.hash.length; i++) {\r\n        x.hash[i] = (byte) (a.hash[i] ^ b.hash[i]);\r\n    }\r\n    return x;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.ui.UIConnector.showServerDesign",
	"Comment": "sends a request to the server to print a design to the console for thegiven component.",
	"Method": "void showServerDesign(ServerConnector connector){\r\n    getRpcProxy(DebugWindowServerRpc.class).showServerDesign(connector);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.renderers.ClickableRenderer.addClickListener",
	"Comment": "adds a click listener to this button renderer. the listener is invokedevery time one of the buttons rendered by this renderer is clicked.",
	"Method": "void addClickListener(RendererClickListener listener){\r\n    addListener(RendererClickEvent.class, listener, RendererClickListener.CLICK_METHOD);\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.getTabStopBottomAssistiveText",
	"Comment": "gets the message that is provided to users of assistive devices when theuser reaches the bottom of the window when leaving a window with the tabkey is prevented.",
	"Method": "String getTabStopBottomAssistiveText(){\r\n    return getState(false).assistiveTabStopBottomText;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.schedule.CalendarEvent.getRangeInMinutes",
	"Comment": "get the amount of minutes between the start and end of the event.",
	"Method": "long getRangeInMinutes(){\r\n    return (getRangeInMilliseconds() / DateConstants.MINUTEINMILLIS);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.isPartialRowUpdate",
	"Comment": "subclass and override this to enable partial row updates and additions,which bypass the normal caching mechanism. this is useful for e.g.treetable.",
	"Method": "boolean isPartialRowUpdate(){\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.getTabStopTopAssistiveText",
	"Comment": "gets the message that is provided to users of assistive devices when theuser reaches the top of the window when leaving a window with the tab keyis prevented.",
	"Method": "String getTabStopTopAssistiveText(){\r\n    return Roles.getNoteRole().getAriaLabelProperty(topTabStop);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.setRangeEnd",
	"Comment": "sets the end range for this component. the end range is inclusive, and itdepends on the current resolution, what is considered inside the range.",
	"Method": "void setRangeEnd(Date newRangeEnd){\r\n    if (!SharedUtil.equals(rangeEnd, newRangeEnd)) {\r\n        rangeEnd = newRangeEnd;\r\n        if (initialRenderDone) {\r\n            renderCalendar();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.TreeTable.setHierarchyColumn",
	"Comment": "explicitly sets the column in which the treetable visualizes thehierarchy. if hierarchycolumnid is not set, the hierarchy is visualizedin the first visible column.",
	"Method": "void setHierarchyColumn(Object hierarchyColumnId){\r\n    this.hierarchyColumnId = hierarchyColumnId;\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.sort.Sort.then",
	"Comment": "continue building a sort order. the provided column is sorted inspecified order if the previously added columns have been evaluated asequals.",
	"Method": "Sort then(Grid.Column<?, ?> column,Sort then,Grid.Column<?, ?> column,SortDirection direction){\r\n    return new Sort(this, column, direction);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VUI.triggerSizeChangeCheck",
	"Comment": "called when a resize event is received.this may trigger a lazy refresh or perform the size check immediatelydepending on the browser used and whether the server side requestsresizes to be lazy.",
	"Method": "void triggerSizeChangeCheck(){\r\n    boolean lazy = resizeLazy;\r\n    if (lazy) {\r\n        delayedResizeExecutor.trigger();\r\n    } else {\r\n        performSizeCheck();\r\n    }\r\n}"
}, {
	"Path": "bt.torrent.selector.RarestFirstSelector.orderedQueue",
	"Comment": "esp. when there are many connects and disconnects, and statistics are slightly adjusted for each added or removed bitfield.",
	"Method": "List<Long> orderedQueue(PieceStatistics pieceStatistics){\r\n    PriorityQueue<Long> rarestFirst = new PriorityQueue(comparator);\r\n    int piecesTotal = pieceStatistics.getPiecesTotal();\r\n    for (int pieceIndex = 0; pieceIndex < piecesTotal; pieceIndex++) {\r\n        int count = pieceStatistics.getCount(pieceIndex);\r\n        if (count > 0) {\r\n            long zipped = zip(pieceIndex, count);\r\n            rarestFirst.add(zipped);\r\n        }\r\n    }\r\n    List<Long> result = new ArrayList(rarestFirst.size());\r\n    Long l;\r\n    while ((l = rarestFirst.poll()) != null) {\r\n        result.add(l);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractField.readOnlyStatusChange",
	"Comment": "react to read only status changes of the property by requesting arepaint.",
	"Method": "void readOnlyStatusChange(Property.ReadOnlyStatusChangeEvent event){\r\n    boolean readOnly = event.getProperty().isReadOnly();\r\n    boolean shouldFireChange = isReadOnly() != readOnly || getState().propertyReadOnly != readOnly;\r\n    getState().propertyReadOnly = readOnly;\r\n    if (shouldFireChange) {\r\n        fireReadOnlyStatusChange();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VMenuBar.getNavigationRightKey",
	"Comment": "get the key that moves the selection right. by default it is the rightarrow key but by overriding this you can change the key to whatever youwant.",
	"Method": "int getNavigationRightKey(){\r\n    return KeyCodes.KEY_RIGHT;\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.setOverlayContainerLabel",
	"Comment": "sets the label that is added to the container element, where tooltip,notifications and dialogs are added to.this is helpful for users of assistive devices, as this element isreachable for them.",
	"Method": "void setOverlayContainerLabel(String overlayContainerLabel){\r\n    getState().overlayContainerLabel = overlayContainerLabel;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VCustomLayout.setWidget",
	"Comment": "sets widget to given location.if location already contains a widget it will be removed.",
	"Method": "void setWidget(Widget widget,String location){\r\n    if (widget == null) {\r\n        return;\r\n    }\r\n    Element elem = locationToElement.get(location);\r\n    if (elem == null && hasTemplate()) {\r\n        throw new IllegalArgumentException(\"No location \" + location + \" found\");\r\n    }\r\n    final Widget previous = locationToWidget.get(location);\r\n    if (previous == widget) {\r\n        return;\r\n    }\r\n    if (previous != null) {\r\n        remove(previous);\r\n    }\r\n    if (!hasTemplate()) {\r\n        elem = getElement();\r\n    }\r\n    super.add(widget, elem);\r\n    locationToWidget.put(location, widget);\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridSingleSelect.getSelectedItems",
	"Comment": "returns a singleton set of the currently selected item or an empty set ifno item is selected.",
	"Method": "Set<T> getSelectedItems(){\r\n    return model.getSelectedItems();\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.hasCloseShortcut",
	"Comment": "checks if a close window shortcut key has already been registered.",
	"Method": "boolean hasCloseShortcut(int keyCode,int modifiers){\r\n    for (CloseShortcut shortcut : closeShortcuts) {\r\n        if (shortcut.equals(keyCode, modifiers)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.getNavigationRightKey",
	"Comment": "get the key that scroll to the right on the table. by default it is theright arrow key but by overriding this you can change the key to whateveryou want.",
	"Method": "int getNavigationRightKey(){\r\n    return KeyCodes.KEY_RIGHT;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.AbstractConnector.getRpcProxy",
	"Comment": "returns an rpc proxy object which can be used to invoke the rpc method onthe server.",
	"Method": "T getRpcProxy(Class<T> rpcInterface){\r\n    String name = rpcInterface.getName();\r\n    if (!rpcProxyMap.containsKey(name)) {\r\n        rpcProxyMap.put(name, RpcProxy.create(rpcInterface, this));\r\n    }\r\n    return (T) rpcProxyMap.get(name);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.fireDateClick",
	"Comment": "fires event when a date was clicked in the calendar. creates a new eventfor the date and passes it to the listener.",
	"Method": "void fireDateClick(Date date){\r\n    fireEvent(new DateClickEvent(this, date));\r\n}"
}, {
	"Path": "com.vaadin.data.provider.InMemoryDataProviderHelpers.createValueProviderFilter",
	"Comment": "creates a new predicate from the given predicate and value provider. thisallows using a predicate of the value providers return type with objectsof the value providers type.",
	"Method": "SerializablePredicate<T> createValueProviderFilter(ValueProvider<T, V> valueProvider,SerializablePredicate<V> valueFilter){\r\n    return item -> valueFilter.test(valueProvider.apply(item));\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.initializeRows",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void initializeRows(UIDL uidl,UIDL rowData){\r\n    if (scrollBody != null) {\r\n        scrollBody.removeFromParent();\r\n    }\r\n    int pos = scrollBodyPanel.getScrollPosition();\r\n    if (pos == 0) {\r\n        firstRowInViewPort = 0;\r\n    }\r\n    scrollBody = createScrollBody();\r\n    scrollBody.renderInitialRows(rowData, uidl.getIntAttribute(\"firstrow\"), uidl.getIntAttribute(\"rows\"));\r\n    scrollBodyPanel.add(scrollBody);\r\n    initialContentReceived = true;\r\n    sizeNeedsInit = true;\r\n    scrollBody.restoreRowVisibility();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.getDataReceivedHandler",
	"Comment": "returns a handler receiving notifications from the connector aboutcommunications.",
	"Method": "DataReceivedHandler getDataReceivedHandler(){\r\n    return dataReceivedHandler;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.setAssistivePostfix",
	"Comment": "setter for the text for assistive devices the window caption is postfixedwith.",
	"Method": "void setAssistivePostfix(String assistivePostfix){\r\n    this.assistivePostfix = assistivePostfix;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTree.getNavigationPageDownKey",
	"Comment": "get the key the moves the selection one page down in the table. bydefault this is the page down key but by overriding this you can changethe key to whatever you want.",
	"Method": "int getNavigationPageDownKey(){\r\n    return KeyCodes.KEY_PAGEDOWN;\r\n}"
}, {
	"Path": "com.vaadin.server.AbstractClientConnector.getRpcProxy",
	"Comment": "returns an rpc proxy for a given server to client rpc interface for thiscomponent.todo more javadoc, subclasses, ...",
	"Method": "T getRpcProxy(Class<T> rpcInterface){\r\n    try {\r\n        if (!rpcProxyMap.containsKey(rpcInterface)) {\r\n            Class<?> proxyClass = Proxy.getProxyClass(rpcInterface.getClassLoader(), rpcInterface);\r\n            Constructor<?> constructor = proxyClass.getConstructor(InvocationHandler.class);\r\n            T rpcProxy = rpcInterface.cast(constructor.newInstance(new RpcInvocationHandler(rpcInterface)));\r\n            rpcProxyMap.put(rpcInterface, rpcProxy);\r\n        }\r\n        return (T) rpcProxyMap.get(rpcInterface);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.writeUncachedStringResponse",
	"Comment": "writes the given string as a response with headers to prevent caching andusing the given content type.",
	"Method": "void writeUncachedStringResponse(VaadinResponse response,String contentType,String responseString){\r\n    response.setNoCacheHeaders();\r\n    writeStringResponse(response, contentType, responseString);\r\n}"
}, {
	"Path": "org.greenrobot.essentials.io.CircularByteBuffer.free",
	"Comment": "returns the number of free bytes available that can still be put without additional gets.",
	"Method": "int free(){\r\n    return capacity - available;\r\n}"
}, {
	"Path": "com.vaadin.ui.DateField.setPlaceholder",
	"Comment": "sets the placeholder text. the placeholder is text that is displayed whenthe field would otherwise be empty, to prompt the user for input.",
	"Method": "void setPlaceholder(String placeholder){\r\n    getState().placeholder = placeholder;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractInMemoryContainer.fireItemAdded",
	"Comment": "notify item set change listeners that an item has been added to thecontainer.",
	"Method": "void fireItemAdded(int position,ITEMIDTYPE itemId,ITEMCLASS item){\r\n    fireItemsAdded(position, itemId, 1);\r\n}"
}, {
	"Path": "com.vaadin.client.EventHelper.updateBlurHandler",
	"Comment": "adds or removes a blur handler depending on if the connector has blurlisteners on the server side or not.",
	"Method": "HandlerRegistration updateBlurHandler(T connector,HandlerRegistration handlerRegistration,HandlerRegistration updateBlurHandler,T connector,HandlerRegistration handlerRegistration,Widget widget){\r\n    return updateHandler(connector, connector, BLUR, handlerRegistration, BlurEvent.getType(), widget);\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractSingleSelect.addSelectionListener",
	"Comment": "adds a selection listener to this select. the listener is called when theselection is changed either by the user or programmatically.",
	"Method": "Registration addSelectionListener(SingleSelectionListener<T> listener){\r\n    return addListener(SingleSelectionEvent.class, listener, SingleSelectionListener.SELECTION_CHANGE_METHOD);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.getTimeZone",
	"Comment": "returns a time zone that is currently used by this component.",
	"Method": "TimeZone getTimeZone(){\r\n    if (timezone == null) {\r\n        return currentCalendar.getTimeZone();\r\n    }\r\n    return timezone;\r\n}"
}, {
	"Path": "com.github.dozermapper.core.functional_tests.CollectionTest.testPrimitiveArrayToCollection",
	"Comment": "test primitive array to collection mapping and also test for bidirectionalityin the custom mappings xml file",
	"Method": "void testPrimitiveArrayToCollection(){\r\n    ArrayDest sourceBean = new ArrayDest();\r\n    int[] primitiveIntArray = { 2, 3, 8 };\r\n    sourceBean.setPrimitiveIntArray(primitiveIntArray);\r\n    ArraySource destBean = mapper.map(sourceBean, ArraySource.class);\r\n    List<Integer> resultList = destBean.getListOfIntegers();\r\n    for (int i = 0; i < primitiveIntArray.length; i++) {\r\n        int srcValue = primitiveIntArray[i];\r\n        int resultValue = resultList.get(i);\r\n        assertEquals(srcValue, resultValue);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractSplitPanel.setFirstWidget",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setFirstWidget(Widget w){\r\n    if (firstChild == w) {\r\n        return;\r\n    }\r\n    if (firstChild != null) {\r\n        firstChild.removeFromParent();\r\n    }\r\n    if (w != null) {\r\n        super.add(w, firstContainer);\r\n    }\r\n    firstChild = w;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.FilesystemContainer.getFileCounts",
	"Comment": "internal method to recursively calculate the number of files under a rootdirectory.",
	"Method": "int getFileCounts(File directory){\r\n    File[] l;\r\n    if (filter != null) {\r\n        l = directory.listFiles(filter);\r\n    } else {\r\n        l = directory.listFiles();\r\n    }\r\n    if (l == null) {\r\n        return 0;\r\n    }\r\n    int ret = l.length;\r\n    for (File f : l) {\r\n        if (f.isDirectory()) {\r\n            ret += getFileCounts(f);\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.vaadin.server.ServiceInitEvent.addConnectorIdGenerator",
	"Comment": "adds as connector id generator to be used by this service. by default,the service will fail to deploy if more than one connector id generatorhas been registered.",
	"Method": "void addConnectorIdGenerator(ConnectorIdGenerator connectorIdGenerator){\r\n    Objects.requireNonNull(connectorIdGenerator, \"Connector id generator cannot be null\");\r\n    addedConnectorIdGenerators.add(connectorIdGenerator);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractTextualDate.createFormatString",
	"Comment": "create a format string suitable for the widget in its current state.",
	"Method": "String createFormatString(){\r\n    if (isYear(getCurrentResolution())) {\r\n        return \"yyyy\";\r\n    }\r\n    try {\r\n        String frmString = LocaleService.getDateFormat(currentLocale);\r\n        return cleanFormat(frmString);\r\n    } catch (LocaleNotLoadedException e) {\r\n        getLogger().log(Level.SEVERE, e.getMessage() == null ? \"\" : e.getMessage(), e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTree.getNavigationSelectKey",
	"Comment": "get the key that selects an item in the table. by default it is the spacebar key but by overriding this you can change the key to whatever youwant.",
	"Method": "int getNavigationSelectKey(){\r\n    return CHARCODE_SPACE;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractSplitPanel.checkSplitPositionLimits",
	"Comment": "returns the given position clamped to the range between current minimumand maximum positions.todo should this be in the connector?",
	"Method": "String checkSplitPositionLimits(String pos){\r\n    float positionAsFloat = convertToPixels(pos);\r\n    if (maximumPosition != null && convertToPixels(maximumPosition) < positionAsFloat) {\r\n        pos = maximumPosition;\r\n    } else if (minimumPosition != null && convertToPixels(minimumPosition) > positionAsFloat) {\r\n        pos = minimumPosition;\r\n    }\r\n    return pos;\r\n}"
}, {
	"Path": "com.vaadin.ui.ComboBox.setEmptySelectionAllowed",
	"Comment": "sets whether the user is allowed to select nothing in the combo box. whentrue, a special empty item is shown to the user.",
	"Method": "void setEmptySelectionAllowed(boolean emptySelectionAllowed){\r\n    getState().emptySelectionAllowed = emptySelectionAllowed;\r\n}"
}, {
	"Path": "com.vaadin.ui.DateTimeField.setTextFieldEnabled",
	"Comment": "enables or disables the text field. by default the text field is enabled.disabling it causes only the button for date selection to be active, thuspreventing the user from entering invalid dates.see issue 6790.",
	"Method": "void setTextFieldEnabled(boolean state){\r\n    getState().textFieldEnabled = state;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.combobox.ComboBoxConnector.clearNewItemHandlingIfMatch",
	"Comment": "clears the new item handling variables if the given value matches thepending value.this method is for internal use only and may be removed in futureversions.",
	"Method": "void clearNewItemHandlingIfMatch(String value){\r\n    if (value != null && value.equals(pendingNewItemValue)) {\r\n        pendingNewItemValue = null;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.data.validator.RegexpValidator.isValid",
	"Comment": "returns whether the given string matches the regular expression.",
	"Method": "boolean isValid(String value){\r\n    if (value == null) {\r\n        return true;\r\n    }\r\n    if (complete) {\r\n        return getMatcher(value).matches();\r\n    } else {\r\n        return getMatcher(value).find();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignContext.getComponentById",
	"Comment": "returns a component having the specified global id. if no component isfound, returns null.",
	"Method": "Component getComponentById(String globalId){\r\n    return idToComponent.get(globalId);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.schedule.CalendarEvent.setDescription",
	"Comment": "set the description of the event. the description is the text displayedwhen hovering over the event with the mouse",
	"Method": "void setDescription(String description){\r\n    this.description = description;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.PopupDateField.getAssistiveText",
	"Comment": "get the description that explains the usage of the widget for users ofassistive devices.",
	"Method": "String getAssistiveText(){\r\n    return getState(false).descriptionForAssistiveDevices;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.removeSessionDestroyListener",
	"Comment": "removes a vaadin service session destroy listener from this service.",
	"Method": "void removeSessionDestroyListener(SessionDestroyListener listener){\r\n    sessionDestroyListeners.remove(listener);\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignFormatter.findConverterFor",
	"Comment": "finds a converter for a given type. may return a converter for asuperclass instead, if one is found.",
	"Method": "Converter<String, T> findConverterFor(Class<? extends T> sourceType,boolean strict,Converter<String, T> findConverterFor,Class<? extends T> sourceType){\r\n    return findConverterFor(sourceType, false);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.FilesystemContainer.setParent",
	"Comment": "returns false when moving files around in the filesystem isnot supported.",
	"Method": "boolean setParent(Object itemId,Object newParentId){\r\n    throw new UnsupportedOperationException(\"File moving is not supported\");\r\n}"
}, {
	"Path": "com.vaadin.ui.Flash.setCodetype",
	"Comment": "this attribute specifies the content type of data expected whendownloading the object specified by classid. this attribute is optionalbut recommended when classid is specified since it allows the user agentto avoid loading information for unsupported content types. when absent,it defaults to the value of the type attribute.",
	"Method": "void setCodetype(String codetype){\r\n    if (codetype != getState().codetype || (codetype != null && !codetype.equals(getState().codetype))) {\r\n        getState().codetype = codetype;\r\n        requestRepaint();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTextField.setMaxLength",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setMaxLength(int newMaxLength){\r\n    if (newMaxLength == maxLength) {\r\n        return;\r\n    }\r\n    maxLength = newMaxLength;\r\n    updateMaxLength(maxLength);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractSplitPanel.convertToPositionUnits",
	"Comment": "converts given string to the same units as the split position is.",
	"Method": "String convertToPositionUnits(String pos){\r\n    if (position.indexOf(\"%\") != -1 && pos.indexOf(\"%\") == -1) {\r\n        pos = convertToPercentage(pos) + \"%\";\r\n    } else if (position.indexOf(\"px\") > 0 && pos.indexOf(\"px\") == -1) {\r\n        pos = convertToPixels(pos) + \"px\";\r\n    }\r\n    return pos;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.IndexedContainer.generateId",
	"Comment": "generates an unique identifier for use as an item id. guarantees that thegenerated id is not currently used as an id.",
	"Method": "Serializable generateId(){\r\n    Serializable id;\r\n    do {\r\n        id = Integer.valueOf(nextGeneratedItemId++);\r\n    } while (items.containsKey(id));\r\n    return id;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponent.fireComponentErrorEvent",
	"Comment": "emits the component error event. it is transmitted to all registeredlisteners interested in such events.",
	"Method": "void fireComponentErrorEvent(){\r\n    fireEvent(new Component.ErrorEvent(getComponentError(), this));\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractPopupCalendar.setRangeStart",
	"Comment": "sets the start range for this component. the start range is inclusive,and it depends on the current resolution, what is considered inside therange.",
	"Method": "void setRangeStart(String rangeStart){\r\n    calendar.setRangeStart(rangeStart);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.getNullSelectionItemId",
	"Comment": "returns the item id that represents null value of this select in singleselect mode.data interface does not support nulls as item ids. selecting the itemidentified by this id is the same as selecting no items at all. thissetting only affects the single select mode.",
	"Method": "Object getNullSelectionItemId(){\r\n    return nullSelectionItemId;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.getSelectedRow",
	"Comment": "keep this javadoc in sync with selectionmodel.single.getselectedrow",
	"Method": "Object getSelectedRow(Object getSelectedRow,Object getSelectedRow){\r\n    if (selectionModel instanceof SelectionModel.Single) {\r\n        return ((SelectionModel.Single) selectionModel).getSelectedRow();\r\n    } else if (selectionModel instanceof SelectionModel.Multi) {\r\n        throw new IllegalStateException(\"Cannot get unique selected row: \" + \"Grid is in multiselect mode \" + \"(the current selection model is \" + selectionModel.getClass().getName() + \").\");\r\n    } else if (selectionModel instanceof SelectionModel.None) {\r\n        throw new IllegalStateException(\"Cannot get selected row: \" + \"Grid selection is disabled \" + \"(the current selection model is \" + selectionModel.getClass().getName() + \").\");\r\n    } else {\r\n        throw new IllegalStateException(\"Cannot get selected row: \" + \"Grid selection model does not implement \" + SelectionModel.Single.class.getName() + \" or \" + SelectionModel.Multi.class.getName() + \"(the current model is \" + selectionModel.getClass().getName() + \").\");\r\n    }\r\n}"
}, {
	"Path": "com.github.dozermapper.core.DozerConverter.convertTo",
	"Comment": "converts the source field to the destination field and return the resulting destinationvalue.",
	"Method": "B convertTo(A source,B destination,B convertTo,A source){\r\n    return convertTo(source, null);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VFilterSelect.createSuggestionPopup",
	"Comment": "this method will create the suggestionpopup used by the vfilterselectinstance. it is invoked during the constructor and should only beoverridden if a custom suggestionpopup shall be used. the overridingmethod cannot use any instance variables.",
	"Method": "SuggestionPopup createSuggestionPopup(){\r\n    return new SuggestionPopup();\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConnection.getConnector",
	"Comment": "get either an existing componentconnector or create a newcomponentconnector with the given type and id.if a componentconnector with the given id already exists, returns it.otherwise creates and registers a new componentconnector of the giventype.",
	"Method": "ServerConnector getConnector(String connectorId,int connectorType){\r\n    if (!connectorMap.hasConnector(connectorId)) {\r\n        return createAndRegisterConnector(connectorId, connectorType);\r\n    }\r\n    return connectorMap.getConnector(connectorId);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.addContainerProperty",
	"Comment": "adds a new property to the table and show it as a visible column.",
	"Method": "boolean addContainerProperty(Object propertyId,Class<?> type,Object defaultValue,boolean addContainerProperty,Object propertyId,Class<?> type,Object defaultValue,String columnHeader,Resource columnIcon,Align columnAlignment){\r\n    if (!this.addContainerProperty(propertyId, type, defaultValue)) {\r\n        return false;\r\n    }\r\n    setColumnAlignment(propertyId, columnAlignment);\r\n    setColumnHeader(propertyId, columnHeader);\r\n    setColumnIcon(propertyId, columnIcon);\r\n    return true;\r\n}"
}, {
	"Path": "com.vaadin.server.GAEVaadinServlet.getMaxInactiveIntervalSeconds",
	"Comment": "returns the maximum inactive time for a session. this is used forhandling the expiration of session related information in caches etc.",
	"Method": "int getMaxInactiveIntervalSeconds(HttpSession session){\r\n    int interval = session.getMaxInactiveInterval();\r\n    if (interval <= 0) {\r\n        getLogger().log(Level.FINE, \"Undefined session expiration time, using default value instead.\");\r\n        return DEFAULT_MAX_INACTIVE_INTERVAL;\r\n    }\r\n    return interval;\r\n}"
}, {
	"Path": "com.vaadin.client.communication.Heartbeat.init",
	"Comment": "initializes the heartbeat for the given application connection.",
	"Method": "void init(ApplicationConnection applicationConnection){\r\n    connection = applicationConnection;\r\n    setInterval(connection.getConfiguration().getHeartbeatInterval());\r\n    uri = SharedUtil.addGetParameters(connection.translateVaadinUri(ApplicationConstants.APP_PROTOCOL_PREFIX + ApplicationConstants.HEARTBEAT_PATH + '/'), UIConstants.UI_ID_PARAMETER + \"=\" + connection.getConfiguration().getUIId());\r\n    connection.addHandler(ApplicationConnection.ApplicationStoppedEvent.TYPE, event -> setInterval(-1));\r\n}"
}, {
	"Path": "com.vaadin.v7.client.renderers.DateRenderer.setTimeZone",
	"Comment": "sets the time zone of the the date. by default uses the time zone of thebrowser.",
	"Method": "void setTimeZone(TimeZone timeZone){\r\n    if (timeZone == null) {\r\n        throw new IllegalArgumentException(\"Timezone should not be null\");\r\n    }\r\n    this.timeZone = timeZone;\r\n}"
}, {
	"Path": "com.vaadin.ui.ComboBox.setNewItemProvider",
	"Comment": "sets the provider function that is called when user types a new item. thecreation of new items is allowed when a new item provider has been set.if a deprecated new item handler is also set it is ignored in favor ofnew item provider.",
	"Method": "void setNewItemProvider(NewItemProvider<T> newItemProvider){\r\n    this.newItemProvider = newItemProvider;\r\n    getState(true).allowNewItems = newItemProvider != null || newItemHandler != null;\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.setTabStopTopAssistiveText",
	"Comment": "sets the message that is provided to users of assistive devices when theuser reaches the top of the window when leaving a window with the tab keyis prevented.this message is not visible on the screen.",
	"Method": "void setTabStopTopAssistiveText(String topMessage){\r\n    getState().assistiveTabStopTopText = topMessage;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.colorpicker.VColorPickerGrid.isGridLoaded",
	"Comment": "returns true if the colors have been successfully updated at least once,false otherwise.for internal use only. may be renamed or removed in a future release.",
	"Method": "boolean isGridLoaded(){\r\n    return gridLoaded;\r\n}"
}, {
	"Path": "com.github.dozermapper.core.loader.xml.XMLParserFactory.createDocumentBuilder",
	"Comment": "create a jaxp documentbuilder that this bean definition reader will use for parsing xml documents. can beoverridden in subclasses, adding further initialization of the builder.",
	"Method": "DocumentBuilder createDocumentBuilder(DocumentBuilderFactory factory){\r\n    DocumentBuilder docBuilder = factory.newDocumentBuilder();\r\n    docBuilder.setErrorHandler(new DozerDefaultHandler());\r\n    docBuilder.setEntityResolver(new DozerResolver(beanContainer));\r\n    return docBuilder;\r\n}"
}, {
	"Path": "com.vaadin.client.debug.internal.DebugButton.isActive",
	"Comment": "indicates wheter the button is currently in its active state or not.",
	"Method": "boolean isActive(){\r\n    return active;\r\n}"
}, {
	"Path": "com.vaadin.server.communication.PushRequestHandler.initAtmosphere",
	"Comment": "initializes atmosphere for the given servletconfiguration",
	"Method": "AtmosphereFramework initAtmosphere(ServletConfig vaadinServletConfig){\r\n    AtmosphereFramework atmosphere = new AtmosphereFramework(false, false) {\r\n        @Override\r\n        protected void analytics() {\r\n        }\r\n        @Override\r\n        public AtmosphereFramework addInitParameter(String name, String value) {\r\n            if (vaadinServletConfig.getInitParameter(name) == null) {\r\n                super.addInitParameter(name, value);\r\n            }\r\n            return this;\r\n        }\r\n    };\r\n    atmosphere.addAtmosphereHandler(\"/*\", new PushAtmosphereHandler());\r\n    atmosphere.addInitParameter(ApplicationConfig.BROADCASTER_CACHE, UUIDBroadcasterCache.class.getName());\r\n    atmosphere.addInitParameter(ApplicationConfig.ANNOTATION_PROCESSOR, VoidAnnotationProcessor.class.getName());\r\n    atmosphere.addInitParameter(ApplicationConfig.PROPERTY_SESSION_SUPPORT, \"true\");\r\n    atmosphere.addInitParameter(ApplicationConfig.MESSAGE_DELIMITER, String.valueOf(PushConstants.MESSAGE_DELIMITER));\r\n    atmosphere.addInitParameter(ApplicationConfig.DROP_ACCESS_CONTROL_ALLOW_ORIGIN_HEADER, \"false\");\r\n    final String bufferSize = String.valueOf(PushConstants.WEBSOCKET_BUFFER_SIZE);\r\n    atmosphere.addInitParameter(ApplicationConfig.WEBSOCKET_BUFFER_SIZE, bufferSize);\r\n    atmosphere.addInitParameter(ApplicationConfig.WEBSOCKET_MAXTEXTSIZE, bufferSize);\r\n    atmosphere.addInitParameter(ApplicationConfig.WEBSOCKET_MAXBINARYSIZE, bufferSize);\r\n    atmosphere.addInitParameter(ApplicationConfig.PROPERTY_ALLOW_SESSION_TIMEOUT_REMOVAL, \"false\");\r\n    atmosphere.addInitParameter(ApplicationConfig.RECOVER_DEAD_BROADCASTER, \"false\");\r\n    atmosphere.addInitParameter(\"org.atmosphere.cpr.showSupportMessage\", \"false\");\r\n    try {\r\n        atmosphere.init(vaadinServletConfig);\r\n        AtmosphereInterceptor trackMessageSize = new TrackMessageSizeInterceptor();\r\n        trackMessageSize.configure(atmosphere.getAtmosphereConfig());\r\n        atmosphere.interceptor(trackMessageSize);\r\n    } catch (ServletException e) {\r\n        throw new RuntimeException(\"Atmosphere init failed\", e);\r\n    }\r\n    return atmosphere;\r\n}"
}, {
	"Path": "com.vaadin.server.communication.PushRequestHandler.initAtmosphere",
	"Comment": "initializes atmosphere for the given servletconfiguration",
	"Method": "AtmosphereFramework initAtmosphere(ServletConfig vaadinServletConfig){\r\n}"
}, {
	"Path": "com.vaadin.server.communication.PushRequestHandler.initAtmosphere",
	"Comment": "initializes atmosphere for the given servletconfiguration",
	"Method": "AtmosphereFramework initAtmosphere(ServletConfig vaadinServletConfig){\r\n    if (vaadinServletConfig.getInitParameter(name) == null) {\r\n        super.addInitParameter(name, value);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinPortletRequest.getPortalProperty",
	"Comment": "reads a portal property from the portal context of the vaadin request.",
	"Method": "String getPortalProperty(String name){\r\n    return getRequest().getPortalContext().getProperty(name);\r\n}"
}, {
	"Path": "com.folioreader.view.DirectionalViewpager.setAdapter",
	"Comment": "set a pageradapter that will supply views for this pager as needed.",
	"Method": "void setAdapter(PagerAdapter adapter){\r\n    if (mAdapter != null) {\r\n        mAdapter.unregisterDataSetObserver(mObserver);\r\n        mAdapter.startUpdate(this);\r\n        for (int i = 0; i < mItems.size(); i++) {\r\n            final ItemInfo ii = mItems.get(i);\r\n            mAdapter.destroyItem(this, ii.position, ii.object);\r\n        }\r\n        mAdapter.finishUpdate(this);\r\n        mItems.clear();\r\n        removeNonDecorViews();\r\n        mCurItem = 0;\r\n        scrollTo(0, 0);\r\n    }\r\n    final PagerAdapter oldAdapter = mAdapter;\r\n    mAdapter = adapter;\r\n    mExpectedAdapterCount = 0;\r\n    if (mAdapter != null) {\r\n        if (mObserver == null) {\r\n            mObserver = new PagerObserver();\r\n        }\r\n        mAdapter.registerDataSetObserver(mObserver);\r\n        mPopulatePending = false;\r\n        final boolean wasFirstLayout = mFirstLayout;\r\n        mFirstLayout = true;\r\n        mExpectedAdapterCount = mAdapter.getCount();\r\n        if (mRestoredCurItem >= 0) {\r\n            mAdapter.restoreState(mRestoredAdapterState, mRestoredClassLoader);\r\n            setCurrentItemInternal(mRestoredCurItem, false, true);\r\n            mRestoredCurItem = -1;\r\n            mRestoredAdapterState = null;\r\n            mRestoredClassLoader = null;\r\n        } else if (!wasFirstLayout) {\r\n            populate();\r\n        } else {\r\n            requestLayout();\r\n        }\r\n    }\r\n    if (mAdapterChangeListener != null && oldAdapter != adapter) {\r\n        mAdapterChangeListener.onAdapterChanged(oldAdapter, adapter);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.communication.ServerRpcHandler.parseInvocations",
	"Comment": "parse json from the client into a list of methodinvocation instances.",
	"Method": "List<MethodInvocation> parseInvocations(ConnectorTracker connectorTracker,JsonArray invocationsJson,int lastSyncIdSeenByClient){\r\n    int invocationCount = invocationsJson.length();\r\n    List<MethodInvocation> invocations = new ArrayList(invocationCount);\r\n    MethodInvocation previousInvocation = null;\r\n    for (int i = 0; i < invocationCount; ++i) {\r\n        JsonArray invocationJson = invocationsJson.getArray(i);\r\n        MethodInvocation invocation = parseInvocation(invocationJson, previousInvocation, connectorTracker, lastSyncIdSeenByClient);\r\n        if (invocation != null) {\r\n            invocations.add(invocation);\r\n            previousInvocation = invocation;\r\n        }\r\n    }\r\n    return invocations;\r\n}"
}, {
	"Path": "com.vaadin.server.FileDownloader.setFileDownloadResource",
	"Comment": "sets the resource that is downloaded when the extended component isclicked.",
	"Method": "void setFileDownloadResource(Resource resource){\r\n    setResource(\"dl\", resource);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Label.getDataSourceValue",
	"Comment": "returns the current value of the data source converted using the currentlocale.",
	"Method": "String getDataSourceValue(){\r\n    return ConverterUtil.convertFromModel(getPropertyDataSource().getValue(), String.class, getConverter(), getLocale());\r\n}"
}, {
	"Path": "com.vaadin.server.ServerRpcManager.getRpcProxy",
	"Comment": "returns an rpc proxy for a given client to server rpc interface for thegiven component or extension.",
	"Method": "T getRpcProxy(ClientConnector connector,Class<T> rpcInterface){\r\n    @SuppressWarnings(\"unchecked\")\r\n    ServerRpcManager<T> rpcManager = (ServerRpcManager<T>) connector.getRpcManager(rpcInterface.getName());\r\n    if (rpcManager == null) {\r\n        return null;\r\n    }\r\n    return rpcManager.getImplementation();\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConnection.isCSSLoaded",
	"Comment": "checks whether or not the css is loaded. by default checks the size ofthe loading indicator element.",
	"Method": "boolean isCSSLoaded(){\r\n    return cssLoaded || getLoadingIndicator().getElement().getOffsetHeight() != 0;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.query.AbstractTransactionalQuery.getConnection",
	"Comment": "returns the currently active connection, reserves and returns a newconnection if no active connection.",
	"Method": "Connection getConnection(){\r\n    if (activeConnection != null) {\r\n        return activeConnection;\r\n    }\r\n    return connectionPool.reserveConnection();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.createSuggestionPopup",
	"Comment": "this method will create the suggestionpopup used by the vcomboboxinstance. it is invoked during the constructor and should only beoverridden if a custom suggestionpopup shall be used. the overridingmethod cannot use any instance variables.",
	"Method": "SuggestionPopup createSuggestionPopup(){\r\n    return new SuggestionPopup();\r\n}"
}, {
	"Path": "com.vaadin.client.communication.AtmospherePushConnection.onError",
	"Comment": "called if the push connection fails. atmosphere will automatically retrythe connection until successful.",
	"Method": "void onError(AtmosphereResponse response){\r\n    state = State.DISCONNECTED;\r\n    getConnectionStateHandler().pushError(this, response);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.setNullSelectionItemId",
	"Comment": "sets the item id that represents null value of this select.data interface does not support nulls as item ids. selecting the itemidentified by this id is the same as selecting no items at all. thissetting only affects the single select mode.",
	"Method": "void setNullSelectionItemId(Object nullSelectionItemId){\r\n    if (nullSelectionItemId != null && isMultiSelect()) {\r\n        throw new IllegalStateException(\"Multiselect and NullSelectionItemId can not be set at the same time.\");\r\n    }\r\n    this.nullSelectionItemId = nullSelectionItemId;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.setSelectedItemIcon",
	"Comment": "sets the icon uri of the selected item. the icon is shown on the leftside of the item caption text. set the uri to null to remove the icon.",
	"Method": "void setSelectedItemIcon(String iconUri){\r\n    if (selectedItemIcon != null) {\r\n        panel.remove(selectedItemIcon);\r\n    }\r\n    if (iconUri == null || iconUri.isEmpty()) {\r\n        if (selectedItemIcon != null) {\r\n            selectedItemIcon = null;\r\n            afterSelectedItemIconChange();\r\n        }\r\n    } else {\r\n        selectedItemIcon = new IconWidget(connector.getConnection().getIcon(iconUri));\r\n        selectedItemIcon.addDomHandler(VComboBox.this, ClickEvent.getType());\r\n        selectedItemIcon.addDomHandler(VComboBox.this, MouseDownEvent.getType());\r\n        selectedItemIcon.addDomHandler(event -> afterSelectedItemIconChange(), LoadEvent.getType());\r\n        panel.insert(selectedItemIcon, 0);\r\n        afterSelectedItemIconChange();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.isWorkPending",
	"Comment": "return true if component need to perform some work and false otherwise.",
	"Method": "boolean isWorkPending(){\r\n    return lazyAdjustColumnWidths.isRunning();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.connectors.AbstractRendererConnector.getColumnId",
	"Comment": "gets the column id for a column.in case this renderer wants be able to identify a column in such a waythat the server also understands it, the column id is used for that.columns are identified by unified ids between the client and the server.",
	"Method": "String getColumnId(Column<?, JsonObject> column){\r\n    final ServerConnector parent = getParent();\r\n    if (parent instanceof GridConnector) {\r\n        return ((GridConnector) parent).getColumnId(column);\r\n    } else {\r\n        throw new IllegalStateException(\"Renderers can only be used \" + \"with a Grid.\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.getEditorSaveCaption",
	"Comment": "gets the current caption of the save button in the grid editor.",
	"Method": "String getEditorSaveCaption(){\r\n    return getState(false).editorSaveCaption;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VPopupView.onDetach",
	"Comment": "make sure that we remove the popup when the main widget is removed.",
	"Method": "void onDetach(){\r\n    popup.hide();\r\n    super.onDetach();\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponent.hasEqualWidth",
	"Comment": "test if the given component has equal width with this instance",
	"Method": "boolean hasEqualWidth(Component component){\r\n    return getWidth() == component.getWidth() && getWidthUnits().equals(component.getWidthUnits());\r\n}"
}, {
	"Path": "com.vaadin.client.ui.ui.UIConnector.activateTheme",
	"Comment": "activates the new theme. assumes the theme has been loaded and taken intouse in the browser.",
	"Method": "void activateTheme(String newTheme){\r\n    if (activeTheme != null) {\r\n        getWidget().getParent().removeStyleName(activeTheme);\r\n        VOverlay.getOverlayContainer(getConnection()).removeClassName(activeTheme);\r\n    }\r\n    String oldThemeBase = getConnection().translateVaadinUri(\"theme://\");\r\n    activeTheme = newTheme;\r\n    if (newTheme != null) {\r\n        getWidget().getParent().addStyleName(newTheme);\r\n        VOverlay.getOverlayContainer(getConnection()).addClassName(activeTheme);\r\n        updateVaadinFavicon(newTheme);\r\n    }\r\n    getConnection().getMessageSender().resynchronize();\r\n    forceStateChangeRecursively(UIConnector.this);\r\n    getLayoutManager().forceLayout();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.SQLContainer.setReferencedItem",
	"Comment": "sets the referenced item. the referencing column of the item in thiscontainer is updated accordingly.",
	"Method": "boolean setReferencedItem(Object itemId,Object refdItemId,SQLContainer refdCont){\r\n    if (refdCont == null) {\r\n        throw new IllegalArgumentException(\"Referenced SQLContainer can not be null.\");\r\n    }\r\n    Reference r = references.get(refdCont);\r\n    if (r == null) {\r\n        throw new IllegalArgumentException(\"Reference to the given SQLContainer not defined.\");\r\n    }\r\n    try {\r\n        getContainerProperty(itemId, r.getReferencingColumn()).setValue(refdCont.getContainerProperty(refdItemId, r.getReferencedColumn()));\r\n        return true;\r\n    } catch (Exception e) {\r\n        getLogger().log(Level.WARNING, \"Setting referenced item failed.\", e);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridSingleSelect.getSelectedItem",
	"Comment": "returns the currently selected item, or an empty optional if no item isselected.",
	"Method": "Optional<T> getSelectedItem(){\r\n    return model.getSelectedItem();\r\n}"
}, {
	"Path": "bt.module.ProtocolModule.contributeMessageHandler",
	"Comment": "contribute a message handler for some message type.binding key is a unique message type id, that will be usedto encode and decode the binary representation of a message of this type.",
	"Method": "MapBinder<Integer, MessageHandler<? extends Message>> contributeMessageHandler(Binder binder){\r\n    return MapBinder.newMapBinder(binder, new TypeLiteral<Integer>() {\r\n    }, new TypeLiteral<MessageHandler<?>>() {\r\n    }, MessageHandlers.class);\r\n}"
}, {
	"Path": "bt.test.protocol.ProtocolTestBuilder.matcher",
	"Comment": "provide a custom message matcher.matchers are used by certain protocol test methods to make assertions about the decoded messages.",
	"Method": "ProtocolTestBuilder matcher(Class<T> messageType,BiPredicate<T, T> matcher){\r\n    Objects.requireNonNull(messageType);\r\n    Objects.requireNonNull(matcher);\r\n    if (matchers == null) {\r\n        matchers = new HashMap();\r\n    }\r\n    matchers.put(messageType, matcher);\r\n    return this;\r\n}"
}, {
	"Path": "com.github.sundeepk.compactcalendarview.CompactCalendarView.getEventsForMonth",
	"Comment": "fetches the events for the month of the date passed in and returns a sorted list of events",
	"Method": "List<Event> getEventsForMonth(long epochMillis,List<Event> getEventsForMonth,Date date){\r\n    return compactCalendarController.getCalendarEventsForMonth(date.getTime());\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.addClickListener",
	"Comment": "add a click listener to the ui. the listener is called whenever the userclicks inside the ui. also when the click targets a component inside theui, provided the targeted component does not prevent the click event frompropagating.",
	"Method": "Registration addClickListener(ClickListener listener){\r\n    return addListener(EventId.CLICK_EVENT_IDENTIFIER, ClickEvent.class, listener, ClickListener.clickMethod);\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.setLastRequestDuration",
	"Comment": "sets the time spent servicing the last request in the session and updatesthe total time spent servicing requests in this session.",
	"Method": "void setLastRequestDuration(long time){\r\n    assert hasLock();\r\n    lastRequestDuration = time;\r\n    cumulativeRequestDuration += time;\r\n}"
}, {
	"Path": "com.vaadin.client.connectors.grid.AbstractSelectionModelConnector.getGrid",
	"Comment": "shorthand for fetching the grid this selection model is bound to.",
	"Method": "Grid<JsonObject> getGrid(){\r\n    return getParent().getWidget();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.MethodProperty.setValue",
	"Comment": "sets the value of the property.note that since vaadin 7, no conversions are performed and the value mustbe of the correct type.",
	"Method": "void setValue(T newValue){\r\n    if (isReadOnly()) {\r\n        throw new Property.ReadOnlyException();\r\n    }\r\n    invokeSetMethod(newValue);\r\n    fireValueChange();\r\n}"
}, {
	"Path": "com.vaadin.server.GenericFontIcon.getHtml",
	"Comment": "utility method for generating html that displays an icon from specificfontfamiliy with a given codepoint in the font.",
	"Method": "String getHtml(String getHtml,String fontFamily,int codePoint){\r\n    return \"<span class=\\\"v-icon\\\" style=\\\"font-family: \" + fontFamily + \";\\\">&#x\" + Integer.toHexString(codePoint) + \";<\/span>\";\r\n}"
}, {
	"Path": "com.vaadin.client.Util.findPaintable",
	"Comment": "helper method to find the nearest parent paintable instance by traversingthe dom upwards from given element.",
	"Method": "ComponentConnector findPaintable(ApplicationConnection client,Element element){\r\n    Widget widget = Util.findWidget(element, null);\r\n    ConnectorMap vPaintableMap = ConnectorMap.get(client);\r\n    while (widget != null && !vPaintableMap.isConnector(widget)) {\r\n        widget = widget.getParent();\r\n    }\r\n    return vPaintableMap.getConnector(widget);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VListSelect.setReadOnly",
	"Comment": "sets this select as read only, meaning selection cannot be changed.",
	"Method": "void setReadOnly(boolean readOnly){\r\n    if (this.readOnly != readOnly) {\r\n        this.readOnly = readOnly;\r\n        updateEnabledState();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.tools.CvalCheckerTest.addLicensedJarToClasspath",
	"Comment": "creates a new .jar file with a manifest.mf with all vaadin license infoattributes set, and add the .jar to the classpath",
	"Method": "void addLicensedJarToClasspath(String productName,String licenseType){\r\n    Manifest testManifest = new Manifest();\r\n    testManifest.getMainAttributes().putValue(\"Manifest-Version\", \"1.0\");\r\n    testManifest.getMainAttributes().putValue(VAADIN_ADDON_LICENSE, licenseType);\r\n    testManifest.getMainAttributes().putValue(VAADIN_ADDON_NAME, productName);\r\n    testManifest.getMainAttributes().putValue(VAADIN_ADDON_TITLE, \"Test \" + productName);\r\n    testManifest.getMainAttributes().putValue(VAADIN_ADDON_VERSION, \"2\");\r\n    File testJarFile = File.createTempFile(\"vaadin.\" + productName, \".jar\");\r\n    testJarFile.deleteOnExit();\r\n    JarOutputStream target = new JarOutputStream(new FileOutputStream(testJarFile), testManifest);\r\n    target.close();\r\n    URL url = testJarFile.toURI().toURL();\r\n    final Method addURL = URLClassLoader.class.getDeclaredMethod(\"addURL\", new Class[] { URL.class });\r\n    addURL.setAccessible(true);\r\n    final URLClassLoader urlClassLoader = (URLClassLoader) Thread.currentThread().getContextClassLoader();\r\n    addURL.invoke(urlClassLoader, new Object[] { url });\r\n}"
}, {
	"Path": "com.vaadin.client.RenderSpace.getHeight",
	"Comment": "returns pixels available vertically for contained widget, includingpossible scrollbars.",
	"Method": "int getHeight(){\r\n    return super.getHeight();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addFooterKeyDownHandler",
	"Comment": "register a footerkeydownhandler to this grid. the event for this handleris fired when a keydown event occurs while cell focus is in the footer ofthis grid.",
	"Method": "HandlerRegistration addFooterKeyDownHandler(FooterKeyDownHandler handler){\r\n    return addHandler(handler, GridKeyDownEvent.TYPE);\r\n}"
}, {
	"Path": "com.vdurmont.emoji.Emoji.stringJoin",
	"Comment": "method to replace string.join, since it was only introduced in java8",
	"Method": "String stringJoin(String[] array,int count){\r\n    String joined = \"\";\r\n    for (int i = 0; i < count; i++) joined += array[i];\r\n    return joined;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.Sort.desc",
	"Comment": "creates a new sort builder with given sorting using descending sortdirection.",
	"Method": "SortBuilder desc(String by){\r\n    return new SortBuilder().thenDesc(by);\r\n}"
}, {
	"Path": "com.vaadin.ui.GridLayout.space",
	"Comment": "moves the cursor forward by one. if the cursor goes out of the right gridborder, it is moved to the first column of the next row.",
	"Method": "void space(){\r\n    cursorX++;\r\n    if (cursorX >= getColumns()) {\r\n        cursorX = 0;\r\n        cursorY++;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.combobox.ComboBoxConnector.isNewItemStillPending",
	"Comment": "confirm with the widget that the pending new item value is still pending.this method is for internal use only and may be removed in futureversions.",
	"Method": "boolean isNewItemStillPending(){\r\n    return getDataReceivedHandler().isPending(pendingNewItemValue);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.SQLContainer.rollback",
	"Comment": "rolls back all the changes, additions and removals made to the items ofthis container.",
	"Method": "void rollback(){\r\n    getLogger().log(Level.FINE, \"Rolling back changes...\");\r\n    removedItems.clear();\r\n    addedItems.clear();\r\n    modifiedItems.clear();\r\n    refresh();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.getBackwardKey",
	"Comment": "the key that selects the previous day in the calendar. by default this isthe left arrow key but by overriding this method it can be changed towhatever you like.",
	"Method": "int getBackwardKey(){\r\n    return KeyCodes.KEY_LEFT;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.setCellStyleGenerator",
	"Comment": "sets the style generator that is used for generating styles for cells.",
	"Method": "void setCellStyleGenerator(CellStyleGenerator<T> cellStyleGenerator){\r\n    this.cellStyleGenerator = cellStyleGenerator;\r\n    refreshBody();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.DefaultItemSorter.compareProperty",
	"Comment": "compares the property indicated by propertyid in the itemsindicated by item1 and item2 for order. returnsa negative integer, zero, or a positive integer as the property value inthe first item is less than, equal to, or greater than the property valuein the second item. if the sortdirection is false thereturned value is negated.the comparator set for this defaultitemsorter is used forcomparing the two property values.",
	"Method": "int compareProperty(Object propertyId,boolean sortDirection,Item item1,Item item2){\r\n    final Property<?> property1 = item1.getItemProperty(propertyId);\r\n    final Property<?> property2 = item2.getItemProperty(propertyId);\r\n    final Object value1 = (property1 == null) ? null : property1.getValue();\r\n    final Object value2 = (property2 == null) ? null : property2.getValue();\r\n    int r = 0;\r\n    if (sortDirection) {\r\n        r = propertyValueComparator.compare(value1, value2);\r\n    } else {\r\n        r = propertyValueComparator.compare(value2, value1);\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VPanel.setCaption",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setCaption(String text){\r\n    DOM.setInnerHTML(captionText, text);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.onNullSelected",
	"Comment": "triggered when an empty value is selected and null selection is allowed.",
	"Method": "void onNullSelected(){\r\n    if (enableDebug) {\r\n        debug(\"VComboBox: onNullSelected()\");\r\n    }\r\n    dataReceivedHandler.cancelPendingPostFiltering();\r\n    currentSuggestion = null;\r\n    setText(getEmptySelectionCaption());\r\n    setSelectedItemIcon(null);\r\n    if (!\"\".equals(selectedOptionKey) || selectedOptionKey != null) {\r\n        selectedOptionKey = \"\";\r\n        setSelectedCaption(\"\");\r\n        connector.sendSelection(null);\r\n    }\r\n    updatePlaceholder();\r\n    suggestionPopup.hide();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractField.setInvalidAllowed",
	"Comment": "fields allow invalid values by default. in most cases this is wanted,because the field otherwise visually forget the user input immediately.in common setting where the user wants to assure the correctness of thedatasource, but allow temporarily invalid contents in the field, the usershould add the validators to datasource, that should not allow invalidvalues. the validators are automatically copied to the field when thedatasource is set.",
	"Method": "void setInvalidAllowed(boolean invalidAllowed){\r\n    this.invalidAllowed = invalidAllowed;\r\n}"
}, {
	"Path": "com.vaadin.ui.Tree.setStyleGenerator",
	"Comment": "sets the style generator that is used for generating class names foritems in this tree. returning null from the generator results in nocustom style name being set.",
	"Method": "void setStyleGenerator(StyleGenerator<T> styleGenerator){\r\n    treeGrid.setStyleGenerator(styleGenerator);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.SQLContainer.itemChangeNotification",
	"Comment": "notifies this container that a property in the given item has beenmodified. the change will be buffered or made instantaneously dependingon auto commit mode.",
	"Method": "void itemChangeNotification(RowItem changedItem){\r\n    if (autoCommit) {\r\n        try {\r\n            queryDelegate.beginTransaction();\r\n            if (queryDelegate.storeRow(changedItem) == 0) {\r\n                queryDelegate.rollback();\r\n                refresh();\r\n                throw new ConcurrentModificationException(\"Item with the ID '\" + changedItem.getId() + \"' has been externally modified.\");\r\n            }\r\n            queryDelegate.commit();\r\n            if (notificationsEnabled) {\r\n                CacheFlushNotifier.notifyOfCacheFlush(this);\r\n            }\r\n            getLogger().log(Level.FINER, \"Row updated to DB...\");\r\n        } catch (SQLException e) {\r\n            getLogger().log(Level.WARNING, \"itemChangeNotification failed, rolling back...\", e);\r\n            try {\r\n                queryDelegate.rollback();\r\n            } catch (SQLException ee) {\r\n                getLogger().log(Level.SEVERE, \"Rollback failed\", e);\r\n            }\r\n            throw new RuntimeException(e);\r\n        }\r\n    } else {\r\n        if (!(changedItem.getId() instanceof TemporaryRowId) && !modifiedItems.contains(changedItem)) {\r\n            modifiedItems.add(changedItem);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.cleanStreamVariables",
	"Comment": "removes streamvariables that belong to connectors that are no longerattached to the session.",
	"Method": "void cleanStreamVariables(){\r\n    if (pidToNameToStreamVariable != null) {\r\n        ConnectorTracker connectorTracker = uI.getConnectorTracker();\r\n        Iterator<String> iterator = pidToNameToStreamVariable.keySet().iterator();\r\n        while (iterator.hasNext()) {\r\n            String connectorId = iterator.next();\r\n            if (connectorTracker.getConnector(connectorId) == null) {\r\n                Map<String, StreamVariable> removed = pidToNameToStreamVariable.get(connectorId);\r\n                for (String key : removed.keySet()) {\r\n                    streamVariableToSeckey.remove(removed.get(key));\r\n                }\r\n                iterator.remove();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addSortHandler",
	"Comment": "register a gwt event handler for a sorting event. this handler getscalled whenever this grid needs its data source to provide data sorted ina specific order.",
	"Method": "HandlerRegistration addSortHandler(SortHandler<T> handler){\r\n    return addHandler(handler, SortEvent.getType());\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addHeaderKeyDownHandler",
	"Comment": "register a headerkeydownhandler to this grid. the event for this handleris fired when a keydown event occurs while cell focus is in the header ofthis grid.",
	"Method": "HandlerRegistration addHeaderKeyDownHandler(HeaderKeyDownHandler handler){\r\n    return addHandler(handler, GridKeyDownEvent.TYPE);\r\n}"
}, {
	"Path": "com.github.dozermapper.core.DozerConverter.setParameter",
	"Comment": "sets the configured parameter value for this converter instance.should be called by dozer internally before actual mapping.",
	"Method": "void setParameter(String parameter){\r\n    this.parameter = parameter;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractMultiSelect.select",
	"Comment": "selects the given item. depending on the implementation, may cause otheritems to be deselected. if the item is already selected, does nothing.",
	"Method": "void select(T item,boolean userOriginated){\r\n    if (selection.contains(item)) {\r\n        return;\r\n    }\r\n    updateSelection(set -> set.add(item), userOriginated);\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.getAssistiveDescription",
	"Comment": "gets the components that are used as assistive description. textcontained in these components will be read by assistive devices when thewindow is opened.",
	"Method": "Component[] getAssistiveDescription(){\r\n    Connector[] contentDescription = getState(false).contentDescription;\r\n    if (contentDescription == null) {\r\n        return null;\r\n    }\r\n    Component[] target = new Component[contentDescription.length];\r\n    System.arraycopy(contentDescription, 0, target, 0, contentDescription.length);\r\n    return target;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VUpload.submit",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void submit(){\r\n    if (submitted || !enabled) {\r\n        getLogger().info(\"Submit cancelled (disabled or already submitted)\");\r\n        return;\r\n    }\r\n    if (fu.getFilename().isEmpty()) {\r\n        getLogger().info(\"Submitting empty selection (no file)\");\r\n    }\r\n    client.sendPendingVariableChanges();\r\n    Scheduler.get().scheduleDeferred(startUploadCmd);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.setRowStyleGenerator",
	"Comment": "sets the style generator that is used for generating styles for rows.",
	"Method": "void setRowStyleGenerator(RowStyleGenerator<T> rowStyleGenerator){\r\n    this.rowStyleGenerator = rowStyleGenerator;\r\n    refreshBody();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.schedule.CalendarEvent.setCaption",
	"Comment": "set the caption of the event. the caption is the text displayed in thecalendar on the event.",
	"Method": "void setCaption(String caption){\r\n    this.caption = caption;\r\n}"
}, {
	"Path": "com.vaadin.client.communication.MessageSender.resynchronize",
	"Comment": "resynchronize the client side, i.e. reload all component hierarchy andstate from the server",
	"Method": "void resynchronize(){\r\n    getLogger().info(\"Resynchronizing from server\");\r\n    JsonObject resyncParam = Json.createObject();\r\n    resyncParam.put(ApplicationConstants.RESYNCHRONIZE_ID, true);\r\n    send(Json.createArray(), resyncParam);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTree.doLayout",
	"Comment": "tell layoutmanager that a layout is needed later for this vtree",
	"Method": "void doLayout(){\r\n    Util.notifyParentOfSizeChange(this, false);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.updateColumnProperties",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void updateColumnProperties(UIDL uidl){\r\n    updateColumnOrder(uidl);\r\n    updateCollapsedColumns(uidl);\r\n    UIDL vc = uidl.getChildByTagName(\"visiblecolumns\");\r\n    if (vc != null) {\r\n        tHead.updateCellsFromUIDL(vc);\r\n        tFoot.updateCellsFromUIDL(vc);\r\n    }\r\n    updateHeader(uidl.getStringArrayAttribute(\"vcolorder\"));\r\n    updateFooter(uidl.getStringArrayAttribute(\"vcolorder\"));\r\n    if (uidl.hasVariable(\"noncollapsiblecolumns\")) {\r\n        noncollapsibleColumns = uidl.getStringArrayVariableAsSet(\"noncollapsiblecolumns\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VUI.sendClientResized",
	"Comment": "send new dimensions to the server.for internal use only. may be removed or replaced in the future.",
	"Method": "void sendClientResized(){\r\n    Profiler.enter(\"VUI.sendClientResized\");\r\n    Element parentElement = getElement().getParentElement();\r\n    int viewHeight = parentElement.getClientHeight();\r\n    int viewWidth = parentElement.getClientWidth();\r\n    ResizeEvent.fire(this, viewWidth, viewHeight);\r\n    Profiler.leave(\"VUI.sendClientResized\");\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.getSession",
	"Comment": "gets the underlying session to which this service session is currentlyassociated.",
	"Method": "WrappedSession getSession(){\r\n    return session;\r\n}"
}, {
	"Path": "com.folioreader.view.DirectionalViewpager.setInternalPageChangeListener",
	"Comment": "set a separate onpagechangelistener for internal use by the support library.",
	"Method": "OnPageChangeListener setInternalPageChangeListener(OnPageChangeListener listener){\r\n    OnPageChangeListener oldListener = mInternalPageChangeListener;\r\n    mInternalPageChangeListener = listener;\r\n    return oldListener;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAccordion.setTabIndex",
	"Comment": "for internal use only. may be renamed or removed in a future release.",
	"Method": "void setTabIndex(int tabIndex){\r\n    tabulatorIndex = tabIndex;\r\n    StackItem openStackItem = getOpenStackItem();\r\n    if (openStackItem != null) {\r\n        openStackItem.getElement().setTabIndex(tabIndex);\r\n    }\r\n}"
}, {
	"Path": "com.ryanharter.viewpager.ViewPager.setAdapter",
	"Comment": "set a pageradapter that will supply views for this pager as needed.",
	"Method": "void setAdapter(PagerAdapter adapter){\r\n    if (mAdapter != null) {\r\n        mAdapter.unregisterDataSetObserver(mObserver);\r\n        mAdapter.startUpdate(this);\r\n        for (int i = 0; i < mItems.size(); i++) {\r\n            final ItemInfo ii = mItems.get(i);\r\n            mAdapter.destroyItem(this, ii.position, ii.object);\r\n        }\r\n        mAdapter.finishUpdate(this);\r\n        mItems.clear();\r\n        removeNonDecorViews();\r\n        mCurItem = 0;\r\n        scrollTo(0, 0);\r\n    }\r\n    final PagerAdapter oldAdapter = mAdapter;\r\n    mAdapter = adapter;\r\n    mExpectedAdapterCount = 0;\r\n    if (mAdapter != null) {\r\n        if (mObserver == null) {\r\n            mObserver = new PagerObserver();\r\n        }\r\n        mAdapter.registerDataSetObserver(mObserver);\r\n        mPopulatePending = false;\r\n        final boolean wasFirstLayout = mFirstLayout;\r\n        mFirstLayout = true;\r\n        mExpectedAdapterCount = mAdapter.getCount();\r\n        if (mRestoredCurItem >= 0) {\r\n            mAdapter.restoreState(mRestoredAdapterState, mRestoredClassLoader);\r\n            setCurrentItemInternal(mRestoredCurItem, false, true);\r\n            mRestoredCurItem = -1;\r\n            mRestoredAdapterState = null;\r\n            mRestoredClassLoader = null;\r\n        } else if (!wasFirstLayout) {\r\n            populate();\r\n        } else {\r\n            requestLayout();\r\n        }\r\n    }\r\n    if (mAdapterChangeListener != null && oldAdapter != adapter) {\r\n        mAdapterChangeListener.onAdapterChanged(oldAdapter, adapter);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.components.calendar.ContainerEventProvider.detachContainerDataSource",
	"Comment": "if you are reusing the container which previously have been attached tothis containereventprovider call this method to remove this eventproviders container listeners before attaching it to an othercontainereventprovider.",
	"Method": "void detachContainerDataSource(){\r\n    ignoreContainerEvents();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Tree.isHtmlContentAllowed",
	"Comment": "checks whether captions are interpreted as html or plain text.",
	"Method": "boolean isHtmlContentAllowed(){\r\n    return htmlContentAllowed;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.DataCommunicator.refresh",
	"Comment": "informs the dataprovider that a data object has been updated.",
	"Method": "void refresh(T data){\r\n    Objects.requireNonNull(data, \"DataCommunicator can not refresh null object\");\r\n    Object id = getDataProvider().getId(data);\r\n    Map<Object, T> activeData = getActiveDataHandler().getActiveData();\r\n    if (activeData.containsKey(id)) {\r\n        if (updatedData.isEmpty()) {\r\n            markAsDirty();\r\n        }\r\n        updatedData.add(activeData.get(id));\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.PopupView.setPopupVisible",
	"Comment": "set the visibility of the popup. does not hide the minimalrepresentation.",
	"Method": "void setPopupVisible(boolean visible){\r\n    if (isPopupVisible() != visible) {\r\n        if (visible) {\r\n            visibleComponent = content.getPopupComponent();\r\n            if (visibleComponent == null) {\r\n                throw new IllegalStateException(\"PopupView.Content did not return Component to set visible\");\r\n            }\r\n            if (visibleComponent.getParent() != null) {\r\n                AbstractSingleComponentContainer.removeFromParent(visibleComponent);\r\n            }\r\n            visibleComponent.setParent(this);\r\n        } else {\r\n            if (equals(visibleComponent.getParent())) {\r\n                visibleComponent.setParent(null);\r\n            }\r\n            visibleComponent = null;\r\n        }\r\n        fireEvent(new PopupVisibilityEvent(this));\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.doRefresh",
	"Comment": "internal reinitialization method, should not be overridden.",
	"Method": "void doRefresh(VaadinRequest request){\r\n    Page page = getPage();\r\n    URI oldLocation = page.getLocation();\r\n    int oldWidth = page.getBrowserWindowWidth();\r\n    int oldHeight = page.getBrowserWindowHeight();\r\n    page.init(request);\r\n    setLastHeartbeatTimestamp(System.currentTimeMillis());\r\n    refresh(request);\r\n    URI newLocation = page.getLocation();\r\n    int newWidth = page.getBrowserWindowWidth();\r\n    int newHeight = page.getBrowserWindowHeight();\r\n    page.updateLocation(oldLocation.toString(), false, false);\r\n    page.updateBrowserWindowSize(oldWidth, oldHeight, false);\r\n    page.updateLocation(newLocation.toString(), true, false);\r\n    page.updateBrowserWindowSize(newWidth, newHeight, true);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.menubar.MenuBar.onHide",
	"Comment": "this method is called when a menu bar is hidden, so that it can hide anychild popups that are currently being shown.",
	"Method": "void onHide(){\r\n    if (shownChildMenu != null) {\r\n        shownChildMenu.onHide();\r\n        popup.hide();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConnection.isLoadingIndicatorVisible",
	"Comment": "determines whether or not the loading indicator is showing.",
	"Method": "boolean isLoadingIndicatorVisible(){\r\n    return getLoadingIndicator().isVisible();\r\n}"
}, {
	"Path": "com.vaadin.server.LocaleService.getState",
	"Comment": "returns the state for this servicethe state is transmitted inside the ui state rather than as an individualentity.",
	"Method": "LocaleServiceState getState(boolean markAsDirty){\r\n    if (markAsDirty) {\r\n        getUI().markAsDirty();\r\n    }\r\n    return state;\r\n}"
}, {
	"Path": "com.vaadin.shared.ui.dnd.criteria.Payload.parse",
	"Comment": "parses a payload string and returns a payload object represented by thatstring.",
	"Method": "Payload parse(String payloadString){\r\n    String[] parts = payloadString.split(\":\");\r\n    if (parts.length != 4 || !ITEM_PREFIX.equals(parts[0])) {\r\n        throw new IllegalArgumentException(\"Data type does not have a valid payload format\");\r\n    }\r\n    return new Payload(parts[2], parts[3], ValueType.valueOf(parts[1].toUpperCase(Locale.ROOT)));\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.setCacheRateFromUIDL",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setCacheRateFromUIDL(UIDL uidl){\r\n    setCacheRate(uidl.hasAttribute(\"cr\") ? uidl.getDoubleAttribute(\"cr\") : CACHE_RATE_DEFAULT);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAccordion.getStackItem",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "StackItem getStackItem(int index){\r\n    return (StackItem) getWidget(index);\r\n}"
}, {
	"Path": "com.vaadin.server.JsonPaintTarget.close",
	"Comment": "closes the paint target. paint target must be closed before thegetuidl can be called. subsequent attempts to write to painttarget. if the target was already closed, call to this function isignored. will generate an exception.",
	"Method": "void close(){\r\n    if (tag != null) {\r\n        uidlBuffer.write(tag.getJSON());\r\n    }\r\n    flush();\r\n    closed = true;\r\n}"
}, {
	"Path": "com.vaadin.ui.Notification.isHtmlContentAllowed",
	"Comment": "checks whether caption and description are interpreted as html or plaintext.",
	"Method": "boolean isHtmlContentAllowed(){\r\n    return getState(false).htmlContentAllowed;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.grid.datasources.ListSorter.removeFromGrid",
	"Comment": "detach this sorter from the grid. this unregisters the sort event handlerwhich was used to apply sorting to the listdatasource.",
	"Method": "void removeFromGrid(){\r\n    sortHandlerRegistration.removeHandler();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.grid.sort.SortEvent.getType",
	"Comment": "static access to the gwt event type identifier associated with this eventclass.",
	"Method": "Type<SortHandler<?>> getType(){\r\n    return TYPE;\r\n}"
}, {
	"Path": "com.vaadin.ui.dnd.event.DropEvent.getComponent",
	"Comment": "returns the drop target component where the drop event occurred.",
	"Method": "T getComponent(){\r\n    return (T) super.getComponent();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.connectors.AbstractRendererConnector.getRowKey",
	"Comment": "gets the row key for a row object.in case this renderer wants be able to identify a row in such a way thatthe server also understands it, the row key is used for that. rows areidentified by unified keys between the client and the server.",
	"Method": "String getRowKey(JsonObject row){\r\n    final ServerConnector parent = getParent();\r\n    if (parent instanceof GridConnector) {\r\n        return ((GridConnector) parent).getRowKey(row);\r\n    } else {\r\n        throw new IllegalStateException(\"Renderers can only be used \" + \"with a Grid.\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.AbstractConnector.getState",
	"Comment": "returns the shared state object for this connector.override this method to define the shared state type for your connector.",
	"Method": "SharedState getState(){\r\n    if (state == null) {\r\n        Profiler.enter(\"AbstractConnector.createState()\");\r\n        state = createState();\r\n        Profiler.leave(\"AbstractConnector.createState()\");\r\n    }\r\n    return state;\r\n}"
}, {
	"Path": "com.vaadin.ui.renderers.ClickableRenderer.addClickListener",
	"Comment": "adds a click listener to this button renderer. the listener is invokedevery time one of the buttons rendered by this renderer is clicked.",
	"Method": "Registration addClickListener(RendererClickListener<T> listener){\r\n    return addListener(RendererClickEvent.class, listener, RendererClickListener.CLICK_METHOD);\r\n}"
}, {
	"Path": "com.vaadin.client.WidgetSet.ensureConnectorLoaded",
	"Comment": "due its nature, gwt does not support dynamic classloading. to bypass thislimitation, widgetset must have function that returns class by its fullyqualified name.",
	"Method": "void ensureConnectorLoaded(int tag,ApplicationConfiguration conf){\r\n    ConnectorBundleLoader loader = ConnectorBundleLoader.get();\r\n    String bundleName = null;\r\n    Integer t = tag;\r\n    String serverSideClassName = \"\";\r\n    do {\r\n        serverSideClassName = conf.getServerSideClassNameForTag(t);\r\n        bundleName = loader.getBundleForIdentifier(serverSideClassName);\r\n        t = conf.getParentTag(t);\r\n    } while (bundleName == null && t != null);\r\n    if (bundleName != null && !loader.isBundleLoaded(bundleName)) {\r\n        getLogger().info(\"Loading bundle \" + bundleName + \" to be able to render server side class \" + serverSideClassName);\r\n        ApplicationConfiguration.startDependencyLoading();\r\n        loader.loadBundle(bundleName, new BundleLoadCallback() {\r\n            @Override\r\n            public void loaded() {\r\n                ApplicationConfiguration.endDependencyLoading();\r\n            }\r\n            @Override\r\n            public void failed(Throwable reason) {\r\n                getLogger().log(Level.SEVERE, \"Error loading bundle\", reason);\r\n                ApplicationConfiguration.endDependencyLoading();\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.WidgetSet.ensureConnectorLoaded",
	"Comment": "due its nature, gwt does not support dynamic classloading. to bypass thislimitation, widgetset must have function that returns class by its fullyqualified name.",
	"Method": "void ensureConnectorLoaded(int tag,ApplicationConfiguration conf){\r\n    ApplicationConfiguration.endDependencyLoading();\r\n}"
}, {
	"Path": "com.vaadin.client.WidgetSet.ensureConnectorLoaded",
	"Comment": "due its nature, gwt does not support dynamic classloading. to bypass thislimitation, widgetset must have function that returns class by its fullyqualified name.",
	"Method": "void ensureConnectorLoaded(int tag,ApplicationConfiguration conf){\r\n    getLogger().log(Level.SEVERE, \"Error loading bundle\", reason);\r\n    ApplicationConfiguration.endDependencyLoading();\r\n}"
}, {
	"Path": "com.vaadin.ui.Component.addStyleNames",
	"Comment": "adds one or more style names to this component by using one or multipleparameters.",
	"Method": "void addStyleNames(String styles){\r\n    for (String style : styles) {\r\n        addStyleName(style);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.data.Binder.getStatusLabel",
	"Comment": "gets the status label or an empty optional if none has been set.",
	"Method": "Optional<Label> getStatusLabel(){\r\n    return Optional.ofNullable(statusLabel);\r\n}"
}, {
	"Path": "com.vaadin.server.AbstractExtension.extend",
	"Comment": "add this extension to the target connector. this method is protected toallow subclasses to require a more specific type of target.",
	"Method": "void extend(AbstractClientConnector target){\r\n    target.addExtension(this);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VSlider.getNavigationLeftKey",
	"Comment": "get the key that decreases the horizontal slider. by default it is theleft arrow key but by overriding this you can change the key to whateveryou want.",
	"Method": "int getNavigationLeftKey(){\r\n    return KeyCodes.KEY_LEFT;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VOverlay.setOverlayContainerLabel",
	"Comment": "set the label of the container element, where tooltip, notification anddialogs are added to.",
	"Method": "void setOverlayContainerLabel(ApplicationConnection applicationConnection,String overlayContainerLabel){\r\n    Roles.getAlertRole().setAriaLabelProperty(VOverlay.getOverlayContainer(applicationConnection), overlayContainerLabel);\r\n}"
}, {
	"Path": "com.vaadin.ui.Dependency.findDependencies",
	"Comment": "finds all the urls defined for the given classes, registers the urls tothe communication manager, passes the registered dependencies through anydefined filters and returns the filtered collection of dependencies toload.",
	"Method": "List<Dependency> findDependencies(List<Class<? extends ClientConnector>> connectorTypes,LegacyCommunicationManager manager,List<Dependency> findDependencies,List<Class<? extends ClientConnector>> connectorTypes,LegacyCommunicationManager manager,FilterContext context){\r\n    List<Dependency> dependencies = findDependencies(connectorTypes, manager);\r\n    VaadinService service = context.getService();\r\n    for (DependencyFilter filter : service.getDependencyFilters()) {\r\n        dependencies = filter.filter(dependencies, context);\r\n    }\r\n    return dependencies;\r\n}"
}, {
	"Path": "com.vaadin.client.componentlocator.VaadinFinderLocatorStrategy.connectorMatchesPathFragment",
	"Comment": "determines whether a connector matches a path fragment. this is done bycomparing the path fragment to the name of the widget type of theconnector.",
	"Method": "boolean connectorMatchesPathFragment(ComponentConnector connector,String widgetName){\r\n    List<String> ids = getIDsForConnector(connector);\r\n    String exactClass = connector.getConnection().getConfiguration().getServerSideClassNameForTag(connector.getTag());\r\n    if (!ids.contains(exactClass)) {\r\n        ids.add(exactClass);\r\n    }\r\n    List<Integer> widgetTags = new ArrayList();\r\n    widgetTags.addAll(getTags(widgetName));\r\n    if (widgetTags.isEmpty()) {\r\n        widgetTags.addAll(getTags(\"com.vaadin.ui.\" + widgetName));\r\n    }\r\n    for (int i = 0, l = ids.size(); i < l; ++i) {\r\n        String name = ids.get(i);\r\n        final String simpleName = getSimpleClassName(name);\r\n        final String fullName = getFullClassName(name);\r\n        if (!widgetTags.isEmpty()) {\r\n            Integer[] foundTags = client.getConfiguration().getTagsForServerSideClassName(fullName);\r\n            for (int tag : foundTags) {\r\n                if (tagsMatch(widgetTags, tag)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        if (widgetName.equals(fullName + \".class\") || widgetName.equals(fullName) || widgetName.equals(simpleName + \".class\") || widgetName.equals(simpleName) || widgetName.equals(name)) {\r\n            return true;\r\n        }\r\n    }\r\n    String widget = Util.getSimpleName(connector.getWidget());\r\n    return widgetName.equals(widget) || widgetName.equals(widget + \".class\");\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignFormatter.format",
	"Comment": "formats an object according to a converter suitable for a given type.",
	"Method": "String format(Object object,String format,T object,Class<? extends T> type){\r\n    if (object == null) {\r\n        return null;\r\n    } else {\r\n        Converter<String, Object> converter = findConverterFor(object.getClass());\r\n        return converter.convertToPresentation(object, new ValueContext());\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.Tree.getContentMode",
	"Comment": "gets the currently set content mode of the item captions of this tree.",
	"Method": "ContentMode getContentMode(){\r\n    return renderer.getState(false).mode;\r\n}"
}, {
	"Path": "com.vaadin.client.extensions.DragSourceExtensionConnector.addDragListeners",
	"Comment": "adds dragstart and dragend event listeners to the given dom element.",
	"Method": "void addDragListeners(Element element){\r\n    EventTarget target = element.cast();\r\n    target.addEventListener(Event.DRAGSTART, dragStartListener);\r\n    target.addEventListener(Event.DRAGEND, dragEndListener);\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractSplitPanel.setSplitPositionLimits",
	"Comment": "sets the maximum and minimum position of the splitter. if the splitposition is reversed, maximum and minimum are also reversed.",
	"Method": "void setSplitPositionLimits(float minPos,Unit minPosUnit,float maxPos,Unit maxPosUnit){\r\n    if ((minPosUnit != Unit.PERCENTAGE && minPosUnit != Unit.PIXELS) || (maxPosUnit != Unit.PERCENTAGE && maxPosUnit != Unit.PIXELS)) {\r\n        throw new IllegalArgumentException(\"Only percentage and pixel units are allowed\");\r\n    }\r\n    SplitterState state = getSplitterState();\r\n    state.minPosition = minPos;\r\n    state.minPositionUnit = minPosUnit.getSymbol();\r\n    posMinUnit = minPosUnit;\r\n    state.maxPosition = maxPos;\r\n    state.maxPositionUnit = maxPosUnit.getSymbol();\r\n    posMaxUnit = maxPosUnit;\r\n}"
}, {
	"Path": "com.vaadin.tests.server.component.absolutelayout.ComponentPositionTest.testUnsetPosition",
	"Comment": "add component, set all attributes using css, unset some using methodcalls, assert getters agree.",
	"Method": "void testUnsetPosition(){\r\n    AbsoluteLayout layout = new AbsoluteLayout();\r\n    Button b = new Button();\r\n    layout.addComponent(b, CSS);\r\n    layout.getPosition(b).setTopValue(null);\r\n    layout.getPosition(b).setRightValue(null);\r\n    layout.getPosition(b).setBottomValue(null);\r\n    layout.getPosition(b).setLeftValue(null);\r\n    layout.getPosition(b).setZIndex(-1);\r\n    assertNull(layout.getPosition(b).getTopValue());\r\n    assertNull(layout.getPosition(b).getBottomValue());\r\n    assertNull(layout.getPosition(b).getLeftValue());\r\n    assertNull(layout.getPosition(b).getRightValue());\r\n    assertEquals(\"\", layout.getPosition(b).getCSSString());\r\n}"
}, {
	"Path": "com.vaadin.client.communication.ServerRpcQueue.isLegacyVariableChange",
	"Comment": "checks if the given method invocation represents a vaadin 6 variablechange.",
	"Method": "boolean isLegacyVariableChange(MethodInvocation invocation){\r\n    return ApplicationConstants.UPDATE_VARIABLE_METHOD.equals(invocation.getInterfaceName()) && ApplicationConstants.UPDATE_VARIABLE_METHOD.equals(invocation.getMethodName());\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.schedule.DateCell.getOverlappingEvents",
	"Comment": "returns all overlapping dayevent indexes in the group. including thetarget.",
	"Method": "DateCellGroup getOverlappingEvents(int targetIndex){\r\n    DateCellGroup g = new DateCellGroup(targetIndex);\r\n    int count = getWidgetCount();\r\n    DateCellDayEvent target = (DateCellDayEvent) getWidget(targetIndex);\r\n    WeekGridMinuteTimeRange targetRange = new WeekGridMinuteTimeRange(target.getCalendarEvent().getStartTime(), target.getCalendarEvent().getEndTime());\r\n    Date groupStart = targetRange.getStart();\r\n    Date groupEnd = targetRange.getEnd();\r\n    for (int i = 0; i < count; i++) {\r\n        if (targetIndex == i) {\r\n            continue;\r\n        }\r\n        DateCellDayEvent d = (DateCellDayEvent) getWidget(i);\r\n        WeekGridMinuteTimeRange nextRange = new WeekGridMinuteTimeRange(d.getCalendarEvent().getStartTime(), d.getCalendarEvent().getEndTime());\r\n        if (WeekGridMinuteTimeRange.doesOverlap(targetRange, nextRange)) {\r\n            g.add(i);\r\n            if (nextRange.getStart().before(targetRange.getStart())) {\r\n                groupStart = targetRange.getStart();\r\n            }\r\n            if (nextRange.getEnd().after(targetRange.getEnd())) {\r\n                groupEnd = targetRange.getEnd();\r\n            }\r\n        }\r\n    }\r\n    g.setDateRange(new WeekGridMinuteTimeRange(groupStart, groupEnd));\r\n    return g;\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridDragSource.getDragDataGenerator",
	"Comment": "returns the drag data generator function for the given type.",
	"Method": "SerializableFunction<T, String> getDragDataGenerator(String type){\r\n    return generatorFunctions.get(type);\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractListing.setItemIconGenerator",
	"Comment": "sets the item icon generator that is used to produce custom icons forshown items. the generator can return null for items with no icon.implementations that support item icons make this method public.",
	"Method": "void setItemIconGenerator(IconGenerator<T> itemIconGenerator){\r\n    Objects.requireNonNull(itemIconGenerator, \"Item icon generator must not be null\");\r\n    this.itemIconGenerator = itemIconGenerator;\r\n    getDataCommunicator().reset();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.sort.Sort.then",
	"Comment": "continue building a sort order. the provided property is sorted inspecified order if the previously added properties have been evaluated asequals.",
	"Method": "Sort then(Object propertyId,Sort then,Object propertyId,SortDirection direction){\r\n    return new Sort(this, propertyId, direction);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.updateTotalRows",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void updateTotalRows(UIDL uidl){\r\n    int newTotalRows = uidl.getIntAttribute(\"totalrows\");\r\n    if (newTotalRows != getTotalRows()) {\r\n        if (scrollBody != null) {\r\n            if (getTotalRows() == 0) {\r\n                tHead.clear();\r\n                tFoot.clear();\r\n            }\r\n            initializedAndAttached = false;\r\n            initialContentReceived = false;\r\n            isNewBody = true;\r\n        }\r\n        setTotalRows(newTotalRows);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTreeTable.buildCaptionHtmlSnippet",
	"Comment": "icons rendered into first actual column in treetable, not to row headercell.",
	"Method": "String buildCaptionHtmlSnippet(UIDL uidl){\r\n    if (uidl.getTag().equals(\"column\")) {\r\n        return super.buildCaptionHtmlSnippet(uidl);\r\n    } else {\r\n        String s = uidl.getStringAttribute(\"caption\");\r\n        return s;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.fieldgroup.FieldGroup.getFields",
	"Comment": "returns a collection of all fields that have been bound.the fields are not returned in any specific order.",
	"Method": "Collection<Field<?>> getFields(){\r\n    return fieldToPropertyId.keySet();\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridDragSource.addGridDragStartListener",
	"Comment": "attaches dragstart listener for the current drag source grid.",
	"Method": "Registration addGridDragStartListener(GridDragStartListener<T> listener){\r\n    return addListener(DragSourceState.EVENT_DRAGSTART, GridDragStartEvent.class, listener, GridDragStartListener.DRAG_START_METHOD);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendar.getWeekClickListener",
	"Comment": "get the listener that listens to user clicking on the week numbers.",
	"Method": "WeekClickListener getWeekClickListener(){\r\n    return weekClickListener;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.AbstractClickEventHandler.getRelativeToElement",
	"Comment": "click event calculates and returns coordinates relative to the elementreturned by this method. default implementation uses the root element ofthe widget. override to provide a different relative element.",
	"Method": "com.google.gwt.user.client.Element getRelativeToElement(){\r\n    return connector.getWidget().getElement();\r\n}"
}, {
	"Path": "net.openhft.chronicle.queue.impl.single.SCQIndexing.setPositionForSequenceNumber",
	"Comment": "add an entry to the sequencenumber, so stores the position of an sequencenumber",
	"Method": "void setPositionForSequenceNumber(ExcerptContext ec,long sequenceNumber,long position){\r\n    if (!indexable(sequenceNumber)) {\r\n        return;\r\n    }\r\n    Wire wire = ec.wireForIndex();\r\n    Bytes<?> bytes = wire.bytes();\r\n    if (position > bytes.capacity())\r\n        throw new IllegalArgumentException(\"pos: \" + position);\r\n    final LongArrayValues index2indexArr = getIndex2index(wire);\r\n    if (((Byteable) index2indexArr).bytesStore() == null) {\r\n        assert false;\r\n        return;\r\n    }\r\n    int index2 = (int) ((sequenceNumber) >>> (indexCountBits + indexSpacingBits));\r\n    if (index2 >= indexCount) {\r\n        if (IGNORE_INDEXING_FAILURE) {\r\n            return;\r\n        }\r\n        throw new IllegalStateException(\"Unable to index \" + sequenceNumber);\r\n    }\r\n    long secondaryAddress = getSecondaryAddress(wire, index2indexArr, index2);\r\n    if (secondaryAddress > bytes.capacity())\r\n        throw new IllegalStateException(\"sa2: \" + secondaryAddress);\r\n    bytes.readLimit(bytes.capacity());\r\n    LongArrayValues indexValues = arrayForAddress(wire, secondaryAddress);\r\n    int index3 = (int) ((sequenceNumber >>> indexSpacingBits) & (indexCount - 1));\r\n    long posN = indexValues.getValueAt(index3);\r\n    if (posN == 0) {\r\n        indexValues.setValueAt(index3, position);\r\n        indexValues.setMaxUsed(index3 + 1);\r\n    } else {\r\n        assert posN == position;\r\n    }\r\n    nextEntryToBeIndexed.setMaxValue(sequenceNumber + indexSpacing);\r\n}"
}, {
	"Path": "lbms.plugins.mldht.kad.Node.onTimeout",
	"Comment": "increase the failed queries count of the bucket entry we sent the message to",
	"Method": "void onTimeout(RPCCall call){\r\n    if (isInSurvivalMode())\r\n        return;\r\n    if (!call.getRequest().getServer().isReachable())\r\n        return;\r\n    InetSocketAddress dest = call.getRequest().getDestination();\r\n    if (call.getExpectedID() != null) {\r\n        routingTableCOW.entryForId(call.getExpectedID()).bucket.onTimeout(dest);\r\n    } else {\r\n        RoutingTableEntry entry = knownNodes.get(dest.getAddress());\r\n        if (entry != null)\r\n            entry.bucket.onTimeout(dest);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.setCurrentInstances",
	"Comment": "sets the this vaadin service as the current service and also sets thecurrent vaadin request and vaadin response. this method is used by theframework to set the current instances when a request related to theservice is processed and they are cleared when the request has beenprocessed.the application developer can also use this method to define the currentinstances outside the normal request handling, e.g. when initiatingcustom background threads.",
	"Method": "void setCurrentInstances(VaadinRequest request,VaadinResponse response){\r\n    setCurrent(this);\r\n    CurrentInstance.set(VaadinRequest.class, request);\r\n    CurrentInstance.set(VaadinResponse.class, response);\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.isClosing",
	"Comment": "returns whether this session is marked to be closed. note that thismethod also returns true if the session is actually already closed.",
	"Method": "boolean isClosing(){\r\n    assert hasLock();\r\n    return state == State.CLOSING || state == State.CLOSED;\r\n}"
}, {
	"Path": "com.vaadin.ui.LegacyWindow.getBrowserWindowWidth",
	"Comment": "gets the last known width of the browser window in which this ui resides.",
	"Method": "int getBrowserWindowWidth(){\r\n    return getPage().getBrowserWindowWidth();\r\n}"
}, {
	"Path": "com.vaadin.tests.server.component.abstractorderedlayout.AddComponentsTest.assertOrder",
	"Comment": "asserts that layout has the components in children in the order specifiedby indices.",
	"Method": "void assertOrder(Layout layout,int[] indices){\r\n    Iterator<?> i = layout.getComponentIterator();\r\n    try {\r\n        for (int index : indices) {\r\n            assertSame(children[index], i.next());\r\n        }\r\n        assertFalse(\"Too many components in layout\", i.hasNext());\r\n    } catch (NoSuchElementException e) {\r\n        fail(\"Too few components in layout\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.connectors.AbstractGridRendererConnector.getColumnId",
	"Comment": "gets the column id for a column.in case this renderer wants be able to identify a column in such a waythat the server also understands it, the column id is used for that.columns are identified by unified ids between the client and the server.",
	"Method": "String getColumnId(Column<?, JsonObject> column){\r\n    final ServerConnector parent = getParent();\r\n    if (parent instanceof GridConnector) {\r\n        return ((GridConnector) parent).getColumnId(column);\r\n    } else {\r\n        throw new IllegalStateException(\"Renderers can only be used \" + \"with a Grid.\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.filter.Compare.getPropertyId",
	"Comment": "returns the property id of the property to compare against the fixedvalue.",
	"Method": "Object getPropertyId(){\r\n    return propertyId;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.renderers.WidgetRenderer.getWidget",
	"Comment": "returns the widget contained inside the given cell element, or null if itis not an instance of the given class. cannot be called for cells that donot contain a widget.",
	"Method": "W getWidget(TableCellElement e,W getWidget,TableCellElement e,Class<W> klass){\r\n    W w = WidgetUtil.findWidget(e.getFirstChildElement(), klass);\r\n    assert w == null || w.getElement() == e.getFirstChildElement() : \"Widget not found inside cell\";\r\n    return w;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.setVaadinModality",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setVaadinModality(boolean modality){\r\n    vaadinModality = modality;\r\n    if (vaadinModality) {\r\n        getElement().setAttribute(\"aria-modal\", \"true\");\r\n        Roles.getDialogRole().set(getElement());\r\n        if (isAttached()) {\r\n            showModalityCurtain();\r\n        }\r\n        addTabBlockHandlers();\r\n        deferOrdering();\r\n    } else {\r\n        getElement().removeAttribute(\"aria-modal\");\r\n        Roles.getDialogRole().remove(getElement());\r\n        if (modalityCurtain != null) {\r\n            if (isAttached()) {\r\n                hideModalityCurtain();\r\n            }\r\n            modalityCurtain = null;\r\n        }\r\n        if (!doTabStop) {\r\n            removeTabBlockHandlers();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.Profiler.logBootstrapTimings",
	"Comment": "outputs the time passed since various events recored inperformance.timing if supported by the browser.",
	"Method": "void logBootstrapTimings(){\r\n    if (isEnabled()) {\r\n        double now = Duration.currentTimeMillis();\r\n        String[] keys = { \"navigationStart\", \"unloadEventStart\", \"unloadEventEnd\", \"redirectStart\", \"redirectEnd\", \"fetchStart\", \"domainLookupStart\", \"domainLookupEnd\", \"connectStart\", \"connectEnd\", \"requestStart\", \"responseStart\", \"responseEnd\", \"domLoading\", \"domInteractive\", \"domContentLoadedEventStart\", \"domContentLoadedEventEnd\", \"domComplete\", \"loadEventStart\", \"loadEventEnd\" };\r\n        LinkedHashMap<String, Double> timings = new LinkedHashMap();\r\n        for (String key : keys) {\r\n            double value = getPerformanceTiming(key);\r\n            if (value == 0) {\r\n                continue;\r\n            }\r\n            timings.put(key, Double.valueOf(now - value));\r\n        }\r\n        if (timings.isEmpty()) {\r\n            getLogger().info(\"Bootstrap timings not supported, please ensure your browser supports performance.timing\");\r\n            return;\r\n        }\r\n        if (getConsumer() != null) {\r\n            getConsumer().addBootstrapData(timings);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.renderers.AbstractRenderer.extend",
	"Comment": "this method is inherited from abstractextension but should never becalled directly with an abstractrenderer.",
	"Method": "void extend(AbstractClientConnector target){\r\n    super.extend(target);\r\n}"
}, {
	"Path": "com.vaadin.server.GAEVaadinServlet.cleanSession",
	"Comment": "removes the applicationcontext from the session in order to minimize thedata serialized to datastore and memcache.",
	"Method": "void cleanSession(VaadinServletRequest request){\r\n    WrappedSession wrappedSession = request.getWrappedSession(false);\r\n    if (wrappedSession == null) {\r\n        return;\r\n    }\r\n    VaadinSession serviceSession = getService().loadSession(wrappedSession);\r\n    if (serviceSession == null) {\r\n        return;\r\n    }\r\n    serviceSession.setAttribute(VaadinService.PRESERVE_UNBOUND_SESSION_ATTRIBUTE, Boolean.TRUE);\r\n    getService().removeSession(serviceSession.getSession());\r\n    serviceSession.setAttribute(VaadinService.PRESERVE_UNBOUND_SESSION_ATTRIBUTE, null);\r\n}"
}, {
	"Path": "com.github.dozermapper.core.functional_tests.WildcardWrapperTypeTest.testCanMapPrimitiveFieldAndWrapperGetter",
	"Comment": "mapping should work without configuration when field is primitive andgetter returns a wrapper class.",
	"Method": "void testCanMapPrimitiveFieldAndWrapperGetter(){\r\n    PrimitiveFieldWrapperGetter source = new PrimitiveFieldWrapperGetter();\r\n    source.setPrimitive(true);\r\n    PrimitiveFieldWrapperGetter target = mapper.map(source, PrimitiveFieldWrapperGetter.class);\r\n    assertThat(target.getPrimitive(), equalTo(true));\r\n}"
}, {
	"Path": "com.vaadin.client.ui.orderedlayout.Slot.getExpandRatio",
	"Comment": "get the expand ratio for the slot. the expand ratio describes how theslot should be resized compared to other slots in the layout",
	"Method": "double getExpandRatio(){\r\n    return expandRatio;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponent.writeSize",
	"Comment": "writes the size related attributes for the component if they differ fromthe defaults",
	"Method": "void writeSize(Attributes attributes,Component defaultInstance){\r\n    if (hasEqualSize(defaultInstance)) {\r\n        return;\r\n    }\r\n    boolean widthFull = getWidth() == 100f && getWidthUnits().equals(Sizeable.Unit.PERCENTAGE);\r\n    boolean heightFull = getHeight() == 100f && getHeightUnits().equals(Sizeable.Unit.PERCENTAGE);\r\n    boolean widthAuto = getWidth() == -1;\r\n    boolean heightAuto = getHeight() == -1;\r\n    if (widthFull && heightFull) {\r\n        attributes.put(\"size-full\", true);\r\n    } else if (widthAuto && heightAuto) {\r\n        attributes.put(\"size-auto\", true);\r\n    } else {\r\n        if (!hasEqualWidth(defaultInstance)) {\r\n            if (widthFull) {\r\n                attributes.put(\"width-full\", true);\r\n            } else if (widthAuto) {\r\n                attributes.put(\"width-auto\", true);\r\n            } else {\r\n                String widthString = DesignAttributeHandler.getFormatter().format(getWidth()) + getWidthUnits().getSymbol();\r\n                attributes.put(\"width\", widthString);\r\n            }\r\n        }\r\n        if (!hasEqualHeight(defaultInstance)) {\r\n            if (heightFull) {\r\n                attributes.put(\"height-full\", true);\r\n            } else if (heightAuto) {\r\n                attributes.put(\"height-auto\", true);\r\n            } else {\r\n                String heightString = DesignAttributeHandler.getFormatter().format(getHeight()) + getHeightUnits().getSymbol();\r\n                attributes.put(\"height\", heightString);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.getSessionAttributeName",
	"Comment": "returns the name used for storing the vaadinsession in the underlyinghttp session.",
	"Method": "String getSessionAttributeName(){\r\n    return VaadinSession.class.getName() + \".\" + getServiceName();\r\n}"
}, {
	"Path": "com.vaadin.client.communication.XhrConnection.setConnection",
	"Comment": "sets the application connection this instance is connected to. calledinternally by the framework.",
	"Method": "void setConnection(ApplicationConnection connection){\r\n    this.connection = connection;\r\n    connection.addHandler(ResponseHandlingEndedEvent.TYPE, new CommunicationHandler() {\r\n        @Override\r\n        public void onRequestStarting(RequestStartingEvent e) {\r\n        }\r\n        @Override\r\n        public void onResponseHandlingStarted(ResponseHandlingStartedEvent e) {\r\n        }\r\n        @Override\r\n        public void onResponseHandlingEnded(ResponseHandlingEndedEvent e) {\r\n            webkitMaybeIgnoringRequests = false;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.vaadin.client.communication.XhrConnection.setConnection",
	"Comment": "sets the application connection this instance is connected to. calledinternally by the framework.",
	"Method": "void setConnection(ApplicationConnection connection){\r\n}"
}, {
	"Path": "com.vaadin.client.communication.XhrConnection.setConnection",
	"Comment": "sets the application connection this instance is connected to. calledinternally by the framework.",
	"Method": "void setConnection(ApplicationConnection connection){\r\n}"
}, {
	"Path": "com.vaadin.client.communication.XhrConnection.setConnection",
	"Comment": "sets the application connection this instance is connected to. calledinternally by the framework.",
	"Method": "void setConnection(ApplicationConnection connection){\r\n    webkitMaybeIgnoringRequests = false;\r\n}"
}, {
	"Path": "com.vaadin.client.connectors.grid.AbstractGridRendererConnector.getRowKey",
	"Comment": "gets the row key for a row object.in case this renderer wants be able to identify a row in such a way thatthe server also understands it, the row key is used for that. rows areidentified by unified keys between the client and the server.",
	"Method": "String getRowKey(JsonObject row){\r\n    return row.getString(DataCommunicatorConstants.KEY);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTree.getRootNodes",
	"Comment": "returns a list of all root nodes in the tree in the order they appear inthe tree.",
	"Method": "List<TreeNode> getRootNodes(){\r\n    List<TreeNode> rootNodes = new ArrayList<TreeNode>();\r\n    for (int i = 0; i < body.getWidgetCount(); i++) {\r\n        rootNodes.add((TreeNode) body.getWidget(i));\r\n    }\r\n    return rootNodes;\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.getPushConfiguration",
	"Comment": "retrieves the object used for configuring the push channel.",
	"Method": "PushConfiguration getPushConfiguration(){\r\n    return pushConfiguration;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.TreeTable.setCollapsed",
	"Comment": "sets the item specified by given identifier as collapsed or expanded. ifthe item is collapsed, its children are not displayed to the user.",
	"Method": "void setCollapsed(Object itemId,boolean collapsed){\r\n    if (isCollapsed(itemId) != collapsed) {\r\n        if (null == toggledItemId && !isRowCacheInvalidated() && getVisibleItemIds().contains(itemId)) {\r\n            toggledItemId = itemId;\r\n            toggleChildVisibility(itemId, false);\r\n        } else {\r\n            toggledItemId = null;\r\n            toggleChildVisibility(itemId, true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.getSidebarMenu",
	"Comment": "gets the customizable menu bar that is by default used for togglingcolumn hidability. the application developer is allowed to add theircustom items to the end of the menu, but should try to avoid modifyingthe items in the beginning of the menu that control the column hiding ifany columns are marked as hidable. a toggle for opening the menu will bedisplayed whenever the menu contains at least one item.",
	"Method": "MenuBar getSidebarMenu(){\r\n    return sidebar.menuBar;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.InMemoryDataProviderHelpers.createEqualsFilter",
	"Comment": "creates a predicate that compares equality of the given required value tothe value the given value provider obtains.",
	"Method": "SerializablePredicate<T> createEqualsFilter(ValueProvider<T, V> valueProvider,V requiredValue){\r\n    Objects.requireNonNull(valueProvider, \"Value provider cannot be null\");\r\n    return item -> Objects.equals(valueProvider.apply(item), requiredValue);\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.getPushId",
	"Comment": "gets the push connection identifier for this session. used whenestablishing a push connection with the client.",
	"Method": "String getPushId(){\r\n    assert hasLock();\r\n    return pushId;\r\n}"
}, {
	"Path": "com.vaadin.ui.PopupView.addPopupVisibilityListener",
	"Comment": "add a listener that is called whenever the visibility of the popup ischanged.",
	"Method": "Registration addPopupVisibilityListener(PopupVisibilityListener listener){\r\n    return addListener(PopupVisibilityEvent.class, listener, POPUP_VISIBILITY_METHOD);\r\n}"
}, {
	"Path": "com.vaadin.ui.ComboBox.isEmptySelectionAllowed",
	"Comment": "returns whether the user is allowed to select nothing in the combo box.",
	"Method": "boolean isEmptySelectionAllowed(){\r\n    return getState(false).emptySelectionAllowed;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.orderedlayout.VAbstractOrderedLayout.updateExpandCompensation",
	"Comment": "updates the expand compensation based on the measured sizes of childrenwithout expand.",
	"Method": "void updateExpandCompensation(){\r\n    boolean isExpanding = false;\r\n    for (Widget slot : getChildren()) {\r\n        if (((Slot) slot).getExpandRatio() != 0) {\r\n            isExpanding = true;\r\n            break;\r\n        }\r\n    }\r\n    if (isExpanding) {\r\n        int totalSize = 0;\r\n        for (Widget w : getChildren()) {\r\n            Slot slot = (Slot) w;\r\n            if (slot.getExpandRatio() == 0 && !slot.isRelativeInDirection(vertical)) {\r\n                if (layoutManager != null) {\r\n                    if (vertical) {\r\n                        int size = layoutManager.getOuterHeight(slot.getWidget().getElement());\r\n                        if (slot.hasCaption()) {\r\n                            size += layoutManager.getOuterHeight(slot.getCaptionElement());\r\n                        }\r\n                        if (size > 0) {\r\n                            totalSize += size;\r\n                        }\r\n                    } else {\r\n                        int max = -1;\r\n                        max = layoutManager.getOuterWidth(slot.getWidget().getElement());\r\n                        if (slot.hasCaption()) {\r\n                            int max2 = layoutManager.getOuterWidth(slot.getCaptionElement());\r\n                            max = Math.max(max, max2);\r\n                        }\r\n                        if (max > 0) {\r\n                            totalSize += max;\r\n                        }\r\n                    }\r\n                } else {\r\n                    totalSize += vertical ? slot.getOffsetHeight() : slot.getOffsetWidth();\r\n                }\r\n            }\r\n            int spacingSize = vertical ? slot.getVerticalSpacing() : slot.getHorizontalSpacing();\r\n            if (spacingSize > 0) {\r\n                totalSize += spacingSize;\r\n            }\r\n        }\r\n        if (vertical) {\r\n            expandWrapper.getStyle().setPaddingTop(totalSize, Unit.PX);\r\n            expandWrapper.getFirstChildElement().getStyle().setMarginTop(-totalSize, Unit.PX);\r\n        } else {\r\n            expandWrapper.getStyle().setPaddingLeft(totalSize, Unit.PX);\r\n            expandWrapper.getFirstChildElement().getStyle().setMarginLeft(-totalSize, Unit.PX);\r\n        }\r\n        if (totalSize != lastExpandSize) {\r\n            lastExpandSize = totalSize;\r\n            for (Widget w : getChildren()) {\r\n                Slot slot = (Slot) w;\r\n                if (slot.getExpandRatio() != 0) {\r\n                    if (layoutManager != null) {\r\n                        layoutManager.setNeedsMeasure(Util.findConnectorFor(slot.getWidget()));\r\n                    } else if (slot.getWidget() instanceof RequiresResize) {\r\n                        ((RequiresResize) slot.getWidget()).onResize();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.combobox.ComboBoxConnector.sendBlurEvent",
	"Comment": "notify the server that the combo box lost focus.for timing reasons, connectorfocusandblurhandler is not used at themoment.this method is for internal use only and may be removed in futureversions.",
	"Method": "void sendBlurEvent(){\r\n    boolean registeredListeners = hasEventListener(EventId.BLUR);\r\n    if (registeredListeners) {\r\n        focusAndBlurRpc.blur();\r\n        getDataReceivedHandler().clearPendingNavigation();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.deselect",
	"Comment": "keep this javadoc in sync with selectionmodel.single.deselect",
	"Method": "boolean deselect(Object itemIds,boolean deselect,Collection<?> itemIds,boolean deselect,Object itemId,boolean deselect,Object itemIds,boolean deselect,Collection<?> itemIds,boolean deselect,Collection<?> itemIds,boolean refresh,boolean deselect,Object itemId){\r\n    if (selectionModel instanceof SelectionModel.Single) {\r\n        if (isSelected(itemId)) {\r\n            return ((SelectionModel.Single) selectionModel).select(null);\r\n        }\r\n        return false;\r\n    } else if (selectionModel instanceof SelectionModel.Multi) {\r\n        return ((SelectionModel.Multi) selectionModel).deselect(itemId);\r\n    } else if (selectionModel instanceof SelectionModel.None) {\r\n        throw new IllegalStateException(\"Cannot deselect row '\" + itemId + \"': Grid selection is disabled \" + \"(the current selection model is \" + selectionModel.getClass().getName() + \").\");\r\n    } else {\r\n        throw new IllegalStateException(\"Cannot deselect row '\" + itemId + \"': Grid selection model does not implement \" + SelectionModel.Single.class.getName() + \" or \" + SelectionModel.Multi.class.getName() + \"(the current model is \" + selectionModel.getClass().getName() + \").\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.GridLayout.iterator",
	"Comment": "gets an iterator for the components contained in the layout. by using theiterator it is possible to step through the contents of the layout.",
	"Method": "Iterator<Component> iterator(){\r\n    return Collections.unmodifiableCollection(components).iterator();\r\n}"
}, {
	"Path": "com.vaadin.client.data.AbstractRemoteDataSource.insertRowData",
	"Comment": "informs this data source that new data has been inserted from the server.",
	"Method": "void insertRowData(int firstRowIndex,int count){\r\n    Profiler.enter(\"AbstractRemoteDataSource.insertRowData\");\r\n    if (invalidatedRows != null) {\r\n        invalidatedRows.clear();\r\n    }\r\n    size += count;\r\n    if (firstRowIndex <= cached.getStart()) {\r\n        Range oldCached = cached;\r\n        cached = cached.offsetBy(count);\r\n        for (int i = 1; i <= cached.length(); i++) {\r\n            int oldIndex = oldCached.getEnd() - i;\r\n            int newIndex = cached.getEnd() - i;\r\n            moveRowFromIndexToIndex(oldIndex, newIndex);\r\n        }\r\n    } else if (cached.contains(firstRowIndex)) {\r\n        int oldCacheEnd = cached.getEnd();\r\n        Range[] splitAt = cached.splitAt(firstRowIndex);\r\n        cached = splitAt[0];\r\n        Range invalid = splitAt[1];\r\n        if (!invalid.isEmpty() && invalidatedRows == null) {\r\n            invalidatedRows = new HashMap();\r\n            for (int i = invalid.getStart(); i < invalid.getEnd(); ++i) {\r\n                invalidatedRows.put(i + count, indexToRowMap.get(i));\r\n            }\r\n        }\r\n        for (int i = firstRowIndex; i < oldCacheEnd; i++) {\r\n            T row = indexToRowMap.remove(Integer.valueOf(i));\r\n            keyToIndexMap.remove(getRowKey(row));\r\n        }\r\n    }\r\n    getHandlers().forEach(dch -> dch.dataAdded(firstRowIndex, count));\r\n    ensureCoverageCheck();\r\n    Profiler.leave(\"AbstractRemoteDataSource.insertRowData\");\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.RichTextArea.selectAll",
	"Comment": "selects all text in the rich text area. as a side effect, focuses therich text area.",
	"Method": "void selectAll(){\r\n    selectAll = true;\r\n    focus();\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.ui.ProgressBar.reset",
	"Comment": "resets the value of this component, effectively displaying zero progress.",
	"Method": "void reset(){\r\n    setValue(DEFAULT_VALUE);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractField.isInvalidAllowed",
	"Comment": "fields allow invalid values by default. in most cases this is wanted,because the field otherwise visually forget the user input immediately.",
	"Method": "boolean isInvalidAllowed(){\r\n    return invalidAllowed;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.reinitializeSession",
	"Comment": "discards the current session and creates a new session with the samecontents. the purpose of this is to introduce a new session key in orderto avoid session fixation attacks.please note that this method makes certain assumptions about how data isstored in the underlying session and may thus not be compatible with someenvironments.",
	"Method": "void reinitializeSession(VaadinRequest request){\r\n    WrappedSession oldSession = request.getWrappedSession();\r\n    Set<String> attributeNames = oldSession.getAttributeNames();\r\n    Map<String, Object> attrs = new HashMap(attributeNames.size() * 2);\r\n    for (String name : attributeNames) {\r\n        Object value = oldSession.getAttribute(name);\r\n        if (value instanceof VaadinSession) {\r\n            VaadinSession serviceSession = (VaadinSession) value;\r\n            serviceSession.setAttribute(PRESERVE_UNBOUND_SESSION_ATTRIBUTE, Boolean.TRUE);\r\n        }\r\n        attrs.put(name, value);\r\n    }\r\n    oldSession.invalidate();\r\n    WrappedSession newSession = request.getWrappedSession();\r\n    for (String name : attrs.keySet()) {\r\n        Object value = attrs.get(name);\r\n        newSession.setAttribute(name, value);\r\n        if (value instanceof VaadinSession) {\r\n            VaadinSession serviceSession = (VaadinSession) value;\r\n            VaadinService service = serviceSession.getService();\r\n            service.setSessionLock(newSession, serviceSession.getLockInstance());\r\n            service.storeSession(serviceSession, newSession);\r\n            serviceSession.setAttribute(PRESERVE_UNBOUND_SESSION_ATTRIBUTE, null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "bt.torrent.messaging.TorrentWorker.getConnectionState",
	"Comment": "get the current state of a connection with a particular peer.",
	"Method": "ConnectionState getConnectionState(Peer peer,ConnectionState getConnectionState){\r\n    PeerWorker worker = peerMap.get(peer);\r\n    return (worker == null) ? null : worker.getConnectionState();\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.hasLock",
	"Comment": "checks if the current thread has exclusive access to the givenwrappedsession.",
	"Method": "boolean hasLock(boolean hasLock,VaadinService service,WrappedSession session){\r\n    ReentrantLock l = (ReentrantLock) service.getSessionLock(session);\r\n    return l.isHeldByCurrentThread();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.getLastDateForWeek",
	"Comment": "gets a date that is last day in the week that target given date belongsto.",
	"Method": "Date getLastDateForWeek(Date date){\r\n    currentCalendar.setTime(date);\r\n    currentCalendar.add(java.util.Calendar.DATE, 1);\r\n    int firstDayOfWeek = currentCalendar.getFirstDayOfWeek();\r\n    while (firstDayOfWeek != currentCalendar.get(java.util.Calendar.DAY_OF_WEEK)) {\r\n        currentCalendar.add(java.util.Calendar.DATE, 1);\r\n    }\r\n    currentCalendar.add(java.util.Calendar.DATE, -1);\r\n    return currentCalendar.getTime();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VMenuBar.onMenuClick",
	"Comment": "this is called by the items in the menu and it communicates theinformation to the server.",
	"Method": "void onMenuClick(int clickedItemId){\r\n    if (uidlId != null && client != null) {\r\n        client.updateVariable(uidlId, \"clickedId\", clickedItemId, true);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.storeSession",
	"Comment": "called when the vaadinsession should be stored.by default stores the vaadinsession in the underlying http session.",
	"Method": "void storeSession(VaadinSession session,WrappedSession wrappedSession){\r\n    assert VaadinSession.hasLock(this, wrappedSession);\r\n    writeToHttpSession(wrappedSession, session);\r\n    session.refreshTransients(wrappedSession, this);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VUpload.enableUpload",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void enableUpload(){\r\n    setEnabledForSubmitButton(true);\r\n    fu.getElement().setPropertyBoolean(\"disabled\", false);\r\n    enabled = true;\r\n    if (submitted) {\r\n        cleanTargetFrame();\r\n        submitted = false;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.getOverlayContainerLabel",
	"Comment": "get the label that is added to the container element, where tooltip,notification and dialogs are added to.",
	"Method": "String getOverlayContainerLabel(){\r\n    return getState(false).overlayContainerLabel;\r\n}"
}, {
	"Path": "com.vaadin.server.widgetsetutils.ClassPathExplorer.getAvailableWidgetSets",
	"Comment": "finds the names and locations of widgetsets available on the class path.",
	"Method": "Map<String, URL> getAvailableWidgetSets(){\r\n    return getAvailableWidgetSetsAndStylesheets().getWidgetsets();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTree.getNavigationStartKey",
	"Comment": "get the key the moves the selection to the beginning of the table. bydefault this is the home key but by overriding this you can change thekey to whatever you want.",
	"Method": "int getNavigationStartKey(){\r\n    return KeyCodes.KEY_HOME;\r\n}"
}, {
	"Path": "lbms.plugins.mldht.kad.Node.doBucketChecks",
	"Comment": "check if a buckets needs to be refreshed, and refresh if necessary.",
	"Method": "void doBucketChecks(long now){\r\n    boolean survival = isInSurvivalMode();\r\n    if (survival && now - timeOfLastPingCheck < DHTConstants.BOOTSTRAP_MIN_INTERVAL)\r\n        return;\r\n    timeOfLastPingCheck = now;\r\n    mergeBuckets();\r\n    int newEntryCount = 0;\r\n    for (RoutingTableEntry e : routingTableCOW.entries) {\r\n        KBucket b = e.bucket;\r\n        boolean isHome = e.homeBucket;\r\n        List<KBucketEntry> entries = b.getEntries();\r\n        Set<Key> localIds = usedIDs.snapshot();\r\n        boolean wasFull = b.getNumEntries() >= DHTConstants.MAX_ENTRIES_PER_BUCKET;\r\n        for (KBucketEntry entry : entries) {\r\n            if (localIds.contains(entry.getID()) || (wasFull && dht.getBootStrapNodes().contains(entry.getAddress()))) {\r\n                b.removeEntryIfBad(entry, true);\r\n                continue;\r\n            }\r\n            RoutingTableEntry reverseMapping = knownNodes.get(entry.getAddress().getAddress());\r\n            if (reverseMapping != null && reverseMapping != e) {\r\n                KBucket otherBucket = reverseMapping.getBucket();\r\n                KBucketEntry other = otherBucket.findByIPorID(entry.getAddress().getAddress(), null).orElse(null);\r\n                if (other != null && !other.equals(entry)) {\r\n                    if (other.getCreationTime() < entry.getCreationTime()) {\r\n                        b.removeEntryIfBad(entry, true);\r\n                    } else {\r\n                        otherBucket.removeEntryIfBad(other, true);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        boolean refreshNeeded = b.needsToBeRefreshed();\r\n        boolean replacementNeeded = b.needsReplacementPing() || (isHome && b.findPingableReplacement().isPresent());\r\n        if (refreshNeeded || replacementNeeded)\r\n            tryPingMaintenance(b, \"Refreshing Bucket #\" + e.prefix, null, (task) -> {\r\n                task.probeUnverifiedReplacement(replacementNeeded);\r\n            });\r\n        if (!survival) {\r\n            b.promoteVerifiedReplacement();\r\n        }\r\n        newEntryCount += e.bucket.getNumEntries();\r\n    }\r\n    num_entries = newEntryCount;\r\n    rebuildAddressCache();\r\n    decayThrottle();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.performSelection",
	"Comment": "perform selection based on a message from the server.the special case where the selected item is not on the current page ishandled separately by the caller.",
	"Method": "void performSelection(String selectedKey,boolean forceUpdateText,boolean updatePromptAndSelectionIfMatchFound){\r\n    if (selectedKey == null || selectedKey.isEmpty()) {\r\n        currentSuggestion = null;\r\n        selectedOptionKey = null;\r\n        setText(getEmptySelectionCaption());\r\n    }\r\n    for (ComboBoxSuggestion suggestion : currentSuggestions) {\r\n        String suggestionKey = suggestion.getOptionKey();\r\n        if (!suggestionKey.equals(selectedKey)) {\r\n            continue;\r\n        }\r\n        if (updatePromptAndSelectionIfMatchFound) {\r\n            if (!suggestionKey.equals(selectedOptionKey) || suggestion.getReplacementString().equals(tb.getText()) || forceUpdateText) {\r\n                setText(suggestion.getReplacementString());\r\n                selectedOptionKey = suggestionKey;\r\n            }\r\n        }\r\n        currentSuggestion = suggestion;\r\n        break;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.debug.internal.SelectorPath.getComponentName",
	"Comment": "returns the name of the component described by given query fragment.",
	"Method": "String getComponentName(String fragment){\r\n    return fragment.split(\"\\\\[\")[0];\r\n}"
}, {
	"Path": "com.vaadin.v7.data.fieldgroup.DefaultFieldGroupFieldFactory.createDefaultField",
	"Comment": "fallback when no specific field has been created. typically returns atextfield.",
	"Method": "T createDefaultField(Class<?> type,Class<T> fieldType){\r\n    if (fieldType.isAssignableFrom(TextField.class)) {\r\n        return fieldType.cast(createAbstractTextField(TextField.class));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.orderedlayout.AbstractOrderedLayoutConnector.updateInternalState",
	"Comment": "updates dom properties and listeners based on the current state of thislayout and its children.",
	"Method": "void updateInternalState(){\r\n    int lastResponseId = getConnection().getLastSeenServerSyncId();\r\n    if (processedResponseId == lastResponseId) {\r\n        return;\r\n    }\r\n    Profiler.enter(\"AOLC.updateInternalState\");\r\n    processedResponseId = lastResponseId;\r\n    hasChildrenWithRelativeHeight = false;\r\n    hasChildrenWithRelativeWidth = false;\r\n    hasChildrenWithMiddleAlignment = false;\r\n    VAbstractOrderedLayout widget = getWidget();\r\n    needsExpand = widget.vertical ? !isUndefinedHeight() : !isUndefinedWidth();\r\n    boolean onlyZeroExpands = true;\r\n    if (needsExpand) {\r\n        for (ComponentConnector child : getChildComponents()) {\r\n            double expandRatio = getState().childData.get(child).expandRatio;\r\n            if (expandRatio != 0) {\r\n                onlyZeroExpands = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    for (ComponentConnector child : getChildComponents()) {\r\n        Slot slot = widget.getSlot(child.getWidget());\r\n        slot.setRelativeWidth(child.isRelativeWidth());\r\n        slot.setRelativeHeight(child.isRelativeHeight());\r\n        if (child.delegateCaptionHandling()) {\r\n            updateCaptionInternal(child);\r\n        }\r\n        List<String> childStyles = child.getState().styles;\r\n        if (childStyles == null) {\r\n            widget.setSlotStyleNames(child.getWidget(), (String[]) null);\r\n        } else {\r\n            widget.setSlotStyleNames(child.getWidget(), childStyles.toArray(new String[childStyles.size()]));\r\n        }\r\n        AlignmentInfo alignment = new AlignmentInfo(getState().childData.get(child).alignmentBitmask);\r\n        slot.setAlignment(alignment);\r\n        if (alignment.isVerticalCenter()) {\r\n            hasChildrenWithMiddleAlignment = true;\r\n        }\r\n        double expandRatio = onlyZeroExpands ? 1 : getState().childData.get(child).expandRatio;\r\n        slot.setExpandRatio(expandRatio);\r\n        if (child.isRelativeHeight()) {\r\n            hasChildrenWithRelativeHeight = true;\r\n        }\r\n        if (child.isRelativeWidth()) {\r\n            hasChildrenWithRelativeWidth = true;\r\n        }\r\n    }\r\n    if (needsFixedHeight()) {\r\n        getLayoutManager().addElementResizeListener(widget.getElement(), childComponentResizeListener);\r\n    } else {\r\n        getLayoutManager().removeElementResizeListener(widget.getElement(), childComponentResizeListener);\r\n    }\r\n    updateAllSlotListeners();\r\n    updateLayoutHeight();\r\n    if (needsExpand()) {\r\n        widget.updateExpandedSizes();\r\n        Scheduler.get().scheduleFinally(() -> widget.updateExpandCompensation());\r\n    } else {\r\n        widget.clearExpand();\r\n    }\r\n    Profiler.leave(\"AOLC.updateInternalState\");\r\n}"
}, {
	"Path": "com.vaadin.v7.server.communication.data.RpcDataProviderExtension.updateRowData",
	"Comment": "informs the client side that data of a row has been modified in the datasource.",
	"Method": "void updateRowData(Object itemId){\r\n    if (updatedItemIds == null) {\r\n        updatedItemIds = new LinkedHashSet<Object>();\r\n    }\r\n    if (updatedItemIds.isEmpty()) {\r\n        markAsDirty();\r\n    }\r\n    updatedItemIds.add(itemId);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractContainer.setPropertySetChangeListeners",
	"Comment": "sets the property set change listener collection. for internal use only.",
	"Method": "void setPropertySetChangeListeners(Collection<Container.PropertySetChangeListener> propertySetChangeListeners){\r\n    this.propertySetChangeListeners = propertySetChangeListeners;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractField.valueChange",
	"Comment": "this method listens to data source value changes and passes the changesforwards.changes are not forwarded to the listeners of the field during internaloperations of the field to avoid duplicate notifications.",
	"Method": "void valueChange(Property.ValueChangeEvent event){\r\n    if (!isBuffered()) {\r\n        if (committingValueToDataSource) {\r\n            boolean propertyNotifiesOfTheBufferedValue = SharedUtil.equals(event.getProperty().getValue(), getInternalValue());\r\n            if (!propertyNotifiesOfTheBufferedValue) {\r\n                readValueFromProperty(event);\r\n                valueWasModifiedByDataSourceDuringCommit = true;\r\n            }\r\n        } else if (!isModified()) {\r\n            readValueFromProperty(event);\r\n            fireValueChange(false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.addStreamVariable",
	"Comment": "adds a streamvariable of the given name to the indicated connector.",
	"Method": "void addStreamVariable(String connectorId,String variableName,StreamVariable variable){\r\n    assert getConnector(connectorId) != null;\r\n    if (pidToNameToStreamVariable == null) {\r\n        pidToNameToStreamVariable = new HashMap();\r\n    }\r\n    Map<String, StreamVariable> nameToStreamVariable = pidToNameToStreamVariable.get(connectorId);\r\n    if (nameToStreamVariable == null) {\r\n        nameToStreamVariable = new HashMap();\r\n        pidToNameToStreamVariable.put(connectorId, nameToStreamVariable);\r\n    }\r\n    nameToStreamVariable.put(variableName, variable);\r\n    if (streamVariableToSeckey == null) {\r\n        streamVariableToSeckey = new HashMap();\r\n    }\r\n    String seckey = streamVariableToSeckey.get(variable);\r\n    if (seckey == null) {\r\n        seckey = UUID.randomUUID().toString();\r\n        streamVariableToSeckey.put(variable, seckey);\r\n    }\r\n}"
}, {
	"Path": "lbms.plugins.mldht.indexer.utils.GenericBloomFilter.b",
	"Comment": "the base for size estimates, occurs in various calculations",
	"Method": "double b(){\r\n    return 1.0 - 1.0 / m;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.validator.AbstractValidator.setErrorMessage",
	"Comment": "sets the message to be included in the exception in case the value doesnot validate. the exception message is typically shown to the end user.",
	"Method": "void setErrorMessage(String errorMessage){\r\n    this.errorMessage = errorMessage;\r\n}"
}, {
	"Path": "sundeepk.github.com.sample.ApplicationTest.testOpenedAndClosedListerCalledForExposeAnimationCalendar",
	"Comment": "maybe a problem with espresso, for now manually check count.",
	"Method": "void testOpenedAndClosedListerCalledForExposeAnimationCalendar(){\r\n    CompactCalendarAnimationListener listener = new CompactCalendarAnimationListener() {\r\n        @Override\r\n        public void onOpened() {\r\n            onOpenedCallCount++;\r\n        }\r\n        @Override\r\n        public void onClosed() {\r\n            onClosedCallCount++;\r\n        }\r\n    };\r\n    compactCalendarView.setAnimationListener(listener);\r\n    setDate(new Date(1423353600000L));\r\n    onView(withId(R.id.show_with_animation_calendar)).perform(click());\r\n    onView(withId(R.id.show_with_animation_calendar)).perform(click());\r\n    waitForAnimationFinish();\r\n    assertEquals(onClosedCallCount, 1);\r\n    assertEquals(onOpenedCallCount, 1);\r\n}"
}, {
	"Path": "sundeepk.github.com.sample.ApplicationTest.testOpenedAndClosedListerCalledForExposeAnimationCalendar",
	"Comment": "maybe a problem with espresso, for now manually check count.",
	"Method": "void testOpenedAndClosedListerCalledForExposeAnimationCalendar(){\r\n    onOpenedCallCount++;\r\n}"
}, {
	"Path": "sundeepk.github.com.sample.ApplicationTest.testOpenedAndClosedListerCalledForExposeAnimationCalendar",
	"Comment": "maybe a problem with espresso, for now manually check count.",
	"Method": "void testOpenedAndClosedListerCalledForExposeAnimationCalendar(){\r\n    onClosedCallCount++;\r\n}"
}, {
	"Path": "com.vaadin.server.ServiceInitEvent.getAddedConnectorIdGenerators",
	"Comment": "gets an unmodifiable list of all connector id generators that have beenadded for the service.",
	"Method": "List<ConnectorIdGenerator> getAddedConnectorIdGenerators(){\r\n    return Collections.unmodifiableList(addedConnectorIdGenerators);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Tree.setItemIconAlternateText",
	"Comment": "set the alternate text for an item.used when the item has an icon.",
	"Method": "void setItemIconAlternateText(Object itemId,String altText){\r\n    if (itemId != null) {\r\n        if (altText == null) {\r\n            throw new IllegalArgumentException(NULL_ALT_EXCEPTION_MESSAGE);\r\n        } else {\r\n            itemIconAlts.put(itemId, altText);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.grid.RendererCellReference.getElement",
	"Comment": "returns the element of the cell. can be either a td elementor a th element.",
	"Method": "TableCellElement getElement(){\r\n    return cell.getElement();\r\n}"
}, {
	"Path": "com.github.dozermapper.core.util.BridgedMethodFinder.isAssignable",
	"Comment": "returns true if all the class supplied as a can be assignedfrom b",
	"Method": "boolean isAssignable(Method candidate,Method method,boolean isAssignable,Class<?>[] as,Class<?>[] bs,boolean isAssignable,Class<?> a,Class<?> b){\r\n    if (a == null && b == null) {\r\n        return true;\r\n    }\r\n    if (a == null || b == null) {\r\n        return false;\r\n    }\r\n    return a.isAssignableFrom(b);\r\n}"
}, {
	"Path": "com.vaadin.server.WrappedPortletSession.getAttributeNames",
	"Comment": "gets the current set of attribute names bound to this session in thegiven scope.",
	"Method": "Set<String> getAttributeNames(Set<String> getAttributeNames,int scope){\r\n    return WrappedHttpSession.enumerationToSet(session.getAttributeNames(scope));\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractBeanContainer.addItemAt",
	"Comment": "adds a new bean at the given index.the bean is used both as the item contents and as the item identifier.",
	"Method": "BeanItem<BEANTYPE> addItemAt(int index,IDTYPE newItemId,BEANTYPE bean){\r\n    if (!validateBean(bean)) {\r\n        return null;\r\n    }\r\n    return internalAddItemAt(index, newItemId, createBeanItem(bean), true);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.setNewItemsAllowed",
	"Comment": "enables or disables possibility to add new options by the user.",
	"Method": "void setNewItemsAllowed(boolean allowNewOptions){\r\n    if (this.allowNewOptions != allowNewOptions) {\r\n        this.allowNewOptions = allowNewOptions;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Tree.collapseItemsRecursively",
	"Comment": "collapses the items recursively.collapse all the children recursively starting from an item. operationsucceeds only if all expandable items are collapsed.",
	"Method": "boolean collapseItemsRecursively(Object startItemId){\r\n    boolean result = true;\r\n    final Stack<Object> todo = new Stack<Object>();\r\n    todo.add(startItemId);\r\n    while (!todo.isEmpty()) {\r\n        final Object id = todo.pop();\r\n        if (areChildrenAllowed(id) && !collapseItem(id)) {\r\n            result = false;\r\n        }\r\n        if (hasChildren(id)) {\r\n            todo.addAll(getChildren(id));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractTextField.setColumns",
	"Comment": "sets the number of columns in the editor. if the number of columns is set0, the actual number of displayed columns is determined implicitly by theadapter.",
	"Method": "void setColumns(int columns){\r\n    if (columns < 0) {\r\n        columns = 0;\r\n    }\r\n    getState().columns = columns;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.setEditorHandler",
	"Comment": "sets the handler responsible for binding data and editor widgets to theeditor.",
	"Method": "void setEditorHandler(EditorHandler<T> handler){\r\n    editor.setHandler(handler);\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.SingleSelectionModelImpl.asSingleSelect",
	"Comment": "gets a wrapper for using this grid as a single select in a binder.",
	"Method": "SingleSelect<T> asSingleSelect(){\r\n    return new SingleSelect<T>() {\r\n        @Override\r\n        public void setValue(T value) {\r\n            SingleSelectionModelImpl.this.setSelectedFromServer(value);\r\n        }\r\n        @Override\r\n        public T getValue() {\r\n            return SingleSelectionModelImpl.this.getSelectedItem().orElse(null);\r\n        }\r\n        @Override\r\n        public Registration addValueChangeListener(com.vaadin.data.HasValue.ValueChangeListener<T> listener) {\r\n            return SingleSelectionModelImpl.this.addSingleSelectionListener((SingleSelectionListener<T>) event -> listener.valueChange(event));\r\n        }\r\n        @Override\r\n        public void setRequiredIndicatorVisible(boolean requiredIndicatorVisible) {\r\n            throw new UnsupportedOperationException(\"Required indicator is not supported for Grid.\");\r\n        }\r\n        @Override\r\n        public boolean isRequiredIndicatorVisible() {\r\n            throw new UnsupportedOperationException(\"Required indicator is not supported for Grid.\");\r\n        }\r\n        @Override\r\n        public void setReadOnly(boolean readOnly) {\r\n            setUserSelectionAllowed(!readOnly);\r\n        }\r\n        @Override\r\n        public boolean isReadOnly() {\r\n            return !isUserSelectionAllowed();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.SingleSelectionModelImpl.asSingleSelect",
	"Comment": "gets a wrapper for using this grid as a single select in a binder.",
	"Method": "SingleSelect<T> asSingleSelect(){\r\n    SingleSelectionModelImpl.this.setSelectedFromServer(value);\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.SingleSelectionModelImpl.asSingleSelect",
	"Comment": "gets a wrapper for using this grid as a single select in a binder.",
	"Method": "SingleSelect<T> asSingleSelect(){\r\n    return SingleSelectionModelImpl.this.getSelectedItem().orElse(null);\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.SingleSelectionModelImpl.asSingleSelect",
	"Comment": "gets a wrapper for using this grid as a single select in a binder.",
	"Method": "SingleSelect<T> asSingleSelect(){\r\n    return SingleSelectionModelImpl.this.addSingleSelectionListener((SingleSelectionListener<T>) event -> listener.valueChange(event));\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.SingleSelectionModelImpl.asSingleSelect",
	"Comment": "gets a wrapper for using this grid as a single select in a binder.",
	"Method": "SingleSelect<T> asSingleSelect(){\r\n    throw new UnsupportedOperationException(\"Required indicator is not supported for Grid.\");\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.SingleSelectionModelImpl.asSingleSelect",
	"Comment": "gets a wrapper for using this grid as a single select in a binder.",
	"Method": "SingleSelect<T> asSingleSelect(){\r\n    throw new UnsupportedOperationException(\"Required indicator is not supported for Grid.\");\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.SingleSelectionModelImpl.asSingleSelect",
	"Comment": "gets a wrapper for using this grid as a single select in a binder.",
	"Method": "SingleSelect<T> asSingleSelect(){\r\n    setUserSelectionAllowed(!readOnly);\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.SingleSelectionModelImpl.asSingleSelect",
	"Comment": "gets a wrapper for using this grid as a single select in a binder.",
	"Method": "SingleSelect<T> asSingleSelect(){\r\n    return !isUserSelectionAllowed();\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignContext.setComponentLocalId",
	"Comment": "creates a mapping between the given local id and the component. returnstrue if localid was already mapped to some component or if component wasmapped to some string. otherwise returns false.if the string was mapped to a component c different from the givencomponent, the mapping from c to the string is removed. similarly, ifcomponent was mapped to some string s different from localid, the mappingfrom s to component is removed.",
	"Method": "boolean setComponentLocalId(Component component,String localId){\r\n    return twoWayMap(localId, component, localIdToComponent, componentToLocalId);\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.getCellStyleGenerator",
	"Comment": "gets the style generator that is used for generating styles for cells.",
	"Method": "CellStyleGenerator<T> getCellStyleGenerator(){\r\n    return cellStyleGenerator;\r\n}"
}, {
	"Path": "com.vaadin.tests.server.component.absolutelayout.ComponentPositionTest.testPartialCss",
	"Comment": "add component, setting some attributes using css, assert getters agree",
	"Method": "void testPartialCss(){\r\n    AbsoluteLayout layout = new AbsoluteLayout();\r\n    Button b = new Button();\r\n    layout.addComponent(b, PARTIAL_CSS);\r\n    assertEquals(CSS_VALUE, layout.getPosition(b).getTopValue());\r\n    assertNull(layout.getPosition(b).getBottomValue());\r\n    assertEquals(CSS_VALUE, layout.getPosition(b).getLeftValue());\r\n    assertNull(layout.getPosition(b).getRightValue());\r\n    assertEquals(Sizeable.Unit.PIXELS, layout.getPosition(b).getTopUnits());\r\n    assertEquals(UNIT_UNSET, layout.getPosition(b).getBottomUnits());\r\n    assertEquals(Sizeable.Unit.EM, layout.getPosition(b).getLeftUnits());\r\n    assertEquals(UNIT_UNSET, layout.getPosition(b).getRightUnits());\r\n    assertEquals(-1, layout.getPosition(b).getZIndex());\r\n    assertEquals(PARTIAL_CSS, layout.getPosition(b).getCSSString());\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.getNavigationSelectKey",
	"Comment": "get the key that selects an item in the table. by default it is the spacebar key but by overriding this you can change the key to whatever youwant.",
	"Method": "int getNavigationSelectKey(){\r\n    return CHARCODE_SPACE;\r\n}"
}, {
	"Path": "com.vaadin.server.communication.PublishedFileHandler.handleRequest",
	"Comment": "writes the connector resource identified by the request uri to theresponse. if a published resource corresponding to the uri path is notfound, writes a http not found error to the response.",
	"Method": "boolean handleRequest(VaadinSession session,VaadinRequest request,VaadinResponse response){\r\n    if (!ServletPortletHelper.isPublishedFileRequest(request)) {\r\n        return false;\r\n    }\r\n    String pathInfo = request.getPathInfo();\r\n    String fileName = pathInfo.substring(ApplicationConstants.PUBLISHED_FILE_PATH.length() + 2);\r\n    final String mimetype = response.getService().getMimeType(fileName);\r\n    if (fileName.startsWith(\"/\")) {\r\n        getLogger().warning(\"Published file request starting with / rejected: \" + fileName);\r\n        response.sendError(HttpServletResponse.SC_NOT_FOUND, fileName);\r\n        return true;\r\n    }\r\n    session.lock();\r\n    Class<?> context;\r\n    try {\r\n        context = session.getCommunicationManager().getDependencies().get(fileName);\r\n    } finally {\r\n        session.unlock();\r\n    }\r\n    if (context == null) {\r\n        getLogger().warning(\"Rejecting published file request for file that has not been published: \" + fileName);\r\n        response.sendError(HttpServletResponse.SC_NOT_FOUND, fileName);\r\n        return true;\r\n    }\r\n    InputStream in = context.getResourceAsStream(fileName);\r\n    if (in == null) {\r\n        getLogger().warning(fileName + \" published by \" + context.getName() + \" not found. Verify that the file \" + context.getPackage().getName().replace('.', '/') + '/' + fileName + \" is available on the classpath.\");\r\n        response.sendError(HttpServletResponse.SC_NOT_FOUND, fileName);\r\n        return true;\r\n    }\r\n    String cacheControl = \"public, max-age=0, must-revalidate\";\r\n    int resourceCacheTime = request.getService().getDeploymentConfiguration().getResourceCacheTime();\r\n    if (resourceCacheTime > 0) {\r\n        cacheControl = \"max-age=\" + String.valueOf(resourceCacheTime);\r\n    }\r\n    response.setHeader(\"Cache-Control\", cacheControl);\r\n    OutputStream out = null;\r\n    try {\r\n        if (mimetype != null) {\r\n            response.setContentType(mimetype);\r\n        }\r\n        out = response.getOutputStream();\r\n        final byte[] buffer = new byte[Constants.DEFAULT_BUFFER_SIZE];\r\n        int bytesRead = 0;\r\n        while ((bytesRead = in.read(buffer)) > 0) {\r\n            out.write(buffer, 0, bytesRead);\r\n        }\r\n        out.flush();\r\n    } finally {\r\n        try {\r\n            in.close();\r\n        } catch (Exception e) {\r\n        }\r\n        if (out != null) {\r\n            try {\r\n                out.close();\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.vaadin.shared.Range.startsAfter",
	"Comment": "checks whether this range starts after the end of another range.",
	"Method": "boolean startsAfter(Range other){\r\n    return getStart() >= other.getEnd();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.colorpicker.VColorPickerGrid.updateGrid",
	"Comment": "updates the row and column count and creates a new grid based on them.the new grid replaces the old grid if one existed.for internal use only. may be renamed or removed in a future release.",
	"Method": "void updateGrid(int rowCount,int columnCount){\r\n    rows = rowCount;\r\n    columns = columnCount;\r\n    this.remove(grid);\r\n    this.add(createGrid(), 0, 0);\r\n}"
}, {
	"Path": "com.vaadin.server.StreamResource.setStreamSource",
	"Comment": "sets the source for this streamresource.streamsource is queried when the resource is about to bestreamed to the client.",
	"Method": "void setStreamSource(StreamSource streamSource){\r\n    this.streamSource = streamSource;\r\n}"
}, {
	"Path": "com.vaadin.client.communication.TranslatedURLReference.setConnection",
	"Comment": "sets the application connection this instance is connected to. calledinternally by the framework.",
	"Method": "void setConnection(ApplicationConnection connection){\r\n    this.connection = connection;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.removeSession",
	"Comment": "called when the vaadinsession should be removed from the underlying httpsession.",
	"Method": "void removeSession(WrappedSession wrappedSession){\r\n    assert VaadinSession.hasLock(this, wrappedSession);\r\n    removeFromHttpSession(wrappedSession);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.combobox.ComboBoxConnector.setFilter",
	"Comment": "send a message to the server set the current filter.this method is for internal use only and may be removed in futureversions.",
	"Method": "void setFilter(String filter){\r\n    if (!Objects.equals(filter, getState().currentFilterText)) {\r\n        getDataReceivedHandler().clearPendingNavigation();\r\n        rpc.setFilter(filter);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.BootstrapFragmentResponse.getFragmentNodes",
	"Comment": "gets the list of dom nodes that will be used to generate the fragmenthtml. changes to the returned list will be reflected in the generatedhtml.",
	"Method": "List<Node> getFragmentNodes(){\r\n    return fragmentNodes;\r\n}"
}, {
	"Path": "com.vaadin.data.Result.map",
	"Comment": "if this result has a value, returns a result of applying the givenfunction to the value. otherwise, returns a result bearing the same erroras this one. note that any exceptions thrown by the mapping function arenot wrapped but allowed to propagate.",
	"Method": "Result<S> map(SerializableFunction<R, S> mapper){\r\n    return flatMap(value -> ok(mapper.apply(value)));\r\n}"
}, {
	"Path": "com.vaadin.client.ui.TouchScrollDelegate.enableTouchScrolling",
	"Comment": "makes the given elements scrollable, either natively or by using atouchscrolldelegate, depending on platform capabilities.",
	"Method": "TouchScrollHandler enableTouchScrolling(Widget widget,Element scrollables){\r\n    TouchScrollHandler handler = GWT.create(TouchScrollHandler.class);\r\n    handler.init(widget, scrollables);\r\n    return handler;\r\n}"
}, {
	"Path": "com.vaadin.server.LegacyApplication.getWindows",
	"Comment": "gets the set of windows contained by the application.note that the returned set of windows can not be modified.",
	"Method": "Collection<LegacyWindow> getWindows(){\r\n    return Collections.unmodifiableCollection(legacyUINames.values());\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractSplitPanel.setStylenames",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setStylenames(){\r\n    final String splitterClass = CLASSNAME + (orientation == Orientation.HORIZONTAL ? \"-hsplitter\" : \"-vsplitter\");\r\n    final String firstContainerClass = CLASSNAME + \"-first-container\";\r\n    final String secondContainerClass = CLASSNAME + \"-second-container\";\r\n    final String lockedSuffix = locked ? \"-locked\" : \"\";\r\n    splitter.setClassName(splitterClass + lockedSuffix);\r\n    firstContainer.setClassName(firstContainerClass);\r\n    secondContainer.setClassName(secondContainerClass);\r\n    for (String styleName : componentStyleNames) {\r\n        splitter.addClassName(splitterClass + \"-\" + styleName + lockedSuffix);\r\n        firstContainer.addClassName(firstContainerClass + \"-\" + styleName);\r\n        secondContainer.addClassName(secondContainerClass + \"-\" + styleName);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.textfield.AbstractTextFieldConnector.sendValueChange",
	"Comment": "sends the updated value and cursor position to the server, if either onehas changed.",
	"Method": "void sendValueChange(){\r\n    if (!hasStateChanged()) {\r\n        return;\r\n    }\r\n    lastSentCursorPosition = getAbstractTextField().getCursorPos();\r\n    getRpcProxy(AbstractTextFieldServerRpc.class).setText(getAbstractTextField().getValue(), lastSentCursorPosition);\r\n    getState().text = getAbstractTextField().getValue();\r\n}"
}, {
	"Path": "com.vaadin.client.metadata.Type.getSignature",
	"Comment": "the unique signature used to identify this type. the structure of thereturned string may change without notice and should not be used for anyother purpose than identification. the signature is currently based onthe fully qualified name of the type.",
	"Method": "String getSignature(){\r\n    return signature;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.getUIById",
	"Comment": "returns a ui with the given id.this is meant for framework internal use.",
	"Method": "UI getUIById(int uiId){\r\n    assert hasLock();\r\n    return uIs.get(uiId);\r\n}"
}, {
	"Path": "com.vaadin.client.connectors.grid.GridConnector.getColumn",
	"Comment": "gets the column corresponding to the given string identifier.",
	"Method": "CustomColumn getColumn(String columnId){\r\n    return idToColumn.get(columnId);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.getTotalSuggestionsIncludingNullSelectionItem",
	"Comment": "gets the total number of suggestions, including the possible nullselection item, if it should be visible.",
	"Method": "int getTotalSuggestionsIncludingNullSelectionItem(){\r\n    return getTotalSuggestions() + (getNullSelectionItemShouldBeVisible() ? 1 : 0);\r\n}"
}, {
	"Path": "com.vaadin.data.provider.HierarchicalDataCommunicator.setDataProvider",
	"Comment": "set the current hierarchical data provider for this communicator.",
	"Method": "SerializableConsumer<F> setDataProvider(HierarchicalDataProvider<T, F> dataProvider,F initialFilter,SerializableConsumer<F> setDataProvider,DataProvider<T, F> dataProvider,F initialFilter){\r\n    if (dataProvider instanceof HierarchicalDataProvider) {\r\n        return setDataProvider((HierarchicalDataProvider<T, F>) dataProvider, initialFilter);\r\n    }\r\n    throw new IllegalArgumentException(\"Only \" + HierarchicalDataProvider.class.getName() + \" and subtypes supported.\");\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConnection.hasEventListeners",
	"Comment": "checks if there is a registered server side listener for the event. thelist of events which has server side listeners is updated automaticallybefore the component is updated so the value is correct if called fromupdatedfromuidl.",
	"Method": "boolean hasEventListeners(ComponentConnector connector,String eventIdentifier,boolean hasEventListeners,Widget widget,String eventIdentifier){\r\n    ComponentConnector connector = getConnectorMap().getConnector(widget);\r\n    if (connector == null) {\r\n        return false;\r\n    }\r\n    return hasEventListeners(connector, eventIdentifier);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VUpload.submit",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void submit(){\r\n    if (submitted || !enabled) {\r\n        getLogger().info(\"Submit cancelled (disabled or already submitted)\");\r\n        return;\r\n    }\r\n    if (fu.getFilename().isEmpty()) {\r\n        getLogger().info(\"Submitting empty selection (no file)\");\r\n    }\r\n    client.sendPendingVariableChanges();\r\n    Scheduler.get().scheduleDeferred(startUploadCmd);\r\n}"
}, {
	"Path": "com.vaadin.data.BinderValidationStatus.createUnresolvedStatus",
	"Comment": "convenience method for creating a unresolved validation status for thegiven binder.in practice this status means that the values might not be valid, butvalidation errors should be hidden.",
	"Method": "BinderValidationStatus<BEAN> createUnresolvedStatus(Binder<BEAN> source){\r\n    return new BinderValidationStatus(source, source.getBindings().stream().map(b -> BindingValidationStatus.createUnresolvedStatus(b)).collect(Collectors.toList()), Collections.emptyList());\r\n}"
}, {
	"Path": "com.vaadin.server.ServiceInitEvent.getAddedRequestHandlers",
	"Comment": "gets an unmodifiable list of all custom request handlers that have beenadded for the service.",
	"Method": "List<RequestHandler> getAddedRequestHandlers(){\r\n    return Collections.unmodifiableList(addedRequestHandlers);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.setCellStyleGenerator",
	"Comment": "sets the style generator that is used for generating styles for cells.",
	"Method": "void setCellStyleGenerator(CellStyleGenerator cellStyleGenerator){\r\n    this.cellStyleGenerator = cellStyleGenerator;\r\n    datasourceExtension.refreshCache();\r\n}"
}, {
	"Path": "com.vaadin.server.LegacyCommunicationManager.isComponentVisibleToClient",
	"Comment": "checks if the component should be visible to the client. returns false ifthe child should not be sent to the client, true otherwise.",
	"Method": "boolean isComponentVisibleToClient(Component child){\r\n    if (!child.isVisible()) {\r\n        return false;\r\n    }\r\n    HasComponents parent = child.getParent();\r\n    if (parent instanceof SelectiveRenderer) {\r\n        if (!((SelectiveRenderer) parent).isRendered(child)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (parent != null) {\r\n        return isComponentVisibleToClient(parent);\r\n    } else {\r\n        if (child instanceof UI) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.getHeaderPadding",
	"Comment": "returns the extra space that is given to the header column when columnwidth is determined by header text.",
	"Method": "int getHeaderPadding(){\r\n    return scrollBody.getCellExtraWidth();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.validator.BeanValidator.setLocale",
	"Comment": "sets the locale used for validation error messages.revalidation is not automatically triggered by setting the locale.",
	"Method": "void setLocale(Locale locale){\r\n    this.locale = locale;\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.isClientSideInitialized",
	"Comment": "checks whether the given connector has already been initialized in thebrowser. the given connector should be registered with this connectortracker.",
	"Method": "boolean isClientSideInitialized(ClientConnector connector){\r\n    assert connectorIdToConnector.get(connector.getConnectorId()) == connector : \"Connector should be registered with this ConnectorTracker\";\r\n    return !uninitializedConnectors.contains(connector);\r\n}"
}, {
	"Path": "com.vaadin.ui.Slider.setResolution",
	"Comment": "set a new resolution for the slider. the resolution is the number ofdigits after the decimal point.",
	"Method": "void setResolution(int resolution){\r\n    if (resolution < 0) {\r\n        throw new IllegalArgumentException(\"Cannot set a negative resolution to Slider\");\r\n    }\r\n    getState().resolution = resolution;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.RowItem.addItemProperty",
	"Comment": "adding properties is not supported. properties are generated bysqlcontainer.",
	"Method": "boolean addItemProperty(Object id,Property property){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.vaadin.server.Page.getBrowserWindowHeight",
	"Comment": "gets the last known height of the browser window in which this uiresides.",
	"Method": "int getBrowserWindowHeight(){\r\n    return browserWindowHeight;\r\n}"
}, {
	"Path": "com.vaadin.server.Page.getPendingDependencies",
	"Comment": "returns all pending dependencies.for internal use only, calling this method will clear the pendingdependencies.",
	"Method": "Collection<Dependency> getPendingDependencies(){\r\n    List<Dependency> copy = new ArrayList();\r\n    if (pendingDependencies != null) {\r\n        copy.addAll(pendingDependencies);\r\n    }\r\n    pendingDependencies = null;\r\n    return copy;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractSplitPanel.setLocked",
	"Comment": "lock the splitpanels position, disabling the user from dragging the splithandle.",
	"Method": "void setLocked(boolean locked){\r\n    getSplitterState().locked = locked;\r\n}"
}, {
	"Path": "com.vaadin.client.communication.StateChangeEvent.addAllStateFields",
	"Comment": "recursively adds the names of all properties in the provided state type.",
	"Method": "void addAllStateFields(com.vaadin.client.metadata.Type type,FastStringSet changedProperties,String context){\r\n    try {\r\n        JsArrayObject<Property> properties = type.getPropertiesAsArray();\r\n        int size = properties.size();\r\n        for (int i = 0; i < size; i++) {\r\n            Property property = properties.get(i);\r\n            String propertyName = context + property.getName();\r\n            changedProperties.add(propertyName);\r\n            com.vaadin.client.metadata.Type propertyType = property.getType();\r\n            if (propertyType.hasProperties()) {\r\n                addAllStateFields(propertyType, changedProperties, propertyName + \".\");\r\n            }\r\n        }\r\n    } catch (NoDataException e) {\r\n        throw new IllegalStateException(\"No property info for \" + type + \". Did you remember to compile the right widgetset?\", e);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.Util.escapeAttribute",
	"Comment": "escapes the string so it is safe to write inside an html attribute.",
	"Method": "String escapeAttribute(String attribute){\r\n    return WidgetUtil.escapeAttribute(attribute);\r\n}"
}, {
	"Path": "com.vaadin.data.validator.RangeValidator.setMinValueIncluded",
	"Comment": "sets whether the minimum value is part of the accepted range.",
	"Method": "void setMinValueIncluded(boolean minValueIncluded){\r\n    this.minValueIncluded = minValueIncluded;\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.setModal",
	"Comment": "sets window modality. when a modal window is open, components outsidethat window cannot be accessed.keyboard navigation is restricted by blocking the tab key at the top andbottom of the window by activating the tab stop function internally.",
	"Method": "void setModal(boolean modal){\r\n    getState().modal = modal;\r\n    center();\r\n}"
}, {
	"Path": "com.ryanharter.viewpager.ViewPager.onRequestFocusInDescendants",
	"Comment": "we only want the current page that is being shown to be focusable.",
	"Method": "boolean onRequestFocusInDescendants(int direction,Rect previouslyFocusedRect){\r\n    int index;\r\n    int increment;\r\n    int end;\r\n    int count = getChildCount();\r\n    if ((direction & FOCUS_FORWARD) != 0) {\r\n        index = 0;\r\n        increment = 1;\r\n        end = count;\r\n    } else {\r\n        index = count - 1;\r\n        increment = -1;\r\n        end = -1;\r\n    }\r\n    for (int i = index; i != end; i += increment) {\r\n        View child = getChildAt(i);\r\n        if (child.getVisibility() == VISIBLE) {\r\n            ItemInfo ii = infoForChild(child);\r\n            if (ii != null && ii.position == mCurItem) {\r\n                if (child.requestFocus(direction, previouslyFocusedRect)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.ryanharter.viewpager.ViewPager.executeKeyEvent",
	"Comment": "you can call this function yourself to have the scroll view performscrolling from a key event, just as if the event had been dispatched toit by the view hierarchy.",
	"Method": "boolean executeKeyEvent(KeyEvent event){\r\n    boolean handled = false;\r\n    if (event.getAction() == KeyEvent.ACTION_DOWN) {\r\n        switch(event.getKeyCode()) {\r\n            case KeyEvent.KEYCODE_DPAD_LEFT:\r\n                if (isOrientationHorizontal())\r\n                    handled = arrowScroll(FOCUS_LEFT);\r\n                break;\r\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\r\n                if (isOrientationHorizontal())\r\n                    handled = arrowScroll(FOCUS_RIGHT);\r\n                break;\r\n            case KeyEvent.KEYCODE_DPAD_UP:\r\n                if (!isOrientationHorizontal())\r\n                    handled = arrowScroll(FOCUS_UP);\r\n                break;\r\n            case KeyEvent.KEYCODE_DPAD_DOWN:\r\n                if (!isOrientationHorizontal())\r\n                    handled = arrowScroll(FOCUS_DOWN);\r\n                break;\r\n            case KeyEvent.KEYCODE_TAB:\r\n                if (Build.VERSION.SDK_INT >= 11) {\r\n                    if (KeyEventCompat.hasNoModifiers(event)) {\r\n                        handled = arrowScroll(FOCUS_FORWARD);\r\n                    } else if (KeyEventCompat.hasModifiers(event, KeyEvent.META_SHIFT_ON)) {\r\n                        handled = arrowScroll(FOCUS_BACKWARD);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return handled;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.menubar.MenuBar.addItem",
	"Comment": "adds a menu item to the bar, that will open the specified menu when it isselected.",
	"Method": "void addItem(MenuItem item,MenuItem addItem,String text,boolean asHTML,Command cmd,MenuItem addItem,String text,boolean asHTML,MenuBar popup,MenuItem addItem,String text,Command cmd,MenuItem addItem,String text,MenuBar popup){\r\n    final MenuItem item = new MenuItem(text, popup);\r\n    addItem(item);\r\n    return item;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTree.getFirstRootNode",
	"Comment": "returns the first root node of the tree or null if there are no rootnodes.",
	"Method": "TreeNode getFirstRootNode(){\r\n    if (body.getWidgetCount() == 0) {\r\n        return null;\r\n    }\r\n    return (TreeNode) body.getWidget(0);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.getNavigationPageDownKey",
	"Comment": "get the key the moves the selection one page down in the table. bydefault this is the page down key but by overriding this you can changethe key to whatever you want.",
	"Method": "int getNavigationPageDownKey(){\r\n    return KeyCodes.KEY_PAGEDOWN;\r\n}"
}, {
	"Path": "com.github.dozermapper.core.MappingProcessor.mapToDestObject",
	"Comment": "this function used to map into created instance of destination class",
	"Method": "void mapToDestObject(ClassMap classMap,Object srcObj,Object destObj,boolean bypassSuperMappings,String mapId){\r\n    Object result = destObj;\r\n    if (javax.xml.bind.JAXBElement.class.isAssignableFrom(destObj.getClass())) {\r\n        classMap = getClassMap(srcObj.getClass(), javax.xml.bind.JAXBElement.class.cast(destObj).getDeclaredType(), mapId);\r\n        result = javax.xml.bind.JAXBElement.class.cast(destObj).getValue();\r\n    }\r\n    map(classMap, srcObj, result, bypassSuperMappings, new ArrayList(), mapId);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.MethodProperty.invokeSetMethod",
	"Comment": "internal method to actually call the setter method of the wrappedproperty.",
	"Method": "void invokeSetMethod(T value){\r\n    try {\r\n        if (setArgs.length == 1) {\r\n            setMethod.invoke(instance, new Object[] { value });\r\n        } else {\r\n            final Object[] args = new Object[setArgs.length];\r\n            for (int i = 0; i < setArgs.length; i++) {\r\n                args[i] = (i == setArgumentIndex) ? value : setArgs[i];\r\n            }\r\n            setMethod.invoke(instance, args);\r\n        }\r\n    } catch (final InvocationTargetException e) {\r\n        final Throwable targetException = e.getTargetException();\r\n        throw new MethodException(this, targetException);\r\n    } catch (final Exception e) {\r\n        throw new MethodException(this, e);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.Link.getTargetName",
	"Comment": "returns the target window name. empty name of null implies that thetarget is opened to the window containing the link.",
	"Method": "String getTargetName(){\r\n    return getState(false).target;\r\n}"
}, {
	"Path": "com.github.dozermapper.core.classmap.ClassMappings.addDefault",
	"Comment": "default mappings. may be ovewritten due to multiple threads generating same mapping",
	"Method": "void addDefault(Class<?> srcClass,Class<?> destClass,ClassMap classMap){\r\n    classMappings.put(keyFactory.createKey(srcClass, destClass), classMap);\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignAttributeHandler.getFormatter",
	"Comment": "returns the currently used formatter. all primitive types and all typesneeded by vaadin components are handled by that formatter.",
	"Method": "DesignFormatter getFormatter(){\r\n    return FORMATTER;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.escalator.ScrollbarBundle.setScrollSize",
	"Comment": "sets the amount of pixels the scrollbar needs to be able to scrollthrough.",
	"Method": "void setScrollSize(double px){\r\n    boolean newScrollSizeIsSmallerThanOffsetSize = px <= getOffsetSize();\r\n    boolean scrollSizeBecomesSmallerThanOffsetSize = showsScrollHandle() && newScrollSizeIsSmallerThanOffsetSize;\r\n    if (scrollSizeBecomesSmallerThanOffsetSize && getScrollPos() != 0) {\r\n        boolean delayedSizeSet = !BrowserInfo.get().isFirefox();\r\n        if (delayedSizeSet) {\r\n            if (scrollSizeTemporaryScrollHandler != null) {\r\n                scrollSizeTemporaryScrollHandler.removeHandler();\r\n            }\r\n            scrollSizeTemporaryScrollHandler = addScrollHandler(new ScrollHandler() {\r\n                @Override\r\n                public void onScroll(ScrollEvent event) {\r\n                    setScrollSizeNow(px);\r\n                }\r\n            });\r\n        }\r\n        setScrollPos(0);\r\n        if (!delayedSizeSet) {\r\n            setScrollSizeNow(px);\r\n        }\r\n    } else {\r\n        setScrollSizeNow(px);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.escalator.ScrollbarBundle.setScrollSize",
	"Comment": "sets the amount of pixels the scrollbar needs to be able to scrollthrough.",
	"Method": "void setScrollSize(double px){\r\n    setScrollSizeNow(px);\r\n}"
}, {
	"Path": "com.vaadin.ui.DateField.getAssistiveText",
	"Comment": "get the description that explains the usage of the widget for users ofassistive devices.",
	"Method": "String getAssistiveText(){\r\n    return getState(false).descriptionForAssistiveDevices;\r\n}"
}, {
	"Path": "com.github.dozermapper.core.DozerConverter.convertFrom",
	"Comment": "converts the source field to the destination field and return the resulting destinationvalue",
	"Method": "A convertFrom(B source,A destination,A convertFrom,B source){\r\n    return convertFrom(source, null);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addFooterClickHandler",
	"Comment": "register a footerclickhandler to this grid. the event for this handler isfired when a click event occurs in the footer of this grid.",
	"Method": "HandlerRegistration addFooterClickHandler(FooterClickHandler handler){\r\n    return addHandler(handler, GridClickEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VMenuBar.getNavigationUpKey",
	"Comment": "get the key that moves the selection upwards. by default it is the uparrow key but by overriding this you can change the key to whatever youwant.",
	"Method": "int getNavigationUpKey(){\r\n    return KeyCodes.KEY_UP;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.setColumnReorderingAllowed",
	"Comment": "sets whether column reordering with drag and drop is allowed or not.",
	"Method": "void setColumnReorderingAllowed(boolean columnReorderingAllowed){\r\n    this.columnReorderingAllowed = columnReorderingAllowed;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractMedia.setSources",
	"Comment": "set multiple sources at once. which of the sources is used is selected bythe browser depending on which file formats it supports. seewikipediafor a table of formats supported by different browsers.",
	"Method": "void setSources(Resource sources){\r\n    clearSources();\r\n    for (Resource source : sources) {\r\n        addSource(source);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VDragAndDropWrapper.startDrag",
	"Comment": "starts a drag and drop operation from mousedown or touchstart event ifrequired conditions are met.",
	"Method": "boolean startDrag(NativeEvent event){\r\n    if (dragStartMode == WRAPPER || dragStartMode == COMPONENT || dragStartMode == COMPONENT_OTHER) {\r\n        VTransferable transferable = new VTransferable();\r\n        transferable.setDragSource(getConnector());\r\n        ComponentConnector paintable = Util.findPaintable(client, Element.as(event.getEventTarget()));\r\n        Widget widget = paintable.getWidget();\r\n        transferable.setData(\"component\", paintable);\r\n        VDragEvent dragEvent = VDragAndDropManager.get().startDrag(transferable, event, true);\r\n        transferable.setData(\"mouseDown\", MouseEventDetailsBuilder.buildMouseEventDetails(event).serialize());\r\n        if (dragStartMode == WRAPPER) {\r\n            dragEvent.createDragImage(getElement(), true);\r\n        } else if (dragStartMode == COMPONENT_OTHER && getDragImageWidget() != null) {\r\n            dragEvent.createDragImage(getDragImageWidget().getElement(), true);\r\n        } else {\r\n            dragEvent.createDragImage(widget.getElement(), true);\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.removeAllItems",
	"Comment": "removes all items from the container.this functionality is optional. if the function is unsupported, it alwaysreturns false.",
	"Method": "boolean removeAllItems(){\r\n    final boolean retval = items.removeAllItems();\r\n    itemIdMapper.removeAll();\r\n    if (retval) {\r\n        setValue(null);\r\n        if (!(items instanceof Container.ItemSetChangeNotifier)) {\r\n            fireItemSetChange();\r\n        }\r\n    }\r\n    return retval;\r\n}"
}, {
	"Path": "org.greenrobot.essentials.io.CircularByteBuffer.skip",
	"Comment": "skips the given count of bytes, but at most the currently available count.",
	"Method": "int skip(int count){\r\n    if (count > available) {\r\n        count = available;\r\n    }\r\n    idxGet = (idxGet + count) % capacity;\r\n    available -= count;\r\n    return count;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.instructServerToForgetPreviousSelections",
	"Comment": "used in multiselect mode when the client side knows that all selectionsare in the next request.",
	"Method": "void instructServerToForgetPreviousSelections(){\r\n    client.updateVariable(paintableId, \"clearSelections\", true, false);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.setTimeChangeListener",
	"Comment": "the time change listener is triggered when the user changes the time.",
	"Method": "void setTimeChangeListener(TimeChangeListener listener){\r\n    timeChangeListener = listener;\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConnection.createAndRegisterConnector",
	"Comment": "creates a new serverconnector with the given type and id.creates and registers a new serverconnector of the given type. shouldnever be called with the connector id of an existing connector.",
	"Method": "ServerConnector createAndRegisterConnector(String connectorId,int connectorType){\r\n    Profiler.enter(\"ApplicationConnection.createAndRegisterConnector\");\r\n    ServerConnector p = widgetSet.createConnector(connectorType, configuration);\r\n    connectorMap.registerConnector(connectorId, p);\r\n    p.doInit(connectorId, this);\r\n    Profiler.leave(\"ApplicationConnection.createAndRegisterConnector\");\r\n    return p;\r\n}"
}, {
	"Path": "com.vaadin.v7.tests.server.component.table.MultipleSelectionTest.testSetMultipleItems",
	"Comment": "tests weather the multiple select mode is set when using table.set",
	"Method": "void testSetMultipleItems(){\r\n    Table table = new Table(\"\", createTestContainer());\r\n    table.setMultiSelect(true);\r\n    assertTrue(table.isMultiSelect());\r\n    table.setValue(Arrays.asList(\"1\", new String[] { \"3\" }));\r\n    assertEquals(2, ((Set<String>) table.getValue()).size());\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.BeanContainer.setBeanIdProperty",
	"Comment": "sets the bean id resolver to use a property of the beans as theidentifier.",
	"Method": "void setBeanIdProperty(Object propertyId){\r\n    setBeanIdResolver(createBeanPropertyResolver(propertyId));\r\n}"
}, {
	"Path": "com.vaadin.tools.CvalAddonsChecker.run",
	"Comment": "visit all manifest.mf files in the classpath validating licenses.return a list of cval licensed products in order to have enough info togenerate nag messages in the ui.",
	"Method": "List<CValUiInfo> run(){\r\n    List<CValUiInfo> ret = new ArrayList();\r\n    try {\r\n        Enumeration<URL> manifests = Thread.currentThread().getContextClassLoader().getResources(JarFile.MANIFEST_NAME);\r\n        while (manifests.hasMoreElements()) {\r\n            try {\r\n                URL url = manifests.nextElement();\r\n                if (!url.getPath().matches(filterPattern)) {\r\n                    continue;\r\n                }\r\n                InputStream is = url.openStream();\r\n                if (is == null) {\r\n                    continue;\r\n                }\r\n                Manifest manifest = new Manifest(is);\r\n                Attributes attribs = manifest.getMainAttributes();\r\n                String license = attribs.getValue(VAADIN_ADDON_LICENSE);\r\n                String name = attribs.getValue(VAADIN_ADDON_NAME);\r\n                String vers = attribs.getValue(VAADIN_ADDON_VERSION) == null ? \"\" : attribs.getValue(VAADIN_ADDON_VERSION);\r\n                String title = attribs.getValue(VAADIN_ADDON_TITLE) == null ? name : attribs.getValue(VAADIN_ADDON_TITLE);\r\n                String widgetsets = attribs.getValue(VAADIN_ADDON_WIDGETSET) == null ? name : attribs.getValue(VAADIN_ADDON_WIDGETSET);\r\n                if (name == null || license == null) {\r\n                    continue;\r\n                }\r\n                if (VAADIN_AGPL.equals(license)) {\r\n                    printAgplLicense(title, vers);\r\n                } else if (VAADIN_CVAL.equals(license)) {\r\n                    CvalInfo info;\r\n                    try {\r\n                        info = cvalChecker.validateProduct(name, vers, title);\r\n                        printValidLicense(info, title, vers);\r\n                    } catch (UnreachableCvalServerException e) {\r\n                        info = CvalChecker.parseJson(\"{'product':{'name':'\" + name + \"'}}\");\r\n                        printServerUnreachable(title, vers);\r\n                    }\r\n                    for (String w : widgetsets.split(\"[, ]+\")) {\r\n                        ret.add(new CValUiInfo(title, String.valueOf(computeMajorVersion(vers)), w, info.getType()));\r\n                    }\r\n                }\r\n            } catch (IOException ignored) {\r\n            }\r\n        }\r\n    } catch (IOException ignored) {\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.vaadin.server.BootstrapHandler.setupMainDiv",
	"Comment": "method to write the div element into which that actual vaadin applicationis rendered.override this method if you want to add some custom html around aroundthe div element into which the actual vaadin application will berendered.",
	"Method": "void setupMainDiv(BootstrapContext context){\r\n    String style = getMainDivStyle(context);\r\n    List<Node> fragmentNodes = context.getBootstrapResponse().getFragmentNodes();\r\n    Element mainDiv = new Element(Tag.valueOf(\"div\"), \"\");\r\n    mainDiv.attr(\"id\", context.getAppId());\r\n    mainDiv.addClass(\"v-app\");\r\n    mainDiv.addClass(context.getThemeName());\r\n    mainDiv.addClass(context.getUIClass().getSimpleName().toLowerCase(Locale.ROOT));\r\n    if (style != null && !style.isEmpty()) {\r\n        mainDiv.attr(\"style\", style);\r\n    }\r\n    mainDiv.appendElement(\"div\").addClass(\"v-app-loading\");\r\n    mainDiv.appendElement(\"noscript\").append(\"You have to enable javascript in your browser to use an application built with Vaadin.\");\r\n    fragmentNodes.add(mainDiv);\r\n    VaadinRequest request = context.getRequest();\r\n    VaadinService vaadinService = request.getService();\r\n    String vaadinLocation = vaadinService.getStaticFileLocation(request) + \"/VAADIN/\";\r\n    String versionQueryParam = \"?v=\" + Version.getFullVersion();\r\n    if (context.getPushMode().isEnabled()) {\r\n        String pushJS = vaadinLocation;\r\n        if (context.getRequest().getService().getDeploymentConfiguration().isProductionMode()) {\r\n            pushJS += ApplicationConstants.VAADIN_PUSH_JS;\r\n        } else {\r\n            pushJS += ApplicationConstants.VAADIN_PUSH_DEBUG_JS;\r\n        }\r\n        pushJS += versionQueryParam;\r\n        fragmentNodes.add(new Element(Tag.valueOf(\"script\"), \"\").attr(\"type\", \"text/javascript\").attr(\"src\", pushJS));\r\n    }\r\n    String bootstrapLocation = vaadinLocation + ApplicationConstants.VAADIN_BOOTSTRAP_JS + versionQueryParam;\r\n    fragmentNodes.add(new Element(Tag.valueOf(\"script\"), \"\").attr(\"type\", \"text/javascript\").attr(\"src\", bootstrapLocation));\r\n    Element mainScriptTag = new Element(Tag.valueOf(\"script\"), \"\").attr(\"type\", \"text/javascript\");\r\n    StringBuilder builder = new StringBuilder();\r\n    builder.append(\"//<![CDATA[\\n\");\r\n    builder.append(\"if (!window.vaadin) alert(\" + JsonUtil.quote(\"Failed to load the bootstrap javascript: \" + bootstrapLocation) + \");\\n\");\r\n    appendMainScriptTagContents(context, builder);\r\n    builder.append(\"//]]>\");\r\n    mainScriptTag.appendChild(new DataNode(builder.toString(), mainScriptTag.baseUri()));\r\n    fragmentNodes.add(mainScriptTag);\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.setLastRequestTimestamp",
	"Comment": "sets the time when the last uidl request was serviced in this session.",
	"Method": "void setLastRequestTimestamp(long timestamp){\r\n    assert hasLock();\r\n    lastRequestTimestamp = timestamp;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.getResetKey",
	"Comment": "returns the reset key which will reset the calendar to the previousselection. by default this is backspace but it can be overridden tochange the key to whatever you want.",
	"Method": "int getResetKey(){\r\n    return KeyCodes.KEY_BACKSPACE;\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridMultiSelect.addMultiSelectionListener",
	"Comment": "adds a selection listener that will be called when the selection ischanged either by the user or programmatically.",
	"Method": "Registration addMultiSelectionListener(MultiSelectionListener<T> listener){\r\n    return model.addMultiSelectionListener(listener);\r\n}"
}, {
	"Path": "com.vaadin.client.WidgetUtil.mayHaveScrollBars",
	"Comment": "detects what is currently the overflow style attribute in given element.",
	"Method": "boolean mayHaveScrollBars(com.google.gwt.dom.client.Element pe){\r\n    String overflow = getComputedStyle(pe, \"overflow\");\r\n    if (overflow != null) {\r\n        return overflow.equals(\"auto\") || overflow.equals(\"scroll\");\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponentContainer.fireComponentAttachEvent",
	"Comment": "fires the component attached event. this should be called by theaddcomponent methods after the component have been added to thiscontainer.",
	"Method": "void fireComponentAttachEvent(Component component){\r\n    fireEvent(new ComponentAttachEvent(this, component));\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Tree.getItemDescriptionGenerator",
	"Comment": "get the item description generator which generates tooltips for treeitems.",
	"Method": "ItemDescriptionGenerator getItemDescriptionGenerator(){\r\n    return itemDescriptionGenerator;\r\n}"
}, {
	"Path": "com.vaadin.client.LayoutManager.getMeasuredSize",
	"Comment": "gets the measured size for an element. method defined as protected forlegacy reasons.",
	"Method": "MeasuredSize getMeasuredSize(Element element,MeasuredSize defaultSize,MeasuredSize getMeasuredSize,Element element){\r\n    MeasuredSize measuredSize = getMeasuredSize(element, null);\r\n    if (measuredSize == null) {\r\n        measuredSize = new MeasuredSize();\r\n        setMeasuredSize(element, measuredSize);\r\n    }\r\n    return measuredSize;\r\n}"
}, {
	"Path": "com.vaadin.tests.server.component.absolutelayout.ComponentPositionTest.testFullCss",
	"Comment": "add component, setting all attributes using css, assert getter agree",
	"Method": "void testFullCss(){\r\n    AbsoluteLayout layout = new AbsoluteLayout();\r\n    Button b = new Button();\r\n    layout.addComponent(b, CSS);\r\n    assertEquals(CSS_VALUE, layout.getPosition(b).getTopValue());\r\n    assertEquals(CSS_VALUE, layout.getPosition(b).getBottomValue());\r\n    assertEquals(CSS_VALUE, layout.getPosition(b).getLeftValue());\r\n    assertEquals(CSS_VALUE, layout.getPosition(b).getRightValue());\r\n    assertEquals(Sizeable.Unit.PIXELS, layout.getPosition(b).getTopUnits());\r\n    assertEquals(Sizeable.Unit.PICAS, layout.getPosition(b).getBottomUnits());\r\n    assertEquals(Sizeable.Unit.EM, layout.getPosition(b).getLeftUnits());\r\n    assertEquals(Sizeable.Unit.PERCENTAGE, layout.getPosition(b).getRightUnits());\r\n    assertEquals(7, layout.getPosition(b).getZIndex());\r\n    assertEquals(CSS, layout.getPosition(b).getCSSString());\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.setAssistivePrefix",
	"Comment": "sets the accessibility prefix for the window caption.this prefix is read to assistive device users before the window caption,but not visible on the page.",
	"Method": "void setAssistivePrefix(String prefix){\r\n    getState().assistivePrefix = prefix;\r\n}"
}, {
	"Path": "com.vaadin.client.widget.escalator.ScrollbarBundle.setScrollSize",
	"Comment": "sets the amount of pixels the scrollbar needs to be able to scrollthrough.",
	"Method": "void setScrollSize(double px){\r\n    boolean newScrollSizeIsSmallerThanOffsetSize = px <= getOffsetSize();\r\n    boolean scrollSizeBecomesSmallerThanOffsetSize = showsScrollHandle() && newScrollSizeIsSmallerThanOffsetSize;\r\n    if (scrollSizeBecomesSmallerThanOffsetSize && getScrollPos() != 0) {\r\n        boolean delayedSizeSet = !BrowserInfo.get().isFirefox();\r\n        if (delayedSizeSet) {\r\n            if (scrollSizeTemporaryScrollHandler != null) {\r\n                scrollSizeTemporaryScrollHandler.removeHandler();\r\n            }\r\n            scrollSizeTemporaryScrollHandler = addScrollHandler(event -> setScrollSizeNow(px));\r\n        }\r\n        setScrollPos(0);\r\n        if (!delayedSizeSet) {\r\n            setScrollSizeNow(px);\r\n        }\r\n    } else {\r\n        setScrollSizeNow(px);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.WrappedPortletSession.getAttribute",
	"Comment": "returns the object bound with the specified name in this session, ornull if no object is bound under the name in the givenscope.",
	"Method": "Object getAttribute(String name,Object getAttribute,String name,int scope){\r\n    return session.getAttribute(name, scope);\r\n}"
}, {
	"Path": "com.vaadin.server.Page.removeUriFragmentChangedListener",
	"Comment": "removes a uri fragment listener that was previously added to this page.",
	"Method": "void removeUriFragmentChangedListener(Page.UriFragmentChangedListener listener){\r\n    removeListener(UriFragmentChangedEvent.class, listener, URI_FRAGMENT_CHANGED_METHOD);\r\n}"
}, {
	"Path": "com.vaadin.client.communication.MessageHandler.handleMessage",
	"Comment": "handles a received uidl json text, parsing it, and passing it on to theappropriate handlers, while logging timing information.",
	"Method": "void handleMessage(ValueMap json){\r\n    if (json == null) {\r\n        throw new IllegalArgumentException(\"The json to handle cannot be null\");\r\n    }\r\n    if (getServerId(json) == -1) {\r\n        getLogger().severe(\"Response didn't contain a server id. \" + \"Please verify that the server is up-to-date and that the response data has not been modified in transmission.\");\r\n    }\r\n    if (connection.getApplicationState() == ApplicationState.RUNNING) {\r\n        handleJSON(json);\r\n    } else if (connection.getApplicationState() == ApplicationState.INITIALIZING) {\r\n        connection.setApplicationRunning(true);\r\n        connection.executeWhenCSSLoaded(() -> handleJSON(json));\r\n    } else {\r\n        getLogger().warning(\"Ignored received message because application has already been stopped\");\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.grid.sort.SortOrder.getOpposite",
	"Comment": "returns a new sortorder object with the sort direction reversed.",
	"Method": "SortOrder getOpposite(){\r\n    return new SortOrder(column, direction.getOpposite());\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.setAllowNewItems",
	"Comment": "sets whether creation of new items when there is no match is allowed ornot.",
	"Method": "void setAllowNewItems(boolean allowNewItems){\r\n    this.allowNewItems = allowNewItems;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.dd.DragAndDropHandler.onDragStartOnDraggableElement",
	"Comment": "this method can be called to trigger drag and drop on any grid elementthat can be dragged and dropped.",
	"Method": "void onDragStartOnDraggableElement(NativeEvent dragStartingEvent,DragAndDropCallback callback){\r\n    startPreviewHandler = Event.addNativePreviewHandler(new NativePreviewHandler() {\r\n        private int startX = WidgetUtil.getTouchOrMouseClientX(dragStartingEvent);\r\n        private int startY = WidgetUtil.getTouchOrMouseClientY(dragStartingEvent);\r\n        @Override\r\n        public void onPreviewNativeEvent(NativePreviewEvent event) {\r\n            final int typeInt = event.getTypeInt();\r\n            if (typeInt == -1 && event.getNativeEvent().getType().toLowerCase(Locale.ROOT).contains(\"pointer\")) {\r\n                return;\r\n            }\r\n            switch(typeInt) {\r\n                case Event.ONMOUSEOVER:\r\n                case Event.ONMOUSEOUT:\r\n                    break;\r\n                case Event.ONKEYDOWN:\r\n                case Event.ONKEYPRESS:\r\n                case Event.ONKEYUP:\r\n                case Event.ONBLUR:\r\n                case Event.ONFOCUS:\r\n                    break;\r\n                case Event.ONMOUSEMOVE:\r\n                case Event.ONTOUCHMOVE:\r\n                    int currentX = WidgetUtil.getTouchOrMouseClientX(event.getNativeEvent());\r\n                    int currentY = WidgetUtil.getTouchOrMouseClientY(event.getNativeEvent());\r\n                    if (Math.abs(startX - currentX) > 3 || Math.abs(startY - currentY) > 3) {\r\n                        removeStartPreviewHandler();\r\n                        startDrag(dragStartingEvent, event, callback);\r\n                    }\r\n                    event.getNativeEvent().stopPropagation();\r\n                    event.getNativeEvent().preventDefault();\r\n                    event.cancel();\r\n                    break;\r\n                default:\r\n                    removeStartPreviewHandler();\r\n                    break;\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.vaadin.client.ui.dd.DragAndDropHandler.onDragStartOnDraggableElement",
	"Comment": "this method can be called to trigger drag and drop on any grid elementthat can be dragged and dropped.",
	"Method": "void onDragStartOnDraggableElement(NativeEvent dragStartingEvent,DragAndDropCallback callback){\r\n    final int typeInt = event.getTypeInt();\r\n    if (typeInt == -1 && event.getNativeEvent().getType().toLowerCase(Locale.ROOT).contains(\"pointer\")) {\r\n        return;\r\n    }\r\n    switch(typeInt) {\r\n        case Event.ONMOUSEOVER:\r\n        case Event.ONMOUSEOUT:\r\n            break;\r\n        case Event.ONKEYDOWN:\r\n        case Event.ONKEYPRESS:\r\n        case Event.ONKEYUP:\r\n        case Event.ONBLUR:\r\n        case Event.ONFOCUS:\r\n            break;\r\n        case Event.ONMOUSEMOVE:\r\n        case Event.ONTOUCHMOVE:\r\n            int currentX = WidgetUtil.getTouchOrMouseClientX(event.getNativeEvent());\r\n            int currentY = WidgetUtil.getTouchOrMouseClientY(event.getNativeEvent());\r\n            if (Math.abs(startX - currentX) > 3 || Math.abs(startY - currentY) > 3) {\r\n                removeStartPreviewHandler();\r\n                startDrag(dragStartingEvent, event, callback);\r\n            }\r\n            event.getNativeEvent().stopPropagation();\r\n            event.getNativeEvent().preventDefault();\r\n            event.cancel();\r\n            break;\r\n        default:\r\n            removeStartPreviewHandler();\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.removeRowFromUnsentSelectionRanges",
	"Comment": "removes a key from a range if the key is found in a selected range",
	"Method": "void removeRowFromUnsentSelectionRanges(VScrollTableRow row){\r\n    Collection<SelectionRange> newRanges = null;\r\n    for (Iterator<SelectionRange> iterator = selectedRowRanges.iterator(); iterator.hasNext(); ) {\r\n        SelectionRange range = iterator.next();\r\n        if (range.inRange(row)) {\r\n            Collection<SelectionRange> splitranges = range.split(row);\r\n            if (newRanges == null) {\r\n                newRanges = new ArrayList<SelectionRange>();\r\n            }\r\n            newRanges.addAll(splitranges);\r\n            iterator.remove();\r\n        }\r\n    }\r\n    if (newRanges != null) {\r\n        selectedRowRanges.addAll(newRanges);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Label.getConverter",
	"Comment": "gets the converter used to convert the property data source value to thelabel value.",
	"Method": "Converter<String, Object> getConverter(){\r\n    return converter;\r\n}"
}, {
	"Path": "com.vaadin.client.UIDL.getChildByTagName",
	"Comment": "returns the child uidl by its name. if several child nodes exist with thegiven name, the first child uidl will be returned.",
	"Method": "UIDL getChildByTagName(String tagName){\r\n    for (Object next : this) {\r\n        if (next instanceof UIDL) {\r\n            UIDL childUIDL = (UIDL) next;\r\n            if (childUIDL.getTag().equals(tagName)) {\r\n                return childUIDL;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.resetSizesFromDom",
	"Comment": "resets all cached pixel sizes and reads new values from the dom. thismethods should be used e.g. when styles affecting the dimensions ofelements in this grid have been changed.",
	"Method": "void resetSizesFromDom(){\r\n    getEscalator().resetSizesFromDom();\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.DropIndexCalculator.alwaysDropToEnd",
	"Comment": "returns a calculator for always dropping items to the end of the targetgrid, regardless of drop position.",
	"Method": "DropIndexCalculator<T> alwaysDropToEnd(){\r\n    return (GridDropEvent<T> event) -> Integer.MAX_VALUE;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.BeanItemContainer.addItem",
	"Comment": "adds the bean to the container.the bean is used both as the item contents and as the item identifier.",
	"Method": "BeanItem<BEANTYPE> addItem(Object itemId){\r\n    return super.addBean((BEANTYPE) itemId);\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignAttributeHandler.writeAlignment",
	"Comment": "writes the alignment to the given child element attributes.",
	"Method": "void writeAlignment(Element childElement,Alignment alignment){\r\n    if (alignment.isMiddle()) {\r\n        childElement.attr(\":middle\", true);\r\n    } else if (alignment.isBottom()) {\r\n        childElement.attr(\":bottom\", true);\r\n    }\r\n    if (alignment.isCenter()) {\r\n        childElement.attr(\":center\", true);\r\n    } else if (alignment.isRight()) {\r\n        childElement.attr(\":right\", true);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.validator.AbstractValidator.getErrorMessage",
	"Comment": "returns the message to be included in the exception in case the valuedoes not validate.",
	"Method": "String getErrorMessage(){\r\n    return errorMessage;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.connectors.AbstractGridRendererConnector.getRowKey",
	"Comment": "gets the row key for a row object.in case this renderer wants be able to identify a row in such a way thatthe server also understands it, the row key is used for that. rows areidentified by unified keys between the client and the server.",
	"Method": "String getRowKey(JsonObject row){\r\n    final ServerConnector parent = getParent();\r\n    if (parent instanceof GridConnector) {\r\n        return ((GridConnector) parent).getRowKey(row);\r\n    } else {\r\n        throw new IllegalStateException(\"Renderers can only be used \" + \"with a Grid.\");\r\n    }\r\n}"
}, {
	"Path": "org.greenrobot.essentials.hash.otherhashes.MurmurHash2b.hash32",
	"Comment": "generates 32 bit hash from byte array with default seed value.",
	"Method": "int hash32(byte[] data,int offset,int len){\r\n    return MurmurHash2b.hash(data, 0x9747b28c, offset, len);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractTextField.setCursorPosition",
	"Comment": "sets the cursor position in the field. as a side effect the field willbecome focused.",
	"Method": "void setCursorPosition(int pos){\r\n    setSelectionRange(pos, 0);\r\n    lastKnownCursorPosition = pos;\r\n}"
}, {
	"Path": "com.vaadin.server.communication.JSR356WebsocketInitializer.isVaadinServlet",
	"Comment": "tries to determine if the given servlet registration refers to a vaadinservlet.",
	"Method": "boolean isVaadinServlet(ServletRegistration servletRegistration,ServletContext servletContext){\r\n    try {\r\n        String servletClassName = servletRegistration.getClassName();\r\n        if (servletClassName.equals(\"com.ibm.ws.wsoc.WsocServlet\")) {\r\n            return false;\r\n        }\r\n        Class<?> servletClass = servletContext.getClassLoader().loadClass(servletClassName);\r\n        return VaadinServlet.class.isAssignableFrom(servletClass);\r\n    } catch (Exception e) {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractField.getConverter",
	"Comment": "gets the converter used to convert the property data source value to thefield value.",
	"Method": "Converter<T, Object> getConverter(){\r\n    return converter;\r\n}"
}, {
	"Path": "com.vaadin.ui.Flash.setParameter",
	"Comment": "sets an object parameter. parameters are optional information, and theyare passed to the instantiated object. parameters are are stored as namevalue pairs. this overrides the previous value assigned to thisparameter.",
	"Method": "void setParameter(String name,String value){\r\n    if (getState().embedParams == null) {\r\n        getState().embedParams = new HashMap();\r\n    }\r\n    getState().embedParams.put(name, value);\r\n    requestRepaint();\r\n}"
}, {
	"Path": "com.vaadin.ui.Embedded.getParameter",
	"Comment": "gets the value of an object parameter. parameters are optionalinformation, and they are passed to the instantiated object. parametersare are stored as name value pairs.",
	"Method": "String getParameter(String name){\r\n    return getState(false).parameters.get(name);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.setRangeEnd",
	"Comment": "sets the end range for this component. the end range is inclusive, and itdepends on the current resolution, what is considered inside the range.",
	"Method": "void setRangeEnd(String newRangeEnd){\r\n    if (!SharedUtil.equals(rangeEnd, newRangeEnd)) {\r\n        rangeEnd = newRangeEnd;\r\n        if (initialRenderDone) {\r\n            renderCalendar();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.createHeaderUpdater",
	"Comment": "creates the escalator updater used to update the header rows in thisgrid. the updater is invoked when header rows or columns are added orremoved, or the content of existing header cells is changed.",
	"Method": "EscalatorUpdater createHeaderUpdater(){\r\n    return new StaticSectionUpdater(header, escalator.getHeader());\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VMenuBar.getSelected",
	"Comment": "returns the currently selected item of this menu, or null if nothing isselected.",
	"Method": "CustomMenuItem getSelected(){\r\n    return selected;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.getVisibleItemIds",
	"Comment": "gets the visible item ids. in select, this returns list of all item ids,but can be overridden in subclasses if they paint only part of the itemsto the terminal or null if no items is visible.",
	"Method": "Collection<?> getVisibleItemIds(){\r\n    return getItemIds();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheetBase.setEnabled",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setEnabled(boolean enabled){\r\n    disabled = !enabled;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.schedule.CalendarEvent.getCaption",
	"Comment": "get the caption of the event. the caption is the text displayed in thecalendar on the event.",
	"Method": "String getCaption(){\r\n    return caption;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VSlider.getNavigationUpKey",
	"Comment": "get the key that increases the vertical slider. by default it is the uparrow key but by overriding this you can change the key to whatever youwant.",
	"Method": "int getNavigationUpKey(){\r\n    return KeyCodes.KEY_UP;\r\n}"
}, {
	"Path": "com.vaadin.server.StreamResource.setCacheTime",
	"Comment": "sets the length of cache expiration time.this gives the adapter the possibility cache streams sent to the client.the caching may be made in adapter or at the client if the clientsupports caching. zero or negative value disables the caching of thisstream.",
	"Method": "void setCacheTime(long cacheTime){\r\n    this.cacheTime = cacheTime;\r\n}"
}, {
	"Path": "com.vaadin.server.TestAbstractApplicationServletStaticFilesLocation.createRequest",
	"Comment": "creates a httpservletrequest mock using the supplied parameters.",
	"Method": "HttpServletRequest createRequest(String base,String contextPath,String servletPath,String pathInfo){\r\n    URL url = new URL(base + contextPath + pathInfo);\r\n    HttpServletRequest request = createMock(HttpServletRequest.class);\r\n    expect(request.isSecure()).andReturn(url.getProtocol().equalsIgnoreCase(\"https\")).anyTimes();\r\n    expect(request.getServerName()).andReturn(url.getHost()).anyTimes();\r\n    expect(request.getServerPort()).andReturn(url.getPort()).anyTimes();\r\n    expect(request.getRequestURI()).andReturn(url.getPath()).anyTimes();\r\n    expect(request.getContextPath()).andReturn(contextPath).anyTimes();\r\n    expect(request.getPathInfo()).andReturn(pathInfo).anyTimes();\r\n    expect(request.getServletPath()).andReturn(servletPath).anyTimes();\r\n    return request;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VPanel.makeScrollable",
	"Comment": "ensures the panel is scrollable e.g. after style name changes.for internal use only. may be removed or replaced in the future.",
	"Method": "void makeScrollable(){\r\n    if (touchScrollHandler == null) {\r\n        touchScrollHandler = TouchScrollDelegate.enableTouchScrolling(this);\r\n    }\r\n    touchScrollHandler.addElement(contentNode);\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.setState",
	"Comment": "sets the lifecycle state of this session. the allowed transitions areopen to closing and closing to closed.",
	"Method": "void setState(State state){\r\n    assert hasLock();\r\n    assert this.state.isValidChange(state) : \"Invalid session state change \" + this.state + \"->\" + state;\r\n    this.state = state;\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.getAssistivePrefix",
	"Comment": "gets the accessibility prefix for the window caption.this prefix is read to assistive device users before the window caption,but not visible on the page.",
	"Method": "String getAssistivePrefix(){\r\n    return getState(false).assistivePrefix;\r\n}"
}, {
	"Path": "com.vaadin.server.communication.UIInitHandler.getInitialUidl",
	"Comment": "generates the initial uidl message that can e.g. be included in a htmlpage to avoid a separate round trip just for getting the uidl.",
	"Method": "String getInitialUidl(VaadinRequest request,UI uI){\r\n    try (StringWriter writer = new StringWriter()) {\r\n        writer.write(\"{\");\r\n        VaadinSession session = uI.getSession();\r\n        if (session.getConfiguration().isXsrfProtectionEnabled()) {\r\n            writer.write(getSecurityKeyUIDL(session));\r\n        }\r\n        writer.write(getPushIdUIDL(session));\r\n        new UidlWriter().write(uI, writer, false);\r\n        writer.write(\"}\");\r\n        String initialUIDL = writer.toString();\r\n        getLogger().log(Level.FINE, \"Initial UIDL:\" + initialUIDL);\r\n        return initialUIDL;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConfiguration.startApplication",
	"Comment": "starts the application with a given id by reading the configurationoptions stored by the bootstrap javascript.",
	"Method": "void startApplication(String applicationId){\r\n    Scheduler.get().scheduleDeferred(() -> {\r\n        Profiler.enter(\"ApplicationConfiguration.startApplication\");\r\n        ApplicationConfiguration appConf = getConfigFromDOM(applicationId);\r\n        ApplicationConnection a = GWT.create(ApplicationConnection.class);\r\n        a.init(widgetSet, appConf);\r\n        runningApplications.add(a);\r\n        Profiler.leave(\"ApplicationConfiguration.startApplication\");\r\n        a.start();\r\n    });\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.schedule.dd.CalendarMonthDropHandler.deEmphasis",
	"Comment": "removed the emphasis css style name from the currently emphasized day",
	"Method": "void deEmphasis(){\r\n    if (currentTargetElement != null && currentTargetDay != null) {\r\n        currentTargetDay.removeEmphasisStyle();\r\n        currentTargetElement = null;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.getCurrentRequest",
	"Comment": "gets the currently processed vaadin request. the current request isautomatically defined when the request is started. the current requestcan not be used in e.g. background threads because of the way serverimplementations reuse request instances.",
	"Method": "VaadinRequest getCurrentRequest(){\r\n    return VaadinRequest.getCurrent();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addHeaderClickHandler",
	"Comment": "register a headerclickhandler to this grid. the event for this handler isfired when a click event occurs in the header of this grid.",
	"Method": "HandlerRegistration addHeaderClickHandler(HeaderClickHandler handler){\r\n    return addHandler(handler, GridClickEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.optiongroup.CheckBoxGroupConnector.isRequiredIndicatorVisible",
	"Comment": "todo remove once this extends abstractmultiselectconnector",
	"Method": "boolean isRequiredIndicatorVisible(){\r\n    return getState().required && !isReadOnly();\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractSplitPanel.getSecondComponent",
	"Comment": "gets the second component of this split panel. depending on the directionthis is either the component shown at the top or to the left.",
	"Method": "Component getSecondComponent(){\r\n    return (Component) getState(false).secondChild;\r\n}"
}, {
	"Path": "bt.runtime.BtRuntimeBuilder.disableAutomaticShutdown",
	"Comment": "disable automatic runtime shutdown, when all clients have been stopped.",
	"Method": "BtRuntimeBuilder disableAutomaticShutdown(){\r\n    this.shouldDisableAutomaticShutdown = true;\r\n    return this;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.setEditorFieldGroup",
	"Comment": "sets the field group that is backing the item editor of this grid.",
	"Method": "void setEditorFieldGroup(FieldGroup fieldGroup){\r\n    if (isEditorActive()) {\r\n        throw new IllegalStateException(\"Cannot change field group while an item (\" + getEditedItemId() + \") is being edited\");\r\n    }\r\n    editorFieldGroup = fieldGroup;\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridDropTarget.isDropAllowedOnRowsWhenSorted",
	"Comment": "gets whether drops are allowed on rows as target, when the user hassorted the grid.",
	"Method": "boolean isDropAllowedOnRowsWhenSorted(){\r\n    return dropAllowedOnRowsWhenSorted;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.fireRangeSelect",
	"Comment": "fires an event range selected event. the event is fired when a userhighlights an area in the calendar. the highlighted areas start and enddates are returned as arguments.",
	"Method": "void fireRangeSelect(Date from,Date to,boolean monthlyMode){\r\n    fireEvent(new RangeSelectEvent(this, from, to, monthlyMode));\r\n}"
}, {
	"Path": "com.vaadin.client.LayoutManager.getConnection",
	"Comment": "returns the application connection for this layout manager.",
	"Method": "ApplicationConnection getConnection(){\r\n    return connection;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.getRequestHandlers",
	"Comment": "returns the request handlers that are registered with this service. theiteration order of the returned collection is the same as the order inwhich the request handlers will be invoked when a request is handled.",
	"Method": "Iterable<RequestHandler> getRequestHandlers(){\r\n    return requestHandlers;\r\n}"
}, {
	"Path": "com.vaadin.ui.Component.removeStyleNames",
	"Comment": "removes one or more style names from component. multiple styles can bespecified by using multiple parameters.",
	"Method": "void removeStyleNames(String styles){\r\n    for (String style : styles) {\r\n        removeStyleName(style);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.Page.getBrowserWindowWidth",
	"Comment": "gets the last known width of the browser window in which this ui resides.",
	"Method": "int getBrowserWindowWidth(){\r\n    return browserWindowWidth;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VUpload.disableTitle",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void disableTitle(boolean disable){\r\n    if (disable) {\r\n        if (BrowserInfo.get().isChrome()) {\r\n            fu.setTitle(\" \");\r\n        } else if (BrowserInfo.get().isFirefox()) {\r\n            fu.getElement().setAttribute(\"title\", \"\");\r\n        }\r\n    } else {\r\n        fu.setTitle(null);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.HierarchicalContainer.addFilteredChildrenRecursively",
	"Comment": "recursively adds all items in the includeditems list to thefilteredchildren map in the same order as they are in the children map.starts from parentitemid and recurses down as long as child items thatshould be included are found.",
	"Method": "void addFilteredChildrenRecursively(Object parentItemId,HashSet<Object> includedItems){\r\n    LinkedList<Object> childList = children.get(parentItemId);\r\n    if (childList == null) {\r\n        return;\r\n    }\r\n    for (Object childItemId : childList) {\r\n        if (includedItems.contains(childItemId)) {\r\n            addFilteredChild(parentItemId, childItemId);\r\n            addFilteredChildrenRecursively(childItemId, includedItems);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Tree.getChildren",
	"Comment": "gets the ids of all items that are children of the specified item.",
	"Method": "Collection<?> getChildren(Object itemId){\r\n    return ((Container.Hierarchical) items).getChildren(itemId);\r\n}"
}, {
	"Path": "com.vaadin.data.provider.DataProvider.fromFilteringCallbacks",
	"Comment": "creates a new data provider that uses filtering callbacks for fetchingand counting items from any backing store.the query that is passed to each callback may contain a filter value thatis provided by the component querying for data.",
	"Method": "CallbackDataProvider<T, F> fromFilteringCallbacks(FetchCallback<T, F> fetchCallback,CountCallback<T, F> countCallback){\r\n    return new CallbackDataProvider(fetchCallback, countCallback);\r\n}"
}, {
	"Path": "bt.protocol.Protocols.verifyPayloadHasLength",
	"Comment": "convenience method to check if actual message length is the same as expected length.",
	"Method": "void verifyPayloadHasLength(Class<? extends Message> type,int expectedLength,int actualLength){\r\n    if (expectedLength != actualLength) {\r\n        throw new InvalidMessageException(\"Unexpected payload length for \" + type.getSimpleName() + \": \" + actualLength + \" (expected \" + expectedLength + \")\");\r\n    }\r\n}"
}, {
	"Path": "bt.torrent.messaging.ConnectionState.getPendingRequests",
	"Comment": "get keys of block requests, that have been sent to the remote peer.",
	"Method": "Set<Object> getPendingRequests(){\r\n    return pendingRequests;\r\n}"
}, {
	"Path": "com.vaadin.client.event.PointerEvent.getHeight",
	"Comment": "gets the height of the contact geometry of the pointer in css pixels.",
	"Method": "int getHeight(int getHeight,NativeEvent e){\r\n    return getHeight(getNativeEvent());\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractSplitPanel.showDraggingCurtain",
	"Comment": "used in ff to avoid losing mouse capture when pointer is moved on aniframe.",
	"Method": "void showDraggingCurtain(){\r\n    if (!isDraggingCurtainRequired()) {\r\n        return;\r\n    }\r\n    if (draggingCurtain == null) {\r\n        draggingCurtain = DOM.createDiv();\r\n        draggingCurtain.getStyle().setPosition(Position.ABSOLUTE);\r\n        draggingCurtain.getStyle().setTop(0, Unit.PX);\r\n        draggingCurtain.getStyle().setLeft(0, Unit.PX);\r\n        draggingCurtain.getStyle().setWidth(100, Unit.PCT);\r\n        draggingCurtain.getStyle().setHeight(100, Unit.PCT);\r\n        draggingCurtain.getStyle().setZIndex(VOverlay.Z_INDEX);\r\n        DOM.appendChild(wrapper, draggingCurtain);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.writeItems",
	"Comment": "writes the data source items to a design. hierarchical select componentsshould override this method to only write the root items.",
	"Method": "void writeItems(Element design,DesignContext context){\r\n    for (Object itemId : getItemIds()) {\r\n        writeItem(design, itemId, context);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.HierarchicalContainer.removeItemRecursively",
	"Comment": "removes the item identified by given itemid and all its children from thegiven container.",
	"Method": "boolean removeItemRecursively(Object itemId,boolean removeItemRecursively,Container.Hierarchical container,Object itemId){\r\n    boolean success = true;\r\n    Collection<?> children2 = container.getChildren(itemId);\r\n    if (children2 != null) {\r\n        for (Object o : children2.toArray()) {\r\n            boolean removeItemRecursively = removeItemRecursively(container, o);\r\n            if (!removeItemRecursively) {\r\n                success = false;\r\n            }\r\n        }\r\n    }\r\n    if (success) {\r\n        success = container.removeItem(itemId);\r\n    }\r\n    return success;\r\n}"
}, {
	"Path": "com.vaadin.client.componentlocator.ComponentLocator.isValidForLegacyLocator",
	"Comment": "check if a given selector is valid for legacylocatorstrategy.",
	"Method": "boolean isValidForLegacyLocator(String path){\r\n    for (LocatorStrategy ls : locatorStrategies) {\r\n        if (ls instanceof LegacyLocatorStrategy) {\r\n            return ls.validatePath(path);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.updateWidth",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void updateWidth(){\r\n    if (!isVisible()) {\r\n        return;\r\n    }\r\n    if (!isDynamicWidth()) {\r\n        int innerPixels = getOffsetWidth() - getBorderWidth();\r\n        if (innerPixels < 0) {\r\n            innerPixels = 0;\r\n        }\r\n        setContentWidth(innerPixels);\r\n        triggerLazyColumnAdjustment(false);\r\n    } else {\r\n        sizeNeedsInit = true;\r\n        triggerLazyColumnAdjustment(false);\r\n    }\r\n    setProperTabIndex();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addBodyKeyPressHandler",
	"Comment": "register a bodykeypresshandler to this grid. the event for this handleris fired when a keypress event occurs while cell focus is in the body ofthis grid.",
	"Method": "HandlerRegistration addBodyKeyPressHandler(BodyKeyPressHandler handler){\r\n    return addHandler(handler, GridKeyPressEvent.TYPE);\r\n}"
}, {
	"Path": "bt.magnet.MagnetUriParser.parser",
	"Comment": "creates a parser, that will throw an exception,when some of the elements of the magnet link can not be parsed,e.g. invalid peer addresses.",
	"Method": "MagnetUriParser parser(){\r\n    return new MagnetUriParser(false);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Tree.setContainerDataSource",
	"Comment": "sets the container that serves as the data source of the viewer.",
	"Method": "void setContainerDataSource(Container newDataSource){\r\n    if (newDataSource == null) {\r\n        newDataSource = new HierarchicalContainer();\r\n    }\r\n    if (Container.Hierarchical.class.isAssignableFrom(newDataSource.getClass())) {\r\n        super.setContainerDataSource(newDataSource);\r\n    } else {\r\n        super.setContainerDataSource(new ContainerHierarchicalWrapper(newDataSource));\r\n    }\r\n    if (expanded != null) {\r\n        cleanupExpandedItems();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.orderedlayout.VAbstractOrderedLayout.getCaptionPositionFromElement",
	"Comment": "deducts the caption position by examining the wrapping element.for internal use only. may be removed or replaced in the future.",
	"Method": "CaptionPosition getCaptionPositionFromElement(com.google.gwt.user.client.Element captionWrap,CaptionPosition getCaptionPositionFromElement,Element captionWrap){\r\n    return getCaptionPositionFromElement(DOM.asOld(captionWrap));\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.ProgressBar.getValue",
	"Comment": "gets the value of this progress bar. the value is a floatbetween 0 and 1 where 0 represents no progress at all and 1 representsfully completed.",
	"Method": "Float getValue(){\r\n    return super.getValue();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.getCellReference",
	"Comment": "returns a cellreference for the cell to which the given element belongsto.",
	"Method": "CellReference<T> getCellReference(Element element){\r\n    RowContainer container = getEscalator().findRowContainer(element);\r\n    if (container != null) {\r\n        Cell cell = container.getCell(element);\r\n        if (cell != null) {\r\n            EventCellReference<T> cellRef = new EventCellReference<T>(this);\r\n            cellRef.set(cell, getSectionFromContainer(container));\r\n            return cellRef;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.vaadin.client.communication.ServerRpcQueue.flush",
	"Comment": "triggers a send of server rpc and legacy variable changes to the server.",
	"Method": "void flush(){\r\n    if (isFlushScheduled() || isEmpty()) {\r\n        return;\r\n    }\r\n    flushPending = true;\r\n    doFlushStrategy = this::doFlush;\r\n    Scheduler.get().scheduleFinally(() -> doFlushStrategy.run());\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractBeanContainer.addBeanAfter",
	"Comment": "adds a bean to the container after a specified item identifier, using thebean item id resolver to find its identifier.a bean id resolver must be set before calling this method.",
	"Method": "BeanItem<BEANTYPE> addBeanAfter(IDTYPE previousItemId,BEANTYPE bean){\r\n    if (bean == null) {\r\n        return null;\r\n    }\r\n    IDTYPE itemId = resolveBeanId(bean);\r\n    if (itemId == null) {\r\n        throw new IllegalArgumentException(\"Resolved identifier for a bean must not be null\");\r\n    }\r\n    return addItemAfter(previousItemId, itemId, bean);\r\n}"
}, {
	"Path": "com.vaadin.server.AbstractClientConnector.getAllChildrenIterable",
	"Comment": "get an iterable for iterating over all child connectors, including bothextensions and child components.",
	"Method": "Iterable<? extends ClientConnector> getAllChildrenIterable(ClientConnector connector){\r\n    Collection<Extension> extensions = connector.getExtensions();\r\n    boolean hasComponents = connector instanceof HasComponents;\r\n    boolean hasExtensions = !extensions.isEmpty();\r\n    if (!hasComponents && !hasExtensions) {\r\n        return Collections.emptyList();\r\n    }\r\n    if (hasComponents && !hasExtensions) {\r\n        return (HasComponents) connector;\r\n    }\r\n    if (!hasComponents && hasExtensions) {\r\n        return extensions;\r\n    }\r\n    final Iterator<Component> componentsIterator = ((HasComponents) connector).iterator();\r\n    final Iterator<Extension> extensionsIterator = extensions.iterator();\r\n    Iterable<? extends ClientConnector> combinedIterable = () -> new Iterator<ClientConnector>() {\r\n        @Override\r\n        public boolean hasNext() {\r\n            return componentsIterator.hasNext() || extensionsIterator.hasNext();\r\n        }\r\n        @Override\r\n        public ClientConnector next() {\r\n            if (componentsIterator.hasNext()) {\r\n                return componentsIterator.next();\r\n            }\r\n            if (extensionsIterator.hasNext()) {\r\n                return extensionsIterator.next();\r\n            }\r\n            throw new NoSuchElementException();\r\n        }\r\n        @Override\r\n        public void remove() {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n    return combinedIterable;\r\n}"
}, {
	"Path": "com.vaadin.server.AbstractClientConnector.getAllChildrenIterable",
	"Comment": "get an iterable for iterating over all child connectors, including bothextensions and child components.",
	"Method": "Iterable<? extends ClientConnector> getAllChildrenIterable(ClientConnector connector){\r\n    return componentsIterator.hasNext() || extensionsIterator.hasNext();\r\n}"
}, {
	"Path": "com.vaadin.server.AbstractClientConnector.getAllChildrenIterable",
	"Comment": "get an iterable for iterating over all child connectors, including bothextensions and child components.",
	"Method": "Iterable<? extends ClientConnector> getAllChildrenIterable(ClientConnector connector){\r\n    if (componentsIterator.hasNext()) {\r\n        return componentsIterator.next();\r\n    }\r\n    if (extensionsIterator.hasNext()) {\r\n        return extensionsIterator.next();\r\n    }\r\n    throw new NoSuchElementException();\r\n}"
}, {
	"Path": "com.vaadin.server.AbstractClientConnector.getAllChildrenIterable",
	"Comment": "get an iterable for iterating over all child connectors, including bothextensions and child components.",
	"Method": "Iterable<? extends ClientConnector> getAllChildrenIterable(ClientConnector connector){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.GeneratedPropertyContainer.getContainerPropertyIds",
	"Comment": "returns a list of propety ids available in this container. thiscollection will contain properties for generated properties. removedproperties will not show unless there is a generated property overridingthose.",
	"Method": "Collection<?> getContainerPropertyIds(){\r\n    Set<Object> wrappedProperties = new LinkedHashSet<Object>(wrappedContainer.getContainerPropertyIds());\r\n    wrappedProperties.removeAll(removedProperties);\r\n    wrappedProperties.addAll(propertyGenerators.keySet());\r\n    return wrappedProperties;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.DateField.setShowISOWeekNumbers",
	"Comment": "sets the visibility of iso 8601 week numbers in the date selector. iso8601 defines that a week always starts with a monday so the week numbersare only shown if this is the case.",
	"Method": "void setShowISOWeekNumbers(boolean showWeekNumbers){\r\n    showISOWeekNumbers = showWeekNumbers;\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.data.Binder.withValidator",
	"Comment": "adds an bean level validator.bean level validators are applied on the bean instance after the bean isupdated. if the validators fail, the bean instance is reverted to itsprevious state.",
	"Method": "BindingBuilder<BEAN, TARGET> withValidator(Validator<? super TARGET> validator,BindingBuilder<BEAN, TARGET> withValidator,SerializablePredicate<? super TARGET> predicate,String message,BindingBuilder<BEAN, TARGET> withValidator,SerializablePredicate<? super TARGET> predicate,String message,ErrorLevel errorLevel,BindingBuilder<BEAN, TARGET> withValidator,SerializablePredicate<? super TARGET> predicate,ErrorMessageProvider errorMessageProvider,BindingBuilder<BEAN, TARGET> withValidator,SerializablePredicate<? super TARGET> predicate,ErrorMessageProvider errorMessageProvider,ErrorLevel errorLevel,BindingBuilder<BEAN, TARGET> withValidator,Validator<? super TARGET> validator,Binder<BEAN> withValidator,Validator<? super BEAN> validator,Binder<BEAN> withValidator,SerializablePredicate<BEAN> predicate,String message,Binder<BEAN> withValidator,SerializablePredicate<BEAN> predicate,ErrorMessageProvider errorMessageProvider){\r\n    return withValidator(Validator.from(predicate, errorMessageProvider));\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractSplitPanel.makeScrollable",
	"Comment": "ensures the panels are scrollable e.g. after style name changesfor internal use only. may be removed or replaced in the future.",
	"Method": "void makeScrollable(){\r\n    if (touchScrollHandler == null) {\r\n        touchScrollHandler = TouchScrollDelegate.enableTouchScrolling(this);\r\n    }\r\n    touchScrollHandler.addElement(firstContainer);\r\n    touchScrollHandler.addElement(secondContainer);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VMenuBar.createOverlay",
	"Comment": "create an overlay for the menu bar.this method can be overridden to use a custom overlay.",
	"Method": "VOverlay createOverlay(){\r\n    return new VOverlay(true, false);\r\n}"
}, {
	"Path": "com.vaadin.ui.ComponentRootSetter.setRoot",
	"Comment": "sets the composition root for the given custom component or composite.for internal use only.",
	"Method": "void setRoot(Component customComponent,Component component){\r\n    if (customComponent instanceof CustomComponent) {\r\n        ((CustomComponent) customComponent).setCompositionRoot(component);\r\n    } else if (customComponent instanceof Composite) {\r\n        ((Composite) customComponent).setCompositionRoot(component);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Parameter is of an unsupported type: \" + customComponent.getClass().getName());\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.MultiSelectionModelImpl.fetchAllDescendants",
	"Comment": "fetch all the descendants of the given parent item from the given dataprovider.",
	"Method": "Stream<T> fetchAllDescendants(T parent,HierarchicalDataProvider<T, ?> dataProvider){\r\n    List<T> children = dataProvider.fetchChildren(new HierarchicalQuery(null, parent)).collect(Collectors.toList());\r\n    if (children.isEmpty()) {\r\n        return Stream.empty();\r\n    }\r\n    return children.stream().flatMap(child -> Stream.concat(Stream.of(child), fetchAllDescendants(child, dataProvider)));\r\n}"
}, {
	"Path": "com.vaadin.server.GlobalResourceHandler.unregisterConnector",
	"Comment": "notifies this handler that resources registered for the given connectorcan be released.",
	"Method": "void unregisterConnector(ClientConnector connector){\r\n    Set<Resource> set = usedResources.remove(connector);\r\n    if (set == null) {\r\n        return;\r\n    }\r\n    for (Resource resource : set) {\r\n        Set<ClientConnector> users = resourceUsers.get(resource);\r\n        users.remove(connector);\r\n        if (users.isEmpty()) {\r\n            resourceUsers.remove(resource);\r\n            unregisterResource(resource);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.getNavigationUpKey",
	"Comment": "get the key that moves the selection head upwards. by default it is theup arrow key but by overriding this you can change the key to whateveryou want.",
	"Method": "int getNavigationUpKey(){\r\n    return KeyCodes.KEY_UP;\r\n}"
}, {
	"Path": "com.github.dozermapper.core.functional_tests.builder.DeepMappingWithMapIdTest.getChildMapping",
	"Comment": "get the child mapping to use for the test, it is configured not to map nulls.",
	"Method": "BeanMappingBuilder getChildMapping(){\r\n    return new BeanMappingBuilder() {\r\n        protected void configure() {\r\n            mapping(Child.class, Child.class, TypeMappingOptions.mapId(MAP_ID_CHILD), TypeMappingOptions.mapNull(false));\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.github.dozermapper.core.functional_tests.builder.DeepMappingWithMapIdTest.getChildMapping",
	"Comment": "get the child mapping to use for the test, it is configured not to map nulls.",
	"Method": "BeanMappingBuilder getChildMapping(){\r\n    mapping(Child.class, Child.class, TypeMappingOptions.mapId(MAP_ID_CHILD), TypeMappingOptions.mapNull(false));\r\n}"
}, {
	"Path": "com.vaadin.client.ui.menubar.MenuBar.getItems",
	"Comment": "returns a list containing the menuitem objects in the menubar. if there are no items in the menu bar, then an emptylist object will be returned.",
	"Method": "List<MenuItem> getItems(){\r\n    return items;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VMediaBase.setMediaElement",
	"Comment": "sets the mediaelement that is to receive all commands and properties.",
	"Method": "void setMediaElement(MediaElement element){\r\n    setElement(element);\r\n    media = element;\r\n}"
}, {
	"Path": "com.vaadin.client.VCaption.setCaptionAsHtml",
	"Comment": "sets whether the caption is rendered as html.default is false",
	"Method": "void setCaptionAsHtml(boolean captionAsHtml){\r\n    this.captionAsHtml = captionAsHtml;\r\n}"
}, {
	"Path": "com.github.dozermapper.core.functional_tests.CollectionTest.testArrayGrowConversion",
	"Comment": "test shows how simple array grows, when dest array is not null",
	"Method": "void testArrayGrowConversion(){\r\n    ArraySource sourceBean = new ArraySource();\r\n    String[] sourceArray = sourceBean.getPreInitializedArray();\r\n    sourceArray[0] = \"1\";\r\n    sourceArray[1] = \"2\";\r\n    ArrayDest destinationBean = new ArrayDest();\r\n    mapper.map(sourceBean, destinationBean, \"array\");\r\n    String[] destinationArray = destinationBean.getPreInitializedArray();\r\n    Assert.assertEquals(sourceArray.length + 2, destinationArray.length);\r\n}"
}, {
	"Path": "org.greenrobot.essentials.javaperf.PipelineStreamBenchmark.main",
	"Comment": "this is only for development purposes or to run tests separately. for automated benchmarking use gradle",
	"Method": "void main(String[] args){\r\n    BenchmarkRunner.runWallTime(new LibImpl(), 100, 10);\r\n}"
}, {
	"Path": "bt.it.fixture.SwarmBuilder.config",
	"Comment": "provide a custom bt configuration, that will be used as a template for creating swarm participants.",
	"Method": "SwarmBuilder config(Config config){\r\n    this.config = config;\r\n    return this;\r\n}"
}, {
	"Path": "com.vaadin.client.event.PointerEvent.isPrimary",
	"Comment": "indicates whether the pointer is the primary pointer of this type.",
	"Method": "boolean isPrimary(boolean isPrimary,NativeEvent e){\r\n    return isPrimary(getNativeEvent());\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTextField.updateMaxLength",
	"Comment": "this method is responsible for updating the dom or otherwise ensuringthat the given max length is enforced. called when the max length for thefield has changed.",
	"Method": "void updateMaxLength(int maxLength){\r\n    if (maxLength >= 0) {\r\n        getElement().setPropertyInt(\"maxLength\", maxLength);\r\n    } else {\r\n        getElement().removeAttribute(\"maxLength\");\r\n    }\r\n    setMaxLengthToElement(maxLength);\r\n}"
}, {
	"Path": "com.vaadin.ui.ProgressBar.setValue",
	"Comment": "sets the value of this progress bar. the value is a floatbetween 0 and 1 where 0 represents no progress at all and 1 representsfully completed.",
	"Method": "void setValue(float newValue){\r\n    getState().state = newValue;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VUI.makeScrollable",
	"Comment": "ensures the widget is scrollable e.g. after style name changes.for internal use only. may be removed or replaced in the future.",
	"Method": "void makeScrollable(){\r\n    if (touchScrollHandler == null) {\r\n        touchScrollHandler = TouchScrollDelegate.enableTouchScrolling(this);\r\n    }\r\n    touchScrollHandler.addElement(getElement());\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinServletResponse.getCurrent",
	"Comment": "gets the currently processed vaadin servlet response. the currentresponse is automatically defined when the request is started. thecurrent response can not be used in e.g. background threads because ofthe way server implementations reuse response instances.",
	"Method": "VaadinServletResponse getCurrent(){\r\n    VaadinResponse currentResponse = VaadinResponse.getCurrent();\r\n    if (currentResponse instanceof VaadinServletResponse) {\r\n        return (VaadinServletResponse) currentResponse;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractMultiSelect.addSelectionListener",
	"Comment": "adds a selection listener that will be called when the selection ischanged either by the user or programmatically.",
	"Method": "Registration addSelectionListener(MultiSelectionListener<T> listener){\r\n    return addListener(MultiSelectionEvent.class, listener, MultiSelectionListener.SELECTION_CHANGE_METHOD);\r\n}"
}, {
	"Path": "net.openhft.chronicle.queue.impl.SingleChronicleQueue.appendMetaDataReturnAddress",
	"Comment": "this method does not update the index, as indexes are not used for meta data",
	"Method": "long appendMetaDataReturnAddress(Bytes buffer){\r\n    long length = checkRemainingForAppend(buffer);\r\n    LongValue writeByte = header.writeByte();\r\n    long lastByte = writeByte.getVolatileValue();\r\n    for (; ; ) {\r\n        if (bytes.compareAndSwapInt(lastByte, 0, NOT_COMPLETE | (int) length)) {\r\n            long lastByte2 = lastByte + 4 + buffer.remaining();\r\n            bytes.write(lastByte + 4, buffer);\r\n            writeByte.setOrderedValue(lastByte2);\r\n            bytes.writeOrderedInt(lastByte, (int) (META_DATA | length));\r\n            return lastByte;\r\n        }\r\n        int length2 = length30(bytes.readVolatileInt());\r\n        bytes.skip(length2);\r\n        try {\r\n            Jvm.checkInterrupted();\r\n        } catch (InterruptedException e) {\r\n            throw new InterruptedRuntimeException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.renderers.NumberRenderer.getFormat",
	"Comment": "gets the number format that the number should be formatted in.",
	"Method": "NumberFormat getFormat(){\r\n    return format;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.createHeaderUpdater",
	"Comment": "creates the escalator updater used to update the header rows in thisgrid. the updater is invoked when header rows or columns are added orremoved, or the content of existing header cells is changed.",
	"Method": "EscalatorUpdater createHeaderUpdater(){\r\n    return new StaticSectionUpdater(header, escalator.getHeader());\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.recalculateColumnWidths",
	"Comment": "requests that the column widths should be recalculated.in most cases grid will know when column widths need to be recalculatedbut this method can be used to force recalculation in situations whengrid does not recalculate automatically.",
	"Method": "void recalculateColumnWidths(){\r\n    getRpcProxy(GridClientRpc.class).recalculateColumnWidths();\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.selection.SelectionModel.isItemSelected",
	"Comment": "gets the selected state from a given grid row json object. this is ahelper method for grid selection models.",
	"Method": "boolean isItemSelected(JsonObject item){\r\n    return item.hasKey(DataCommunicatorConstants.SELECTED) && item.getBoolean(DataCommunicatorConstants.SELECTED);\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponent.isOrHasAncestor",
	"Comment": "determine whether a content component is equal to, or theancestor of this component.",
	"Method": "boolean isOrHasAncestor(Component content){\r\n    if (content instanceof HasComponents) {\r\n        for (Component parent = this; parent != null; parent = parent.getParent()) {\r\n            if (parent.equals(content)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTree.getNavigationUpKey",
	"Comment": "get the key that moves the selection head upwards. by default it is theup arrow key but by overriding this you can change the key to whateveryou want.",
	"Method": "int getNavigationUpKey(){\r\n    return KeyCodes.KEY_UP;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.getNavigationStartKey",
	"Comment": "get the key the moves the selection to the beginning of the table. bydefault this is the home key but by overriding this you can change thekey to whatever you want.",
	"Method": "int getNavigationStartKey(){\r\n    return KeyCodes.KEY_HOME;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.ContainerHierarchicalWrapper.removeAllItems",
	"Comment": "removes all items from the underlying container and from the hierarcy.",
	"Method": "boolean removeAllItems(){\r\n    final boolean success = container.removeAllItems();\r\n    if (!hierarchical && success) {\r\n        roots.clear();\r\n        parent.clear();\r\n        children.clear();\r\n        noChildrenAllowed.clear();\r\n    }\r\n    return success;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.setConverter",
	"Comment": "sets a converter for a property id.the converter is used to format the the data for the given property idbefore displaying it in the table.",
	"Method": "void setConverter(Object propertyId,Converter<String, ?> converter){\r\n    if (!getContainerPropertyIds().contains(propertyId)) {\r\n        throw new IllegalArgumentException(\"PropertyId \" + propertyId + \" must be in the container\");\r\n    }\r\n    if (!typeIsCompatible(converter.getModelType(), getType(propertyId))) {\r\n        throw new IllegalArgumentException(\"Property type (\" + getType(propertyId) + \") must match converter source type (\" + converter.getModelType() + \")\");\r\n    }\r\n    propertyValueConverters.put(propertyId, (Converter<String, Object>) converter);\r\n    refreshRowCache();\r\n}"
}, {
	"Path": "sundeepk.github.com.sample.SlidingTabLayout.setSelectedIndicatorColors",
	"Comment": "sets the colors to be used for indicating the selected tab. these colors are treated as acircular array. providing one color will mean that all tabs are indicated with the same color.",
	"Method": "void setSelectedIndicatorColors(int colors){\r\n    mTabStrip.setSelectedIndicatorColors(colors);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.getFirstUpdatedItemIndex",
	"Comment": "subclass and override this to enable partial row updates, bypassing thenormal caching and lazy loading mechanism. this is useful for updatingthe state of certain rows, e.g. in the treetable the collapsed state of asingle node is updated using this mechanism.",
	"Method": "int getFirstUpdatedItemIndex(){\r\n    return 0;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.DataCommunicator.removeDataGenerator",
	"Comment": "removes a data generator from this data communicator. if there is no suchdata generator, does nothing.",
	"Method": "void removeDataGenerator(DataGenerator<T> generator){\r\n    Objects.requireNonNull(generator, \"generator cannot be null\");\r\n    generators.remove(generator);\r\n}"
}, {
	"Path": "com.vaadin.client.Profiler.getRelativeTimeMillis",
	"Comment": "returns time relative to the particular page load time. the value shouldnot be used directly but rather difference between two values returned bythis method should be used to compare measurements.",
	"Method": "double getRelativeTimeMillis(){\r\n    return RELATIVE_TIME_SUPPLIER.getRelativeTime();\r\n}"
}, {
	"Path": "com.github.dozermapper.core.functional_tests.WildcardWrapperTypeTest.testCanMapWrapperFieldAndPrimitiveSetter",
	"Comment": "mapping should work without configuration when field is of wrapper type andsetter takes a primitive type.",
	"Method": "void testCanMapWrapperFieldAndPrimitiveSetter(){\r\n    WrapperFieldPrimitiveSetter source = new WrapperFieldPrimitiveSetter();\r\n    source.setPrimitive(Float.MAX_VALUE);\r\n    WrapperFieldPrimitiveSetter target = mapper.map(source, WrapperFieldPrimitiveSetter.class);\r\n    assertThat(target.getPrimitive(), equalTo(Float.MAX_VALUE));\r\n}"
}, {
	"Path": "com.vaadin.navigator.Navigator.parseStateParameterMap",
	"Comment": "parses the state parameter to a map using the given separator string.",
	"Method": "Map<String, String> parseStateParameterMap(String separator){\r\n    if (getState() == null || getState().isEmpty()) {\r\n        return Collections.emptyMap();\r\n    }\r\n    String state = getState();\r\n    int viewSeparatorLocation = state.indexOf(DEFAULT_VIEW_SEPARATOR);\r\n    String parameterString;\r\n    if (viewSeparatorLocation == -1) {\r\n        parameterString = \"\";\r\n    } else {\r\n        parameterString = state.substring(viewSeparatorLocation + 1, state.length());\r\n    }\r\n    return parseParameterStringToMap(parameterString, separator);\r\n}"
}, {
	"Path": "com.vaadin.server.BootstrapResponse.getSession",
	"Comment": "gets the service session to which the rendered view belongs.",
	"Method": "VaadinSession getSession(){\r\n    return session;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VDragAndDropWrapper.startNextUpload",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void startNextUpload(){\r\n    Scheduler.get().scheduleDeferred(() -> {\r\n        if (!uploading) {\r\n            if (!fileIds.isEmpty()) {\r\n                uploading = true;\r\n                final Integer fileId = fileIds.remove(0);\r\n                VHtml5File file = files.remove(0);\r\n                final String receiverUrl = client.translateVaadinUri(fileIdToReceiver.remove(fileId.toString()));\r\n                ExtendedXHR extendedXHR = (ExtendedXHR) ExtendedXHR.create();\r\n                extendedXHR.setOnReadyStateChange(readyStateChangeHandler);\r\n                extendedXHR.open(\"POST\", receiverUrl);\r\n                extendedXHR.postFile(file);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.vaadin.shared.Range.intersects",
	"Comment": "checks whether this range and another range are at least partiallycovering the same values.",
	"Method": "boolean intersects(Range other){\r\n    return getStart() < other.getEnd() && other.getStart() < getEnd();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.NestedMethodProperty.setValue",
	"Comment": "sets the value of the property. the new value must be assignable to thetype of this property.",
	"Method": "void setValue(T newValue){\r\n    if (isReadOnly()) {\r\n        throw new Property.ReadOnlyException();\r\n    }\r\n    invokeSetMethod(newValue);\r\n    fireValueChange();\r\n}"
}, {
	"Path": "com.vaadin.ui.Tree.setAutoRecalculateWidth",
	"Comment": "sets the automatic width recalculation on or off. this feature is on bydefault.",
	"Method": "void setAutoRecalculateWidth(boolean autoRecalculateWidth){\r\n    this.autoRecalculateWidth = autoRecalculateWidth;\r\n    treeGrid.getColumns().get(0).setMinimumWidthFromContent(autoRecalculateWidth);\r\n    treeGrid.recalculateColumnWidths();\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.FieldBinder.asFieldName",
	"Comment": "converts the given identifier to a valid field name by stripping awayillegal character and setting the first letter of the name to lower case.",
	"Method": "String asFieldName(String identifier){\r\n    if (identifier == null) {\r\n        return \"\";\r\n    }\r\n    StringBuilder result = new StringBuilder();\r\n    for (int i = 0; i < identifier.length(); i++) {\r\n        char character = identifier.charAt(i);\r\n        if (Character.isJavaIdentifierPart(character)) {\r\n            result.append(character);\r\n        }\r\n    }\r\n    if (result.length() != 0 && Character.isLetter(result.charAt(0))) {\r\n        result.setCharAt(0, Character.toLowerCase(result.charAt(0)));\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.getSessionLock",
	"Comment": "gets the lock instance used to lock the vaadinsession associated with thegiven wrapped session.this method uses the wrapped session instead of vaadinsession to be ableto lock even before the vaadinsession has been initialized.",
	"Method": "Lock getSessionLock(WrappedSession wrappedSession){\r\n    Object lock = wrappedSession.getAttribute(getLockAttributeName());\r\n    if (lock instanceof ReentrantLock) {\r\n        return (ReentrantLock) lock;\r\n    }\r\n    if (lock == null) {\r\n        return null;\r\n    }\r\n    throw new RuntimeException(\"Something else than a ReentrantLock was stored in the \" + getLockAttributeName() + \" in the session\");\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.cleanStreamVariable",
	"Comment": "removes any streamvariable of the given name from the indicatedconnector.",
	"Method": "void cleanStreamVariable(String connectorId,String variableName){\r\n    if (pidToNameToStreamVariable == null) {\r\n        return;\r\n    }\r\n    Map<String, StreamVariable> nameToStreamVar = pidToNameToStreamVariable.get(connectorId);\r\n    StreamVariable streamVar = nameToStreamVar.remove(variableName);\r\n    streamVariableToSeckey.remove(streamVar);\r\n    if (nameToStreamVar.isEmpty()) {\r\n        pidToNameToStreamVariable.remove(connectorId);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.JsonPaintTarget.escapeXML",
	"Comment": "substitutes the xml sensitive characters with predefined xml entities.",
	"Method": "String escapeXML(String xml,StringBuilder escapeXML,StringBuilder xml){\r\n    if (xml == null || xml.length() <= 0) {\r\n        return new StringBuilder();\r\n    }\r\n    final StringBuilder result = new StringBuilder(xml.length() * 2);\r\n    for (int i = 0; i < xml.length(); i++) {\r\n        final char c = xml.charAt(i);\r\n        final String s = toXmlChar(c);\r\n        if (s != null) {\r\n            result.append(s);\r\n        } else {\r\n            result.append(c);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.setLastProcessedClientToServerId",
	"Comment": "sets the last processed server message id.used internally for communication tracking.",
	"Method": "void setLastProcessedClientToServerId(int lastProcessedClientToServerId){\r\n    this.lastProcessedClientToServerId = lastProcessedClientToServerId;\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.Header.getDefaultRow",
	"Comment": "returns the default row of this header. the default row displays columncaptions and sort indicators.",
	"Method": "Row getDefaultRow(){\r\n    return getRows().stream().filter(Row::isDefault).findAny().orElse(null);\r\n}"
}, {
	"Path": "com.vaadin.tests.server.component.ui.CustomUIClassLoaderTest.testWithDefaultClassLoader",
	"Comment": "tests that a ui class can be loaded even if no classloader has beenprovided.",
	"Method": "void testWithDefaultClassLoader(){\r\n    VaadinSession application = createStubApplication();\r\n    application.setConfiguration(createConfigurationMock());\r\n    DefaultUIProvider uiProvider = new DefaultUIProvider();\r\n    Class<? extends UI> uiClass = uiProvider.getUIClass(new UIClassSelectionEvent(createRequestMock(getClass().getClassLoader())));\r\n    assertEquals(MyUI.class, uiClass);\r\n}"
}, {
	"Path": "com.vaadin.client.JavaScriptConnectorHelper.ensureJavascriptInited",
	"Comment": "makes sure the javascript part of the connector has been initialized. thejavascript is usually initalized the first time a state change event isreceived, but it might in some cases be necessary to make this happenearlier.",
	"Method": "void ensureJavascriptInited(){\r\n    if (initFunctionName == null) {\r\n        processStateChanges();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.handleKeyPress",
	"Comment": "handles the keypress from both the onkeypress event and the onkeydownevent",
	"Method": "void handleKeyPress(DomEvent<?> event){\r\n    int keycode = event.getNativeEvent().getKeyCode();\r\n    if (keycode == KeyCodes.KEY_TAB && event.getNativeEvent().getShiftKey()) {\r\n        if (onTabOut(event)) {\r\n            return;\r\n        }\r\n    }\r\n    if (handleNavigation(keycode, event.getNativeEvent().getCtrlKey() || event.getNativeEvent().getMetaKey(), event.getNativeEvent().getShiftKey())) {\r\n        event.preventDefault();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractPopupCalendar.getOpenCalenderPanelKey",
	"Comment": "get the key code that opens the calendar panel. by default it is the downkey but you can override this to be whatever you like",
	"Method": "int getOpenCalenderPanelKey(){\r\n    return KeyCodes.KEY_DOWN;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractProperty.fireReadOnlyStatusChange",
	"Comment": "sends a read only status change event to all registered listeners.",
	"Method": "void fireReadOnlyStatusChange(){\r\n    if (readOnlyStatusChangeListeners != null) {\r\n        final Property.ReadOnlyStatusChangeEvent event = new ReadOnlyStatusChangeEvent(this);\r\n        for (Object l : readOnlyStatusChangeListeners.toArray()) {\r\n            ((Property.ReadOnlyStatusChangeListener) l).readOnlyStatusChange(event);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.IndexedContainer.firePropertyValueChange",
	"Comment": "sends a property value change event to all interested listeners.",
	"Method": "void firePropertyValueChange(IndexedContainerProperty source){\r\n    if (propertyValueChangeListeners != null) {\r\n        final Property.ValueChangeEvent event = new IndexedContainer.PropertyValueChangeEvent(source);\r\n        for (Object l : propertyValueChangeListeners.toArray()) {\r\n            ((Property.ValueChangeListener) l).valueChange(event);\r\n        }\r\n    }\r\n    if (singlePropertyValueChangeListeners != null) {\r\n        final Map<Object, List<Property.ValueChangeListener>> propertySetToListenerListMap = singlePropertyValueChangeListeners.get(source.propertyId);\r\n        if (propertySetToListenerListMap != null) {\r\n            final List<Property.ValueChangeListener> listenerList = propertySetToListenerListMap.get(source.itemId);\r\n            if (listenerList != null) {\r\n                final Property.ValueChangeEvent event = new IndexedContainer.PropertyValueChangeEvent(source);\r\n                for (Object listener : listenerList.toArray()) {\r\n                    ((Property.ValueChangeListener) listener).valueChange(event);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.event.EventRouter.getListeners",
	"Comment": "returns all listeners that match or extend the given event type.",
	"Method": "Collection<?> getListeners(Class<?> eventType){\r\n    List<Object> listeners = new ArrayList();\r\n    if (listenerList != null) {\r\n        for (ListenerMethod lm : listenerList) {\r\n            if (lm.isOrExtendsType(eventType)) {\r\n                listeners.add(lm.getTarget());\r\n            }\r\n        }\r\n    }\r\n    return listeners;\r\n}"
}, {
	"Path": "com.vaadin.ui.DateTimeField.setPlaceholder",
	"Comment": "sets the placeholder text. the placeholder is text that is displayed whenthe field would otherwise be empty, to prompt the user for input.",
	"Method": "void setPlaceholder(String placeholder){\r\n    getState().placeholder = placeholder;\r\n}"
}, {
	"Path": "com.vaadin.ui.GridLayout.checkExistingOverlaps",
	"Comment": "tests if the given area overlaps with any of the items already on thegrid.",
	"Method": "void checkExistingOverlaps(Area area){\r\n    for (Entry<Connector, ChildComponentData> entry : getState().childData.entrySet()) {\r\n        if (componentsOverlap(entry.getValue(), area.childData)) {\r\n            throw new OverlapsException(new Area(entry.getValue(), (Component) entry.getKey()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.selectFirstRenderedRowInViewPort",
	"Comment": "selects the first row visible in the tablefor internal use only. may be removed or replaced in the future.",
	"Method": "void selectFirstRenderedRowInViewPort(boolean focusOnly){\r\n    int index = firstRowInViewPort;\r\n    VScrollTableRow firstInViewport = scrollBody.getRowByRowIndex(index);\r\n    if (firstInViewport == null) {\r\n        return;\r\n    }\r\n    setRowFocus(firstInViewport);\r\n    if (!focusOnly) {\r\n        selectFocusedRow(false, multiselectPending);\r\n        sendSelectedRows();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.handleSessionExpired",
	"Comment": "called when the session has expired and the request handling is thereforeaborted.",
	"Method": "void handleSessionExpired(VaadinRequest request,VaadinResponse response){\r\n    for (RequestHandler handler : getRequestHandlers()) {\r\n        if (handler instanceof SessionExpiredHandler) {\r\n            try {\r\n                if (((SessionExpiredHandler) handler).handleSessionExpired(request, response)) {\r\n                    return;\r\n                }\r\n            } catch (IOException e) {\r\n                throw new ServiceException(\"Handling of session expired failed\", e);\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        SystemMessages systemMessages = getSystemMessages(ServletPortletHelper.findLocale(null, null, request), request);\r\n        String sessionExpiredURL = systemMessages.getSessionExpiredURL();\r\n        if (sessionExpiredURL != null && (response instanceof VaadinServletResponse)) {\r\n            ((VaadinServletResponse) response).sendRedirect(sessionExpiredURL);\r\n        } else {\r\n            response.sendError(HttpServletResponse.SC_GONE, \"Session expired\");\r\n        }\r\n    } catch (IOException e) {\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendar.getBackwardListener",
	"Comment": "set the listener which listens to backward events from the calendar.",
	"Method": "BackwardListener getBackwardListener(){\r\n    return backwardListener;\r\n}"
}, {
	"Path": "com.vaadin.client.ConnectorHierarchyChangeEvent.getOldChildren",
	"Comment": "returns a collection of the old children for the connector. this was thestate before the update was received from the server.",
	"Method": "List<ComponentConnector> getOldChildren(){\r\n    return oldChildren;\r\n}"
}, {
	"Path": "com.vaadin.client.Util.getInvocationDebugString",
	"Comment": "produces a string representation of a method invocation, suitable fordebug output",
	"Method": "String getInvocationDebugString(MethodInvocation invocation){\r\n    Object[] parameters = invocation.getParameters();\r\n    String formattedParams = null;\r\n    if (ApplicationConstants.UPDATE_VARIABLE_METHOD.equals(invocation.getMethodName()) && parameters.length == 2) {\r\n        Object value = parameters[1];\r\n        String formattedValue = value instanceof ServerConnector ? ((ServerConnector) value).getConnectorId() : String.valueOf(value);\r\n        formattedParams = parameters[0] + \" : \" + formattedValue;\r\n    }\r\n    if (null == formattedParams) {\r\n        formattedParams = (null != parameters) ? Arrays.toString(parameters) : null;\r\n    }\r\n    return invocation.getInterfaceName() + \".\" + invocation.getMethodName() + \"(\" + formattedParams + \")\";\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Tree.setItemDescriptionGenerator",
	"Comment": "set the item description generator which generates tooltips for the treeitems.",
	"Method": "void setItemDescriptionGenerator(ItemDescriptionGenerator generator){\r\n    if (generator != itemDescriptionGenerator) {\r\n        itemDescriptionGenerator = generator;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.getWindowOrder",
	"Comment": "returns window position in list of opened and shown windows.",
	"Method": "int getWindowOrder(){\r\n    return windowOrder.indexOf(this);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractInMemoryContainer.getAllItemIds",
	"Comment": "internal helper method to get the internal list of all item identifiers.avoid using this method outside this class, may disappear in futureversions.",
	"Method": "List<ITEMIDTYPE> getAllItemIds(){\r\n    return allItemIds;\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.Header.setDefaultRow",
	"Comment": "sets the default row of this header. the default row displays columncaptions and sort indicators.",
	"Method": "void setDefaultRow(Row defaultRow){\r\n    if (defaultRow != null) {\r\n        if (!getRows().contains(defaultRow)) {\r\n            throw new IllegalArgumentException(\"The section does not contain the row\");\r\n        }\r\n        if (defaultRow.isDefault()) {\r\n            return;\r\n        }\r\n    }\r\n    getRows().forEach(row -> row.setDefault(row == defaultRow));\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.getColumnGenerator",
	"Comment": "returns the columngenerator used to generate the given column.",
	"Method": "ColumnGenerator getColumnGenerator(Object columnId){\r\n    return columnGenerators.get(columnId);\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.refreshTransients",
	"Comment": "refreshes the transient fields of the session to ensure they are up todate.called internally by the framework.",
	"Method": "void refreshTransients(WrappedSession wrappedSession,VaadinService vaadinService){\r\n    session = wrappedSession;\r\n    service = vaadinService;\r\n    refreshLock();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VFilterSelect.createTextBox",
	"Comment": "this method will create the textbox used by the vfilterselect instance.it is invoked during the constructor and should only be overridden if acustom textbox shall be used. the overriding method cannot use anyinstance variables.",
	"Method": "TextBox createTextBox(){\r\n    return new FilterSelectTextBox();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.BeanItemContainer.addBean",
	"Comment": "adds the bean to the container.the bean is used both as the item contents and as the item identifier.",
	"Method": "BeanItem<BEANTYPE> addBean(BEANTYPE bean){\r\n    return addItem(bean);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.getCloseKey",
	"Comment": "returns the key that closes the popup window if this is a vpopopcalendar.else this does nothing. by default this is the escape key but you canchange the key to whatever you want by overriding this method.",
	"Method": "int getCloseKey(){\r\n    return KeyCodes.KEY_ESCAPE;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.getNavigationEndKey",
	"Comment": "get the key the moves the selection to the end of the table. by defaultthis is the end key but by overriding this you can change the key towhatever you want.",
	"Method": "int getNavigationEndKey(){\r\n    return KeyCodes.KEY_END;\r\n}"
}, {
	"Path": "com.vaadin.ui.Upload.getUploadSize",
	"Comment": "returns size of file currently being uploaded. value sane only duringupload.",
	"Method": "long getUploadSize(){\r\n    return contentLength;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheetBase.getConnectorForWidget",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "ComponentConnector getConnectorForWidget(Widget widget){\r\n    return ConnectorMap.get(client).getConnector(widget);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.OptionGroup.setHtmlContentAllowed",
	"Comment": "sets whether html is allowed in the item captions. if set to true, thecaptions are passed to the browser as html and the developer isresponsible for ensuring no harmful html is used. if set to false, thecontent is passed to the browser as plain text.",
	"Method": "void setHtmlContentAllowed(boolean htmlContentAllowed){\r\n    this.htmlContentAllowed = htmlContentAllowed;\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.setColumnReorderingAllowed",
	"Comment": "sets whether or not column reordering is allowed. default value isfalse.",
	"Method": "void setColumnReorderingAllowed(boolean columnReorderingAllowed){\r\n    if (isColumnReorderingAllowed() != columnReorderingAllowed) {\r\n        getState().columnReorderingAllowed = columnReorderingAllowed;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.Tree.select",
	"Comment": "this method is a shorthand that delegates to the currently set selectionmodel.",
	"Method": "void select(T item){\r\n    treeGrid.select(item);\r\n}"
}, {
	"Path": "com.github.dozermapper.core.functional_tests.MapIdSameInstanceTest.testMappingDifferentInstances",
	"Comment": "different instances of two in the fields of one.worked correctly in dozer 5.5.1.",
	"Method": "void testMappingDifferentInstances(){\r\n    testMapping(createTwo());\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTwinColSelect.setInternalWidths",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setInternalWidths(){\r\n    getElement().getStyle().setPosition(Position.RELATIVE);\r\n    int bordersAndPaddings = WidgetUtil.measureHorizontalPaddingAndBorder(buttons.getElement(), 0);\r\n    int buttonWidth = WidgetUtil.getRequiredWidth(buttons);\r\n    int totalWidth = getOffsetWidth();\r\n    int spaceForSelect = (totalWidth - buttonWidth - bordersAndPaddings) / 2;\r\n    optionsListBox.setWidth(spaceForSelect + \"px\");\r\n    if (optionsCaption != null) {\r\n        optionsCaption.setWidth(spaceForSelect + \"px\");\r\n    }\r\n    selectionsListBox.setWidth(spaceForSelect + \"px\");\r\n    if (selectionsCaption != null) {\r\n        selectionsCaption.setWidth(spaceForSelect + \"px\");\r\n    }\r\n    captionWrapper.setWidth(\"100%\");\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.TreeTable.setAnimationsEnabled",
	"Comment": "animations can be enabled by passing true to this method. currentlyexpanding rows slide in from the top and collapsing rows slide out thesame way. note! not supported in internet explorer 6 or 7.",
	"Method": "void setAnimationsEnabled(boolean animationsEnabled){\r\n    this.animationsEnabled = animationsEnabled;\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractInMemoryContainer.filterAll",
	"Comment": "filter the view to recreate the visible item list from the unfiltereditems, and send a notification if the set of visible items changed in anyway.",
	"Method": "void filterAll(){\r\n    if (doFilterContainer(!getFilters().isEmpty())) {\r\n        fireItemSetChange();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.handleNavigationYearMode",
	"Comment": "handles the keyboard navigation when the resolution is set to years.",
	"Method": "boolean handleNavigationYearMode(int keycode,boolean ctrl,boolean shift){\r\n    if (ctrl || shift) {\r\n        return false;\r\n    } else if (keycode == getPreviousKey()) {\r\n        focusNextYear(10);\r\n        return true;\r\n    } else if (keycode == getForwardKey()) {\r\n        focusNextYear(1);\r\n        return true;\r\n    } else if (keycode == getNextKey()) {\r\n        focusPreviousYear(10);\r\n        return true;\r\n    } else if (keycode == getBackwardKey()) {\r\n        focusPreviousYear(1);\r\n        return true;\r\n    } else if (keycode == getSelectKey()) {\r\n        value = (Date) focusedDate.clone();\r\n        onSubmit();\r\n        return true;\r\n    } else if (keycode == getResetKey()) {\r\n        focusedDate.setTime(value.getTime());\r\n        renderCalendar();\r\n        return true;\r\n    } else if (keycode == getCloseKey()) {\r\n        onCancel();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractContainer.getPropertySetChangeListeners",
	"Comment": "returns the property set change listener collection. for internal useonly.",
	"Method": "Collection<Container.PropertySetChangeListener> getPropertySetChangeListeners(){\r\n    return propertySetChangeListeners;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractTextField.getColumns",
	"Comment": "gets the number of columns in the editor. if the number of columns is set0, the actual number of displayed columns is determined implicitly by theadapter.",
	"Method": "int getColumns(){\r\n    return getState(false).columns;\r\n}"
}, {
	"Path": "com.vaadin.server.JsonCodec.getInternalTransportType",
	"Comment": "these methods looks good to inline, but are on a cold path of theotherwise hot encode method, which needed to be shorted to allow inliningof the hot part.",
	"Method": "String getInternalTransportType(Type valueType){\r\n    return TYPE_TO_TRANSPORT_TYPE.get(getClassForType(valueType));\r\n}"
}, {
	"Path": "com.vaadin.util.CurrentInstance.restoreInstances",
	"Comment": "restores the given instances to the given values. note that this shouldonly be used internally to restore vaadin classes.",
	"Method": "void restoreInstances(Map<Class<?>, CurrentInstance> old){\r\n    boolean removeStale = false;\r\n    for (Class c : old.keySet()) {\r\n        CurrentInstance ci = old.get(c);\r\n        Object v = ci.instance.get();\r\n        if (v == null) {\r\n            removeStale = true;\r\n        } else if (v == NULL_OBJECT) {\r\n            v = null;\r\n        }\r\n        set(c, v);\r\n    }\r\n    if (removeStale) {\r\n        removeStaleInstances(old);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.grid.selection.SpaceSelectHandler.setDeselectAllowed",
	"Comment": "sets whether pressing space for the currently selected row shoulddeselect the row.",
	"Method": "void setDeselectAllowed(boolean deselectAllowed){\r\n    this.deselectAllowed = deselectAllowed;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VMenuBar.isNavigationSelectKey",
	"Comment": "checks whether key code selects a menu item. by default it is the enterand space keys but by overriding this you can change the keys to whateveryou want.",
	"Method": "boolean isNavigationSelectKey(int keycode){\r\n    return keycode == getNavigationSelectKey() || keycode == KeyCodes.KEY_SPACE;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinServlet.findResourceURL",
	"Comment": "finds the given resource from the web content folder or using the classloader.",
	"Method": "URL findResourceURL(String filename){\r\n    URL resourceUrl = getServletContext().getResource(filename);\r\n    if (resourceUrl == null) {\r\n        if (filename.startsWith(\"/\")) {\r\n            filename = filename.substring(1);\r\n        }\r\n        resourceUrl = getService().getClassLoader().getResource(filename);\r\n    }\r\n    return resourceUrl;\r\n}"
}, {
	"Path": "com.vaadin.ui.Alignment.isBottom",
	"Comment": "checks if component is aligned to the bottom of the available space.",
	"Method": "boolean isBottom(){\r\n    return (bitMask & Bits.ALIGNMENT_BOTTOM) == Bits.ALIGNMENT_BOTTOM;\r\n}"
}, {
	"Path": "com.vaadin.ui.CustomLayout.setTemplateContents",
	"Comment": "set the contents of the template used to draw the custom layout.",
	"Method": "void setTemplateContents(String templateContents){\r\n    getState().templateContents = templateContents;\r\n    getState().templateName = null;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTwinColSelect.clearInternalWidths",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void clearInternalWidths(){\r\n    String colWidth = DEFAULT_COLUMN_COUNT + \"em\";\r\n    String containerWidth = 2 * DEFAULT_COLUMN_COUNT + 4 + \"em\";\r\n    String captionWrapperWidth = 2 * DEFAULT_COLUMN_COUNT + 4 - 0.5 + \"em\";\r\n    optionsListBox.setWidth(colWidth);\r\n    if (optionsCaption != null) {\r\n        optionsCaption.setWidth(colWidth);\r\n    }\r\n    selectionsListBox.setWidth(colWidth);\r\n    if (selectionsCaption != null) {\r\n        selectionsCaption.setWidth(colWidth);\r\n    }\r\n    buttons.setWidth(\"3.5em\");\r\n    optionsContainer.setWidth(containerWidth);\r\n    captionWrapper.setWidth(captionWrapperWidth);\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractMedia.setShowControls",
	"Comment": "sets whether or not the browser should show native media controls.",
	"Method": "void setShowControls(boolean showControls){\r\n    getState().showControls = showControls;\r\n}"
}, {
	"Path": "bt.torrent.messaging.TorrentWorker.getPeers",
	"Comment": "get all peers, that this torrent worker is currently working with.",
	"Method": "Set<Peer> getPeers(){\r\n    return peerMap.keySet();\r\n}"
}, {
	"Path": "com.vaadin.server.KeyMapper.createKey",
	"Comment": "creates a key for a new item.this method can be overridden to customize the keys used.",
	"Method": "String createKey(){\r\n    return String.valueOf(++lastKey);\r\n}"
}, {
	"Path": "com.folioreader.util.HighlightUtil.getRangyString",
	"Comment": "function extracts rangy element corresponding to latest highlight.",
	"Method": "String getRangyString(String rangy,String oldRangy){\r\n    List<String> rangyList = getRangyArray(rangy);\r\n    for (String firs : getRangyArray(oldRangy)) {\r\n        if (rangyList.contains(firs)) {\r\n            rangyList.remove(firs);\r\n        }\r\n    }\r\n    if (rangyList.size() >= 1) {\r\n        return rangyList.get(0);\r\n    } else {\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.connectors.grid.MultiSelectionModelConnector.updateSelectAllCheckBox",
	"Comment": "called whenever there has been a state update for select all checkboxvisibility or all have been selected or deselected.",
	"Method": "void updateSelectAllCheckBox(){\r\n    final boolean selectAllCheckBoxVisible = getState().selectAllCheckBoxVisible;\r\n    if (selectAllCheckBoxVisible && selectAllHandler == null) {\r\n        selectAllHandler = getGrid().addSelectAllHandler(this::onSelectAllEvent);\r\n    } else if (!selectAllCheckBoxVisible && selectAllHandler != null) {\r\n        selectAllHandler.removeHandler();\r\n        selectAllHandler = null;\r\n    }\r\n    Optional<Grid<JsonObject>.SelectionColumn<JsonObject>> selectionColumn = getGrid().getSelectionColumn();\r\n    if (selectionColumn.isPresent()) {\r\n        selectionColumn.get().setSelectAllCheckBoxVisible(selectAllCheckBoxVisible);\r\n        selectionColumn.get().getSelectAllCheckBox().ifPresent(checkbox -> checkbox.setValue(getState().allSelected, false));\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Form.setFooter",
	"Comment": "sets the layout that is rendered below normal form contents. no footer isrendered if this is set to null, .",
	"Method": "void setFooter(Layout footer){\r\n    if (getFooter() != null) {\r\n        getFooter().setParent(null);\r\n    }\r\n    getState().footer = footer;\r\n    if (footer != null) {\r\n        footer.setParent(this);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.registerEventToolTips",
	"Comment": "register the description of the events as tooltips. this way, any eventdisplaying widget can use the event index as a key to display thetooltip.",
	"Method": "void registerEventToolTips(List<CalendarState.Event> events){\r\n    for (CalendarState.Event e : events) {\r\n        if (e.description != null && !\"\".equals(e.description)) {\r\n            tooltips.put(e.index, e.description);\r\n        } else {\r\n            tooltips.remove(e.index);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.setSystemMessagesProvider",
	"Comment": "sets the system messages provider to use for getting system messages todisplay to users of this service.",
	"Method": "void setSystemMessagesProvider(SystemMessagesProvider systemMessagesProvider){\r\n    if (systemMessagesProvider == null) {\r\n        throw new IllegalArgumentException(\"SystemMessagesProvider can not be null.\");\r\n    }\r\n    this.systemMessagesProvider = systemMessagesProvider;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.removePropertySetChangeListener",
	"Comment": "removes a previously registered property set change listener.",
	"Method": "void removePropertySetChangeListener(Container.PropertySetChangeListener listener){\r\n    if (propertySetEventListeners != null) {\r\n        propertySetEventListeners.remove(listener);\r\n        if (propertySetEventListeners.isEmpty()) {\r\n            propertySetEventListeners = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.ensurePushAvailable",
	"Comment": "enables push if push support is available and push has not yet beenenabled.if push support is not available, a warning explaining the situation willbe logged at least the first time this method is invoked.",
	"Method": "boolean ensurePushAvailable(){\r\n    if (atmosphereAvailable) {\r\n        return true;\r\n    } else {\r\n        if (!pushWarningEmitted) {\r\n            pushWarningEmitted = true;\r\n            getLogger().log(Level.WARNING, Constants.ATMOSPHERE_MISSING_ERROR);\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.greenrobot.essentials.javaperf.LongHashMapBenchmark.main",
	"Comment": "this is only for development purposes or to run tests separately. for automated benchmarking use gradle",
	"Method": "void main(String[] args){\r\n    BenchmarkRunner.runWallTime(new LibImpl(), RUN_COUNT, WARM_UP_TIME_S);\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.FieldBinder.getFields",
	"Comment": "returns a list containing field objects reflecting all the fields of theclass or interface represented by this class object. the fields insuperclasses are excluded.",
	"Method": "List<java.lang.reflect.Field> getFields(Class<?> searchClass){\r\n    List<java.lang.reflect.Field> memberFields = new ArrayList();\r\n    memberFields.addAll(Arrays.asList(searchClass.getDeclaredFields()));\r\n    return memberFields;\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridMultiSelect.select",
	"Comment": "selects the given item. if another item was already selected, that itemis deselected.",
	"Method": "void select(T item){\r\n    model.select(item);\r\n}"
}, {
	"Path": "com.vaadin.client.DependencyLoader.setConnection",
	"Comment": "sets the applicationconnection this instance is connected to.only used internally.",
	"Method": "void setConnection(ApplicationConnection connection){\r\n    if (this.connection != null) {\r\n        throw new IllegalStateException(\"Application connection has already been set\");\r\n    }\r\n    if (connection == null) {\r\n        throw new IllegalArgumentException(\"ApplicationConnection can not be null\");\r\n    }\r\n    this.connection = connection;\r\n}"
}, {
	"Path": "com.vaadin.client.widget.escalator.FlyweightRow.assertSetup",
	"Comment": "asserts that the flyweight row has properly been set up before trying toaccess any of its data.",
	"Method": "void assertSetup(){\r\n    assert element != null && row != BLANK && columnWidths != null : \"Flyweight row was not \" + \"properly initialized. Make sure the setup-method is \" + \"called before retrieving data. This is either a bug \" + \"in Escalator, or the instance of the flyweight row \" + \"has been stored and accessed.\";\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.removeContainerProperty",
	"Comment": "removes the property from all items. removes a property with given idfrom all the items in the container.this functionality is optional. if the function is unsupported, it alwaysreturns false.",
	"Method": "boolean removeContainerProperty(Object propertyId){\r\n    final boolean retval = items.removeContainerProperty(propertyId);\r\n    if (retval && !(items instanceof Container.PropertySetChangeNotifier)) {\r\n        firePropertySetChange();\r\n    }\r\n    return retval;\r\n}"
}, {
	"Path": "com.vaadin.shared.ui.MarginInfo.getBitMask",
	"Comment": "returns the current bit mask that make up the margin settings.this method is for internal use by the framework.",
	"Method": "int getBitMask(){\r\n    return bitMask;\r\n}"
}, {
	"Path": "com.vaadin.ui.Panel.addClickListener",
	"Comment": "add a click listener to the panel. the listener is called whenever theuser clicks inside the panel. also when the click targets a componentinside the panel, provided the targeted component does not prevent theclick event from propagating.",
	"Method": "Registration addClickListener(ClickListener listener){\r\n    return addListener(EventId.CLICK_EVENT_IDENTIFIER, ClickEvent.class, listener, ClickListener.clickMethod);\r\n}"
}, {
	"Path": "com.vaadin.client.communication.MessageSender.hasActiveRequest",
	"Comment": "indicates whether or not there are currently active uidl requests. usedinternally to sequence requests properly, seldom needed in widgets.",
	"Method": "boolean hasActiveRequest(){\r\n    return hasActiveRequest;\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridMultiSelect.getSelectAllCheckBoxVisibility",
	"Comment": "gets the current mode for the select all checkbox visibility.",
	"Method": "SelectAllCheckBoxVisibility getSelectAllCheckBoxVisibility(){\r\n    return model.getSelectAllCheckBoxVisibility();\r\n}"
}, {
	"Path": "com.vaadin.client.communication.DefaultConnectionStateHandler.giveUp",
	"Comment": "called when we should give up trying to reconnect and let the user decidehow to continue.",
	"Method": "void giveUp(){\r\n    reconnectionCause = null;\r\n    endRequest();\r\n    stopDialogTimer();\r\n    if (!isDialogVisible()) {\r\n        showDialog();\r\n    }\r\n    reconnectDialog.setText(getDialogTextGaveUp(reconnectAttempt));\r\n    reconnectDialog.setReconnecting(false);\r\n    connection.setApplicationRunning(false);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTextField.updateFieldContent",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void updateFieldContent(String text){\r\n    setPrompting(inputPrompt != null && focusedTextField != this && (text.equals(\"\")));\r\n    String fieldValue;\r\n    if (prompting) {\r\n        fieldValue = isReadOnly() ? \"\" : inputPrompt;\r\n        addStyleDependentName(CLASSNAME_PROMPT);\r\n    } else {\r\n        fieldValue = text;\r\n        removeStyleDependentName(CLASSNAME_PROMPT);\r\n    }\r\n    setText(fieldValue);\r\n    lastTextChangeString = valueBeforeEdit = text;\r\n    valueBeforeEditIsSynced = true;\r\n}"
}, {
	"Path": "com.vaadin.navigator.Navigator.parseParameterStringToMap",
	"Comment": "parses the given parameter string to a map using the given separatorstring.",
	"Method": "Map<String, String> parseParameterStringToMap(String parameterString,String separator){\r\n    if (parameterString.isEmpty()) {\r\n        return Collections.emptyMap();\r\n    }\r\n    Map<String, String> parameterMap = new HashMap();\r\n    String[] parameters = parameterString.split(separator);\r\n    for (String parameter : parameters) {\r\n        String[] keyAndValue = parameter.split(DEFAULT_STATE_PARAMETER_KEY_VALUE_SEPARATOR);\r\n        parameterMap.put(keyAndValue[0], keyAndValue.length > 1 ? keyAndValue[1] : \"\");\r\n    }\r\n    return parameterMap;\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConnection.getActiveConnector",
	"Comment": "gets the active connector for the focused element in the browser.",
	"Method": "ComponentConnector getActiveConnector(){\r\n    Element focusedElement = WidgetUtil.getFocusedElement();\r\n    if (focusedElement == null) {\r\n        return null;\r\n    }\r\n    return Util.getConnectorForElement(this, RootPanel.get(), focusedElement);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.updateSortingProperties",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void updateSortingProperties(UIDL uidl){\r\n    oldSortColumn = sortColumn;\r\n    if (uidl.hasVariable(\"sortascending\")) {\r\n        sortAscending = uidl.getBooleanVariable(\"sortascending\");\r\n        sortColumn = uidl.getStringVariable(\"sortcolumn\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.focusRowFromBody",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void focusRowFromBody(){\r\n    if (selectedRowKeys.size() == 1) {\r\n        String selectedRowKey = selectedRowKeys.iterator().next();\r\n        if (selectedRowKey != null) {\r\n            VScrollTableRow renderedRow = getRenderedRowByKey(selectedRowKey);\r\n            if (renderedRow == null || !renderedRow.isInViewPort()) {\r\n                setRowFocus(scrollBody.getRowByRowIndex(firstRowInViewPort));\r\n            } else {\r\n                setRowFocus(renderedRow);\r\n            }\r\n        }\r\n    } else {\r\n        setRowFocus(scrollBody.getRowByRowIndex(firstRowInViewPort));\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.JsonCodec.decodeInternalType",
	"Comment": "decodes a value that is of an internal type.ensures the encoded value is of the same type as target type.allows restricting collections so that they must be declared usinggenerics. if this is used then all objects in the collection are encodedusing the declared type. otherwise only internal types are allowed incollections.",
	"Method": "Object decodeInternalType(Type targetType,boolean restrictToInternalTypes,JsonValue encodedJsonValue,ConnectorTracker connectorTracker){\r\n    if (!isInternalType(targetType)) {\r\n        throw new JsonException(\"Type \" + targetType + \" is not a supported internal type.\");\r\n    }\r\n    String transportType = getInternalTransportType(targetType);\r\n    if (encodedJsonValue.getType() == JsonType.NULL) {\r\n        return null;\r\n    } else if (targetType == Void.class) {\r\n        throw new JsonException(\"Something other than null was encoded for a null type\");\r\n    }\r\n    if (targetType == UidlValue.class) {\r\n        return decodeUidlValue((JsonArray) encodedJsonValue, connectorTracker);\r\n    }\r\n    if (JsonConstants.VTYPE_LIST.equals(transportType)) {\r\n        return decodeList(targetType, restrictToInternalTypes, (JsonArray) encodedJsonValue, connectorTracker);\r\n    } else if (JsonConstants.VTYPE_SET.equals(transportType)) {\r\n        return decodeSet(targetType, restrictToInternalTypes, (JsonArray) encodedJsonValue, connectorTracker);\r\n    } else if (JsonConstants.VTYPE_MAP.equals(transportType)) {\r\n        return decodeMap(targetType, restrictToInternalTypes, encodedJsonValue, connectorTracker);\r\n    }\r\n    if (JsonConstants.VTYPE_ARRAY.equals(transportType)) {\r\n        return decodeObjectArray(targetType, (JsonArray) encodedJsonValue, connectorTracker);\r\n    } else if (JsonConstants.VTYPE_STRINGARRAY.equals(transportType)) {\r\n        return decodeArray(String.class, (JsonArray) encodedJsonValue, null);\r\n    }\r\n    if (JsonConstants.VTYPE_CONNECTOR.equals(transportType)) {\r\n        return connectorTracker.getConnector(encodedJsonValue.asString());\r\n    }\r\n    if (JsonConstants.VTYPE_STRING.equals(transportType)) {\r\n        return encodedJsonValue.asString();\r\n    } else if (JsonConstants.VTYPE_INTEGER.equals(transportType)) {\r\n        return (int) encodedJsonValue.asNumber();\r\n    } else if (JsonConstants.VTYPE_LONG.equals(transportType)) {\r\n        return (long) encodedJsonValue.asNumber();\r\n    } else if (JsonConstants.VTYPE_FLOAT.equals(transportType)) {\r\n        return (float) encodedJsonValue.asNumber();\r\n    } else if (JsonConstants.VTYPE_DOUBLE.equals(transportType)) {\r\n        return encodedJsonValue.asNumber();\r\n    } else if (JsonConstants.VTYPE_BOOLEAN.equals(transportType)) {\r\n        return encodedJsonValue.asBoolean();\r\n    }\r\n    throw new JsonException(\"Unknown type \" + transportType);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VMenuBar.getCloseMenuKey",
	"Comment": "get the key that closes the menu. by default it is the escape key but byoverriding this yoy can change the key to whatever you want.",
	"Method": "int getCloseMenuKey(){\r\n    return KeyCodes.KEY_ESCAPE;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinPortletService.preserveUIOnRefresh",
	"Comment": "always preserve uis in portlets to make portlet actions work.",
	"Method": "boolean preserveUIOnRefresh(UIProvider provider,UICreateEvent event){\r\n    return true;\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.writeObject",
	"Comment": "special serialization to jsonobjects which are not serializable",
	"Method": "void writeObject(ObjectOutputStream out){\r\n    out.defaultWriteObject();\r\n    Map<ClientConnector, String> stringDiffStates = new HashMap(diffStates.size() * 2);\r\n    for (ClientConnector key : diffStates.keySet()) {\r\n        stringDiffStates.put(key, diffStates.get(key).toString());\r\n    }\r\n    out.writeObject(stringDiffStates);\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.addSessionInitListener",
	"Comment": "adds a listener that gets notified when a new vaadin service session isinitialized for this service.because of the way different service instances share the same session,the listener is not necessarily notified immediately when the session iscreated but only when the first request for that session is handled bythis service.",
	"Method": "Registration addSessionInitListener(SessionInitListener listener){\r\n    sessionInitListeners.add(listener);\r\n    return () -> sessionInitListeners.remove(listener);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.components.calendar.ContainerEventProvider.getStyleNameProperty",
	"Comment": "get the property which provides the style name for the event.",
	"Method": "Object getStyleNameProperty(){\r\n    return styleNameProperty;\r\n}"
}, {
	"Path": "com.vaadin.client.WidgetUtil.escapeAttribute",
	"Comment": "escapes the string so it is safe to write inside an html attribute.",
	"Method": "String escapeAttribute(String attribute){\r\n    if (attribute == null) {\r\n        return \"\";\r\n    }\r\n    attribute = attribute.replace(\"\\\"\", \"&quot;\");\r\n    attribute = attribute.replace(\"'\", \"&#39;\");\r\n    attribute = attribute.replace(\">\", \"&gt;\");\r\n    attribute = attribute.replace(\"<\", \"&lt;\");\r\n    attribute = attribute.replace(\"&\", \"&amp;\");\r\n    return attribute;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractField.attach",
	"Comment": "notifies the component that it is connected to an application.",
	"Method": "void attach(){\r\n    super.attach();\r\n    localeMightHaveChanged();\r\n    if (!isListeningToPropertyEvents) {\r\n        addPropertyListeners();\r\n        if (!isModified() && !isBuffered()) {\r\n            updateValueFromDataSource();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractSplitPanel.setMinSplitPosition",
	"Comment": "sets the minimum split position to the given position and unit. if thesplit position is reversed, maximum and minimum are also reversed.",
	"Method": "void setMinSplitPosition(float pos,Unit unit){\r\n    setSplitPositionLimits(pos, unit, getSplitterState(false).maxPosition, posMaxUnit);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.components.calendar.ContainerEventProvider.setStyleNameProperty",
	"Comment": "set the property which provides the style name for the event.",
	"Method": "void setStyleNameProperty(Object styleNameProperty){\r\n    this.styleNameProperty = styleNameProperty;\r\n}"
}, {
	"Path": "com.vaadin.shared.Range.endsAfter",
	"Comment": "checks whether this range ends after the end of another range.",
	"Method": "boolean endsAfter(Range other){\r\n    return getEnd() > other.getEnd();\r\n}"
}, {
	"Path": "com.vaadin.server.communication.JSR356WebsocketInitializer.initAtmosphereForVaadinServlet",
	"Comment": "initializes atmosphere for use with the given vaadin servletfor jsr 356 websockets to work properly, the initialization must be donein the servlet context initialization phase.",
	"Method": "void initAtmosphereForVaadinServlet(ServletRegistration servletRegistration,ServletContext servletContext){\r\n    String servletName = servletRegistration.getName();\r\n    String attributeName = getAttributeName(servletName);\r\n    if (servletContext.getAttribute(attributeName) != null) {\r\n        getLogger().warning(\"Atmosphere already initialized\");\r\n        return;\r\n    }\r\n    getLogger().finer(\"Creating AtmosphereFramework for \" + servletName);\r\n    AtmosphereFramework framework = PushRequestHandler.initAtmosphere(new FakeServletConfig(servletRegistration, servletContext));\r\n    servletContext.setAttribute(attributeName, framework);\r\n    getLogger().finer(\"Created AtmosphereFramework for \" + servletName);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VFilterSelect.updateRootWidth",
	"Comment": "calculates the width of the select if the select has undefined width.should be called when the width changes or when the icon changes.for internal use only. may be removed or replaced in the future.",
	"Method": "void updateRootWidth(){\r\n    ComponentConnector paintable = ConnectorMap.get(client).getConnector(this);\r\n    if (paintable.isUndefinedWidth()) {\r\n        int w = WidgetUtil.getRequiredWidth(this);\r\n        if ((!initDone || currentPage + 1 < 0) && suggestionPopupMinWidth > w) {\r\n            Style style = getElement().getStyle();\r\n            String originalPadding = style.getPadding();\r\n            String originalBorder = style.getBorderWidth();\r\n            style.setPaddingLeft(0, Unit.PX);\r\n            style.setBorderWidth(0, Unit.PX);\r\n            style.setProperty(\"padding\", originalPadding);\r\n            style.setProperty(\"borderWidth\", originalBorder);\r\n            int iconWidth = selectedItemIcon == null ? 0 : WidgetUtil.getRequiredWidth(selectedItemIcon);\r\n            int buttonWidth = popupOpener == null ? 0 : WidgetUtil.getRequiredWidth(popupOpener);\r\n            tb.setWidth((suggestionPopupMinWidth - iconWidth - buttonWidth) + \"px\");\r\n        }\r\n        if (!tb.getElement().getStyle().getWidth().endsWith(\"px\")) {\r\n            int iconWidth = selectedItemIcon == null ? 0 : selectedItemIcon.getOffsetWidth();\r\n            tb.setWidth((tb.getOffsetWidth() - iconWidth) + \"px\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.renderers.ClickableRenderer.addClickHandler",
	"Comment": "adds a click handler to this button renderer. the handler is invokedevery time one of the widgets rendered by this renderer is clicked.note that the row type of the click handler must match the row type ofthe containing grid.",
	"Method": "HandlerRegistration addClickHandler(RendererClickHandler<?> handler){\r\n    if (handlerManager == null) {\r\n        handlerManager = new HandlerManager(this);\r\n    }\r\n    return handlerManager.addHandler(RendererClickEvent.TYPE, handler);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addBodyKeyDownHandler",
	"Comment": "register a bodykeydownhandler to this grid. the event for this handler isfired when a keydown event occurs while cell focus is in the body of thisgrid.",
	"Method": "HandlerRegistration addBodyKeyDownHandler(BodyKeyDownHandler handler){\r\n    return addHandler(handler, GridKeyDownEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.TransactionalPropertyWrapper.detachFromProperty",
	"Comment": "removes the valuechangelistener from wrapped property that was added bytransactionalpropertywrapper.",
	"Method": "void detachFromProperty(){\r\n    if (wrappedProperty instanceof ValueChangeNotifier) {\r\n        ((ValueChangeNotifier) wrappedProperty).removeValueChangeListener(listener);\r\n    }\r\n}"
}, {
	"Path": "net.openhft.chronicle.queue.impl.single.SingleChronicleQueueBuilder.pretouchIntervalMillis",
	"Comment": "interval in ms to invoke out of process pretoucher. default is not to turn on",
	"Method": "long pretouchIntervalMillis(){\r\n    return pretouchIntervalMillis;\r\n}"
}, {
	"Path": "com.vaadin.ui.ComboBox.init",
	"Comment": "initialize the combobox with default settings and register client toserver rpc implementation.",
	"Method": "void init(){\r\n    registerRpc(rpc);\r\n    registerRpc(new FocusAndBlurServerRpcDecorator(this, this::fireEvent));\r\n    addDataGenerator(new DataGenerator<T>() {\r\n        private Map<Object, String> resourceKeyMap = new HashMap();\r\n        private int counter = 0;\r\n        @Override\r\n        public void generateData(T item, JsonObject jsonObject) {\r\n            String caption = getItemCaptionGenerator().apply(item);\r\n            if (caption == null) {\r\n                caption = \"\";\r\n            }\r\n            jsonObject.put(DataCommunicatorConstants.NAME, caption);\r\n            String style = itemStyleGenerator.apply(item);\r\n            if (style != null) {\r\n                jsonObject.put(ComboBoxConstants.STYLE, style);\r\n            }\r\n            Resource icon = getItemIcon(item);\r\n            if (icon != null) {\r\n                String iconKey = resourceKeyMap.get(getDataProvider().getId(item));\r\n                String iconUrl = ResourceReference.create(icon, ComboBox.this, iconKey).getURL();\r\n                jsonObject.put(ComboBoxConstants.ICON, iconUrl);\r\n            }\r\n        }\r\n        @Override\r\n        public void destroyData(T item) {\r\n            Object itemId = getDataProvider().getId(item);\r\n            if (resourceKeyMap.containsKey(itemId)) {\r\n                setResource(resourceKeyMap.get(itemId), null);\r\n                resourceKeyMap.remove(itemId);\r\n            }\r\n        }\r\n        private Resource getItemIcon(T item) {\r\n            Resource icon = getItemIconGenerator().apply(item);\r\n            if (icon == null || !(icon instanceof ConnectorResource)) {\r\n                return icon;\r\n            }\r\n            Object itemId = getDataProvider().getId(item);\r\n            if (!resourceKeyMap.containsKey(itemId)) {\r\n                resourceKeyMap.put(itemId, \"icon\" + (counter++));\r\n            }\r\n            setResource(resourceKeyMap.get(itemId), icon);\r\n            return icon;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.vaadin.ui.ComboBox.init",
	"Comment": "initialize the combobox with default settings and register client toserver rpc implementation.",
	"Method": "void init(){\r\n    String caption = getItemCaptionGenerator().apply(item);\r\n    if (caption == null) {\r\n        caption = \"\";\r\n    }\r\n    jsonObject.put(DataCommunicatorConstants.NAME, caption);\r\n    String style = itemStyleGenerator.apply(item);\r\n    if (style != null) {\r\n        jsonObject.put(ComboBoxConstants.STYLE, style);\r\n    }\r\n    Resource icon = getItemIcon(item);\r\n    if (icon != null) {\r\n        String iconKey = resourceKeyMap.get(getDataProvider().getId(item));\r\n        String iconUrl = ResourceReference.create(icon, ComboBox.this, iconKey).getURL();\r\n        jsonObject.put(ComboBoxConstants.ICON, iconUrl);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.ComboBox.init",
	"Comment": "initialize the combobox with default settings and register client toserver rpc implementation.",
	"Method": "void init(){\r\n    Object itemId = getDataProvider().getId(item);\r\n    if (resourceKeyMap.containsKey(itemId)) {\r\n        setResource(resourceKeyMap.get(itemId), null);\r\n        resourceKeyMap.remove(itemId);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.ComboBox.init",
	"Comment": "initialize the combobox with default settings and register client toserver rpc implementation.",
	"Method": "void init(){\r\n    Resource icon = getItemIconGenerator().apply(item);\r\n    if (icon == null || !(icon instanceof ConnectorResource)) {\r\n        return icon;\r\n    }\r\n    Object itemId = getDataProvider().getId(item);\r\n    if (!resourceKeyMap.containsKey(itemId)) {\r\n        resourceKeyMap.put(itemId, \"icon\" + (counter++));\r\n    }\r\n    setResource(resourceKeyMap.get(itemId), icon);\r\n    return icon;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.fieldgroup.FieldGroup.buildAndBind",
	"Comment": "builds a field using the given caption and binds it to the given propertyid using the field binder.",
	"Method": "Field<?> buildAndBind(Object propertyId,Field<?> buildAndBind,String caption,Object propertyId,T buildAndBind,String caption,Object propertyId,Class<T> fieldType){\r\n    Class<?> type = getPropertyType(propertyId);\r\n    T field = build(caption, type, fieldType);\r\n    bind(field, propertyId);\r\n    return field;\r\n}"
}, {
	"Path": "com.vaadin.server.communication.MetadataWriter.write",
	"Comment": "writes a json object containing metadata related to the given ui.",
	"Method": "void write(UI ui,Writer writer,boolean repaintAll,boolean async,SystemMessages messages){\r\n    writer.write(\"{\");\r\n    boolean metaOpen = false;\r\n    if (repaintAll) {\r\n        metaOpen = true;\r\n        writer.write(\"\\\"repaintAll\\\":true\");\r\n    }\r\n    if (async) {\r\n        if (metaOpen) {\r\n            writer.write(\", \");\r\n        }\r\n        metaOpen = true;\r\n        writer.write(\"\\\"async\\\":true\");\r\n    }\r\n    if (messages != null && messages.getSessionExpiredMessage() == null && messages.getSessionExpiredCaption() == null && messages.isSessionExpiredNotificationEnabled() && ui.getSession().getSession() != null) {\r\n        int newTimeoutInterval = ui.getSession().getSession().getMaxInactiveInterval();\r\n        if (repaintAll || (timeoutInterval != newTimeoutInterval)) {\r\n            String escapedURL = messages.getSessionExpiredURL() == null ? \"\" : messages.getSessionExpiredURL().replace(\"/\", \"\\\\/\");\r\n            if (metaOpen) {\r\n                writer.write(\",\");\r\n            }\r\n            writer.write(\"\\\"timedRedirect\\\":{\\\"interval\\\":\" + (newTimeoutInterval + 15) + \",\\\"url\\\":\\\"\" + escapedURL + \"\\\"}\");\r\n            metaOpen = true;\r\n        }\r\n        timeoutInterval = newTimeoutInterval;\r\n    }\r\n    writer.write(\"}\");\r\n}"
}, {
	"Path": "com.vaadin.ui.PopupView.removePopupVisibilityListener",
	"Comment": "removes a previously added listener, so that it no longer receives eventswhen the visibility of the popup changes.",
	"Method": "void removePopupVisibilityListener(PopupVisibilityListener listener){\r\n    removeListener(PopupVisibilityEvent.class, listener, POPUP_VISIBILITY_METHOD);\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignFormatter.canConvert",
	"Comment": "checks whether or not a value of a given type can be converted. if aconverter for a superclass is found, this will return true.",
	"Method": "boolean canConvert(Class<?> type){\r\n    return findConverterFor(type) != null;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addFooterKeyUpHandler",
	"Comment": "register a footerkeyuphandler to this grid. the event for this handler isfired when a keyup event occurs while cell focus is in the footer of thisgrid.",
	"Method": "HandlerRegistration addFooterKeyUpHandler(FooterKeyUpHandler handler){\r\n    return addHandler(handler, GridKeyUpEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.ContainerOrderedWrapper.removeAllItems",
	"Comment": "removes all items from the underlying container and from the ordering.",
	"Method": "boolean removeAllItems(){\r\n    final boolean success = container.removeAllItems();\r\n    if (!ordered && success) {\r\n        first = last = null;\r\n        next.clear();\r\n        prev.clear();\r\n    }\r\n    return success;\r\n}"
}, {
	"Path": "com.vaadin.ui.TabSheet.addTab",
	"Comment": "adds a new tab into tabsheet. component caption and icon are copied tothe tab metadata at creation time.if the tab sheet already contains the component, its tab is returned.",
	"Method": "Tab addTab(Component c,String caption,Tab addTab,Component c,String caption,Resource icon,Tab addTab,Component tabComponent,String caption,Resource icon,int position,Tab addTab,Component c,Tab addTab,Component component,int position){\r\n    Tab result = tabs.get(component);\r\n    if (result == null) {\r\n        result = addTab(component, component.getCaption(), component.getIcon(), position);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.vaadin.client.data.AbstractRemoteDataSource.pinHandle",
	"Comment": "pins a row with given handle. this function can be overridden to dospecific logic related to pinning rows.",
	"Method": "void pinHandle(RowHandleImpl handle){\r\n    Object key = handle.key;\r\n    Integer count = pinnedCounts.get(key);\r\n    if (count == null) {\r\n        count = Integer.valueOf(0);\r\n        pinnedRows.put(key, handle);\r\n    }\r\n    pinnedCounts.put(key, Integer.valueOf(count.intValue() + 1));\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VMenuBar.getNavigationLeftKey",
	"Comment": "get the key that moves the selection left. by default it is the leftarrow key but by overriding this you can change the key to whatever youwant.",
	"Method": "int getNavigationLeftKey(){\r\n    return KeyCodes.KEY_LEFT;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Form.setFormDataSource",
	"Comment": "updates the internal form datasource.method setformdatasource.",
	"Method": "void setFormDataSource(Object data,Collection<?> properties){\r\n    Item item = null;\r\n    if (data instanceof Item) {\r\n        item = (Item) data;\r\n    } else if (data != null) {\r\n        item = new BeanItem<Object>(data);\r\n    }\r\n    if (item != null && properties != null) {\r\n        this.setItemDataSource(item, properties);\r\n    } else {\r\n        this.setItemDataSource(item);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.dnd.event.FileDropEvent.getFiles",
	"Comment": "gets the collection of files dropped onto the file drop target component.",
	"Method": "Collection<Html5File> getFiles(){\r\n    return files;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractInMemoryContainer.getVisibleItemIds",
	"Comment": "returns the internal list of visible item identifiers after filtering.for internal use only.",
	"Method": "List<ITEMIDTYPE> getVisibleItemIds(){\r\n    if (isFiltered()) {\r\n        return getFilteredItemIds();\r\n    } else {\r\n        return getAllItemIds();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.getLoadingIndicatorConfiguration",
	"Comment": "retrieves the object used for configuring the loading indicator.",
	"Method": "LoadingIndicatorConfiguration getLoadingIndicatorConfiguration(){\r\n    return loadingIndicatorConfiguration;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.getNavigationLeftKey",
	"Comment": "get the key that scrolls to the left in the table. by default it is theleft arrow key but by overriding this you can change the key to whateveryou want.",
	"Method": "int getNavigationLeftKey(){\r\n    return KeyCodes.KEY_LEFT;\r\n}"
}, {
	"Path": "com.vaadin.client.renderers.WidgetRenderer.getWidget",
	"Comment": "returns the widget contained inside the given cell element, or null if itis not an instance of the given class. cannot be called for cells that donot contain a widget.",
	"Method": "W getWidget(TableCellElement e,W getWidget,TableCellElement e,Class<W> klass){\r\n    W w = WidgetUtil.findWidget(e.getFirstChildElement(), klass);\r\n    assert w == null || w.getElement() == e.getFirstChildElement() : \"Widget not found inside cell\";\r\n    return w;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VCustomLayout.initImgElements",
	"Comment": "img elements needs some special handling in custom layout. img elementswill get their onload events sunk. this way custom layout can notifyparent about possible size change.",
	"Method": "void initImgElements(){\r\n    NodeList<Element> nodeList = getElement().getElementsByTagName(\"IMG\");\r\n    for (int i = 0; i < nodeList.getLength(); i++) {\r\n        ImageElement img = ImageElement.as(nodeList.getItem(i));\r\n        DOM.sinkEvents(img, Event.ONLOAD);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.NestedMethodProperty.invokeSetMethod",
	"Comment": "internal method to actually call the setter method of the wrappedproperty.",
	"Method": "void invokeSetMethod(T value){\r\n    try {\r\n        Object object = instance;\r\n        for (int i = 0; i < getMethods.size() - 1; i++) {\r\n            object = getMethods.get(i).invoke(object);\r\n            if (object == null) {\r\n                return;\r\n            }\r\n        }\r\n        setMethod.invoke(object, new Object[] { value });\r\n    } catch (final InvocationTargetException e) {\r\n        throw new MethodException(this, e.getTargetException());\r\n    } catch (final Exception e) {\r\n        throw new MethodException(this, e);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.cancelEditor",
	"Comment": "cancels the currently active edit if any. hides the editor and discardspossible unsaved changes in the editor fields.",
	"Method": "void cancelEditor(){\r\n    if (editorSaving) {\r\n        return;\r\n    }\r\n    if (isEditorActive()) {\r\n        getEditorRpc().cancel(getContainerDataSource().indexOfId(editedItemId));\r\n        doCancelEditor();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractDateField.isShowISOWeekNumbers",
	"Comment": "checks whether iso 8601 week numbers are shown in the date selector.",
	"Method": "boolean isShowISOWeekNumbers(){\r\n    return getState(false).showISOWeekNumbers;\r\n}"
}, {
	"Path": "com.vaadin.server.JsonPaintTarget.getUIDL",
	"Comment": "gets the uidl already printed to stream. paint target must be closedbefore the getuidl can be called.",
	"Method": "String getUIDL(){\r\n    if (closed) {\r\n        return uidlBuffer.toString();\r\n    }\r\n    throw new IllegalStateException(\"Tried to read UIDL from open PaintTarget\");\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.Design.designToComponentTree",
	"Comment": "constructs a component hierarchy from the design specified as an htmltree.if a component root is given, the component instances created duringreading the design are assigned to its member fields based on their id,local id, and caption",
	"Method": "DesignContext designToComponentTree(Document doc,Component componentRoot,DesignContext designToComponentTree,Document doc,Component componentRoot,Class<?> classWithFields){\r\n    DesignContext designContext = new DesignContext(doc);\r\n    designContext.readPackageMappings(doc);\r\n    Element root = doc.body();\r\n    Elements children = root.children();\r\n    if (children.size() > 1) {\r\n        throw new DesignException(\"The first level of a component hierarchy should contain at most one root component, but found \" + children.size() + \".\");\r\n    }\r\n    Element element = children.isEmpty() ? null : children.first();\r\n    if (componentRoot != null) {\r\n        if (element == null) {\r\n            throw new DesignException(\"The root element cannot be null when the specified root Component is\" + \" not null.\");\r\n        }\r\n        final FieldBinder binder;\r\n        try {\r\n            binder = new FieldBinder(componentRoot, classWithFields);\r\n        } catch (IntrospectionException e) {\r\n            throw new DesignException(\"Could not bind fields of the root component\", e);\r\n        }\r\n        ComponentCreationListener creationListener = (ComponentCreatedEvent event) -> binder.bindField(event.getComponent(), event.getLocalId());\r\n        designContext.addComponentCreationListener(creationListener);\r\n        if (ComponentRootSetter.canSetRoot(componentRoot)) {\r\n            Component rootComponent = designContext.readDesign(element);\r\n            ComponentRootSetter.setRoot(componentRoot, rootComponent);\r\n        } else {\r\n            designContext.readDesign(element, componentRoot);\r\n        }\r\n        Collection<String> unboundFields = binder.getUnboundFields();\r\n        if (!unboundFields.isEmpty()) {\r\n            throw new DesignException(\"Found unbound fields from component root \" + unboundFields);\r\n        }\r\n        designContext.removeComponentCreationListener(creationListener);\r\n    } else {\r\n        componentRoot = element == null ? null : designContext.readDesign(element);\r\n    }\r\n    designContext.setRootComponent(componentRoot);\r\n    return designContext;\r\n}"
}, {
	"Path": "brave.spring.rabbit.ITSpringRabbitTracing.method_names_as_span_names",
	"Comment": "we will revisit this eventually, but these names mostly match the method names",
	"Method": "void method_names_as_span_names(){\r\n    testFixture.produceMessage();\r\n    testFixture.awaitMessageConsumed();\r\n    List<Span> allSpans = new ArrayList();\r\n    allSpans.add(takeProducerSpan());\r\n    allSpans.add(takeConsumerSpan());\r\n    allSpans.add(takeConsumerSpan());\r\n    assertThat(allSpans).extracting(Span::name).containsExactly(\"publish\", \"next-message\", \"on-message\");\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridDropTarget.getDropThreshold",
	"Comment": "gets the threshold between drop locations from the top and the bottom ofthe row.",
	"Method": "int getDropThreshold(){\r\n    return getState(false).dropThreshold;\r\n}"
}, {
	"Path": "com.vaadin.ui.ComponentRootSetter.canSetRoot",
	"Comment": "checks if the given custom component or composite may accept a rootcomponent.for internal use only.",
	"Method": "boolean canSetRoot(Component customComponent){\r\n    if (customComponent instanceof CustomComponent) {\r\n        return true;\r\n    }\r\n    if (customComponent instanceof Composite) {\r\n        return ((Composite) customComponent).getCompositionRoot() == null;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.client.renderers.ClickableRenderer.addClickHandler",
	"Comment": "adds a click handler to this button renderer. the handler is invokedevery time one of the widgets rendered by this renderer is clicked.note that the row type of the click handler must match the row type ofthe containing grid.",
	"Method": "HandlerRegistration addClickHandler(RendererClickHandler<?> handler){\r\n    if (handlerManager == null) {\r\n        handlerManager = new HandlerManager(this);\r\n    }\r\n    return handlerManager.addHandler(RendererClickEvent.TYPE, handler);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.setPageLength",
	"Comment": "sets the number of items to show per page, or 0 for showing all items.",
	"Method": "void setPageLength(int pageLength){\r\n    this.pageLength = pageLength;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTwinColSelect.clearInternalHeights",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void clearInternalHeights(){\r\n    selections.setHeight(\"\");\r\n    options.setHeight(\"\");\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.getSelectKey",
	"Comment": "returns the select key which selects the value. by default this is theenter key but it can be changed to whatever you like by overriding thismethod.",
	"Method": "int getSelectKey(){\r\n    return KeyCodes.KEY_ENTER;\r\n}"
}, {
	"Path": "bt.BaseClientBuilder.runtime",
	"Comment": "set the runtime that the newly built client will be attached to.",
	"Method": "B runtime(BtRuntime runtime){\r\n    this.runtime = Objects.requireNonNull(runtime, \"Missing runtime\");\r\n    return (B) this;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VFilterSelect.setPromptingOn",
	"Comment": "turns prompting on. when prompting is turned on a command prompt is shownin the text box if nothing has been entered.",
	"Method": "void setPromptingOn(){\r\n    debug(\"VFS: setPromptingOn()\");\r\n    if (!prompting) {\r\n        prompting = true;\r\n        addStyleDependentName(CLASSNAME_PROMPT);\r\n    }\r\n    setTextboxText(inputPrompt);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.treegrid.TreeGridConnector.updateHierarchyColumn",
	"Comment": "this method has been scheduled finally to avoid possible race conditionsbetween state change handling for the grid and its columns. the rendererof the column is set in a state change handler, and might not beavailable when this method is executed.",
	"Method": "void updateHierarchyColumn(){\r\n    if (hierarchyColumnUpdateScheduled) {\r\n        return;\r\n    }\r\n    Scheduler.get().scheduleFinally(() -> {\r\n        hierarchyColumnUpdateScheduled = false;\r\n        String oldHierarchyColumnId = hierarchyColumnId;\r\n        String newHierarchyColumnId = getState().hierarchyColumnId;\r\n        if (newHierarchyColumnId == null && !getState().columnOrder.isEmpty()) {\r\n            newHierarchyColumnId = getState().columnOrder.get(0);\r\n        }\r\n        Grid.Column<?, ?> newColumn = getColumn(newHierarchyColumnId);\r\n        Grid.Column<?, ?> oldColumn = getColumn(oldHierarchyColumnId);\r\n        if (newColumn == null && oldColumn == null) {\r\n            return;\r\n        }\r\n        if (oldColumn != null && oldColumn.getRenderer() instanceof HierarchyRenderer) {\r\n            oldColumn.setRenderer(((HierarchyRenderer) oldColumn.getRenderer()).getInnerRenderer());\r\n        }\r\n        if (newColumn != null) {\r\n            HierarchyRenderer wrapperRenderer = getHierarchyRenderer();\r\n            wrapperRenderer.setInnerRenderer(newColumn.getRenderer());\r\n            newColumn.setRenderer(wrapperRenderer);\r\n            getWidget().setFrozenColumnCount(getState().frozenColumnCount);\r\n            hierarchyColumnId = newHierarchyColumnId;\r\n        } else {\r\n            Logger.getLogger(TreeGridConnector.class.getName()).warning(\"Couldn't find column: \" + newHierarchyColumnId);\r\n        }\r\n    });\r\n    hierarchyColumnUpdateScheduled = true;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.fieldgroup.FieldGroup.unbind",
	"Comment": "detaches the field from its property id and removes it from thisfieldbinder.note that the field is not detached from its property data source if itis no longer connected to the same property id it was bound to using thisfieldbinder.",
	"Method": "void unbind(Field<?> field){\r\n    Object propertyId = fieldToPropertyId.get(field);\r\n    if (propertyId == null) {\r\n        throw new BindException(\"The given field is not part of this FieldBinder\");\r\n    }\r\n    TransactionalPropertyWrapper<?> wrapper = null;\r\n    Property fieldDataSource = field.getPropertyDataSource();\r\n    if (fieldDataSource instanceof TransactionalPropertyWrapper) {\r\n        wrapper = (TransactionalPropertyWrapper<?>) fieldDataSource;\r\n        fieldDataSource = ((TransactionalPropertyWrapper<?>) fieldDataSource).getWrappedProperty();\r\n    }\r\n    if (getItemDataSource() != null && fieldDataSource == getItemProperty(propertyId)) {\r\n        if (null != wrapper) {\r\n            wrapper.detachFromProperty();\r\n        }\r\n        field.setPropertyDataSource(null);\r\n    }\r\n    fieldToPropertyId.remove(field);\r\n    propertyIdToField.remove(propertyId);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.SQLContainer.getReferencedItemId",
	"Comment": "fetches the item id of the referenced item from the target sqlcontainer.",
	"Method": "Object getReferencedItemId(Object itemId,SQLContainer refdCont){\r\n    if (refdCont == null) {\r\n        throw new IllegalArgumentException(\"Referenced SQLContainer can not be null.\");\r\n    }\r\n    Reference r = references.get(refdCont);\r\n    if (r == null) {\r\n        throw new IllegalArgumentException(\"Reference to the given SQLContainer not defined.\");\r\n    }\r\n    Object refKey = getContainerProperty(itemId, r.getReferencingColumn()).getValue();\r\n    refdCont.removeAllContainerFilters();\r\n    refdCont.addContainerFilter(new Equal(r.getReferencedColumn(), refKey));\r\n    Object toReturn = refdCont.firstItemId();\r\n    refdCont.removeAllContainerFilters();\r\n    return toReturn;\r\n}"
}, {
	"Path": "com.vaadin.ui.dnd.DragSourceExtension.setDragData",
	"Comment": "set server side drag data. this data is available in the drop event andcan be used to transfer data between drag source and drop target if theyare in the same ui.",
	"Method": "void setDragData(Object data){\r\n    dragData = data;\r\n}"
}, {
	"Path": "com.vaadin.ui.Alignment.getBitMask",
	"Comment": "returns a bitmask representation of the alignment value. used internallyby terminal.",
	"Method": "int getBitMask(){\r\n    return bitMask;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.grid.DefaultEditorEventHandler.isTouchOpenEvent",
	"Comment": "returns whether the given event is a touch event that should open theeditor.",
	"Method": "boolean isTouchOpenEvent(EditorDomEvent<T> event){\r\n    final Event e = event.getDomEvent();\r\n    final int type = e.getTypeInt();\r\n    final double now = Duration.currentTimeMillis();\r\n    final int currentX = WidgetUtil.getTouchOrMouseClientX(e);\r\n    final int currentY = WidgetUtil.getTouchOrMouseClientY(e);\r\n    final boolean validTouchOpenEvent = type == Event.ONTOUCHEND && now - lastTouchEventTime < 500 && lastTouchEventRow == event.getCell().getRowIndex() && Math.abs(lastTouchEventX - currentX) < 20 && Math.abs(lastTouchEventY - currentY) < 20;\r\n    if (type == Event.ONTOUCHSTART) {\r\n        lastTouchEventX = currentX;\r\n        lastTouchEventY = currentY;\r\n    }\r\n    if (type == Event.ONTOUCHEND) {\r\n        lastTouchEventTime = now;\r\n        lastTouchEventRow = event.getCell().getRowIndex();\r\n    }\r\n    return validTouchOpenEvent;\r\n}"
}, {
	"Path": "com.vaadin.v7.event.SelectionEvent.setDifference",
	"Comment": "slightly optimized set difference that can return the original set or amodified one.",
	"Method": "Set<T> setDifference(Set<T> set1,Set<T> set2){\r\n    if (set2.isEmpty()) {\r\n        return set1;\r\n    } else {\r\n        LinkedHashSet<T> set = new LinkedHashSet<T>(set1);\r\n        set.removeAll(set2);\r\n        return set;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addFooterKeyUpHandler",
	"Comment": "register a footerkeyuphandler to this grid. the event for this handler isfired when a keyup event occurs while cell focus is in the footer of thisgrid.",
	"Method": "HandlerRegistration addFooterKeyUpHandler(FooterKeyUpHandler handler){\r\n    return addHandler(handler, GridKeyUpEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.setFocusChangeListener",
	"Comment": "the given focuschangelistener is notified when the focused date changesby user either clicking on a new date or by using the keyboard.",
	"Method": "void setFocusChangeListener(FocusChangeListener listener){\r\n    focusChangeListener = listener;\r\n}"
}, {
	"Path": "com.vaadin.client.Profiler.initialize",
	"Comment": "initializes the profiler. this should be done before calling any otherfunction in this class. failing to do so might cause undesired behavior.this method has no side effects if the initialization has already beendone.please note that this method should be called even if the profiler is notenabled because it will then remove a logger function that might havebeen included in the html page and that would leak memory unless removed.",
	"Method": "void initialize(){\r\n    if (hasHighPrecisionTime()) {\r\n        RELATIVE_TIME_SUPPLIER = new HighResolutionTimeSupplier();\r\n    } else {\r\n        RELATIVE_TIME_SUPPLIER = new DefaultRelativeTimeSupplier();\r\n    }\r\n    if (isEnabled()) {\r\n        ensureLogger();\r\n    } else {\r\n        ensureNoLogger();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.data.TreeData.addRootItems",
	"Comment": "adds the items of the given stream as root items to this structure.",
	"Method": "TreeData<T> addRootItems(T items,TreeData<T> addRootItems,Collection<T> items,TreeData<T> addRootItems,Stream<T> items){\r\n    addItems(null, items);\r\n    return this;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.getMainWidth",
	"Comment": "get the width of the select in pixels where the text area and icon hasbeen included.",
	"Method": "int getMainWidth(){\r\n    return getOffsetWidth();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.OptionGroup.isHtmlContentAllowed",
	"Comment": "checks whether captions are interpreted as html or plain text.",
	"Method": "boolean isHtmlContentAllowed(){\r\n    return htmlContentAllowed;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.components.calendar.ContainerEventProvider.listenToContainerEvents",
	"Comment": "attaches listeners to the container so container events can be processed",
	"Method": "void listenToContainerEvents(){\r\n    if (container instanceof ItemSetChangeNotifier) {\r\n        ((ItemSetChangeNotifier) container).addItemSetChangeListener(this);\r\n    }\r\n    if (container instanceof ValueChangeNotifier) {\r\n        ((ValueChangeNotifier) container).addValueChangeListener(this);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VUpload.ensureTargetFrame",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void ensureTargetFrame(){\r\n    if (synthesizedFrame == null) {\r\n        DivElement dummy = Document.get().createDivElement();\r\n        dummy.setInnerHTML(\"<iframe src=\\\"javascript:''\\\" name='\" + getFrameName() + \"' style='position:absolute;width:0;height:0;border:0'>\");\r\n        synthesizedFrame = dummy.getFirstChildElement();\r\n        Document.get().getBody().appendChild(synthesizedFrame);\r\n        element.setTarget(getFrameName());\r\n        onloadstrategy.hookEvents(synthesizedFrame, this);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignAttributeHandler.assignValue",
	"Comment": "assigns the specified design attribute to the given component.",
	"Method": "boolean assignValue(Object target,String attribute,String value){\r\n    if (target == null || attribute == null || value == null) {\r\n        throw new IllegalArgumentException(\"Parameters with null value not allowed\");\r\n    }\r\n    boolean success = false;\r\n    try {\r\n        Method setter = findSetterForAttribute(target.getClass(), attribute);\r\n        if (setter == null) {\r\n            success = false;\r\n        } else {\r\n            Type[] types = GenericTypeReflector.getExactParameterTypes(setter, target.getClass());\r\n            Object param = getFormatter().parse(value, (Class<?>) types[0]);\r\n            setter.invoke(target, param);\r\n            success = true;\r\n        }\r\n    } catch (Exception e) {\r\n        getLogger().log(Level.WARNING, \"Failed to set value \\\"\" + value + \"\\\" to attribute \" + attribute, e);\r\n    }\r\n    if (!success) {\r\n        getLogger().info(\"property \" + attribute + \" ignored by default attribute handler\");\r\n    }\r\n    return success;\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.datasources.ListSorter.removeFromGrid",
	"Comment": "detach this sorter from the grid. this unregisters the sort event handlerwhich was used to apply sorting to the listdatasource.",
	"Method": "void removeFromGrid(){\r\n    sortHandlerRegistration.removeHandler();\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.getDefaultHeaderRow",
	"Comment": "returns the current default row of the header section. the default row isa special header row providing a user interface for sorting columns.setting a header caption for column updates cells in the default header.",
	"Method": "HeaderRow getDefaultHeaderRow(){\r\n    return header.getDefaultRow();\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.cleanupSession",
	"Comment": "called at the end of a request, after sending the response. closesinactive uis in the given session, removes closed uis from the session,and closes the session if it is itself inactive.",
	"Method": "void cleanupSession(VaadinSession session){\r\n    if (isSessionActive(session)) {\r\n        closeInactiveUIs(session);\r\n        removeClosedUIs(session);\r\n    } else {\r\n        if (session.getState() == State.OPEN) {\r\n            closeSession(session);\r\n            if (session.getSession() != null) {\r\n                getLogger().log(Level.FINE, \"Closing inactive session {0}\", session.getSession().getId());\r\n            }\r\n        }\r\n        if (session.getSession() != null) {\r\n            removeSession(session.getSession());\r\n        }\r\n        fireSessionDestroy(session);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addHeaderKeyPressHandler",
	"Comment": "register a headerkeypresshandler to this grid. the event for this handleris fired when a keypress event occurs while cell focus is in the headerof this grid.",
	"Method": "HandlerRegistration addHeaderKeyPressHandler(HeaderKeyPressHandler handler){\r\n    return addHandler(handler, GridKeyPressEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponent.isCaptionAsHtml",
	"Comment": "checks whether captions are rendered as htmlthe default is false, i.e. to render that caption as plain text.",
	"Method": "boolean isCaptionAsHtml(){\r\n    return getState(false).captionAsHtml;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.PropertyFormatter.readOnlyStatusChange",
	"Comment": "listens for changes in the datasource.this should not be called directly.",
	"Method": "void readOnlyStatusChange(Property.ReadOnlyStatusChangeEvent event){\r\n    fireReadOnlyStatusChange();\r\n}"
}, {
	"Path": "com.github.dozermapper.core.functional_tests.EnumMapping_WithExceptionsLoggedTest.testEnumMapsToNonexistEnumValue",
	"Comment": "test on if mapping to nonexist enum value would throw exception.",
	"Method": "void testEnumMapsToNonexistEnumValue(){\r\n    LOG.error(\"WithExceptionsLoggedTest; 'IllegalArgumentException: No enum constant com.github.dozermapper.core.vo.enumtest.DestType.BAR'\");\r\n    testEnumMapsToNonexistEnumValueEE.expectMessage(\"Cannot convert [BAR] to enum of type class com.github.dozermapper.core.vo.enumtest.DestType\");\r\n    testEnumMapsToNonexistEnumValueEE.expect(MappingException.class);\r\n    mapper = getMapper(\"mappings/enumMapping.xml\");\r\n    MyBean src = newInstance(MyBean.class);\r\n    src.setSrcType(SrcType.BAR);\r\n    mapper.map(src, MyBeanPrime.class);\r\n}"
}, {
	"Path": "com.folioreader.ui.folio.activity.FolioActivity.getBottomDistraction",
	"Comment": "calculates the bottom distraction which can cause due to navigation bar.in mobile landscape mode, navigation bar is either to left or right of the screen.in tablet, navigation bar is always at bottom of the screen.",
	"Method": "int getBottomDistraction(){\r\n    int bottomDistraction = 0;\r\n    if (!distractionFreeMode)\r\n        bottomDistraction = appBarLayout.getNavigationBarHeight();\r\n    bottomDistraction /= density;\r\n    Log.v(LOG_TAG, \"-> getBottomDistraction = \" + bottomDistraction);\r\n    return bottomDistraction;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractBeanContainer.createBeanPropertyResolver",
	"Comment": "create an item identifier resolver using a named bean property.",
	"Method": "BeanIdResolver<IDTYPE, BEANTYPE> createBeanPropertyResolver(Object propertyId){\r\n    return new PropertyBasedBeanIdResolver(propertyId);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Tree.writeItems",
	"Comment": "recursively writes the root items and their children to a design.",
	"Method": "void writeItems(Element design,DesignContext context){\r\n    for (Object itemId : rootItemIds()) {\r\n        writeItem(design, itemId, context);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.SerializablePredicate.negate",
	"Comment": "returns a predicate that represents the logical negation of thispredicate.",
	"Method": "SerializablePredicate<T> negate(){\r\n    return t -> !test(t);\r\n}"
}, {
	"Path": "com.vaadin.client.widget.escalator.FlyweightCell.assertSetup",
	"Comment": "asserts that the flyweight cell has properly been set up before trying toaccess any of its data.",
	"Method": "void assertSetup(){\r\n    assert currentIterator != null : \"FlyweightCell was not properly \" + \"initialized. This is either a bug in Grid/Escalator \" + \"or a Cell reference has been stored and reused \" + \"inappropriately.\";\r\n}"
}, {
	"Path": "com.vaadin.client.debug.internal.VDebugWindow.getTimingTooltip",
	"Comment": "gets a nicely formatted string with timing information suitable fordisplay in tooltips.",
	"Method": "String getTimingTooltip(int sinceStart,int sinceReset){\r\n    String title = formatDuration(sinceStart) + \" since start\";\r\n    title += \", &#10; \" + formatDuration(sinceReset) + \" since timer reset\";\r\n    title += \" &#10; @ \" + DateTimeFormat.getFormat(\"HH:mm:ss.SSS\").format(new Date());\r\n    return title;\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.DefaultEditorEventHandler.triggerValueChangeEvent",
	"Comment": "triggers a value change event from the editor field if it has focus. thisis based on the assumption that editor field will fire the value changewhen a blur event occurs.",
	"Method": "void triggerValueChangeEvent(EditorDomEvent<T> event){\r\n    Widget editorWidget = event.getEditorWidget();\r\n    if (editorWidget != null) {\r\n        Element focusedElement = WidgetUtil.getFocusedElement();\r\n        if (editorWidget.getElement().isOrHasChild(focusedElement)) {\r\n            focusedElement.blur();\r\n            focusedElement.focus();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.folioreader.view.VerticalViewPager.setAdapter",
	"Comment": "set a pageradapter that will supply views for this pager as needed.",
	"Method": "void setAdapter(PagerAdapter adapter){\r\n    if (mAdapter != null) {\r\n        mAdapter.unregisterDataSetObserver(mObserver);\r\n        mAdapter.startUpdate(this);\r\n        for (int i = 0; i < mItems.size(); i++) {\r\n            final ItemInfo ii = mItems.get(i);\r\n            mAdapter.destroyItem(this, ii.position, ii.object);\r\n        }\r\n        mAdapter.finishUpdate(this);\r\n        mItems.clear();\r\n        removeNonDecorViews();\r\n        mCurItem = 0;\r\n        scrollTo(0, 0);\r\n    }\r\n    final PagerAdapter oldAdapter = mAdapter;\r\n    mAdapter = adapter;\r\n    mExpectedAdapterCount = 0;\r\n    if (mAdapter != null) {\r\n        if (mObserver == null) {\r\n            mObserver = new PagerObserver();\r\n        }\r\n        mAdapter.registerDataSetObserver(mObserver);\r\n        mPopulatePending = false;\r\n        final boolean wasFirstLayout = mFirstLayout;\r\n        mFirstLayout = true;\r\n        mExpectedAdapterCount = mAdapter.getCount();\r\n        if (mRestoredCurItem >= 0) {\r\n            mAdapter.restoreState(mRestoredAdapterState, mRestoredClassLoader);\r\n            setCurrentItemInternal(mRestoredCurItem, false, true);\r\n            mRestoredCurItem = -1;\r\n            mRestoredAdapterState = null;\r\n            mRestoredClassLoader = null;\r\n        } else if (!wasFirstLayout) {\r\n            populate();\r\n        } else {\r\n            requestLayout();\r\n        }\r\n    }\r\n    if (mAdapterChangeListener != null && oldAdapter != adapter) {\r\n        mAdapterChangeListener.onAdapterChanged(oldAdapter, adapter);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.DateTimeService.getFirstDayOfWeek",
	"Comment": "returns the first day of the week, according to the used locale.",
	"Method": "int getFirstDayOfWeek(){\r\n    try {\r\n        return LocaleService.getFirstDayOfWeek(locale);\r\n    } catch (final LocaleNotLoadedException e) {\r\n        getLogger().log(Level.SEVERE, \"Error in getFirstDayOfWeek\", e);\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "com.github.dozermapper.core.functional_tests.InvalidMapping_WithExceptionsLoggedTest.setDefaultLocale",
	"Comment": "messages of saxexceptions are localized, so we have to set the language to english as expected by the tests.",
	"Method": "void setDefaultLocale(){\r\n    Locale.setDefault(Locale.US);\r\n}"
}, {
	"Path": "com.commafeed.backend.feed.FeedUtils.normalizeURL",
	"Comment": "normalize the url. the resulting url is not meant to be fetched but rather used as a mean to identify a feed and avoid duplicates",
	"Method": "String normalizeURL(String url){\r\n    if (url == null) {\r\n        return null;\r\n    }\r\n    String normalized = URLCanonicalizer.getCanonicalURL(url);\r\n    if (normalized == null) {\r\n        normalized = url;\r\n    }\r\n    normalized = normalized.toLowerCase();\r\n    if (normalized.startsWith(\"https\")) {\r\n        normalized = \"http\" + normalized.substring(5);\r\n    }\r\n    normalized = normalized.replace(\"//www.\", \"//\");\r\n    normalized = normalized.replace(\"feedproxy.google.com\", \"feeds.feedburner.com\");\r\n    if (normalized.split(ESCAPED_QUESTION_MARK)[0].contains(\"feedburner.com\")) {\r\n        normalized = normalized.replace(\"feeds2.feedburner.com\", \"feeds.feedburner.com\");\r\n        normalized = normalized.split(ESCAPED_QUESTION_MARK)[0];\r\n        normalized = StringUtils.removeEnd(normalized, \"/\");\r\n    }\r\n    return normalized;\r\n}"
}, {
	"Path": "com.vaadin.client.Util.getElementUnderMouse",
	"Comment": "find the element corresponding to the coordinates in the passed mouseevent. please note that this is not always the same as the target of theevent e.g. if event capture is used.",
	"Method": "com.google.gwt.user.client.Element getElementUnderMouse(NativeEvent event){\r\n    return DOM.asOld(WidgetUtil.getElementUnderMouse(event));\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.buildCaptionHtmlSnippet",
	"Comment": "helper function to build html snippet for column or row headers.",
	"Method": "String buildCaptionHtmlSnippet(UIDL uidl){\r\n    String s = uidl.hasAttribute(\"caption\") ? uidl.getStringAttribute(\"caption\") : \"\";\r\n    if (uidl.hasAttribute(\"icon\")) {\r\n        Icon icon = client.getIcon(uidl.getStringAttribute(\"icon\"));\r\n        icon.setAlternateText(\"icon\");\r\n        s = icon.getElement().getString() + s;\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "bt.tracker.TrackerRequestBuilder.left",
	"Comment": "optionally set the amount of data left for the client to download.",
	"Method": "TrackerRequestBuilder left(long left){\r\n    if (left < 0) {\r\n        throw new BtException(\"Invalid left value: \" + left);\r\n    }\r\n    this.left = left;\r\n    return this;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.setClassLoader",
	"Comment": "sets the class loader to use for loading classes loaded by name, e.g.custom ui classes. invokers of this method should be careful to not breakany existing class loader hierarchy, e.g. by ensuring that a class loaderset for this service delegates to the previously set class loader if theclass is not found.",
	"Method": "void setClassLoader(ClassLoader classLoader){\r\n    if (classLoader == null) {\r\n        throw new IllegalArgumentException(\"Can not set class loader to null\");\r\n    }\r\n    this.classLoader = classLoader;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.HierarchyMapper.doFetchDirectChildren",
	"Comment": "generic method for finding direct children of a given parent, limited bygiven range.",
	"Method": "Stream<T> doFetchDirectChildren(T parent,Range range){\r\n    return getDataProvider().fetchChildren(new HierarchicalQuery(range.getStart(), range.length(), getBackEndSorting(), getInMemorySorting(), getFilter(), parent));\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.BeanItemContainerTest.testEmptyCollectionConstructor",
	"Comment": "this only applies to the collection constructor with no type parameter",
	"Method": "void testEmptyCollectionConstructor(){\r\n    try {\r\n        new BeanItemContainer<ClassName>((Collection<ClassName>) null);\r\n        fail(\"Initializing BeanItemContainer from a null collection should not work!\");\r\n    } catch (IllegalArgumentException e) {\r\n    }\r\n    try {\r\n        new BeanItemContainer<ClassName>(new ArrayList<ClassName>());\r\n        fail(\"Initializing BeanItemContainer from an empty collection should not work!\");\r\n    } catch (IllegalArgumentException e) {\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.data.provider.BackEndDataProvider.setSortOrder",
	"Comment": "sets a single sort order to use as the default sorting for this dataprovider. this overrides the sorting set by any other method thatmanipulates the default sorting of this data provider.the default sorting is used if the query defines no sorting. the defaultsorting is also used to determine the ordering of items that areconsidered equal by the sorting defined in the query.",
	"Method": "void setSortOrder(QuerySortOrder sortOrder){\r\n    if (sortOrder == null) {\r\n        setSortOrders(Collections.emptyList());\r\n    } else {\r\n        setSortOrders(Collections.singletonList(sortOrder));\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.extensions.DropTargetExtensionConnector.isDropAllowedByCriteriaScript",
	"Comment": "checks if a criteria script exists and, if yes, executes it. this methodis protected, so subclasses as e.g. griddroptargetconnector can overrideit to add additional script parameters.",
	"Method": "boolean isDropAllowedByCriteriaScript(NativeEvent event){\r\n    final String criteriaScript = getState().criteriaScript;\r\n    if (criteriaScript == null) {\r\n        return true;\r\n    }\r\n    return executeScript(event, criteriaScript);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.FocusUtil.focusOnLastFocusableElement",
	"Comment": "moves the focus to the last focusable child of given parent element.",
	"Method": "void focusOnLastFocusableElement(Element parent){\r\n    Element[] focusableChildren = getFocusableChildren(parent);\r\n    if (focusableChildren.length > 0) {\r\n        focusableChildren[focusableChildren.length - 1].focus();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VFilterSelect.afterUpdateClientVariables",
	"Comment": "anything that should be set after the client updates the server.",
	"Method": "void afterUpdateClientVariables(){\r\n    selectPopupItemWhenResponseIsReceived = Select.NONE;\r\n}"
}, {
	"Path": "com.vaadin.ui.NativeSelect.setEmptySelectionAllowed",
	"Comment": "sets whether the user is allowed to select nothing in the combo box. whentrue, a special empty item is shown to the user.",
	"Method": "void setEmptySelectionAllowed(boolean emptySelectionAllowed){\r\n    getState().emptySelectionAllowed = emptySelectionAllowed;\r\n}"
}, {
	"Path": "com.vaadin.client.Util.getElementFromPoint",
	"Comment": "returns the topmost element of from given coordinates.todo fix crossplat issues clientx vs pagex. see quircksmode. not criticalfor vaadin as we scroll div istead of page.",
	"Method": "com.google.gwt.user.client.Element getElementFromPoint(int clientX,int clientY){\r\n    return DOM.asOld(WidgetUtil.getElementFromPoint(clientX, clientY));\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Form.getFooter",
	"Comment": "returns a layout that is rendered below normal form contents. this areacan be used for example to include buttons related to form contents.",
	"Method": "Layout getFooter(){\r\n    return (Layout) getState(false).footer;\r\n}"
}, {
	"Path": "com.vaadin.client.connectors.grid.GridConnector.detailsRefreshed",
	"Comment": "method called for a row details refresh. runs all callbacks if anydetails were shown and clears the callbacks.",
	"Method": "void detailsRefreshed(boolean detailsShown){\r\n    if (detailsShown) {\r\n        refreshDetailsCallbacks.forEach(Runnable::run);\r\n    }\r\n    refreshDetailsCallbacks.clear();\r\n}"
}, {
	"Path": "com.vaadin.client.LayoutManager.addElementResizeListener",
	"Comment": "adds a listener that will be notified whenever the size of a specificelement changes. adding a listener to an element also ensures that allsizes for that element will be available starting from the next layoutphase.",
	"Method": "void addElementResizeListener(Element element,ElementResizeListener listener){\r\n    Collection<ElementResizeListener> listeners = elementResizeListeners.get(element);\r\n    if (listeners == null) {\r\n        listeners = new HashSet();\r\n        elementResizeListeners.put(element, listeners);\r\n        ensureMeasured(element);\r\n    }\r\n    listeners.add(listener);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.components.calendar.ContainerEventProvider.setStartDateProperty",
	"Comment": "set the property which provides the starting date and time of the event.",
	"Method": "void setStartDateProperty(Object startDateProperty){\r\n    this.startDateProperty = startDateProperty;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.setFocusOutListener",
	"Comment": "a focus out listener is triggered when the panel loosed focus. this canhappen either after a user clicks outside the panel or tabs out.",
	"Method": "void setFocusOutListener(FocusOutListener listener){\r\n    focusOutListener = listener;\r\n}"
}, {
	"Path": "com.github.dozermapper.core.converters.JAXBElementConverter.convert",
	"Comment": "convert the specified input object into an output object of thespecified type.",
	"Method": "Object convert(Class type,Object value){\r\n    Object result;\r\n    Object factory = objectFactory(destObjClass, beanContainer);\r\n    Class<?> factoryClass = factory.getClass();\r\n    Class<?> destClass = value.getClass();\r\n    Class<?> valueClass = value.getClass();\r\n    String methodName = \"create\" + destObjClass.substring(destObjClass.lastIndexOf(\".\") + 1) + StringUtils.capitalize(destFieldName);\r\n    Method method = null;\r\n    try {\r\n        method = ReflectionUtils.findAMethod(factoryClass, methodName, beanContainer);\r\n        Class<?>[] parameterTypes = method.getParameterTypes();\r\n        for (Class<?> parameterClass : parameterTypes) {\r\n            if (!valueClass.equals(parameterClass)) {\r\n                destClass = parameterClass;\r\n                break;\r\n            }\r\n        }\r\n        Class<?>[] paramTypes = { destClass };\r\n        method = ReflectionUtils.getMethod(factoryClass, methodName, paramTypes);\r\n    } catch (NoSuchMethodException e) {\r\n        MappingUtils.throwMappingException(e);\r\n    }\r\n    Object param = value;\r\n    Converter converter;\r\n    if (java.util.Date.class.isAssignableFrom(valueClass) && !destClass.equals(XMLGregorianCalendar.class)) {\r\n        converter = new DateConverter(dateFormat);\r\n        param = converter.convert(destClass, param);\r\n    } else if (java.util.Calendar.class.isAssignableFrom(valueClass) && !destClass.equals(XMLGregorianCalendar.class)) {\r\n        converter = new CalendarConverter(dateFormat);\r\n        param = converter.convert(destClass, param);\r\n    } else if (XMLGregorianCalendar.class.isAssignableFrom(valueClass) || XMLGregorianCalendar.class.isAssignableFrom(destClass)) {\r\n        converter = new XMLGregorianCalendarConverter(dateFormat);\r\n        param = converter.convert(destClass, param);\r\n    }\r\n    Object[] paramValues = { param };\r\n    result = ReflectionUtils.invoke(method, factory, paramValues);\r\n    return result;\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConnection.setCommunicationErrorDelegate",
	"Comment": "sets the delegate that is called whenever a communication error occurrs.",
	"Method": "void setCommunicationErrorDelegate(CommunicationErrorHandler delegate){\r\n    communicationErrorDelegate = delegate;\r\n}"
}, {
	"Path": "com.vaadin.ui.GridLayout.setRows",
	"Comment": "sets the number of rows in the grid. the number of rows can not bereduced if there are any areas that would be outside of the shrunk grid.",
	"Method": "void setRows(int rows){\r\n    if (rows < 1) {\r\n        throw new IllegalArgumentException(\"The number of columns and rows in the grid must be at least 1\");\r\n    }\r\n    if (getRows() == rows) {\r\n        return;\r\n    }\r\n    if (getRows() > rows) {\r\n        for (Entry<Connector, ChildComponentData> entry : getState().childData.entrySet()) {\r\n            if (entry.getValue().row2 >= rows) {\r\n                throw new OutOfBoundsException(new Area(entry.getValue(), (Component) entry.getKey()));\r\n            }\r\n        }\r\n    }\r\n    if (rows < getRows()) {\r\n        for (int i = rows; i < getRows(); i++) {\r\n            rowExpandRatio.remove(i);\r\n            getState().explicitRowRatios.remove(i);\r\n        }\r\n    }\r\n    getState().rows = rows;\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConfiguration.getUIDL",
	"Comment": "gets the initial uidl from the dom, if it was provided during the initprocess.",
	"Method": "String getUIDL(String getUIDL){\r\n    return getJsoConfiguration(id).getUIDL();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.schedule.CalendarEvent.getRangeInMinutesForDay",
	"Comment": "get the amount of minutes for the event on a specific day. this is usefulif the event spans several days.",
	"Method": "long getRangeInMinutesForDay(Date targetDay){\r\n    long rangeInMinutesForDay = 0;\r\n    if (isTimeOnDifferentDays()) {\r\n        if (targetDay.compareTo(getStart()) == 0) {\r\n            rangeInMinutesForDay = DateConstants.DAYINMINUTES - (getStartTime().getTime() - getStart().getTime()) / DateConstants.MINUTEINMILLIS;\r\n        } else if (targetDay.compareTo(getEnd()) == 0) {\r\n            rangeInMinutesForDay = (getEndTime().getTime() - getEnd().getTime()) / DateConstants.MINUTEINMILLIS;\r\n        } else {\r\n            rangeInMinutesForDay = DateConstants.DAYINMINUTES;\r\n        }\r\n    } else {\r\n        rangeInMinutesForDay = getRangeInMinutes();\r\n    }\r\n    return rangeInMinutesForDay;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.getAttribute",
	"Comment": "gets a stored attribute value. if a value has been stored for thesession, that value is returned. if no value is stored for the name,null is returned.",
	"Method": "Object getAttribute(String name,T getAttribute,Class<T> type){\r\n    assert hasLock();\r\n    if (type == null) {\r\n        throw new IllegalArgumentException(\"type can not be null\");\r\n    }\r\n    Object value = getAttribute(type.getName());\r\n    if (value == null) {\r\n        return null;\r\n    } else {\r\n        return type.cast(value);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VButton.cleanupCaptureState",
	"Comment": "resets internal state if this button can no longer service events. thiscan occur when the widget becomes detached or disabled.",
	"Method": "void cleanupCaptureState(){\r\n    if (isCapturing || isFocusing) {\r\n        DOM.releaseCapture(getElement());\r\n        isCapturing = false;\r\n        isFocusing = false;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.debug.internal.SelectorPath.getNameFromPredicates",
	"Comment": "get variable name based on predicates. fallback to elementtype",
	"Method": "String getNameFromPredicates(List<SelectorPredicate> predicates,String elementType){\r\n    String name = elementType;\r\n    for (SelectorPredicate p : predicates) {\r\n        if (\"caption\".equals(p.getName())) {\r\n            name = p.getValue() + elementType;\r\n        } else if (\"id\".equals(p.getName())) {\r\n            return p.getValue();\r\n        }\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.components.calendar.ContainerEventProvider.setDescriptionProperty",
	"Comment": "set the property which provides the description of the event.",
	"Method": "void setDescriptionProperty(Object descriptionProperty){\r\n    this.descriptionProperty = descriptionProperty;\r\n}"
}, {
	"Path": "com.github.dozermapper.core.loader.MappingsParser.processMappings",
	"Comment": "decorates raw classmap objects and performs various validations on the explicit field mappings.it applies global configuration and class level attributes to raw class mappings.",
	"Method": "ClassMappings processMappings(List<ClassMap> classMaps,Configuration globalConfiguration){\r\n    if (globalConfiguration == null) {\r\n        throw new IllegalArgumentException(\"Global configuration parameter cannot be null\");\r\n    }\r\n    ClassMappings result = new ClassMappings(beanContainer);\r\n    if (classMaps == null || classMaps.size() == 0) {\r\n        return result;\r\n    }\r\n    FieldMap fieldMapPrime;\r\n    ClassMap classMapPrime;\r\n    Set<String> mapIds = new HashSet();\r\n    for (ClassMap classMap : classMaps) {\r\n        classMap.setGlobalConfiguration(globalConfiguration);\r\n        ReflectionUtils.findPropertyDescriptor(classMap.getSrcClassToMap(), \"\", null);\r\n        ReflectionUtils.findPropertyDescriptor(classMap.getDestClassToMap(), \"\", null);\r\n        if (!MappingUtils.isBlankOrNull(classMap.getMapId())) {\r\n            if (mapIds.contains(classMap.getMapId())) {\r\n                throw new IllegalArgumentException(\"Duplicate Map Id's Found. Map Id: \" + classMap.getMapId());\r\n            }\r\n            mapIds.add(classMap.getMapId());\r\n        }\r\n        result.add(classMap.getSrcClassToMap(), classMap.getDestClassToMap(), classMap.getMapId(), classMap);\r\n        classMapPrime = new ClassMap(globalConfiguration);\r\n        MappingUtils.reverseFields(classMap, classMapPrime, beanContainer);\r\n        if (classMap.getFieldMaps() != null) {\r\n            List<FieldMap> fms = classMap.getFieldMaps();\r\n            if (!MappingDirection.ONE_WAY.equals(classMap.getType())) {\r\n                for (FieldMap fieldMap : fms.toArray(new FieldMap[] {})) {\r\n                    fieldMap.validate();\r\n                    if (!(fieldMap instanceof ExcludeFieldMap)) {\r\n                        if ((MappingUtils.isSupportedMap(classMap.getDestClassToMap()) ^ MappingUtils.isSupportedMap(classMap.getSrcClassToMap())) || (MappingUtils.isSupportedMap(fieldMap.getDestFieldType(classMap.getDestClassToMap())) ^ MappingUtils.isSupportedMap(fieldMap.getSrcFieldType(classMap.getSrcClassToMap())))) {\r\n                            FieldMap fm = new MapFieldMap(fieldMap, beanContainer, destBeanCreator, propertyDescriptorFactory);\r\n                            classMap.removeFieldMapping(fieldMap);\r\n                            classMap.addFieldMapping(fm);\r\n                            fieldMap = fm;\r\n                        }\r\n                    }\r\n                    if (MappingUtils.isSupportedMap(classMap.getSrcClassToMap()) && fieldMap.getSrcFieldKey() == null) {\r\n                        DozerField newSrcField = fieldMap.getSrcFieldCopy();\r\n                        newSrcField.setName(DozerConstants.SELF_KEYWORD);\r\n                        newSrcField.setKey(fieldMap.getSrcFieldName());\r\n                        fieldMap.setSrcField(newSrcField);\r\n                    }\r\n                    if (MappingUtils.isSupportedMap(classMap.getDestClassToMap()) && fieldMap.getDestFieldKey() == null) {\r\n                        DozerField newDestField = fieldMap.getDestFieldCopy();\r\n                        newDestField.setName(DozerConstants.SELF_KEYWORD);\r\n                        newDestField.setKey(fieldMap.getDestFieldName());\r\n                        fieldMap.setDestField(newDestField);\r\n                    }\r\n                    if (!(MappingDirection.ONE_WAY.equals(fieldMap.getType()) && !(fieldMap instanceof ExcludeFieldMap))) {\r\n                        fieldMapPrime = (FieldMap) fieldMap.clone();\r\n                        fieldMapPrime.setClassMap(classMapPrime);\r\n                        if (fieldMapPrime instanceof ExcludeFieldMap && MappingDirection.ONE_WAY.equals(fieldMap.getType())) {\r\n                            fieldMapPrime = new GenericFieldMap(classMapPrime, beanContainer, destBeanCreator, propertyDescriptorFactory);\r\n                        }\r\n                        MappingUtils.reverseFields(fieldMap, fieldMapPrime);\r\n                        if (!(fieldMap instanceof ExcludeFieldMap)) {\r\n                            MappingUtils.applyGlobalCopyByReference(globalConfiguration, fieldMap, classMap);\r\n                        }\r\n                        if (!(fieldMapPrime instanceof ExcludeFieldMap)) {\r\n                            MappingUtils.applyGlobalCopyByReference(globalConfiguration, fieldMapPrime, classMapPrime);\r\n                        }\r\n                    } else {\r\n                        fieldMapPrime = new ExcludeFieldMap(classMapPrime, beanContainer, destBeanCreator, propertyDescriptorFactory);\r\n                        MappingUtils.reverseFields(fieldMap, fieldMapPrime);\r\n                        MappingUtils.applyGlobalCopyByReference(globalConfiguration, fieldMap, classMap);\r\n                    }\r\n                    classMapPrime.addFieldMapping(fieldMapPrime);\r\n                }\r\n            } else {\r\n                for (FieldMap oneWayFieldMap : fms.toArray(new FieldMap[] {})) {\r\n                    oneWayFieldMap.validate();\r\n                    MappingUtils.applyGlobalCopyByReference(globalConfiguration, oneWayFieldMap, classMap);\r\n                    if (MappingDirection.ONE_WAY.equals(oneWayFieldMap.getType())) {\r\n                        fieldMapPrime = new ExcludeFieldMap(classMapPrime, beanContainer, destBeanCreator, propertyDescriptorFactory);\r\n                        MappingUtils.reverseFields(oneWayFieldMap, fieldMapPrime);\r\n                        classMapPrime.addFieldMapping(fieldMapPrime);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!MappingDirection.ONE_WAY.equals(classMap.getType())) {\r\n            result.add(classMap.getDestClassToMap(), classMap.getSrcClassToMap(), classMap.getMapId(), classMapPrime);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.greenrobot.essentials.io.CircularByteBuffer.get",
	"Comment": "gets as many of the requested bytes as available from this buffer.",
	"Method": "int get(int get,byte[] dst,int get,byte[] dst,int off,int len){\r\n    if (available == 0) {\r\n        return 0;\r\n    }\r\n    int limit = idxGet < idxPut ? idxPut : capacity;\r\n    int count = Math.min(limit - idxGet, len);\r\n    System.arraycopy(buffer, idxGet, dst, off, count);\r\n    idxGet += count;\r\n    if (idxGet == capacity) {\r\n        int count2 = Math.min(len - count, idxPut);\r\n        if (count2 > 0) {\r\n            System.arraycopy(buffer, 0, dst, off + count, count2);\r\n            idxGet = count2;\r\n            count += count2;\r\n        } else {\r\n            idxGet = 0;\r\n        }\r\n    }\r\n    available -= count;\r\n    return count;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.onTabOut",
	"Comment": "if true should be returned if the panel will not be used after thisevent.",
	"Method": "boolean onTabOut(DomEvent<?> event){\r\n    if (focusOutListener != null) {\r\n        return focusOutListener.onFocusOut(event);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.client.communication.ServerRpcQueue.isJavascriptRpc",
	"Comment": "checks if the given method invocation originates from javascript.",
	"Method": "boolean isJavascriptRpc(MethodInvocation invocation){\r\n    return invocation instanceof JavaScriptMethodInvocation;\r\n}"
}, {
	"Path": "com.vaadin.client.communication.JsonEncoder.encode",
	"Comment": "encode a value to a json representation for transport from the client tothe server.",
	"Method": "JsonValue encode(Object value,Type type,ApplicationConnection connection){\r\n    if (null == value) {\r\n        return Json.createNull();\r\n    } else if (value instanceof JsonValue) {\r\n        return (JsonValue) value;\r\n    } else if (value instanceof String[]) {\r\n        String[] array = (String[]) value;\r\n        JsonArray jsonArray = Json.createArray();\r\n        for (int i = 0; i < array.length; ++i) {\r\n            jsonArray.set(i, array[i]);\r\n        }\r\n        return jsonArray;\r\n    } else if (value instanceof String) {\r\n        return Json.create((String) value);\r\n    } else if (value instanceof Boolean) {\r\n        return Json.create((Boolean) value);\r\n    } else if (value instanceof Number) {\r\n        return Json.create(((Number) value).doubleValue());\r\n    } else if (value instanceof Character) {\r\n        return Json.create(String.valueOf(value));\r\n    } else if (value instanceof Object[] && type == null) {\r\n        return encodeLegacyObjectArray((Object[]) value, connection);\r\n    } else if (value instanceof Enum) {\r\n        return encodeEnum((Enum<?>) value, connection);\r\n    } else if (value instanceof Map) {\r\n        return encodeMap((Map) value, type, connection);\r\n    } else if (value instanceof Connector) {\r\n        Connector connector = (Connector) value;\r\n        return Json.create(connector.getConnectorId());\r\n    } else if (value instanceof Collection) {\r\n        return encodeCollection((Collection) value, type, connection);\r\n    } else if (value instanceof UidlValue) {\r\n        return encodeVariableChange((UidlValue) value, connection);\r\n    } else {\r\n        JSONSerializer<Object> serializer = null;\r\n        if (type != null) {\r\n            serializer = (JSONSerializer<Object>) type.findSerializer();\r\n            if (serializer != null) {\r\n                return serializer.serialize(value, connection);\r\n            }\r\n        }\r\n        String transportType = getTransportType(value);\r\n        if (transportType != null) {\r\n            return Json.create(String.valueOf(value));\r\n        } else if (type != null) {\r\n            try {\r\n                JsArrayObject<Property> properties = type.getPropertiesAsArray();\r\n                JsonObject jsonObject = Json.createObject();\r\n                int size = properties.size();\r\n                for (int i = 0; i < size; i++) {\r\n                    Property property = properties.get(i);\r\n                    Object propertyValue = property.getValue(value);\r\n                    Type propertyType = property.getType();\r\n                    JsonValue encodedPropertyValue = encode(propertyValue, propertyType, connection);\r\n                    jsonObject.put(property.getName(), encodedPropertyValue);\r\n                }\r\n                return jsonObject;\r\n            } catch (NoDataException e) {\r\n                throw new RuntimeException(\"Can not encode \" + type.getSignature(), e);\r\n            }\r\n        } else {\r\n            throw new RuntimeException(\"Can't encode \" + value.getClass() + \" without type information\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConfiguration.isDebugMode",
	"Comment": "checks if client side is in debug mode. practically this is invoked byadding ?debug parameter to uri. please note that debug mode is alwaysdisabled if production mode is enabled, but disabling production modedoes not automatically enable debug mode.",
	"Method": "boolean isDebugMode(){\r\n    return isDebugAvailable() && Window.Location.getParameter(\"debug\") != null;\r\n}"
}, {
	"Path": "com.vaadin.server.themeutils.SASSAddonImportFileCreator.updateTheme",
	"Comment": "updates a themes addons.scss with the addon themes found on theclasspath.",
	"Method": "void updateTheme(String themeDirectory){\r\n    File addonImports = new File(themeDirectory, ADDON_IMPORTS_FILE);\r\n    if (!addonImports.exists()) {\r\n        addonImports.getParentFile().mkdirs();\r\n        addonImports.createNewFile();\r\n    }\r\n    LocationInfo info = ClassPathExplorer.getAvailableWidgetSetsAndStylesheets();\r\n    try (PrintStream printStream = new PrintStream(new FileOutputStream(addonImports))) {\r\n        printStream.println(\"/* \" + ADDON_IMPORTS_FILE_TEXT + \" */\");\r\n        printStream.println(\"/* Do not manually edit this file. */\");\r\n        printStream.println();\r\n        Map<String, URL> addonThemes = info.getAddonStyles();\r\n        List<String> paths = new ArrayList(addonThemes.keySet());\r\n        Collections.sort(paths, (String path1, String path2) -> {\r\n            if (path1.toLowerCase(Locale.ROOT).endsWith(\".css\") && path2.toLowerCase(Locale.ROOT).endsWith(\".scss\")) {\r\n                return -1;\r\n            }\r\n            if (path1.toLowerCase(Locale.ROOT).endsWith(\".scss\") && path2.toLowerCase(Locale.ROOT).endsWith(\".css\")) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n        List<String> mixins = new ArrayList();\r\n        for (String path : paths) {\r\n            mixins.addAll(addImport(printStream, path, addonThemes.get(path)));\r\n            printStream.println();\r\n        }\r\n        createAddonsMixin(printStream, mixins);\r\n    } catch (FileNotFoundException e) {\r\n        getLogger().log(Level.WARNING, \"Error updating addons.scss\", e);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.communication.ServerRpcQueue.showLoadingIndicator",
	"Comment": "checks if a loading indicator should be shown when the rpcs have beensent to the server and we are waiting for a response.",
	"Method": "boolean showLoadingIndicator(){\r\n    for (MethodInvocation invocation : getAll()) {\r\n        if (isLegacyVariableChange(invocation) || isJavascriptRpc(invocation)) {\r\n            return true;\r\n        } else {\r\n            Type type = new Type(invocation.getInterfaceName(), null);\r\n            Method method = type.getMethod(invocation.getMethodName());\r\n            if (!TypeDataStore.isNoLoadingIndicator(method)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.getConnectorString",
	"Comment": "returns a string with the connector name and id. useful mostly fordebugging and logging.",
	"Method": "String getConnectorString(ClientConnector connector){\r\n    if (connector == null) {\r\n        return \"(null)\";\r\n    }\r\n    String connectorId;\r\n    try {\r\n        connectorId = connector.getConnectorId();\r\n    } catch (RuntimeException e) {\r\n        connectorId = \"@\" + Integer.toHexString(connector.hashCode());\r\n    }\r\n    return connector.getClass().getName() + \"(\" + connectorId + \")\";\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.getActionID",
	"Comment": "get the original action id that was passed in from the shared state.",
	"Method": "String getActionID(String actionKey){\r\n    return actionMap.get(actionKey + \"_k\");\r\n}"
}, {
	"Path": "com.vaadin.client.RenderSpace.getWidth",
	"Comment": "returns pixels available horizontally for contained widget, includingpossible scrollbars.",
	"Method": "int getWidth(){\r\n    return super.getWidth();\r\n}"
}, {
	"Path": "com.vaadin.server.communication.AtmospherePushConnection.enableAtmosphereDebugLogging",
	"Comment": "internal method used for reconfiguring loggers to show all atmosphere logmessages in the console.",
	"Method": "void enableAtmosphereDebugLogging(){\r\n    Level level = Level.FINEST;\r\n    Logger atmosphereLogger = Logger.getLogger(\"org.atmosphere\");\r\n    if (atmosphereLogger.getLevel() == level) {\r\n        return;\r\n    }\r\n    atmosphereLogger.setLevel(level);\r\n    LogRecord record = new LogRecord(Level.INFO, \"Enabling Atmosphere debug logging\");\r\n    atmosphereLogger.log(record);\r\n    ConsoleHandler ch = new ConsoleHandler();\r\n    ch.setLevel(Level.ALL);\r\n    atmosphereLogger.addHandler(ch);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.grid.datasources.ListSorter.getComparator",
	"Comment": "retrieve the comparator assigned for a specific grid column.",
	"Method": "Comparator<C> getComparator(Grid.Column<C, T> column){\r\n    if (column == null) {\r\n        throw new IllegalArgumentException(\"Column reference can not be null\");\r\n    }\r\n    return (Comparator<C>) comparators.get(column);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.getColumns",
	"Comment": "returns a copy of currently configures columns in their current visualorder in this grid.",
	"Method": "List<Column> getColumns(){\r\n    List<Column> columns = new ArrayList<Grid.Column>();\r\n    for (String columnId : getState(false).columnOrder) {\r\n        columns.add(getColumnByColumnId(columnId));\r\n    }\r\n    return Collections.unmodifiableList(columns);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.PropertysetItem.getItemProperty",
	"Comment": "gets the property corresponding to the given property id stored in theitem. if the item does not contain the property, null isreturned.",
	"Method": "Property getItemProperty(Object id){\r\n    return map.get(id);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VFlash.rebuildIfNeeded",
	"Comment": "call this after changing values of widget. it will rebuild embeddingstructure if needed.",
	"Method": "void rebuildIfNeeded(){\r\n    if (needsRebuild) {\r\n        needsRebuild = false;\r\n        this.setHTML(createFlashEmbed());\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.extensions.DropTargetExtensionConnector.removeDropListeners",
	"Comment": "removes dragenter, dragover, dragleave and drop event listeners from thegiven dom element.",
	"Method": "void removeDropListeners(Element element){\r\n    EventTarget target = element.cast();\r\n    target.removeEventListener(Event.DRAGENTER, dragEnterListener);\r\n    target.removeEventListener(Event.DRAGOVER, dragOverListener);\r\n    target.removeEventListener(Event.DRAGLEAVE, dragLeaveListener);\r\n    target.removeEventListener(Event.DROP, dropListener);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.AbstractConnector.unregisterRpc",
	"Comment": "unregisters an implementation for a server to client rpc interface.",
	"Method": "void unregisterRpc(Class<T> rpcInterface,T implementation){\r\n    String rpcInterfaceId = rpcInterface.getName().replaceAll(\"\\\\$\", \".\");\r\n    if (null != rpcImplementations && null != rpcImplementations.get(rpcInterfaceId)) {\r\n        rpcImplementations.get(rpcInterfaceId).remove(implementation);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConnection.analyzeLayouts",
	"Comment": "requests an analyze of layouts, to find inconsistencies. exclusively usedfor debugging during development.",
	"Method": "void analyzeLayouts(){\r\n    getUIConnector().analyzeLayouts();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.discardRowsOutsideCacheWindow",
	"Comment": "updates the internal cache by unlinking rows that fall outside of thecaching window.",
	"Method": "void discardRowsOutsideCacheWindow(){\r\n    int firstRowToKeep = (int) (firstRowInViewPort - pageLength * cacheRate);\r\n    int lastRowToKeep = (int) (firstRowInViewPort + pageLength + pageLength * cacheRate);\r\n    if (firstRowToKeep < 0) {\r\n        firstRowToKeep = 0;\r\n    }\r\n    if (lastRowToKeep > totalRows) {\r\n        lastRowToKeep = totalRows - 1;\r\n    }\r\n    debug(\"Client side calculated cache rows to keep: \" + firstRowToKeep + \"-\" + lastRowToKeep);\r\n    if (serverCacheFirst != -1) {\r\n        firstRowToKeep = serverCacheFirst;\r\n        lastRowToKeep = serverCacheLast;\r\n        debug(\"Server cache rows that override: \" + serverCacheFirst + \"-\" + serverCacheLast);\r\n        if (firstRowToKeep < scrollBody.getFirstRendered() || lastRowToKeep > scrollBody.getLastRendered()) {\r\n            debug(\"*** Server wants us to keep \" + serverCacheFirst + \"-\" + serverCacheLast + \" but we only have rows \" + scrollBody.getFirstRendered() + \"-\" + scrollBody.getLastRendered() + \" rendered!\");\r\n        }\r\n    }\r\n    discardRowsOutsideOf(firstRowToKeep, lastRowToKeep);\r\n    scrollBody.fixSpacers();\r\n    scrollBody.restoreRowVisibility();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.getEditorWidget",
	"Comment": "returns the editor widget associated with the given column. if the editoris not active, returns null.",
	"Method": "Widget getEditorWidget(Widget getEditorWidget,Column<?, T> column){\r\n    return editor.getWidget(column);\r\n}"
}, {
	"Path": "com.vaadin.client.componentlocator.VaadinFinderLocatorStrategy.filterMatches",
	"Comment": "go through a list of potentially matching components, modifying that listuntil all elements that remain in that list match the complete list ofpredicates.",
	"Method": "List<ComponentConnector> filterMatches(List<ComponentConnector> potentialMatches,List<SelectorPredicate> predicates){\r\n    for (SelectorPredicate p : predicates) {\r\n        if (p.getIndex() > -1) {\r\n            try {\r\n                ComponentConnector v = potentialMatches.get(p.getIndex());\r\n                potentialMatches.clear();\r\n                potentialMatches.add(v);\r\n            } catch (IndexOutOfBoundsException e) {\r\n                potentialMatches.clear();\r\n            }\r\n            continue;\r\n        }\r\n        for (int i = 0, l = potentialMatches.size(); i < l; ++i) {\r\n            String propData = getPropertyValue(potentialMatches.get(i), p.getName());\r\n            if ((p.isWildcard() && propData == null) || (!p.isWildcard() && !p.getValue().equals(propData))) {\r\n                potentialMatches.remove(i);\r\n                --l;\r\n                --i;\r\n            }\r\n        }\r\n    }\r\n    return eliminateDuplicates(potentialMatches);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.getContainerProperty",
	"Comment": "gets the property identified by the given itemid and propertyid from thecontainer.",
	"Method": "Property getContainerProperty(Object itemId,Object propertyId){\r\n    return items.getContainerProperty(itemId, propertyId);\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Overlay.isFitInWindow",
	"Comment": "checks whether the overlay should be moved or shrunk to fit inside thewindow.",
	"Method": "boolean isFitInWindow(){\r\n    return fitInWindow;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.getHeader",
	"Comment": "returns the header section of this grid. the default header contains asingle row displaying the column captions.",
	"Method": "Header getHeader(){\r\n    return header;\r\n}"
}, {
	"Path": "com.vaadin.server.LocaleServiceTest.generateData",
	"Comment": "helper method for generating the above data using localeservice.",
	"Method": "void generateData(Locale locale){\r\n    System.out.println();\r\n    String id = locale.getLanguage();\r\n    if (!locale.getCountry().isEmpty()) {\r\n        id += \"_\" + locale.getCountry();\r\n        if (!locale.getVariant().isEmpty()) {\r\n            id += \"_\" + locale.getVariant();\r\n        }\r\n    }\r\n    String field = id.replace('-', '_');\r\n    LocaleService localeService = new LocaleService(Mockito.mock(UI.class), new LocaleServiceState());\r\n    LocaleData localeData = localeService.createLocaleData(locale);\r\n    System.out.println(\"LocaleData \" + field + \" = new LocaleData();\");\r\n    System.out.println(field + \".dateFormat = \\\"\" + localeData.dateFormat + \"\\\";\");\r\n    System.out.println(field + \".twelveHourClock = \" + localeData.twelveHourClock + \";\");\r\n    System.out.println(field + \".hourMinuteDelimiter = \\\"\" + localeData.hourMinuteDelimiter + \"\\\";\");\r\n    if (localeData.twelveHourClock) {\r\n        System.out.println(field + \".am = \\\"\" + localeData.am + \"\\\";\");\r\n        System.out.println(field + \".pm = \\\"\" + localeData.pm + \"\\\";\");\r\n    }\r\n    System.out.println(\"expectedLocaleData.put(new Locale(\\\"\" + id.replaceAll(\"_\", \"\\\",\\\"\") + \"\\\"), \" + field + \");\");\r\n}"
}, {
	"Path": "lbms.plugins.mldht.kad.RPCCall.injectStall",
	"Comment": "when external circumstances indicate that this request is probably stalled and will time out",
	"Method": "void injectStall(){\r\n    stateTransition(EnumSet.of(RPCState.SENT), RPCState.STALLED);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheetBase.addTabKey",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void addTabKey(String key,boolean disabled){\r\n    tabKeys.add(key);\r\n    if (disabled) {\r\n        disabledTabKeys.add(key);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.ContainerHierarchicalWrapper.addToHierarchyWrapper",
	"Comment": "adds the specified item specified to the internal hierarchy structure.the new item is added as a root item. the underlying container is notmodified.",
	"Method": "void addToHierarchyWrapper(Object itemId){\r\n    roots.add(itemId);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VSlider.getNavigationDownKey",
	"Comment": "get the key that decreases the vertical slider. by default it is the downarrow key but by overriding this you can change the key to whatever youwant.",
	"Method": "int getNavigationDownKey(){\r\n    return KeyCodes.KEY_DOWN;\r\n}"
}, {
	"Path": "com.vaadin.v7.tests.server.component.abstractfield.AbstractFieldValueChangeTestBase.testRemoveListener",
	"Comment": "test that listeners are not called when they have been unregistered.",
	"Method": "void testRemoveListener(){\r\n    getField().setPropertyDataSource(new ObjectProperty<String>(\"\"));\r\n    getField().setBuffered(false);\r\n    listener.valueChange(EasyMock.isA(ValueChangeEvent.class));\r\n    EasyMock.replay(listener);\r\n    getField().addListener(listener);\r\n    setValue(getField());\r\n    EasyMock.verify(listener);\r\n    getField().removeListener(listener);\r\n    setValue(getField());\r\n    EasyMock.verify(listener);\r\n}"
}, {
	"Path": "com.vaadin.client.debug.internal.InfoSection.equalsEither",
	"Comment": "checks if the target value equals one of the reference values",
	"Method": "boolean equalsEither(String target,String reference1,String reference2){\r\n    if (SharedUtil.equals(target, reference1)) {\r\n        return true;\r\n    }\r\n    if (SharedUtil.equals(target, reference2)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.addRequestHandler",
	"Comment": "adds a request handler to this session. request handlers can be added toprovide responses to requests that are not handled by the defaultfunctionality of the framework.handlers are called in reverse order of addition, so the most recentlyadded handler will be called first.",
	"Method": "void addRequestHandler(RequestHandler handler){\r\n    assert hasLock();\r\n    requestHandlers.addFirst(handler);\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.Design.findClassWithAnnotation",
	"Comment": "find the first class with the given annotation, starting the search fromthe given class and moving upwards in the class hierarchy.",
	"Method": "Class<? extends Component> findClassWithAnnotation(Class<? extends Component> componentClass,Class<? extends Annotation> annotationClass){\r\n    if (componentClass == null) {\r\n        return null;\r\n    }\r\n    if (componentClass.isAnnotationPresent(annotationClass)) {\r\n        return componentClass;\r\n    }\r\n    Class<?> superClass = componentClass.getSuperclass();\r\n    if (!Component.class.isAssignableFrom(superClass)) {\r\n        return null;\r\n    }\r\n    return findClassWithAnnotation(superClass.asSubclass(Component.class), annotationClass);\r\n}"
}, {
	"Path": "com.github.dozermapper.core.converters.JAXBElementConverter.objectFactory",
	"Comment": "returns a new instance of objectfactory, or the cached one if previously created.",
	"Method": "Object objectFactory(String destObjClass,BeanContainer beanContainer){\r\n    String objectFactoryClassName = destObjClass.substring(0, destObjClass.lastIndexOf(\".\")) + \".ObjectFactory\";\r\n    if (objectFactory == null || objectFactoryClass == null || !objectFactoryClass.getCanonicalName().equals(objectFactoryClassName)) {\r\n        objectFactoryClass = MappingUtils.loadClass(objectFactoryClassName, beanContainer);\r\n        objectFactory = ReflectionUtils.newInstance(objectFactoryClass);\r\n    }\r\n    return objectFactory;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.getHeader",
	"Comment": "returns the header section of this grid. the default header contains asingle row displaying the column captions.",
	"Method": "Header getHeader(){\r\n    return header;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.grid.DefaultEditorEventHandler.triggerValueChangeEvent",
	"Comment": "triggers a value change event from the editor field if it has focus. thisis based on the assumption that editor field will fire the value changewhen a blur event occurs.",
	"Method": "void triggerValueChangeEvent(EditorDomEvent<T> event){\r\n    Widget editorWidget = event.getEditorWidget();\r\n    if (editorWidget != null) {\r\n        Element focusedElement = WidgetUtil.getFocusedElement();\r\n        if (editorWidget.getElement().isOrHasChild(focusedElement)) {\r\n            focusedElement.blur();\r\n            focusedElement.focus();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.CacheFlushNotifier.addInstance",
	"Comment": "adds the given sqlcontainer to the cache flush notification receiver list",
	"Method": "void addInstance(SQLContainer c){\r\n    removeDeadReferences();\r\n    if (c != null) {\r\n        allInstances.add(new WeakReference<SQLContainer>(c, deadInstances));\r\n    }\r\n}"
}, {
	"Path": "com.github.dozermapper.core.classmap.ClassMapBuilder.addDefaultFieldMappings",
	"Comment": "prepares default mappings based on provided mapping definition",
	"Method": "void addDefaultFieldMappings(ClassMappings classMappings,Configuration globalConfiguration){\r\n    Set<Entry<String, ClassMap>> entries = classMappings.getAll().entrySet();\r\n    for (Entry<String, ClassMap> entry : entries) {\r\n        ClassMap classMap = entry.getValue();\r\n        generateMapping(classMap, globalConfiguration, runTimeGenerators);\r\n    }\r\n}"
}, {
	"Path": "bt.it.fixture.SwarmBuilder.module",
	"Comment": "provide a custom feature, that will be used by all swarm participants.",
	"Method": "SwarmBuilder module(Module module){\r\n    this.modules.add(module);\r\n    return this;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendar.getEventClickListener",
	"Comment": "get the listener that listens to the user clicking on the events.",
	"Method": "EventClickListener getEventClickListener(){\r\n    return eventClickListener;\r\n}"
}, {
	"Path": "com.vaadin.client.ComputedStyle.getIntProperty",
	"Comment": "retrieves the given computed property as an integer.returns 0 if the property cannot be converted to an integer",
	"Method": "int getIntProperty(String name){\r\n    Profiler.enter(\"ComputedStyle.getIntProperty\");\r\n    String value = getProperty(name);\r\n    int result = parseIntNative(value);\r\n    Profiler.leave(\"ComputedStyle.getIntProperty\");\r\n    return result;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.FilesystemContainer.getFilter",
	"Comment": "returns the file filter used to limit the files in this container.",
	"Method": "FilenameFilter getFilter(){\r\n    return filter;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.setDefaultHandlers",
	"Comment": "set all the wanted default handlers here. this is always called afterconstructing this object. all other events have default handlers exceptrange and event click.",
	"Method": "void setDefaultHandlers(){\r\n    setHandler(new BasicBackwardHandler());\r\n    setHandler(new BasicForwardHandler());\r\n    setHandler(new BasicWeekClickHandler());\r\n    setHandler(new BasicDateClickHandler());\r\n    setHandler(new BasicEventMoveHandler());\r\n    setHandler(new BasicEventResizeHandler());\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractTextField.setSelection",
	"Comment": "sets the range of text to be selected.as a side effect the field will become focused.",
	"Method": "void setSelection(int start,int length){\r\n    getRpcProxy(AbstractTextFieldClientRpc.class).selectRange(start, length);\r\n    focus();\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addBodyKeyDownHandler",
	"Comment": "register a bodykeydownhandler to this grid. the event for this handler isfired when a keydown event occurs while cell focus is in the body of thisgrid.",
	"Method": "HandlerRegistration addBodyKeyDownHandler(BodyKeyDownHandler handler){\r\n    return addHandler(handler, GridKeyDownEvent.TYPE);\r\n}"
}, {
	"Path": "bt.it.fixture.SwarmPeer.getPeer",
	"Comment": "get standard bt peer, representing this swarm participant.",
	"Method": "Peer getPeer(){\r\n    return runtime.service(IPeerRegistry.class).getLocalPeer();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendar.setEventCaptionAsHtml",
	"Comment": "sets whether the event captions are rendered as html.if set to true, the captions are rendered in the browser as html and thedeveloper is responsible for ensuring no harmful html is used. if set tofalse, the caption is rendered in the browser as plain text.the default is false, i.e. to render that caption as plain text.",
	"Method": "void setEventCaptionAsHtml(boolean eventCaptionAsHtml){\r\n    this.eventCaptionAsHtml = eventCaptionAsHtml;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.createAndRegisterSession",
	"Comment": "creates and registers a new vaadinsession for this service. assumesproper locking has been taken care of by the caller.",
	"Method": "VaadinSession createAndRegisterSession(VaadinRequest request){\r\n    assert ((ReentrantLock) getSessionLock(request.getWrappedSession())).isHeldByCurrentThread() : \"Session has not been locked by this thread\";\r\n    VaadinSession session = createVaadinSession(request);\r\n    VaadinSession.setCurrent(session);\r\n    storeSession(session, request.getWrappedSession());\r\n    session.getBrowser().updateRequestDetails(request);\r\n    Locale locale = request.getLocale();\r\n    session.setLocale(locale);\r\n    session.setConfiguration(getDeploymentConfiguration());\r\n    session.setCommunicationManager(new LegacyCommunicationManager(session));\r\n    ServletPortletHelper.initDefaultUIProvider(session, this);\r\n    onVaadinSessionStarted(request, session);\r\n    return session;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTree.getLastRootNode",
	"Comment": "returns the last root node of the tree or null if there are no rootnodes.",
	"Method": "TreeNode getLastRootNode(){\r\n    if (body.getWidgetCount() == 0) {\r\n        return null;\r\n    }\r\n    return (TreeNode) body.getWidget(body.getWidgetCount() - 1);\r\n}"
}, {
	"Path": "com.vaadin.client.LayoutManager.registerDependency",
	"Comment": "registers that a managedlayout is depending on the size of an element.this causes this layout manager to measure the element in the beginningof every layout phase and call the appropriate layout method of themanaged layout if the size of the element has changed.",
	"Method": "void registerDependency(ManagedLayout owner,Element element){\r\n    MeasuredSize measuredSize = ensureMeasured(element);\r\n    setNeedsLayout(owner);\r\n    measuredSize.addDependent(owner.getConnectorId());\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.getPageLength",
	"Comment": "gets the page length.setting page length 0 disables paging.",
	"Method": "int getPageLength(){\r\n    return pageLength;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addHeaderKeyUpHandler",
	"Comment": "register a headerkeyuphandler to this grid. the event for this handler isfired when a keyup event occurs while cell focus is in the header of thisgrid.",
	"Method": "HandlerRegistration addHeaderKeyUpHandler(HeaderKeyUpHandler handler){\r\n    return addHandler(handler, GridKeyUpEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.server.Page.getStyles",
	"Comment": "returns that stylesheet associated with this page. the stylesheetcontains additional styles injected at runtime into the html document.",
	"Method": "Styles getStyles(){\r\n    if (styles == null) {\r\n        styles = new Styles(uI);\r\n    }\r\n    return styles;\r\n}"
}, {
	"Path": "com.vaadin.server.StreamResource.getBufferSize",
	"Comment": "gets the size of the download buffer used for this resource.if the buffer size is 0, the buffer size is decided by the terminaladapter. the default value is 0.",
	"Method": "int getBufferSize(){\r\n    return bufferSize;\r\n}"
}, {
	"Path": "com.github.sundeepk.compactcalendarview.CompactCalendarController.drawEventsWithPlus",
	"Comment": "draw 2 eventsbymonthandyearmap followed by plus indicator to show there are more than 2 eventsbymonthandyearmap",
	"Method": "void drawEventsWithPlus(Canvas canvas,float xPosition,float yPosition,List<Event> eventsList){\r\n    for (int j = 0, k = -2; j < 3; j++, k += 2) {\r\n        Event event = eventsList.get(j);\r\n        float xStartPosition = xPosition + (xIndicatorOffset * k);\r\n        if (j == 2) {\r\n            dayPaint.setColor(multiEventIndicatorColor);\r\n            dayPaint.setStrokeWidth(multiDayIndicatorStrokeWidth);\r\n            canvas.drawLine(xStartPosition - smallIndicatorRadius, yPosition, xStartPosition + smallIndicatorRadius, yPosition, dayPaint);\r\n            canvas.drawLine(xStartPosition, yPosition - smallIndicatorRadius, xStartPosition, yPosition + smallIndicatorRadius, dayPaint);\r\n            dayPaint.setStrokeWidth(0);\r\n        } else {\r\n            drawEventIndicatorCircle(canvas, xStartPosition, yPosition, event.getColor());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.Dependency.findAndRegisterResources",
	"Comment": "finds all the urls defined for the given class using annotations for thegiven type, registers the urls to the communication manager and adds theregistered dependencies to the given list.",
	"Method": "void findAndRegisterResources(Type type,Class<? extends ClientConnector> cls,LegacyCommunicationManager manager,List<Dependency> dependencies){\r\n    Annotation[] annotations = cls.getAnnotationsByType(type.annotationType);\r\n    if (annotations != null) {\r\n        for (Annotation annotation : annotations) {\r\n            String[] resources;\r\n            if (annotation instanceof StyleSheet) {\r\n                resources = ((StyleSheet) annotation).value();\r\n            } else if (annotation instanceof JavaScript) {\r\n                resources = ((JavaScript) annotation).value();\r\n            } else if (annotation instanceof HtmlImport) {\r\n                resources = ((HtmlImport) annotation).value();\r\n            } else {\r\n                throw new IllegalArgumentException(\"Unknown annotation type: \" + annotation.annotationType().getName());\r\n            }\r\n            for (String resource : resources) {\r\n                String url = manager.registerDependency(resource, cls);\r\n                dependencies.add(new Dependency(type, url));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.data.provider.DataCommunicator.onDropRows",
	"Comment": "triggered when rows have been dropped from the client side cache.",
	"Method": "void onDropRows(JsonArray keys){\r\n    for (int i = 0; i < keys.length(); ++i) {\r\n        handler.dropActiveData(keys.getString(i));\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.dnd.event.DragEndEvent.getComponent",
	"Comment": "returns the drag source component where the dragend event occurred.",
	"Method": "T getComponent(){\r\n    return (T) super.getComponent();\r\n}"
}, {
	"Path": "com.ryanharter.viewpager.ViewPager.addFocusables",
	"Comment": "we only want the current page that is being shown to be focusable.",
	"Method": "void addFocusables(ArrayList<View> views,int direction,int focusableMode){\r\n    final int focusableCount = views.size();\r\n    final int descendantFocusability = getDescendantFocusability();\r\n    if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {\r\n        for (int i = 0; i < getChildCount(); i++) {\r\n            final View child = getChildAt(i);\r\n            if (child.getVisibility() == VISIBLE) {\r\n                ItemInfo ii = infoForChild(child);\r\n                if (ii != null && ii.position == mCurItem) {\r\n                    child.addFocusables(views, direction, focusableMode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (descendantFocusability != FOCUS_AFTER_DESCENDANTS || (focusableCount == views.size())) {\r\n        if (!isFocusable()) {\r\n            return;\r\n        }\r\n        if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && isInTouchMode() && !isFocusableInTouchMode()) {\r\n            return;\r\n        }\r\n        if (views != null) {\r\n            views.add(this);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.event.PointerDownEvent.getType",
	"Comment": "gets the event type associated with pointerdownevent events.",
	"Method": "Type<PointerDownHandler> getType(){\r\n    return TYPE;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.getPreviousKey",
	"Comment": "the key that selects the previous week in the calendar. by default thisis the up arrow key but by overriding this method it can be changed towhatever you like.",
	"Method": "int getPreviousKey(){\r\n    return KeyCodes.KEY_UP;\r\n}"
}, {
	"Path": "com.vaadin.client.Util.canWeSkipChildMeasurement",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "boolean canWeSkipChildMeasurement(ComponentConnector child){\r\n    if (child instanceof ElementResizeListener || child instanceof ManagedLayout || child instanceof AbstractLayoutConnector) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.grid.selection.ClickSelectHandler.setDeselectAllowed",
	"Comment": "sets whether clicking the currently selected row should deselect the row.",
	"Method": "void setDeselectAllowed(boolean deselectAllowed){\r\n    this.deselectAllowed = deselectAllowed;\r\n}"
}, {
	"Path": "net.openhft.chronicle.queue.impl.single.SingleChronicleQueueBuilder.onRingBufferStats",
	"Comment": "consumer will be called every second, also as there is data to report",
	"Method": "SingleChronicleQueueBuilder onRingBufferStats(Consumer<BytesRingBufferStats> onRingBufferStats,Consumer<BytesRingBufferStats> onRingBufferStats){\r\n    return this.onRingBufferStats == null ? NoBytesRingBufferStats.NONE : onRingBufferStats;\r\n}"
}, {
	"Path": "com.vaadin.event.ListenerMethod.getTarget",
	"Comment": "returns the target object which contains the trigger method.",
	"Method": "Object getTarget(){\r\n    return target;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.HierarchyMapper.getParentIndex",
	"Comment": "finds the index of the parent of the item in given target index.",
	"Method": "Integer getParentIndex(T item){\r\n    List<T> flatHierarchy = getHierarchy(null).collect(Collectors.toList());\r\n    return flatHierarchy.indexOf(getParentOfItem(item));\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractField.convertFromModel",
	"Comment": "convert the given value from the data source type to the ui type.",
	"Method": "T convertFromModel(Object newValue,T convertFromModel,Object newValue,Locale locale){\r\n    return ConverterUtil.convertFromModel(newValue, getType(), getConverter(), locale);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VPopupCalendar.setDescriptionForAssistiveDevices",
	"Comment": "set a description that explains the usage of the widget for users ofassistive devices.",
	"Method": "void setDescriptionForAssistiveDevices(String descriptionForAssistiveDevices){\r\n    descriptionForAssistiveDevicesElement.setInnerText(descriptionForAssistiveDevices);\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addFooterKeyPressHandler",
	"Comment": "register a footerkeypresshandler to this grid. the event for this handleris fired when a keypress event occurs while cell focus is in the footerof this grid.",
	"Method": "HandlerRegistration addFooterKeyPressHandler(FooterKeyPressHandler handler){\r\n    return addHandler(handler, GridKeyPressEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.DateField.setDateOutOfRangeMessage",
	"Comment": "sets the current error message if the range validation fails.",
	"Method": "void setDateOutOfRangeMessage(String dateOutOfRangeMessage){\r\n    this.dateOutOfRangeMessage = dateOutOfRangeMessage;\r\n    updateRangeValidator();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.setItemDescriptionGenerator",
	"Comment": "set the item description generator which generates tooltips for cells androws in the table.",
	"Method": "void setItemDescriptionGenerator(ItemDescriptionGenerator generator){\r\n    if (generator != itemDescriptionGenerator) {\r\n        itemDescriptionGenerator = generator;\r\n        refreshRenderedCells();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.componentlocator.VaadinFinderLocatorStrategy.generateQueries",
	"Comment": "function to generate all possible search paths for given component list.function strips out all the com.vaadin.ui. prefixes from elements as thisfunctionality makes generating a query later on easier.",
	"Method": "List<String> generateQueries(List<String> components){\r\n    List<String> paths = new ArrayList();\r\n    int compIdx = 0;\r\n    String basePath = components.get(compIdx).replace(\"com.vaadin.ui.\", \"\");\r\n    paths.add((components.size() == 1 ? \"/\" : \"//\") + basePath);\r\n    while (++compIdx < components.size()) {\r\n        for (int i = components.size() - 1; i >= compIdx; --i) {\r\n            boolean recursive = false;\r\n            if (i > compIdx) {\r\n                recursive = true;\r\n            }\r\n            paths.add((i == components.size() - 1 ? \"/\" : \"//\") + components.get(i).replace(\"com.vaadin.ui.\", \"\") + (recursive ? \"//\" : \"/\") + basePath);\r\n        }\r\n        basePath = components.get(compIdx).replace(\"com.vaadin.ui.\", \"\") + \"/\" + basePath;\r\n    }\r\n    return paths;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheetBase.isDynamicHeight",
	"Comment": "returns true if the height of the widget is undefined, false otherwise.",
	"Method": "boolean isDynamicHeight(){\r\n    return getConnectorForWidget(this).isUndefinedHeight();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.SQLContainer.enableCacheFlushNotifications",
	"Comment": "calling this will enable this sqlcontainer to send and receive cacheflush notifications for its lifetime.",
	"Method": "void enableCacheFlushNotifications(){\r\n    if (!notificationsEnabled) {\r\n        notificationsEnabled = true;\r\n        CacheFlushNotifier.addInstance(this);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.setEditable",
	"Comment": "sets the editable property.if table is editable a editor of type field is created for each tablecell. the assigned fieldfactory is used to create the instances.to provide custom editors for table cells create a class implementing thefieldfactory interface, and assign it to table, and set the editableproperty to true.",
	"Method": "void setEditable(boolean editable){\r\n    this.editable = editable;\r\n    refreshRowCache();\r\n}"
}, {
	"Path": "com.vaadin.data.provider.Query.getOffset",
	"Comment": "gets the first index of items to fetch. the offset is only used whenfetching items, but not when counting the number of available items.",
	"Method": "int getOffset(){\r\n    return offset;\r\n}"
}, {
	"Path": "com.vaadin.client.connectors.grid.GridDragSourceConnector.dragMultipleRows",
	"Comment": "tells if multiple rows are dragged. returns true if multiple selection isallowed and a selected row is dragged.",
	"Method": "boolean dragMultipleRows(JsonObject draggedRow){\r\n    SelectionModel<JsonObject> selectionModel = getGrid().getSelectionModel();\r\n    return selectionModel.isSelectionAllowed() && selectionModel instanceof MultiSelectionModelConnector.MultiSelectionModel && selectionModel.isSelected(draggedRow);\r\n}"
}, {
	"Path": "com.vaadin.osgi.resources.impl.PathFormatHelper.getWidgetsetAlias",
	"Comment": "returns the alias for a widgetset given a the widgetset name and a pathprefix.",
	"Method": "String getWidgetsetAlias(String widgetsetName,String pathPrefix){\r\n    return String.format(VAADIN_WIDGETSET_ALIAS_FORMAT, pathPrefix, widgetsetName);\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignContext.addComponentCreationListener",
	"Comment": "adds a component creation listener. the listener will be notified whencomponents are created while parsing a design template",
	"Method": "Registration addComponentCreationListener(ComponentCreationListener listener){\r\n    listeners.add(listener);\r\n    return () -> listeners.remove(listener);\r\n}"
}, {
	"Path": "com.vaadin.client.DateTimeService.isTwelveHourClock",
	"Comment": "returns whether the locale has twelve hour, or twenty four hour clock.",
	"Method": "boolean isTwelveHourClock(){\r\n    try {\r\n        return LocaleService.isTwelveHourClock(locale);\r\n    } catch (final LocaleNotLoadedException e) {\r\n        getLogger().log(Level.SEVERE, \"Error in isTwelveHourClock\", e);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.dd.VDragAndDropManager.getEventHandleStrategy",
	"Comment": "returns dnd strategy to handle native preview events used by the manager.subclasses can override this method to return custom strategy or use gwtdeferred binding.",
	"Method": "DDEventHandleStrategy getEventHandleStrategy(){\r\n    if (eventHandleStrategy == null) {\r\n        eventHandleStrategy = GWT.create(DDEventHandleStrategy.class);\r\n    }\r\n    return eventHandleStrategy;\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridSingleSelect.select",
	"Comment": "selects the given item. if another item was already selected, that itemis deselected.",
	"Method": "void select(T item){\r\n    model.select(item);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VGridLayout.distributeRowSpanHeights",
	"Comment": "iterates rowspanned cells, ensures rows have enough space to accommodatethem",
	"Method": "void distributeRowSpanHeights(){\r\n    for (SpanList list : rowSpans) {\r\n        for (Cell cell : list.cells) {\r\n            int height = cell.hasRelativeHeight() ? 0 : cell.getHeight();\r\n            distributeSpanSize(rowHeights, cell.row, cell.rowspan, getVerticalSpacing(), height, rowExpandRatioArray);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VRichTextArea.selectAll",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void selectAll(){\r\n    new Timer() {\r\n        @Override\r\n        public void run() {\r\n            rta.getFormatter().selectAll();\r\n        }\r\n    }.schedule(320);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VRichTextArea.selectAll",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void selectAll(){\r\n    rta.getFormatter().selectAll();\r\n}"
}, {
	"Path": "com.vaadin.client.ComputedStyle.getDoubleProperty",
	"Comment": "retrieves the given computed property as a double.returns nan if the property cannot be converted to a double",
	"Method": "double getDoubleProperty(String name){\r\n    Profiler.enter(\"ComputedStyle.getDoubleProperty\");\r\n    String value = getProperty(name);\r\n    double result = parseDoubleNative(value);\r\n    Profiler.leave(\"ComputedStyle.getDoubleProperty\");\r\n    return result;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.setEventCaptionAsHtml",
	"Comment": "sets whether the event captions are rendered as html.if set to true, the captions are rendered in the browser as html and thedeveloper is responsible for ensuring no harmful html is used. if set tofalse, the caption is rendered in the browser as plain text.the default is false, i.e. to render that caption as plain text.",
	"Method": "void setEventCaptionAsHtml(boolean eventCaptionAsHtml){\r\n    getState().eventCaptionAsHtml = eventCaptionAsHtml;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.removeUI",
	"Comment": "called by the framework to remove an ui instance from the session becauseit has been closed.",
	"Method": "void removeUI(UI ui){\r\n    assert hasLock() : \"Session is locked\";\r\n    assert UI.getCurrent() != null : \"Current UI cannot be null\";\r\n    assert ui != null : \"Removed UI cannot be null\";\r\n    assert UI.getCurrent().getUIId() == ui.getUIId() : \"UIs don't match\";\r\n    Integer id = Integer.valueOf(ui.getUIId());\r\n    ui.setSession(null);\r\n    uIs.remove(id);\r\n    String embedId = ui.getEmbedId();\r\n    if (embedId != null && id.equals(embedIdMap.get(embedId))) {\r\n        embedIdMap.remove(embedId);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractTextField.setCursorPosition",
	"Comment": "sets the cursor position in the field. as a side effect the field willbecome focused.",
	"Method": "void setCursorPosition(int pos){\r\n    setSelection(pos, 0);\r\n}"
}, {
	"Path": "com.vaadin.server.communication.PushHandler.onMessage",
	"Comment": "called when a message is received through the push connection",
	"Method": "void onMessage(AtmosphereResource resource){\r\n    callWithUi(resource, receiveCallback, resource.transport() == TRANSPORT.WEBSOCKET);\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractEmbedded.setSource",
	"Comment": "sets the object source resource. the dimensions are assumed if possible.the type is guessed from resource.",
	"Method": "void setSource(Resource source){\r\n    setResource(AbstractEmbeddedState.SOURCE_RESOURCE, source);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendar.getEventMovedListener",
	"Comment": "get the listener that listens to when event is dragged to a new location.",
	"Method": "EventMovedListener getEventMovedListener(){\r\n    return eventMovedListener;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheet.setTabIndex",
	"Comment": "for internal use only. may be renamed or removed in a future release.",
	"Method": "void setTabIndex(int tabIndex){\r\n    tabulatorIndex = tabIndex;\r\n    Tab activeTab = getActiveTab();\r\n    if (activeTab != null) {\r\n        activeTab.setTabulatorIndex(tabIndex);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.updateSelectionProperties",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void updateSelectionProperties(UIDL uidl,AbstractComponentState state,boolean readOnly){\r\n    setMultiSelectMode(uidl.hasAttribute(\"multiselectmode\") ? uidl.getIntAttribute(\"multiselectmode\") : MULTISELECT_MODE_DEFAULT);\r\n    nullSelectionAllowed = uidl.hasAttribute(\"nsa\") ? uidl.getBooleanAttribute(\"nsa\") : true;\r\n    if (uidl.hasAttribute(\"selectmode\")) {\r\n        if (readOnly) {\r\n            selectMode = SelectMode.NONE;\r\n        } else if (uidl.getStringAttribute(\"selectmode\").equals(\"multi\")) {\r\n            selectMode = SelectMode.MULTI;\r\n        } else if (uidl.getStringAttribute(\"selectmode\").equals(\"single\")) {\r\n            selectMode = SelectMode.SINGLE;\r\n        } else {\r\n            selectMode = SelectMode.NONE;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Form.removeItemProperty",
	"Comment": "removes the property and corresponding field from the form.",
	"Method": "boolean removeItemProperty(Object id){\r\n    ownProperties.remove(id);\r\n    final Field<?> field = fields.get(id);\r\n    if (field != null) {\r\n        propertyIds.remove(id);\r\n        fields.remove(id);\r\n        detachField(field);\r\n        field.removeListener(fieldValueChangeListener);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.SQLContainer.hasContainerFilters",
	"Comment": "returns true if any filters have been applied to the container.",
	"Method": "boolean hasContainerFilters(){\r\n    return !getContainerFilters().isEmpty();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.sanitizeSelection",
	"Comment": "checks that the current selection is valid, i.e. the selected item idsexist in the container. updates the selection if one or several selecteditem ids are no longer available in the container.",
	"Method": "void sanitizeSelection(){\r\n    Object value = getValue();\r\n    if (value == null) {\r\n        return;\r\n    }\r\n    boolean changed = false;\r\n    if (isMultiSelect()) {\r\n        Collection<Object> valueAsCollection = (Collection<Object>) value;\r\n        List<Object> newSelection = new ArrayList<Object>(valueAsCollection.size());\r\n        for (Object subValue : valueAsCollection) {\r\n            if (containsId(subValue)) {\r\n                newSelection.add(subValue);\r\n            } else {\r\n                changed = true;\r\n            }\r\n        }\r\n        if (changed) {\r\n            setValue(newSelection);\r\n        }\r\n    } else {\r\n        if (!containsId(value)) {\r\n            setValue(null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.writeStringResponse",
	"Comment": "writes the given string as a response using the given content type.",
	"Method": "void writeStringResponse(VaadinResponse response,String contentType,String responseString){\r\n    response.setContentType(contentType);\r\n    final OutputStream out = response.getOutputStream();\r\n    try (PrintWriter outWriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, UTF_8)))) {\r\n        outWriter.print(responseString);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.data.provider.DataCommunicator.getDataProvider",
	"Comment": "gets the current data provider from this datacommunicator.",
	"Method": "DataProvider<T, ?> getDataProvider(){\r\n    return dataProvider;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.RowItem.removeItemProperty",
	"Comment": "removing properties is not supported. properties are generated bysqlcontainer.",
	"Method": "boolean removeItemProperty(Object id){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.setRowStyleGenerator",
	"Comment": "sets the style generator that is used for generating styles for rows.",
	"Method": "void setRowStyleGenerator(RowStyleGenerator<T> rowStyleGenerator){\r\n    this.rowStyleGenerator = rowStyleGenerator;\r\n    requestRefreshBody();\r\n}"
}, {
	"Path": "com.vaadin.client.extensions.ResponsiveConnector.constructSelectorsForTarget",
	"Comment": "construct the list of selectors that should be matched against in therange selectors.",
	"Method": "String constructSelectorsForTarget(){\r\n    String primaryStyle = target.getState().primaryStyleName;\r\n    StringBuilder selectors = new StringBuilder();\r\n    selectors.append('.').append(primaryStyle);\r\n    if (target.getState().styles != null && !target.getState().styles.isEmpty()) {\r\n        for (String style : target.getState().styles) {\r\n            selectors.append(\",.\").append(style);\r\n            selectors.append(\",.\").append(primaryStyle).append('.').append(style);\r\n            selectors.append(\",.\").append(style).append('.').append(primaryStyle);\r\n            selectors.append(\",.\").append(primaryStyle).append('-').append(style);\r\n        }\r\n    }\r\n    if (target.getState().id != null) {\r\n        selectors.append(\",#\").append(target.getState().id);\r\n    }\r\n    return selectors.toString();\r\n}"
}, {
	"Path": "com.vaadin.ui.TabSheet.updateSelection",
	"Comment": "checks if the current selection is valid, and updates the selection ifthe previously selected component is not visible and enabled. the firstvisible and enabled tab is selected if the current selection is empty orinvalid.this method does not fire tab change events, but the caller should do soif appropriate.",
	"Method": "boolean updateSelection(){\r\n    Component originalSelection = selected;\r\n    for (final Iterator<Component> i = getComponentIterator(); i.hasNext(); ) {\r\n        final Component component = i.next();\r\n        Tab tab = tabs.get(component);\r\n        Tab selectedTabInfo = null;\r\n        if (selected != null) {\r\n            selectedTabInfo = tabs.get(selected);\r\n        }\r\n        if (selected == null || selectedTabInfo == null || !selectedTabInfo.isVisible() || !selectedTabInfo.isEnabled()) {\r\n            if (tab.isEnabled() && tab.isVisible()) {\r\n                setSelected(component);\r\n                break;\r\n            } else {\r\n                setSelected(null);\r\n            }\r\n        }\r\n    }\r\n    return originalSelection != selected;\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConnection.getConnectionStateHandler",
	"Comment": "gets the communication error handler for this application.",
	"Method": "ConnectionStateHandler getConnectionStateHandler(){\r\n    return connectionStateHandler;\r\n}"
}, {
	"Path": "com.vaadin.client.widget.escalator.RowVisibilityChangeEvent.getFirstVisibleRow",
	"Comment": "gets the index of the first row that is at least partially visible.",
	"Method": "int getFirstVisibleRow(){\r\n    return visibleRows.getStart();\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.getLocaleService",
	"Comment": "returns the locale service which handles transmission of locale data tothe client.",
	"Method": "LocaleService getLocaleService(){\r\n    return localeService;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.GridSortOrder.desc",
	"Comment": "creates a new grid sort builder with given sorting using descending sortdirection.",
	"Method": "GridSortOrderBuilder<T> desc(Column<T, ?> by){\r\n    return new GridSortOrderBuilder<T>().thenDesc(by);\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.removeUnregisteredConnectors",
	"Comment": "removes all references and information about connectors marked asunregistered.",
	"Method": "void removeUnregisteredConnectors(){\r\n    GlobalResourceHandler globalResourceHandler = uI.getSession().getGlobalResourceHandler(false);\r\n    for (ClientConnector connector : unregisteredConnectors) {\r\n        removeUnregisteredConnector(connector, globalResourceHandler);\r\n    }\r\n    unregisteredConnectors.clear();\r\n}"
}, {
	"Path": "com.ryanharter.viewpager.ViewPager.canScroll",
	"Comment": "tests scrollability within child views of v given a delta of dx.",
	"Method": "boolean canScroll(View v,boolean checkV,int dx,int x,int y,boolean canScroll){\r\n    if (v instanceof ViewGroup) {\r\n        final ViewGroup group = (ViewGroup) v;\r\n        final int scrollX = v.getScrollX();\r\n        final int scrollY = v.getScrollY();\r\n        final int count = group.getChildCount();\r\n        for (int i = count - 1; i >= 0; i--) {\r\n            final View child = group.getChildAt(i);\r\n            if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && canScroll(child, true, dx, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    boolean canScroll = false;\r\n    if (isOrientationHorizontal()) {\r\n        canScroll = ViewCompat.canScrollHorizontally(v, -dx);\r\n    } else {\r\n        canScroll = ViewCompat.canScrollVertically(v, -dx);\r\n    }\r\n    return checkV && canScroll;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.nativeselect.NativeSelectConnector.onDataChange",
	"Comment": "a data change handler registered to the data source. updates the dataitems and selection status when the data source notifies of new changesfrom the server side.",
	"Method": "void onDataChange(Range range){\r\n    assert range.getStart() == 0 && range.getEnd() == getDataSource().size() : \"NativeSelect only supports full updates, but got range \" + range;\r\n    final VNativeSelect select = getWidget();\r\n    final int itemCount = select.getListBox().getItemCount();\r\n    int increment = getState().emptySelectionAllowed ? 1 : 0;\r\n    for (int i = range.getStart() + increment; i < range.getEnd() + increment; i++) {\r\n        final JsonObject row = getDataSource().getRow(i - increment);\r\n        if (i < itemCount) {\r\n            select.getListBox().setItemText(i, getRowData(row).asString());\r\n            select.getListBox().setValue(i, getRowKey(row));\r\n        } else {\r\n            select.getListBox().addItem(getRowData(row).asString(), getRowKey(row));\r\n        }\r\n    }\r\n    for (int i = select.getListBox().getItemCount() - 1; i >= range.getEnd() + increment; i--) {\r\n        select.getListBox().removeItem(i);\r\n    }\r\n    updateSelectedItem();\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.MultiSelectionModelImpl.asMultiSelect",
	"Comment": "gets a wrapper for using this grid as a multiselect in a binder.",
	"Method": "MultiSelect<T> asMultiSelect(){\r\n    return new MultiSelect<T>() {\r\n        @Override\r\n        public void setValue(Set<T> value) {\r\n            Objects.requireNonNull(value);\r\n            Set<T> copy = value.stream().map(Objects::requireNonNull).collect(Collectors.toCollection(LinkedHashSet::new));\r\n            updateSelection(copy, new LinkedHashSet(getSelectedItems()));\r\n        }\r\n        @Override\r\n        public Set<T> getValue() {\r\n            return getSelectedItems();\r\n        }\r\n        @Override\r\n        public Registration addValueChangeListener(com.vaadin.data.HasValue.ValueChangeListener<Set<T>> listener) {\r\n            return addSelectionListener(event -> listener.valueChange(event));\r\n        }\r\n        @Override\r\n        public void setRequiredIndicatorVisible(boolean requiredIndicatorVisible) {\r\n            throw new UnsupportedOperationException(\"Required indicator is not supported in grid.\");\r\n        }\r\n        @Override\r\n        public boolean isRequiredIndicatorVisible() {\r\n            throw new UnsupportedOperationException(\"Required indicator is not supported in grid.\");\r\n        }\r\n        @Override\r\n        public void setReadOnly(boolean readOnly) {\r\n            setUserSelectionAllowed(!readOnly);\r\n        }\r\n        @Override\r\n        public boolean isReadOnly() {\r\n            return !isUserSelectionAllowed();\r\n        }\r\n        @Override\r\n        public void updateSelection(Set<T> addedItems, Set<T> removedItems) {\r\n            MultiSelectionModelImpl.this.updateSelection(addedItems, removedItems);\r\n        }\r\n        @Override\r\n        public Set<T> getSelectedItems() {\r\n            return MultiSelectionModelImpl.this.getSelectedItems();\r\n        }\r\n        @Override\r\n        public Registration addSelectionListener(MultiSelectionListener<T> listener) {\r\n            return MultiSelectionModelImpl.this.addMultiSelectionListener(listener);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.MultiSelectionModelImpl.asMultiSelect",
	"Comment": "gets a wrapper for using this grid as a multiselect in a binder.",
	"Method": "MultiSelect<T> asMultiSelect(){\r\n    Objects.requireNonNull(value);\r\n    Set<T> copy = value.stream().map(Objects::requireNonNull).collect(Collectors.toCollection(LinkedHashSet::new));\r\n    updateSelection(copy, new LinkedHashSet(getSelectedItems()));\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.MultiSelectionModelImpl.asMultiSelect",
	"Comment": "gets a wrapper for using this grid as a multiselect in a binder.",
	"Method": "MultiSelect<T> asMultiSelect(){\r\n    return getSelectedItems();\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.MultiSelectionModelImpl.asMultiSelect",
	"Comment": "gets a wrapper for using this grid as a multiselect in a binder.",
	"Method": "MultiSelect<T> asMultiSelect(){\r\n    return addSelectionListener(event -> listener.valueChange(event));\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.MultiSelectionModelImpl.asMultiSelect",
	"Comment": "gets a wrapper for using this grid as a multiselect in a binder.",
	"Method": "MultiSelect<T> asMultiSelect(){\r\n    throw new UnsupportedOperationException(\"Required indicator is not supported in grid.\");\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.MultiSelectionModelImpl.asMultiSelect",
	"Comment": "gets a wrapper for using this grid as a multiselect in a binder.",
	"Method": "MultiSelect<T> asMultiSelect(){\r\n    throw new UnsupportedOperationException(\"Required indicator is not supported in grid.\");\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.MultiSelectionModelImpl.asMultiSelect",
	"Comment": "gets a wrapper for using this grid as a multiselect in a binder.",
	"Method": "MultiSelect<T> asMultiSelect(){\r\n    setUserSelectionAllowed(!readOnly);\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.MultiSelectionModelImpl.asMultiSelect",
	"Comment": "gets a wrapper for using this grid as a multiselect in a binder.",
	"Method": "MultiSelect<T> asMultiSelect(){\r\n    return !isUserSelectionAllowed();\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.MultiSelectionModelImpl.asMultiSelect",
	"Comment": "gets a wrapper for using this grid as a multiselect in a binder.",
	"Method": "MultiSelect<T> asMultiSelect(){\r\n    MultiSelectionModelImpl.this.updateSelection(addedItems, removedItems);\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.MultiSelectionModelImpl.asMultiSelect",
	"Comment": "gets a wrapper for using this grid as a multiselect in a binder.",
	"Method": "MultiSelect<T> asMultiSelect(){\r\n    return MultiSelectionModelImpl.this.getSelectedItems();\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.MultiSelectionModelImpl.asMultiSelect",
	"Comment": "gets a wrapper for using this grid as a multiselect in a binder.",
	"Method": "MultiSelect<T> asMultiSelect(){\r\n    return MultiSelectionModelImpl.this.addMultiSelectionListener(listener);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.escalator.ScrollbarBundle.getScrollSize",
	"Comment": "gets the amount of pixels the scrollbar needs to be able to scrollthrough.",
	"Method": "double getScrollSize(){\r\n    return parseCssDimensionToPixels(internalGetScrollSize());\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractField.getDataSourceValue",
	"Comment": "gets the value from the data source. this is only here because of clarityin the code that handles both the data model value and the field value.",
	"Method": "Object getDataSourceValue(){\r\n    return dataSource.getValue();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractSplitPanel.getSplitterPosition",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "String getSplitterPosition(){\r\n    return position;\r\n}"
}, {
	"Path": "com.vaadin.client.debug.internal.SelectorPath.generateJavaVariable",
	"Comment": "generate java variable assignment from given selector fragment",
	"Method": "String generateJavaVariable(String pathFragment){\r\n    List<SelectorPredicate> predicates = SelectorPredicate.extractPredicates(pathFragment);\r\n    String elementType = pathFragment.split(\"\\\\[\")[0];\r\n    String name = getNameFromPredicates(predicates, elementType);\r\n    if (name.equals(elementType)) {\r\n        name = getNameWithCount(name);\r\n    }\r\n    name = name.replaceAll(\"\\\\W\", \"\");\r\n    return elementType + \"Element \" + name.substring(0, 1).toLowerCase(Locale.ROOT) + name.substring(1) + \" = \";\r\n}"
}, {
	"Path": "bt.net.BigIntegers.decodeUnsigned",
	"Comment": "decode an unsigned big integer from the provided buffer.leading zeros are stripped.",
	"Method": "BigInteger decodeUnsigned(ByteBuffer buffer,int length){\r\n    if (length < 1) {\r\n        throw new IllegalArgumentException(\"Invalid number of bytes: \" + length);\r\n    } else if (buffer.remaining() < length) {\r\n        throw new IllegalStateException(\"Insufficient bytes in buffer: \" + buffer.remaining() + \", requested: \" + length);\r\n    }\r\n    byte b;\r\n    int i = 0;\r\n    while ((b = buffer.get()) == 0 && ++i < length) ;\r\n    if (i == length) {\r\n        return BigInteger.ZERO;\r\n    }\r\n    int len = length - i;\r\n    byte[] bytes = new byte[len];\r\n    bytes[0] = b;\r\n    buffer.get(bytes, 1, len - 1);\r\n    return new BigInteger(1, bytes);\r\n}"
}, {
	"Path": "org.greenrobot.essentials.io.FileUtils.readObject",
	"Comment": "to read an object in a quick & dirty way. prepare to handle failures when object serialization changes!",
	"Method": "Object readObject(File file){\r\n    FileInputStream fileIn = new FileInputStream(file);\r\n    ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(fileIn));\r\n    try {\r\n        return in.readObject();\r\n    } finally {\r\n        IoUtils.safeClose(in);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.componentlocator.SelectorPredicate.unquote",
	"Comment": "removes the surrounding quotes from a string if it is quoted.",
	"Method": "String unquote(String str){\r\n    if ((str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\")) || (str.startsWith(\"'\") && str.endsWith(\"'\"))) {\r\n        return str.substring(1, str.length() - 1);\r\n    }\r\n    return str;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinServletRequest.getCurrent",
	"Comment": "gets the currently processed vaadin servlet request. the current requestis automatically defined when the request is started. the current requestcan not be used in e.g. background threads because of the way serverimplementations reuse request instances.",
	"Method": "VaadinServletRequest getCurrent(){\r\n    VaadinRequest currentRequest = VaadinRequest.getCurrent();\r\n    if (currentRequest instanceof VaadinServletRequest) {\r\n        return (VaadinServletRequest) currentRequest;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.setColumnOrder",
	"Comment": "sets a new column order for the grid. all columns which are not orderedhere will remain in the order they were before as the last columns ofgrid.",
	"Method": "void setColumnOrder(Object propertyIds){\r\n    if (SharedUtil.containsDuplicates(propertyIds)) {\r\n        throw new IllegalArgumentException(\"The propertyIds array contains duplicates: \" + SharedUtil.getDuplicates(propertyIds));\r\n    }\r\n    List<String> columnOrder = new ArrayList<String>();\r\n    for (Object propertyId : propertyIds) {\r\n        if (columns.containsKey(propertyId)) {\r\n            columnOrder.add(columnKeys.key(propertyId));\r\n        } else {\r\n            throw new IllegalArgumentException(\"Grid does not contain column for property \" + String.valueOf(propertyId));\r\n        }\r\n    }\r\n    List<String> stateColumnOrder = getState().columnOrder;\r\n    if (stateColumnOrder.size() != columnOrder.size()) {\r\n        stateColumnOrder.removeAll(columnOrder);\r\n        columnOrder.addAll(stateColumnOrder);\r\n    }\r\n    getState().columnOrder = columnOrder;\r\n    fireColumnReorderEvent(false);\r\n}"
}, {
	"Path": "com.vaadin.server.AbstractClientConnector.addExtension",
	"Comment": "add an extension to this connector. this method is protected to allowextensions to select which targets they can extend.",
	"Method": "void addExtension(Extension extension){\r\n    ClientConnector previousParent = extension.getParent();\r\n    if (equals(previousParent)) {\r\n        return;\r\n    } else if (previousParent != null) {\r\n        throw new IllegalStateException(\"Moving an extension from one parent to another is not supported\");\r\n    }\r\n    extensions.add(extension);\r\n    extension.setParent(this);\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.getResetKey",
	"Comment": "returns the reset key which will reset the calendar to the previousselection. by default this is backspace but it can be overridden tochange the key to whatever you want.",
	"Method": "int getResetKey(){\r\n    return KeyCodes.KEY_BACKSPACE;\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.readObject",
	"Comment": "special serialization to jsonobjects which are not serializable",
	"Method": "void readObject(ObjectInputStream in){\r\n    in.defaultReadObject();\r\n    diffStates = new HashMap();\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<ClientConnector, String> stringDiffStates = (HashMap<ClientConnector, String>) in.readObject();\r\n    diffStates = new HashMap(stringDiffStates.size() * 2);\r\n    for (ClientConnector key : stringDiffStates.keySet()) {\r\n        try {\r\n            diffStates.put(key, Json.parse(stringDiffStates.get(key)));\r\n        } catch (JsonException e) {\r\n            throw new IOException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Tree.expandItemsRecursively",
	"Comment": "expands the items recursivelyexpands all the children recursively starting from an item. operationsucceeds only if all expandable items are expanded.",
	"Method": "boolean expandItemsRecursively(Object startItemId){\r\n    boolean result = true;\r\n    final Stack<Object> todo = new Stack<Object>();\r\n    todo.add(startItemId);\r\n    while (!todo.isEmpty()) {\r\n        final Object id = todo.pop();\r\n        if (areChildrenAllowed(id) && !expandItem(id, false)) {\r\n            result = false;\r\n        }\r\n        if (hasChildren(id)) {\r\n            todo.addAll(getChildren(id));\r\n        }\r\n    }\r\n    markAsDirty();\r\n    return result;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VPopupCalendar.setRangeStart",
	"Comment": "sets the start range for this component. the start range is inclusive,and it depends on the current resolution, what is considered inside therange.",
	"Method": "void setRangeStart(Date rangeStart){\r\n    calendar.setRangeStart(rangeStart);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.SQLContainer.setPageLength",
	"Comment": "sets the page length used in lazy fetching of items from the data source.also resets the cache size to match the new page length.as a side effect the container will be refreshed.",
	"Method": "void setPageLength(int pageLength){\r\n    setPageLengthInternal(pageLength);\r\n    refresh();\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConnection.scheduleHeartbeat",
	"Comment": "schedules a heartbeat request to occur after the configured heartbeatinterval elapses if the interval is a positive number. otherwise, doesnothing.",
	"Method": "void scheduleHeartbeat(){\r\n    heartbeat.schedule();\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinPortletService.getCurrentPortletRequest",
	"Comment": "gets the currently processed portlet request. the current portlet requestis automatically defined when the request is started. the current portletrequest can not be used in e.g. background threads because of the wayserver implementations reuse request instances.",
	"Method": "PortletRequest getCurrentPortletRequest(){\r\n    VaadinPortletRequest currentRequest = getCurrentRequest();\r\n    if (currentRequest != null) {\r\n        return currentRequest.getPortletRequest();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.ui.UIConnector.hasSubWindow",
	"Comment": "checks if the given sub window is a child of this ui connector.",
	"Method": "boolean hasSubWindow(WindowConnector wc){\r\n    return getChildComponents().contains(wc);\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractDateField.convertFromDateString",
	"Comment": "parses string representaion of date range limit into date type",
	"Method": "T convertFromDateString(String temporalStr){\r\n    if (temporalStr == null) {\r\n        return null;\r\n    }\r\n    return toType(RANGE_FORMATTER.parse(temporalStr));\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignAttributeHandler.toAttributeValue",
	"Comment": "serializes the given value to valid design attribute representation",
	"Method": "String toAttributeValue(Class<?> sourceType,Object value){\r\n    if (value == null) {\r\n        return \"\";\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    Converter<String, Object> converter = getFormatter().findConverterFor(sourceType);\r\n    if (converter != null) {\r\n        return converter.convertToPresentation(value, new ValueContext());\r\n    } else {\r\n        return value.toString();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.getEmbedId",
	"Comment": "gets a string the uniquely distinguishes this ui instance based on whereit is embedded. the embed identifier is based on thewindow.name dom attribute of the browser window where the uiis displayed and the id of the div element where the ui is embedded.",
	"Method": "String getEmbedId(){\r\n    return embedId;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.renderers.ComplexRenderer.onActivate",
	"Comment": "called when the cell is activated by pressing enter, doubleclicking or performing a double tap on the cell.",
	"Method": "boolean onActivate(CellReference<?> cell){\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.getAddedRowCount",
	"Comment": "subclass and override this to enable partial row additions, bypassing thenormal caching mechanism. this is useful for e.g. treetable, whereexpanding a node should only fetch and add the items inside of that node.",
	"Method": "int getAddedRowCount(){\r\n    return 0;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.HierarchyMapper.getHierarchy",
	"Comment": "getst hte full hierarchy tree starting from given node. the starting nodecan be omitted.",
	"Method": "Stream<T> getHierarchy(T parent,Stream<T> getHierarchy,T parent,boolean includeParent){\r\n    return Stream.of(parent).flatMap(node -> getChildrenStream(node, includeParent));\r\n}"
}, {
	"Path": "com.vaadin.server.WebBrowser.isEs6Supported",
	"Comment": "checks if the browser supports ecmascript 6, based on the user agent.",
	"Method": "boolean isEs6Supported(){\r\n    if (browserDetails == null) {\r\n        return false;\r\n    }\r\n    return browserDetails.isEs6Supported();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.FontIcon.isFontIconUri",
	"Comment": "checks whether or not the given uri is a font icon uri. does not checkwhether or not the font icon is available and can be rendered.",
	"Method": "boolean isFontIconUri(String uri){\r\n    return uri != null && uri.startsWith(ApplicationConstants.FONTICON_PROTOCOL_PREFIX);\r\n}"
}, {
	"Path": "com.folioreader.view.DirectionalViewpager.getOffscreenPageLimit",
	"Comment": "returns the number of pages that will be retained to either side of thecurrent page in the view hierarchy in an idle state. defaults to 1.",
	"Method": "int getOffscreenPageLimit(){\r\n    return mOffscreenPageLimit;\r\n}"
}, {
	"Path": "net.openhft.chronicle.queue.impl.ringbuffer.ZippedDocumentAppender.append",
	"Comment": "the bytes that you wish to append, this bytes will become zipped and appended to thechronicle using a background thread",
	"Method": "void append(Bytes bytes){\r\n    while (!q.offer(bytes)) {\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponent.getDefaultAttributes",
	"Comment": "returns a collection of attributes that do not require custom handlingwhen reading or writing design. these are typically attributes of someprimitive type. the default implementation searches setters withprimitive values",
	"Method": "Collection<String> getDefaultAttributes(){\r\n    Collection<String> attributes = DesignAttributeHandler.getSupportedAttributes(this.getClass());\r\n    attributes.removeAll(getCustomAttributes());\r\n    return attributes;\r\n}"
}, {
	"Path": "lbms.plugins.mldht.kad.KBucket.insertOrRefresh",
	"Comment": "notify bucket of new incoming packet from a node, perform update or insert existing nodes where appropriate",
	"Method": "void insertOrRefresh(KBucketEntry newEntry){\r\n    if (newEntry == null)\r\n        return;\r\n    List<KBucketEntry> entriesRef = entries;\r\n    for (KBucketEntry existing : entriesRef) {\r\n        if (existing.equals(newEntry)) {\r\n            existing.mergeInTimestamps(newEntry);\r\n            return;\r\n        }\r\n        if (existing.matchIPorID(newEntry)) {\r\n            DHT.logInfo(\"new node \" + newEntry + \" claims same ID or IP as \" + existing + \", might be impersonation attack or IP change. ignoring until old entry times out\");\r\n            return;\r\n        }\r\n    }\r\n    if (newEntry.verifiedReachable()) {\r\n        if (entriesRef.size() < DHTConstants.MAX_ENTRIES_PER_BUCKET) {\r\n            modifyMainBucket(null, newEntry);\r\n            return;\r\n        }\r\n        if (replaceBadEntry(newEntry))\r\n            return;\r\n        KBucketEntry youngest = entriesRef.get(entriesRef.size() - 1);\r\n        if (youngest.getCreationTime() > newEntry.getCreationTime() || newEntry.getRTT() * 2.5 < youngest.getRTT()) {\r\n            modifyMainBucket(youngest, newEntry);\r\n            insertInReplacementBucket(youngest);\r\n            return;\r\n        }\r\n    }\r\n    insertInReplacementBucket(newEntry);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.getSelectedCaption",
	"Comment": "this method is meant for internal use and may change in future versions.",
	"Method": "String getSelectedCaption(){\r\n    return explicitSelectedCaption;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.setEditorHandler",
	"Comment": "sets the handler responsible for binding data and editor widgets to theeditor.",
	"Method": "void setEditorHandler(EditorHandler<T> handler){\r\n    editor.setHandler(handler);\r\n}"
}, {
	"Path": "com.vaadin.v7.tests.server.component.textfield.TextFieldValueChangeTest.testNoDataSource",
	"Comment": "case where the text field only uses its internal buffer, no externalproperty data source.",
	"Method": "void testNoDataSource(){\r\n    getField().setPropertyDataSource(null);\r\n    expectValueChangeFromSetValueNotCommit();\r\n}"
}, {
	"Path": "com.vaadin.data.provider.DataCommunicator.beforeClientResponse",
	"Comment": "initially and in the case of a reset all data should be pushed to theclient.",
	"Method": "void beforeClientResponse(boolean initial){\r\n    super.beforeClientResponse(initial);\r\n    if (initial && getPushRows().isEmpty()) {\r\n        setPushRows(Range.withLength(0, getMinPushSize()));\r\n    }\r\n    sendDataToClient(initial);\r\n}"
}, {
	"Path": "com.vaadin.ui.Embedded.setCodebase",
	"Comment": "this attribute specifies the base path used to resolve relative urisspecified by the classid, data, and archive attributes. when absent, itsdefault value is the base uri of the current document.",
	"Method": "void setCodebase(String codebase){\r\n    String oldCodebase = getCodebase();\r\n    if (codebase != oldCodebase || (codebase != null && !codebase.equals(oldCodebase))) {\r\n        getState().codebase = codebase;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.fieldgroup.FieldGroup.configureField",
	"Comment": "configures a field with the settings set for this fieldbinder.by default this updates the buffered, read only and enabled state of thefield. also adds validators when applicable. fields with read only datasource are always configured as read only.",
	"Method": "void configureField(Field<?> field){\r\n    field.setBuffered(isBuffered());\r\n    field.setEnabled(isEnabled());\r\n    if (field.getPropertyDataSource().isReadOnly()) {\r\n        field.setReadOnly(true);\r\n    } else {\r\n        field.setReadOnly(isReadOnly());\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractSplitPanel.isSplitPositionReversed",
	"Comment": "is the split position reversed. by default the split position is measuredby the first region, but if split position is reversed the measuring isdone by the second region instead.",
	"Method": "boolean isSplitPositionReversed(){\r\n    return getSplitterState(false).positionReversed;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.orderedlayout.Slot.setSpacing",
	"Comment": "set the spacing for the slot. the spacing determines if there should beempty space around the slot when the slot.",
	"Method": "void setSpacing(boolean spacing){\r\n    if (spacing && spacer == null) {\r\n        spacer = DOM.createDiv();\r\n        spacer.addClassName(\"v-spacing\");\r\n        getElement().getParentElement().insertBefore(spacer, getElement());\r\n    } else if (!spacing && spacer != null) {\r\n        LayoutManager lm = layout.getLayoutManager();\r\n        if (lm != null && spacingResizeListener != null) {\r\n            lm.removeElementResizeListener(spacer, spacingResizeListener);\r\n        }\r\n        spacer.removeFromParent();\r\n        spacer = null;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTwinColSelect.setReadOnly",
	"Comment": "sets this twin column select as read only, meaning selection cannot bechanged.",
	"Method": "void setReadOnly(boolean readOnly){\r\n    if (this.readOnly != readOnly) {\r\n        this.readOnly = readOnly;\r\n        updateEnabledState();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.components.calendar.ContainerEventProvider.ignoreContainerEvents",
	"Comment": "removes listeners from the container so no events are processed",
	"Method": "void ignoreContainerEvents(){\r\n    if (container instanceof ItemSetChangeNotifier) {\r\n        ((ItemSetChangeNotifier) container).removeItemSetChangeListener(this);\r\n    }\r\n    if (container instanceof ValueChangeNotifier) {\r\n        ((ValueChangeNotifier) container).removeValueChangeListener(this);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.updateBody",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void updateBody(UIDL uidl,int firstRow,int reqRows){\r\n    int oldIndent = scrollBody.getMaxIndent();\r\n    if (uidl == null || reqRows < 1) {\r\n        if (firstRow <= 0) {\r\n            postponeSanityCheckForLastRendered = true;\r\n            while (scrollBody.getLastRendered() > scrollBody.getFirstRendered()) {\r\n                scrollBody.unlinkRow(false);\r\n            }\r\n            postponeSanityCheckForLastRendered = false;\r\n            scrollBody.unlinkRow(false);\r\n        }\r\n        return;\r\n    }\r\n    scrollBody.renderRows(uidl, firstRow, reqRows);\r\n    discardRowsOutsideCacheWindow();\r\n    scrollBody.calculateMaxIndent();\r\n    if (oldIndent != scrollBody.getMaxIndent()) {\r\n        headerChangedDuringUpdate = true;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.getSelectedRows",
	"Comment": "gets currently selected rows from the current selection model.",
	"Method": "Collection<T> getSelectedRows(){\r\n    return selectionModel.getSelectedRows();\r\n}"
}, {
	"Path": "com.vaadin.ui.MenuBar.addItemBefore",
	"Comment": "add an item before some item. if the given item does not exist the itemis added at the end of the menu. icon and command can be null, but acaption must be given.",
	"Method": "MenuBar.MenuItem addItemBefore(String caption,Resource icon,MenuBar.Command command,MenuBar.MenuItem itemToAddBefore,MenuBar.MenuItem addItemBefore,String caption,Resource icon,MenuBar.Command command,MenuBar.MenuItem itemToAddBefore){\r\n    if (caption == null) {\r\n        throw new IllegalArgumentException(\"caption cannot be null\");\r\n    }\r\n    MenuItem newItem = new MenuItem(caption, icon, command);\r\n    if (menuItems.contains(itemToAddBefore)) {\r\n        int index = menuItems.indexOf(itemToAddBefore);\r\n        menuItems.add(index, newItem);\r\n    } else {\r\n        menuItems.add(newItem);\r\n    }\r\n    markAsDirty();\r\n    return newItem;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.editItem",
	"Comment": "opens the editor interface for the provided item. scrolls the grid tobring the item to view if it is not already visible.note that any cell content rendered by a widgetrenderer will not bevisible in the editor row.",
	"Method": "void editItem(Object itemId){\r\n    if (!isEditorEnabled()) {\r\n        throw new IllegalStateException(\"Item editor is not enabled\");\r\n    } else if (isEditorBuffered() && editedItemId != null) {\r\n        throw new IllegalStateException(\"Editing item \" + itemId + \" failed. Item editor is already editing item \" + editedItemId);\r\n    } else if (!getContainerDataSource().containsId(itemId)) {\r\n        throw new IllegalArgumentException(\"Item with id \" + itemId + \" not found in current container\");\r\n    }\r\n    editedItemId = itemId;\r\n    getEditorRpc().bind(getContainerDataSource().indexOfId(itemId));\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbsoluteLayout.layoutVertically",
	"Comment": "performs a vertical layout of the layout. should be called when a widgetis added or removed",
	"Method": "void layoutVertically(){\r\n    layout();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.IndexedContainer.removeSinglePropertyChangeListener",
	"Comment": "removes a previously registered single property change listener.",
	"Method": "void removeSinglePropertyChangeListener(Object propertyId,Object itemId,Property.ValueChangeListener listener){\r\n    if (listener != null && singlePropertyValueChangeListeners != null) {\r\n        final Map<Object, List<Property.ValueChangeListener>> propertySetToListenerListMap = singlePropertyValueChangeListeners.get(propertyId);\r\n        if (propertySetToListenerListMap != null) {\r\n            final List<Property.ValueChangeListener> listenerList = propertySetToListenerListMap.get(itemId);\r\n            if (listenerList != null) {\r\n                listenerList.remove(listener);\r\n                if (listenerList.isEmpty()) {\r\n                    propertySetToListenerListMap.remove(itemId);\r\n                }\r\n            }\r\n            if (propertySetToListenerListMap.isEmpty()) {\r\n                singlePropertyValueChangeListeners.remove(propertyId);\r\n            }\r\n        }\r\n        if (singlePropertyValueChangeListeners.isEmpty()) {\r\n            singlePropertyValueChangeListeners = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.getTabStopBottomAssistiveText",
	"Comment": "gets the message that is provided to users of assistive devices when theuser reaches the bottom of the window when leaving a window with the tabkey is prevented.",
	"Method": "String getTabStopBottomAssistiveText(){\r\n    return Roles.getNoteRole().getAriaLabelProperty(bottomTabStop);\r\n}"
}, {
	"Path": "com.vaadin.ui.Tree.getSelectedItems",
	"Comment": "this method is a shorthand that delegates to the currently set selectionmodel.",
	"Method": "Set<T> getSelectedItems(){\r\n    return treeGrid.getSelectedItems();\r\n}"
}, {
	"Path": "com.vaadin.client.data.AbstractRemoteDataSource.isWaitingForData",
	"Comment": "checks whether this data source is currently waiting for more rows tobecome available.",
	"Method": "boolean isWaitingForData(){\r\n    return currentRequestCallback != null;\r\n}"
}, {
	"Path": "brave.servlet.ServletRuntime.findServletRuntime",
	"Comment": "attempt to match the host runtime to a capable platform implementation.",
	"Method": "ServletRuntime findServletRuntime(){\r\n    try {\r\n        Class.forName(\"javax.servlet.AsyncEvent\");\r\n        HttpServletRequest.class.getMethod(\"isAsyncStarted\");\r\n        return new Servlet3();\r\n    } catch (NoSuchMethodException e) {\r\n    } catch (ClassNotFoundException e) {\r\n    }\r\n    return new Servlet25();\r\n}"
}, {
	"Path": "com.vaadin.client.componentlocator.VaadinFinderLocatorStrategy.getTags",
	"Comment": "gets the tags for server side class name. also includes tags for oldercomponents in v7 package.",
	"Method": "List<Integer> getTags(String widgetName){\r\n    List<Integer> widgetTags = new ArrayList();\r\n    Arrays.stream(client.getConfiguration().getTagsForServerSideClassName(getFullClassName(widgetName))).forEach(widgetTags::add);\r\n    if (widgetName.startsWith(\"com.vaadin.ui\")) {\r\n        Arrays.stream(client.getConfiguration().getTagsForServerSideClassName(getFullClassName(widgetName.replace(\"com.vaadin.ui\", \"com.vaadin.v7.ui\")))).forEach(widgetTags::add);\r\n    }\r\n    return widgetTags;\r\n}"
}, {
	"Path": "com.vaadin.client.extensions.DragSourceExtensionConnector.addDraggedStyle",
	"Comment": "add class name to indicate that the drag source element is being dragged.this method is called during the dragstart event.",
	"Method": "void addDraggedStyle(NativeEvent event){\r\n    Element dragSource = getDraggableElement();\r\n    dragSource.addClassName(getStylePrimaryName(dragSource) + STYLE_SUFFIX_DRAGGED);\r\n}"
}, {
	"Path": "com.vaadin.data.provider.InMemoryDataProvider.filteringBySubstring",
	"Comment": "wraps this data provider to create a new data provider that is filteredby a string by checking whether the lower case representation of thefilter value provided in the query is a substring of the lower caserepresentation of an item property value. the filter never passes if theitem property value is null.",
	"Method": "DataProvider<T, String> filteringBySubstring(ValueProvider<T, String> valueProvider,Locale locale,DataProvider<T, String> filteringBySubstring,ValueProvider<T, String> valueProvider){\r\n    return InMemoryDataProviderHelpers.filteringByCaseInsensitiveString(this, valueProvider, String::contains, InMemoryDataProviderHelpers.CURRENT_LOCALE_SUPPLIER);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.ColumnProperty.isRowIdentifier",
	"Comment": "returns whether or not this property is used as a row identifier.",
	"Method": "boolean isRowIdentifier(){\r\n    return isPrimaryKey() || isVersionColumn();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractBeanContainer.addValueChangeListener",
	"Comment": "make this container listen to the given property provided it notifieswhen its value changes.",
	"Method": "void addValueChangeListener(Item item,Object propertyId){\r\n    Property<?> property = item.getItemProperty(propertyId);\r\n    if (property instanceof ValueChangeNotifier) {\r\n        ValueChangeNotifier notifier = (ValueChangeNotifier) property;\r\n        notifier.removeListener(this);\r\n        notifier.addListener(this);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.SQLContainer.updateOffsetAndCache",
	"Comment": "determines a new offset for updating the row cache. the offset iscalculated from the given index, and will be fixed to match the start ofa page, based on the value of pagelength.",
	"Method": "void updateOffsetAndCache(int index){\r\n    int oldOffset = currentOffset;\r\n    currentOffset = (index / pageLength) * pageLength - cacheOverlap;\r\n    if (currentOffset < 0) {\r\n        currentOffset = 0;\r\n    }\r\n    if (oldOffset == currentOffset && !cachedItems.isEmpty()) {\r\n        return;\r\n    }\r\n    getPage();\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.getEditorHandler",
	"Comment": "returns the handler responsible for binding data and editor widgets tothe editor.",
	"Method": "EditorHandler<T> getEditorHandler(){\r\n    return editor.getHandler();\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.isClosable",
	"Comment": "returns the closable status of the window. if a window is closable, ittypically shows an x in the upper right corner. clicking on the x sends aclose event to the server. setting closable to false will remove the xfrom the window and prevent the user from closing the window.",
	"Method": "boolean isClosable(){\r\n    return getState(false).closable;\r\n}"
}, {
	"Path": "org.greenrobot.essentials.javaperf.LongHashSetBenchmark.main",
	"Comment": "this is only for development purposes or to run tests separately. for automated benchmarking use gradle",
	"Method": "void main(String[] args){\r\n    BenchmarkRunner.runWallTime(new LibImpl(), RUN_COUNT, WARM_UP_TIME_S);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.updateMaxIndent",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void updateMaxIndent(){\r\n    int oldIndent = scrollBody.getMaxIndent();\r\n    scrollBody.calculateMaxIndent();\r\n    if (oldIndent != scrollBody.getMaxIndent()) {\r\n        triggerLazyColumnAdjustment(true);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.dd.VAcceptCriterion.accept",
	"Comment": "checks if current drag event has valid drop target and target accepts thetransferable. if drop target is valid, callback is used.",
	"Method": "void accept(VDragEvent drag,UIDL configuration,VAcceptCallback callback,boolean accept,VDragEvent drag,UIDL configuration){\r\n    if (needsServerSideCheck(drag, configuration)) {\r\n        VDragEventServerCallback acceptCallback = (accepted, response) -> {\r\n            if (accepted) {\r\n                callback.accepted(drag);\r\n            }\r\n        };\r\n        VDragAndDropManager.get().visitServer(acceptCallback);\r\n    } else {\r\n        boolean validates = accept(drag, configuration);\r\n        if (validates) {\r\n            callback.accepted(drag);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractField.convertToModel",
	"Comment": "convert the given value from the ui type to the data source type.",
	"Method": "Object convertToModel(T fieldValue,Object convertToModel,T fieldValue,Locale locale){\r\n    Class<?> modelType = getModelType();\r\n    try {\r\n        return ConverterUtil.convertToModel(fieldValue, (Class<Object>) modelType, getConverter(), locale);\r\n    } catch (ConversionException e) {\r\n        throw new ConversionException(getConversionError(modelType, e), e);\r\n    }\r\n}"
}, {
	"Path": "bt.runtime.BtRuntimeBuilder.disableStandardExtensions",
	"Comment": "if this options is set, bt will not automatically load standard extensions, such as pex or lsd.may be used to selectively enable only a subset of standard extensions.",
	"Method": "BtRuntimeBuilder disableStandardExtensions(){\r\n    this.shouldDisableStandardExtensions = true;\r\n    return this;\r\n}"
}, {
	"Path": "com.vaadin.client.VConsole.setImplementation",
	"Comment": "used by applicationconfiguration to initialize vconsole.",
	"Method": "void setImplementation(VDebugWindow console){\r\n    impl = console;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.updateDragMode",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void updateDragMode(UIDL uidl){\r\n    dragmode = uidl.hasAttribute(\"dragmode\") ? uidl.getIntAttribute(\"dragmode\") : 0;\r\n    if (BrowserInfo.get().isIE()) {\r\n        if (dragmode > 0) {\r\n            getElement().setPropertyJSO(\"onselectstart\", getPreventTextSelectionIEHack());\r\n        } else {\r\n            getElement().setPropertyJSO(\"onselectstart\", null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.query.FreeformQuery.containsRowWithKey",
	"Comment": "this implementation of the containsrowwithkey method rewrites existingwhere clauses in the query string. the logic is, however, not verycomplex and some times can do the wrong thingtm. for thesituations where this logic is not enough, you can implement thegetcontainsrowquerystring method in freeformquerydelegate and this willbe used instead of the logic.",
	"Method": "boolean containsRowWithKey(Object keys){\r\n    String query = null;\r\n    boolean contains = false;\r\n    if (delegate != null) {\r\n        if (delegate instanceof FreeformStatementDelegate) {\r\n            try {\r\n                StatementHelper sh = ((FreeformStatementDelegate) delegate).getContainsRowQueryStatement(keys);\r\n                PreparedStatement pstmt = null;\r\n                ResultSet rs = null;\r\n                Connection c = getConnection();\r\n                try {\r\n                    pstmt = c.prepareStatement(sh.getQueryString());\r\n                    sh.setParameterValuesToStatement(pstmt);\r\n                    rs = pstmt.executeQuery();\r\n                    contains = rs.next();\r\n                    return contains;\r\n                } finally {\r\n                    releaseConnection(c, pstmt, rs);\r\n                }\r\n            } catch (UnsupportedOperationException e) {\r\n            }\r\n        }\r\n        try {\r\n            query = delegate.getContainsRowQueryString(keys);\r\n        } catch (UnsupportedOperationException e) {\r\n            query = modifyWhereClause(keys);\r\n        }\r\n    } else {\r\n        query = modifyWhereClause(keys);\r\n    }\r\n    Statement statement = null;\r\n    ResultSet rs = null;\r\n    Connection conn = getConnection();\r\n    try {\r\n        statement = conn.createStatement();\r\n        rs = statement.executeQuery(query);\r\n        contains = rs.next();\r\n    } finally {\r\n        releaseConnection(conn, statement, rs);\r\n    }\r\n    return contains;\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridMultiSelect.addSelectionListener",
	"Comment": "adds a generic listener to this selection model, accepting both singleand multiselection events.",
	"Method": "Registration addSelectionListener(SelectionListener<T> listener,Registration addSelectionListener,MultiSelectionListener<T> listener){\r\n    return model.asMultiSelect().addSelectionListener(listener);\r\n}"
}, {
	"Path": "com.vaadin.ui.Upload.getButtonCaption",
	"Comment": "returns the string rendered into button that fires uploading.",
	"Method": "String getButtonCaption(){\r\n    return buttonCaption;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTextField.updateCursorPosition",
	"Comment": "updates the cursor position variable if it has changed since the lastupdate.",
	"Method": "boolean updateCursorPosition(){\r\n    if (WidgetUtil.isAttachedAndDisplayed(this)) {\r\n        int cursorPos = prompting ? 0 : getCursorPos();\r\n        if (lastCursorPos != cursorPos) {\r\n            client.updateVariable(paintableId, TextFieldConstants.VAR_CURSOR, cursorPos, false);\r\n            lastCursorPos = cursorPos;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.BeanItemContainer.addItemAfter",
	"Comment": "adds the bean after the given bean.the bean is used both as the item contents and as the item identifier.",
	"Method": "BeanItem<BEANTYPE> addItemAfter(Object previousItemId,Object newItemId){\r\n    return super.addBeanAfter((BEANTYPE) previousItemId, (BEANTYPE) newItemId);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTwinColSelect.clearInternalHeights",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void clearInternalHeights(){\r\n    selectionsListBox.setHeight(\"\");\r\n    optionsListBox.setHeight(\"\");\r\n}"
}, {
	"Path": "com.vaadin.ui.RadioButtonGroup.isHtmlContentAllowed",
	"Comment": "checks whether captions are interpreted as html or plain text.",
	"Method": "boolean isHtmlContentAllowed(){\r\n    return getState(false).htmlContentAllowed;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.setAssistiveDescription",
	"Comment": "allows to specify which connectors contain the description for thewindow. text contained in the widgets of the connectors will be read byassistive devices when it is opened.when the provided array is empty, an existing description is removed.",
	"Method": "void setAssistiveDescription(Connector[] connectors){\r\n    if (connectors != null) {\r\n        assistiveConnectors = connectors;\r\n        if (connectors.length == 0) {\r\n            Roles.getDialogRole().removeAriaDescribedbyProperty(getElement());\r\n        } else {\r\n            Id[] ids = new Id[connectors.length];\r\n            for (int index = 0; index < connectors.length; index++) {\r\n                if (connectors[index] == null) {\r\n                    throw new IllegalArgumentException(\"All values in parameter description need to be non-null\");\r\n                }\r\n                Element element = ((ComponentConnector) connectors[index]).getWidget().getElement();\r\n                AriaHelper.ensureHasId(element);\r\n                ids[index] = Id.of(element);\r\n            }\r\n            Roles.getDialogRole().setAriaDescribedbyProperty(getElement(), ids);\r\n        }\r\n    } else {\r\n        throw new IllegalArgumentException(\"Parameter description must be non-null\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addBodyDoubleClickHandler",
	"Comment": "register a bodydoubleclickhandler to this grid. the event for thishandler is fired when a double click event occurs in the body of thisgrid.",
	"Method": "HandlerRegistration addBodyDoubleClickHandler(BodyDoubleClickHandler handler){\r\n    return addHandler(handler, GridDoubleClickEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.client.connectors.grid.GridConnector.addColumn",
	"Comment": "adds a column to the grid widget. for each column a communication idstored for client to server communication.",
	"Method": "void addColumn(CustomColumn column,String id){\r\n    assert !columnToIdMap.containsKey(column) && !columnToIdMap.containsValue(id) : \"Column with given id already exists.\";\r\n    columnToIdMap.put(column, id);\r\n    idToColumn.put(id, column);\r\n    if (idToColumn.keySet().containsAll(getState().columnOrder)) {\r\n        updateColumns();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.ComponentTest.assertEncodedStateProperties",
	"Comment": "asserts the set of properties that would be sent as state changes for thegiven connector.",
	"Method": "void assertEncodedStateProperties(ClientConnector connector,String message,String expectedProperties){\r\n    assert connector.isAttached();\r\n    JsonObject encodeState = connector.encodeState();\r\n    assertEquals(message, new HashSet(Arrays.asList(expectedProperties)), new HashSet(Arrays.asList(encodeState.keys())));\r\n}"
}, {
	"Path": "com.vaadin.client.LayoutManager.setConnection",
	"Comment": "sets the application connection this instance is connected to. calledinternally by the framework.",
	"Method": "void setConnection(ApplicationConnection connection){\r\n    if (this.connection != null) {\r\n        throw new RuntimeException(\"LayoutManager connection can never be changed\");\r\n    }\r\n    this.connection = connection;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.components.calendar.ContainerEventProvider.getDescriptionProperty",
	"Comment": "get the property which provides the description of the event.",
	"Method": "Object getDescriptionProperty(){\r\n    return descriptionProperty;\r\n}"
}, {
	"Path": "com.vaadin.ui.PopupView.isHideOnMouseOut",
	"Comment": "check if this popup will be hidden when the user takes the mouse cursorout of the popup area.",
	"Method": "boolean isHideOnMouseOut(){\r\n    return getState(false).hideOnMouseOut;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addSelectAllHandler",
	"Comment": "register a gwt event handler for a select all event. this handler getscalled whenever grid needs all rows selected.",
	"Method": "HandlerRegistration addSelectAllHandler(SelectAllHandler<T> handler){\r\n    return addHandler(handler, SelectAllEvent.getType());\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.setDraggable",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setDraggable(boolean draggable){\r\n    if (this.draggable == draggable) {\r\n        return;\r\n    }\r\n    this.draggable = draggable;\r\n    setCursorProperties();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.isScrollPositionVisible",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "boolean isScrollPositionVisible(){\r\n    return scrollPositionElement != null && !scrollPositionElement.getStyle().getDisplay().equals(Display.NONE.toString());\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.setClosable",
	"Comment": "sets the closable status for the window. if a window is closable ittypically shows an x in the upper right corner. clicking on the x sends aclose event to the server. setting closable to false will remove the xfrom the window and prevent the user from closing the window.",
	"Method": "void setClosable(boolean closable){\r\n    if (closable != isClosable()) {\r\n        getState().closable = closable;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Form.setLayout",
	"Comment": "sets the layout of the form.if set to null then form uses a formlayout by default.",
	"Method": "void setLayout(Layout layout){\r\n    if (layout == null) {\r\n        layout = new FormLayout();\r\n    }\r\n    gridlayoutCursorX = -1;\r\n    gridlayoutCursorY = -1;\r\n    if (getLayout() != null) {\r\n        for (Object property : propertyIds) {\r\n            Field<?> f = getField(property);\r\n            detachField(f);\r\n            if (layout instanceof CustomLayout) {\r\n                ((CustomLayout) layout).addComponent(f, property.toString());\r\n            } else {\r\n                layout.addComponent(f);\r\n            }\r\n        }\r\n        getLayout().setParent(null);\r\n    }\r\n    layout.setParent(this);\r\n    getState().layout = layout;\r\n}"
}, {
	"Path": "com.vaadin.client.debug.internal.LogSection.addRow",
	"Comment": "adds a row to the log, applies the log row limit by removing old rows ifneeded, and scrolls new row into view if scroll lock is not active.",
	"Method": "Element addRow(Level level,String msg){\r\n    int sinceReset = VDebugWindow.getMillisSinceReset();\r\n    int sinceStart = VDebugWindow.getMillisSinceStart();\r\n    Element row = DOM.createDiv();\r\n    row.addClassName(VDebugWindow.STYLENAME + \"-row\");\r\n    row.addClassName(level.getName());\r\n    String inner = \"<span class='\" + VDebugWindow.STYLENAME + \"-\" + \"'><\/span><span class='\" + VDebugWindow.STYLENAME + \"-time' title='\" + VDebugWindow.getTimingTooltip(sinceStart, sinceReset) + \"'>\" + sinceReset + \"ms<\/span><span class='\" + VDebugWindow.STYLENAME + \"-message'>\" + msg + \"<\/span>\";\r\n    row.setInnerHTML(inner);\r\n    contentElement.appendChild(row);\r\n    applyLimit();\r\n    maybeScroll();\r\n    return row;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendar.getEventResizeListener",
	"Comment": "get the listener that listens to when an events time limits are beingadjusted.",
	"Method": "EventResizeListener getEventResizeListener(){\r\n    return eventResizeListener;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractPopupCalendar.setDescriptionForAssistiveDevices",
	"Comment": "set a description that explains the usage of the widget for users ofassistive devices.",
	"Method": "void setDescriptionForAssistiveDevices(String descriptionForAssistiveDevices){\r\n    descriptionForAssistiveDevicesElement.setInnerText(descriptionForAssistiveDevices);\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.ChildFocusAwareFlowPanel.focusFirstEnabledChild",
	"Comment": "put focus in the first child widget that can be focused and is notdisabled.",
	"Method": "void focusFirstEnabledChild(){\r\n    for (int i = 0; i < getWidgetCount(); i++) {\r\n        Widget widget = getWidget(i);\r\n        if (!(widget instanceof FocusWidget)) {\r\n            continue;\r\n        }\r\n        FocusWidget focusableChild = (FocusWidget) widget;\r\n        if (focusableChild.isEnabled()) {\r\n            focusableChild.setFocus(true);\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.communication.ClientRpcWriter.write",
	"Comment": "writes a json object containing all pending client rpc invocations in thegiven ui.",
	"Method": "void write(UI ui,Writer writer){\r\n    Collection<ClientMethodInvocation> pendingInvocations = collectPendingRpcCalls(ui.getConnectorTracker().getDirtyVisibleConnectors());\r\n    JsonArray rpcCalls = Json.createArray();\r\n    for (ClientMethodInvocation invocation : pendingInvocations) {\r\n        try {\r\n            JsonArray invocationJson = Json.createArray();\r\n            invocationJson.set(0, invocation.getConnector().getConnectorId());\r\n            invocationJson.set(1, invocation.getInterfaceName());\r\n            invocationJson.set(2, invocation.getMethodName());\r\n            JsonArray paramJson = Json.createArray();\r\n            for (int i = 0; i < invocation.getParameterTypes().length; ++i) {\r\n                Type parameterType = invocation.getParameterTypes()[i];\r\n                JsonValue referenceParameter = null;\r\n                EncodeResult encodeResult = JsonCodec.encode(invocation.getParameters()[i], referenceParameter, parameterType, ui.getConnectorTracker());\r\n                paramJson.set(i, encodeResult.getEncodedValue());\r\n            }\r\n            invocationJson.set(3, paramJson);\r\n            rpcCalls.set(rpcCalls.length(), invocationJson);\r\n        } catch (JsonException e) {\r\n            throw new PaintException(\"Failed to serialize RPC method call parameters for connector \" + invocation.getConnector().getConnectorId() + \" method \" + invocation.getInterfaceName() + \".\" + invocation.getMethodName() + \": \" + e.getMessage(), e);\r\n        }\r\n    }\r\n    writer.write(JsonUtil.stringify(rpcCalls));\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.appendColumn",
	"Comment": "creates a new column based on a property id and appends it as the lastcolumn.",
	"Method": "Column appendColumn(Object datasourcePropertyId){\r\n    if (datasourcePropertyId == null) {\r\n        throw new IllegalArgumentException(\"Property id cannot be null\");\r\n    }\r\n    assert datasource.getContainerPropertyIds().contains(datasourcePropertyId) : \"Datasource should contain the property id\";\r\n    GridColumnState columnState = new GridColumnState();\r\n    columnState.id = columnKeys.key(datasourcePropertyId);\r\n    Column column = new Column(this, columnState, datasourcePropertyId);\r\n    columns.put(datasourcePropertyId, column);\r\n    getState().columns.add(columnState);\r\n    getState().columnOrder.add(columnState.id);\r\n    header.addColumn(datasourcePropertyId);\r\n    footer.addColumn(datasourcePropertyId);\r\n    String humanFriendlyPropertyId = SharedUtil.propertyIdToHumanFriendly(String.valueOf(datasourcePropertyId));\r\n    column.setHeaderCaption(humanFriendlyPropertyId);\r\n    if (datasource instanceof Sortable && ((Sortable) datasource).getSortableContainerPropertyIds().contains(datasourcePropertyId)) {\r\n        column.setSortable(true);\r\n    }\r\n    return column;\r\n}"
}, {
	"Path": "com.vaadin.ui.dnd.event.DropEvent.getDragData",
	"Comment": "gets the server side drag data. this data can be set during the dragstart event on the server side and can be used to transfer data betweendrag source and drop target when they are in the same ui.",
	"Method": "Optional<Object> getDragData(){\r\n    return getDragSourceExtension().map(DragSourceExtension::getDragData);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.SQLContainer.getPage",
	"Comment": "fetches a page from the data source based on the values of pagelength andcurrentoffset. also updates the set of primary keys, used inidentification of rowitems.",
	"Method": "void getPage(){\r\n    updateCount();\r\n    ResultSet rs = null;\r\n    ResultSetMetaData rsmd = null;\r\n    cachedItems.clear();\r\n    itemIndexes.clear();\r\n    try {\r\n        try {\r\n            queryDelegate.setOrderBy(sorters);\r\n        } catch (UnsupportedOperationException e) {\r\n            getLogger().log(Level.FINE, \"The query delegate doesn't support sorting\", e);\r\n        }\r\n        queryDelegate.beginTransaction();\r\n        int fetchedRows = pageLength * CACHE_RATIO + cacheOverlap;\r\n        rs = queryDelegate.getResults(currentOffset, fetchedRows);\r\n        rsmd = rs.getMetaData();\r\n        List<String> pKeys = queryDelegate.getPrimaryKeyColumns();\r\n        ColumnProperty cp = null;\r\n        int rowCount = currentOffset;\r\n        if (!queryDelegate.implementationRespectsPagingLimits()) {\r\n            rowCount = currentOffset = 0;\r\n            setPageLengthInternal(size);\r\n        }\r\n        while (rs.next()) {\r\n            List<ColumnProperty> itemProperties = new ArrayList<ColumnProperty>();\r\n            Object[] itemId = new Object[pKeys.size()];\r\n            for (int i = 0; i < pKeys.size(); i++) {\r\n                itemId[i] = rs.getObject(pKeys.get(i));\r\n            }\r\n            RowId id = null;\r\n            if (pKeys.isEmpty()) {\r\n                id = new ReadOnlyRowId(rs.getRow());\r\n            } else {\r\n                id = new RowId(itemId);\r\n            }\r\n            List<String> propertiesToAdd = new ArrayList<String>(propertyIds);\r\n            if (!removedItems.containsKey(id)) {\r\n                for (int i = 1; i <= rsmd.getColumnCount(); i++) {\r\n                    if (!isColumnIdentifierValid(rsmd.getColumnLabel(i))) {\r\n                        continue;\r\n                    }\r\n                    String colName = rsmd.getColumnLabel(i);\r\n                    Object value = rs.getObject(i);\r\n                    Class<?> type = value != null ? value.getClass() : Object.class;\r\n                    if (value == null) {\r\n                        for (String propName : propertyTypes.keySet()) {\r\n                            if (propName.equals(rsmd.getColumnLabel(i))) {\r\n                                type = propertyTypes.get(propName);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (propertiesToAdd.contains(colName)) {\r\n                        cp = new ColumnProperty(colName, propertyReadOnly.get(colName), propertyPersistable.get(colName), propertyNullable.get(colName), propertyPrimaryKey.get(colName), value, type);\r\n                        itemProperties.add(cp);\r\n                        propertiesToAdd.remove(colName);\r\n                    }\r\n                }\r\n                itemIndexes.put(rowCount, id);\r\n                int modifiedIndex = indexInModifiedCache(id);\r\n                if (modifiedIndex != -1) {\r\n                    cachedItems.put(id, modifiedItems.get(modifiedIndex));\r\n                } else {\r\n                    cachedItems.put(id, new RowItem(this, id, itemProperties));\r\n                }\r\n                rowCount++;\r\n            }\r\n        }\r\n        rs.getStatement().close();\r\n        rs.close();\r\n        queryDelegate.commit();\r\n        getLogger().log(Level.FINER, \"Fetched {0} rows starting from {1}\", new Object[] { fetchedRows, currentOffset });\r\n    } catch (SQLException e) {\r\n        getLogger().log(Level.WARNING, \"Failed to fetch rows, rolling back\", e);\r\n        try {\r\n            queryDelegate.rollback();\r\n        } catch (SQLException e1) {\r\n            getLogger().log(Level.SEVERE, \"Failed to roll back\", e1);\r\n        }\r\n        try {\r\n            if (rs != null) {\r\n                if (rs.getStatement() != null) {\r\n                    rs.getStatement().close();\r\n                    rs.close();\r\n                }\r\n            }\r\n        } catch (SQLException e1) {\r\n            getLogger().log(Level.WARNING, \"Failed to close session\", e1);\r\n        }\r\n        throw new RuntimeException(\"Failed to fetch page.\", e);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.isSelectable",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "boolean isSelectable(){\r\n    return selectMode.getId() > SelectMode.NONE.getId();\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractListing.addDataGenerator",
	"Comment": "adds the given data generator to this listing. if the generator wasalready added, does nothing.",
	"Method": "void addDataGenerator(DataGenerator<T> generator){\r\n    getDataCommunicator().addDataGenerator(generator);\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractMedia.setAutoplay",
	"Comment": "sets whether the media is to automatically start playback when enoughdata has been loaded.",
	"Method": "void setAutoplay(boolean autoplay){\r\n    getState().autoplay = autoplay;\r\n}"
}, {
	"Path": "com.vaadin.server.BootstrapPageResponse.setDateHeader",
	"Comment": "properly formats a timestamp as a date in a header that will be includedin the http response. if the header had already been set, the new valueoverwrites the previous one.",
	"Method": "void setDateHeader(String name,long timestamp){\r\n    headers.put(name, Long.valueOf(timestamp));\r\n}"
}, {
	"Path": "com.vaadin.client.communication.MessageHandler.setConnection",
	"Comment": "sets the application connection this instance is connected to. calledinternally by the framework.",
	"Method": "void setConnection(ApplicationConnection connection){\r\n    this.connection = connection;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.query.generator.filter.QueryBuilder.getWhereStringForFilter",
	"Comment": "constructs and returns a string representing the filter that can be usedin a where clause.",
	"Method": "String getWhereStringForFilter(Filter filter,StatementHelper sh){\r\n    for (FilterTranslator ft : filterTranslators) {\r\n        if (ft.translatesFilter(filter)) {\r\n            return ft.getWhereStringForFilter(filter, sh);\r\n        }\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.updateSuggestionPopupMinWidth",
	"Comment": "update minimum width for combo box textarea based on input prompt andsuggestions.for internal use only. may be removed or replaced in the future.",
	"Method": "void updateSuggestionPopupMinWidth(){\r\n    debug(\"VComboBox: updateSuggestionPopupMinWidth()\");\r\n    String captions = WidgetUtil.escapeHTML(inputPrompt);\r\n    for (ComboBoxSuggestion suggestion : currentSuggestions) {\r\n        if (!captions.isEmpty()) {\r\n            captions += \"|\";\r\n        }\r\n        captions += WidgetUtil.escapeHTML(suggestion.getReplacementString());\r\n    }\r\n    suggestionPopupMinWidth = minWidth(captions);\r\n}"
}, {
	"Path": "com.vaadin.server.DownloadStream.setCacheTime",
	"Comment": "sets length of cache expiration time. this gives the adapter thepossibility cache streams sent to the client. the caching may be made inadapter or at the client if the client supports caching. zero or negativevalue disables the caching of this stream.",
	"Method": "void setCacheTime(long cacheTime){\r\n    this.cacheTime = cacheTime;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.HierarchicalQuery.getParent",
	"Comment": "get the hierarchical parent object, where null correspondsto the root node.",
	"Method": "T getParent(){\r\n    return parent;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VOptionGroupBase.getRows",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "int getRows(){\r\n    return rows;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.getClassLoader",
	"Comment": "gets the class loader to use for loading classes loaded by name, e.g.custom ui classes. this is by default the class loader that was used toload the servlet or portlet class to which this service belongs.",
	"Method": "ClassLoader getClassLoader(){\r\n    return classLoader;\r\n}"
}, {
	"Path": "com.vaadin.ui.Flash.getParameter",
	"Comment": "gets the value of an object parameter. parameters are optionalinformation, and they are passed to the instantiated object. parametersare are stored as name value pairs.",
	"Method": "String getParameter(String name){\r\n    return getState(false).embedParams != null ? getState(false).embedParams.get(name) : null;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VDateTimeCalendarPanel.setTimeChangeListener",
	"Comment": "the time change listener is triggered when the user changes the time.",
	"Method": "void setTimeChangeListener(TimeChangeListener listener){\r\n    timeChangeListener = listener;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addFooterKeyDownHandler",
	"Comment": "register a footerkeydownhandler to this grid. the event for this handleris fired when a keydown event occurs while cell focus is in the footer ofthis grid.",
	"Method": "HandlerRegistration addFooterKeyDownHandler(FooterKeyDownHandler handler){\r\n    return addHandler(handler, GridKeyDownEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.client.communication.MessageHandler.isUpdatingState",
	"Comment": "checks whether state changes are currently being processed. certainoperations are not allowed when the internal state of the applicationmight be in an inconsistent state because some state changes have beenapplied but others not. this includes running layotus.",
	"Method": "boolean isUpdatingState(){\r\n    return updatingState;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.DataProvider.ofItems",
	"Comment": "creates a new data provider from the given items.the items are copied into a new backing list, so structural changes tothe provided array will not be visible via the created data provider.",
	"Method": "ListDataProvider<T> ofItems(T items){\r\n    return new ListDataProvider(new ArrayList(Arrays.asList(items)));\r\n}"
}, {
	"Path": "bt.bencoding.BEParser.readType",
	"Comment": "read type of the root object of the bencoded document that this parser was created for.",
	"Method": "BEType readType(){\r\n    return type;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.getStartOfDay",
	"Comment": "calculates the end time of the day using the given calendar and date",
	"Method": "Date getStartOfDay(java.util.Calendar calendar,Date date){\r\n    java.util.Calendar calendarClone = (java.util.Calendar) calendar.clone();\r\n    calendarClone.setTime(date);\r\n    calendarClone.set(java.util.Calendar.MILLISECOND, 0);\r\n    calendarClone.set(java.util.Calendar.SECOND, 0);\r\n    calendarClone.set(java.util.Calendar.MINUTE, 0);\r\n    calendarClone.set(java.util.Calendar.HOUR, 0);\r\n    calendarClone.set(java.util.Calendar.HOUR_OF_DAY, 0);\r\n    return calendarClone.getTime();\r\n}"
}, {
	"Path": "com.vaadin.shared.ui.MarginInfo.hasTop",
	"Comment": "checks if this margininfo object has the top edge margin enabled.",
	"Method": "boolean hasTop(){\r\n    return (bitMask & TOP) == TOP;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.DataProvider.fromCallbacks",
	"Comment": "creates a new data provider that uses callbacks for fetching and countingitems from any backing store.the query that is passed to each callback will not contain any filtervalues.",
	"Method": "CallbackDataProvider<T, Void> fromCallbacks(FetchCallback<T, Void> fetchCallback,CountCallback<T, Void> countCallback){\r\n    return fromFilteringCallbacks(fetchCallback, countCallback);\r\n}"
}, {
	"Path": "com.vaadin.ui.LoginForm.createLoginButton",
	"Comment": "customize the login button. only for overriding, do not call.",
	"Method": "Button createLoginButton(){\r\n    throwIfInitialized();\r\n    return new Button(getLoginButtonCaption());\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.escalator.FlyweightRow.assertSetup",
	"Comment": "asserts that the flyweight row has properly been set up before trying toaccess any of its data.",
	"Method": "void assertSetup(){\r\n    assert element != null && row != BLANK && columnWidths != null : \"Flyweight row was not \" + \"properly initialized. Make sure the setup-method is \" + \"called before retrieving data. This is either a bug \" + \"in Escalator, or the instance of the flyweight row \" + \"has been stored and accessed.\";\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.converter.ConverterUtil.convertFromModel",
	"Comment": "convert the given value from the data source type to the ui type.",
	"Method": "PRESENTATIONTYPE convertFromModel(MODELTYPE modelValue,Class<? extends PRESENTATIONTYPE> presentationType,Converter<PRESENTATIONTYPE, MODELTYPE> converter,Locale locale){\r\n    if (converter != null) {\r\n        PRESENTATIONTYPE presentation = converter.convertToPresentation(modelValue, presentationType, locale);\r\n        if (presentation != null && !presentationType.isInstance(presentation)) {\r\n            throw new Converter.ConversionException(\"Converter returned an object of type \" + presentation.getClass().getName() + \" when expecting \" + presentationType.getName());\r\n        }\r\n        return presentation;\r\n    }\r\n    if (modelValue == null) {\r\n        return null;\r\n    }\r\n    if (presentationType.isAssignableFrom(modelValue.getClass())) {\r\n        return (PRESENTATIONTYPE) modelValue;\r\n    } else {\r\n        throw new Converter.ConversionException(\"Unable to convert value of type \" + modelValue.getClass().getName() + \" to presentation type \" + presentationType + \". No converter is set and the types are not compatible.\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.WebBrowser.isSafari",
	"Comment": "tests whether the user is using safari. note that chrome on ios is notdetected as safari but as chrome although the underlying browser engineis the same.",
	"Method": "boolean isSafari(){\r\n    if (browserDetails == null) {\r\n        return false;\r\n    }\r\n    return browserDetails.isSafari();\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addHeaderKeyUpHandler",
	"Comment": "register a headerkeyuphandler to this grid. the event for this handler isfired when a keyup event occurs while cell focus is in the header of thisgrid.",
	"Method": "HandlerRegistration addHeaderKeyUpHandler(HeaderKeyUpHandler handler){\r\n    return addHandler(handler, GridKeyUpEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinRequest.getCurrent",
	"Comment": "gets the currently processed vaadin request. the current request isautomatically defined when the request is started. the current requestcan not be used in e.g. background threads because of the way serverimplementations reuse request instances.",
	"Method": "VaadinRequest getCurrent(){\r\n    return CurrentInstance.get(VaadinRequest.class);\r\n}"
}, {
	"Path": "bt.tracker.TrackerRequestBuilder.uploaded",
	"Comment": "optionally set the amount of data uploaded during the current session.",
	"Method": "TrackerRequestBuilder uploaded(long uploaded){\r\n    if (uploaded < 0) {\r\n        throw new BtException(\"Invalid uploaded value: \" + uploaded);\r\n    }\r\n    this.uploaded = uploaded;\r\n    return this;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinServlet.ensureCookiesEnabled",
	"Comment": "check that cookie support is enabled in the browser. only checks uidlrequests.",
	"Method": "boolean ensureCookiesEnabled(VaadinServletRequest request,VaadinServletResponse response){\r\n    if (ServletPortletHelper.isUIDLRequest(request)) {\r\n        if (request.getRequestedSessionId() == null) {\r\n            SystemMessages systemMessages = getService().getSystemMessages(ServletPortletHelper.findLocale(null, null, request), request);\r\n            getService().writeUncachedStringResponse(response, JsonConstants.JSON_CONTENT_TYPE, VaadinService.createCriticalNotificationJSON(systemMessages.getCookiesDisabledCaption(), systemMessages.getCookiesDisabledMessage(), null, systemMessages.getCookiesDisabledURL()));\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinPortletRequest.getCurrentPortletRequest",
	"Comment": "gets the currently processed portlet request. the current portlet requestis automatically defined when the request is started. the current portletrequest can not be used in e.g. background threads because of the wayserver implementations reuse request instances.",
	"Method": "PortletRequest getCurrentPortletRequest(){\r\n    return VaadinPortletService.getCurrentPortletRequest();\r\n}"
}, {
	"Path": "com.vaadin.data.Binder.validateBindings",
	"Comment": "validates the bindings and returns the result of the validation as a listof validation statuses.does not run bean validators.",
	"Method": "List<BindingValidationStatus<?>> validateBindings(){\r\n    return getBindings().stream().map(BindingImpl::doValidation).collect(Collectors.toList());\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendar.isZeroLengthMidnightEvent",
	"Comment": "is the calendar event zero seconds long and is occurring at midnight.",
	"Method": "boolean isZeroLengthMidnightEvent(CalendarEvent event){\r\n    return areDatesEqualToSecond(event.getStartTime(), event.getEndTime()) && isMidnight(event.getEndTime());\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.DateField.fireValueChange",
	"Comment": "only fires the event if preventvaluechangeevent flag is false",
	"Method": "void fireValueChange(boolean repaintIsNotNeeded){\r\n    if (!preventValueChangeEvent) {\r\n        super.fireValueChange(repaintIsNotNeeded);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.sort.Sort.by",
	"Comment": "start building a sort order by sorting a provided column in ascendingorder.",
	"Method": "Sort by(Grid.Column<?, ?> column,Sort by,Grid.Column<?, ?> column,SortDirection direction){\r\n    return new Sort(column, direction);\r\n}"
}, {
	"Path": "com.vaadin.client.Profiler.reset",
	"Comment": "resets the collected profiler data. calls to this method will be removedby the compiler unless profiling is enabled.",
	"Method": "void reset(){\r\n    if (isEnabled()) {\r\n        initialize();\r\n        clearEventsList();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbsoluteLayout.internalSetPosition",
	"Comment": "updates the position for a component. caller must ensure component is achild of this layout.",
	"Method": "void internalSetPosition(Component component,ComponentPosition position){\r\n    componentToCoordinates.put(component, position);\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.client.BrowserInfo.isSafariOrIOS",
	"Comment": "returns true if the browser is safari or is a browser that is running onios and using the safari rendering engine.",
	"Method": "boolean isSafariOrIOS(){\r\n    return browserDetails.isSafariOrIOS();\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConnection.getThemeUri",
	"Comment": "gets the uri for the current theme. can be used to reference themeresources.",
	"Method": "String getThemeUri(){\r\n    return configuration.getVaadinDirUrl() + \"themes/\" + getUIConnector().getActiveTheme();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.addColumn",
	"Comment": "adds a new column to grid. this function makes sure that the propertywith the given id and data type exists in the container. if property doesnot exists, it will be created.default value for the new property is 0 if type is integer, double andfloat. if type is string, default value is an empty string. for all othertypes the default value is null.note that adding a new property is only done for the default containerthat grid sets up with the default constructor.",
	"Method": "void addColumn(Object propertyId,Column addColumn,Object propertyId,Column addColumn,Object propertyId,Class<?> type){\r\n    addColumnProperty(propertyId, type, null);\r\n    return getColumn(propertyId);\r\n}"
}, {
	"Path": "com.vaadin.util.ConnectorHelper.writeHierarchyInformation",
	"Comment": "creates a string containing hierarchy information for the connector.",
	"Method": "void writeHierarchyInformation(ClientConnector connector,StringBuilder builder){\r\n    LinkedList<ClientConnector> h = new LinkedList();\r\n    h.add(connector);\r\n    ClientConnector parent = connector.getParent();\r\n    while (parent != null) {\r\n        h.addFirst(parent);\r\n        parent = parent.getParent();\r\n    }\r\n    builder.append(\"\\nConnector hierarchy:\\n\");\r\n    int l = 0;\r\n    for (ClientConnector connector2 : h) {\r\n        if (l != 0) {\r\n            builder.append(\"\\n\");\r\n            for (int i = 0; i < l; i++) {\r\n                builder.append(\"  \");\r\n            }\r\n        }\r\n        l++;\r\n        Class<? extends ClientConnector> connectorClass = connector2.getClass();\r\n        Class<?> topClass = connectorClass;\r\n        while (topClass.getEnclosingClass() != null) {\r\n            topClass = topClass.getEnclosingClass();\r\n        }\r\n        builder.append(connectorClass.getName());\r\n        builder.append('(');\r\n        builder.append(topClass.getSimpleName());\r\n        builder.append(\".java:1)\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.data.AbstractRemoteDataSource.unpinHandle",
	"Comment": "unpins a previously pinned row with given handle. this function can beoverridden to do specific logic related to unpinning rows.",
	"Method": "void unpinHandle(RowHandleImpl handle){\r\n    Object key = handle.key;\r\n    final Integer count = pinnedCounts.get(key);\r\n    if (count == null) {\r\n        throw new IllegalStateException(\"Row \" + handle.getRow() + \" with key \" + key + \" was not pinned to begin with\");\r\n    } else if (count.equals(Integer.valueOf(1))) {\r\n        pinnedRows.remove(key);\r\n        pinnedCounts.remove(key);\r\n    } else {\r\n        pinnedCounts.put(key, Integer.valueOf(count.intValue() - 1));\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.extensions.DropTargetExtensionConnector.getDropTargetElement",
	"Comment": "finds the drop target element within the widget. by default, returns thetopmost element.",
	"Method": "Element getDropTargetElement(){\r\n    return dropTargetWidget.getElement();\r\n}"
}, {
	"Path": "com.vaadin.ui.MenuBar.setAutoOpen",
	"Comment": "using this method menubar can be put into a special mode where top levelmenus opens without clicking on the menu, but automatically when mousecursor is moved over the menu. in this mode the menu also closes itselfif the mouse is moved out of the opened menu.note, that on touch devices the menu still opens on a click event.",
	"Method": "void setAutoOpen(boolean autoOpenTopLevelMenu){\r\n    if (autoOpenTopLevelMenu != openRootOnHover) {\r\n        openRootOnHover = autoOpenTopLevelMenu;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.fieldgroup.FieldGroup.setReadOnly",
	"Comment": "sets the read only state to the given value for all fields with writabledata source. fields with read only data source will always be set to readonly.",
	"Method": "void setReadOnly(boolean fieldsReadOnly){\r\n    readOnly = fieldsReadOnly;\r\n    for (Field<?> field : getFields()) {\r\n        if (field.getPropertyDataSource() == null || !field.getPropertyDataSource().isReadOnly()) {\r\n            field.setReadOnly(fieldsReadOnly);\r\n        } else {\r\n            field.setReadOnly(true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTree.getNavigationPageUpKey",
	"Comment": "get the key the moves the selection one page up in the table. by defaultthis is the page up key but by overriding this you can change the key towhatever you want.",
	"Method": "int getNavigationPageUpKey(){\r\n    return KeyCodes.KEY_PAGEUP;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.getCloseKey",
	"Comment": "returns the key that closes the popup window if this is a vpopopcalendar.else this does nothing. by default this is the escape key but you canchange the key to whatever you want by overriding this method.",
	"Method": "int getCloseKey(){\r\n    return KeyCodes.KEY_ESCAPE;\r\n}"
}, {
	"Path": "com.vaadin.ui.Embedded.setParameter",
	"Comment": "sets an object parameter. parameters are optional information, and theyare passed to the instantiated object. parameters are are stored as namevalue pairs. this overrides the previous value assigned to thisparameter.",
	"Method": "void setParameter(String name,String value){\r\n    getState().parameters.put(name, value);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.updateRootWidth",
	"Comment": "calculates the width of the select if the select has undefined width.should be called when the width changes or when the icon changes.for internal use only. may be removed or replaced in the future.",
	"Method": "void updateRootWidth(){\r\n    debug(\"VComboBox: updateRootWidth()\");\r\n    if (connector.isUndefinedWidth()) {\r\n        int w = WidgetUtil.getRequiredWidth(this);\r\n        if (dataReceivedHandler.isWaitingForInitialData() && suggestionPopupMinWidth > w) {\r\n            Style style = getElement().getStyle();\r\n            String originalPadding = style.getPadding();\r\n            String originalBorder = style.getBorderWidth();\r\n            style.setPaddingLeft(0, Unit.PX);\r\n            style.setBorderWidth(0, Unit.PX);\r\n            style.setProperty(\"padding\", originalPadding);\r\n            style.setProperty(\"borderWidth\", originalBorder);\r\n            int iconWidth = selectedItemIcon == null ? 0 : WidgetUtil.getRequiredWidth(selectedItemIcon);\r\n            int buttonWidth = popupOpener == null ? 0 : WidgetUtil.getRequiredWidth(popupOpener);\r\n            tb.setWidth(suggestionPopupMinWidth - iconWidth - buttonWidth + \"px\");\r\n        }\r\n        if (!tb.getElement().getStyle().getWidth().endsWith(\"px\")) {\r\n            int iconWidth = selectedItemIcon == null ? 0 : selectedItemIcon.getOffsetWidth();\r\n            tb.setWidth(tb.getOffsetWidth() - iconWidth + \"px\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignAttributeHandler.removeSubsequentUppercase",
	"Comment": "replaces subsequent uppercase strings of length 2 or more followed eitherby another uppercase letter or an end of string. this is to generalisehandling of method names like showisoweeknumbers.",
	"Method": "String removeSubsequentUppercase(String param){\r\n    StringBuffer result = new StringBuffer();\r\n    Pattern pattern = Pattern.compile(\"(^|[^A-Z])([A-Z]{2,})([A-Z]|$)\");\r\n    Matcher matcher = pattern.matcher(param);\r\n    while (matcher.find()) {\r\n        String matched = matcher.group(2);\r\n        if (matcher.group(1).isEmpty()) {\r\n            matcher.appendReplacement(result, matched.toLowerCase(Locale.ROOT) + matcher.group(3));\r\n        } else {\r\n            matcher.appendReplacement(result, matcher.group(1) + matched.substring(0, 1) + matched.substring(1).toLowerCase(Locale.ROOT) + matcher.group(3));\r\n        }\r\n    }\r\n    matcher.appendTail(result);\r\n    return result.toString();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.orderedlayout.VAbstractOrderedLayout.getSlot",
	"Comment": "gets a slot based on the widget element. if no slot is found then null isreturned.",
	"Method": "Slot getSlot(Widget widget,Slot getSlot,com.google.gwt.user.client.Element widgetElement,Slot getSlot,Element widgetElement){\r\n    return getSlot(DOM.asOld(widgetElement));\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractSelect.addItem",
	"Comment": "create a new item into container. the created new item is returned andready for setting property values. if the creation fails, null isreturned. in case the container already contains the item, null isreturned.this functionality is optional. if the function is unsupported, it alwaysreturns null.",
	"Method": "Object addItem(Item addItem,Object itemId){\r\n    final Item retval = items.addItem(itemId);\r\n    if (retval != null && !(items instanceof Container.ItemSetChangeNotifier)) {\r\n        fireItemSetChange();\r\n    }\r\n    return retval;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.HierarchicalDataProvider.size",
	"Comment": "get the number of immediate child data items for the parent item returnedby a given query.",
	"Method": "int size(Query<T, F> query){\r\n    if (query instanceof HierarchicalQuery<?, ?>) {\r\n        return getChildCount((HierarchicalQuery<T, F>) query);\r\n    }\r\n    throw new IllegalArgumentException(\"Hierarchical data provider doesn't support non-hierarchical queries\");\r\n}"
}, {
	"Path": "com.vaadin.shared.Range.endsBefore",
	"Comment": "checks whether this range ends before the start of another range.",
	"Method": "boolean endsBefore(Range other){\r\n    return getEnd() <= other.getStart();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addHeaderKeyDownHandler",
	"Comment": "register a headerkeydownhandler to this grid. the event for this handleris fired when a keydown event occurs while cell focus is in the header ofthis grid.",
	"Method": "HandlerRegistration addHeaderKeyDownHandler(HeaderKeyDownHandler handler){\r\n    return addHandler(handler, GridKeyDownEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractTextualDate.getPlaceHolder",
	"Comment": "gets the set placeholder this textual date input, or an empty string ifnone is set.",
	"Method": "String getPlaceHolder(){\r\n    return text.getElement().getAttribute(\"placeholder\");\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTree.doNoRelationSelection",
	"Comment": "select a range between two nodes which have no relation to each other",
	"Method": "void doNoRelationSelection(TreeNode startNode,TreeNode endNode){\r\n    TreeNode commonParent = getCommonGrandParent(startNode, endNode);\r\n    TreeNode startBranch = null, endBranch = null;\r\n    List<TreeNode> children;\r\n    if (commonParent != null) {\r\n        children = commonParent.getChildren();\r\n    } else {\r\n        children = getRootNodes();\r\n    }\r\n    for (TreeNode node : children) {\r\n        if (nodeIsInBranch(startNode, node)) {\r\n            startBranch = node;\r\n        }\r\n        if (nodeIsInBranch(endNode, node)) {\r\n            endBranch = node;\r\n        }\r\n    }\r\n    if (children.indexOf(startBranch) > children.indexOf(endBranch)) {\r\n        TreeNode temp = startBranch;\r\n        startBranch = endBranch;\r\n        endBranch = temp;\r\n        temp = startNode;\r\n        startNode = endNode;\r\n        endNode = temp;\r\n    }\r\n    selectAllChildren(startNode, true);\r\n    TreeNode startParent = startNode.getParentNode();\r\n    TreeNode currentNode = startNode;\r\n    while (startParent != null && startParent != commonParent) {\r\n        List<TreeNode> startChildren = startParent.getChildren();\r\n        for (int i = startChildren.indexOf(currentNode) + 1; i < startChildren.size(); i++) {\r\n            selectAllChildren(startChildren.get(i), true);\r\n        }\r\n        currentNode = startParent;\r\n        startParent = startParent.getParentNode();\r\n    }\r\n    for (int i = children.indexOf(startBranch) + 1; i <= children.indexOf(endBranch); i++) {\r\n        selectAllChildrenUntil(children.get(i), endNode, true, true);\r\n    }\r\n    endNode.setSelected(true);\r\n    selectedIds.add(endNode.key);\r\n    selectionHasChanged = true;\r\n}"
}, {
	"Path": "com.vaadin.client.LayoutManager.unregisterDependency",
	"Comment": "registers that a managedlayout is no longer depending on the size of anelement.",
	"Method": "void unregisterDependency(ManagedLayout owner,Element element){\r\n    MeasuredSize measuredSize = getMeasuredSize(element, null);\r\n    if (measuredSize == null) {\r\n        return;\r\n    }\r\n    measuredSize.removeDependent(owner.getConnectorId());\r\n    stopMeasuringIfUnecessary(element);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.schedule.CalendarEvent.getRangeInMilliseconds",
	"Comment": "get the amount of milliseconds between the start and end of the event.",
	"Method": "long getRangeInMilliseconds(){\r\n    return getEndTime().getTime() - getStartTime().getTime();\r\n}"
}, {
	"Path": "com.vaadin.client.componentlocator.LocatorUtil.isNotificationElement",
	"Comment": "checks if path refers to vaadin notification elementcom.vaadin.ui.notification.",
	"Method": "boolean isNotificationElement(String path){\r\n    String regex = \"^\\\\/{0,2}(com\\\\.vaadin\\\\.ui\\\\.)?V?Notification[\\\\/\\\\[]?\";\r\n    RegExp regexp = RegExp.compile(regex);\r\n    return regexp.test(path);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.combobox.ComboBoxConnector.requestPage",
	"Comment": "send a message to the server to request a page of items with the currentfilter.this method is for internal use only and may be removed in futureversions.",
	"Method": "void requestPage(int page,String filter){\r\n    setFilter(filter);\r\n    if (page < 0) {\r\n        if (getState().scrollToSelectedItem) {\r\n            getDataSource().ensureAvailability(0, getDataSource().size());\r\n            return;\r\n        }\r\n        page = 0;\r\n    }\r\n    VComboBox widget = getWidget();\r\n    int adjustment = widget.nullSelectionAllowed && filter.isEmpty() ? 1 : 0;\r\n    int startIndex = Math.max(0, page * widget.pageLength - adjustment);\r\n    int pageLength = widget.pageLength > 0 ? widget.pageLength : getDataSource().size();\r\n    getDataSource().ensureAvailability(startIndex, pageLength);\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.getDependencyFilters",
	"Comment": "gets the filters which all resource dependencies are passed throughbefore being sent to the client for loading.",
	"Method": "Iterable<DependencyFilter> getDependencyFilters(){\r\n    if (dependencyFilters == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    return dependencyFilters;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.getFooter",
	"Comment": "returns the footer section of this grid. the default footer is empty.",
	"Method": "Footer getFooter(){\r\n    return footer;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addSortHandler",
	"Comment": "register a gwt event handler for a sorting event. this handler getscalled whenever this grid needs its data source to provide data sorted ina specific order.",
	"Method": "HandlerRegistration addSortHandler(SortHandler<T> handler){\r\n    return addHandler(handler, SortEvent.getType());\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.ContainerOrderedWrapper.removeItem",
	"Comment": "removes an item specified by the itemid from the underlying container andfrom the ordering.",
	"Method": "boolean removeItem(Object itemId){\r\n    final boolean success = container.removeItem(itemId);\r\n    if (!ordered && success) {\r\n        removeFromOrderWrapper(itemId);\r\n    }\r\n    return success;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VFilterSelect.setPromptingOff",
	"Comment": "turns prompting off. when prompting is turned on a command prompt isshown in the text box if nothing has been entered.for internal use only. may be removed or replaced in the future.",
	"Method": "void setPromptingOff(String text){\r\n    debug(\"VFS: setPromptingOff()\");\r\n    setTextboxText(text);\r\n    if (prompting) {\r\n        prompting = false;\r\n        removeStyleDependentName(CLASSNAME_PROMPT);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.DateTimeService.parseDate",
	"Comment": "parses the given date string using the given format string and the localeset in this datetimeservice instance.",
	"Method": "Date parseDate(String dateString,String formatString,boolean lenient){\r\n    DateTimeFormat format = DateTimeFormat.getFormat(formatString);\r\n    dateString = parseMonthName(dateString, formatString);\r\n    Date date;\r\n    if (lenient) {\r\n        date = format.parse(dateString);\r\n    } else {\r\n        date = format.parseStrict(dateString);\r\n    }\r\n    if (date != null && date.getTime() == 0) {\r\n        throw new IllegalArgumentException(\"Parsing of '\" + dateString + \"' failed\");\r\n    }\r\n    return date;\r\n}"
}, {
	"Path": "bt.peer.lan.AnnounceGroupChannel.shutdown",
	"Comment": "close currently opened channel if present and prevent creation of new channels.",
	"Method": "void shutdown(){\r\n    if (shutdown.compareAndSet(false, true)) {\r\n        closeQuietly();\r\n    }\r\n}"
}, {
	"Path": "com.folioreader.FolioReader.setConfig",
	"Comment": "pass your configuration and choose to override it every time or just for first execution.",
	"Method": "FolioReader setConfig(Config config,boolean overrideConfig){\r\n    this.config = config;\r\n    this.overrideConfig = overrideConfig;\r\n    return singleton;\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.getLastProcessedClientToServerId",
	"Comment": "gets the last processed server message id.used internally for communication tracking.",
	"Method": "int getLastProcessedClientToServerId(){\r\n    return lastProcessedClientToServerId;\r\n}"
}, {
	"Path": "com.vaadin.server.JsonCodec.valueChanged",
	"Comment": "compares the value with the reference. if they match, returns false.",
	"Method": "boolean valueChanged(JsonValue fieldValue,JsonValue referenceValue){\r\n    if (fieldValue instanceof JsonNull) {\r\n        fieldValue = null;\r\n    }\r\n    if (fieldValue == referenceValue) {\r\n        return false;\r\n    } else if (fieldValue == null || referenceValue == null) {\r\n        return true;\r\n    } else {\r\n        return !jsonEquals(fieldValue, referenceValue);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.PropertyValueGenerator.modifyFilter",
	"Comment": "return an updated filter that should be compatible with the underlyingcontainer.this function is called when setting a filter for this generatedproperty. returning null from this function causesgeneratedpropertycontainer to discard the filter and not use it.by default this function throws unsupportedfilterexception.",
	"Method": "Filter modifyFilter(Filter filter){\r\n    throw new UnsupportedFilterException(\"Filter\" + filter + \" is not supported\");\r\n}"
}, {
	"Path": "com.vaadin.ui.Flash.setCodebase",
	"Comment": "this attribute specifies the base path used to resolve relative urisspecified by the classid, data, and archive attributes. when absent, itsdefault value is the base uri of the current document.",
	"Method": "void setCodebase(String codebase){\r\n    if (codebase != getState().codebase || (codebase != null && !codebase.equals(getState().codebase))) {\r\n        getState().codebase = codebase;\r\n        requestRepaint();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponent.readSize",
	"Comment": "reads the size of this component from the given design attributes. if theattributes do not contain relevant size information, defaults isconsulted.",
	"Method": "void readSize(Attributes attributes){\r\n    if (attributes.hasKey(\"width-auto\") || attributes.hasKey(\"size-auto\")) {\r\n        this.setWidth(null);\r\n    } else if (attributes.hasKey(\"width-full\") || attributes.hasKey(\"size-full\")) {\r\n        this.setWidth(\"100%\");\r\n    } else if (attributes.hasKey(\"width\")) {\r\n        this.setWidth(attributes.get(\"width\"));\r\n    }\r\n    if (attributes.hasKey(\"height-auto\") || attributes.hasKey(\"size-auto\")) {\r\n        this.setHeight(null);\r\n    } else if (attributes.hasKey(\"height-full\") || attributes.hasKey(\"size-full\")) {\r\n        this.setHeight(\"100%\");\r\n    } else if (attributes.hasKey(\"height\")) {\r\n        this.setHeight(attributes.get(\"height\"));\r\n    }\r\n}"
}, {
	"Path": "org.greenrobot.essentials.Base64.decodeToObject",
	"Comment": "attempts to decode base64 data and deserialize a java object within. returns null if there was an error.if loader is not null, it will be the class loader used when deserializing.",
	"Method": "Object decodeToObject(String encodedObject,Object decodeToObject,String encodedObject,int options,ClassLoader loader){\r\n    byte[] objBytes = decode(encodedObject, options);\r\n    java.io.ByteArrayInputStream bais = null;\r\n    java.io.ObjectInputStream ois = null;\r\n    Object obj = null;\r\n    try {\r\n        bais = new java.io.ByteArrayInputStream(objBytes);\r\n        if (loader == null) {\r\n            ois = new java.io.ObjectInputStream(bais);\r\n        } else {\r\n            ois = new java.io.ObjectInputStream(bais) {\r\n                @Override\r\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\r\n                    Class c = Class.forName(streamClass.getName(), false, loader);\r\n                    if (c == null) {\r\n                        return super.resolveClass(streamClass);\r\n                    } else {\r\n                        return c;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        obj = ois.readObject();\r\n    } catch (java.io.IOException e) {\r\n        throw e;\r\n    } catch (java.lang.ClassNotFoundException e) {\r\n        throw e;\r\n    } finally {\r\n        try {\r\n            bais.close();\r\n        } catch (Exception e) {\r\n        }\r\n        try {\r\n            ois.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "org.greenrobot.essentials.Base64.decodeToObject",
	"Comment": "attempts to decode base64 data and deserialize a java object within. returns null if there was an error.if loader is not null, it will be the class loader used when deserializing.",
	"Method": "Object decodeToObject(String encodedObject,Object decodeToObject,String encodedObject,int options,ClassLoader loader){\r\n    Class c = Class.forName(streamClass.getName(), false, loader);\r\n    if (c == null) {\r\n        return super.resolveClass(streamClass);\r\n    } else {\r\n        return c;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.navigator.Navigator.fireAfterViewChange",
	"Comment": "fires an event after the current view has changed.listeners are called in registration order.",
	"Method": "void fireAfterViewChange(ViewChangeEvent event){\r\n    for (ViewChangeListener l : new ArrayList(listeners)) {\r\n        l.afterViewChange(event);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.Window.getTabStopTopAssistiveText",
	"Comment": "gets the message that is provided to users of assistive devices when theuser reaches the top of the window when leaving a window with the tab keyis prevented.",
	"Method": "String getTabStopTopAssistiveText(){\r\n    return getState(false).assistiveTabStopTopText;\r\n}"
}, {
	"Path": "com.vaadin.client.debug.internal.VDebugWindow.formatDuration",
	"Comment": "formats the given milliseconds as hours, minutes, seconds andmilliseconds.",
	"Method": "String formatDuration(int ms){\r\n    NumberFormat fmt = NumberFormat.getFormat(\"00\");\r\n    String seconds = fmt.format((ms / 1000) % 60);\r\n    String minutes = fmt.format((ms / (1000 * 60)) % 60);\r\n    String hours = fmt.format((ms / (1000 * 60 * 60)) % 24);\r\n    String millis = NumberFormat.getFormat(\"000\").format(ms % 1000);\r\n    return hours + \"h \" + minutes + \"m \" + seconds + \"s \" + millis + \"ms\";\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.components.calendar.event.BasicEvent.fireEventChange",
	"Comment": "fires an event change event to the listeners. should be triggered whensome property of the event changes.",
	"Method": "void fireEventChange(){\r\n    EventChangeEvent event = new EventChangeEvent(this);\r\n    for (EventChangeListener listener : listeners) {\r\n        listener.eventChange(event);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConfiguration.loadFromDOM",
	"Comment": "reads the configuration values defined by the bootstrap javascript.",
	"Method": "void loadFromDOM(){\r\n    JsoConfiguration jsoConfiguration = getJsoConfiguration(id);\r\n    serviceUrl = jsoConfiguration.getConfigString(ApplicationConstants.SERVICE_URL);\r\n    if (serviceUrl == null || serviceUrl.isEmpty()) {\r\n        serviceUrl = Window.Location.getHref().replaceFirst(\"[?#].*\", \"\");\r\n    } else {\r\n        serviceUrl = WidgetUtil.getAbsoluteUrl(serviceUrl);\r\n    }\r\n    if (!useServiceUrlPathParam() && !serviceUrl.endsWith(\"/\")) {\r\n        serviceUrl += '/';\r\n    }\r\n    contextRootUrl = jsoConfiguration.getConfigString(ApplicationConstants.CONTEXT_ROOT_URL);\r\n    vaadinDirUrl = WidgetUtil.getAbsoluteUrl(jsoConfiguration.getConfigString(ApplicationConstants.VAADIN_DIR_URL));\r\n    frontendUrl = WidgetUtil.getAbsoluteUrl(jsoConfiguration.getConfigString(ApplicationConstants.FRONTEND_URL));\r\n    uiId = jsoConfiguration.getConfigInteger(UIConstants.UI_ID_PARAMETER).intValue();\r\n    standalone = jsoConfiguration.getConfigBoolean(\"standalone\") == Boolean.TRUE;\r\n    heartbeatInterval = jsoConfiguration.getConfigInteger(\"heartbeatInterval\");\r\n    communicationError = jsoConfiguration.getConfigError(\"comErrMsg\");\r\n    authorizationError = jsoConfiguration.getConfigError(\"authErrMsg\");\r\n    sessionExpiredError = jsoConfiguration.getConfigError(\"sessExpMsg\");\r\n    rootElement = jsoConfiguration.getConfigElement(\"rootElement\");\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTree.getNavigationEndKey",
	"Comment": "get the key the moves the selection to the end of the table. by defaultthis is the end key but by overriding this you can change the key towhatever you want.",
	"Method": "int getNavigationEndKey(){\r\n    return KeyCodes.KEY_END;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.BeanContainer.addItemAt",
	"Comment": "adds a new bean at the given index.the bean is used both as the item contents and as the item identifier.",
	"Method": "BeanItem<BEANTYPE> addItemAt(int index,IDTYPE newItemId,BEANTYPE bean){\r\n    if (newItemId != null && bean != null) {\r\n        return super.addItemAt(index, newItemId, bean);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.ui.UIConnector.getPageState",
	"Comment": "returns the state of the page associated with the ui.note that state is considered an internal part of the connector. youshould not rely on the state object outside of the connector who owns it.if you depend on the state of other connectors you should use theirpublic api instead of their state object directly. the page state mightnot be an independent state object but can be embedded in ui state.",
	"Method": "PageState getPageState(){\r\n    return getState().pageState;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractDateField.reconstructDateFromFields",
	"Comment": "construct a date object from the individual field values received fromthe client.",
	"Method": "T reconstructDateFromFields(Map<String, Integer> resolutions,T oldDate){\r\n    Map<R, Integer> calendarFields = new HashMap();\r\n    for (R resolution : getResolutionsHigherOrEqualTo(getResolution())) {\r\n        String resolutionName = resolution.name();\r\n        Integer newValue = resolutions.get(resolutionName);\r\n        if (newValue == null) {\r\n            newValue = getDatePart(oldDate, resolution);\r\n        }\r\n        calendarFields.put(resolution, newValue);\r\n    }\r\n    return buildDate(calendarFields);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractContainer.getItemSetChangeListeners",
	"Comment": "returns the item set change listener collection. for internal use only.",
	"Method": "Collection<Container.ItemSetChangeListener> getItemSetChangeListeners(){\r\n    return itemSetChangeListeners;\r\n}"
}, {
	"Path": "com.vaadin.client.data.AbstractRemoteDataSource.setRowData",
	"Comment": "informs this data source that updated data has been sent from the server.",
	"Method": "void setRowData(int firstRowIndex,List<T> rowData){\r\n    assert firstRowIndex + rowData.size() <= size();\r\n    Profiler.enter(\"AbstractRemoteDataSource.setRowData\");\r\n    Range received = Range.withLength(firstRowIndex, rowData.size());\r\n    if (isWaitingForData()) {\r\n        cacheStrategy.onDataArrive(Duration.currentTimeMillis() - currentRequestCallback.requestStart, received.length());\r\n        currentRequestCallback = null;\r\n    }\r\n    Range maxCacheRange = getMaxCacheRange(received);\r\n    Range[] partition = received.partitionWith(maxCacheRange);\r\n    Range newUsefulData = partition[1];\r\n    if (!newUsefulData.isEmpty()) {\r\n        if (!cached.isEmpty())\r\n            discardStaleCacheEntries();\r\n        int start = newUsefulData.getStart();\r\n        for (int i = start; i < newUsefulData.getEnd(); i++) {\r\n            final T row = rowData.get(i - firstRowIndex);\r\n            indexToRowMap.put(Integer.valueOf(i), row);\r\n            keyToIndexMap.put(getRowKey(row), Integer.valueOf(i));\r\n        }\r\n        Profiler.enter(\"AbstractRemoteDataSource.setRowData notify dataChangeHandler\");\r\n        int length = newUsefulData.length();\r\n        getHandlers().forEach(dch -> dch.dataUpdated(start, length));\r\n        Profiler.leave(\"AbstractRemoteDataSource.setRowData notify dataChangeHandler\");\r\n        if (cached.isEmpty()) {\r\n            cached = newUsefulData;\r\n        } else {\r\n            if (!cached.isEmpty()) {\r\n                cached = cached.combineWith(newUsefulData);\r\n                fillCacheFromInvalidatedRows(maxCacheRange);\r\n            } else {\r\n                cached = newUsefulData;\r\n            }\r\n        }\r\n        getHandlers().forEach(dch -> dch.dataAvailable(cached.getStart(), cached.length()));\r\n        updatePinnedRows(rowData);\r\n    }\r\n    if (!partition[0].isEmpty() || !partition[2].isEmpty()) {\r\n        for (int i = 0; i < partition[0].length(); ++i) {\r\n            onDropFromCache(i + partition[0].getStart(), rowData.get(i));\r\n        }\r\n        for (int i = 0; i < partition[2].length(); ++i) {\r\n            onDropFromCache(i + partition[2].getStart(), rowData.get(i));\r\n        }\r\n    }\r\n    ensureCoverageCheck();\r\n    Profiler.leave(\"AbstractRemoteDataSource.setRowData\");\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.setWindowOrderAndPosition",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setWindowOrderAndPosition(){\r\n    if (windowOrder.contains(this)) {\r\n        return;\r\n    }\r\n    final int order = windowOrder.size();\r\n    setWindowOrder(order);\r\n    windowOrder.add(this);\r\n    setPopupPosition(order * STACKING_OFFSET_PIXELS, order * STACKING_OFFSET_PIXELS);\r\n    doFireOrderEvent();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.isColumnReorderingAllowed",
	"Comment": "returns whether columns can be reordered with drag and drop.",
	"Method": "boolean isColumnReorderingAllowed(){\r\n    return columnReorderingAllowed;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheet.updateTabCaptionSizes",
	"Comment": "recalculates the sizes of tab captions, causing the tabs to be renderedthe correct size.",
	"Method": "void updateTabCaptionSizes(){\r\n    for (int tabIx = 0; tabIx < tb.getTabCount(); tabIx++) {\r\n        tb.getTab(tabIx).recalculateCaptionWidth();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignAttributeHandler.resolveSupportedAttributes",
	"Comment": "resolves the supported attributes and corresponding getters and settersfor the class using introspection. after resolving, the information iscached internally by this class",
	"Method": "void resolveSupportedAttributes(Class<?> clazz){\r\n    if (clazz == null) {\r\n        throw new IllegalArgumentException(\"The clazz can not be null\");\r\n    }\r\n    if (CACHE.containsKey(clazz)) {\r\n        return;\r\n    }\r\n    BeanInfo beanInfo;\r\n    try {\r\n        beanInfo = Introspector.getBeanInfo(clazz);\r\n    } catch (IntrospectionException e) {\r\n        throw new RuntimeException(\"Could not get supported attributes for class \" + clazz.getName());\r\n    }\r\n    AttributeCacheEntry entry = new AttributeCacheEntry();\r\n    for (PropertyDescriptor descriptor : beanInfo.getPropertyDescriptors()) {\r\n        Method getter = descriptor.getReadMethod();\r\n        Method setter = descriptor.getWriteMethod();\r\n        Class<?> propertyType = descriptor.getPropertyType();\r\n        if (getter != null && setter != null && propertyType != null && getFormatter().canConvert(propertyType)) {\r\n            String attribute = toAttributeName(descriptor.getName());\r\n            entry.addAttribute(attribute, getter, setter);\r\n        }\r\n    }\r\n    CACHE.put(clazz, entry);\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addFooterDoubleClickHandler",
	"Comment": "register a footerdoubleclickhandler to this grid. the event for thishandler is fired when a double click event occurs in the footer of thisgrid.",
	"Method": "HandlerRegistration addFooterDoubleClickHandler(FooterDoubleClickHandler handler){\r\n    return addHandler(handler, GridDoubleClickEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.data.validator.BeanValidator.createContext",
	"Comment": "creates a simple message interpolation context based on the givenconstraint violation.",
	"Method": "Context createContext(ConstraintViolation<?> violation){\r\n    return new ContextImpl(violation);\r\n}"
}, {
	"Path": "com.vaadin.server.BootstrapPageResponse.setHeader",
	"Comment": "sets a header value that will be added to the http response. if theheader had already been set, the new value overwrites the previous one.",
	"Method": "void setHeader(String name,String value){\r\n    headers.put(name, value);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VPopupCalendar.getDescriptionForAssistiveDevices",
	"Comment": "get the description that explains the usage of the widget for users ofassistive devices.",
	"Method": "String getDescriptionForAssistiveDevices(){\r\n    return descriptionForAssistiveDevicesElement.getInnerText();\r\n}"
}, {
	"Path": "com.vaadin.server.BootstrapPageResponse.getDocument",
	"Comment": "gets the document node representing the root of the dom hierarchy thatwill be used to generate the html page. changes to the document will bereflected in the html.",
	"Method": "Document getDocument(){\r\n    return document;\r\n}"
}, {
	"Path": "com.vaadin.server.ServiceInitEvent.addDependencyFilter",
	"Comment": "adds a new dependency filter that will be used by this service.",
	"Method": "void addDependencyFilter(DependencyFilter dependencyFilter){\r\n    Objects.requireNonNull(dependencyFilter, \"Dependency filter cannot be null\");\r\n    addedDependencyFilters.add(dependencyFilter);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheetBase.setTabCaptionsAsHtml",
	"Comment": "sets whether the caption is rendered as html.the default is false, i.e. render tab captions as plain text",
	"Method": "void setTabCaptionsAsHtml(boolean tabCaptionsAsHtml){\r\n    this.tabCaptionsAsHtml = tabCaptionsAsHtml;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VMenuBar.showChildMenu",
	"Comment": "shows the child menu of an item. the caller must ensure that the item hasa submenu.",
	"Method": "void showChildMenu(CustomMenuItem item){\r\n    int left = 0;\r\n    int top = 0;\r\n    if (subMenu) {\r\n        left = item.getParentMenu().getAbsoluteLeft() + item.getParentMenu().getOffsetWidth();\r\n        top = item.getAbsoluteTop();\r\n    } else {\r\n        left = item.getAbsoluteLeft();\r\n        top = item.getParentMenu().getAbsoluteTop() + item.getParentMenu().getOffsetHeight();\r\n    }\r\n    showChildMenuAt(item, top, left);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.isDateInsideRange",
	"Comment": "checks inclusively whether a date is inside a range of dates or not.",
	"Method": "boolean isDateInsideRange(Date date,Resolution minResolution){\r\n    assert (date != null);\r\n    return isAcceptedByRangeEnd(date, minResolution) && isAcceptedByRangeStart(date, minResolution);\r\n}"
}, {
	"Path": "com.vaadin.navigator.Navigator.createNavigationStateManager",
	"Comment": "creates a navigation state manager for given ui. this method should takeinto account any navigation related annotations.",
	"Method": "NavigationStateManager createNavigationStateManager(UI ui){\r\n    if (ui.getClass().getAnnotation(PushStateNavigation.class) != null) {\r\n        return new PushStateManager(ui);\r\n    }\r\n    return new UriFragmentManager(ui.getPage());\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.createRequestHandlers",
	"Comment": "called during initialization to add the request handlers for the service.note that the returned list will be reversed so the last handler will becalled first. this enables overriding this method and using add on thereturned list to add a custom request handler which overrides anypredefined handler.",
	"Method": "List<RequestHandler> createRequestHandlers(){\r\n    List<RequestHandler> handlers = new ArrayList();\r\n    handlers.add(new SessionRequestHandler());\r\n    handlers.add(new PublishedFileHandler());\r\n    handlers.add(new HeartbeatHandler());\r\n    handlers.add(new FileUploadHandler());\r\n    handlers.add(new UidlRequestHandler());\r\n    handlers.add(new UnsupportedBrowserHandler());\r\n    handlers.add(new ConnectorResourceHandler());\r\n    return handlers;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.cursorInsideBrowserContentArea",
	"Comment": "todo check if we need to support this with touch based devices.checks if the cursor was inside the browser content area when the eventhappened.",
	"Method": "boolean cursorInsideBrowserContentArea(Event event){\r\n    if (event.getClientX() < 0 || event.getClientY() < 0) {\r\n        return false;\r\n    }\r\n    if (event.getClientX() > Window.getClientWidth() || event.getClientY() > Window.getClientHeight()) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.vaadin.ui.Upload.interruptUpload",
	"Comment": "interrupts the upload currently being received. the interruption will bedone by the receiving thread so this method will return immediately andthe actual interrupt will happen a bit later.",
	"Method": "void interruptUpload(){\r\n    if (isUploading) {\r\n        interrupted = true;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheetBase.isDynamicWidth",
	"Comment": "returns true if the width of the widget is undefined, false otherwise.",
	"Method": "boolean isDynamicWidth(){\r\n    return getConnectorForWidget(this).isUndefinedWidth();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.schedule.DateCell.updateGroup",
	"Comment": "update top and bottom date range values. add new index to the group.",
	"Method": "void updateGroup(DateCellGroup targetGroup,DateCellGroup byGroup){\r\n    Date newStart = targetGroup.getStart();\r\n    Date newEnd = targetGroup.getEnd();\r\n    if (byGroup.getStart().before(targetGroup.getStart())) {\r\n        newStart = byGroup.getEnd();\r\n    }\r\n    if (byGroup.getStart().after(targetGroup.getEnd())) {\r\n        newStart = byGroup.getStart();\r\n    }\r\n    targetGroup.setDateRange(new WeekGridMinuteTimeRange(newStart, newEnd));\r\n    for (Integer index : byGroup.getItems()) {\r\n        if (!targetGroup.getItems().contains(index)) {\r\n            targetGroup.add(index);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.communication.StateChangeEvent.addJsonFields",
	"Comment": "recursively adds the names of all fields in all objects in the providedjson object.",
	"Method": "void addJsonFields(JsonObject json,FastStringSet changedProperties,String context){\r\n    for (String key : json.keys()) {\r\n        String fieldName = context + key;\r\n        changedProperties.add(fieldName);\r\n        JsonObject object = json.get(key);\r\n        if (object != null) {\r\n            addJsonFields(object, changedProperties, fieldName + \".\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.escalator.RowVisibilityChangeEvent.getFirstVisibleRow",
	"Comment": "gets the index of the first row that is at least partially visible.",
	"Method": "int getFirstVisibleRow(){\r\n    return visibleRows.getStart();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.PropertyFormatter.valueChange",
	"Comment": "listens for changes in the datasource.this should not be called directly.",
	"Method": "void valueChange(Property.ValueChangeEvent event){\r\n    fireValueChange();\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.sort.SortEvent.getType",
	"Comment": "static access to the gwt event type identifier associated with this eventclass.",
	"Method": "Type<SortHandler<?>> getType(){\r\n    return TYPE;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.FilesystemContainer.addItemIds",
	"Comment": "internal recursive method to add the files under the specified directoryto the collection.",
	"Method": "void addItemIds(Collection<File> col,File f){\r\n    File[] l;\r\n    if (filter != null) {\r\n        l = f.listFiles(filter);\r\n    } else {\r\n        l = f.listFiles();\r\n    }\r\n    if (l == null) {\r\n        return;\r\n    }\r\n    final List<File> ll = Arrays.asList(l);\r\n    Collections.sort(ll);\r\n    for (final File lf : ll) {\r\n        col.add(lf);\r\n        if (lf.isDirectory()) {\r\n            addItemIds(col, lf);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.communication.MessageHandler.parseWrappedJson",
	"Comment": "parse the given wrapped json, received from the server, to a valuemap.",
	"Method": "ValueMap parseWrappedJson(String wrappedJsonText){\r\n    return parseJson(stripJSONWrapping(wrappedJsonText));\r\n}"
}, {
	"Path": "edu.uci.ics.crawler4j.url.UrlResolver.indexOf",
	"Comment": "returns the index within the specified string of the first occurrence ofthe specified search character.",
	"Method": "int indexOf(String s,char searchChar,int beginIndex,int endIndex){\r\n    for (int i = beginIndex; i < endIndex; i++) {\r\n        if (s.charAt(i) == searchChar) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "brave.spring.webmvc.WebMvcRuntime.findWebMvcRuntime",
	"Comment": "attempt to match the host runtime to a capable platform implementation.",
	"Method": "WebMvcRuntime findWebMvcRuntime(){\r\n    try {\r\n        Class.forName(\"org.springframework.web.method.HandlerMethod\");\r\n        return new WebMvc31();\r\n    } catch (ClassNotFoundException e) {\r\n    }\r\n    return new WebMvc25();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.ListSelect.setRows",
	"Comment": "sets the number of rows in the editor. if the number of rows is set 0,the actual number of displayed rows is determined implicitly by theadapter.",
	"Method": "void setRows(int rows){\r\n    if (rows < 0) {\r\n        rows = 0;\r\n    }\r\n    if (this.rows != rows) {\r\n        this.rows = rows;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.JsonCodec.encodeConnectorMap",
	"Comment": "encodes a connector map. invisible connectors are skipped.",
	"Method": "JsonObject encodeConnectorMap(Type valueType,Map<?, ?> map,ConnectorTracker connectorTracker){\r\n    JsonObject jsonMap = Json.createObject();\r\n    for (Entry<?, ?> entry : map.entrySet()) {\r\n        ClientConnector key = (ClientConnector) entry.getKey();\r\n        if (LegacyCommunicationManager.isConnectorVisibleToClient(key)) {\r\n            EncodeResult encodedValue = encode(entry.getValue(), null, valueType, connectorTracker);\r\n            jsonMap.put(key.getConnectorId(), encodedValue.getEncodedValue());\r\n        }\r\n    }\r\n    return jsonMap;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTwinColSelect.setInternalHeights",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setInternalHeights(){\r\n    int captionHeight = WidgetUtil.getRequiredHeight(captionWrapper);\r\n    int totalHeight = getOffsetHeight();\r\n    String selectHeight = totalHeight - captionHeight + \"px\";\r\n    selectionsListBox.setHeight(selectHeight);\r\n    optionsListBox.setHeight(selectHeight);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractSplitPanel.updateSizes",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void updateSizes(){\r\n    if (!isAttached()) {\r\n        return;\r\n    }\r\n    switch(orientation) {\r\n        case HORIZONTAL:\r\n            horizontalOrientationUpdateSizes();\r\n            break;\r\n        case VERTICAL:\r\n            verticalOrientationUpdateSizes();\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VContextMenu.ensureHidden",
	"Comment": "hides context menu if it is currently shown by given action owner.",
	"Method": "void ensureHidden(ActionOwner actionOwner){\r\n    if (this.actionOwner == actionOwner) {\r\n        hide();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.getNavigationPageUpKey",
	"Comment": "get the key the moves the selection one page up in the table. by defaultthis is the page up key but by overriding this you can change the key towhatever you want.",
	"Method": "int getNavigationPageUpKey(){\r\n    return KeyCodes.KEY_PAGEUP;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.HierarchyMapper.setFilter",
	"Comment": "sets the current filter. this will cause the hierarchy to be constructedagain.",
	"Method": "void setFilter(Object filter){\r\n    this.filter = (F) filter;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VFilterSelect.getMainWidth",
	"Comment": "get the width of the select in pixels where the text area and icon hasbeen included.",
	"Method": "int getMainWidth(){\r\n    return getOffsetWidth();\r\n}"
}, {
	"Path": "com.vaadin.ui.Panel.changeVariables",
	"Comment": "called when one or more variables handled by the implementing class arechanged.",
	"Method": "void changeVariables(Object source,Map<String, Object> variables){\r\n    final Integer newWidth = (Integer) variables.get(\"width\");\r\n    final Integer newHeight = (Integer) variables.get(\"height\");\r\n    if (newWidth != null && newWidth.intValue() != getWidth()) {\r\n        setWidth(newWidth.intValue(), UNITS_PIXELS);\r\n    }\r\n    if (newHeight != null && newHeight.intValue() != getHeight()) {\r\n        setHeight(newHeight.intValue(), UNITS_PIXELS);\r\n    }\r\n    final Integer newScrollX = (Integer) variables.get(\"scrollLeft\");\r\n    final Integer newScrollY = (Integer) variables.get(\"scrollTop\");\r\n    if (newScrollX != null && newScrollX.intValue() != getScrollLeft()) {\r\n        getState().scrollLeft = newScrollX.intValue();\r\n    }\r\n    if (newScrollY != null && newScrollY.intValue() != getScrollTop()) {\r\n        getState().scrollTop = newScrollY.intValue();\r\n    }\r\n    if (actionManager != null) {\r\n        actionManager.handleActions(variables, this);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractInMemoryContainer.fireItemsAdded",
	"Comment": "notify item set change listeners that items has been added to thecontainer.",
	"Method": "void fireItemsAdded(int firstPosition,ITEMIDTYPE firstItemId,int numberOfItems){\r\n    BaseItemAddEvent addEvent = new BaseItemAddEvent(this, firstItemId, firstPosition, numberOfItems);\r\n    fireItemSetChange(addEvent);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendar.isEventCaptionAsHtml",
	"Comment": "checks whether event captions are rendered as htmlthe default is false, i.e. to render that caption as plain text.",
	"Method": "boolean isEventCaptionAsHtml(){\r\n    return eventCaptionAsHtml;\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignContext.instantiateComponent",
	"Comment": "creates a component corresponding to the given node. does not set theattributes for the created object.",
	"Method": "Component instantiateComponent(Node node){\r\n    String tag = node.nodeName();\r\n    ComponentMapper componentMapper = Design.getComponentMapper();\r\n    Component component = componentMapper.tagToComponent(tag, Design.getComponentFactory(), this);\r\n    assert tagEquals(tag, componentMapper.componentToTag(component, this));\r\n    return component;\r\n}"
}, {
	"Path": "com.vaadin.tests.design.LocaleTest.testParsing",
	"Comment": "checks that the locale of a component is set when the html elementcorresponding to the component specifies a locale.",
	"Method": "void testParsing(){\r\n    Document doc = new Document(\"\");\r\n    DocumentType docType = new DocumentType(\"html\", \"\", \"\", \"\");\r\n    doc.appendChild(docType);\r\n    Element html = doc.createElement(\"html\");\r\n    doc.appendChild(html);\r\n    html.appendChild(doc.createElement(\"head\"));\r\n    Element body = doc.createElement(\"body\");\r\n    html.appendChild(body);\r\n    Element evLayout = doc.createElement(\"vaadin-vertical-layout\");\r\n    evLayout.attr(\"locale\", \"en_US\");\r\n    body.appendChild(evLayout);\r\n    Element ehLayout = doc.createElement(\"vaadin-horizontal-layout\");\r\n    evLayout.appendChild(ehLayout);\r\n    Element eb1 = doc.createElement(\"vaadin-button\");\r\n    eb1.attr(\"locale\", \"en_US\");\r\n    ehLayout.appendChild(eb1);\r\n    Element eb2 = doc.createElement(\"vaadin-button\");\r\n    eb2.attr(\"locale\", \"en_GB\");\r\n    ehLayout.appendChild(eb2);\r\n    Element eb3 = doc.createElement(\"vaadin-button\");\r\n    ehLayout.appendChild(eb3);\r\n    String string = doc.html();\r\n    VerticalLayout vLayout = (VerticalLayout) Design.read(new ByteArrayInputStream(string.getBytes()));\r\n    assertEquals(\"Wrong locale.\", new Locale(\"en\", \"US\"), vLayout.getLocale());\r\n    HorizontalLayout hLayout = (HorizontalLayout) vLayout.getComponent(0);\r\n    assertEquals(\"The element should have the same locale as its parent.\", vLayout.getLocale(), hLayout.getLocale());\r\n    Button b1 = (Button) hLayout.getComponent(0);\r\n    assertEquals(\"Wrong locale.\", new Locale(\"en\", \"US\"), b1.getLocale());\r\n    Button b2 = (Button) hLayout.getComponent(1);\r\n    assertEquals(\"Wrong locale.\", new Locale(\"en\", \"GB\"), b2.getLocale());\r\n    Button b3 = (Button) hLayout.getComponent(2);\r\n    assertEquals(\"The component should have the same locale as its parent.\", hLayout.getLocale(), b3.getLocale());\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VMenuBar.getNavigationSelectKey",
	"Comment": "get the key that selects a menu item. by default it is the enter key butby overriding this you can change the key to whatever you want.",
	"Method": "int getNavigationSelectKey(){\r\n    return KeyCodes.KEY_ENTER;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addFooterClickHandler",
	"Comment": "register a footerclickhandler to this grid. the event for this handler isfired when a click event occurs in the footer of this grid.",
	"Method": "HandlerRegistration addFooterClickHandler(FooterClickHandler handler){\r\n    return addHandler(handler, GridClickEvent.TYPE);\r\n}"
}, {
	"Path": "com.github.dozermapper.core.DozerModule.getBeanBuilderCreationStrategies",
	"Comment": "to be implemented by module if it provides any additional strategies for beans creation.",
	"Method": "Collection<BeanBuilderCreationStrategy> getBeanBuilderCreationStrategies(){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.getPreviousKey",
	"Comment": "the key that selects the previous week in the calendar. by default thisis the up arrow key but by overriding this method it can be changed towhatever you like.",
	"Method": "int getPreviousKey(){\r\n    return KeyCodes.KEY_UP;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Form.addValidator",
	"Comment": "adding validators directly to form is not supported.add the validators to form fields instead.",
	"Method": "void addValidator(Validator validator){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.vaadin.ui.NativeSelect.isEmptySelectionAllowed",
	"Comment": "returns whether the user is allowed to select nothing in the combo box.",
	"Method": "boolean isEmptySelectionAllowed(){\r\n    return getState(false).emptySelectionAllowed;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractSplitPanel.setLocked",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setLocked(boolean newValue){\r\n    if (locked != newValue) {\r\n        locked = newValue;\r\n        splitterSize = -1;\r\n        setStylenames();\r\n    }\r\n}"
}, {
	"Path": "bt.dht.stream.StreamAdapter.finishStream",
	"Comment": "caller should invoke this method, if the underlying stream should not expectto receive any more items and can terminate at will.",
	"Method": "void finishStream(){\r\n    streamFinished.set(true);\r\n    ConsumerThread t = consumerThread.get();\r\n    if (t != null && t.isNewItemExpected()) {\r\n        t.getThread().interrupt();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.getDefaultHeaderRow",
	"Comment": "returns the current default row of the header section. the default row isa special header row providing a user interface for sorting columns.setting a header caption for column updates cells in the default header.",
	"Method": "HeaderRow getDefaultHeaderRow(){\r\n    return header.getDefaultRow();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addFooterDoubleClickHandler",
	"Comment": "register a footerdoubleclickhandler to this grid. the event for thishandler is fired when a double click event occurs in the footer of thisgrid.",
	"Method": "HandlerRegistration addFooterDoubleClickHandler(FooterDoubleClickHandler handler){\r\n    return addHandler(handler, GridDoubleClickEvent.TYPE);\r\n}"
}, {
	"Path": "brave.spring.webmvc.SpanCustomizingAsyncHandlerInterceptor.afterCompletion",
	"Comment": "set the route attribute on completion to avoid any thread visibility issues reading it",
	"Method": "void afterCompletion(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex){\r\n    SpanCustomizer span = (SpanCustomizer) request.getAttribute(SpanCustomizer.class.getName());\r\n    if (span != null)\r\n        setHttpRouteAttribute(request);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VSlider.getNavigationRightKey",
	"Comment": "get the key that increases the horizontal slider. by default it is theright arrow key but by overriding this you can change the key to whateveryou want.",
	"Method": "int getNavigationRightKey(){\r\n    return KeyCodes.KEY_RIGHT;\r\n}"
}, {
	"Path": "com.vaadin.server.communication.JSR356WebsocketInitializer.isAtmosphereFrameworkAttribute",
	"Comment": "checks if the given attribute name matches the convention used forstoring atmosphereframework references.",
	"Method": "boolean isAtmosphereFrameworkAttribute(String attributeName){\r\n    return attributeName.startsWith(JSR356WebsocketInitializer.class.getName() + \".\");\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VFilterSelect.getSelectedCaption",
	"Comment": "this method is meant for internal use and may change in future versions.",
	"Method": "String getSelectedCaption(){\r\n    return explicitSelectedCaption;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.getEditorCancelCaption",
	"Comment": "gets the current caption of the cancel button in the grid editor.",
	"Method": "String getEditorCancelCaption(){\r\n    return getState(false).editorCancelCaption;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTwinColSelect.setInternalHeights",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setInternalHeights(){\r\n    int captionHeight = WidgetUtil.getRequiredHeight(captionWrapper);\r\n    int totalHeight = getOffsetHeight();\r\n    String selectHeight = (totalHeight - captionHeight) + \"px\";\r\n    selections.setHeight(selectHeight);\r\n    options.setHeight(selectHeight);\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.setCellStyleGenerator",
	"Comment": "sets the style generator that is used for generating styles for cells.",
	"Method": "void setCellStyleGenerator(CellStyleGenerator<T> cellStyleGenerator){\r\n    this.cellStyleGenerator = cellStyleGenerator;\r\n    requestRefreshBody();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VUI.isMonitoringParentSize",
	"Comment": "returns true if the size of the parent should be checked periodically andthe application should react to its changes.",
	"Method": "boolean isMonitoringParentSize(){\r\n    return isEmbedded();\r\n}"
}, {
	"Path": "com.vaadin.client.metadata.ConnectorBundleLoader.getLoadedBundles",
	"Comment": "gets a list of all currently loaded bundle names.this method is intended for testing the loading mechanism.",
	"Method": "List<String> getLoadedBundles(){\r\n    List<String> bundles = new ArrayList();\r\n    JsArrayString keys = asyncBlockLoaders.getKeys();\r\n    for (int i = 0; i < keys.length(); i++) {\r\n        String bundleName = keys.get(i);\r\n        if (isBundleLoaded(bundleName)) {\r\n            bundles.add(bundleName);\r\n        }\r\n    }\r\n    return bundles;\r\n}"
}, {
	"Path": "com.vaadin.client.widget.escalator.ScrollbarBundle.updateScrollPosFromDom",
	"Comment": "this is a method that jsni can call to synchronize the object state fromthe dom.",
	"Method": "void updateScrollPosFromDom(){\r\n    int newScrollPos = internalGetScrollPos();\r\n    if (!isLocked()) {\r\n        scrollPos = newScrollPos;\r\n        scrollEventFirer.scheduleEvent();\r\n    } else if (scrollPos != newScrollPos) {\r\n        internalSetScrollPos(toInt32(scrollPos));\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VSlider.getNavigationDownKey",
	"Comment": "get the key that decreases the vertical slider. by default it is the downarrow key but by overriding this you can change the key to whatever youwant.",
	"Method": "int getNavigationDownKey(){\r\n    return KeyCodes.KEY_DOWN;\r\n}"
}, {
	"Path": "net.openhft.chronicle.queue.VisibilityOfMessagesBetweenTailorsAndAppenderTest.test",
	"Comment": "check if a message is written with an appender its visible to the tailor, without locks etc.",
	"Method": "void test(){\r\n    ChronicleQueue x = SingleChronicleQueueBuilder.binary(getTmpDir()).rollCycle(RollCycles.MINUTELY).build();\r\n    ExecutorService e1 = Executors.newSingleThreadExecutor();\r\n    e1.submit(() -> {\r\n        ExcerptAppender excerptAppender = x.acquireAppender();\r\n        for (long i = 0; i < 1_000_000; i++) {\r\n            try (DocumentContext dc = excerptAppender.writingDocument()) {\r\n                dc.wire().getValueOut().int64(i);\r\n            }\r\n            lastWrittenIndex = excerptAppender.lastIndexAppended();\r\n        }\r\n    });\r\n    ExecutorService e2 = Executors.newSingleThreadExecutor();\r\n    Future f2 = e2.submit(() -> {\r\n        ExcerptTailer tailer = x.createTailer();\r\n        for (; ; ) {\r\n            long i = lastWrittenIndex;\r\n            if (i != Long.MIN_VALUE)\r\n                if (!tailer.moveToIndex(i))\r\n                    throw new ExecutionException(\"non atomic, index=\" + Long.toHexString(i), null);\r\n        }\r\n    });\r\n    try {\r\n        f2.get(5, TimeUnit.SECONDS);\r\n    } catch (TimeoutException ignore) {\r\n    }\r\n    e2.shutdownNow();\r\n    e1.shutdownNow();\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridDragSource.addGridDragEndListener",
	"Comment": "attaches dragend listener for the current drag source grid.",
	"Method": "Registration addGridDragEndListener(GridDragEndListener<T> listener){\r\n    return addListener(DragSourceState.EVENT_DRAGEND, GridDragEndEvent.class, listener, GridDragEndListener.DRAG_END_METHOD);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.dd.VDragEvent.syncContent",
	"Comment": "do additional content sync between original element and itscopy if needed.",
	"Method": "void syncContent(Element original,Element copy){\r\n    for (int i = 0; i < original.getChildCount(); i++) {\r\n        Node child = original.getChild(i);\r\n        if (child instanceof Element) {\r\n            syncContent((Element) child, (Element) copy.getChild(i));\r\n        }\r\n    }\r\n    doSyncContent(original, copy);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.converter.ConverterUtil.canConverterPossiblyHandle",
	"Comment": "checks if it possible that the given converter can handle conversionbetween the given presentation and model type somehow.",
	"Method": "boolean canConverterPossiblyHandle(Converter<?, ?> converter,Class<?> presentationType,Class<?> modelType){\r\n    if (converter == null) {\r\n        return false;\r\n    }\r\n    Class<?> converterModelType = converter.getModelType();\r\n    if (!modelType.isAssignableFrom(converterModelType) && !converterModelType.isAssignableFrom(modelType)) {\r\n        return false;\r\n    }\r\n    Class<?> converterPresentationType = converter.getPresentationType();\r\n    if (!presentationType.isAssignableFrom(converterPresentationType) && !converterPresentationType.isAssignableFrom(presentationType)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractMultiSelect.addValueChangeListener",
	"Comment": "adds a value change listener. the listener is called when the selectionset of this multi select is changed either by the user orprogrammatically.",
	"Method": "Registration addValueChangeListener(HasValue.ValueChangeListener<Set<T>> listener){\r\n    return addSelectionListener(event -> listener.valueChange(new ValueChangeEvent(this, event.getOldValue(), event.isUserOriginated())));\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.getEditorSaveCaption",
	"Comment": "gets the current caption on the save button in the grid editor.",
	"Method": "String getEditorSaveCaption(){\r\n    return editor.getSaveCaption();\r\n}"
}, {
	"Path": "com.vaadin.client.connectors.AbstractMultiSelectConnector.onDataChange",
	"Comment": "this method handles the parsing of the new json data containing the itemsand the selection information.",
	"Method": "void onDataChange(Range range){\r\n    assert range.getStart() == 0 && range.getEnd() == getDataSource().size() : getClass().getSimpleName() + \" only supports full updates, but got range \" + range;\r\n    List<JsonObject> items = new ArrayList(range.length());\r\n    for (int i = 0; i < range.getEnd(); i++) {\r\n        items.add(getDataSource().getRow(i));\r\n    }\r\n    getMultiSelectWidget().setItems(items);\r\n}"
}, {
	"Path": "com.vaadin.client.WidgetUtil.getSubPixelRoundingFactor",
	"Comment": "returns the factor used by browsers to round subpixel values",
	"Method": "double getSubPixelRoundingFactor(){\r\n    if (detectedSubPixelRoundingFactor != -1) {\r\n        return detectedSubPixelRoundingFactor;\r\n    }\r\n    double probeSize = 0.999999;\r\n    DivElement div = Document.get().createDivElement();\r\n    Document.get().getBody().appendChild(div);\r\n    div.getStyle().setHeight(probeSize, Unit.PX);\r\n    ComputedStyle computedStyle = new ComputedStyle(div);\r\n    double computedHeight = computedStyle.getHeight();\r\n    if (computedHeight < probeSize) {\r\n        detectedSubPixelRoundingFactor = (int) Math.round(1.0 / (1.0 - computedHeight));\r\n    } else {\r\n        probeSize = 1;\r\n        while (computedStyle.getHeight() != 0.0) {\r\n            computedHeight = computedStyle.getHeight();\r\n            probeSize /= 2.0;\r\n            div.getStyle().setHeight(probeSize, Unit.PX);\r\n        }\r\n        detectedSubPixelRoundingFactor = (int) Math.round(1.0 / computedHeight);\r\n    }\r\n    div.removeFromParent();\r\n    return detectedSubPixelRoundingFactor;\r\n}"
}, {
	"Path": "com.vaadin.client.ComponentDetail.getTooltipInfo",
	"Comment": "returns a tooltipinfo associated with component. if element is given,returns an additional tooltipinfo.",
	"Method": "TooltipInfo getTooltipInfo(Object key){\r\n    if (key == null) {\r\n        return tooltipInfo;\r\n    } else {\r\n        if (additionalTooltips != null) {\r\n            return additionalTooltips.get(key);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.isEditorActive",
	"Comment": "returns whether an item is currently being edited in the editor.",
	"Method": "boolean isEditorActive(){\r\n    return editorActive;\r\n}"
}, {
	"Path": "com.folioreader.view.DirectionalViewpager.addFocusables",
	"Comment": "we only want the current page that is being shown to be focusable.",
	"Method": "void addFocusables(ArrayList<View> views,int direction,int focusableMode){\r\n    final int focusableCount = views.size();\r\n    final int descendantFocusability = getDescendantFocusability();\r\n    if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {\r\n        for (int i = 0; i < getChildCount(); i++) {\r\n            final View child = getChildAt(i);\r\n            if (child.getVisibility() == VISIBLE) {\r\n                ItemInfo ii = infoForChild(child);\r\n                if (ii != null && ii.position == mCurItem) {\r\n                    child.addFocusables(views, direction, focusableMode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (descendantFocusability != FOCUS_AFTER_DESCENDANTS || (focusableCount == views.size())) {\r\n        if (!isFocusable()) {\r\n            return;\r\n        }\r\n        if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && isInTouchMode() && !isFocusableInTouchMode()) {\r\n            return;\r\n        }\r\n        if (views != null) {\r\n            views.add(this);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.communication.PushAtmosphereHandler.onMessage",
	"Comment": "called when the client sends a message through the push channel",
	"Method": "void onMessage(AtmosphereResource resource){\r\n    pushHandler.onMessage(resource);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VNotification.showError",
	"Comment": "shows an error notification and redirects the user to the given url whenshe clicks on the notification.if both message and caption are null, redirects the user to the urlimmediately",
	"Method": "void showError(ApplicationConnection connection,String caption,String message,String details,String url){\r\n    StringBuilder html = new StringBuilder();\r\n    if (caption != null) {\r\n        html.append(\"<h1 class='\");\r\n        html.append(getDependentStyle(connection, CAPTION));\r\n        html.append(\"'>\");\r\n        html.append(caption);\r\n        html.append(\"<\/h1>\");\r\n    }\r\n    if (message != null) {\r\n        html.append(\"<p class='\");\r\n        html.append(getDependentStyle(connection, DESCRIPTION));\r\n        html.append(\"'>\");\r\n        html.append(message);\r\n        html.append(\"<\/p>\");\r\n    }\r\n    if (html.length() != 0) {\r\n        if (details != null) {\r\n            html.append(\"<p class='\");\r\n            html.append(getDependentStyle(connection, DETAILS));\r\n            html.append(\"'>\");\r\n            html.append(\"<i style=\\\"font-size:0.7em\\\">\");\r\n            html.append(details);\r\n            html.append(\"<\/i><\/p>\");\r\n        }\r\n        VNotification n = VNotification.createNotification(1000 * 60 * 45, connection.getUIConnector().getWidget());\r\n        n.addEventListener(new NotificationRedirect(url));\r\n        n.show(html.toString(), VNotification.CENTERED_TOP, VNotification.STYLE_SYSTEM);\r\n    } else {\r\n        WidgetUtil.redirect(url);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.fieldgroup.FieldGroup.discard",
	"Comment": "discards all changes done to the bound fields.only has effect if buffered mode is used.",
	"Method": "void discard(){\r\n    for (Field<?> f : fieldToPropertyId.keySet()) {\r\n        try {\r\n            f.discard();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.dd.VDragAndDropManager.interruptDrag",
	"Comment": "the drag and drop operation is ended, but drop did not happen. ifoperation is currently on a drop handler, its dragleave method is calledand appropriate cleanup happens.",
	"Method": "void interruptDrag(){\r\n    endDrag(false);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Form.setInternalValue",
	"Comment": "sets the internal value.this is relevant when the form is used as field.",
	"Method": "void setInternalValue(Object newValue){\r\n    final Object oldValue = propertyValue;\r\n    super.setInternalValue(newValue);\r\n    propertyValue = newValue;\r\n    if (oldValue != newValue) {\r\n        setFormDataSource(newValue, getVisibleItemProperties());\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractListing.writeItems",
	"Comment": "writes the data source items to a design. hierarchical select componentsshould override this method to only write the root items.",
	"Method": "void writeItems(Element design,DesignContext context){\r\n    internalGetDataProvider().fetch(new Query()).forEach(item -> writeItem(design, item, context));\r\n}"
}, {
	"Path": "com.vaadin.server.WebBrowser.getBrowserMajorVersion",
	"Comment": "gets the major version of the browser the user is using.note that internet explorer in ie7 compatibility mode might return 8 insome cases even though it should return 7.",
	"Method": "int getBrowserMajorVersion(){\r\n    if (browserDetails == null) {\r\n        return -1;\r\n    }\r\n    return browserDetails.getBrowserMajorVersion();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.combobox.ComboBoxConnector.sendSelection",
	"Comment": "send a message to the server updating the current selection.this method is for internal use only and may be removed in futureversions.",
	"Method": "void sendSelection(String selectionKey){\r\n    selectionRpc.select(\"\".equals(selectionKey) ? null : selectionKey);\r\n    getDataReceivedHandler().clearPendingNavigation();\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.getRowStyleGenerator",
	"Comment": "gets the style generator that is used for generating styles for rows.",
	"Method": "RowStyleGenerator<T> getRowStyleGenerator(){\r\n    return rowStyleGenerator;\r\n}"
}, {
	"Path": "com.folioreader.view.DirectionalViewpager.executeKeyEvent",
	"Comment": "you can call this function yourself to have the scroll view performscrolling from a key event, just as if the event had been dispatched toit by the view hierarchy.",
	"Method": "boolean executeKeyEvent(KeyEvent event){\r\n    boolean handled = false;\r\n    if (event.getAction() == KeyEvent.ACTION_DOWN) {\r\n        switch(event.getKeyCode()) {\r\n            case KeyEvent.KEYCODE_DPAD_LEFT:\r\n                handled = arrowScroll(FOCUS_LEFT);\r\n                break;\r\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\r\n                handled = arrowScroll(FOCUS_RIGHT);\r\n                break;\r\n            case KeyEvent.KEYCODE_TAB:\r\n                if (Build.VERSION.SDK_INT >= 11) {\r\n                    if (KeyEvent.metaStateHasNoModifiers(event.getMetaState())) {\r\n                        handled = arrowScroll(FOCUS_FORWARD);\r\n                    } else if (KeyEvent.metaStateHasNoModifiers(event.getMetaState())) {\r\n                        handled = arrowScroll(FOCUS_BACKWARD);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return handled;\r\n}"
}, {
	"Path": "org.greenrobot.essentials.ObjectCache.get",
	"Comment": "get the cached entry or null if no valid cached entry is found.",
	"Method": "VALUE get(KEY key){\r\n    CacheEntry<VALUE> entry;\r\n    synchronized (this) {\r\n        entry = values.get(key);\r\n    }\r\n    VALUE value;\r\n    if (entry != null) {\r\n        if (isExpiring) {\r\n            long age = System.currentTimeMillis() - entry.timeCreated;\r\n            if (age < expirationMillis) {\r\n                value = getValue(key, entry);\r\n            } else {\r\n                countExpired++;\r\n                synchronized (this) {\r\n                    values.remove(key);\r\n                }\r\n                value = null;\r\n            }\r\n        } else {\r\n            value = getValue(key, entry);\r\n        }\r\n    } else {\r\n        value = null;\r\n    }\r\n    if (value != null) {\r\n        countHit++;\r\n    } else {\r\n        countMiss++;\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.getHeader",
	"Comment": "returns the header section of this grid. the default header contains asingle row displaying the column captions.",
	"Method": "Header getHeader(){\r\n    return header;\r\n}"
}, {
	"Path": "com.vaadin.client.communication.StateChangeEvent.isInitialStateChange",
	"Comment": "checks if the state change event is the first one for the givenconnector.",
	"Method": "boolean isInitialStateChange(){\r\n    return initialStateChange;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.HierarchicalContainer.addFilteredChild",
	"Comment": "adds the given childitemid as a filteredchildren for the parentitemid andsets it filteredparent.",
	"Method": "void addFilteredChild(Object parentItemId,Object childItemId){\r\n    LinkedList<Object> parentToChildrenList = filteredChildren.get(parentItemId);\r\n    if (parentToChildrenList == null) {\r\n        parentToChildrenList = new LinkedList<Object>();\r\n        filteredChildren.put(parentItemId, parentToChildrenList);\r\n    }\r\n    filteredParent.put(childItemId, parentItemId);\r\n    parentToChildrenList.add(childItemId);\r\n}"
}, {
	"Path": "com.vaadin.data.provider.Sort.asc",
	"Comment": "creates a new sort builder with given sorting using ascending sortdirection.",
	"Method": "SortBuilder asc(String by){\r\n    return new SortBuilder().thenAsc(by);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.isEditable",
	"Comment": "is table editable.if table is editable a editor of type field is created for each tablecell. the assigned fieldfactory is used to create the instances.to provide custom editors for table cells create a class implementing thefieldfactory interface, and assign it to table, and set the editableproperty to true.",
	"Method": "boolean isEditable(){\r\n    return editable;\r\n}"
}, {
	"Path": "com.vaadin.server.SystemError.getHtmlMessage",
	"Comment": "returns the message of the error in html.note that this api may change in future versions.",
	"Method": "String getHtmlMessage(){\r\n    StringBuilder sb = new StringBuilder();\r\n    if (getMessage() != null) {\r\n        sb.append(\"<h2>\");\r\n        sb.append(VaadinServlet.safeEscapeForHtml(getMessage()));\r\n        sb.append(\"<\/h2>\");\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.vaadin.server.Responsive.makeResponsive",
	"Comment": "enable responsive width and height range styling for the target componentor ui instance.",
	"Method": "void makeResponsive(Component components){\r\n    for (Component c : components) {\r\n        if (c instanceof AbstractClientConnector) {\r\n            new Responsive().extend((AbstractClientConnector) c);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.shared.Range.combineWith",
	"Comment": "combines two ranges to create a range containing all values in bothranges, provided there are no gaps between the ranges.",
	"Method": "Range combineWith(Range other){\r\n    if (getStart() > other.getEnd() || other.getStart() > getEnd()) {\r\n        throw new IllegalArgumentException(\"There is a gap between \" + this + \" and \" + other);\r\n    }\r\n    return Range.between(Math.min(getStart(), other.getStart()), Math.max(getEnd(), other.getEnd()));\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.query.TableQuery.getTableName",
	"Comment": "returns the table name for the query without catalog and schemainformation.",
	"Method": "String getTableName(){\r\n    return tableName;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.validator.AbstractValidator.isValidType",
	"Comment": "checks the type of the value to validate to ensure it conforms withgettype. enables sub classes to handle the specific type instead ofobject.",
	"Method": "boolean isValidType(Object value){\r\n    if (value == null) {\r\n        return true;\r\n    }\r\n    return getType().isAssignableFrom(value.getClass());\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.selection.SpaceSelectHandler.setDeselectAllowed",
	"Comment": "sets whether pressing space for the currently selected row shoulddeselect the row.",
	"Method": "void setDeselectAllowed(boolean deselectAllowed){\r\n    this.deselectAllowed = deselectAllowed;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.fieldgroup.FieldGroup.getBoundPropertyIds",
	"Comment": "returns a collection of all property ids that have been bound to fields.note that this will return property ids even before the item has beenset. in that case it returns the property ids that will be bound once theitem is set.no guarantee is given for the order of the property ids",
	"Method": "Collection<Object> getBoundPropertyIds(){\r\n    return Collections.unmodifiableCollection(propertyIdToField.keySet());\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addHeaderDoubleClickHandler",
	"Comment": "register a headerdoubleclickhandler to this grid. the event for thishandler is fired when a double click event occurs in the header of thisgrid.",
	"Method": "HandlerRegistration addHeaderDoubleClickHandler(HeaderDoubleClickHandler handler){\r\n    return addHandler(handler, GridDoubleClickEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheetBase.isTabCaptionsAsHtml",
	"Comment": "checks whether captions are rendered as htmlthe default is false, i.e. render tab captions as plain text",
	"Method": "boolean isTabCaptionsAsHtml(){\r\n    return tabCaptionsAsHtml;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.FilesystemContainer.addRoot",
	"Comment": "adds new root file directory. adds a file to be included as root filedirectory in the filesystemcontainer.",
	"Method": "void addRoot(File root){\r\n    if (root != null) {\r\n        final File[] newRoots = new File[roots.length + 1];\r\n        for (int i = 0; i < roots.length; i++) {\r\n            newRoots[i] = roots[i];\r\n        }\r\n        newRoots[roots.length] = root;\r\n        roots = newRoots;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.setColumns",
	"Comment": "sets the columns and their order for the grid. current columns whoseproperty id is not in propertyids are removed. similarly, a column isadded for any property id in propertyids that has no corresponding columnin this grid.",
	"Method": "void setColumns(Object propertyIds){\r\n    if (SharedUtil.containsDuplicates(propertyIds)) {\r\n        throw new IllegalArgumentException(\"The propertyIds array contains duplicates: \" + SharedUtil.getDuplicates(propertyIds));\r\n    }\r\n    Set<?> removePids = new HashSet<Object>(columns.keySet());\r\n    removePids.removeAll(Arrays.asList(propertyIds));\r\n    for (Object removePid : removePids) {\r\n        removeColumn(removePid);\r\n    }\r\n    Set<?> addPids = new HashSet<Object>(Arrays.asList(propertyIds));\r\n    addPids.removeAll(columns.keySet());\r\n    for (Object propertyId : addPids) {\r\n        addColumn(propertyId);\r\n    }\r\n    setColumnOrder(propertyIds);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.fieldgroup.FieldGroup.getFieldsInDeclareOrder",
	"Comment": "returns an array containing field objects reflecting all the fields ofthe class or interface represented by this class object. the elements inthe array returned are sorted in declare order from sub class to superclass.",
	"Method": "List<java.lang.reflect.Field> getFieldsInDeclareOrder(Class searchClass){\r\n    List<java.lang.reflect.Field> memberFieldInOrder = new ArrayList<java.lang.reflect.Field>();\r\n    while (searchClass != null) {\r\n        for (java.lang.reflect.Field memberField : searchClass.getDeclaredFields()) {\r\n            memberFieldInOrder.add(memberField);\r\n        }\r\n        searchClass = searchClass.getSuperclass();\r\n    }\r\n    return memberFieldInOrder;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.NestedMethodProperty.getGetMethods",
	"Comment": "returns an unmodifiable list of getter methods to call in sequence to getthe property value.this api may change in future versions.",
	"Method": "List<Method> getGetMethods(){\r\n    return Collections.unmodifiableList(getMethods);\r\n}"
}, {
	"Path": "com.vaadin.ui.dnd.DragSourceExtension.getDataTransferData",
	"Comment": "returns the map of data stored in this drag source element. the returnedmap preserves the order of storage and is unmodifiable.",
	"Method": "String getDataTransferData(String type,Map<String, String> getDataTransferData){\r\n    Map<String, String> data = getState(false).data;\r\n    LinkedHashMap<String, String> orderedData = new LinkedHashMap(data.size());\r\n    getState(false).types.forEach(type -> orderedData.put(type, data.get(type)));\r\n    return Collections.unmodifiableMap(orderedData);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.setTabStopTopAssistiveText",
	"Comment": "sets the message that is provided to users of assistive devices when theuser reaches the top of the window when leaving a window with the tab keyis prevented.this message is not visible on the screen.",
	"Method": "void setTabStopTopAssistiveText(String topMessage){\r\n    Roles.getNoteRole().setAriaLabelProperty(topTabStop, topMessage);\r\n}"
}, {
	"Path": "bt.net.InetPeer.equals",
	"Comment": "compares peers by address, regardless of the particular classes.",
	"Method": "boolean equals(Object object){\r\n    if (object == this) {\r\n        return true;\r\n    }\r\n    if (object == null || !Peer.class.isAssignableFrom(object.getClass())) {\r\n        return false;\r\n    }\r\n    Peer that = (Peer) object;\r\n    return addressSupplier.get().equals(that.getInetSocketAddress());\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractLegacyComponent.isImmediate",
	"Comment": "returns the immediate mode of the component.since vaadin 8, the default mode is immediate.",
	"Method": "boolean isImmediate(){\r\n    if (explicitImmediateValue != null) {\r\n        return explicitImmediateValue;\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.tests.server.component.csslayout.AddComponentsTest.assertOrder",
	"Comment": "asserts that layout has the components in children in the order specifiedby indices.",
	"Method": "void assertOrder(Layout layout,int[] indices){\r\n    Iterator<?> i = layout.getComponentIterator();\r\n    try {\r\n        for (int index : indices) {\r\n            assertSame(children[index], i.next());\r\n        }\r\n        assertFalse(\"Too many components in layout\", i.hasNext());\r\n    } catch (NoSuchElementException e) {\r\n        fail(\"Too few components in layout\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.createConnectorId",
	"Comment": "generate an id for the given connector. connectors must not call thismethod more than once, the first time they need an id.",
	"Method": "String createConnectorId(ClientConnector connector){\r\n    return service.generateConnectorId(this, connector);\r\n}"
}, {
	"Path": "com.vaadin.client.widget.escalator.ScrollbarBundle.getScrollPos",
	"Comment": "gets the scroll position of the scrollbar in the axis the scrollbar isrepresenting.",
	"Method": "double getScrollPos(){\r\n    assert internalGetScrollPos() == toInt32(scrollPos) : \"calculated scroll position (\" + scrollPos + \") did not match the DOM element scroll position (\" + internalGetScrollPos() + \")\";\r\n    return scrollPos;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.table.TableConnector.showSavedContextMenu",
	"Comment": "shows a saved row context menu if the row for the context menu is stillvisible. does nothing if a context menu has not been saved.",
	"Method": "void showSavedContextMenu(ContextMenuDetails savedContextMenu){\r\n    if (isEnabled() && savedContextMenu != null) {\r\n        for (Widget w : getWidget().scrollBody) {\r\n            VScrollTableRow row = (VScrollTableRow) w;\r\n            if (row.getKey().equals(savedContextMenu.rowKey)) {\r\n                row.showContextMenu(savedContextMenu.left, savedContextMenu.top);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "bt.module.ServiceModuleExtender.addMessagingAgentType",
	"Comment": "to avoid accidental contribution of agent type as an actual agent instance",
	"Method": "ServiceModuleExtender addMessagingAgentType(Class<?> agentType){\r\n    Objects.requireNonNull(agentType);\r\n    contributeMessagingAgents().addBinding().to(agentType).in(Singleton.class);\r\n    return this;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addBodyKeyPressHandler",
	"Comment": "register a bodykeypresshandler to this grid. the event for this handleris fired when a keypress event occurs while cell focus is in the body ofthis grid.",
	"Method": "HandlerRegistration addBodyKeyPressHandler(BodyKeyPressHandler handler){\r\n    return addHandler(handler, GridKeyPressEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.dd.VDragAndDropManager.defer",
	"Comment": "method to que tasks until all dd related server visits are done",
	"Method": "void defer(Command command){\r\n    deferredCommand = command;\r\n}"
}, {
	"Path": "lbms.plugins.mldht.kad.Key.findApproxKeyDistance",
	"Comment": "returns the approximate distance of this key to the other key.\tdistance is simplified by returning the index of the first different bit.",
	"Method": "int findApproxKeyDistance(Key id){\r\n    Key d = Key.distance(id, this);\r\n    return d.leadingOneBit();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.setTabStopBottomAssistiveText",
	"Comment": "sets the message that is provided to users of assistive devices when theuser reaches the bottom of the window when leaving a window with the tabkey is prevented.this message is not visible on the screen.",
	"Method": "void setTabStopBottomAssistiveText(String bottomMessage){\r\n    Roles.getNoteRole().setAriaLabelProperty(bottomTabStop, bottomMessage);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.getTimeFormat",
	"Comment": "gets currently active time format. value is either timeformat.format12hor timeformat.format24h.",
	"Method": "TimeFormat getTimeFormat(){\r\n    if (currentTimeFormat == null) {\r\n        SimpleDateFormat f;\r\n        if (getLocale() == null) {\r\n            f = (SimpleDateFormat) SimpleDateFormat.getTimeInstance(SimpleDateFormat.SHORT);\r\n        } else {\r\n            f = (SimpleDateFormat) SimpleDateFormat.getTimeInstance(SimpleDateFormat.SHORT, getLocale());\r\n        }\r\n        String p = f.toPattern();\r\n        if (p.indexOf(\"HH\") != -1 || p.indexOf(\"H\") != -1) {\r\n            return TimeFormat.Format24H;\r\n        }\r\n        return TimeFormat.Format12H;\r\n    }\r\n    return currentTimeFormat;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.getClient",
	"Comment": "returns the applicationconnection used to connect to the server side.",
	"Method": "ApplicationConnection getClient(){\r\n    return getConnection();\r\n}"
}, {
	"Path": "com.vaadin.ui.MenuBar.isAutoOpen",
	"Comment": "detects whether the menubar is in a mode where top level menus areautomatically opened when the mouse cursor is moved over the menu.normally root menu opens only by clicking on the menu. submenus alwaysopen automatically.",
	"Method": "boolean isAutoOpen(){\r\n    return openRootOnHover;\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.getNavigator",
	"Comment": "returns the navigator attached to this ui or null if there is nonavigator.",
	"Method": "Navigator getNavigator(){\r\n    return navigator;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.setSessionLock",
	"Comment": "associates the given lock with this service and the given wrappedsession. this method should not be called more than once when the lock isinitialized for the session.",
	"Method": "void setSessionLock(WrappedSession wrappedSession,Lock lock){\r\n    if (wrappedSession == null) {\r\n        throw new IllegalArgumentException(\"Can't set a lock for a null session\");\r\n    }\r\n    Object currentSessionLock = wrappedSession.getAttribute(getLockAttributeName());\r\n    assert (currentSessionLock == null || currentSessionLock == lock) : \"Changing the lock for a session is not allowed\";\r\n    wrappedSession.setAttribute(getLockAttributeName(), lock);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Form.setImmediate",
	"Comment": "setting the form to be immediate also sets all the fields of the form tothe same state.",
	"Method": "void setImmediate(boolean immediate){\r\n    super.setImmediate(immediate);\r\n    for (Field<?> f : fields.values()) {\r\n        if (f instanceof AbstractLegacyComponent) {\r\n            ((AbstractLegacyComponent) f).setImmediate(immediate);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbsoluteLayout.iterator",
	"Comment": "gets an iterator for going through all components enclosed in theabsolute layout.",
	"Method": "Iterator<Component> iterator(){\r\n    return Collections.unmodifiableCollection(componentToCoordinates.keySet()).iterator();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.TouchScrollDelegate.moveTransformationToScrolloffset",
	"Comment": "called at the end of scrolling. moves possible translate values toscrolltop, causing onscroll event.",
	"Method": "void moveTransformationToScrolloffset(){\r\n    if (ANDROID_WITH_BROKEN_SCROLL_TOP) {\r\n        scrolledElement.setPropertyInt(\"_vScrollTop\", finalScrollTop);\r\n        if (scrollHandler != null) {\r\n            scrollHandler.onScroll(null);\r\n        }\r\n    } else {\r\n        for (Element el : layers) {\r\n            Style style = el.getStyle();\r\n            style.setProperty(\"webkitTransform\", \"translate3d(0,0,0)\");\r\n        }\r\n        scrolledElement.setScrollTop(finalScrollTop);\r\n    }\r\n    activeScrollDelegate = null;\r\n    handlerRegistration.removeHandler();\r\n    handlerRegistration = null;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.FilesystemContainer.size",
	"Comment": "gets the number of items in the container. in effect, this is thecombined amount of files and directories.",
	"Method": "int size(){\r\n    if (recursive) {\r\n        int counts = 0;\r\n        for (File f : roots) {\r\n            counts += getFileCounts(f);\r\n        }\r\n        return counts;\r\n    } else {\r\n        File[] f;\r\n        if (roots.length == 1) {\r\n            if (filter != null) {\r\n                f = roots[0].listFiles(filter);\r\n            } else {\r\n                f = roots[0].listFiles();\r\n            }\r\n        } else {\r\n            f = roots;\r\n        }\r\n        if (f == null) {\r\n            return 0;\r\n        }\r\n        return f.length;\r\n    }\r\n}"
}, {
	"Path": "bt.torrent.messaging.Mapper.buildKey",
	"Comment": "create a unique key for a block request, cancel request or received piece.",
	"Method": "Object buildKey(int pieceIndex,int offset,int length){\r\n    return new Key(pieceIndex, offset, length);\r\n}"
}, {
	"Path": "net.openhft.chronicle.queue.TailerDirectionTest.readNextEntry",
	"Comment": "read next message, forward or backward, depending on the settings of the tailer",
	"Method": "String readNextEntry(ExcerptTailer tailer){\r\n    DocumentContext dc = tailer.readingDocument();\r\n    try {\r\n        if (dc.isPresent()) {\r\n            Object parent = dc.wire().parent();\r\n            assert parent == tailer;\r\n            return dc.wire().read().text();\r\n        }\r\n        return null;\r\n    } finally {\r\n        dc.close();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.AutoScroller.setScrollArea",
	"Comment": "set the auto scroll area height or width depending on the scrolling axis.this is the amount of pixels from the edge of the grid that the scroll istriggered.defaults to 100px.",
	"Method": "void setScrollArea(int px){\r\n    scrollAreaPX = px;\r\n}"
}, {
	"Path": "com.vaadin.client.event.PointerEvent.getPointerId",
	"Comment": "gets a unique identifier for the pointer that caused this event. theidentifiers of previously active but retired pointers may be recycled.",
	"Method": "int getPointerId(int getPointerId,NativeEvent e){\r\n    return getPointerId(getNativeEvent());\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.FilesystemContainer.setChildrenAllowed",
	"Comment": "returns false when conversion from files to directories isnot supported.",
	"Method": "boolean setChildrenAllowed(Object itemId,boolean areChildrenAllowed){\r\n    throw new UnsupportedOperationException(\"Conversion file to/from directory is not supported\");\r\n}"
}, {
	"Path": "com.vaadin.client.Util.shouldSkipMeasurementOfConnector",
	"Comment": "test if we can can skip measuring this connector. we can skip themeasurement if its parent is a childmeasurehintconnector and has anappropriate mode set.this version of the method tries to recursively locate such a parent.for internal use only. may be removed or replaced in the future.",
	"Method": "boolean shouldSkipMeasurementOfConnector(ComponentConnector candidate,ComponentConnector parent,boolean shouldSkipMeasurementOfConnector,ComponentConnector candidate){\r\n    Profiler.enter(\"skipMeasureDueLayoutHint\");\r\n    boolean skip = false;\r\n    HasChildMeasurementHintConnector parent = getPossibleChildMeasurementHintParentConnector(candidate);\r\n    if (parent != null) {\r\n        ChildMeasurementHint measureMode = parent.getChildMeasurementHint();\r\n        if (measureMode == ChildMeasurementHint.MEASURE_NEVER) {\r\n            skip = true;\r\n        } else if (measureMode == ChildMeasurementHint.MEASURE_IF_NEEDED) {\r\n            skip = canWeSkipChildMeasurement(candidate);\r\n        }\r\n    }\r\n    Profiler.leave(\"skipMeasureDueLayoutHint\");\r\n    return skip;\r\n}"
}, {
	"Path": "com.vaadin.client.ApplicationConfiguration.isWidgetsetVersionSent",
	"Comment": "checks whether the widget set version has been sent to the server. it issent in the first uidl request.",
	"Method": "boolean isWidgetsetVersionSent(){\r\n    return widgetsetVersionSent;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.converter.ConverterUtil.canConverterHandle",
	"Comment": "checks if the given converter can handle conversion between the givenpresentation and model type. does strict type checking and only returnstrue if the converter claims it can handle exactly the given types.",
	"Method": "boolean canConverterHandle(Converter<?, ?> converter,Class<?> presentationType,Class<?> modelType){\r\n    if (converter == null) {\r\n        return false;\r\n    }\r\n    if (modelType != converter.getModelType()) {\r\n        return false;\r\n    }\r\n    if (presentationType != converter.getPresentationType()) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTwinColSelect.getNavigationSelectKey",
	"Comment": "get the key that selects an item in the table. by default it is the enterkey but by overriding this you can change the key to whatever you want.",
	"Method": "int getNavigationSelectKey(){\r\n    return KeyCodes.KEY_ENTER;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.addAndRemoveRows",
	"Comment": "inserts rows in the table body or removes them from the table body basedon the commands in the uidl.for internal use only. may be removed or replaced in the future.",
	"Method": "void addAndRemoveRows(UIDL partialRowAdditions){\r\n    if (partialRowAdditions == null) {\r\n        return;\r\n    }\r\n    if (partialRowAdditions.hasAttribute(\"hide\")) {\r\n        scrollBody.unlinkAndReindexRows(partialRowAdditions.getIntAttribute(\"firstprowix\"), partialRowAdditions.getIntAttribute(\"numprows\"));\r\n        scrollBody.ensureCacheFilled();\r\n    } else {\r\n        if (partialRowAdditions.hasAttribute(\"delbelow\")) {\r\n            scrollBody.insertRowsDeleteBelow(partialRowAdditions, partialRowAdditions.getIntAttribute(\"firstprowix\"), partialRowAdditions.getIntAttribute(\"numprows\"));\r\n        } else {\r\n            scrollBody.insertAndReindexRows(partialRowAdditions, partialRowAdditions.getIntAttribute(\"firstprowix\"), partialRowAdditions.getIntAttribute(\"numprows\"));\r\n        }\r\n    }\r\n    discardRowsOutsideCacheWindow();\r\n}"
}, {
	"Path": "com.vaadin.ui.CustomLayout.iterator",
	"Comment": "gets the component container iterator for going trough all the componentsin the container.",
	"Method": "Iterator<Component> iterator(){\r\n    return Collections.unmodifiableCollection(slots.values()).iterator();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.query.generator.DefaultSQLGenerator.getStatementHelper",
	"Comment": "returns the statement helper for the generator. override this to handleplatform specific data types.",
	"Method": "StatementHelper getStatementHelper(){\r\n    if (statementHelperClass == null) {\r\n        return new StatementHelper();\r\n    }\r\n    try {\r\n        return statementHelperClass.newInstance();\r\n    } catch (InstantiationException e) {\r\n        throw new RuntimeException(\"Unable to instantiate custom StatementHelper\", e);\r\n    } catch (IllegalAccessException e) {\r\n        throw new RuntimeException(\"Unable to instantiate custom StatementHelper\", e);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.ProgressBar.setValue",
	"Comment": "sets the value of this progress bar. the value is a floatbetween 0 and 1 where 0 represents no progress at all and 1 representsfully completed.",
	"Method": "void setValue(Float newValue){\r\n    super.setValue(newValue);\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.sort.SortOrder.getOpposite",
	"Comment": "returns a new sortorder object with the sort direction reversed.",
	"Method": "SortOrder getOpposite(){\r\n    return new SortOrder(column, direction.getOpposite());\r\n}"
}, {
	"Path": "com.vaadin.server.LegacyApplication.setMainWindow",
	"Comment": "sets the main window of this application. setting window as a main windowof this application also adds the window to this application.",
	"Method": "void setMainWindow(LegacyWindow mainWindow){\r\n    if (this.mainWindow != null) {\r\n        throw new IllegalStateException(\"mainWindow has already been set\");\r\n    }\r\n    if (mainWindow.isAttached()) {\r\n        throw new IllegalStateException(\"mainWindow is attached to another application\");\r\n    }\r\n    if (UI.getCurrent() == null) {\r\n        UI.setCurrent(mainWindow);\r\n    }\r\n    addWindow(mainWindow);\r\n    this.mainWindow = mainWindow;\r\n}"
}, {
	"Path": "com.vaadin.client.connectors.grid.MultiSelectionModelConnector.createSelectionModel",
	"Comment": "creates an instance of multiselectionmodel. method provided overridingfeatures of the selection model without copying all logic.",
	"Method": "MultiSelectionModel createSelectionModel(){\r\n    return new MultiSelectionModel();\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.getStreamVariable",
	"Comment": "checks if the indicated connector has a streamvariable of the given nameand returns the variable if one is found.",
	"Method": "StreamVariable getStreamVariable(String connectorId,String variableName){\r\n    if (pidToNameToStreamVariable == null) {\r\n        return null;\r\n    }\r\n    Map<String, StreamVariable> map = pidToNameToStreamVariable.get(connectorId);\r\n    if (map == null) {\r\n        return null;\r\n    }\r\n    StreamVariable streamVariable = map.get(variableName);\r\n    return streamVariable;\r\n}"
}, {
	"Path": "lbms.plugins.mldht.kad.DHT.bootstrap",
	"Comment": "initiates a bootstrap.\tthis function bootstraps with router.bittorrent.com if there are less\tthan 10 peers in the routing table. if there are more then a lookup on\tour own id is initiated. if the either task is finished than it will try\tto fill the buckets.",
	"Method": "void bootstrap(){\r\n    if (!isRunning() || System.currentTimeMillis() - lastBootstrap < DHTConstants.BOOTSTRAP_MIN_INTERVAL) {\r\n        return;\r\n    }\r\n    if (!bootstrapping.compareAndSet(BootstrapState.NONE, BootstrapState.FILL))\r\n        return;\r\n    if (useRouterBootstrapping && node.getNumEntriesInRoutingTable() < DHTConstants.USE_BT_ROUTER_IF_LESS_THAN_X_PEERS) {\r\n        routerBootstrap();\r\n    } else {\r\n        fillHomeBuckets(Collections.emptyList());\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.dd.DragHandle.getParent",
	"Comment": "returns the current parent element for this drag handle. may be null.",
	"Method": "Element getParent(){\r\n    return parent;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.getForwardKey",
	"Comment": "the key that selects the next day in the calendar. by default this is theright arrow key but by overriding this method it can be changed towhatever you like.",
	"Method": "int getForwardKey(){\r\n    return KeyCodes.KEY_RIGHT;\r\n}"
}, {
	"Path": "com.vaadin.server.WebBrowser.getScreenWidth",
	"Comment": "gets the width of the screen in pixels. this is the full screenresolution and not the width available for the application.",
	"Method": "int getScreenWidth(){\r\n    return screenWidth;\r\n}"
}, {
	"Path": "com.folioreader.view.VerticalViewPager.onRequestFocusInDescendants",
	"Comment": "we only want the current page that is being shown to be focusable.",
	"Method": "boolean onRequestFocusInDescendants(int direction,Rect previouslyFocusedRect){\r\n    int index;\r\n    int increment;\r\n    int end;\r\n    int count = getChildCount();\r\n    if ((direction & FOCUS_FORWARD) != 0) {\r\n        index = 0;\r\n        increment = 1;\r\n        end = count;\r\n    } else {\r\n        index = count - 1;\r\n        increment = -1;\r\n        end = -1;\r\n    }\r\n    for (int i = index; i != end; i += increment) {\r\n        View child = getChildAt(i);\r\n        if (child.getVisibility() == VISIBLE) {\r\n            ItemInfo ii = infoForChild(child);\r\n            if (ii != null && ii.position == mCurItem && child.requestFocus(direction, previouslyFocusedRect)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.ui.CssLayout.addComponentAsFirst",
	"Comment": "adds a component into this container. the component is added to the leftor on top of the other components.",
	"Method": "void addComponentAsFirst(Component c){\r\n    if (equals(c.getParent())) {\r\n        removeComponent(c);\r\n    }\r\n    components.addFirst(c);\r\n    try {\r\n        super.addComponent(c);\r\n    } catch (IllegalArgumentException e) {\r\n        components.remove(c);\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.getEditorFieldGroup",
	"Comment": "gets the field group that is backing the item editor of this grid.",
	"Method": "FieldGroup getEditorFieldGroup(){\r\n    return editorFieldGroup;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinResponse.setNoCacheHeaders",
	"Comment": "sets all conceivable headers that might prevent a response from beingstored in any caches.",
	"Method": "void setNoCacheHeaders(){\r\n    setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");\r\n    setHeader(\"Pragma\", \"no-cache\");\r\n    setHeader(\"Expires\", \"0\");\r\n}"
}, {
	"Path": "net.openhft.chronicle.queue.TailerDirectionTest.appendEntry",
	"Comment": "add a test message with the given excerptappender and return the index position of the entry",
	"Method": "long appendEntry(ExcerptAppender appender,String msg){\r\n    DocumentContext dc = appender.writingDocument();\r\n    try {\r\n        dc.wire().write().text(msg);\r\n        return dc.index();\r\n    } finally {\r\n        dc.close();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addBodyClickHandler",
	"Comment": "register a bodyclickhandler to this grid. the event for this handler isfired when a click event occurs in the body of this grid.",
	"Method": "HandlerRegistration addBodyClickHandler(BodyClickHandler handler){\r\n    return addHandler(handler, GridClickEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.getAssistivePrefix",
	"Comment": "getter for the text for assistive devices the window caption is prefixedwith.",
	"Method": "String getAssistivePrefix(){\r\n    return assistivePrefix;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.MethodProperty.fireValueChange",
	"Comment": "sends a value change event to all registered listeners.public for backwards compatibility, visibility may be reduced in futureversions.",
	"Method": "void fireValueChange(){\r\n    super.fireValueChange();\r\n}"
}, {
	"Path": "com.vaadin.data.provider.GridSortOrder.asc",
	"Comment": "creates a new grid sort builder with given sorting using ascending sortdirection.",
	"Method": "GridSortOrderBuilder<T> asc(Column<T, ?> by){\r\n    return new GridSortOrderBuilder<T>().thenAsc(by);\r\n}"
}, {
	"Path": "com.vaadin.client.data.DataSource.addDataChangeHandler",
	"Comment": "sets a simple data change handler for a widget without lazy loading.refresh method should reset all the data in the widget.",
	"Method": "Registration addDataChangeHandler(DataChangeHandler dataChangeHandler,Registration addDataChangeHandler,Consumer<Range> refreshMethod){\r\n    return addDataChangeHandler(new SimpleDataChangeHandler(this, refreshMethod));\r\n}"
}, {
	"Path": "com.vaadin.client.BrowserInfo.isAndroidWithBrokenScrollTop",
	"Comment": "tests if this is an android devices with a broken scrolltopimplementation.",
	"Method": "boolean isAndroidWithBrokenScrollTop(){\r\n    return isAndroid() && (getOperatingSystemMajorVersion() == 3 || getOperatingSystemMajorVersion() == 4);\r\n}"
}, {
	"Path": "com.vaadin.client.Util.isTouchEventOrLeftMouseButton",
	"Comment": "checks if the given event is either a touch event or caused by the leftmouse button.",
	"Method": "boolean isTouchEventOrLeftMouseButton(Event event){\r\n    return WidgetUtil.isTouchEventOrLeftMouseButton(event);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.updateFooter",
	"Comment": "updates footers.update headers whould be called before this method is called!",
	"Method": "void updateFooter(String[] strings){\r\n    if (strings == null) {\r\n        return;\r\n    }\r\n    int colIndex = 0;\r\n    if (showRowHeaders) {\r\n        tFoot.enableColumn(ROW_HEADER_COLUMN_KEY, colIndex);\r\n        colIndex++;\r\n    } else {\r\n        tFoot.removeCell(ROW_HEADER_COLUMN_KEY);\r\n    }\r\n    for (final String cid : strings) {\r\n        tFoot.enableColumn(cid, colIndex);\r\n        colIndex++;\r\n    }\r\n    tFoot.setVisible(showColFooters);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.validator.NullValidator.getErrorMessage",
	"Comment": "gets the error message that is displayed in case the value is invalid.",
	"Method": "String getErrorMessage(){\r\n    return errorMessage;\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.getSeckey",
	"Comment": "returns the security key associated with the given streamvariable.",
	"Method": "String getSeckey(StreamVariable variable){\r\n    if (streamVariableToSeckey == null) {\r\n        return null;\r\n    }\r\n    return streamVariableToSeckey.get(variable);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.ContainerHierarchicalWrapper.addItem",
	"Comment": "adds a new item by its id to the underlying container and to thehierarchy.",
	"Method": "Object addItem(Item addItem,Object itemId){\r\n    if (itemId == null) {\r\n        return null;\r\n    }\r\n    final Item item = container.addItem(itemId);\r\n    if (!hierarchical && item != null) {\r\n        addToHierarchyWrapper(itemId);\r\n    }\r\n    return item;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.isShowISOWeekNumbers",
	"Comment": "returns whether iso 8601 week numbers should be shown in the valueselector or not. iso 8601 defines that a week always starts with a mondayso the week numbers are only shown if this is the case.",
	"Method": "boolean isShowISOWeekNumbers(){\r\n    return showISOWeekNumbers;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.addSessionDestroyListener",
	"Comment": "adds a listener that gets notified when a vaadin service session that hasbeen initialized for this service is destroyed.the session being destroyed is locked and its uis have been removed whenthe listeners are called.",
	"Method": "Registration addSessionDestroyListener(SessionDestroyListener listener){\r\n    sessionDestroyListeners.add(listener);\r\n    return () -> sessionDestroyListeners.remove(listener);\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.AutoScroller.getScrollArea",
	"Comment": "returns the size of the auto scroll area in pixels.defaults to 100px.",
	"Method": "int getScrollArea(){\r\n    return scrollAreaPX;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractBeanContainer.addBean",
	"Comment": "adds a bean to the container using the bean item id resolver to find itsidentifier.a bean id resolver must be set before calling this method.",
	"Method": "BeanItem<BEANTYPE> addBean(BEANTYPE bean){\r\n    if (bean == null) {\r\n        return null;\r\n    }\r\n    IDTYPE itemId = resolveBeanId(bean);\r\n    if (itemId == null) {\r\n        throw new IllegalArgumentException(\"Resolved identifier for a bean must not be null\");\r\n    }\r\n    return addItem(itemId, bean);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.expandEndDate",
	"Comment": "finds the last day of the week and returns a day representing the end ofthat day.",
	"Method": "Date expandEndDate(Date end,boolean expandToFullWeek){\r\n    if (expandToFullWeek) {\r\n        end = getLastDateForWeek(end);\r\n    } else {\r\n        end = (Date) end.clone();\r\n    }\r\n    end = getEndOfDay(currentCalendar, end);\r\n    return end;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.InMemoryDataProviderHelpers.filteringByIgnoreNull",
	"Comment": "wraps a given data provider so that its filter ignores null itemsreturned by the given value provider.",
	"Method": "DataProvider<T, Q> filteringByIgnoreNull(InMemoryDataProvider<T> dataProvider,ValueProvider<T, V> valueProvider,SerializableBiPredicate<V, Q> predicate){\r\n    Objects.requireNonNull(predicate, \"Predicate cannot be null\");\r\n    return dataProvider.filteringBy(valueProvider, (itemValue, queryFilter) -> itemValue != null && predicate.test(itemValue, queryFilter));\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.getCurrentResponse",
	"Comment": "gets the currently processed vaadin response. the current response isautomatically defined when the request is started. the current responsecan not be used in e.g. background threads because of the way serverimplementations reuse response instances.",
	"Method": "VaadinResponse getCurrentResponse(){\r\n    return VaadinResponse.getCurrent();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.addSortListener",
	"Comment": "adds a sort order change listener that gets notified when the sort orderchanges.",
	"Method": "Registration addSortListener(SortListener listener){\r\n    addListener(SortEvent.class, listener, SORT_ORDER_CHANGE_METHOD);\r\n    return () -> removeListener(SortEvent.class, listener, SORT_ORDER_CHANGE_METHOD);\r\n}"
}, {
	"Path": "com.vaadin.ui.ProgressBar.isIndeterminate",
	"Comment": "gets whether or not this progress indicator is indeterminate. inindeterminate mode there is an animation indicating that the task isrunning but without providing any information about the current progress.",
	"Method": "boolean isIndeterminate(){\r\n    return getState(false).indeterminate;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTextArea.getScrollLeft",
	"Comment": "get horizontal scroll value required to get position visible. method iscalled only when text wrapping is off. there is need to scrollhorizontally in case words are wrapped.",
	"Method": "int getScrollLeft(String value,int index){\r\n    String beginning = value.substring(0, index);\r\n    int begin = beginning.lastIndexOf('\\n');\r\n    String line = value.substring(begin + 1);\r\n    index = index - begin - 1;\r\n    if (index < line.length()) {\r\n        index++;\r\n    }\r\n    line = line.substring(0, index);\r\n    setValue(line.trim(), false);\r\n    getElement().setScrollLeft(getElement().getScrollWidth());\r\n    return getElement().getScrollLeft();\r\n}"
}, {
	"Path": "com.vaadin.data.provider.InMemoryDataProvider.addSortComparator",
	"Comment": "adds a comparator to the default sorting for this data provider. if nodefault sorting has been defined, then the provided comparator will beused as the default sorting. if a default sorting has been defined, thenthe provided comparator will be used to determine the ordering of itemsthat are considered equal by the previously defined default sorting.the default sorting is used if the query defines no sorting. the defaultsorting is also used to determine the ordering of items that areconsidered equal by the sorting defined in the query.",
	"Method": "void addSortComparator(SerializableComparator<T> comparator){\r\n    Objects.requireNonNull(comparator, \"Comparator to add cannot be null\");\r\n    SerializableComparator<T> originalComparator = getSortComparator();\r\n    if (originalComparator == null) {\r\n        setSortComparator(comparator);\r\n    } else {\r\n        setSortComparator((a, b) -> {\r\n            int result = originalComparator.compare(a, b);\r\n            if (result == 0) {\r\n                result = comparator.compare(a, b);\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractPopupCalendar.getDescriptionForAssistiveDevices",
	"Comment": "get the description that explains the usage of the widget for users ofassistive devices.",
	"Method": "String getDescriptionForAssistiveDevices(){\r\n    return descriptionForAssistiveDevicesElement.getInnerText();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.setColumnOrder",
	"Comment": "sets a new column order for the grid. all columns which are not orderedhere will remain in the order they were before as the last columns ofgrid.",
	"Method": "void setColumnOrder(Column<?, T> orderedColumns){\r\n    ColumnConfiguration conf = getEscalator().getColumnConfiguration();\r\n    conf.removeColumns(0, conf.getColumnCount());\r\n    List<Column<?, T>> newOrder = new ArrayList<Column<?, T>>();\r\n    if (selectionColumn != null) {\r\n        newOrder.add(selectionColumn);\r\n    }\r\n    int i = 0;\r\n    for (Column<?, T> column : orderedColumns) {\r\n        if (columns.contains(column)) {\r\n            newOrder.add(column);\r\n            ++i;\r\n        } else {\r\n            throw new IllegalArgumentException(\"Given column at index \" + i + \" does not exist in Grid\");\r\n        }\r\n    }\r\n    if (columns.size() != newOrder.size()) {\r\n        columns.removeAll(newOrder);\r\n        newOrder.addAll(columns);\r\n    }\r\n    columns = newOrder;\r\n    List<Column<?, T>> visibleColumns = getVisibleColumns();\r\n    conf.insertColumns(0, visibleColumns.size());\r\n    updateFrozenColumns();\r\n    for (Column<?, T> column : columns) {\r\n        column.reapplyWidth();\r\n    }\r\n    for (HeaderRow row : header.getRows()) {\r\n        row.calculateColspans();\r\n    }\r\n    for (FooterRow row : footer.getRows()) {\r\n        row.calculateColspans();\r\n    }\r\n    columnHider.updateTogglesOrder();\r\n    fireEvent(new ColumnReorderEvent<T>());\r\n}"
}, {
	"Path": "com.folioreader.view.DirectionalViewpager.addTouchables",
	"Comment": "we only want the current page that is being shown to be touchable.",
	"Method": "void addTouchables(ArrayList<View> views){\r\n    for (int i = 0; i < getChildCount(); i++) {\r\n        final View child = getChildAt(i);\r\n        if (child.getVisibility() == VISIBLE) {\r\n            ItemInfo ii = infoForChild(child);\r\n            if (ii != null && ii.position == mCurItem) {\r\n                child.addTouchables(views);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "bt.runtime.BtRuntime.disableAutomaticShutdown",
	"Comment": "disable automatic runtime shutdown, when all clients have been stopped.",
	"Method": "void disableAutomaticShutdown(){\r\n    this.manualShutdownOnly = true;\r\n}"
}, {
	"Path": "com.vaadin.shared.Range.isEmpty",
	"Comment": "checks whether the range has no elements between the start and end.",
	"Method": "boolean isEmpty(){\r\n    return getStart() >= getEnd();\r\n}"
}, {
	"Path": "com.github.sundeepk.compactcalendarview.CompactCalendarView.setLocale",
	"Comment": "use a custom locale for compact calendar and reinitialise the view.",
	"Method": "void setLocale(TimeZone timeZone,Locale locale){\r\n    compactCalendarController.setLocale(timeZone, locale);\r\n    invalidate();\r\n}"
}, {
	"Path": "com.vaadin.client.componentlocator.LocatorUtil.isUIElement",
	"Comment": "checks if path refers to vaadin ui element com.vaadin.ui.ui.",
	"Method": "boolean isUIElement(String path){\r\n    String regex = \"^\\\\/{0,2}(com\\\\.vaadin\\\\.ui\\\\.)?V?UI[\\\\/\\\\[]?\";\r\n    RegExp regexp = RegExp.compile(regex);\r\n    return regexp.test(path);\r\n}"
}, {
	"Path": "com.vaadin.server.Page.getWindowName",
	"Comment": "gets the window.name value of the browser window of this page.",
	"Method": "String getWindowName(){\r\n    return windowName;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.registerListeners",
	"Comment": "registers listeners on the calendar so server can be notified of theevents.",
	"Method": "void registerListeners(){\r\n    VCalendar calendar = getWidget();\r\n    calendar.setListener(new DateClickListener() {\r\n        @Override\r\n        public void dateClick(String date) {\r\n            if (!calendar.isDisabled() && hasEventListener(CalendarEventId.DATECLICK)) {\r\n                rpc.dateClick(date);\r\n            }\r\n        }\r\n    });\r\n    calendar.setListener(new ForwardListener() {\r\n        @Override\r\n        public void forward() {\r\n            if (hasEventListener(CalendarEventId.FORWARD)) {\r\n                rpc.forward();\r\n            }\r\n        }\r\n    });\r\n    calendar.setListener(new BackwardListener() {\r\n        @Override\r\n        public void backward() {\r\n            if (hasEventListener(CalendarEventId.BACKWARD)) {\r\n                rpc.backward();\r\n            }\r\n        }\r\n    });\r\n    calendar.setListener(new RangeSelectListener() {\r\n        @Override\r\n        public void rangeSelected(String value) {\r\n            if (hasEventListener(CalendarEventId.RANGESELECT)) {\r\n                rpc.rangeSelect(value);\r\n            }\r\n        }\r\n    });\r\n    calendar.setListener(new WeekClickListener() {\r\n        @Override\r\n        public void weekClick(String event) {\r\n            if (!calendar.isDisabled() && hasEventListener(CalendarEventId.WEEKCLICK)) {\r\n                rpc.weekClick(event);\r\n            }\r\n        }\r\n    });\r\n    calendar.setListener(new EventMovedListener() {\r\n        @Override\r\n        public void eventMoved(CalendarEvent event) {\r\n            if (hasEventListener(CalendarEventId.EVENTMOVE)) {\r\n                StringBuilder sb = new StringBuilder();\r\n                sb.append(DateUtil.formatClientSideDate(event.getStart()));\r\n                sb.append('-');\r\n                sb.append(DateUtil.formatClientSideTime(event.getStartTime()));\r\n                rpc.eventMove(event.getIndex(), sb.toString());\r\n            }\r\n        }\r\n    });\r\n    calendar.setListener(new EventResizeListener() {\r\n        @Override\r\n        public void eventResized(CalendarEvent event) {\r\n            if (hasEventListener(CalendarEventId.EVENTRESIZE)) {\r\n                StringBuilder buffer = new StringBuilder();\r\n                buffer.append(DateUtil.formatClientSideDate(event.getStart()));\r\n                buffer.append('-');\r\n                buffer.append(DateUtil.formatClientSideTime(event.getStartTime()));\r\n                String newStartDate = buffer.toString();\r\n                buffer = new StringBuilder();\r\n                buffer.append(DateUtil.formatClientSideDate(event.getEnd()));\r\n                buffer.append('-');\r\n                buffer.append(DateUtil.formatClientSideTime(event.getEndTime()));\r\n                String newEndDate = buffer.toString();\r\n                rpc.eventResize(event.getIndex(), newStartDate, newEndDate);\r\n            }\r\n        }\r\n    });\r\n    calendar.setListener(new VCalendar.ScrollListener() {\r\n        @Override\r\n        public void scroll(int scrollPosition) {\r\n            rpc.scroll(scrollPosition);\r\n        }\r\n    });\r\n    calendar.setListener(new EventClickListener() {\r\n        @Override\r\n        public void eventClick(CalendarEvent event) {\r\n            if (hasEventListener(CalendarEventId.EVENTCLICK)) {\r\n                rpc.eventClick(event.getIndex());\r\n            }\r\n        }\r\n    });\r\n    calendar.setListener(new MouseEventListener() {\r\n        @Override\r\n        public void contextMenu(ContextMenuEvent event, final Widget widget) {\r\n            final NativeEvent ne = event.getNativeEvent();\r\n            int left = ne.getClientX();\r\n            int top = ne.getClientY();\r\n            top += Window.getScrollTop();\r\n            left += Window.getScrollLeft();\r\n            getClient().getContextMenu().showAt(new ActionOwner() {\r\n                @Override\r\n                public String getPaintableId() {\r\n                    return CalendarConnector.this.getPaintableId();\r\n                }\r\n                @Override\r\n                public ApplicationConnection getClient() {\r\n                    return CalendarConnector.this.getClient();\r\n                }\r\n                @Override\r\n                @SuppressWarnings(\"deprecation\")\r\n                public Action[] getActions() {\r\n                    if (widget instanceof SimpleDayCell) {\r\n                        SimpleDayCell cell = (SimpleDayCell) widget;\r\n                        Date start = new Date(cell.getDate().getYear(), cell.getDate().getMonth(), cell.getDate().getDate(), 0, 0, 0);\r\n                        Date end = new Date(cell.getDate().getYear(), cell.getDate().getMonth(), cell.getDate().getDate(), 23, 59, 59);\r\n                        return CalendarConnector.this.getActionsBetween(start, end);\r\n                    } else if (widget instanceof MonthEventLabel) {\r\n                        MonthEventLabel mel = (MonthEventLabel) widget;\r\n                        CalendarEvent event = mel.getCalendarEvent();\r\n                        Action[] actions = CalendarConnector.this.getActionsBetween(event.getStartTime(), event.getEndTime());\r\n                        for (Action action : actions) {\r\n                            ((VCalendarAction) action).setEvent(event);\r\n                        }\r\n                        return actions;\r\n                    } else if (widget instanceof DateCell) {\r\n                        DateCell cell = (DateCell) widget;\r\n                        int slotIndex = DOM.getChildIndex(cell.getElement(), (Element) ne.getEventTarget().cast());\r\n                        DateCellSlot slot = cell.getSlot(slotIndex);\r\n                        return CalendarConnector.this.getActionsBetween(slot.getFrom(), slot.getTo());\r\n                    } else if (widget instanceof DateCellDayEvent) {\r\n                        DateCellDayEvent dayEvent = (DateCellDayEvent) widget;\r\n                        CalendarEvent event = dayEvent.getCalendarEvent();\r\n                        Action[] actions = CalendarConnector.this.getActionsBetween(event.getStartTime(), event.getEndTime());\r\n                        for (Action action : actions) {\r\n                            ((VCalendarAction) action).setEvent(event);\r\n                        }\r\n                        return actions;\r\n                    }\r\n                    return null;\r\n                }\r\n            }, left, top);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.registerListeners",
	"Comment": "registers listeners on the calendar so server can be notified of theevents.",
	"Method": "void registerListeners(){\r\n    if (!calendar.isDisabled() && hasEventListener(CalendarEventId.DATECLICK)) {\r\n        rpc.dateClick(date);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.registerListeners",
	"Comment": "registers listeners on the calendar so server can be notified of theevents.",
	"Method": "void registerListeners(){\r\n    if (hasEventListener(CalendarEventId.FORWARD)) {\r\n        rpc.forward();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.registerListeners",
	"Comment": "registers listeners on the calendar so server can be notified of theevents.",
	"Method": "void registerListeners(){\r\n    if (hasEventListener(CalendarEventId.BACKWARD)) {\r\n        rpc.backward();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.registerListeners",
	"Comment": "registers listeners on the calendar so server can be notified of theevents.",
	"Method": "void registerListeners(){\r\n    if (hasEventListener(CalendarEventId.RANGESELECT)) {\r\n        rpc.rangeSelect(value);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.registerListeners",
	"Comment": "registers listeners on the calendar so server can be notified of theevents.",
	"Method": "void registerListeners(){\r\n    if (!calendar.isDisabled() && hasEventListener(CalendarEventId.WEEKCLICK)) {\r\n        rpc.weekClick(event);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.registerListeners",
	"Comment": "registers listeners on the calendar so server can be notified of theevents.",
	"Method": "void registerListeners(){\r\n    if (hasEventListener(CalendarEventId.EVENTMOVE)) {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(DateUtil.formatClientSideDate(event.getStart()));\r\n        sb.append('-');\r\n        sb.append(DateUtil.formatClientSideTime(event.getStartTime()));\r\n        rpc.eventMove(event.getIndex(), sb.toString());\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.registerListeners",
	"Comment": "registers listeners on the calendar so server can be notified of theevents.",
	"Method": "void registerListeners(){\r\n    if (hasEventListener(CalendarEventId.EVENTRESIZE)) {\r\n        StringBuilder buffer = new StringBuilder();\r\n        buffer.append(DateUtil.formatClientSideDate(event.getStart()));\r\n        buffer.append('-');\r\n        buffer.append(DateUtil.formatClientSideTime(event.getStartTime()));\r\n        String newStartDate = buffer.toString();\r\n        buffer = new StringBuilder();\r\n        buffer.append(DateUtil.formatClientSideDate(event.getEnd()));\r\n        buffer.append('-');\r\n        buffer.append(DateUtil.formatClientSideTime(event.getEndTime()));\r\n        String newEndDate = buffer.toString();\r\n        rpc.eventResize(event.getIndex(), newStartDate, newEndDate);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.registerListeners",
	"Comment": "registers listeners on the calendar so server can be notified of theevents.",
	"Method": "void registerListeners(){\r\n    rpc.scroll(scrollPosition);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.registerListeners",
	"Comment": "registers listeners on the calendar so server can be notified of theevents.",
	"Method": "void registerListeners(){\r\n    if (hasEventListener(CalendarEventId.EVENTCLICK)) {\r\n        rpc.eventClick(event.getIndex());\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.registerListeners",
	"Comment": "registers listeners on the calendar so server can be notified of theevents.",
	"Method": "void registerListeners(){\r\n    final NativeEvent ne = event.getNativeEvent();\r\n    int left = ne.getClientX();\r\n    int top = ne.getClientY();\r\n    top += Window.getScrollTop();\r\n    left += Window.getScrollLeft();\r\n    getClient().getContextMenu().showAt(new ActionOwner() {\r\n        @Override\r\n        public String getPaintableId() {\r\n            return CalendarConnector.this.getPaintableId();\r\n        }\r\n        @Override\r\n        public ApplicationConnection getClient() {\r\n            return CalendarConnector.this.getClient();\r\n        }\r\n        @Override\r\n        @SuppressWarnings(\"deprecation\")\r\n        public Action[] getActions() {\r\n            if (widget instanceof SimpleDayCell) {\r\n                SimpleDayCell cell = (SimpleDayCell) widget;\r\n                Date start = new Date(cell.getDate().getYear(), cell.getDate().getMonth(), cell.getDate().getDate(), 0, 0, 0);\r\n                Date end = new Date(cell.getDate().getYear(), cell.getDate().getMonth(), cell.getDate().getDate(), 23, 59, 59);\r\n                return CalendarConnector.this.getActionsBetween(start, end);\r\n            } else if (widget instanceof MonthEventLabel) {\r\n                MonthEventLabel mel = (MonthEventLabel) widget;\r\n                CalendarEvent event = mel.getCalendarEvent();\r\n                Action[] actions = CalendarConnector.this.getActionsBetween(event.getStartTime(), event.getEndTime());\r\n                for (Action action : actions) {\r\n                    ((VCalendarAction) action).setEvent(event);\r\n                }\r\n                return actions;\r\n            } else if (widget instanceof DateCell) {\r\n                DateCell cell = (DateCell) widget;\r\n                int slotIndex = DOM.getChildIndex(cell.getElement(), (Element) ne.getEventTarget().cast());\r\n                DateCellSlot slot = cell.getSlot(slotIndex);\r\n                return CalendarConnector.this.getActionsBetween(slot.getFrom(), slot.getTo());\r\n            } else if (widget instanceof DateCellDayEvent) {\r\n                DateCellDayEvent dayEvent = (DateCellDayEvent) widget;\r\n                CalendarEvent event = dayEvent.getCalendarEvent();\r\n                Action[] actions = CalendarConnector.this.getActionsBetween(event.getStartTime(), event.getEndTime());\r\n                for (Action action : actions) {\r\n                    ((VCalendarAction) action).setEvent(event);\r\n                }\r\n                return actions;\r\n            }\r\n            return null;\r\n        }\r\n    }, left, top);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.registerListeners",
	"Comment": "registers listeners on the calendar so server can be notified of theevents.",
	"Method": "void registerListeners(){\r\n    return CalendarConnector.this.getPaintableId();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.registerListeners",
	"Comment": "registers listeners on the calendar so server can be notified of theevents.",
	"Method": "void registerListeners(){\r\n    return CalendarConnector.this.getClient();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.calendar.CalendarConnector.registerListeners",
	"Comment": "registers listeners on the calendar so server can be notified of theevents.",
	"Method": "void registerListeners(){\r\n    if (widget instanceof SimpleDayCell) {\r\n        SimpleDayCell cell = (SimpleDayCell) widget;\r\n        Date start = new Date(cell.getDate().getYear(), cell.getDate().getMonth(), cell.getDate().getDate(), 0, 0, 0);\r\n        Date end = new Date(cell.getDate().getYear(), cell.getDate().getMonth(), cell.getDate().getDate(), 23, 59, 59);\r\n        return CalendarConnector.this.getActionsBetween(start, end);\r\n    } else if (widget instanceof MonthEventLabel) {\r\n        MonthEventLabel mel = (MonthEventLabel) widget;\r\n        CalendarEvent event = mel.getCalendarEvent();\r\n        Action[] actions = CalendarConnector.this.getActionsBetween(event.getStartTime(), event.getEndTime());\r\n        for (Action action : actions) {\r\n            ((VCalendarAction) action).setEvent(event);\r\n        }\r\n        return actions;\r\n    } else if (widget instanceof DateCell) {\r\n        DateCell cell = (DateCell) widget;\r\n        int slotIndex = DOM.getChildIndex(cell.getElement(), (Element) ne.getEventTarget().cast());\r\n        DateCellSlot slot = cell.getSlot(slotIndex);\r\n        return CalendarConnector.this.getActionsBetween(slot.getFrom(), slot.getTo());\r\n    } else if (widget instanceof DateCellDayEvent) {\r\n        DateCellDayEvent dayEvent = (DateCellDayEvent) widget;\r\n        CalendarEvent event = dayEvent.getCalendarEvent();\r\n        Action[] actions = CalendarConnector.this.getActionsBetween(event.getStartTime(), event.getEndTime());\r\n        for (Action action : actions) {\r\n            ((VCalendarAction) action).setEvent(event);\r\n        }\r\n        return actions;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTree.getNavigationLeftKey",
	"Comment": "get the key that scrolls to the left in the table. by default it is theleft arrow key but by overriding this you can change the key to whateveryou want.",
	"Method": "int getNavigationLeftKey(){\r\n    return KeyCodes.KEY_LEFT;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractContainer.setItemSetChangeListeners",
	"Comment": "sets the item set change listener collection. for internal use only.",
	"Method": "void setItemSetChangeListeners(Collection<Container.ItemSetChangeListener> itemSetChangeListeners){\r\n    this.itemSetChangeListeners = itemSetChangeListeners;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.setDragMode",
	"Comment": "sets the drag start mode of the table. drag start mode controls how tablebehaves as a drag source.",
	"Method": "void setDragMode(TableDragMode newDragMode){\r\n    dragMode = newDragMode;\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.client.DateTimeService.parseMonthName",
	"Comment": "replaces month names in the entered date with the name in the currentbrowser locale.",
	"Method": "String parseMonthName(String enteredDate,String formatString){\r\n    LocaleInfo browserLocale = LocaleInfo.getCurrentLocale();\r\n    if (browserLocale.getLocaleName().equals(getLocale())) {\r\n        return enteredDate;\r\n    }\r\n    String[] browserMonthNames = browserLocale.getDateTimeConstants().months();\r\n    String[] browserShortMonthNames = browserLocale.getDateTimeConstants().shortMonths();\r\n    if (formatString.contains(\"MMMM\")) {\r\n        for (int i = 0; i < 12; i++) {\r\n            enteredDate = enteredDate.replaceAll(getMonth(i), browserMonthNames[i]);\r\n        }\r\n    }\r\n    if (formatString.contains(\"MMM\")) {\r\n        for (int i = 0; i < 12; i++) {\r\n            enteredDate = enteredDate.replaceAll(getShortMonth(i), browserShortMonthNames[i]);\r\n        }\r\n    }\r\n    return enteredDate;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VSlider.getNavigationLeftKey",
	"Comment": "get the key that decreases the horizontal slider. by default it is theleft arrow key but by overriding this you can change the key to whateveryou want.",
	"Method": "int getNavigationLeftKey(){\r\n    return KeyCodes.KEY_LEFT;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.escalator.ScrollbarBundle.getScrollPos",
	"Comment": "gets the scroll position of the scrollbar in the axis the scrollbar isrepresenting.",
	"Method": "double getScrollPos(){\r\n    assert internalGetScrollPos() == toInt32(scrollPos) : \"calculated scroll position (\" + scrollPos + \") did not match the DOM element scroll position (\" + internalGetScrollPos() + \")\";\r\n    return scrollPos;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.InMemoryDataProvider.filteringByPrefix",
	"Comment": "wraps this data provider to create a new data provider that is filteredby a string by checking whether the lower case representation of an itemproperty value starts with the lower case representation of the filtervalue provided in the query. the filter never passes if the item propertyvalue is null.",
	"Method": "DataProvider<T, String> filteringByPrefix(ValueProvider<T, String> valueProvider,Locale locale,DataProvider<T, String> filteringByPrefix,ValueProvider<T, String> valueProvider){\r\n    return InMemoryDataProviderHelpers.filteringByCaseInsensitiveString(this, valueProvider, String::startsWith, InMemoryDataProviderHelpers.CURRENT_LOCALE_SUPPLIER);\r\n}"
}, {
	"Path": "com.vaadin.ui.Notification.setHtmlContentAllowed",
	"Comment": "sets whether html is allowed in the caption and description. if set totrue, the texts are passed to the browser as html and the developer isresponsible for ensuring no harmful html is used. if set to false, thetexts are passed to the browser as plain text.",
	"Method": "void setHtmlContentAllowed(boolean htmlContentAllowed){\r\n    getState().htmlContentAllowed = htmlContentAllowed;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbsoluteLayout.layoutHorizontally",
	"Comment": "performs an horizontal layout. should be called when a widget is add orremoved",
	"Method": "void layoutHorizontally(){\r\n    layout();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VRichTextArea.selectAll",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void selectAll(){\r\n    new Timer() {\r\n        @Override\r\n        public void run() {\r\n            rta.getFormatter().selectAll();\r\n        }\r\n    }.schedule(320);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VRichTextArea.selectAll",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void selectAll(){\r\n    rta.getFormatter().selectAll();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.hasConverter",
	"Comment": "checks if there is a converter set explicitly for the given property id.",
	"Method": "boolean hasConverter(Object propertyId){\r\n    return propertyValueConverters.containsKey(propertyId);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.setColumnFooter",
	"Comment": "sets the column footer caption. the column footer caption is the textdisplayed beneath the column if footers have been set visible.",
	"Method": "void setColumnFooter(Object propertyId,String footer){\r\n    if (footer == null) {\r\n        columnFooters.remove(propertyId);\r\n    } else {\r\n        columnFooters.put(propertyId, footer);\r\n    }\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.getLastVisibleHourOfDay",
	"Comment": "returns the last visible hour in the week view. returns the hour using a24h time format",
	"Method": "int getLastVisibleHourOfDay(){\r\n    return lastHour;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.filter.Compare.compareEquals",
	"Comment": "checks if the this value equals the given value. favors comparable overequals to better support e.g. bigdecimal where equals is stricter thancompareto.",
	"Method": "boolean compareEquals(Object otherValue){\r\n    if (value == null || otherValue == null) {\r\n        return (otherValue == value);\r\n    } else if (value == otherValue) {\r\n        return true;\r\n    } else if (value instanceof Comparable && otherValue.getClass().isAssignableFrom(getValue().getClass())) {\r\n        return ((Comparable) value).compareTo(otherValue) == 0;\r\n    } else {\r\n        return value.equals(otherValue);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.DateTimeField.getAssistiveText",
	"Comment": "get the description that explains the usage of the widget for users ofassistive devices.",
	"Method": "String getAssistiveText(){\r\n    return getState(false).descriptionForAssistiveDevices;\r\n}"
}, {
	"Path": "com.vaadin.client.extensions.DragSourceExtensionConnector.sendDragStartEventToServer",
	"Comment": "initiates a server rpc for the drag start event.this method is called only if there is a server side drag start eventhandler attached.",
	"Method": "void sendDragStartEventToServer(NativeEvent dragStartEvent){\r\n    getRpcProxy(DragSourceRpc.class).dragStart();\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.createFooterUpdater",
	"Comment": "creates the escalator updater used to update the footer rows in thisgrid. the updater is invoked when header rows or columns are added orremoved, or the content of existing header cells is changed.",
	"Method": "EscalatorUpdater createFooterUpdater(){\r\n    return new StaticSectionUpdater(footer, escalator.getFooter());\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.components.calendar.ContainerEventProvider.getStartDateProperty",
	"Comment": "get the property which provides the starting date and time of the event.",
	"Method": "Object getStartDateProperty(){\r\n    return startDateProperty;\r\n}"
}, {
	"Path": "bt.protocol.Protocols.reverseBits",
	"Comment": "returns a copy of the provided byte array with each byte reversed.",
	"Method": "byte[] reverseBits(byte[] bytes,byte reverseBits,byte b){\r\n    int i = b;\r\n    i = (i & 0b11110000) >> 4 | (i & 0b00001111) << 4;\r\n    i = (i & 0b11001100) >> 2 | (i & 0b00110011) << 2;\r\n    i = (i & 0b10101010) >> 1 | (i & 0b01010101) << 1;\r\n    return (byte) i;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.setCurrent",
	"Comment": "sets the thread local for the current session. this method is used by theframework to set the current session whenever a new request is processedand it is cleared when the request has been processed.the application developer can also use this method to define the currentsession outside the normal request handling and treads started fromrequest handling threads, e.g. when initiating custom background threads.the session is stored using a weak reference to avoid leaking memory incase it is not explicitly cleared.",
	"Method": "void setCurrent(VaadinSession session){\r\n    CurrentInstance.set(VaadinSession.class, session);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.getEditorHandler",
	"Comment": "returns the handler responsible for binding data and editor widgets tothe editor.",
	"Method": "EditorHandler<T> getEditorHandler(){\r\n    return editor.getHandler();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.isEventCaptionAsHtml",
	"Comment": "checks whether event captions are rendered as htmlthe default is false, i.e. to render that caption as plain text.",
	"Method": "boolean isEventCaptionAsHtml(){\r\n    return getState(false).eventCaptionAsHtml;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponentContainer.removeComponent",
	"Comment": "this only implements the events and component parent calls. the extendingclasses must implement component list maintenance and call this methodbefore component list maintenance.",
	"Method": "void removeComponent(Component c){\r\n    if (equals(c.getParent())) {\r\n        c.setParent(null);\r\n        fireComponentDetachEvent(c);\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.communication.AtmospherePushConnection.onTransportFailure",
	"Comment": "called if the transport mechanism cannot be used and the fallback will betried.",
	"Method": "void onTransportFailure(){\r\n    getLogger().warning(\"Push connection using primary method (\" + getConfig().getTransport() + \") failed. Trying with \" + getConfig().getFallbackTransport());\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.setFirstDayOfWeek",
	"Comment": "allow setting first day of week independent of locale. set to null if youwant first day of week being defined by the locale",
	"Method": "void setFirstDayOfWeek(Integer dayOfWeek){\r\n    int minimalSupported = java.util.Calendar.SUNDAY;\r\n    int maximalSupported = java.util.Calendar.SATURDAY;\r\n    if (dayOfWeek != null && (dayOfWeek < minimalSupported || dayOfWeek > maximalSupported)) {\r\n        throw new IllegalArgumentException(String.format(\"Day of week must be between %s and %s. Actually received: %s\", minimalSupported, maximalSupported, dayOfWeek));\r\n    }\r\n    customFirstDayOfWeek = dayOfWeek;\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinPortletRequest.getCurrent",
	"Comment": "gets the currently processed vaadin portlet request. the current requestis automatically defined when the request is started. the current requestcan not be used in e.g. background threads because of the way serverimplementations reuse request instances.",
	"Method": "VaadinPortletRequest getCurrent(){\r\n    return VaadinPortletService.getCurrentRequest();\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractOrderedLayout.addComponentAsFirst",
	"Comment": "adds a component into this container. the component is added to the leftor on top of the other components.",
	"Method": "void addComponentAsFirst(Component c){\r\n    if (equals(c.getParent())) {\r\n        removeComponent(c);\r\n    }\r\n    components.addFirst(c);\r\n    try {\r\n        super.addComponent(c);\r\n    } catch (IllegalArgumentException e) {\r\n        components.remove(c);\r\n        throw e;\r\n    }\r\n    componentAdded(c);\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.selection.ClickSelectHandler.setDeselectAllowed",
	"Comment": "sets whether clicking the currently selected row should deselect the row.",
	"Method": "void setDeselectAllowed(boolean deselectAllowed){\r\n    this.deselectAllowed = deselectAllowed;\r\n}"
}, {
	"Path": "com.vaadin.server.LegacyCommunicationManager.handleConnectorRelatedException",
	"Comment": "handles an exception related to a connector by invoking the appropriateerror handler.",
	"Method": "void handleConnectorRelatedException(ClientConnector connector,Throwable throwable){\r\n    ErrorEvent errorEvent = new ConnectorErrorEvent(connector, throwable);\r\n    ErrorHandler handler = ErrorEvent.findErrorHandler(connector);\r\n    handler.error(errorEvent);\r\n}"
}, {
	"Path": "com.vaadin.server.communication.PushHandler.sendRefreshAndDisconnect",
	"Comment": "sends a refresh message to the given atmosphere resource. uses anatmosphereresource instead of an atmospherepushconnection even though itmight be possible to look up the atmospherepushconnection from the ui toensure border cases work correctly, especially when there temporarily aretwo push connections which try to use the same ui. using theatmosphereresource directly guarantees the message goes to the correctrecipient.",
	"Method": "void sendRefreshAndDisconnect(AtmosphereResource resource){\r\n    sendNotificationAndDisconnect(resource, VaadinService.createCriticalNotificationJSON(null, null, null, null));\r\n}"
}, {
	"Path": "com.vaadin.server.LocaleService.createLocaleData",
	"Comment": "creates a localedata instance for transportation to the client.",
	"Method": "LocaleData createLocaleData(Locale locale){\r\n    LocaleData localeData = new LocaleData();\r\n    localeData.name = locale.toString();\r\n    Calendar c = Calendar.getInstance(locale);\r\n    c.set(2015, 0, 1);\r\n    SimpleDateFormat shortMonthFormat = new SimpleDateFormat(\"MMM\", locale);\r\n    SimpleDateFormat longMonthFormat = new SimpleDateFormat(\"MMMM\", locale);\r\n    int monthsInYear = c.getMaximum(Calendar.MONTH) + 1;\r\n    localeData.shortMonthNames = new String[monthsInYear];\r\n    localeData.monthNames = new String[monthsInYear];\r\n    for (int month = 0; month < monthsInYear; month++) {\r\n        c.set(Calendar.MONTH, month);\r\n        String shortMonth = shortMonthFormat.format(c.getTime());\r\n        String longMonth = longMonthFormat.format(c.getTime());\r\n        localeData.shortMonthNames[month] = shortMonth;\r\n        localeData.monthNames[month] = longMonth;\r\n    }\r\n    final DateFormatSymbols dfs = new DateFormatSymbols(locale);\r\n    localeData.shortDayNames = new String[7];\r\n    localeData.dayNames = new String[7];\r\n    String[] sDayNames = dfs.getShortWeekdays();\r\n    String[] lDayNames = dfs.getWeekdays();\r\n    for (int i = 0; i < 7; i++) {\r\n        localeData.shortDayNames[i] = sDayNames[i + 1];\r\n        localeData.dayNames[i] = lDayNames[i + 1];\r\n    }\r\n    final Calendar cal = new GregorianCalendar(locale);\r\n    localeData.firstDayOfWeek = cal.getFirstDayOfWeek() - 1;\r\n    DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.SHORT, locale);\r\n    DateFormat timeFormat = DateFormat.getTimeInstance(DateFormat.SHORT, locale);\r\n    if (!(dateFormat instanceof SimpleDateFormat)) {\r\n        getLogger().warning(\"Unable to get default date pattern for locale \" + locale.toString());\r\n        dateFormat = new SimpleDateFormat();\r\n    }\r\n    if (!(timeFormat instanceof SimpleDateFormat)) {\r\n        getLogger().warning(\"Unable to get default time pattern for locale \" + locale.toString());\r\n        timeFormat = new SimpleDateFormat();\r\n    }\r\n    final String datePattern = ((SimpleDateFormat) dateFormat).toPattern();\r\n    final String timePattern = ((SimpleDateFormat) timeFormat).toPattern();\r\n    localeData.dateFormat = datePattern.trim();\r\n    final boolean twelveHourClock = timePattern.indexOf(\"a\") > -1;\r\n    final String hourMinDelimiter = timePattern.indexOf(\".\") > -1 ? \".\" : \":\";\r\n    localeData.twelveHourClock = twelveHourClock;\r\n    localeData.hourMinuteDelimiter = hourMinDelimiter;\r\n    if (twelveHourClock) {\r\n        final String[] ampm = dfs.getAmPmStrings();\r\n        localeData.am = ampm[0];\r\n        localeData.pm = ampm[1];\r\n    }\r\n    return localeData;\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignContext.readPackageMappings",
	"Comment": "reads and stores the mappings from prefixes to package names from metatags located underin the html document.",
	"Method": "void readPackageMappings(Document doc){\r\n    Element head = doc.head();\r\n    if (head == null) {\r\n        return;\r\n    }\r\n    for (Node child : head.childNodes()) {\r\n        if (child instanceof Element) {\r\n            Element childElement = (Element) child;\r\n            if (\"meta\".equals(childElement.tagName())) {\r\n                Attributes attributes = childElement.attributes();\r\n                if (attributes.hasKey(\"name\") && attributes.hasKey(\"content\") && \"package-mapping\".equals(attributes.get(\"name\"))) {\r\n                    String contentString = attributes.get(\"content\");\r\n                    String[] parts = contentString.split(\":\");\r\n                    if (parts.length != 2) {\r\n                        throw new DesignException(\"The meta tag '\" + child + \"' cannot be parsed.\");\r\n                    }\r\n                    String prefixName = parts[0];\r\n                    String packageName = parts[1];\r\n                    addPackagePrefix(prefixName, packageName);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.fireEventResize",
	"Comment": "fires an event resize event. the event is fired when a user resizes theevent in the calendar causing the time range of the event to increase ordecrease. the new start and end times are returned as arguments to thismethod.",
	"Method": "void fireEventResize(int index,Date startTime,Date endTime){\r\n    EventResize event = new EventResize(this, events.get(index), startTime, endTime);\r\n    if (calendarEventProvider instanceof EventResizeHandler) {\r\n        ((EventResizeHandler) calendarEventProvider).eventResize(event);\r\n    }\r\n    fireEvent(event);\r\n}"
}, {
	"Path": "com.vaadin.ui.GridLayout.removeRow",
	"Comment": "removes a row and all the components in the row.components which span over several rows are removed if the selected rowis on the first row of such a component.if the last row is removed then all remaining components will be removedand the grid will be reduced to one row. the cursor will be moved to theupper left cell of the grid.",
	"Method": "void removeRow(int row){\r\n    if (row >= getRows()) {\r\n        throw new IllegalArgumentException(\"Cannot delete row \" + row + \" from a gridlayout with height \" + getRows());\r\n    }\r\n    for (int col = 0; col < getColumns(); col++) {\r\n        removeComponent(col, row);\r\n    }\r\n    for (ChildComponentData existingArea : getState().childData.values()) {\r\n        if (existingArea.row2 >= row) {\r\n            existingArea.row2--;\r\n            if (existingArea.row1 > row) {\r\n                existingArea.row1--;\r\n            }\r\n        }\r\n    }\r\n    if (getRows() == 1) {\r\n        cursorX = 0;\r\n        cursorY = 0;\r\n    } else {\r\n        setRows(getRows() - 1);\r\n        if (cursorY > row) {\r\n            cursorY--;\r\n        }\r\n    }\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractPopupCalendar.setRangeEnd",
	"Comment": "sets the end range for this component. the end range is inclusive, and itdepends on the current resolution, what is considered inside the range.",
	"Method": "void setRangeEnd(String rangeEnd){\r\n    calendar.setRangeEnd(rangeEnd);\r\n}"
}, {
	"Path": "com.vaadin.client.data.AbstractRemoteDataSource.canFetchData",
	"Comment": "checks if it is possible to currently fetch data from the remote datasource.",
	"Method": "boolean canFetchData(){\r\n    return true;\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.RendererCellReference.getElement",
	"Comment": "returns the element of the cell. can be either a td elementor a th element.",
	"Method": "TableCellElement getElement(){\r\n    return cell.getElement();\r\n}"
}, {
	"Path": "com.vaadin.client.extensions.DragSourceExtensionConnector.removeDraggedStyle",
	"Comment": "remove class name that indicated that the drag source element was beingdragged. this method is called during the dragend event.",
	"Method": "void removeDraggedStyle(NativeEvent event){\r\n    Element dragSource = getDraggableElement();\r\n    dragSource.removeClassName(getStylePrimaryName(dragSource) + STYLE_SUFFIX_DRAGGED);\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addHeaderDoubleClickHandler",
	"Comment": "register a headerdoubleclickhandler to this grid. the event for thishandler is fired when a double click event occurs in the header of thisgrid.",
	"Method": "HandlerRegistration addHeaderDoubleClickHandler(HeaderDoubleClickHandler handler){\r\n    return addHandler(handler, GridDoubleClickEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.getNextKey",
	"Comment": "the key that selects the next week in the calendar. by default this isthe down arrow key but by overriding this method it can be changed towhatever you like.",
	"Method": "int getNextKey(){\r\n    return KeyCodes.KEY_DOWN;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.setRangeStart",
	"Comment": "sets the start range for this component. the start range is inclusive,and it depends on the current resolution, what is considered inside therange.",
	"Method": "void setRangeStart(Date newRangeStart){\r\n    if (!SharedUtil.equals(rangeStart, newRangeStart)) {\r\n        rangeStart = newRangeStart;\r\n        if (initialRenderDone) {\r\n            renderCalendar();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.resizeSortedColumnForSortIndicator",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void resizeSortedColumnForSortIndicator(){\r\n    HeaderCell sortedHeader = tHead.getHeaderCell(sortColumn);\r\n    if (sortedHeader != null) {\r\n        sortedHeader.setSorted(true);\r\n        tHead.resizeCaptionContainer(sortedHeader);\r\n    }\r\n    HeaderCell oldSortedHeader = tHead.getHeaderCell(oldSortColumn);\r\n    if (oldSortedHeader != null) {\r\n        tHead.resizeCaptionContainer(oldSortedHeader);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.setContainerDataSource",
	"Comment": "sets the grid data source.note grid columns are based on properties and try todetect a correct converter for the data type. the columns are notreinitialized automatically if the container is changed, and if the sameproperties are present after container change, the columns are reused.properties with same names, but different data types will lead tounpredictable behavior.",
	"Method": "void setContainerDataSource(Container.Indexed container){\r\n    defaultContainer = false;\r\n    internalSetContainerDataSource(container);\r\n}"
}, {
	"Path": "com.vaadin.client.VTooltip.connectHandlersToWidget",
	"Comment": "connects dom handlers to widget that are needed for tooltip presentation.",
	"Method": "void connectHandlersToWidget(Widget widget){\r\n    Profiler.enter(\"VTooltip.connectHandlersToWidget\");\r\n    widget.addDomHandler(tooltipEventHandler, MouseOutEvent.getType());\r\n    widget.addDomHandler(tooltipEventHandler, MouseMoveEvent.getType());\r\n    widget.addDomHandler(tooltipEventHandler, MouseDownEvent.getType());\r\n    widget.addDomHandler(tooltipEventHandler, KeyDownEvent.getType());\r\n    widget.addDomHandler(tooltipEventHandler, FocusEvent.getType());\r\n    widget.addDomHandler(tooltipEventHandler, BlurEvent.getType());\r\n    Profiler.leave(\"VTooltip.connectHandlersToWidget\");\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.deferOrdering",
	"Comment": "calling this method will defer ordering algorithm, to order windows basedon servers bringtofront and modality instructions. non changed windowswill be left intact.for internal use only. may be removed or replaced in the future.",
	"Method": "void deferOrdering(){\r\n    if (!orderingDefered) {\r\n        orderingDefered = true;\r\n        Scheduler.get().scheduleFinally(() -> {\r\n            doServerSideOrdering();\r\n            VNotification.bringNotificationsToFront();\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinServlet.handleContextRootWithoutSlash",
	"Comment": "invoked for every request to this servlet to potentially send a redirectto avoid problems with requests to the context root with no trailingslash.",
	"Method": "boolean handleContextRootWithoutSlash(HttpServletRequest request,HttpServletResponse response){\r\n    String location = request.getRequestURI();\r\n    String lastPathParameter = getLastPathParameter(location);\r\n    location = location.substring(0, location.length() - lastPathParameter.length());\r\n    if ((request.getPathInfo() == null || \"/\".equals(request.getPathInfo())) && request.getServletPath().isEmpty() && !location.endsWith(\"/\")) {\r\n        location = location + \"/\" + lastPathParameter;\r\n        String queryString = request.getQueryString();\r\n        if (queryString != null) {\r\n            queryString = queryString.replaceAll(\"[\\\\r\\\\n]\", \"\");\r\n            location += '?' + queryString;\r\n        }\r\n        response.sendRedirect(location);\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.github.dozermapper.core.builder.xml.BeanMappingXMLBuilder.loadInputStreams",
	"Comment": "loads the collection of streams into memory and parses the xml",
	"Method": "void loadInputStreams(List<Supplier<InputStream>> xmlMappingSuppliers){\r\n    for (Supplier<InputStream> supplier : xmlMappingSuppliers) {\r\n        try (InputStream stream = new BufferedInputStream(supplier.get())) {\r\n            load(stream);\r\n        } catch (IOException ex) {\r\n            MappingUtils.throwMappingException(ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.FilesystemContainer.areChildrenAllowed",
	"Comment": "tests if the specified item in the container may have children. since afilesystemcontainer contains files and directories, thismethod returns true for directory items only.",
	"Method": "boolean areChildrenAllowed(Object itemId){\r\n    return itemId instanceof File && ((File) itemId).canRead() && ((File) itemId).isDirectory();\r\n}"
}, {
	"Path": "com.vaadin.v7.data.validator.CompositeValidator.setErrorMessage",
	"Comment": "sets the message to be included in the exception in case the value doesnot validate. the exception message is typically shown to the end user.",
	"Method": "void setErrorMessage(String errorMessage){\r\n    this.errorMessage = errorMessage;\r\n}"
}, {
	"Path": "com.vaadin.server.ServerRpcManager.getRpcInterface",
	"Comment": "returns the rpc interface type managed by this rpc manager instance.",
	"Method": "Class<T> getRpcInterface(){\r\n    return rpcInterface;\r\n}"
}, {
	"Path": "com.folioreader.view.VerticalViewPager.getOffscreenPageLimit",
	"Comment": "returns the number of pages that will be retained to either side of thecurrent page in the view hierarchy in an idle state. defaults to 1.",
	"Method": "int getOffscreenPageLimit(){\r\n    return mOffscreenPageLimit;\r\n}"
}, {
	"Path": "com.vaadin.ui.DateField.setAssistiveText",
	"Comment": "set a description that explains the usage of the widget for users ofassistive devices.",
	"Method": "void setAssistiveText(String description){\r\n    getState().descriptionForAssistiveDevices = description;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VGridLayout.getHorizontalSpacing",
	"Comment": "returns the spacing between the cells horizontally in pixels.",
	"Method": "int getHorizontalSpacing(){\r\n    return LayoutManager.get(client).getOuterWidth(spacingMeasureElement);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.AbstractConnector.forceStateChange",
	"Comment": "force the connector to recheck its state variables as the variables ortheir meaning might have changed.",
	"Method": "void forceStateChange(){\r\n    StateChangeEvent event = new FullStateChangeEvent(this);\r\n    fireEvent(event);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.window.WindowConnector.setWindowOrderAndPosition",
	"Comment": "gives the windowconnector an order number. as a side effect, moves thewindow according to its order number so the windows are stacked. thismethod should be called for each window in the order they should appear.",
	"Method": "void setWindowOrderAndPosition(){\r\n    getWidget().setWindowOrderAndPosition();\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinServletService.getCancelingRelativePath",
	"Comment": "gets a relative path that cancels the provided path. this essentiallyadds one .. for each part of the path to cancel.",
	"Method": "String getCancelingRelativePath(String pathToCancel){\r\n    StringBuilder sb = new StringBuilder(\".\");\r\n    for (int i = 1; i < pathToCancel.length(); i++) {\r\n        if (pathToCancel.charAt(i) == '/') {\r\n            sb.append(\"/..\");\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VTree.getNavigationDownKey",
	"Comment": "get the key that moves the selection head downwards. by default it is thedown arrow key but by overriding this you can change the key to whateveryou want.",
	"Method": "int getNavigationDownKey(){\r\n    return KeyCodes.KEY_DOWN;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.loadSession",
	"Comment": "called when the vaadinsession should be loaded from the underlying httpsession.",
	"Method": "VaadinSession loadSession(WrappedSession wrappedSession){\r\n    assert VaadinSession.hasLock(this, wrappedSession);\r\n    VaadinSession vaadinSession = readFromHttpSession(wrappedSession);\r\n    if (vaadinSession == null) {\r\n        return null;\r\n    }\r\n    vaadinSession.refreshTransients(wrappedSession, this);\r\n    return vaadinSession;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.GeneratedPropertyContainer.addGeneratedProperty",
	"Comment": "add a new propertyvaluegenerator with given property id. this willoverride any existing properties with the same property id. fires apropertysetchangeevent.",
	"Method": "void addGeneratedProperty(Object propertyId,PropertyValueGenerator<?> generator){\r\n    propertyGenerators.put(propertyId, generator);\r\n    fireContainerPropertySetChange();\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractListing.getItemIconGenerator",
	"Comment": "gets the currently used item icon generator. the default item iconprovider returns null for all items, resulting in no icons being used.implementations that support item icons make this method public.",
	"Method": "IconGenerator<T> getItemIconGenerator(){\r\n    return itemIconGenerator;\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.markConnectorsDirtyRecursively",
	"Comment": "marks all visible connectors dirty, starting from the given connector andgoing downwards in the hierarchy.",
	"Method": "void markConnectorsDirtyRecursively(ClientConnector c){\r\n    if (c instanceof Component && !((Component) c).isVisible()) {\r\n        return;\r\n    }\r\n    markDirty(c);\r\n    for (ClientConnector child : AbstractClientConnector.getAllChildrenIterable(c)) {\r\n        markConnectorsDirtyRecursively(child);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Calendar.fireEventClick",
	"Comment": "fires event when a date was clicked in the calendar. uses an existingevent from the event cache.",
	"Method": "void fireEventClick(Integer index){\r\n    fireEvent(new EventClick(this, events.get(index)));\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addSelectionAllowedHandler",
	"Comment": "register a selection allowed status change handler to this grid. theevent for this handler is fired when the grid changes selection allowedstate.",
	"Method": "HandlerRegistration addSelectionAllowedHandler(GridSelectionAllowedHandler handler){\r\n    return addHandler(handler, GridSelectionAllowedEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.data.provider.SortOrderBuilder.build",
	"Comment": "returns an unmodifiable copy of the list of current sort orders in thissort builder.",
	"Method": "List<T> build(){\r\n    return Collections.unmodifiableList(new ArrayList(sortOrders));\r\n}"
}, {
	"Path": "com.vaadin.tests.server.component.ui.CustomUIClassLoaderTest.testWithClassLoader",
	"Comment": "tests that the classloader passed in the applicationstartevent is used toload ui classes.",
	"Method": "void testWithClassLoader(){\r\n    LoggingClassLoader loggingClassLoader = new LoggingClassLoader();\r\n    DefaultUIProvider uiProvider = new DefaultUIProvider();\r\n    Class<? extends UI> uiClass = uiProvider.getUIClass(new UIClassSelectionEvent(createRequestMock(loggingClassLoader)));\r\n    assertEquals(MyUI.class, uiClass);\r\n    assertEquals(1, loggingClassLoader.requestedClasses.size());\r\n    assertEquals(MyUI.class.getName(), loggingClassLoader.requestedClasses.get(0));\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VMenuBar.getNavigationDownKey",
	"Comment": "get the key that moves the selection downwards. by default it is the downarrow key but by overriding this you can change the key to whatever youwant.",
	"Method": "int getNavigationDownKey(){\r\n    return KeyCodes.KEY_DOWN;\r\n}"
}, {
	"Path": "com.vaadin.ui.Tree.setItemIconGenerator",
	"Comment": "sets the item icon generator that is used to produce custom icons foritems. the generator can return null for items with no icon.",
	"Method": "void setItemIconGenerator(IconGenerator<T> iconGenerator){\r\n    Objects.requireNonNull(iconGenerator, \"Item icon generator must not be null\");\r\n    this.iconProvider = iconGenerator;\r\n    treeGrid.getDataCommunicator().reset();\r\n}"
}, {
	"Path": "com.vaadin.ui.JavaScript.getCurrent",
	"Comment": "get the javascript object for the current page, or null if there is nocurrent page.",
	"Method": "JavaScript getCurrent(){\r\n    Page page = Page.getCurrent();\r\n    if (page == null) {\r\n        return null;\r\n    }\r\n    return page.getJavaScript();\r\n}"
}, {
	"Path": "com.vaadin.server.widgetsetutils.ClassPathExplorer.getAvailableWidgetSetsAndStylesheets",
	"Comment": "finds the names and locations of widgetsets and themes available on theclass path.",
	"Method": "LocationInfo getAvailableWidgetSetsAndStylesheets(){\r\n    long start = System.currentTimeMillis();\r\n    Map<String, URL> widgetsets = new HashMap();\r\n    Map<String, URL> themes = new HashMap();\r\n    Set<String> keySet = CLASSPATH_LOCATIONS.keySet();\r\n    for (String location : keySet) {\r\n        searchForWidgetSetsAndAddonStyles(location, widgetsets, themes);\r\n    }\r\n    long end = System.currentTimeMillis();\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"Widgetsets found from classpath:\\n\");\r\n    for (String ws : widgetsets.keySet()) {\r\n        sb.append(\"\\t\");\r\n        sb.append(ws);\r\n        sb.append(\" in \");\r\n        sb.append(widgetsets.get(ws));\r\n        sb.append(\"\\n\");\r\n    }\r\n    sb.append(\"Addon styles found from classpath:\\n\");\r\n    for (String theme : themes.keySet()) {\r\n        sb.append(\"\\t\");\r\n        sb.append(theme);\r\n        sb.append(\" in \");\r\n        sb.append(themes.get(theme));\r\n        sb.append(\"\\n\");\r\n    }\r\n    log(sb.toString());\r\n    log(\"Search took \" + (end - start) + \"ms\");\r\n    return new LocationInfo(widgetsets, themes);\r\n}"
}, {
	"Path": "com.vaadin.ui.LegacyWindow.getBrowserWindowHeight",
	"Comment": "gets the last known height of the browser window in which this uiresides.",
	"Method": "int getBrowserWindowHeight(){\r\n    return getPage().getBrowserWindowHeight();\r\n}"
}, {
	"Path": "com.vaadin.data.provider.DataCommunicator.getMinPushSize",
	"Comment": "get minimum size of data which will be sent to the client when datasource is set.",
	"Method": "int getMinPushSize(){\r\n    return minPushSize;\r\n}"
}, {
	"Path": "com.vaadin.client.renderers.ComplexRenderer.onActivate",
	"Comment": "called when the cell is activated by pressing enter, doubleclicking or performing a double tap on the cell.",
	"Method": "boolean onActivate(CellReference<?> cell){\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbsoluteLayout.replaceComponent",
	"Comment": "replaces one component with another one. the new component inherits theold components position.",
	"Method": "void replaceComponent(Component oldComponent,Component newComponent){\r\n    ComponentPosition position = getPosition(oldComponent);\r\n    removeComponent(oldComponent);\r\n    addComponent(newComponent, position);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractTextField.setSelectionRange",
	"Comment": "sets the range of text to be selected.as a side effect the field will become focused.",
	"Method": "void setSelectionRange(int pos,int length){\r\n    selectionPosition = pos;\r\n    selectionLength = length;\r\n    focus();\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractSplitPanel.iterator",
	"Comment": "gets an iterator to the collection of contained components. using thisiterator it is possible to step through all components contained in thiscontainer and remove components from it.",
	"Method": "Iterator<Component> iterator(){\r\n    return new ComponentIterator();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.getSubmitListener",
	"Comment": "returns the submit listener that listens to selection made from thepanel.",
	"Method": "SubmitListener getSubmitListener(){\r\n    return submitListener;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.destroy",
	"Comment": "called when the servlet, portlet or similar for this service is beingdestroyed. after this method has been called, no more requests will behandled by this service.",
	"Method": "void destroy(){\r\n    ServiceDestroyEvent event = new ServiceDestroyEvent(this);\r\n    serviceDestroyListeners.forEach(listener -> listener.serviceDestroy(event));\r\n}"
}, {
	"Path": "com.vaadin.ui.MenuBar.removeItem",
	"Comment": "remove first occurrence the specified item from the main menu.",
	"Method": "void removeItem(MenuBar.MenuItem item){\r\n    if (item != null) {\r\n        menuItems.remove(item);\r\n    }\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.getReconnectDialogConfiguration",
	"Comment": "retrieves the object used for configuring the reconnect dialog.",
	"Method": "ReconnectDialogConfiguration getReconnectDialogConfiguration(){\r\n    return reconnectDialogConfiguration;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Slider.setResolution",
	"Comment": "set a new resolution for the slider. the resolution is the number ofdigits after the decimal point.",
	"Method": "void setResolution(int resolution){\r\n    if (resolution < 0) {\r\n        throw new IllegalArgumentException(\"Cannot set a negative resolution to Slider\");\r\n    }\r\n    getState().resolution = resolution;\r\n}"
}, {
	"Path": "com.vaadin.client.VTooltip.showAssistive",
	"Comment": "show the tooltip with the provided info for assistive devices.",
	"Method": "void showAssistive(TooltipInfo info){\r\n    updatePosition(null, true);\r\n    setTooltipText(info);\r\n    showTooltip();\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.getLastRequestTimestamp",
	"Comment": "returns the time when the last request was serviced in this session.",
	"Method": "long getLastRequestTimestamp(){\r\n    assert hasLock();\r\n    return lastRequestTimestamp;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.addHeaderClickListener",
	"Comment": "adds a header click listener which handles the click events when the userclicks on a column header cell in the table.the listener will receive events which contain information about whichcolumn was clicked and some details about the mouse event.",
	"Method": "void addHeaderClickListener(HeaderClickListener listener){\r\n    addListener(TableConstants.HEADER_CLICK_EVENT_ID, HeaderClickEvent.class, listener, HeaderClickEvent.HEADER_CLICK_METHOD);\r\n}"
}, {
	"Path": "com.vaadin.ui.ProgressBar.setIndeterminate",
	"Comment": "sets whether or not this progress indicator is indeterminate. inindeterminate mode there is an animation indicating that the task isrunning but without providing any information about the current progress.",
	"Method": "void setIndeterminate(boolean indeterminate){\r\n    getState().indeterminate = indeterminate;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.setColumnIcon",
	"Comment": "sets the icon resource for the specified column.throws illegalargumentexception if the specified column is not visible.",
	"Method": "void setColumnIcon(Object propertyId,Resource icon){\r\n    if (icon == null) {\r\n        columnIcons.remove(propertyId);\r\n    } else {\r\n        columnIcons.put(propertyId, icon);\r\n    }\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.server.communication.PushHandler.getLongPollingSuspendTimeout",
	"Comment": "gets the timeout used for suspend calls when using long polling.",
	"Method": "int getLongPollingSuspendTimeout(){\r\n    return longPollingSuspendTimeout;\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.SingleSelectionModelImpl.isKeySelected",
	"Comment": "returns whether the given key maps to the currently selected item.",
	"Method": "boolean isKeySelected(String key){\r\n    return isSelected(getData(key));\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.recalculateColumnWidths",
	"Comment": "requests that the column widths should be recalculated.the actual recalculation is not necessarily done immediately so youcannot rely on the columns being the correct width after the callreturns.",
	"Method": "void recalculateColumnWidths(){\r\n    autoColumnWidthsRecalculator.schedule();\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractListing.getItemCaptionGenerator",
	"Comment": "gets the item caption generator that is used to produce the strings shownin the combo box for each item.",
	"Method": "ItemCaptionGenerator<T> getItemCaptionGenerator(){\r\n    return itemCaptionGenerator;\r\n}"
}, {
	"Path": "com.vaadin.ui.HorizontalLayout.addComponentsAndExpand",
	"Comment": "adds the given components to this layout and sets them as expanded. thewidth of all added child components are set to 100% so that the expansionwill be effective. the width of this layout is also set to 100% if it iscurrently undefined.the components are added in the provided order to the end of this layout.any components that are already children of this layout will be moved tonew positions.",
	"Method": "void addComponentsAndExpand(Component components){\r\n    addComponents(components);\r\n    if (getWidth() < 0) {\r\n        setWidth(100, Unit.PERCENTAGE);\r\n    }\r\n    for (Component child : components) {\r\n        child.setWidth(100, Unit.PERCENTAGE);\r\n        setExpandRatio(child, 1);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.colorpicker.VColorPickerGrid.createGrid",
	"Comment": "creates a grid according to the current row and column count information.",
	"Method": "Grid createGrid(){\r\n    grid = new Grid(rows, columns);\r\n    grid.setWidth(\"100%\");\r\n    grid.setHeight(\"100%\");\r\n    grid.addClickHandler(this);\r\n    return grid;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.getRowStyleGenerator",
	"Comment": "gets the style generator that is used for generating styles for rows.",
	"Method": "RowStyleGenerator<T> getRowStyleGenerator(){\r\n    return rowStyleGenerator;\r\n}"
}, {
	"Path": "org.greenrobot.essentials.DateUtils.getDayAsReadableInt",
	"Comment": "readable yyyymmdd representation of a day, which is also sortable.",
	"Method": "int getDayAsReadableInt(long time,int getDayAsReadableInt,Calendar calendar){\r\n    int day = calendar.get(Calendar.DAY_OF_MONTH);\r\n    int month = calendar.get(Calendar.MONTH) + 1;\r\n    int year = calendar.get(Calendar.YEAR);\r\n    return year * 10000 + month * 100 + day;\r\n}"
}, {
	"Path": "com.vaadin.v7.tests.server.component.table.MultipleSelectionTest.testSetMultiSelectMode",
	"Comment": "tests setting the multiselect mode of the table. the multiselect modeaffects how mouse selection is made in the table by the user.",
	"Method": "void testSetMultiSelectMode(){\r\n    Table table = new Table(\"\", createTestContainer());\r\n    assertEquals(MultiSelectMode.DEFAULT, table.getMultiSelectMode());\r\n    table.setMultiSelectMode(MultiSelectMode.SIMPLE);\r\n    assertEquals(MultiSelectMode.SIMPLE, table.getMultiSelectMode());\r\n}"
}, {
	"Path": "com.vaadin.v7.server.communication.data.RpcDataProviderExtension.columnsAdded",
	"Comment": "informs this data provider that given columns have been added to grid.",
	"Method": "void columnsAdded(List<Column> addedColumns){\r\n    for (GridValueChangeListener l : activeItemHandler.getValueChangeListeners()) {\r\n        l.addColumns(addedColumns);\r\n    }\r\n    refreshCache();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VRadioButtonGroup.getItem",
	"Comment": "returns the jsonobject used to populate the radiobutton widget thatcontains given element.",
	"Method": "JsonObject getItem(Element element){\r\n    return tryGetItem(element).orElse(tryGetItem(element.getParentElement()).orElse(null));\r\n}"
}, {
	"Path": "com.vaadin.ui.GridLayout.getComponentArea",
	"Comment": "returns information about the area where given component is laid in thegridlayout.",
	"Method": "Area getComponentArea(Component component){\r\n    ChildComponentData childComponentData = getState(false).childData.get(component);\r\n    if (childComponentData == null) {\r\n        return null;\r\n    } else {\r\n        return new Area(childComponentData, component);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.DefaultEditorEventHandler.isTouchOpenEvent",
	"Comment": "returns whether the given event is a touch event that should open theeditor.",
	"Method": "boolean isTouchOpenEvent(EditorDomEvent<T> event){\r\n    final Event e = event.getDomEvent();\r\n    final int type = e.getTypeInt();\r\n    final double now = Duration.currentTimeMillis();\r\n    final int currentX = WidgetUtil.getTouchOrMouseClientX(e);\r\n    final int currentY = WidgetUtil.getTouchOrMouseClientY(e);\r\n    final boolean validTouchOpenEvent = type == Event.ONTOUCHEND && now - lastTouchEventTime < 500 && lastTouchEventRow == event.getCell().getRowIndex() && Math.abs(lastTouchEventX - currentX) < 20 && Math.abs(lastTouchEventY - currentY) < 20;\r\n    if (type == Event.ONTOUCHSTART) {\r\n        lastTouchEventX = currentX;\r\n        lastTouchEventY = currentY;\r\n    }\r\n    if (type == Event.ONTOUCHEND) {\r\n        lastTouchEventTime = now;\r\n        lastTouchEventRow = event.getCell().getRowIndex();\r\n    }\r\n    return validTouchOpenEvent;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinSession.getRequestHandlers",
	"Comment": "gets the request handlers that are registered to the session. theiteration order of the returned collection is the same as the order inwhich the request handlers will be invoked when a request is handled.",
	"Method": "Collection<RequestHandler> getRequestHandlers(){\r\n    assert hasLock();\r\n    return Collections.unmodifiableCollection(requestHandlers);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendar.getRangeSelectListener",
	"Comment": "get the listener that listens to the user highlighting a region in thecalendar.",
	"Method": "RangeSelectListener getRangeSelectListener(){\r\n    return rangeSelectListener;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.ContainerHierarchicalWrapper.removeItemRecursively",
	"Comment": "removes the item identified by given itemid and all its children.",
	"Method": "boolean removeItemRecursively(Object itemId){\r\n    return HierarchicalContainer.removeItemRecursively(this, itemId);\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addSpacerVisibilityChangedHandler",
	"Comment": "adds a spacer visibility changed handler to the underlying escalator.",
	"Method": "HandlerRegistration addSpacerVisibilityChangedHandler(SpacerVisibilityChangedHandler handler){\r\n    return escalator.addHandler(handler, SpacerVisibilityChangedEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.createTextBox",
	"Comment": "this method will create the textbox used by the vcombobox instance. it isinvoked during the constructor and should only be overridden if a customtextbox shall be used. the overriding method cannot use any instancevariables.",
	"Method": "TextBox createTextBox(){\r\n    return new FilterSelectTextBox();\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.AbstractField.shouldHideErrors",
	"Comment": "returns true if the error indicator be hidden when painting the componenteven when there are errors.this is a mostly internal method, but can be overridden in subclassese.g. if the error indicator should also be shown for empty fields in somecases.",
	"Method": "boolean shouldHideErrors(){\r\n    return isRequired() && isEmpty() && getComponentError() == null;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addBodyKeyUpHandler",
	"Comment": "register a bodykeyuphandler to this grid. the event for this handler isfired when a keyup event occurs while cell focus is in the body of thisgrid.",
	"Method": "HandlerRegistration addBodyKeyUpHandler(BodyKeyUpHandler handler){\r\n    return addHandler(handler, GridKeyUpEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinPortletService.getCurrentRequest",
	"Comment": "gets the currently processed vaadin portlet request. the current requestis automatically defined when the request is started. the current requestcan not be used in e.g. background threads because of the way serverimplementations reuse request instances.",
	"Method": "VaadinPortletRequest getCurrentRequest(){\r\n    return (VaadinPortletRequest) VaadinService.getCurrentRequest();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VGridLayout.createNewCell",
	"Comment": "creates a new cell with the given coordinates.for internal use only. may be removed or replaced in the future.",
	"Method": "Cell createNewCell(int row,int col){\r\n    Cell cell = new Cell(row, col);\r\n    cells[col][row] = cell;\r\n    return cell;\r\n}"
}, {
	"Path": "com.vaadin.client.Util.scrollIntoViewVertically",
	"Comment": "scrolls an element into view vertically only. modified version ofelement.scrollintoview.",
	"Method": "void scrollIntoViewVertically(Element elem){\r\n    WidgetUtil.scrollIntoViewVertically(elem);\r\n}"
}, {
	"Path": "com.vaadin.event.EventRouter.hasListeners",
	"Comment": "checks if the given event type is listened by a listener registered tothis router.",
	"Method": "boolean hasListeners(Class<?> eventType){\r\n    if (listenerList != null) {\r\n        for (ListenerMethod lm : listenerList) {\r\n            if (lm.isType(eventType)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.ui.Alignment.isRight",
	"Comment": "checks if component is aligned to the right of the available space.",
	"Method": "boolean isRight(){\r\n    return (bitMask & Bits.ALIGNMENT_RIGHT) == Bits.ALIGNMENT_RIGHT;\r\n}"
}, {
	"Path": "lbms.plugins.mldht.kad.Key.threeWayDistance",
	"Comment": "compares the distance of two keys relative to this one using the xor metric",
	"Method": "int threeWayDistance(Key k1,Key k2){\r\n    byte[] h0 = hash;\r\n    byte[] h1 = k1.hash;\r\n    byte[] h2 = k2.hash;\r\n    int mmi = mismatch(h1, h2);\r\n    if (mmi == -1)\r\n        return 0;\r\n    int h = Byte.toUnsignedInt(h0[mmi]);\r\n    int a = Byte.toUnsignedInt(h1[mmi]);\r\n    int b = Byte.toUnsignedInt(h2[mmi]);\r\n    return Integer.compareUnsigned(a ^ h, b ^ h);\r\n}"
}, {
	"Path": "com.vaadin.data.provider.DataCommunicator.getDataObject",
	"Comment": "creates the jsonobject for given data object. this method calls all datagenerators for it.",
	"Method": "JsonObject getDataObject(T data){\r\n    JsonObject dataObject = Json.createObject();\r\n    for (DataGenerator<T> generator : generators) {\r\n        generator.generateData(data, dataObject);\r\n    }\r\n    return dataObject;\r\n}"
}, {
	"Path": "com.folioreader.view.VerticalViewPager.executeKeyEvent",
	"Comment": "you can call this function yourself to have the scroll view performscrolling from a key event, just as if the event had been dispatched toit by the view hierarchy.",
	"Method": "boolean executeKeyEvent(KeyEvent event){\r\n    boolean handled = false;\r\n    if (event.getAction() == KeyEvent.ACTION_DOWN) {\r\n        switch(event.getKeyCode()) {\r\n            case KeyEvent.KEYCODE_DPAD_LEFT:\r\n                handled = arrowScroll(FOCUS_LEFT);\r\n                break;\r\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\r\n                handled = arrowScroll(FOCUS_RIGHT);\r\n                break;\r\n            case KeyEvent.KEYCODE_TAB:\r\n                if (Build.VERSION.SDK_INT >= 11) {\r\n                    if (KeyEvent.metaStateHasNoModifiers(event.getMetaState())) {\r\n                        handled = arrowScroll(FOCUS_FORWARD);\r\n                    } else if (KeyEvent.metaStateHasNoModifiers(event.getMetaState())) {\r\n                        handled = arrowScroll(FOCUS_BACKWARD);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return handled;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTwinColSelect.getNavigationSelectKey",
	"Comment": "get the key that selects an item in the table. by default it is the enterkey but by overriding this you can change the key to whatever you want.",
	"Method": "int getNavigationSelectKey(){\r\n    return KeyCodes.KEY_ENTER;\r\n}"
}, {
	"Path": "com.vaadin.ui.Tree.deselect",
	"Comment": "this method is a shorthand that delegates to the currently set selectionmodel.",
	"Method": "void deselect(T item){\r\n    treeGrid.deselect(item);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.AbstractClickEventHandler.hasEventListener",
	"Comment": "checks if there is a server side event listener registered for clicks.",
	"Method": "boolean hasEventListener(){\r\n    return connector.hasEventListener(clickEventIdentifier);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VSlider.getNavigationRightKey",
	"Comment": "get the key that increases the horizontal slider. by default it is theright arrow key but by overriding this you can change the key to whateveryou want.",
	"Method": "int getNavigationRightKey(){\r\n    return KeyCodes.KEY_RIGHT;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinServlet.createVaadinRequest",
	"Comment": "creates a vaadin request for a http servlet request. this method can beoverridden if the vaadin request should have special properties.",
	"Method": "VaadinServletRequest createVaadinRequest(HttpServletRequest request){\r\n    return new VaadinServletRequest(request, getService());\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VCssLayout.addOrMove",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void addOrMove(Widget child,int index){\r\n    Profiler.enter(\"VCssLayout.addOrMove\");\r\n    if (child.getParent() == this) {\r\n        Profiler.enter(\"VCssLayout.addOrMove getWidgetIndex\");\r\n        int currentIndex = getWidgetIndex(child);\r\n        Profiler.leave(\"VCssLayout.addOrMove getWidgetIndex\");\r\n        if (index == currentIndex) {\r\n            Profiler.leave(\"VCssLayout.addOrMove\");\r\n            return;\r\n        }\r\n    } else if (index == getWidgetCount()) {\r\n        Profiler.enter(\"VCssLayout.addOrMove add\");\r\n        add(child);\r\n        Profiler.leave(\"VCssLayout.addOrMove add\");\r\n        Profiler.leave(\"VCssLayout.addOrMove\");\r\n        return;\r\n    }\r\n    Profiler.enter(\"VCssLayout.addOrMove insert\");\r\n    insert(child, index);\r\n    Profiler.leave(\"VCssLayout.addOrMove insert\");\r\n    Profiler.leave(\"VCssLayout.addOrMove\");\r\n}"
}, {
	"Path": "com.vaadin.ui.components.grid.GridMultiSelect.deselect",
	"Comment": "selects the given item. depending on the implementation, may cause otheritems to be deselected. if the item is already selected, does nothing.",
	"Method": "void deselect(T item){\r\n    model.deselect(item);\r\n}"
}, {
	"Path": "com.vaadin.ui.PopupView.setHideOnMouseOut",
	"Comment": "should the popup automatically hide when the user takes the mouse cursorout of the popup area? if this is false, the user must click outside thepopup to close it. the default is true.",
	"Method": "void setHideOnMouseOut(boolean hideOnMouseOut){\r\n    getState().hideOnMouseOut = hideOnMouseOut;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.getSelectedRows",
	"Comment": "keep this javadoc in sync with selectionmodel.getselectedrows",
	"Method": "Collection<Object> getSelectedRows(Collection<Object> getSelectedRows,Collection<Object> getSelectedRows,Collection<Object> getSelectedRows,Collection<Object> getSelectedRows,Collection<Object> getSelectedRows){\r\n    return getSelectionModel().getSelectedRows();\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinPortletSession.setSharedRenderParameter",
	"Comment": "sets a shared portlet parameter.internally, an action may be created and opened, as shared parameterscannot be set directly from all types of requests.setting shared render parameters from background threads is notsupported.the parameters and values need to be kept in the context until sent. anymemory leaks if the action fails are limited to the session.shared parameters set or read by a portlet need to be declared inportlet.xml .",
	"Method": "void setSharedRenderParameter(UI uI,String name,String value){\r\n    PortletResponse response = getCurrentResponse();\r\n    if (response instanceof MimeResponse) {\r\n        String actionKey = \"\" + System.currentTimeMillis();\r\n        while (sharedParameterActionNameMap.containsKey(actionKey)) {\r\n            actionKey += \".\";\r\n        }\r\n        PortletURL actionUrl = generateActionURL(actionKey);\r\n        if (actionUrl != null) {\r\n            sharedParameterActionNameMap.put(actionKey, name);\r\n            sharedParameterActionValueMap.put(actionKey, value);\r\n            uI.getPage().setLocation(actionUrl.toString());\r\n        } else {\r\n            throw new IllegalStateException(\"Shared parameters can only be set from a portlet request\");\r\n        }\r\n    } else if (response instanceof StateAwareResponse) {\r\n        ((StateAwareResponse) response).setRenderParameter(name, value);\r\n    } else {\r\n        throw new IllegalStateException(\"Shared parameters can only be set from a portlet request\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignContext.getComponentByLocalId",
	"Comment": "returns a component having the specified local id. if no component isfound, returns null.",
	"Method": "Component getComponentByLocalId(String localId){\r\n    return localIdToComponent.get(localId);\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignContext.getDefaultInstance",
	"Comment": "returns the default instance for the given class. the instance must notbe modified by the caller.",
	"Method": "T getDefaultInstance(Component component,Component getDefaultInstance,Class<? extends Component> componentClass){\r\n    Component instance = instanceCache.get(componentClass);\r\n    if (instance == null) {\r\n        instance = instantiateClass(componentClass.getName());\r\n        instanceCache.put(componentClass, instance);\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "com.vaadin.client.renderers.DateRenderer.setTimeZone",
	"Comment": "sets the time zone of the the date. by default uses the time zone of thebrowser.",
	"Method": "void setTimeZone(TimeZone timeZone){\r\n    if (timeZone == null) {\r\n        throw new IllegalArgumentException(\"Timezone should not be null\");\r\n    }\r\n    this.timeZone = timeZone;\r\n}"
}, {
	"Path": "com.vaadin.server.ServiceInitEvent.getAddedDependencyFilters",
	"Comment": "gets an unmodifiable list of all dependency filters that have been addedfor the service.",
	"Method": "List<DependencyFilter> getAddedDependencyFilters(){\r\n    return Collections.unmodifiableList(addedDependencyFilters);\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractMedia.addSource",
	"Comment": "adds an alternative media file to the sources list. which of the sourcesis used is selected by the browser depending on which file formats itsupports. seewikipediafor a table of formats supported by different browsers.",
	"Method": "void addSource(Resource source){\r\n    if (source != null) {\r\n        List<URLReference> sources = getState().sources;\r\n        sources.add(new ResourceReference(source, this, Integer.toString(sources.size())));\r\n        getState().sourceTypes.add(source.getMIMEType());\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.Util.findWidget",
	"Comment": "helper method to find first instance of given widget type found bytraversing dom upwards from given element.",
	"Method": "T findWidget(Element element,Class<? extends Widget> class1){\r\n    return WidgetUtil.findWidget(element, class1);\r\n}"
}, {
	"Path": "com.vaadin.v7.data.fieldgroup.FieldGroup.setItemDataSource",
	"Comment": "updates the item that is used by this fieldbinder. rebinds all fields tothe properties in the new item.",
	"Method": "void setItemDataSource(Item itemDataSource){\r\n    this.itemDataSource = itemDataSource;\r\n    bindFields();\r\n}"
}, {
	"Path": "com.vaadin.ui.MenuBar.setHtmlContentAllowed",
	"Comment": "sets whether html is allowed in the item captions. if set to true, thecaptions are passed to the browser as html and the developer isresponsible for ensuring no harmful html is used. if set to false, thecontent is passed to the browser as plain text.",
	"Method": "void setHtmlContentAllowed(boolean htmlContentAllowed){\r\n    this.htmlContentAllowed = htmlContentAllowed;\r\n    markAsDirty();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.setSubmitListener",
	"Comment": "the submit listener is called when the user selects a value from thecalendar either by clicking the day or selects it by keyboard.",
	"Method": "void setSubmitListener(SubmitListener submitListener){\r\n    this.submitListener = submitListener;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponent.hasEqualSize",
	"Comment": "test if the given components has equal size with this instance",
	"Method": "boolean hasEqualSize(Component component){\r\n    return hasEqualWidth(component) && hasEqualHeight(component);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VUpload.setImmediate",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setImmediate(boolean booleanAttribute){\r\n    if (immediate != booleanAttribute) {\r\n        immediate = booleanAttribute;\r\n        if (immediate) {\r\n            fu.sinkEvents(Event.ONCHANGE);\r\n            fu.sinkEvents(Event.ONFOCUS);\r\n        }\r\n    }\r\n    setStyleName(getElement(), CLASSNAME + \"-immediate\", immediate);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheetBase.clearTabKeys",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void clearTabKeys(){\r\n    tabKeys.clear();\r\n    disabledTabKeys.clear();\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractMedia.setSource",
	"Comment": "sets a single media file as the source of the media component.",
	"Method": "void setSource(Resource source){\r\n    clearSources();\r\n    addSource(source);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractSplitPanel.setSecondWidget",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setSecondWidget(Widget w){\r\n    if (secondChild == w) {\r\n        return;\r\n    }\r\n    if (secondChild != null) {\r\n        secondChild.removeFromParent();\r\n    }\r\n    if (w != null) {\r\n        super.add(w, secondContainer);\r\n    }\r\n    secondChild = w;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VButton.isTargetInsideButton",
	"Comment": "check if the event occurred over an element which is part of this button",
	"Method": "boolean isTargetInsideButton(Event event){\r\n    Element to = event.getRelatedTarget();\r\n    return getElement().isOrHasChild(DOM.eventGetTarget(event)) && (to == null || !getElement().isOrHasChild(to));\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheet.getApplicationConnection",
	"Comment": "for internal use only.avoid using this method directly and use appropriate superclass methodswhere applicable.",
	"Method": "ApplicationConnection getApplicationConnection(){\r\n    return client;\r\n}"
}, {
	"Path": "net.openhft.chronicle.queue.ExcerptAppender.writingDocument",
	"Comment": "write an entry at a given index. this can use used for rebuilding a queue, or replication.",
	"Method": "DocumentContext writingDocument(long index){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.vaadin.ui.ConnectorTracker.addMarkedAsDirtyListener",
	"Comment": "add a marked as dirty listener that will be called when a clientconnector is marked as dirty.",
	"Method": "Registration addMarkedAsDirtyListener(MarkedAsDirtyListener listener){\r\n    markedDirtyListeners.add(listener);\r\n    return () -> markedDirtyListeners.remove(listener);\r\n}"
}, {
	"Path": "com.vaadin.client.communication.Heartbeat.schedule",
	"Comment": "updates the schedule of the heartbeat to match the set interval. anegative interval disables the heartbeat.",
	"Method": "void schedule(){\r\n    if (interval > 0) {\r\n        getLogger().fine(\"Scheduling heartbeat in \" + interval + \" seconds\");\r\n        timer.schedule(interval * 1000);\r\n    } else {\r\n        getLogger().fine(\"Disabling heartbeat\");\r\n        timer.cancel();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.server.communication.data.RpcDataProviderExtension.removeRowData",
	"Comment": "informs the client side that rows have been removed from the data source.",
	"Method": "void removeRowData(int index,int count){\r\n    if (rowChanges == null) {\r\n        rowChanges = new ArrayList<Runnable>();\r\n    }\r\n    if (rowChanges.isEmpty()) {\r\n        markAsDirty();\r\n    }\r\n    rowChanges.add(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            rpc.removeRowData(index, count);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.vaadin.v7.server.communication.data.RpcDataProviderExtension.removeRowData",
	"Comment": "informs the client side that rows have been removed from the data source.",
	"Method": "void removeRowData(int index,int count){\r\n    rpc.removeRowData(index, count);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VFilterSelect.setSelectedItemIcon",
	"Comment": "sets the icon uri of the selected item. the icon is shown on the leftside of the item caption text. set the uri to null to remove the icon.",
	"Method": "void setSelectedItemIcon(String iconUri){\r\n    if (iconUri == null || iconUri.isEmpty()) {\r\n        if (selectedItemIcon != null) {\r\n            panel.remove(selectedItemIcon);\r\n            selectedItemIcon = null;\r\n            afterSelectedItemIconChange();\r\n        }\r\n    } else {\r\n        IconWidget newIcon = new IconWidget(client.getIcon(iconUri));\r\n        if (iconEquals(newIcon, selectedItemIcon)) {\r\n            return;\r\n        }\r\n        if (selectedItemIcon != null) {\r\n            panel.remove(selectedItemIcon);\r\n        }\r\n        newIcon.getElement().removeAttribute(\"height\");\r\n        newIcon.getElement().removeAttribute(\"width\");\r\n        newIcon.addDomHandler(new LoadHandler() {\r\n            @Override\r\n            public void onLoad(LoadEvent event) {\r\n                afterSelectedItemIconChange();\r\n            }\r\n        }, LoadEvent.getType());\r\n        panel.insert(newIcon, 0);\r\n        selectedItemIcon = newIcon;\r\n        afterSelectedItemIconChange();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VFilterSelect.setSelectedItemIcon",
	"Comment": "sets the icon uri of the selected item. the icon is shown on the leftside of the item caption text. set the uri to null to remove the icon.",
	"Method": "void setSelectedItemIcon(String iconUri){\r\n    afterSelectedItemIconChange();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.getFooter",
	"Comment": "returns the footer section of this grid. the default footer is empty.",
	"Method": "Footer getFooter(){\r\n    return footer;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheet.isTabSetVisibleBeforeScroller",
	"Comment": "checks whether the tab has been set to visible and the scroller is at thefirst visible tab. that means that the scroller has to be adjusted sothat the tab is visible again.",
	"Method": "boolean isTabSetVisibleBeforeScroller(TabState tabState,int index,Tab tab){\r\n    return isIndexSkippingHiddenTabs() && isScrollerAtFirstVisibleTab() && hasTabChangedVisibility(tabState, tab) && scrolledOutOfView(index);\r\n}"
}, {
	"Path": "net.openhft.chronicle.queue.impl.single.Pretoucher.assignCurrentCycle",
	"Comment": "used by the pretoucher to acquire the next cycle file, but does not do the roll. if configured,we acquire the cycle file early",
	"Method": "void assignCurrentCycle(){\r\n    final int qCycle = queue.cycle(pretouchTimeProvider);\r\n    if (qCycle != currentCycle) {\r\n        releaseResources();\r\n        queue.writeLock().lock();\r\n        try {\r\n            currentCycleWireStore = queue.storeForCycle(qCycle, queue.epoch(), true);\r\n        } finally {\r\n            queue.writeLock().unlock();\r\n        }\r\n        currentCycleMappedBytes = currentCycleWireStore.bytes();\r\n        currentCycle = qCycle;\r\n        if (chunkListener != null)\r\n            currentCycleMappedBytes.setNewChunkListener(chunkListener);\r\n        cycleChangedListener.accept(qCycle);\r\n        if (EARLY_ACQUIRE_NEXT_CYCLE)\r\n            if (Jvm.isDebugEnabled(getClass()))\r\n                Jvm.debug().on(getClass(), \"Pretoucher ROLLING early to next file=\" + currentCycleWireStore.file());\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.handleNavigationMonthMode",
	"Comment": "handle the keyboard navigation when the resolution is set to month.",
	"Method": "boolean handleNavigationMonthMode(int keycode,boolean ctrl,boolean shift){\r\n    if (ctrl) {\r\n        return false;\r\n    } else if (keycode == getPreviousKey()) {\r\n        focusNextYear(1);\r\n        return true;\r\n    } else if (keycode == getForwardKey()) {\r\n        focusNextMonth();\r\n        return true;\r\n    } else if (keycode == getNextKey()) {\r\n        focusPreviousYear(1);\r\n        return true;\r\n    } else if (keycode == getBackwardKey()) {\r\n        focusPreviousMonth();\r\n        return true;\r\n    } else if (keycode == getSelectKey()) {\r\n        value = (Date) focusedDate.clone();\r\n        onSubmit();\r\n        return true;\r\n    } else if (keycode == getResetKey()) {\r\n        focusedDate.setTime(value.getTime());\r\n        renderCalendar();\r\n        return true;\r\n    } else if (keycode == getCloseKey()) {\r\n        onCancel();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.QuerySortOrder.desc",
	"Comment": "creates a new query sort builder with given sorting using descending sortdirection.",
	"Method": "QuerySortOrderBuilder desc(String by){\r\n    return new QuerySortOrderBuilder().thenDesc(by);\r\n}"
}, {
	"Path": "com.vaadin.ui.ProgressBar.getValue",
	"Comment": "gets the value of this progress bar. the value is a floatbetween 0 and 1 where 0 represents no progress at all and 1 representsfully completed.",
	"Method": "float getValue(){\r\n    return getState(false).state;\r\n}"
}, {
	"Path": "com.ryanharter.viewpager.ViewPager.getOffscreenPageLimit",
	"Comment": "returns the number of pages that will be retained to either side of thecurrent page in the view hierarchy in an idle state. defaults to 1.",
	"Method": "int getOffscreenPageLimit(){\r\n    return mOffscreenPageLimit;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.DataProvider.withConfigurableFilter",
	"Comment": "wraps this data provider to create a data provider that supportsprogrammatically setting a filter but no filtering through the query.",
	"Method": "ConfigurableFilterDataProvider<T, Q, C> withConfigurableFilter(SerializableBiFunction<Q, C, F> filterCombiner,ConfigurableFilterDataProvider<T, Void, F> withConfigurableFilter){\r\n    return withConfigurableFilter((queryFilter, configuredFilter) -> {\r\n        assert queryFilter == null : \"Filter from Void query must be null\";\r\n        return configuredFilter;\r\n    });\r\n}"
}, {
	"Path": "com.github.dozermapper.core.loader.xml.XMLParser.read",
	"Comment": "builds object representation of mappings based on content of xml document",
	"Method": "MappingFileData read(Document document){\r\n    DozerBuilder builder = new DozerBuilder(beanContainer, destBeanCreator, propertyDescriptorFactory);\r\n    Element theRoot = document.getDocumentElement();\r\n    NodeList nl = theRoot.getChildNodes();\r\n    for (int i = 0; i < nl.getLength(); i++) {\r\n        Node node = nl.item(i);\r\n        if (node instanceof Element) {\r\n            Element ele = (Element) node;\r\n            log.debug(\"name: {}\", ele.getNodeName());\r\n            if (CONFIGURATION_ELEMENT.equals(ele.getNodeName())) {\r\n                parseConfiguration(ele, builder);\r\n            } else if (MAPPING_ELEMENT.equals(ele.getNodeName())) {\r\n                parseMapping(ele, builder);\r\n            }\r\n        }\r\n    }\r\n    return builder.build();\r\n}"
}, {
	"Path": "bt.data.Bitfield.isComplete",
	"Comment": "shortcut method to find out if the piece has been downloaded.",
	"Method": "boolean isComplete(int pieceIndex){\r\n    PieceStatus pieceStatus = getPieceStatus(pieceIndex);\r\n    return (pieceStatus == PieceStatus.COMPLETE || pieceStatus == PieceStatus.COMPLETE_VERIFIED);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addFooterKeyPressHandler",
	"Comment": "register a footerkeypresshandler to this grid. the event for this handleris fired when a keypress event occurs while cell focus is in the footerof this grid.",
	"Method": "HandlerRegistration addFooterKeyPressHandler(FooterKeyPressHandler handler){\r\n    return addHandler(handler, GridKeyPressEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.escalator.FlyweightCell.getElement",
	"Comment": "returns the element of the cell. can be either a td elementor a th element.",
	"Method": "TableCellElement getElement(){\r\n    assertSetup();\r\n    return element;\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.getRowStyleGenerator",
	"Comment": "gets the style generator that is used for generating styles for rows.",
	"Method": "RowStyleGenerator getRowStyleGenerator(){\r\n    return rowStyleGenerator;\r\n}"
}, {
	"Path": "com.vaadin.data.validator.RangeValidator.isMinValueIncluded",
	"Comment": "returns whether the minimum value is part of the accepted range.",
	"Method": "boolean isMinValueIncluded(){\r\n    return minValueIncluded;\r\n}"
}, {
	"Path": "com.vaadin.shared.ui.MarginInfo.hasRight",
	"Comment": "checks if this margininfo object has the right edge margin enabled.",
	"Method": "boolean hasRight(){\r\n    return (bitMask & RIGHT) == RIGHT;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.setFocusOutListener",
	"Comment": "a focus out listener is triggered when the panel loosed focus. this canhappen either after a user clicks outside the panel or tabs out.",
	"Method": "void setFocusOutListener(FocusOutListener listener){\r\n    focusOutListener = listener;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.MethodProperty.getValue",
	"Comment": "gets the value stored in the property. the value is resolved by callingthe specified getter method with the argument specified at instantiation.",
	"Method": "T getValue(){\r\n    try {\r\n        if (instance == null) {\r\n            return null;\r\n        } else {\r\n            return (T) getMethod.invoke(instance, getArgs);\r\n        }\r\n    } catch (final Throwable e) {\r\n        throw new MethodException(this, e);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.addColumnResizeListener",
	"Comment": "adds a column resize listener to the table. a column resize listener iscalled when a user resizes a columns width.",
	"Method": "void addColumnResizeListener(ColumnResizeListener listener){\r\n    addListener(TableConstants.COLUMN_RESIZE_EVENT_ID, ColumnResizeEvent.class, listener, ColumnResizeEvent.COLUMN_RESIZE_METHOD);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.selectDate",
	"Comment": "sets the selection highlight to a given day in the current view",
	"Method": "void selectDate(Date date){\r\n    if (selectedDay != null) {\r\n        selectedDay.removeStyleDependentName(CN_SELECTED);\r\n        Roles.getGridcellRole().removeAriaSelectedState(selectedDay.getElement());\r\n    }\r\n    int rowCount = days.getRowCount();\r\n    for (int i = 0; i < rowCount; i++) {\r\n        int cellCount = days.getCellCount(i);\r\n        for (int j = 0; j < cellCount; j++) {\r\n            Widget widget = days.getWidget(i, j);\r\n            if (widget != null && widget instanceof Day) {\r\n                Day curday = (Day) widget;\r\n                if (curday.getDate().equals(date)) {\r\n                    curday.addStyleDependentName(CN_SELECTED);\r\n                    selectedDay = curday;\r\n                    Roles.getGridcellRole().setAriaSelectedState(selectedDay.getElement(), SelectedValue.TRUE);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.communication.DefaultConnectionStateHandler.showDialog",
	"Comment": "called when the reconnect dialog should be shown. this is typically whenn seconds has passed since a problem with the connection has beendetected",
	"Method": "void showDialog(){\r\n    reconnectDialog.setReconnecting(true);\r\n    reconnectDialog.show(connection);\r\n    connection.getLoadingIndicator().hide();\r\n}"
}, {
	"Path": "bt.magnet.MagnetUriParser.lenientParser",
	"Comment": "creates a parser, that will suppress parsing errors,that do not prevent identification of torrent id,e.g. invalid peer addresses.",
	"Method": "MagnetUriParser lenientParser(){\r\n    return new MagnetUriParser(true);\r\n}"
}, {
	"Path": "com.vaadin.ui.components.colorpicker.ColorPickerPreview.getUserErrorText",
	"Comment": "get the client error message text for color input parsing error.",
	"Method": "String getUserErrorText(String value){\r\n    return value.isEmpty() ? \"Input cannot be empty\" : \"Input '\".concat(value).concat(\"' is not in any recognized format\");\r\n}"
}, {
	"Path": "com.vaadin.client.communication.XhrConnectionError.getException",
	"Comment": "returns the exception which caused the problem, if available.",
	"Method": "Throwable getException(){\r\n    return exception;\r\n}"
}, {
	"Path": "com.vaadin.ui.RichTextArea.selectAll",
	"Comment": "selects all text in the rich text area. as a side effect, focuses therich text area.",
	"Method": "void selectAll(){\r\n    getRpcProxy(RichTextAreaClientRpc.class).selectAll();\r\n    focus();\r\n}"
}, {
	"Path": "com.ryanharter.viewpager.ViewPager.addTouchables",
	"Comment": "we only want the current page that is being shown to be touchable.",
	"Method": "void addTouchables(ArrayList<View> views){\r\n    for (int i = 0; i < getChildCount(); i++) {\r\n        final View child = getChildAt(i);\r\n        if (child.getVisibility() == VISIBLE) {\r\n            ItemInfo ii = infoForChild(child);\r\n            if (ii != null && ii.position == mCurItem) {\r\n                child.addTouchables(views);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.DefaultErrorHandler.findAbstractComponent",
	"Comment": "returns the abstractcomponent associated with the given error if such canbe found.",
	"Method": "AbstractComponent findAbstractComponent(com.vaadin.server.ErrorEvent event){\r\n    if (event instanceof ConnectorErrorEvent) {\r\n        Component c = findComponent(((ConnectorErrorEvent) event).getConnector());\r\n        if (c instanceof AbstractComponent) {\r\n            return (AbstractComponent) c;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.QuerySortOrder.asc",
	"Comment": "creates a new query sort builder with given sorting using ascending sortdirection.",
	"Method": "QuerySortOrderBuilder asc(String by){\r\n    return new QuerySortOrderBuilder().thenAsc(by);\r\n}"
}, {
	"Path": "com.vaadin.server.WebBrowser.getScreenHeight",
	"Comment": "gets the height of the screen in pixels. this is the full screenresolution and not the height available for the application.",
	"Method": "int getScreenHeight(){\r\n    return screenHeight;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractListing.removeDataGenerator",
	"Comment": "removes the given data generator from this listing. if this listing doesnot have the generator, does nothing.",
	"Method": "void removeDataGenerator(DataGenerator<T> generator){\r\n    getDataCommunicator().removeDataGenerator(generator);\r\n}"
}, {
	"Path": "com.vaadin.data.TreeData.removeItem",
	"Comment": "remove a given item from this structure. additionally, this willrecursively remove any descendants of the item.",
	"Method": "TreeData<T> removeItem(T item){\r\n    if (!contains(item)) {\r\n        throw new IllegalArgumentException(\"Item '\" + item + \"' not in the hierarchy\");\r\n    }\r\n    new ArrayList(getChildren(item)).forEach(child -> removeItem(child));\r\n    itemToWrapperMap.get(itemToWrapperMap.get(item).getParent()).removeChild(item);\r\n    if (item != null) {\r\n        itemToWrapperMap.remove(item);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.vaadin.navigator.ViewBeforeLeaveEvent.navigate",
	"Comment": "performs the navigation which triggered the event in the first place.",
	"Method": "void navigate(){\r\n    if (navigateRun) {\r\n        throw new IllegalStateException(\"navigate() can only be called once\");\r\n    }\r\n    action.run();\r\n    navigateRun = true;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.SQLContainer.commit",
	"Comment": "commits all the changes, additions and removals made to the items of thiscontainer.",
	"Method": "void commit(){\r\n    try {\r\n        getLogger().log(Level.FINER, \"Commiting changes through delegate...\");\r\n        queryDelegate.beginTransaction();\r\n        for (RowItem item : removedItems.values()) {\r\n            try {\r\n                if (!queryDelegate.removeRow(item)) {\r\n                    throw new SQLException(\"Removal failed for row with ID: \" + item.getId());\r\n                }\r\n            } catch (IllegalArgumentException e) {\r\n                throw new SQLException(\"Removal failed for row with ID: \" + item.getId(), e);\r\n            }\r\n        }\r\n        for (RowItem item : modifiedItems) {\r\n            if (!removedItems.containsKey(item.getId())) {\r\n                if (queryDelegate.storeRow(item) > 0) {\r\n                    item.commit();\r\n                } else {\r\n                    queryDelegate.rollback();\r\n                    refresh();\r\n                    throw new ConcurrentModificationException(\"Item with the ID '\" + item.getId() + \"' has been externally modified.\");\r\n                }\r\n            }\r\n        }\r\n        for (RowItem item : addedItems) {\r\n            queryDelegate.storeRow(item);\r\n        }\r\n        queryDelegate.commit();\r\n        removedItems.clear();\r\n        addedItems.clear();\r\n        modifiedItems.clear();\r\n        refresh();\r\n        if (notificationsEnabled) {\r\n            CacheFlushNotifier.notifyOfCacheFlush(this);\r\n        }\r\n    } catch (SQLException e) {\r\n        queryDelegate.rollback();\r\n        throw e;\r\n    } catch (OptimisticLockException e) {\r\n        queryDelegate.rollback();\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractDateField.setShowISOWeekNumbers",
	"Comment": "sets the visibility of iso 8601 week numbers in the date selector. iso8601 defines that a week always starts with a monday so the week numbersare only shown if this is the case.",
	"Method": "void setShowISOWeekNumbers(boolean showWeekNumbers){\r\n    getState().showISOWeekNumbers = showWeekNumbers;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.splitpanel.AbstractSplitPanelConnector.handleSingleComponentMove",
	"Comment": "handles the case when there is only one child component and thatcomponent is moved between firstsecond. this does not trigger ahierarchy change event as the list of children contains the samecomponent in both cases.",
	"Method": "void handleSingleComponentMove(){\r\n    if (getChildComponents().size() == 1) {\r\n        Widget stateFirstChild = null;\r\n        Widget stateSecondChild = null;\r\n        if (getState().firstChild != null) {\r\n            stateFirstChild = ((ComponentConnector) getState().firstChild).getWidget();\r\n        }\r\n        if (getState().secondChild != null) {\r\n            stateSecondChild = ((ComponentConnector) getState().secondChild).getWidget();\r\n        }\r\n        if (stateFirstChild == getWidget().getSecondWidget() || stateSecondChild == getWidget().getFirstWidget()) {\r\n            handleHierarchyChange();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.server.communication.data.RpcDataProviderExtension.columnsRemoved",
	"Comment": "informs this data provider that given columns have been removed fromgrid.",
	"Method": "void columnsRemoved(List<Column> removedColumns){\r\n    for (GridValueChangeListener l : activeItemHandler.getValueChangeListeners()) {\r\n        l.removeColumns(removedColumns);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.SQLContainer.indexInModifiedCache",
	"Comment": "returns the index of the item with the given itemid for the modifiedcache.",
	"Method": "int indexInModifiedCache(Object itemId){\r\n    for (int ix = 0; ix < modifiedItems.size(); ix++) {\r\n        RowItem item = modifiedItems.get(ix);\r\n        if (item.getId().equals(itemId)) {\r\n            return ix;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VScrollTable.updateActionMap",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void updateActionMap(UIDL mainUidl){\r\n    UIDL actionsUidl = mainUidl.getChildByTagName(\"actions\");\r\n    if (actionsUidl == null) {\r\n        return;\r\n    }\r\n    for (final Object child : actionsUidl) {\r\n        final UIDL action = (UIDL) child;\r\n        final String key = action.getStringAttribute(\"key\");\r\n        final String caption = action.getStringAttribute(\"caption\");\r\n        actionMap.put(key + \"_c\", caption);\r\n        if (action.hasAttribute(\"icon\")) {\r\n            actionMap.put(key + \"_i\", action.getStringAttribute(\"icon\"));\r\n        } else {\r\n            actionMap.remove(key + \"_i\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VTabsheetBase.setReadonly",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setReadonly(boolean readonly){\r\n    this.readonly = readonly;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addBodyDoubleClickHandler",
	"Comment": "register a bodydoubleclickhandler to this grid. the event for thishandler is fired when a double click event occurs in the body of thisgrid.",
	"Method": "HandlerRegistration addBodyDoubleClickHandler(BodyDoubleClickHandler handler){\r\n    return addHandler(handler, GridDoubleClickEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.ui.ComboBox.isScrollToSelectedItem",
	"Comment": "returns true if the select should find the page with the selected itemwhen opening the popup.",
	"Method": "boolean isScrollToSelectedItem(){\r\n    return getState(false).scrollToSelectedItem;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.handleNavigationDayMode",
	"Comment": "handle keyboard navigation what the resolution is set to day.",
	"Method": "boolean handleNavigationDayMode(int keycode,boolean ctrl,boolean shift){\r\n    if (ctrl) {\r\n        return false;\r\n    }\r\n    if (keycode == getForwardKey() && !shift) {\r\n        focusNextDay(1);\r\n        return true;\r\n    } else if (keycode == getBackwardKey() && !shift) {\r\n        focusPreviousDay(1);\r\n        return true;\r\n    } else if (keycode == getNextKey() && !shift) {\r\n        focusNextDay(7);\r\n        return true;\r\n    } else if (keycode == getPreviousKey() && !shift) {\r\n        focusPreviousDay(7);\r\n        return true;\r\n    } else if (keycode == getSelectKey() && !shift) {\r\n        selectFocused();\r\n        onSubmit();\r\n        return true;\r\n    } else if (keycode == getCloseKey()) {\r\n        onCancel();\r\n        return true;\r\n    } else if (shift && keycode == getForwardKey()) {\r\n        focusNextMonth();\r\n        return true;\r\n    } else if (shift && keycode == getBackwardKey()) {\r\n        focusPreviousMonth();\r\n        return true;\r\n    } else if (shift && keycode == getPreviousKey()) {\r\n        focusNextYear(1);\r\n        return true;\r\n    } else if (shift && keycode == getNextKey()) {\r\n        focusPreviousYear(1);\r\n        return true;\r\n    } else if (keycode == getResetKey() && !shift) {\r\n        focusedDate = new FocusedDate(value.getYear(), value.getMonth(), value.getDate());\r\n        displayedMonth = new FocusedDate(value.getYear(), value.getMonth(), 1);\r\n        renderCalendar();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.server.FileResource.setCacheTime",
	"Comment": "sets the length of cache expiration time. this gives the adapter thepossibility cache streams sent to the client. the caching may be made inadapter or at the client if the client supports caching. zero or negativevalue disables the caching of this stream.",
	"Method": "void setCacheTime(long cacheTime){\r\n    this.cacheTime = cacheTime;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.aria.AriaHelper.setVisibleForAssistiveDevicesOnly",
	"Comment": "allows to move an element out of the visible area of the browser window.this makes it possible to have additional information for an assistivedevice, that is not in the way for visual users.",
	"Method": "void setVisibleForAssistiveDevicesOnly(Element element,boolean assistiveOnly){\r\n    if (assistiveOnly) {\r\n        element.addClassName(ASSISTIVE_DEVICE_ONLY_STYLE);\r\n    } else {\r\n        element.removeClassName(ASSISTIVE_DEVICE_ONLY_STYLE);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addHeaderClickHandler",
	"Comment": "register a headerclickhandler to this grid. the event for this handler isfired when a click event occurs in the header of this grid.",
	"Method": "HandlerRegistration addHeaderClickHandler(HeaderClickHandler handler){\r\n    return addHandler(handler, GridClickEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.client.communication.MessageSender.setConnection",
	"Comment": "sets the application connection this instance is connected to. calledinternally by the framework.",
	"Method": "void setConnection(ApplicationConnection connection){\r\n    this.connection = connection;\r\n    xhrConnection.setConnection(connection);\r\n}"
}, {
	"Path": "com.vaadin.ui.Embedded.setSource",
	"Comment": "sets the object source resource. the dimensions are assumed if possible.the type is guessed from resource.",
	"Method": "void setSource(Resource source){\r\n    if (source != null && !source.equals(getSource())) {\r\n        setResource(\"src\", source);\r\n        final String mt = source.getMIMEType();\r\n        if (getMimeType() == null) {\r\n            getState().mimeType = mt;\r\n        }\r\n        if (mt.equals(\"image/svg+xml\")) {\r\n            getState().type = TYPE_OBJECT;\r\n        } else if ((mt.substring(0, mt.indexOf('/')).equalsIgnoreCase(\"image\"))) {\r\n            getState().type = TYPE_IMAGE;\r\n        } else {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.updateSelectedIconPosition",
	"Comment": "positions the icon vertically in the middle. should be called after theicon has loaded",
	"Method": "void updateSelectedIconPosition(){\r\n    int availableHeight = 0;\r\n    availableHeight = getOffsetHeight();\r\n    int iconHeight = WidgetUtil.getRequiredHeight(selectedItemIcon);\r\n    int marginTop = (availableHeight - iconHeight) / 2;\r\n    selectedItemIcon.getElement().getStyle().setMarginTop(marginTop, Unit.PX);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.renderers.NumberRenderer.getFormat",
	"Comment": "gets the number format that the number should be formatted in.",
	"Method": "NumberFormat getFormat(){\r\n    return format;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractMultiSelect.readItem",
	"Comment": "reads an item from a design and inserts it into the data source.hierarchical select components should override this method to recursivelyrecursively read any child items as well.",
	"Method": "T readItem(Element child,Set<T> selected,DesignContext context){\r\n    T item = readItem(child, context);\r\n    if (child.hasAttr(\"selected\")) {\r\n        selected.add(item);\r\n    }\r\n    return item;\r\n}"
}, {
	"Path": "com.vaadin.server.CompositeErrorMessage.addErrorMessage",
	"Comment": "adds a error message into this composite message. updates the levelfield.",
	"Method": "void addErrorMessage(ErrorMessage error){\r\n    if (error != null && !getCauses().contains(error)) {\r\n        addCause(error);\r\n        if (error.getErrorLevel().intValue() > getErrorLevel().intValue()) {\r\n            setErrorLevel(error.getErrorLevel());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.componentlocator.SelectorPredicate.extractPredicates",
	"Comment": "generates a list of predicates from a single predicate string.",
	"Method": "List<SelectorPredicate> extractPredicates(String path){\r\n    List<SelectorPredicate> predicates = new ArrayList();\r\n    String predicateStr = extractPredicateString(path);\r\n    if (null == predicateStr || predicateStr.isEmpty()) {\r\n        return predicates;\r\n    }\r\n    List<String> input = readPredicatesFromString(predicateStr);\r\n    for (String s : input) {\r\n        SelectorPredicate p = new SelectorPredicate();\r\n        s = s.trim();\r\n        try {\r\n            p.index = Integer.parseInt(s);\r\n            predicates.add(p);\r\n            continue;\r\n        } catch (Exception e) {\r\n            p.index = -1;\r\n        }\r\n        int idx = LocatorUtil.indexOfIgnoringQuoted(s, '=');\r\n        if (idx < 0) {\r\n            continue;\r\n        }\r\n        p.name = s.substring(0, idx);\r\n        p.value = s.substring(idx + 1);\r\n        if (p.value.equals(\"?\")) {\r\n            p.wildcard = true;\r\n            p.value = null;\r\n        } else {\r\n            p.value = unquote(p.value);\r\n        }\r\n        predicates.add(p);\r\n    }\r\n    for (int i = 0, l = predicates.size(); i < l - 1; ++i) {\r\n        if (predicates.get(i).index > -1) {\r\n            predicates.add(predicates.remove(i));\r\n            --i;\r\n            --l;\r\n        }\r\n    }\r\n    return predicates;\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractComponent.hasEqualHeight",
	"Comment": "test if the given component has equal height with this instance",
	"Method": "boolean hasEqualHeight(Component component){\r\n    return getHeight() == component.getHeight() && getHeightUnits().equals(component.getHeightUnits());\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VComboBox.setEmptySelectionCaption",
	"Comment": "sets the empty selection caption for this vcombobox. the text isdisplayed in the text input when nothing is selected.",
	"Method": "void setEmptySelectionCaption(String emptySelectionCaption){\r\n    this.emptySelectionCaption = emptySelectionCaption;\r\n    if (selectedOptionKey == null) {\r\n        setText(emptySelectionCaption);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.OptionGroup.setItemEnabled",
	"Comment": "sets an item disabled or enabled. in the multiselect mode, a disableditem cannot be selected or deselected by the user. in the singleselection mode, a disable item cannot be selected.however, programmatical selection or deselection of an disable item ispossible. by default, items are enabled.",
	"Method": "void setItemEnabled(Object itemId,boolean enabled){\r\n    if (itemId != null) {\r\n        if (enabled) {\r\n            disabledItemIds.remove(itemId);\r\n        } else {\r\n            disabledItemIds.add(itemId);\r\n        }\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractListing.writeItem",
	"Comment": "writes a data source item to a design. hierarchical select componentsshould override this method to recursively write any child items as well.",
	"Method": "Element writeItem(Element design,T item,DesignContext context){\r\n    Element element = design.appendElement(\"option\");\r\n    String caption = getItemCaptionGenerator().apply(item);\r\n    if (caption != null) {\r\n        element.html(DesignFormatter.encodeForTextNode(caption));\r\n    } else {\r\n        element.html(DesignFormatter.encodeForTextNode(item.toString()));\r\n    }\r\n    element.attr(\"item\", serializeDeclarativeRepresentation(item));\r\n    Resource icon = getItemIconGenerator().apply(item);\r\n    if (icon != null) {\r\n        DesignAttributeHandler.writeAttribute(\"icon\", element.attributes(), icon, null, Resource.class, context);\r\n    }\r\n    return element;\r\n}"
}, {
	"Path": "com.vaadin.ui.PopupView.iterator",
	"Comment": "this class only contains other components when the popup is showing.",
	"Method": "Iterator<Component> iterator(){\r\n    if (visibleComponent != null) {\r\n        return Collections.singletonList(visibleComponent).iterator();\r\n    } else {\r\n        return Collections.<Component>emptyList().iterator();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.communication.ServerRpcQueue.removeMatching",
	"Comment": "removes any pending invocation of the given method from the queue.",
	"Method": "void removeMatching(MethodInvocation invocation){\r\n    Iterator<MethodInvocation> iter = pendingInvocations.values().iterator();\r\n    while (iter.hasNext()) {\r\n        MethodInvocation mi = iter.next();\r\n        if (mi.equals(invocation)) {\r\n            iter.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.events.ColumnReorderEvent.isUserOriginated",
	"Comment": "check whether this event originated from the user reordering columns orvia api call.",
	"Method": "boolean isUserOriginated(){\r\n    return userOriginated;\r\n}"
}, {
	"Path": "com.vaadin.server.communication.PushHandler.setLongPollingSuspendTimeout",
	"Comment": "sets the timeout used for suspend calls when using long polling.if you are using a proxy with a defined idle timeout, set the suspendtimeout to a value smaller than the proxy timeout so that the server isaware of a reconnect taking place.",
	"Method": "void setLongPollingSuspendTimeout(int longPollingSuspendTimeout){\r\n    this.longPollingSuspendTimeout = longPollingSuspendTimeout;\r\n}"
}, {
	"Path": "com.vaadin.client.communication.MessageHandler.getPushId",
	"Comment": "gets the push connection identifier for this session. used whenestablishing a push connection with the client.",
	"Method": "String getPushId(){\r\n    return pushId;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.selectDate",
	"Comment": "sets the selection highlight to a given day in the current view",
	"Method": "void selectDate(Date date){\r\n    if (selectedDay != null) {\r\n        selectedDay.removeStyleDependentName(CN_SELECTED);\r\n        Roles.getGridcellRole().removeAriaSelectedState(selectedDay.getElement());\r\n    }\r\n    int rowCount = days.getRowCount();\r\n    for (int i = 0; i < rowCount; i++) {\r\n        int cellCount = days.getCellCount(i);\r\n        for (int j = 0; j < cellCount; j++) {\r\n            Widget widget = days.getWidget(i, j);\r\n            if (widget instanceof VAbstractCalendarPanel.Day) {\r\n                Day curday = (Day) widget;\r\n                if (curday.getDate().equals(date)) {\r\n                    curday.addStyleDependentName(CN_SELECTED);\r\n                    selectedDay = curday;\r\n                    Roles.getGridcellRole().setAriaSelectedState(selectedDay.getElement(), SelectedValue.TRUE);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.folioreader.view.VerticalViewPager.canScroll",
	"Comment": "tests scrollability within child views of v given a delta of dx.",
	"Method": "boolean canScroll(View v,boolean checkV,int dy,int x,int y,boolean canScroll){\r\n    if (v instanceof ViewGroup) {\r\n        final ViewGroup group = (ViewGroup) v;\r\n        final int scrollX = v.getScrollX();\r\n        final int scrollY = v.getScrollY();\r\n        final int count = group.getChildCount();\r\n        for (int i = count - 1; i >= 0; i--) {\r\n            final View child = group.getChildAt(i);\r\n            if (y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && canScroll(child, true, dy, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return checkV && ViewCompat.canScrollVertically(v, -dy);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.components.calendar.event.BasicEventProvider.fireEventSetChange",
	"Comment": "fires a eventsetchange event. the event is fired when either an event isadded or removed to the event provider",
	"Method": "void fireEventSetChange(){\r\n    EventSetChangeEvent event = new EventSetChangeEvent(this);\r\n    for (EventSetChangeListener listener : listeners) {\r\n        listener.eventSetChange(event);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.connectors.grid.GridConnector.updateColumns",
	"Comment": "updates the widgets columns to match the map in this connector.",
	"Method": "void updateColumns(){\r\n    List<Column<?, JsonObject>> currentColumns = getWidget().getColumns();\r\n    List<CustomColumn> columnOrder = getState().columnOrder.stream().map(this::getColumn).collect(Collectors.toList());\r\n    if (isColumnOrderCorrect(currentColumns, columnOrder)) {\r\n        return;\r\n    }\r\n    Grid<JsonObject> grid = getWidget();\r\n    currentColumns.stream().filter(col -> !(columnOrder.contains(col) || col instanceof SelectionColumn)).forEach(grid::removeColumn);\r\n    grid.addColumns(columnOrder.stream().filter(col -> !currentColumns.contains(col)).toArray(CustomColumn[]::new));\r\n    grid.setColumnOrder(columnOrder.toArray(new CustomColumn[columnOrder.size()]));\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Label.setValue",
	"Comment": "set the value of the label. value of the label is the xml contents of thelabel. since vaadin 7.2, changing the value of label instance with thatmethod will fire valuechangeevent.",
	"Method": "void setValue(String newStringValue){\r\n    if (getPropertyDataSource() == null) {\r\n        LabelState state = getState(false);\r\n        String oldTextValue = state.text;\r\n        if (!SharedUtil.equals(oldTextValue, newStringValue)) {\r\n            getState().text = newStringValue;\r\n            fireValueChange();\r\n        }\r\n    } else {\r\n        throw new IllegalStateException(\"Label is only a Property.Viewer and cannot update its data source\");\r\n    }\r\n}"
}, {
	"Path": "com.github.dozermapper.core.DozerModule.getPropertyDescriptorCreationStrategies",
	"Comment": "to be implemented by module if it provides any additional strategies to create property description.",
	"Method": "Collection<PropertyDescriptorCreationStrategy> getPropertyDescriptorCreationStrategies(){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widget.escalator.FlyweightCell.assertSetup",
	"Comment": "asserts that the flyweight cell has properly been set up before trying toaccess any of its data.",
	"Method": "void assertSetup(){\r\n    assert currentIterator != null : \"FlyweightCell was not properly \" + \"initialized. This is either a bug in Grid/Escalator \" + \"or a Cell reference has been stored and reused \" + \"inappropriately.\";\r\n}"
}, {
	"Path": "com.vaadin.shared.ui.MarginInfo.hasLeft",
	"Comment": "checks if this margininfo object has the left edge margin enabled.",
	"Method": "boolean hasLeft(){\r\n    return (bitMask & LEFT) == LEFT;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.sqlcontainer.query.generator.filter.QueryBuilder.setStringDecorator",
	"Comment": "allows specification of a custom columnquoter instance that handlesquoting of column names for the current db dialect.",
	"Method": "void setStringDecorator(StringDecorator decorator){\r\n    stringDecorator = decorator;\r\n}"
}, {
	"Path": "com.vaadin.data.provider.HierarchyMapper.registerChildren",
	"Comment": "register parent and children items into inner structures. may beoverridden in subclasses.",
	"Method": "void registerChildren(T parent,List<T> childList){\r\n    childMap.put(parent, new HashSet(childList));\r\n    childList.forEach(x -> parentIdMap.put(getDataProvider().getId(x), parent));\r\n}"
}, {
	"Path": "com.vaadin.ui.Video.setPoster",
	"Comment": "sets the poster image, which is shown in place of the video before theuser presses play.",
	"Method": "void setPoster(Resource poster){\r\n    setResource(VideoConstants.POSTER_RESOURCE, poster);\r\n}"
}, {
	"Path": "com.github.sundeepk.compactcalendarview.CompactCalendarView.setUseThreeLetterAbbreviation",
	"Comment": "compact calendar will use the locale to determine the abbreviation to use as the day column names.the default is to use the default locale and to abbreviate the day names to one character.setting this to true will displace the short weekday string provided by java.",
	"Method": "void setUseThreeLetterAbbreviation(boolean useThreeLetterAbbreviation){\r\n    compactCalendarController.setUseWeekDayAbbreviation(useThreeLetterAbbreviation);\r\n    invalidate();\r\n}"
}, {
	"Path": "com.vaadin.ui.Alignment.isLeft",
	"Comment": "checks if component is aligned to the left of the available space.",
	"Method": "boolean isLeft(){\r\n    return (bitMask & Bits.ALIGNMENT_LEFT) == Bits.ALIGNMENT_LEFT;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VWindow.getAssistivePostfix",
	"Comment": "getter for the text for assistive devices the window caption is postfixedwith.",
	"Method": "String getAssistivePostfix(){\r\n    return assistivePostfix;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VPopupCalendar.setTextFieldEnabled",
	"Comment": "sets the state of the text field of this component. by default the textfield is enabled. disabling it causes only the button for date selectionto be active, thus preventing the user from entering invalid dates. see6790.",
	"Method": "void setTextFieldEnabled(boolean textFieldEnabled){\r\n    this.textFieldEnabled = textFieldEnabled;\r\n    updateTextFieldEnabled();\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.getUI",
	"Comment": "overridden to return a value instead of referring to the parent.",
	"Method": "UI getUI(){\r\n    return this;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.AbstractInMemoryContainer.fireItemRemoved",
	"Comment": "notify item set change listeners that an item has been removed from thecontainer.",
	"Method": "void fireItemRemoved(int position,Object itemId){\r\n    fireItemsRemoved(position, itemId, 1);\r\n}"
}, {
	"Path": "com.github.dozermapper.core.functional_tests.RecursiveTest.testConvertWithSubClass",
	"Comment": "this test should validate dozerxx correct behaviour in front of recursive class references in a subclass. withdozer3.0 the first reference is not used but the recursion is correct on the next levels.",
	"Method": "void testConvertWithSubClass(){\r\n    mapper = getMapper(\"mappings/recursivemappings.xml\", \"mappings/recursivemappings2.xml\");\r\n    ClassAA testAA = createTestClassAA();\r\n    ClassB testClassB = testAA.getSubs().iterator().next();\r\n    assertTrue(testClassB.getParent() == testAA);\r\n    ClassAAPrime testAAPrime = mapper.map(testAA, ClassAAPrime.class, null);\r\n    assertEquals(testAA.getSubs().size(), testAAPrime.getSubs().size());\r\n    ClassBPrime testClassBPrime = testAAPrime.getSubs().iterator().next();\r\n    assertTrue(testClassBPrime.getParent().equals(testAAPrime));\r\n    ClassBPrime testClassBPrime2 = testAAPrime.getSubs().iterator().next();\r\n    assertTrue(testClassBPrime2.getParent() == testAAPrime);\r\n}"
}, {
	"Path": "com.vaadin.data.util.BeanUtil.checkSerialization",
	"Comment": "checks if the object is serializable or not. to be used in assertionchecks only, since the check might be a bit heavyweight.",
	"Method": "boolean checkSerialization(Object obj){\r\n    try {\r\n        ObjectOutputStream dummyObjectOutputStream = new ObjectOutputStream(new OutputStream() {\r\n            @Override\r\n            public void write(int b) {\r\n            }\r\n            @SuppressWarnings(\"NullableProblems\")\r\n            @Override\r\n            public void write(byte[] ignored) {\r\n            }\r\n            @SuppressWarnings(\"NullableProblems\")\r\n            @Override\r\n            public void write(byte[] b, int off, int len) {\r\n            }\r\n        });\r\n        dummyObjectOutputStream.writeObject(obj);\r\n    } catch (Throwable e) {\r\n        throw new AssertionError(\"Formatter supplier should be serializable\", e);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.vaadin.data.util.BeanUtil.checkSerialization",
	"Comment": "checks if the object is serializable or not. to be used in assertionchecks only, since the check might be a bit heavyweight.",
	"Method": "boolean checkSerialization(Object obj){\r\n}"
}, {
	"Path": "com.vaadin.data.util.BeanUtil.checkSerialization",
	"Comment": "checks if the object is serializable or not. to be used in assertionchecks only, since the check might be a bit heavyweight.",
	"Method": "boolean checkSerialization(Object obj){\r\n}"
}, {
	"Path": "com.vaadin.data.util.BeanUtil.checkSerialization",
	"Comment": "checks if the object is serializable or not. to be used in assertionchecks only, since the check might be a bit heavyweight.",
	"Method": "boolean checkSerialization(Object obj){\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignContext.getPackage",
	"Comment": "gets the package corresponding to the give prefix, or nullno package has been registered for the prefix.",
	"Method": "String getPackage(String prefix){\r\n    return prefixToPackage.get(prefix);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.components.calendar.ContainerEventProvider.setEndDateProperty",
	"Comment": "set the property which provides the ending date and time of the event.",
	"Method": "void setEndDateProperty(Object endDateProperty){\r\n    this.endDateProperty = endDateProperty;\r\n}"
}, {
	"Path": "com.vaadin.ui.UI.setCurrent",
	"Comment": "sets the thread local for the current ui. this method is used by theframework to set the current application whenever a new request isprocessed and it is cleared when the request has been processed.the application developer can also use this method to define the currentui outside the normal request handling, e.g. when initiating custombackground threads.the ui is stored using a weak reference to avoid leaking memory in caseit is not explicitly cleared.",
	"Method": "void setCurrent(UI ui){\r\n    CurrentInstance.set(UI.class, ui);\r\n}"
}, {
	"Path": "com.vaadin.util.ReflectTools.findMethod",
	"Comment": "locates the method in the given class. returns null if the method is notfound. throws an exceptionininitializererror if there is a problemlocating the method as this is mainly called from static blocks.",
	"Method": "Method findMethod(Class<?> cls,String methodName,Class<?> parameterTypes){\r\n    try {\r\n        return cls.getDeclaredMethod(methodName, parameterTypes);\r\n    } catch (Exception e) {\r\n        throw new ExceptionInInitializerError(e);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinPortletResponse.escapeHtml",
	"Comment": "perform minimal html escaping similar to guava htmlescapers.",
	"Method": "String escapeHtml(String input){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < input.length(); i++) {\r\n        char c = input.charAt(i);\r\n        switch(c) {\r\n            case '\"':\r\n                sb.append(\"&quot;\");\r\n                break;\r\n            case '\\'':\r\n                sb.append(\"&#39;\");\r\n                break;\r\n            case '&':\r\n                sb.append(\"&amp;\");\r\n                break;\r\n            case '<':\r\n                sb.append(\"&lt;\");\r\n                break;\r\n            case '>':\r\n                sb.append(\"&gt;\");\r\n                break;\r\n            default:\r\n                sb.append(c);\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "net.openhft.chronicle.queue.impl.single.SingleChronicleQueueBuilder.testBlockSize",
	"Comment": "this is for testing only.this makes the block size small to speed up short tests and show up issues which occur when moving from one block to another.using this will be slower when you have many messages, and break when you have large messages.",
	"Method": "SingleChronicleQueueBuilder testBlockSize(){\r\n    return blockSize(64 << 10);\r\n}"
}, {
	"Path": "com.github.dozermapper.core.loader.xml.XMLParserFactory.createDocumentBuilderFactory",
	"Comment": "create a jaxp documentbuilderfactory that this bean definition reader will use for parsing xml documents. can beoverridden in subclasses, adding further initialization of the factory.",
	"Method": "DocumentBuilderFactory createDocumentBuilderFactory(){\r\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\r\n    factory.setValidating(true);\r\n    factory.setNamespaceAware(true);\r\n    factory.setIgnoringElementContentWhitespace(true);\r\n    factory.setAttribute(SCHEMA_FEATURE, true);\r\n    return factory;\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.isShowISOWeekNumbers",
	"Comment": "returns whether iso 8601 week numbers should be shown in the valueselector or not. iso 8601 defines that a week always starts with a mondayso the week numbers are only shown if this is the case.",
	"Method": "boolean isShowISOWeekNumbers(){\r\n    return showISOWeekNumbers;\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.ContainerHierarchicalWrapper.removeItem",
	"Comment": "removes an item specified by the itemid from the underlying container andfrom the hierarchy.",
	"Method": "boolean removeItem(Object itemId){\r\n    final boolean success = container.removeItem(itemId);\r\n    if (!hierarchical && success) {\r\n        removeFromHierarchyWrapper(itemId);\r\n    }\r\n    return success;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.addSpacerVisibilityChangedHandler",
	"Comment": "adds a spacer visibility changed handler to the underlying escalator.",
	"Method": "HandlerRegistration addSpacerVisibilityChangedHandler(SpacerVisibilityChangedHandler handler){\r\n    return escalator.addHandler(handler, SpacerVisibilityChangedEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.ui.AbstractSingleSelect.readItem",
	"Comment": "reads an item from a design and inserts it into the data source.hierarchical select components should override this method to recursivelyrecursively read any child items as well.",
	"Method": "T readItem(Element child,Set<T> selected,DesignContext context){\r\n    T item = readItem(child, context);\r\n    if (child.hasAttr(\"selected\")) {\r\n        selected.add(item);\r\n    }\r\n    return item;\r\n}"
}, {
	"Path": "com.vaadin.client.EventHelper.updateFocusHandler",
	"Comment": "adds or removes a focus handler depending on if the connector has focuslisteners on the server side or not.",
	"Method": "HandlerRegistration updateFocusHandler(T connector,HandlerRegistration handlerRegistration,HandlerRegistration updateFocusHandler,T connector,HandlerRegistration handlerRegistration,Widget widget){\r\n    return updateHandler(connector, connector, FOCUS, handlerRegistration, FocusEvent.getType(), widget);\r\n}"
}, {
	"Path": "com.vaadin.client.ui.dd.VDragAndDropManager.findDragTarget",
	"Comment": "first seeks the widget from this element, then iterates widgets until oneimplement hasdrophandler. returns drophandler from that.",
	"Method": "VDropHandler findDragTarget(Element element){\r\n    try {\r\n        Widget w = WidgetUtil.findWidget(element);\r\n        if (w == null) {\r\n            return null;\r\n        }\r\n        while (!(w instanceof VHasDropHandler) || !isDropEnabled((VHasDropHandler) w)) {\r\n            w = w.getParent();\r\n            if (w == null) {\r\n                break;\r\n            }\r\n        }\r\n        if (w == null) {\r\n            return null;\r\n        } else {\r\n            VDropHandler dh = ((VHasDropHandler) w).getDropHandler();\r\n            return dh;\r\n        }\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.orderedlayout.VAbstractOrderedLayout.updateExpandedSizes",
	"Comment": "assigns relative sizes to the children that should expand based on theirexpand ratios.",
	"Method": "void updateExpandedSizes(){\r\n    if (expandWrapper == null) {\r\n        expandWrapper = DOM.createDiv();\r\n        expandWrapper.setClassName(\"v-expand\");\r\n        for (Widget widget : getChildren()) {\r\n            orphan(widget);\r\n        }\r\n        while (getElement().getChildCount() > 0) {\r\n            Node el = getElement().getChild(0);\r\n            expandWrapper.appendChild(el);\r\n        }\r\n        getElement().appendChild(expandWrapper);\r\n        for (Widget widget : getChildren()) {\r\n            adopt(widget);\r\n        }\r\n    }\r\n    double total = 0;\r\n    for (Slot slot : widgetToSlot.values()) {\r\n        total += slot.getExpandRatio();\r\n    }\r\n    for (Slot slot : widgetToSlot.values()) {\r\n        Element slotElement = slot.getElement();\r\n        slotElement.removeAttribute(\"aria-hidden\");\r\n        Style slotStyle = slotElement.getStyle();\r\n        slotStyle.clearVisibility();\r\n        slotStyle.clearMarginLeft();\r\n        slotStyle.clearMarginTop();\r\n        if (slot.getExpandRatio() != 0) {\r\n            double size = 100 * (slot.getExpandRatio() / total);\r\n            if (vertical) {\r\n                slot.setHeight(size + \"%\");\r\n                if (slot.hasRelativeHeight()) {\r\n                    Util.notifyParentOfSizeChange(this, true);\r\n                }\r\n            } else {\r\n                slot.setWidth(size + \"%\");\r\n                if (slot.hasRelativeWidth()) {\r\n                    Util.notifyParentOfSizeChange(this, true);\r\n                }\r\n            }\r\n        } else if (slot.isRelativeInDirection(vertical)) {\r\n            if (vertical) {\r\n                slot.setHeight(\"0\");\r\n            } else {\r\n                slot.setWidth(\"0\");\r\n            }\r\n            slotStyle.setVisibility(Visibility.HIDDEN);\r\n            slotElement.setAttribute(\"aria-hidden\", \"true\");\r\n        } else {\r\n            if (vertical) {\r\n                slotStyle.clearHeight();\r\n            } else {\r\n                slotStyle.clearWidth();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.communication.UidlWriter.write",
	"Comment": "writes a json object containing all pending changes to the given ui.",
	"Method": "void write(UI ui,Writer writer,boolean async){\r\n    VaadinSession session = ui.getSession();\r\n    VaadinService service = session.getService();\r\n    service.runPendingAccessTasks(session);\r\n    Set<ClientConnector> processedConnectors = new HashSet();\r\n    LegacyCommunicationManager manager = session.getCommunicationManager();\r\n    ClientCache clientCache = manager.getClientCache(ui);\r\n    boolean repaintAll = clientCache.isEmpty();\r\n    ConnectorTracker uiConnectorTracker = ui.getConnectorTracker();\r\n    getLogger().log(Level.FINE, \"* Creating response to client\");\r\n    while (true) {\r\n        List<ClientConnector> connectorsToProcess = new ArrayList();\r\n        for (ClientConnector c : uiConnectorTracker.getDirtyVisibleConnectors()) {\r\n            if (!processedConnectors.contains(c)) {\r\n                connectorsToProcess.add(c);\r\n            }\r\n        }\r\n        if (connectorsToProcess.isEmpty()) {\r\n            break;\r\n        }\r\n        Collections.sort(connectorsToProcess, Comparator.comparingInt(conn -> {\r\n            int depth = 0;\r\n            ClientConnector connector = conn;\r\n            while (connector.getParent() != null) {\r\n                ++depth;\r\n                connector = connector.getParent();\r\n            }\r\n            return depth;\r\n        }));\r\n        for (ClientConnector connector : connectorsToProcess) {\r\n            boolean initialized = uiConnectorTracker.isDirty(connector) && uiConnectorTracker.isClientSideInitialized(connector);\r\n            processedConnectors.add(connector);\r\n            try {\r\n                connector.beforeClientResponse(!initialized);\r\n            } catch (RuntimeException e) {\r\n                manager.handleConnectorRelatedException(connector, e);\r\n            }\r\n        }\r\n    }\r\n    getLogger().log(Level.FINE, \"Found \" + processedConnectors.size() + \" dirty connectors to paint\");\r\n    uiConnectorTracker.setWritingResponse(true);\r\n    try {\r\n        int syncId = service.getDeploymentConfiguration().isSyncIdCheckEnabled() ? uiConnectorTracker.getCurrentSyncId() : -1;\r\n        writer.write(\"\\\"\" + ApplicationConstants.SERVER_SYNC_ID + \"\\\": \" + syncId + \", \");\r\n        if (repaintAll) {\r\n            writer.write(\"\\\"\" + ApplicationConstants.RESYNCHRONIZE_ID + \"\\\": true, \");\r\n        }\r\n        int nextClientToServerMessageId = ui.getLastProcessedClientToServerId() + 1;\r\n        writer.write(\"\\\"\" + ApplicationConstants.CLIENT_TO_SERVER_ID + \"\\\": \" + nextClientToServerMessageId + \", \");\r\n        writer.write(\"\\\"changes\\\" : \");\r\n        JsonPaintTarget paintTarget = new JsonPaintTarget(manager, writer, !repaintAll);\r\n        new LegacyUidlWriter().write(ui, writer, paintTarget);\r\n        paintTarget.close();\r\n        writer.write(\", \");\r\n        writer.write(\"\\\"state\\\":\");\r\n        Set<String> stateUpdateConnectors = new SharedStateWriter().write(ui, writer);\r\n        writer.write(\", \");\r\n        writer.write(\"\\\"types\\\":\");\r\n        new ConnectorTypeWriter().write(ui, writer, paintTarget);\r\n        writer.write(\", \");\r\n        writer.write(\"\\\"hierarchy\\\":\");\r\n        new ConnectorHierarchyWriter().write(ui, writer, stateUpdateConnectors);\r\n        writer.write(\", \");\r\n        writer.write(\"\\\"rpc\\\" : \");\r\n        new ClientRpcWriter().write(ui, writer);\r\n        writer.write(\", \");\r\n        uiConnectorTracker.markAllConnectorsClean();\r\n        writer.write(\"\\\"meta\\\" : \");\r\n        SystemMessages messages = ui.getSession().getService().getSystemMessages(ui.getLocale(), null);\r\n        new MetadataWriter().write(ui, writer, repaintAll, async, messages);\r\n        writer.write(\", \");\r\n        writer.write(\"\\\"resources\\\" : \");\r\n        new ResourceWriter().write(ui, writer, paintTarget);\r\n        Collection<Class<? extends ClientConnector>> usedClientConnectors = paintTarget.getUsedClientConnectors();\r\n        boolean typeMappingsOpen = false;\r\n        List<Class<? extends ClientConnector>> newConnectorTypes = new ArrayList();\r\n        for (Class<? extends ClientConnector> class1 : usedClientConnectors) {\r\n            if (clientCache.cache(class1)) {\r\n                newConnectorTypes.add(class1);\r\n                if (!typeMappingsOpen) {\r\n                    typeMappingsOpen = true;\r\n                    writer.write(\", \\\"typeMappings\\\" : { \");\r\n                } else {\r\n                    writer.write(\" , \");\r\n                }\r\n                String canonicalName = class1.getCanonicalName();\r\n                writer.write(\"\\\"\");\r\n                writer.write(canonicalName);\r\n                writer.write(\"\\\" : \");\r\n                writer.write(manager.getTagForType(class1));\r\n            }\r\n        }\r\n        if (typeMappingsOpen) {\r\n            writer.write(\" }\");\r\n        }\r\n        boolean typeInheritanceMapOpen = false;\r\n        if (typeMappingsOpen) {\r\n            for (Class<? extends ClientConnector> class1 : usedClientConnectors) {\r\n                if (!ClientConnector.class.isAssignableFrom(class1.getSuperclass())) {\r\n                    continue;\r\n                }\r\n                if (!typeInheritanceMapOpen) {\r\n                    typeInheritanceMapOpen = true;\r\n                    writer.write(\", \\\"typeInheritanceMap\\\" : { \");\r\n                } else {\r\n                    writer.write(\" , \");\r\n                }\r\n                writer.write(\"\\\"\");\r\n                writer.write(manager.getTagForType(class1));\r\n                writer.write(\"\\\" : \");\r\n                writer.write(manager.getTagForType((Class<? extends ClientConnector>) class1.getSuperclass()));\r\n            }\r\n            if (typeInheritanceMapOpen) {\r\n                writer.write(\" }\");\r\n            }\r\n        }\r\n        Collections.sort(newConnectorTypes, new Comparator<Class<?>>() {\r\n            @Override\r\n            public int compare(Class<?> o1, Class<?> o2) {\r\n                return hierarchyDepth(o1) - hierarchyDepth(o2);\r\n            }\r\n            private int hierarchyDepth(Class<?> type) {\r\n                if (type == Object.class) {\r\n                    return 0;\r\n                } else {\r\n                    return hierarchyDepth(type.getSuperclass()) + 1;\r\n                }\r\n            }\r\n        });\r\n        List<Dependency> dependencies = new ArrayList();\r\n        dependencies.addAll(ui.getPage().getPendingDependencies());\r\n        dependencies.addAll(Dependency.findDependencies(newConnectorTypes, manager, new FilterContext(session)));\r\n        if (!dependencies.isEmpty()) {\r\n            writer.write(\", \\\"dependencies\\\": \" + JsonUtil.stringify(toJsonArray(dependencies)));\r\n        }\r\n        session.getDragAndDropService().printJSONResponse(writer);\r\n        for (ClientConnector connector : processedConnectors) {\r\n            uiConnectorTracker.markClientSideInitialized(connector);\r\n        }\r\n        assert (uiConnectorTracker.getDirtyConnectors().isEmpty()) : \"Connectors have been marked as dirty during the end of the paint phase. This is most certainly not intended.\";\r\n        writePerformanceData(ui, writer);\r\n    } finally {\r\n        uiConnectorTracker.setWritingResponse(false);\r\n        uiConnectorTracker.cleanConnectorMap(true);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.communication.UidlWriter.write",
	"Comment": "writes a json object containing all pending changes to the given ui.",
	"Method": "void write(UI ui,Writer writer,boolean async){\r\n    return hierarchyDepth(o1) - hierarchyDepth(o2);\r\n}"
}, {
	"Path": "com.vaadin.server.communication.UidlWriter.write",
	"Comment": "writes a json object containing all pending changes to the given ui.",
	"Method": "void write(UI ui,Writer writer,boolean async){\r\n    if (type == Object.class) {\r\n        return 0;\r\n    } else {\r\n        return hierarchyDepth(type.getSuperclass()) + 1;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.client.widgets.Grid.getSidebarMenu",
	"Comment": "gets the customizable menu bar that is by default used for togglingcolumn hidability. the application developer is allowed to add theircustom items to the end of the menu, but should try to avoid modifyingthe items in the beginning of the menu that control the column hiding ifany columns are marked as hidable. a toggle for opening the menu will bedisplayed whenever the menu contains at least one item.",
	"Method": "MenuBar getSidebarMenu(){\r\n    return sidebar.menuBar;\r\n}"
}, {
	"Path": "com.vaadin.ui.declarative.DesignContext.setCustomAttribute",
	"Comment": "sets a custom attribute not handled by the component. these attributesare directly written to the component tag.",
	"Method": "void setCustomAttribute(Component component,String attribute,String value){\r\n    Map<String, String> map = customAttributes.get(component);\r\n    if (map == null) {\r\n        customAttributes.put(component, map = new HashMap());\r\n    }\r\n    map.put(attribute, value);\r\n}"
}, {
	"Path": "com.vaadin.client.componentlocator.VaadinFinderLocatorStrategy.getBestSelector",
	"Comment": "search different queries for the best one. use the fact that the lowestpossible index is with the last selector. last selector is the fullsearch path containing the complete component hierarchy.",
	"Method": "String getBestSelector(List<String> selectors,Element target,String subPart){\r\n    String bestSelector = selectors.get(selectors.size() - 1);\r\n    int min = getElementsByPath(bestSelector).indexOf(target);\r\n    if (selectors.size() > 1 && min == getElementsByPath(selectors.get(0)).indexOf(target)) {\r\n        bestSelector = selectors.get(0);\r\n    } else if (selectors.size() > 2) {\r\n        if (getElementsByPath(selectors.get(selectors.size() - 2)).indexOf(target) == min) {\r\n            for (int i = 1; i < selectors.size() - 2; ++i) {\r\n                if (getElementsByPath(selectors.get(i)).indexOf(target) == min) {\r\n                    bestSelector = selectors.get(i);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return \"(\" + bestSelector + (subPart != null ? \"#\" + subPart : \"\") + \")[\" + min + \"]\";\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.addBodyKeyUpHandler",
	"Comment": "register a bodykeyuphandler to this grid. the event for this handler isfired when a keyup event occurs while cell focus is in the body of thisgrid.",
	"Method": "HandlerRegistration addBodyKeyUpHandler(BodyKeyUpHandler handler){\r\n    return addHandler(handler, GridKeyUpEvent.TYPE);\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VUpload.disableUpload",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void disableUpload(){\r\n    setEnabledForSubmitButton(false);\r\n    if (!submitted) {\r\n        fu.getElement().setPropertyBoolean(\"disabled\", true);\r\n    }\r\n    enabled = false;\r\n}"
}, {
	"Path": "com.github.dozermapper.core.DozerConverter.convert",
	"Comment": "method first checks exact type matches and only then checks for assignement",
	"Method": "Object convert(Object existingDestinationFieldValue,Object sourceFieldValue,Class<?> destinationClass,Class<?> sourceClass){\r\n    Class<?> wrappedDestinationClass = ClassUtils.primitiveToWrapper(destinationClass);\r\n    Class<?> wrappedSourceClass = ClassUtils.primitiveToWrapper(sourceClass);\r\n    if (prototypeA.equals(wrappedDestinationClass)) {\r\n        return convertFrom((B) sourceFieldValue, (A) existingDestinationFieldValue);\r\n    } else if (prototypeB.equals(wrappedDestinationClass)) {\r\n        return convertTo((A) sourceFieldValue, (B) existingDestinationFieldValue);\r\n    } else if (prototypeA.equals(wrappedSourceClass)) {\r\n        return convertTo((A) sourceFieldValue, (B) existingDestinationFieldValue);\r\n    } else if (prototypeB.equals(wrappedSourceClass)) {\r\n        return convertFrom((B) sourceFieldValue, (A) existingDestinationFieldValue);\r\n    } else if (prototypeA.isAssignableFrom(wrappedDestinationClass)) {\r\n        return convertFrom((B) sourceFieldValue, (A) existingDestinationFieldValue);\r\n    } else if (prototypeB.isAssignableFrom(wrappedDestinationClass)) {\r\n        return convertTo((A) sourceFieldValue, (B) existingDestinationFieldValue);\r\n    } else if (prototypeA.isAssignableFrom(wrappedSourceClass)) {\r\n        return convertTo((A) sourceFieldValue, (B) existingDestinationFieldValue);\r\n    } else if (prototypeB.isAssignableFrom(wrappedSourceClass)) {\r\n        return convertFrom((B) sourceFieldValue, (A) existingDestinationFieldValue);\r\n    } else {\r\n        throw new MappingException(\"Destination Type (\" + wrappedDestinationClass.getName() + \") is not accepted by this Custom Converter (\" + this.getClass().getName() + \")!\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.server.communication.data.RpcDataProviderExtension.internalDropItems",
	"Comment": "informs all datagenerators than an item id has been dropped.",
	"Method": "void internalDropItems(Collection<Object> droppedItemIds){\r\n    for (Object itemId : droppedItemIds) {\r\n        for (DataGenerator generator : dataGenerators) {\r\n            generator.destroyData(itemId);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.findVaadinSession",
	"Comment": "attempts to find a vaadin service session associated with this request.handles locking of the session internally to avoid creation of duplicatesessions by two threads simultaneously.",
	"Method": "VaadinSession findVaadinSession(VaadinRequest request){\r\n    VaadinSession vaadinSession = findOrCreateVaadinSession(request);\r\n    if (vaadinSession == null) {\r\n        return null;\r\n    }\r\n    VaadinSession.setCurrent(vaadinSession);\r\n    request.setAttribute(VaadinSession.class.getName(), vaadinSession);\r\n    return vaadinSession;\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinService.removeSessionInitListener",
	"Comment": "removes a vaadin service session initialization listener from thisservice.",
	"Method": "void removeSessionInitListener(SessionInitListener listener){\r\n    sessionInitListeners.remove(listener);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Grid.getCellStyleGenerator",
	"Comment": "gets the style generator that is used for generating styles for cells.",
	"Method": "CellStyleGenerator getCellStyleGenerator(){\r\n    return cellStyleGenerator;\r\n}"
}, {
	"Path": "com.vaadin.server.UnsupportedBrowserHandler.writeBrowserTooOldPage",
	"Comment": "writes a page encouraging the user to upgrade to a more current browser.",
	"Method": "void writeBrowserTooOldPage(VaadinRequest request,VaadinResponse response){\r\n    try (Writer page = response.getWriter()) {\r\n        WebBrowser b = VaadinSession.getCurrent().getBrowser();\r\n        page.write(\"<html>\" + \"<head>\" + \"  <style>\" + \"    html {\" + \"      background: #fff;\" + \"      color: #444;\" + \"      font: 400 1em/1.5 \\\"Helvetica Neue\\\", Roboto, \\\"Segoe UI\\\", sans-serif;\" + \"      padding: 2em;\" + \"    }\" + \"    body {\" + \"      margin: 2em auto;\" + \"      width: 27em;\" + \"      max-width: 100%;\" + \"    }\" + \"    h1 {\" + \"      line-height: 1.1;\" + \"      margin: 2em 0 1em;\" + \"      color: #000;\" + \"      font-weight: 400;\" + \"    }\" + \"    em {\" + \"      font-size: 1.2em;\" + \"      font-style: normal;\" + \"      display: block;\" + \"      margin-bottom: 1.2em;\" + \"    }\" + \"    p {\" + \"      margin: 0.5em 0 0;\" + \"    }\" + \"    a {\" + \"      text-decoration: none;\" + \"      color: #007df0;\" + \"    }\" + \"    sub {\" + \"      display: block;\" + \"      margin-top: 2.5em;\" + \"      text-align: center;\" + \"      border-top: 1px solid #eee;\" + \"      padding-top: 2em;\" + \"    }\" + \"    sub,\" + \"    small {\" + \"      color: #999;\" + \"    }\" + \"  <\/style>\" + \"<\/head>\" + \"<body><h1>I'm sorry, but your browser is not supported<\/h1>\" + \"<p>The version (\" + b.getBrowserMajorVersion() + \".\" + b.getBrowserMinorVersion() + \") of the browser you are using \" + \" is outdated and not supported.<\/p>\" + \"<p>You should <b>consider upgrading<\/b> to a more up-to-date browser.<\/p> \" + \"<p>The most popular browsers are <b>\" + \" <a href=\\\"https://www.google.com/chrome\\\">Chrome<\/a>,\" + \" <a href=\\\"http://www.mozilla.com/firefox\\\">Firefox<\/a>,\" + (b.isWindows() ? \" <a href=\\\"http://windows.microsoft.com/en-US/internet-explorer/downloads/ie\\\">Internet Explorer<\/a>,\" : \"\") + \" <a href=\\\"http://www.opera.com/browser\\\">Opera<\/a>\" + \" and <a href=\\\"http://www.apple.com/safari\\\">Safari<\/a>.<\/b><br/>\" + \"Upgrading to the latest version of one of these <b>will make the web safer, faster and better looking.<\/b><\/p>\" + (b.isIE() ? \"<script type=\\\"text/javascript\\\" src=\\\"http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js\\\"><\/script>\" + \"<p>If you can not upgrade your browser, please consider trying <a onclick=\\\"CFInstall.check({mode:'overlay'});return false;\\\" href=\\\"http://www.google.com/chromeframe\\\">Chrome Frame<\/a>.<\/p>\" : \"\") + \"<p><sub><a onclick=\\\"document.cookie='\" + FORCE_LOAD_COOKIE + \"';window.location.reload();return false;\\\" href=\\\"#\\\">Continue without updating<\/a> (not recommended)<\/sub><\/p>\" + \"<\/body>\\n\" + \"<\/html>\");\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VAbstractCalendarPanel.setRangeStart",
	"Comment": "sets the start range for this component. the start range is inclusive,and it depends on the current resolution, what is considered inside therange.",
	"Method": "void setRangeStart(String newRangeStart){\r\n    if (!SharedUtil.equals(rangeStart, newRangeStart)) {\r\n        rangeStart = newRangeStart;\r\n        if (initialRenderDone) {\r\n            renderCalendar();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.data.util.ObjectProperty.setValue",
	"Comment": "sets the value of the property.note that since vaadin 7, no conversions are performed and the value mustbe of the correct type.",
	"Method": "void setValue(T newValue){\r\n    if (isReadOnly()) {\r\n        throw new Property.ReadOnlyException();\r\n    }\r\n    this.value = newValue;\r\n    fireValueChange();\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VPanel.setIconUri",
	"Comment": "for internal use only. may be removed or replaced in the future.",
	"Method": "void setIconUri(String iconUri,ApplicationConnection client){\r\n    if (icon != null) {\r\n        captionNode.removeChild(icon.getElement());\r\n    }\r\n    icon = client.getIcon(iconUri);\r\n    if (icon != null) {\r\n        DOM.insertChild(captionNode, icon.getElement(), 0);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.server.VaadinServletServiceTest.createRequest",
	"Comment": "creates a httpservletrequest mock using the supplied parameters.",
	"Method": "HttpServletRequest createRequest(String base,String contextPath,String servletPath,String pathInfo){\r\n    URL url = new URL(base + contextPath + pathInfo);\r\n    HttpServletRequest request = createMock(HttpServletRequest.class);\r\n    expect(request.isSecure()).andReturn(url.getProtocol().equalsIgnoreCase(\"https\")).anyTimes();\r\n    expect(request.getServerName()).andReturn(url.getHost()).anyTimes();\r\n    expect(request.getServerPort()).andReturn(url.getPort()).anyTimes();\r\n    expect(request.getRequestURI()).andReturn(url.getPath()).anyTimes();\r\n    expect(request.getContextPath()).andReturn(contextPath).anyTimes();\r\n    expect(request.getPathInfo()).andReturn(pathInfo).anyTimes();\r\n    expect(request.getServletPath()).andReturn(servletPath).anyTimes();\r\n    return request;\r\n}"
}, {
	"Path": "com.vaadin.client.widgets.Grid.recalculateColumnWidths",
	"Comment": "requests that the column widths should be recalculated.the actual recalculation is not necessarily done immediately so youcannot rely on the columns being the correct width after the callreturns.",
	"Method": "void recalculateColumnWidths(){\r\n    autoColumnWidthsRecalculator.schedule();\r\n}"
}, {
	"Path": "org.greenrobot.essentials.DateUtils.setTime",
	"Comment": "sets hour, minutes, seconds and milliseconds to the given values. leaves date info untouched.",
	"Method": "void setTime(Calendar calendar,int hourOfDay,int minute,int second,int millisecond){\r\n    calendar.set(Calendar.HOUR_OF_DAY, hourOfDay);\r\n    calendar.set(Calendar.MINUTE, minute);\r\n    calendar.set(Calendar.SECOND, second);\r\n    calendar.set(Calendar.MILLISECOND, millisecond);\r\n}"
}, {
	"Path": "com.vaadin.ui.Embedded.getCodebase",
	"Comment": "this attribute specifies the base path used to resolve relative urisspecified by the classid, data, and archive attributes. when absent, itsdefault value is the base uri of the current document.",
	"Method": "String getCodebase(){\r\n    return getState(false).codebase;\r\n}"
}, {
	"Path": "com.commafeed.backend.feed.FeedQueues.refill",
	"Comment": "refills the refresh queue and empties the giveback queue while at it",
	"Method": "void refill(){\r\n    refill.mark();\r\n    List<FeedRefreshContext> contexts = new ArrayList();\r\n    int batchSize = Math.min(100, 3 * config.getApplicationSettings().getBackgroundThreads());\r\n    int addQueueSize = addQueue.size();\r\n    for (int i = 0; i < Math.min(batchSize, addQueueSize); i++) {\r\n        contexts.add(addQueue.poll());\r\n    }\r\n    int count = batchSize - contexts.size();\r\n    if (count > 0) {\r\n        List<Feed> feeds = UnitOfWork.call(sessionFactory, () -> feedDAO.findNextUpdatable(count, getLastLoginThreshold()));\r\n        for (Feed feed : feeds) {\r\n            contexts.add(new FeedRefreshContext(feed, false));\r\n        }\r\n    }\r\n    Map<Long, FeedRefreshContext> map = new LinkedHashMap();\r\n    for (FeedRefreshContext context : contexts) {\r\n        Feed feed = context.getFeed();\r\n        feed.setDisabledUntil(DateUtils.addMinutes(new Date(), config.getApplicationSettings().getRefreshIntervalMinutes()));\r\n        map.put(feed.getId(), context);\r\n    }\r\n    takeQueue.addAll(map.values());\r\n    int giveBackQueueSize = giveBackQueue.size();\r\n    for (int i = 0; i < giveBackQueueSize; i++) {\r\n        Feed feed = giveBackQueue.poll();\r\n        map.put(feed.getId(), new FeedRefreshContext(feed, false));\r\n    }\r\n    List<Feed> feeds = map.values().stream().map(c -> c.getFeed()).collect(Collectors.toList());\r\n    UnitOfWork.run(sessionFactory, () -> feedDAO.saveOrUpdate(feeds));\r\n}"
}, {
	"Path": "com.folioreader.view.VerticalViewPager.addFocusables",
	"Comment": "we only want the current page that is being shown to be focusable.",
	"Method": "void addFocusables(ArrayList<View> views,int direction,int focusableMode){\r\n    final int focusableCount = views.size();\r\n    final int descendantFocusability = getDescendantFocusability();\r\n    if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {\r\n        for (int i = 0; i < getChildCount(); i++) {\r\n            final View child = getChildAt(i);\r\n            if (child.getVisibility() == VISIBLE) {\r\n                ItemInfo ii = infoForChild(child);\r\n                if (ii != null && ii.position == mCurItem) {\r\n                    child.addFocusables(views, direction, focusableMode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (descendantFocusability != FOCUS_AFTER_DESCENDANTS || (focusableCount == views.size())) {\r\n        if (!isFocusable()) {\r\n            return;\r\n        }\r\n        if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && isInTouchMode() && !isFocusableInTouchMode()) {\r\n            return;\r\n        }\r\n        if (views != null) {\r\n            views.add(this);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.client.ui.VGridLayout.getVerticalSpacing",
	"Comment": "returns the spacing between the cells vertically in pixels.",
	"Method": "int getVerticalSpacing(){\r\n    return LayoutManager.get(client).getOuterHeight(spacingMeasureElement);\r\n}"
}, {
	"Path": "com.vaadin.server.DownloadStream.setParameter",
	"Comment": "sets a parameter for download stream. parameters are optional informationabout the downloadable stream and their meaning depends on the usedadapter. for example in webadapter they are interpreted as http responseheaders.if the parameters by this name exists, the old value is replaced.",
	"Method": "void setParameter(String name,String value){\r\n    if (params == null) {\r\n        params = new HashMap();\r\n    }\r\n    params.put(name, value);\r\n}"
}, {
	"Path": "com.vaadin.v7.ui.Table.getFirstAddedItemIndex",
	"Comment": "subclass and override this to enable partial row additions, bypassing thenormal caching mechanism. this is useful for e.g. treetable, whereexpanding a node should only fetch and add the items inside of that node.",
	"Method": "int getFirstAddedItemIndex(){\r\n    return 0;\r\n}"
}, {
	"Path": "com.vaadin.v7.client.ui.VCalendarPanel.handleNavigationDayMode",
	"Comment": "handle keyboard navigation what the resolution is set to day.",
	"Method": "boolean handleNavigationDayMode(int keycode,boolean ctrl,boolean shift){\r\n    if (ctrl) {\r\n        return false;\r\n    }\r\n    if (keycode == getForwardKey() && !shift) {\r\n        focusNextDay(1);\r\n        return true;\r\n    } else if (keycode == getBackwardKey() && !shift) {\r\n        focusPreviousDay(1);\r\n        return true;\r\n    } else if (keycode == getNextKey() && !shift) {\r\n        focusNextDay(7);\r\n        return true;\r\n    } else if (keycode == getPreviousKey() && !shift) {\r\n        focusPreviousDay(7);\r\n        return true;\r\n    } else if (keycode == getSelectKey() && !shift) {\r\n        selectFocused();\r\n        onSubmit();\r\n        return true;\r\n    } else if (keycode == getCloseKey()) {\r\n        onCancel();\r\n        return true;\r\n    } else if (shift && keycode == getForwardKey()) {\r\n        focusNextMonth();\r\n        return true;\r\n    } else if (shift && keycode == getBackwardKey()) {\r\n        focusPreviousMonth();\r\n        return true;\r\n    } else if (shift && keycode == getPreviousKey()) {\r\n        focusNextYear(1);\r\n        return true;\r\n    } else if (shift && keycode == getNextKey()) {\r\n        focusPreviousYear(1);\r\n        return true;\r\n    } else if (keycode == getResetKey() && !shift) {\r\n        focusedDate = new FocusedDate(value.getYear(), value.getMonth(), value.getDate());\r\n        displayedMonth = new FocusedDate(value.getYear(), value.getMonth(), 1);\r\n        renderCalendar();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vaadin.ui.renderers.AbstractRenderer.getSupportedParentType",
	"Comment": "this method is inherited from abstractextension but should never becalled directly with an abstractrenderer.",
	"Method": "Class<Column> getSupportedParentType(){\r\n    return Column.class;\r\n}"
}, {
	"Path": "com.vaadin.client.debug.internal.SelectorPath.generateFragment",
	"Comment": "generates a recursive elementquery for given path fragment",
	"Method": "String generateFragment(String fragment){\r\n    String elementClass = getComponentName(fragment) + \"Element.class\";\r\n    String queryFragment = \"$(\" + elementClass + \")\";\r\n    for (SelectorPredicate p : SelectorPredicate.extractPredicates(fragment)) {\r\n        queryFragment += \".\" + p.getName() + \"(\\\"\" + p.getValue() + \"\\\")\";\r\n    }\r\n    return queryFragment;\r\n}"
}, {
	"Path": "com.vaadin.client.widget.grid.sort.SortEvent.isUserOriginated",
	"Comment": "returns whether this event originated from actions done by the user.",
	"Method": "boolean isUserOriginated(){\r\n    return userOriginated;\r\n}"
}]