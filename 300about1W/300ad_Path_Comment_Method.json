[{
	"Path": "com.vaadin.testbench.elements.ColorPickerPreviewElement.getColorFieldValue",
	"Comment": "get the value of the input element textfield in colorpickerpreview.",
	"Method": "String getColorFieldValue(){\r\n    return getColorTextField().getAttribute(\"value\");\r\n}"
}, {
	"Path": "com.vaadin.tests.components.grid.HorizontalScrollAfterResizeTest.scrollAfterResize",
	"Comment": "the behavior without the fix differs across different browsers butscenario should work everywhere.",
	"Method": "void scrollAfterResize(){\r\n    getDriver().manage().window().setSize(new Dimension(600, 400));\r\n    openTestURL();\r\n    getDriver().manage().window().setSize(new Dimension(200, 400));\r\n    scrollGridHorizontallyTo(600);\r\n    Point locationAfterFirstScroll = $(GridElement.class).first().getCell(0, 9).getLocation();\r\n    getDriver().manage().window().setSize(new Dimension(600, 400));\r\n    getDriver().manage().window().setSize(new Dimension(200, 400));\r\n    scrollGridHorizontallyTo(600);\r\n    Point locationAfterSecondScrollcation = $(GridElement.class).first().getCell(0, 9).getLocation();\r\n    assertEquals(locationAfterFirstScroll.getY(), locationAfterSecondScrollcation.getY());\r\n    int delta = 5;\r\n    assertTrue(Math.abs(locationAfterFirstScroll.getX() - locationAfterSecondScrollcation.getX()) < delta);\r\n}"
}, {
	"Path": "fj.data.List.zip",
	"Comment": "zips this list with the given list to produce a list of pairs. if this list and the given listhave different lengths, then the longer list is normalised so this function never fails.",
	"Method": "List<P2<A, B>> zip(List<B> bs,F<List<A>, F<List<B>, List<P2<A, B>>>> zip){\r\n    return curry(List::zip);\r\n}"
}, {
	"Path": "fj.data.Java.StringBuilder_SynchronousQueue",
	"Comment": "a function that converts string builders to synchronous queues.",
	"Method": "F<StringBuilder, SynchronousQueue<Character>> StringBuilder_SynchronousQueue(boolean fair){\r\n    return Function.compose(Java.List_SynchronousQueue(fair), Conversions.StringBuilder_List);\r\n}"
}, {
	"Path": "fj.data.Option.valueE",
	"Comment": "returns the value of this optional value or fails with the given message.",
	"Method": "A valueE(F0<String> message,A valueE,String message){\r\n    if (isSome())\r\n        return some();\r\n    else\r\n        throw error(message);\r\n}"
}, {
	"Path": "fj.data.Stream.removeAll",
	"Comment": "filters elements from this stream by returning only elements which produce false whenthe given function is applied to them.",
	"Method": "Stream<A> removeAll(F<A, Boolean> f){\r\n    return filter(compose(not, f));\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.reader.CatalogFileReader.jumpToItem",
	"Comment": "jumptoitem is overridden because reading in and attempting to bind an entire fragment is unacceptable in a restart scenario, and may causeexceptions to be thrown that were already skipped in previous runs.",
	"Method": "void jumpToItem(int itemIndex){\r\n    for (int i = 0; i < itemIndex; i++) {\r\n        try {\r\n            QName fragmentName = readToStartFragment();\r\n            readToEndFragment(fragmentName);\r\n        } catch (NoSuchElementException e) {\r\n            if (itemIndex == (i + 1)) {\r\n                return;\r\n            } else {\r\n                logValidationExceptions((T) null, e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "fj.data.Validation.successE",
	"Comment": "returns the success value or fails with the given error message.",
	"Method": "T successE(F0<String> err,T successE,String err){\r\n    return e.right().valueE(p(err));\r\n}"
}, {
	"Path": "fj.data.fingertrees.FingerTree.split1",
	"Comment": "like split, but returns the element where pred first holds separately.throws an error if the tree is empty.",
	"Method": "P3<FingerTree<V, A>, A, FingerTree<V, A>> split1(F<V, Boolean> predicate,P3<FingerTree<V, A>, A, FingerTree<V, A>> split1,F<V, Boolean> predicate,V acc){\r\n    return split1(predicate, measured().zero());\r\n}"
}, {
	"Path": "org.geoserver.wms.DimensionsRasterGetFeatureInfoTest.getValueAt",
	"Comment": "ensures there is at most one feature at the specified location, and returns its feature id",
	"Method": "Double getValueAt(String baseFeatureInfo,int x,int y){\r\n    MockHttpServletResponse response = getAsServletResponse(baseFeatureInfo + \"&info_format=application/vnd.ogc.gml&x=\" + x + \"&y=\" + y);\r\n    assertEquals(\"application/vnd.ogc.gml\", response.getContentType());\r\n    Document doc = dom(new ByteArrayInputStream(response.getContentAsString().getBytes()));\r\n    String sCount = xpath.evaluate(\"count(//\" + layerId + \")\", doc);\r\n    int count = Integer.valueOf(sCount);\r\n    if (count == 0) {\r\n        return null;\r\n    } else if (count == 1) {\r\n        return Double.valueOf(xpath.evaluate(\"//\" + layerId + \"/sf:GRAY_INDEX\", doc));\r\n    } else {\r\n        fail(\"Found more than one feature: \" + count);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "fj.data.TreeZipper.fromForest",
	"Comment": "creates a new tree zipper focused on the first element of the given forest.",
	"Method": "Option<TreeZipper<A>> fromForest(Stream<Tree<A>> ts){\r\n    return ts.isNotEmpty() ? some(treeZipper(ts.head(), Stream.nil(), ts.tail()._1(), TreeZipper.lp3nil())) : Option.none();\r\n}"
}, {
	"Path": "fj.control.parallel.Strategy.parMapArray",
	"Comment": "promotes a function to a parallel function on arrays using this strategy.",
	"Method": "F<Array<B>, P1<Array<A>>> parMapArray(F<B, A> f,F<F<B, A>, F<Array<B>, P1<Array<A>>>> parMapArray){\r\n    return this::parMapArray;\r\n}"
}, {
	"Path": "fj.data.vector.V2.zip",
	"Comment": "zips this vector with the given vector to produce a vector of pairs.",
	"Method": "V2<P2<A, B>> zip(V2<B> bs){\r\n    final F<A, F<B, P2<A, B>>> __2 = p2();\r\n    return zipWith(__2, bs);\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.TwinColSelectElement.getAvailableOptions",
	"Comment": "gets the available option texts, i.e. all values which have not beenselected.",
	"Method": "List<String> getAvailableOptions(){\r\n    return getOptionsFromSelect(options);\r\n}"
}, {
	"Path": "fj.data.Enumerator.enumerator",
	"Comment": "construct an enumerator. the plus function is derived from the successor andpredecessor.",
	"Method": "Enumerator<A> enumerator(F<A, Option<A>> successor,F<A, Option<A>> predecessor,Option<A> max,Option<A> min,Ord<A> order,F<A, F<Long, Option<A>>> plus,Enumerator<A> enumerator,F<A, Option<A>> successor,F<A, Option<A>> predecessor,Option<A> max,Option<A> min,Ord<A> order){\r\n    return new Enumerator(successor, predecessor, max, min, order, curry((a, l) -> {\r\n        if (l == 0L)\r\n            return some(a);\r\n        else if (l < 0L) {\r\n            A aa = a;\r\n            for (long x = l; x < 0; x++) {\r\n                final Option<A> s = predecessor.f(aa);\r\n                if (s.isNone())\r\n                    return none();\r\n                else\r\n                    aa = s.some();\r\n            }\r\n            return some(aa);\r\n        } else {\r\n            A aa = a;\r\n            for (long x = l; x > 0; x--) {\r\n                final Option<A> s = successor.f(aa);\r\n                if (s.isNone())\r\n                    return none();\r\n                else\r\n                    aa = s.some();\r\n            }\r\n            return some(aa);\r\n        }\r\n    }));\r\n}"
}, {
	"Path": "fj.data.List.sort",
	"Comment": "sorts this list using the given order over elements using a merge sort algorithm.",
	"Method": "List<A> sort(Ord<A> o){\r\n    if (isEmpty())\r\n        return nil();\r\n    else if (tail().isEmpty())\r\n        return this;\r\n    else {\r\n        final class Merge {\r\n            List<A> merge(List<A> xs, List<A> ys, final Ord<A> o) {\r\n                final Buffer<A> buf = empty();\r\n                while (true) {\r\n                    if (xs.isEmpty()) {\r\n                        buf.append(ys);\r\n                        break;\r\n                    }\r\n                    if (ys.isEmpty()) {\r\n                        buf.append(xs);\r\n                        break;\r\n                    }\r\n                    final A x = xs.head();\r\n                    final A y = ys.head();\r\n                    if (o.isLessThanOrEqualTo(x, y)) {\r\n                        buf.snoc(x);\r\n                        xs = xs.tail();\r\n                    } else {\r\n                        buf.snoc(y);\r\n                        ys = ys.tail();\r\n                    }\r\n                }\r\n                return buf.toList();\r\n            }\r\n        }\r\n        final P2<List<A>, List<A>> s = splitAt(length() / 2);\r\n        return new Merge().merge(s._1().sort(o), s._2().sort(o), o);\r\n    }\r\n}"
}, {
	"Path": "fj.data.List.sort",
	"Comment": "sorts this list using the given order over elements using a merge sort algorithm.",
	"Method": "List<A> sort(Ord<A> o){\r\n    final Buffer<A> buf = empty();\r\n    while (true) {\r\n        if (xs.isEmpty()) {\r\n            buf.append(ys);\r\n            break;\r\n        }\r\n        if (ys.isEmpty()) {\r\n            buf.append(xs);\r\n            break;\r\n        }\r\n        final A x = xs.head();\r\n        final A y = ys.head();\r\n        if (o.isLessThanOrEqualTo(x, y)) {\r\n            buf.snoc(x);\r\n            xs = xs.tail();\r\n        } else {\r\n            buf.snoc(y);\r\n            ys = ys.tail();\r\n        }\r\n    }\r\n    return buf.toList();\r\n}"
}, {
	"Path": "fj.test.Property.maxSize",
	"Comment": "checks this property using the given random generator, 100 minimumsuccessful checks, 500 maximum discarded tests, minimum size of 0, the given maximum size.",
	"Method": "CheckResult maxSize(int maxSize,CheckResult maxSize,Rand r,int maxSize){\r\n    return check(r, 100, 500, 0, maxSize);\r\n}"
}, {
	"Path": "fj.control.parallel.ParModule.parFoldMap",
	"Comment": "maps with the given function across the given iterable in parallel, while folding withthe given monoid.",
	"Method": "Promise<B> parFoldMap(Stream<A> as,F<A, B> map,Monoid<B> reduce,Promise<B> parFoldMap,Stream<A> as,F<A, B> map,Monoid<B> reduce,F<Stream<A>, P2<Stream<A>, Stream<A>>> chunking,Promise<B> parFoldMap,Iterable<A> as,F<A, B> map,Monoid<B> reduce,F<Iterable<A>, P2<Iterable<A>, Iterable<A>>> chunking,Promise<B> parFoldMap,Iterable<A> as,F<A, B> map,Monoid<B> reduce){\r\n    return parFoldMap(iterableStream(as), map, reduce);\r\n}"
}, {
	"Path": "fj.data.vector.V4.vzip",
	"Comment": "zips this vector with the given vector to produce a vector of vectors.",
	"Method": "V4<V2<A>> vzip(V4<A> bs){\r\n    final F2<A, A, V2<A>> __2 = V.v2();\r\n    return zipWith(curry(__2), bs);\r\n}"
}, {
	"Path": "fj.data.Java.PriorityBlockingQueue_List",
	"Comment": "a function that converts priority blocking queues to lists.",
	"Method": "F<PriorityBlockingQueue<A>, List<A>> PriorityBlockingQueue_List(){\r\n    return Java::Collection_List;\r\n}"
}, {
	"Path": "com.vaadin.tests.tb3.CustomTestBenchCommandExecutor.cropToElement",
	"Comment": "crops the image to show only the element. if the element is partly offscreen, crops to show the part of the element which is in the screenshot",
	"Method": "BufferedImage cropToElement(WebElement element,BufferedImage fullScreen){\r\n    Point loc = element.getLocation();\r\n    Dimension size = element.getSize();\r\n    int x = loc.x, y = loc.y;\r\n    int w = size.width;\r\n    int h = size.height;\r\n    if (x >= 0 && x < fullScreen.getWidth()) {\r\n        w = Math.min(fullScreen.getWidth() - x, w);\r\n    } else {\r\n        throw new IOException(\"Element x is outside the screenshot (x: \" + x + \", y: \" + y + \")\");\r\n    }\r\n    if (y >= 0 && y < fullScreen.getHeight()) {\r\n        h = Math.min(fullScreen.getHeight() - y, h);\r\n    } else {\r\n        throw new IOException(\"Element y is outside the screenshot (x: \" + x + \", y: \" + y + \")\");\r\n    }\r\n    return fullScreen.getSubimage(x, y, w, h);\r\n}"
}, {
	"Path": "fj.data.List.removeAll",
	"Comment": "filters elements from this list by returning only elements which produce false whenthe given function is applied to them.",
	"Method": "List<A> removeAll(F<A, Boolean> f){\r\n    return filter(compose(not, f));\r\n}"
}, {
	"Path": "fj.P8.__8",
	"Comment": "returns a function that returns the eighth element of a product.",
	"Method": "fj.F<P8<A, B, C, D, E, F$, G, H>, H> __8(){\r\n    return P8::_8;\r\n}"
}, {
	"Path": "fj.P8.__6",
	"Comment": "returns a function that returns the sixth element of a product.",
	"Method": "fj.F<P8<A, B, C, D, E, F$, G, H>, F$> __6(){\r\n    return P8::_6;\r\n}"
}, {
	"Path": "fj.P8.__7",
	"Comment": "returns a function that returns the seventh element of a product.",
	"Method": "fj.F<P8<A, B, C, D, E, F$, G, H>, G> __7(){\r\n    return P8::_7;\r\n}"
}, {
	"Path": "fj.P8.__4",
	"Comment": "returns a function that returns the fourth element of a product.",
	"Method": "fj.F<P8<A, B, C, D, E, F$, G, H>, D> __4(){\r\n    return P8::_4;\r\n}"
}, {
	"Path": "fj.data.fingertrees.FingerTree.measured",
	"Comment": "constructs a measured instance for the element type, given a monoid and a measuring function.",
	"Method": "Measured<V, A> measured(Measured<V, A> measured,Monoid<V> monoid,F<A, V> measure){\r\n    return Measured.measured(monoid, measure);\r\n}"
}, {
	"Path": "fj.P8.__5",
	"Comment": "returns a function that returns the fifth element of a product.",
	"Method": "fj.F<P8<A, B, C, D, E, F$, G, H>, E> __5(){\r\n    return P8::_5;\r\n}"
}, {
	"Path": "fj.data.Stream.sequence",
	"Comment": "performs a bind across each stream element, but ignores the element value each time.",
	"Method": "Stream<B> sequence(Stream<B> bs,Stream<IO<A>> sequence,IO<Stream<A>> io,Stream<P1<A>> sequence,F0<Stream<A>> p,Stream<Option<A>> sequence,Option<Stream<A>> o){\r\n    return o.isNone() ? nil() : o.some().map(Option::some);\r\n}"
}, {
	"Path": "fj.P8.__2",
	"Comment": "returns a function that returns the second element of a product.",
	"Method": "fj.F<P8<A, B, C, D, E, F$, G, H>, B> __2(){\r\n    return P8::_2;\r\n}"
}, {
	"Path": "fj.P8.__3",
	"Comment": "returns a function that returns the third element of a product.",
	"Method": "fj.F<P8<A, B, C, D, E, F$, G, H>, C> __3(){\r\n    return P8::_3;\r\n}"
}, {
	"Path": "fj.P8.__1",
	"Comment": "returns a function that returns the first element of a product.",
	"Method": "fj.F<P8<A, B, C, D, E, F$, G, H>, A> __1(){\r\n    return P8::_1;\r\n}"
}, {
	"Path": "fj.F1W.lift",
	"Comment": "lifts the function into the fully featured function wrapper",
	"Method": "F1W<A, B> lift(F<A, B> f){\r\n    return new F1WFunc(f);\r\n}"
}, {
	"Path": "fj.test.Cogen.cogen",
	"Comment": "transforms the given value and generator to a new generator with a high probability of beingindependent.",
	"Method": "Gen<B> cogen(A a,Gen<B> g,F<Gen<B>, Gen<B>> cogen,A a){\r\n    return g -> cogen(a, g);\r\n}"
}, {
	"Path": "fj.data.Enumerator.successor",
	"Comment": "returns the potential successor of a value for this enumerator.",
	"Method": "F<A, Option<A>> successor(Option<A> successor,A a){\r\n    return successor.f(a);\r\n}"
}, {
	"Path": "fj.data.Validation.fail",
	"Comment": "returns the failing value, or throws an error if there is no failing value.",
	"Method": "E fail(Validation<E, T> fail,E e){\r\n    return validation(Either.left(e));\r\n}"
}, {
	"Path": "fj.data.IOFunctions.enumFileCharChunks",
	"Comment": "an io monad that reads char chunks from the given file and passes them to the given iteratee.",
	"Method": "IO<IterV<char[], A>> enumFileCharChunks(File f,Option<Charset> encoding,IterV<char[], A> i){\r\n    return bracket(fileReader(f, encoding), Function.vary(closeReader), partialApply2(IOFunctions.charChunkReader(), i));\r\n}"
}, {
	"Path": "fj.data.Stream.single",
	"Comment": "returns a function that yields a stream containing its argument.",
	"Method": "Stream<A> single(A a,F<A, Stream<A>> single){\r\n    return Stream::single;\r\n}"
}, {
	"Path": "fj.F1Functions.onRight",
	"Comment": "returns a function that returns the right side of a given either, or this function applied to the left side.",
	"Method": "F<Either<A, B>, B> onRight(F<A, B> f){\r\n    return e -> e.right().on(f);\r\n}"
}, {
	"Path": "fj.data.LazyString.unwords",
	"Comment": "joins the given stream of lazy strings into one, separated by spaces.",
	"Method": "LazyString unwords(Stream<LazyString> str){\r\n    return fromStream(join(str.intersperse(str(\" \")).map(toStream)));\r\n}"
}, {
	"Path": "fj.data.Either.traverseStreamRight",
	"Comment": "traversable instance of rightprojection of either for stream.",
	"Method": "Stream<Either<A, C>> traverseStreamRight(F<B, Stream<C>> f){\r\n    return right().traverseStream(f);\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.ExtraFileHandler.copyFile",
	"Comment": "helper method for copying a file from a directory to another.",
	"Method": "void copyFile(Resource inputDirectory,String inputFileName,Resource outputDirectory,String outputFileName){\r\n    Resource inputFile = inputDirectory.get(inputFileName);\r\n    if (!Resources.exists(inputFile)) {\r\n        return;\r\n    }\r\n    if (Resources.exists(outputDirectory) && outputDirectory.getType() == Type.DIRECTORY) {\r\n        Resource outputFile = outputDirectory.get(outputFileName);\r\n        try (InputStream input = inputFile.in();\r\n            OutputStream output = outputFile.out()) {\r\n            IOUtils.copy(input, output);\r\n        } catch (Exception exception) {\r\n            throw new RuntimeException(String.format(\"Error copying file '%s' to file '%s'.\", inputFile, outputFile), exception);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "fj.data.properties.PriorityQueueProperties.addRemove",
	"Comment": "adding a priority that is at the top and then removing it returns the original top.",
	"Method": "Property addRemove(){\r\n    return property(arbPriorityQueueIntegerString, arbInteger, arbAlphaNumString, (q, i, s) -> {\r\n        Option<P2<Integer, String>> t1 = q.top();\r\n        Option<P2<Integer, String>> t2 = q.enqueue(i, s).dequeue().top();\r\n        return prop(q.isLessThan(Ord.intOrd, i) ? t1.equals(t2) : t2.map(p -> p._1() >= i).orSome(true));\r\n    });\r\n}"
}, {
	"Path": "fj.data.Stream.interleave",
	"Comment": "interleaves the given stream with this stream to produce a new stream.",
	"Method": "Stream<A> interleave(Stream<A> as){\r\n    return isEmpty() ? as : as.isEmpty() ? this : cons(head(), () -> as.interleave(tail()._1()));\r\n}"
}, {
	"Path": "org.geogig.geoserver.functional.GeoServerTestSupport.postFile",
	"Comment": "issue a post request to the provided url with the given file passed as form data.",
	"Method": "MockHttpServletResponse postFile(String resourceUri,String formFieldName,File file){\r\n    try (FileInputStream fis = new FileInputStream(file)) {\r\n        MockMultipartFile mFile = new MockMultipartFile(formFieldName, fis);\r\n        MockMultipartHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders.fileUpload(new URI(resourceUri)).file(mFile);\r\n        MockHttpServletRequest request = requestBuilder.buildRequest(applicationContext.getServletContext());\r\n        request.setScheme(\"http\");\r\n        request.setServerName(\"localhost\");\r\n        request.setServerPort(8080);\r\n        request.setContextPath(\"/geoserver\");\r\n        request.setRequestURI(ResponseUtils.stripQueryString(ResponseUtils.appendPath(\"/geoserver/\", resourceUri)));\r\n        request.setQueryString(ResponseUtils.getQueryString(resourceUri));\r\n        request.setRemoteAddr(\"127.0.0.1\");\r\n        request.setServletPath(ResponseUtils.makePathAbsolute(ResponseUtils.stripRemainingPath(resourceUri)));\r\n        request.setPathInfo(ResponseUtils.makePathAbsolute(ResponseUtils.stripBeginningPath(ResponseUtils.stripQueryString(resourceUri))));\r\n        request.addHeader(\"Host\", \"localhost:8080\");\r\n        if (username != null) {\r\n            String token = username + \":\";\r\n            if (password != null) {\r\n                token += password;\r\n            }\r\n            request.addHeader(\"Authorization\", \"Basic \" + new String(Base64.encodeBase64(token.getBytes())));\r\n        }\r\n        kvp(request, resourceUri);\r\n        request.setUserPrincipal(null);\r\n        return dispatch(request);\r\n    }\r\n}"
}, {
	"Path": "fj.parser.Parser.repeat1",
	"Comment": "returns a parser that repeats application of this parser one or many times.",
	"Method": "Parser<I, Stream<A>, E> repeat1(){\r\n    return bind(a -> repeat().map(as -> as.cons(a)));\r\n}"
}, {
	"Path": "fj.data.Validation.accumulate",
	"Comment": "accumulates errors on the failing side of this or any given validation if one or more are encountered, or appliesthe given function if all succeeded and returns that value on the successful side.",
	"Method": "Validation<E, B> accumulate(Semigroup<E> s,Validation<E, A> va,F<T, F<A, B>> f,Validation<E, B> accumulate,Semigroup<E> s,Validation<E, A> va,F2<T, A, B> f,Option<E> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, C> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,F<T, F<A, F<B, C>>> f,Validation<E, C> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,F3<T, A, B, C> f,Option<E> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, D> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, C> vc,F<T, F<A, F<B, F<C, D>>>> f,Validation<E, D> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, C> vc,F4<T, A, B, C, D> f,Option<E> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, C> vc,Validation<E, E$> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, C> vc,Validation<E, D> vd,F<T, F<A, F<B, F<C, F<D, E$>>>>> f,Validation<E, E$> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, C> vc,Validation<E, D> vd,F5<T, A, B, C, D, E$> f,Option<E> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, C> vc,Validation<E, D> vd,Validation<E, F$> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, C> vc,Validation<E, D> vd,Validation<E, E$> ve,F<T, F<A, F<B, F<C, F<D, F<E$, F$>>>>>> f,Validation<E, F$> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, C> vc,Validation<E, D> vd,Validation<E, E$> ve,F6<T, A, B, C, D, E$, F$> f,Option<E> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, C> vc,Validation<E, D> vd,Validation<E, E$> ve,Validation<E, G> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, C> vc,Validation<E, D> vd,Validation<E, E$> ve,Validation<E, F$> vf,F<T, F<A, F<B, F<C, F<D, F<E$, F<F$, G>>>>>>> f,Validation<E, G> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, C> vc,Validation<E, D> vd,Validation<E, E$> ve,Validation<E, F$> vf,F7<T, A, B, C, D, E$, F$, G> f,Option<E> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, C> vc,Validation<E, D> vd,Validation<E, E$> ve,Validation<E, F$> vf,Validation<E, H> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, C> vc,Validation<E, D> vd,Validation<E, E$> ve,Validation<E, F$> vf,Validation<E, G> vg,F<T, F<A, F<B, F<C, F<D, F<E$, F<F$, F<G, H>>>>>>>> f,Validation<E, H> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, C> vc,Validation<E, D> vd,Validation<E, E$> ve,Validation<E, F$> vf,Validation<E, G> vg,F8<T, A, B, C, D, E$, F$, G, H> f,Option<E> accumulate,Semigroup<E> s,Validation<E, A> va,Validation<E, B> vb,Validation<E, C> vc,Validation<E, D> vd,Validation<E, E$> ve,Validation<E, F$> vf,Validation<E, G> vg,Validation<List<E>, T> accumulate,Validation<List<E>, B> accumulate,F<T, B> f,Validation<List<E>, C> accumulate,Validation<E, B> v2,F2<T, B, C> f,Validation<List<E>, D> accumulate,Validation<E, B> v2,Validation<E, C> v3,F3<T, B, C, D> f,Validation<List<E>, $E> accumulate,Validation<E, B> v2,Validation<E, C> v3,Validation<E, D> v4,F4<T, B, C, D, $E> f,Validation<List<E>, $F> accumulate,Validation<E, B> v2,Validation<E, C> v3,Validation<E, D> v4,Validation<E, $E> v5,F5<T, B, C, D, $E, $F> f,Validation<List<E>, G> accumulate,Validation<E, B> v2,Validation<E, C> v3,Validation<E, D> v4,Validation<E, $E> v5,Validation<E, $F> v6,F6<T, B, C, D, $E, $F, G> f,Validation<List<E>, H> accumulate,Validation<E, B> v2,Validation<E, C> v3,Validation<E, D> v4,Validation<E, $E> v5,Validation<E, $F> v6,Validation<E, G> v7,F7<T, B, C, D, $E, $F, G, H> f,Validation<List<E>, I> accumulate,Validation<E, B> v2,Validation<E, C> v3,Validation<E, D> v4,Validation<E, $E> v5,Validation<E, $F> v6,Validation<E, G> v7,Validation<E, H> v8,F8<T, B, C, D, $E, $F, G, H, I> f){\r\n    List<E> list = fails(list(this, v2, v3, v4, v5));\r\n    if (!list.isEmpty()) {\r\n        return fail(list);\r\n    } else {\r\n        return success(f.f(success(), v2.success(), v3.success(), v4.success(), v5.success(), v6.success(), v7.success(), v8.success()));\r\n    }\r\n}"
}, {
	"Path": "fj.F1W.successK",
	"Comment": "promotes this function so that it returns its result on the success side of an validation.kleisli arrow for the validation success projection.",
	"Method": "F1W<A, Validation<C, B>> successK(){\r\n    return lift(F1Functions.successK(this));\r\n}"
}, {
	"Path": "fj.data.Array.bind",
	"Comment": "binds the given function across each element of this array and the given array with a finaljoin.",
	"Method": "Array<B> bind(F<A, Array<B>> f,Array<C> bind,Array<B> sb,F<A, F<B, C>> f,Array<C> bind,Array<B> sb,F2<A, B, C> f,Array<B> bind,F<A, Array<B>> f){\r\n    return bind(sb, curry(f));\r\n}"
}, {
	"Path": "fj.Bottom.undefined",
	"Comment": "returns an error to represent undefinedness in a computation.",
	"Method": "Error undefined(){\r\n    return error(\"undefined\");\r\n}"
}, {
	"Path": "fj.data.fingertrees.FingerTree.emptyIntMax",
	"Comment": "returns a finger tree which combines the integer node annotations with themaximum function.a priority queue with integer priorities.",
	"Method": "FingerTree<Integer, P2<Integer, A>> emptyIntMax(){\r\n    return empty(intMaxMonoid, (P2<Integer, A> p) -> p._1());\r\n}"
}, {
	"Path": "fj.data.List.partition",
	"Comment": "partitions the list into a tuple where the first element contains theitems that satisfy the the predicate f and the second element contains theitems that does not.the relative order of the elements in the returned tupleis the same as the original list.",
	"Method": "List<List<A>> partition(int n,P2<List<A>, List<A>> partition,F<A, Boolean> f){\r\n    P2<List<A>, List<A>> p2 = foldLeft((acc, a) -> f.f(a) ? p(acc._1().cons(a), acc._2()) : p(acc._1(), acc._2().cons(a)), p(nil(), nil()));\r\n    return p(p2._1().reverse(), p2._2().reverse());\r\n}"
}, {
	"Path": "fj.F1W.mapSnd",
	"Comment": "promotes this function to map over the second element of a pair.",
	"Method": "F1W<P2<C, A>, P2<C, B>> mapSnd(){\r\n    return lift(F1Functions.mapSnd(this));\r\n}"
}, {
	"Path": "fj.P2.map",
	"Comment": "maps the given function across both the elements of the given product.",
	"Method": "P2<B, B> map(F<A, B> f,P2<A, A> p){\r\n    return p.split(f, f);\r\n}"
}, {
	"Path": "fj.data.List.init",
	"Comment": "returns all but the last element of this list. undefiend for the empty list.",
	"Method": "List<A> init(){\r\n    List<A> ys = this;\r\n    final Buffer<A> a = empty();\r\n    while (ys.isNotEmpty() && ys.tail().isNotEmpty()) {\r\n        a.snoc(ys.head());\r\n        ys = ys.tail();\r\n    }\r\n    return a.toList();\r\n}"
}, {
	"Path": "fj.data.fingertrees.FingerTree.mkTree",
	"Comment": "returns a builder of trees and tree components that annotates them using the given measured instance.",
	"Method": "MakeTree<V, A> mkTree(Measured<V, A> m){\r\n    return new MakeTree(m);\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.tasklet.GenericTasklet.putContinuableHandlers",
	"Comment": "put the provided continuable jobs in the job execution context overriding any existing ones.",
	"Method": "void putContinuableHandlers(JobExecution jobExecution,List<GenericTaskletHandler> handlers){\r\n    jobExecution.getExecutionContext().put(GENERIC_CONTINUABLE_HANDLERS_KEY, handlers);\r\n}"
}, {
	"Path": "fj.function.Visitor.associationLazy",
	"Comment": "uses an association list to perform a lookup with equality and returns a function that can be applied to a default,followed by the associated key to return a value.",
	"Method": "F<P1<B>, F<A, B>> associationLazy(List<P2<A, B>> x,Equal<A> eq){\r\n    return curry((def, a) -> lookup(eq, x, a).orSome(def));\r\n}"
}, {
	"Path": "fj.data.Zipper.deleteLeft",
	"Comment": "possibly deletes the element at the focus, then moves the element on the left into focus.if no element is on the left, focus on the element to the right.returns none if the focus element is the only element in this zipper.",
	"Method": "Option<Zipper<A>> deleteLeft(){\r\n    return left.isEmpty() && right.isEmpty() ? Option.none() : some(zipper(left.isEmpty() ? left : left.tail()._1(), left.isEmpty() ? right.head() : left.head(), left.isEmpty() ? right.tail()._1() : right));\r\n}"
}, {
	"Path": "fj.test.Shrink.shrinkArrayList",
	"Comment": "returns a shrink strategy for array lists. an empty array list is fully shrunk.",
	"Method": "Shrink<ArrayList<A>> shrinkArrayList(Shrink<A> sa){\r\n    return shrinkList(sa).map(Java.List_ArrayList(), Java.ArrayList_List());\r\n}"
}, {
	"Path": "fj.data.TreeZipper.modifyLabel",
	"Comment": "modifies the label at the current node with the given function.",
	"Method": "TreeZipper<A> modifyLabel(F<A, A> f){\r\n    return setLabel(f.f(getLabel()));\r\n}"
}, {
	"Path": "fj.Monoid.join",
	"Comment": "intersperses the given value between each two elements of the iterable, and sums the result.",
	"Method": "A join(Iterable<A> as,A a){\r\n    final Stream<A> s = iterableStream(as);\r\n    F<A, A> prependA = def.prepend(a);\r\n    return s.isEmpty() ? def.empty() : s.foldLeft1((a1, a2) -> def.append(a1, prependA.f(a2)));\r\n}"
}, {
	"Path": "fj.data.Stream.iterateWhile",
	"Comment": "creates a stream where the first item is calculated by applying the function on the third argument,the second item by applying the function on the previous result and so on.",
	"Method": "Stream<A> iterateWhile(F<A, A> f,F<A, Boolean> p,A a){\r\n    return unfold(o -> Option.iif(p2 -> p.f(o), p(o, f.f(o))), a);\r\n}"
}, {
	"Path": "fj.data.IOFunctions.sequence",
	"Comment": "evaluate each action in the sequence from left to right, and collect the results.",
	"Method": "IO<List<A>> sequence(List<IO<A>> list,IO<Stream<A>> sequence,Stream<IO<A>> stream){\r\n    F2<IO<Stream<A>>, IO<A>, IO<Stream<A>>> f2 = (ioList, io) -> bind(ioList, (xs) -> map(io, x -> Stream.cons(x, () -> xs)));\r\n    return stream.foldLeft(f2, unit(Stream.nil()));\r\n}"
}, {
	"Path": "fj.test.Cogen.compose",
	"Comment": "composes the given function with this cogen to produce a new cogen.",
	"Method": "Cogen<B> compose(F<B, A> f){\r\n    return new Cogen<B>() {\r\n        public <X> Gen<X> cogen(final B b, final Gen<X> g) {\r\n            return Cogen.this.cogen(f.f(b), g);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "fj.test.Cogen.compose",
	"Comment": "composes the given function with this cogen to produce a new cogen.",
	"Method": "Cogen<B> compose(F<B, A> f){\r\n    return Cogen.this.cogen(f.f(b), g);\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.AbstractExecutionAdapter.getAllFailureExceptions",
	"Comment": "return all failure causing exceptions for this jobexecution, including step executions.",
	"Method": "List<Throwable> getAllFailureExceptions(){\r\n    return delegate.getAllFailureExceptions();\r\n}"
}, {
	"Path": "fj.P2.inject",
	"Comment": "replaces the first element of this product with the given value.",
	"Method": "P2<C, B> inject(C c){\r\n    final F<P2<A, B>, C> co = constant(c);\r\n    return cobind(co);\r\n}"
}, {
	"Path": "fj.F1W.mapFst",
	"Comment": "promotes this function to map over the first element of a pair.",
	"Method": "F1W<P2<A, C>, P2<B, C>> mapFst(){\r\n    return lift(F1Functions.mapFst(this));\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.NativeSelectElement.setValue",
	"Comment": "select item of the native select element with the specified value.",
	"Method": "void setValue(CharSequence chars){\r\n    selectByText((String) chars);\r\n}"
}, {
	"Path": "fj.data.List.minimumOption",
	"Comment": "returns the minimum element in this list according to the given ordering.",
	"Method": "Option<A> minimumOption(Ord<A> o){\r\n    return NonEmptyList.fromList(this).map(nel -> nel.minimum(o));\r\n}"
}, {
	"Path": "fj.control.parallel.Promise.sequenceW",
	"Comment": "applies a stream of comonadic functions to this promise, returning a stream of values.",
	"Method": "Stream<B> sequenceW(Stream<F<Promise<A>, B>> fs){\r\n    return fs.isEmpty() ? Stream.nil() : Stream.cons(fs.head().f(this), () -> sequenceW(fs.tail()._1()));\r\n}"
}, {
	"Path": "fj.data.Validation.on",
	"Comment": "the success value or the application of the given function to the failing value.",
	"Method": "T on(F<E, T> f,E on,F<T, E> f){\r\n    return e.right().on(f);\r\n}"
}, {
	"Path": "fj.F1W.mapLeft",
	"Comment": "promotes this function to map over the left side of an either.",
	"Method": "F1W<Either<A, X>, Either<B, X>> mapLeft(){\r\n    return lift(F1Functions.mapLeft(this));\r\n}"
}, {
	"Path": "fj.F1W.mapSuccess",
	"Comment": "promotes this function to map over the success side of a validation.",
	"Method": "F1W<Validation<X, A>, Validation<X, B>> mapSuccess(){\r\n    return lift(F1Functions.mapSuccess(this));\r\n}"
}, {
	"Path": "fj.data.List.inits",
	"Comment": "returns the list of initial segments of this list, shortest first.",
	"Method": "List<List<A>> inits(){\r\n    List<List<A>> s = single(List.nil());\r\n    if (isNotEmpty())\r\n        s = s.append(tail().inits().map(List.<A>cons().f(head())));\r\n    return s;\r\n}"
}, {
	"Path": "fj.data.List.iterateWhile",
	"Comment": "creates a list where the first item is calculated by applying the function on the third argument,the second item by applying the function on the previous result and so on.",
	"Method": "List<A> iterateWhile(F<A, A> f,F<A, Boolean> p,A a){\r\n    return unfold(o -> Option.iif(p2 -> p.f(o), p(o, f.f(o))), a);\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.NativeSelectElement.clear",
	"Comment": "clear operation is not supported for native select. this operation has noeffect on native select element.",
	"Method": "void clear(){\r\n    super.clear();\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.TableElement.getCell",
	"Comment": "function to find a table cell. looking for a cell that is currently notvisible will throw nosuchelementexception",
	"Method": "TestBenchElement getCell(int row,int column){\r\n    TestBenchElement cell = wrapElement(findElement(By.vaadin(\"#row[\" + row + \"]/col[\" + column + \"]\")), getCommandExecutor());\r\n    return cell;\r\n}"
}, {
	"Path": "fj.Monoid.sum",
	"Comment": "returns a function that sums the given value according to this monoid.",
	"Method": "A sum(F0<Stream<A>> as,A sum,A a,F0<Stream<A>> as,A sum,A a1,A a2,F<A, A> sum,A a1,F<A, F<A, A>> sum){\r\n    return def::prepend;\r\n}"
}, {
	"Path": "org.geoserver.jdbcconfig.internal.QueryBuilder.isOffsetLimitApplied",
	"Comment": "when the query was built, were the offset and limit included.",
	"Method": "boolean isOffsetLimitApplied(){\r\n    return offsetLimitApplied;\r\n}"
}, {
	"Path": "fj.data.Option.iif",
	"Comment": "returns an optional value that has a value of the given argument if the given boolean is true, otherwise, returnsno value.",
	"Method": "Option<A> iif(F<A, Boolean> f,A a,Option<A> iif,boolean p,F0<A> a,Option<A> iif,boolean p,A a,F2<F<A, Boolean>, A, Option<A>> iif){\r\n    return Option::iif;\r\n}"
}, {
	"Path": "fj.data.Stream.orTail",
	"Comment": "returns the tail of this stream if there is one or the given argument if this stream is empty.",
	"Method": "P1<Stream<A>> orTail(F0<Stream<A>> as){\r\n    return isEmpty() ? P.lazy(as) : tail();\r\n}"
}, {
	"Path": "fj.data.Java.Either_ConcurrentLinkedQueueA",
	"Comment": "a function that converts eithers to concurrent linked queues.",
	"Method": "F<Either<A, B>, ConcurrentLinkedQueue<A>> Either_ConcurrentLinkedQueueA(){\r\n    return Function.compose(Java.Option_ConcurrentLinkedQueue(), Conversions.Either_OptionA());\r\n}"
}, {
	"Path": "fj.data.Java.Either_ConcurrentLinkedQueueB",
	"Comment": "a function that converts eithers to concurrent linked queues.",
	"Method": "F<Either<A, B>, ConcurrentLinkedQueue<B>> Either_ConcurrentLinkedQueueB(){\r\n    return Function.compose(Java.Option_ConcurrentLinkedQueue(), Conversions.Either_OptionB());\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.AbstractSplitPanelElement.getFirstComponent",
	"Comment": "gets the first component of a split panel and wraps it in given class.",
	"Method": "T getFirstComponent(Class<T> clazz){\r\n    return getContainedComponent(clazz, byFirstContainer);\r\n}"
}, {
	"Path": "fj.Function.nullable",
	"Comment": "return a function that inspects the argument of the given function for a null value and if so, doesnot apply the value, instead returning an empty optional value.",
	"Method": "F<A, Option<B>> nullable(F<A, B> f){\r\n    return a -> a == null ? Option.none() : Option.some(f.f(a));\r\n}"
}, {
	"Path": "org.geoserver.cluster.impl.handlers.configuration.JMSGeoServerHandler.localizeContactInfo",
	"Comment": "return the updated local contactinfo object replacing all the members with the ones comingfrom the passed contactinfo",
	"Method": "ContactInfo localizeContactInfo(GeoServer geoServer,ContactInfo deserInfo){\r\n    if (geoServer == null || deserInfo == null)\r\n        throw new IllegalArgumentException(\"Wrong passed arguments are null\");\r\n    final ContactInfo info = geoServer.getGlobal().getSettings().getContact();\r\n    BeanUtils.copyProperties(info, deserInfo);\r\n    return info;\r\n}"
}, {
	"Path": "fj.F1W.failK",
	"Comment": "promotes this function so that it returns its result on the failure side of a validation.kleisli arrow for the validation failure projection.",
	"Method": "F1W<A, Validation<B, C>> failK(){\r\n    return lift(F1Functions.failK(this));\r\n}"
}, {
	"Path": "fj.test.Property.implies",
	"Comment": "returns a property that produces a result only if the given condition satisfies. the resultwill be taken from the given property.",
	"Method": "Property implies(boolean b,F0<Property> p){\r\n    return b ? p.f() : new Property(i -> r -> noResult());\r\n}"
}, {
	"Path": "com.vaadin.tests.tb3.AbstractTB3Test.getFocusedElement",
	"Comment": "uses javascript to determine the currently focused element.",
	"Method": "WebElement getFocusedElement(){\r\n    Object focusedElement = executeScript(\"return document.activeElement\");\r\n    if (null != focusedElement) {\r\n        return (WebElement) focusedElement;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.tests.components.notification.NotificationsWaiAriaTest.notificationTest",
	"Comment": "checks if the aria roles are correctly applied to notification.",
	"Method": "void notificationTest(){\r\n    openTestURL();\r\n    TextFieldElement prefix = $(TextFieldElement.class).first();\r\n    TextFieldElement postfix = $(TextFieldElement.class).get(1);\r\n    NativeSelectElement type = $(NativeSelectElement.class).first();\r\n    ButtonElement show = $(ButtonElement.class).first();\r\n    prefix.clear();\r\n    prefix.sendKeys(\"Prefix:\");\r\n    postfix.clear();\r\n    postfix.sendKeys(\"- press ESC to close\");\r\n    type.selectByText(StringToEnumConverter.enumToString(NotificationRole.ALERT, null));\r\n    show.click();\r\n    waitForElementPresent(By.className(\"v-Notification\"));\r\n    NotificationElement notification = $(NotificationElement.class).first();\r\n    String text = notification.getAttribute(\"role\");\r\n    assertTrue(\"Expected attribute 'role' to equal 'alert', found \" + text, text.equals(\"alert\"));\r\n    text = getHiddenText(notification.findElements(By.className(\"v-assistive-device-only\")).get(0));\r\n    assertTrue(\"Expected 'Prefix:', found \" + text, text.equals(\"Prefix:\"));\r\n    text = getHiddenText(notification.findElements(By.className(\"v-assistive-device-only\")).get(1));\r\n    assertTrue(\"Expected '- press ESC to close', found \" + text, text.equals(\"- press ESC to close\"));\r\n    notification.close();\r\n    type.selectByText(StringToEnumConverter.enumToString(NotificationRole.STATUS, null));\r\n    show.click();\r\n    waitForElementPresent(By.className(\"v-Notification\"));\r\n    notification = $(NotificationElement.class).first();\r\n    text = notification.getAttribute(\"role\");\r\n    assertTrue(\"Expected attribute 'role' to equal 'status', found \" + text, text.equals(\"status\"));\r\n    notification.close();\r\n    prefix.clear();\r\n    postfix.clear();\r\n    show.click();\r\n    waitForElementPresent(By.className(\"v-Notification\"));\r\n    WebElement element;\r\n    try {\r\n        element = getDriver().findElement(By.vaadin(\"Root/VNotification[0]/domChild[0]/domChild[0]/domChild[1]\"));\r\n    } catch (Exception e) {\r\n        element = null;\r\n    }\r\n    assertNull(\"Notification shouldn't have assistive-device-only spans\", element);\r\n}"
}, {
	"Path": "com.vaadin.tests.tb3.AbstractTB3Test.selectMenuPath",
	"Comment": "selects a submenu described by a path of menus from the first menubar inthe ui.",
	"Method": "void selectMenuPath(String menuCaptions){\r\n    selectMenu(menuCaptions[0], true);\r\n    waitUntil(e -> isElementPresent(By.className(\"gwt-MenuBarPopup\")) || isElementPresent(By.className(\"v-menubar-popup\")));\r\n    new Actions(getDriver()).moveByOffset(0, getMenuElement(menuCaptions[0]).getSize().getHeight()).perform();\r\n    for (int i = 1; i < menuCaptions.length - 1; i++) {\r\n        selectMenu(menuCaptions[i]);\r\n        new Actions(getDriver()).moveByOffset(getMenuElement(menuCaptions[i]).getSize().getWidth(), 0).build().perform();\r\n    }\r\n    selectMenu(menuCaptions[menuCaptions.length - 1], true);\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.writer.CatalogMultiResourceItemWriter.setResourceSuffixCreator",
	"Comment": "allows customization of the suffix of the created resources based on the index.",
	"Method": "void setResourceSuffixCreator(ResourceSuffixCreator suffixCreator){\r\n    this.suffixCreator = suffixCreator;\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.ComboBoxElement.selectByText",
	"Comment": "selects the first option in the combobox which matches the given text.",
	"Method": "void selectByText(String text){\r\n    if (isReadOnly()) {\r\n        throw new ReadOnlyException();\r\n    }\r\n    if (!isTextInputAllowed()) {\r\n        selectByTextFromPopup(text);\r\n        return;\r\n    }\r\n    getInputField().clear();\r\n    getInputField().sendKeys(text);\r\n    selectSuggestion(text);\r\n}"
}, {
	"Path": "fj.control.Trampoline.pure",
	"Comment": "constructs a pure computation that results in the given value.",
	"Method": "F<A, Trampoline<A>> pure(Trampoline<A> pure,A a){\r\n    return new Pure(a);\r\n}"
}, {
	"Path": "fj.data.DList.snoc",
	"Comment": "appends a single element on the end of the dlist to produce a new dlist.",
	"Method": "DList<A> snoc(A a){\r\n    return this.append(single(a));\r\n}"
}, {
	"Path": "fj.data.Java.Option_PriorityBlockingQueue",
	"Comment": "a function that converts options to priority blocking queues.",
	"Method": "F<Option<A>, PriorityBlockingQueue<A>> Option_PriorityBlockingQueue(){\r\n    return as -> new PriorityBlockingQueue(as.toCollection());\r\n}"
}, {
	"Path": "org.geoserver.security.AbstractAuthenticationKeyMapper.getAvailableParameters",
	"Comment": "returns the list of configuration parameters supported by the mapper.",
	"Method": "Set<String> getAvailableParameters(){\r\n    return new HashSet<String>();\r\n}"
}, {
	"Path": "org.geogig.geoserver.functional.GeoServerTestSupport.postContent",
	"Comment": "issue a post request to the provided url with the given content.",
	"Method": "MockHttpServletResponse postContent(String contentType,String resourceUri,String postContent){\r\n    MockHttpServletRequest req = createRequest(resourceUri);\r\n    req.setContentType(contentType);\r\n    req.addHeader(\"Content-Type\", contentType);\r\n    req.setMethod(\"POST\");\r\n    req.setContent(postContent == null ? null : postContent.getBytes());\r\n    return dispatch(req);\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.writer.CatalogFileWriter.setTransactional",
	"Comment": "flag to indicate that writing to the buffer should be delayed if a transaction is active.defaults to true.",
	"Method": "void setTransactional(boolean transactional){\r\n    this.transactional = transactional;\r\n}"
}, {
	"Path": "fj.data.List.insertBy",
	"Comment": "inserts the given element before the first element that is greater than or equal to it accordingto the given ordering.",
	"Method": "List<A> insertBy(F<A, F<A, Ordering>> f,A x){\r\n    List<A> ys = this;\r\n    Buffer<A> xs = empty();\r\n    while (ys.isNotEmpty() && f.f(x).f(ys.head()) == GT) {\r\n        xs = xs.snoc(ys.head());\r\n        ys = ys.tail();\r\n    }\r\n    return xs.append(ys.cons(x)).toList();\r\n}"
}, {
	"Path": "fj.data.State.sequence",
	"Comment": "evaluate each action in the sequence from left to right, and collect the results.",
	"Method": "State<S, List<A>> sequence(List<State<S, A>> list){\r\n    return list.foldLeft((acc, ts) -> acc.flatMap(as -> ts.map(a -> cons(a, as))), State.<S, List<A>>constant(List.nil())).map(as -> as.reverse());\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.writer.CatalogFileWriter.open",
	"Comment": "initialize the reader. this method may be called multiple times before close is called.",
	"Method": "void open(ExecutionContext executionContext){\r\n    super.open(executionContext);\r\n    Assert.notNull(resource, \"The resource must be set\");\r\n    if (!getOutputState().isInitialized()) {\r\n        try {\r\n            doOpen(executionContext);\r\n        } catch (ItemStreamException e) {\r\n            logValidationExceptions((T) null, new WriteFailedException(\"Could not write data.  The file may be corrupt.\", e));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "fj.data.Validation.toStream",
	"Comment": "returns a single element stream if this is a success value, otherwise an empty list.",
	"Method": "Stream<T> toStream(Stream<E> toStream){\r\n    return e.right().toStream();\r\n}"
}, {
	"Path": "fj.data.Stream.zapp",
	"Comment": "zips this stream with the given stream of functions, applying each function in turn to thecorresponding element in this stream to produce a new stream. if this stream and the given streamhave different lengths, then the longer stream is normalised so this function never fails.",
	"Method": "Stream<B> zapp(Stream<F<A, B>> fs){\r\n    return fs.isEmpty() || isEmpty() ? Stream.nil() : cons(fs.head().f(head()), () -> tail()._1().zapp(fs.tail()._1()));\r\n}"
}, {
	"Path": "com.vaadin.tests.minitutorials.v7b9.SettingsView.hideOrShowButtons",
	"Comment": "hide or show buttons depending on whether date is modified or not",
	"Method": "void hideOrShowButtons(){\r\n    apply.setVisible(date.isModified());\r\n    cancel.setVisible(date.isModified());\r\n}"
}, {
	"Path": "fj.function.Booleans.cond",
	"Comment": "curried form of conditional. if the first argument is true, returns the second argument,otherwise the third argument.",
	"Method": "F<Boolean, F<A, F<A, A>>> cond(){\r\n    return curry((p, a1, a2) -> p ? a1 : a2);\r\n}"
}, {
	"Path": "fj.Monoid.monoidDef",
	"Comment": "constructs a monoid from the given semigroup definition and zero value, which must follow the monoidal laws.",
	"Method": "Monoid<A> monoidDef(Definition<A> def,Monoid<A> monoidDef,AltDefinition<A> def,Monoid<A> monoidDef,Semigroup.Definition<A> s,A zero,Monoid<A> monoidDef,Semigroup.AltDefinition<A> s,A zero){\r\n    return monoidDef((Semigroup.Definition<A>) s, zero);\r\n}"
}, {
	"Path": "fj.data.Zipper.cyclePrevious",
	"Comment": "move the focus to the previous element. if the first element is focused, loop to the last element.",
	"Method": "Zipper<A> cyclePrevious(){\r\n    if (left.isEmpty() && right.isEmpty())\r\n        return this;\r\n    else if (left.isEmpty()) {\r\n        final Stream<A> xs = right.reverse();\r\n        return zipper(xs.tail()._1().snoc(P.p(focus)), xs.head(), Stream.nil());\r\n    } else\r\n        return tryPrevious();\r\n}"
}, {
	"Path": "fj.control.parallel.Strategy.mergeAll",
	"Comment": "waits for every future in a list to obtain a value, and collects those values in a list.",
	"Method": "List<P1<A>> mergeAll(List<Future<A>> xs){\r\n    return xs.map(Strategy.obtain());\r\n}"
}, {
	"Path": "fj.data.Seq.drop",
	"Comment": "drops the given number of elements from the head of this sequence if they are available.",
	"Method": "Seq<A> drop(int n){\r\n    return split(n)._2();\r\n}"
}, {
	"Path": "org.geoserver.cluster.impl.handlers.configuration.JMSGeoServerHandler.localizeSettingsInfo",
	"Comment": "return the local settingsinfo updating its member with the ones coming from the passedjaiinfo",
	"Method": "SettingsInfo localizeSettingsInfo(GeoServer geoServer,SettingsInfo deserInfo){\r\n    if (geoServer == null || deserInfo == null)\r\n        throw new IllegalArgumentException(\"Wrong passed arguments are null\");\r\n    final SettingsInfo info = geoServer.getSettings();\r\n    BeanUtils.copyProperties(info, deserInfo);\r\n    final WorkspaceInfo workspace = info.getWorkspace();\r\n    if (workspace != null) {\r\n        info.setWorkspace(CatalogUtils.localizeWorkspace(workspace, geoServer.getCatalog()));\r\n    }\r\n    final ContactInfo contact = info.getContact();\r\n    if (contact != null) {\r\n        info.setContact(localizeContactInfo(geoServer, contact));\r\n    }\r\n    return info;\r\n}"
}, {
	"Path": "fj.data.$.__",
	"Comment": "returns a function that given an argument, returns a function that ignores its argument.",
	"Method": "$<A, B> __(B b){\r\n    return constant(b);\r\n}"
}, {
	"Path": "fj.data.List.take",
	"Comment": "takes the given number of elements from the head of this list if they are available.",
	"Method": "List<A> take(int i,F<Integer, F<List<A>, List<A>>> take){\r\n    return curry((n, as) -> as.take(n));\r\n}"
}, {
	"Path": "fj.data.List.maximum",
	"Comment": "returns the maximum element in this list according to the given ordering.",
	"Method": "A maximum(Ord<A> o){\r\n    return foldLeft1(o::max);\r\n}"
}, {
	"Path": "fj.data.Zipper.tryNext",
	"Comment": "attempts to move the focus to the next element, or throws an error if there are no more elements.",
	"Method": "Zipper<A> tryNext(){\r\n    if (right.isEmpty())\r\n        throw new Error(\"Tried next at the end of a zipper.\");\r\n    else\r\n        return zipper(left.cons(focus), right.head(), right.tail()._1());\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.TreeElement.asTreeGrid",
	"Comment": "convenience method for accessing the underlying treegrid.",
	"Method": "TreeGridElement asTreeGrid(){\r\n    return wrap(TreeGridElement.class);\r\n}"
}, {
	"Path": "fj.test.Arbitrary.arbEnumValue",
	"Comment": "returns an arbitrary implementation for a java enumeration.",
	"Method": "Gen<A> arbEnumValue(Class<A> clazz){\r\n    return elements(clazz.getEnumConstants());\r\n}"
}, {
	"Path": "com.vaadin.tests.tb3.AbstractTB3Test.getLogRow",
	"Comment": "for tests extending abstracttestuiwithlog, returns the text in the nthlog row",
	"Method": "String getLogRow(int rowNr){\r\n    return getLogRowElement(rowNr).getText();\r\n}"
}, {
	"Path": "fj.data.Zipper.deleteRight",
	"Comment": "possibly deletes the element at the focus, then moves the element on the right into focus.if no element is on the right, focus on the element to the left.returns none if the focus element is the only element in this zipper.",
	"Method": "Option<Zipper<A>> deleteRight(){\r\n    return left.isEmpty() && right.isEmpty() ? Option.none() : some(zipper(right.isEmpty() ? left.tail()._1() : left, right.isEmpty() ? left.head() : right.head(), right.isEmpty() ? right : right.tail()._1()));\r\n}"
}, {
	"Path": "org.geoserver.wms.dynamic.legendgraphic.DynamicGetLegendGraphicDispatcherCallback.createTestEnvelope",
	"Comment": "create a small 2x2 envelope to be used to read a small coverage in order to retrievestatistics from it",
	"Method": "ReferencedEnvelope createTestEnvelope(CoverageInfo coverageInfo){\r\n    final ReferencedEnvelope envelope = coverageInfo.getNativeBoundingBox();\r\n    final GridGeometry geometry = coverageInfo.getGrid();\r\n    final MathTransform transform = geometry.getGridToCRS();\r\n    final double scaleX = XAffineTransform.getScaleX0((AffineTransform) transform);\r\n    final double scaleY = XAffineTransform.getScaleY0((AffineTransform) transform);\r\n    final double minX = envelope.getMinimum(0);\r\n    final double minY = envelope.getMinimum(1);\r\n    final ReferencedEnvelope newEnvelope = new ReferencedEnvelope(minX, minX + scaleX * 2, minY, minY + scaleY * 2, envelope.getCoordinateReferenceSystem());\r\n    return newEnvelope;\r\n}"
}, {
	"Path": "fj.control.parallel.ParModule.actor",
	"Comment": "creates a concurrent actor that is guaranteed to process only one message at a time.",
	"Method": "Actor<A> actor(Effect1<A> e,F<Effect1<A>, Actor<A>> actor){\r\n    return this::actor;\r\n}"
}, {
	"Path": "org.acme.Ldap.initDirectoryService",
	"Comment": "initialize the server. it creates the partition, adds the index, andinjects the context entries for the created partitions.",
	"Method": "void initDirectoryService(File workDir){\r\n    service = new DefaultDirectoryService();\r\n    service.setWorkingDirectory(workDir);\r\n    initSchemaPartition();\r\n    Partition systemPartition = addPartition(\"system\", ServerDNConstants.SYSTEM_DN);\r\n    service.setSystemPartition(systemPartition);\r\n    service.getChangeLog().setEnabled(false);\r\n    service.setDenormalizeOpAttrsEnabled(true);\r\n    Partition acmePartition = addPartition(\"acme\", \"dc=acme,dc=org\");\r\n    addIndex(acmePartition, \"objectClass\", \"ou\", \"uid\");\r\n    service.startup();\r\n    try {\r\n        service.getAdminSession().lookup(acmePartition.getSuffixDn());\r\n    } catch (LdapException lnnfe) {\r\n        DN dnBar = new DN(\"dc=acme,dc=org\");\r\n        ServerEntry entryBar = service.newEntry(dnBar);\r\n        entryBar.add(\"objectClass\", \"dcObject\", \"organization\");\r\n        entryBar.add(\"o\", \"acme\");\r\n        entryBar.add(\"dc\", \"acme\");\r\n        service.getAdminSession().add(entryBar);\r\n    }\r\n    DN peopleDn = new DN(\"ou=people,dc=acme,dc=org\");\r\n    if (!service.getAdminSession().exists(peopleDn)) {\r\n        ServerEntry e = service.newEntry(peopleDn);\r\n        e.add(\"objectClass\", \"organizationalUnit\");\r\n        e.add(\"ou\", \"people\");\r\n        service.getAdminSession().add(e);\r\n    }\r\n    DN groupsDn = new DN(\"ou=groups,dc=acme,dc=org\");\r\n    if (!service.getAdminSession().exists(groupsDn)) {\r\n        ServerEntry e = service.newEntry(groupsDn);\r\n        e.add(\"objectClass\", \"organizationalUnit\");\r\n        e.add(\"ou\", \"groups\");\r\n        service.getAdminSession().add(e);\r\n    }\r\n    addUser(\"bob\", \"Bob\", \"secret\");\r\n    addUser(\"alice\", \"Alice\", \"foobar\");\r\n    addUser(\"bill\", \"Bill\", \"hello\");\r\n    addGroup(\"user\", \"bob\", \"alice\");\r\n    addGroup(\"admin\", \"bill\");\r\n}"
}, {
	"Path": "fj.data.TreeMap.set",
	"Comment": "inserts the given key and value association into the tree map.if the given key is already mapped to a value, the old value is replaced with the given one.",
	"Method": "TreeMap<K, V> set(K k,V v){\r\n    return new TreeMap(tree.insert(p(k, Option.some(v))));\r\n}"
}, {
	"Path": "fj.data.fingertrees.FingerTree.foldRight",
	"Comment": "folds the tree to the right with the given function and the given initial element.",
	"Method": "B foldRight(F<A, F<B, B>> f,B z,B foldRight,F2<A, B, B> f,B z){\r\n    return foldRight(F2Functions.curry(f), z);\r\n}"
}, {
	"Path": "fj.data.HashSet.hash",
	"Comment": "compute the hash of the given value using the underlying hashing strategy.",
	"Method": "int hash(A a){\r\n    return m.hash(a);\r\n}"
}, {
	"Path": "org.geogig.geoserver.functional.GeoServerTestSupport.kvp",
	"Comment": "copied from parent class to do the same work on mockmultiparthttpservletrequest.",
	"Method": "void kvp(MockHttpServletRequest request,String path){\r\n    Map<String, Object> params = KvpUtils.parseQueryString(path);\r\n    for (String key : params.keySet()) {\r\n        Object value = params.get(key);\r\n        if (value instanceof String) {\r\n            request.addParameter(key, (String) value);\r\n        } else {\r\n            String[] values = (String[]) value;\r\n            request.addParameter(key, values);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "fj.data.List.splitAt",
	"Comment": "splits this list into two lists at the given index. if the index goes out of bounds, then it isnormalised so that this function never fails.",
	"Method": "P2<List<A>, List<A>> splitAt(int i){\r\n    int c = 0;\r\n    List<A> first = List.nil();\r\n    List<A> second = nil();\r\n    for (List<A> xs = this; xs.isNotEmpty(); xs = xs.tail()) {\r\n        final A h = xs.head();\r\n        if (c < i) {\r\n            first = first.cons(h);\r\n        } else {\r\n            second = second.cons(h);\r\n        }\r\n        c++;\r\n    }\r\n    return p(first.reverse(), second.reverse());\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.ComboBoxElement.getPopupSuggestions",
	"Comment": "gets the text representation of all suggestions on the current page.",
	"Method": "List<String> getPopupSuggestions(){\r\n    List<String> suggestionsTexts = new ArrayList();\r\n    List<WebElement> suggestions = getPopupSuggestionElements();\r\n    for (WebElement suggestion : suggestions) {\r\n        String text = suggestion.getText();\r\n        if (!text.isEmpty()) {\r\n            suggestionsTexts.add(text);\r\n        }\r\n    }\r\n    return suggestionsTexts;\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.TwinColSelectElement.selectByText",
	"Comment": "selects the option with the given option text, i.e. adds it to the rightside column.",
	"Method": "void selectByText(String text){\r\n    if (isReadOnly()) {\r\n        throw new ReadOnlyException();\r\n    }\r\n    options.deselectAll();\r\n    options.selectByVisibleText(text);\r\n    selButton.click();\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.TreeGridElement.isRowExpanded",
	"Comment": "returns whether the row at the given index is expanded or not.",
	"Method": "boolean isRowExpanded(int rowIndex,int hierarchyColumnIndex){\r\n    WebElement expandElement = getExpandElement(rowIndex, hierarchyColumnIndex);\r\n    List<String> classes = Arrays.asList(expandElement.getAttribute(\"class\").split(\" \"));\r\n    return classes.contains(\"expanded\") && !classes.contains(\"collapsed\");\r\n}"
}, {
	"Path": "fj.Ord.isGreaterThan",
	"Comment": "returns a function that returns true if its argument is greater than than the argument to this method.",
	"Method": "boolean isGreaterThan(A a1,A a2,F<A, Boolean> isGreaterThan,A a){\r\n    return compose(o -> o == Ordering.LT, def.compare(a));\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.reader.CatalogFileReader.afterPropertiesSet",
	"Comment": "ensure that all required dependencies for the itemreader to run are provided after allproperties have been set.",
	"Method": "void afterPropertiesSet(){\r\n    Assert.notEmpty(fragmentRootElementNames, \"The FragmentRootElementNames must not be empty\");\r\n    for (QName fragmentRootElementName : fragmentRootElementNames) {\r\n        Assert.hasText(fragmentRootElementName.getLocalPart(), \"The FragmentRootElementNames must not contain empty elements\");\r\n    }\r\n}"
}, {
	"Path": "fj.data.HashMap.getDelete",
	"Comment": "deletes the entry in the hash map that corresponds to the given key and returns any associated value.",
	"Method": "Option<V> getDelete(K k){\r\n    return fromNull(m.remove(new Key(k)));\r\n}"
}, {
	"Path": "fj.data.Array.sequence",
	"Comment": "performs a bind across each array element, but ignores the element value each time.",
	"Method": "Array<B> sequence(Array<B> bs,Array<B> sequence,Array<B> bs){\r\n    final F<A, Array<B>> c = constant(bs);\r\n    return bind(c);\r\n}"
}, {
	"Path": "fj.data.Stream.minus",
	"Comment": "returns a new stream of all the items in this stream that do not appear in the given stream.",
	"Method": "Stream<A> minus(Equal<A> eq,Stream<A> xs){\r\n    return removeAll(compose(Monoid.disjunctionMonoid.sumLeftS(), xs.mapM(curry(eq.eq()))));\r\n}"
}, {
	"Path": "fj.data.Option.option",
	"Comment": "performs a reduction on this optional value using the given arguments.",
	"Method": "B option(B b,F<A, B> f,B option,F0<B> b,F<A, B> f){\r\n    return isSome() ? f.f(some()) : b.f();\r\n}"
}, {
	"Path": "fj.Show.showS",
	"Comment": "returns the display rendering of the given argument as a string.",
	"Method": "String showS(A a,Show<A> showS,F<A, String> f){\r\n    return show(a -> fromString(f.f(a)));\r\n}"
}, {
	"Path": "fj.test.Property.prop",
	"Comment": "returns the result of applying the given size and random generator.",
	"Method": "Result prop(int i,Rand r,Property prop,F<Integer, F<Rand, Result>> f,Property prop,Result r,Property prop,boolean b){\r\n    return b ? prop(Result.proven(List.nil())) : prop(Result.falsified(List.nil()));\r\n}"
}, {
	"Path": "fj.data.Java.Either_LinkedBlockingQueueA",
	"Comment": "a function that converts eithers to linked blocking queues.",
	"Method": "F<Either<A, B>, LinkedBlockingQueue<A>> Either_LinkedBlockingQueueA(){\r\n    return Function.compose(Java.Option_LinkedBlockingQueue(), Conversions.Either_OptionA());\r\n}"
}, {
	"Path": "fj.data.Java.Either_LinkedBlockingQueueB",
	"Comment": "a function that converts eithers to linked blocking queues.",
	"Method": "F<Either<A, B>, LinkedBlockingQueue<B>> Either_LinkedBlockingQueueB(){\r\n    return Function.compose(Java.Option_LinkedBlockingQueue(), Conversions.Either_OptionB());\r\n}"
}, {
	"Path": "fj.data.Java.ConcurrentLinkedQueue_List",
	"Comment": "a function that converts concurrent linked queues to lists.",
	"Method": "F<ConcurrentLinkedQueue<A>, List<A>> ConcurrentLinkedQueue_List(){\r\n    return Java::Collection_List;\r\n}"
}, {
	"Path": "fj.test.Gen.gen",
	"Comment": "applies the given size and random generator to produce a value.",
	"Method": "A gen(int i,Rand r,Gen<A> gen,F<Integer, F<Rand, A>> f){\r\n    return new Gen(f);\r\n}"
}, {
	"Path": "fj.data.List.bind",
	"Comment": "binds the given function across each element of this list and the given lists with a finaljoin.",
	"Method": "List<B> bind(F<A, List<B>> f,List<C> bind,List<B> lb,F<A, F<B, C>> f,List<C> bind,List<B> lb,F2<A, B, C> f,List<D> bind,List<B> lb,List<C> lc,F<A, F<B, F<C, D>>> f,List<E> bind,List<B> lb,List<C> lc,List<D> ld,F<A, F<B, F<C, F<D, E>>>> f,List<F$> bind,List<B> lb,List<C> lc,List<D> ld,List<E> le,F<A, F<B, F<C, F<D, F<E, F$>>>>> f,List<G> bind,List<B> lb,List<C> lc,List<D> ld,List<E> le,List<F$> lf,F<A, F<B, F<C, F<D, F<E, F<F$, G>>>>>> f,List<H> bind,List<B> lb,List<C> lc,List<D> ld,List<E> le,List<F$> lf,List<G> lg,F<A, F<B, F<C, F<D, F<E, F<F$, F<G, H>>>>>>> f,List<I> bind,List<B> lb,List<C> lc,List<D> ld,List<E> le,List<F$> lf,List<G> lg,List<H> lh,F<A, F<B, F<C, F<D, F<E, F<F$, F<G, F<H, I>>>>>>>> f){\r\n    return lh.apply(bind(lb, lc, ld, le, lf, lg, f));\r\n}"
}, {
	"Path": "fj.F1Functions.promiseK",
	"Comment": "promotes this function to a concurrent function that returns a promise of a value.",
	"Method": "F<A, Promise<B>> promiseK(F<A, B> f,Strategy<Unit> s){\r\n    return Promise.promise(s, f);\r\n}"
}, {
	"Path": "org.geoserver.cluster.configuration.ApplicationProperties.setApplicationContext",
	"Comment": "sets the web application context to be used for looking up extensions.this method is called by the spring container, and should never be called by client code.if client needs to supply a particular context, methods which take a context are available.this is the context that is used for methods which dont supply their own context.",
	"Method": "void setApplicationContext(ApplicationContext context){\r\n    ApplicationProperties.context = context;\r\n}"
}, {
	"Path": "fj.data.List.intercalate",
	"Comment": "intersperses this list through the given list then joins the results.",
	"Method": "List<A> intercalate(List<List<A>> as){\r\n    return join(as.intersperse(this));\r\n}"
}, {
	"Path": "fj.control.parallel.ParModule.promise",
	"Comment": "promotes the given function to a concurrent function that returns a promise.",
	"Method": "Promise<A> promise(P1<A> p,F<P1<A>, Promise<A>> promise,F<A, Promise<B>> promise,F<A, B> f,F2<A, B, Promise<C>> promise,F2<A, B, C> f){\r\n    return P2.untuple(F1Functions.promiseK(F2Functions.tuple(f), strategy));\r\n}"
}, {
	"Path": "com.vaadin.shared.util.SharedUtil.splitCamelCase",
	"Comment": "splits a camelcasestring into an array of words with the casingpreserved.",
	"Method": "String[] splitCamelCase(String camelCaseString){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < camelCaseString.length(); i++) {\r\n        char c = camelCaseString.charAt(i);\r\n        if (Character.isUpperCase(c) && isWordComplete(camelCaseString, i)) {\r\n            sb.append(' ');\r\n        }\r\n        sb.append(c);\r\n    }\r\n    return sb.toString().split(\" \");\r\n}"
}, {
	"Path": "fj.data.HashMap.eq",
	"Comment": "compare two key values for equality using the underlying equality strategy.",
	"Method": "boolean eq(K k1,K k2){\r\n    return e.eq(k1, k2);\r\n}"
}, {
	"Path": "fj.F1Functions.optionK",
	"Comment": "promotes this function so that it returns its result in an option. kleisli arrow for option.",
	"Method": "F<A, Option<B>> optionK(F<A, B> f){\r\n    return a -> some(f.f(a));\r\n}"
}, {
	"Path": "fj.data.IterableW.zapp",
	"Comment": "zips this iterable with the given iterable of functions, applying each function in turn to thecorresponding element in this iterable to produce a new iterable. the iteration is normalisedso that it ends when one of the iterators is exhausted.",
	"Method": "IterableW<B> zapp(Iterable<F<A, B>> fs){\r\n    return wrap(iterableStream(this).zapp(iterableStream(fs)));\r\n}"
}, {
	"Path": "fj.data.TreeZipper.iterator",
	"Comment": "returns an iterator of all the positions of this treezipper. exists for use with the foreach syntax.",
	"Method": "Iterator<TreeZipper<A>> iterator(){\r\n    return positions().toTree().iterator();\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.tasklet.AbstractCatalogBackupRestoreTasklet.setTaskExecutor",
	"Comment": "sets the task executor that will be used to execute the system command nb! avoid using asynchronous task executor",
	"Method": "void setTaskExecutor(TaskExecutor taskExecutor){\r\n    this.taskExecutor = taskExecutor;\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.TabSheetElement.getTabCaption",
	"Comment": "returns the caption text of the given tab. if the tab has no caption,returns null.",
	"Method": "String getTabCaption(WebElement tabCell){\r\n    List<WebElement> captionElements = tabCell.findElements(byCaption);\r\n    if (captionElements.isEmpty()) {\r\n        return null;\r\n    } else {\r\n        return captionElements.get(0).getText();\r\n    }\r\n}"
}, {
	"Path": "fj.data.Stream.unfold",
	"Comment": "unfolds across the given function starting at the given value to produce a stream.",
	"Method": "Stream<A> unfold(F<B, Option<P2<A, B>>> f,B b){\r\n    final Option<P2<A, B>> o = f.f(b);\r\n    if (o.isNone())\r\n        return nil();\r\n    else {\r\n        final P2<A, B> p = o.some();\r\n        return cons(p._1(), () -> unfold(f, p._2()));\r\n    }\r\n}"
}, {
	"Path": "fj.control.Trampoline.zipWith",
	"Comment": "combines two trampolines so they run cooperatively. the results are combined with the given function.",
	"Method": "Trampoline<C> zipWith(Trampoline<B> b,F2<A, B, C> f){\r\n    final Either<P1<Trampoline<A>>, A> ea = resume();\r\n    final Either<P1<Trampoline<B>>, B> eb = b.resume();\r\n    for (final P1<Trampoline<A>> x : ea.left()) {\r\n        for (final P1<Trampoline<B>> y : eb.left()) {\r\n            return suspend(x.bind(y, F2Functions.curry((ta, tb) -> suspend(() -> ta.zipWith(tb, f)))));\r\n        }\r\n        for (final B y : eb.right()) {\r\n            return suspend(x.map(ta -> ta.map(F2Functions.f(F2Functions.flip(f), y))));\r\n        }\r\n    }\r\n    for (final A x : ea.right()) {\r\n        for (final B y : eb.right()) {\r\n            return suspend(() -> pure(f.f(x, y)));\r\n        }\r\n        for (final P1<Trampoline<B>> y : eb.left()) {\r\n            return suspend(y.map(liftM2(F2Functions.curry(f)).f(pure(x))));\r\n        }\r\n    }\r\n    throw Bottom.error(\"Match error: Trampoline is neither done nor suspended.\");\r\n}"
}, {
	"Path": "fj.data.Stream.drop",
	"Comment": "drops the given number of elements from the head of this stream if they are available.",
	"Method": "Stream<A> drop(int i){\r\n    Stream<A> xs = this;\r\n    for (int c = 0; xs.isNotEmpty() && c < i; xs = xs.tail()._1()) c++;\r\n    return xs;\r\n}"
}, {
	"Path": "fj.test.Gen.listOf",
	"Comment": "returns a generator of lists whose values come from the given generator.",
	"Method": "Gen<List<A>> listOf(Gen<A> g,int x,Gen<List<A>> listOf,Gen<A> g){\r\n    return listOf(g, 0);\r\n}"
}, {
	"Path": "fj.data.Zipper.deleteLeftCycle",
	"Comment": "possibly deletes the element at the focus, then move the element on the left into focus. if no element is on theleft, focus on the last element. if the deletion will cause the list to be empty, return none.",
	"Method": "Option<Zipper<A>> deleteLeftCycle(){\r\n    if (left.isEmpty() && right.isEmpty())\r\n        return none();\r\n    else if (left.isNotEmpty())\r\n        return some(zipper(left.tail()._1(), left.head(), right));\r\n    else {\r\n        final Stream<A> xs = right.reverse();\r\n        return some(zipper(xs.tail()._1(), xs.head(), Stream.nil()));\r\n    }\r\n}"
}, {
	"Path": "fj.data.properties.PriorityQueueProperties.addTop",
	"Comment": "adding a value with the highest priority makes it the top item.",
	"Method": "Property addTop(){\r\n    return property(arbPriorityQueueIntegerString, arbInteger, arbAlphaNumString, (q, i, s) -> {\r\n        Option<P2<Integer, String>> actual = q.enqueue(i, s).top();\r\n        return prop(q.isLessThan(Ord.intOrd, i) ? actual.equals(some(P.p(i, s))) : actual.equals(q.top()));\r\n    });\r\n}"
}, {
	"Path": "fj.data.TreeMap.delete",
	"Comment": "deletes the entry in the tree map that corresponds to the given key.",
	"Method": "TreeMap<K, V> delete(K k){\r\n    return new TreeMap(tree.delete(p(k, Option.none())));\r\n}"
}, {
	"Path": "fj.Show.println",
	"Comment": "prints the given argument to the standard output stream with a new line.",
	"Method": "Unit println(A a){\r\n    print(a);\r\n    System.out.println();\r\n    return unit();\r\n}"
}, {
	"Path": "org.geoserver.web.ComponentInfo.getTitleKey",
	"Comment": "the i18n key for the title of the component.the exact way this title is used depends one the component. for instanceif the component is a page, the title could be the used for a link to thepage. if the component is a panel in a tabbed panel, the title might be the label on the tab.",
	"Method": "String getTitleKey(){\r\n    return title;\r\n}"
}, {
	"Path": "com.vaadin.tests.components.menubar.MenuBarsWithNesting.createSecondMenuBar",
	"Comment": "returns a menu bar containing items with icons. the last menu item isnested and its submenu contains items with and without icons.",
	"Method": "MenuBar createSecondMenuBar(){\r\n    MenuBar menuBar = new MenuBar();\r\n    int n = itemNames.length;\r\n    for (int i = 0; i < n - 1; i++) {\r\n        menuBar.addItem(itemNames[i], itemIcons[i], selectionCommand);\r\n    }\r\n    MenuItem last = menuBar.addItem(itemNames[n - 1], itemIcons[n - 1], null);\r\n    for (int i = 0; i < nestedItemnames.length; i++) {\r\n        last.addItem(nestedItemnames[i], nestedItemIcons[i], selectionCommand);\r\n    }\r\n    return menuBar;\r\n}"
}, {
	"Path": "fj.data.Zipper.iterator",
	"Comment": "returns an iterator of all the positions of this zipper, starting from the leftmost position.",
	"Method": "Iterator<Zipper<A>> iterator(){\r\n    return positions().toStream().iterator();\r\n}"
}, {
	"Path": "fj.control.db.DbState.writer",
	"Comment": "returns a new writer that writes the database via the given connector.",
	"Method": "DbState writer(String url,DbState writer,Connector pc){\r\n    return new DbState(pc, commit);\r\n}"
}, {
	"Path": "fj.data.List.intersperse",
	"Comment": "intersperses the given argument between each element of this list.",
	"Method": "List<A> intersperse(A a){\r\n    return isEmpty() || tail().isEmpty() ? this : cons(head(), tail().bind(a2 -> list(a, a2)));\r\n}"
}, {
	"Path": "fj.F1Functions.listK",
	"Comment": "promotes this function so that it returns its result in a list. kleisli arrow for list.",
	"Method": "F<A, List<B>> listK(F<A, B> f){\r\n    return a -> List.single(f.f(a));\r\n}"
}, {
	"Path": "org.geoserver.security.WebServiceBodyResponseUserGroupServiceConfig.getRoleServiceName",
	"Comment": "optional name of the role service to use for roles resolution. if null it will use thesecurity default active service.",
	"Method": "String getRoleServiceName(){\r\n    return roleServiceName;\r\n}"
}, {
	"Path": "fj.F1Functions.streamK",
	"Comment": "promotes this function so that it returns its result in a stream. kleisli arrow for stream.",
	"Method": "F<A, Stream<B>> streamK(F<A, B> f){\r\n    return a -> Stream.single(f.f(a));\r\n}"
}, {
	"Path": "fj.Ord.isLessThanOrEqualTo",
	"Comment": "returns true if the first given argument is less than or equal to the second given argument,false otherwise.",
	"Method": "boolean isLessThanOrEqualTo(A a1,A a2){\r\n    return def.compare(a1, a2) != Ordering.GT;\r\n}"
}, {
	"Path": "org.geoserver.security.WebServiceAuthenticationKeyMapper.getSearchUser",
	"Comment": "returns the regular expression used to extract the user name from the webservice response.",
	"Method": "String getSearchUser(){\r\n    return searchUser;\r\n}"
}, {
	"Path": "fj.F1Functions.on",
	"Comment": "applies this function over the arguments of another function.",
	"Method": "F<A, F<A, C>> on(F<A, B> f,F<B, F<B, C>> g,F<F<B, F<B, C>>, F<A, F<A, C>>> on,F<A, B> f){\r\n    return g -> on(f, g);\r\n}"
}, {
	"Path": "com.vaadin.tests.LayoutDemo.init",
	"Comment": "initialize application. demo components are added to main window.",
	"Method": "void init(){\r\n    final LegacyWindow mainWindow = new LegacyWindow(\"Layout demo\");\r\n    setMainWindow(mainWindow);\r\n    final HorizontalLayout layoutA = new HorizontalLayout();\r\n    fillLayout(layoutA, 4);\r\n    final VerticalLayout layoutB = new VerticalLayout();\r\n    fillLayout(layoutB, 4);\r\n    final GridLayout layoutG = new GridLayout(4, 4);\r\n    fillLayout(layoutG, 16);\r\n    final GridLayout layoutG2 = new GridLayout(4, 4);\r\n    layoutG2.addComponent(getExampleComponent(\"x=0, y=0\"), 0, 0);\r\n    layoutG2.addComponent(getExampleComponent(\"x=1, y=1\"), 1, 1);\r\n    layoutG2.addComponent(getExampleComponent(\"x=2, y=2\"), 2, 2);\r\n    layoutG2.addComponent(getExampleComponent(\"x=3, y=3\"), 3, 3);\r\n    layoutG2.addComponent(getExamplePicture(\"x=3, y=0\"), 3, 0);\r\n    layoutG2.addComponent(getExamplePicture(\"x=2, y=1\"), 2, 1);\r\n    layoutG2.addComponent(getExamplePicture(\"x=1, y=2\"), 1, 2);\r\n    layoutG2.addComponent(getExamplePicture(\"x=0, y=3\"), 0, 3);\r\n    final TabSheet tabsheet = new TabSheet();\r\n    tabsheet.setCaption(\"Tabsheet, above layouts are added to this component\");\r\n    tabsheet.addTab(layoutA, \"Horizontal ordered layout\", null);\r\n    tabsheet.addTab(layoutB, \"Vertical ordered layout\", null);\r\n    tabsheet.addTab(layoutG, \"First grid layout\", null);\r\n    tabsheet.addTab(layoutG2, \"Second grid layout\", null);\r\n    mainWindow.addComponent(new Label(\"<h3>Horizontal ordered layout<\/h3>Added four components.\", ContentMode.HTML));\r\n    mainWindow.addComponent(layoutA);\r\n    mainWindow.addComponent(new Label(\"<br /><h3>Vertical ordered layout<\/h3>Added four components.\", ContentMode.HTML));\r\n    mainWindow.addComponent(layoutB);\r\n    mainWindow.addComponent(new Label(\"<br /><h3>Grid Layout (4 x 4)<\/h3>Added 16 components.\", ContentMode.HTML));\r\n    mainWindow.addComponent(layoutG);\r\n    mainWindow.addComponent(new Label(\"<br /><h3>Grid Layout (4 x 4)<\/h3>\" + \"Added four panels and four embedded components \" + \"diagonally with absolute coordinates.\", ContentMode.HTML));\r\n    mainWindow.addComponent(layoutG2);\r\n    mainWindow.addComponent(new Label(\"<br /><h3>TabSheet<\/h3>Added above layouts as tabs.\", ContentMode.HTML));\r\n    mainWindow.addComponent(tabsheet);\r\n}"
}, {
	"Path": "fj.data.Java.Stream_CopyOnWriteArraySet",
	"Comment": "a function that converts streams to copy on write array sets.",
	"Method": "F<Stream<A>, CopyOnWriteArraySet<A>> Stream_CopyOnWriteArraySet(){\r\n    return as -> new CopyOnWriteArraySet(as.toCollection());\r\n}"
}, {
	"Path": "fj.data.Option.forall",
	"Comment": "returns true if this optional value has no value, or the predicate holds for thegiven predicate function, false otherwise.",
	"Method": "boolean forall(F<A, Boolean> f){\r\n    return isNone() || f.f(some());\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.utils.BackupUtils.tmpDir",
	"Comment": "returns a random temp folder resource inside the system temp directory.",
	"Method": "Resource tmpDir(){\r\n    String tempPath = null;\r\n    try {\r\n        tempPath = System.getProperty(\"java.io.tmpdir\");\r\n        if (tempPath == null) {\r\n            tempPath = IOUtils.createTempDirectory(\"backuputils\").getAbsolutePath();\r\n            LOGGER.warning(\"It was not possible to create a temporary folder into the System 'java.io.tmpdir'. Falling back to default TEMP [\" + tempPath + \"].\");\r\n        }\r\n    } catch (Exception e) {\r\n        tempPath = null;\r\n        LOGGER.log(Level.SEVERE, \"It was not possible to create a temporary folder! In order to fix the problem, please check the System 'java.io.tmpdir' point to a valid folder.\", e);\r\n        throw new IOException(\"It was not possible to create a temporary folder! In order to fix the problem, please check the System 'java.io.tmpdir' point to a valid folder.\", e);\r\n    }\r\n    if (tempPath == null) {\r\n        LOGGER.log(Level.SEVERE, \"It was not possible to create or find a suitable temporary folder. 'tempPath' is NULL! In order to fix the problem, please check the System 'java.io.tmpdir' point to a valid folder.\");\r\n        throw new IOException(\"It was not possible to create or find a suitable temporary folder. 'tempPath' is NULL! In order to fix the problem, please check the System 'java.io.tmpdir' point to a valid folder.\");\r\n    }\r\n    return createRandomResource(tempPath);\r\n}"
}, {
	"Path": "fj.data.Set.minus",
	"Comment": "remove all elements from this set that occur in the given set.",
	"Method": "Set<A> minus(Set<A> s,F<Set<A>, F<Set<A>, Set<A>>> minus){\r\n    return curry(Set::minus);\r\n}"
}, {
	"Path": "fj.control.Trampoline.map",
	"Comment": "maps the given function across the result of this trampoline.",
	"Method": "Trampoline<B> map(F<A, B> f){\r\n    return bind(F1Functions.o(Trampoline.pure(), f));\r\n}"
}, {
	"Path": "fj.data.Stream.span",
	"Comment": "returns a tuple where the first element is the longest prefix of this stream that satisfiesthe given predicate and the second element is the remainder of the stream.",
	"Method": "P2<Stream<A>, Stream<A>> span(F<A, Boolean> p){\r\n    if (isEmpty())\r\n        return p(this, this);\r\n    else if (p.f(head())) {\r\n        final P1<P2<Stream<A>, Stream<A>>> yszs = P.lazy(() -> tail()._1().span(p));\r\n        return P.lazy(() -> cons(head(), yszs.map(P2.__1())), () -> yszs._1()._2());\r\n    } else\r\n        return p(Stream.nil(), this);\r\n}"
}, {
	"Path": "fj.data.Stream.cons",
	"Comment": "prepends the given head element to the given tail element to produce a new stream.",
	"Method": "Stream<A> cons(A a,F<A, F<P1<Stream<A>>, Stream<A>>> cons,Stream<A> cons,A head,F0<Stream<A>> tail){\r\n    return new Cons(head, tail);\r\n}"
}, {
	"Path": "fj.data.IOFunctions.runSafe",
	"Comment": "run io, rethrowing any ioexception wrapped in a runtimeexception",
	"Method": "A runSafe(IO<A> io){\r\n    return toSafe(io).run();\r\n}"
}, {
	"Path": "fj.data.Java.StringBuffer_SynchronousQueue",
	"Comment": "a function that converts string buffers to synchronous queues.",
	"Method": "F<StringBuffer, SynchronousQueue<Character>> StringBuffer_SynchronousQueue(boolean fair){\r\n    return Function.compose(Java.List_SynchronousQueue(fair), Conversions.StringBuffer_List);\r\n}"
}, {
	"Path": "fj.test.Gen.someWordOf",
	"Comment": "returns a generator of lists that produces some of the values of the given list. the selection isa permutation with replacement of elements from the given list, i.e.for any given selection, a generated list may contain its elements in any ordereach element may be picked more than once",
	"Method": "Gen<List<A>> someWordOf(int maxLength,List<A> as){\r\n    return choose(0, maxLength).bind(n -> wordOf(n, as));\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.ComboBoxElement.getInputField",
	"Comment": "returns the text input field element, used for entering text into thecombo box.",
	"Method": "WebElement getInputField(){\r\n    return findElement(By.vaadin(\"#textbox\"));\r\n}"
}, {
	"Path": "fj.data.Zipper.insertRight",
	"Comment": "inserts an element to the right of the focus, then moves the focus to the new element.",
	"Method": "Zipper<A> insertRight(A a){\r\n    return zipper(left.cons(focus), a, right);\r\n}"
}, {
	"Path": "fj.data.List.mapMOption",
	"Comment": "maps the given function across this list by binding through the option monad.",
	"Method": "Option<List<B>> mapMOption(F<A, Option<B>> f){\r\n    return traverseOption(f);\r\n}"
}, {
	"Path": "fj.test.Rand.rand",
	"Comment": "constructs a reseedable random generator from the given functions that supply a range to produce aresult.",
	"Method": "Rand rand(F<Option<Long>, F<Integer, F<Integer, Integer>>> f,F<Option<Long>, F<Double, F<Double, Double>>> g,Rand rand,F<Option<Long>, F<Integer, F<Integer, Integer>>> f,F<Option<Long>, F<Double, F<Double, Double>>> g,F<Long, Rand> onReseed){\r\n    return new Rand(f, g, some(onReseed));\r\n}"
}, {
	"Path": "org.geoserver.wms.DimensionsVectorGetFeatureInfoTest.getFeatureAt",
	"Comment": "ensures there is at most one feature at the specified location, and returns its feature id",
	"Method": "String getFeatureAt(String baseFeatureInfo,int x,int y){\r\n    MockHttpServletResponse response = getAsServletResponse(baseFeatureInfo + \"&info_format=application/vnd.ogc.gml&x=\" + x + \"&y=\" + y);\r\n    assertEquals(\"application/vnd.ogc.gml\", response.getContentType());\r\n    Document doc = dom(new ByteArrayInputStream(response.getContentAsString().getBytes()));\r\n    String sCount = xpath.evaluate(\"count(//sf:TimeElevation)\", doc);\r\n    int count = Integer.valueOf(sCount);\r\n    if (count == 0) {\r\n        return null;\r\n    } else if (count == 1) {\r\n        return xpath.evaluate(\"//sf:TimeElevation/@fid\", doc);\r\n    } else {\r\n        fail(\"Found more than one feature: \" + count);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.WebServiceAuthenticationKeyMapper.setSearchUser",
	"Comment": "sets the regular expression used to extract the user name from the webservice response.",
	"Method": "void setSearchUser(String searchUser){\r\n    this.searchUser = searchUser;\r\n    searchUserRegex = Pattern.compile(searchUser);\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.reader.CatalogMultiResourceItemReader.readNextItem",
	"Comment": "use the delegate to read the next item, jump to next resource if current one is exhausted.items are appended to the buffer.",
	"Method": "T readNextItem(){\r\n    T item = readFromDelegate();\r\n    while (item == null) {\r\n        currentResource++;\r\n        if (currentResource >= resources.length) {\r\n            return null;\r\n        }\r\n        delegate.close();\r\n        delegate.setResource(resources[currentResource]);\r\n        delegate.open(new ExecutionContext());\r\n        item = readFromDelegate();\r\n    }\r\n    return item;\r\n}"
}, {
	"Path": "fj.test.CheckResult.succeeded",
	"Comment": "returns the number of succeeded checks of the property in this result.",
	"Method": "int succeeded(){\r\n    return succeeded;\r\n}"
}, {
	"Path": "fj.data.Array.find",
	"Comment": "finds the first occurrence of an element that matches the given predicate or no value if noelements match.",
	"Method": "Option<A> find(F<A, Boolean> f){\r\n    for (final Object x : a) if (f.f((A) x))\r\n        return some((A) x);\r\n    return none();\r\n}"
}, {
	"Path": "fj.F1Functions.mapFail",
	"Comment": "promotes this function to map over the failure side of a validation.",
	"Method": "F<Validation<A, X>, Validation<B, X>> mapFail(F<A, B> f){\r\n    return v -> v.f().map(f);\r\n}"
}, {
	"Path": "fj.data.IOFunctions.enumFileChars",
	"Comment": "an io monad that reads char chunks from the given file and passes single chars to the given iteratee.",
	"Method": "IO<IterV<Character, A>> enumFileChars(File f,Option<Charset> encoding,IterV<Character, A> i){\r\n    return bracket(fileReader(f, encoding), Function.vary(closeReader), partialApply2(IOFunctions.charChunkReader2(), i));\r\n}"
}, {
	"Path": "fj.data.vector.V6.zipWith",
	"Comment": "zips this vector with the given vector using the given function to produce a new vector.",
	"Method": "V6<C> zipWith(F<A, F<B, C>> f,V6<B> bs){\r\n    return bs.apply(map(f));\r\n}"
}, {
	"Path": "fj.F1W.onSuccess",
	"Comment": "returns a function that returns the success side of a given validation,or this function applied to the failure side.",
	"Method": "F1W<Validation<A, B>, B> onSuccess(){\r\n    return lift(F1Functions.onSuccess(this));\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.ListSelectElement.clear",
	"Comment": "clear operation is not supported for list select. this operation has noeffect on list select element.",
	"Method": "void clear(){\r\n    super.clear();\r\n}"
}, {
	"Path": "fj.test.Shrink.shrinkList",
	"Comment": "returns a shrink strategy for lists. an empty list is fully shrunk.",
	"Method": "Shrink<List<A>> shrinkList(Shrink<A> sa){\r\n    final class Util {\r\n        Stream<List<A>> removeChunks(final int n, final List<A> as) {\r\n            if (as.isEmpty())\r\n                return nil();\r\n            else if (as.tail().isEmpty())\r\n                return cons(List.nil(), Stream.nil_());\r\n            else {\r\n                final int n1 = n / 2;\r\n                final int n2 = n - n1;\r\n                final List<A> as1 = as.take(n1);\r\n                final F<List<A>, Boolean> isNotEmpty = isNotEmpty_();\r\n                return cons(as1, P.lazy(() -> {\r\n                    final List<A> as2 = as.drop(n1);\r\n                    return cons(as2, P.lazy(() -> removeChunks(n1, as1).filter(isNotEmpty).map(aas1 -> aas1.append(as2)).interleave(removeChunks(n2, as2).filter(isNotEmpty).map(as1::append))));\r\n                }));\r\n            }\r\n        }\r\n        @SuppressWarnings(\"IfMayBeConditional\")\r\n        Stream<List<A>> shrinkOne(final List<A> as) {\r\n            if (as.isEmpty())\r\n                return nil();\r\n            else\r\n                return sa.shrink(as.head()).map(a -> as.tail().cons(a)).append(shrinkOne(as.tail()).map(aas -> aas.cons(as.head())));\r\n        }\r\n    }\r\n    return shrink(as -> {\r\n        final Util u = new Util();\r\n        return u.removeChunks(as.length(), as).append(u.shrinkOne(as));\r\n    });\r\n}"
}, {
	"Path": "fj.test.Shrink.shrinkList",
	"Comment": "returns a shrink strategy for lists. an empty list is fully shrunk.",
	"Method": "Shrink<List<A>> shrinkList(Shrink<A> sa){\r\n    if (as.isEmpty())\r\n        return nil();\r\n    else if (as.tail().isEmpty())\r\n        return cons(List.nil(), Stream.nil_());\r\n    else {\r\n        final int n1 = n / 2;\r\n        final int n2 = n - n1;\r\n        final List<A> as1 = as.take(n1);\r\n        final F<List<A>, Boolean> isNotEmpty = isNotEmpty_();\r\n        return cons(as1, P.lazy(() -> {\r\n            final List<A> as2 = as.drop(n1);\r\n            return cons(as2, P.lazy(() -> removeChunks(n1, as1).filter(isNotEmpty).map(aas1 -> aas1.append(as2)).interleave(removeChunks(n2, as2).filter(isNotEmpty).map(as1::append))));\r\n        }));\r\n    }\r\n}"
}, {
	"Path": "fj.test.Shrink.shrinkList",
	"Comment": "returns a shrink strategy for lists. an empty list is fully shrunk.",
	"Method": "Shrink<List<A>> shrinkList(Shrink<A> sa){\r\n    if (as.isEmpty())\r\n        return nil();\r\n    else\r\n        return sa.shrink(as.head()).map(a -> as.tail().cons(a)).append(shrinkOne(as.tail()).map(aas -> aas.cons(as.head())));\r\n}"
}, {
	"Path": "fj.F1W.mapRight",
	"Comment": "promotes this function to map over the right side of an either.",
	"Method": "F1W<Either<X, A>, Either<X, B>> mapRight(){\r\n    return lift(F1Functions.mapRight(this));\r\n}"
}, {
	"Path": "com.vaadin.v7.testbench.elements.TreeElement.getValue",
	"Comment": "returns selected item of the tree. in multiselect mode returns firstselected item. if there is no selected item returns empty string",
	"Method": "String getValue(){\r\n    List<WebElement> selectedElements = findElements(By.className(\"v-tree-node-selected\"));\r\n    if (selectedElements.isEmpty()) {\r\n        return \"\";\r\n    } else {\r\n        return selectedElements.get(0).getText();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.v7.tests.components.grid.basicfeatures.GridColumnHidingTest.getColumnHidingToggle",
	"Comment": "returns the toggle inside the sidebar for hiding the column at the givenindex, or null if not found.",
	"Method": "WebElement getColumnHidingToggle(int columnIndex){\r\n    WebElement sidebar = getSidebarPopup();\r\n    List<WebElement> elements = sidebar.findElements(By.className(\"column-hiding-toggle\"));\r\n    for (WebElement e : elements) {\r\n        if ((\"Header (0,\" + columnIndex + \")\").equalsIgnoreCase(e.getText())) {\r\n            return e;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.vaadin.tests.CustomLayoutDemo.componentEvent",
	"Comment": "handle all menu events. updates body panel contents if menu item isclicked.",
	"Method": "void componentEvent(Event event){\r\n    if (event.getSource() == menu) {\r\n        if (event.getClass() == Field.ValueChangeEvent.class) {\r\n            setBody(menu.getValue().toString());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "fj.test.Property.forall",
	"Comment": "returns a property where its result is derived from universal quantification across theapplication of its arguments.",
	"Method": "Property forall(Gen<A> g,Shrink<A> shrink,F<A, P1<Property>> f){\r\n    return prop(i -> r -> {\r\n        final class Util {\r\n            @SuppressWarnings(\"IfMayBeConditional\")\r\n            Option<P2<A, Result>> first(final Stream<A> as, final int shrinks) {\r\n                final Stream<Option<P2<A, Result>>> results = as.map(a -> {\r\n                    final Result result = exception(f.f(a)).prop(i, r);\r\n                    return result.toOption().map(result1 -> p(a, result1.provenAsUnfalsified().addArg(arg(a, shrinks))));\r\n                });\r\n                if (results.isEmpty())\r\n                    return none();\r\n                else\r\n                    return results.find(this::failed).orSome(results::head);\r\n            }\r\n            public boolean failed(final Option<P2<A, Result>> o) {\r\n                return o.isSome() && o.some()._2().failed();\r\n            }\r\n        }\r\n        final Util u = new Util();\r\n        Option<P2<A, Result>> x = u.first(Stream.single(g.gen(i, r)), 0);\r\n        final F<P2<A, Result>, Result> __2 = __2();\r\n        if (u.failed(x)) {\r\n            Option<Result> or;\r\n            int shrinks = 0;\r\n            do {\r\n                shrinks++;\r\n                or = x.map(__2);\r\n                x = u.first(shrink.shrink(x.some()._1()), shrinks);\r\n            } while (u.failed(x));\r\n            return noResult(or);\r\n        } else\r\n            return noResult(x.map(__2));\r\n    });\r\n}"
}, {
	"Path": "fj.test.Property.forall",
	"Comment": "returns a property where its result is derived from universal quantification across theapplication of its arguments.",
	"Method": "Property forall(Gen<A> g,Shrink<A> shrink,F<A, P1<Property>> f){\r\n    final Stream<Option<P2<A, Result>>> results = as.map(a -> {\r\n        final Result result = exception(f.f(a)).prop(i, r);\r\n        return result.toOption().map(result1 -> p(a, result1.provenAsUnfalsified().addArg(arg(a, shrinks))));\r\n    });\r\n    if (results.isEmpty())\r\n        return none();\r\n    else\r\n        return results.find(this::failed).orSome(results::head);\r\n}"
}, {
	"Path": "fj.test.Property.forall",
	"Comment": "returns a property where its result is derived from universal quantification across theapplication of its arguments.",
	"Method": "Property forall(Gen<A> g,Shrink<A> shrink,F<A, P1<Property>> f){\r\n    return o.isSome() && o.some()._2().failed();\r\n}"
}, {
	"Path": "com.vaadin.tests.tb3.CustomTestBenchCommandExecutor.compareScreen",
	"Comment": "compares the screenshot of the given element with the reference.copied from testbenchcommandexecutor and added croptoelement",
	"Method": "boolean compareScreen(WebElement element,File reference,boolean compareScreen,WebElement element,BufferedImage reference,String referenceName){\r\n    for (int times = 0; times < Parameters.getMaxScreenshotRetries(); times++) {\r\n        BufferedImage screenshotImage = cropToElement(element, ImageIO.read(new ByteArrayInputStream(((TakesScreenshot) actualDriver).getScreenshotAs(OutputType.BYTES))));\r\n        if (reference == null) {\r\n            ImageFileUtil.createScreenshotDirectoriesIfNeeded();\r\n            ImageIO.write(screenshotImage, \"png\", ImageFileUtil.getErrorScreenshotFile(referenceName));\r\n            getLogger().severe(\"No reference found for \" + referenceName + \" in \" + ImageFileUtil.getScreenshotReferenceDirectory());\r\n            return false;\r\n        }\r\n        if (imageComparison.imageEqualToReference(screenshotImage, reference, referenceName, Parameters.getScreenshotComparisonTolerance())) {\r\n            return true;\r\n        }\r\n        pause(Parameters.getScreenshotRetryDelay());\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "fj.parser.Result.result",
	"Comment": "construct a result with the given remainder of the parse input and parse value.",
	"Method": "Result<I, A> result(I i,A a,F<I, F<A, Result<I, A>>> result){\r\n    return curry(Result::result);\r\n}"
}, {
	"Path": "fj.control.parallel.Promise.claim",
	"Comment": "waits if necessary for the computation to complete, and then retrieves its result.",
	"Method": "A claim(Option<A> claim,long timeout,TimeUnit unit){\r\n    try {\r\n        if (l.await(timeout, unit))\r\n            return v;\r\n    } catch (InterruptedException e) {\r\n        throw new Error(e);\r\n    }\r\n    return none();\r\n}"
}, {
	"Path": "fj.data.Enumerator.plus",
	"Comment": "returns a function that moves a value along the enumerator a given number of times.",
	"Method": "F<A, F<Long, Option<A>>> plus(F<Long, Option<A>> plus,A a,F<A, Option<A>> plus,long l,Option<A> plus,A a,long l){\r\n    return plus.f(a).f(l);\r\n}"
}, {
	"Path": "fj.parser.Parser.or",
	"Comment": "returns a parser that tries this parser and if it fails, then tries the given parser. if both parsers fail, thenappend their errors with the given semigroup.",
	"Method": "Parser<I, A, E> or(F0<Parser<I, A, E>> alt,Parser<I, A, E> or,Parser<I, A, E> alt,Parser<I, A, E> or,F0<Parser<I, A, E>> alt,Semigroup<E> s,Parser<I, A, E> or,Parser<I, A, E> alt,Semigroup<E> s){\r\n    return or(p(alt), s);\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.TableElement.openCollapseMenu",
	"Comment": "opens the collapse menu of this table and returns the element for it.",
	"Method": "CollapseMenuElement openCollapseMenu(){\r\n    getCollapseMenuToggle().click();\r\n    WebElement cm = getDriver().findElement(By.xpath(\"//*[@id='PID_VAADIN_CM']\"));\r\n    return wrapElement(cm, getCommandExecutor()).wrap(CollapseMenuElement.class);\r\n}"
}, {
	"Path": "fj.data.List.isSingle",
	"Comment": "true if and only if the list has one element. runs in constant time.",
	"Method": "boolean isSingle(){\r\n    return isNotEmpty() && tail().isEmpty();\r\n}"
}, {
	"Path": "org.geogig.geoserver.web.repository.CommonPanelTest.assertFeedbackMessages",
	"Comment": "asserts that feedbackmessages match the expected list of messages.",
	"Method": "void assertFeedbackMessages(List<FeedbackMessage> actualMsgs,List<String> expectedMsgs){\r\n    assertEquals(\"Unexpected number of FeedbackMessages\", expectedMsgs.size(), actualMsgs.size());\r\n    final List<String> actuals = Lists.transform(actualMsgs, new Function<FeedbackMessage, String>() {\r\n        @Override\r\n        public String apply(FeedbackMessage input) {\r\n            return input.getMessage().toString();\r\n        }\r\n    });\r\n    for (String expectedMsg : expectedMsgs) {\r\n        assertTrue(String.format(\"Missing expected FeedbackMessage: %s\", expectedMsg), actuals.contains(expectedMsg));\r\n    }\r\n}"
}, {
	"Path": "org.geogig.geoserver.web.repository.CommonPanelTest.assertFeedbackMessages",
	"Comment": "asserts that feedbackmessages match the expected list of messages.",
	"Method": "void assertFeedbackMessages(List<FeedbackMessage> actualMsgs,List<String> expectedMsgs){\r\n    return input.getMessage().toString();\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.SliderElement.getValue",
	"Comment": "get value of the sliderwarning! this method cause slider popup to appear on the screen. to hidethis popup just focus any other element on the page.",
	"Method": "String getValue(){\r\n    WebElement popupElem = findElement(By.vaadin(\"#popup\"));\r\n    return popupElem.getAttribute(\"textContent\");\r\n}"
}, {
	"Path": "com.vaadin.tests.contextclick.GridContextClickTest.contextClick",
	"Comment": "performs a context click on given element at coordinates 20, 10 followedby a regular click. this prevents browser context menu from blockingfuture operations.a smaller x offset might hit the resize handle of the previous cell thatoverlaps with the next header cell.",
	"Method": "void contextClick(WebElement e){\r\n    contextClick(e, 20, 10);\r\n}"
}, {
	"Path": "fj.data.Array.unzip",
	"Comment": "transforms an array of pairs into an array of first components and an array of second components.",
	"Method": "P2<Array<A>, Array<B>> unzip(Array<P2<A, B>> xs){\r\n    final int len = xs.length();\r\n    final Array<A> aa = new Array(new Object[len]);\r\n    final Array<B> ab = new Array(new Object[len]);\r\n    for (int i = len - 1; i >= 0; i--) {\r\n        final P2<A, B> p = xs.get(i);\r\n        aa.set(i, p._1());\r\n        ab.set(i, p._2());\r\n    }\r\n    return p(aa, ab);\r\n}"
}, {
	"Path": "fj.data.List.isEmpty_",
	"Comment": "returns a function that determines whether a given list is empty.",
	"Method": "F<List<A>, Boolean> isEmpty_(){\r\n    return List::isEmpty;\r\n}"
}, {
	"Path": "fj.test.Gen.apply",
	"Comment": "function application within this generator to produce a new generator.",
	"Method": "Gen<B> apply(Gen<F<A, B>> gf){\r\n    return gf.bind(this::map);\r\n}"
}, {
	"Path": "fj.test.Gen.bind",
	"Comment": "binds the given function across this generator and the given generators to produce a newgenerator.",
	"Method": "Gen<B> bind(F<A, Gen<B>> f,Gen<C> bind,Gen<B> gb,F<A, F<B, C>> f,Gen<D> bind,Gen<B> gb,Gen<C> gc,F<A, F<B, F<C, D>>> f,Gen<E> bind,Gen<B> gb,Gen<C> gc,Gen<D> gd,F<A, F<B, F<C, F<D, E>>>> f,Gen<F$> bind,Gen<B> gb,Gen<C> gc,Gen<D> gd,Gen<E> ge,F<A, F<B, F<C, F<D, F<E, F$>>>>> f,Gen<G> bind,Gen<B> gb,Gen<C> gc,Gen<D> gd,Gen<E> ge,Gen<F$> gf,F<A, F<B, F<C, F<D, F<E, F<F$, G>>>>>> f,Gen<H> bind,Gen<B> gb,Gen<C> gc,Gen<D> gd,Gen<E> ge,Gen<F$> gf,Gen<G> gg,F<A, F<B, F<C, F<D, F<E, F<F$, F<G, H>>>>>>> f,Gen<I> bind,Gen<B> gb,Gen<C> gc,Gen<D> gd,Gen<E> ge,Gen<F$> gf,Gen<G> gg,Gen<H> gh,F<A, F<B, F<C, F<D, F<E, F<F$, F<G, F<H, I>>>>>>>> f){\r\n    return gh.apply(bind(gb, gc, gd, ge, gf, gg, f));\r\n}"
}, {
	"Path": "fj.test.Variant.variant",
	"Comment": "produces a generator that is independent of the given generator using the given value.",
	"Method": "Gen<A> variant(long n,Gen<A> g,F<Gen<A>, Gen<A>> variant,long n){\r\n    return g -> variant(n, g);\r\n}"
}, {
	"Path": "fj.data.Java.Option_CopyOnWriteArrayList",
	"Comment": "a function that converts options to copy on write array lists.",
	"Method": "F<Option<A>, CopyOnWriteArrayList<A>> Option_CopyOnWriteArrayList(){\r\n    return as -> new CopyOnWriteArrayList(as.toCollection());\r\n}"
}, {
	"Path": "fj.data.PriorityQueue.top",
	"Comment": "if the tree is not empty, returns the node with highest priority otherwise returns nothing.",
	"Method": "Option<P2<K, A>> top(){\r\n    return unqueue(none(), (top, tail) -> some(top));\r\n}"
}, {
	"Path": "fj.demo.concurrent.WordCount.wordCountsFromCharChunks",
	"Comment": "an iteratee that consumes char chunks and calculates word counts",
	"Method": "IterV<char[], Map<String, Integer>> wordCountsFromCharChunks(){\r\n    final F<P2<StringBuilder, Map<String, Integer>>, F<Input<char[]>, IterV<char[], Map<String, Integer>>>> step = new F<P2<StringBuilder, Map<String, Integer>>, F<Input<char[]>, IterV<char[], Map<String, Integer>>>>() {\r\n        final F<P2<StringBuilder, Map<String, Integer>>, F<Input<char[]>, IterV<char[], Map<String, Integer>>>> step = this;\r\n        @Override\r\n        public F<Input<char[]>, IterV<char[], Map<String, Integer>>> f(final P2<StringBuilder, Map<String, Integer>> acc) {\r\n            final P1<IterV<char[], Map<String, Integer>>> empty = P.lazy(() -> IterV.cont(step.f(acc)));\r\n            final P1<F<char[], IterV<char[], Map<String, Integer>>>> el = new P1<F<char[], IterV<char[], Map<String, Integer>>>>() {\r\n                @Override\r\n                public F<char[], IterV<char[], Map<String, Integer>>> _1() {\r\n                    return e -> {\r\n                        StringBuilder sb = acc._1();\r\n                        Map<String, Integer> map = acc._2();\r\n                        for (char c : e) {\r\n                            if (Character.isWhitespace(c)) {\r\n                                if (sb.length() > 0) {\r\n                                    map = update(map, sb.toString(), addOne, Integer.valueOf(0));\r\n                                    sb = new StringBuilder();\r\n                                }\r\n                            } else {\r\n                                sb.append(c);\r\n                            }\r\n                        }\r\n                        return IterV.cont(step.f(P.p(sb, map)));\r\n                    };\r\n                }\r\n            };\r\n            final P1<IterV<char[], Map<String, Integer>>> eof = P.lazy(() -> {\r\n                final StringBuilder sb = acc._1();\r\n                if (sb.length() > 0) {\r\n                    final Map<String, Integer> map = update(acc._2(), sb.toString(), addOne, Integer.valueOf(0));\r\n                    return IterV.done(map, Input.eof());\r\n                }\r\n                return IterV.done(acc._2(), Input.eof());\r\n            });\r\n            return s -> s.apply(empty, el, eof);\r\n        }\r\n    };\r\n    return IterV.cont(step.f(P.p(new StringBuilder(), (Map<String, Integer>) new HashMap<String, Integer>())));\r\n}"
}, {
	"Path": "fj.demo.concurrent.WordCount.wordCountsFromCharChunks",
	"Comment": "an iteratee that consumes char chunks and calculates word counts",
	"Method": "IterV<char[], Map<String, Integer>> wordCountsFromCharChunks(){\r\n    final P1<IterV<char[], Map<String, Integer>>> empty = P.lazy(() -> IterV.cont(step.f(acc)));\r\n    final P1<F<char[], IterV<char[], Map<String, Integer>>>> el = new P1<F<char[], IterV<char[], Map<String, Integer>>>>() {\r\n        @Override\r\n        public F<char[], IterV<char[], Map<String, Integer>>> _1() {\r\n            return e -> {\r\n                StringBuilder sb = acc._1();\r\n                Map<String, Integer> map = acc._2();\r\n                for (char c : e) {\r\n                    if (Character.isWhitespace(c)) {\r\n                        if (sb.length() > 0) {\r\n                            map = update(map, sb.toString(), addOne, Integer.valueOf(0));\r\n                            sb = new StringBuilder();\r\n                        }\r\n                    } else {\r\n                        sb.append(c);\r\n                    }\r\n                }\r\n                return IterV.cont(step.f(P.p(sb, map)));\r\n            };\r\n        }\r\n    };\r\n    final P1<IterV<char[], Map<String, Integer>>> eof = P.lazy(() -> {\r\n        final StringBuilder sb = acc._1();\r\n        if (sb.length() > 0) {\r\n            final Map<String, Integer> map = update(acc._2(), sb.toString(), addOne, Integer.valueOf(0));\r\n            return IterV.done(map, Input.eof());\r\n        }\r\n        return IterV.done(acc._2(), Input.eof());\r\n    });\r\n    return s -> s.apply(empty, el, eof);\r\n}"
}, {
	"Path": "fj.demo.concurrent.WordCount.wordCountsFromCharChunks",
	"Comment": "an iteratee that consumes char chunks and calculates word counts",
	"Method": "IterV<char[], Map<String, Integer>> wordCountsFromCharChunks(){\r\n    return e -> {\r\n        StringBuilder sb = acc._1();\r\n        Map<String, Integer> map = acc._2();\r\n        for (char c : e) {\r\n            if (Character.isWhitespace(c)) {\r\n                if (sb.length() > 0) {\r\n                    map = update(map, sb.toString(), addOne, Integer.valueOf(0));\r\n                    sb = new StringBuilder();\r\n                }\r\n            } else {\r\n                sb.append(c);\r\n            }\r\n        }\r\n        return IterV.cont(step.f(P.p(sb, map)));\r\n    };\r\n}"
}, {
	"Path": "fj.data.NonEmptyList.minimum",
	"Comment": "returns the minimum element in this non empty list according to the given ordering.",
	"Method": "A minimum(Ord<A> o){\r\n    return foldLeft1(o::min);\r\n}"
}, {
	"Path": "fj.test.reflect.Check.check",
	"Comment": "returns the results and names of checking the properties on the given class.",
	"Method": "List<P2<String, CheckResult>> check(List<java.lang.Class<T>> c,String categories,List<P2<String, CheckResult>> check,List<java.lang.Class<T>> c,List<String> categories,List<P2<String, CheckResult>> check,List<java.lang.Class<T>> c,Rand r,String categories,List<P2<String, CheckResult>> check,List<java.lang.Class<T>> c,Rand r,List<String> categories,List<P2<String, CheckResult>> check,java.lang.Class<T> c,String categories,List<P2<String, CheckResult>> check,java.lang.Class<T> c,List<String> categories,List<P2<String, CheckResult>> check,java.lang.Class<T> c,Rand r,String categories,List<P2<String, CheckResult>> check,java.lang.Class<T> c,Rand r,List<String> categories){\r\n    return check(c, r, categories.toArray().array(String[].class));\r\n}"
}, {
	"Path": "fj.test.Gen.sized",
	"Comment": "constructs a generator that can access its size construction arguments.",
	"Method": "Gen<A> sized(F<Integer, Gen<A>> f){\r\n    return parameterised(flip(Function.constant(f)));\r\n}"
}, {
	"Path": "fj.data.vector.V2.vzip",
	"Comment": "zips this vector with the given vector to produce a vector of vectors.",
	"Method": "V2<V2<A>> vzip(V2<A> bs){\r\n    final F2<A, A, V2<A>> __2 = V.v2();\r\n    return zipWith(curry(__2), bs);\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.AbstractExecutionAdapter.addFailureExceptions",
	"Comment": "adds exceptions to the current executions marking it as failed.",
	"Method": "void addFailureExceptions(List<Throwable> exceptions){\r\n    for (Throwable t : exceptions) {\r\n        this.delegate.addFailureException(t);\r\n    }\r\n    this.delegate.setExitStatus(ExitStatus.FAILED);\r\n}"
}, {
	"Path": "fj.F1W.nelK",
	"Comment": "promotes this function to return its value in a nonemptylist.",
	"Method": "F1W<A, NonEmptyList<B>> nelK(){\r\n    return lift(F1Functions.nelK(this));\r\n}"
}, {
	"Path": "fj.data.List.span",
	"Comment": "returns a tuple where the first element is the longest prefix of this list that satisfiesthe given predicate and the second element is the remainder of the list.",
	"Method": "P2<List<A>, List<A>> span(F<A, Boolean> p){\r\n    final Buffer<A> b = empty();\r\n    for (List<A> xs = this; xs.isNotEmpty(); xs = xs.tail()) {\r\n        if (p.f(xs.head()))\r\n            b.snoc(xs.head());\r\n        else\r\n            return p(b.toList(), xs);\r\n    }\r\n    return p(b.toList(), List.nil());\r\n}"
}, {
	"Path": "fj.test.Gen.elemFrequency",
	"Comment": "returns a generator that produces values from the given frequency and value pairs. the returnedgenerator will produce the value with a higher frequency than a lower one.",
	"Method": "Gen<A> elemFrequency(List<P2<Integer, A>> as){\r\n    return frequency(as.map(p -> p.map2(Gen::value)));\r\n}"
}, {
	"Path": "fj.data.Set.filter",
	"Comment": "filters elements from this set by returning only elements which produce truewhen the given function is applied to them.",
	"Method": "Set<A> filter(F<A, Boolean> f){\r\n    return iterableSet(ord, toStream().filter(f));\r\n}"
}, {
	"Path": "fj.data.vector.V6.zip",
	"Comment": "zips this vector with the given vector to produce a vector of pairs.",
	"Method": "V6<P2<A, B>> zip(V6<B> bs){\r\n    final F<A, F<B, P2<A, B>>> __2 = p2();\r\n    return zipWith(__2, bs);\r\n}"
}, {
	"Path": "com.vaadin.tests.tb3.PrivateTB3Configuration.findAutoHostname",
	"Comment": "tries to automatically determine the ip address of the machine the testis running on.",
	"Method": "String findAutoHostname(){\r\n    try {\r\n        Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\r\n        while (interfaces.hasMoreElements()) {\r\n            NetworkInterface nwInterface = interfaces.nextElement();\r\n            if (!nwInterface.isUp() || nwInterface.isLoopback() || nwInterface.isVirtual()) {\r\n                continue;\r\n            }\r\n            Enumeration<InetAddress> addresses = nwInterface.getInetAddresses();\r\n            while (addresses.hasMoreElements()) {\r\n                InetAddress address = addresses.nextElement();\r\n                if (address.isLoopbackAddress()) {\r\n                    continue;\r\n                }\r\n                if (address.isSiteLocalAddress()) {\r\n                    return address.getHostAddress();\r\n                }\r\n            }\r\n        }\r\n    } catch (SocketException e) {\r\n        throw new RuntimeException(\"Could not enumerate \");\r\n    }\r\n    throw new RuntimeException(\"No compatible (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) ip address found.\");\r\n}"
}, {
	"Path": "fj.data.Either.either_",
	"Comment": "first class catamorphism for either. folds over this either breaking into left or right.",
	"Method": "F<Either<A, B>, X> either_(F<A, X> left,F<B, X> right){\r\n    return e -> e.either(left, right);\r\n}"
}, {
	"Path": "org.geoserver.cluster.impl.handlers.configuration.JMSGeoServerHandler.localizeJAIInfo",
	"Comment": "return the local jaiinfo updating its member with the ones coming from the passed jaiinfo",
	"Method": "JAIInfo localizeJAIInfo(GeoServer geoServer,JAIInfo deserInfo){\r\n    if (geoServer == null || deserInfo == null)\r\n        throw new IllegalArgumentException(\"Wrong passed arguments are null\");\r\n    final JAIInfo info = geoServer.getGlobal().getJAI();\r\n    final TileCache sunTyleCache = info.getTileCache();\r\n    BeanUtils.copyProperties(info, deserInfo);\r\n    info.setTileCache(sunTyleCache);\r\n    return info;\r\n}"
}, {
	"Path": "fj.data.PriorityQueue.topDequeue",
	"Comment": "returns a tuple of the node with the highest priority and the rest of the priority queue.",
	"Method": "P2<Option<P2<K, A>>, PriorityQueue<K, A>> topDequeue(){\r\n    return unqueue(P.p(none(), this), (top, tail) -> P.p(some(top), tail));\r\n}"
}, {
	"Path": "com.vaadin.tests.contextclick.TreeV8ContextClickTest.contextClick",
	"Comment": "performs a context click on given element at coordinates 20, 10 followedby a regular click. this prevents browser context menu from blockingfuture operations.a smaller x offset might hit the resize handle of the previous cell thatoverlaps with the next header cell.",
	"Method": "void contextClick(WebElement e){\r\n    contextClick(e, 20, 10);\r\n}"
}, {
	"Path": "fj.data.List.cons",
	"Comment": "prepends the given head element to the given tail element to produce a new list.",
	"Method": "List<A> cons(A a,F<A, F<List<A>, List<A>>> cons,F<A, List<A>> cons,List<A> tail,List<A> cons,A head,List<A> tail,Prism<List<A>, P2<A, List<A>>> cons){\r\n    return new Cons(head, tail);\r\n}"
}, {
	"Path": "fj.test.Gen.pickOne",
	"Comment": "returns a generator that picks one element from the given list. if the given list is empty, then thereturned generator will never produce a value.",
	"Method": "Gen<A> pickOne(List<A> as){\r\n    return wordOf(1, as).map(List::head);\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.writer.CatalogMultiResourceItemWriter.setItemCountLimitPerResource",
	"Comment": "after this limit is exceeded the next chunk will be written into newly created resource.",
	"Method": "void setItemCountLimitPerResource(int itemCountLimitPerResource){\r\n    this.itemCountLimitPerResource = itemCountLimitPerResource;\r\n}"
}, {
	"Path": "fj.data.Set.toStreamReverse",
	"Comment": "returns a stream representation of this set in reverse order.",
	"Method": "Stream<A> toStreamReverse(){\r\n    if (isEmpty()) {\r\n        return Stream.nil();\r\n    } else if (r().isEmpty()) {\r\n        return Stream.cons(head(), () -> l().toStreamReverse());\r\n    } else {\r\n        return r().toStreamReverse().append(Stream.cons(head(), () -> l().toStreamReverse()));\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.InlineDateFieldElement.getFocusElement",
	"Comment": "returns the element which receives focus when the component is focused.",
	"Method": "WebElement getFocusElement(){\r\n    return findElement(By.tagName(\"table\"));\r\n}"
}, {
	"Path": "fj.test.Result.exception",
	"Comment": "returns the potential exception associated with this result. this will only have a value if andonly if this result is an exception result.",
	"Method": "Option<Throwable> exception(Result exception,List<Arg<?>> args,Throwable t){\r\n    return new Result(some(args), R.Exception, some(t));\r\n}"
}, {
	"Path": "fj.data.Stream.last",
	"Comment": "get the last element of this stream. undefined for infinite streams.",
	"Method": "A last(){\r\n    return reverse().head();\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.TreeElement.getAllItems",
	"Comment": "gets all items currently shown in this tree. the returned element objectsare the rendered contents for each item.",
	"Method": "List<TestBenchElement> getAllItems(){\r\n    return asTreeGrid().getBody().findElements(By.tagName(\"tr\")).stream().map(this::findCellContentFromRow).collect(Collectors.toList());\r\n}"
}, {
	"Path": "com.vaadin.tests.widgetset.client.MockApplicationConnection.getLastCsrfTokenReceiver",
	"Comment": "provide the last token received from the server. we added this to test the change done on csrf token.",
	"Method": "String getLastCsrfTokenReceiver(){\r\n    return getMessageHandler().lastCsrfTokenReceiver;\r\n}"
}, {
	"Path": "fj.data.List.filter",
	"Comment": "filters elements from this list by returning only elements which produce true whenthe given function is applied to them.",
	"Method": "List<A> filter(F<A, Boolean> f){\r\n    final Buffer<A> b = empty();\r\n    for (List<A> xs = this; xs.isNotEmpty(); xs = xs.tail()) {\r\n        final A h = xs.head();\r\n        if (f.f(h)) {\r\n            b.snoc(h);\r\n        }\r\n    }\r\n    return b.toList();\r\n}"
}, {
	"Path": "fj.data.IterableW.foldLeft1",
	"Comment": "takes the first 2 elements of the iterable and applies the function to them,then applies the function to the result and the third element and so on.",
	"Method": "A foldLeft1(F2<A, A, A> f,A foldLeft1,F<A, F<A, A>> f){\r\n    return iterableStream(this).foldLeft1(f);\r\n}"
}, {
	"Path": "fj.data.Java.Stream_LinkedBlockingQueue",
	"Comment": "a function that converts streams to linked blocking queues.",
	"Method": "F<Stream<A>, LinkedBlockingQueue<A>> Stream_LinkedBlockingQueue(){\r\n    return as -> new LinkedBlockingQueue(as.toCollection());\r\n}"
}, {
	"Path": "fj.control.parallel.Callables.callable",
	"Comment": "provides a transformation from a value to a callable that completely preserves that value.",
	"Method": "Callable<A> callable(A a,Callable<A> callable,Exception e,F<A, Callable<A>> callable,F<A, Callable<B>> callable,F<A, B> f){\r\n    return a -> () -> f.f(a);\r\n}"
}, {
	"Path": "fj.data.List.sequence",
	"Comment": "performs a bind across each list element, but ignores the element value each time.",
	"Method": "List<B> sequence(List<B> bs){\r\n    final F<A, List<B>> c = constant(bs);\r\n    return bind(c);\r\n}"
}, {
	"Path": "fj.data.List.lookup",
	"Comment": "returns an associated value with the given key in the list of pairs.",
	"Method": "Option<B> lookup(Equal<A> e,List<P2<A, B>> x,A a,F2<List<P2<A, B>>, A, Option<B>> lookup,Equal<A> e){\r\n    return (x, a) -> lookup(e, x, a);\r\n}"
}, {
	"Path": "com.vaadin.tests.components.tabsheet.TabSheetScrollOnTabCloseTest.visibilityOfElement",
	"Comment": "an expectation for checking that the visibility status of the specifiedelement is correct. if the element does not exist in the dom, it isconsidered not to be visible. if several elements match the locator, onlythe visibility of the first matching element is considered.",
	"Method": "ExpectedCondition<Boolean> visibilityOfElement(org.openqa.selenium.By locator,boolean expectedVisibility){\r\n    return new ExpectedCondition<Boolean>() {\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            List<WebElement> matchingElements = driver.findElements(locator);\r\n            if (matchingElements.isEmpty()) {\r\n                return !expectedVisibility;\r\n            } else {\r\n                try {\r\n                    WebElement first = matchingElements.get(0);\r\n                    return first.isDisplayed() == expectedVisibility;\r\n                } catch (StaleElementReferenceException e) {\r\n                    return !expectedVisibility;\r\n                }\r\n            }\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"element \" + (expectedVisibility ? \"\" : \"not \") + \"expected to be visible: \" + locator;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.vaadin.tests.components.tabsheet.TabSheetScrollOnTabCloseTest.visibilityOfElement",
	"Comment": "an expectation for checking that the visibility status of the specifiedelement is correct. if the element does not exist in the dom, it isconsidered not to be visible. if several elements match the locator, onlythe visibility of the first matching element is considered.",
	"Method": "ExpectedCondition<Boolean> visibilityOfElement(org.openqa.selenium.By locator,boolean expectedVisibility){\r\n    List<WebElement> matchingElements = driver.findElements(locator);\r\n    if (matchingElements.isEmpty()) {\r\n        return !expectedVisibility;\r\n    } else {\r\n        try {\r\n            WebElement first = matchingElements.get(0);\r\n            return first.isDisplayed() == expectedVisibility;\r\n        } catch (StaleElementReferenceException e) {\r\n            return !expectedVisibility;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.tests.components.tabsheet.TabSheetScrollOnTabCloseTest.visibilityOfElement",
	"Comment": "an expectation for checking that the visibility status of the specifiedelement is correct. if the element does not exist in the dom, it isconsidered not to be visible. if several elements match the locator, onlythe visibility of the first matching element is considered.",
	"Method": "ExpectedCondition<Boolean> visibilityOfElement(org.openqa.selenium.By locator,boolean expectedVisibility){\r\n    return \"element \" + (expectedVisibility ? \"\" : \"not \") + \"expected to be visible: \" + locator;\r\n}"
}, {
	"Path": "fj.data.IterableW.zip",
	"Comment": "zips this iterable with the given iterable to produce a iterable of pairs. if this iterable and thegiven iterable have different lengths, then the longer iterable is normalised so this functionnever fails.",
	"Method": "Iterable<P2<A, B>> zip(Iterable<B> bs){\r\n    return wrap(iterableStream(this).zip(iterableStream(bs)));\r\n}"
}, {
	"Path": "fj.control.parallel.ParModule.sequence",
	"Comment": "stream iteration inside a promise. traverses a stream of promises yielding a promise of a stream.",
	"Method": "Promise<List<A>> sequence(List<Promise<A>> ps,Promise<Stream<A>> sequence,Stream<Promise<A>> ps,Promise<P1<A>> sequence,P1<Promise<A>> p){\r\n    return Promise.sequence(strategy, p);\r\n}"
}, {
	"Path": "fj.data.Validation.map",
	"Comment": "maps the given function across the success side of this validation.",
	"Method": "Validation<E, A> map(F<T, A> f,Validation<A, T> map,F<E, A> f){\r\n    return isFail() ? Validation.fail(fail()) : Validation.success(f.f(success()));\r\n}"
}, {
	"Path": "fj.data.Zipper.find",
	"Comment": "moves the focus to the element matching the given predicate, if present.",
	"Method": "Option<Zipper<A>> find(F<A, Boolean> p){\r\n    if (p.f(focus()))\r\n        return some(this);\r\n    else {\r\n        final Zipper<Zipper<A>> ps = positions();\r\n        return ps.lefts().interleave(ps.rights()).find(zipper -> p.f(zipper.focus()));\r\n    }\r\n}"
}, {
	"Path": "fj.data.List.drop",
	"Comment": "drops the given number of elements from the head of this list if they are available.",
	"Method": "List<A> drop(int i){\r\n    List<A> xs = this;\r\n    for (int c = 0; xs.isNotEmpty() && c < i; xs = xs.tail()) c++;\r\n    return xs;\r\n}"
}, {
	"Path": "fj.F1Functions.onLeft",
	"Comment": "returns a function that returns the left side of a given either, or this function applied to the right side.",
	"Method": "F<Either<B, A>, B> onLeft(F<A, B> f){\r\n    return e -> e.left().on(f);\r\n}"
}, {
	"Path": "fj.parser.Parser.bind",
	"Comment": "binds the given function across the parsers with a final join.",
	"Method": "Parser<I, B, E> bind(F<A, Parser<I, B, E>> f,Parser<I, C, E> bind,Parser<I, B, E> pb,F<A, F<B, C>> f,Parser<I, D, E> bind,Parser<I, B, E> pb,Parser<I, C, E> pc,F<A, F<B, F<C, D>>> f,Parser<I, E$, E> bind,Parser<I, B, E> pb,Parser<I, C, E> pc,Parser<I, D, E> pd,F<A, F<B, F<C, F<D, E$>>>> f,Parser<I, F$, E> bind,Parser<I, B, E> pb,Parser<I, C, E> pc,Parser<I, D, E> pd,Parser<I, E$, E> pe,F<A, F<B, F<C, F<D, F<E$, F$>>>>> f,Parser<I, G, E> bind,Parser<I, B, E> pb,Parser<I, C, E> pc,Parser<I, D, E> pd,Parser<I, E$, E> pe,Parser<I, F$, E> pf,F<A, F<B, F<C, F<D, F<E$, F<F$, G>>>>>> f,Parser<I, H, E> bind,Parser<I, B, E> pb,Parser<I, C, E> pc,Parser<I, D, E> pd,Parser<I, E$, E> pe,Parser<I, F$, E> pf,Parser<I, G, E> pg,F<A, F<B, F<C, F<D, F<E$, F<F$, F<G, H>>>>>>> f,Parser<I, I$, E> bind,Parser<I, B, E> pb,Parser<I, C, E> pc,Parser<I, D, E> pd,Parser<I, E$, E> pe,Parser<I, F$, E> pf,Parser<I, G, E> pg,Parser<I, H, E> ph,F<A, F<B, F<C, F<D, F<E$, F<F$, F<G, F<H, I$>>>>>>>> f){\r\n    return ph.apply(bind(pb, pc, pd, pe, pf, pg, f));\r\n}"
}, {
	"Path": "fj.data.Stream.iteratorStream",
	"Comment": "constructs a stream with the given elements in the iterator.",
	"Method": "Stream<A> iteratorStream(Iterator<A> it){\r\n    if (it.hasNext()) {\r\n        final A a = it.next();\r\n        return cons(a, () -> iteratorStream(it));\r\n    } else\r\n        return nil();\r\n}"
}, {
	"Path": "com.vaadin.tests.components.table.TableMatchesMouseDownMouseUpElementTest.testMoveOut",
	"Comment": "mousedown on element and mouseup outside element but on same cell",
	"Method": "void testMoveOut(WebElement element){\r\n    clearSelection();\r\n    clickAndMove(element, 5, 5, 0, 50);\r\n    checkSelectedRowCount(1);\r\n    checkRowSelected(0);\r\n}"
}, {
	"Path": "fj.Show.printlnE",
	"Comment": "prints the given argument to the standard error stream with a new line.",
	"Method": "void printlnE(A a){\r\n    System.err.println(showS(a));\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.ComboBoxElement.getPopupSuggestionElements",
	"Comment": "gets the elements of all suggestions on the current page.opens the popup if not already open.",
	"Method": "List<WebElement> getPopupSuggestionElements(){\r\n    List<WebElement> tables = getSuggestionPopup().findElements(By.tagName(\"table\"));\r\n    if (tables == null || tables.isEmpty()) {\r\n        return Collections.emptyList();\r\n    }\r\n    WebElement table = tables.get(0);\r\n    return table.findElements(By.tagName(\"td\"));\r\n}"
}, {
	"Path": "fj.data.TreeZipper.insertDownFirst",
	"Comment": "inserts a tree as the first child of the current node. the inserted tree becomes the current tree.",
	"Method": "TreeZipper<A> insertDownFirst(Tree<A> t){\r\n    return treeZipper(t, Stream.nil(), tree.subForest()._1(), downParents());\r\n}"
}, {
	"Path": "fj.data.List.dropWhile",
	"Comment": "removes elements from the head of this list that do not match the given predicate functionuntil an element is found that does match or the list is exhausted.",
	"Method": "List<A> dropWhile(F<A, Boolean> f){\r\n    List<A> xs;\r\n    for (xs = this; xs.isNotEmpty() && f.f(xs.head()); xs = xs.tail()) ;\r\n    return xs;\r\n}"
}, {
	"Path": "org.geoserver.cluster.hazelcast.HzCluster.isStickySession",
	"Comment": "is session sharing sticky. see hazelcast documentation for details.",
	"Method": "boolean isStickySession(){\r\n    return Boolean.parseBoolean(getClusterConfig().getProperty(\"session_sticky\", \"false\"));\r\n}"
}, {
	"Path": "fj.data.Stream.index",
	"Comment": "returns the element at the given index if it exists, fails otherwise.",
	"Method": "A index(int i){\r\n    if (i < 0)\r\n        throw error(\"index \" + i + \" out of range on stream\");\r\n    else {\r\n        Stream<A> xs = this;\r\n        for (int c = 0; c < i; c++) {\r\n            if (xs.isEmpty())\r\n                throw error(\"index \" + i + \" out of range on stream\");\r\n            xs = xs.tail()._1();\r\n        }\r\n        if (xs.isEmpty())\r\n            throw error(\"index \" + i + \" out of range on stream\");\r\n        return xs.head();\r\n    }\r\n}"
}, {
	"Path": "fj.data.TreeZipper.isLeaf",
	"Comment": "indicates whether the current node is at the bottom of the tree.",
	"Method": "boolean isLeaf(){\r\n    return tree.subForest()._1().isEmpty();\r\n}"
}, {
	"Path": "fj.data.List.orHead",
	"Comment": "returns the head of this list if there is one or the given argument if this list is empty.",
	"Method": "A orHead(F0<A> a){\r\n    return isEmpty() ? a.f() : head();\r\n}"
}, {
	"Path": "fj.data.Java.Either_CopyOnWriteArrayListB",
	"Comment": "a function that converts eithers to copy on write array lists.",
	"Method": "F<Either<A, B>, CopyOnWriteArrayList<B>> Either_CopyOnWriteArrayListB(){\r\n    return Function.compose(Java.Option_CopyOnWriteArrayList(), Conversions.Either_OptionB());\r\n}"
}, {
	"Path": "fj.data.Java.Either_CopyOnWriteArrayListA",
	"Comment": "a function that converts eithers to copy on write array lists.",
	"Method": "F<Either<A, B>, CopyOnWriteArrayList<A>> Either_CopyOnWriteArrayListA(){\r\n    return Function.compose(Java.Option_CopyOnWriteArrayList(), Conversions.Either_OptionA());\r\n}"
}, {
	"Path": "fj.Semigroup.firstOptionSemigroup",
	"Comment": "a semigroup for optional values that take the first available value.",
	"Method": "Semigroup<Option<A>> firstOptionSemigroup(){\r\n    return Monoid.<A>firstOptionMonoid().semigroup();\r\n}"
}, {
	"Path": "org.geoserver.cluster.configuration.JMSConfiguration.override",
	"Comment": "check if instance name is changed since last application boot, if so set the overridden valueinto configuration and returns true",
	"Method": "boolean override(boolean override,String nameKey,Object defaultVal){\r\n    boolean override = false;\r\n    final String ovrName = getOverride(nameKey);\r\n    if (ovrName != null) {\r\n        final String name = configuration.getProperty(nameKey);\r\n        if (name != null && !name.equals(ovrName)) {\r\n            override = true;\r\n        }\r\n        configuration.put(nameKey, ovrName);\r\n    } else {\r\n        final String name = configuration.getProperty(nameKey);\r\n        if (name == null) {\r\n            override = true;\r\n            configuration.put(nameKey, defaultVal);\r\n        }\r\n    }\r\n    return override;\r\n}"
}, {
	"Path": "fj.data.vector.V5.zip",
	"Comment": "zips this vector with the given vector to produce a vector of pairs.",
	"Method": "V5<P2<A, B>> zip(V5<B> bs){\r\n    final F<A, F<B, P2<A, B>>> __2 = p2();\r\n    return zipWith(__2, bs);\r\n}"
}, {
	"Path": "fj.test.Arbitrary.arbPriorityBlockingQueue",
	"Comment": "returns an arbitrary implementation for priority blocking queues.",
	"Method": "Gen<PriorityBlockingQueue<A>> arbPriorityBlockingQueue(Gen<A> aa){\r\n    return arbArray(aa).map(a -> new PriorityBlockingQueue(a.asJavaList()));\r\n}"
}, {
	"Path": "com.vaadin.tests.tb3.MultiBrowserTestWithProxy.connectProxy",
	"Comment": "ensure the proxy is active. does nothing if the proxy is already active.",
	"Method": "void connectProxy(){\r\n    if (proxySession != null) {\r\n        return;\r\n    }\r\n    for (int i = 0; i < 10; i++) {\r\n        try {\r\n            createProxy(getProxyPort());\r\n            break;\r\n        } catch (IOException e) {\r\n            sleep(500);\r\n            if (i == 9) {\r\n                throw new RuntimeException(\"All 10 attempts to connect a proxy failed\", e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "fj.control.db.DB.db",
	"Comment": "constructs a database action as a function from a database connection to a value.",
	"Method": "DB<A> db(F<Connection, A> f,DB<A> db,Try1<Connection, A, SQLException> t){\r\n    return new DB<A>() {\r\n        public A run(final Connection c) throws SQLException {\r\n            return t.f(c);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "fj.control.db.DB.db",
	"Comment": "constructs a database action as a function from a database connection to a value.",
	"Method": "DB<A> db(F<Connection, A> f,DB<A> db,Try1<Connection, A, SQLException> t){\r\n    return t.f(c);\r\n}"
}, {
	"Path": "fj.data.TreeZipper.getChild",
	"Comment": "navigates to the given child of the current location, starting at index 0.",
	"Method": "Option<TreeZipper<A>> getChild(int n){\r\n    Option<TreeZipper<A>> r = none();\r\n    for (final P2<Stream<Tree<A>>, Stream<Tree<A>>> lr : splitChildren(Stream.nil(), tree.subForest()._1(), n)) {\r\n        r = some(treeZipper(lr._1().head(), lr._1().tail()._1(), lr._2(), downParents()));\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "fj.data.Stream.zip",
	"Comment": "zips this stream with the given stream to produce a stream of pairs. if this stream and thegiven stream have different lengths, then the longer stream is normalised so this functionnever fails.",
	"Method": "Stream<P2<A, B>> zip(Stream<B> bs){\r\n    final F<A, F<B, P2<A, B>>> __2 = p2();\r\n    return zipWith(bs, __2);\r\n}"
}, {
	"Path": "fj.Function.bind",
	"Comment": "binds the given function f to the values of the given functions, with a final join.",
	"Method": "F<C, B> bind(F<C, A> ma,F<A, F<C, B>> f,F<D, C> bind,F<D, A> ca,F<D, B> cb,F<A, F<B, C>> f){\r\n    return apply(compose(f, ca), cb);\r\n}"
}, {
	"Path": "fj.F1Functions.failK",
	"Comment": "promotes this function so that it returns its result on the failure side of a validation.kleisli arrow for the validation failure projection.",
	"Method": "F<A, Validation<B, C>> failK(F<A, B> f){\r\n    return a -> Validation.fail(f.f(a));\r\n}"
}, {
	"Path": "fj.data.Stream.sequence_",
	"Comment": "turn a stream of functions into a function returning a stream.",
	"Method": "F<B, Stream<A>> sequence_(Stream<F<B, A>> fs){\r\n    return fs.foldRight((baf, p1) -> Function.bind(baf, p1._1(), curry((a, stream) -> cons(a, p(stream)))), Function.constant(Stream.nil()));\r\n}"
}, {
	"Path": "fj.data.List.toString",
	"Comment": "obtain a string representation of this list using the tostring implementations of the members.uses show.listshow with f2 argument and maynot be very performant.",
	"Method": "String toString(){\r\n    return Show.listShow(Show.<A>anyShow()).showS(this);\r\n}"
}, {
	"Path": "fj.control.db.DB.bind",
	"Comment": "binds the given action across the result of this database action.",
	"Method": "DB<B> bind(F<A, DB<B>> f){\r\n    return new DB<B>() {\r\n        public B run(final Connection c) throws SQLException {\r\n            return f.f(DB.this.run(c)).run(c);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "fj.control.db.DB.bind",
	"Comment": "binds the given action across the result of this database action.",
	"Method": "DB<B> bind(F<A, DB<B>> f){\r\n    return f.f(DB.this.run(c)).run(c);\r\n}"
}, {
	"Path": "fj.test.CheckResult.discarded",
	"Comment": "returns the number of discarded checks of the property in this result.",
	"Method": "int discarded(){\r\n    return discarded;\r\n}"
}, {
	"Path": "org.geoserver.cluster.JMSManager.getHandler",
	"Comment": "method to make lookup using the type of the passed eventtype.",
	"Method": "JMSEventHandler<S, O> getHandler(O eventType){\r\n    final Set<?> beanSet = beans.entrySet();\r\n    final Set<JMSEventHandlerSPI<S, O>> candidates = new TreeSet<JMSEventHandlerSPI<S, O>>(new Comparator<JMSEventHandlerSPI<S, O>>() {\r\n        @Override\r\n        public int compare(JMSEventHandlerSPI<S, O> o1, JMSEventHandlerSPI<S, O> o2) {\r\n            if (o1.getPriority() < o2.getPriority())\r\n                return -1;\r\n            else if (o1.getPriority() == o2.getPriority()) {\r\n                return 0;\r\n            } else {\r\n                return 1;\r\n            }\r\n        }\r\n    });\r\n    for (final Iterator<?> it = beanSet.iterator(); it.hasNext(); ) {\r\n        final Map.Entry<String, ?> entry = (Entry<String, ?>) it.next();\r\n        final JMSEventHandlerSPI<S, O> spi = (JMSEventHandlerSPI) entry.getValue();\r\n        if (spi != null) {\r\n            if (spi.canHandle(eventType)) {\r\n                if (LOGGER.isLoggable(Level.INFO))\r\n                    LOGGER.info(\"Creating an instance of: \" + spi.getClass());\r\n                candidates.add(spi);\r\n            }\r\n        }\r\n    }\r\n    final Iterator<JMSEventHandlerSPI<S, O>> it = candidates.iterator();\r\n    while (it.hasNext()) {\r\n        try {\r\n            final JMSEventHandler<S, O> handler = it.next().createHandler();\r\n            if (handler != null)\r\n                return handler;\r\n        } catch (Exception e) {\r\n            if (LOGGER.isLoggable(Level.WARNING))\r\n                LOGGER.log(Level.WARNING, e.getLocalizedMessage(), e);\r\n        }\r\n    }\r\n    final String message = \"Unable to find the needed Handler SPI for event of type: \" + eventType.getClass().getCanonicalName();\r\n    if (LOGGER.isLoggable(Level.WARNING))\r\n        LOGGER.warning(message);\r\n    throw new IllegalArgumentException(message);\r\n}"
}, {
	"Path": "org.geoserver.cluster.JMSManager.getHandler",
	"Comment": "method to make lookup using the type of the passed eventtype.",
	"Method": "JMSEventHandler<S, O> getHandler(O eventType){\r\n    if (o1.getPriority() < o2.getPriority())\r\n        return -1;\r\n    else if (o1.getPriority() == o2.getPriority()) {\r\n        return 0;\r\n    } else {\r\n        return 1;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.launcher.DevelopmentServerLauncher.main",
	"Comment": "main function for running jetty.command line arguments are passed through to jetty, see runserver methodfor options.",
	"Method": "void main(String[] args){\r\n    System.setProperty(\"java.awt.headless\", \"true\");\r\n    System.setProperty(\"org.eclipse.jetty.util.log.class\", JavaUtilLog.class.getName());\r\n    assertAssertionsEnabled();\r\n    final Map<String, String> serverArgs = parseArguments(args);\r\n    if (!serverArgs.containsKey(\"shutdownPort\")) {\r\n        serverArgs.put(\"shutdownPort\", \"8889\");\r\n    }\r\n    int port = Integer.parseInt(serverArgs.get(\"shutdownPort\"));\r\n    if (port > 0) {\r\n        try {\r\n            Socket socket = new Socket((String) null, port);\r\n            socket.getInputStream().read();\r\n            socket.close();\r\n        } catch (IOException e) {\r\n        }\r\n    }\r\n    System.out.println(\"Starting Jetty servlet container.\");\r\n    String url;\r\n    try {\r\n        url = runServer(serverArgs, \"Development Server Mode\");\r\n        if (serverArgs.containsKey(\"gui\") && url != null) {\r\n            System.out.println(\"Starting Web Browser.\");\r\n            BrowserLauncher.openBrowser(url);\r\n        }\r\n    } catch (Exception e) {\r\n    }\r\n}"
}, {
	"Path": "fj.data.Stream.sequenceW",
	"Comment": "applies a stream of comonadic functions to this stream, returning a stream of values.",
	"Method": "Stream<B> sequenceW(Stream<F<Stream<A>, B>> fs){\r\n    return fs.isEmpty() ? Stream.nil() : cons(fs.head().f(this), () -> sequenceW(fs.tail()._1()));\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.AbstractSelectElement.clear",
	"Comment": "clear operation is not supported for select element classes. thisoperation has no effect on select element",
	"Method": "void clear(){\r\n    super.clear();\r\n}"
}, {
	"Path": "fj.parser.Parser.value",
	"Comment": "constructs a parser that always returns the given value. the unital for a parser.",
	"Method": "Parser<I, A, E> value(A a){\r\n    return parser(i -> success(result(i, a)));\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.AbstractSplitPanelElement.getSecondComponent",
	"Comment": "gets the second component of a split panel and wraps it in given class.",
	"Method": "T getSecondComponent(Class<T> clazz){\r\n    return getContainedComponent(clazz, bySecondContainer);\r\n}"
}, {
	"Path": "fj.data.properties.PriorityQueueProperties.sorted",
	"Comment": "sorting a list returns the same as putting the list into a priority queue and getting the queue as a list.",
	"Method": "Property sorted(){\r\n    return property(arbPriorityQueueIntegerString, pq -> {\r\n        List<P2<Integer, String>> expected = pq.toList().sort(Ord.p2Ord1(Ord.intOrd.reverse()));\r\n        List<P2<Integer, String>> actual = pq.toList();\r\n        return prop(actual.equals(expected));\r\n    });\r\n}"
}, {
	"Path": "fj.F1Functions.mapLeft",
	"Comment": "promotes this function to map over the left side of an either.",
	"Method": "F<Either<A, X>, Either<B, X>> mapLeft(F<A, B> f){\r\n    return Either.<A, X, B>leftMap_().f(f);\r\n}"
}, {
	"Path": "fj.demo.IODemo.readFirstLine",
	"Comment": "read a stream of input lazily using interact, in effect reading the first line",
	"Method": "void readFirstLine(){\r\n    F<LazyString, LazyString> f = lift(LazyString::lines).andThen(unlines_());\r\n    runSafe(interact(f));\r\n}"
}, {
	"Path": "fj.control.Trampoline.run",
	"Comment": "runs this computation all the way to the end, in constant stack.",
	"Method": "A run(){\r\n    Trampoline<A> current = this;\r\n    while (true) {\r\n        final Either<P1<Trampoline<A>>, A> x = current.resume();\r\n        for (final P1<Trampoline<A>> t : x.left()) {\r\n            current = t._1();\r\n        }\r\n        for (final A a : x.right()) {\r\n            return a;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.reader.CatalogMultiResourceItemReader.update",
	"Comment": "store the current resource index and position in the resource.",
	"Method": "void update(ExecutionContext executionContext){\r\n    super.update(executionContext);\r\n    if (saveState) {\r\n        executionContext.putInt(getExecutionContextKey(RESOURCE_KEY), currentResource);\r\n        delegate.update(executionContext);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.tests.applicationcontext.CloseSessionTest.testBackgroundThreadHttpSessionInvalidation",
	"Comment": "verify we get a session expired error if closing httpsession in abackground thread.",
	"Method": "void testBackgroundThreadHttpSessionInvalidation(){\r\n    String caption = \"Invalidate HttpSession in a background thread\";\r\n    clickButton(caption);\r\n    sleep(2000);\r\n    clickButton(caption);\r\n    assertSessionExpired();\r\n}"
}, {
	"Path": "fj.test.Property.and",
	"Comment": "performs a conjunction of this property with the given property.",
	"Method": "Property and(Property p){\r\n    return fromGen(gen().bind(p.gen(), res1 -> res2 -> res1.isException() || res1.isFalsified() ? res1 : res2.isException() || res2.isFalsified() ? res2 : res1.isProven() || res1.isUnfalsified() ? res2 : res2.isProven() || res2.isUnfalsified() ? res1 : noResult()));\r\n}"
}, {
	"Path": "com.galenframework.specs.page.PageSpec.setSections",
	"Comment": "clears the current root sections and copies new sections from given list",
	"Method": "void setSections(List<PageSection> sections){\r\n    this.sections.clear();\r\n    if (sections != null) {\r\n        this.sections.addAll(sections);\r\n    }\r\n}"
}, {
	"Path": "fj.data.Validation.toArray",
	"Comment": "returns a single element array if this is a success value, otherwise an empty list.",
	"Method": "Array<T> toArray(Array<E> toArray){\r\n    return e.right().toArray();\r\n}"
}, {
	"Path": "fj.test.Gen.somePermutationOf",
	"Comment": "returns a generator of lists that produces some of the values of the given list. the selection isa permutation without replacement of elements from the given list, i.e.for any given selection, a generated list may contain its elements in any orderan element will never be picked more than once",
	"Method": "Gen<List<A>> somePermutationOf(List<A> as){\r\n    return choose(0, as.length()).bind(n -> permutationOf(n, as));\r\n}"
}, {
	"Path": "fj.test.Property.impliesBoolean",
	"Comment": "returns a property that produces a result only if the given condition satisfies. the resultwill be taken from the given lazy boolean b.",
	"Method": "Property impliesBoolean(boolean a,boolean b,Property impliesBoolean,boolean a,F0<Boolean> b){\r\n    return implies(a, () -> prop(b.f()));\r\n}"
}, {
	"Path": "fj.test.CheckResult.propException",
	"Comment": "returns a result that checking the property threw an exception.",
	"Method": "CheckResult propException(List<Arg<?>> args,Throwable ex,int succeeded,int discarded){\r\n    return new CheckResult(R.PropException, some(args), some(ex), succeeded, discarded);\r\n}"
}, {
	"Path": "fj.F1W.optionK",
	"Comment": "promotes this function so that it returns its result in an option. kleisli arrow for option.",
	"Method": "F1W<A, Option<B>> optionK(){\r\n    return lift(F1Functions.optionK(this));\r\n}"
}, {
	"Path": "fj.data.vector.V5.vzip",
	"Comment": "zips this vector with the given vector to produce a vector of vectors.",
	"Method": "V5<V2<A>> vzip(V5<A> bs){\r\n    final F2<A, A, V2<A>> __2 = V.v2();\r\n    return zipWith(curry(__2), bs);\r\n}"
}, {
	"Path": "org.geoserver.wcs.response.GdalCoverageResponseDelegate.replaceFormats",
	"Comment": "replaces currently supported formats with the provided list.",
	"Method": "void replaceFormats(List<Format> formats){\r\n    if (formats == null || formats.isEmpty()) {\r\n        throw new IllegalArgumentException(\"No formats provided\");\r\n    }\r\n    formatsLock.writeLock().lock();\r\n    try {\r\n        clearFormatsInternal();\r\n        for (Format format : formats) {\r\n            if (format != null) {\r\n                addFormatInternal(format);\r\n            }\r\n        }\r\n    } finally {\r\n        formatsLock.writeLock().unlock();\r\n    }\r\n}"
}, {
	"Path": "fj.data.LazyString.endsWith",
	"Comment": "returns true if the given lazy string is a suffix of this lazy string.",
	"Method": "boolean endsWith(LazyString cs){\r\n    return reverse().startsWith(cs.reverse());\r\n}"
}, {
	"Path": "fj.data.Stream.snoc",
	"Comment": "append the given element to this stream to produce a new stream.",
	"Method": "Stream<A> snoc(A a,Stream<A> snoc,F0<A> a){\r\n    return append(() -> single(a.f()));\r\n}"
}, {
	"Path": "fj.data.Stream.length",
	"Comment": "the length of this stream. this function will not terminate for an infinite stream.",
	"Method": "int length(){\r\n    Stream<A> xs = this;\r\n    int i = 0;\r\n    while (!xs.isEmpty()) {\r\n        xs = xs.tail()._1();\r\n        i += 1;\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "fj.data.Zipper.insertLeft",
	"Comment": "inserts an element to the left of the focus, then moves the focus to the new element.",
	"Method": "Zipper<A> insertLeft(A a){\r\n    return zipper(left, a, right.cons(focus));\r\n}"
}, {
	"Path": "fj.data.Validation.toOption",
	"Comment": "returns the success value in some if there is one, otherwise none.",
	"Method": "Option<T> toOption(Option<E> toOption){\r\n    return e.right().toOption();\r\n}"
}, {
	"Path": "fj.data.Enumerator.predecessor",
	"Comment": "returns the potential predecessor of a value for this enumerator.",
	"Method": "F<A, Option<A>> predecessor(Option<A> predecessor,A a){\r\n    return predecessor.f(a);\r\n}"
}, {
	"Path": "fj.data.LazyString.contains",
	"Comment": "returns true if the given lazy string is a substring of this lazy string.",
	"Method": "boolean contains(LazyString cs){\r\n    return or(s.tails().map(compose(startsWith().f(cs), fromStream)));\r\n}"
}, {
	"Path": "fj.data.Java.Array_CopyOnWriteArrayList",
	"Comment": "a function that converts arrays to copy on write array lists.",
	"Method": "F<Array<A>, CopyOnWriteArrayList<A>> Array_CopyOnWriteArrayList(){\r\n    return as -> new CopyOnWriteArrayList(as.asJavaList());\r\n}"
}, {
	"Path": "fj.data.NonEmptyList.maximum",
	"Comment": "returns the maximum element in this non empty list according to the given ordering.",
	"Method": "A maximum(Ord<A> o){\r\n    return foldLeft1(o::max);\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerRestRoleService.connectToRESTEndpoint",
	"Comment": "execute rest call, and then call the given callback on http json response.",
	"Method": "Object connectToRESTEndpoint(String roleRESTBaseURL,String roleRESTEndpoint,String roleJSONPath,RestEndpointConnectionCallback callback){\r\n    final String restEndPoint = roleRESTBaseURL + roleRESTEndpoint + roleJSONPath;\r\n    final String hash = getHash(restEndPoint);\r\n    try {\r\n        final String cachedResponse = cachedResponses.get(hash, new Callable<String>() {\r\n            @Override\r\n            public String call() throws Exception {\r\n                LOGGER.fine(\"GeoServer REST Role Service CACHE MISS for '\" + restEndPoint + \"'\");\r\n                ClientHttpRequest clientRequest = null;\r\n                ClientHttpResponse clientResponse = null;\r\n                try {\r\n                    final URI baseURI = new URI(roleRESTBaseURL);\r\n                    URL url = baseURI.resolve(roleRESTEndpoint).toURL();\r\n                    clientRequest = getRestTemplate().getRequestFactory().createRequest(url.toURI(), HttpMethod.GET);\r\n                    clientResponse = clientRequest.execute();\r\n                    int status = clientResponse.getRawStatusCode();\r\n                    switch(status) {\r\n                        case 200:\r\n                        case 201:\r\n                            BufferedReader br = new BufferedReader(new InputStreamReader(clientResponse.getBody()));\r\n                            StringBuilder sb = new StringBuilder();\r\n                            String line;\r\n                            while ((line = br.readLine()) != null) {\r\n                                sb.append(line + \"\\n\");\r\n                            }\r\n                            br.close();\r\n                            String json = sb.toString();\r\n                            return json;\r\n                    }\r\n                } catch (MalformedURLException ex) {\r\n                    Logger.getLogger(getClass().getName()).log(Level.FINEST, null, ex);\r\n                } catch (IOException ex) {\r\n                    Logger.getLogger(getClass().getName()).log(Level.FINEST, null, ex);\r\n                } catch (URISyntaxException ex) {\r\n                    Logger.getLogger(getClass().getName()).log(Level.FINEST, null, ex);\r\n                } finally {\r\n                    if (clientResponse != null) {\r\n                        try {\r\n                            clientResponse.close();\r\n                        } catch (Exception ex) {\r\n                            Logger.getLogger(getClass().getName()).log(Level.SEVERE, null, ex);\r\n                        }\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        return callback.executeWithContext(cachedResponse);\r\n    } catch (ExecutionException e) {\r\n        LOGGER.log(Level.FINEST, e.getMessage(), e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerRestRoleService.connectToRESTEndpoint",
	"Comment": "execute rest call, and then call the given callback on http json response.",
	"Method": "Object connectToRESTEndpoint(String roleRESTBaseURL,String roleRESTEndpoint,String roleJSONPath,RestEndpointConnectionCallback callback){\r\n    LOGGER.fine(\"GeoServer REST Role Service CACHE MISS for '\" + restEndPoint + \"'\");\r\n    ClientHttpRequest clientRequest = null;\r\n    ClientHttpResponse clientResponse = null;\r\n    try {\r\n        final URI baseURI = new URI(roleRESTBaseURL);\r\n        URL url = baseURI.resolve(roleRESTEndpoint).toURL();\r\n        clientRequest = getRestTemplate().getRequestFactory().createRequest(url.toURI(), HttpMethod.GET);\r\n        clientResponse = clientRequest.execute();\r\n        int status = clientResponse.getRawStatusCode();\r\n        switch(status) {\r\n            case 200:\r\n            case 201:\r\n                BufferedReader br = new BufferedReader(new InputStreamReader(clientResponse.getBody()));\r\n                StringBuilder sb = new StringBuilder();\r\n                String line;\r\n                while ((line = br.readLine()) != null) {\r\n                    sb.append(line + \"\\n\");\r\n                }\r\n                br.close();\r\n                String json = sb.toString();\r\n                return json;\r\n        }\r\n    } catch (MalformedURLException ex) {\r\n        Logger.getLogger(getClass().getName()).log(Level.FINEST, null, ex);\r\n    } catch (IOException ex) {\r\n        Logger.getLogger(getClass().getName()).log(Level.FINEST, null, ex);\r\n    } catch (URISyntaxException ex) {\r\n        Logger.getLogger(getClass().getName()).log(Level.FINEST, null, ex);\r\n    } finally {\r\n        if (clientResponse != null) {\r\n            try {\r\n                clientResponse.close();\r\n            } catch (Exception ex) {\r\n                Logger.getLogger(getClass().getName()).log(Level.SEVERE, null, ex);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.tasklet.GenericTaskletUtils.isDryRun",
	"Comment": "returns true if the current job is a restore job running in a dry mode.",
	"Method": "boolean isDryRun(BackupRestoreItem context){\r\n    return context.isDryRun();\r\n}"
}, {
	"Path": "org.geoserver.wms.worldwind.util.BilWCSUtils.reproject",
	"Comment": "reprojectingthe new grid geometry can have a different coordinate reference system than the underlyinggrid geometry. for example, a grid coverage can be reprojected from a geodetic coordinatereference system to universal transverse mercator crs.",
	"Method": "GridCoverage2D reproject(GridCoverage2D coverage,CoordinateReferenceSystem sourceCRS,CoordinateReferenceSystem targetCRS,Interpolation interpolation){\r\n    if (!CRS.equalsIgnoreMetadata(sourceCRS, targetCRS)) {\r\n        final ParameterValueGroup param = (ParameterValueGroup) processor.getOperation(\"Resample\").getParameters();\r\n        param.parameter(\"Source\").setValue(coverage);\r\n        param.parameter(\"CoordinateReferenceSystem\").setValue(targetCRS);\r\n        param.parameter(\"GridGeometry\").setValue(null);\r\n        param.parameter(\"InterpolationType\").setValue(interpolation);\r\n        coverage = (GridCoverage2D) ((Resample) processor.getOperation(\"Resample\")).doOperation(param, hints);\r\n    }\r\n    return coverage;\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.OptionGroupElement.clear",
	"Comment": "clear operation is not supported for option group. this operation has noeffect on option group element.",
	"Method": "void clear(){\r\n    super.clear();\r\n}"
}, {
	"Path": "fj.data.TreeZipper.zipWithFocus",
	"Comment": "zips the nodes in this zipper with a boolean that indicates whether that node has focus.all of the booleans will be false, except for the focused node.",
	"Method": "TreeZipper<P2<A, Boolean>> zipWithFocus(){\r\n    final F<A, P2<A, Boolean>> f = flip(P.<A, Boolean>p2()).f(false);\r\n    return map(f).modifyLabel(P2.map2_(Booleans.not));\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.listener.GenericListenersExecutor.getListeners",
	"Comment": "helper method that returns all the available job execution listeners.",
	"Method": "List<BackupRestoreJobExecutionListener> getListeners(){\r\n    return GeoServerExtensions.extensions(BackupRestoreJobExecutionListener.class);\r\n}"
}, {
	"Path": "fj.control.db.DbState.reader",
	"Comment": "returns a new reader that reads the database via the given connector.",
	"Method": "DbState reader(String url,DbState reader,Connector pc){\r\n    return new DbState(pc, rollback);\r\n}"
}, {
	"Path": "fj.data.NonEmptyList.bind",
	"Comment": "binds the given function across each element of this list with a final join.",
	"Method": "NonEmptyList<B> bind(F<A, NonEmptyList<B>> f){\r\n    final List.Buffer<B> b = new List.Buffer();\r\n    final NonEmptyList<B> p = f.f(head);\r\n    b.snoc(p.head);\r\n    b.append(p.tail);\r\n    tail.foreachDoEffect(a -> {\r\n        final NonEmptyList<B> p1 = f.f(a);\r\n        b.snoc(p1.head);\r\n        b.append(p1.tail);\r\n    });\r\n    final List<B> bb = b.toList();\r\n    return nel(bb.head(), bb.tail());\r\n}"
}, {
	"Path": "fj.data.vector.V4.zip",
	"Comment": "zips this vector with the given vector to produce a vector of pairs.",
	"Method": "V4<P2<A, B>> zip(V4<B> bs){\r\n    final F<A, F<B, P2<A, B>>> __2 = p2();\r\n    return zipWith(__2, bs);\r\n}"
}, {
	"Path": "fj.parser.Result.mapRest",
	"Comment": "maps the given function across the remainder of the parse input.",
	"Method": "Result<J, A> mapRest(F<I, J> f,F<F<I, J>, Result<J, A>> mapRest){\r\n    return this::mapRest;\r\n}"
}, {
	"Path": "fj.F1W.mapFail",
	"Comment": "promotes this function to map over the failure side of a validation.",
	"Method": "F1W<Validation<A, X>, Validation<B, X>> mapFail(){\r\n    return lift(F1Functions.mapFail(this));\r\n}"
}, {
	"Path": "fj.Monoid.xmap",
	"Comment": "maps the given functions across this monoid as an invariant functor.",
	"Method": "Monoid<B> xmap(F<A, B> f,F<B, A> g){\r\n    Monoid.Definition<A> def = this.def;\r\n    B zero = f.f(def.empty());\r\n    return monoidDef(new Definition<B>() {\r\n        @Override\r\n        public B empty() {\r\n            return zero;\r\n        }\r\n        @Override\r\n        public B append(B a1, B a2) {\r\n            return f.f(def.append(g.f(a1), g.f(a2)));\r\n        }\r\n        @Override\r\n        public F<B, B> prepend(B b) {\r\n            return dimap(def.prepend(g.f(b)), g, f);\r\n        }\r\n        @Override\r\n        public B multiply(int n, B b) {\r\n            return f.f(def.multiply(n, g.f(b)));\r\n        }\r\n        @Override\r\n        public B sum(F0<Stream<B>> as) {\r\n            return f.f(def.sum(() -> as.f().map(g)));\r\n        }\r\n    });\r\n}"
}, {
	"Path": "fj.Monoid.xmap",
	"Comment": "maps the given functions across this monoid as an invariant functor.",
	"Method": "Monoid<B> xmap(F<A, B> f,F<B, A> g){\r\n    return zero;\r\n}"
}, {
	"Path": "fj.Monoid.xmap",
	"Comment": "maps the given functions across this monoid as an invariant functor.",
	"Method": "Monoid<B> xmap(F<A, B> f,F<B, A> g){\r\n    return f.f(def.append(g.f(a1), g.f(a2)));\r\n}"
}, {
	"Path": "fj.Monoid.xmap",
	"Comment": "maps the given functions across this monoid as an invariant functor.",
	"Method": "Monoid<B> xmap(F<A, B> f,F<B, A> g){\r\n    return dimap(def.prepend(g.f(b)), g, f);\r\n}"
}, {
	"Path": "fj.Monoid.xmap",
	"Comment": "maps the given functions across this monoid as an invariant functor.",
	"Method": "Monoid<B> xmap(F<A, B> f,F<B, A> g){\r\n    return f.f(def.multiply(n, g.f(b)));\r\n}"
}, {
	"Path": "fj.Monoid.xmap",
	"Comment": "maps the given functions across this monoid as an invariant functor.",
	"Method": "Monoid<B> xmap(F<A, B> f,F<B, A> g){\r\n    return f.f(def.sum(() -> as.f().map(g)));\r\n}"
}, {
	"Path": "fj.F1Functions.onSuccess",
	"Comment": "returns a function that returns the success side of a given validation,or this function applied to the failure side.",
	"Method": "F<Validation<A, B>, B> onSuccess(F<A, B> f){\r\n    return v -> v.on(f);\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.tasklet.AbstractCatalogBackupRestoreTasklet.setTerminationCheckInterval",
	"Comment": "the time interval how often the tasklet will check for termination status.",
	"Method": "void setTerminationCheckInterval(long checkInterval){\r\n    this.checkInterval = checkInterval;\r\n}"
}, {
	"Path": "fj.data.List.isNotEmpty_",
	"Comment": "returns a function that determines whether a given list is not empty.",
	"Method": "F<List<A>, Boolean> isNotEmpty_(){\r\n    return List::isNotEmpty;\r\n}"
}, {
	"Path": "fj.data.vector.V8.zipWith",
	"Comment": "zips this vector with the given vector using the given function to produce a new vector.",
	"Method": "V8<C> zipWith(F<A, F<B, C>> f,V8<B> bs){\r\n    return bs.apply(map(f));\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.tasklet.GenericTasklet.getAllHandlers",
	"Comment": "helper method that just retrieves all the available generic handlers contributed byextensions.",
	"Method": "List<GenericTaskletHandler> getAllHandlers(){\r\n    return GeoServerExtensions.extensions(GenericTaskletHandler.class);\r\n}"
}, {
	"Path": "fj.Equal.notEq",
	"Comment": "returns true if the two given arguments are not equal, false otherwise.",
	"Method": "boolean notEq(A a1,A a2){\r\n    return !def.equal(a1, a2);\r\n}"
}, {
	"Path": "fj.data.IterableW.map",
	"Comment": "returns a function that promotes any function so that it operates on iterables.",
	"Method": "IterableW<B> map(F<A, B> f,F<F<A, B>, F<IterableW<A>, IterableW<B>>> map){\r\n    return f -> a -> a.map(f);\r\n}"
}, {
	"Path": "fj.demo.IODemo.simpleInteract",
	"Comment": "demonstrate use of interact, just echoing the lazy string.reading lines is donelazily, so just the first line is read.",
	"Method": "void simpleInteract(){\r\n    runSafe(interact(s -> s));\r\n}"
}, {
	"Path": "org.geoserver.cluster.hazelcast.EventHzSynchronizerRecvTest.catResEvent",
	"Comment": "matches a catalog event that has a source with the given id, and a store property, the valueof which has the given id.",
	"Method": "CatalogEvent catResEvent(String id,String storeId){\r\n    EasyMock2Adapter.adapt(hasProperty(\"source\", allOf(hasProperty(\"id\", is(id)), hasProperty(\"store\", hasProperty(\"id\", is(storeId))))));\r\n    return null;\r\n}"
}, {
	"Path": "fj.P1.bind",
	"Comment": "binds the given function to the values in the given p1s with a final join.",
	"Method": "P1<B> bind(F<A, P1<B>> f,P1<C> bind,P1<B> cb,F<A, F<B, C>> f,P1<C> bind,P1<B> cb,F2<A, B, C> f){\r\n    return bind(cb, F2W.lift(f).curry());\r\n}"
}, {
	"Path": "fj.data.Validation.success",
	"Comment": "returns a succeeding validation containing the given value.",
	"Method": "T success(Validation<E, T> success,T t){\r\n    return validation(Either.right(t));\r\n}"
}, {
	"Path": "fj.data.Array.scanLeft",
	"Comment": "performs a fold left accummulating and returns an array of the intermediate results.this function runs in constant stack space.",
	"Method": "Array<B> scanLeft(F<B, F<A, B>> f,B b,Array<B> scanLeft,F2<B, A, B> f,B b){\r\n    return scanLeft(curry(f), b);\r\n}"
}, {
	"Path": "fj.data.Stream.orHead",
	"Comment": "returns the head of this stream if there is one or the given argument if this stream is empty.",
	"Method": "A orHead(F0<A> a){\r\n    return isEmpty() ? a.f() : head();\r\n}"
}, {
	"Path": "fj.control.parallel.Strategy.simpleThreadStrategy",
	"Comment": "provides a simple parallelization strategy that creates, and discards, a new thread forevery evaluation.",
	"Method": "Strategy<A> simpleThreadStrategy(){\r\n    return strategy(p -> {\r\n        final FutureTask<A> t = new FutureTask(Java.<A>P1_Callable().f(p));\r\n        new Thread(t).start();\r\n        return obtain(t);\r\n    });\r\n}"
}, {
	"Path": "com.vaadin.shared.VBrowserDetails.isEs6Supported",
	"Comment": "checks whether the browser should support es6 based on its vendor andversion number.",
	"Method": "boolean isEs6Supported(){\r\n    if (isSafari() && getBrowserMajorVersion() >= 10) {\r\n        return true;\r\n    }\r\n    if (isFirefox() && getBrowserMajorVersion() >= 51) {\r\n        return true;\r\n    }\r\n    if (isOpera() && getBrowserMajorVersion() >= 36) {\r\n        return true;\r\n    }\r\n    if (isChrome() && getBrowserMajorVersion() >= 49) {\r\n        return true;\r\n    }\r\n    if (isEdge() && (getBrowserMajorVersion() > 15 || (getBrowserMajorVersion() == 15 && getBrowserMinorVersion() >= 15063))) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "fj.data.Stream.forever",
	"Comment": "returns a stream that is either infinite or bounded up to the maximum value of the given iterator starting at thegiven value and stepping at the given increment.",
	"Method": "Stream<A> forever(Enumerator<A> e,A from,Stream<A> forever,Enumerator<A> e,A from,long step){\r\n    return cons(from, () -> e.plus(from, step).map(a -> forever(e, a, step)).orSome(Stream.nil()));\r\n}"
}, {
	"Path": "fj.data.hlist.HList.single",
	"Comment": "returns a heterogeneous list consisting of a single element.",
	"Method": "HCons<E, HNil> single(E e){\r\n    return cons(e, nil());\r\n}"
}, {
	"Path": "fj.F1W.arrayK",
	"Comment": "promotes this function so that it returns its result in a array. kleisli arrow for array.",
	"Method": "F1W<A, Array<B>> arrayK(){\r\n    return lift(F1Functions.arrayK(this));\r\n}"
}, {
	"Path": "com.vaadin.tests.elements.listselect.ListSelectOptionClickTest.checkValueChanged",
	"Comment": "checks that value has changed. checks that the change event was firedonce.",
	"Method": "void checkValueChanged(){\r\n    String actual = select.getValue();\r\n    String actualCounter = counterLbl.getText();\r\n    assertEquals(\"The value of the ListSelect has not changed\", \"item2\", actual);\r\n    assertEquals(\"The number of list select valueChange events is not one.\", \"1: item2\", actualCounter);\r\n}"
}, {
	"Path": "fj.Bottom.error",
	"Comment": "returns an error to represent undefinedness in a computation with early failure using the givenmessage.",
	"Method": "Error error(String s){\r\n    throw new Error(s);\r\n}"
}, {
	"Path": "fj.data.Stream.mergesort",
	"Comment": "merges a stream of individually sorted streams into a single sorted stream.",
	"Method": "Stream<A> mergesort(Ord<A> o,Stream<Stream<A>> s){\r\n    if (s.isEmpty())\r\n        return nil();\r\n    Stream<Stream<A>> xss = s;\r\n    while (xss.tail()._1().isNotEmpty()) xss = mergePairs(o, xss);\r\n    return xss.head();\r\n}"
}, {
	"Path": "com.galenframework.javascript.GalenJsExecutor.evalStrictToString",
	"Comment": "used for processing js expressions in page spec reader. in case of failure throws an exception",
	"Method": "String evalStrictToString(String script){\r\n    Object returnedObject = context.evaluateString(scope, script, \"<cmd>\", 1, null);\r\n    String unwrappedObject = unwrapProcessedObjectToString(returnedObject);\r\n    if (unwrappedObject != null) {\r\n        return unwrappedObject;\r\n    } else\r\n        return \"null\";\r\n}"
}, {
	"Path": "fj.data.List.foldLeft1",
	"Comment": "takes the first 2 elements of the list and applies the function to them,then applies the function to the result and the third element and so on.",
	"Method": "A foldLeft1(F2<A, A, A> f,A foldLeft1,F<A, F<A, A>> f){\r\n    return foldLeft1(uncurryF2(f));\r\n}"
}, {
	"Path": "com.vaadin.tests.themes.valo.CalendarTest.deleteCalendarEvent",
	"Comment": "removes the event from the data source and fires change event.",
	"Method": "void deleteCalendarEvent(){\r\n    BasicEvent event = getFormCalendarEvent();\r\n    if (dataSource.containsEvent(event)) {\r\n        dataSource.removeEvent(event);\r\n    }\r\n    getUI().removeWindow(scheduleEventPopup);\r\n}"
}, {
	"Path": "fj.data.Option.isSome",
	"Comment": "returns true if this optional value has a value, false otherwise.",
	"Method": "boolean isSome(){\r\n    return this instanceof Some;\r\n}"
}, {
	"Path": "fj.data.Validation.condition",
	"Comment": "returns a validation based on a boolean condition. if the condition is true, the validation succeeds,otherwise it fails.",
	"Method": "Validation<E, T> condition(boolean c,E e,T t){\r\n    return c ? Validation.success(t) : Validation.fail(e);\r\n}"
}, {
	"Path": "fj.data.Either.sequenceLeft",
	"Comment": "sequences through the left side of the either monad with a list of values.",
	"Method": "Either<List<A>, X> sequenceLeft(List<Either<A, X>> a){\r\n    return a.isEmpty() ? left(List.nil()) : a.head().left().bind(aa -> sequenceLeft(a.tail()).left().map(cons_(aa)));\r\n}"
}, {
	"Path": "fj.test.Shrink.shrinkArray",
	"Comment": "returns a shrink strategy for arrays. an empty array is fully shrunk.",
	"Method": "Shrink<Array<A>> shrinkArray(Shrink<A> sa){\r\n    return shrinkList(sa).map(Conversions.List_Array(), Conversions.Array_List());\r\n}"
}, {
	"Path": "fj.data.Stream.range",
	"Comment": "returns a stream using the given enumerator from the given value to the other given value stepping at the givenincrement.",
	"Method": "Stream<Integer> range(int from,long to,Stream<A> range,Enumerator<A> e,A from,A to,Stream<A> range,Enumerator<A> e,A from,A to,long step,Stream<Integer> range,int from){\r\n    return cons(from, () -> range(from + 1));\r\n}"
}, {
	"Path": "com.vaadin.tests.components.grid.CompatibilityGridInDetailsRowTest.getColumnHidingToggle",
	"Comment": "returns the first toggle inside the sidebar for hiding a column, or nullif not found.",
	"Method": "WebElement getColumnHidingToggle(GridElement grid){\r\n    WebElement sidebar = findElement(By.className(\"v-grid-sidebar-popup\"));\r\n    List<WebElement> elements = sidebar.findElements(By.className(\"column-hiding-toggle\"));\r\n    for (WebElement e : elements) {\r\n        return e;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "fj.data.TreeZipper.insertDownLast",
	"Comment": "inserts a tree as the last child of the current node. the inserted tree becomes the current tree.",
	"Method": "TreeZipper<A> insertDownLast(Tree<A> t){\r\n    return treeZipper(t, tree.subForest()._1().reverse(), Stream.nil(), downParents());\r\n}"
}, {
	"Path": "fj.test.Gen.someSelectionOf",
	"Comment": "returns a generator of lists that produces some of the values of the given list. the selection isa combination with replacement of elements from the given list, i.e.for any given selection, a generated list will always contain its elements in the same ordereach element may be picked more than once",
	"Method": "Gen<List<A>> someSelectionOf(int maxLength,List<A> as){\r\n    return choose(0, maxLength).bind(n -> selectionOf(n, as));\r\n}"
}, {
	"Path": "fj.data.Zipper.zipWithFocus",
	"Comment": "zips the elements of this zipper with a boolean that indicates whether that element has focus.all of the booleans will be false, except the focused element.",
	"Method": "Zipper<P2<A, Boolean>> zipWithFocus(){\r\n    return zipper(left.zip(repeat(false)), P.p(focus, true), right.zip(repeat(false)));\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.MenuBarElement.closeAll",
	"Comment": "closes all submenus, if any is open.this is done by clicking on the currently selected top level item.",
	"Method": "void closeAll(){\r\n    lastItemLocationMovedTo = null;\r\n    WebElement selectedItem = getSelectedTopLevelItem();\r\n    if (selectedItem != null) {\r\n        activateOrOpenSubmenu(selectedItem, true);\r\n    }\r\n}"
}, {
	"Path": "fj.data.Either.sequenceRight",
	"Comment": "sequences through the right side of the either monad with a list of values.",
	"Method": "Either<X, List<B>> sequenceRight(List<Either<X, B>> a){\r\n    return a.isEmpty() ? right(List.nil()) : a.head().right().bind(bb -> sequenceRight(a.tail()).right().map(cons_(bb)));\r\n}"
}, {
	"Path": "org.geoserver.wms.worldwind.util.BilWCSUtils.crop",
	"Comment": "croppingthe crop operation is responsible for selecting geographic subareas of the source coverage.",
	"Method": "GridCoverage2D crop(Coverage coverage,GeneralEnvelope sourceEnvelope,CoordinateReferenceSystem sourceCRS,GeneralEnvelope destinationEnvelopeInSourceCRS,Boolean conserveEnvelope){\r\n    final GridCoverage2D croppedGridCoverage;\r\n    final GeneralEnvelope intersectionEnvelope = new GeneralEnvelope(destinationEnvelopeInSourceCRS);\r\n    intersectionEnvelope.setCoordinateReferenceSystem(sourceCRS);\r\n    intersectionEnvelope.intersect((GeneralEnvelope) sourceEnvelope);\r\n    if (intersectionEnvelope.isEmpty()) {\r\n        throw new WcsException(\"The Intersection is null. Check the requested BBOX!\");\r\n    }\r\n    if (!intersectionEnvelope.equals((GeneralEnvelope) sourceEnvelope)) {\r\n        final ParameterValueGroup param = (ParameterValueGroup) processor.getOperation(\"CoverageCrop\").getParameters();\r\n        param.parameter(\"Source\").setValue(coverage);\r\n        param.parameter(\"Envelope\").setValue(intersectionEnvelope);\r\n        croppedGridCoverage = (GridCoverage2D) ((Crop) processor.getOperation(\"CoverageCrop\")).doOperation(param, hints);\r\n    } else {\r\n        croppedGridCoverage = (GridCoverage2D) coverage;\r\n    }\r\n    croppedGridCoverage.prefetch(intersectionEnvelope.toRectangle2D());\r\n    return croppedGridCoverage;\r\n}"
}, {
	"Path": "fj.data.List.orTail",
	"Comment": "returns the tail of this list if there is one or the given argument if this list is empty.",
	"Method": "List<A> orTail(F0<List<A>> as){\r\n    return isEmpty() ? as.f() : tail();\r\n}"
}, {
	"Path": "fj.Ord.ordDef",
	"Comment": "returns an order instance that uses the given minimal equality test and ordering definition.",
	"Method": "Ord<A> ordDef(Definition<A> def,Ord<A> ordDef,AltDefinition<A> def){\r\n    return new Ord(def);\r\n}"
}, {
	"Path": "fj.data.List.minimum",
	"Comment": "returns the minimum element in this list according to the given ordering.",
	"Method": "A minimum(Ord<A> o){\r\n    return foldLeft1(o::min);\r\n}"
}, {
	"Path": "fj.data.Validation.validation",
	"Comment": "returns a function that constructs a validation with an either.",
	"Method": "X validation(F<E, X> fail,F<T, X> success,Validation<E, T> validation,Validation<E, T> validation,Either<E, T> e,F<Either<E, T>, Validation<E, T>> validation){\r\n    return Validation::validation;\r\n}"
}, {
	"Path": "fj.data.vector.V3.zipWith",
	"Comment": "zips this vector with the given vector using the given function to produce a new vector.",
	"Method": "V3<C> zipWith(F<A, F<B, C>> f,V3<B> bs){\r\n    return bs.apply(map(f));\r\n}"
}, {
	"Path": "fj.data.vector.V3.zip",
	"Comment": "zips this vector with the given vector to produce a vector of pairs.",
	"Method": "V3<P2<A, B>> zip(V3<B> bs){\r\n    final F<A, F<B, P2<A, B>>> __2 = p2();\r\n    return zipWith(__2, bs);\r\n}"
}, {
	"Path": "fj.data.Validation.either",
	"Comment": "returns a function that constructs an either with a validation.",
	"Method": "F<Validation<E, T>, Either<E, T>> either(){\r\n    return Validation::toEither;\r\n}"
}, {
	"Path": "com.vaadin.tests.util.TestUtils.injectCSS",
	"Comment": "crossbrowser hack to dynamically add css current window. can be used tokeep tests css in source files.",
	"Method": "void injectCSS(UI w,String cssString){\r\n    String script = \"if ('\\\\v'=='v') /* ie only */ {\\n\" + \"        document.createStyleSheet().cssText = '\" + cssString + \"';\\n\" + \"    } else {var tag = document.createElement('style'); tag.type = 'text/css';\" + \" document.getElementsByTagName('head')[0].appendChild(tag);tag[ (typeof \" + \"document.body.style.WebkitAppearance=='string') /* webkit only */ ? 'innerText' \" + \": 'innerHTML'] = '\" + cssString + \"';}\";\r\n    w.getPage().getJavaScript().execute(script);\r\n}"
}, {
	"Path": "fj.test.CheckResult.isGenException",
	"Comment": "returns true if this result is an exception during generating of values forproperty checking, false otherwise.",
	"Method": "boolean isGenException(){\r\n    return r == R.GenException;\r\n}"
}, {
	"Path": "fj.data.Stream.fromFunction",
	"Comment": "converts a function of an enumerable type to a stream of the results of that function,starting at the given index.",
	"Method": "Stream<A> fromFunction(F<Natural, A> f,Stream<A> fromFunction,Enumerator<B> e,F<B, A> f,B i){\r\n    return cons(f.f(i), () -> {\r\n        final Option<B> s = e.successor(i);\r\n        return s.isSome() ? fromFunction(e, f, s.some()) : Stream.nil();\r\n    });\r\n}"
}, {
	"Path": "fj.data.Stream.intersperse",
	"Comment": "intersperses the given value between each two elements of the stream.",
	"Method": "Stream<A> intersperse(A a){\r\n    return isEmpty() ? this : cons(head(), new P1<Stream<A>>() {\r\n        public Stream<A> _1() {\r\n            return prefix(a, tail()._1());\r\n        }\r\n        public Stream<A> prefix(final A x, final Stream<A> xs) {\r\n            return xs.isEmpty() ? xs : cons(x, p(cons(xs.head(), () -> prefix(a, xs.tail()._1()))));\r\n        }\r\n    });\r\n}"
}, {
	"Path": "fj.data.Stream.intersperse",
	"Comment": "intersperses the given value between each two elements of the stream.",
	"Method": "Stream<A> intersperse(A a){\r\n    return prefix(a, tail()._1());\r\n}"
}, {
	"Path": "fj.data.Stream.intersperse",
	"Comment": "intersperses the given value between each two elements of the stream.",
	"Method": "Stream<A> intersperse(A a){\r\n    return xs.isEmpty() ? xs : cons(x, p(cons(xs.head(), () -> prefix(a, xs.tail()._1()))));\r\n}"
}, {
	"Path": "fj.data.TreeZipper.isChild",
	"Comment": "indicates whether the current node is a child node of another node.",
	"Method": "boolean isChild(){\r\n    return !isRoot();\r\n}"
}, {
	"Path": "fj.data.IterableW.foldRight",
	"Comment": "the catamorphism for iterables, implemented as a right fold.",
	"Method": "B foldRight(F2<A, B, B> f,B z){\r\n    final F<B, B> id = identity();\r\n    return foldLeft(curry((k, a, b) -> k.f(f.f(a, b))), id).f(z);\r\n}"
}, {
	"Path": "fj.F1W.contramapEqual",
	"Comment": "promotes this function to map over an equal as a contravariant functor.",
	"Method": "F1W<Equal<B>, Equal<A>> contramapEqual(){\r\n    return lift(F1Functions.contramapEqual(this));\r\n}"
}, {
	"Path": "fj.test.Arbitrary.arbTreeMap",
	"Comment": "returns an arbitrary implementation for tree maps where the size is less than or equal to the max size.",
	"Method": "Gen<fj.data.TreeMap<K, V>> arbTreeMap(Ord<K> ord,Gen<List<P2<K, V>>> al,Gen<fj.data.TreeMap<K, V>> arbTreeMap,Ord<K> ord,Gen<K> ak,Gen<V> av,Gen<fj.data.TreeMap<K, V>> arbTreeMap,Ord<K> ord,Gen<K> ak,Gen<V> av,Gen<Integer> ai,Gen<fj.data.TreeMap<K, V>> arbTreeMap,Ord<K> ord,Gen<K> ak,Gen<V> av,int maxSize){\r\n    if (maxSize < 0) {\r\n        throw Bottom.error(\"Undefined: arbitrary natural is negative (\" + maxSize + \")\");\r\n    }\r\n    return arbTreeMap(ord, ak, av, choose(0, maxSize));\r\n}"
}, {
	"Path": "fj.data.IterableW.iterable",
	"Comment": "returns an iterable that completely preserves the argument. the unit function for iterables.",
	"Method": "IterableW<A> iterable(A a,F<A, IterableW<B>> iterable,F<A, B> f){\r\n    return a -> iterable(f.f(a));\r\n}"
}, {
	"Path": "fj.data.fingertrees.FingerTree.empty",
	"Comment": "creates an empty finger tree with elements of type a and node annotationsof type v.",
	"Method": "FingerTree<V, A> empty(Monoid<V> m,F<A, V> f){\r\n    return FingerTree.mkTree(measured(m, f)).empty();\r\n}"
}, {
	"Path": "fj.data.Zipper.deleteRightCycle",
	"Comment": "possibly deletes the element at the focus, then move the element on the right into focus. if no element is on theright, focus on the first element. if the deletion will cause the list to be empty, return none.",
	"Method": "Option<Zipper<A>> deleteRightCycle(){\r\n    if (left.isEmpty() && right.isEmpty())\r\n        return none();\r\n    else if (right.isNotEmpty())\r\n        return some(zipper(left, right.head(), right.tail()._1()));\r\n    else {\r\n        final Stream<A> xs = left.reverse();\r\n        return some(zipper(Stream.nil(), xs.head(), xs.tail()._1()));\r\n    }\r\n}"
}, {
	"Path": "fj.test.Arbitrary.arbJavaTreeMap",
	"Comment": "returns an arbitrary implementation for java.util tree maps.",
	"Method": "Gen<java.util.TreeMap<K, V>> arbJavaTreeMap(Gen<K> ak,Gen<V> av){\r\n    return arbHashtable(ak, av).map(java.util.TreeMap::new);\r\n}"
}, {
	"Path": "org.geoserver.security.AbstractAuthenticationKeyMapper.getDefaultParamValue",
	"Comment": "gets the default value for the given parameter. default implementation always returns anempty string.",
	"Method": "String getDefaultParamValue(String paramName){\r\n    return \"\";\r\n}"
}, {
	"Path": "fj.data.Java.List_ConcurrentLinkedQueue",
	"Comment": "a function that converts lists to concurrent linked queues.",
	"Method": "F<List<A>, ConcurrentLinkedQueue<A>> List_ConcurrentLinkedQueue(){\r\n    return as -> new ConcurrentLinkedQueue(as.toCollection());\r\n}"
}, {
	"Path": "fj.F1Functions.nelK",
	"Comment": "promotes this function to return its value in a nonemptylist.",
	"Method": "F<A, NonEmptyList<B>> nelK(F<A, B> f){\r\n    return o(NonEmptyList.nel(), f);\r\n}"
}, {
	"Path": "fj.function.Booleans.and",
	"Comment": "returns true if all the elements of the given stream are true.",
	"Method": "boolean and(List<Boolean> l,F<A, Boolean> and,F<A, Boolean> p1,F<A, Boolean> p2,boolean and,Stream<Boolean> l){\r\n    return Monoid.conjunctionMonoid.sumLeft(l);\r\n}"
}, {
	"Path": "fj.control.parallel.ParModule.parZipWith",
	"Comment": "zips two iterables together with a given function, in parallel.",
	"Method": "Promise<List<C>> parZipWith(List<A> as,List<B> bs,F<A, F<B, C>> f,Promise<Stream<C>> parZipWith,Stream<A> as,Stream<B> bs,F<A, F<B, C>> f,Promise<Array<C>> parZipWith,Array<A> as,Array<B> bs,F<A, F<B, C>> f,Promise<Iterable<C>> parZipWith,Iterable<A> as,Iterable<B> bs,F<A, F<B, C>> f){\r\n    return parZipWith(iterableStream(as), iterableStream(bs), f).fmap(Function.vary(Function.<Iterable<C>>identity()));\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.CatalogDiffVisitor.listDiffOther",
	"Comment": "register has differences the elements from the other collection that are not present incollection.",
	"Method": "void listDiffOther(Collection<T> collection,Collection<T> otherCollection){\r\n    differences.addAll(otherCollection.stream().filter(info -> !containsElementWithId(info.getId(), collection)).map(info -> new InfoDiff(null, info)).collect(Collectors.toList()));\r\n}"
}, {
	"Path": "com.vaadin.tests.elements.notification.NotificationGetTypeAndDescriptionTest.testNotificationByIndex",
	"Comment": "this method tests caption, description and type of the notification",
	"Method": "void testNotificationByIndex(int index){\r\n    openTestURL();\r\n    String id = \"button\" + index;\r\n    ButtonElement btn = $(ButtonElement.class).id(id);\r\n    btn.click();\r\n    NotificationElement notification = $(NotificationElement.class).get(0);\r\n    String eCaption = NotificationGetTypeAndDescription.captions[index];\r\n    String aCaption = notification.getCaption();\r\n    assertEquals(\"Test captions fail\", eCaption, aCaption);\r\n    String eDescription = NotificationGetTypeAndDescription.descriptions[index];\r\n    String aDescription = notification.getDescription();\r\n    assertEquals(\"Test descriptions fail\", eDescription, aDescription);\r\n    String eType = NotificationGetTypeAndDescription.type_names[index];\r\n    String aType = notification.getType();\r\n    assertEquals(\"Test types fail\", eType, aType);\r\n}"
}, {
	"Path": "fj.data.List.find",
	"Comment": "finds the first occurrence of an element that matches the given predicate or no value if noelements match.",
	"Method": "Option<A> find(F<A, Boolean> f){\r\n    for (List<A> as = this; as.isNotEmpty(); as = as.tail()) {\r\n        if (f.f(as.head()))\r\n            return some(as.head());\r\n    }\r\n    return none();\r\n}"
}, {
	"Path": "com.vaadin.tests.TreeFilesystemContainer.componentEvent",
	"Comment": "listener for any component events. this class has been registered as anlistener for component fstree.",
	"Method": "void componentEvent(Event event){\r\n    if (event.getSource() == filesystem) {\r\n        if (event.getClass() == Field.ValueChangeEvent.class) {\r\n            final FileItem fileItem = (FileItem) filesystem.getItem(filesystem.getValue());\r\n            fileProperties.setIcon(fileItem.getIcon());\r\n            fileProperties.setCaption(fileItem.getName() + \", size \" + fileItem.getSize() + \" bytes.\");\r\n            propertyPanel.setEnabled(true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.tests.tb3.ScreenshotTB3Test.checkCompareFailures",
	"Comment": "checks if any screenshot comparisons failures occurred during the testand combines all comparison errors into one exception",
	"Method": "void checkCompareFailures(){\r\n    if (screenshotFailures != null && !screenshotFailures.isEmpty()) {\r\n        throw new IOException(\"The following screenshots did not match the reference: \" + screenshotFailures.toString());\r\n    }\r\n}"
}, {
	"Path": "fj.test.Property.property",
	"Comment": "returns a property where its result is derived from universal quantification across theapplication of its arguments. no shrinking occurs upon falsification.",
	"Method": "Property property(Gen<A> aa,Shrink<A> sa,F<A, Property> f,Property property,Gen<A> aa,F<A, Property> f,Property property,Gen<A> aa,Gen<B> ab,Shrink<A> sa,Shrink<B> sb,F<A, F<B, Property>> f,Property property,Gen<A> aa,Gen<B> ab,F<A, F<B, Property>> f,Property property,Gen<A> aa,Gen<B> ab,Shrink<A> sa,Shrink<B> sb,F2<A, B, Property> f,Property property,Gen<A> aa,Gen<B> ab,F2<A, B, Property> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Shrink<A> sa,Shrink<B> sb,Shrink<C> sc,F<A, F<B, F<C, Property>>> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,F<A, F<B, F<C, Property>>> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Shrink<A> sa,Shrink<B> sb,Shrink<C> sc,F3<A, B, C, Property> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,F3<A, B, C, Property> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Shrink<A> sa,Shrink<B> sb,Shrink<C> sc,Shrink<D> sd,F<A, F<B, F<C, F<D, Property>>>> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,F<A, F<B, F<C, F<D, Property>>>> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Shrink<A> sa,Shrink<B> sb,Shrink<C> sc,Shrink<D> sd,F4<A, B, C, D, Property> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,F4<A, B, C, D, Property> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,Shrink<A> sa,Shrink<B> sb,Shrink<C> sc,Shrink<D> sd,Shrink<E> se,F<A, F<B, F<C, F<D, F<E, Property>>>>> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,F<A, F<B, F<C, F<D, F<E, Property>>>>> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,Shrink<A> sa,Shrink<B> sb,Shrink<C> sc,Shrink<D> sd,Shrink<E> se,F5<A, B, C, D, E, Property> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,F5<A, B, C, D, E, Property> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,Gen<F$> af,Shrink<A> sa,Shrink<B> sb,Shrink<C> sc,Shrink<D> sd,Shrink<E> se,Shrink<F$> sf,F<A, F<B, F<C, F<D, F<E, F<F$, Property>>>>>> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,Gen<F$> af,F<A, F<B, F<C, F<D, F<E, F<F$, Property>>>>>> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,Gen<F$> af,Shrink<A> sa,Shrink<B> sb,Shrink<C> sc,Shrink<D> sd,Shrink<E> se,Shrink<F$> sf,F6<A, B, C, D, E, F$, Property> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,Gen<F$> af,F6<A, B, C, D, E, F$, Property> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,Gen<F$> af,Gen<G> ag,Shrink<A> sa,Shrink<B> sb,Shrink<C> sc,Shrink<D> sd,Shrink<E> se,Shrink<F$> sf,Shrink<G> sg,F<A, F<B, F<C, F<D, F<E, F<F$, F<G, Property>>>>>>> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,Gen<F$> af,Gen<G> ag,F<A, F<B, F<C, F<D, F<E, F<F$, F<G, Property>>>>>>> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,Gen<F$> af,Gen<G> ag,Shrink<A> sa,Shrink<B> sb,Shrink<C> sc,Shrink<D> sd,Shrink<E> se,Shrink<F$> sf,Shrink<G> sg,F7<A, B, C, D, E, F$, G, Property> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,Gen<F$> af,Gen<G> ag,F7<A, B, C, D, E, F$, G, Property> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,Gen<F$> af,Gen<G> ag,Gen<H> ah,Shrink<A> sa,Shrink<B> sb,Shrink<C> sc,Shrink<D> sd,Shrink<E> se,Shrink<F$> sf,Shrink<G> sg,Shrink<H> sh,F<A, F<B, F<C, F<D, F<E, F<F$, F<G, F<H, Property>>>>>>>> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,Gen<F$> af,Gen<G> ag,Gen<H> ah,F<A, F<B, F<C, F<D, F<E, F<F$, F<G, F<H, Property>>>>>>>> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,Gen<F$> af,Gen<G> ag,Gen<H> ah,Shrink<A> sa,Shrink<B> sb,Shrink<C> sc,Shrink<D> sd,Shrink<E> se,Shrink<F$> sf,Shrink<G> sg,Shrink<H> sh,F8<A, B, C, D, E, F$, G, H, Property> f,Property property,Gen<A> aa,Gen<B> ab,Gen<C> ac,Gen<D> ad,Gen<E> ae,Gen<F$> af,Gen<G> ag,Gen<H> ah,F8<A, B, C, D, E, F$, G, H, Property> f){\r\n    return property(aa, ab, ac, ad, ae, af, ag, ah, curry(f));\r\n}"
}, {
	"Path": "fj.data.Stream.cobind",
	"Comment": "binds the given function across the stream of substreams of this stream.",
	"Method": "Stream<B> cobind(F<Stream<A>, B> k){\r\n    return substreams().map(k);\r\n}"
}, {
	"Path": "com.galenframework.specs.page.PageSpec.setObjectGroups",
	"Comment": "clears the current object groups list and sets new group list",
	"Method": "void setObjectGroups(Map<String, List<String>> objectGroups){\r\n    this.objectGroups.clear();\r\n    if (objectGroups != null) {\r\n        this.objectGroups.putAll(objectGroups);\r\n    }\r\n}"
}, {
	"Path": "fj.data.Stream.takeWhile",
	"Comment": "returns the first elements of the head of this stream that match the given predicate function.",
	"Method": "Stream<A> takeWhile(F<A, Boolean> f){\r\n    return isEmpty() ? this : f.f(head()) ? cons(head(), () -> tail()._1().takeWhile(f)) : Stream.nil();\r\n}"
}, {
	"Path": "fj.test.Gen.combinationOf",
	"Comment": "returns a generator of lists that picks the given number of elements from the given list. the selection isa combination without replacement of elements from the given list, i.e.for any given selection, a generated list will always contain its elements in the same orderan element will never be picked more than onceif the given number is less than zero or greater than the length of the given list, then thereturned generator will never produce a value.",
	"Method": "Gen<List<A>> combinationOf(int n,List<A> as){\r\n    int aLength = as.length();\r\n    return ((n >= 0) && (n <= aLength)) ? parameterised(s -> r -> {\r\n        final class Tramp {\r\n            private Trampoline<List<A>> tramp(List<A> remainAs, int remainN, int remainALength) {\r\n                return suspend(() -> (remainN == 0) ? pure(nil()) : (r.choose(0, remainALength - 1) < remainN) ? tramp(remainAs.tail(), remainN - 1, remainALength - 1).map(pickedTail -> cons(remainAs.head(), pickedTail)) : tramp(remainAs.tail(), remainN, remainALength - 1));\r\n            }\r\n        }\r\n        return value(new Tramp().tramp(as, n, aLength).run());\r\n    }) : fail();\r\n}"
}, {
	"Path": "fj.test.Gen.combinationOf",
	"Comment": "returns a generator of lists that picks the given number of elements from the given list. the selection isa combination without replacement of elements from the given list, i.e.for any given selection, a generated list will always contain its elements in the same orderan element will never be picked more than onceif the given number is less than zero or greater than the length of the given list, then thereturned generator will never produce a value.",
	"Method": "Gen<List<A>> combinationOf(int n,List<A> as){\r\n    return suspend(() -> (remainN == 0) ? pure(nil()) : (r.choose(0, remainALength - 1) < remainN) ? tramp(remainAs.tail(), remainN - 1, remainALength - 1).map(pickedTail -> cons(remainAs.head(), pickedTail)) : tramp(remainAs.tail(), remainN, remainALength - 1));\r\n}"
}, {
	"Path": "fj.P1.__1",
	"Comment": "returns a function that returns the first element of a product.",
	"Method": "F<P1<A>, A> __1(){\r\n    return P1::_1;\r\n}"
}, {
	"Path": "com.galenframework.specs.page.PageSpec.getSortedObjectNames",
	"Comment": "returns an alphanumericly sorted list of names of all declared objects",
	"Method": "List<String> getSortedObjectNames(){\r\n    List<String> list = new ArrayList(getObjects().keySet());\r\n    Collections.sort(list, new AlphanumericComparator());\r\n    return list;\r\n}"
}, {
	"Path": "com.vaadin.tests.tb3.AbstractTB3Test.vaadinElementById",
	"Comment": "find a vaadin element based on its id given using component.setid",
	"Method": "WebElement vaadinElementById(String id){\r\n    return driver.findElement(By.id(id));\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.tasklet.GenericTasklet.getHandlers",
	"Comment": "helper method that return the handlers that should be executed. if there is any pendingcontinuable handler we only run the pending continuable handlers otherwise we run all theavailable handlers.",
	"Method": "List<GenericTaskletHandler> getHandlers(JobExecution jobExecution){\r\n    Object value = jobExecution.getExecutionContext().get(GENERIC_CONTINUABLE_HANDLERS_KEY);\r\n    if (value == null || !List.class.isAssignableFrom(value.getClass())) {\r\n        return getAllHandlers();\r\n    }\r\n    List values = (List) value;\r\n    if (values.isEmpty() || !GenericTaskletHandler.class.isAssignableFrom(values.get(0).getClass())) {\r\n        return getAllHandlers();\r\n    }\r\n    return (List<GenericTaskletHandler>) values;\r\n}"
}, {
	"Path": "fj.control.parallel.Callables.bind",
	"Comment": "binds the given function to the values in the given callables with a final join.",
	"Method": "Callable<B> bind(Callable<A> a,F<A, Callable<B>> f,Callable<C> bind,Callable<A> ca,Callable<B> cb,F<A, F<B, C>> f){\r\n    return apply(cb, fmap(f).f(ca));\r\n}"
}, {
	"Path": "fj.data.HashMap.set",
	"Comment": "inserts the given key and value association into the hash map.",
	"Method": "void set(K k,V v){\r\n    if (v != null) {\r\n        m.put(new Key(k), v);\r\n    }\r\n}"
}, {
	"Path": "fj.data.IterableW.foldLeft",
	"Comment": "the catamorphism for iterables, implemented as a left fold.",
	"Method": "B foldLeft(F<B, F<A, B>> f,B z){\r\n    B p = z;\r\n    for (final A x : this) {\r\n        p = f.f(p).f(x);\r\n    }\r\n    return p;\r\n}"
}, {
	"Path": "org.geogig.geoserver.spring.controller.UnsupportedCommandController.rename",
	"Comment": "list any unsupported commands in this requestmapping annotation.",
	"Method": "void rename(){\r\n    throw new CommandSpecException(\"This command is unsupported by the GeoGig plugin.\", HttpStatus.BAD_REQUEST);\r\n}"
}, {
	"Path": "fj.data.NonEmptyList.unzip",
	"Comment": "transforms a non empty list of pairs into a non empty list of first components anda non empty list of second components.",
	"Method": "P2<NonEmptyList<A>, NonEmptyList<B>> unzip(NonEmptyList<P2<A, B>> xs){\r\n    final P2<List<A>, List<B>> p = List.unzip(xs.toList());\r\n    return P.p(nel(p._1().head(), p._1().tail()), nel(p._2().head(), p._2().tail()));\r\n}"
}, {
	"Path": "org.geoserver.jdbcstore.internal.JDBCQueryHelper.anyBlobQuery",
	"Comment": "blobs should always be queried with this method, not with the regular selects!",
	"Method": "InputStream anyBlobQuery(QueryBuilder query,Field<InputStream> field){\r\n    LOGGER.log(Level.FINEST, query.toString());\r\n    Connection c;\r\n    boolean closeConnection = false;\r\n    try {\r\n        c = ds.getConnection();\r\n    } catch (SQLException ex) {\r\n        throw new IllegalStateException(\"Could not connect to DataSource.\", ex);\r\n    }\r\n    try {\r\n        try (PreparedStatement stmt = query.toStatement(c)) {\r\n            try (ResultSet rs = stmt.executeQuery()) {\r\n                if (rs.next()) {\r\n                    assert (rs.isLast());\r\n                    InputStream is = field.getValue(rs);\r\n                    return is == null ? null : new ClosingInputStreamWrapper(is, c);\r\n                } else {\r\n                    closeConnection = true;\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n    } catch (SQLException ex) {\r\n        throw new IllegalStateException(\"BlobQuery Failed\", ex);\r\n    } finally {\r\n        if (closeConnection) {\r\n            try {\r\n                c.close();\r\n            } catch (SQLException ex) {\r\n                throw new IllegalArgumentException(\"Error while closing connection.\", ex);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "fj.data.Java.Stream_PriorityBlockingQueue",
	"Comment": "a function that converts streams to priority blocking queues.",
	"Method": "F<Stream<A>, PriorityBlockingQueue<A>> Stream_PriorityBlockingQueue(){\r\n    return as -> new PriorityBlockingQueue(as.toCollection());\r\n}"
}, {
	"Path": "fj.control.parallel.Strategy.executorStrategy",
	"Comment": "provides a parallelization strategy that uses an executorservice to control the method anddegree of parallelism.",
	"Method": "Strategy<A> executorStrategy(ExecutorService s){\r\n    return strategy(p -> obtain(s.submit(Java.<A>P1_Callable().f(p))));\r\n}"
}, {
	"Path": "fj.data.List.takeWhile",
	"Comment": "returns the first elements of the head of this list that match the given predicate function.",
	"Method": "List<A> takeWhile(F<A, Boolean> f){\r\n    final Buffer<A> b = empty();\r\n    boolean taking = true;\r\n    for (List<A> xs = this; xs.isNotEmpty() && taking; xs = xs.tail()) {\r\n        final A h = xs.head();\r\n        if (f.f(h)) {\r\n            b.snoc(h);\r\n        } else {\r\n            taking = false;\r\n        }\r\n    }\r\n    return b.toList();\r\n}"
}, {
	"Path": "fj.demo.concurrent.Fibs.seqFib",
	"Comment": "the sequential version of the recursive fibonacci function",
	"Method": "int seqFib(int n){\r\n    return n < 2 ? n : seqFib(n - 1) + seqFib(n - 2);\r\n}"
}, {
	"Path": "fj.control.db.DB.unit",
	"Comment": "constructs a database action that returns the given value completely intact.",
	"Method": "DB<A> unit(A a){\r\n    return new DB<A>() {\r\n        public A run(final Connection c) {\r\n            return a;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "fj.control.db.DB.unit",
	"Comment": "constructs a database action that returns the given value completely intact.",
	"Method": "DB<A> unit(A a){\r\n    return a;\r\n}"
}, {
	"Path": "fj.F1Functions.contramapEqual",
	"Comment": "promotes this function to map over an equal as a contravariant functor.",
	"Method": "F<Equal<B>, Equal<A>> contramapEqual(F<A, B> f){\r\n    return e -> e.contramap(f);\r\n}"
}, {
	"Path": "org.geoserver.cluster.impl.handlers.catalog.JMSCatalogEventHandler.removeCatalogProperties",
	"Comment": "make sure that properties of type catalog are not serialized for catalog modified events.",
	"Method": "CatalogEvent removeCatalogProperties(CatalogEvent event){\r\n    if (!(event instanceof CatalogModifyEvent)) {\r\n        return event;\r\n    }\r\n    CatalogModifyEvent modifyEvent = (CatalogModifyEvent) event;\r\n    List<Integer> indexes = new ArrayList();\r\n    int totalProperties = modifyEvent.getPropertyNames().size();\r\n    for (int i = 0; i < totalProperties; i++) {\r\n        Object value = modifyEvent.getNewValues().get(i);\r\n        if (!(value instanceof Catalog)) {\r\n            indexes.add(i);\r\n        }\r\n    }\r\n    if (indexes.size() == totalProperties) {\r\n        return event;\r\n    }\r\n    List<String> properties = new ArrayList();\r\n    List<Object> oldValues = new ArrayList();\r\n    List<Object> newValues = new ArrayList();\r\n    for (int index : indexes) {\r\n        properties.add(modifyEvent.getPropertyNames().get(index));\r\n        oldValues.add(modifyEvent.getOldValues().get(index));\r\n        newValues.add(modifyEvent.getNewValues().get(index));\r\n    }\r\n    CatalogModifyEventImpl newEvent = new CatalogModifyEventImpl();\r\n    newEvent.setPropertyNames(properties);\r\n    newEvent.setOldValues(oldValues);\r\n    newEvent.setNewValues(newValues);\r\n    newEvent.setSource(modifyEvent.getSource());\r\n    return newEvent;\r\n}"
}, {
	"Path": "com.galenframework.utils.GalenUtils.resizeScreenshotIfNeeded",
	"Comment": "check the devicepixelratio and adapts the size of the screenshot as if the ratio was 1.0",
	"Method": "BufferedImage resizeScreenshotIfNeeded(WebDriver driver,BufferedImage screenshotImage){\r\n    Double devicePixelRatio = 1.0;\r\n    try {\r\n        devicePixelRatio = ((Number) ((JavascriptExecutor) driver).executeScript(JS_RETRIEVE_DEVICE_PIXEL_RATIO)).doubleValue();\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n    }\r\n    if (devicePixelRatio > 1.0 && screenshotImage.getWidth() > 0) {\r\n        Long screenSize = ((Number) ((JavascriptExecutor) driver).executeScript(\"return Math.max(\" + \"document.body.scrollWidth, document.documentElement.scrollWidth,\" + \"document.body.offsetWidth, document.documentElement.offsetWidth,\" + \"document.body.clientWidth, document.documentElement.clientWidth);\")).longValue();\r\n        Double estimatedPixelRatio = ((double) screenshotImage.getWidth()) / ((double) screenSize);\r\n        if (estimatedPixelRatio > 1.0) {\r\n            int newWidth = (int) (screenshotImage.getWidth() / estimatedPixelRatio);\r\n            int newHeight = (int) (screenshotImage.getHeight() / estimatedPixelRatio);\r\n            Image tmp = screenshotImage.getScaledInstance(newWidth, newHeight, Image.SCALE_SMOOTH);\r\n            BufferedImage scaledImage = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_INT_RGB);\r\n            Graphics2D g2d = scaledImage.createGraphics();\r\n            g2d.drawImage(tmp, 0, 0, null);\r\n            g2d.dispose();\r\n            return scaledImage;\r\n        } else\r\n            return screenshotImage;\r\n    } else\r\n        return screenshotImage;\r\n}"
}, {
	"Path": "fj.data.LazyString.startsWith",
	"Comment": "returns true if the given lazy string is a prefix of this lazy string.",
	"Method": "boolean startsWith(LazyString cs,F<LazyString, F<LazyString, Boolean>> startsWith){\r\n    return curry((needle, haystack) -> haystack.startsWith(needle));\r\n}"
}, {
	"Path": "fj.control.parallel.Strategy.parMapList",
	"Comment": "promotes a function to a parallel function on lists using this strategy.",
	"Method": "F<List<B>, P1<List<A>>> parMapList(F<B, A> f,F<F<B, A>, F<List<B>, P1<List<A>>>> parMapList){\r\n    return this::parMapList;\r\n}"
}, {
	"Path": "fj.data.Java.Option_CopyOnWriteArraySet",
	"Comment": "a function that converts options to copy on write array sets.",
	"Method": "F<Option<A>, CopyOnWriteArraySet<A>> Option_CopyOnWriteArraySet(){\r\n    return as -> new CopyOnWriteArraySet(as.toCollection());\r\n}"
}, {
	"Path": "fj.data.List.index",
	"Comment": "returns the element at the given index if it exists, fails otherwise.",
	"Method": "A index(int i){\r\n    if (i < 0 || i > length() - 1)\r\n        throw error(\"index \" + i + \" out of range on list with length \" + length());\r\n    else {\r\n        List<A> xs = this;\r\n        for (int c = 0; c < i; c++) {\r\n            xs = xs.tail();\r\n        }\r\n        return xs.head();\r\n    }\r\n}"
}, {
	"Path": "fj.data.Enumerator.max",
	"Comment": "returns the maximum value for this enumerator if there is one.",
	"Method": "Option<A> max(){\r\n    return max;\r\n}"
}, {
	"Path": "fj.control.parallel.ParModule.promisePure",
	"Comment": "returns a function that promotes a given function to a concurrent function that returns a promise.the pure kleisli arrow of promise.",
	"Method": "F<F<A, B>, F<A, Promise<B>>> promisePure(){\r\n    return this::promise;\r\n}"
}, {
	"Path": "fj.F1W.on",
	"Comment": "applies this function over the arguments of another function.",
	"Method": "F1W<A, F<A, C>> on(F<B, F<B, C>> g,F1W<F<B, F<B, C>>, F<A, F<A, C>>> on){\r\n    return lift(F1Functions.on(this));\r\n}"
}, {
	"Path": "fj.data.vector.V8.vzip",
	"Comment": "zips this vector with the given vector to produce a vector of vectors.",
	"Method": "V8<V2<A>> vzip(V8<A> bs){\r\n    final F2<A, A, V2<A>> __2 = V.v2();\r\n    return zipWith(curry(__2), bs);\r\n}"
}, {
	"Path": "com.vaadin.tests.components.absolutelayout.AbsoluteLayoutResizeComponentsTest.getComponentWrapper",
	"Comment": "search for the absolutelayout wrapper element that contains component forcomponentid",
	"Method": "Optional<WebElement> getComponentWrapper(String componentId){\r\n    WebElement panelWrapper = null;\r\n    for (WebElement wrapper : findElements(By.className(\"v-absolutelayout-wrapper\"))) {\r\n        if (!wrapper.findElements(By.id(componentId)).isEmpty()) {\r\n            panelWrapper = wrapper;\r\n            break;\r\n        }\r\n    }\r\n    return Optional.ofNullable(panelWrapper);\r\n}"
}, {
	"Path": "fj.P1.curry",
	"Comment": "promotes the given function so that it returns its value in a p1.",
	"Method": "F<A, P1<B>> curry(F<A, B> f){\r\n    return a -> P.lazy(() -> f.f(a));\r\n}"
}, {
	"Path": "fj.test.Bool.implies",
	"Comment": "returns a property that produces a result only if this value is true.",
	"Method": "Property implies(F0<Property> p,Property implies,Property p,Property implies,Bool c,Property implies,boolean c){\r\n    return Property.implies(b, () -> prop(c));\r\n}"
}, {
	"Path": "fj.control.parallel.Strategy.discard",
	"Comment": "returns an effect that waits for a given future to obtain a value, discarding the value.",
	"Method": "Effect1<Future<A>> discard(){\r\n    return a -> Strategy.<A>obtain().f(a)._1();\r\n}"
}, {
	"Path": "fj.control.parallel.Promise.bind",
	"Comment": "binds the given function to this promise and the given promise, with a final join.",
	"Method": "Promise<B> bind(F<A, Promise<B>> f,Promise<C> bind,Promise<B> pb,F<A, F<B, C>> f,Promise<C> bind,P1<Promise<B>> p,F<A, F<B, C>> f){\r\n    return join(s, p).apply(fmap(f));\r\n}"
}, {
	"Path": "org.geoserver.jdbcloader.DataSourceFactoryBean.createDataSource",
	"Comment": "create and configure a datasource based on the jdbcloaderproperties",
	"Method": "DataSource createDataSource(){\r\n    BasicDataSource dataSource = createBasicDataSource();\r\n    dataSource.setUrl(config.getJdbcUrl().get());\r\n    Optional<String> driverClassName = get(config, \"driverClassName\", String.class, true);\r\n    try {\r\n        Class.forName(driverClassName.get());\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(\"Error loading jdbc driver class: \" + driverClassName, e);\r\n    }\r\n    dataSource.setDriverClassName(driverClassName.get());\r\n    dataSource.setUsername(get(config, \"username\", String.class, false).orNull());\r\n    dataSource.setPassword(get(config, \"password\", String.class, false).orNull());\r\n    dataSource.setMinIdle(get(config, \"pool.minIdle\", Integer.class, false).or(1));\r\n    dataSource.setMaxActive(get(config, \"pool.maxActive\", Integer.class, false).or(10));\r\n    dataSource.setPoolPreparedStatements(get(config, \"pool.poolPreparedStatements\", Boolean.class, false).or(true));\r\n    dataSource.setMaxOpenPreparedStatements(get(config, \"pool.maxOpenPreparedStatements\", Integer.class, false).or(50));\r\n    boolean testOnBorrow = get(config, \"pool.testOnBorrow\", Boolean.class, false).or(false);\r\n    if (testOnBorrow) {\r\n        String validateQuery = get(config, \"pool.validationQuery\", String.class, true).get();\r\n        dataSource.setTestOnBorrow(true);\r\n        dataSource.setValidationQuery(validateQuery);\r\n    }\r\n    if (LOGGER.isLoggable(Level.INFO)) {\r\n        LOGGER.log(Level.INFO, \"JDBCConfig using JDBC DataSource {0}\", config.getJdbcUrl());\r\n    }\r\n    config.setDatasourceId(config.getJdbcUrl().get());\r\n    return dataSource;\r\n}"
}, {
	"Path": "fj.data.Tree.bottomUp",
	"Comment": "folds a tree into a tree by applying the function f from the bottom of the tree to the top",
	"Method": "Tree<B> bottomUp(Tree<A> t,F<P2<A, Stream<B>>, B> f){\r\n    final F<Tree<A>, Tree<B>> recursiveCall = a -> bottomUp(a, f);\r\n    final Stream<Tree<B>> tbs = t.subForest()._1().map(recursiveCall);\r\n    return node(f.f(P.p(t.root(), tbs.map(Tree.getRoot()))), tbs);\r\n}"
}, {
	"Path": "fj.test.Shrink.shrink",
	"Comment": "constructs a shrink strategy from the given function that produces a tree of values given avalue.",
	"Method": "Stream<A> shrink(A a,Shrink<A> shrink,F<A, Stream<A>> f){\r\n    return new Shrink(f);\r\n}"
}, {
	"Path": "fj.data.Validation.partition",
	"Comment": "partitions the list into the list of fails and the list of successes",
	"Method": "P2<List<A>, List<B>> partition(List<Validation<A, B>> list){\r\n    return p(list.filter(Validation::isFail).map(v -> v.fail()), list.filter(Validation::isSuccess).map(v -> v.success()));\r\n}"
}, {
	"Path": "fj.data.Validation.exists",
	"Comment": "returns false if this is a failure or returns the result of the application of the givenfunction to the success value.",
	"Method": "boolean exists(F<T, Boolean> f,boolean exists,F<E, Boolean> f){\r\n    return e.right().exists(f);\r\n}"
}, {
	"Path": "fj.data.TreeZipper.fromTree",
	"Comment": "creates a new tree zipper focused on the root of the given tree.",
	"Method": "TreeZipper<A> fromTree(Tree<A> t,F<Tree<A>, TreeZipper<A>> fromTree){\r\n    return TreeZipper::fromTree;\r\n}"
}, {
	"Path": "fj.data.List.mapMTrampoline",
	"Comment": "maps the given function across this list by binding through the trampoline monad.",
	"Method": "Trampoline<List<B>> mapMTrampoline(F<A, Trampoline<B>> f){\r\n    return foldRight((a, bs) -> f.f(a).bind(b -> bs.map(bbs -> bbs.cons(b))), Trampoline.pure(List.nil()));\r\n}"
}, {
	"Path": "com.vaadin.tests.urifragments.FragmentHandlingAndAsynchUIUpdateTest.testBackwardForwardHistoryWithWaitingForSettingFrag",
	"Comment": "the case when we successively set 10 fragments, go back 9 times and thengo forward 9 times",
	"Method": "void testBackwardForwardHistoryWithWaitingForSettingFrag(){\r\n    openTestURL();\r\n    for (int i = 0; i < 10; i++) {\r\n        getDriver().findElement(By.id(FragmentHandlingAndAsynchUIUpdate.BUTTON_ID)).click();\r\n        assertFragment(String.format(FRAG_NAME_TPL, START_FRAG_ID + i));\r\n    }\r\n    for (int i = 8; i >= 0; i--) {\r\n        ((JavascriptExecutor) driver).executeScript(\"history.back()\");\r\n        assertFragment(String.format(FRAG_NAME_TPL, START_FRAG_ID + i));\r\n    }\r\n    for (int i = 1; i < 10; i++) {\r\n        ((JavascriptExecutor) driver).executeScript(\"history.forward()\");\r\n        assertFragment(String.format(FRAG_NAME_TPL, START_FRAG_ID + i));\r\n    }\r\n}"
}, {
	"Path": "fj.demo.realworld.Chapter7.toUpperInteract",
	"Comment": "read from stdin each line, whilst each line is not empty, printuppercase line to stdout",
	"Method": "void toUpperInteract(){\r\n    runSafe(interactWhile(s -> s.trim().length() > 0, String::toUpperCase));\r\n}"
}, {
	"Path": "fj.parser.Parser.not",
	"Comment": "returns a parser that negates this parser. if this parser succeeds, then the returned parser fails and vice versa.",
	"Method": "Parser<I, Unit, E> not(F0<E> e,Parser<I, Unit, E> not,E e){\r\n    return not(p(e));\r\n}"
}, {
	"Path": "fj.P1.weakMemo",
	"Comment": "like memo, but the memoized value is wrapped into a weakreference",
	"Method": "P1<A> weakMemo(P1<A> weakMemo,P1<A> weakMemo,P1<A> weakMemo){\r\n    return new WeakReferenceMemo(this);\r\n}"
}, {
	"Path": "fj.data.Option.isNone",
	"Comment": "returns false if this optional value has a value, true otherwise.",
	"Method": "boolean isNone(){\r\n    return this instanceof None;\r\n}"
}, {
	"Path": "fj.data.Option.fromSome",
	"Comment": "returns a function that takes an optional value to a value or errors if there is no value.",
	"Method": "F<Option<A>, A> fromSome(){\r\n    return option -> option.some();\r\n}"
}, {
	"Path": "org.geogig.geoserver.model.DropDownTestUtil.setAvailableBackends",
	"Comment": "allows for overriding the list of available backends for testing purposes, as well as thedefault backend.",
	"Method": "void setAvailableBackends(List<String> backends,String defaultBackend){\r\n    DropDownModel.setConfigList(backends, defaultBackend);\r\n}"
}, {
	"Path": "fj.function.Visitor.visitor",
	"Comment": "returns the first value found in the list of visitors after application of the given value, otherwise returns thegiven default.",
	"Method": "B visitor(List<F<A, Option<B>>> visitors,F0<B> def,A value){\r\n    return findFirst(visitors.map(Function.apply(value)), def);\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.GridElement.getRows",
	"Comment": "gets all the data rows in the grid.returns an iterable which will lazily scroll rows into views and lazyload data as needed.",
	"Method": "Iterable<GridRowElement> getRows(){\r\n    return () -> new Iterator<GridElement.GridRowElement>() {\r\n        int nextIndex = 0;\r\n        @Override\r\n        public GridRowElement next() {\r\n            return getRow(nextIndex++);\r\n        }\r\n        @Override\r\n        public boolean hasNext() {\r\n            try {\r\n                getRow(nextIndex);\r\n                return true;\r\n            } catch (Exception e) {\r\n                return false;\r\n            }\r\n        }\r\n        @Override\r\n        public void remove() {\r\n            throw new UnsupportedOperationException(\"remove not supported\");\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.GridElement.getRows",
	"Comment": "gets all the data rows in the grid.returns an iterable which will lazily scroll rows into views and lazyload data as needed.",
	"Method": "Iterable<GridRowElement> getRows(){\r\n    return getRow(nextIndex++);\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.GridElement.getRows",
	"Comment": "gets all the data rows in the grid.returns an iterable which will lazily scroll rows into views and lazyload data as needed.",
	"Method": "Iterable<GridRowElement> getRows(){\r\n    try {\r\n        getRow(nextIndex);\r\n        return true;\r\n    } catch (Exception e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.GridElement.getRows",
	"Comment": "gets all the data rows in the grid.returns an iterable which will lazily scroll rows into views and lazyload data as needed.",
	"Method": "Iterable<GridRowElement> getRows(){\r\n    throw new UnsupportedOperationException(\"remove not supported\");\r\n}"
}, {
	"Path": "fj.data.TreeZipper.findChild",
	"Comment": "navigates to the first child of the current location, that satisfies the given predicate.",
	"Method": "Option<TreeZipper<A>> findChild(F<Tree<A>, Boolean> p,F2<F<Tree<A>, Boolean>, TreeZipper<A>, Option<TreeZipper<A>>> findChild){\r\n    return (f, az) -> az.findChild(f);\r\n}"
}, {
	"Path": "fj.test.Arg.arg",
	"Comment": "construct a property argument with the given value and number of shrinks.",
	"Method": "Arg<T> arg(T value,int shrinks){\r\n    return new Arg(value, shrinks);\r\n}"
}, {
	"Path": "fj.data.Option.orSome",
	"Comment": "returns the value of this optional value or the given argument.",
	"Method": "A orSome(F0<A> a,A orSome,A a){\r\n    return isSome() ? some() : a;\r\n}"
}, {
	"Path": "fj.F1W.contramapShow",
	"Comment": "promotes this function to map over a show as a contravariant functor.",
	"Method": "F1W<Show<B>, Show<A>> contramapShow(){\r\n    return lift(F1Functions.contramapShow(this));\r\n}"
}, {
	"Path": "fj.data.IOFunctions.toSafe",
	"Comment": "convert io to a safeio, throwing any ioexception wrapped inside a runtimeexception",
	"Method": "SafeIO<A> toSafe(IO<A> io){\r\n    return () -> {\r\n        try {\r\n            return io.run();\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "fj.data.Stream.isEmpty_",
	"Comment": "returns a function that determines whether a given stream is empty.",
	"Method": "F<Stream<A>, Boolean> isEmpty_(){\r\n    return Stream::isEmpty;\r\n}"
}, {
	"Path": "fj.data.Validation.accumapply",
	"Comment": "function application on the successful side of this validation, or accumulating the errors on the failing sideusing the given semigroup should one or more be encountered.",
	"Method": "Validation<E, A> accumapply(Semigroup<E> s,Validation<E, F<T, A>> v){\r\n    return isFail() ? Validation.fail(v.isFail() ? s.sum(v.fail(), fail()) : fail()) : v.isFail() ? Validation.fail(v.fail()) : Validation.success(v.success().f(success()));\r\n}"
}, {
	"Path": "fj.data.Java.List_PriorityBlockingQueue",
	"Comment": "a function that converts lists to priority blocking queues.",
	"Method": "F<List<A>, PriorityBlockingQueue<A>> List_PriorityBlockingQueue(){\r\n    return as -> new PriorityBlockingQueue(as.toCollection());\r\n}"
}, {
	"Path": "fj.F1W.onFail",
	"Comment": "returns a function that returns the failure side of a given validation,or this function applied to the success side.",
	"Method": "F1W<Validation<B, A>, B> onFail(){\r\n    return lift(F1Functions.onFail(this));\r\n}"
}, {
	"Path": "fj.F1Functions.contramapHash",
	"Comment": "promotes this function to map over a hash as a contravariant functor.",
	"Method": "F<Hash<B>, Hash<A>> contramapHash(F<A, B> f){\r\n    return h -> h.contramap(f);\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.AbstractSplitPanelElement.getContainedComponent",
	"Comment": "gets a component of a split panel and wraps it in the given class.",
	"Method": "T getContainedComponent(Class<T> clazz,org.openqa.selenium.By byContainer){\r\n    List<AbstractComponentElement> containedComponents = $$(AbstractComponentElement.class).all();\r\n    List<WebElement> componentsInSelectedContainer = findElements(byContainer);\r\n    for (AbstractComponentElement component : containedComponents) {\r\n        WebElement elem = component.getWrappedElement();\r\n        if (componentsInSelectedContainer.contains(elem)) {\r\n            return TestBench.createElement(clazz, elem, getCommandExecutor());\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.vaadin.tests.RandomLayoutStress.init",
	"Comment": "initialize application. demo components are added to main window.",
	"Method": "void init(){\r\n    final LegacyWindow mainWindow = new LegacyWindow(\"Layout demo\");\r\n    setMainWindow(mainWindow);\r\n    VerticalLayout panelALayout = new VerticalLayout();\r\n    panelALayout.setMargin(true);\r\n    final Panel panelA = new Panel(\"Panel containing horizontal ordered layout\", panelALayout);\r\n    HorizontalLayout layoutA = new HorizontalLayout();\r\n    fillLayout(layoutA, componentCountA);\r\n    panelALayout.addComponent(layoutA);\r\n    VerticalLayout panelBLayout = new VerticalLayout();\r\n    panelBLayout.setMargin(true);\r\n    final Panel panelB = new Panel(\"Panel containing vertical ordered layout\", panelBLayout);\r\n    VerticalLayout layoutB = new VerticalLayout();\r\n    fillLayout(layoutB, componentCountB);\r\n    panelBLayout.addComponent(layoutB);\r\n    final int gridSize = (int) Math.sqrt(componentCountC);\r\n    VerticalLayout panelGLayout = new VerticalLayout();\r\n    panelGLayout.setMargin(true);\r\n    final Panel panelG = new Panel(\"Panel containing grid layout (\" + gridSize + \" x \" + gridSize + \")\", panelGLayout);\r\n    GridLayout layoutG = new GridLayout(gridSize, gridSize);\r\n    fillLayout(layoutG, componentCountC);\r\n    panelGLayout.addComponent(layoutG);\r\n    final TabSheet tabsheet = new TabSheet();\r\n    tabsheet.setCaption(\"Tabsheet, above layouts are added to this component\");\r\n    layoutA = new HorizontalLayout();\r\n    fillLayout(layoutA, componentCountA);\r\n    tabsheet.addTab(layoutA, \"Horizontal ordered layout\", null);\r\n    layoutB = new VerticalLayout();\r\n    fillLayout(layoutB, componentCountB);\r\n    tabsheet.addTab(layoutB, \"Vertical ordered layout\", null);\r\n    layoutG = new GridLayout(gridSize, gridSize);\r\n    fillLayout(layoutG, componentCountC);\r\n    tabsheet.addTab(layoutG, \"Grid layout (4 x 2)\", null);\r\n    VerticalLayout panelCLayout = new VerticalLayout();\r\n    panelCLayout.setMargin(true);\r\n    final Panel panelC = new Panel(\"Custom layout with style exampleStyle\", panelCLayout);\r\n    final CustomLayout layoutC = new CustomLayout(\"exampleStyle\");\r\n    fillLayout(layoutC, componentCountD);\r\n    panelCLayout.addComponent(layoutC);\r\n    mainWindow.addComponent(panelA);\r\n    mainWindow.addComponent(panelB);\r\n    mainWindow.addComponent(panelG);\r\n    mainWindow.addComponent(tabsheet);\r\n    mainWindow.addComponent(panelC);\r\n}"
}, {
	"Path": "fj.F1Functions.eitherRightK",
	"Comment": "promotes this function so that it returns its result on the right side of an either.kleisli arrow for the either right projection.",
	"Method": "F<A, Either<C, B>> eitherRightK(F<A, B> f){\r\n    return o(Either.right_(), f);\r\n}"
}, {
	"Path": "com.vaadin.tests.elements.menubar.MenuBarUITest.testMenuBarSelector",
	"Comment": "tests whether the selected menubar and its items are the correct ones.",
	"Method": "void testMenuBarSelector(){\r\n    MenuBarElement menuBar = $(MenuBarElement.class).get(2);\r\n    menuBar.clickItem(\"File\");\r\n    assertTrue(isItemVisible(\"Open2\"));\r\n    menuBar.clickItem(\"File\");\r\n    menuBar = $(MenuBarElement.class).get(1);\r\n    menuBar.clickItem(\"Edit2\");\r\n    assertTrue(isItemVisible(\"Cut\"));\r\n    menuBar.clickItem(\"Edit2\");\r\n    menuBar = $(MenuBarElement.class).first();\r\n    menuBar.clickItem(\"File\");\r\n    assertTrue(isItemVisible(\"Open\"));\r\n}"
}, {
	"Path": "fj.test.Shrink.map",
	"Comment": "creates a shrink from this shrink and the given symmetric transformations.",
	"Method": "Shrink<B> map(F<A, B> f,F<B, A> g){\r\n    return shrink(b -> Shrink.this.f.f(g.f(b)).map(f));\r\n}"
}, {
	"Path": "fj.data.IterableW.zipWith",
	"Comment": "zips this iterable with the given iterable using the given function to produce a new iterable. ifthis iterable and the given iterable have different lengths, then the longer iterable is normalisedso this function never fails.",
	"Method": "Iterable<C> zipWith(Iterable<B> bs,F<A, F<B, C>> f,Iterable<C> zipWith,Iterable<B> bs,F2<A, B, C> f){\r\n    return zipWith(bs, curry(f));\r\n}"
}, {
	"Path": "org.geogig.geoserver.config.ConfigStore.addRepositoryInfoChangedCallback",
	"Comment": "add a callback that will be called whenever a repositoryinfo is changed.",
	"Method": "void addRepositoryInfoChangedCallback(RepositoryInfoChangedCallback callback){\r\n    this.callbacks.add(callback);\r\n}"
}, {
	"Path": "org.geoserver.cluster.impl.handlers.configuration.JMSGeoServerHandler.localizeCoverageAccessInfo",
	"Comment": "return the updated local coverageaccessinfo object replacing all the members with the onescoming from the passed coverageaccessinfo",
	"Method": "CoverageAccessInfo localizeCoverageAccessInfo(GeoServer geoServer,CoverageAccessInfo deserInfo){\r\n    if (geoServer == null || deserInfo == null)\r\n        throw new IllegalArgumentException(\"Wrong passed arguments are null\");\r\n    final CoverageAccessInfo info = geoServer.getGlobal().getCoverageAccess();\r\n    final ThreadPoolExecutor executor = info.getThreadPoolExecutor();\r\n    BeanUtils.copyProperties(info, deserInfo);\r\n    info.setThreadPoolExecutor(executor);\r\n    return info;\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.AbstractExecutionAdapter.getJobId",
	"Comment": "convenience getter for for the id of the enclosing job. useful for dao implementations.",
	"Method": "Long getJobId(){\r\n    return delegate.getJobId();\r\n}"
}, {
	"Path": "fj.control.Trampoline.bind",
	"Comment": "binds the given function across the result of this trampoline and the given trampoline.",
	"Method": "Trampoline<B> bind(F<A, Trampoline<B>> f,Trampoline<B> bind,F<A, Trampoline<B>> f,Trampoline<B> bind,F<A, Trampoline<B>> f,Trampoline<C> bind,Trampoline<B> lb,F<A, F<B, C>> f){\r\n    return lb.apply(map(f));\r\n}"
}, {
	"Path": "fj.function.Visitor.findFirst",
	"Comment": "returns the first value available in the given list of optional values. if none is found return the given default value.",
	"Method": "X findFirst(List<Option<X>> values,F0<X> def){\r\n    return Monoid.<X>firstOptionMonoid().sumLeft(values).orSome(def);\r\n}"
}, {
	"Path": "fj.Ord.isLessThan",
	"Comment": "returns a function that returns true if its argument is less than the argument to this method.",
	"Method": "boolean isLessThan(A a1,A a2,F<A, Boolean> isLessThan,A a){\r\n    return compose(o -> o == Ordering.GT, def.compare(a));\r\n}"
}, {
	"Path": "fj.data.Either.traverseOptionLeft",
	"Comment": "traversable instance of leftprojection of either for option.",
	"Method": "Option<Either<C, B>> traverseOptionLeft(F<A, Option<C>> f){\r\n    return left().traverseOption(f);\r\n}"
}, {
	"Path": "com.vaadin.tests.widgetset.client.v7.grid.GridBasicClientFeaturesWidget.createDataRow",
	"Comment": "convenience method for creating a list of data objects to be used as arow in the data source",
	"Method": "List<Data> createDataRow(int cols){\r\n    List<Data> list = new ArrayList(cols);\r\n    for (int i = 0; i < cols; ++i) {\r\n        list.add(new Data());\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "fj.data.HashMap.delete",
	"Comment": "deletes the entry in the hash map that corresponds to the given key.",
	"Method": "void delete(K k){\r\n    m.remove(new Key(k));\r\n}"
}, {
	"Path": "fj.data.Option.orElse",
	"Comment": "returns this optional value if there is one, otherwise, returns the argument optional value.",
	"Method": "Option<A> orElse(F0<Option<A>> o,Option<A> orElse,Option<A> o){\r\n    return isSome() ? this : o;\r\n}"
}, {
	"Path": "fj.Bottom.errorF",
	"Comment": "provides a function that throws an error using the given message, ignoring its argument.",
	"Method": "F<A, B> errorF(String s){\r\n    return a -> {\r\n        throw new Error(s);\r\n    };\r\n}"
}, {
	"Path": "fj.data.Stream.bind",
	"Comment": "binds the given function across each element of this stream and the given streams with a finaljoin.",
	"Method": "Stream<B> bind(F<A, Stream<B>> f,Stream<C> bind,Stream<B> sb,F<A, F<B, C>> f,Stream<C> bind,Stream<B> sb,F2<A, B, C> f,Stream<D> bind,Stream<B> sb,Stream<C> sc,F<A, F<B, F<C, D>>> f,Stream<E> bind,Stream<B> sb,Stream<C> sc,Stream<D> sd,F<A, F<B, F<C, F<D, E>>>> f,Stream<F$> bind,Stream<B> sb,Stream<C> sc,Stream<D> sd,Stream<E> se,F<A, F<B, F<C, F<D, F<E, F$>>>>> f,Stream<G> bind,Stream<B> sb,Stream<C> sc,Stream<D> sd,Stream<E> se,Stream<F$> sf,F<A, F<B, F<C, F<D, F<E, F<F$, G>>>>>> f,Stream<H> bind,Stream<B> sb,Stream<C> sc,Stream<D> sd,Stream<E> se,Stream<F$> sf,Stream<G> sg,F<A, F<B, F<C, F<D, F<E, F<F$, F<G, H>>>>>>> f,Stream<I> bind,Stream<B> sb,Stream<C> sc,Stream<D> sd,Stream<E> se,Stream<F$> sf,Stream<G> sg,Stream<H> sh,F<A, F<B, F<C, F<D, F<E, F<F$, F<G, F<H, I>>>>>>>> f){\r\n    return sh.apply(bind(sb, sc, sd, se, sf, sg, f));\r\n}"
}, {
	"Path": "fj.F1Functions.successK",
	"Comment": "promotes this function so that it returns its result on the success side of an validation.kleisli arrow for the validation success projection.",
	"Method": "F<A, Validation<C, B>> successK(F<A, B> f){\r\n    return a -> Validation.success(f.f(a));\r\n}"
}, {
	"Path": "fj.data.Validation.toList",
	"Comment": "returns a single element list if this is a success value, otherwise an empty list.",
	"Method": "List<T> toList(List<E> toList){\r\n    return e.right().toList();\r\n}"
}, {
	"Path": "fj.parser.Parser.repeat",
	"Comment": "returns a parser that repeats application of this parser zero or many times.",
	"Method": "Parser<I, Stream<A>, E> repeat(){\r\n    return repeat1().or(() -> value(Stream.nil()));\r\n}"
}, {
	"Path": "fj.data.Java.Array_ConcurrentLinkedQueue",
	"Comment": "a function that converts arrays to concurrent linked queues.",
	"Method": "F<Array<A>, ConcurrentLinkedQueue<A>> Array_ConcurrentLinkedQueue(){\r\n    return as -> new ConcurrentLinkedQueue(as.asJavaList());\r\n}"
}, {
	"Path": "fj.data.IterableW.bind",
	"Comment": "binds the given function to the values in the given iterables with a final join.",
	"Method": "IterableW<B> bind(F<A, T> f,IterableW<C> bind,Iterable<A> a,Iterable<B> b,F<A, F<B, C>> f,F<IterableW<A>, F<F<A, T>, IterableW<B>>> bind){\r\n    return a -> a::bind;\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.ColorPickerPreviewElement.getColorFieldContainsErrors",
	"Comment": "get whether textfield in colorpickerpreview has validation errors.",
	"Method": "boolean getColorFieldContainsErrors(){\r\n    List<WebElement> caption = findElements(By.className(\"v-caption-v-colorpicker-preview-textfield\"));\r\n    return !caption.isEmpty() && !caption.get(0).findElements(By.className(\"v-errorindicator\")).isEmpty();\r\n}"
}, {
	"Path": "fj.data.vector.V2.zipWith",
	"Comment": "zips this vector with the given vector using the given function to produce a new vector.",
	"Method": "V2<C> zipWith(F<A, F<B, C>> f,V2<B> bs){\r\n    return bs.apply(map(f));\r\n}"
}, {
	"Path": "fj.data.Set.intersect",
	"Comment": "remove all elements from this set that do not occur in the given set.",
	"Method": "Set<A> intersect(Set<A> s,F<Set<A>, F<Set<A>, Set<A>>> intersect){\r\n    return curry(Set::intersect);\r\n}"
}, {
	"Path": "fj.Bottom.error_",
	"Comment": "provides a thunk that throws an error using the given message when evaluated.",
	"Method": "P1<A> error_(String s){\r\n    return P.lazy(() -> {\r\n        throw new Error(s);\r\n    });\r\n}"
}, {
	"Path": "fj.control.parallel.Strategy.idStrategy",
	"Comment": "provides a strategy that performs no evaluation of its argument.",
	"Method": "Strategy<A> idStrategy(){\r\n    return strategy(Function.identity());\r\n}"
}, {
	"Path": "fj.data.Java.Either_CopyOnWriteArraySetB",
	"Comment": "a function that converts eithers to copy on write array sets.",
	"Method": "F<Either<A, B>, CopyOnWriteArraySet<B>> Either_CopyOnWriteArraySetB(){\r\n    return Function.compose(Java.Option_CopyOnWriteArraySet(), Conversions.Either_OptionB());\r\n}"
}, {
	"Path": "fj.data.Java.Either_CopyOnWriteArraySetA",
	"Comment": "a function that converts eithers to copy on write array sets.",
	"Method": "F<Either<A, B>, CopyOnWriteArraySet<A>> Either_CopyOnWriteArraySetA(){\r\n    return Function.compose(Java.Option_CopyOnWriteArraySet(), Conversions.Either_OptionA());\r\n}"
}, {
	"Path": "fj.data.Option.some",
	"Comment": "constructs an optional value that has a value of the given argument.",
	"Method": "A some(A some,A some,Option<T> some,T t,Prism<Option<A>, A> some){\r\n    return new Some(t);\r\n}"
}, {
	"Path": "com.vaadin.tests.components.table.TableMatchesMouseDownMouseUpElementTest.testMoveIn",
	"Comment": "mousedown outside element but on same cell and mouseup on element",
	"Method": "void testMoveIn(WebElement element){\r\n    clearSelection();\r\n    clickAndMove(element, 5, 55, 0, -50);\r\n    checkSelectedRowCount(1);\r\n    checkRowSelected(0);\r\n}"
}, {
	"Path": "fj.F1W.promiseK",
	"Comment": "promotes this function to a concurrent function that returns a promise of a value.",
	"Method": "F1W<A, Promise<B>> promiseK(Strategy<Unit> s){\r\n    return lift(F1Functions.promiseK(this, s));\r\n}"
}, {
	"Path": "com.vaadin.tests.components.table.TableNavigationPageDownTest.waitForScrollToFinish",
	"Comment": "waits until the scroll position indicator goes away, signifying that allthe required rows have been fetched.",
	"Method": "void waitForScrollToFinish(){\r\n    waitUntil(new ExpectedCondition<Boolean>() {\r\n        @Override\r\n        public Boolean apply(WebDriver input) {\r\n            List<WebElement> elements = findElements(By.className(\"v-table-scrollposition\"));\r\n            return elements.isEmpty() || !elements.get(0).isDisplayed();\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"scroll position indicator to vanish\";\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.vaadin.tests.components.table.TableNavigationPageDownTest.waitForScrollToFinish",
	"Comment": "waits until the scroll position indicator goes away, signifying that allthe required rows have been fetched.",
	"Method": "void waitForScrollToFinish(){\r\n    List<WebElement> elements = findElements(By.className(\"v-table-scrollposition\"));\r\n    return elements.isEmpty() || !elements.get(0).isDisplayed();\r\n}"
}, {
	"Path": "com.vaadin.tests.components.table.TableNavigationPageDownTest.waitForScrollToFinish",
	"Comment": "waits until the scroll position indicator goes away, signifying that allthe required rows have been fetched.",
	"Method": "void waitForScrollToFinish(){\r\n    return \"scroll position indicator to vanish\";\r\n}"
}, {
	"Path": "fj.test.Gen.frequency",
	"Comment": "returns a generator that uses values from the given frequency and generator pairs. the returnedgenerator will produce values from the generator in a pair with a higher frequency than a lowerfrequency generator.",
	"Method": "Gen<A> frequency(List<P2<Integer, Gen<A>>> gs){\r\n    final class Pick {\r\n        Gen<A> pick(final int n, final List<P2<Integer, Gen<A>>> gs) {\r\n            if (gs.isEmpty())\r\n                return fail();\r\n            else {\r\n                final int k = gs.head()._1();\r\n                return n <= k ? gs.head()._2() : pick(n - k, gs.tail());\r\n            }\r\n        }\r\n    }\r\n    final F<P2<Integer, Gen<A>>, Integer> f = __1();\r\n    return choose(1, intAdditionMonoid.sumLeft(gs.map(f))).bind(i -> new Pick().pick(i, gs));\r\n}"
}, {
	"Path": "fj.test.Gen.frequency",
	"Comment": "returns a generator that uses values from the given frequency and generator pairs. the returnedgenerator will produce values from the generator in a pair with a higher frequency than a lowerfrequency generator.",
	"Method": "Gen<A> frequency(List<P2<Integer, Gen<A>>> gs){\r\n    if (gs.isEmpty())\r\n        return fail();\r\n    else {\r\n        final int k = gs.head()._1();\r\n        return n <= k ? gs.head()._2() : pick(n - k, gs.tail());\r\n    }\r\n}"
}, {
	"Path": "fj.function.Visitor.association",
	"Comment": "uses an association list to perform a lookup with equality and returns a function that can be applied to a default,followed by the associated key to return a value.",
	"Method": "F<B, F<A, B>> association(List<P2<A, B>> x,Equal<A> eq){\r\n    return curry((def, a) -> lookup(eq, x, a).orSome(def));\r\n}"
}, {
	"Path": "fj.data.List.list",
	"Comment": "performs a reduction on this list using the given arguments.",
	"Method": "B list(B nil,F<A, F<List<A>, B>> cons,List<A> list,A as,List<A> list,Iterable<A> i,List<A> list,Iterator<A> it){\r\n    return iteratorList(it);\r\n}"
}, {
	"Path": "fj.test.Arbitrary.arbConcurrentLinkedQueue",
	"Comment": "returns an arbitrary implementation for concurrent linked queues.",
	"Method": "Gen<ConcurrentLinkedQueue<A>> arbConcurrentLinkedQueue(Gen<A> aa){\r\n    return arbArray(aa).map(a -> new ConcurrentLinkedQueue(a.asJavaList()));\r\n}"
}, {
	"Path": "fj.test.Gen.elements",
	"Comment": "returns a generator that produces values from the given arguments.",
	"Method": "Gen<A> elements(A as){\r\n    return array(as).isEmpty() ? Gen.fail() : choose(0, as.length - 1).map(i -> as[i]);\r\n}"
}, {
	"Path": "fj.data.fingertrees.MakeTree.deep",
	"Comment": "constructs a deep tree. this structure consists of two digits, of 1 to 4 elements each, on the left and right,with the rest of the tree in the middle.",
	"Method": "FingerTree<V, A> deep(Digit<V, A> prefix,FingerTree<V, Node<V, A>> middle,Digit<V, A> suffix,FingerTree<V, A> deep,V v,Digit<V, A> prefix,FingerTree<V, Node<V, A>> middle,Digit<V, A> suffix){\r\n    return new Deep(m, v, prefix, middle, suffix);\r\n}"
}, {
	"Path": "fj.data.Option.sequence",
	"Comment": "performs a bind across the optional value, but ignores the element value in the function.",
	"Method": "Option<B> sequence(Option<B> o,Option<List<A>> sequence,List<Option<A>> a){\r\n    return a.isEmpty() ? some(List.nil()) : a.head().bind(aa -> sequence(a.tail()).map(cons_(aa)));\r\n}"
}, {
	"Path": "fj.data.fingertrees.FingerTree.foldLeft",
	"Comment": "folds the tree to the left with the given function and the given initial element.",
	"Method": "B foldLeft(F<B, F<A, B>> f,B z,B foldLeft,F2<B, A, B> f,B z){\r\n    return foldLeft(F2Functions.curry(f), z);\r\n}"
}, {
	"Path": "fj.P1.softMemo",
	"Comment": "like memo, but the memoized value is wrapped into a softreference",
	"Method": "P1<A> softMemo(P1<A> softMemo,P1<A> softMemo){\r\n    return new SoftReferenceMemo(this);\r\n}"
}, {
	"Path": "fj.data.vector.V7.vzip",
	"Comment": "zips this vector with the given vector to produce a vector of vectors.",
	"Method": "V7<V2<A>> vzip(V7<A> bs){\r\n    final F2<A, A, V2<A>> __2 = V.v2();\r\n    return zipWith(curry(__2), bs);\r\n}"
}, {
	"Path": "org.geoserver.security.WebServiceAuthenticationKeyMapper.setHttpClient",
	"Comment": "configures the httpclient implementation to be used to connect to the web service.",
	"Method": "void setHttpClient(HTTPClient httpClient){\r\n    this.httpClient = httpClient;\r\n}"
}, {
	"Path": "com.vaadin.tests.applicationcontext.CloseSessionTest.testCloseVaadinSession",
	"Comment": "verify we get a session expired error if doing something after closingthe vaadinsession.",
	"Method": "void testCloseVaadinSession(){\r\n    String caption = \"Just close VaadinSession\";\r\n    clickButton(caption);\r\n    clickButton(caption);\r\n    assertSessionExpired();\r\n}"
}, {
	"Path": "fj.data.Validation.forall",
	"Comment": "returns true if this is a failure or returns the result of the application of the givenfunction to the success value.",
	"Method": "boolean forall(F<T, Boolean> f,boolean forall,F<E, Boolean> f){\r\n    return e.right().forall(f);\r\n}"
}, {
	"Path": "fj.data.vector.V5.zipWith",
	"Comment": "zips this vector with the given vector using the given function to produce a new vector.",
	"Method": "V5<C> zipWith(F<A, F<B, C>> f,V5<B> bs){\r\n    return bs.apply(map(f));\r\n}"
}, {
	"Path": "fj.P2.fanout",
	"Comment": "sends the given input value to both argument functions and combines their output.",
	"Method": "P2<C, D> fanout(F<B, C> f,F<B, D> g,B b){\r\n    return join(P.<B, B>p2()).f(b).split(f, g);\r\n}"
}, {
	"Path": "fj.F1Functions.onFail",
	"Comment": "returns a function that returns the failure side of a given validation,or this function applied to the success side.",
	"Method": "F<Validation<B, A>, B> onFail(F<A, B> f){\r\n    return v -> v.f().on(f);\r\n}"
}, {
	"Path": "fj.data.Java.Array_PriorityBlockingQueue",
	"Comment": "a function that converts arrays to priority blocking queues.",
	"Method": "F<Array<A>, PriorityBlockingQueue<A>> Array_PriorityBlockingQueue(){\r\n    return as -> new PriorityBlockingQueue(as.asJavaList());\r\n}"
}, {
	"Path": "fj.data.Stream.split",
	"Comment": "returns a tuple where the first element is the longest prefix of this stream that does not satisfythe given predicate and the second element is the remainder of the stream.",
	"Method": "P2<Stream<A>, Stream<A>> split(F<A, Boolean> p){\r\n    return span(compose(not, p));\r\n}"
}, {
	"Path": "fj.data.Zipper.previous",
	"Comment": "possibly moves the focus to the previous element in the list.",
	"Method": "Option<Zipper<A>> previous(){\r\n    return left.isEmpty() ? Option.none() : some(tryPrevious());\r\n}"
}, {
	"Path": "fj.Try.f",
	"Comment": "promotes the try8 to a validation that returns an exception on the failure side and its result on the success side.",
	"Method": "P1<Validation<E, A>> f(Try0<A, E> t,F<A, Validation<E, B>> f,Try1<A, B, E> t,F2<A, B, Validation<E, C>> f,Try2<A, B, C, E> t,F3<A, B, C, Validation<E, D>> f,Try3<A, B, C, D, E> t,F4<A, B, C, D, Validation<Z, E>> f,Try4<A, B, C, D, E, Z> t,F5<A, B, C, D, E, Validation<Z, F>> f,Try5<A, B, C, D, E, F, Z> t,F6<A, B, C, D, E, F, Validation<Z, G>> f,Try6<A, B, C, D, E, F, G, Z> t,F7<A, B, C, D, E, F, G, Validation<Z, H>> f,Try7<A, B, C, D, E, F, G, H, Z> t,F8<A, B, C, D, E, F, G, H, Validation<Z, I>> f,Try8<A, B, C, D, E, F, G, H, I, Z> t){\r\n    return (a, b, c, d, e, f, g, h) -> {\r\n        try {\r\n            return success(t.f(a, b, c, d, e, f, g, h));\r\n        } catch (Exception ex) {\r\n            return fail((Z) ex);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.geoserver.web.ComponentInfo.getDescriptionKey",
	"Comment": "the i18n key for the description of the component.this description is often used as a tooltip, or some contextual help.",
	"Method": "String getDescriptionKey(){\r\n    return description;\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.reader.CatalogFileReader.moveCursorToNextFragment",
	"Comment": "responsible for moving the cursor before the startelement of the fragment root.this implementation simply looks for the next corresponding element, it does not careabout element nesting. you will need to override this method to correctly handle compositefragments.",
	"Method": "boolean moveCursorToNextFragment(XMLEventReader reader){\r\n    try {\r\n        while (true) {\r\n            while (reader.peek() != null && !reader.peek().isStartElement()) {\r\n                reader.nextEvent();\r\n            }\r\n            if (reader.peek() == null) {\r\n                return false;\r\n            }\r\n            QName startElementName = ((StartElement) reader.peek()).getName();\r\n            if (isFragmentRootElementName(startElementName)) {\r\n                return true;\r\n            }\r\n            reader.nextEvent();\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        return logValidationExceptions((T) null, new NonTransientResourceException(\"Error while reading from event reader\", e));\r\n    }\r\n}"
}, {
	"Path": "fj.data.Enumerator.min",
	"Comment": "returns the minimum value for this enumerator if there is one.",
	"Method": "Option<A> min(){\r\n    return min;\r\n}"
}, {
	"Path": "fj.data.PriorityQueue.unqueue",
	"Comment": "performs a reduction on this priority queue using the given arguments.",
	"Method": "B unqueue(B empty,F2<P2<K, A>, PriorityQueue<K, A>, B> topDequeue){\r\n    K top = ftree.measure();\r\n    P2<FingerTree<K, P2<K, A>>, FingerTree<K, P2<K, A>>> p = ftree.split(equal.eq(top));\r\n    return p._2().uncons(empty, (head, tail) -> topDequeue.f(head, priorityQueue(equal, p._1().append(tail))));\r\n}"
}, {
	"Path": "fj.P2.sequenceW",
	"Comment": "applies a stream of comonadic functions to this product, returning a stream of values.",
	"Method": "List<C> sequenceW(List<F<P2<A, B>, C>> fs,Stream<C> sequenceW,Stream<F<P2<A, B>, C>> fs){\r\n    return fs.isEmpty() ? Stream.nil() : Stream.cons(fs.head().f(this), () -> sequenceW(fs.tail()._1()));\r\n}"
}, {
	"Path": "fj.data.Enumerator.toStream",
	"Comment": "returns a stream of the values from this enumerator, starting at the given value, counting up.",
	"Method": "Stream<A> toStream(A a){\r\n    final F<A, A> id = identity();\r\n    return Stream.fromFunction(this, id, a);\r\n}"
}, {
	"Path": "fj.control.parallel.Promise.join",
	"Comment": "turns a product of a promise into just a promise. does not block on the product by calling it,but creates a new promise with a final join.",
	"Method": "Promise<A> join(Promise<Promise<A>> p,Promise<A> join,Strategy<Unit> s,P1<Promise<A>> p){\r\n    return join(promise(s, p));\r\n}"
}, {
	"Path": "com.vaadin.shared.util.SharedUtil.addGetParameters",
	"Comment": "adds the get parameters to the uri and returns the new uri that containsthe parameters.",
	"Method": "String addGetParameters(String uri,String extraParams){\r\n    if (extraParams == null || extraParams.isEmpty()) {\r\n        return uri;\r\n    }\r\n    String fragment = null;\r\n    int hashPosition = uri.indexOf('#');\r\n    if (hashPosition != -1) {\r\n        fragment = uri.substring(hashPosition);\r\n        uri = uri.substring(0, hashPosition);\r\n    }\r\n    if (uri.contains(\"?\")) {\r\n        uri += \"&\";\r\n    } else {\r\n        uri += \"?\";\r\n    }\r\n    uri += extraParams;\r\n    if (fragment != null) {\r\n        uri += fragment;\r\n    }\r\n    return uri;\r\n}"
}, {
	"Path": "fj.data.TreeZipper.treeZipper",
	"Comment": "creates a new tree zipper given a currently selected tree, a forest on the left, a forest on the right,and a stream of parent contexts.",
	"Method": "TreeZipper<A> treeZipper(Tree<A> tree,Stream<Tree<A>> lefts,Stream<Tree<A>> rights,Stream<P3<Stream<Tree<A>>, A, Stream<Tree<A>>>> parents,F<Tree<A>, F<Stream<Tree<A>>, F<Stream<Tree<A>>, F<Stream<P3<Stream<Tree<A>>, A, Stream<Tree<A>>>>, TreeZipper<A>>>>> treeZipper){\r\n    return curry(TreeZipper::treeZipper);\r\n}"
}, {
	"Path": "fj.data.Validation.sequence",
	"Comment": "if list contains a failure, returns a failure of the reduction ofall the failures using the semigroup, otherwise returns the successful list.",
	"Method": "Validation<E, A> sequence(Validation<E, A> v,Validation<E, List<A>> sequence,Semigroup<E> s,List<Validation<E, A>> list,Validation<A, T> sequence,Validation<A, T> v){\r\n    if (list.exists(Validation::isFail)) {\r\n        return Validation.fail(list.filter(Validation::isFail).map(v -> v.fail()).foldLeft1((F2<E, E, E>) s::sum));\r\n    } else {\r\n        return success(list.foldLeft((List<A> acc, Validation<E, A> v) -> acc.cons(v.success()), List.nil()).reverse());\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.AbstractExecutionAdapter.getAllWarningExceptions",
	"Comment": "return all failure marked as warnings by this jobexecution, including step executions.",
	"Method": "List<Throwable> getAllWarningExceptions(){\r\n    return warningsList;\r\n}"
}, {
	"Path": "fj.data.vector.V8.zip",
	"Comment": "zips this vector with the given vector to produce a vector of pairs.",
	"Method": "V8<P2<A, B>> zip(V8<B> bs){\r\n    final F<A, F<B, P2<A, B>>> __2 = p2();\r\n    return zipWith(__2, bs);\r\n}"
}, {
	"Path": "fj.P3.__1",
	"Comment": "returns a function that returns the first element of a product.",
	"Method": "F<P3<A, B, C>, A> __1(){\r\n    return P3::_1;\r\n}"
}, {
	"Path": "fj.P3.__2",
	"Comment": "returns a function that returns the second element of a product.",
	"Method": "F<P3<A, B, C>, B> __2(){\r\n    return P3::_2;\r\n}"
}, {
	"Path": "fj.P3.__3",
	"Comment": "returns a function that returns the third element of a product.",
	"Method": "F<P3<A, B, C>, C> __3(){\r\n    return P3::_3;\r\n}"
}, {
	"Path": "fj.data.List.groupBy",
	"Comment": "groups the elements of this list by a given keyfunction, applies the valuefunction andaccumulates the mapped values with the given grouping accumulator function on the groupingidentity.",
	"Method": "TreeMap<B, List<A>> groupBy(F<A, B> keyFunction,TreeMap<B, List<A>> groupBy,F<A, B> keyFunction,Ord<B> keyOrd,TreeMap<B, List<C>> groupBy,F<A, B> keyFunction,F<A, C> valueFunction,TreeMap<B, List<C>> groupBy,F<A, B> keyFunction,F<A, C> valueFunction,Ord<B> keyOrd,TreeMap<B, C> groupBy,F<A, B> keyFunction,F<A, C> valueFunction,Monoid<C> monoid,Ord<B> keyOrd,TreeMap<B, D> groupBy,F<A, B> keyFunction,F<A, C> valueFunction,D groupingIdentity,F2<C, D, D> groupingAcc,Ord<B> keyOrd){\r\n    java.util.TreeMap<B, D> buffer = new java.util.TreeMap(keyOrd.toComparator());\r\n    foreachDoEffect(element -> {\r\n        final B key = keyFunction.f(element);\r\n        final C value = valueFunction.f(element);\r\n        buffer.put(key, buffer.containsKey(key) ? groupingAcc.f(value, buffer.get(key)) : groupingAcc.f(value, groupingIdentity));\r\n    });\r\n    return TreeMap.fromMutableMap(keyOrd, buffer);\r\n}"
}, {
	"Path": "fj.data.TreeZipper.delete",
	"Comment": "removes the current node from the tree. the new position becomes the right sibling, or the left siblingif the current node has no right siblings, or the parent node if the current node has no siblings.",
	"Method": "Option<TreeZipper<A>> delete(){\r\n    Option<TreeZipper<A>> r = none();\r\n    if (rights.isNotEmpty())\r\n        r = some(treeZipper(rights.head(), lefts, rights.tail()._1(), parents));\r\n    else if (lefts.isNotEmpty())\r\n        r = some(treeZipper(lefts.head(), lefts.tail()._1(), rights, parents));\r\n    else\r\n        for (final TreeZipper<A> loc : parent()) r = some(loc.modifyTree(t -> node(t.root(), Stream.nil())));\r\n    return r;\r\n}"
}, {
	"Path": "com.vaadin.tests.tb3.AbstractTB3Test.getApplicationId",
	"Comment": "generates the application id based on the url in a way compatible withvaadinservletservice.",
	"Method": "String getApplicationId(String pathWithQueryParameters){\r\n    String pathWithoutQueryParameters = pathWithQueryParameters.replaceAll(\"\\\\?.*\", \"\");\r\n    if (pathWithoutQueryParameters.isEmpty()) {\r\n        return \"ROOT\";\r\n    }\r\n    return pathWithoutQueryParameters.replaceAll(\"[^a-zA-Z0-9]\", \"\");\r\n}"
}, {
	"Path": "org.geoserver.cluster.Event.setSource",
	"Comment": "set an identifier for the node on which the event originates.",
	"Method": "void setSource(Serializable source){\r\n    this.source = source;\r\n}"
}, {
	"Path": "fj.data.Stream.indexOf",
	"Comment": "returns the position of the first element matching the given predicate, if any.",
	"Method": "Option<Integer> indexOf(F<A, Boolean> p){\r\n    return zipIndex().find(p2 -> p.f(p2._1())).map(P2.__2());\r\n}"
}, {
	"Path": "fj.Semigroup.sum",
	"Comment": "returns a function that sums the given value according to this semigroup.",
	"Method": "A sum(A a,F0<Stream<A>> as,A sum,A a1,A a2,F<A, A> sum,A a1,F<A, F<A, A>> sum){\r\n    return def::prepend;\r\n}"
}, {
	"Path": "fj.P2.__2",
	"Comment": "returns a function that returns the second element of a product.",
	"Method": "F<P2<A, B>, B> __2(){\r\n    return P2::_2;\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.CheckBoxElement.clear",
	"Comment": "clears the check box, setting unchecked value. the check box is uncheckedby sending a click event on it.",
	"Method": "void clear(){\r\n    if (isChecked()) {\r\n        click();\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.tests.tb3.AbstractTB3Test.getLogRowElement",
	"Comment": "for tests extending abstracttestuiwithlog, returns the element for thenth log row",
	"Method": "WebElement getLogRowElement(int rowNr){\r\n    return vaadinElementById(\"Log_row_\" + rowNr);\r\n}"
}, {
	"Path": "fj.test.CheckResult.isPropException",
	"Comment": "returns true if this result is an exception during property execution,false otherwise.",
	"Method": "boolean isPropException(){\r\n    return r == R.PropException;\r\n}"
}, {
	"Path": "com.vaadin.tests.tb3.AbstractTB3Test.sleep",
	"Comment": "sleeps for the given number of ms but ensures that the browser connectiondoes not time out.",
	"Method": "void sleep(int timeoutMillis){\r\n    while (timeoutMillis > 0) {\r\n        int d = Math.min(BROWSER_TIMEOUT_IN_MS, timeoutMillis);\r\n        try {\r\n            Thread.sleep(d);\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n        timeoutMillis -= d;\r\n        getDriver().getTitle();\r\n    }\r\n}"
}, {
	"Path": "fj.control.parallel.Promise.promise",
	"Comment": "transforms any function so that it returns a promise of a value instead of an actual value.represents the kleisli arrow for the promise monad.",
	"Method": "Promise<A> promise(Strategy<Unit> s,P1<A> a,F<P1<A>, Promise<A>> promise,Strategy<Unit> s,Promise<Callable<A>> promise,Strategy<Unit> s,Callable<A> a,F<A, Promise<B>> promise,Strategy<Unit> s,F<A, B> f){\r\n    return a -> promise(s, P1.curry(f).f(a));\r\n}"
}, {
	"Path": "com.galenframework.specs.page.PageSpec.addSpec",
	"Comment": "parses the spec from spectext and adds it to the page spec inside specified section. if section does not exit, it will create it",
	"Method": "void addSpec(String sectionName,String objectName,String specText){\r\n    PageSection pageSection = findSection(sectionName);\r\n    if (pageSection == null) {\r\n        pageSection = new PageSection(sectionName);\r\n        sections.add(pageSection);\r\n    }\r\n    ObjectSpecs objectSpecs = new ObjectSpecs(objectName);\r\n    objectSpecs.addSpec(new SpecReader().read(specText));\r\n    pageSection.addObjects(objectSpecs);\r\n}"
}, {
	"Path": "fj.P2.__1",
	"Comment": "returns a function that returns the first element of a product.",
	"Method": "F<P2<A, B>, A> __1(){\r\n    return P2::_1;\r\n}"
}, {
	"Path": "fj.data.fingertrees.Empty.match",
	"Comment": "pattern matching on the structure of this tree. matches the empty tree.",
	"Method": "B match(F<Empty<V, A>, B> empty,F<Single<V, A>, B> single,F<Deep<V, A>, B> deep){\r\n    return empty.f(this);\r\n}"
}, {
	"Path": "fj.data.NonEmptyList.sort",
	"Comment": "sorts this non empty list using the given order over elements using a merge sort algorithm.",
	"Method": "NonEmptyList<A> sort(Ord<A> o){\r\n    final List<A> list = toList().sort(o);\r\n    return nel(list.head(), list.tail());\r\n}"
}, {
	"Path": "fj.F1W.onLeft",
	"Comment": "returns a function that returns the left side of a given either, or this function applied to the right side.",
	"Method": "F1W<Either<B, A>, B> onLeft(){\r\n    return lift(F1Functions.onLeft(this));\r\n}"
}, {
	"Path": "fj.control.parallel.Callables.either",
	"Comment": "turns the given callable into either an exception or the value in the callable.",
	"Method": "P1<Either<Exception, A>> either(Callable<A> a,F<Callable<A>, P1<Either<Exception, A>>> either){\r\n    return Callables::either;\r\n}"
}, {
	"Path": "fj.data.Stream.zipWith",
	"Comment": "zips this stream with the given stream using the given function to produce a new stream. ifthis stream and the given stream have different lengths, then the longer stream is normalisedso this function never fails.",
	"Method": "Stream<C> zipWith(Stream<B> bs,F<A, F<B, C>> f,Stream<C> zipWith,Stream<B> bs,F2<A, B, C> f,F<Stream<B>, Stream<C>> zipWith,F<A, F<B, C>> f,F<Stream<A>, F<Stream<B>, F<F<A, F<B, C>>, Stream<C>>>> zipWith){\r\n    return curry((F3<Stream<A>, Stream<B>, F<A, F<B, C>>, Stream<C>>) Stream::zipWith);\r\n}"
}, {
	"Path": "fj.data.Stream.iterate",
	"Comment": "returns a stream constructed by applying the given iteration function starting at the given value.",
	"Method": "Stream<A> iterate(F<A, A> f,A a,F<F<A, A>, F<A, Stream<A>>> iterate){\r\n    return curry(Stream::iterate);\r\n}"
}, {
	"Path": "fj.data.LazyString.unlines",
	"Comment": "joins the given stream of lazy strings into one, separated by newlines.",
	"Method": "LazyString unlines(Stream<LazyString> str){\r\n    return fromStream(join(str.intersperse(str(\"\\n\")).map(toStream)));\r\n}"
}, {
	"Path": "fj.test.Gen.permutationOf",
	"Comment": "returns a generator of lists that picks the given number of elements from the given list. the selection isa permutation without replacement of elements from the given list, i.e.for any given selection, a generated list may contain its elements in any orderan element will never be picked more than onceif the given number is less than zero or greater than the length of the given list, then thereturned generator will never produce a value.",
	"Method": "Gen<List<A>> permutationOf(int n,List<A> as){\r\n    return parameterised(s -> r -> combinationOf(n, as).map(combination -> {\r\n        Array<A> aArr = combination.toArray();\r\n        int length = aArr.length();\r\n        for (int i = length - 1; i > 0; --i) {\r\n            int j = r.choose(0, i);\r\n            A tmp = aArr.get(i);\r\n            aArr.set(i, aArr.get(j));\r\n            aArr.set(j, tmp);\r\n        }\r\n        return aArr.toList();\r\n    }));\r\n}"
}, {
	"Path": "com.vaadin.tests.util.User.setRoles",
	"Comment": "replaces the set of roles with another collection. user references inroles are automatically updated when setting the roles of a user.",
	"Method": "void setRoles(Set<Role> roles){\r\n    for (Role role : this.roles) {\r\n        role.getUsers().remove(this);\r\n    }\r\n    this.roles = roles;\r\n    for (Role role : this.roles) {\r\n        role.getUsers().add(this);\r\n    }\r\n}"
}, {
	"Path": "fj.data.Stream.filter",
	"Comment": "filters elements from this stream by returning only elements which produce truewhen the given function is applied to them.",
	"Method": "Stream<A> filter(F<A, Boolean> f,F<F<A, Boolean>, F<Stream<A>, Stream<A>>> filter){\r\n    return curry((f, as) -> as.filter(f));\r\n}"
}, {
	"Path": "com.vaadin.tests.components.table.ReloadWidgetsTest.waitForScrollToFinish",
	"Comment": "waits until the scroll position indicator goes away, signifying that allthe required rows have been fetched.",
	"Method": "void waitForScrollToFinish(){\r\n    waitUntil(new ExpectedCondition<Boolean>() {\r\n        @Override\r\n        public Boolean apply(WebDriver input) {\r\n            List<WebElement> elements = findElements(By.className(\"v-table-scrollposition\"));\r\n            return elements.isEmpty() || !elements.get(0).isDisplayed();\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"scroll position indicator to vanish\";\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.vaadin.tests.components.table.ReloadWidgetsTest.waitForScrollToFinish",
	"Comment": "waits until the scroll position indicator goes away, signifying that allthe required rows have been fetched.",
	"Method": "void waitForScrollToFinish(){\r\n    List<WebElement> elements = findElements(By.className(\"v-table-scrollposition\"));\r\n    return elements.isEmpty() || !elements.get(0).isDisplayed();\r\n}"
}, {
	"Path": "com.vaadin.tests.components.table.ReloadWidgetsTest.waitForScrollToFinish",
	"Comment": "waits until the scroll position indicator goes away, signifying that allthe required rows have been fetched.",
	"Method": "void waitForScrollToFinish(){\r\n    return \"scroll position indicator to vanish\";\r\n}"
}, {
	"Path": "fj.test.Property.minSuccessful",
	"Comment": "checks this property using the given random generator, the given minimumsuccessful checks, 500 maximum discarded tests, minimum size of 0, maximum size of 100.",
	"Method": "CheckResult minSuccessful(int minSuccessful,CheckResult minSuccessful,Rand r,int minSuccessful){\r\n    return check(r, minSuccessful, 500, 0, 100);\r\n}"
}, {
	"Path": "org.geoserver.wms.dimension.DynamicDefaultValueSelectionFactory.addExplicitValues",
	"Comment": "separates values provided by the user that do not need defaulting, from those where the userasked explicitly for a default value",
	"Method": "void addExplicitValues(String dimensionName,List<? extends Object> values,Map<String, Object> completeSpecs,Map<String, List<? extends Object>> incompleteSpecs){\r\n    if (values.contains(null)) {\r\n        incompleteSpecs.put(dimensionName, values);\r\n    } else {\r\n        completeSpecs.put(dimensionName, values);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.shared.util.SharedUtil.join",
	"Comment": "joins the words in the input array together into a single string byinserting the separator string between each word.",
	"Method": "String join(String[] parts,String separator){\r\n    if (parts.length == 0) {\r\n        return \"\";\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    for (String part : parts) {\r\n        sb.append(part);\r\n        sb.append(separator);\r\n    }\r\n    return sb.substring(0, sb.length() - separator.length());\r\n}"
}, {
	"Path": "org.geogig.geoserver.model.DropDownTestUtil.resetAvailableBackends",
	"Comment": "resets the list of available backends, based on what is available at runtime.",
	"Method": "void resetAvailableBackends(){\r\n    DropDownModel.setConfigList(DEFAULT_LIST, DEFAULT_CONFIG);\r\n}"
}, {
	"Path": "fj.data.Eval.now",
	"Comment": "constructs an eager evaluation by wrapping the given value.",
	"Method": "Eval<A> now(A a){\r\n    return new Now(a);\r\n}"
}, {
	"Path": "fj.data.Stream.substreams",
	"Comment": "returns a stream of all infixes of this stream. a stream is considered to contain itself.",
	"Method": "Stream<Stream<A>> substreams(){\r\n    return tails().bind(Stream::inits);\r\n}"
}, {
	"Path": "fj.data.Either.traverseListLeft",
	"Comment": "traversable instance of leftprojection of either for list.",
	"Method": "List<Either<C, B>> traverseListLeft(F<A, List<C>> f){\r\n    return left().traverseList(f);\r\n}"
}, {
	"Path": "fj.data.Zipper.cycleNext",
	"Comment": "move the focus to the next element. if the last element is focused, loop to the first element.",
	"Method": "Zipper<A> cycleNext(){\r\n    if (left.isEmpty() && right.isEmpty())\r\n        return this;\r\n    else if (right.isEmpty()) {\r\n        final Stream<A> xs = left.reverse();\r\n        return zipper(Stream.nil(), xs.head(), xs.tail()._1().snoc(P.p(focus)));\r\n    } else\r\n        return tryNext();\r\n}"
}, {
	"Path": "fj.F1Functions.arrayK",
	"Comment": "promotes this function so that it returns its result in a array. kleisli arrow for array.",
	"Method": "F<A, Array<B>> arrayK(F<A, B> f){\r\n    return a -> Array.single(f.f(a));\r\n}"
}, {
	"Path": "fj.test.Property.propertyP",
	"Comment": "returns a property where its result is derived from universal quantification across theapplication of its arguments. no shrinking occurs upon falsification.",
	"Method": "Property propertyP(Gen<A> aa,Shrink<A> sa,F<A, P1<Property>> f,Property propertyP,Gen<A> aa,F<A, P1<Property>> f,Property propertyP,Gen<A> aa,Gen<B> ab,Shrink<A> sa,Shrink<B> sb,F<A, F<B, P1<Property>>> f,Property propertyP,Gen<A> aa,Gen<B> ab,F<A, F<B, P1<Property>>> f,Property propertyP,Gen<A> aa,Gen<B> ab,Shrink<A> sa,Shrink<B> sb,F2<A, B, P1<Property>> f,Property propertyP,Gen<A> aa,Gen<B> ab,F2<A, B, P1<Property>> f){\r\n    return propertyP(aa, ab, curry(f));\r\n}"
}, {
	"Path": "fj.data.Option.join",
	"Comment": "joins the given optional value of optional value using a bind operation.",
	"Method": "Option<A> join(Option<Option<A>> o,F<Option<Option<A>>, Option<A>> join){\r\n    return Option::join;\r\n}"
}, {
	"Path": "fj.data.List.minus",
	"Comment": "returns a new list of all the items in this list that do not appear in the given list.",
	"Method": "List<A> minus(Equal<A> eq,List<A> xs){\r\n    return removeAll(compose(Monoid.disjunctionMonoid.sumLeft(), xs.mapM(curry(eq.eq()))));\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.ColorPickerPreviewElement.setColorTextFieldValue",
	"Comment": "set value of textfield in colorpickerpreview. any existing value in thefield is replaced.",
	"Method": "void setColorTextFieldValue(String value){\r\n    getColorTextField().sendKeys(Keys.chord(Keys.CONTROL, \"a\"));\r\n    getColorTextField().sendKeys(value);\r\n}"
}, {
	"Path": "fj.data.vector.V7.zip",
	"Comment": "zips this vector with the given vector to produce a vector of pairs.",
	"Method": "V7<P2<A, B>> zip(V7<B> bs){\r\n    final F<A, F<B, P2<A, B>>> __2 = p2();\r\n    return zipWith(__2, bs);\r\n}"
}, {
	"Path": "fj.data.Set.update",
	"Comment": "updates, with the given function, the first element in the set that is equal to the given element,according to the order.",
	"Method": "P2<Boolean, Set<A>> update(A a,F<A, A> f){\r\n    return isEmpty() ? P.p(false, this) : tryUpdate(a, f).either(a2 -> P.p(true, delete(a).insert(a2)), Function.identity());\r\n}"
}, {
	"Path": "fj.data.fingertrees.FingerTree.uncons",
	"Comment": "performs a reduction on this finger tree using the given arguments.",
	"Method": "B uncons(B nil,F2<A, FingerTree<V, A>, B> cons){\r\n    return isEmpty() ? nil : cons.f(head(), tail());\r\n}"
}, {
	"Path": "fj.data.TreeZipper.isFirst",
	"Comment": "indicates whether the current node is the leftmost tree in the current forest.",
	"Method": "boolean isFirst(){\r\n    return lefts.isEmpty();\r\n}"
}, {
	"Path": "fj.control.db.DB.liftM",
	"Comment": "promotes any given function so that it transforms between values in the database.",
	"Method": "F<DB<A>, DB<B>> liftM(F<A, B> f){\r\n    return a -> a.map(f);\r\n}"
}, {
	"Path": "com.vaadin.tests.components.tabsheet.TabSheetScrollOnTabCloseTest.leftmostTabHasId",
	"Comment": "an expectation for checking that the leftmost tab has id equal to tabid.",
	"Method": "ExpectedCondition<Boolean> leftmostTabHasId(TabSheetElement tabSheet,String tabId){\r\n    return new ExpectedCondition<Boolean>() {\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            try {\r\n                WebElement leftElement = tabSheet.findElement(By.cssSelector(\".v-tabsheet-tabitemcell\"));\r\n                String leftId = leftElement.getAttribute(\"id\");\r\n                return leftId.equals(tabId);\r\n            } catch (NoSuchElementException e) {\r\n                return false;\r\n            }\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"expected tab index of the leftmost tab in the tab sheet: \" + tabId;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.vaadin.tests.components.tabsheet.TabSheetScrollOnTabCloseTest.leftmostTabHasId",
	"Comment": "an expectation for checking that the leftmost tab has id equal to tabid.",
	"Method": "ExpectedCondition<Boolean> leftmostTabHasId(TabSheetElement tabSheet,String tabId){\r\n    try {\r\n        WebElement leftElement = tabSheet.findElement(By.cssSelector(\".v-tabsheet-tabitemcell\"));\r\n        String leftId = leftElement.getAttribute(\"id\");\r\n        return leftId.equals(tabId);\r\n    } catch (NoSuchElementException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.tests.components.tabsheet.TabSheetScrollOnTabCloseTest.leftmostTabHasId",
	"Comment": "an expectation for checking that the leftmost tab has id equal to tabid.",
	"Method": "ExpectedCondition<Boolean> leftmostTabHasId(TabSheetElement tabSheet,String tabId){\r\n    return \"expected tab index of the leftmost tab in the tab sheet: \" + tabId;\r\n}"
}, {
	"Path": "fj.demo.IODemo.readFirstShortLine",
	"Comment": "reads from standard input until the line length is less than threeand prints that last line.",
	"Method": "void readFirstShortLine(){\r\n    F<LazyString, LazyString> f = lift(lines_()).andThen(l -> l.filter(s -> s.length() < 3)).andThen(unlines_());\r\n    runSafe(interact(f));\r\n}"
}, {
	"Path": "com.vaadin.tests.tb3.AbstractTB3Test.getTestURL",
	"Comment": "returns the full url to be used for the test for the provided ui class.",
	"Method": "String getTestURL(Class<?> uiClass){\r\n    return StringUtils.strip(getBaseURL(), \"/\") + getDeploymentPath(uiClass);\r\n}"
}, {
	"Path": "org.geoserver.security.WebServiceBodyResponseUserGroupServiceConfig.setRoleServiceName",
	"Comment": "optional name of the role service to use for roles resolution. if null it will use thesecurity default active service.",
	"Method": "void setRoleServiceName(String roleServiceName){\r\n    this.roleServiceName = roleServiceName;\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.TwinColSelectElement.deselectByText",
	"Comment": "deselects the option with the given option text, i.e. removes it from theright side column.",
	"Method": "void deselectByText(String text){\r\n    if (isReadOnly()) {\r\n        throw new ReadOnlyException();\r\n    }\r\n    selectedOptions.deselectAll();\r\n    selectedOptions.selectByVisibleText(text);\r\n    deselButton.click();\r\n}"
}, {
	"Path": "com.vaadin.v7.tests.components.grid.basicfeatures.GridBasicFeaturesTest.reopenTestURL",
	"Comment": "reloads the page without restartapplication. this occasionally breaksstuff.",
	"Method": "void reopenTestURL(){\r\n    String testUrl = getTestUrl();\r\n    testUrl = testUrl.replace(\"?restartApplication\", \"?\");\r\n    testUrl = testUrl.replace(\"?&\", \"?\");\r\n    driver.get(testUrl);\r\n}"
}, {
	"Path": "fj.data.Either.iif",
	"Comment": "if the condition satisfies, return the given a in left, otherwise, return the given b in right.",
	"Method": "Either<A, B> iif(boolean c,F0<B> right,F0<A> left){\r\n    return c ? new Right(right.f()) : new Left(left.f());\r\n}"
}, {
	"Path": "fj.data.List.group",
	"Comment": "groups elements according to the given equality implementation by longestsequence of equal elements.",
	"Method": "List<List<A>> group(Equal<A> e){\r\n    if (isEmpty())\r\n        return nil();\r\n    else {\r\n        final P2<List<A>, List<A>> z = tail().span(e.eq(head()));\r\n        return cons(z._1().cons(head()), z._2().group(e));\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.RadioButtonGroupElement.clear",
	"Comment": "clear operation is not supported for option group. this operation has noeffect on option group element.",
	"Method": "void clear(){\r\n    super.clear();\r\n}"
}, {
	"Path": "fj.data.LazyString.subSequence",
	"Comment": "gets the specified subsequence of this lazy string.this operation does not fail for indexes that are out of bounds. if the start index is past the endof this lazy string, then the resulting character sequence will be empty. if the end index is past theend of this lazy string, then the resulting character sequence will be truncated.",
	"Method": "CharSequence subSequence(int start,int end){\r\n    return fromStream(s.drop(start).take(end - start));\r\n}"
}, {
	"Path": "fj.data.Stream.inits",
	"Comment": "returns a stream of all prefixes of this stream. a stream is considered a prefix of itself in tnis context.",
	"Method": "Stream<Stream<A>> inits(){\r\n    final Stream<Stream<A>> nil = cons(Stream.nil(), Stream::nil);\r\n    return isEmpty() ? nil : nil.append(() -> tail()._1().inits().map(Stream.<A>cons_().f(head())));\r\n}"
}, {
	"Path": "fj.test.Gen.listOf1",
	"Comment": "returns a generator of non empty lists whose values come from the given generator.",
	"Method": "Gen<List<A>> listOf1(Gen<A> g){\r\n    return listOf(g, 1);\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.GridElement.toggleColumnHidden",
	"Comment": "toggles the column visibility. column is identified by its hiding togglecaption.",
	"Method": "void toggleColumnHidden(String toggleCaption){\r\n    if (!isElementPresent(By.className(\"v-grid-sidebar-content\"))) {\r\n        WebElement sidebarButton = findElement(By.className(\"v-grid-sidebar\")).findElement(By.tagName(\"button\"));\r\n        sidebarButton.click();\r\n    }\r\n    Optional<WebElement> toggleButton = getDriver().findElement(By.className(\"v-grid-sidebar-content\")).findElements(By.className(\"column-hiding-toggle\")).stream().filter(element -> element.getText().equals(toggleCaption)).findAny();\r\n    if (toggleButton.isPresent()) {\r\n        toggleButton.ifPresent(element -> element.click());\r\n    } else {\r\n        throw new IllegalArgumentException(\"No column hiding toggle with caption '\" + toggleCaption + \"'\");\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.CatalogDiffVisitor.checkEquals",
	"Comment": "return true if the two collection contains exactly the same elements in any order.",
	"Method": "boolean checkEquals(Collection<?> collectionA,Collection<?> collectionB,boolean checkEquals,MetadataMap metadataA,MetadataMap metadataB,boolean checkEquals,Map<String, Serializable> mapA,Map<String, Serializable> mapB){\r\n    if (mapA.size() != mapB.size()) {\r\n        return false;\r\n    }\r\n    for (Map.Entry<String, Serializable> entry : mapA.entrySet()) {\r\n        if (!Objects.equals(entry.getValue(), mapB.get(entry.getKey()))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "fj.data.LazyString.indexOf",
	"Comment": "returns the first index of the given substring in this lazy string, if present.",
	"Method": "Option<Integer> indexOf(char c,Option<Integer> indexOf,LazyString cs){\r\n    return s.substreams().indexOf(eqS.eq(cs.s));\r\n}"
}, {
	"Path": "fj.data.TreeMap.update",
	"Comment": "modifies the value for the given key, if present, by applying the given function to it, orinserts the given value if the key is not present.",
	"Method": "P2<Boolean, TreeMap<K, V>> update(K k,F<V, V> f,TreeMap<K, V> update,K k,F<V, V> f,V v){\r\n    final P2<Boolean, TreeMap<K, V>> up = update(k, f);\r\n    return up._1() ? up._2() : set(k, v);\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.TreeElement.getItem",
	"Comment": "gets an item at given index. the returned element object is the renderedcontent in the given index.",
	"Method": "TestBenchElement getItem(int index){\r\n    return findCellContentFromRow(asTreeGrid().getRow(index));\r\n}"
}, {
	"Path": "fj.data.vector.V6.vzip",
	"Comment": "zips this vector with the given vector to produce a vector of vectors.",
	"Method": "V6<V2<A>> vzip(V6<A> bs){\r\n    final F2<A, A, V2<A>> __2 = V.v2();\r\n    return zipWith(curry(__2), bs);\r\n}"
}, {
	"Path": "fj.data.List.replicate",
	"Comment": "returns a list of the given value replicated the given number of times.",
	"Method": "List<A> replicate(int n,A a){\r\n    List<A> list = nil();\r\n    for (int i = 0; i < n; i++) {\r\n        list = list.cons(a);\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "fj.Semigroup.xmap",
	"Comment": "maps the given functions across this monoid as an invariant functor.",
	"Method": "Semigroup<B> xmap(F<A, B> f,F<B, A> g){\r\n    Definition<A> def = this.def;\r\n    return semigroupDef(new Definition<B>() {\r\n        @Override\r\n        public B append(B a1, B a2) {\r\n            return f.f(def.append(g.f(a1), g.f(a2)));\r\n        }\r\n        @Override\r\n        public F<B, B> prepend(B b) {\r\n            return dimap(def.prepend(g.f(b)), g, f);\r\n        }\r\n        @Override\r\n        public B multiply1p(int n, B b) {\r\n            return f.f(def.multiply1p(n, g.f(b)));\r\n        }\r\n        @Override\r\n        public B sum(B b, F0<Stream<B>> bs) {\r\n            return f.f(def.sum(g.f(b), () -> bs.f().map(g)));\r\n        }\r\n    });\r\n}"
}, {
	"Path": "fj.Semigroup.xmap",
	"Comment": "maps the given functions across this monoid as an invariant functor.",
	"Method": "Semigroup<B> xmap(F<A, B> f,F<B, A> g){\r\n    return f.f(def.append(g.f(a1), g.f(a2)));\r\n}"
}, {
	"Path": "fj.Semigroup.xmap",
	"Comment": "maps the given functions across this monoid as an invariant functor.",
	"Method": "Semigroup<B> xmap(F<A, B> f,F<B, A> g){\r\n    return dimap(def.prepend(g.f(b)), g, f);\r\n}"
}, {
	"Path": "fj.Semigroup.xmap",
	"Comment": "maps the given functions across this monoid as an invariant functor.",
	"Method": "Semigroup<B> xmap(F<A, B> f,F<B, A> g){\r\n    return f.f(def.multiply1p(n, g.f(b)));\r\n}"
}, {
	"Path": "fj.Semigroup.xmap",
	"Comment": "maps the given functions across this monoid as an invariant functor.",
	"Method": "Semigroup<B> xmap(F<A, B> f,F<B, A> g){\r\n    return f.f(def.sum(g.f(b), () -> bs.f().map(g)));\r\n}"
}, {
	"Path": "fj.data.Java.Stream_ConcurrentLinkedQueue",
	"Comment": "a function that converts streams to concurrent linked queues.",
	"Method": "F<Stream<A>, ConcurrentLinkedQueue<A>> Stream_ConcurrentLinkedQueue(){\r\n    return as -> new ConcurrentLinkedQueue(as.toCollection());\r\n}"
}, {
	"Path": "com.vaadin.tests.widgetset.client.MockApplicationConnection.getLastCsrfTokenSent",
	"Comment": "provide the last token sent to the server. we added this to test the change done on csrf token.",
	"Method": "String getLastCsrfTokenSent(){\r\n    return getMessageSender().lastCsrfTokenSent;\r\n}"
}, {
	"Path": "fj.Monoid.monoid",
	"Comment": "constructs a monoid from the given semigroup and zero value, which must follow the monoidal laws.",
	"Method": "Monoid<A> monoid(F<A, F<A, A>> sum,A zero,Monoid<A> monoid,F2<A, A, A> sum,A zero,Monoid<A> monoid,Semigroup<A> s,A zero){\r\n    return s.monoid(zero);\r\n}"
}, {
	"Path": "fj.data.fingertrees.Single.match",
	"Comment": "pattern matching on the structure of this tree. matches the singleton tree.",
	"Method": "B match(F<Empty<V, A>, B> empty,F<Single<V, A>, B> single,F<Deep<V, A>, B> deep){\r\n    return single.f(this);\r\n}"
}, {
	"Path": "fj.Ord.eq",
	"Comment": "returns true if the given arguments are equal, false otherwise.",
	"Method": "boolean eq(A a1,A a2){\r\n    return def.compare(a1, a2) == Ordering.EQ;\r\n}"
}, {
	"Path": "fj.F1Functions.mapRight",
	"Comment": "promotes this function to map over the right side of an either.",
	"Method": "F<Either<X, A>, Either<X, B>> mapRight(F<A, B> f){\r\n    return Either.<X, A, B>rightMap_().f(f);\r\n}"
}, {
	"Path": "fj.parser.Parser.filter",
	"Comment": "returns a parser that fails with the given error if the result value does not meet the given predicate.",
	"Method": "Parser<I, A, E> filter(F<A, Boolean> f,E e){\r\n    return parser(i -> parse(i).bind(r -> {\r\n        final A v = r.value();\r\n        return f.f(v) ? Validation.<E, Result<I, A>>success(result(r.rest(), v)) : Validation.<E, Result<I, A>>fail(e);\r\n    }));\r\n}"
}, {
	"Path": "fj.P5.__3",
	"Comment": "returns a function that returns the third element of a product.",
	"Method": "F<P5<A, B, C, D, E>, C> __3(){\r\n    return P5::_3;\r\n}"
}, {
	"Path": "fj.data.Java.Either_PriorityBlockingQueueB",
	"Comment": "a function that converts eithers to priority blocking queues.",
	"Method": "F<Either<A, B>, PriorityBlockingQueue<B>> Either_PriorityBlockingQueueB(){\r\n    return Function.compose(Java.Option_PriorityBlockingQueue(), Conversions.Either_OptionB());\r\n}"
}, {
	"Path": "fj.P5.__4",
	"Comment": "returns a function that returns the fourth element of a product.",
	"Method": "F<P5<A, B, C, D, E>, D> __4(){\r\n    return P5::_4;\r\n}"
}, {
	"Path": "fj.data.Java.Either_PriorityBlockingQueueA",
	"Comment": "a function that converts eithers to priority blocking queues.",
	"Method": "F<Either<A, B>, PriorityBlockingQueue<A>> Either_PriorityBlockingQueueA(){\r\n    return Function.compose(Java.Option_PriorityBlockingQueue(), Conversions.Either_OptionA());\r\n}"
}, {
	"Path": "fj.P5.__5",
	"Comment": "returns a function that returns the fifth element of a product.",
	"Method": "F<P5<A, B, C, D, E>, E> __5(){\r\n    return P5::_5;\r\n}"
}, {
	"Path": "fj.parser.Result.bimap",
	"Comment": "a bifunctor map across both the remainder of the parse input and the parse value.",
	"Method": "Result<J, B> bimap(F<I, J> f,F<A, B> g,F<F<I, J>, F<F<A, B>, Result<J, B>>> bimap){\r\n    return curry(this::bimap);\r\n}"
}, {
	"Path": "fj.F2W.lift",
	"Comment": "lifts the function into the fully featured function wrapper",
	"Method": "F2W<A, B, C> lift(F2<A, B, C> f){\r\n    return new F2WFunc(f);\r\n}"
}, {
	"Path": "fj.P5.__1",
	"Comment": "returns a function that returns the first element of a product.",
	"Method": "F<P5<A, B, C, D, E>, A> __1(){\r\n    return P5::_1;\r\n}"
}, {
	"Path": "fj.P5.__2",
	"Comment": "returns a function that returns the second element of a product.",
	"Method": "F<P5<A, B, C, D, E>, B> __2(){\r\n    return P5::_2;\r\n}"
}, {
	"Path": "fj.data.Stream.tails",
	"Comment": "returns a stream of the suffixes of this stream. a stream is considered to be a suffix of itself in this context.",
	"Method": "Stream<Stream<A>> tails(){\r\n    return isEmpty() ? Stream.nil() : cons(this, () -> tail()._1().tails());\r\n}"
}, {
	"Path": "fj.test.Property.sequence",
	"Comment": "performs a sequence of this property with the given property. the returned property holds ifand only if this property and the given property also hold. if one property does not hold, butthe other does, then the returned property will produce the same result and the property thatholds.",
	"Method": "Property sequence(Property p){\r\n    return fromGen(gen().bind(p.gen(), res1 -> res2 -> res1.isException() || res1.isProven() || res1.isUnfalsified() ? res1 : res2.isException() || res2.isProven() || res2.isUnfalsified() ? res2 : res1.isFalsified() ? res2 : res2.isFalsified() ? res1 : noResult()));\r\n}"
}, {
	"Path": "fj.P2.map1_",
	"Comment": "promotes a function so that it maps the first element of a product.",
	"Method": "F<P2<A, B>, P2<X, B>> map1_(F<A, X> f){\r\n    return p -> p.map1(f);\r\n}"
}, {
	"Path": "com.vaadin.tests.integration.push.AbstractTestUI.runAfterResponse",
	"Comment": "execute the provided runnable on the ui thread as soon as the currentrequest has been sent.",
	"Method": "void runAfterResponse(Runnable runnable){\r\n    new Thread() {\r\n        @Override\r\n        public void run() {\r\n            accessSynchronously(runnable);\r\n        }\r\n    }.start();\r\n}"
}, {
	"Path": "com.vaadin.tests.integration.push.AbstractTestUI.runAfterResponse",
	"Comment": "execute the provided runnable on the ui thread as soon as the currentrequest has been sent.",
	"Method": "void runAfterResponse(Runnable runnable){\r\n    accessSynchronously(runnable);\r\n}"
}, {
	"Path": "org.geoserver.security.WebServiceBodyResponseUserGroupServiceConfig.setSearchRoles",
	"Comment": "regular expression, used to extract the roles name from the webservice response",
	"Method": "void setSearchRoles(String searchRoles){\r\n    this.searchRoles = searchRoles;\r\n}"
}, {
	"Path": "fj.data.Either.traverseOptionRight",
	"Comment": "traversable instance of rightprojection of either for option.",
	"Method": "Option<Either<A, C>> traverseOptionRight(F<B, Option<C>> f){\r\n    return right().traverseOption(f);\r\n}"
}, {
	"Path": "fj.data.Java.StringBuilder_ArrayBlockingQueue",
	"Comment": "a function that converts string builders to array blocking queues.",
	"Method": "F<StringBuilder, ArrayBlockingQueue<Character>> StringBuilder_ArrayBlockingQueue(boolean fair){\r\n    return Function.compose(Java.List_ArrayBlockingQueue(fair), Conversions.StringBuilder_List);\r\n}"
}, {
	"Path": "fj.P2.map2_",
	"Comment": "promotes a function so that it maps the second element of a product.",
	"Method": "F<P2<A, B>, P2<A, X>> map2_(F<B, X> f){\r\n    return p -> p.map2(f);\r\n}"
}, {
	"Path": "fj.data.NonEmptyList.zipWith",
	"Comment": "zips this non empty list with the given non empty list using the given function to produce a new list. if this listand the given list have different lengths, then the longer list is normalised so this functionnever fails.",
	"Method": "NonEmptyList<C> zipWith(List<B> bs,F<A, F<B, C>> f,NonEmptyList<C> zipWith,List<B> bs,F2<A, B, C> f){\r\n    final List<C> list = toList().zipWith(bs, f);\r\n    return nel(list.head(), list.tail());\r\n}"
}, {
	"Path": "fj.data.LazyString.split",
	"Comment": "splits this lazy string by characters matching the given predicate.",
	"Method": "Stream<LazyString> split(F<Character, Boolean> p,Stream<LazyString> split,char c){\r\n    return split(charEqual.eq(c));\r\n}"
}, {
	"Path": "fj.control.parallel.Strategy.parMap",
	"Comment": "maps the given function over the given array in parallel using this strategy.",
	"Method": "P1<List<A>> parMap(F<B, A> f,List<B> bs,P1<Array<A>> parMap,F<B, A> f,Array<B> bs){\r\n    return P1.sequence(bs.map(concurry(f)));\r\n}"
}, {
	"Path": "fj.data.vector.V4.zipWith",
	"Comment": "zips this vector with the given vector using the given function to produce a new vector.",
	"Method": "V4<C> zipWith(F<A, F<B, C>> f,V4<B> bs){\r\n    return bs.apply(map(f));\r\n}"
}, {
	"Path": "fj.data.Stream.unzip",
	"Comment": "transforms a stream of pairs into a stream of first components and a stream of second components.",
	"Method": "P2<Stream<A>, Stream<B>> unzip(Stream<P2<A, B>> xs){\r\n    return xs.foldRight((p, ps) -> {\r\n        final P2<Stream<A>, Stream<B>> pp = ps._1();\r\n        return p(cons(p._1(), p(pp._1())), cons(p._2(), p(pp._2())));\r\n    }, p(Stream.nil(), Stream.nil()));\r\n}"
}, {
	"Path": "fj.test.CheckResult.genException",
	"Comment": "returns a result that generating values to check the property threw an exception.",
	"Method": "CheckResult genException(Throwable ex,int succeeded,int discarded){\r\n    return new CheckResult(R.GenException, Option.none(), some(ex), succeeded, discarded);\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.TwinColSelectElement.getValues",
	"Comment": "functionality to find option texts of all currently selected options.",
	"Method": "List<String> getValues(){\r\n    return getOptionsFromSelect(selectedOptions);\r\n}"
}, {
	"Path": "fj.F1Functions.contramapShow",
	"Comment": "promotes this function to map over a show as a contravariant functor.",
	"Method": "F<Show<B>, Show<A>> contramapShow(F<A, B> f){\r\n    return s -> s.contramap(f);\r\n}"
}, {
	"Path": "fj.data.Seq.take",
	"Comment": "takes the given number of elements from the head of this sequence if they are available.",
	"Method": "Seq<A> take(int n){\r\n    return split(n)._1();\r\n}"
}, {
	"Path": "fj.test.Gen.selectionOf",
	"Comment": "returns a generator of lists that picks the given number of elements from the given list. the selection isa combination with replacement of elements from the given list, i.e.for any given selection, a generated list will always contain its elements in the same ordereach element may be picked more than onceif the given number is less than zero, then the returned generator will never produce a value. note that,with replacement, the given number may be larger than the length of the given list.",
	"Method": "Gen<List<A>> selectionOf(int n,List<A> as){\r\n    Array<A> aArr = as.toArray();\r\n    return (n >= 0) ? pick(indexWord(n, aArr.length()).map(indexes -> indexes.sort(intOrd)), aArr) : fail();\r\n}"
}, {
	"Path": "fj.F1Functions.mapFst",
	"Comment": "promotes this function to map over the first element of a pair.",
	"Method": "F<P2<A, C>, P2<B, C>> mapFst(F<A, B> f){\r\n    return P2.map1_(f);\r\n}"
}, {
	"Path": "fj.data.Stream.dropWhile",
	"Comment": "removes elements from the head of this stream that do not match the given predicate functionuntil an element is found that does match or the stream is exhausted.",
	"Method": "Stream<A> dropWhile(F<A, Boolean> f){\r\n    Stream<A> as;\r\n    for (as = this; !as.isEmpty() && f.f(as.head()); as = as.tail()._1()) ;\r\n    return as;\r\n}"
}, {
	"Path": "fj.data.fingertrees.Deep.match",
	"Comment": "pattern matching on the tree. matches the function on the deep tree.",
	"Method": "B match(F<Empty<V, A>, B> empty,F<Single<V, A>, B> single,F<Deep<V, A>, B> deep){\r\n    return deep.f(this);\r\n}"
}, {
	"Path": "fj.F1W.contramapHash",
	"Comment": "promotes this function to map over a hash as a contravariant functor.",
	"Method": "F1W<Hash<B>, Hash<A>> contramapHash(){\r\n    return lift(F1Functions.contramapHash(this));\r\n}"
}, {
	"Path": "org.geogig.geoserver.config.ConfigStore.removeRepositoryInfoChangedCallback",
	"Comment": "remove a callback that was previously added to the config store.",
	"Method": "void removeRepositoryInfoChangedCallback(RepositoryInfoChangedCallback callback){\r\n    this.callbacks.remove(callback);\r\n}"
}, {
	"Path": "fj.data.Validation.filter",
	"Comment": "returns none if this is a failure or if the given predicate p does not hold for thesuccess value, otherwise, returns a success in some.",
	"Method": "Option<Validation<A, T>> filter(F<T, Boolean> f,Option<Validation<E, A>> filter,F<E, Boolean> f){\r\n    return e.right().<A>filter(f).map(Validation.validation());\r\n}"
}, {
	"Path": "fj.data.State.traverse",
	"Comment": "map each element of a structure to an action, evaluate these actions from left to rightand collect the results.",
	"Method": "State<S, List<B>> traverse(List<A> list,F<A, State<S, B>> f){\r\n    return list.foldLeft((acc, a) -> acc.flatMap(bs -> f.f(a).map(b -> cons(b, bs))), State.<S, List<B>>constant(List.nil())).map(bs -> bs.reverse());\r\n}"
}, {
	"Path": "org.geoserver.wms.dynamic.legendgraphic.DynamicGetLegendGraphicDispatcherCallback.parseReadParameters",
	"Comment": "parse the read parameter from the getlegendgraphicrequest in order to access the propercoverage slice to retrieve the proper statistics.",
	"Method": "GeneralParameterValue[] parseReadParameters(CoverageInfo coverageInfo,GridCoverage2DReader reader){\r\n    final ParameterValueGroup readParametersDescriptor = reader.getFormat().getReadParameters();\r\n    GeneralParameterValue[] readParameters = CoverageUtils.getParameters(readParametersDescriptor, coverageInfo.getParameters(), false);\r\n    final List<GeneralParameterDescriptor> parameterDescriptors = new ArrayList<GeneralParameterDescriptor>(readParametersDescriptor.getDescriptor().descriptors());\r\n    Set<ParameterDescriptor<List>> dynamicParameters = reader.getDynamicParameters();\r\n    parameterDescriptors.addAll(dynamicParameters);\r\n    final ReaderDimensionsAccessor dimensions = new ReaderDimensionsAccessor(reader);\r\n    final MetadataMap metadata = coverageInfo.getMetadata();\r\n    final ReferencedEnvelope testEnvelope = createTestEnvelope(coverageInfo);\r\n    final GridGeometry2D gridGeometry = new GridGeometry2D(new GridEnvelope2D(new Rectangle(0, 0, 2, 2)), testEnvelope);\r\n    readParameters = CoverageUtils.mergeParameter(parameterDescriptors, readParameters, gridGeometry, AbstractGridFormat.READ_GRIDGEOMETRY2D.getName().toString());\r\n    Map<String, Object> map = Dispatcher.REQUEST.get().getKvp();\r\n    readParameters = parseTimeParameter(metadata, readParameters, parameterDescriptors, map);\r\n    readParameters = parseElevationParameter(metadata, readParameters, parameterDescriptors, map);\r\n    readParameters = parseCustomDomains(dimensions, metadata, readParameters, parameterDescriptors, map);\r\n    return readParameters;\r\n}"
}, {
	"Path": "fj.data.Stream.uncons",
	"Comment": "performs a reduction on this stream using the given arguments.",
	"Method": "B uncons(B nil,F<A, F<P1<Stream<A>>, B>> cons){\r\n    return isEmpty() ? nil : cons.f(head()).f(tail());\r\n}"
}, {
	"Path": "fj.data.Java.StringBuffer_ArrayBlockingQueue",
	"Comment": "a function that converts string buffers to array blocking queues.",
	"Method": "F<StringBuffer, ArrayBlockingQueue<Character>> StringBuffer_ArrayBlockingQueue(boolean fair){\r\n    return Function.compose(Java.List_ArrayBlockingQueue(fair), Conversions.StringBuffer_List);\r\n}"
}, {
	"Path": "fj.data.Option.filter",
	"Comment": "filters elements from this optional value by returning only elements which producetrue when the given function is applied to them.",
	"Method": "Option<A> filter(F<A, Boolean> f){\r\n    return isSome() ? f.f(some()) ? this : Option.none() : Option.none();\r\n}"
}, {
	"Path": "fj.control.parallel.Callables.option",
	"Comment": "returns a transformation from a callable to an optional value.",
	"Method": "P1<Option<A>> option(Callable<A> a,F<Callable<A>, P1<Option<A>>> option){\r\n    return Callables::option;\r\n}"
}, {
	"Path": "fj.data.Array.filter",
	"Comment": "filters elements from this array by returning only elements which produce truewhen the given function is applied to them.",
	"Method": "Array<A> filter(F<A, Boolean> f,Array<A> filter,F<A, Boolean> f){\r\n    List<A> x = List.nil();\r\n    for (int i = a.length - 1; i >= 0; i--) {\r\n        if (f.f((A) a[i]))\r\n            x = x.cons((A) a[i]);\r\n    }\r\n    return x.toArray();\r\n}"
}, {
	"Path": "com.galenframework.generator.SpecGenerator.restructurePageItems",
	"Comment": "orders page items into a tree by their area. tries to fit one item inside another",
	"Method": "List<PageItemNode> restructurePageItems(List<PageItem> items){\r\n    List<PageItemNode> pins = items.stream().map(PageItemNode::new).collect(toList());\r\n    for (PageItemNode pinA : pins) {\r\n        for (PageItemNode pinB : pins) {\r\n            if (pinA != pinB) {\r\n                if (isInside(pinA.getPageItem().getArea(), pinB.getPageItem().getArea())) {\r\n                    if (pinB.getParent() == pinA) {\r\n                        throw new RuntimeException(format(\"The following objects have identical areas: %s, %s. Please remove one of the objects\", pinA.getPageItem().getName(), pinB.getPageItem().getName()));\r\n                    }\r\n                    pinA.moveToParent(pinB);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return pins.stream().filter(pin -> pin.getParent() == null && pin.getChildren().size() > 0).collect(toList());\r\n}"
}, {
	"Path": "fj.data.vector.V7.zipWith",
	"Comment": "zips this vector with the given vector using the given function to produce a new vector.",
	"Method": "V7<C> zipWith(F<A, F<B, C>> f,V7<B> bs){\r\n    return bs.apply(map(f));\r\n}"
}, {
	"Path": "fj.data.List.maximumOption",
	"Comment": "returns the maximum element in this list according to the given ordering.",
	"Method": "Option<A> maximumOption(Ord<A> o){\r\n    return NonEmptyList.fromList(this).map(nel -> nel.maximum(o));\r\n}"
}, {
	"Path": "org.geoserver.cluster.hazelcast.HzSynchronizerTest.replay",
	"Comment": "replay all the mocks on this test class, plus those specified",
	"Method": "void replay(Object mocks){\r\n    EasyMock.replay(myMocks().toArray());\r\n    EasyMock.replay(mocks);\r\n}"
}, {
	"Path": "org.geogig.geoserver.web.repository.CommonPanelTest.navigateToStartPage",
	"Comment": "before method that navigates all subclass tests to their respective starting pages.",
	"Method": "void navigateToStartPage(){\r\n    login();\r\n    repoPage = new RepositoriesPage();\r\n    tester.startPage(repoPage);\r\n    tester.clickLink(getStartPage());\r\n    tester.assertRenderedPage(getStartPageClass());\r\n    temp = new TemporaryFolder();\r\n    temp.create();\r\n}"
}, {
	"Path": "fj.data.IOFunctions.interactWhile",
	"Comment": "read lines from stdin until condition is not met, transforming each line and printingthe result to stdout.",
	"Method": "IO<Unit> interactWhile(F<String, Boolean> condition,F<String, String> transform){\r\n    Stream<IO<String>> s1 = Stream.repeat(stdinReadLine());\r\n    IO<Stream<String>> io = sequenceWhile(s1, condition);\r\n    return () -> runSafe(io).foreach(s -> runSafe(stdoutPrintln(transform.f(s))));\r\n}"
}, {
	"Path": "fj.data.TreeZipper.insertRight",
	"Comment": "inserts a tree to the right of the current position. the inserted tree becomes the current tree.",
	"Method": "TreeZipper<A> insertRight(Tree<A> t){\r\n    return treeZipper(t, lefts.cons(tree), rights, parents);\r\n}"
}, {
	"Path": "fj.data.hamt.Node.match",
	"Comment": "performs a reduction on this node using the given arguments.",
	"Method": "B match(F<P2<K, V>, B> f,F<HashArrayMappedTrie<K, V>, B> g){\r\n    return either.either(f, g);\r\n}"
}, {
	"Path": "fj.data.Option.bind",
	"Comment": "binds the given function across the element of this optional value and the given optional valuewith a final join.",
	"Method": "Option<B> bind(F<A, Option<B>> f,Option<C> bind,Option<B> ob,F<A, F<B, C>> f,Option<D> bind,Option<B> ob,Option<C> oc,F<A, F<B, F<C, D>>> f,Option<E> bind,Option<B> ob,Option<C> oc,Option<D> od,F<A, F<B, F<C, F<D, E>>>> f,Option<F$> bind,Option<B> ob,Option<C> oc,Option<D> od,Option<E> oe,F<A, F<B, F<C, F<D, F<E, F$>>>>> f,Option<G> bind,Option<B> ob,Option<C> oc,Option<D> od,Option<E> oe,Option<F$> of,F<A, F<B, F<C, F<D, F<E, F<F$, G>>>>>> f,Option<H> bind,Option<B> ob,Option<C> oc,Option<D> od,Option<E> oe,Option<F$> of,Option<G> og,F<A, F<B, F<C, F<D, F<E, F<F$, F<G, H>>>>>>> f,Option<I> bind,Option<B> ob,Option<C> oc,Option<D> od,Option<E> oe,Option<F$> of,Option<G> og,Option<H> oh,F<A, F<B, F<C, F<D, F<E, F<F$, F<G, F<H, I>>>>>>>> f,F<F<A, Option<B>>, F<Option<A>, Option<B>>> bind){\r\n    return curry((f, a) -> a.bind(f));\r\n}"
}, {
	"Path": "fj.data.Either.traverseListRight",
	"Comment": "traversable instance of rightprojection of either for list.",
	"Method": "List<Either<A, C>> traverseListRight(F<B, List<C>> f){\r\n    return right().traverseList(f);\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.ComboBoxElement.selectByTextFromPopup",
	"Comment": "selects, without filtering, the first option in the combobox whichmatches the given text.",
	"Method": "void selectByTextFromPopup(String text){\r\n    while (openPrevPage()) {\r\n    }\r\n    do {\r\n        if (selectSuggestion(text)) {\r\n            return;\r\n        }\r\n    } while (openNextPage());\r\n}"
}, {
	"Path": "fj.F1Functions.mapSuccess",
	"Comment": "promotes this function to map over the success side of a validation.",
	"Method": "F<Validation<X, A>, Validation<X, B>> mapSuccess(F<A, B> f){\r\n    return v -> v.map(f);\r\n}"
}, {
	"Path": "fj.data.Zipper.zipper",
	"Comment": "creates a new zipper with the given streams before and after the focus, and the given focused item.",
	"Method": "Zipper<A> zipper(Stream<A> left,A focus,Stream<A> right,Zipper<A> zipper,P3<Stream<A>, A, Stream<A>> p,F3<Stream<A>, A, Stream<A>, Zipper<A>> zipper){\r\n    return Zipper::zipper;\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.reader.CatalogFileReader.readToStartFragment",
	"Comment": "read until the first startelement tag that matches any of the provided fragmentrootelementnames. because there may be any number of tags inbetween where the reader is now and the fragment start, this is done in a loop until the element type and name match.",
	"Method": "QName readToStartFragment(){\r\n    while (true) {\r\n        XMLEvent nextEvent = eventReader.nextEvent();\r\n        if (nextEvent.isStartElement() && isFragmentRootElementName(((StartElement) nextEvent).getName())) {\r\n            return ((StartElement) nextEvent).getName();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "fj.P4.__4",
	"Comment": "returns a function that returns the fourth element of a product.",
	"Method": "F<P4<A, B, C, D>, D> __4(){\r\n    return P4::_4;\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.tasklet.GenericTaskletUtils.getInputDirectory",
	"Comment": "can be used in the context of a restore job to get the directory that contain the backupcontent.",
	"Method": "Resource getInputDirectory(JobExecution jobExecution){\r\n    String inputDirectoryUrl = jobExecution.getJobParameters().getString(Backup.PARAM_INPUT_FILE_PATH);\r\n    if (inputDirectoryUrl == null) {\r\n        throw new RuntimeException(\"No input directory available for this job execution.\");\r\n    }\r\n    return Resources.fromURL(inputDirectoryUrl);\r\n}"
}, {
	"Path": "fj.data.Natural.divmod",
	"Comment": "divide a natural number by another yielding both the quotient and the remainder.",
	"Method": "V2<Natural> divmod(Natural n){\r\n    final BigInteger[] x = value.divideAndRemainder(n.value);\r\n    return V.v(natural(x[0]).some(), natural(x[1]).some());\r\n}"
}, {
	"Path": "fj.P4.__2",
	"Comment": "returns a function that returns the second element of a product.",
	"Method": "F<P4<A, B, C, D>, B> __2(){\r\n    return P4::_2;\r\n}"
}, {
	"Path": "fj.P4.__3",
	"Comment": "returns a function that returns the third element of a product.",
	"Method": "F<P4<A, B, C, D>, C> __3(){\r\n    return P4::_3;\r\n}"
}, {
	"Path": "fj.data.Stream.isNotEmpty_",
	"Comment": "returns a function that determines whether a given stream is not empty.",
	"Method": "F<Stream<A>, Boolean> isNotEmpty_(){\r\n    return Stream::isNotEmpty;\r\n}"
}, {
	"Path": "fj.P4.__1",
	"Comment": "returns a function that returns the first element of a product.",
	"Method": "F<P4<A, B, C, D>, A> __1(){\r\n    return P4::_1;\r\n}"
}, {
	"Path": "fj.data.fingertrees.Digit.map",
	"Comment": "maps a function across the elements of this digit, measuring with the given measurement.",
	"Method": "Digit<V, B> map(F<A, B> f,Measured<V, B> m){\r\n    return match(one -> new One(m, f.f(one.value())), two -> new Two(m, two.values().map(f)), three -> new Three(m, three.values().map(f)), four -> new Four(m, four.values().map(f)));\r\n}"
}, {
	"Path": "com.galenframework.support.GalenJavaTestBase.inject",
	"Comment": "injects the given javascript expression in current driver for current test thread",
	"Method": "void inject(String javaScript){\r\n    GalenUtils.injectJavascript(getDriver(), javaScript);\r\n}"
}, {
	"Path": "fj.data.Array.zipWith",
	"Comment": "zips this array with the given array using the given function to produce a new array. if thisarray and the given array have different lengths, then the longer array is normalised so thisfunction never fails.",
	"Method": "Array<C> zipWith(Array<B> bs,F<A, F<B, C>> f,Array<C> zipWith,Array<B> bs,F2<A, B, C> f){\r\n    return zipWith(bs, curry(f));\r\n}"
}, {
	"Path": "fj.data.Tree.fmap_",
	"Comment": "provides a transformation to lift any function so that it maps over trees.",
	"Method": "F<F<A, B>, F<Tree<A>, Tree<B>>> fmap_(){\r\n    return f -> a -> a.fmap(f);\r\n}"
}, {
	"Path": "fj.F1Functions.mapSnd",
	"Comment": "promotes this function to map over the second element of a pair.",
	"Method": "F<P2<C, A>, P2<C, B>> mapSnd(F<A, B> f){\r\n    return P2.map2_(f);\r\n}"
}, {
	"Path": "fj.test.Property.check",
	"Comment": "checks this property using the given random generator, 100 minimum successful checks, 500maximum discarded tests, the given minimum size and the given maximum size.",
	"Method": "CheckResult check(Rand r,int minSuccessful,int maxDiscarded,int minSize,int maxSize,CheckResult check,int minSuccessful,int maxDiscarded,int minSize,int maxSize,CheckResult check,Rand r,CheckResult check,Rand r,int minSize,int maxSize,CheckResult check,int minSize,int maxSize,CheckResult check){\r\n    return check(0, 100);\r\n}"
}, {
	"Path": "fj.data.Either.swap",
	"Comment": "if this is a left, then return the left value in right, or vice versa.",
	"Method": "Either<B, A> swap(){\r\n    return either(right_(), left_());\r\n}"
}, {
	"Path": "fj.data.List.unfold",
	"Comment": "unfolds across the given function starting at the given value to produce a list.",
	"Method": "List<A> unfold(F<B, Option<P2<A, B>>> f,B b){\r\n    Buffer<A> buf = empty();\r\n    for (Option<P2<A, B>> o = f.f(b); o.isSome(); o = f.f(o.some()._2())) {\r\n        buf = buf.snoc(o.some()._1());\r\n    }\r\n    return buf.toList();\r\n}"
}, {
	"Path": "fj.Function.constant",
	"Comment": "returns a function that ignores its argument to constantly produce the given value.",
	"Method": "F<B, F<A, B>> constant(F<A, B> constant,B b){\r\n    return a -> b;\r\n}"
}, {
	"Path": "fj.test.Arbitrary.arbEither",
	"Comment": "returns an arbitrary implementation for the disjoint union.",
	"Method": "Gen<Either<A, B>> arbEither(Gen<A> aa,Gen<B> ab){\r\n    final Gen<Either<A, B>> left = aa.map(Either::left);\r\n    final Gen<Either<A, B>> right = ab.map(Either::right);\r\n    return oneOf(list(left, right));\r\n}"
}, {
	"Path": "com.vaadin.tests.components.AbstractTestUI.runAfterResponse",
	"Comment": "execute the provided runnable on the ui thread as soon as the currentrequest has been sent.",
	"Method": "void runAfterResponse(Runnable runnable){\r\n    new Thread() {\r\n        @Override\r\n        public void run() {\r\n            accessSynchronously(runnable);\r\n        }\r\n    }.start();\r\n}"
}, {
	"Path": "com.vaadin.tests.components.AbstractTestUI.runAfterResponse",
	"Comment": "execute the provided runnable on the ui thread as soon as the currentrequest has been sent.",
	"Method": "void runAfterResponse(Runnable runnable){\r\n    accessSynchronously(runnable);\r\n}"
}, {
	"Path": "fj.data.List.last",
	"Comment": "returns the last element of this list. undefined for the empty list.",
	"Method": "A last(){\r\n    A a = head();\r\n    for (List<A> xs = tail(); xs.isNotEmpty(); xs = xs.tail()) a = xs.head();\r\n    return a;\r\n}"
}, {
	"Path": "org.geoserver.cluster.hazelcast.HzSynchronizerTest.verify",
	"Comment": "verify all the mocks on this test class, plus those specified",
	"Method": "void verify(Object mocks){\r\n    EasyMock.verify(myMocks().toArray());\r\n    EasyMock.verify(mocks);\r\n}"
}, {
	"Path": "com.vaadin.shared.VBrowserDetails.setIEMode",
	"Comment": "sets the version for ie based on the documentmode. this is used to returnthe correct the correct ie version when the version from the user agentstring and the value of the documentmode property do not match.",
	"Method": "void setIEMode(int documentMode){\r\n    browserMajorVersion = documentMode;\r\n    browserMinorVersion = 0;\r\n    browserVersion = browserMajorVersion + \".\" + browserMinorVersion;\r\n}"
}, {
	"Path": "fj.F1W.streamK",
	"Comment": "promotes this function so that it returns its result in a stream. kleisli arrow for stream.",
	"Method": "F1W<A, Stream<B>> streamK(){\r\n    return lift(F1Functions.streamK(this));\r\n}"
}, {
	"Path": "fj.data.List.tails",
	"Comment": "returns the list of final segments of this list, longest first.",
	"Method": "List<List<A>> tails(){\r\n    return isEmpty() ? single(List.nil()) : cons(this, tail().tails());\r\n}"
}, {
	"Path": "fj.test.Property.minSize",
	"Comment": "checks this property using the given random generator, 100 minimumsuccessful checks, 500 maximum discarded tests, the given minimum size, maximum size of 100.",
	"Method": "CheckResult minSize(int minSize,CheckResult minSize,Rand r,int minSize){\r\n    return check(r, 100, 500, minSize, 100);\r\n}"
}, {
	"Path": "org.geoserver.cluster.impl.handlers.configuration.JMSGeoServerHandler.localizeGeoServerInfo",
	"Comment": "return the local geoserverinfo updating its member with the ones coming from the passedgeoserverinfo",
	"Method": "GeoServerInfo localizeGeoServerInfo(GeoServer geoServer,JMSGlobalModifyEvent ev){\r\n    if (geoServer == null || ev == null)\r\n        throw new IllegalArgumentException(\"Wrong passed arguments are null\");\r\n    final GeoServerInfo localObject = geoServer.getGlobal();\r\n    final GeoServerInfo deserGeoServerInfo = ev.getSource();\r\n    BeanUtils.copyProperties(localObject, deserGeoServerInfo);\r\n    org.geoserver.cluster.impl.utils.BeanUtils.smartUpdate(localObject, ev.getPropertyNames(), ev.getNewValues());\r\n    localObject.setCoverageAccess(localizeCoverageAccessInfo(geoServer, deserGeoServerInfo.getCoverageAccess()));\r\n    localObject.setJAI(localizeJAIInfo(geoServer, deserGeoServerInfo.getJAI()));\r\n    localObject.setSettings(localizeSettingsInfo(geoServer, deserGeoServerInfo.getSettings()));\r\n    return localObject;\r\n}"
}, {
	"Path": "org.geoserver.cluster.hazelcast.HzCluster.isSessionSharing",
	"Comment": "is session sharing enabled. only true if clustering in general is enabled.",
	"Method": "boolean isSessionSharing(){\r\n    return isEnabled() && Boolean.parseBoolean(getClusterConfig().getProperty(\"session_sharing\", \"true\"));\r\n}"
}, {
	"Path": "fj.data.Option.exists",
	"Comment": "returns true is this optional value has a value and the given predicate functionholds on that value, false otherwise.",
	"Method": "boolean exists(F<A, Boolean> f){\r\n    return isSome() && f.f(some());\r\n}"
}, {
	"Path": "fj.test.CheckResult.exhausted",
	"Comment": "returns a result that the property been exhausted in checking.",
	"Method": "CheckResult exhausted(int succeeded,int discarded){\r\n    return new CheckResult(R.Exhausted, Option.none(), Option.none(), succeeded, discarded);\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.reader.CatalogFileReader.readToEndFragment",
	"Comment": "read until the first endelement tag that matches the provided fragmentrootelementname. because there may be any number of tags in between wherethe reader is now and the fragment end tag, this is done in a loop until the element type and name match",
	"Method": "void readToEndFragment(QName fragmentRootElementName){\r\n    while (true) {\r\n        XMLEvent nextEvent = eventReader.nextEvent();\r\n        if (nextEvent.isEndElement() && fragmentRootElementName.equals(((EndElement) nextEvent).getName())) {\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.reader.CatalogReader.isSaveState",
	"Comment": "the flag that determines whether to save internal state for restarts.",
	"Method": "boolean isSaveState(){\r\n    return saveState;\r\n}"
}, {
	"Path": "org.acme.Ldap.initSchemaPartition",
	"Comment": "initialize the schema manager and add the schema partition to diectory service",
	"Method": "void initSchemaPartition(){\r\n    SchemaPartition schemaPartition = service.getSchemaService().getSchemaPartition();\r\n    LdifPartition ldifPartition = new LdifPartition();\r\n    String workingDirectory = service.getWorkingDirectory().getPath();\r\n    ldifPartition.setWorkingDirectory(workingDirectory + \"/schema\");\r\n    File schemaRepository = new File(workingDirectory, \"schema\");\r\n    SchemaLdifExtractor extractor = new DefaultSchemaLdifExtractor(new File(workingDirectory));\r\n    extractor.extractOrCopy(true);\r\n    schemaPartition.setWrappedPartition(ldifPartition);\r\n    SchemaLoader loader = new LdifSchemaLoader(schemaRepository);\r\n    SchemaManager schemaManager = new DefaultSchemaManager(loader);\r\n    service.setSchemaManager(schemaManager);\r\n    schemaManager.loadAllEnabled();\r\n    schemaPartition.setSchemaManager(schemaManager);\r\n    List<Throwable> errors = schemaManager.getErrors();\r\n    if (errors.size() != 0) {\r\n        throw new Exception(\"Schema load failed : \" + errors);\r\n    }\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.CheckBoxGroupElement.clear",
	"Comment": "clear operation is not supported for option group. this operation has noeffect on option group element.",
	"Method": "void clear(){\r\n    super.clear();\r\n}"
}, {
	"Path": "fj.data.Java.Option_ConcurrentLinkedQueue",
	"Comment": "a function that converts options to concurrent linked queues.",
	"Method": "F<Option<A>, ConcurrentLinkedQueue<A>> Option_ConcurrentLinkedQueue(){\r\n    return as -> new ConcurrentLinkedQueue(as.toCollection());\r\n}"
}, {
	"Path": "fj.Semigroup.lastOptionSemigroup",
	"Comment": "a semigroup for optional values that take the last available value.",
	"Method": "Semigroup<Option<A>> lastOptionSemigroup(){\r\n    return Monoid.<A>lastOptionMonoid().semigroup();\r\n}"
}, {
	"Path": "fj.test.Gen.filter",
	"Comment": "returns a generator that produces values that meet the given predicate.",
	"Method": "Gen<A> filter(F<A, Boolean> f){\r\n    return gen(curry((i, r) -> {\r\n        A a;\r\n        do {\r\n            a = gen(i, r);\r\n        } while (!f.f(a));\r\n        return a;\r\n    }));\r\n}"
}, {
	"Path": "fj.F1W.listK",
	"Comment": "promotes this function so that it returns its result in a list. kleisli arrow for list.",
	"Method": "F1W<A, List<B>> listK(){\r\n    return lift(F1Functions.listK(this));\r\n}"
}, {
	"Path": "fj.data.Tree.levels",
	"Comment": "provides a stream of the elements of the tree at each level, in level order.",
	"Method": "Stream<Stream<A>> levels(){\r\n    final F<Stream<Tree<A>>, Stream<Tree<A>>> flatSubForests = Stream.<Tree<A>, Tree<A>>bind_().f(compose(P1.__1(), Tree.subForest_()));\r\n    final F<Stream<Tree<A>>, Stream<A>> roots = Stream.<Tree<A>, A>map_().f(Tree.root_());\r\n    return iterateWhile(flatSubForests, Stream.isNotEmpty_(), single(this)).map(roots);\r\n}"
}, {
	"Path": "fj.data.DList.cons",
	"Comment": "prepends a single element on the dlist to produce a new dlist.",
	"Method": "DList<A> cons(A a){\r\n    return single(a).append(this);\r\n}"
}, {
	"Path": "fj.test.Arbitrary.arbConcurrentHashMap",
	"Comment": "returns an arbitrary implementation for concurrent hash maps.",
	"Method": "Gen<ConcurrentHashMap<K, V>> arbConcurrentHashMap(Gen<K> ak,Gen<V> av){\r\n    return arbHashtable(ak, av).map(ConcurrentHashMap::new);\r\n}"
}, {
	"Path": "fj.test.Gen.oneOf",
	"Comment": "returns a generator that produces values from one of the given generators on subsequentrequests.",
	"Method": "Gen<A> oneOf(List<Gen<A>> gs){\r\n    return gs.isEmpty() ? Gen.fail() : choose(0, gs.length() - 1).bind(gs::index);\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.TreeElement.isExpanded",
	"Comment": "returns whether the row at the given index is expanded or not.",
	"Method": "boolean isExpanded(int index){\r\n    WebElement expandElement = getExpandElement(index);\r\n    List<String> classes = Arrays.asList(expandElement.getAttribute(\"class\").split(\" \"));\r\n    return classes.contains(\"expanded\") && !classes.contains(\"collapsed\");\r\n}"
}, {
	"Path": "fj.test.Gen.wordOf",
	"Comment": "returns a generator of lists that picks the given number of elements from the given list. the selection isa permutation with replacement of elements from the given list, i.e.for any given selection, a generated list may contain its elements in any ordereach element may be picked more than onceif the given number is less than zero, then the returned generator will never produce a value. note that,with replacement, the given number may be larger than the length of the given list.",
	"Method": "Gen<List<A>> wordOf(int n,List<A> as){\r\n    Array<A> aArr = as.toArray();\r\n    return (n >= 0) ? pick(indexWord(n, aArr.length()), aArr) : fail();\r\n}"
}, {
	"Path": "fj.data.Stream.find",
	"Comment": "finds the first occurrence of an element that matches the given predicate or no value if noelements match.",
	"Method": "Option<A> find(F<A, Boolean> f){\r\n    for (Stream<A> as = this; as.isNotEmpty(); as = as.tail()._1()) {\r\n        if (f.f(as.head()))\r\n            return some(as.head());\r\n    }\r\n    return none();\r\n}"
}, {
	"Path": "fj.data.Java.Stream_CopyOnWriteArrayList",
	"Comment": "a function that converts streams to copy on write array lists.",
	"Method": "F<Stream<A>, CopyOnWriteArrayList<A>> Stream_CopyOnWriteArrayList(){\r\n    return as -> new CopyOnWriteArrayList(as.toCollection());\r\n}"
}, {
	"Path": "fj.data.NonEmptyList.zipIndex",
	"Comment": "zips this non empty list with the index of its element as a pair.",
	"Method": "NonEmptyList<P2<A, Integer>> zipIndex(){\r\n    final List<P2<A, Integer>> list = toList().zipIndex();\r\n    return nel(list.head(), list.tail());\r\n}"
}, {
	"Path": "fj.data.Stream.sort",
	"Comment": "sort this stream according to the given ordering, using a parallel quick sort algorithm that uses the givenparallelisation strategy.",
	"Method": "Stream<A> sort(Ord<A> o,Stream<A> sort,Ord<A> o,Strategy<Unit> s){\r\n    return qs(o, s).claim();\r\n}"
}, {
	"Path": "com.vaadin.tests.CustomLayoutDemo.setBody",
	"Comment": "set body panel caption, remove all existing components and add givencustom layout in it.",
	"Method": "void setBody(String customLayout){\r\n    VerticalLayout bodyLayout = new VerticalLayout();\r\n    bodyLayout.setMargin(true);\r\n    bodyLayout.addComponent(new CustomLayout(customLayout));\r\n    bodyPanel.setContent(bodyLayout);\r\n    bodyPanel.setCaption(customLayout + \".html\");\r\n}"
}, {
	"Path": "fj.F1W.onRight",
	"Comment": "returns a function that returns the right side of a given either, or this function applied to the left side.",
	"Method": "F1W<Either<A, B>, B> onRight(){\r\n    return lift(F1Functions.onRight(this));\r\n}"
}, {
	"Path": "fj.data.Validation.sequenceNonCumulative",
	"Comment": "if the list contains a failure, returns a validation of the list offails in the list, otherwise returns a successful validation withthe list of successful values.does not accumulate the failures into asingle failure using a semigroup.",
	"Method": "Validation<List<E>, List<A>> sequenceNonCumulative(List<Validation<E, A>> list){\r\n    if (list.exists(Validation::isFail)) {\r\n        F2<List<E>, Validation<E, A>, List<E>> f = (acc, v) -> acc.cons(v.fail());\r\n        return fail(list.filter(Validation::isFail).foldLeft(f, List.nil()).reverse());\r\n    } else {\r\n        F2<List<A>, Validation<E, A>, List<A>> f = (acc, v) -> acc.cons(v.success());\r\n        return success(list.filter(Validation::isSuccess).foldLeft(f, List.nil()).reverse());\r\n    }\r\n}"
}, {
	"Path": "fj.data.List.zipWith",
	"Comment": "zips this list with the given list using the given function to produce a new list. if this listand the given list have different lengths, then the longer list is normalised so this functionnever fails.",
	"Method": "List<C> zipWith(List<B> bs,F<A, F<B, C>> f,List<C> zipWith,List<B> bs,F2<A, B, C> f,F<List<A>, F<List<B>, F<F<A, F<B, C>>, List<C>>>> zipWith){\r\n    return curry((as, bs, f) -> as.zipWith(bs, f));\r\n}"
}, {
	"Path": "fj.control.parallel.Strategy.parMap1",
	"Comment": "a strict version of parmap over arrays.maps the given function over the given arrays in parallel using this strategy,blocking the current thread until all values have been obtained.",
	"Method": "List<A> parMap1(F<B, A> f,List<B> bs,Array<A> parMap1,F<B, A> f,Array<B> bs){\r\n    return compose(P1.__1(), parMapArray(f)).f(bs);\r\n}"
}, {
	"Path": "fj.data.NonEmptyList.zip",
	"Comment": "zips this non empty list with the given non empty list to produce a list of pairs. if this list and the given listhave different lengths, then the longer list is normalised so this function never fails.",
	"Method": "NonEmptyList<P2<A, B>> zip(NonEmptyList<B> bs){\r\n    final List<P2<A, B>> list = toList().zip(bs.toList());\r\n    return nel(list.head(), list.tail());\r\n}"
}, {
	"Path": "fj.Show.streamShow_",
	"Comment": "returns the transformation equivalent for the stream show.",
	"Method": "F<Stream<A>, Stream<Character>> streamShow_(Show<A> sa,String start,String sep,String end){\r\n    return as -> join(as.map(sa.show_()).intersperse(fromString(sep)).cons(fromString(start)).snoc(p(fromString(end))));\r\n}"
}, {
	"Path": "com.vaadin.tests.components.grid.GridInitiallyHiddenColumnsTest.getColumnHidingToggle",
	"Comment": "returns the toggle inside the sidebar for hiding the column at the givenindex, or null if not found.",
	"Method": "WebElement getColumnHidingToggle(GridElement grid,String caption){\r\n    WebElement sidebar = getSidebar(grid);\r\n    List<WebElement> elements = sidebar.findElements(By.className(\"column-hiding-toggle\"));\r\n    for (WebElement e : elements) {\r\n        if (caption.equalsIgnoreCase(e.getText())) {\r\n            return e;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "fj.F1W.eitherLeftK",
	"Comment": "promotes this function so that it returns its result on the left side of an either.kleisli arrow for the either left projection.",
	"Method": "F1W<A, Either<B, C>> eitherLeftK(){\r\n    return lift(F1Functions.eitherLeftK(this));\r\n}"
}, {
	"Path": "fj.data.Stream.replace",
	"Comment": "returns a new stream resulting from replacing all elements that match the given predicate with the given element.",
	"Method": "Stream<A> replace(F<A, Boolean> p,A a){\r\n    if (isEmpty())\r\n        return nil();\r\n    else {\r\n        final P2<Stream<A>, Stream<A>> s = span(p);\r\n        return s._1().append(cons(a, () -> s._2().tail()._1().replace(p, a)));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.backuprestore.utils.BackupUtils.geoServerTmpDir",
	"Comment": "returns a random temp folder resource inside the geoserver temp directory.",
	"Method": "Resource geoServerTmpDir(GeoServerDataDirectory geoServerDataDirectory){\r\n    String tempPath = geoServerDataDirectory.findOrCreateDir(\"temp\").getAbsolutePath();\r\n    return createRandomResource(tempPath);\r\n}"
}, {
	"Path": "com.vaadin.tests.tb3.AbstractTB3Test.getKeyboard",
	"Comment": "returns the keyboard object for controlling keyboard events",
	"Method": "Keyboard getKeyboard(){\r\n    return ((HasInputDevices) getDriver()).getKeyboard();\r\n}"
}, {
	"Path": "fj.test.Arbitrary.arbIdentityHashMap",
	"Comment": "returns an arbitrary implementation for identity hash maps.",
	"Method": "Gen<IdentityHashMap<K, V>> arbIdentityHashMap(Gen<K> ak,Gen<V> av){\r\n    return arbHashtable(ak, av).map(IdentityHashMap::new);\r\n}"
}, {
	"Path": "fj.Semigroup.monoid",
	"Comment": "constructs a monoid from this semigroup and a zero value, which must follow the monoidal laws.",
	"Method": "Monoid<A> monoid(A zero){\r\n    return monoidDef(this.def, zero);\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.GridElement.getHeaderCellByCaption",
	"Comment": "gets the header cell element with the given caption in the given headerrow. if there are multiple headers with the same name, the first one isreturned.",
	"Method": "GridCellElement getHeaderCellByCaption(String caption,GridCellElement getHeaderCellByCaption,int rowIndex,String caption){\r\n    List<GridCellElement> headerCells = getHeaderCells(rowIndex);\r\n    for (GridCellElement cell : headerCells) {\r\n        if (caption.equals(cell.getText())) {\r\n            return cell;\r\n        }\r\n    }\r\n    String errorMessage = String.format(\"The row with index %d does not have header with %s caption. \", rowIndex, caption);\r\n    throw new NoSuchElementException(errorMessage);\r\n}"
}, {
	"Path": "com.vaadin.testbench.elements.TreeElement.findCellContentFromRow",
	"Comment": "finds the rendered cell content from given row element. this expects therow to contain only a single column rendered with treerenderer.",
	"Method": "TestBenchElement findCellContentFromRow(WebElement rowElement){\r\n    return TestBenchElement.wrapElement(rowElement.findElement(By.className(\"gwt-HTML\")), getCommandExecutor());\r\n}"
}, {
	"Path": "fj.F1Functions.eitherLeftK",
	"Comment": "promotes this function so that it returns its result on the left side of an either.kleisli arrow for the either left projection.",
	"Method": "F<A, Either<B, C>> eitherLeftK(F<A, B> f){\r\n    return o(Either.left_(), f);\r\n}"
}, {
	"Path": "org.geoserver.wms.worldwind.util.BilWCSUtils.scale",
	"Comment": "scalinglet user to scale down to the exact needed resolution. this step does not prevent from havingloaded an overview of the original image based on the requested scale.",
	"Method": "GridCoverage2D scale(GridCoverage2D coverage,GridEnvelope newGridRange,GridCoverage sourceCoverage,CoordinateReferenceSystem sourceCRS,GeneralEnvelope destinationEnvelopeInSourceCRS){\r\n    GridGeometry2D scaledGridGeometry = new GridGeometry2D(newGridRange, (destinationEnvelopeInSourceCRS != null) ? destinationEnvelopeInSourceCRS : sourceCoverage.getEnvelope());\r\n    final ParameterValueGroup param = (ParameterValueGroup) processor.getOperation(\"Resample\").getParameters();\r\n    param.parameter(\"Source\").setValue(coverage);\r\n    param.parameter(\"CoordinateReferenceSystem\").setValue(sourceCRS);\r\n    param.parameter(\"GridGeometry\").setValue(scaledGridGeometry);\r\n    param.parameter(\"InterpolationType\").setValue(Interpolation.getInstance(Interpolation.INTERP_NEAREST));\r\n    final GridCoverage2D scaledGridCoverage = (GridCoverage2D) ((Resample) processor.getOperation(\"Resample\")).doOperation(param, hints);\r\n    return scaledGridCoverage;\r\n}"
}]