[{
	"Path": "org.geoserver.kml.KMLReflectorTest.testCoordinateShift",
	"Comment": "verify that when ge asks for coordinates larger than 180 we still manage gracefully",
	"Method": "void testCoordinateShift(){\r\n    Document document = getAsDOM(\"wms/kml?layers=\" + getLayerId(MockData.BASIC_POLYGONS) + \"&mode=download&bbox=150,-90,380,90\");\r\n    assertEquals(3, document.getElementsByTagName(\"Placemark\").getLength());\r\n}"
}, {
	"Path": "org.geoserver.util.XmlTestUtil.hasNode",
	"Comment": "match a document at least one of the nodes matched by the given xpath expression matches thegiven matcher.",
	"Method": "Matcher<Document> hasNode(String xPath,Matcher<Node> matcher,Matcher<Document> hasNode,String xPath){\r\n    return hasNode(xPath, any(Node.class));\r\n}"
}, {
	"Path": "org.geoserver.security.impl.DefaultResourceAccessManager.canAccessChild",
	"Comment": "returns true if the user can access the specified node, or one of the nodes below itthe specified nodes",
	"Method": "boolean canAccessChild(SecureTreeNode node,Authentication user,AccessMode mode){\r\n    if (node.canAccess(user, mode)) {\r\n        return true;\r\n    }\r\n    for (SecureTreeNode child : node.getChildren().values()) {\r\n        if (canAccessChild(child, user, mode)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.web.wicket.GeoServerTablePanel.sortLink",
	"Comment": "builds a sort link that will force sorting on a certain column, and flip it to the otherdirection when clicked again",
	"Method": "AjaxLink<S> sortLink(GeoServerDataProvider<T> dataProvider,ListItem<S> item){\r\n    return new AjaxLink<S>(\"link\", item.getModel()) {\r\n        private static final long serialVersionUID = -6180419488076488737L;\r\n        @Override\r\n        public void onClick(AjaxRequestTarget target) {\r\n            SortParam<?> currSort = dataProvider.getSort();\r\n            @SuppressWarnings(\"unchecked\")\r\n            Property<T> property = (Property<T>) getModelObject();\r\n            if (currSort == null || !property.getName().equals(currSort.getProperty())) {\r\n                dataProvider.setSort(new SortParam<Object>(property.getName(), true));\r\n            } else {\r\n                dataProvider.setSort(new SortParam<Object>(property.getName(), !currSort.isAscending()));\r\n            }\r\n            setSelection(false);\r\n            target.add(listContainer);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.geoserver.web.wicket.GeoServerTablePanel.sortLink",
	"Comment": "builds a sort link that will force sorting on a certain column, and flip it to the otherdirection when clicked again",
	"Method": "AjaxLink<S> sortLink(GeoServerDataProvider<T> dataProvider,ListItem<S> item){\r\n    SortParam<?> currSort = dataProvider.getSort();\r\n    @SuppressWarnings(\"unchecked\")\r\n    Property<T> property = (Property<T>) getModelObject();\r\n    if (currSort == null || !property.getName().equals(currSort.getProperty())) {\r\n        dataProvider.setSort(new SortParam<Object>(property.getName(), true));\r\n    } else {\r\n        dataProvider.setSort(new SortParam<Object>(property.getName(), !currSort.isAscending()));\r\n    }\r\n    setSelection(false);\r\n    target.add(listContainer);\r\n}"
}, {
	"Path": "org.geoserver.security.jdbc.config.JDBCConnectAuthProviderConfig.setConnectURL",
	"Comment": "the jdbc url with which to obtain a database connection with.",
	"Method": "void setConnectURL(String connectURL){\r\n    this.connectURL = connectURL;\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.DownloadUtilities.transformGeometry",
	"Comment": "reprojects the input geometry from its crs to the defined crs.",
	"Method": "Geometry transformGeometry(Geometry geometry,CoordinateReferenceSystem crs){\r\n    final CoordinateReferenceSystem geometryCRS = (CoordinateReferenceSystem) geometry.getUserData();\r\n    MathTransform targetTX = null;\r\n    if (!CRS.equalsIgnoreMetadata(geometryCRS, crs)) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Geometry CRS is not equal to the target CRS, we might have to reproject\");\r\n        }\r\n        try {\r\n            targetTX = CRS.findMathTransform(geometryCRS, crs, true);\r\n        } catch (Exception e) {\r\n            throw new IOException(e);\r\n        }\r\n        if (!targetTX.isIdentity()) {\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.log(Level.FINE, \"CRS transform is not an identity, we have to reproject the Geometry\");\r\n            }\r\n            try {\r\n                geometry = JTS.transform(geometry, targetTX);\r\n            } catch (Exception e) {\r\n                throw new IOException(e);\r\n            }\r\n            if (geometry == null) {\r\n                throw new IllegalStateException(\"The Region of Interest is null after going back to native CRS!\");\r\n            }\r\n            geometry.setUserData(crs);\r\n            // Check if the geometry is a Polygon or MultiPolygon\r\n            DownloadUtilities.checkPolygonROI(geometry);\r\n        }\r\n    }\r\n    return geometry;\r\n}"
}, {
	"Path": "org.geoserver.wfs.xml.NameSpaceTranslator.getPrefix",
	"Comment": "getprefix purpose.returns the prefix that this namespace represents.",
	"Method": "String getPrefix(){\r\n    return prefix;\r\n}"
}, {
	"Path": "org.geoserver.util.XmlTestUtil.hasNodes",
	"Comment": "match a document where the list of nodes selected by the given xpath expression also matchesthe given matcher.",
	"Method": "Matcher<Document> hasNodes(String xPath,Matcher<? extends Iterable<Node>> matcher){\r\n    return new BaseMatcher<Document>() {\r\n        @Override\r\n        public boolean matches(Object item) {\r\n            XpathEngine engine = XMLUnit.newXpathEngine();\r\n            engine.setNamespaceContext(namespaceContext);\r\n            try {\r\n                List<Node> nodes = nodeCollection(engine.getMatchingNodes(xPath, (Document) item));\r\n                return matcher.matches(nodes);\r\n            } catch (XpathException e) {\r\n                return false;\r\n            }\r\n        }\r\n        @Override\r\n        public void describeTo(Description description) {\r\n            description.appendText(\"Document where the list of nodes matching \").appendValue(xPath).appendText(\" is \").appendDescriptionOf(matcher);\r\n        }\r\n        @Override\r\n        public void describeMismatch(Object item, Description description) {\r\n            XpathEngine engine = XMLUnit.newXpathEngine();\r\n            engine.setNamespaceContext(namespaceContext);\r\n            try {\r\n                List<Node> nodes = nodeCollection(engine.getMatchingNodes(xPath, (Document) item));\r\n                matcher.describeMismatch(nodes, description);\r\n                if (showXML != null) {\r\n                    printDom((Document) item, showXML);\r\n                }\r\n            } catch (XpathException e) {\r\n                description.appendText(\"exception occured: \").appendText(e.getMessage());\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.geoserver.util.XmlTestUtil.hasNodes",
	"Comment": "match a document where the list of nodes selected by the given xpath expression also matchesthe given matcher.",
	"Method": "Matcher<Document> hasNodes(String xPath,Matcher<? extends Iterable<Node>> matcher){\r\n    XpathEngine engine = XMLUnit.newXpathEngine();\r\n    engine.setNamespaceContext(namespaceContext);\r\n    try {\r\n        List<Node> nodes = nodeCollection(engine.getMatchingNodes(xPath, (Document) item));\r\n        return matcher.matches(nodes);\r\n    } catch (XpathException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.util.XmlTestUtil.hasNodes",
	"Comment": "match a document where the list of nodes selected by the given xpath expression also matchesthe given matcher.",
	"Method": "Matcher<Document> hasNodes(String xPath,Matcher<? extends Iterable<Node>> matcher){\r\n    description.appendText(\"Document where the list of nodes matching \").appendValue(xPath).appendText(\" is \").appendDescriptionOf(matcher);\r\n}"
}, {
	"Path": "org.geoserver.util.XmlTestUtil.hasNodes",
	"Comment": "match a document where the list of nodes selected by the given xpath expression also matchesthe given matcher.",
	"Method": "Matcher<Document> hasNodes(String xPath,Matcher<? extends Iterable<Node>> matcher){\r\n    XpathEngine engine = XMLUnit.newXpathEngine();\r\n    engine.setNamespaceContext(namespaceContext);\r\n    try {\r\n        List<Node> nodes = nodeCollection(engine.getMatchingNodes(xPath, (Document) item));\r\n        matcher.describeMismatch(nodes, description);\r\n        if (showXML != null) {\r\n            printDom((Document) item, showXML);\r\n        }\r\n    } catch (XpathException e) {\r\n        description.appendText(\"exception occured: \").appendText(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.login",
	"Comment": "sets up the authentication context for the test.this context lasts only for a single test case, it is cleared after every test hascompleted.",
	"Method": "void login(String username,String password,String roles){\r\n    SecurityContextHolder.setContext(new SecurityContextImpl());\r\n    List<GrantedAuthority> l = new ArrayList<GrantedAuthority>();\r\n    for (String role : roles) {\r\n        l.add(new SimpleGrantedAuthority(role));\r\n    }\r\n    SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(username, password, l));\r\n}"
}, {
	"Path": "org.geoserver.csw.store.CatalogStoreCapabilities.supportsGetRepositoryItem",
	"Comment": "returns true if getrepositoryitem is supported on the specified type",
	"Method": "boolean supportsGetRepositoryItem(Name typeName){\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.csw.GetRecordsTest.testFullTextSearchCaseInsensitive",
	"Comment": "this one comes from the cite tests, like filters are to be applied in a case insensitivefashion",
	"Method": "void testFullTextSearchCaseInsensitive(){\r\n    String request = \"csw?service=CSW&version=2.0.2&request=GetRecords&typeNames=csw:Record&resultType=results&elementSetName=full&constraint=AnyText like '%lorem%'\";\r\n    Document d = getAsDOM(request);\r\n    checkValidationErrors(d, new CSWConfiguration());\r\n    assertXpathEvaluatesTo(\"full\", \"//csw:SearchResults/@elementSet\", d);\r\n    assertXpathEvaluatesTo(\"5\", \"//csw:SearchResults/@numberOfRecordsMatched\", d);\r\n    assertXpathEvaluatesTo(\"5\", \"//csw:SearchResults/@numberOfRecordsReturned\", d);\r\n    assertXpathEvaluatesTo(\"0\", \"//csw:SearchResults/@nextRecord\", d);\r\n    assertXpathEvaluatesTo(\"5\", \"count(//csw:SearchResults/*)\", d);\r\n    assertXpathEvaluatesTo(\"1\", \"count(//csw:Record[dc:identifier='urn:uuid:ab42a8c4-95e8-4630-bf79-33e59241605a'])\", d);\r\n    assertXpathEvaluatesTo(\"1\", \"count(//csw:Record[dc:identifier='urn:uuid:94bc9c83-97f6-4b40-9eb8-a8e8787a5c63'])\", d);\r\n    assertXpathEvaluatesTo(\"1\", \"count(//csw:Record[dc:identifier='urn:uuid:88247b56-4cbc-4df9-9860-db3f8042e357'])\", d);\r\n    assertXpathEvaluatesTo(\"1\", \"count(//csw:Record[dc:identifier='urn:uuid:19887a8a-f6b0-4a63-ae56-7fba0e17801f'])\", d);\r\n    assertXpathEvaluatesTo(\"1\", \"count(//csw:Record[dc:identifier='urn:uuid:a06af396-3105-442d-8b40-22b57a90d2f2'])\", d);\r\n}"
}, {
	"Path": "org.geoserver.wps.GetExecutionsTest.testGetExecutionsRequest",
	"Comment": "tests a process execution with a boudingbox as the output and check internal layer requesthandling as well",
	"Method": "void testGetExecutionsRequest(){\r\n    String request = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<wps:Execute version=\\\"1.0.0\\\" service=\\\"WPS\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns=\\\"http://www.opengis.net/wps/1.0.0\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\" xmlns:wps=\\\"http://www.opengis.net/wps/1.0.0\\\" xmlns:ows=\\\"http://www.opengis.net/ows/1.1\\\" xmlns:gml=\\\"http://www.opengis.net/gml\\\" xmlns:ogc=\\\"http://www.opengis.net/ogc\\\" xmlns:wcs=\\\"http://www.opengis.net/wcs/1.1.1\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" xsi:schemaLocation=\\\"http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd\\\">\\n\" + \"  <ows:Identifier>gs:Bounds<\/ows:Identifier>\\n\" + \"  <wps:DataInputs>\\n\" + \"    <wps:Input>\\n\" + \"      <ows:Identifier>features<\/ows:Identifier>\\n\" + \"      <wps:Reference mimeType=\\\"text/xml; subtype=wfs-collection/1.0\\\" xlink:href=\\\"http://geoserver/wfs\\\" method=\\\"POST\\\">\\n\" + \"        <wps:Body>\\n\" + \"          <wfs:GetFeature service=\\\"WFS\\\" version=\\\"1.0.0\\\">\\n\" + \"            <wfs:Query typeName=\\\"cite:Streams\\\"/>\\n\" + \"          <\/wfs:GetFeature>\\n\" + \"        <\/wps:Body>\\n\" + \"      <\/wps:Reference>\\n\" + \"    <\/wps:Input>\\n\" + \"  <\/wps:DataInputs>\\n\" + \"  <wps:ResponseForm>\\n\" + \"    <wps:RawDataOutput>\\n\" + \"      <ows:Identifier>bounds<\/ows:Identifier>\\n\" + \"    <\/wps:RawDataOutput>\\n\" + \"  <\/wps:ResponseForm>\\n\" + \"<\/wps:Execute>\";\r\n    Document dom = postAsDOM(root(), request);\r\n    assertXpathEvaluatesTo(\"-4.0E-4 -0.0024\", \"/ows:BoundingBox/ows:LowerCorner\", dom);\r\n    assertXpathEvaluatesTo(\"0.0036 0.0024\", \"/ows:BoundingBox/ows:UpperCorner\", dom);\r\n    dom = getAsDOM(root() + \"service=wps&version=1.0.0&request=GetExecutions\");\r\n    assertXpathEvaluatesTo(\"No Process Execution available.\", \"/ows:ExceptionReport/ows:Exception/ows:ExceptionText\", dom);\r\n    login(\"admin\", \"geoserver\", \"ROLE_ADMINISTRATOR\");\r\n    dom = getAsDOM(root() + \"service=wps&version=1.0.0&request=GetExecutions\");\r\n    assertXpathEvaluatesTo(\"1\", \"/wps:GetExecutionsResponse/@count\", dom);\r\n    assertXpathEvaluatesTo(\"gs:Bounds\", \"/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Process/ows:Identifier\", dom);\r\n    assertXpathEvaluatesTo(\"gs:Bounds\", \"/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Status/wps:Identifier\", dom);\r\n    assertXpathEvaluatesTo(\"SUCCEEDED\", \"/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Status/wps:Status\", dom);\r\n    assertXpathEvaluatesTo(\"100.0\", \"/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Status/wps:PercentCompleted\", dom);\r\n    login(\"afabiani\", \"geosolutions\", \"ROLE_AUTHENITCATED\");\r\n    dom = postAsDOM(root(), request);\r\n    dom = getAsDOM(root() + \"service=wps&version=1.0.0&request=GetExecutions\");\r\n    assertXpathEvaluatesTo(\"1\", \"/wps:GetExecutionsResponse/@count\", dom);\r\n    assertXpathEvaluatesTo(\"gs:Bounds\", \"/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Process/ows:Identifier\", dom);\r\n    assertXpathEvaluatesTo(\"afabiani\", \"/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Status/wps:Owner\", dom);\r\n    login(\"admin\", \"geoserver\", \"ROLE_ADMINISTRATOR\");\r\n    dom = getAsDOM(root() + \"service=wps&version=1.0.0&request=GetExecutions\");\r\n    assertXpathEvaluatesTo(\"2\", \"/wps:GetExecutionsResponse/@count\", dom);\r\n    dom = getAsDOM(root() + \"service=wps&version=1.0.0&request=GetExecutions&owner=afabiani\");\r\n    assertXpathEvaluatesTo(\"1\", \"/wps:GetExecutionsResponse/@count\", dom);\r\n    for (int i = 0; i < 3; i++) {\r\n        dom = postAsDOM(root(), request);\r\n    }\r\n    dom = getAsDOM(root() + \"service=wps&version=1.0.0&request=GetExecutions\");\r\n    assertXpathEvaluatesTo(\"5\", \"/wps:GetExecutionsResponse/@count\", dom);\r\n    dom = getAsDOM(root() + \"service=wps&version=1.0.0&request=GetExecutions&maxFeatures=2\");\r\n    assertXpathEvaluatesTo(\"5\", \"/wps:GetExecutionsResponse/@count\", dom);\r\n    assertXpathEvaluatesTo(\"\", \"/wps:GetExecutionsResponse/@previous\", dom);\r\n    assertXpathEvaluatesTo(\"/ows?service=wps&version=1.0.0&request=GetExecutions&maxFeatures=2&startIndex=2\", \"/wps:GetExecutionsResponse/@next\", dom);\r\n    dom = getAsDOM(root() + \"service=wps&version=1.0.0&request=GetExecutions&startIndex=1&maxFeatures=2\");\r\n    assertXpathEvaluatesTo(\"5\", \"/wps:GetExecutionsResponse/@count\", dom);\r\n    assertXpathEvaluatesTo(\"/ows?service=wps&version=1.0.0&request=GetExecutions&maxFeatures=2&startIndex=0\", \"/wps:GetExecutionsResponse/@previous\", dom);\r\n    assertXpathEvaluatesTo(\"/ows?service=wps&version=1.0.0&request=GetExecutions&maxFeatures=2&startIndex=3\", \"/wps:GetExecutionsResponse/@next\", dom);\r\n    dom = getAsDOM(root() + \"service=wps&version=1.0.0&request=GetExecutions&startIndex=3&maxFeatures=2\");\r\n    assertXpathEvaluatesTo(\"5\", \"/wps:GetExecutionsResponse/@count\", dom);\r\n    assertXpathEvaluatesTo(\"/ows?service=wps&version=1.0.0&request=GetExecutions&maxFeatures=2&startIndex=1\", \"/wps:GetExecutionsResponse/@previous\", dom);\r\n    assertXpathEvaluatesTo(\"\", \"/wps:GetExecutionsResponse/@next\", dom);\r\n    request = \"<wps:Execute version=\\\"1.0.0\\\" service=\\\"WPS\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns=\\\"http://www.opengis.net/wps/1.0.0\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\" xmlns:wps=\\\"http://www.opengis.net/wps/1.0.0\\\" xmlns:ows=\\\"http://www.opengis.net/ows/1.1\\\" xmlns:gml=\\\"http://www.opengis.net/gml\\\" xmlns:ogc=\\\"http://www.opengis.net/ogc\\\" xmlns:wcs=\\\"http://www.opengis.net/wcs/1.1.1\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" xsi:schemaLocation=\\\"http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd\\\">\\n\" + \"  <ows:Identifier>gs:RectangularClip<\/ows:Identifier>\\n\" + \"  <wps:DataInputs>\\n\" + \"    <wps:Input>\\n\" + \"      <ows:Identifier>features<\/ows:Identifier>\\n\" + \"      <wps:Reference mimeType=\\\"text/xml; subtype=wfs-collection/1.0\\\" xlink:href=\\\"http://geoserver/wfs\\\" method=\\\"POST\\\">\\n\" + \"        <wps:Body>\\n\" + \"          <wfs:GetFeature service=\\\"WFS\\\" version=\\\"1.0.0\\\">\\n\" + \"            <wfs:Query typeName=\\\"cite:Streams\\\"/>\\n\" + \"          <\/wfs:GetFeature>\\n\" + \"        <\/wps:Body>\\n\" + \"      <\/wps:Reference>\\n\" + \"    <\/wps:Input>\\n\" + \"    <wps:Input>\\n\" + \"      <ows:Identifier>clip<\/ows:Identifier>\\n\" + \"      <wps:Data>\\n\" + \"        <wps:BoundingBoxData crs=\\\"EPSG:4326\\\" dimensions=\\\"2\\\">\\n\" + \"          <ows:LowerCorner>-4.0E-4 -0.0024<\/ows:LowerCorner>\\n\" + \"          <ows:UpperCorner>0.0036 0.0024<\/ows:UpperCorner>\\n\" + \"        <\/wps:BoundingBoxData>\\n\" + \"      <\/wps:Data>\\n\" + \"    <\/wps:Input>\\n\" + \"    <wps:Input>\\n\" + \"      <ows:Identifier>preserveZ<\/ows:Identifier>\\n\" + \"      <wps:Data>\\n\" + \"        <wps:LiteralData>False<\/wps:LiteralData>\\n\" + \"      <\/wps:Data>\\n\" + \"    <\/wps:Input>\\n\" + \"  <\/wps:DataInputs>\\n\" + \"  <wps:ResponseForm>\\n\" + \"    <wps:ResponseDocument lineage=\\\"true\\\" storeExecuteResponse=\\\"true\\\" status=\\\"true\\\">\\n\" + \"      <wps:Output asReference=\\\"false\\\">\\n\" + \"        <ows:Identifier>result<\/ows:Identifier>\\n\" + \"      <\/wps:Output>\\n\" + \"    <\/wps:ResponseDocument>\\n\" + \"  <\/wps:ResponseForm>\\n\" + \"<\/wps:Execute>\";\r\n    dom = postAsDOM(root(), request);\r\n    assertXpathEvaluatesTo(\"Process accepted.\", \"/wps:ExecuteResponse/wps:Status/wps:ProcessAccepted\", dom);\r\n    login(\"admin\", \"geoserver\", \"ROLE_ADMINISTRATOR\");\r\n    dom = getAsDOM(root() + \"service=wps&version=1.0.0&request=GetExecutions\");\r\n    assertXpathEvaluatesTo(\"6\", \"/wps:GetExecutionsResponse/@count\", dom);\r\n    dom = getAsDOM(root() + \"service=wps&version=1.0.0&request=GetExecutions&identifier=gs:RectangularClip\");\r\n    assertXpathEvaluatesTo(\"1\", \"/wps:GetExecutionsResponse/@count\", dom);\r\n    assertXpathEvaluatesTo(\"3\", \"count(/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Status/wps:DataInputs/wps:Input)\", dom);\r\n    assertXpathEvaluatesTo(\"1\", \"count(/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Status/wps:DataInputs/wps:Input[ows:Identifier='features'])\", dom);\r\n    assertXpathEvaluatesTo(\"1\", \"count(/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Status/wps:DataInputs/wps:Input[ows:Identifier='clip'])\", dom);\r\n    assertXpathEvaluatesTo(\"1\", \"count(/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Status/wps:DataInputs/wps:Input[ows:Identifier='preserveZ'])\", dom);\r\n    assertXpathEvaluatesTo(\"-4.0E-4 -0.00240.0036 0.0024\", \"/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Status/wps:DataInputs/wps:Input[ows:Identifier='clip']/wps:BoundingBoxData\", dom);\r\n    assertXpathEvaluatesTo(\"-4.0E-4 -0.0024\", \"/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Status/wps:DataInputs/wps:Input[ows:Identifier='clip']/wps:BoundingBoxData/ows:LowerCorner\", dom);\r\n    assertXpathEvaluatesTo(\"0.0036 0.0024\", \"/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Status/wps:DataInputs/wps:Input[ows:Identifier='clip']/wps:BoundingBoxData/ows:UpperCorner\", dom);\r\n    assertXpathEvaluatesTo(\"False\", \"/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Status/wps:DataInputs/wps:Input[ows:Identifier='preserveZ']/wps:Data/wps:LiteralData\", dom);\r\n    request = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<wps:Execute version=\\\"1.0.0\\\" service=\\\"WPS\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns=\\\"http://www.opengis.net/wps/1.0.0\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\" xmlns:wps=\\\"http://www.opengis.net/wps/1.0.0\\\" xmlns:ows=\\\"http://www.opengis.net/ows/1.1\\\" xmlns:gml=\\\"http://www.opengis.net/gml\\\" xmlns:ogc=\\\"http://www.opengis.net/ogc\\\" xmlns:wcs=\\\"http://www.opengis.net/wcs/1.1.1\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" xsi:schemaLocation=\\\"http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd\\\">\\n\" + \"  <ows:Identifier>gs:Clip<\/ows:Identifier>\\n\" + \"  <wps:DataInputs>\\n\" + \"    <wps:Input>\\n\" + \"      <ows:Identifier>features<\/ows:Identifier>\\n\" + \"      <wps:Reference mimeType=\\\"text/xml\\\" xlink:href=\\\"http://geoserver/wfs\\\" method=\\\"POST\\\">\\n\" + \"        <wps:Body>\\n\" + \"          <wfs:GetFeature service=\\\"WFS\\\" version=\\\"1.0.0\\\" outputFormat=\\\"GML2\\\" xmlns:geonode=\\\"http://www.geonode.org/\\\">\\n\" + \"            <wfs:Query typeName=\\\"geonode:san_andres_y_providencia_administrative\\\"/>\\n\" + \"          <\/wfs:GetFeature>\\n\" + \"        <\/wps:Body>\\n\" + \"      <\/wps:Reference>\\n\" + \"    <\/wps:Input>\\n\" + \"    <wps:Input>\\n\" + \"      <ows:Identifier>clip<\/ows:Identifier>\\n\" + \"      <wps:Data>\\n\" + \"        <wps:ComplexData mimeType=\\\"application/json\\\"><![CDATA[{\\\"type\\\":\\\"MultiLineString\\\",\\\"coordinates\\\":[[[-81.8254,12.199],[-81.8162,12.1827],[-81.812,12.1653],[-81.8156,12.1465],[-81.8269,12.1321],[-81.8433,12.123],[-81.8614,12.119],[-81.8795,12.1232],[-81.8953,12.1336],[-81.9049,12.1494],[-81.9087,12.1673],[-81.9054,12.1864],[-81.8938,12.2004],[-81.8795,12.2089],[-81.8593,12.2136],[-81.8399,12.2096],[-81.8254,12.199]],[[-81.6565,12.635],[-81.6808,12.6391],[-81.7085,12.6262],[-81.739,12.6046],[-81.7611,12.5775],[-81.775,12.5397],[-81.7708,12.5207],[-81.7667,12.4971],[-81.7701,12.4748],[-81.7646,12.4504],[-81.739,12.4369],[-81.7022,12.4389],[-81.6835,12.4578],[-81.6794,12.4883],[-81.6676,12.5153],[-81.651,12.541],[-81.66,12.5552],[-81.6489,12.5762],[-81.6274,12.5931],[-81.6309,12.6181],[-81.6565,12.635]],[[-81.2954,13.3496],[-81.3004,13.3132],[-81.3143,13.29],[-81.3413,13.2755],[-81.3731,13.2674],[-81.4058,13.2657],[-81.4335,13.2633],[-81.4531,13.2771],[-81.4574,13.3079],[-81.4663,13.3257],[-81.463,13.3476],[-81.447,13.3674],[-81.4228,13.3879],[-81.412,13.4126],[-81.403,13.4375],[-81.391,13.4582],[-81.3674,13.4687],[-81.3503,13.4574],[-81.3205,13.448],[-81.2941,13.4177],[-81.2846,13.3878],[-81.2954,13.3496]],[[-79.9333,14.9856],[-79.9333,15.5028]]]}]]><\/wps:ComplexData>\\n\" + \"      <\/wps:Data>\\n\" + \"    <\/wps:Input>\\n\" + \"  <\/wps:DataInputs>\\n\" + \"  <wps:ResponseForm>\\n\" + \"    <wps:ResponseDocument lineage=\\\"true\\\" storeExecuteResponse=\\\"true\\\" status=\\\"true\\\">\\n\" + \"      <wps:Output asReference=\\\"false\\\">\\n\" + \"        <ows:Identifier>result<\/ows:Identifier>\\n\" + \"      <\/wps:Output>\\n\" + \"    <\/wps:ResponseDocument>\\n\" + \"  <\/wps:ResponseForm>\\n\" + \"<\/wps:Execute>\";\r\n    dom = postAsDOM(root(), request);\r\n    assertXpathEvaluatesTo(\"Process accepted.\", \"/wps:ExecuteResponse/wps:Status/wps:ProcessAccepted\", dom);\r\n    login(\"admin\", \"geoserver\", \"ROLE_ADMINISTRATOR\");\r\n    dom = getAsDOM(root() + \"service=wps&version=1.0.0&request=GetExecutions\");\r\n    assertXpathEvaluatesTo(\"7\", \"/wps:GetExecutionsResponse/@count\", dom);\r\n    dom = getAsDOM(root() + \"service=wps&version=1.0.0&request=GetExecutions&identifier=gs:Clip\");\r\n    assertXpathEvaluatesTo(\"1\", \"/wps:GetExecutionsResponse/@count\", dom);\r\n    assertXpathEvaluatesTo(\"<![CDATA[{\\\"type\\\":\\\"MultiLineString\\\",\\\"coordinates\\\":[[[-81.8254,12.199],[-81.8162,12.1827],[-81.812,12.1653],[-81.8156,12.1465],[-81.8269,12.1321],[-81.8433,12.123],[-81.8614,12.119],[-81.8795,12.1232],[-81.8953,12.1336],[-81.9049,12.1494],[-81.9087,12.1673],[-81.9054,12.1864],[-81.8938,12.2004],[-81.8795,12.2089],[-81.8593,12.2136],[-81.8399,12.2096],[-81.8254,12.199]],[[-81.6565,12.635],[-81.6808,12.6391],[-81.7085,12.6262],[-81.739,12.6046],[-81.7611,12.5775],[-81.775,12.5397],[-81.7708,12.5207],[-81.7667,12.4971],[-81.7701,12.4748],[-81.7646,12.4504],[-81.739,12.4369],[-81.7022,12.4389],[-81.6835,12.4578],[-81.6794,12.4883],[-81.6676,12.5153],[-81.651,12.541],[-81.66,12.5552],[-81.6489,12.5762],[-81.6274,12.5931],[-81.6309,12.6181],[-81.6565,12.635]],[[-81.2954,13.3496],[-81.3004,13.3132],[-81.3143,13.29],[-81.3413,13.2755],[-81.3731,13.2674],[-81.4058,13.2657],[-81.4335,13.2633],[-81.4531,13.2771],[-81.4574,13.3079],[-81.4663,13.3257],[-81.463,13.3476],[-81.447,13.3674],[-81.4228,13.3879],[-81.412,13.4126],[-81.403,13.4375],[-81.391,13.4582],[-81.3674,13.4687],[-81.3503,13.4574],[-81.3205,13.448],[-81.2941,13.4177],[-81.2846,13.3878],[-81.2954,13.3496]],[[-79.9333,14.9856],[-79.9333,15.5028]]]}]]\", \"/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Status/wps:DataInputs/wps:Input[ows:Identifier='clip']/wps:Data/wps:ComplexData\", dom);\r\n    request = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<wps:Execute version=\\\"1.0.0\\\" service=\\\"WPS\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns=\\\"http://www.opengis.net/wps/1.0.0\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\" xmlns:wps=\\\"http://www.opengis.net/wps/1.0.0\\\" xmlns:ows=\\\"http://www.opengis.net/ows/1.1\\\" xmlns:gml=\\\"http://www.opengis.net/gml\\\" xmlns:ogc=\\\"http://www.opengis.net/ogc\\\" xmlns:wcs=\\\"http://www.opengis.net/wcs/1.1.1\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" xsi:schemaLocation=\\\"http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd\\\">\\n\" + \"  <ows:Identifier>JTS:convexHull<\/ows:Identifier>\\n\" + \"  <wps:DataInputs>\\n\" + \"    <wps:Input>\\n\" + \"      <ows:Identifier>geom<\/ows:Identifier>\\n\" + \"      <wps:Reference mimeType=\\\"application/wkt\\\" xlink:href=\\\"http://www.pippo.it\\\" method=\\\"GET\\\"/>\\n\" + \"    <\/wps:Input>\\n\" + \"  <\/wps:DataInputs>\\n\" + \"  <wps:ResponseForm>\\n\" + \"    <wps:ResponseDocument lineage=\\\"true\\\" storeExecuteResponse=\\\"true\\\" status=\\\"true\\\">\\n\" + \"      <wps:Output asReference=\\\"false\\\">\\n\" + \"        <ows:Identifier>result<\/ows:Identifier>\\n\" + \"      <\/wps:Output>\\n\" + \"    <\/wps:ResponseDocument>\\n\" + \"  <\/wps:ResponseForm>\\n\" + \"<\/wps:Execute>\";\r\n    dom = postAsDOM(root(), request);\r\n    assertXpathEvaluatesTo(\"Process accepted.\", \"/wps:ExecuteResponse/wps:Status/wps:ProcessAccepted\", dom);\r\n    login(\"admin\", \"geoserver\", \"ROLE_ADMINISTRATOR\");\r\n    dom = getAsDOM(root() + \"service=wps&version=1.0.0&request=GetExecutions\");\r\n    assertXpathEvaluatesTo(\"8\", \"/wps:GetExecutionsResponse/@count\", dom);\r\n    dom = getAsDOM(root() + \"service=wps&version=1.0.0&request=GetExecutions&identifier=JTS:convexHull\");\r\n    assertXpathEvaluatesTo(\"1\", \"/wps:GetExecutionsResponse/@count\", dom);\r\n    assertXpathEvaluatesTo(\"http://www.pippo.it\", \"/wps:GetExecutionsResponse/wps:ExecuteResponse/wps:Status/wps:DataInputs/wps:Input[ows:Identifier='geom']/wps:Reference/@xlink:href\", dom);\r\n}"
}, {
	"Path": "org.geoserver.gwc.RESTIntegrationTest.testPutBadId",
	"Comment": "put creates a new layer, shall fail if the layer id is provided and not found in the catalog",
	"Method": "void testPutBadId(){\r\n    final String layerName = getLayerId(MockData.BASIC_POLYGONS);\r\n    final String url = \"gwc/rest/layers/\" + layerName + \".xml\";\r\n    MockHttpServletResponse response = putLayer(url, \"badId\", layerName);\r\n    assertThat(response, hasProperty(\"status\", equalTo(HttpServletResponse.SC_BAD_REQUEST)));\r\n    assertThat(response, hasProperty(\"contentAsString\", containsString(\"No GeoServer Layer or LayerGroup exists with id 'badId'\")));\r\n    assertThat(response, hasProperty(\"contentType\", startsWith(\"text/plain\")));\r\n}"
}, {
	"Path": "org.geoserver.wps.executor.ProcessStatusTracker.touch",
	"Comment": "custom method that updates the status last updated field without touching anything else, tomake sure we let the cluster know the process is still running",
	"Method": "void touch(String executionId){\r\n    ExecutionStatus status = store.get(executionId);\r\n    if (status != null) {\r\n        status.setLastUpdated(new Date());\r\n        store.save(status);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs3.OpenAPIBuilder.build",
	"Comment": "build the document based on request, current wfs configuration, and list of availableextensions",
	"Method": "OpenAPI build(BaseRequest request,WFSInfo wfs,List<WFS3Extension> extensions){\r\n    OpenAPI api = readTemplate();\r\n    ContactInfo contactInfo = wfs.getGeoServer().getGlobal().getSettings().getContact();\r\n    Contact contact = new Contact().email(contactInfo.getContactEmail()).name(Stream.of(contactInfo.getContactPerson(), contactInfo.getContactOrganization()).filter(s -> s != null).collect(Collectors.joining(\" - \"))).url(contactInfo.getOnlineResource());\r\n    String title = wfs.getTitle() == null ? \"WFS 3.0 server\" : wfs.getTitle();\r\n    String version = getGeoServerVersion();\r\n    Info info = new Info().contact(contact).title(title).description(wfs.getAbstract()).version(version);\r\n    api.info(info);\r\n    api.externalDocs(new ExternalDocumentation().description(\"WFS specification\").url(\"https://github.com/opengeospatial/WFS_FES\"));\r\n    String wfsUrl = ResponseUtils.buildURL(request.getBaseUrl(), \"wfs3\", null, URLMangler.URLType.SERVICE);\r\n    api.servers(Arrays.asList(new Server().description(\"This server\").url(wfsUrl)));\r\n    declareGetResponseFormats(api, \"/\", OpenAPI.class);\r\n    declareGetResponseFormats(api, \"/conformance\", ConformanceDocument.class);\r\n    declareGetResponseFormats(api, \"/collections\", CollectionsDocument.class);\r\n    declareGetResponseFormats(api, \"/collections/{collectionId}\", CollectionsDocument.class);\r\n    declareGetResponseFormats(api, \"/collections/{collectionId}/items\", FeatureCollectionResponse.class);\r\n    declareGetResponseFormats(api, \"/collections/{collectionId}/items/{featureId}\", FeatureCollectionResponse.class);\r\n    Map<String, Parameter> parameters = api.getComponents().getParameters();\r\n    Parameter collectionId = parameters.get(\"collectionId\");\r\n    Catalog catalog = wfs.getGeoServer().getCatalog();\r\n    List<String> validCollectionIds = catalog.getFeatureTypes().stream().map(ft -> NCNameResourceCodec.encode(ft)).collect(Collectors.toList());\r\n    collectionId.getSchema().setEnum(validCollectionIds);\r\n    Parameter limit = parameters.get(\"limit\");\r\n    BigDecimal limitMax;\r\n    if (wfs.getMaxFeatures() > 0) {\r\n        limitMax = BigDecimal.valueOf(wfs.getMaxFeatures());\r\n    } else {\r\n        limitMax = BigDecimal.valueOf(Integer.MAX_VALUE);\r\n    }\r\n    limit.getSchema().setMaximum(limitMax);\r\n    limit.getSchema().setDefault(limitMax);\r\n    for (WFS3Extension extension : extensions) {\r\n        extension.extendAPI(api);\r\n    }\r\n    return api;\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityProvider.createUserGroupService",
	"Comment": "creates a new user group service.if the extension does not provide a user group service this method should simply returnnull.",
	"Method": "GeoServerUserGroupService createUserGroupService(SecurityNamedServiceConfig config){\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDimensionsHelper.getDefaultValue",
	"Comment": "return the default value of the specified additional domain",
	"Method": "String getDefaultValue(String domainName){\r\n    if (additionalDimensions != null && !additionalDimensions.isEmpty() && additionalDimensions.containsKey(domainName)) {\r\n        return accessor.getCustomDomainDefaultValue(domainName);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.catalog.SLDNamedLayerRenameHelper.visitStyles",
	"Comment": "visit each style in the catalog and determine if any of them contain namedlayers ornamedstyles with the registered names that would need to be renamed. optionally, apply theserenames.",
	"Method": "List<StyleInfo> visitStyles(boolean doRename){\r\n    List<StyleInfo> stylesToUpdate = new ArrayList();\r\n    for (StyleInfo style : catalog.getStyles()) {\r\n        SLDNamedLayerRenameVisitor visitor = new SLDNamedLayerRenameVisitor(catalog, doRename);\r\n        try {\r\n            StyledLayerDescriptor sld = catalog.getResourcePool().getSld(style);\r\n            sld.accept(visitor);\r\n            if (visitor.needsRename) {\r\n                stylesToUpdate.add(style);\r\n                if (doRename) {\r\n                    backupStyle(style);\r\n                    catalog.getResourcePool().writeSLD(style, sld, true);\r\n                }\r\n            }\r\n        } catch (IOException | ServiceException e) {\r\n            if (skipErrors) {\r\n                LOGGER.log(Level.INFO, \"Skipping style '\" + style.getName() + \"'.\", e);\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    return stylesToUpdate;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.WCSEnvelope.isEmpty",
	"Comment": "returns true if the envelope has a empty span on at least one dimension. a span is empty ifits zero or negative, but in case a dimension is the longitude, a negative span will betreated as a dateline crossing, and thus treated as non empty",
	"Method": "boolean isEmpty(){\r\n    for (int i = 0; i < dimensions; i++) {\r\n        double span = getSpan(i);\r\n        if (span == 0) {\r\n            return true;\r\n        } else if (span < 0 && i != longitudeDimension) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.security.impl.DefaultResourceAccessManager.allowsAccessViaNonOpaqueGroup",
	"Comment": "returns true if there is a path from the group to the resource that does not involve crossinga opaque group",
	"Method": "boolean allowsAccessViaNonOpaqueGroup(LayerGroupInfo gi,ResourceInfo resource){\r\n    for (PublishedInfo pi : gi.getLayers()) {\r\n        if (pi instanceof LayerInfo) {\r\n            if (resource.equals(((LayerInfo) pi).getResource())) {\r\n                return true;\r\n            }\r\n        } else {\r\n            LayerGroupInfo lg = (LayerGroupInfo) pi;\r\n            if (lg.getMode() != LayerGroupInfo.Mode.OPAQUE_CONTAINER && allowsAccessViaNonOpaqueGroup(lg, resource)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.dxf.AbstractDXFWriter.getNewHandle",
	"Comment": "gets a new handle of the given type. the type is used to generate handles in differentnumeric spaces, for different entities.",
	"Method": "String getNewHandle(String type){\r\n    int currentHandle = handles.get(type);\r\n    String handle = Integer.toHexString(currentHandle).toUpperCase();\r\n    currentHandle++;\r\n    handles.put(type, currentHandle);\r\n    return handle;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.WCSEnvelope.isLongitude",
	"Comment": "returns true if the specified dimension index is matching the longitude axis",
	"Method": "boolean isLongitude(int dimension){\r\n    return longitudeDimension == dimension;\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaTestSupport.getNamespaces",
	"Comment": "returns the map of namespace prefix to uri configured in the test data.",
	"Method": "Map<String, String> getNamespaces(){\r\n    return getTestData().getNamespaces();\r\n}"
}, {
	"Path": "org.geoserver.security.impl.LayerGroupContainmentCache.getContainerGroupsFor",
	"Comment": "returns all groups containing directly or indirectly containing the resource",
	"Method": "Collection<LayerGroupSummary> getContainerGroupsFor(ResourceInfo resource,Collection<LayerGroupSummary> getContainerGroupsFor,LayerGroupInfo lg){\r\n    String id = lg.getId();\r\n    if (id == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    LayerGroupSummary summary = groupCache.get(id);\r\n    if (summary == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    Set<LayerGroupSummary> result = new HashSet();\r\n    for (LayerGroupSummary container : summary.getContainerGroups()) {\r\n        collectContainers(container, result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.wcs.DefaultWebCoverageService111.getDeclaredFormat",
	"Comment": "checks if the supported format string list contains the specified format, doing a caseinsensitive search. if found the declared output format name is returned, otherwise null isreturned.",
	"Method": "String getDeclaredFormat(List supportedFormats,String format){\r\n    for (Iterator it = supportedFormats.iterator(); it.hasNext(); ) {\r\n        String sf = (String) it.next();\r\n        if (sf.equalsIgnoreCase(format)) {\r\n            return sf;\r\n        } else {\r\n            CoverageResponseDelegate delegate = responseFactory.encoderFor(sf);\r\n            if (delegate != null && delegate.canProduce(format))\r\n                return sf;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.vfny.geoserver.servlets.SpeedStrategy.getDestination",
	"Comment": "works against the real output stream provided by the response.this is dangerous of course, but fast and exciting.",
	"Method": "DispatcherOutputStream getDestination(HttpServletResponse response){\r\n    out = response.getOutputStream();\r\n    return new DispatcherOutputStream(out);\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.IsolatedCatalogFacade.enforceLayerGroupIsolation",
	"Comment": "checks if the provided layer group is visible in the current context. note that layer groupcontained layer groups will not be filtered.",
	"Method": "T enforceLayerGroupIsolation(T layerGroup){\r\n    if (layerGroup == null) {\r\n        return null;\r\n    }\r\n    WorkspaceInfo workspace = layerGroup.getWorkspace();\r\n    return canSeeWorkspace(workspace) ? layerGroup : null;\r\n}"
}, {
	"Path": "org.geoserver.gwc.GWC.reload",
	"Comment": "reloads the configuration and notifies gwc of any externally removed layer.",
	"Method": "void reload(){\r\n    final Set<String> currLayerNames = new HashSet<String>(getTileLayerNames());\r\n    try {\r\n        tld.reInit();\r\n    } catch (RuntimeException e) {\r\n        log.log(Level.WARNING, \"Unable to reinit TileLayerDispatcher\", e);\r\n        throw e;\r\n    }\r\n    Set<String> newLayerNames = getTileLayerNames();\r\n    SetView<String> removedExternally = Sets.difference(currLayerNames, newLayerNames);\r\n    for (String removedLayerName : removedExternally) {\r\n        log.info(\"Notifying of TileLayer '\" + removedLayerName + \"' removed externally\");\r\n        layerRemoved(removedLayerName);\r\n    }\r\n    try {\r\n        DiskQuotaMonitor monitor = getDiskQuotaMonitor();\r\n        monitor.reloadConfig();\r\n        ConfigurableQuotaStoreProvider provider = (ConfigurableQuotaStoreProvider) monitor.getQuotaStoreProvider();\r\n        provider.reloadQuotaStore();\r\n        monitor.shutDown(1);\r\n        monitor.startUp();\r\n    } catch (Exception e) {\r\n        log.log(Level.SEVERE, \"Failed to reload the disk quoa configuration\", e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.GeoTIFFCoverageResponseDelegate.handleInterleaving",
	"Comment": "handle interleaving encoding parameters for wcs.notice that the tiff imagewriter supports only pixel interleaving.",
	"Method": "void handleInterleaving(Map<String, String> encondingParameters,GridCoverage2D sourceCoverage,GeoTiffWriterHelper writerHelper){\r\n    if (encondingParameters.containsKey(\"interleave\")) {\r\n        final String interleavingS = encondingParameters.get(\"interleave\");\r\n        if (interleavingS.equals(\"pixel\") || interleavingS.equals(\"Pixel\")) {\r\n        } else if (interleavingS.equals(\"band\") || interleavingS.equals(\"Band\")) {\r\n            throw new OWS20Exception(\"Banded Interleaving not supported\", ows20Code(WcsExceptionCode.InterleavingNotSupported), interleavingS);\r\n        } else {\r\n            throw new OWS20Exception(\"Invalid Interleaving type provided\", ows20Code(WcsExceptionCode.InterleavingInvalid), interleavingS);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.store.AbstractMappingStore.buildDefaultSort",
	"Comment": "builds the default sort for the underlying feature source query",
	"Method": "SortBy[] buildDefaultSort(FeatureType schema){\r\n    String timeStart = propertyMapper.getSourceName(\"timeStart\");\r\n    String identifier = propertyMapper.getSourceName(\"identifier\");\r\n    return new SortBy[] { FF.sort(timeStart, SortOrder.DESCENDING), FF.sort(identifier, SortOrder.ASCENDING) };\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.DownloadProcessTest.testDownloadEstimatorWriteLimitsRaster",
	"Comment": "test download estimator write limits raster. the result should exceed the limits",
	"Method": "void testDownloadEstimatorWriteLimitsRaster(){\r\n    DownloadEstimatorProcess limits = new DownloadEstimatorProcess(new StaticDownloadServiceConfiguration(new DownloadServiceConfiguration(DownloadServiceConfiguration.NO_LIMIT, DownloadServiceConfiguration.NO_LIMIT, 10, 10, DownloadServiceConfiguration.DEFAULT_COMPRESSION_LEVEL, DownloadServiceConfiguration.NO_LIMIT)), getGeoServer());\r\n    final WPSResourceManager resourceManager = getResourceManager();\r\n    DownloadProcess downloadProcess = new DownloadProcess(getGeoServer(), limits, resourceManager);\r\n    Polygon roi = (Polygon) new WKTReader2().read(\"POLYGON (( -127.57473954542964 54.06575021619523, -130.88669845369998 52.00807146727025, -129.50812897394974 49.85372324691927, -130.5300633861675 49.20465679591609, -129.25955033314003 48.60392508062591, -128.00975216684665 50.986137055052474, -125.8623089087404 48.63154492960477, -123.984159178178 50.68231871628503, -126.91186316993704 52.15307567440926, -125.3444367403868 53.54787804784162, -127.57473954542964 54.06575021619523 ))\");\r\n    roi.setSRID(4326);\r\n    try {\r\n        // layerName\r\n        downloadProcess.execute(getLayerId(MockData.USA_WORLDIMG), null, \"image/tiff\", null, CRS.decode(\"EPSG:4326\", true), roi, true, null, null, null, null, null, new NullProgressListener());\r\n        Assert.assertFalse(true);\r\n    } catch (ProcessException e) {\r\n        Assert.assertEquals(\"org.geotools.process.ProcessException: java.io.IOException: Download Exceeded the maximum HARD allowed size!: java.io.IOException: Download Exceeded the maximum HARD allowed size!\", e.getMessage() + (e.getCause() != null ? \": \" + e.getCause().getMessage() : \"\"));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerResourcePersister.uniqueResource",
	"Comment": "determine unique name of the form newname.extension. newname will have a numberappended as required to produce a unique resource name.",
	"Method": "Resource uniqueResource(Resource resource,String newName,String extension){\r\n    Resource target = resource.parent().get(newName + \".\" + extension);\r\n    int i = 0;\r\n    while (target.getType() != Type.UNDEFINED && ++i <= MAX_RENAME_ATTEMPTS) {\r\n        target = resource.parent().get(newName + i + \".\" + extension);\r\n    }\r\n    if (i > MAX_RENAME_ATTEMPTS) {\r\n        throw new IOException(\"All target files between \" + newName + \"1.\" + extension + \" and \" + newName + MAX_RENAME_ATTEMPTS + \".\" + extension + \" are in use already, giving up\");\r\n    }\r\n    return target;\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.support.GSFixtureUtilitiesDelegate.printSkipNotice",
	"Comment": "print a notice that tests are being skipped, identifying the property file whose absence isresponsible.",
	"Method": "void printSkipNotice(String fixtureId,File fixtureFile){\r\n    FixtureUtilities.printSkipNotice(fixtureId, fixtureFile);\r\n}"
}, {
	"Path": "org.geoserver.test.StationsMockData.buildXpathEngine",
	"Comment": "helper method that builds a xpath engine that will use the provided gml namespaces.",
	"Method": "XpathEngine buildXpathEngine(Map<String, String> baseNamespaces,String namespaces){\r\n    XpathEngine xpathEngine = XMLUnit.newXpathEngine();\r\n    Map<String, String> finalNamespaces = new HashMap();\r\n    finalNamespaces.put(\"ows\", \"http://www.opengis.net/ows\");\r\n    finalNamespaces.put(\"ogc\", \"http://www.opengis.net/ogc\");\r\n    finalNamespaces.put(\"xs\", \"http://www.w3.org/2001/XMLSchema\");\r\n    finalNamespaces.put(\"xsd\", \"http://www.w3.org/2001/XMLSchema\");\r\n    finalNamespaces.put(\"xlink\", \"http://www.w3.org/1999/xlink\");\r\n    finalNamespaces.put(\"xsi\", \"http://www.w3.org/2001/XMLSchema-instance\");\r\n    finalNamespaces.putAll(baseNamespaces);\r\n    if (namespaces.length % 2 != 0) {\r\n        throw new RuntimeException(\"Invalid number of namespaces provided.\");\r\n    }\r\n    for (int i = 0; i < namespaces.length; i += 2) {\r\n        finalNamespaces.put(namespaces[i], namespaces[i + 1]);\r\n    }\r\n    xpathEngine.setNamespaceContext(new SimpleNamespaceContext(finalNamespaces));\r\n    return xpathEngine;\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.DownloadProcessTest.testDownloadRasterSelectedBands",
	"Comment": "test download of selected bands of raster data. result contains only bands 0 and 2.",
	"Method": "void testDownloadRasterSelectedBands(){\r\n    DownloadEstimatorProcess limits = new DownloadEstimatorProcess(new StaticDownloadServiceConfiguration(), getGeoServer());\r\n    final WPSResourceManager resourceManager = getResourceManager();\r\n    DownloadProcess downloadProcess = new DownloadProcess(getGeoServer(), limits, resourceManager);\r\n    File rasterZip = // layerName\r\n    downloadProcess.execute(getLayerId(MockData.USA_WORLDIMG), null, \"image/tiff\", null, CRS.decode(\"EPSG:4326\", true), null, false, null, null, null, new int[] { 0, 2 }, null, new NullProgressListener());\r\n    Assert.assertNotNull(rasterZip);\r\n    GeoTiffReader reader = null;\r\n    GridCoverage2D gc = null;\r\n    try {\r\n        final File[] tiffFiles = extractFiles(rasterZip, \"GTIFF\");\r\n        Assert.assertNotNull(tiffFiles);\r\n        Assert.assertTrue(tiffFiles.length > 0);\r\n        reader = new GeoTiffReader(tiffFiles[0]);\r\n        gc = reader.read(null);\r\n        Assert.assertNotNull(gc);\r\n        Assert.assertEquals(2, gc.getNumSampleDimensions());\r\n        Assert.assertEquals(0, CoverageUtilities.getVisibleBand(gc));\r\n        Assert.assertNotEquals(3, gc.getNumSampleDimensions());\r\n    } finally {\r\n        if (gc != null) {\r\n            CoverageCleanerCallback.disposeCoverage(gc);\r\n        }\r\n        if (reader != null) {\r\n            reader.dispose();\r\n        }\r\n        resourceManager.finished(resourceManager.getExecutionId(true));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.csw.DescribeRecordTest.testDummyRecord",
	"Comment": "this is one of the cite tests, unknown type names should just be ignored",
	"Method": "void testDummyRecord(){\r\n    Document dom = getAsDOM(\"csw?service=CSW&version=2.0.2&request=DescribeRecord&typeName=csw:DummyRecord\");\r\n    checkValidationErrors(dom);\r\n    print(dom);\r\n    assertXpathEvaluatesTo(\"1\", \"count(/csw:DescribeRecordResponse)\", dom);\r\n    assertXpathEvaluatesTo(\"0\", \"count(//csw:SchemaComponent)\", dom);\r\n}"
}, {
	"Path": "org.geoserver.web.wicket.EnvelopePanel.getCoordinateReferenceSystem",
	"Comment": "returns the coordinate reference system added by the user in the gui, if any and valid",
	"Method": "CoordinateReferenceSystem getCoordinateReferenceSystem(){\r\n    return crs;\r\n}"
}, {
	"Path": "org.geoserver.gwc.GWC.removeTileLayers",
	"Comment": "completely and persistently eliminates, including the cached contents, the given tile layers.",
	"Method": "void removeTileLayers(List<String> tileLayerNames){\r\n    checkNotNull(tileLayerNames);\r\n    for (String tileLayerName : tileLayerNames) {\r\n        try {\r\n            tld.removeLayer(tileLayerName);\r\n        } catch (IllegalArgumentException e) {\r\n            log.log(Level.WARNING, \"Error saving GWC Configuration \" + tld.getConfiguration(tileLayerName).getIdentifier(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.CascadeRemovalReporter.getObjects",
	"Comment": "returns the objects that will be affected by the removal, filtering them by type and by kindof modification they will sustain as a consequence of the removal",
	"Method": "List<T> getObjects(Class<T> catalogClass,ModificationType modifications){\r\n    List<T> result = new ArrayList<T>();\r\n    List<ModificationType> mods = (modifications == null || modifications.length == 0) ? null : Arrays.asList(modifications);\r\n    for (CatalogInfo ci : objects.keySet()) {\r\n        if (catalogClass == null || catalogClass.isAssignableFrom(ci.getClass())) {\r\n            if (mods == null || mods.contains(objects.get(ci)))\r\n                result.add((T) ci);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.vfny.geoserver.global.xml.NameSpaceTranslator.getElements",
	"Comment": "getelements purpose.returns a set of all elements with the exact class specified.",
	"Method": "Set getElements(Set getElements,Class type){\r\n    if (type == null) {\r\n        return null;\r\n    }\r\n    HashSet r = new HashSet();\r\n    Set elems = getElements();\r\n    Iterator i = elems.iterator();\r\n    while (i.hasNext()) {\r\n        NameSpaceElement nse = (NameSpaceElement) i.next();\r\n        if ((nse != null) && type.equals(nse.getJavaClass())) {\r\n            r.add(nse);\r\n        }\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "org.geoserver.ows.Response.getHeaders",
	"Comment": "returns a 2xn array of strings, each of which is an http header pair to be set on the httpresponse. can return null if there are no headers to be set on the response.",
	"Method": "String[][] getHeaders(Object value,Operation operation){\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.rest.util.RESTUtils.loadMapfromWorkSpace",
	"Comment": "this method is used for extracting the metadata map from the selected workspace",
	"Method": "MetadataMap loadMapfromWorkSpace(String workspaceName,Catalog catalog){\r\n    WorkspaceInfo wsInfo = catalog.getWorkspaceByName(workspaceName);\r\n    if (wsInfo != null) {\r\n        GeoServer gs = GeoServerExtensions.bean(GeoServer.class);\r\n        SettingsInfo info = gs.getSettings(wsInfo);\r\n        return info != null ? info.getMetadata() : null;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityFilterChain.insertLast",
	"Comment": "inserts a filter as the last of the filter list corresponding to the specified pattern.",
	"Method": "boolean insertLast(String pattern,String filterName){\r\n    RequestFilterChain requestChain = findAndCheck(pattern, filterName);\r\n    if (requestChain == null) {\r\n        return false;\r\n    }\r\n    return requestChain.getFilterNames().add(filterName);\r\n}"
}, {
	"Path": "org.geoserver.security.impl.GeoServerUserDao.serializeUser",
	"Comment": "turns the users password, granted authorities and enabled state into a property file value",
	"Method": "String serializeUser(User user){\r\n    StringBuffer sb = new StringBuffer();\r\n    sb.append(user.getPassword());\r\n    sb.append(\",\");\r\n    for (GrantedAuthority ga : user.getAuthorities()) {\r\n        sb.append(ga.getAuthority());\r\n        sb.append(\",\");\r\n    }\r\n    sb.append(user.isEnabled() ? \"enabled\" : \"disabled\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.geoserver.wfs.GetFeatureTest.testRequestDisabledStore",
	"Comment": "test that a request for a resource from a disabled store fails.",
	"Method": "void testRequestDisabledStore(){\r\n    Catalog catalog = getCatalog();\r\n    StoreInfo store = catalog.getStoreByName(\"cdf\", DataStoreInfo.class);\r\n    try {\r\n        store.setEnabled(false);\r\n        catalog.save(store);\r\n        Document doc = getAsDOM(\"wfs?service=WFS&version=1.0.0&request=GetFeature&typename=cdf:Fifteen\");\r\n        XMLAssert.assertXpathEvaluatesTo(\"1\", \"count(//ogc:ServiceException)\", doc);\r\n        XMLAssert.assertXpathEvaluatesTo(\"InvalidParameterValue\", \"//ogc:ServiceException/@code\", doc);\r\n        XMLAssert.assertXpathEvaluatesTo(\"typeName\", \"//ogc:ServiceException/@locator\", doc);\r\n    } finally {\r\n        store.setEnabled(true);\r\n        catalog.save(store);\r\n    }\r\n}"
}, {
	"Path": "org.vfny.geoserver.global.Log4JFormatter.format",
	"Comment": "format the given log record and return the formatted string.",
	"Method": "String format(LogRecord record){\r\n    String logger = record.getLoggerName();\r\n    final String recordLevel = record.getLevel().getLocalizedName();\r\n    try {\r\n        buffer.setLength(1);\r\n        final Long millis = new Long(record.getMillis() - startMillis);\r\n        writer.write(millis.toString());\r\n        writer.write(\" \");\r\n        writer.write(PREFIX);\r\n        writer.write(recordLevel);\r\n        writer.write(SUFFIX);\r\n        if (record.getSourceClassName() != null) {\r\n            writer.write(record.getSourceClassName());\r\n        }\r\n        writer.write(\" - \");\r\n        writer.setLineSeparator(bodyLineSeparator);\r\n        if (record.getMessage() == null) {\r\n            record.setMessage(\"null\");\r\n        }\r\n        writer.write(formatMessage(record));\r\n        writer.setLineSeparator(lineSeparator);\r\n        writer.write('\\n');\r\n        if (record.getThrown() != null) {\r\n            try {\r\n                writer.write(getStackTrace(record.getThrown()));\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        writer.flush();\r\n    } catch (IOException exception) {\r\n        throw new AssertionError(exception);\r\n    }\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "org.geoserver.test.FeatureChainingWfsTest.testDenormalisedFeaturesCount",
	"Comment": "test that denormalized data reports the correct number of features",
	"Method": "void testDenormalisedFeaturesCount(){\r\n    Document doc = getAsDOM(\"wfs?request=GetFeature&version=1.1.0&typename=gsml:GeologicUnit&maxFeatures=3\");\r\n    LOGGER.info(\"WFS GetFeature&typename=gsml:GeologicUnit&maxFeatures=3 response:\\n\" + prettyString(doc));\r\n    assertXpathCount(3, \"//gsml:GeologicUnit\", doc);\r\n    String id = \"gu.25678\";\r\n    assertXpathEvaluatesTo(id, \"(//gsml:GeologicUnit)[1]/@gml:id\", doc);\r\n    id = \"gu.25682\";\r\n    assertXpathEvaluatesTo(id, \"(//gsml:GeologicUnit)[2]/@gml:id\", doc);\r\n    id = \"gu.25699\";\r\n    assertXpathEvaluatesTo(id, \"(//gsml:GeologicUnit)[3]/@gml:id\", doc);\r\n}"
}, {
	"Path": "org.geoserver.filter.function.QueryLayerFunctionFactory.setMaxCoordinates",
	"Comment": "sets the maximum number of coordinates to be collected, a non positive value implies no limit",
	"Method": "void setMaxCoordinates(long maxCoordinates){\r\n    this.maxCoordinates = maxCoordinates;\r\n}"
}, {
	"Path": "org.geoserver.kml.regionate.ExternalSortRegionatingStrategy.getSortAttributeValue",
	"Comment": "returns the value that will be inserted into the h2 index as the sorting field",
	"Method": "Object getSortAttributeValue(SimpleFeature f){\r\n    return f.getAttribute(attribute);\r\n}"
}, {
	"Path": "org.geoserver.cluster.JmsEventsListener.getMessagesByHandlerKey",
	"Comment": "blocking helper method that allows us to wait for certain messages in a certain time. thestop method will be used to check if we have all the messages we need. only messages thatmatch one of the provided handlers keys will be selected.",
	"Method": "List<Message> getMessagesByHandlerKey(int timeoutMs,Function<List<Message>, Boolean> stop,String keys){\r\n    List<String> keysList = Arrays.asList(keys);\r\n    return JmsEventsListener.getMessages(timeoutMs, stop, (message) -> {\r\n        try {\r\n            String handlerKey = message.getStringProperty(JMSEventHandlerSPI.getKeyName());\r\n            if (keysList.contains(handlerKey)) {\r\n                return Status.SELECT_CONTINUE;\r\n            }\r\n        } catch (Exception exception) {\r\n        }\r\n        return Status.REJECT_CONTINUE;\r\n    });\r\n}"
}, {
	"Path": "org.geoserver.web.demo.PreviewLayerProvider.filteredItems",
	"Comment": "returns the requested page of layer objects after applying any keyword filtering set on thepage",
	"Method": "Iterator<PreviewLayer> filteredItems(long first,long count){\r\n    final Catalog catalog = getCatalog();\r\n    final SortParam sort = getSort();\r\n    final Property<PreviewLayer> property = getProperty(sort);\r\n    SortBy sortOrder = null;\r\n    if (sort != null) {\r\n        if (property instanceof BeanProperty) {\r\n            final String sortProperty = ((BeanProperty<PreviewLayer>) property).getPropertyPath();\r\n            sortOrder = sortBy(sortProperty, sort.isAscending());\r\n        } else if (property == NAME) {\r\n            sortOrder = sortBy(\"prefixedName\", sort.isAscending());\r\n        }\r\n    }\r\n    Filter filter = getFilter();\r\n    CloseableIterator<PublishedInfo> pi = catalog.list(PublishedInfo.class, filter, (int) first, (int) count, sortOrder);\r\n    return CloseableIteratorAdapter.transform(pi, new Function<PublishedInfo, PreviewLayer>() {\r\n        @Override\r\n        public PreviewLayer apply(PublishedInfo input) {\r\n            if (input instanceof LayerInfo) {\r\n                return new PreviewLayer((LayerInfo) input);\r\n            } else if (input instanceof LayerGroupInfo) {\r\n                return new PreviewLayer((LayerGroupInfo) input);\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.geoserver.web.demo.PreviewLayerProvider.filteredItems",
	"Comment": "returns the requested page of layer objects after applying any keyword filtering set on thepage",
	"Method": "Iterator<PreviewLayer> filteredItems(long first,long count){\r\n    if (input instanceof LayerInfo) {\r\n        return new PreviewLayer((LayerInfo) input);\r\n    } else if (input instanceof LayerGroupInfo) {\r\n        return new PreviewLayer((LayerGroupInfo) input);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.script.ScriptManager.findAppDir",
	"Comment": "finds a named app dir, returning null if the directory does not exist.",
	"Method": "File findAppDir(String app){\r\n    return app(app).dir();\r\n}"
}, {
	"Path": "org.geoserver.kml.GeoSearchKMLTest.testDuplicateAttribute",
	"Comment": "test whether specifying different regionating strategies changes the results.",
	"Method": "void testDuplicateAttribute(){\r\n    final String path = \"wms?request=getmap&service=wms&version=1.1.1\" + \"&format=\" + KMLMapOutputFormat.MIME_TYPE + \"&layers=\" + TILE_TESTS.getPrefix() + \":\" + TILE_TESTS.getLocalPart() + \"&bbox=-180,-90,0,90&styles=\" + \"&height=1024&width=1024&srs=EPSG:4326\";\r\n    FeatureTypeInfo fti = getFeatureTypeInfo(TILE_TESTS);\r\n    fti.getMetadata().put(\"kml.regionateFeatureLimit\", 2);\r\n    Document geo = getAsDOM(path + \"&format_options=regionateBy:best_guess;regionateattr:the_geom\");\r\n    assertEquals(\"kml\", geo.getDocumentElement().getTagName());\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.arcsde.ArcSDECoverageStoreEditPanelTest.testRefreshRasterTableList",
	"Comment": "connection parameters are properly set and the refresh raster tables button is hit, producingthe dropdownchoice to be filled up with the table names",
	"Method": "void testRefreshRasterTableList(){\r\n    startPanelForNewStore();\r\n    final FormTester formTester = tester.newFormTester(\"rasterStoreForm\");\r\n    final String base = \"rasterStoreForm:parametersPanel:\";\r\n    RasterTableSelectionPanel tableChooserPanel = (RasterTableSelectionPanel) tester.getComponentFromLastRenderedPage(base + \"tableNamePanel\");\r\n    final List<String> rasterColumns = Arrays.asList(\"FAKE.TABLE1\", \"FAKE.TABLE2\", \"FAKE.TABLE3\");\r\n    tableChooserPanel.setSessionFactory(new ISessionPoolFactory() {\r\n        public ISessionPool createPool(final ArcSDEConnectionConfig config) throws IOException {\r\n            return new ISessionPool() {\r\n                public ISession getSession() throws IOException, UnavailableConnectionException {\r\n                    return getSession(true);\r\n                }\r\n                public ISession getSession(final boolean transactional) throws IOException, UnavailableConnectionException {\r\n                    return new SessionWrapper(null) {\r\n                        @Override\r\n                        public List<String> getRasterColumns() throws IOException {\r\n                            return rasterColumns;\r\n                        }\r\n                        @Override\r\n                        public void dispose() {\r\n                        }\r\n                    };\r\n                }\r\n                public boolean isClosed() {\r\n                    return false;\r\n                }\r\n                public int getPoolSize() {\r\n                    return 1;\r\n                }\r\n                public int getInUseCount() {\r\n                    return 0;\r\n                }\r\n                public ArcSDEConnectionConfig getConfig() {\r\n                    return config;\r\n                }\r\n                public int getAvailableCount() {\r\n                    return 1;\r\n                }\r\n                public void close() {\r\n                }\r\n            };\r\n        }\r\n    });\r\n    final String dropDownPath = base + \"tableNamePanel:border:border_body:rasterTable\";\r\n    final DropDownChoice<?> choice = (DropDownChoice<?>) tester.getComponentFromLastRenderedPage(dropDownPath);\r\n    assertTrue(choice.getChoices().isEmpty());\r\n    String submitLink = base + \"tableNamePanel:refresh\";\r\n    tester.executeAjaxEvent(submitLink, \"click\");\r\n    FeedbackMessage feedbackMessage = formTester.getForm().getFeedbackMessages().first();\r\n    assertNull(feedbackMessage);\r\n    assertEquals(rasterColumns, choice.getChoices());\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.arcsde.ArcSDECoverageStoreEditPanelTest.testRefreshRasterTableList",
	"Comment": "connection parameters are properly set and the refresh raster tables button is hit, producingthe dropdownchoice to be filled up with the table names",
	"Method": "void testRefreshRasterTableList(){\r\n    return new ISessionPool() {\r\n        public ISession getSession() throws IOException, UnavailableConnectionException {\r\n            return getSession(true);\r\n        }\r\n        public ISession getSession(final boolean transactional) throws IOException, UnavailableConnectionException {\r\n            return new SessionWrapper(null) {\r\n                @Override\r\n                public List<String> getRasterColumns() throws IOException {\r\n                    return rasterColumns;\r\n                }\r\n                @Override\r\n                public void dispose() {\r\n                }\r\n            };\r\n        }\r\n        public boolean isClosed() {\r\n            return false;\r\n        }\r\n        public int getPoolSize() {\r\n            return 1;\r\n        }\r\n        public int getInUseCount() {\r\n            return 0;\r\n        }\r\n        public ArcSDEConnectionConfig getConfig() {\r\n            return config;\r\n        }\r\n        public int getAvailableCount() {\r\n            return 1;\r\n        }\r\n        public void close() {\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.arcsde.ArcSDECoverageStoreEditPanelTest.testRefreshRasterTableList",
	"Comment": "connection parameters are properly set and the refresh raster tables button is hit, producingthe dropdownchoice to be filled up with the table names",
	"Method": "void testRefreshRasterTableList(){\r\n    return getSession(true);\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.arcsde.ArcSDECoverageStoreEditPanelTest.testRefreshRasterTableList",
	"Comment": "connection parameters are properly set and the refresh raster tables button is hit, producingthe dropdownchoice to be filled up with the table names",
	"Method": "void testRefreshRasterTableList(){\r\n    return new SessionWrapper(null) {\r\n        @Override\r\n        public List<String> getRasterColumns() throws IOException {\r\n            return rasterColumns;\r\n        }\r\n        @Override\r\n        public void dispose() {\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.arcsde.ArcSDECoverageStoreEditPanelTest.testRefreshRasterTableList",
	"Comment": "connection parameters are properly set and the refresh raster tables button is hit, producingthe dropdownchoice to be filled up with the table names",
	"Method": "void testRefreshRasterTableList(){\r\n    return rasterColumns;\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.arcsde.ArcSDECoverageStoreEditPanelTest.testRefreshRasterTableList",
	"Comment": "connection parameters are properly set and the refresh raster tables button is hit, producingthe dropdownchoice to be filled up with the table names",
	"Method": "void testRefreshRasterTableList(){\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.arcsde.ArcSDECoverageStoreEditPanelTest.testRefreshRasterTableList",
	"Comment": "connection parameters are properly set and the refresh raster tables button is hit, producingthe dropdownchoice to be filled up with the table names",
	"Method": "void testRefreshRasterTableList(){\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.arcsde.ArcSDECoverageStoreEditPanelTest.testRefreshRasterTableList",
	"Comment": "connection parameters are properly set and the refresh raster tables button is hit, producingthe dropdownchoice to be filled up with the table names",
	"Method": "void testRefreshRasterTableList(){\r\n    return 1;\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.arcsde.ArcSDECoverageStoreEditPanelTest.testRefreshRasterTableList",
	"Comment": "connection parameters are properly set and the refresh raster tables button is hit, producingthe dropdownchoice to be filled up with the table names",
	"Method": "void testRefreshRasterTableList(){\r\n    return 0;\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.arcsde.ArcSDECoverageStoreEditPanelTest.testRefreshRasterTableList",
	"Comment": "connection parameters are properly set and the refresh raster tables button is hit, producingthe dropdownchoice to be filled up with the table names",
	"Method": "void testRefreshRasterTableList(){\r\n    return config;\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.arcsde.ArcSDECoverageStoreEditPanelTest.testRefreshRasterTableList",
	"Comment": "connection parameters are properly set and the refresh raster tables button is hit, producingthe dropdownchoice to be filled up with the table names",
	"Method": "void testRefreshRasterTableList(){\r\n    return 1;\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.arcsde.ArcSDECoverageStoreEditPanelTest.testRefreshRasterTableList",
	"Comment": "connection parameters are properly set and the refresh raster tables button is hit, producingthe dropdownchoice to be filled up with the table names",
	"Method": "void testRefreshRasterTableList(){\r\n}"
}, {
	"Path": "org.geoserver.rest.util.IOUtils.copyToFileChannel",
	"Comment": "copies the content of the source channel onto the destination file.",
	"Method": "Long copyToFileChannel(int bufferSize,ReadableByteChannel source,FileChannel destination,Long initialWritePosition){\r\n    Long writedByte = 0L;\r\n    inputNotNull(source, destination);\r\n    if (!source.isOpen() || !destination.isOpen())\r\n        throw new IllegalStateException(\"Source and destination channels must be open.\");\r\n    final java.nio.ByteBuffer buffer = java.nio.ByteBuffer.allocateDirect(bufferSize);\r\n    FileLock lock = null;\r\n    try {\r\n        lock = destination.lock();\r\n        destination.position(initialWritePosition);\r\n        while (source.read(buffer) != -1) {\r\n            buffer.flip();\r\n            while (buffer.hasRemaining()) writedByte = writedByte + destination.write(buffer);\r\n            buffer.clear();\r\n        }\r\n    } finally {\r\n        if (lock != null) {\r\n            try {\r\n                lock.release();\r\n            } catch (Throwable t) {\r\n                if (LOGGER.isLoggable(Level.INFO))\r\n                    LOGGER.log(Level.INFO, t.getLocalizedMessage(), t);\r\n            }\r\n        }\r\n    }\r\n    return writedByte;\r\n}"
}, {
	"Path": "org.geoserver.wps.executor.ProcessStatusTracker.remove",
	"Comment": "removes the execution status for the given id, and returns its value, if found, or null, ifnot found",
	"Method": "ExecutionStatus remove(String executionId){\r\n    return store.remove(executionId);\r\n}"
}, {
	"Path": "org.geoserver.wps.ExecuteOnCoverageTest.testCrop",
	"Comment": "we use the crop process as a simple test to see if we requesting a coverage using differentwcs versions works.",
	"Method": "void testCrop(){\r\n    String wcsRequest = WCS2GetCoverageRequestBuilder.newBuilder().coverageId(getLayerId(MockData.TASMANIA_DEM)).bbox(130.0, 150, -44., -40).asXML(version);\r\n    String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<wps:Execute version=\\\"1.0.0\\\" service=\\\"WPS\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns=\\\"http://www.opengis.net/wps/1.0.0\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\" xmlns:wps=\\\"http://www.opengis.net/wps/1.0.0\\\" xmlns:ows=\\\"http://www.opengis.net/ows/1.1\\\" xmlns:gml=\\\"http://www.opengis.net/gml\\\" xmlns:ogc=\\\"http://www.opengis.net/ogc\\\" xmlns:wcs=\\\"http://www.opengis.net/wcs/1.1.1\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" xsi:schemaLocation=\\\"http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd\\\">\\n\" + \"  <ows:Identifier>gs:CropCoverage<\/ows:Identifier>\\n\" + \"  <wps:DataInputs>\\n\" + \"    <wps:Input>\\n\" + \"      <ows:Identifier>coverage<\/ows:Identifier>\\n\" + \"      <wps:Reference mimeType=\\\"image/tiff\\\" xlink:href=\\\"http://geoserver/wcs\\\" method=\\\"POST\\\">\\n\" + \"        <wps:Body>\\n\" + wcsRequest + \"        <\/wps:Body>\\n\" + \"      <\/wps:Reference>\\n\" + \"    <\/wps:Input>\\n\" + \"    <wps:Input>\\n\" + \"      <ows:Identifier>cropShape<\/ows:Identifier>\\n\" + \"      <wps:Data>\\n\" + \"        <wps:ComplexData mimeType=\\\"application/wkt\\\"><![CDATA[POLYGON((145.5 -41.9, 145.5 -42.1, 145.6 -42, 145.5 -41.9))]]><\/wps:ComplexData>\\n\" + \"      <\/wps:Data>\\n\" + \"    <\/wps:Input>\\n\" + \"  <\/wps:DataInputs>\\n\" + \"  <wps:ResponseForm>\\n\" + \"    <wps:RawDataOutput mimeType=\\\"application/arcgrid\\\">\\n\" + \"      <ows:Identifier>result<\/ows:Identifier>\\n\" + \"    <\/wps:RawDataOutput>\\n\" + \"  <\/wps:ResponseForm>\\n\" + \"<\/wps:Execute>\\n\" + \"\\n\" + \"\";\r\n    MockHttpServletResponse response = postAsServletResponse(root(), xml);\r\n    InputStream is = getBinaryInputStream(response);\r\n    ArcGridFormat format = new ArcGridFormat();\r\n    GridCoverage gc = format.getReader(is).read(null);\r\n    assertTrue(new Envelope(-145.4, 145.6, -41.8, -42.1).contains(new ReferencedEnvelope(gc.getEnvelope())));\r\n    double[] valueInside = (double[]) gc.evaluate(new DirectPosition2D(145.55, -42));\r\n    assertEquals(615.0, valueInside[0]);\r\n    double[] valueOutside = (double[]) gc.evaluate(new DirectPosition2D(145.57, -41.9));\r\n    assertEquals(-9999 & 0xFFFF, (int) valueOutside[0]);\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaMockData.getDataStoreName",
	"Comment": "get the name of the data store for a feature type. this is used to construct the name of thefeature type directory as well as the name of the data store.",
	"Method": "String getDataStoreName(String namespacePrefix,String typeName){\r\n    return namespacePrefix + \"_\" + typeName;\r\n}"
}, {
	"Path": "org.geoserver.wps.executor.WPSExecutionManager.submit",
	"Comment": "process submission, not blocking. returns an id that can be used to get the process statusand result later.",
	"Method": "ExecuteResponseType submit(ExecuteRequest request,boolean synchronous){\r\n    Name processName = request.getProcessName();\r\n    ProcessManager processManager = getProcessManager(processName);\r\n    String executionId = resourceManager.getExecutionId(synchronous);\r\n    LazyInputMap inputs = request.getProcessInputs(WPSExecutionManager.this);\r\n    request.validateOutputs(inputs);\r\n    ExecutionStatus status = new ExecutionStatus(processName, executionId, request.isAsynchronous());\r\n    status.setRequest(request.getRequest());\r\n    long maxExecutionTime = getMaxExecutionTime(synchronous);\r\n    long maxTotalTime = getMaxTotalTime(synchronous);\r\n    WPSInfo wps = geoServer.getService(WPSInfo.class);\r\n    int resourceExpirationTimeout = wps.getResourceExpirationTimeout();\r\n    Calendar calendar = Calendar.getInstance();\r\n    calendar.setTime(new Date());\r\n    calendar.add(Calendar.SECOND, resourceExpirationTimeout);\r\n    status.setExpirationDate(calendar.getTime());\r\n    status.setEstimatedCompletion(null);\r\n    int nextPollTimeDelta = maxExecutionTime > 0 ? (int) maxExecutionTime / 2 : 10;\r\n    calendar.setTime(new Date());\r\n    calendar.add(Calendar.SECOND, nextPollTimeDelta);\r\n    status.setNextPoll(new Date());\r\n    Executor executor = new Executor(request, processManager, processName, inputs, synchronous, status, resourceManager, maxExecutionTime, maxTotalTime);\r\n    ExecuteResponseType response;\r\n    if (synchronous) {\r\n        response = executor.call();\r\n    } else {\r\n        LOGGER.log(Level.INFO, \"Submitting new asynch process \" + processName.getURI() + \" with execution id \" + executionId);\r\n        try {\r\n            resourceManager.storeRequestObject(request.getRequest(), executionId);\r\n        } catch (IOException e) {\r\n            throw new WPSException(\"Failed to store original WPS request, which \" + \"will be needed to encode the output\", e);\r\n        }\r\n        ExecuteResponseBuilder builder = new ExecuteResponseBuilder(request.getRequest(), applicationContext, status);\r\n        response = builder.build();\r\n        executors.submit(executor);\r\n    }\r\n    return response;\r\n}"
}, {
	"Path": "org.geoserver.gwc.layer.GeoServerTileLayer.getGroupMaxAge",
	"Comment": "returns the max age of a layer group by looking for the minimum max age of its components",
	"Method": "int getGroupMaxAge(LayerGroupInfo lg){\r\n    int maxAge = Integer.MAX_VALUE;\r\n    for (PublishedInfo pi : lg.getLayers()) {\r\n        int piAge;\r\n        if (pi instanceof LayerInfo) {\r\n            piAge = getLayerMaxAge((LayerInfo) pi);\r\n        } else if (pi instanceof LayerGroupInfo) {\r\n            piAge = getGroupMaxAge((LayerGroupInfo) pi);\r\n        } else {\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.log(Level.FINE, \"Found a PublishedInfo that is nor LayerInfo nor \" + \"LayerGroupInfo, setting its max age to 0: \" + pi);\r\n            }\r\n            piAge = 0;\r\n        }\r\n        maxAge = Math.min(piAge, maxAge);\r\n    }\r\n    return maxAge;\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.ConfigurationDiffVisitor.getAllServices",
	"Comment": "get all services info objects of a geoserver instance, including the global service andworkspace services.",
	"Method": "List<ServiceInfo> getAllServices(GeoServer geoServer){\r\n    List<ServiceInfo> allServices = new ArrayList();\r\n    allServices.addAll(geoServer.getServices());\r\n    List<WorkspaceInfo> workspaces = geoServer.getCatalog().getWorkspaces();\r\n    for (WorkspaceInfo workspace : workspaces) {\r\n        allServices.addAll(geoServer.getFacade().getServices(workspace));\r\n    }\r\n    return allServices;\r\n}"
}, {
	"Path": "org.geoserver.test.SecuredFeatureChainingTest.testDenormalisedFeaturesCount",
	"Comment": "test that denormalized data reports the correct number of features",
	"Method": "void testDenormalisedFeaturesCount(){\r\n    setRequestAuth(\"cite_readatts\", \"cite\");\r\n    Document doc = getAsDOM(\"wfs?request=GetFeature&version=1.1.0&typename=gsml:GeologicUnit\" + \"&maxFeatures=3&resultType=hits\");\r\n    LOGGER.info(\"WFS GetFeature&typename=gsml:GeologicUnit&maxFeatures=3 response:\\n\" + prettyString(doc));\r\n    assertXpathEvaluatesTo(\"3\", \"//wfs:FeatureCollection/@numberOfFeatures\", doc);\r\n}"
}, {
	"Path": "org.vfny.geoserver.servlets.FileStrategy.flush",
	"Comment": "closes safe output stream, copies resulting file to response.",
	"Method": "void flush(HttpServletResponse response){\r\n    if ((temp == null) || (response == null) || (safe == null) || !temp.exists()) {\r\n        LOGGER.fine(\"temp is \" + temp + \", response is \" + response + \" safe is \" + safe + \", temp exists \" + temp.exists());\r\n        throw new IllegalStateException(\"flush should only be called after getDestination\");\r\n    }\r\n    InputStream copy = null;\r\n    try {\r\n        safe.flush();\r\n        safe.close();\r\n        safe = null;\r\n        copy = new BufferedInputStream(new FileInputStream(temp));\r\n        OutputStream out = response.getOutputStream();\r\n        out = new BufferedOutputStream(out, 1024 * 1024);\r\n        byte[] buffer = new byte[BUFF_SIZE];\r\n        int b;\r\n        while ((b = copy.read(buffer, 0, BUFF_SIZE)) > 0) {\r\n            out.write(buffer, 0, b);\r\n        }\r\n        out.flush();\r\n    } catch (IOException ioe) {\r\n        throw ioe;\r\n    } finally {\r\n        if (copy != null) {\r\n            try {\r\n                copy.close();\r\n            } catch (Exception ex) {\r\n            }\r\n        }\r\n        copy = null;\r\n        if ((temp != null) && temp.exists()) {\r\n            temp.delete();\r\n        }\r\n        temp = null;\r\n        response = null;\r\n        safe = null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaMockData.modifyOnlineMappingFileContent",
	"Comment": "modify the mapping file stream that is to be copied to the target directory. this is so themapping file copy has the right datastore parameters to use the test database.",
	"Method": "String modifyOnlineMappingFileContent(String mappingFileName){\r\n    InputStream is = openResource(mappingFileName);\r\n    BufferedReader br = new BufferedReader(new InputStreamReader(is));\r\n    StringBuffer content = new StringBuffer();\r\n    boolean parametersStartFound = false;\r\n    boolean parametersEndFound = false;\r\n    boolean isOracle = onlineTestId.equals(\"oracle\");\r\n    for (String line = br.readLine(); line != null; line = br.readLine()) {\r\n        if (!parametersStartFound || (parametersStartFound && parametersEndFound)) {\r\n            if (!parametersStartFound) {\r\n                if (line.trim().equals(\"<parameters>\")) {\r\n                    parametersStartFound = true;\r\n                    if (isOracle) {\r\n                        content.append(AppSchemaTestOracleSetup.DB_PARAMS);\r\n                    } else {\r\n                        content.append(AppSchemaTestPostgisSetup.DB_PARAMS);\r\n                    }\r\n                } else {\r\n                    content.append(line);\r\n                }\r\n            } else if (line.trim().startsWith(\"<sourceType>\")) {\r\n                line = line.trim();\r\n                String sourceTypeTag = \"<sourceType>\";\r\n                content.append(sourceTypeTag);\r\n                String tableName = line.substring(line.indexOf(sourceTypeTag) + sourceTypeTag.length(), line.indexOf(\"<\/sourceType>\"));\r\n                content.append(tableName.toUpperCase());\r\n                content.append(\"<\/sourceType>\");\r\n                content.append(\"\\n\");\r\n            } else {\r\n                content.append(line);\r\n            }\r\n            content.append(\"\\n\");\r\n        } else {\r\n            if (line.trim().equals(\"<\/parameters>\")) {\r\n                parametersEndFound = true;\r\n            }\r\n        }\r\n    }\r\n    return content.toString();\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.ShapeZipTest.testMultiPolygonZMShp",
	"Comment": "test for multipolygon zm support on getfeature shapefile output",
	"Method": "void testMultiPolygonZMShp(){\r\n    GeometryFactory gf = JTSFactoryFinder.getGeometryFactory();\r\n    SimpleFeatureType featureType = DataUtilities.createType(\"polygonmz\", \"name:String,geom:MultiPolygon:4326\");\r\n    SimpleFeatureBuilder fb = new SimpleFeatureBuilder(featureType);\r\n    fb.add(\"polygon1\");\r\n    fb.add(gf.createMultiPolygon(new Polygon[] { gf.createPolygon(new CoordinateXYZM[] { new CoordinateXYZM(0, 0, 3, 1), new CoordinateXYZM(1, 1, 7, 2), new CoordinateXYZM(1, 0, 7, 3), new CoordinateXYZM(0, 0, 3, 1) }) }));\r\n    List<SimpleFeature> features = new ArrayList<SimpleFeature>();\r\n    features.add(fb.buildFeature(\"1\"));\r\n    SimpleFeatureCollection featureCollection = DataUtilities.collection(features);\r\n    byte[] zipBytes = writeOut(featureCollection);\r\n    byte[] resultBytes = getShpOnlyBytes(zipBytes);\r\n    InputStream in = getClass().getClassLoader().getResourceAsStream(\"org/geoserver/wfs/response/polygonZm.shp\");\r\n    byte[] expectedBytes = IOUtils.toByteArray(in);\r\n    assertTrue(Arrays.equals(resultBytes, expectedBytes));\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.postAsServletResponse",
	"Comment": "executes an ows request using the post method, with xml as body content.",
	"Method": "MockHttpServletResponse postAsServletResponse(String path,String xml,MockHttpServletResponse postAsServletResponse,String path,String body,String contentType){\r\n    MockHttpServletRequest request = createRequest(path);\r\n    request.setMethod(\"POST\");\r\n    request.setContentType(contentType);\r\n    request.setContent(body.getBytes(\"UTF-8\"));\r\n    request.addHeader(\"Content-type\", contentType);\r\n    return dispatch(request);\r\n}"
}, {
	"Path": "org.geoserver.flow.ControlFlowCallback.registDefaultBeansIfNeeded",
	"Comment": "register default beans for control flow configurator and flow controller.",
	"Method": "void registDefaultBeansIfNeeded(ConfigurableApplicationContext applicationContext){\r\n    ConfigurableListableBeanFactory factory = applicationContext.getBeanFactory();\r\n    synchronized (ControlFlowCallback.class) {\r\n        try {\r\n            applicationContext.getBean(ControlFlowConfigurator.class, applicationContext);\r\n        } catch (NoSuchBeanDefinitionException exception) {\r\n            factory.registerSingleton(\"defaultControlFlowConfigurator\", new DefaultControlFlowConfigurator());\r\n            LOGGER.fine(\"Defautl flow configurator bean dynamically registered.\");\r\n        }\r\n        try {\r\n            applicationContext.getBean(FlowControllerProvider.class, applicationContext);\r\n        } catch (NoSuchBeanDefinitionException exception) {\r\n            factory.registerSingleton(\"defaultFlowControllerProvider\", new DefaultFlowControllerProvider(applicationContext));\r\n            LOGGER.fine(\"Defautl flow controller provider bean dynamically registered.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.impl.ServiceAccessRuleDAO.get",
	"Comment": "returns the instanced contained in the spring context for the ui to use",
	"Method": "ServiceAccessRuleDAO get(){\r\n    return GeoServerExtensions.bean(ServiceAccessRuleDAO.class);\r\n}"
}, {
	"Path": "org.geoserver.ows.util.OwsUtils.updateCollectionProperty",
	"Comment": "helper method for updating a collection based property. only used if setter is null.",
	"Method": "void updateCollectionProperty(Object object,Collection newValue,Method getter){\r\n    Collection oldValue = (Collection) getter.invoke(object, null);\r\n    if (oldValue != null) {\r\n        oldValue.clear();\r\n        oldValue.addAll(newValue);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.IsolatedCatalogFacade.getLocalWorkspace",
	"Comment": "helper method that just returns the current local workspace if available.",
	"Method": "WorkspaceInfo getLocalWorkspace(){\r\n    return LocalWorkspace.get();\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.ReaderUtils.checkFile",
	"Comment": "checks to ensure the file is valid.returns the file passed in to allow this to wrap file creations.",
	"Method": "File checkFile(File file,boolean isDir){\r\n    if (!file.exists()) {\r\n        throw new Exception(\"File does not exist: \" + file);\r\n    }\r\n    if (isDir && !file.isDirectory()) {\r\n        throw new Exception(\"File is not a directory:\" + file);\r\n    }\r\n    if (!isDir && !file.isFile()) {\r\n        throw new Exception(\"File is not valid:\" + file);\r\n    }\r\n    if (LOGGER.isLoggable(Level.FINER)) {\r\n        LOGGER.finer(new StringBuffer(\"File is valid: \").append(file).toString());\r\n    }\r\n    return file;\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaTestSupport.getMatchingNodes",
	"Comment": "return the list of nodes in a document that match an xpath expression.",
	"Method": "NodeList getMatchingNodes(String xpath,Document document){\r\n    try {\r\n        return getXpathEngine().getMatchingNodes(xpath, document);\r\n    } catch (XpathException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.data.layer.SQLViewAbstractPage.getFirstErrorMessage",
	"Comment": "data stores tend to return ioexceptions with no explanation, and the actual error coming fromthe db is in the cause. this method extracts the first not null message in the cause chain",
	"Method": "String getFirstErrorMessage(Throwable t){\r\n    Throwable original = t;\r\n    while (!(t instanceof SQLException)) {\r\n        t = t.getCause();\r\n        if (t == null) {\r\n            break;\r\n        }\r\n    }\r\n    if (t == null) {\r\n        return original.getMessage();\r\n    } else {\r\n        return t.getMessage();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.StationsMockData.getGml32StandardParamaters",
	"Comment": "return a map containing the standard placeholders with the corresponding gml32 values.",
	"Method": "Map<String, String> getGml32StandardParamaters(){\r\n    Map<String, String> gml32Parameters = new HashMap();\r\n    gml32Parameters.put(\"GML_PREFIX\", \"gml32\");\r\n    gml32Parameters.put(\"GML_PREFIX_UPPER\", \"GML32\");\r\n    gml32Parameters.put(\"GML_NAMESPACE\", \"http://www.opengis.net/gml/3.2\");\r\n    gml32Parameters.put(\"GML_LOCATION\", \"http://schemas.opengis.net/gml/3.2.1/gml.xsd\");\r\n    return gml32Parameters;\r\n}"
}, {
	"Path": "org.geoserver.wps.remote.plugin.server.XMPPBoshEndpoint.createJettyServer",
	"Comment": "create a basic jetty server including a connector on the configured port override in subclassto create a different kind of setup or to reuse an existing instance",
	"Method": "Server createJettyServer(){\r\n    Server server = new Server();\r\n    ServerConnector connector;\r\n    HttpConfiguration http_config = new HttpConfiguration();\r\n    http_config.setSecureScheme(\"https\");\r\n    http_config.setSecurePort(port);\r\n    http_config.setOutputBufferSize(32768);\r\n    if (isSSLEnabled) {\r\n        SslContextFactory sslContextFactory = new SslContextFactory();\r\n        sslContextFactory.setKeyStorePath(sslKeystorePath);\r\n        sslContextFactory.setKeyManagerPassword(sslKeystorePassword);\r\n        sslContextFactory.setKeyStorePassword(sslKeystorePassword);\r\n        HttpConfiguration https_config = new HttpConfiguration(http_config);\r\n        SecureRequestCustomizer src = new SecureRequestCustomizer();\r\n        https_config.addCustomizer(src);\r\n        connector = new ServerConnector(server, new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString()), new HttpConnectionFactory(https_config));\r\n        connector.setIdleTimeout(500000);\r\n    } else {\r\n        connector = new ServerConnector(server, new HttpConnectionFactory(http_config));\r\n        connector.setIdleTimeout(30000);\r\n    }\r\n    connector.setPort(port);\r\n    server.setConnectors(new Connector[] { connector });\r\n    return server;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.putAsJSON",
	"Comment": "executes a request using the put method and parses the result as a json object.",
	"Method": "JSON putAsJSON(String path,String body,String contentType){\r\n    MockHttpServletResponse response = putAsServletResponse(path, body, contentType);\r\n    return json(response);\r\n}"
}, {
	"Path": "org.geoserver.kml.KmlEncodingContext.getCurrentFeatureType",
	"Comment": "returns the current feature type is the current layer is made of vector features, nullotherwise",
	"Method": "SimpleFeatureType getCurrentFeatureType(){\r\n    if (currentLayer instanceof FeatureLayer) {\r\n        FeatureLayer fl = (FeatureLayer) currentLayer;\r\n        return (SimpleFeatureType) fl.getFeatureSource().getSchema();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexIndexesTest.getFixtureFile",
	"Comment": "gets the fixture file for geoserver apache solr integration tests.",
	"Method": "File getFixtureFile(){\r\n    File directory = new File(System.getProperty(\"user.home\") + \"/.geoserver\");\r\n    if (!directory.exists()) {\r\n        directory.mkdir();\r\n    }\r\n    return new File(directory, \"appschema-indexes.properties\");\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.MultiDimensionalExtensionTest.minimumValue",
	"Comment": "helper method that will create a default value strategy, minimum value in this case.",
	"Method": "DimensionDefaultValueSetting minimumValue(){\r\n    DimensionDefaultValueSetting defaultValueSetting = new DimensionDefaultValueSetting();\r\n    defaultValueSetting.setStrategyType(DimensionDefaultValueSetting.Strategy.MINIMUM);\r\n    return defaultValueSetting;\r\n}"
}, {
	"Path": "org.geoserver.security.impl.LayerGroupContainmentCache.collectContainers",
	"Comment": "recursively collects the group and all its containers in the groups collection",
	"Method": "void collectContainers(LayerGroupSummary lg,Set<LayerGroupSummary> groups){\r\n    if (!groups.contains(lg)) {\r\n        if (lg.getMode() != LayerGroupInfo.Mode.SINGLE) {\r\n            groups.add(lg);\r\n        }\r\n        for (LayerGroupSummary container : lg.containerGroups) {\r\n            collectContainers(container, groups);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.importer.Importer.doIndirectImport",
	"Comment": "an import that involves reading from the datastore and writing into a specified target store",
	"Method": "void doIndirectImport(ImportTask task){\r\n    if (!task.getStore().isEnabled()) {\r\n        task.getStore().setEnabled(true);\r\n    }\r\n    if (task.progress().isCanceled()) {\r\n        return;\r\n    }\r\n    task.setState(ImportTask.State.RUNNING);\r\n    TransformChain tx = task.getTransform();\r\n    if (!doPreTransform(task, task.getData(), tx)) {\r\n        return;\r\n    }\r\n    boolean canceled = false;\r\n    DataFormat format = task.getData().getFormat();\r\n    if (format instanceof VectorFormat) {\r\n        try {\r\n            currentlyProcessing.put(task.getContext().getId(), task);\r\n            loadIntoDataStore(task, (DataStoreInfo) task.getStore(), (VectorFormat) format, (VectorTransformChain) tx);\r\n            canceled = task.progress().isCanceled();\r\n            FeatureTypeInfo featureType = (FeatureTypeInfo) task.getLayer().getResource();\r\n            featureType.getAttributes().clear();\r\n            if (!canceled) {\r\n                if (task.getUpdateMode() == UpdateMode.CREATE) {\r\n                    addToCatalog(task);\r\n                }\r\n                FeatureTypeInfo resource = getCatalog().getResourceByName(featureType.getQualifiedName(), FeatureTypeInfo.class);\r\n                calculateBounds(resource);\r\n            }\r\n        } catch (Throwable th) {\r\n            LOGGER.log(Level.SEVERE, \"Error occured during import\", th);\r\n            Exception e = (th instanceof Exception) ? (Exception) th : new Exception(th);\r\n            task.setError(e);\r\n            task.setState(ImportTask.State.ERROR);\r\n            return;\r\n        } finally {\r\n            currentlyProcessing.remove(task.getContext().getId());\r\n        }\r\n    } else {\r\n        StoreInfo store = task.getStore();\r\n        final String errorMessage = \"Indirect raster import can only work against a structured grid coverage store (e.g., mosaic), this one is not: \";\r\n        if (!(store instanceof CoverageStoreInfo)) {\r\n            throw new IllegalArgumentException(errorMessage + store);\r\n        }\r\n        CoverageStoreInfo cs = (CoverageStoreInfo) store;\r\n        GridCoverageReader reader = cs.getGridCoverageReader(null, null);\r\n        if (!(reader instanceof StructuredGridCoverage2DReader)) {\r\n            throw new IllegalArgumentException(errorMessage + store);\r\n        }\r\n        StructuredGridCoverage2DReader sr = (StructuredGridCoverage2DReader) reader;\r\n        ImportData data = task.getData();\r\n        harvestImportData(sr, data);\r\n        if (task.getUpdateMode() == UpdateMode.CREATE) {\r\n            if (task.getLayer() != null && task.getLayer().getId() == null) {\r\n                addToCatalog(task);\r\n            }\r\n        }\r\n    }\r\n    if (!canceled && !doPostTransform(task, task.getData(), tx)) {\r\n        return;\r\n    }\r\n    task.setState(canceled ? ImportTask.State.CANCELED : ImportTask.State.COMPLETE);\r\n}"
}, {
	"Path": "org.geoserver.rest.catalog.FeatureTypeController.getExistingDataStore",
	"Comment": "helper method that find a store based on the workspace name and store name.",
	"Method": "DataStoreInfo getExistingDataStore(String workspaceName,String storeName){\r\n    DataStoreInfo original = catalog.getDataStoreByName(workspaceName, storeName);\r\n    if (original == null) {\r\n        throw new ResourceNotFoundException(\"No such data store: \" + workspaceName + \",\" + storeName);\r\n    }\r\n    return original;\r\n}"
}, {
	"Path": "org.geoserver.security.cas.GeoServerCasAuthenticationFilter.isLogoutRequest",
	"Comment": "determines whether the given request is a cas logout request.",
	"Method": "boolean isLogoutRequest(HttpServletRequest request){\r\n    return \"POST\".equals(request.getMethod()) && CommonUtils.isNotBlank(CommonUtils.safeGetParameter(request, ConfigurationKeys.LOGOUT_PARAMETER_NAME.getDefaultValue()));\r\n}"
}, {
	"Path": "org.geoserver.security.SecureCatalogImpl.filterStyles",
	"Comment": "given a list of styles, returns a copy of it containing only the styles the user can access.",
	"Method": "List<StyleInfo> filterStyles(Authentication user,List<StyleInfo> styles){\r\n    List<StyleInfo> result = new ArrayList<StyleInfo>();\r\n    for (StyleInfo original : styles) {\r\n        StyleInfo secured = checkAccess(user, original, MixedModeBehavior.HIDE);\r\n        if (secured != null)\r\n            result.add(secured);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.web.data.workspace.WorkspaceNewPage.validateAndReport",
	"Comment": "executes a validation and in the case of a failure reports the found errors in the providedform, this method will log the found exception too.",
	"Method": "boolean validateAndReport(Supplier<ValidationResult> validation,Form form){\r\n    ValidationResult validationResult;\r\n    try {\r\n        validationResult = validation.get();\r\n    } catch (Exception exception) {\r\n        LOGGER.log(Level.INFO, \"Error validating workspace related objects.\", exception);\r\n        form.error(exception.getMessage());\r\n        return false;\r\n    }\r\n    if (!validationResult.isValid()) {\r\n        String message = validationResult.getErrosAsString(System.lineSeparator());\r\n        LOGGER.log(Level.INFO, message);\r\n        form.error(message);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.wps.ProcessEvent.getInputs",
	"Comment": "the process inputs. this field is available only when the inputs have been parsed already",
	"Method": "Map<String, Object> getInputs(){\r\n    return inputs;\r\n}"
}, {
	"Path": "org.geoserver.wps.process.DelegatingProcessFactory.getInnermostDelegate",
	"Comment": "returns the innermost delegate, this method can be used to check what the original factorywas",
	"Method": "ProcessFactory getInnermostDelegate(){\r\n    ProcessFactory pf = delegate;\r\n    while (pf instanceof DelegatingProcessFactory) {\r\n        pf = ((DelegatingProcessFactory) pf).delegate;\r\n    }\r\n    return pf;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.reloadCatalogAndConfiguration",
	"Comment": "reloads the catalog and configuration from disk.this method can be used by subclasses from a test method after they have changed theconfiguration on disk.",
	"Method": "void reloadCatalogAndConfiguration(){\r\n    GeoServerLoaderProxy loader = GeoServerExtensions.bean(GeoServerLoaderProxy.class, applicationContext);\r\n    loader.reload();\r\n}"
}, {
	"Path": "org.geoserver.wps.transmute.ComplexTransmuter.decode",
	"Comment": "used to decode external xml documents for use as process inputs",
	"Method": "Object decode(InputStream stream){\r\n    Object decoded = null;\r\n    Configuration config = null;\r\n    try {\r\n        config = (Configuration) (this.getXMLConfiguration().getConstructor().newInstance());\r\n    } catch (Exception e) {\r\n        throw new WPSException(\"NoApplicableCode\", \"Failed to initialize XMLConfiguration\");\r\n    }\r\n    Parser parser = new Parser(config);\r\n    try {\r\n        decoded = (Geometry) parser.parse(stream);\r\n    } catch (Exception e) {\r\n        throw new WPSException(\"NoApplicableCode\", \"Parsing error \" + e);\r\n    }\r\n    return decoded;\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexSolrTest.getFixtureFile",
	"Comment": "gets the fixture file for geoserver apache solr integration tests.",
	"Method": "File getFixtureFile(){\r\n    File directory = new File(System.getProperty(\"user.home\") + \"/.geoserver\");\r\n    if (!directory.exists()) {\r\n        directory.mkdir();\r\n    }\r\n    return new File(directory, \"solr.properties\");\r\n}"
}, {
	"Path": "org.geoserver.script.ScriptManager.findScriptDir",
	"Comment": "finds a script directory located at the specified path, returning null if nosuch directory exists.",
	"Method": "File findScriptDir(String path){\r\n    Resource r = script(path);\r\n    if (r.getType() == Type.RESOURCE) {\r\n        return r.dir();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.GeoJSONBuilder.writeMap",
	"Comment": "write a java.util.map out as a json object. keys are serialized using the tostring method ofthe object and values are serialized using primitives conversions. if a value in the map is alist or map object, it will be serialized as json array or json object respectively.",
	"Method": "JSONBuilder writeMap(Map map){\r\n    this.object();\r\n    for (final Object k : map.keySet()) {\r\n        this.key(k.toString());\r\n        this.value(map.get(k));\r\n    }\r\n    return this.endObject();\r\n}"
}, {
	"Path": "org.geoserver.wms.web.data.AbstractStylePage.configurationChanged",
	"Comment": "called when a configuration change requires updating an inactive tab",
	"Method": "void configurationChanged(){\r\n    tabbedPanel.visitChildren(StyleEditTabPanel.class, (component, visit) -> {\r\n        if (component instanceof StyleEditTabPanel) {\r\n            ((StyleEditTabPanel) component).configurationChanged();\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.geoserver.util.ReaderUtils.getElementText",
	"Comment": "getchildtext purpose.used to help with xml manipulations. returns the text value of the specified element name.an exception occurs when the node is required and not found.",
	"Method": "String getElementText(Element elem,String getElementText,Element elem,boolean mandatory){\r\n    String value = null;\r\n    if (LOGGER.isLoggable(Level.FINER)) {\r\n        LOGGER.finer(new StringBuffer(\"getting element text for \").append(elem).toString());\r\n    }\r\n    if (elem != null) {\r\n        Node child;\r\n        NodeList childs = elem.getChildNodes();\r\n        int nChilds = childs.getLength();\r\n        for (int i = 0; i < nChilds; i++) {\r\n            child = childs.item(i);\r\n            if (child.getNodeType() == Node.TEXT_NODE) {\r\n                value = child.getNodeValue();\r\n                if (mandatory && \"\".equals(value.trim())) {\r\n                    throw new Exception(elem.getNodeName() + \" text is empty\");\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        if (mandatory && (value == null)) {\r\n            throw new Exception(elem.getNodeName() + \" element does not contains text\");\r\n        }\r\n    } else {\r\n        throw new Exception(\"Argument element can't be null\");\r\n    }\r\n    return unescape(value);\r\n}"
}, {
	"Path": "org.geoserver.gwc.layer.TileLayerInfoUtil.loadOrCreate",
	"Comment": "creates a cached tile layer from the given layer or layer group",
	"Method": "GeoServerTileLayerInfo loadOrCreate(CatalogInfo info,GWCConfig defaults,GeoServerTileLayerInfoImpl loadOrCreate,LayerGroupInfo groupInfo,GWCConfig defaults,GeoServerTileLayerInfoImpl loadOrCreate,LayerInfo layerInfo,GWCConfig defaults){\r\n    GeoServerTileLayerInfoImpl info = LegacyTileLayerInfoLoader.load(layerInfo);\r\n    if (info == null) {\r\n        info = create(defaults);\r\n        final ResourceInfo resource = layerInfo.getResource();\r\n        if (resource instanceof FeatureTypeInfo) {\r\n            info.getMimeFormats().clear();\r\n            info.getMimeFormats().addAll(defaults.getDefaultVectorCacheFormats());\r\n        } else if (resource instanceof CoverageInfo) {\r\n            info.getMimeFormats().clear();\r\n            info.getMimeFormats().addAll(defaults.getDefaultCoverageCacheFormats());\r\n        }\r\n        checkAutomaticStyles(layerInfo, info);\r\n    }\r\n    info.setName(tileLayerName(layerInfo));\r\n    info.setId(layerInfo.getId());\r\n    return info;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.reloadCatalogAndConfiguration",
	"Comment": "reloads the catalog and configuration from disk.this method can be used by subclasses from a test method after they have changed theconfiguration on disk.",
	"Method": "void reloadCatalogAndConfiguration(){\r\n    GeoServerLoaderProxy loader = GeoServerExtensions.bean(GeoServerLoaderProxy.class, applicationContext);\r\n    loader.reload();\r\n}"
}, {
	"Path": "org.geoserver.catalog.ResourcePool.setEntityResolverProvider",
	"Comment": "sets the entity resolver provider injected in the code doing xml parsing",
	"Method": "void setEntityResolverProvider(EntityResolverProvider entityResolverProvider){\r\n    this.entityResolverProvider = entityResolverProvider;\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.listMasterPasswordProviders",
	"Comment": "lists all available master password provider configurations.",
	"Method": "SortedSet<String> listMasterPasswordProviders(){\r\n    return listFiles(masterPasswordProvider());\r\n}"
}, {
	"Path": "org.geoserver.nsg.pagination.random.IndexConfigurationManager.loadConfigurations",
	"Comment": "helper method that loads configuration file and changes environment setup",
	"Method": "void loadConfigurations(Resource resource){\r\n    try {\r\n        IndexConfigurationManager.READ_WRITE_LOCK.writeLock().lock();\r\n        Properties properties = new Properties();\r\n        InputStream is = resource.in();\r\n        properties.load(is);\r\n        properties.replaceAll((k, v) -> ((String) v).replace(\"${GEOSERVER_DATA_DIR}\", dd.root().getPath()));\r\n        is.close();\r\n        Map<String, Object> params = new HashMap();\r\n        params.put(JDBCDataStoreFactory.DBTYPE.key, properties.get(PROPERTY_DB_PREFIX + JDBCDataStoreFactory.DBTYPE.key));\r\n        params.put(JDBCDataStoreFactory.DATABASE.key, properties.get(PROPERTY_DB_PREFIX + JDBCDataStoreFactory.DATABASE.key));\r\n        params.put(JDBCDataStoreFactory.HOST.key, properties.get(PROPERTY_DB_PREFIX + JDBCDataStoreFactory.HOST.key));\r\n        params.put(JDBCDataStoreFactory.PORT.key, properties.get(PROPERTY_DB_PREFIX + JDBCDataStoreFactory.PORT.key));\r\n        params.put(JDBCDataStoreFactory.SCHEMA.key, properties.get(PROPERTY_DB_PREFIX + JDBCDataStoreFactory.SCHEMA.key));\r\n        params.put(JDBCDataStoreFactory.USER.key, properties.get(PROPERTY_DB_PREFIX + JDBCDataStoreFactory.USER.key));\r\n        params.put(JDBCDataStoreFactory.PASSWD.key, properties.get(PROPERTY_DB_PREFIX + JDBCDataStoreFactory.PASSWD.key));\r\n        manageDBChange(params);\r\n        manageStorageChange(properties.get(\"resultSets.storage.path\"));\r\n        manageTimeToLiveChange(properties.get(\"resultSets.timeToLive\"));\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error reload configurations.\", exception);\r\n    } finally {\r\n        IndexConfigurationManager.READ_WRITE_LOCK.writeLock().unlock();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.ows.util.OwsUtils.setter",
	"Comment": "returns a setter method for a property of java bean.the type parameter may be null to indicate the the setter for theproperty should be returned regardless of the type. if not null it will be used to filter thereturned method.",
	"Method": "Method setter(Class clazz,String property,Class type){\r\n    return classProperties(clazz).setter(property, type);\r\n}"
}, {
	"Path": "org.geoserver.util.IOUtils.delete",
	"Comment": "recursively deletes the contents of the specified directory, and finally wipes out thedirectory itself. for each file that cannot be deleted a warning log will be issued.",
	"Method": "boolean delete(File directory,boolean delete,File directory,boolean quiet){\r\n    try {\r\n        emptyDirectory(directory, quiet);\r\n        return directory.delete();\r\n    } catch (Exception exception) {\r\n        if (!quiet) {\r\n            throw exception;\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.loadFilterConfig",
	"Comment": "loads an authentication provider config from a named configuration.null if not found",
	"Method": "SecurityFilterConfig loadFilterConfig(String name,MigrationHelper migrationHelper,SecurityFilterConfig loadFilterConfig,String name){\r\n    return filterHelper.loadConfig(name);\r\n}"
}, {
	"Path": "org.geoserver.platform.resource.Files.out",
	"Comment": "safe buffered output stream to temp file, output stream close used to renmae file into place.",
	"Method": "OutputStream out(OutputStream out,File file){\r\n    final File temp = new File(file.getParentFile(), file.getName() + \".tmp\");\r\n    if (temp.exists()) {\r\n        temp.delete();\r\n    }\r\n    return new OutputStream() {\r\n        FileOutputStream delegate = new FileOutputStream(temp);\r\n        @Override\r\n        public void close() throws IOException {\r\n            delegate.close();\r\n            Files.move(temp, file);\r\n        }\r\n        @Override\r\n        public void write(byte[] b, int off, int len) throws IOException {\r\n            delegate.write(b, off, len);\r\n        }\r\n        @Override\r\n        public void flush() throws IOException {\r\n            delegate.flush();\r\n        }\r\n        @Override\r\n        public void write(byte[] b) throws IOException {\r\n            delegate.write(b);\r\n        }\r\n        @Override\r\n        public void write(int b) throws IOException {\r\n            delegate.write(b);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.geoserver.platform.resource.Files.out",
	"Comment": "safe buffered output stream to temp file, output stream close used to renmae file into place.",
	"Method": "OutputStream out(OutputStream out,File file){\r\n    delegate.close();\r\n    Files.move(temp, file);\r\n}"
}, {
	"Path": "org.geoserver.platform.resource.Files.out",
	"Comment": "safe buffered output stream to temp file, output stream close used to renmae file into place.",
	"Method": "OutputStream out(OutputStream out,File file){\r\n    delegate.write(b, off, len);\r\n}"
}, {
	"Path": "org.geoserver.platform.resource.Files.out",
	"Comment": "safe buffered output stream to temp file, output stream close used to renmae file into place.",
	"Method": "OutputStream out(OutputStream out,File file){\r\n    delegate.flush();\r\n}"
}, {
	"Path": "org.geoserver.platform.resource.Files.out",
	"Comment": "safe buffered output stream to temp file, output stream close used to renmae file into place.",
	"Method": "OutputStream out(OutputStream out,File file){\r\n    delegate.write(b);\r\n}"
}, {
	"Path": "org.geoserver.platform.resource.Files.out",
	"Comment": "safe buffered output stream to temp file, output stream close used to renmae file into place.",
	"Method": "OutputStream out(OutputStream out,File file){\r\n    delegate.write(b);\r\n}"
}, {
	"Path": "org.geoserver.geofence.server.rest.AdminRulesRestController.findRules",
	"Comment": "helper method that will parse and retrieve the provided rules sorted by their priority.",
	"Method": "List<AdminRule> findRules(String rulesIds){\r\n    return Arrays.stream(rulesIds.split(\",\")).map(ruleId -> {\r\n        try {\r\n            return Long.parseLong(ruleId);\r\n        } catch (NumberFormatException exception) {\r\n            throw new InvalidRulesIds();\r\n        }\r\n    }).map(ruleId -> {\r\n        return adminService.get(ruleId);\r\n    }).filter(rule -> rule != null).sorted((ruleA, ruleB) -> Long.compare(ruleA.getPriority(), ruleB.getPriority())).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.geoserver.rest.converters.XStreamCatalogListConverter.aliasCollection",
	"Comment": "template method to alias the type of the collection.the default works with list, subclasses may override for instance to work with a set.",
	"Method": "void aliasCollection(Object data,XStream xstream,Class<?> clazz,RestListWrapper<?> wrapper){\r\n    XStreamPersister xp = xpf.createXMLPersister();\r\n    wrapper.configurePersister(xp, this);\r\n    final String alias = getItemName(xp, clazz);\r\n    xstream.alias(alias + \"s\", Collection.class, data.getClass());\r\n}"
}, {
	"Path": "org.geoserver.test.StationsMockData.substituteParameters",
	"Comment": "helper method that reads a resource to a string, performs the parameterization and writes theresult to the provided new file.",
	"Method": "void substituteParameters(String resourceName,Map<String, String> parameters,File newFile){\r\n    String resourceContent = resourceToString(resourceName);\r\n    for (Map.Entry<String, String> parameter : parameters.entrySet()) {\r\n        resourceContent = resourceContent.replace(String.format(\"${%s}\", parameter.getKey()), parameter.getValue());\r\n    }\r\n    try {\r\n        Files.write(newFile.toPath(), resourceContent.getBytes());\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(String.format(\"Error writing content to file '%s'.\", newFile.getAbsolutePath()), exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.csw.store.internal.CatalogStoreMapping.getIdentifierElement",
	"Comment": "getter for the identifier element, provides identifier expression for features",
	"Method": "CatalogStoreMappingElement getIdentifierElement(){\r\n    return identifier;\r\n}"
}, {
	"Path": "org.geoserver.config.util.SecureXStream.registerConverterDynamically",
	"Comment": "straight copy of the registerconverterdynamically private method of xstream",
	"Method": "void registerConverterDynamically(String className,int priority,Class[] constructorParamTypes,Object[] constructorParamValues){\r\n    try {\r\n        Class type = Class.forName(className, false, getClassLoaderReference().getReference());\r\n        Constructor constructor = type.getConstructor(constructorParamTypes);\r\n        Object instance = constructor.newInstance(constructorParamValues);\r\n        if (instance instanceof Converter) {\r\n            registerConverter((Converter) instance, priority);\r\n        } else if (instance instanceof SingleValueConverter) {\r\n            registerConverter((SingleValueConverter) instance, priority);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new com.thoughtworks.xstream.InitializationException(\"Could not instantiate converter : \" + className, e);\r\n    } catch (LinkageError e) {\r\n        throw new com.thoughtworks.xstream.InitializationException(\"Could not instantiate converter : \" + className, e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.WCSNetCDFTest.testInputMemoryCorrect",
	"Comment": "this test checks if an exception is not thrown when is requested an image with a total sizelower than the maximum geoserver input size.",
	"Method": "void testInputMemoryCorrect(){\r\n    setInputLimit(40);\r\n    MockHttpServletResponse response = getAsServletResponse(\"ows?request=GetCoverage&service=WCS&version=2.0.1\" + \"&coverageId=wcs__NO2&format=application/x-netcdf&subset=http://www.opengis.net/def/axis/OGC/0/elevation(450)\");\r\n    assertEquals(200, response.getStatus());\r\n    assertEquals(\"application/x-netcdf\", response.getContentType());\r\n    setInputLimit(-1);\r\n}"
}, {
	"Path": "org.geoserver.security.SecureCatalogImpl.filterResources",
	"Comment": "given a list of resources, returns a copy of it containing only the resources the user canaccess",
	"Method": "List<T> filterResources(Authentication user,List<T> resources){\r\n    List<T> result = new ArrayList<T>();\r\n    for (T original : resources) {\r\n        T secured = checkAccess(user, original, MixedModeBehavior.HIDE);\r\n        if (secured != null)\r\n            result.add(secured);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.ows.kvp.ElevationParser.getMaxElevations",
	"Comment": "maximum number of elevations this parser will parse before throwing an exception",
	"Method": "int getMaxElevations(){\r\n    if (maxElevations != null) {\r\n        return maxElevations;\r\n    } else {\r\n        return DEFAULT_MAX_ELEMENTS_ELEVATIONS_KVP;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.dxf.AbstractDXFWriter.writeHandle",
	"Comment": "writes an handle of the given type. the type is used to generate handles in different numericspaces, for different entities.",
	"Method": "String writeHandle(String type){\r\n    String handle = getNewHandle(type);\r\n    writeGroup(5, handle);\r\n    return handle;\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaTestSupport.getNamespace",
	"Comment": "returns the namespace uri for a given prefix configured in the test data.",
	"Method": "String getNamespace(String prefix){\r\n    return getNamespaces().get(prefix);\r\n}"
}, {
	"Path": "org.geoserver.script.ScriptManager.findOrCreateScriptDir",
	"Comment": "finds a script directory located at the specified path, creating the directory if it does notalready exist.",
	"Method": "File findOrCreateScriptDir(String path){\r\n    return script(path).dir();\r\n}"
}, {
	"Path": "org.geoserver.wps.DataTransformer.getComplexTransmuter",
	"Comment": "attempt to find complextransmuter for given java type and schema",
	"Method": "ComplexTransmuter getComplexTransmuter(Class<?> type,String schema){\r\n    for (Transmuter transmuter : this.transmuters) {\r\n        if (false == transmuter instanceof ComplexTransmuter) {\r\n            continue;\r\n        }\r\n        if (false == ((ComplexTransmuter) transmuter).getSchema(this.urlBase).equalsIgnoreCase(schema)) {\r\n            continue;\r\n        }\r\n        if (type != transmuter.getType()) {\r\n            continue;\r\n        }\r\n        return (ComplexTransmuter) transmuter;\r\n    }\r\n    throw new WPSException(\"NoApplicableCode\", \"Could not find ComplexTransmuter for '\" + schema + \"'.\");\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerBasePage.splitByCategory",
	"Comment": "splits up the pages by category, turning the list into a map keyed by category",
	"Method": "Map<Category, List<MenuPageInfo>> splitByCategory(List<MenuPageInfo> pages){\r\n    Collections.sort(pages);\r\n    HashMap<Category, List<MenuPageInfo>> map = new HashMap<Category, List<MenuPageInfo>>();\r\n    for (MenuPageInfo page : pages) {\r\n        Category cat = page.getCategory();\r\n        if (!map.containsKey(cat))\r\n            map.put(cat, new ArrayList<MenuPageInfo>());\r\n        map.get(cat).add(page);\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.DimensionsUtils.checkAndAddDimension",
	"Comment": "helper method that adds a dimension to a list of dimensions if the dimension is enabled.",
	"Method": "void checkAndAddDimension(List<Dimension> dimensions,Dimension dimension){\r\n    if (dimension.getDimensionInfo().isEnabled()) {\r\n        dimensions.add(dimension);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.xml.FeatureTypeSchemaBuilder.getWfsSchema",
	"Comment": "return any additional wfs xsdschema that the gml version might require, or null if notrequired.",
	"Method": "XSDSchema getWfsSchema(XSDSchema getWfsSchema,XSDSchema getWfsSchema){\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.spatialite.RestTest.createTestDatabase",
	"Comment": "helper method that just creates the test data store using geotools apis.",
	"Method": "void createTestDatabase(){\r\n    Map<String, String> params = new HashMap();\r\n    params.put(\"dbtype\", \"spatialite\");\r\n    params.put(\"database\", DATABASE_FILE.getAbsolutePath());\r\n    DataStore datastore = DataStoreFinder.getDataStore(params);\r\n    SimpleFeatureType featureType = DataUtilities.createType(\"points\", \"id:Integer,name:String,geometry:Point:srid=4326\");\r\n    datastore.createSchema(featureType);\r\n    SimpleFeatureSource featureSource = datastore.getFeatureSource(\"points\");\r\n    if (!(featureSource instanceof SimpleFeatureStore)) {\r\n        throw new RuntimeException(\"SpatiaLite data store doesn't support write access.\");\r\n    }\r\n    SimpleFeatureStore featureStore = (SimpleFeatureStore) featureSource;\r\n    Transaction transaction = new DefaultTransaction(\"create\");\r\n    featureStore.setTransaction(transaction);\r\n    SimpleFeatureCollection features = new ListFeatureCollection(featureType, new SimpleFeature[] { DataUtilities.createFeature(featureType, \"1|point_a|POINT(-1,1)\"), DataUtilities.createFeature(featureType, \"2|point_b|POINT(-1,-1)\"), DataUtilities.createFeature(featureType, \"3|point_c|POINT(1,-1)\"), DataUtilities.createFeature(featureType, \"4|point_d|POINT(1,1)\") });\r\n    try {\r\n        featureStore.addFeatures(features);\r\n        transaction.commit();\r\n    } finally {\r\n        transaction.close();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.geofence.server.rest.RulesRestController.findRules",
	"Comment": "helper method that will parse and retrieve the provided rules sorted by their priority.",
	"Method": "List<Rule> findRules(String rulesIds){\r\n    return Arrays.stream(rulesIds.split(\",\")).map(ruleId -> {\r\n        try {\r\n            return Long.parseLong(ruleId);\r\n        } catch (NumberFormatException exception) {\r\n            throw new InvalidRulesIds();\r\n        }\r\n    }).map(ruleId -> {\r\n        return adminService.get(ruleId);\r\n    }).filter(rule -> rule != null).sorted((ruleA, ruleB) -> Long.compare(ruleA.getPriority(), ruleB.getPriority())).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.ContourProcessTest.testProcessStandaloneBasicValues",
	"Comment": "test basic capabilities for the contour process. it works on the dem tiff and produces ashapefile. nothing more nothing less.",
	"Method": "void testProcessStandaloneBasicValues(){\r\n    GridCoverage2D gc = extractCoverageSubset();\r\n    final double[] levels = new double[2];\r\n    levels[0] = 1500;\r\n    levels[1] = 1700;\r\n    final ContourProcess process = new ContourProcess();\r\n    final SimpleFeatureCollection fc = process.execute(gc, 0, levels, null, false, false, null, new NullProgressListener());\r\n    assertNotNull(fc);\r\n    assertTrue(fc.size() > 0);\r\n    SimpleFeatureIterator fi = fc.features();\r\n    while (fi.hasNext()) {\r\n        SimpleFeature sf = fi.next();\r\n        Double value = (Double) sf.getAttribute(\"value\");\r\n        assertTrue(value == 1500.0 || value == 1700.0);\r\n    }\r\n    fi.close();\r\n}"
}, {
	"Path": "org.geoserver.security.password.MasterPasswordProviderConfig.setLoginEnabled",
	"Comment": "sets flag determining if the root can login to geoserver or not.",
	"Method": "void setLoginEnabled(boolean loginEnabled){\r\n    this.loginEnabled = loginEnabled;\r\n}"
}, {
	"Path": "org.geoserver.wps.process.AbstractRawData.getOutputMimeParameters",
	"Comment": "extracts the a map of process input parameters that should be filled with the chosen outputmime type for rawdata outputs, the map goes from the output result name to the input thatwill receive the user chosen mime type",
	"Method": "Map<String, String> getOutputMimeParameters(Name processName,ProcessFactory pf){\r\n    Map<String, Parameter<?>> resultInfo = pf.getResultInfo(processName, null);\r\n    Map<String, String> result = new HashMap<String, String>();\r\n    for (Parameter p : resultInfo.values()) {\r\n        if (RawData.class.isAssignableFrom(p.getType())) {\r\n            String attribute = (String) p.metadata.get(SELECTION_ATTRIBUTE);\r\n            if (attribute != null) {\r\n                if (result.containsValue(attribute)) {\r\n                    LOGGER.warning(\"In process \" + processName + \" two raw results parameter are using the same input attribute \" + attribute + \" to notify the process of the user chosen mime type\");\r\n                } else {\r\n                    result.put(p.key, attribute);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.CatalogInfoLookup.update",
	"Comment": "updates the value in the name map. the new value must be a modificationproxy",
	"Method": "void update(T proxiedValue){\r\n    ModificationProxy h = (ModificationProxy) Proxy.getInvocationHandler(proxiedValue);\r\n    T actualValue = (T) h.getProxyObject();\r\n    Name oldName = nameMapper.apply(actualValue);\r\n    Name newName = nameMapper.apply(proxiedValue);\r\n    if (!oldName.equals(newName)) {\r\n        Map<Name, T> nameMap = getMapForValue(nameMultiMap, actualValue);\r\n        nameMap.remove(oldName);\r\n        nameMap.put(newName, actualValue);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.getCatalog",
	"Comment": "accessor for global catalog instance from the test application context.",
	"Method": "Catalog getCatalog(){\r\n    return (Catalog) applicationContext.getBean(\"catalog\");\r\n}"
}, {
	"Path": "org.vfny.geoserver.util.DataStoreUtils.getParams",
	"Comment": "processed parameters with relative urls resolved against data directory.",
	"Method": "Map<K, V> getParams(Map<K, V> m,Map<K, V> getParams,Map<K, V> m,ServletContext sc){\r\n    GeoServerResourceLoader loader;\r\n    if (sc != null) {\r\n        String basePath = GeoServerResourceLoader.lookupGeoServerDataDirectory(sc);\r\n        File baseDir = new File(basePath);\r\n        loader = new GeoServerResourceLoader(baseDir);\r\n    } else {\r\n        loader = GeoServerExtensions.bean(GeoServerResourceLoader.class);\r\n    }\r\n    return ResourcePool.getParams(m, loader);\r\n}"
}, {
	"Path": "org.geoserver.gwc.GWC.autoConfigureLayers",
	"Comment": "creates new tile layers for the layers and layergroups given by their names using thesettings of the given default config options",
	"Method": "void autoConfigureLayers(List<String> catalogLayerNames,GWCConfig saneConfig){\r\n    checkArgument(saneConfig.isSane());\r\n    final Catalog catalog = getCatalog();\r\n    for (String name : catalogLayerNames) {\r\n        checkArgument(!tileLayerExists(name), \"Can't auto configure Layer, a tile layer named '\", name, \"' already exists.\");\r\n        GeoServerTileLayer tileLayer = null;\r\n        LayerInfo layer = catalog.getLayerByName(name);\r\n        if (layer != null) {\r\n            tileLayer = new GeoServerTileLayer(layer, saneConfig, gridSetBroker);\r\n        } else {\r\n            LayerGroupInfo layerGroup = catalog.getLayerGroupByName(name);\r\n            if (layerGroup != null) {\r\n                tileLayer = new GeoServerTileLayer(layerGroup, saneConfig, gridSetBroker);\r\n            }\r\n        }\r\n        if (tileLayer != null) {\r\n            add(tileLayer);\r\n        } else {\r\n            log.warning(\"Requested layer \" + name + \" does not exist. Won't create TileLayer\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.CatalogCapabilities.supportsIsolatedWorkspaces",
	"Comment": "if this method returns true it means that isolated workspaces are supported.",
	"Method": "boolean supportsIsolatedWorkspaces(){\r\n    return supportsIsolatedWorkspaces;\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexMongoDBSupport.checkMeasurementExists",
	"Comment": "helper method that checks that the provided xml document contains the correct stations andassociated measurement.",
	"Method": "void checkMeasurementExists(XpathEngine xpathEngine,Document document,String stationName,String stationMail,String measurementName,String measurementUnit,String measurementTimestamp,String measurementValue){\r\n    checkCount(xpathEngine, document, 1, String.format(\"/wfs:FeatureCollection/gml:featureMembers\" + \"/st:StationFeature[st:name='%s']/st:contact[st:mail='%s']\", stationName, stationMail));\r\n    checkCount(WFS11_XPATH_ENGINE, document, 1, String.format(\"/wfs:FeatureCollection/gml:featureMembers\" + \"/st:StationFeature[st:name='%s']/st:measurement/st:Measurement[st:name='%s'][st:unit='%s']\" + \"/st:values/st:Value[st:timestamp='%s'][st:value='%s']\", stationName, measurementName, measurementUnit, measurementTimestamp, measurementValue));\r\n}"
}, {
	"Path": "org.geoserver.security.xml.XMLXpath.compileRelativeAttribute",
	"Comment": "creates a relatvie xpathexpression for a xml attribute, needs name space prefix",
	"Method": "XPathExpression compileRelativeAttribute(XPath xpath,String attrName,String prefix){\r\n    return compile(xpath, \"@\" + attrName);\r\n}"
}, {
	"Path": "org.vfny.geoserver.global.xml.NameSpaceTranslator.isValidDefinition",
	"Comment": "isvaliddefinition purpose.checks to see if the definition provided is found in the list of elements for thisnamespace.",
	"Method": "boolean isValidDefinition(String definition){\r\n    if ((definition == null) || (definition == \"\")) {\r\n        return false;\r\n    }\r\n    Set elems = getElements();\r\n    Iterator i = elems.iterator();\r\n    while (i.hasNext()) {\r\n        NameSpaceElement nse = (NameSpaceElement) i.next();\r\n        if (nse == null) {\r\n            continue;\r\n        }\r\n        String def = nse.getTypeDefName();\r\n        if ((def != null) && def.equals(definition)) {\r\n            return true;\r\n        }\r\n        def = nse.getQualifiedTypeDefName();\r\n        if ((def != null) && def.equals(definition)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerHomePage.isAdmin",
	"Comment": "checks if the current user is authenticated and is the administrator",
	"Method": "boolean isAdmin(Authentication authentication){\r\n    return GeoServerExtensions.bean(GeoServerSecurityManager.class).checkAuthenticationForAdminRole(authentication);\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.ShapeZipOutputFormat.getFeatureTypeInfo",
	"Comment": "either retrieves the corresponding featuretypeinfo from the catalog or fakes one with thenecessary information",
	"Method": "FeatureTypeInfo getFeatureTypeInfo(SimpleFeatureType schema){\r\n    FeatureTypeInfo ftInfo = catalog.getFeatureTypeByName(schema.getName());\r\n    if (ftInfo == null) {\r\n        final SimpleFeatureSource featureSource = DataUtilities.source(new ListFeatureCollection(schema));\r\n        final CatalogBuilder catalogBuilder = new CatalogBuilder(catalog);\r\n        catalogBuilder.setStore(catalogBuilder.buildDataStore(schema.getName().getLocalPart()));\r\n        ftInfo = catalogBuilder.buildFeatureType(featureSource);\r\n    }\r\n    return ftInfo;\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.DimensionsUtils.getMinValue",
	"Comment": "helper method that return the minimum value. if the first value of the tree set is a rangethe minimum value of the range is returned.",
	"Method": "Object getMinValue(List<Object> values){\r\n    Object minValue = values.get(0);\r\n    if (minValue instanceof Range) {\r\n        return ((Range) minValue).getMinValue();\r\n    }\r\n    return minValue;\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.ReaderUtils.getDoubleAttribute",
	"Comment": "getdoubleattribute purpose.used to help with xml manipulations. returns the first child integer attribute of thespecified name. an exception occurs when the node is required and not found.",
	"Method": "double getDoubleAttribute(Element elem,String attName,boolean mandatory){\r\n    String value = getAttribute(elem, attName, mandatory);\r\n    if ((value == null) || (value == \"\")) {\r\n        return 0.0;\r\n    }\r\n    double d = Double.NaN;\r\n    if (value != null) {\r\n        try {\r\n            d = Double.parseDouble(value);\r\n        } catch (NumberFormatException ex) {\r\n            throw new ConfigurationException(\"Illegal attribute value for \" + attName + \" in element \" + elem.getNodeName() + \". Expected double, but was \" + value);\r\n        }\r\n    }\r\n    return d;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.getAsJSON",
	"Comment": "executes a request using the get method and parses the result as a json object.",
	"Method": "JSON getAsJSON(String path,int statusCode,JSON getAsJSON,String path){\r\n    MockHttpServletResponse response = getAsServletResponse(path);\r\n    return json(response);\r\n}"
}, {
	"Path": "org.geoserver.geofence.config.GeoFenceConfiguration.getInstanceName",
	"Comment": "name of this geoserver instance for geofence rule configuration.",
	"Method": "String getInstanceName(){\r\n    return instanceName;\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.DownloadProcessTest.testWrongOutputFormat",
	"Comment": "test with a wrong output format. it should thrown an exception.",
	"Method": "void testWrongOutputFormat(){\r\n    DownloadEstimatorProcess limits = new DownloadEstimatorProcess(new StaticDownloadServiceConfiguration(), getGeoServer());\r\n    final WPSResourceManager resourceManager = getResourceManager();\r\n    DownloadProcess downloadProcess = new DownloadProcess(getGeoServer(), limits, resourceManager);\r\n    FeatureTypeInfo ti = getCatalog().getFeatureTypeByName(getLayerId(MockData.POLYGONS));\r\n    SimpleFeatureCollection rawSource = (SimpleFeatureCollection) ti.getFeatureSource(null, null).getFeatures();\r\n    final DefaultProgressListener progressListener = new DefaultProgressListener();\r\n    try {\r\n        // layerName\r\n        downloadProcess.execute(getLayerId(MockData.POLYGONS), null, \"IAmWrong!!!\", null, CRS.decode(\"EPSG:32615\"), roi, false, null, null, null, null, null, progressListener);\r\n        Assert.assertTrue(\"We did not get an exception\", false);\r\n    } catch (Exception e) {\r\n        Assert.assertTrue(\"Everything as expected\", true);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.web.ProcessLimitsPage.buildValidators",
	"Comment": "turn the input limits into the ui into a set of operational validators, filtering out thosethat have empty or default input",
	"Method": "Multimap<String, WPSInputValidator> buildValidators(List<InputLimit> inputLimits){\r\n    Multimap<String, WPSInputValidator> result = ArrayListMultimap.create();\r\n    for (InputLimit inputLimit : inputLimits) {\r\n        String name = inputLimit.getName();\r\n        WPSInputValidator validator = inputLimit.getValidator();\r\n        if (validator.isUnset()) {\r\n            continue;\r\n        }\r\n        result.put(name, validator);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.monitor.ows.ControlFlowCallbackProxy.getRunningRequests",
	"Comment": "returns the number of running requests from the underlying control flow callback.",
	"Method": "long getRunningRequests(){\r\n    return (Long) OwsUtils.get(target, \"runningRequests\");\r\n}"
}, {
	"Path": "org.geoserver.ows.util.OwsUtils.getClassProperties",
	"Comment": "returns the properties object describing the properties of a class.",
	"Method": "ClassProperties getClassProperties(Class clazz){\r\n    return classProperties(clazz);\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.OpenSearchAccessProvider.getDataStoreInfo",
	"Comment": "returns the configuration of the store backing the opensearch subsystem",
	"Method": "DataStoreInfo getDataStoreInfo(){\r\n    OSEOInfo service = getService();\r\n    String openSearchAccessStoreId = service.getOpenSearchAccessStoreId();\r\n    if (openSearchAccessStoreId == null) {\r\n        throw new OWS20Exception(\"OpenSearchAccess is not configured in the\" + \" OpenSearch for EO panel, please do so\");\r\n    }\r\n    DataStoreInfo dataStore = this.geoServer.getCatalog().getDataStore(openSearchAccessStoreId);\r\n    return dataStore;\r\n}"
}, {
	"Path": "org.geoserver.data.test.LiveDbmsData.lookupFixture",
	"Comment": "looks up the fixture file in the home directory provided that the",
	"Method": "File lookupFixture(String fixtureId){\r\n    final String property = System.getProperty(\"gs.\" + fixtureId);\r\n    if (property != null && \"false\".equals(property.toLowerCase())) {\r\n        return null;\r\n    }\r\n    File base = new File(System.getProperty(\"user.home\"), \".geoserver\");\r\n    if (!base.exists())\r\n        base.mkdir();\r\n    File fixtureFile = new File(base, fixtureId + \".properties\");\r\n    if (!fixtureFile.exists()) {\r\n        final String warning = \"Disabling test based on fixture \" + fixtureId + \" since the file \" + fixtureFile + \" could not be found\";\r\n        disableTest(warning);\r\n        return null;\r\n    }\r\n    return fixtureFile;\r\n}"
}, {
	"Path": "org.geoserver.web.wicket.GeoServerTablePanel.updateFilter",
	"Comment": "parses the keywords and sets them into the data provider, forces update of the componentsthat need to as a result of the different filtering",
	"Method": "void updateFilter(AjaxRequestTarget target,String flatKeywords){\r\n    if (\"\".equals(flatKeywords)) {\r\n        dataProvider.setKeywords(null);\r\n        filter.setModelObject(\"\");\r\n        dataView.setCurrentPage(0);\r\n    } else {\r\n        String[] keywords = flatKeywords.split(\"\\\\s+\");\r\n        dataProvider.setKeywords(keywords);\r\n        dataView.setCurrentPage(0);\r\n    }\r\n    pagerDelegate.updateMatched();\r\n    navigatorTop.updateMatched();\r\n    navigatorBottom.updateMatched();\r\n    setSelection(false);\r\n    target.add(listContainer);\r\n    target.add(navigatorTop);\r\n    target.add(navigatorBottom);\r\n}"
}, {
	"Path": "org.geoserver.rest.wrapper.RestHttpInputWrapper.configurePersister",
	"Comment": "apply configuration to the xstreampersister based on the converter",
	"Method": "void configurePersister(XStreamPersister persister,XStreamMessageConverter xStreamMessageConverter){\r\n    controller.configurePersister(persister, xStreamMessageConverter);\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.DefaultOpenSearchEoService.getCollectionByParentIdentifier",
	"Comment": "returns the complex feature representing a collection by parentid",
	"Method": "Feature getCollectionByParentIdentifier(String parentId){\r\n    OpenSearchAccess access = getOpenSearchAccess();\r\n    final FeatureSource<FeatureType, Feature> collectionSource = access.getCollectionSource();\r\n    final NameImpl identifier = new NameImpl(OpenSearchAccess.EO_NAMESPACE, \"identifier\");\r\n    final PropertyIsEqualTo filter = FF.equal(FF.property(identifier), FF.literal(parentId), true);\r\n    Query query = new Query(collectionSource.getName().getLocalPart(), filter);\r\n    FeatureCollection<FeatureType, Feature> features = collectionSource.getFeatures(query);\r\n    Feature match = DataUtilities.first(features);\r\n    if (match == null) {\r\n        throw new OWS20Exception(\"Unknown parentId '\" + parentId + \"'\", OWSExceptionCode.InvalidParameterValue);\r\n    }\r\n    return match;\r\n}"
}, {
	"Path": "org.geoserver.wfs3.response.RFCGeoJSONFeaturesResponse.writeSingleFeature",
	"Comment": "writes a single feature using the facilities provided by the base class",
	"Method": "void writeSingleFeature(FeatureCollectionResponse value,OutputStream output,Operation operation){\r\n    OutputStreamWriter osw = new OutputStreamWriter(output, gs.getGlobal().getSettings().getCharset());\r\n    BufferedWriter outWriter = new BufferedWriter(osw);\r\n    FeatureCollectionResponse featureCollection = value;\r\n    boolean isComplex = isComplexFeature(featureCollection);\r\n    GeoJSONBuilder jsonWriter = getGeoJSONBuilder(featureCollection, outWriter);\r\n    writeFeatures(featureCollection.getFeatures(), operation, isComplex, jsonWriter);\r\n    outWriter.flush();\r\n}"
}, {
	"Path": "org.geoserver.script.rest.converter.ScriptConverter.encodeAlternateAtomLinkNoExt",
	"Comment": "the default encodealternateatomlink method calls the default href method and adds anextension to the link, this method is used to override that behavior.",
	"Method": "void encodeAlternateAtomLinkNoExt(String link,HierarchicalStreamWriter writer){\r\n    writer.startNode(\"atom:link\");\r\n    writer.addAttribute(\"xmlns:atom\", \"http://www.w3.org/2005/Atom\");\r\n    writer.addAttribute(\"rel\", \"alternate\");\r\n    writer.addAttribute(\"href\", hrefNoExt(link));\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.IsolatedCatalogFacade.getLocalNamespace",
	"Comment": "if a local workspace is set returns the namespace associated to it.",
	"Method": "NamespaceInfo getLocalNamespace(){\r\n    WorkspaceInfo localWorkspace = getLocalWorkspace();\r\n    if (localWorkspace != null) {\r\n        return facade.getNamespaceByPrefix(localWorkspace.getName());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.wfs.GetFeatureHitsIgnoreMaxFeaturesTest.testGetFeatureRespectsMaxFeatures",
	"Comment": "test that doing a getfeature request for data instead of hits still respects max featureswith the hitsignoremaxfeatures flag active",
	"Method": "void testGetFeatureRespectsMaxFeatures(){\r\n    WFSInfo wfs = getWFS();\r\n    wfs.setMaxFeatures(1);\r\n    wfs.setHitsIgnoreMaxFeatures(true);\r\n    getGeoServer().save(wfs);\r\n    Document doc = getAsDOM(\"wfs?request=GetFeature&typename=cdf:Fifteen\" + \"&version=1.1.0&service=wfs\");\r\n    assertEquals(\"wfs:FeatureCollection\", doc.getDocumentElement().getNodeName());\r\n    NodeList featureMembers = doc.getElementsByTagName(\"cdf:Fifteen\");\r\n    assertEquals(1, featureMembers.getLength());\r\n}"
}, {
	"Path": "org.geoserver.test.BBoxFilterTest.testQueryBboxLatLongEPSGCode",
	"Comment": "the following performs a wfs request specifying a bbox parameter of axis ordering latitudelongitude and srsname in epsg code format. this test should not return features if the axisordering behaves similar to queries to simple features.",
	"Method": "void testQueryBboxLatLongEPSGCode(){\r\n    Document doc = getAsDOM(WFS_GET_FEATURE + LATLONG + \",EPSG:4326\");\r\n    LOGGER.info(WFS_GET_FEATURE_LOG + LATLONG + prettyString(doc));\r\n    assertXpathEvaluatesTo(\"0\", \"/wfs:FeatureCollection/@numberOfFeatures\", doc);\r\n    assertXpathCount(0, \"//ex:geomContainer\", doc);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.getGeoServer",
	"Comment": "accessor for global geoserver instance from the test application context.",
	"Method": "GeoServer getGeoServer(){\r\n    return (GeoServer) applicationContext.getBean(\"geoServer\");\r\n}"
}, {
	"Path": "org.geoserver.wps.remote.plugin.XMPPClient.performLogin",
	"Comment": "logins as manager to the xmpp server and registers to the service channels management chatrooms",
	"Method": "void performLogin(String username,String password){\r\n    if (connection != null && connection.isConnected()) {\r\n        connection.login(username, password, getResource(username));\r\n        DiscussionHistory history = new DiscussionHistory();\r\n        history.setMaxStanzas(5);\r\n        mucManagementChannel = new MultiUserChat(connection, managementChannel + \"@\" + bus + \".\" + domain);\r\n        try {\r\n            mucManagementChannel.join(getJID(username), managementChannelPassword);\r\n        } catch (Exception e) {\r\n            mucManagementChannel.join(username, managementChannelPassword);\r\n        }\r\n        for (String channel : serviceChannels) {\r\n            MultiUserChat serviceChannel = new MultiUserChat(connection, channel + \"@\" + bus + \".\" + domain);\r\n            try {\r\n                serviceChannel.join(getJID(username), managementChannelPassword);\r\n            } catch (Exception e) {\r\n                serviceChannel.join(username, managementChannelPassword);\r\n            }\r\n            mucServiceChannels.add(serviceChannel);\r\n        }\r\n        setStatus(true, \"Orchestrator Active\");\r\n        setupListeners();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.csw.store.internal.GetRecordsTest.testUnsupportedOutputFormat",
	"Comment": "from cite compliance, throw an error the output format is not supported",
	"Method": "void testUnsupportedOutputFormat(){\r\n    String request = \"csw?service=CSW&version=2.0.2&request=GetRecords&typeNames=csw:Record&outputFormat=application/xhtml+xml\";\r\n    Document d = getAsDOM(request);\r\n    print(d);\r\n    checkOws10Exception(d, ServiceException.INVALID_PARAMETER_VALUE, \"outputFormat\");\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.GeoTIFFCoverageResponseDelegate.handleTiling",
	"Comment": "handle tiling encoding parameters for wcs.notice that tile width and height must be positive and multiple of 16.",
	"Method": "void handleTiling(Map<String, String> econdingParameters,GridCoverage2D sourceCoverage,GeoTiffWriterHelper helper){\r\n    final RenderedImage sourceImage = sourceCoverage.getRenderedImage();\r\n    final SampleModel sampleModel = sourceImage.getSampleModel();\r\n    final int sourceTileW = sampleModel.getWidth();\r\n    final int sourceTileH = sampleModel.getHeight();\r\n    final Dimension tileDimensions = new Dimension(sourceTileW, sourceTileH);\r\n    LOGGER.fine(\"Source tiling:\" + tileDimensions.width + \"x\" + tileDimensions.height);\r\n    final GridEnvelope gr = sourceCoverage.getGridGeometry().getGridRange();\r\n    if (gr.getSpan(0) < tileDimensions.width) {\r\n        tileDimensions.width = gr.getSpan(0);\r\n    }\r\n    if (gr.getSpan(1) < tileDimensions.height) {\r\n        tileDimensions.height = gr.getSpan(1);\r\n    }\r\n    LOGGER.fine(\"Source tiling reviewed to save space:\" + tileDimensions.width + \"x\" + tileDimensions.height);\r\n    if (econdingParameters.containsKey(\"tiling\")) {\r\n        final String tilingS = econdingParameters.get(\"tiling\");\r\n        if (tilingS != null && Boolean.valueOf(tilingS)) {\r\n            if (econdingParameters.containsKey(\"tilewidth\")) {\r\n                final String tileW_ = econdingParameters.get(\"tilewidth\");\r\n                if (tileW_ != null) {\r\n                    try {\r\n                        final int tileW = Integer.valueOf(tileW_);\r\n                        if (tileW > 0 && (tileW % 16 == 0)) {\r\n                            tileDimensions.width = tileW;\r\n                        } else {\r\n                            throw new OWS20Exception(\"Provided tile width is invalid\", ows20Code(WcsExceptionCode.TilingInvalid), Integer.toString(tileW));\r\n                        }\r\n                    } catch (Exception e) {\r\n                        throw new OWS20Exception(\"Provided tile width is invalid\", ows20Code(WcsExceptionCode.TilingInvalid), tileW_);\r\n                    }\r\n                }\r\n            }\r\n            if (econdingParameters.containsKey(\"tileheight\")) {\r\n                final String tileH_ = econdingParameters.get(\"tileheight\");\r\n                if (tileH_ != null) {\r\n                    try {\r\n                        final int tileH = Integer.valueOf(tileH_);\r\n                        if (tileH > 0 && (tileH % 16 == 0)) {\r\n                            tileDimensions.height = tileH;\r\n                        } else {\r\n                            throw new OWS20Exception(\"Provided tile height is invalid\", ows20Code(WcsExceptionCode.TilingInvalid), Integer.toString(tileH));\r\n                        }\r\n                    } catch (Exception e) {\r\n                        throw new OWS20Exception(\"Provided tile height is invalid\", ows20Code(WcsExceptionCode.TilingInvalid), tileH_);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        GeoTiffWriteParams wp = helper.getImageIoWriteParams();\r\n        helper.disableSourceCopyOptimization();\r\n        wp.setTilingMode(GeoToolsWriteParams.MODE_EXPLICIT);\r\n        wp.setTiling(tileDimensions.width, tileDimensions.height);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDimensionsSubsetHelper.extractElevationSubset",
	"Comment": "parses a number range out of the dimension subsetting directives",
	"Method": "NumberRange extractElevationSubset(){\r\n    NumberRange elevationSubset = null;\r\n    if (elevationDimension != null) {\r\n        for (DimensionSubsetType dim : request.getDimensionSubset()) {\r\n            String dimension = WCSDimensionsSubsetHelper.getDimensionName(dim);\r\n            if (!WCSDimensionsSubsetHelper.ELEVATION_NAMES.contains(dimension.toLowerCase())) {\r\n                continue;\r\n            }\r\n            if (elevationSubset != null) {\r\n                throw new WCS20Exception(\"Elevation dimension trimming/slicing specified twice in the request\", WCS20Exception.WCS20ExceptionCode.InvalidSubsetting, \"subset\");\r\n            }\r\n            if (dim instanceof DimensionTrimType) {\r\n                final DimensionTrimType trim = (DimensionTrimType) dim;\r\n                final Double low = PARSER.parseDouble(trim.getTrimLow());\r\n                final Double high = PARSER.parseDouble(trim.getTrimHigh());\r\n                if (low > high) {\r\n                    throw new WCS20Exception(\"Low greater than High: \" + trim.getTrimLow() + \", \" + trim.getTrimHigh(), WCS20Exception.WCS20ExceptionCode.InvalidSubsetting, \"subset\");\r\n                }\r\n                elevationSubset = new NumberRange<Double>(Double.class, low, high);\r\n            } else if (dim instanceof DimensionSliceType) {\r\n                final DimensionSliceType slicing = (DimensionSliceType) dim;\r\n                final String slicePointS = slicing.getSlicePoint();\r\n                final Double slicePoint = PARSER.parseDouble(slicePointS);\r\n                elevationSubset = new NumberRange<Double>(Double.class, slicePoint, slicePoint);\r\n            } else {\r\n                throw new WCS20Exception(\"Invalid element found while attempting to parse dimension subsetting request: \" + dim.getClass().toString(), WCS20Exception.WCS20ExceptionCode.InvalidSubsetting, \"subset\");\r\n            }\r\n        }\r\n        if (!(reader instanceof StructuredGridCoverage2DReader) && elevationSubset != null && !elevationSubset.getMinValue().equals(elevationSubset.getMaxValue())) {\r\n            throw new WCS20Exception(\"Trimming on elevation is not supported at the moment on not StructuredGridCoverage2DReaders, only slicing is\");\r\n        }\r\n        if (elevationSubset != null && elevationSubset.getMinValue().equals(elevationSubset.getMaxValue())) {\r\n            interpolateElevation(elevationSubset, accessor);\r\n        }\r\n    }\r\n    return elevationSubset;\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.encodeGeometry",
	"Comment": "encode feature geometry attribute which may not exist or be null. returns the geometryattribute name for the provided feature, null will be returned if the provided feature has nogeometry attribute.",
	"Method": "Property encodeGeometry(Feature feature){\r\n    GeometryDescriptor geometryType = feature.getType().getGeometryDescriptor();\r\n    Property geometryAttribute = null;\r\n    Geometry geometry = null;\r\n    if (geometryType != null) {\r\n        CoordinateReferenceSystem crs = geometryType.getCoordinateReferenceSystem();\r\n        jsonWriter.setAxisOrder(CRS.getAxisOrder(crs));\r\n        if (crs != null) {\r\n            this.crs = crs;\r\n        }\r\n        geometryAttribute = feature.getProperty(geometryType.getName());\r\n        geometry = (Geometry) geometryAttribute.getValue();\r\n    } else {\r\n        jsonWriter.setAxisOrder(CRS.AxisOrder.EAST_NORTH);\r\n    }\r\n    jsonWriter.key(\"geometry\");\r\n    if (geometry != null) {\r\n        jsonWriter.writeGeom(geometry);\r\n        geometryFound = true;\r\n    } else {\r\n        jsonWriter.value(null);\r\n    }\r\n    return geometryAttribute;\r\n}"
}, {
	"Path": "org.geoserver.wms.eo.web.EoLayerGroupAbstractPage.initUI",
	"Comment": "subclasses must call this method to initialize the ui for this page",
	"Method": "void initUI(LayerGroupInfo layerGroup){\r\n    this.returnPageClass = EoLayerGroupPage.class;\r\n    lgModel = new LayerGroupDetachableModel(layerGroup);\r\n    layerGroupId = layerGroup.getId();\r\n    add(popupWindow = new ModalWindow(\"popup\"));\r\n    add(dialog = new GeoServerDialog(\"dialog\"));\r\n    Form form = new Form(\"form\", new CompoundPropertyModel(lgModel)) {\r\n        @Override\r\n        public <C> IConverter<C> getConverter(Class<C> type) {\r\n            if (LayerInfo.class.isAssignableFrom(type)) {\r\n                return (IConverter<C>) new LayerInfoConverter();\r\n            } else if (StyleInfo.class.isAssignableFrom(type)) {\r\n                return (IConverter<C>) new StyleInfoConverter();\r\n            } else {\r\n                return super.getConverter(type);\r\n            }\r\n        }\r\n    };\r\n    add(form);\r\n    name = new TextField<String>(\"name\");\r\n    name.setRequired(true);\r\n    groupName = layerGroup.getName();\r\n    form.add(name);\r\n    form.add(new TextField(\"title\"));\r\n    form.add(new TextArea(\"abstract\"));\r\n    final DropDownChoice<WorkspaceInfo> wsChoice = new DropDownChoice(\"workspace\", new WorkspacesModel(), new WorkspaceChoiceRenderer());\r\n    wsChoice.setNullValid(true);\r\n    if (!isAuthenticatedAsAdmin()) {\r\n        wsChoice.setNullValid(false);\r\n        wsChoice.setRequired(true);\r\n    }\r\n    form.add(wsChoice);\r\n    form.add(envelopePanel = new EnvelopePanel(\"bounds\"));\r\n    envelopePanel.setRequired(true);\r\n    envelopePanel.setCRSFieldVisible(true);\r\n    envelopePanel.setCrsRequired(true);\r\n    envelopePanel.setOutputMarkupId(true);\r\n    form.add(new GeoServerAjaxFormLink(\"generateBounds\") {\r\n        @Override\r\n        public void onClick(AjaxRequestTarget target, Form form) {\r\n            LayerGroupInfo lg = getCatalog().getFactory().createLayerGroup();\r\n            for (EoLayerGroupEntry entry : lgEntryPanel.getEntries()) {\r\n                lg.getLayers().add(entry.getLayer());\r\n                lg.getStyles().add(entry.getStyle());\r\n            }\r\n            try {\r\n                CoordinateReferenceSystem crs = envelopePanel.getCoordinateReferenceSystem();\r\n                if (crs != null) {\r\n                    new CatalogBuilder(getCatalog()).calculateLayerGroupBounds(lg, crs);\r\n                } else {\r\n                    new CatalogBuilder(getCatalog()).calculateLayerGroupBounds(lg);\r\n                }\r\n                envelopePanel.setModelObject(lg.getBounds());\r\n                target.add(envelopePanel);\r\n            } catch (Exception e) {\r\n                throw new WicketRuntimeException(e);\r\n            }\r\n        }\r\n    });\r\n    form.add(lgEntryPanel = new EoLayerGroupEntryPanel(\"layers\", layerGroup, popupWindow));\r\n    lgEntryPanel.setOutputMarkupId(true);\r\n    EoLayerTypeRenderer eoLayerTypeRenderer = new EoLayerTypeRenderer();\r\n    final DropDownChoice<EoLayerType> layerTypes = new DropDownChoice<EoLayerType>(\"layerType\", EoLayerType.getRegularTypes(), eoLayerTypeRenderer);\r\n    layerTypes.setModel(new Model<EoLayerType>(null));\r\n    layerTypes.setOutputMarkupId(true);\r\n    form.add(layerTypes);\r\n    final GeoServerAjaxFormLink createStoreLink = new GeoServerAjaxFormLink(\"createStore\") {\r\n        @Override\r\n        public void onClick(AjaxRequestTarget target, Form form) {\r\n            final String layerGroupName = getNonNullGroupName(target);\r\n            if (layerGroupName != null) {\r\n                CoverageStoreNewPage coverageStoreCreator = new CoverageStoreNewPage(new ImageMosaicFormat().getName()) {\r\n                    protected void onSuccessfulSave(org.geoserver.catalog.CoverageStoreInfo info, org.geoserver.catalog.Catalog catalog, org.geoserver.catalog.CoverageStoreInfo savedStore) {\r\n                        EoCoverageSelectorPage page = new EoCoverageSelectorPage(EoLayerGroupAbstractPage.this, layerGroupName, savedStore.getId());\r\n                        setResponsePage(page);\r\n                    }\r\n                };\r\n                setResponsePage(coverageStoreCreator);\r\n            } else {\r\n                dialog.showInfo(target, null, new ParamResourceModel(\"layerInfoTitle\", EoLayerGroupAbstractPage.this), new ParamResourceModel(\"provideGroupName\", EoLayerGroupAbstractPage.this));\r\n            }\r\n        }\r\n    };\r\n    createStoreLink.setOutputMarkupId(true);\r\n    form.add(createStoreLink);\r\n    final GeoServerAjaxFormLink addFromStoreLink = new GeoServerAjaxFormLink(\"addFromStore\") {\r\n        @Override\r\n        public void onClick(AjaxRequestTarget target, Form form) {\r\n            final String layerGroupName = getNonNullGroupName(target);\r\n            if (layerGroupName != null) {\r\n                EoCoverageSelectorPage page = new EoCoverageSelectorPage(EoLayerGroupAbstractPage.this, layerGroupName);\r\n                setResponsePage(page);\r\n            } else {\r\n                dialog.showInfo(target, null, new ParamResourceModel(\"layerInfoTitle\", EoLayerGroupAbstractPage.this), new ParamResourceModel(\"provideGroupName\", EoLayerGroupAbstractPage.this));\r\n            }\r\n        }\r\n    };\r\n    addFromStoreLink.setOutputMarkupId(true);\r\n    form.add(addFromStoreLink);\r\n    final GeoServerAjaxFormLink addLayerLink = new GeoServerAjaxFormLink(\"addLayer\") {\r\n        @Override\r\n        public void onClick(AjaxRequestTarget target, Form form) {\r\n            popupWindow.setInitialHeight(375);\r\n            popupWindow.setInitialWidth(525);\r\n            popupWindow.setTitle(new ParamResourceModel(\"chooseLayer\", this));\r\n            layerTypes.processInput();\r\n            final EoLayerType layerType = layerTypes.getModelObject();\r\n            popupWindow.setContent(new EoLayerListPanel(popupWindow.getContentId(), layerType, lgEntryPanel.entryProvider) {\r\n                @Override\r\n                protected void handleLayer(LayerInfo layer, AjaxRequestTarget target) {\r\n                    popupWindow.close(target);\r\n                    layer.getMetadata().put(EoLayerType.KEY, layerType);\r\n                    lgEntryPanel.entryProvider.getItems().add(new EoLayerGroupEntry(layer, layer.getDefaultStyle(), groupName));\r\n                    target.add(lgEntryPanel);\r\n                    layerTypes.setDefaultModelObject(layerTypes.getDefaultModelObject());\r\n                    target.add(layerTypes);\r\n                }\r\n            });\r\n            popupWindow.show(target);\r\n        }\r\n    };\r\n    addLayerLink.setEnabled(false);\r\n    form.add(addLayerLink);\r\n    final DropDownChoice<EoLayerGroupEntry> outlinesEntryChooser = new DropDownChoice<EoLayerGroupEntry>(\"sourceLayer\", new OutlineSourceModel(lgEntryPanel.items), new LayerGroupEntryRenderer());\r\n    outlinesEntryChooser.setModel(new Model<EoLayerGroupEntry>(null));\r\n    outlinesEntryChooser.setOutputMarkupId(true);\r\n    outlinesEntryChooser.setEnabled(!outlinesPresent(lgEntryPanel.items));\r\n    form.add(outlinesEntryChooser);\r\n    outlinesEntryChooser.add(new AjaxFormComponentUpdatingBehavior(\"change\") {\r\n        @Override\r\n        protected void onUpdate(AjaxRequestTarget target) {\r\n            wsChoice.processInput();\r\n            WorkspaceInfo ws = (WorkspaceInfo) wsChoice.getDefaultModelObject();\r\n            outlinesEntryChooser.processInput();\r\n            EoLayerGroupEntry entry = outlinesEntryChooser.getModelObject();\r\n            try {\r\n                EoCatalogBuilder builder = new EoCatalogBuilder(getCatalog());\r\n                CoverageInfo coverage = (CoverageInfo) ((LayerInfo) entry.getLayer()).getResource();\r\n                CoverageStoreInfo store = coverage.getStore();\r\n                String url = store.getURL();\r\n                StructuredGridCoverage2DReader reader = (StructuredGridCoverage2DReader) coverage.getGridCoverageReader(null, null);\r\n                LayerInfo layer = builder.createEoOutlineLayer(url, ws, groupName, coverage.getNativeCoverageName(), reader);\r\n                lgEntryPanel.items.add(new EoLayerGroupEntry(layer, layer.getDefaultStyle(), groupName));\r\n            } catch (Exception e) {\r\n                LOGGER.log(Level.SEVERE, \"Failed to create outlines layer\", e);\r\n                String layerName = entry.getLayer().prefixedName();\r\n                error(new ParamResourceModel(\"outlinesCreationError\", EoLayerGroupAbstractPage.this, layerName, e.getMessage()).getString());\r\n            } finally {\r\n                outlinesEntryChooser.setDefaultModelObject(null);\r\n            }\r\n            target.add(lgEntryPanel);\r\n            addFeedbackPanels(target);\r\n            target.add(outlinesEntryChooser);\r\n        }\r\n    });\r\n    layerTypes.add(new AjaxFormComponentUpdatingBehavior(\"change\") {\r\n        @Override\r\n        protected void onUpdate(AjaxRequestTarget target) {\r\n            layerTypes.processInput();\r\n            boolean input = layerTypes.getModelObject() != null;\r\n            addLayerLink.setEnabled(input);\r\n            target.add(addLayerLink);\r\n        }\r\n    });\r\n    name.add(new AjaxFormComponentUpdatingBehavior(\"blur\") {\r\n        @Override\r\n        protected void onUpdate(AjaxRequestTarget target) {\r\n            groupName = name.getInput();\r\n            boolean nameAvailable = groupName != null && !\"\".equals(groupName.trim());\r\n            if (!nameAvailable) {\r\n                info(new ParamResourceModel(\"provideGroupName\", EoLayerGroupAbstractPage.this).getString());\r\n            } else {\r\n                if (isLayerRenameRequired(groupName)) {\r\n                    info(new ParamResourceModel(\"layerRenameWarning\", EoLayerGroupAbstractPage.this, groupName).getString());\r\n                }\r\n            }\r\n            target.add(createStoreLink);\r\n            target.add(addFromStoreLink);\r\n            addFeedbackPanels(target);\r\n        }\r\n    });\r\n    if (name.getDefaultModelObject() == null || \"\".equals(name.getDefaultModelObject())) {\r\n        info(new ParamResourceModel(\"provideGroupName\", this).getString());\r\n    }\r\n    form.add(saveLink());\r\n    form.add(cancelLink());\r\n}"
}, {
	"Path": "org.geoserver.wms.eo.web.EoLayerGroupAbstractPage.initUI",
	"Comment": "subclasses must call this method to initialize the ui for this page",
	"Method": "void initUI(LayerGroupInfo layerGroup){\r\n    if (LayerInfo.class.isAssignableFrom(type)) {\r\n        return (IConverter<C>) new LayerInfoConverter();\r\n    } else if (StyleInfo.class.isAssignableFrom(type)) {\r\n        return (IConverter<C>) new StyleInfoConverter();\r\n    } else {\r\n        return super.getConverter(type);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wms.eo.web.EoLayerGroupAbstractPage.initUI",
	"Comment": "subclasses must call this method to initialize the ui for this page",
	"Method": "void initUI(LayerGroupInfo layerGroup){\r\n    LayerGroupInfo lg = getCatalog().getFactory().createLayerGroup();\r\n    for (EoLayerGroupEntry entry : lgEntryPanel.getEntries()) {\r\n        lg.getLayers().add(entry.getLayer());\r\n        lg.getStyles().add(entry.getStyle());\r\n    }\r\n    try {\r\n        CoordinateReferenceSystem crs = envelopePanel.getCoordinateReferenceSystem();\r\n        if (crs != null) {\r\n            new CatalogBuilder(getCatalog()).calculateLayerGroupBounds(lg, crs);\r\n        } else {\r\n            new CatalogBuilder(getCatalog()).calculateLayerGroupBounds(lg);\r\n        }\r\n        envelopePanel.setModelObject(lg.getBounds());\r\n        target.add(envelopePanel);\r\n    } catch (Exception e) {\r\n        throw new WicketRuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wms.eo.web.EoLayerGroupAbstractPage.initUI",
	"Comment": "subclasses must call this method to initialize the ui for this page",
	"Method": "void initUI(LayerGroupInfo layerGroup){\r\n    final String layerGroupName = getNonNullGroupName(target);\r\n    if (layerGroupName != null) {\r\n        CoverageStoreNewPage coverageStoreCreator = new CoverageStoreNewPage(new ImageMosaicFormat().getName()) {\r\n            protected void onSuccessfulSave(org.geoserver.catalog.CoverageStoreInfo info, org.geoserver.catalog.Catalog catalog, org.geoserver.catalog.CoverageStoreInfo savedStore) {\r\n                EoCoverageSelectorPage page = new EoCoverageSelectorPage(EoLayerGroupAbstractPage.this, layerGroupName, savedStore.getId());\r\n                setResponsePage(page);\r\n            }\r\n        };\r\n        setResponsePage(coverageStoreCreator);\r\n    } else {\r\n        dialog.showInfo(target, null, new ParamResourceModel(\"layerInfoTitle\", EoLayerGroupAbstractPage.this), new ParamResourceModel(\"provideGroupName\", EoLayerGroupAbstractPage.this));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wms.eo.web.EoLayerGroupAbstractPage.initUI",
	"Comment": "subclasses must call this method to initialize the ui for this page",
	"Method": "void initUI(LayerGroupInfo layerGroup){\r\n    EoCoverageSelectorPage page = new EoCoverageSelectorPage(EoLayerGroupAbstractPage.this, layerGroupName, savedStore.getId());\r\n    setResponsePage(page);\r\n}"
}, {
	"Path": "org.geoserver.wms.eo.web.EoLayerGroupAbstractPage.initUI",
	"Comment": "subclasses must call this method to initialize the ui for this page",
	"Method": "void initUI(LayerGroupInfo layerGroup){\r\n    final String layerGroupName = getNonNullGroupName(target);\r\n    if (layerGroupName != null) {\r\n        EoCoverageSelectorPage page = new EoCoverageSelectorPage(EoLayerGroupAbstractPage.this, layerGroupName);\r\n        setResponsePage(page);\r\n    } else {\r\n        dialog.showInfo(target, null, new ParamResourceModel(\"layerInfoTitle\", EoLayerGroupAbstractPage.this), new ParamResourceModel(\"provideGroupName\", EoLayerGroupAbstractPage.this));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wms.eo.web.EoLayerGroupAbstractPage.initUI",
	"Comment": "subclasses must call this method to initialize the ui for this page",
	"Method": "void initUI(LayerGroupInfo layerGroup){\r\n    popupWindow.setInitialHeight(375);\r\n    popupWindow.setInitialWidth(525);\r\n    popupWindow.setTitle(new ParamResourceModel(\"chooseLayer\", this));\r\n    layerTypes.processInput();\r\n    final EoLayerType layerType = layerTypes.getModelObject();\r\n    popupWindow.setContent(new EoLayerListPanel(popupWindow.getContentId(), layerType, lgEntryPanel.entryProvider) {\r\n        @Override\r\n        protected void handleLayer(LayerInfo layer, AjaxRequestTarget target) {\r\n            popupWindow.close(target);\r\n            layer.getMetadata().put(EoLayerType.KEY, layerType);\r\n            lgEntryPanel.entryProvider.getItems().add(new EoLayerGroupEntry(layer, layer.getDefaultStyle(), groupName));\r\n            target.add(lgEntryPanel);\r\n            layerTypes.setDefaultModelObject(layerTypes.getDefaultModelObject());\r\n            target.add(layerTypes);\r\n        }\r\n    });\r\n    popupWindow.show(target);\r\n}"
}, {
	"Path": "org.geoserver.wms.eo.web.EoLayerGroupAbstractPage.initUI",
	"Comment": "subclasses must call this method to initialize the ui for this page",
	"Method": "void initUI(LayerGroupInfo layerGroup){\r\n    popupWindow.close(target);\r\n    layer.getMetadata().put(EoLayerType.KEY, layerType);\r\n    lgEntryPanel.entryProvider.getItems().add(new EoLayerGroupEntry(layer, layer.getDefaultStyle(), groupName));\r\n    target.add(lgEntryPanel);\r\n    layerTypes.setDefaultModelObject(layerTypes.getDefaultModelObject());\r\n    target.add(layerTypes);\r\n}"
}, {
	"Path": "org.geoserver.wms.eo.web.EoLayerGroupAbstractPage.initUI",
	"Comment": "subclasses must call this method to initialize the ui for this page",
	"Method": "void initUI(LayerGroupInfo layerGroup){\r\n    wsChoice.processInput();\r\n    WorkspaceInfo ws = (WorkspaceInfo) wsChoice.getDefaultModelObject();\r\n    outlinesEntryChooser.processInput();\r\n    EoLayerGroupEntry entry = outlinesEntryChooser.getModelObject();\r\n    try {\r\n        EoCatalogBuilder builder = new EoCatalogBuilder(getCatalog());\r\n        CoverageInfo coverage = (CoverageInfo) ((LayerInfo) entry.getLayer()).getResource();\r\n        CoverageStoreInfo store = coverage.getStore();\r\n        String url = store.getURL();\r\n        StructuredGridCoverage2DReader reader = (StructuredGridCoverage2DReader) coverage.getGridCoverageReader(null, null);\r\n        LayerInfo layer = builder.createEoOutlineLayer(url, ws, groupName, coverage.getNativeCoverageName(), reader);\r\n        lgEntryPanel.items.add(new EoLayerGroupEntry(layer, layer.getDefaultStyle(), groupName));\r\n    } catch (Exception e) {\r\n        LOGGER.log(Level.SEVERE, \"Failed to create outlines layer\", e);\r\n        String layerName = entry.getLayer().prefixedName();\r\n        error(new ParamResourceModel(\"outlinesCreationError\", EoLayerGroupAbstractPage.this, layerName, e.getMessage()).getString());\r\n    } finally {\r\n        outlinesEntryChooser.setDefaultModelObject(null);\r\n    }\r\n    target.add(lgEntryPanel);\r\n    addFeedbackPanels(target);\r\n    target.add(outlinesEntryChooser);\r\n}"
}, {
	"Path": "org.geoserver.wms.eo.web.EoLayerGroupAbstractPage.initUI",
	"Comment": "subclasses must call this method to initialize the ui for this page",
	"Method": "void initUI(LayerGroupInfo layerGroup){\r\n    layerTypes.processInput();\r\n    boolean input = layerTypes.getModelObject() != null;\r\n    addLayerLink.setEnabled(input);\r\n    target.add(addLayerLink);\r\n}"
}, {
	"Path": "org.geoserver.wms.eo.web.EoLayerGroupAbstractPage.initUI",
	"Comment": "subclasses must call this method to initialize the ui for this page",
	"Method": "void initUI(LayerGroupInfo layerGroup){\r\n    groupName = name.getInput();\r\n    boolean nameAvailable = groupName != null && !\"\".equals(groupName.trim());\r\n    if (!nameAvailable) {\r\n        info(new ParamResourceModel(\"provideGroupName\", EoLayerGroupAbstractPage.this).getString());\r\n    } else {\r\n        if (isLayerRenameRequired(groupName)) {\r\n            info(new ParamResourceModel(\"layerRenameWarning\", EoLayerGroupAbstractPage.this, groupName).getString());\r\n        }\r\n    }\r\n    target.add(createStoreLink);\r\n    target.add(addFromStoreLink);\r\n    addFeedbackPanels(target);\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.parsedSld",
	"Comment": "retrieve the styled layer descriptor prepared for direct geotools use. all file referenceshave been made absolute.",
	"Method": "StyledLayerDescriptor parsedSld(StyleInfo s){\r\n    final Resource styleResource = style(s);\r\n    if (styleResource.getType() == Type.UNDEFINED) {\r\n        throw new IOException(\"No such resource: \" + s.getFilename());\r\n    }\r\n    File input = styleResource.file();\r\n    DefaultResourceLocator locator = new DefaultResourceLocator() {\r\n        @Override\r\n        public URL locateResource(String uri) {\r\n            URL url = super.locateResource(uri);\r\n            if (url != null && url.getProtocol().equalsIgnoreCase(\"resource\")) {\r\n                Resource resource = resourceLoader.fromURL(url);\r\n                File file;\r\n                if (Resources.exists(resource)) {\r\n                    file = resource.file();\r\n                } else {\r\n                    file = Paths.toFile(root(), resource.path());\r\n                }\r\n                URL u = fileToUrlPreservingCqlTemplates(file);\r\n                if (url.getQuery() != null) {\r\n                    try {\r\n                        u = new URL(u.toString() + \"?\" + url.getQuery());\r\n                    } catch (MalformedURLException ex) {\r\n                        GeoServerConfigPersister.LOGGER.log(Level.WARNING, \"Error processing query string for resource with uri: \" + uri, ex);\r\n                        return null;\r\n                    }\r\n                }\r\n                if (url.getRef() != null) {\r\n                    try {\r\n                        u = new URL(u.toString() + \"#\" + url.getRef());\r\n                    } catch (MalformedURLException ex) {\r\n                        GeoServerConfigPersister.LOGGER.log(Level.WARNING, \"Error processing # fragment for resource with uri: \" + uri, ex);\r\n                        return null;\r\n                    }\r\n                }\r\n                return u;\r\n            } else {\r\n                return url;\r\n            }\r\n        }\r\n        @Override\r\n        protected URL validateRelativeURL(URL relativeUrl) {\r\n            if (relativeUrl.getProtocol().equalsIgnoreCase(\"resource\")) {\r\n                return relativeUrl;\r\n            } else {\r\n                return super.validateRelativeURL(relativeUrl);\r\n            }\r\n        }\r\n    };\r\n    locator.setSourceUrl(Resources.toURL(styleResource));\r\n    EntityResolver entityResolver = getEntityResolver();\r\n    final StyledLayerDescriptor sld = Styles.handler(s.getFormat()).parse(input, s.getFormatVersion(), locator, getEntityResolver());\r\n    return sld;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.parsedSld",
	"Comment": "retrieve the styled layer descriptor prepared for direct geotools use. all file referenceshave been made absolute.",
	"Method": "StyledLayerDescriptor parsedSld(StyleInfo s){\r\n    URL url = super.locateResource(uri);\r\n    if (url != null && url.getProtocol().equalsIgnoreCase(\"resource\")) {\r\n        Resource resource = resourceLoader.fromURL(url);\r\n        File file;\r\n        if (Resources.exists(resource)) {\r\n            file = resource.file();\r\n        } else {\r\n            file = Paths.toFile(root(), resource.path());\r\n        }\r\n        URL u = fileToUrlPreservingCqlTemplates(file);\r\n        if (url.getQuery() != null) {\r\n            try {\r\n                u = new URL(u.toString() + \"?\" + url.getQuery());\r\n            } catch (MalformedURLException ex) {\r\n                GeoServerConfigPersister.LOGGER.log(Level.WARNING, \"Error processing query string for resource with uri: \" + uri, ex);\r\n                return null;\r\n            }\r\n        }\r\n        if (url.getRef() != null) {\r\n            try {\r\n                u = new URL(u.toString() + \"#\" + url.getRef());\r\n            } catch (MalformedURLException ex) {\r\n                GeoServerConfigPersister.LOGGER.log(Level.WARNING, \"Error processing # fragment for resource with uri: \" + uri, ex);\r\n                return null;\r\n            }\r\n        }\r\n        return u;\r\n    } else {\r\n        return url;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.parsedSld",
	"Comment": "retrieve the styled layer descriptor prepared for direct geotools use. all file referenceshave been made absolute.",
	"Method": "StyledLayerDescriptor parsedSld(StyleInfo s){\r\n    if (relativeUrl.getProtocol().equalsIgnoreCase(\"resource\")) {\r\n        return relativeUrl;\r\n    } else {\r\n        return super.validateRelativeURL(relativeUrl);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.useLegacyDataDirectory",
	"Comment": "flag which controls the mock data directory setup.if true is returned, the legacy structure is presevered on sstartup, and no conversion tothe new data directory structure happens.",
	"Method": "boolean useLegacyDataDirectory(){\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.catalog.Catalog.getCatalogCapabilities",
	"Comment": "return the catalog capabilities supported by this catalog. normally this will correspond tothe capabilities supported by the used catalog facade.",
	"Method": "CatalogCapabilities getCatalogCapabilities(){\r\n    return new CatalogCapabilities();\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.GeoJSONGetFeatureResponse.isComplexFeature",
	"Comment": "helper method that checks if the results feature collections contain complex features.",
	"Method": "boolean isComplexFeature(FeatureCollectionResponse results){\r\n    for (FeatureCollection featureCollection : results.getFeatures()) {\r\n        if (!(featureCollection.getSchema() instanceof SimpleFeatureType)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.security.validation.AbstractSecurityValidator.lookupBean",
	"Comment": "helper for looking up a named spring bean in application context.",
	"Method": "Object lookupBean(String name){\r\n    Object bean = GeoServerExtensions.bean(name, manager.getApplicationContext());\r\n    if (bean == null) {\r\n        throw new NoSuchBeanDefinitionException(name);\r\n    }\r\n    return bean;\r\n}"
}, {
	"Path": "org.geoserver.sldservice.utils.classifier.RulesBuilder.closedRangedRules",
	"Comment": "generate rules from rangedclassifier groups build a list of rules",
	"Method": "List<Rule> closedRangedRules(RangedClassifier groups,String property,Class<?> propertyType,boolean normalize){\r\n    Rule r;\r\n    Filter f;\r\n    List<Rule> list = new ArrayList();\r\n    Expression att = normalizeProperty(FF.property(property), propertyType, normalize);\r\n    try {\r\n        r = SF.createRule();\r\n        for (int i = 0; i < groups.getSize(); i++) {\r\n            r = SF.createRule();\r\n            if (groups.getMin(i).equals(groups.getMax(i))) {\r\n                f = FF.equals(att, FF.literal(groups.getMin(i)));\r\n                r.setTitle(FF.literal(groups.getMin(i)).toString());\r\n                r.setFilter(f);\r\n                list.add(r);\r\n            } else {\r\n                f = FF.and(FF.greaterOrEqual(att, FF.literal(groups.getMin(i))), i == (groups.getSize() - 1) ? FF.lessOrEqual(att, FF.literal(groups.getMax(i))) : FF.less(att, FF.literal(groups.getMax(i))));\r\n                r.setTitle(\" >= \" + FF.literal(groups.getMin(i)) + \" AND \" + (i == (groups.getSize() - 1) ? \"<=\" : \"<\") + FF.literal(groups.getMax(i)));\r\n                r.setFilter(f);\r\n                list.add(r);\r\n            }\r\n        }\r\n        return list;\r\n    } catch (Exception e) {\r\n        if (LOGGER.isLoggable(Level.INFO))\r\n            LOGGER.log(Level.INFO, \"Failed to build closed Ranged Rules\" + e.getLocalizedMessage(), e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.data.CatalogReader.dataStoreParams",
	"Comment": "convenience method for reading connection parameters from a datastore element.",
	"Method": "Map dataStoreParams(Element dataStoreElement){\r\n    Element paramsElement = ReaderUtils.getChildElement(dataStoreElement, \"connectionParameters\", true);\r\n    NodeList paramList = paramsElement.getElementsByTagName(\"parameter\");\r\n    Map params = new HashMap();\r\n    for (int i = 0; i < paramList.getLength(); i++) {\r\n        Element paramElement = (Element) paramList.item(i);\r\n        String key = ReaderUtils.getAttribute(paramElement, \"name\", true);\r\n        String value = ReaderUtils.getAttribute(paramElement, \"value\", true);\r\n        params.put(key, value);\r\n    }\r\n    return params;\r\n}"
}, {
	"Path": "org.geoserver.config.util.XStreamPersister.setUnwrapNulls",
	"Comment": "sets null handling in proxy objects. defaults to unwrap. if set to false, proxy object arenot transformed to nulls.",
	"Method": "void setUnwrapNulls(boolean unwrapNulls){\r\n    this.unwrapNulls = unwrapNulls;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.GetCoverage.readCoverage",
	"Comment": "this method is responsible for reading the data based on the specified request. it mightreturn a single coverage, but if the request is a dateline crossing one, it will return twoinstead",
	"Method": "List<GridCoverage2D> readCoverage(WCSDimensionsSubsetHelper helper,GridCoverageRequest request,GridCoverage2DReader reader,Hints hints,ImageSizeRecorder incrementalInputSize,ScalingType scaling,double[] preAppliedScale,GridCoverage2D readCoverage,CoverageInfo cinfo,GridCoverageRequest request,GridCoverage2DReader reader,Hints hints,ImageSizeRecorder incrementalInputSize,Interpolation spatialInterpolation,CoordinateReferenceSystem coverageCRS,Envelope subset,WCSEnvelope requestedEnvelope,ScalingType scaling,double[] preAppliedScale){\r\n    if (!CRS.equalsIgnoreMetadata(subset.getCoordinateReferenceSystem(), coverageCRS)) {\r\n        subset = CRS.transform(subset, coverageCRS);\r\n    }\r\n    final GridGeometry2D readGG;\r\n    CoordinateReferenceSystem outputCRS = request.getOutputCRS();\r\n    final boolean equalsMetadata = CRS.equalsIgnoreMetadata(outputCRS, coverageCRS);\r\n    boolean sameCRS;\r\n    try {\r\n        sameCRS = equalsMetadata ? true : CRS.findMathTransform(outputCRS, coverageCRS, true).isIdentity();\r\n    } catch (FactoryException e1) {\r\n        final IOException ioe = new IOException();\r\n        ioe.initCause(e1);\r\n        throw ioe;\r\n    }\r\n    final ParameterValueGroup readParametersDescriptor = reader.getFormat().getReadParameters();\r\n    GeneralParameterValue[] readParameters = CoverageUtils.getParameters(readParametersDescriptor, cinfo.getParameters());\r\n    readParameters = (readParameters != null ? readParameters : new GeneralParameterValue[0]);\r\n    readParameters = WCSUtils.replaceParameter(readParameters, Boolean.TRUE, AbstractGridFormat.USE_JAI_IMAGEREAD);\r\n    if (request.getTemporalSubset() != null) {\r\n        List<GeneralParameterDescriptor> descriptors = readParametersDescriptor.getDescriptor().descriptors();\r\n        List<Object> times = new ArrayList<Object>();\r\n        times.add(request.getTemporalSubset());\r\n        readParameters = CoverageUtils.mergeParameter(descriptors, readParameters, times, \"TIME\", \"Time\");\r\n    }\r\n    if (request.getElevationSubset() != null) {\r\n        List<GeneralParameterDescriptor> descriptors = readParametersDescriptor.getDescriptor().descriptors();\r\n        List<Object> elevations = new ArrayList<Object>();\r\n        elevations.add(request.getElevationSubset());\r\n        readParameters = CoverageUtils.mergeParameter(descriptors, readParameters, elevations, \"ELEVATION\", \"Elevation\");\r\n    }\r\n    if (request.getFilter() != null) {\r\n        List<GeneralParameterDescriptor> descriptors = readParametersDescriptor.getDescriptor().descriptors();\r\n        readParameters = CoverageUtils.mergeParameter(descriptors, readParameters, request.getFilter(), \"Filter\");\r\n    }\r\n    if (request.getSortBy() != null) {\r\n        List<GeneralParameterDescriptor> descriptors = readParametersDescriptor.getDescriptor().descriptors();\r\n        String sortBySpec = request.getSortBy().stream().map(sb -> sb.getPropertyName().getPropertyName() + \" \" + sb.getSortOrder().name().charAt(0)).collect(Collectors.joining(\",\"));\r\n        readParameters = CoverageUtils.mergeParameter(descriptors, readParameters, sortBySpec, \"SORTING\");\r\n    }\r\n    if (request.getDimensionsSubset() != null && !request.getDimensionsSubset().isEmpty()) {\r\n        final List<GeneralParameterDescriptor> descriptors = new ArrayList<GeneralParameterDescriptor>(readParametersDescriptor.getDescriptor().descriptors());\r\n        Set<ParameterDescriptor<List>> dynamicParameters = reader.getDynamicParameters();\r\n        descriptors.addAll(dynamicParameters);\r\n        Map<String, List<Object>> dimensionsSubset = request.getDimensionsSubset();\r\n        Set<String> dimensionKeys = dimensionsSubset.keySet();\r\n        for (String key : dimensionKeys) {\r\n            List<Object> dimValues = dimensionsSubset.get(key);\r\n            readParameters = CoverageUtils.mergeParameter(descriptors, readParameters, dimValues, key);\r\n        }\r\n    }\r\n    GridCoverage2D coverage = null;\r\n    if (sameCRS) {\r\n        MathTransform transform = getMathTransform(reader, requestedEnvelope != null ? requestedEnvelope : subset, request, PixelInCell.CELL_CENTER, scaling);\r\n        readGG = new GridGeometry2D(PixelInCell.CELL_CENTER, transform, subset, hints);\r\n    } else {\r\n        Rectangle rasterRange = CRS.transform(reader.getOriginalGridToWorld(PixelInCell.CELL_CORNER).inverse(), subset).toRectangle2D().getBounds();\r\n        rasterRange.setBounds(rasterRange.x - 10, rasterRange.y - 10, rasterRange.width + 20, rasterRange.height + 20);\r\n        rasterRange = rasterRange.intersection((GridEnvelope2D) reader.getOriginalGridRange());\r\n        readGG = new GridGeometry2D(new GridEnvelope2D(rasterRange), PixelInCell.CELL_CENTER, reader.getOriginalGridToWorld(PixelInCell.CELL_CENTER), coverageCRS, hints);\r\n    }\r\n    WCSUtils.checkInputLimits(wcs, cinfo, reader, readGG);\r\n    Hints readHints = new Hints();\r\n    if (hints != null) {\r\n        readHints.putAll(hints);\r\n    }\r\n    if (request.getOverviewPolicy() != null) {\r\n        readHints.add(new Hints(Hints.OVERVIEW_POLICY, request.getOverviewPolicy()));\r\n    }\r\n    coverage = RequestUtils.readBestCoverage(reader, readParameters, readGG, spatialInterpolation, request.getOverviewPolicy(), readHints);\r\n    if (coverage != null) {\r\n        if (incrementalInputSize == null) {\r\n            WCSUtils.checkInputLimits(wcs, coverage);\r\n        } else {\r\n            incrementalInputSize.addSize(coverage);\r\n        }\r\n        if (scaling != null) {\r\n            MathTransform cmt = coverage.getGridGeometry().getGridToCRS();\r\n            MathTransform rmt = reader.getOriginalGridToWorld(PixelInCell.CELL_CENTER);\r\n            if (!(cmt instanceof AffineTransform2D) || !(rmt instanceof AffineTransform2D)) {\r\n                LOGGER.log(Level.FINE, \"Cannot check if the returned coverage \" + \"matched the requested resolution due to a non affine \" + \"grid to world backing it\");\r\n            } else {\r\n                AffineTransform2D cat = (AffineTransform2D) cmt;\r\n                AffineTransform2D rat = (AffineTransform2D) rmt;\r\n                preAppliedScale[0] = cat.getScaleX() / rat.getScaleX();\r\n                preAppliedScale[1] = cat.getScaleY() / rat.getScaleY();\r\n            }\r\n        }\r\n    }\r\n    return coverage;\r\n}"
}, {
	"Path": "org.geoserver.flow.DefaultFlowControllerProvider.reloadConfiguration",
	"Comment": "reloads the flow controller list and replaces the existing ones",
	"Method": "void reloadConfiguration(){\r\n    try {\r\n        List<FlowController> newControllers = new ArrayList<FlowController>(configurator.buildFlowControllers());\r\n        Collections.sort(newControllers, new ControllerPriorityComparator());\r\n        controllers = newControllers;\r\n        int controllersCount = controllers.size();\r\n        if (controllersCount > 0) {\r\n            LOGGER.info(\"Control-flow active with \" + controllersCount + \" flow controllers\");\r\n        } else {\r\n            LOGGER.info(\"Control-flow inactive, there are no configured rules\");\r\n        }\r\n        timeout = configurator.getTimeout();\r\n    } catch (Exception e) {\r\n        LOGGER.log(Level.SEVERE, \"Error occurerd during flow controllers reconfiguration\");\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.kml.GeoSearchKMLTest.testDataRegionator",
	"Comment": "test that requests regionated by data actually return stuff.",
	"Method": "void testDataRegionator(){\r\n    final String path = \"wms?request=getmap&service=wms&version=1.1.1\" + \"&format=\" + KMLMapOutputFormat.MIME_TYPE + \"&layers=\" + MockData.DIVIDED_ROUTES.getPrefix() + \":\" + MockData.DIVIDED_ROUTES.getLocalPart() + \"&styles=\" + MockData.DIVIDED_ROUTES.getLocalPart() + \"&height=1024&width=1024&srs=EPSG:4326\" + \"&format_options=regionateBy:external-sorting;regionateAttr:NUM_LANES\";\r\n    Document document = getAsDOM(path + \"&bbox=-180,-90,0,90\");\r\n    assertEquals(\"kml\", document.getDocumentElement().getTagName());\r\n    int westCount = document.getDocumentElement().getElementsByTagName(\"Placemark\").getLength();\r\n    assertStatusCodeForGet(204, path + \"&bbox=0,-90,180,90\");\r\n    assertEquals(1, westCount);\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.ConfigurationDiffVisitor.computeServicesDifference",
	"Comment": "register services differences between the two geoservers.",
	"Method": "void computeServicesDifference(){\r\n    Collection<ServiceInfo> servicesA = getAllServices(geoServerA);\r\n    Collection<ServiceInfo> servicesB = getAllServices(geoServerB);\r\n    differences.addAll(servicesB.stream().filter(service -> search(service, servicesA) == null).map(service -> new InfoDiff(null, service)).collect(Collectors.toList()));\r\n    for (ServiceInfo service : servicesA) {\r\n        ServiceInfo otherService = search(service, servicesB);\r\n        if (!checkEquals(service, otherService)) {\r\n            differences.add(new InfoDiff(service, otherService));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.AdvertisedCatalog.hideLayer",
	"Comment": "hide layer if request is getcapabilities and layer or its resource are not advertised.",
	"Method": "boolean hideLayer(LayerInfo layer){\r\n    if (!layer.isAdvertised()) {\r\n        return checkCapabilitiesRequest(layer.getResource());\r\n    } else {\r\n        return hideResource(layer.getResource());\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.impl.EditableUserDAO.update",
	"Comment": "ensure the user data map matches the information in the user data file. this should be calledautomatically, so that no code outside of this class needs to access this method.",
	"Method": "void update(){\r\n    try {\r\n        if (myWatcher == null) {\r\n        } else if (myWatcher.isStale()) {\r\n            Properties prop = myWatcher.getProperties();\r\n            UserAttributeEditor uae = new UserAttributeEditor();\r\n            myDetailStorage.clear();\r\n            Iterator<Object> it = prop.keySet().iterator();\r\n            while (it.hasNext()) {\r\n                String username = (String) it.next();\r\n                uae.setAsText(prop.getProperty(username));\r\n                UserAttribute attrs = (UserAttribute) uae.getValue();\r\n                if (attrs != null) {\r\n                    myDetailStorage.put(username, makeUser(username, attrs));\r\n                }\r\n            }\r\n        }\r\n    } catch (IOException ioe) {\r\n        myDetailStorage.clear();\r\n        createDefaultUser();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.WFSGetFeatureOutputFormat.getAllCapabilitiesElementNames",
	"Comment": "subclasses can delegate to this method if they want the full list of valid output formatelement names to be returned in the wfs 1.0 capabilities",
	"Method": "List<String> getAllCapabilitiesElementNames(){\r\n    List<String> result = new ArrayList<String>();\r\n    for (String name : getOutputFormats()) {\r\n        if (XML_ELEMENT.matcher(name).matches()) {\r\n            result.add(name);\r\n        }\r\n    }\r\n    Collections.sort(result);\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.encodeProperty",
	"Comment": "encode a feature property, we only support complex attributes and simple attributes, ifanother tye of attribute is used an exception will be throw.",
	"Method": "void encodeProperty(Property property){\r\n    Map<NameImpl, String> attributes = (Map<NameImpl, String>) property.getUserData().get(org.xml.sax.Attributes.class);\r\n    if (property instanceof ComplexAttribute) {\r\n        ComplexAttribute complexAttribute = (ComplexAttribute) property;\r\n        Object simpleValue = getSimpleContent(complexAttribute);\r\n        if (simpleValue != null) {\r\n            encodeSimpleAttribute(complexAttribute.getName().getLocalPart(), simpleValue, attributes);\r\n        } else {\r\n            encodeComplexAttribute((ComplexAttribute) property, attributes);\r\n        }\r\n    } else if (property instanceof Attribute) {\r\n        List<Feature> features = getFeatures((Attribute) property);\r\n        if (features != null) {\r\n            encodeChainedFeatures(property.getName().getLocalPart(), features);\r\n        } else {\r\n            encodeSimpleAttribute((Attribute) property, attributes);\r\n        }\r\n    } else {\r\n        throw new RuntimeException(String.format(\"Invalid property '%s' of type '%s', only 'Attribute' and 'ComplexAttribute' properties types are supported.\", property.getName(), property.getClass().getCanonicalName()));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.CatalogIconFactory.getSpecificLayerIcon",
	"Comment": "returns the appropriate icon for the specified layer. this one distinguishes the geometrytype inside vector layers.",
	"Method": "PackageResourceReference getSpecificLayerIcon(LayerInfo info){\r\n    if (info.getType() == PublishedType.RASTER) {\r\n        return RASTER_ICON;\r\n    } else if (info.getType() == PublishedType.VECTOR) {\r\n        try {\r\n            FeatureTypeInfo fti = (FeatureTypeInfo) info.getResource();\r\n            GeometryDescriptor gd = fti.getFeatureType().getGeometryDescriptor();\r\n            return getVectoryIcon(gd);\r\n        } catch (Exception e) {\r\n            return GEOMETRY_ICON;\r\n        }\r\n    } else if (info.getType() == PublishedType.WMS) {\r\n        return MAP_ICON;\r\n    } else if (info.getType() == PublishedType.WMTS) {\r\n        return MAP_ICON;\r\n    } else {\r\n        return UNKNOWN_ICON;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.gwc.layer.TimeoutReadWriteLock.downgradeToReadLock",
	"Comment": "downgrades a write lock to a read lock. the write lock gets released, the caller must stillrelease the read lock after this is called",
	"Method": "void downgradeToReadLock(){\r\n    lock.readLock().lock();\r\n    lock.writeLock().unlock();\r\n}"
}, {
	"Path": "org.geoserver.gwc.GWCIntegrationTest.createLayerGroup",
	"Comment": "helper method that creates a layer group using the provided name and layers names.",
	"Method": "void createLayerGroup(String layerGroupName,QName layersNames){\r\n    List<LayerInfo> layers = Arrays.stream(layersNames).map(layerName -> getCatalog().getLayerByName(new NameImpl(layerName))).collect(Collectors.toList());\r\n    LayerGroupInfo layerGroup = getCatalog().getFactory().createLayerGroup();\r\n    layerGroup.setName(layerGroupName);\r\n    for (LayerInfo layerInfo : layers) {\r\n        layerGroup.getLayers().add(layerInfo);\r\n        layerGroup.getStyles().add(null);\r\n    }\r\n    CatalogBuilder catalogBuilder = new CatalogBuilder(getCatalog());\r\n    catalogBuilder.calculateLayerGroupBounds(layerGroup);\r\n    getCatalog().add(layerGroup);\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.GridCoverage2DRIA.create",
	"Comment": "wrap the src coverage in the dst layout. the resulting renderedimage will contain the data in src, and will be accessible via the gridspecs of dst,",
	"Method": "GridCoverage2DRIA create(GridCoverage2D src,GridCoverage2D dst,double nodata,GridCoverage2DRIA create,GridCoverage2D src,GridGeometry2D dstGridGeometry,double nodata){\r\n    Utilities.ensureNonNull(\"dstGridGeometry\", dstGridGeometry);\r\n    Utilities.ensureNonNull(\"src\", src);\r\n    final GridEnvelope2D destinationRasterDimension = dstGridGeometry.getGridRange2D();\r\n    final ImageLayout imageLayout = new ImageLayout();\r\n    imageLayout.setMinX(destinationRasterDimension.x).setMinY(destinationRasterDimension.y);\r\n    imageLayout.setWidth(destinationRasterDimension.width).setHeight(destinationRasterDimension.height);\r\n    imageLayout.setTileHeight(src.getRenderedImage().getSampleModel().getHeight()).setTileWidth(src.getRenderedImage().getSampleModel().getWidth());\r\n    imageLayout.setColorModel(src.getRenderedImage().getColorModel());\r\n    imageLayout.setSampleModel(src.getRenderedImage().getSampleModel());\r\n    BorderExtender extender = new BorderExtenderConstant(new double[] { nodata });\r\n    final RenderingHints hints = new RenderingHints(JAI.KEY_TILE_CACHE, JAI.getDefaultInstance().getTileCache());\r\n    return new GridCoverage2DRIA(src, dstGridGeometry, vectorize(src.getRenderedImage()), imageLayout, hints, false, extender, Interpolation.getInstance(Interpolation.INTERP_NEAREST), new double[] { nodata });\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.MultiDimensionalExtension.encodeLayerDimensions",
	"Comment": "helper method that will encode a layer dimensions, if the layer dimension are null or emptynothing will be done.",
	"Method": "void encodeLayerDimensions(XMLBuilder xml,List<Dimension> dimensions){\r\n    for (Dimension dimension : dimensions) {\r\n        encodeLayerDimension(xml, dimension);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.CatalogIconFactory.getVectoryIcon",
	"Comment": "returns the vector icon associated to the specified geometry descriptor",
	"Method": "PackageResourceReference getVectoryIcon(GeometryDescriptor gd){\r\n    if (gd == null) {\r\n        return GEOMETRY_ICON;\r\n    }\r\n    Class<?> geom = gd.getType().getBinding();\r\n    return getVectorIcon(geom);\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.DXFOutputFormat.write",
	"Comment": "actually write the given featurecollection as a dxf file to the output stream.",
	"Method": "void write(FeatureCollectionResponse featureCollection,OutputStream output,Operation operation){\r\n    String format = getDxfExtension(operation);\r\n    BufferedWriter w = null;\r\n    ZipOutputStream zipStream = null;\r\n    if (format.equals(\"dxf\")) {\r\n        LOGGER.log(Level.FINE, \"Plain DXF output\");\r\n        w = new BufferedWriter(new OutputStreamWriter(output));\r\n    } else {\r\n        LOGGER.log(Level.FINE, \"Zipped DXF output\");\r\n        zipStream = new ZipOutputStream(output);\r\n        ZipEntry entry = new ZipEntry(getFileName(operation) + \".dxf\");\r\n        zipStream.putNextEntry(entry);\r\n        w = new BufferedWriter(new OutputStreamWriter(zipStream));\r\n    }\r\n    GetFeatureRequest gft = GetFeatureRequest.adapt(operation.getParameters()[0]);\r\n    String version = (String) gft.getFormatOptions().get(\"VERSION\");\r\n    String blocks = (String) gft.getFormatOptions().get(\"ASBLOCKS\");\r\n    String colors = (String) gft.getFormatOptions().get(\"COLORS\");\r\n    String ltypes = (String) gft.getFormatOptions().get(\"LTYPES\");\r\n    String[] layers = null;\r\n    if (gft.getFormatOptions().get(\"LAYERS\") instanceof String) {\r\n        layers = ((String) gft.getFormatOptions().get(\"LAYERS\")).split(\",\");\r\n    } else if (gft.getFormatOptions().get(\"LAYERS\") instanceof List) {\r\n        layers = (String[]) ((List) gft.getFormatOptions().get(\"LAYERS\")).toArray(new String[0]);\r\n    }\r\n    if (layers != null) {\r\n        for (int count = 0; count < layers.length; count++) {\r\n            layers[count] = layers[count].toUpperCase();\r\n        }\r\n    }\r\n    String writeAttributes = (String) gft.getFormatOptions().get(\"WITHATTRIBUTES\");\r\n    LOGGER.log(Level.FINE, \"Format options: \" + version + \"; \" + blocks + \"; \" + colors + \"; \" + ltypes + \"; \" + StringUtils.join(layers, \",\") + \"; \" + writeAttributes);\r\n    DXFWriter dxfWriter = DXFWriterFinder.getWriter(version, w);\r\n    if (dxfWriter != null) {\r\n        LOGGER.log(Level.INFO, \"DXFWriter: \" + dxfWriter.getDescription());\r\n        if (layers == null) {\r\n            layers = getLayerNames(gft.getQueries());\r\n        }\r\n        LOGGER.log(Level.FINE, \"Layers names: \" + StringUtils.join(layers, \",\"));\r\n        dxfWriter.setOption(\"layers\", layers);\r\n        if (writeAttributes != null) {\r\n            dxfWriter.setOption(\"writeattributes\", writeAttributes.toLowerCase().equals(\"true\"));\r\n        }\r\n        if (blocks != null && blocks.toLowerCase().equals(\"true\"))\r\n            dxfWriter.setOption(\"geometryasblock\", true);\r\n        if (colors != null) {\r\n            try {\r\n                String[] sColors = colors.split(\",\");\r\n                int[] icolors = new int[sColors.length];\r\n                for (int count = 0; count < sColors.length; count++) icolors[count] = Integer.parseInt(sColors[count]);\r\n                dxfWriter.setOption(\"colors\", icolors);\r\n            } catch (Throwable t) {\r\n                LOGGER.log(Level.WARNING, \"format option colors ignored by DXFOutputFormat due to a wrong format: \" + t.getMessage());\r\n            }\r\n        }\r\n        if (ltypes != null) {\r\n            try {\r\n                String[] sLTypes = ltypes.split(\",\");\r\n                LineType[] ltypesArr = new LineType[sLTypes.length];\r\n                for (int count = 0; count < sLTypes.length; count++) ltypesArr[count] = LineType.parse(sLTypes[count]);\r\n                dxfWriter.setOption(\"linetypes\", ltypesArr);\r\n            } catch (Throwable t) {\r\n                LOGGER.warning(\"format option ltypes ignored by DXFOutputFormat due to a wrong format: \" + t.getMessage());\r\n            }\r\n        }\r\n        dxfWriter.write(featureCollection.getFeature(), version);\r\n        w.flush();\r\n        if (zipStream != null) {\r\n            zipStream.closeEntry();\r\n            zipStream.close();\r\n        }\r\n        dxfWriter = null;\r\n        zipStream = null;\r\n        w = null;\r\n    } else\r\n        throw new UnsupportedOperationException(\"Version \" + version + \" not supported by dxf output format\");\r\n}"
}, {
	"Path": "org.geoserver.test.StationsMockData.addMeasurementFeatureType",
	"Comment": "helper method that will add the measurement feature type customizing it for the desired gmlversion.",
	"Method": "void addMeasurementFeatureType(String namespacePrefix,String gmlPrefix,String mappingsName,String mappingsPath,Map<String, String> parameters){\r\n    File gmlDirectory = getDirectoryForGmlPrefix(gmlPrefix);\r\n    gmlDirectory.mkdirs();\r\n    File measurementsMappings = new File(gmlDirectory, String.format(\"%s_%s.xml\", mappingsName, gmlPrefix));\r\n    File measurementsProperties = new File(gmlDirectory, String.format(\"measurements_%s.properties\", gmlPrefix));\r\n    File measurementsSchema = new File(gmlDirectory, String.format(\"measurements_%s.xsd\", gmlPrefix));\r\n    substituteParameters(\"/test-data/stations/\" + mappingsPath, parameters, measurementsMappings);\r\n    substituteParameters(\"/test-data/stations/base/measurements.properties\", parameters, measurementsProperties);\r\n    substituteParameters(\"/test-data/stations/base/measurements.xsd\", parameters, measurementsSchema);\r\n    addMeasurementFeatures(measurementsProperties);\r\n    addFeatureType(namespacePrefix, String.format(\"Measurement_%s\", gmlPrefix), measurementsMappings.getAbsolutePath(), measurementsProperties.getAbsolutePath(), measurementsSchema.getAbsolutePath());\r\n}"
}, {
	"Path": "org.geoserver.catalog.IsolatedWorkspacesTest.checkWorkspace",
	"Comment": "helper method that checks that the provided workspace has the expected content.",
	"Method": "void checkWorkspace(WorkspaceInfo workspace,String expectedPrefix,boolean expectedIsolation){\r\n    assertThat(workspace, notNullValue());\r\n    assertThat(workspace.getName(), is(expectedPrefix));\r\n    assertThat(workspace.isIsolated(), is(expectedIsolation));\r\n}"
}, {
	"Path": "org.geoserver.security.filter.GeoServerCredentialsFromRequestHeaderFilter.parseHeader",
	"Comment": "parse an header string to extract the credential. the regular expression must contain agroup, that will represent the credential to be extracted.",
	"Method": "String parseHeader(String header,Pattern pattern){\r\n    Matcher m = pattern.matcher(header);\r\n    if (m.find() && m.groupCount() == 1) {\r\n        String res = m.group(1);\r\n        return res;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.csw.GetRecordById.getRecordDescriptor",
	"Comment": "search for the record descriptor maching the request, throws a service exception in case noneis found",
	"Method": "RecordDescriptor getRecordDescriptor(GetRecordByIdType request){\r\n    String outputSchema = request.getOutputSchema();\r\n    if (outputSchema == null) {\r\n        outputSchema = CSW.NAMESPACE;\r\n        request.setOutputFormat(CSW.NAMESPACE);\r\n    }\r\n    for (RecordDescriptor rd : recordDescriptors) {\r\n        if (outputSchema.equals(rd.getOutputSchema())) {\r\n            return rd;\r\n        }\r\n    }\r\n    throw new ServiceException(\"Cannot encode records in output schema \" + outputSchema, ServiceException.INVALID_PARAMETER_VALUE, \"outputSchema\");\r\n}"
}, {
	"Path": "org.geoserver.catalog.ResourcePool.setFeatureTypeCacheSize",
	"Comment": "sets the size of the feature type cache.a warning that calling this method will blow away the existing cache.",
	"Method": "void setFeatureTypeCacheSize(int featureTypeCacheSize){\r\n    synchronized (this) {\r\n        featureTypeCache.clear();\r\n        featureTypeCache = createFeatureTypeCache(featureTypeCacheSize);\r\n        featureTypeAttributeCache.clear();\r\n        featureTypeAttributeCache = createFeatureTypeAttributeCache(featureTypeCacheSize);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.rest.catalog.StyleController.checkStyleResourceNotExists",
	"Comment": "verifies that the style resource for the passed style does not yet exist, throwing anappropriate exception if it does",
	"Method": "void checkStyleResourceNotExists(StyleInfo info){\r\n    GeoServerDataDirectory dataDir = new GeoServerDataDirectory(catalog.getResourceLoader());\r\n    if (dataDir.style(info).getType() != Resource.Type.UNDEFINED) {\r\n        throw new RestException(\"Style resource \" + info.getFilename() + \" already exists.\", HttpStatus.FORBIDDEN);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.DataAccessNewPageTest.testPageRendersOnLoad",
	"Comment": "a kind of smoke test that only asserts the page is rendered when first loaded",
	"Method": "void testPageRendersOnLoad(){\r\n    final PropertyDataStoreFactory dataStoreFactory = new PropertyDataStoreFactory();\r\n    final String dataStoreFactoryDisplayName = dataStoreFactory.getDisplayName();\r\n    startPage();\r\n    tester.assertLabel(\"dataStoreForm:storeType\", dataStoreFactoryDisplayName);\r\n    tester.assertLabel(\"dataStoreForm:storeTypeDescription\", dataStoreFactory.getDescription());\r\n    tester.assertComponent(\"dataStoreForm:workspacePanel\", WorkspacePanel.class);\r\n}"
}, {
	"Path": "org.geoserver.data.test.SystemTestData.addService",
	"Comment": "adds a service configuration to the test setup. if the service object already exists it issimply reverted to its original state.",
	"Method": "void addService(Class<T> serviceClass,String workspace,GeoServer geoServer){\r\n    Catalog catalog = geoServer.getCatalog();\r\n    List<XStreamServiceLoader> loaders = GeoServerExtensions.extensions(XStreamServiceLoader.class);\r\n    for (XStreamServiceLoader loader : loaders) {\r\n        if (serviceClass.equals(loader.getServiceClass())) {\r\n            T created = (T) loader.create(geoServer);\r\n            T old = null;\r\n            WorkspaceInfo ws = null;\r\n            if (workspace != null) {\r\n                ws = catalog.getWorkspaceByName(workspace);\r\n                old = geoServer.getService(ws, serviceClass);\r\n            } else {\r\n                old = geoServer.getService(serviceClass);\r\n            }\r\n            if (old != null) {\r\n                OwsUtils.copy(created, old, serviceClass);\r\n                geoServer.save(old);\r\n            } else {\r\n                created.setWorkspace(ws);\r\n                geoServer.add(created);\r\n            }\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.LoginFormInfo.setLoginPath",
	"Comment": "authentication security endpoint invoked by the pluggable form",
	"Method": "void setLoginPath(String loginPath){\r\n    this.loginPath = loginPath;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerLoader.initializeStyle",
	"Comment": "copies a well known style out to the data directory and adds a catalog entry for it.",
	"Method": "void initializeStyle(Catalog catalog,String styleName,String sld){\r\n    Resource styleResource = resourceLoader.get(Paths.path(\"styles\", sld));\r\n    if (!Resources.exists(styleResource)) {\r\n        try (InputStream in = GeoServerLoader.class.getResourceAsStream(sld);\r\n            OutputStream out = styleResource.out()) {\r\n            IOUtils.copy(in, out);\r\n        }\r\n    }\r\n    StyleInfo s = catalog.getFactory().createStyle();\r\n    s.setName(styleName);\r\n    s.setFilename(sld);\r\n    catalog.add(s);\r\n}"
}, {
	"Path": "org.geoserver.sldservice.rest.ClassifierTest.getRules",
	"Comment": "parses the dom, check there is just one feature type style and returns all rules in it",
	"Method": "List<Rule> getRules(Document dom){\r\n    SLDParser parser = new SLDParser(CommonFactoryFinder.getStyleFactory());\r\n    StyledLayerDescriptor sld = parser.parseDescriptor(dom.getDocumentElement());\r\n    NamedLayer layer = (NamedLayer) sld.getStyledLayers()[0];\r\n    Style style = layer.getStyles()[0];\r\n    List<FeatureTypeStyle> featureTypeStyles = style.featureTypeStyles();\r\n    assertEquals(1, featureTypeStyles.size());\r\n    return featureTypeStyles.get(0).rules();\r\n}"
}, {
	"Path": "org.geoserver.wms.capabilities.DimensionHelper.getMinMaxTimeInterval",
	"Comment": "builds a single time range from the domain, be it made of date or timerange objects",
	"Method": "DateRange getMinMaxTimeInterval(TreeSet<? extends Object> values){\r\n    Object minValue = values.first();\r\n    Object maxValue = values.last();\r\n    Date min, max;\r\n    if (minValue instanceof DateRange) {\r\n        min = ((DateRange) minValue).getMinValue();\r\n    } else {\r\n        min = (Date) minValue;\r\n    }\r\n    if (maxValue instanceof DateRange) {\r\n        max = ((DateRange) maxValue).getMaxValue();\r\n    } else {\r\n        max = (Date) maxValue;\r\n    }\r\n    return new DateRange(min, max);\r\n}"
}, {
	"Path": "org.geoserver.gwc.config.GWCConfig.isPersistenceEnabled",
	"Comment": "checks whether gwc tiles are stored in the file system also if they are already stored inmemory",
	"Method": "boolean isPersistenceEnabled(){\r\n    return persistenceEnabled;\r\n}"
}, {
	"Path": "org.geoserver.platform.resource.ResourceNotification.events",
	"Comment": "paths of changed resources.this list of changed resources is sorted and includes any relevant directories.",
	"Method": "List<Event> events(){\r\n    return delta;\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityFilterChain.patternsForFilter",
	"Comment": "get a list of patterns having the filter in their chain. if includeall is false, onlyauthentication filters are searched",
	"Method": "List<String> patternsForFilter(String filterName,boolean includeAll){\r\n    List<String> result = new ArrayList<String>();\r\n    for (RequestFilterChain requestChain : requestChains) {\r\n        List<String> filterNames = includeAll ? requestChain.getCompiledFilterNames() : requestChain.getFilterNames();\r\n        if (filterNames.contains(filterName)) {\r\n            result.addAll(requestChain.getPatterns());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTestsUtils.updateInfoImpl",
	"Comment": "updates the second info values using the first info values. values are cloned when possible.",
	"Method": "U updateInfoImpl(Info infoA,Info infoB,Class<U> type){\r\n    if (!type.isAssignableFrom(infoA.getClass()) || !type.isAssignableFrom(infoB.getClass())) {\r\n        throw new RuntimeException(String.format(\"Info objects should be of type '%s', but are of types '%s' and '%s'.\", type.getSimpleName(), infoA.getClass().getSimpleName(), infoB.getClass().getSimpleName()));\r\n    }\r\n    U proxy = ModificationProxy.create(type.cast(infoB), type);\r\n    ClassProperties properties = OwsUtils.getClassProperties(type);\r\n    for (String propertyName : properties.properties()) {\r\n        try {\r\n            Object propertyValue = OwsUtils.get(infoA, propertyName);\r\n            if (propertyValue instanceof Info) {\r\n                Object otherPropertyValue = OwsUtils.get(infoB, propertyName);\r\n                if (otherPropertyValue instanceof Info) {\r\n                    propertyValue = updateInfoImpl((Info) propertyValue, (Info) otherPropertyValue, getInfoInterface(propertyValue.getClass()));\r\n                }\r\n            }\r\n            if (propertyValue instanceof Serializable && !(propertyValue instanceof Proxy)) {\r\n                propertyValue = SerializationUtils.clone((Serializable) propertyValue);\r\n            }\r\n            OwsUtils.set(proxy, propertyName, propertyValue);\r\n        } catch (IllegalArgumentException exception) {\r\n            LOGGER.log(Level.FINE, String.format(\"Error setting property '%s'.\", propertyName), exception);\r\n        }\r\n    }\r\n    return proxy;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.getSpringContextLocations",
	"Comment": "returns the spring context locations to be used in order to build the geoserver springcontext. subclasses might want to provide extra locations in order to test extension points.",
	"Method": "String[] getSpringContextLocations(){\r\n    return new String[] { \"classpath*:/applicationContext.xml\", \"classpath*:/applicationSecurityContext.xml\" };\r\n}"
}, {
	"Path": "org.geoserver.security.decorators.DefaultSecureCatalogFactory.logIfSecured",
	"Comment": "generates a warning log if the info object is already wrapped with a secured decorator. thismethod is only intended to log a situation where a catalog info object is being secured, butis already secured. repeated calls to this will keep adding additional wrapper layers and mayeventually cause a stackoverflowerror. the log generated is merely to aid in finding the realissue, as opposed to masking it here.",
	"Method": "WMTSLayerInfo logIfSecured(WMTSLayerInfo object,WMSLayerInfo logIfSecured,WMSLayerInfo object,LayerInfo logIfSecured,LayerInfo object,FeatureTypeInfo logIfSecured,FeatureTypeInfo object,CoverageStoreInfo logIfSecured,CoverageStoreInfo object,CoverageInfo logIfSecured,CoverageInfo object,DataStoreInfo logIfSecured,DataStoreInfo object){\r\n    DataStoreInfo unwrapped = ModificationProxy.unwrap(object);\r\n    if (unwrapped instanceof SecuredDataStoreInfo) {\r\n        logDoubleWrap(unwrapped, object);\r\n    }\r\n    return object;\r\n}"
}, {
	"Path": "org.geoserver.geofence.config.GeoFenceConfiguration.isUseRolesToFilter",
	"Comment": "use authenticated users roles to match rules, instead of username.",
	"Method": "boolean isUseRolesToFilter(){\r\n    return useRolesToFilter;\r\n}"
}, {
	"Path": "org.geoserver.kml.regionate.CachedHierarchyRegionatingStrategy.getUpwardFids",
	"Comment": "returns a set of all the fids in the specified tile and in the parents of it, recursing up tothe root tile",
	"Method": "Set<String> getUpwardFids(Tile tile,Connection conn){\r\n    if (tile == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    Set<String> fids = new HashSet();\r\n    fids.addAll(readFeaturesForTile(tile, conn));\r\n    Tile parent = tile.getParent();\r\n    if (parent != null) {\r\n        fids.addAll(getUpwardFids(parent, conn));\r\n    }\r\n    return fids;\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.ROIManager.useNativeCRS",
	"Comment": "reproject the initial roi to the provided crs which is supposedly the native crs of the datato clip.",
	"Method": "void useNativeCRS(CoordinateReferenceSystem nativeCRS){\r\n    if (nativeCRS == null) {\r\n        throw new IllegalArgumentException(\"The provided nativeCRS is null\");\r\n    }\r\n    roiInNativeCRS = DownloadUtilities.transformGeometry(originalRoi, nativeCRS);\r\n    DownloadUtilities.checkPolygonROI(roiInNativeCRS);\r\n    if (isROIBBOX) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"ROI is a Bounding Box\");\r\n        }\r\n        safeRoiInNativeCRS = roiInNativeCRS.getEnvelope();\r\n    } else {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"ROI is not a Bounding Box\");\r\n        }\r\n        safeRoiInNativeCRS = roiInNativeCRS;\r\n    }\r\n    safeRoiInNativeCRS.setUserData(nativeCRS);\r\n    this.nativeCRS = nativeCRS;\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.dxf.AbstractDXFWriter.getEnvelope",
	"Comment": "extracts and cache the global referenceenvelope for the given feature list.",
	"Method": "ReferencedEnvelope getEnvelope(List featureList){\r\n    if (e == null) {\r\n        for (int i = 0; i < featureList.size(); i++) {\r\n            FeatureCollection collection = (FeatureCollection) featureList.get(i);\r\n            if (e == null) {\r\n                e = collection.getBounds();\r\n            } else {\r\n                e.expandToInclude(collection.getBounds());\r\n            }\r\n        }\r\n    }\r\n    return normalizeEnvelope(e);\r\n}"
}, {
	"Path": "org.geoserver.test.PropertySelectionTest.testSameNameDiffNamespace1",
	"Comment": "test getfeature with property selection, with properties names with same name but differentnamespace.",
	"Method": "void testSameNameDiffNamespace1(){\r\n    Document doc = getAsDOM(\"wfs?service=WFS&version=1.1.0&request=GetFeature&typeName=ex:MyTestFeature&propertyname=ex:name\");\r\n    LOGGER.info(\"wfs?service=WFS&version=1.1.0&request=GetFeature&typeName=ex:MyTestFeature&propertyname=ex:name response:\\n\" + prettyString(doc));\r\n    assertXpathCount(1, \"//ex:MyTestFeature[@gml:id='f1']/ex:name\", doc);\r\n    assertXpathCount(0, \"//ex:MyTestFeature[@gml:id='f1']/gml:name\", doc);\r\n}"
}, {
	"Path": "org.geoserver.platform.resource.Resources.fromPath",
	"Comment": "creates resource from a path, if the path is relative it will return a resource relative tothe provided directory otherwise it will return a file based resource",
	"Method": "Resource fromPath(String path,org.geoserver.platform.resource.Resource fromPath,String path,org.geoserver.platform.resource.Resource relativeDir){\r\n    File file = new File(path);\r\n    if (file.isAbsolute()) {\r\n        return Files.asResource(file);\r\n    } else {\r\n        return relativeDir.get(path.replace(File.separatorChar, '/'));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.PropertySelectionTest.testSameNameDiffNamespace2",
	"Comment": "test getfeature with property selection, with properties names with same name but differentnamespace.",
	"Method": "void testSameNameDiffNamespace2(){\r\n    Document doc = getAsDOM(\"wfs?service=WFS&version=1.1.0&request=GetFeature&typeName=ex:MyTestFeature&propertyname=gml:name\");\r\n    LOGGER.info(\"wfs?service=WFS&version=1.1.0&request=GetFeature&typeName=ex:MyTestFeature&propertyname=gml:name response:\\n\" + prettyString(doc));\r\n    assertXpathCount(1, \"//ex:MyTestFeature[@gml:id='f1']/gml:name\", doc);\r\n    assertXpathCount(0, \"//ex:MyTestFeature[@gml:id='f1']/ex:name\", doc);\r\n}"
}, {
	"Path": "org.geoserver.test.PropertySelectionTest.testSameNameDiffNamespace3",
	"Comment": "test getfeature with property selection, with an invalid column name.",
	"Method": "void testSameNameDiffNamespace3(){\r\n    Document doc = getAsDOM(\"wfs?service=WFS&version=1.1.0&request=GetFeature&typeName=ex:MyTestFeature\");\r\n    LOGGER.info(\"wfs?service=WFS&version=1.1.0&request=GetFeature&typeName=ex:MyTestFeature response:\\n\" + prettyString(doc));\r\n}"
}, {
	"Path": "org.geoserver.wfs.request.RequestObject.getFactory",
	"Comment": "factory that creates the underlying request model objects.",
	"Method": "EFactory getFactory(){\r\n    return adaptee.eClass().getEPackage().getEFactoryInstance();\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.LegacyCoverageInfoReader.read",
	"Comment": "parses the info.xml file into a dom.this methodbe called before any other methods.",
	"Method": "void read(File file){\r\n    parentDirectory = file.getParentFile();\r\n    Reader reader = XmlCharsetDetector.getCharsetAwareReader(new FileInputStream(file));\r\n    try {\r\n        coverage = ReaderUtils.parse(reader);\r\n    } finally {\r\n        reader.close();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.GeoJSONBuilder.writeList",
	"Comment": "write a java.util.list out as a json array. the values of the array will be converted usingike standard primitive conversions. if the list contains list or map objects, they will beserialized as json arrays and json objects respectively.",
	"Method": "JSONBuilder writeList(List list){\r\n    this.array();\r\n    for (final Object o : list) {\r\n        this.value(o);\r\n    }\r\n    return this.endArray();\r\n}"
}, {
	"Path": "org.geoserver.geofence.config.GeoFenceConfiguration.getAcceptedRoles",
	"Comment": "list of mutually exclusive roles used for rule matching when userolestofilter is true.",
	"Method": "String getAcceptedRoles(){\r\n    return acceptedRoles;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findOrCreateStyleDir",
	"Comment": "returns the directory in which global styles are persisted, if the directory does not existit will be created.",
	"Method": "File findOrCreateStyleDir(){\r\n    Resource styles = get(STYLE_DIR);\r\n    return styles.dir();\r\n}"
}, {
	"Path": "org.geoserver.wfs.v2_0.DescribeFeatureTypeTest.testNoWfsSchemaImport",
	"Comment": "tests that wfs schema is not imported in a describefeaturetype response.",
	"Method": "void testNoWfsSchemaImport(){\r\n    String typeName = getLayerId(CiteTestData.PRIMITIVEGEOFEATURE);\r\n    MockHttpServletResponse response = getAsServletResponse(\"wfs?service=WFS&version=2.0.0&request=DescribeFeatureType&typeNames=\" + typeName);\r\n    assertThat(response.getContentType(), is(\"application/gml+xml; version=3.2\"));\r\n    Document doc = dom(response, true);\r\n    assertSchema(doc, CiteTestData.PRIMITIVEGEOFEATURE);\r\n    assertXpathNotExists(\"//xsd:import[@namespace='\" + WFS.NAMESPACE + \"']\", doc);\r\n}"
}, {
	"Path": "org.geoserver.csw.DirectDownload.run",
	"Comment": "prepare the list of files to be downloaded from the current request.",
	"Method": "List<File> run(DirectDownloadType request){\r\n    List<File> result = new ArrayList<File>();\r\n    String resourceId = request.getResourceId();\r\n    String fileId = request.getFile();\r\n    String[] identifiers = resourceId.split(\":\");\r\n    assert (identifiers.length == 2);\r\n    String nameSpace = identifiers[0];\r\n    String layerName = identifiers[1];\r\n    Name coverageName = new NameImpl(nameSpace, layerName);\r\n    CoverageInfo info = geoserver.getCatalog().getCoverageByName(coverageName);\r\n    if (info == null) {\r\n        throw new ServiceException(\"No object available for the specified name:\" + coverageName);\r\n    }\r\n    GridCoverage2DReader reader;\r\n    try {\r\n        reader = (GridCoverage2DReader) info.getGridCoverageReader(null, GeoTools.getDefaultHints());\r\n    } catch (IOException e) {\r\n        throw new ServiceException(\"Failed to get a reader for the associated info: \" + info, e);\r\n    }\r\n    String name = extractName(info);\r\n    getFileResources(reader, name, fileId, result);\r\n    if (fileId == null && reader instanceof StructuredGridCoverage2DReader) {\r\n        getExtraFiles(reader, result);\r\n    }\r\n    if (result == null || result.isEmpty()) {\r\n        throw new ServiceException(\"Unable to get any data for resourceId=\" + resourceId + \" and file=\" + fileId);\r\n    }\r\n    checkSizeLimit(result, info);\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.AbstractNetCDFEncoder.updateDimensionValues",
	"Comment": "update the dimension values of a dimension, by inspecting the coverage properties",
	"Method": "void updateDimensionValues(GridCoverage2D coverage){\r\n    Map properties = coverage.getProperties();\r\n    for (NetCDFDimensionsManager.NetCDFDimensionMapping dimension : dimensionsManager.getDimensions()) {\r\n        final String dimensionName = dimension.getName();\r\n        final Object value = properties.get(dimensionName);\r\n        if (value == null) {\r\n            Set<String> dimensions = crsWriter.getCoordinatesDimensionNames();\r\n            if (dimensions != null && !dimensions.contains(dimensionName) && LOGGER.isLoggable(Level.WARNING)) {\r\n                LOGGER.warning(\"No Dimensions available with the specified name: \" + dimensionName);\r\n            }\r\n        } else {\r\n            dimension.getDimensionValues().addValue(value);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.DownloadProcess.execute",
	"Comment": "this process returns a zipped file containing the selected layer, cropped if needed.",
	"Method": "File execute(String layerName,Filter filter,String mimeType,CoordinateReferenceSystem targetCRS,CoordinateReferenceSystem roiCRS,Geometry roi,Boolean clip,Interpolation interpolation,Integer targetSizeX,Integer targetSizeY,int[] bandIndices,Parameters writeParameters,ProgressListener progressListener){\r\n    try {\r\n        if (layerName == null || layerName.length() <= 0) {\r\n            throw new IllegalArgumentException(\"Empty or null layerName provided!\");\r\n        }\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Download process called on resource: \" + layerName);\r\n        }\r\n        if (clip == null) {\r\n            clip = false;\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.log(Level.FINE, \"Clipping disabled\");\r\n            }\r\n        }\r\n        if (roi != null) {\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.log(Level.FINE, \"ROI check\");\r\n            }\r\n            DownloadUtilities.checkPolygonROI(roi);\r\n            if (roiCRS == null) {\r\n                throw new IllegalArgumentException(\"ROI without a CRS is not usable!\");\r\n            }\r\n            roi.setUserData(roiCRS);\r\n        }\r\n        if (interpolation == null) {\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.log(Level.FINE, \"Interpolation parameter not specified, using default (Nearest Neighbor)\");\r\n            }\r\n            interpolation = (Interpolation) ImageUtilities.NN_INTERPOLATION_HINT.get(JAI.KEY_INTERPOLATION);\r\n        }\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Running the estimator\");\r\n        }\r\n        if (!estimator.execute(layerName, filter, targetCRS, roiCRS, roi, clip, targetSizeX, targetSizeY, bandIndices, progressListener)) {\r\n            throw new IllegalArgumentException(\"Download Limits Exceeded. Unable to proceed!\");\r\n        }\r\n        LayerInfo layerInfo = catalog.getLayerByName(layerName);\r\n        if (layerInfo == null) {\r\n            throw new IllegalArgumentException(\"Unable to locate layer: \" + layerName);\r\n        }\r\n        ResourceInfo resourceInfo = layerInfo.getResource();\r\n        if (resourceInfo == null) {\r\n            throw new IllegalArgumentException(\"Unable to locate ResourceInfo for layer:\" + layerName);\r\n        }\r\n        DownloadServiceConfiguration limits = estimator.getDownloadServiceConfiguration();\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Employing limits \" + limits);\r\n        }\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"The resource to work on is \" + resourceInfo.getName());\r\n        }\r\n        Resource internalOutput = null;\r\n        if (resourceInfo instanceof FeatureTypeInfo) {\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.log(Level.FINE, \"The resource to work on is a vector layer\");\r\n            }\r\n            internalOutput = new VectorDownload(limits, resourceManager, context).execute((FeatureTypeInfo) resourceInfo, mimeType, roi, clip, filter, targetCRS, progressListener);\r\n        } else if (resourceInfo instanceof CoverageInfo) {\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.log(Level.FINE, \"The resource to work on is a raster layer\");\r\n            }\r\n            CoverageInfo cInfo = (CoverageInfo) resourceInfo;\r\n            internalOutput = new RasterDownload(limits, resourceManager, context, catalog).execute(mimeType, progressListener, cInfo, roi, targetCRS, clip, filter, interpolation, targetSizeX, targetSizeY, bandIndices, writeParameters);\r\n        } else {\r\n            throw new IllegalArgumentException(\"Could not complete the Download Process, requested layer was of wrong type-->\" + resourceInfo.getClass());\r\n        }\r\n        if (internalOutput == null) {\r\n            throw new IllegalStateException(\"Could not complete the Download Process, output file is null\");\r\n        }\r\n        if (!Resources.exists(internalOutput) || !Resources.canRead(internalOutput)) {\r\n            throw new IllegalStateException(\"Could not complete the Download Process, output file invalid! --> \" + internalOutput.path());\r\n        }\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Preparing the result\");\r\n        }\r\n        final Resource result = resourceManager.getOutputResource(resourceManager.getExecutionId(true), resourceInfo.getName() + \".zip\");\r\n        try (OutputStream os1 = result.out()) {\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.log(Level.FINE, \"Listing files\");\r\n            }\r\n            List<File> filesToDownload = new ArrayList<File>();\r\n            filesToDownload.add(internalOutput.file());\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.log(Level.FINE, \"Collecting styles\");\r\n            }\r\n            for (Resource style : DownloadUtilities.collectStyles(layerInfo)) {\r\n                filesToDownload.add(style.file());\r\n            }\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.log(Level.FINE, \"Zipping files\");\r\n            }\r\n            new ZipArchivePPIO(estimator.getDownloadServiceConfiguration().getCompressionLevel()).encode(filesToDownload, os1);\r\n        } finally {\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.log(Level.FINE, \"Prepare the result for deletion\");\r\n            }\r\n            resourceManager.addResource(new WPSFileResource(internalOutput));\r\n        }\r\n        if (progressListener != null) {\r\n            progressListener.complete();\r\n        }\r\n        return result.file();\r\n    } catch (Throwable e) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Download failed\");\r\n        }\r\n        final ProcessException processException = new ProcessException(e);\r\n        if (progressListener != null) {\r\n            progressListener.exceptionOccurred(processException);\r\n        }\r\n        throw processException;\r\n    }\r\n}"
}, {
	"Path": "org.geotools.renderer.lite.VectorMapRenderUtils.reprojectSpatialFilter",
	"Comment": "reprojects spatial filters so that they match the feature source native crs, and assuming all literalgeometries are specified in the specified declaredcrsmodified from streamingrenderer",
	"Method": "Filter reprojectSpatialFilter(CoordinateReferenceSystem declaredCRS,FeatureType schema,Filter filter){\r\n    if (filter == null) {\r\n        return null;\r\n    }\r\n    SpatialFilterVisitor sfv = new SpatialFilterVisitor();\r\n    filter.accept(sfv, null);\r\n    if (!sfv.hasSpatialFilter()) {\r\n        return filter;\r\n    }\r\n    DefaultCRSFilterVisitor defaulter = new DefaultCRSFilterVisitor(FF, declaredCRS);\r\n    Filter defaulted = (Filter) filter.accept(defaulter, null);\r\n    ReprojectingFilterVisitor reprojector = new ReprojectingFilterVisitor(FF, schema);\r\n    Filter reprojected = (Filter) defaulted.accept(reprojector, null);\r\n    return reprojected;\r\n}"
}, {
	"Path": "org.geoserver.wms.web.data.StyleProvider.filteredItems",
	"Comment": "returns the requested page of layer objects after applying any keyword filtering set on thepage",
	"Method": "Iterator<StyleInfo> filteredItems(Integer first,Integer count){\r\n    final Catalog catalog = getCatalog();\r\n    final SortParam sort = getSort();\r\n    final Property<StyleInfo> property = getProperty(sort);\r\n    SortBy sortOrder = null;\r\n    if (sort != null) {\r\n        if (property instanceof BeanProperty) {\r\n            final String sortProperty = ((BeanProperty<StyleInfo>) property).getPropertyPath();\r\n            sortOrder = sortBy(sortProperty, sort.isAscending());\r\n        }\r\n    }\r\n    final Filter filter = getFilter();\r\n    Iterator<StyleInfo> items = catalog.list(StyleInfo.class, filter, first, count, sortOrder);\r\n    return items;\r\n}"
}, {
	"Path": "org.geoserver.csw.GetRecords.getRecordDescriptor",
	"Comment": "search for the record descriptor maching the request, throws a service exception in case noneis found",
	"Method": "RecordDescriptor getRecordDescriptor(Name typeName,RecordDescriptor getRecordDescriptor,GetRecordsType request){\r\n    String outputSchema = request.getOutputSchema();\r\n    if (outputSchema == null) {\r\n        outputSchema = CSW.NAMESPACE;\r\n        request.setOutputFormat(CSW.NAMESPACE);\r\n    }\r\n    for (RecordDescriptor rd : recordDescriptors) {\r\n        if (outputSchema.equals(rd.getOutputSchema())) {\r\n            return rd;\r\n        }\r\n    }\r\n    throw new ServiceException(\"Cannot encode records in output schema \" + outputSchema, ServiceException.INVALID_PARAMETER_VALUE, \"outputSchema\");\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findWorkspaceFile",
	"Comment": "returns the configuration file for the specified workspace, if the file does not exist nullis returned.",
	"Method": "File findWorkspaceFile(WorkspaceInfo ws){\r\n    Resource workspaceFile = config(ws);\r\n    return Resources.file(workspaceFile);\r\n}"
}, {
	"Path": "org.geoserver.wfs.xml.NameSpaceTranslator.isValidTypeRef",
	"Comment": "isvalidtyperef purpose.checks to see if the reference provided is found in the list of elements for thisnamespace.",
	"Method": "boolean isValidTypeRef(String type){\r\n    if ((type == null) || (type == \"\")) {\r\n        return false;\r\n    }\r\n    Set elems = getElements();\r\n    Iterator i = elems.iterator();\r\n    while (i.hasNext()) {\r\n        NameSpaceElement nse = (NameSpaceElement) i.next();\r\n        if (nse == null) {\r\n            continue;\r\n        }\r\n        String tp = nse.getTypeRefName();\r\n        if ((tp != null) && tp.equals(type)) {\r\n            return true;\r\n        }\r\n        tp = nse.getQualifiedTypeRefName();\r\n        if ((tp != null) && tp.equals(type)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.catalog.CatalogBuilder.getAttributes",
	"Comment": "extracts the attributetypeinfo by copying them from the specified feature type.",
	"Method": "List<AttributeTypeInfo> getAttributes(FeatureType ft,FeatureTypeInfo info){\r\n    List<AttributeTypeInfo> attributes = new ArrayList<AttributeTypeInfo>();\r\n    for (PropertyDescriptor pd : ft.getDescriptors()) {\r\n        AttributeTypeInfo att = catalog.getFactory().createAttribute();\r\n        att.setFeatureType(info);\r\n        att.setName(pd.getName().getLocalPart());\r\n        att.setMinOccurs(pd.getMinOccurs());\r\n        att.setMaxOccurs(pd.getMaxOccurs());\r\n        att.setNillable(pd.isNillable());\r\n        att.setBinding(pd.getType().getBinding());\r\n        int length = FeatureTypes.getFieldLength(pd);\r\n        if (length > 0) {\r\n            att.setLength(length);\r\n        }\r\n        attributes.add(att);\r\n    }\r\n    return attributes;\r\n}"
}, {
	"Path": "org.geoserver.security.password.MasterPasswordProviderConfig.setReadOnly",
	"Comment": "sets flag determining if the url is read only and may not be written back to.",
	"Method": "void setReadOnly(boolean readOnly){\r\n    this.readOnly = readOnly;\r\n}"
}, {
	"Path": "org.geoserver.nsg.pagination.random.IndexConfigurationManager.createFeatureType",
	"Comment": "helper method that create a new table on db to store resource informations",
	"Method": "void createFeatureType(DataStore dataStore,boolean forceDelete){\r\n    boolean exists = dataStore.getNames().contains(new NameImpl(STORE_SCHEMA_NAME));\r\n    if (exists) {\r\n        if (forceDelete) {\r\n            dataStore.removeSchema(STORE_SCHEMA_NAME);\r\n            SimpleFeatureType schema = DataUtilities.createType(STORE_SCHEMA_NAME, STORE_SCHEMA);\r\n            dataStore.createSchema(schema);\r\n        }\r\n    } else {\r\n        SimpleFeatureType schema = DataUtilities.createType(STORE_SCHEMA_NAME, STORE_SCHEMA);\r\n        dataStore.createSchema(schema);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.DataAccessLimits.writeFilter",
	"Comment": "writes the non serializable filter object ot the objectoutputstream via a ogc filter xmlencoding conversion",
	"Method": "void writeFilter(Filter filter,ObjectOutputStream out){\r\n    if (filter != null) {\r\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        Encoder encoder = new Encoder(CONFIGURATION);\r\n        encoder.encode(filter, OGC.Filter, bos);\r\n        out.writeObject(bos.toByteArray());\r\n    } else {\r\n        out.writeObject(null);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.HistogramUtils.getTimeBuckets",
	"Comment": "helper method that creates buckets for a time domain based on the provided resolution. thereturned tuple will contain the domain representation and the domain buckets.",
	"Method": "Tuple<String, List<Range>> getTimeBuckets(List<Object> domainValues,String resolution,Tuple<String, List<Range>> getTimeBuckets,Date min,Date max,String resolution){\r\n    resolution = resolution != null ? resolution : TIME_DEFAULT_RESOLUTION;\r\n    long difference = max.getTime() - min.getTime();\r\n    long resolutionInMs;\r\n    try {\r\n        resolutionInMs = org.geoserver.ows.kvp.TimeParser.parsePeriod(resolution);\r\n        if (difference % resolutionInMs == 0) {\r\n            max = new Date(max.getTime() + resolutionInMs);\r\n        }\r\n    } catch (ParseException e) {\r\n        throw new RuntimeException(String.format(\"Error parsing time resolution '%s'.\", resolution), e);\r\n    }\r\n    Tuple<Date, Date> minMax = Tuple.tuple(min, max);\r\n    Tuple<String, List<Date>> intervalsAndSpec = getDateIntervals(minMax, resolution);\r\n    int i = 0;\r\n    while (intervalsAndSpec.second.size() >= HISTOGRAM_MAX_THRESHOLD && i < MAX_ITERATIONS) {\r\n        i++;\r\n        resolution = \"PT\" + i + \"M\";\r\n        resolutionInMs = i * 30L * 24 * 60 * 60 * 1000;\r\n        intervalsAndSpec = getDateIntervals(minMax, resolution);\r\n    }\r\n    List<Date> intervals = intervalsAndSpec.second;\r\n    if (intervals.size() == 1) {\r\n        boolean includeLast = difference < resolutionInMs;\r\n        return Tuple.tuple(intervalsAndSpec.first, Collections.singletonList(new DateRange(min, true, max, includeLast)));\r\n    }\r\n    List<Range> buckets = new ArrayList();\r\n    Date previous = intervals.get(0);\r\n    for (int step = 1; step < intervals.size(); step++) {\r\n        buckets.add(new DateRange(previous, true, intervals.get(step), false));\r\n        previous = intervals.get(step);\r\n    }\r\n    return Tuple.tuple(intervalsAndSpec.first, buckets);\r\n}"
}, {
	"Path": "org.geoserver.web.publish.PublishedConfigurationPage.updatePublishedInfo",
	"Comment": "allows collaborating pages to update the published info object",
	"Method": "void updatePublishedInfo(T info){\r\n    myModel.setObject(info);\r\n}"
}, {
	"Path": "org.vfny.geoserver.servlets.FreefsLog.destroy",
	"Comment": "closes down the zserver if it is running, and frees up resources.",
	"Method": "void destroy(){\r\n    super.destroy();\r\n    try {\r\n        Class sdepfClass = Class.forName(\"org.geotools.data.arcsde.ConnectionPoolFactory\");\r\n        LOGGER.fine(\"SDE datasource found, releasing resources\");\r\n        java.lang.reflect.Method m = sdepfClass.getMethod(\"getInstance\", new Class[0]);\r\n        Object pfInstance = m.invoke(sdepfClass, new Object[0]);\r\n        LOGGER.fine(\"got sde connection pool factory instance: \" + pfInstance);\r\n        java.lang.reflect.Method closeMethod = pfInstance.getClass().getMethod(\"closeAll\", new Class[0]);\r\n        closeMethod.invoke(pfInstance, new Object[0]);\r\n        LOGGER.info(\"just asked SDE datasource to release connections\");\r\n    } catch (ClassNotFoundException cnfe) {\r\n        LOGGER.fine(\"No SDE datasource found\");\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.StoredQueryProvider.putStoredQuery",
	"Comment": "persists a stored query, overwriting it if the query already exists.",
	"Method": "void putStoredQuery(StoredQuery query){\r\n    try {\r\n        Resource dir = storedQueryDir();\r\n        Resource f = dir.get(toFilename(query.getName()));\r\n        if (f.getType() != Type.UNDEFINED) {\r\n        }\r\n        BufferedOutputStream bout = new BufferedOutputStream(f.out());\r\n        try {\r\n            Encoder e = new Encoder(new WFSConfiguration());\r\n            e.setRootElementType(WFS.StoredQueryDescriptionType);\r\n            e.encode(query.getQuery(), WFS.StoredQueryDescription, new BufferedOutputStream(bout));\r\n            bout.flush();\r\n        } finally {\r\n            bout.close();\r\n        }\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(\"i/o error listing stored queries\", e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.WMSStoreNewPageTest.testPageRendersOnLoad",
	"Comment": "a kind of smoke test that only asserts the page is rendered when first loaded",
	"Method": "void testPageRendersOnLoad(){\r\n    startPage();\r\n    tester.assertComponent(\"form:workspacePanel\", WorkspacePanel.class);\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.LDAPAuthenticationProviderTest.testBindBeforeGroupSearchRequiredIfAnonymousDisabled",
	"Comment": "test that without bindbeforegroupsearch we get an exception during roles fetching on a serverwithout anonymous access enabled.",
	"Method": "void testBindBeforeGroupSearchRequiredIfAnonymousDisabled(){\r\n    Assume.assumeTrue(LDAPTestUtils.initLdapServer(false, ldapServerUrl, basePath));\r\n    ((LDAPSecurityServiceConfig) config).setUserDnPattern(\"uid={0},ou=People\");\r\n    config.setBindBeforeGroupSearch(false);\r\n    createAuthenticationProvider();\r\n    boolean error = false;\r\n    try {\r\n        authProvider.authenticate(authentication);\r\n    } catch (Exception e) {\r\n        error = true;\r\n    }\r\n    assertTrue(error);\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.GeoTiffWriterHelper.isUnprocessed",
	"Comment": "returns true if the coverage has not been processed in any way since it has been read",
	"Method": "boolean isUnprocessed(GridCoverage2D coverage){\r\n    RenderedImage ri = coverage.getRenderedImage();\r\n    if (ri instanceof RenderedOp) {\r\n        RenderedOp op = (RenderedOp) ri;\r\n        return op.getOperationName().startsWith(\"ImageRead\");\r\n    } else if (ri instanceof OpImage) {\r\n        return ri.getClass().getSimpleName().startsWith(\"ImageRead\");\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.sextante.SextanteProcessFactory.create",
	"Comment": "creates a geotools process which wraps a sextante geoalgorithm",
	"Method": "Process create(Name name){\r\n    checkName(name);\r\n    try {\r\n        return new SextanteProcess(Sextante.getAlgorithmFromCommandLineName(name.getLocalPart()));\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(\"Error occurred cloning the prototype \" + \"algorithm... this should not happen\", e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.Ogr2OgrOutputFormat.writeToDisk",
	"Comment": "writes to disk using shapefile if the feature type allows for it, gml otherwise",
	"Method": "File writeToDisk(File tempDir,SimpleFeatureCollection curCollection){\r\n    final SimpleFeatureType originalSchema = curCollection.getSchema();\r\n    if (curCollection.isEmpty()) {\r\n        if (isShapefileCompatible(originalSchema)) {\r\n            return writeShapefile(tempDir, curCollection);\r\n        } else {\r\n            SimpleFeatureType simplifiedShema = buildShapefileCompatible(originalSchema);\r\n            return writeShapefile(tempDir, new EmptyFeatureCollection(simplifiedShema));\r\n        }\r\n    }\r\n    File outFile = new File(tempDir, originalSchema.getTypeName() + \".gml\");\r\n    OutputStream os = null;\r\n    try {\r\n        os = new FileOutputStream(outFile);\r\n        FeatureTransformer ft = new FeatureTransformer();\r\n        ft.setNumDecimals(16);\r\n        ft.getFeatureNamespaces().declarePrefix(\"gs\", originalSchema.getName().getNamespaceURI());\r\n        ft.transform(curCollection, os);\r\n    } finally {\r\n        os.close();\r\n    }\r\n    return outFile;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findSuppWorkspacesFile",
	"Comment": "returns a supplementary configuration file in the workspaces directory, if the file does notexist null is returned.",
	"Method": "File findSuppWorkspacesFile(WorkspaceInfo ws,String filename){\r\n    Resource resource = getWorkspaces(filename);\r\n    return Resources.file(resource);\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerWicketTestSupport.initResourceSettings",
	"Comment": "helper method to initialize a standalone wickettester with the proper customizations to domessage lookups.",
	"Method": "void initResourceSettings(WicketTester tester){\r\n    tester.getApplication().getResourceSettings().setResourceStreamLocator(new GeoServerResourceStreamLocator());\r\n    tester.getApplication().getResourceSettings().getStringResourceLoaders().add(0, new GeoServerStringResourceLoader());\r\n}"
}, {
	"Path": "org.geoserver.config.impl.GeoServerInfoImpl.readResolve",
	"Comment": "xstream specific method, needed to initialize members that are added over time and to cleanlyhandle deprecated members.",
	"Method": "Object readResolve(){\r\n    if (this.globalServices == null) {\r\n        this.globalServices = true;\r\n    }\r\n    if (this.xmlPostRequestLogBufferSize == null) {\r\n        this.xmlPostRequestLogBufferSize = 1024;\r\n    }\r\n    if (this.settings == null) {\r\n        this.settings = new SettingsInfoImpl();\r\n    }\r\n    if (contact != null) {\r\n        setContact(contact);\r\n        contact = null;\r\n    }\r\n    if (charset != null) {\r\n        setCharset(charset);\r\n        charset = null;\r\n    }\r\n    if (title != null) {\r\n        setTitle(title);\r\n        title = null;\r\n    }\r\n    if (numDecimals != null) {\r\n        setNumDecimals(numDecimals);\r\n        numDecimals = null;\r\n    }\r\n    if (onlineResource != null) {\r\n        setOnlineResource(onlineResource);\r\n        onlineResource = null;\r\n    }\r\n    if (schemaBaseUrl != null) {\r\n        setSchemaBaseUrl(schemaBaseUrl);\r\n        schemaBaseUrl = null;\r\n    }\r\n    if (proxyBaseUrl != null) {\r\n        setProxyBaseUrl(proxyBaseUrl);\r\n        proxyBaseUrl = null;\r\n    }\r\n    if (verbose != null) {\r\n        setVerbose(verbose);\r\n        verbose = null;\r\n    }\r\n    if (verboseExceptions != null) {\r\n        setVerboseExceptions(verboseExceptions);\r\n        verboseExceptions = null;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.geoserver.security.xml.XMLValidator.validateRoleRegistry",
	"Comment": "validates a role dom against the xmlschema. the schema is determined by the version of therole dom",
	"Method": "void validateRoleRegistry(Document doc){\r\n    if (versionMapRR == null)\r\n        initializeSchemataRR();\r\n    XPathExpression expr = XMLXpathFactory.Singleton.getVersionExpressionRR();\r\n    String versionString;\r\n    try {\r\n        versionString = expr.evaluate(doc);\r\n    } catch (XPathExpressionException e) {\r\n        throw new IOException(e);\r\n    }\r\n    Schema schema = versionMapRR.get(versionString);\r\n    Validator val = schema.newValidator();\r\n    try {\r\n        val.validate(new DOMSource(doc));\r\n    } catch (SAXException e) {\r\n        throw new IOException(e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.encodeFeatureCollection",
	"Comment": "encode all available features by iterating over the iterator.",
	"Method": "void encodeFeatureCollection(FeatureIterator iterator){\r\n    while (iterator.hasNext()) {\r\n        encodeFeature(iterator.next());\r\n        featuresCount++;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.ResourcePool.getAttributeDescriptor",
	"Comment": "loads an attribute descriptor from feature type and attribute type metadata.this method returns null if the attribute descriptor could not be loaded.",
	"Method": "AttributeDescriptor getAttributeDescriptor(FeatureTypeInfo ftInfo,AttributeTypeInfo atInfo){\r\n    FeatureType featureType = getFeatureType(ftInfo);\r\n    if (featureType != null) {\r\n        for (PropertyDescriptor pd : featureType.getDescriptors()) {\r\n            if (pd instanceof AttributeDescriptor) {\r\n                AttributeDescriptor ad = (AttributeDescriptor) pd;\r\n                if (atInfo.getName().equals(ad.getLocalName())) {\r\n                    return ad;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.getSecurity",
	"Comment": "retrieve a resource in the the security directory. an empty path will retrieve the directoryitself.",
	"Method": "Resource getSecurity(String path){\r\n    Resource r = get(Paths.path(SECURITY_DIR, Paths.path(path)));\r\n    assert r != null;\r\n    return r;\r\n}"
}, {
	"Path": "org.geoserver.ows.XmlRequestReader.equals",
	"Comment": "two xmlreaders considered equal if namespace,element, and version properties are the same.",
	"Method": "boolean equals(Object obj){\r\n    if (!(obj instanceof XmlRequestReader)) {\r\n        return false;\r\n    }\r\n    XmlRequestReader other = (XmlRequestReader) obj;\r\n    return new EqualsBuilder().append(element, other.element).append(version, other.version).append(serviceId, other.serviceId).isEquals();\r\n}"
}, {
	"Path": "org.geoserver.opensearch.rest.CollectionsController.validateLayer",
	"Comment": "validates the layer and throws appropriate exceptions in case mandatory bits are missing",
	"Method": "void validateLayer(CollectionLayer layer){\r\n    if (layer.getWorkspace() == null) {\r\n        throw new RestException(\"Invalid layer configuration, workspace name is missing or null\", HttpStatus.BAD_REQUEST);\r\n    }\r\n    if (catalog.getWorkspaceByName(layer.getWorkspace()) == null) {\r\n        throw new RestException(\"Invalid layer configuration, workspace '\" + layer.getWorkspace() + \"' does not exist\", HttpStatus.BAD_REQUEST);\r\n    }\r\n    if (layer.getLayer() == null) {\r\n        throw new RestException(\"Invalid layer configuration, layer name is missing or null\", HttpStatus.BAD_REQUEST);\r\n    }\r\n    if (layer.isSeparateBands()) {\r\n        if (layer.getBands() == null || layer.getBands().length == 0) {\r\n            throw new RestException(\"Invalid layer configuration, claims to have separate bands but does \" + \"not list the band names\", HttpStatus.BAD_REQUEST);\r\n        }\r\n        if (layer.getBrowseBands() == null || layer.getBrowseBands().length == 0) {\r\n            throw new RestException(\"Invalid layer configuration, claims to have separate bands but does not \" + \"list the browse band names (hence cannot setup a style for it)\", HttpStatus.BAD_REQUEST);\r\n        } else if ((layer.getBrowseBands().length != 3 && layer.getBrowseBands().length != 1)) {\r\n            throw new RestException(\"Invalid layer configuration, browse bands must be either \" + \"one (gray) or three (RGB)\", HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n    if (layer.getMosaicCRS() != null) {\r\n        try {\r\n            if (!CRS.equalsIgnoreMetadata(DefaultGeographicCRS.WGS84, CRS.decode(layer.getMosaicCRS()))) {\r\n                throw new RestException(\"Invalid mosaicCRS value, can only be EPSG:4326 for the time being\", HttpStatus.BAD_REQUEST);\r\n            }\r\n        } catch (FactoryException e) {\r\n            throw new RestException(\"Invalid mosaicCRS value, cannot be decoded: \" + e.getMessage(), HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.testreader.CustomFormatReader.readImage",
	"Comment": "reads an image from a geotiff file. for more information, see imagereaddescriptor",
	"Method": "RenderedImage readImage(File inFile){\r\n    final ParameterBlock readParams = new ParameterBlock();\r\n    ImageInputStreamSpi lSpi = ImageIOExt.getImageInputStreamSPI(inFile);\r\n    PlanarImage lImage = null;\r\n    ImageInputStream lImgIn = lSpi.createInputStreamInstance(inFile, false, null);\r\n    readParams.add(lImgIn);\r\n    readParams.add(0);\r\n    readParams.add(Boolean.FALSE);\r\n    readParams.add(Boolean.FALSE);\r\n    readParams.add(Boolean.FALSE);\r\n    readParams.add(null);\r\n    readParams.add(null);\r\n    readParams.add(null);\r\n    readParams.add(READER_SPI.createReaderInstance());\r\n    lImage = JAI.create(\"ImageRead\", readParams, null);\r\n    final String lFileName = inFile.getName();\r\n    final int lExtIndex = lFileName.lastIndexOf('.');\r\n    final String lFileNameNoExt = lExtIndex < 0 ? lFileName : lFileName.substring(0, lExtIndex);\r\n    lImage.setProperty(\"name\", lFileNameNoExt);\r\n    return lImage;\r\n}"
}, {
	"Path": "org.geoserver.gwc.dispatch.GwcServiceDispatcherCallback.isGwcServiceTargeted",
	"Comment": "helper method that checks if the gwc service is targeted based on the request context.",
	"Method": "boolean isGwcServiceTargeted(String context){\r\n    if (context.startsWith(\"gwc/service\")) {\r\n        return true;\r\n    }\r\n    Matcher matcher = GWC_WS_VIRTUAL_SERVICE_PATTERN.matcher(context);\r\n    if (matcher.matches()) {\r\n        if (LocalWorkspace.get() == null && !(LocalPublished.get() instanceof LayerGroupInfo)) {\r\n            throw new ServiceException(\"No such workspace '\" + matcher.group(1) + \"'\");\r\n        }\r\n        return true;\r\n    }\r\n    matcher = GWC_LAYER_VIRTUAL_SERVICE_PATTERN.matcher(context);\r\n    if (matcher.matches()) {\r\n        if (LocalPublished.get() == null) {\r\n            throw new ServiceException(\"No such layer or layer group '\" + matcher.group(2) + \"'\");\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.post",
	"Comment": "executes an ows request using the post method with key value pairs form encoded.",
	"Method": "InputStream post(String path,InputStream post,String path,String xml,InputStream post,String path,String body,String contentType){\r\n    MockHttpServletResponse response = postAsServletResponse(path, body, contentType);\r\n    return new ByteArrayInputStream(response.getContentAsString().getBytes());\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.DataReferenceWfsOnlineTest.testGetFeaturePropertyFilter",
	"Comment": "test if we can get gsml.geologicunit.16777549126930540 using its name.",
	"Method": "void testGetFeaturePropertyFilter(){\r\n    String xml = \"<wfs:GetFeature \" + \"service=\\\"WFS\\\" \" + \"version=\\\"1.1.0\\\" \" + \"xmlns:cdf=\\\"http://www.opengis.net/cite/data\\\" \" + \"xmlns:ogc=\\\"http://www.opengis.net/ogc\\\" \" + \"xmlns:wfs=\\\"http://www.opengis.net/wfs\\\" \" + \"xmlns:gml=\\\"http://www.opengis.net/gml\\\" \" + \"xmlns:gsml=\\\"\" + AbstractAppSchemaMockData.GSML_URI + \"\\\" \" + \">\" + \"    <wfs:Query typeName=\\\"gsml:GeologicUnit\\\">\" + \"        <ogc:Filter>\" + \"            <ogc:PropertyIsEqualTo>\" + \"                <ogc:PropertyName>gml:name<\/ogc:PropertyName>\" + \"                <ogc:Literal>Unnamed incised alluvium (Na)<\/ogc:Literal>\" + \"            <\/ogc:PropertyIsEqualTo>\" + \"        <\/ogc:Filter>\" + \"    <\/wfs:Query> \" + \"<\/wfs:GetFeature>\";\r\n    Document doc = postAsDOM(\"wfs\", xml);\r\n    if (printDoc) {\r\n        LOGGER.info(\"WFS filter GetFeature response:\\n\" + prettyString(doc));\r\n    }\r\n    assertXpathCount(1, \"//gsml:GeologicUnit\", doc);\r\n    checkGU16777549126930540(doc);\r\n}"
}, {
	"Path": "org.geoserver.web.wicket.WicketHierarchyPrinter.setClassDumpEnabled",
	"Comment": "set to true if you want to see the component classes in the dump",
	"Method": "void setClassDumpEnabled(boolean classDumpEnabled){\r\n    this.classDumpEnabled = classDumpEnabled;\r\n}"
}, {
	"Path": "org.geoserver.wcs.DefaultWebCoverageService100.getDeclaredFormat",
	"Comment": "checks if the supported format string list contains the specified format, doing a caseinsensitive search. if found the declared output format name is returned, otherwise null isreturned.",
	"Method": "String getDeclaredFormat(List<String> supportedFormats,String format){\r\n    for (String sf : supportedFormats) {\r\n        if (sf.equalsIgnoreCase(format.trim())) {\r\n            return sf;\r\n        } else {\r\n            CoverageResponseDelegate delegate = responseFactory.encoderFor(sf);\r\n            if (delegate != null && delegate.canProduce(format))\r\n                return sf;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.web.HeaderContribution.appliesTo",
	"Comment": "determines if the header contribution should apply to a particular page or not.this implementation always returns true, if clients need a more flexible mechanism fordetermining which pages apply they should subclass and override this method.",
	"Method": "boolean appliesTo(WebPage page){\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.getChainedFeatures",
	"Comment": "get a list of chained features, null will be returned if this properties are not chainedfeatures.",
	"Method": "List<Feature> getChainedFeatures(List<Property> properties){\r\n    List<Feature> features = new ArrayList();\r\n    for (Property property : properties) {\r\n        if (!(property instanceof ComplexAttribute)) {\r\n            return null;\r\n        }\r\n        ComplexAttribute complexProperty = (ComplexAttribute) property;\r\n        Collection<Property> subProperties = complexProperty.getProperties();\r\n        if (subProperties.size() > 1) {\r\n            return null;\r\n        }\r\n        Property subProperty = getElementAt(subProperties, 0);\r\n        if (!(subProperty instanceof Feature)) {\r\n            return null;\r\n        }\r\n        features.add((Feature) subProperty);\r\n    }\r\n    return features;\r\n}"
}, {
	"Path": "org.geoserver.wps.ppio.JAIToolsRangePPIO.encode",
	"Comment": "encodes the internal object representation of a parameter as a string.",
	"Method": "String encode(Object value){\r\n    throw new UnsupportedOperationException(\"JaiTools range not supported out of the box\");\r\n}"
}, {
	"Path": "org.geoserver.h2.RestTest.readSqLiteDatabaseDir",
	"Comment": "helper method that zips the h2 data directory and returns it as an array of bytes.",
	"Method": "byte[] readSqLiteDatabaseDir(){\r\n    File outputFile = new File(DATABASE_DIR, \"test-database.data.db\");\r\n    InputStream input = RestTest.class.getResourceAsStream(\"/test-database.data.db\");\r\n    IOUtils.copy(input, new FileOutputStream(outputFile));\r\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\r\n    ZipOutputStream zip = new ZipOutputStream(output);\r\n    IOUtils.zipDirectory(DATABASE_DIR, zip, (dir, name) -> !name.toLowerCase().contains(\"lock\"));\r\n    zip.close();\r\n    return output.toByteArray();\r\n}"
}, {
	"Path": "org.geoserver.wps.ppio.ComplexPPIO.getFileExtension",
	"Comment": "provides a suitable extension for the output file. implement this if the file extension isnot depend on the object being encoded",
	"Method": "String getFileExtension(String getFileExtension,Object object){\r\n    return getFileExtension();\r\n}"
}, {
	"Path": "org.geoserver.netcdf.NetCDFUnitsConfigurator.getResource",
	"Comment": "searches for a config file with an absolute path, or inside the netcdf data dir, or insidethe geoserver data dir. will return a resource for the searched file, but only if it wasfound, null otherwise.",
	"Method": "Resource getResource(String absolutePathProperty,String defaultFileName){\r\n    String source = GeoServerExtensions.getProperty(absolutePathProperty);\r\n    Resource resource = getResourceForPath(source);\r\n    if (resource == null && NetCDFUtilities.EXTERNAL_DATA_DIR != null) {\r\n        source = new File(NetCDFUtilities.EXTERNAL_DATA_DIR, defaultFileName).getPath();\r\n        resource = getResourceForPath(source);\r\n    }\r\n    if (resource == null) {\r\n        resource = resourceLoader.get(NetCDFUnitFormat.NETCDF_UNIT_ALIASES);\r\n        if (resource.getType() != Resource.Type.RESOURCE) {\r\n            resource = null;\r\n        }\r\n    }\r\n    return resource;\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.MultiDimensionalExtension.appendDomainRestrictionsFilter",
	"Comment": "helper method that will build a dimension domain values filter based on this dimension startand end attributes. the created filter will be merged with the provided filter.",
	"Method": "Filter appendDomainRestrictionsFilter(Filter filter,String startAttribute,String endAttribute,Object domainRestrictions){\r\n    DimensionFilterBuilder dimensionFilterBuilder = new DimensionFilterBuilder(filterFactory);\r\n    List<Object> restrictionList = domainRestrictions instanceof Collection ? new ArrayList((Collection) domainRestrictions) : Arrays.asList(domainRestrictions);\r\n    dimensionFilterBuilder.appendFilters(startAttribute, endAttribute, restrictionList);\r\n    return filterFactory.and(filter, dimensionFilterBuilder.getFilter());\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.HistogramUtils.buildHistogram",
	"Comment": "builds an histogram for the provided domain values. the returned tuple will contain thedomain representation and the histogram values. the domain values should be numbers, dates orstrings. ranges are also supported, the min value will be used to discover the domain valuestype.",
	"Method": "Tuple<String, List<Integer>> buildHistogram(List<Object> domainValues,String resolution){\r\n    if (domainValues.isEmpty()) {\r\n        return Tuple.tuple(\"\", Collections.emptyList());\r\n    }\r\n    Tuple<String, List<Range>> buckets = computeBuckets(domainValues, resolution);\r\n    ArrayList<Integer> histogramValues = new ArrayList(buckets.second.size());\r\n    for (int i = 0; i < buckets.second.size(); i++) {\r\n        histogramValues.add(0);\r\n    }\r\n    for (Object value : domainValues) {\r\n        int index = getBucketIndex(buckets.second, (Comparable) value);\r\n        if (index >= 0) {\r\n            histogramValues.set(index, histogramValues.get(index) + 1);\r\n        } else if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Bucket not found for value: \" + value);\r\n        }\r\n    }\r\n    return Tuple.tuple(buckets.first, histogramValues);\r\n}"
}, {
	"Path": "org.geoserver.security.SecureCatalogImpl.isAdmin",
	"Comment": "checks if the current user is authenticated and is the administrator. protected to allowoverriding in tests.",
	"Method": "boolean isAdmin(Authentication authentication){\r\n    return GeoServerExtensions.bean(GeoServerSecurityManager.class).checkAuthenticationForAdminRole(authentication);\r\n}"
}, {
	"Path": "org.geoserver.gwc.web.gridset.GridSetListTablePanel.selectOneCheckbox",
	"Comment": "overrides to return a disabled and non selectable checkbox if the gridset for the item is aninternally defined one",
	"Method": "CheckBox selectOneCheckbox(Item<GridSet> item){\r\n    CheckBox cb = super.selectOneCheckbox(item);\r\n    GridSet gs = (GridSet) item.getModelObject();\r\n    String name = gs.getName();\r\n    final boolean internal = GWC.get().isInternalGridSet(name);\r\n    if (internal) {\r\n        cb.setEnabled(false);\r\n        cb.setModelObject(Boolean.FALSE);\r\n    }\r\n    return cb;\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.LDAPTestUtils.startEmbeddedServer",
	"Comment": "start an embedded apache directory server. only one embedded server will be permitted in thesame jvm.",
	"Method": "void startEmbeddedServer(int port,String defaultPartitionSuffix,String defaultPartitionName,boolean allowAnonymousAccess){\r\n    if (embeddedServer != null) {\r\n        throw new IllegalStateException(\"An embedded server is already started\");\r\n    }\r\n    try {\r\n        embeddedServer = EmbeddedLdapServer.newEmbeddedServer(defaultPartitionName, defaultPartitionSuffix, port, allowAnonymousAccess);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(\"Failed to start embedded server\", e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.getFeatureTypeInfo",
	"Comment": "get the featuretypeinfo for a featuretype by the layername that would be used in a request.",
	"Method": "FeatureTypeInfo getFeatureTypeInfo(QName typename,FeatureTypeInfo getFeatureTypeInfo,String typename){\r\n    return getFeatureTypeInfo(resolveLayerName(typename));\r\n}"
}, {
	"Path": "org.geoserver.wfs.kvp.BaseFeatureKvpRequestReader.ensureMutuallyExclusive",
	"Comment": "given a set of keys, this method will ensure that no two keys are specified at the same time",
	"Method": "void ensureMutuallyExclusive(Map kvp,String[] keys,EObject request){\r\n    for (int i = 0; i < keys.length; i++) {\r\n        if (kvp.containsKey(keys[i])) {\r\n            for (int j = i + 1; j < keys.length; j++) {\r\n                if (kvp.containsKey(keys[j])) {\r\n                    String msg = keys[i] + \" and \" + keys[j] + \" both specified but are mutually exclusive\";\r\n                    throw new WFSException(request, msg);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.ModificationProxy.handler",
	"Comment": "returns the modificationproxy invocation handler for an proxy object.this method will return null in the case where the object is not a proxy, or it is beingproxies by another invocation handler.",
	"Method": "ModificationProxy handler(Object object){\r\n    return ProxyUtils.handler(object, ModificationProxy.class);\r\n}"
}, {
	"Path": "org.geoserver.security.impl.DataAccessRule.compareTo",
	"Comment": "comparison implemented so that generic rules get first, specific one are compared by name,and if anything else is equal, read comes before write",
	"Method": "int compareTo(DataAccessRule other){\r\n    int compareRoot = compareCatalogItems(root, other.root);\r\n    if (compareRoot != 0)\r\n        return compareRoot;\r\n    int compareLayer = compareCatalogItems(layer, other.layer);\r\n    if (compareLayer != 0)\r\n        return compareLayer;\r\n    if (accessMode.equals(other.accessMode))\r\n        return 0;\r\n    else\r\n        return accessMode.equals(AccessMode.READ) ? -1 : 1;\r\n}"
}, {
	"Path": "org.geoserver.taskmanager.external.impl.InformixDialectImpl.isNullable",
	"Comment": "override because in a view informix returns the value of the underlying column definition ofthe table. even when performing left join in the create view statement.",
	"Method": "int isNullable(int nullable){\r\n    return -1;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.eo.response.GranuleCoverageExtension.getCoverageId",
	"Comment": "returns the coverage identifier related to the specified coverageid, or null if the syntax isincorrect",
	"Method": "String getCoverageId(String coverageId){\r\n    if (!coverageId.contains(GRANULE_SEPARATOR)) {\r\n        return null;\r\n    }\r\n    String[] splitted = coverageId.split(GRANULE_SEPARATOR);\r\n    if (splitted.length != 2) {\r\n        return null;\r\n    } else {\r\n        return splitted[0];\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.sextante.StreamOutputLayer.getFieldCount",
	"Comment": "all methods from here are dummy ones and are not supposed to be used",
	"Method": "int getFieldCount(){\r\n    return 0;\r\n}"
}, {
	"Path": "org.geoserver.test.StationsAppSchemaTestSupport.checkCount",
	"Comment": "helper method that evaluates a xpath and checks if the number of nodes found correspond tothe expected number,",
	"Method": "void checkCount(XpathEngine xpathEngine,Document document,int expectedCount,String xpath){\r\n    try {\r\n        assertThat(xpathEngine.getMatchingNodes(xpath, document).getLength(), is(expectedCount));\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error evaluating xpath: \" + xpath, exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerLoader.depersist",
	"Comment": "helper method which uses xstream to depersist an object as xml from disk.",
	"Method": "T depersist(XStreamPersister xp,Resource f,Class<T> clazz,T depersist,XStreamPersister xp,byte[] contents,Class<T> clazz){\r\n    try (InputStream in = new ByteArrayInputStream(contents)) {\r\n        return xp.load(in, clazz);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.AggregateProcessJSONPPIO.encodeSimpleResult",
	"Comment": "helper method that encodes the result of an aggregator process when there is no group byattributes. we encode the value of each aggregation function producing an output very similarof an sql query result.",
	"Method": "Number[] encodeSimpleResult(AggregateProcess.Results processResult){\r\n    return processResult.getFunctions().stream().map(function -> processResult.getResults().get(function)).toArray(Number[]::new);\r\n}"
}, {
	"Path": "org.geoserver.web.publish.PublishedConfigurationPage.initComponents",
	"Comment": "initialize components including tabpanels via publishededittabpanelinfo extensions",
	"Method": "void initComponents(){\r\n    this.tabPanelCustomModels = new LinkedHashMap<Class<? extends PublishedEditTabPanel<T>>, IModel<?>>();\r\n    add(new Label(\"publishedinfoname\", getPublishedInfo().prefixedName()));\r\n    Form<T> theForm = new Form<T>(\"publishedinfo\", myModel);\r\n    add(theForm);\r\n    List<ITab> tabs = new ArrayList<ITab>();\r\n    tabs.add(new AbstractTab(new org.apache.wicket.model.ResourceModel(\"ResourceConfigurationPage.Data\")) {\r\n        private static final long serialVersionUID = 1L;\r\n        public Panel getPanel(String panelID) {\r\n            return createMainTab(panelID).setInputEnabled(inputEnabled);\r\n        }\r\n    });\r\n    tabs.add(new AbstractTab(new org.apache.wicket.model.ResourceModel(\"ResourceConfigurationPage.Publishing\")) {\r\n        private static final long serialVersionUID = 1L;\r\n        public Panel getPanel(String panelID) {\r\n            return new PublishingEditTabPanel(panelID).setInputEnabled(inputEnabled);\r\n        }\r\n    });\r\n    List<PublishedEditTabPanelInfo> tabPanels = tabPanelsExtensions();\r\n    sortTabPanels(tabPanels);\r\n    for (PublishedEditTabPanelInfo ttabPanelInfo : tabPanels) {\r\n        if (ttabPanelInfo.supports(getPublishedInfo())) {\r\n            @SuppressWarnings(\"unchecked\")\r\n            PublishedEditTabPanelInfo<T> tabPanelInfo = (PublishedEditTabPanelInfo<T>) ttabPanelInfo;\r\n            String titleKey = tabPanelInfo.getTitleKey();\r\n            IModel<String> titleModel = null;\r\n            if (titleKey != null) {\r\n                titleModel = new org.apache.wicket.model.ResourceModel(titleKey);\r\n            } else {\r\n                titleModel = new Model<String>(tabPanelInfo.getComponentClass().getSimpleName());\r\n            }\r\n            final Class<PublishedEditTabPanel<T>> panelClass = tabPanelInfo.getComponentClass();\r\n            IModel<?> panelCustomModel = tabPanelInfo.createOwnModel(myModel, isNew);\r\n            tabPanelCustomModels.put(panelClass, panelCustomModel);\r\n            tabs.add(new AbstractTab(titleModel) {\r\n                private static final long serialVersionUID = -6637277497986497791L;\r\n                private final Class<PublishedEditTabPanel<T>> panelType = panelClass;\r\n                @Override\r\n                public Panel getPanel(String panelId) {\r\n                    PublishedEditTabPanel<?> tabPanel;\r\n                    final IModel<?> panelCustomModel = tabPanelCustomModels.get(panelType);\r\n                    try {\r\n                        if (panelCustomModel == null) {\r\n                            tabPanel = panelClass.getConstructor(String.class, IModel.class).newInstance(panelId, myModel);\r\n                        } else {\r\n                            tabPanel = panelClass.getConstructor(String.class, IModel.class, IModel.class).newInstance(panelId, myModel, panelCustomModel);\r\n                        }\r\n                    } catch (Exception e) {\r\n                        throw new WicketRuntimeException(e);\r\n                    }\r\n                    return tabPanel;\r\n                }\r\n            });\r\n        }\r\n    }\r\n    tabbedPanel = new TabbedPanel(\"tabs\", tabs) {\r\n        private static final long serialVersionUID = 1L;\r\n        @Override\r\n        protected WebMarkupContainer newLink(String linkId, final int index) {\r\n            return new SubmitLink(linkId) {\r\n                private static final long serialVersionUID = 1L;\r\n                @Override\r\n                public void onSubmit() {\r\n                    setSelectedTab(index);\r\n                }\r\n            };\r\n        }\r\n    };\r\n    theForm.add(tabbedPanel);\r\n    theForm.add(saveLink());\r\n    theForm.add(cancelLink());\r\n}"
}, {
	"Path": "org.geoserver.web.publish.PublishedConfigurationPage.initComponents",
	"Comment": "initialize components including tabpanels via publishededittabpanelinfo extensions",
	"Method": "void initComponents(){\r\n    return createMainTab(panelID).setInputEnabled(inputEnabled);\r\n}"
}, {
	"Path": "org.geoserver.web.publish.PublishedConfigurationPage.initComponents",
	"Comment": "initialize components including tabpanels via publishededittabpanelinfo extensions",
	"Method": "void initComponents(){\r\n    return new PublishingEditTabPanel(panelID).setInputEnabled(inputEnabled);\r\n}"
}, {
	"Path": "org.geoserver.web.publish.PublishedConfigurationPage.initComponents",
	"Comment": "initialize components including tabpanels via publishededittabpanelinfo extensions",
	"Method": "void initComponents(){\r\n    PublishedEditTabPanel<?> tabPanel;\r\n    final IModel<?> panelCustomModel = tabPanelCustomModels.get(panelType);\r\n    try {\r\n        if (panelCustomModel == null) {\r\n            tabPanel = panelClass.getConstructor(String.class, IModel.class).newInstance(panelId, myModel);\r\n        } else {\r\n            tabPanel = panelClass.getConstructor(String.class, IModel.class, IModel.class).newInstance(panelId, myModel, panelCustomModel);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new WicketRuntimeException(e);\r\n    }\r\n    return tabPanel;\r\n}"
}, {
	"Path": "org.geoserver.web.publish.PublishedConfigurationPage.initComponents",
	"Comment": "initialize components including tabpanels via publishededittabpanelinfo extensions",
	"Method": "void initComponents(){\r\n    return new SubmitLink(linkId) {\r\n        private static final long serialVersionUID = 1L;\r\n        @Override\r\n        public void onSubmit() {\r\n            setSelectedTab(index);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.geoserver.web.publish.PublishedConfigurationPage.initComponents",
	"Comment": "initialize components including tabpanels via publishededittabpanelinfo extensions",
	"Method": "void initComponents(){\r\n    setSelectedTab(index);\r\n}"
}, {
	"Path": "org.geoserver.gwc.config.GWCConfig.isInnerCachingEnabled",
	"Comment": "checks whether gwc tiles should be cached in memory instead of caching them in the filesystem",
	"Method": "boolean isInnerCachingEnabled(){\r\n    return innerCachingEnabled;\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.LimitedImageOutputStream.checkLimit",
	"Comment": "called to check, whether the input streams limit is reached.",
	"Method": "void checkLimit(){\r\n    if (count > sizeMax) {\r\n        raiseError(sizeMax, count);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.gwc.ConfigurableQuotaStoreProvider.getException",
	"Comment": "the exception occurred during the last attempt to load the quota store, if any",
	"Method": "Exception getException(){\r\n    return exception;\r\n}"
}, {
	"Path": "org.geoserver.security.password.URLMasterPasswordProviderConfig.setEncrypting",
	"Comment": "sets flag controlling whether passwords are stored encrypted.",
	"Method": "void setEncrypting(boolean encrypting){\r\n    this.encrypting = encrypting;\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.dxf.AbstractDXFWriter.getColor",
	"Comment": "assign a color to the collection, cycling through the available color list.",
	"Method": "int getColor(FeatureCollection coll){\r\n    int color = colors[colorPos];\r\n    if (colorPos < (colors.length - 1))\r\n        colorPos++;\r\n    else\r\n        colorPos = 0;\r\n    return color;\r\n}"
}, {
	"Path": "org.geoserver.inspire.wcs.WCSExtendedCapabilitiesTest.testExtCaps111WithFullSettings",
	"Comment": "no inspire extendedcapabilities should be returned in a wcs 1.1.1 response",
	"Method": "void testExtCaps111WithFullSettings(){\r\n    final ServiceInfo serviceInfo = getGeoServer().getService(WCSInfo.class);\r\n    final MetadataMap metadata = serviceInfo.getMetadata();\r\n    clearInspireMetadata(metadata);\r\n    metadata.put(CREATE_EXTENDED_CAPABILITIES.key, true);\r\n    metadata.put(SERVICE_METADATA_URL.key, \"http://foo.com?bar=baz\");\r\n    metadata.put(SERVICE_METADATA_TYPE.key, \"application/vnd.iso.19139+xml\");\r\n    metadata.put(LANGUAGE.key, \"fre\");\r\n    metadata.put(SPATIAL_DATASET_IDENTIFIER_TYPE.key, \"one,http://www.geoserver.org/one;two,http://www.geoserver.org/two,http://metadata.geoserver.org/id?two\");\r\n    getGeoServer().save(serviceInfo);\r\n    final Document dom = getAsDOM(WCS_1_1_1_GETCAPREQUEST);\r\n    final NodeList nodeList = dom.getElementsByTagNameNS(DLS_NAMESPACE, \"ExtendedCapabilities\");\r\n    assertTrue(nodeList.getLength() == 0);\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTest.applyDeleteCatalogChanges",
	"Comment": "helper method that removes some elements from the catalog of the provided instance.",
	"Method": "void applyDeleteCatalogChanges(GeoServerInstance instance){\r\n    Catalog catalog = instance.getCatalog();\r\n    LayerGroupInfo layerGroup = catalog.getLayerGroupByName(\"layerGroup-Name\");\r\n    catalog.remove(layerGroup);\r\n    LayerInfo layer = catalog.getLayerByName(\"featureType-Name\");\r\n    catalog.remove(layer);\r\n    WMSLayerInfo wmsLayer = catalog.getResourceByName(\"wmsLayer-Name\", WMSLayerInfo.class);\r\n    catalog.remove(wmsLayer);\r\n    FeatureTypeInfo featureType = catalog.getFeatureTypeByName(\"featureType-Name\");\r\n    catalog.remove(featureType);\r\n    StyleInfo style = catalog.getStyleByName(\"style-Name-modified\");\r\n    catalog.remove(style);\r\n    CoverageInfo coverage = catalog.getCoverageByName(\"coverage-Name\");\r\n    catalog.remove(coverage);\r\n    DataStoreInfo dataStore = catalog.getDataStoreByName(\"dataStore-Name\");\r\n    catalog.remove(dataStore);\r\n    CoverageStoreInfo coverageStore = catalog.getCoverageStoreByName(\"coverageStore-Name\");\r\n    catalog.remove(coverageStore);\r\n    WMSStoreInfo wmsStore = catalog.getStoreByName(\"wmsStore-Name\", WMSStoreInfo.class);\r\n    catalog.remove(wmsStore);\r\n    NamespaceInfo namespace = catalog.getNamespaceByPrefix(\"workspace-Name\");\r\n    catalog.remove(namespace);\r\n}"
}, {
	"Path": "org.geoserver.nsg.pagination.random.IndexOutputFormat.writeDocument",
	"Comment": "helper method that just writes a xml document to a given output stream.",
	"Method": "void writeDocument(Document document,OutputStream output){\r\n    TransformerFactory transformerFactory = TransformerFactory.newInstance();\r\n    Transformer transformer;\r\n    try {\r\n        transformer = transformerFactory.newTransformer();\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error creating XML transformer.\", exception);\r\n    }\r\n    DOMSource source = new DOMSource(document);\r\n    StreamResult result = new StreamResult(output);\r\n    try {\r\n        transformer.transform(source, result);\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error writing INDEX result to the output stream.\", exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.csw.DirectDownloadTest.evaluate",
	"Comment": "return the flattened value corresponding to an xpath expression from a document.",
	"Method": "String evaluate(String xpath,Document document){\r\n    try {\r\n        return getXpathEngine().evaluate(xpath, document);\r\n    } catch (XpathException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.BBoxFilterTest.testQueryBboxLongLat",
	"Comment": "the following performs a wfs request specifying a bbox parameter of axis ordering longitudelatitude.",
	"Method": "void testQueryBboxLongLat(){\r\n    Document doc = getAsDOM(WFS_GET_FEATURE + LONGLAT);\r\n    LOGGER.info(WFS_GET_FEATURE_LOG + LONGLAT + prettyString(doc));\r\n    assertXpathEvaluatesTo(\"0\", \"/wfs:FeatureCollection/@numberOfFeatures\", doc);\r\n    assertXpathCount(0, \"//ex:geomContainer\", doc);\r\n}"
}, {
	"Path": "org.geoserver.importer.Importer.createContext",
	"Comment": "create a context with the provided optional id. the provided id must be higher than thecurrent mark.",
	"Method": "ImportContext createContext(ImportData data,WorkspaceInfo targetWorkspace,ImportContext createContext,ImportData data,StoreInfo targetStore,ImportContext createContext,ImportData data,ImportContext createContext,Long id,ImportContext createContext,ImportData data,WorkspaceInfo targetWorkspace,StoreInfo targetStore,ImportContext createContext,ImportData data,WorkspaceInfo targetWorkspace,StoreInfo targetStore,ProgressMonitor monitor){\r\n    ImportContext context = new ImportContext();\r\n    context.setProgress(monitor);\r\n    context.setData(data);\r\n    if (targetWorkspace == null && targetStore != null) {\r\n        targetWorkspace = targetStore.getWorkspace();\r\n    }\r\n    if (targetWorkspace == null) {\r\n        targetWorkspace = catalog.getDefaultWorkspace();\r\n    }\r\n    context.setTargetWorkspace(targetWorkspace);\r\n    context.setTargetStore(targetStore);\r\n    init(context);\r\n    if (!context.progress().isCanceled()) {\r\n        contextStore.add(context);\r\n    }\r\n    return context;\r\n}"
}, {
	"Path": "org.geoserver.security.SecurityUtils.isSecurityException",
	"Comment": "spring secruity 3.x drops the common base security exception class springsecurityexception,now the test is based on the package name",
	"Method": "boolean isSecurityException(Throwable t){\r\n    return t != null && t.getClass().getPackage().getName().startsWith(\"org.springframework.security\");\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.pgraster.PGRasterPanel.buildURL",
	"Comment": "setup a url string composing all the required configuration options",
	"Method": "String buildURL(){\r\n    StringBuilder builder = new StringBuilder(\"pgraster://\");\r\n    builder.append(user.getValue()).append(\":\").append(password.getValue()).append(\"@\").append(server.getValue()).append(\":\").append(port.getValue()).append(\":\").append(database.getValue()).append(\".\").append(schema.getValue()).append(\".\").append(table.getValue());\r\n    final CoordinateReferenceSystem crs = (CoordinateReferenceSystem) epsgcode.getModel().getObject();\r\n    if (crs != null) {\r\n        Integer code;\r\n        try {\r\n            code = CRS.lookupEpsgCode(crs, false);\r\n            if (code != null) {\r\n                builder.append(\"@\").append(code);\r\n            }\r\n        } catch (FactoryException e) {\r\n            if (LOGGER.isLoggable(Level.WARNING)) {\r\n                LOGGER.warning(\"Unable to parse the specified CRS due to \" + e.getMessage());\r\n            }\r\n        }\r\n    }\r\n    builder.append(\":\");\r\n    final String fileExt = fileext.getValue();\r\n    if (fileExt != null && fileExt.trim().length() > 0) {\r\n        builder.append(fileExt);\r\n    }\r\n    final String options = importopt.getValue();\r\n    if (options != null && options.trim().length() > 0) {\r\n        builder.append(\"?\").append(options);\r\n    }\r\n    builder.append(\"#\");\r\n    return builder.toString();\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findOrResolveStoreFile",
	"Comment": "returns the configuration file for the specified store, if the file does not exist a fileobject is still returned.",
	"Method": "File findOrResolveStoreFile(StoreInfo store){\r\n    Resource resource = get(store);\r\n    return resource.file();\r\n}"
}, {
	"Path": "org.geoserver.importer.DataFormat.relativeDataFileURL",
	"Comment": "converts an absolute url to a resource to be relative to the data directory if applicable.",
	"Method": "String relativeDataFileURL(String url,Catalog catalog){\r\n    if (catalog == null) {\r\n        return url;\r\n    }\r\n    File baseDirectory = catalog.getResourceLoader().getBaseDirectory();\r\n    File f = Files.url(baseDirectory, url);\r\n    return f == null ? url : \"file:\" + Paths.convert(baseDirectory, f);\r\n}"
}, {
	"Path": "org.geoserver.config.util.SecureXStream.setupConverters",
	"Comment": "this method is a clone of the base class one, leaving the converters in the same order wherepossible, but altering a few ones performing illegal reflective accesses against java coreclasses, replacing them with alternatives that do not, or simply removing them, if we are notusing them",
	"Method": "void setupConverters(){\r\n    Mapper mapper = getMapper();\r\n    ReflectionProvider reflectionProvider = getReflectionProvider();\r\n    ClassLoaderReference classLoaderReference = getClassLoaderReference();\r\n    ConverterLookup converterLookup = getConverterLookup();\r\n    registerConverter(new ReflectionConverter(mapper, reflectionProvider), PRIORITY_VERY_LOW);\r\n    registerConverter(new NullConverter(), PRIORITY_VERY_HIGH);\r\n    registerConverter(new IntConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new FloatConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new DoubleConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new LongConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new ShortConverter(), PRIORITY_NORMAL);\r\n    registerConverter((Converter) new CharConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new BooleanConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new ByteConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new StringConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new StringBufferConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new DateConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new BitSetConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new URIConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new URLConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new BigIntegerConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new BigDecimalConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new ArrayConverter(mapper), PRIORITY_NORMAL);\r\n    registerConverter(new CharArrayConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new CollectionConverter(mapper), PRIORITY_NORMAL);\r\n    registerConverter(new MapConverter(mapper), PRIORITY_NORMAL);\r\n    registerConverter(new TreeMapConverter(mapper), PRIORITY_NORMAL);\r\n    registerConverter(new TreeSetConverter(mapper), PRIORITY_NORMAL);\r\n    registerConverter(new SingletonCollectionConverter(mapper), PRIORITY_NORMAL);\r\n    registerConverter(new SingletonMapConverter(mapper), PRIORITY_NORMAL);\r\n    registerConverter((Converter) new EncodedByteArrayConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new FileConverter(), PRIORITY_NORMAL);\r\n    if (JVM.isSQLAvailable()) {\r\n        registerConverter(new SqlTimestampConverter(), PRIORITY_NORMAL);\r\n        registerConverter(new SqlTimeConverter(), PRIORITY_NORMAL);\r\n        registerConverter(new SqlDateConverter(), PRIORITY_NORMAL);\r\n    }\r\n    registerConverter(new JavaClassConverter(classLoaderReference), PRIORITY_NORMAL);\r\n    registerConverter(new JavaMethodConverter(classLoaderReference), PRIORITY_NORMAL);\r\n    registerConverter(new JavaFieldConverter(classLoaderReference), PRIORITY_NORMAL);\r\n    if (JVM.isAWTAvailable()) {\r\n        registerConverter(new ColorConverter(), PRIORITY_NORMAL);\r\n    }\r\n    if (JVM.isSwingAvailable()) {\r\n        registerConverter(new LookAndFeelConverter(mapper, reflectionProvider), PRIORITY_NORMAL);\r\n    }\r\n    registerConverter(new LocaleConverter(), PRIORITY_NORMAL);\r\n    registerConverter(new GregorianCalendarConverter(), PRIORITY_NORMAL);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.SubjectConverter\", PRIORITY_NORMAL, new Class[] { Mapper.class }, new Object[] { mapper });\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.ThrowableConverter\", PRIORITY_NORMAL, new Class[] { ConverterLookup.class }, new Object[] { converterLookup });\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.StackTraceElementConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.CurrencyConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.RegexPatternConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.CharsetConverter\", PRIORITY_NORMAL, null, null);\r\n    if (JVM.loadClassForName(\"javax.xml.datatype.Duration\") != null) {\r\n        registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.DurationConverter\", PRIORITY_NORMAL, null, null);\r\n    }\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.enums.EnumConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.basic.StringBuilderConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.basic.UUIDConverter\", PRIORITY_NORMAL, null, null);\r\n    if (JVM.loadClassForName(\"javax.activation.ActivationDataFlavor\") != null) {\r\n        registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.ActivationDataFlavorConverter\", PRIORITY_NORMAL, null, null);\r\n    }\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.PathConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ChronologyConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.DurationConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.HijrahDateConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseDateConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseEraConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.InstantConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateTimeConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalTimeConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MinguoDateConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MonthDayConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetDateTimeConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetTimeConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.PeriodConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.SystemClockConverter\", PRIORITY_NORMAL, new Class[] { Mapper.class }, new Object[] { mapper });\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ThaiBuddhistDateConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ValueRangeConverter\", PRIORITY_NORMAL, new Class[] { Mapper.class }, new Object[] { mapper });\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.WeekFieldsConverter\", PRIORITY_NORMAL, new Class[] { Mapper.class }, new Object[] { mapper });\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearMonthConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZonedDateTimeConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZoneIdConverter\", PRIORITY_NORMAL, null, null);\r\n    registerConverterDynamically(\"com.thoughtworks.xstream.converters.reflection.LambdaConverter\", PRIORITY_NORMAL, new Class[] { Mapper.class, ReflectionProvider.class, ClassLoaderReference.class }, new Object[] { mapper, reflectionProvider, classLoaderReference });\r\n    registerConverter(new SelfStreamingInstanceChecker(converterLookup, this), PRIORITY_NORMAL);\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.kvp.SearchRequestKvpReaderTest.testParseSearchTermsWrongCase",
	"Comment": "from spec the parameter keys are case sensitive, and unknown ones should be ignored",
	"Method": "void testParseSearchTermsWrongCase(){\r\n    Map<String, String> map = toMap(SEARCH_TERMS.key.toUpperCase(), \"a b \\\"c and d\\\"\");\r\n    SearchRequest request = parseSearchRequest(map);\r\n    assertEquals(null, request.getParentId());\r\n    final Query query = request.getQuery();\r\n    assertEquals(Filter.INCLUDE, query.getFilter());\r\n}"
}, {
	"Path": "org.geoserver.wfs.GetFeatureContext.getRequest",
	"Comment": "the full getfeature request being run. the object returned may be mutable, but the callbackis strongly suggested not to attempt any modification, the behavior of doing so is undefinedand might change over time",
	"Method": "GetFeatureRequest getRequest(){\r\n    return request;\r\n}"
}, {
	"Path": "org.geoserver.wms.ncwms.NcWmsGetTimeSeriesTest.testTimeRanges",
	"Comment": "ensures we get the right results with shorter or wider time ranges",
	"Method": "void testTimeRanges(){\r\n    setupRasterDimension(WATTEMP, ResourceInfo.ELEVATION, DimensionPresentation.LIST, null, UNITS, UNIT_SYMBOL);\r\n    setupRasterDimension(WATTEMP, ResourceInfo.TIME, DimensionPresentation.LIST, null, null, \"degrees\");\r\n    String url = BASE_URL_4326 + CSV_FORMAT + TIME_RANGE_EXTRA;\r\n    String rawCsv = getAsString(url);\r\n    String[] csvLines = rawCsv.split(\"\\\\r?\\\\n\");\r\n    Assert.assertEquals(\"CSV Number of results\", 5, csvLines.length);\r\n    assertCsvLine(\"value 2008-10-31\", csvLines[3], \"2008-10-31T00:00:00.000Z\", 16.88799985218793, 0.000000000001);\r\n    assertCsvLine(\"value 2008-11-01\", csvLines[4], \"2008-11-01T00:00:00.000Z\", 17.120999863254838, 0.000000000001);\r\n    url = BASE_URL_4326 + CSV_FORMAT + TIME_RANGE_SLICE1;\r\n    rawCsv = getAsString(url);\r\n    csvLines = rawCsv.split(\"\\\\r?\\\\n\");\r\n    Assert.assertEquals(\"CSV Number of results\", 4, csvLines.length);\r\n    assertCsvLine(\"value 2008-10-31\", csvLines[3], \"2008-10-31T00:00:00.000Z\", 16.88799985218793, 0.000000000001);\r\n    url = BASE_URL_4326 + CSV_FORMAT + TIME_RANGE_SLICE2;\r\n    rawCsv = getAsString(url);\r\n    csvLines = rawCsv.split(\"\\\\r?\\\\n\");\r\n    Assert.assertEquals(\"CSV Number of results\", 4, csvLines.length);\r\n    assertCsvLine(\"value 2008-11-01\", csvLines[3], \"2008-11-01T00:00:00.000Z\", 17.120999863254838, 0.000000000001);\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.RasterDownload.bandSelect",
	"Comment": "apply bandselection operation in case band indices have been specified but underlying readerdo not support bands param.",
	"Method": "GridCoverage2D bandSelect(GridCoverage2DReader reader,GeneralParameterValue[] readParameters,int[] bandIndices,GridCoverage2D originalGridCoverage,List<GridCoverage2D> disposableSources){\r\n    GridCoverage2D bandFilteredCoverage = originalGridCoverage;\r\n    if (bandIndices != null && bandIndices.length > 0) {\r\n        for (GeneralParameterValue readParameter : readParameters) {\r\n            if (AbstractGridFormat.BANDS.getName().equals(readParameter.getDescriptor().getName())) {\r\n                Object bands = ((ParameterValue) readParameter).getValue();\r\n                if (bands != null && reader.getFormat() != null && reader.getFormat().getReadParameters().getDescriptor().descriptors().contains(AbstractGridFormat.BANDS)) {\r\n                    return bandFilteredCoverage;\r\n                }\r\n            }\r\n        }\r\n        int sampleDimensionsNumber = originalGridCoverage.getNumSampleDimensions();\r\n        for (int i : bandIndices) {\r\n            if (i < 0 || i >= sampleDimensionsNumber) {\r\n                throw new WPSException(\"Band index \" + i + \" is invalid for the current input raster. \" + \"This raster contains \" + sampleDimensionsNumber + \" band\" + (sampleDimensionsNumber > 1 ? \"s\" : \"\"));\r\n            }\r\n        }\r\n        BandSelectProcess bandSelectProcess = new BandSelectProcess();\r\n        disposableSources.add(originalGridCoverage);\r\n        bandFilteredCoverage = bandSelectProcess.execute(originalGridCoverage, bandIndices, null);\r\n    }\r\n    return bandFilteredCoverage;\r\n}"
}, {
	"Path": "org.geoserver.monitor.MonitorFilter.getBody",
	"Comment": "get the body and trim to the maximum allowable size if necessary",
	"Method": "byte[] getBody(HttpServletRequest req){\r\n    long maxBodyLength = monitor.config.getMaxBodySize();\r\n    if (maxBodyLength == 0)\r\n        return null;\r\n    try {\r\n        byte[] body = ((MonitorServletRequest) req).getBodyContent();\r\n        if (body != null && maxBodyLength != MonitorServletRequest.BODY_SIZE_UNBOUNDED && body.length > maxBodyLength)\r\n            body = Arrays.copyOfRange(body, 0, (int) maxBodyLength);\r\n        return body;\r\n    } catch (IOException ex) {\r\n        LOGGER.log(Level.WARNING, \"Could not read request body\", ex);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.RasterTimeDimensionTest.getGeneratedMiddleValue",
	"Comment": "generates the current middle date, this date is one month later than the current minimumdate.",
	"Method": "Date getGeneratedMiddleValue(){\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\r\n    Calendar calendar = Calendar.getInstance();\r\n    calendar.set(Calendar.HOUR_OF_DAY, calendar.getActualMinimum(Calendar.HOUR_OF_DAY));\r\n    calendar.set(Calendar.MINUTE, calendar.getActualMinimum(Calendar.MINUTE));\r\n    calendar.set(Calendar.SECOND, calendar.getActualMinimum(Calendar.SECOND));\r\n    calendar.set(Calendar.MILLISECOND, calendar.getActualMinimum(Calendar.MILLISECOND));\r\n    calendar.set(Calendar.MONTH, calendar.get(Calendar.MONTH) + 1);\r\n    return calendar.getTime();\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.isStrongEncryptionAvailable",
	"Comment": "determines if strong encryption is available.this method does the determination by trying to encrypt a value with aes 256 bitencryption.",
	"Method": "boolean isStrongEncryptionAvailable(){\r\n    if (strongEncryptionAvaialble != null)\r\n        return strongEncryptionAvaialble;\r\n    KeyGenerator kgen;\r\n    try {\r\n        kgen = KeyGenerator.getInstance(\"AES\");\r\n        kgen.init(256);\r\n        SecretKey skey = kgen.generateKey();\r\n        byte[] raw = skey.getEncoded();\r\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\r\n        Cipher cipher = Cipher.getInstance(\"AES\");\r\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\r\n        cipher.doFinal(\"This is just an example\".getBytes());\r\n        strongEncryptionAvaialble = true;\r\n        LOGGER.info(\"Strong cryptography is available\");\r\n    } catch (InvalidKeyException e) {\r\n        strongEncryptionAvaialble = false;\r\n        LOGGER.warning(\"Strong cryptography is NOT available\" + \"\\nDownload and installation the of unlimted length policy files is recommended\");\r\n    } catch (Exception ex) {\r\n        LOGGER.log(Level.WARNING, \"Strong cryptography is NOT available, unexpected error\", ex);\r\n        strongEncryptionAvaialble = false;\r\n    }\r\n    return strongEncryptionAvaialble;\r\n}"
}, {
	"Path": "org.geoserver.ows.KvpRequestReader.createRequest",
	"Comment": "creats a new instance of the request object.subclasses may with to override this method. the default implementation attempts toreflectivley create an instance of the request bean.",
	"Method": "Object createRequest(){\r\n    return getRequestBean().newInstance();\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.runTest",
	"Comment": "override runtest so that the test will be skipped if the testdata is not available",
	"Method": "void runTest(){\r\n    if (getTestData().isTestDataAvailable()) {\r\n        super.runTest();\r\n    } else {\r\n        LOGGER.warning(\"Skipping \" + getClass() + \".\" + getName() + \" since test data is not available\");\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.opensearch.rest.AbstractOpenSearchController.simpleToComplex",
	"Comment": "converts the simple feature representatin of a collection into a complex feature suitable foropensearchaccess usage",
	"Method": "Feature simpleToComplex(SimpleFeature feature,FeatureType targetSch,Collection<String> ignoredAttributes){\r\n    ComplexFeatureBuilder builder = new ComplexFeatureBuilder(targetSch);\r\n    AttributeBuilder ab = new AttributeBuilder(FEATURE_FACTORY);\r\n    for (AttributeDescriptor ad : feature.getType().getAttributeDescriptors()) {\r\n        String sourceName = ad.getLocalName();\r\n        if (ignoredAttributes.contains(sourceName)) {\r\n            continue;\r\n        }\r\n        Name pname = toName(sourceName, targetSch.getName().getNamespaceURI());\r\n        PropertyDescriptor pd = targetSch.getDescriptor(pname);\r\n        if (pd == null) {\r\n            throw new RestException(\"Unexpected attribute found: '\" + sourceName + \"'\", HttpStatus.BAD_REQUEST);\r\n        }\r\n        ab.setDescriptor((AttributeDescriptor) pd);\r\n        Object originalValue = feature.getAttribute(sourceName);\r\n        Object converted = convert(originalValue, pd.getType().getBinding());\r\n        Attribute attribute = ab.buildSimple(null, converted);\r\n        builder.append(pd.getName(), attribute);\r\n    }\r\n    Feature collectionFeature = builder.buildFeature(feature.getID());\r\n    return collectionFeature;\r\n}"
}, {
	"Path": "org.geoserver.wps.ppio.LiteralPPIO.encode",
	"Comment": "encodes the internal object representation of a parameter as a string.",
	"Method": "String encode(Object value){\r\n    return Converters.convert(value, String.class);\r\n}"
}, {
	"Path": "org.geoserver.rest.wrapper.RestWrapperAdapter.getTemplate",
	"Comment": "default implementation. subclasses should override this to implement custom functionality",
	"Method": "Template getTemplate(){\r\n    return template;\r\n}"
}, {
	"Path": "org.geoserver.wfs.WFSTestSupport.setMeasuresEncoding",
	"Comment": "helper method that activates or deactivates geometries measures encoding for the feature typematching the provided name.",
	"Method": "void setMeasuresEncoding(Catalog catalog,String featureTypeName,boolean encodeMeasures){\r\n    FeatureTypeInfo featureTypeInfo = catalog.getFeatureTypeByName(featureTypeName);\r\n    if (featureTypeInfo == null) {\r\n        throw new RuntimeException(String.format(\"No feature type matching the provided name '%s' found.\", featureTypeName));\r\n    }\r\n    featureTypeInfo.setEncodeMeasures(encodeMeasures);\r\n    catalog.save(featureTypeInfo);\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.dxf.AbstractDXFWriter.getLayerName",
	"Comment": "gets a name for the layer represented by the given collection.",
	"Method": "String getLayerName(FeatureCollection coll){\r\n    String name = getCachedName(coll.hashCode() + \"\");\r\n    if (name == null) {\r\n        name = layerNames[layerCounter];\r\n        if (name.equals(\"\"))\r\n            name = \"LAYER\" + layerCounter;\r\n        layerCounter++;\r\n        storeCachedName(coll.hashCode() + \"\", name);\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findStyleSldFile",
	"Comment": "returns the sld file for the specified style, if the file does not exist null is returned.",
	"Method": "File findStyleSldFile(StyleInfo s){\r\n    Resource resource = style(s);\r\n    return Resources.file(resource);\r\n}"
}, {
	"Path": "org.geoserver.config.util.LegacyServiceLoader.setReader",
	"Comment": "sets the legacy services.xml reader.this method is called by the geoserver startup, it should not be called by client code.",
	"Method": "void setReader(LegacyServicesReader reader){\r\n    this.reader = reader;\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.OgrConfiguration.getEnvironment",
	"Comment": "ensures compatibility with old style configuration files.",
	"Method": "Map<String, String> getEnvironment(){\r\n    if (gdalData != null) {\r\n        return java.util.Collections.singletonMap(\"GDAL_DATA\", gdalData);\r\n    } else {\r\n        return environment;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.script.rest.converter.ScriptConverter.hrefNoExt",
	"Comment": "the default href method adds an extension onto the link which for the scripts module is notwanted this method is called in place of the default href method.",
	"Method": "String hrefNoExt(String link){\r\n    final RequestInfo pg = RequestInfo.get();\r\n    if (link.startsWith(\"/\")) {\r\n        return pg.servletURI(link);\r\n    } else {\r\n        return pg.pageURI(link);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.IsolatedWorkspacesTest.checkNamespace",
	"Comment": "helper method that checks that the provided namespace has the expected content.",
	"Method": "void checkNamespace(NamespaceInfo namespace,String expectedPrefix,String expectedNamespaceUri,boolean expectedIsolation){\r\n    assertThat(namespace, notNullValue());\r\n    assertThat(namespace.getPrefix(), is(expectedPrefix));\r\n    assertThat(namespace.getName(), is(expectedPrefix));\r\n    assertThat(namespace.getURI(), is(expectedNamespaceUri));\r\n    assertThat(namespace.isIsolated(), is(expectedIsolation));\r\n}"
}, {
	"Path": "org.geoserver.catalog.CoverageViewReader.checkIfDelegateReaderSupportsBands",
	"Comment": "helper method that checks if the delegate reader support bands selection.",
	"Method": "boolean checkIfDelegateReaderSupportsBands(){\r\n    List<GeneralParameterDescriptor> parameters = delegate.getFormat().getReadParameters().getDescriptor().descriptors();\r\n    for (GeneralParameterDescriptor parameterDescriptor : parameters) {\r\n        if (parameterDescriptor.getName().equals(AbstractGridFormat.BANDS.getName())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.put",
	"Comment": "executes a request with a default mimetype using the put method.",
	"Method": "InputStream put(String path,InputStream put,String path,String body,InputStream put,String path,String body,String contentType,InputStream put,String path,byte[] body,String contentType){\r\n    MockHttpServletResponse response = putAsServletResponse(path, body, contentType);\r\n    return new ByteArrayInputStream(response.getContentAsString().getBytes());\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.MultiDimensionalExtension.encodeLayerDimension",
	"Comment": "helper method that will encode a dimension, if the dimension is null nothing will be done.all optional attributes that are null will be ignored.",
	"Method": "void encodeLayerDimension(XMLBuilder xml,Dimension dimension){\r\n    xml.indentElement(\"Dimension\");\r\n    xml.simpleElement(\"ows:Identifier\", dimension.getDimensionName(), true);\r\n    xml.simpleElement(\"Default\", dimension.getDefaultValueAsString(), true);\r\n    int limit = DimensionsUtils.NO_LIMIT;\r\n    if (dimension.getDimensionInfo().getPresentation() != DimensionPresentation.LIST) {\r\n        limit = 0;\r\n    }\r\n    List<String> values = dimension.getDomainValuesAsStrings(Query.ALL, limit).second;\r\n    for (String value : values) {\r\n        xml.simpleElement(\"Value\", value, true);\r\n    }\r\n    xml.endElement(\"Dimension\");\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.getSecurityManager",
	"Comment": "accesssor for global security manager instance from the test application context.",
	"Method": "GeoServerSecurityManager getSecurityManager(){\r\n    return (GeoServerSecurityManager) applicationContext.getBean(\"geoServerSecurityManager\");\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.GeoServerInstance.addDefaultStyles",
	"Comment": "helper method that adds geoserver default styles to a dt directory.",
	"Method": "void addDefaultStyles(File dataDirectory){\r\n    File stylesDirectory = new File(dataDirectory, \"styles\");\r\n    GeoServerResourceLoader loader = new GeoServerResourceLoader(dataDirectory);\r\n    Catalog catalog = new CatalogImpl();\r\n    catalog.setResourceLoader(loader);\r\n    XStreamPersister xstreamPersister = new XStreamPersisterFactory().createXMLPersister();\r\n    GeoServerConfigPersister geoserverPersister = new GeoServerConfigPersister(loader, xstreamPersister);\r\n    catalog.addListener(geoserverPersister);\r\n    catalog.addListener(new GeoServerResourcePersister(loader));\r\n    createDefaultStyle(catalog, stylesDirectory, \"point\", \"default_point.sld\");\r\n    createDefaultStyle(catalog, stylesDirectory, \"line\", \"default_line.sld\");\r\n    createDefaultStyle(catalog, stylesDirectory, \"polygon\", \"default_polygon.sld\");\r\n    createDefaultStyle(catalog, stylesDirectory, \"raster\", \"default_raster.sld\");\r\n    createDefaultStyle(catalog, stylesDirectory, \"generic\", \"default_generic.sld\");\r\n}"
}, {
	"Path": "org.geoserver.rest.security.AbstractAclController.validateRule",
	"Comment": "validate a rule, return an error message or null if the rule is ok",
	"Method": "String validateRule(String ruleKey,String ruleValue){\r\n    return validateRuleKey(ruleKey);\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.GetCoverage.setupCoverage",
	"Comment": "setup a coverage on top of the specified gridcoveragerequest",
	"Method": "GridCoverage2D setupCoverage(WCSDimensionsSubsetHelper helper,GridCoverageRequest gridCoverageRequest,GetCoverageType coverageType,GridCoverage2DReader reader,Hints hints,Map<String, ExtensionItemType> extensions,List<DimensionBean> coverageDimensions,ImageSizeRecorder incrementalOutputSize,ImageSizeRecorder incrementalInputSize,GridCoverageFactory coverageFactory){\r\n    List<GridCoverage2D> coverages = null;\r\n    double[] preAppliedScale = new double[] { Double.NaN, Double.NaN };\r\n    ScalingType scaling = extractScaling(extensions);\r\n    coverages = readCoverage(helper, gridCoverageRequest, reader, hints, incrementalInputSize, scaling, preAppliedScale);\r\n    GridSampleDimension[] sampleDimensions = collectDimensions(coverages);\r\n    if (coverages == null || coverages.isEmpty()) {\r\n        throwFailedReadException(coverageType.getCoverageId(), reader, helper.getGridCoverageRequest(), helper.getCoverageInfo());\r\n    }\r\n    for (int i = 0; i < coverages.size(); i++) {\r\n        GridCoverage2D rangeSubsetted = handleRangeSubsettingExtension(coverages.get(i), extensions, hints);\r\n        coverages.set(i, rangeSubsetted);\r\n    }\r\n    List<GridCoverage2D> temp = new ArrayList();\r\n    for (int i = 0; i < coverages.size(); i++) {\r\n        List<GridCoverage2D> subsetted = handleSubsettingExtension(coverages.get(i), gridCoverageRequest.getSpatialSubset(), hints);\r\n        temp.addAll(subsetted);\r\n    }\r\n    coverages = temp;\r\n    for (int i = 0; i < coverages.size(); i++) {\r\n        GridCoverage2D scaled = handleScaling(coverages.get(i), scaling, gridCoverageRequest.getSpatialInterpolation(), preAppliedScale, hints);\r\n        coverages.set(i, scaled);\r\n    }\r\n    for (int i = 0; i < coverages.size(); i++) {\r\n        GridCoverage2D reprojected = handleReprojection(coverages.get(i), gridCoverageRequest.getOutputCRS(), gridCoverageRequest.getSpatialInterpolation(), hints);\r\n        coverages.set(i, reprojected);\r\n    }\r\n    GridCoverage2D coverage = mosaicCoverages(coverages, hints);\r\n    final boolean enforceLatLonAxesOrder = requestingLatLonAxesOrder(gridCoverageRequest.getOutputCRS());\r\n    if (wcs.isLatLon() && enforceLatLonAxesOrder) {\r\n        coverage = enforceLatLongOrder(coverage, hints, gridCoverageRequest.getOutputCRS());\r\n    }\r\n    if (incrementalOutputSize == null) {\r\n        WCSUtils.checkOutputLimits(wcs, coverage.getGridGeometry().getGridRange2D(), coverage.getRenderedImage().getSampleModel());\r\n    } else {\r\n        incrementalOutputSize.addSize(coverage);\r\n    }\r\n    if (reader instanceof StructuredGridCoverage2DReader && coverageDimensions != null) {\r\n        Map map = coverage.getProperties();\r\n        if (map == null) {\r\n            map = new HashMap();\r\n        }\r\n        for (DimensionBean coverageDimension : coverageDimensions) {\r\n            helper.setCoverageDimensionProperty(map, gridCoverageRequest, coverageDimension);\r\n        }\r\n        coverage = coverageFactory.create(coverage.getName(), coverage.getRenderedImage(), coverage.getEnvelope(), coverage.getSampleDimensions(), null, map);\r\n    }\r\n    if (sampleDimensions != null && sampleDimensions.length > 0) {\r\n        coverage = GridCoverageWrapper.wrapCoverage(coverage, coverage, sampleDimensions, null, true);\r\n    }\r\n    return coverage;\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.GeoTiffWriterHelper.getGeotoolsWriteParams",
	"Comment": "returns the geotools grid writer params, allowing their customization",
	"Method": "ParameterValueGroup getGeotoolsWriteParams(){\r\n    return geotoolsWriteParams;\r\n}"
}, {
	"Path": "org.vfny.geoserver.global.xml.NameSpaceTranslator.getPrefix",
	"Comment": "getprefix purpose.returns the prefix that this namespace represents.",
	"Method": "String getPrefix(){\r\n    return prefix;\r\n}"
}, {
	"Path": "org.geoserver.inspire.wfs.WFSExtendedCapabilitiesTest.testExtCaps100WithFullSettings",
	"Comment": "no inspire extendedcapabilities should be returned in a wfs 1.0.0 response",
	"Method": "void testExtCaps100WithFullSettings(){\r\n    final ServiceInfo serviceInfo = getGeoServer().getService(WFSInfo.class);\r\n    final MetadataMap metadata = serviceInfo.getMetadata();\r\n    clearInspireMetadata(metadata);\r\n    metadata.put(CREATE_EXTENDED_CAPABILITIES.key, true);\r\n    metadata.put(SERVICE_METADATA_URL.key, \"http://foo.com?bar=baz\");\r\n    metadata.put(SERVICE_METADATA_TYPE.key, \"application/vnd.iso.19139+xml\");\r\n    metadata.put(LANGUAGE.key, \"fre\");\r\n    metadata.put(SPATIAL_DATASET_IDENTIFIER_TYPE.key, \"one,http://www.geoserver.org/one;two,http://www.geoserver.org/two,http://metadata.geoserver.org/id?two\");\r\n    getGeoServer().save(serviceInfo);\r\n    final Document dom = getAsDOM(WFS_1_0_0_GETCAPREQUEST);\r\n    final NodeList nodeList = dom.getElementsByTagNameNS(DLS_NAMESPACE, \"ExtendedCapabilities\");\r\n    assertTrue(nodeList.getLength() == 0);\r\n}"
}, {
	"Path": "org.geoserver.kml.GeoSearchKMLTest.testStrategyChangesStuff",
	"Comment": "test whether specifying different regionating strategies changes the results.",
	"Method": "void testStrategyChangesStuff(){\r\n    final String path = \"wms?request=getmap&service=wms&version=1.1.1\" + \"&format=\" + KMLMapOutputFormat.MIME_TYPE + \"&layers=\" + TILE_TESTS.getPrefix() + \":\" + TILE_TESTS.getLocalPart() + \"&bbox=-180,-90,0,90&styles=\" + \"&height=1024&width=1024&srs=EPSG:4326\";\r\n    FeatureTypeInfo fti = getFeatureTypeInfo(TILE_TESTS);\r\n    fti.getMetadata().put(\"kml.regionateFeatureLimit\", 2);\r\n    getCatalog().save(fti);\r\n    Document geo = getAsDOM(path + \"&format_options=regionateBy:geometry;regionateattr:location\");\r\n    assertEquals(\"kml\", geo.getDocumentElement().getTagName());\r\n    NodeList geoPlacemarks = geo.getDocumentElement().getElementsByTagName(\"Placemark\");\r\n    assertEquals(2, geoPlacemarks.getLength());\r\n    Document data = getAsDOM(path + \"&format_options=regionateBy:external-sorting;regionateAttr:z\");\r\n    assertEquals(\"kml\", data.getDocumentElement().getTagName());\r\n    NodeList dataPlacemarks = data.getDocumentElement().getElementsByTagName(\"Placemark\");\r\n    assertEquals(2, dataPlacemarks.getLength());\r\n    for (int i = 0; i < geoPlacemarks.getLength(); i++) {\r\n        String geoName = ((Element) geoPlacemarks.item(i)).getAttribute(\"id\");\r\n        String dataName = ((Element) dataPlacemarks.item(i)).getAttribute(\"id\");\r\n        assertTrue(geoName + \" and \" + dataName + \" should not be the same!\", !geoName.equals(dataName));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.ows.util.UCSReader.getEncoding",
	"Comment": "returns the encoding currently in use by this character stream.",
	"Method": "String getEncoding(){\r\n    if (4 > fEncoding) {\r\n        return \"ISO-10646-UCS-2\";\r\n    } else {\r\n        return \"ISO-10646-UCS-4\";\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.inspire.wms.WMSExtendedCapabilitiesTest.testExtCaps111WithFullSettings",
	"Comment": "there is an inspire dtd for wms 1.1.1 but not implementing this",
	"Method": "void testExtCaps111WithFullSettings(){\r\n    final ServiceInfo serviceInfo = getGeoServer().getService(WMSInfo.class);\r\n    final MetadataMap metadata = serviceInfo.getMetadata();\r\n    clearInspireMetadata(metadata);\r\n    metadata.put(CREATE_EXTENDED_CAPABILITIES.key, true);\r\n    metadata.put(SERVICE_METADATA_URL.key, \"http://foo.com?bar=baz\");\r\n    metadata.put(SERVICE_METADATA_TYPE.key, \"application/vnd.iso.19139+xml\");\r\n    metadata.put(LANGUAGE.key, \"fre\");\r\n    getGeoServer().save(serviceInfo);\r\n    final Document dom = getAsDOM(WMS_1_1_1_GETCAPREQUEST);\r\n    final NodeList nodeList = dom.getElementsByTagNameNS(VS_NAMESPACE, \"ExtendedCapabilities\");\r\n    assertEquals(\"Number of INSPIRE ExtendedCapabilities elements\", 0, nodeList.getLength());\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.ImportProcessTest.testCreateCoverageStore",
	"Comment": "test creating a coverage store when a store name is specified but does not exist",
	"Method": "void testCreateCoverageStore(){\r\n    String storeName = SystemTestData.CITE_PREFIX + \"raster\";\r\n    GridCoverage2D sampleCoverage = Coverage2RenderedImageAdapterTest.createTestCoverage(500, 500, 0, 0, 10, 10);\r\n    CoverageStoreInfo storeInfo = catalog.getCoverageStoreByName(storeName);\r\n    assertNull(\"Store already exists \" + storeInfo, storeInfo);\r\n    ImportProcess importer = new ImportProcess(getCatalog());\r\n    String result = importer.execute(null, sampleCoverage, SystemTestData.CITE_PREFIX, storeName, \"Buildings4\", CRS.decode(\"EPSG:4326\"), null, null, null);\r\n    assertEquals(result, SystemTestData.CITE_PREFIX + \":\" + \"Buildings4\");\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.assertStatusCodeForRequest",
	"Comment": "assert that an http request will have a particular status code for the response.",
	"Method": "void assertStatusCodeForRequest(int code,String method,String path,String body,String type){\r\n    MockHttpServletRequest request = createRequest(path);\r\n    request.setMethod(method);\r\n    request.setContent(body.getBytes(\"UTF-8\"));\r\n    request.setContentType(type);\r\n    CodeExpectingHttpServletResponse response = new CodeExpectingHttpServletResponse(new MockHttpServletResponse());\r\n    dispatch(request, response);\r\n    assertEquals(code, response.getErrorCode());\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.getLinkedFeatures",
	"Comment": "extracts from the provided properties any chained features resolved as links.",
	"Method": "List<Map<NameImpl, String>> getLinkedFeatures(List<Property> properties){\r\n    List<Map<NameImpl, String>> linkedFeatures = new ArrayList();\r\n    for (Property property : properties) {\r\n        Map<NameImpl, String> attributes = (Map<NameImpl, String>) property.getUserData().get(org.xml.sax.Attributes.class);\r\n        if (checkIfFeatureIsLinked(property, attributes)) {\r\n            linkedFeatures.add(attributes);\r\n        }\r\n    }\r\n    return linkedFeatures;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findStyleDir",
	"Comment": "returns the directory in which global styles are persisted, if the directory does not existnull is returned.",
	"Method": "File findStyleDir(){\r\n    Resource styles = get(STYLE_DIR);\r\n    return Resources.directory(styles);\r\n}"
}, {
	"Path": "org.geoserver.util.LoggerRule.setTestLevel",
	"Comment": "set the level of the logger. will be reverted when the test is complete.",
	"Method": "void setTestLevel(Level testLevel){\r\n    log.setLevel(testLevel);\r\n    newLevel = testLevel;\r\n    super.setLevel(testLevel);\r\n}"
}, {
	"Path": "org.geoserver.security.oauth2.GeoServerAccessTokenConverter.setUserTokenConverter",
	"Comment": "converter for the part of the data in the token representing a user.",
	"Method": "void setUserTokenConverter(UserAuthenticationConverter userTokenConverter){\r\n    this.userTokenConverter = userTokenConverter;\r\n    super.setUserTokenConverter(userTokenConverter);\r\n}"
}, {
	"Path": "org.geoserver.security.impl.AbstractAccessRuleDAO.checkPropertyFile",
	"Comment": "checks the property file is up to date, eventually rebuilds the tree",
	"Method": "void checkPropertyFile(boolean force){\r\n    try {\r\n        if (rules == null || force) {\r\n            if (securityDir == null || securityDir.getType() == Type.UNDEFINED) {\r\n                this.rules = new TreeSet<R>();\r\n            } else {\r\n                Resource layers = securityDir.get(propertyFileName);\r\n                if (layers.getType() == Type.UNDEFINED) {\r\n                    InputStream in = getClass().getResourceAsStream(propertyFileName + \".template\");\r\n                    if (in != null) {\r\n                        IOUtils.copy(in, layers.out());\r\n                    }\r\n                }\r\n                if (layers.getType() == Type.UNDEFINED) {\r\n                    this.rules = new TreeSet<R>();\r\n                } else {\r\n                    watcher = new PropertyFileWatcher(layers);\r\n                    loadRules(watcher.getProperties());\r\n                }\r\n            }\r\n            lastModified = System.currentTimeMillis();\r\n        } else if (isModified()) {\r\n            loadRules(watcher.getProperties());\r\n            lastModified = System.currentTimeMillis();\r\n        }\r\n    } catch (Exception e) {\r\n        LOGGER.log(Level.SEVERE, \"Failed to reload data access rules from layers.properties, keeping old rules\", e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.xml.v1_0_0.WFS.buildSchema",
	"Comment": "suplements the schema built by the parent by adding hte aplication schema feature typsdefined in geoserver.",
	"Method": "XSDSchema buildSchema(){\r\n    XSDSchema wfsSchema = super.buildSchema();\r\n    wfsSchema = schemaBuilder.addApplicationTypes(wfsSchema);\r\n    return wfsSchema;\r\n}"
}, {
	"Path": "org.geoserver.gwc.config.GWCConfig.setInnerCachingEnabled",
	"Comment": "this method sets a flag indicating if gwc tiles must be cached in memory",
	"Method": "void setInnerCachingEnabled(boolean innerCachingEnabled){\r\n    this.innerCachingEnabled = innerCachingEnabled;\r\n}"
}, {
	"Path": "org.geoserver.wms.ncwms.GetMapNcWmsCallback.mapParameter",
	"Comment": "maps a parameter needing at most a simple type conversion from the kvp map to the envfunction",
	"Method": "void mapParameter(Map kvp,Map rawKvp,String ncWmsParameter,String paletteParameter,Class targetClass){\r\n    if (kvp.containsKey(ncWmsParameter)) {\r\n        String str = (String) rawKvp.get(ncWmsParameter);\r\n        Object value = Converters.convert(str, targetClass);\r\n        if (value == null && str != null && !str.trim().isEmpty()) {\r\n            throw new ServiceException(\"Expected a value of type \" + targetClass.getSimpleName() + \" for \" + ncWmsParameter + \" but found '\" + str + \"' instead\", ServiceException.INVALID_PARAMETER_VALUE, ncWmsParameter);\r\n        }\r\n        EnvFunction.setLocalValue(paletteParameter, value);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.util.ReaderUtils.getChildText",
	"Comment": "getchildtext purpose.used to help with xml manipulations. returns the first child text value of the specifiedelement name. an exception occurs when the node is required and not found.",
	"Method": "String getChildText(Element root,String childName,String getChildText,Element root,String childName,boolean mandatory){\r\n    Element elem = getChildElement(root, childName, mandatory);\r\n    if (elem != null) {\r\n        return getElementText(elem, mandatory);\r\n    } else {\r\n        if (mandatory) {\r\n            String msg = \"Mandatory child \" + childName + \"not found in \" + \" element: \" + root;\r\n            throw new Exception(msg);\r\n        }\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.isMemoryCleanRequired",
	"Comment": "subclasses may override this method to force memory cleaning before the test data dir iscleaned up. this is necessary on windows if coverages are used in the test, since readersmight still be around in the heap as garbage without having been disposed of",
	"Method": "boolean isMemoryCleanRequired(){\r\n    return false;\r\n}"
}, {
	"Path": "org.vfny.geoserver.util.WCSUtils.getCoverageSize",
	"Comment": "computes the size of a grid coverage in bytes given its grid envelope and the target samplemodel",
	"Method": "long getCoverageSize(GridEnvelope2D envelope,SampleModel sm){\r\n    final long pixelsNumber = computePixelsNumber(envelope);\r\n    long pixelSize = 0;\r\n    final int numBands = sm.getNumBands();\r\n    for (int i = 0; i < numBands; i++) {\r\n        pixelSize += sm.getSampleSize(i);\r\n    }\r\n    return pixelsNumber * pixelSize / 8;\r\n}"
}, {
	"Path": "org.geoserver.security.impl.Util.convertToBoolean",
	"Comment": "convert from string to boolean, use defaultvalue in case of null or empty string",
	"Method": "boolean convertToBoolean(String booleanString,boolean defaultValue){\r\n    if (booleanString == null || booleanString.trim().length() == 0)\r\n        return defaultValue;\r\n    return Boolean.valueOf(booleanString.trim());\r\n}"
}, {
	"Path": "org.geoserver.test.BBoxFilterTest.testQueryBboxLatLongSrs4283",
	"Comment": "the following performs a wfs request specifying a bbox parameter of axis ordering longitudelatitude along with srs reprojection.",
	"Method": "void testQueryBboxLatLongSrs4283(){\r\n    Document doc = getAsDOM(WFS_GET_FEATURE + LATLONG + \"&srsName=urn:x-ogc:def:crs:EPSG:4283\");\r\n    LOGGER.info(WFS_GET_FEATURE_LOG + LONGLAT + prettyString(doc));\r\n    CoordinateReferenceSystem sourceCRS = (CoordinateReferenceSystem) CRS.decode(EPSG_4326);\r\n    CoordinateReferenceSystem targetCRS = (CoordinateReferenceSystem) CRS.decode(EPSG_4283);\r\n    MathTransform transform = CRS.findMathTransform(sourceCRS, targetCRS);\r\n    GeometryFactory factory = new GeometryFactory();\r\n    Point targetPoint = (Point) JTS.transform(factory.createPoint(new Coordinate(132.61, -26.98)), transform);\r\n    CoordinateFormatter format = new CoordinateFormatter(8);\r\n    String targetPointCoord1 = format.format(targetPoint.getCoordinate().x) + \" \" + format.format(targetPoint.getCoordinate().y);\r\n    targetPoint = (Point) JTS.transform(factory.createPoint(new Coordinate(132.71, -26.46)), transform);\r\n    String targetPointCoord2 = format.format(targetPoint.getCoordinate().x) + \" \" + format.format(targetPoint.getCoordinate().y);\r\n    assertXpathEvaluatesTo(\"urn:x-ogc:def:crs:EPSG:4283\", \"//ex:geomContainer[@gml:id='1']/ex:geom/gml:Point/@srsName\", doc);\r\n    assertXpathEvaluatesTo(\"2\", \"//ex:geomContainer[@gml:id='1']/ex:geom/gml:Point/@srsDimension\", doc);\r\n    assertXpathEvaluatesTo(targetPointCoord1, \"//ex:geomContainer[@gml:id='1']/ex:geom/gml:Point/gml:pos\", doc);\r\n    assertXpathEvaluatesTo(\"urn:x-ogc:def:crs:EPSG:4283\", \"//ex:geomContainer[@gml:id='1']/ex:nestedFeature/ex:nestedGeom[@gml:id='nested.1']/ex:geom/gml:Point/@srsName\", doc);\r\n    assertXpathEvaluatesTo(\"2\", \"//ex:geomContainer[@gml:id='1']/ex:nestedFeature/ex:nestedGeom[@gml:id='nested.1']/ex:geom/gml:Point/@srsDimension\", doc);\r\n    assertXpathEvaluatesTo(targetPointCoord1, \"//ex:geomContainer[@gml:id='1']/ex:nestedFeature/ex:nestedGeom[@gml:id='nested.1']/ex:geom/gml:Point/gml:pos\", doc);\r\n    assertXpathEvaluatesTo(\"urn:x-ogc:def:crs:EPSG:4283\", \"//ex:geomContainer[@gml:id='2']/ex:geom/gml:Point/@srsName\", doc);\r\n    assertXpathEvaluatesTo(\"2\", \"//ex:geomContainer[@gml:id='2']/ex:geom/gml:Point/@srsDimension\", doc);\r\n    assertXpathEvaluatesTo(targetPointCoord2, \"//ex:geomContainer[@gml:id='2']/ex:geom/gml:Point/gml:pos\", doc);\r\n    assertXpathEvaluatesTo(\"urn:x-ogc:def:crs:EPSG:4283\", \"//ex:geomContainer[@gml:id='2']/ex:nestedFeature/ex:nestedGeom[@gml:id='nested.2']/ex:geom/gml:Point/@srsName\", doc);\r\n    assertXpathEvaluatesTo(\"2\", \"//ex:geomContainer[@gml:id='2']/ex:nestedFeature/ex:nestedGeom[@gml:id='nested.2']/ex:geom/gml:Point/@srsDimension\", doc);\r\n    assertXpathEvaluatesTo(targetPointCoord2, \"//ex:geomContainer[@gml:id='2']/ex:nestedFeature/ex:nestedGeom[@gml:id='nested.2']/ex:geom/gml:Point/gml:pos\", doc);\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerBasePage.filterByAuth",
	"Comment": "filters a set of component descriptors based on the current authenticated user.",
	"Method": "List<T> filterByAuth(List<T> list){\r\n    Authentication user = getSession().getAuthentication();\r\n    List<T> result = new ArrayList<T>();\r\n    for (T component : list) {\r\n        if (component.getAuthorizer() == null) {\r\n            continue;\r\n        }\r\n        final Class<?> clazz = component.getComponentClass();\r\n        if (!component.getAuthorizer().isAccessAllowed(clazz, user))\r\n            continue;\r\n        result.add(component);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.inspire.ViewServicesTestSupport.testNoMetadataUrl",
	"Comment": "test extendedcapabilities is not produced if required settings missing",
	"Method": "void testNoMetadataUrl(){\r\n    final ServiceInfo serviceInfo = getServiceInfo();\r\n    final MetadataMap metadata = serviceInfo.getMetadata();\r\n    clearInspireMetadata(metadata);\r\n    metadata.put(CREATE_EXTENDED_CAPABILITIES.key, true);\r\n    metadata.put(SERVICE_METADATA_TYPE.key, getMetadataType());\r\n    metadata.put(LANGUAGE.key, getLanguage());\r\n    getGeoServer().save(serviceInfo);\r\n    final Document dom = getAsDOM(getGetCapabilitiesRequestPath());\r\n    final NodeList nodeList = dom.getElementsByTagNameNS(getInspireNameSpace(), \"ExtendedCapabilities\");\r\n    assertEquals(\"Number of INSPIRE ExtendedCapabilities elements\", 0, nodeList.getLength());\r\n}"
}, {
	"Path": "org.geoserver.ows.util.ResponseUtils.getQueryString",
	"Comment": "returns the query string part of a request url.if the url does not have a query string compopnent, the empty string is returned.",
	"Method": "String getQueryString(String url){\r\n    int index = url.indexOf('?');\r\n    if (index == -1 || index == url.length() - 1) {\r\n        return \"\";\r\n    }\r\n    return url.substring(index + 1);\r\n}"
}, {
	"Path": "org.geoserver.catalog.StyleHandler.versionForMimeType",
	"Comment": "returns the format version for the specified mime type.this method should only be overriden by formats that support multiple versions. thedefault implementation just returns 1.0.0.",
	"Method": "Version versionForMimeType(String mimeType){\r\n    return new Version(\"1.0.0\");\r\n}"
}, {
	"Path": "org.geoserver.wfs.v2_0.SrsNameRequestTest.testUrn",
	"Comment": "test response numberreturned, feature identity, srsname, and axis order for a request with anogc urn srsname.",
	"Method": "void testUrn(){\r\n    runTest(URN_SRSNAME, null, 5, URN_SRSNAME, LAT_LON_DATA);\r\n}"
}, {
	"Path": "org.geoserver.ows.util.RewindableInputStream.rewind",
	"Comment": "quickly reset stream pointer to the beginning of the stream or to position which offset wasspecified during the last setstartoffset call.",
	"Method": "void rewind(){\r\n    fOffset = fStartOffset;\r\n}"
}, {
	"Path": "org.geoserver.csw.store.internal.GetRecordsTest.testSpatialFilterNonGeomProperty",
	"Comment": "from cite compliance, throw an error if a non spatial property is used in a spatial filter",
	"Method": "void testSpatialFilterNonGeomProperty(){\r\n    String request = \"csw?service=CSW&version=2.0.2&request=GetRecords&typeNames=csw:Record&resultType=results\" + \"&elementName=dc:identifier,ows:BoundingBox&constraint=BBOX(dct:spatial, -250, -250, -190, -100)\";\r\n    Document d = getAsDOM(request);\r\n    checkOws10Exception(d);\r\n}"
}, {
	"Path": "org.geoserver.feature.FeatureSourceUtils.getBoundingBoxEnvelope",
	"Comment": "retreives the bounds for a feature source.if the feautre source can calculate the bounds directly, those bounds are returned.otherwise, the underlying feature collection is retreived and asked to calculate bounds. ifthat fails, an empty envelope is returned.",
	"Method": "ReferencedEnvelope getBoundingBoxEnvelope(FeatureSource<? extends FeatureType, ? extends Feature> fs){\r\n    ReferencedEnvelope ev = fs.getBounds();\r\n    if ((ev == null) || ev.isNull()) {\r\n        try {\r\n            ev = fs.getFeatures().getBounds();\r\n        } catch (Throwable t) {\r\n            LOGGER.log(Level.FINE, \"Could not compute the data bounding box. Returning an empty envelope\", t);\r\n            ev = new ReferencedEnvelope(fs.getSchema().getCoordinateReferenceSystem());\r\n        }\r\n    }\r\n    return ev;\r\n}"
}, {
	"Path": "org.geoserver.gwc.layer.LegacyTileLayerInfoLoader.save",
	"Comment": "saves a tile layer info into the given metadata map using the old legacy metadata elements.for unit testing only.",
	"Method": "void save(GeoServerTileLayerInfo source,MetadataMap metadata){\r\n    final boolean enabled = source.isEnabled();\r\n    final int gutter = source.getGutter();\r\n    final Set<XMLGridSubset> cachedGridSubsets = source.getGridSubsets();\r\n    final int metaTilingX = source.getMetaTilingX();\r\n    final int metaTilingY = source.getMetaTilingY();\r\n    final Set<String> mimeFormats = source.getMimeFormats();\r\n    final Boolean autoCacheStyles = source.isAutoCacheStyles();\r\n    final Set<String> cachedStyles = source.cachedStyles();\r\n    final boolean inMemoryCached = source.isInMemoryCached();\r\n    metadata.put(CONFIG_KEY_ENABLED, Boolean.valueOf(enabled));\r\n    metadata.put(CONFIG_KEY_GUTTER, Integer.valueOf(gutter));\r\n    Collection<String> subsetNames = new ArrayList<String>();\r\n    for (XMLGridSubset s : cachedGridSubsets) {\r\n        subsetNames.add(s.getGridSetName());\r\n    }\r\n    metadata.put(CONFIG_KEY_GRIDSETS, marshalList(subsetNames));\r\n    metadata.put(CONFIG_KEY_METATILING_X, Integer.valueOf(metaTilingX));\r\n    metadata.put(CONFIG_KEY_METATILING_Y, Integer.valueOf(metaTilingY));\r\n    metadata.put(CONFIG_KEY_FORMATS, marshalList(mimeFormats));\r\n    metadata.put(CONFIG_KEY_AUTO_CACHE_STYLES, autoCacheStyles);\r\n    metadata.put(CONFIG_KEY_IN_MEMORY_CACHED, inMemoryCached);\r\n    if (cachedStyles.size() > 0) {\r\n        metadata.put(CONFIG_KEY_CACHED_STYLES, marshalList(cachedStyles));\r\n    } else {\r\n        metadata.remove(CONFIG_KEY_CACHED_STYLES);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.HistogramUtils.computeBuckets",
	"Comment": "compute the buckets for the given domain values and resolution.",
	"Method": "Tuple<String, List<Range>> computeBuckets(List<Object> domainValues,String resolution){\r\n    switch(findHistogramType(domainValues)) {\r\n        case NUMERIC:\r\n            return getNumericBuckets(domainValues, resolution);\r\n        case TIME:\r\n            return getTimeBuckets(domainValues, resolution);\r\n        default:\r\n            return getEnumeratedBuckets(domainValues);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.WCSNetCDFTest.testNetcdfRotatedPole",
	"Comment": "test netcdf output from a netcdf file with a rotated pole projection.",
	"Method": "void testNetcdfRotatedPole(){\r\n    MockHttpServletResponse response = getAsServletResponse(\"ows?request=GetCoverage&service=WCS&version=2.0.1\" + \"&coverageid=wcs__Temperature_surface_NetCDF&format=application/x-netcdf\");\r\n    assertEquals(200, response.getStatus());\r\n    assertEquals(\"application/x-netcdf\", response.getContentType());\r\n    byte[] responseBytes = getBinary(response);\r\n    File file = File.createTempFile(\"netcdf-rotated-pole-\", \"-wcs__Temperature_surface_NetCDF.nc\", new File(\"./target\"));\r\n    FileUtils.writeByteArrayToFile(file, responseBytes);\r\n    try (NetcdfDataset dataset = NetcdfDataset.openDataset(file.getAbsolutePath())) {\r\n        assertNotNull(dataset);\r\n        Dimension rlonDim = dataset.findDimension(\"rlon\");\r\n        assertNotNull(rlonDim);\r\n        assertEquals(7, rlonDim.getLength());\r\n        Dimension rlatDim = dataset.findDimension(\"rlat\");\r\n        assertNotNull(rlatDim);\r\n        assertEquals(5, rlatDim.getLength());\r\n        Variable rlonVar = dataset.findVariable(\"rlon\");\r\n        assertNotNull(rlonVar);\r\n        assertEquals(1, rlonVar.getDimensions().size());\r\n        assertEquals(rlonDim, rlonVar.getDimensions().get(0));\r\n        assertEquals(\"grid_longitude\", rlonVar.findAttribute(\"long_name\").getStringValue());\r\n        assertEquals(\"grid_longitude\", rlonVar.findAttribute(\"standard_name\").getStringValue());\r\n        assertEquals(\"degrees\", rlonVar.findAttribute(\"units\").getStringValue());\r\n        assertArrayEquals(new float[] { -30, -20, -10, 0, 10, 20, 30 }, (float[]) rlonVar.read().copyTo1DJavaArray(), (float) DELTA);\r\n        Variable rlatVar = dataset.findVariable(\"rlat\");\r\n        assertNotNull(rlatVar);\r\n        assertEquals(1, rlatVar.getDimensions().size());\r\n        assertEquals(rlatDim, rlatVar.getDimensions().get(0));\r\n        assertEquals(\"grid_latitude\", rlatVar.findAttribute(\"long_name\").getStringValue());\r\n        assertEquals(\"grid_latitude\", rlatVar.findAttribute(\"standard_name\").getStringValue());\r\n        assertEquals(\"degrees\", rlatVar.findAttribute(\"units\").getStringValue());\r\n        assertArrayEquals(new float[] { -20, -10, 0, 10, 20 }, (float[]) rlatVar.read().copyTo1DJavaArray(), (float) DELTA);\r\n        Variable projVar = dataset.findVariable(\"rotated_latitude_longitude\");\r\n        assertNotNull(projVar);\r\n        assertEquals(\"rotated_latitude_longitude\", projVar.findAttribute(\"grid_mapping_name\").getStringValue());\r\n        assertEquals(74.0, projVar.findAttribute(\"grid_north_pole_longitude\").getNumericValue().doubleValue(), DELTA);\r\n        assertEquals(36.0, projVar.findAttribute(\"grid_north_pole_latitude\").getNumericValue().doubleValue(), DELTA);\r\n        Variable tempVar = dataset.findVariable(\"Temperature_surface_NetCDF\");\r\n        assertNotNull(tempVar);\r\n        assertEquals(\"rotated_latitude_longitude\", tempVar.findAttribute(\"grid_mapping\").getStringValue());\r\n        assertEquals(\"K\", tempVar.findAttribute(\"units\").getStringValue());\r\n        assertEquals(2, tempVar.getDimensions().size());\r\n        assertEquals(rlatDim, tempVar.getDimensions().get(0));\r\n        assertEquals(rlonDim, tempVar.getDimensions().get(1));\r\n        assertArrayEquals(new float[] { 300, 299, 298, 297, 296, 295, 294, 299, 300, 299, 298, 297, 296, 295, 298, 299, 300, 299, 298, 297, 296, 297, 298, 299, 300, 299, 298, 297, 296, 297, 298, 299, 300, 299, 298 }, (float[]) tempVar.read().copyTo1DJavaArray(), (float) DELTA);\r\n    } finally {\r\n        FileUtils.deleteQuietly(file);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.data.layer.SQLViewAbstractPage.testViewDefinition",
	"Comment": "checks the view definition works as expected and returns the feature type guessed solely bylooking at the sql and the first row of its output",
	"Method": "SimpleFeatureType testViewDefinition(boolean guessGeometrySrid,SimpleFeatureType testViewDefinition,VirtualTable virtualTable,boolean guessGeometrySrid){\r\n    JDBCDataStore ds = (JDBCDataStore) getCatalog().getDataStore(storeId).getDataStore(null);\r\n    String vtName = null;\r\n    try {\r\n        do {\r\n            vtName = UUID.randomUUID().toString();\r\n        } while (Arrays.asList(ds.getTypeNames()).contains(vtName));\r\n        VirtualTable vt = new VirtualTable(vtName, virtualTable);\r\n        vt.setPrimaryKeyColumns(Collections.emptyList());\r\n        vt.setEscapeSql(escapeSql);\r\n        ds.createVirtualTable(vt);\r\n        return guessFeatureType(ds, vt.getName(), guessGeometrySrid);\r\n    } finally {\r\n        if (vtName != null) {\r\n            ds.dropVirtualTable(name);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.impl.GeoServerUserDao.checkUserMap",
	"Comment": "either loads the default property file on the first access, or reloads it if it has beenmodified since last access.",
	"Method": "void checkUserMap(){\r\n    try {\r\n        if ((userMap == null) || userDefinitionsFile == null || userDefinitionsFile.isStale()) {\r\n            if (userDefinitionsFile == null) {\r\n                Resource propFile = findUserProperties();\r\n                userDefinitionsFile = new PropertyFileWatcher(propFile);\r\n            }\r\n            userMap = loadUsersFromProperties(userDefinitionsFile.getProperties());\r\n        }\r\n    } catch (Exception e) {\r\n        LOGGER.log(Level.SEVERE, \"An error occurred loading user definitions\", e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.script.ScriptManager.createNewEngine",
	"Comment": "creates a new script engine for the specified file extension.",
	"Method": "ScriptEngine createNewEngine(Resource script,ScriptEngine createNewEngine,File script,ScriptEngine createNewEngine,String ext){\r\n    if (ext == null) {\r\n        return null;\r\n    }\r\n    return initEngine(engineMgr.getEngineByExtension(ext));\r\n}"
}, {
	"Path": "org.geoserver.test.WaterMLTimeSeriesWfsTest.testGetFeature",
	"Comment": "test get feature is fine with quantitylist as a list of simple type.",
	"Method": "void testGetFeature(){\r\n    String path = \"wfs?request=GetFeature&outputFormat=gml32&typename=wml2dr:MeasurementTimeseriesDomainRange\";\r\n    Document doc = getAsDOM(path);\r\n    LOGGER.info(\"WFS GetFeature, typename=wml2dr:MeasurementTimeseriesDomainRange response:\\n\" + prettyString(doc));\r\n    validateGet(path);\r\n    assertXpathCount(2, \"//wml2dr:MeasurementTimeseriesDomainRange\", doc);\r\n    String id = \"ID1\";\r\n    assertXpathEvaluatesTo(id, \"(//wml2dr:MeasurementTimeseriesDomainRange)[1]/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(\"tpl.\" + id, \"//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='\" + id + \"']/gml:domainSet/wml2dr:TimePositionList/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(\"1948-01-01T00:00:00Z 1948-02-01T00:00:00Z 1948-03-01T00:00:00Z 1948-04-01T00:00:00Z 1948-05-01T00:00:00Z \" + \"1948-06-01T00:00:00Z 1948-07-01T00:00:00Z 1948-08-01T00:00:00Z 1948-09-01T00:00:00Z 1948-10-01T00:00:00Z \" + \"1948-11-01T00:00:00Z 1948-12-01T00:00:00Z 1949-01-01T00:00:00Z 1949-02-01T00:00:00Z 1949-03-01T00:00:00Z \" + \"1949-04-01T00:00:00Z\", \"//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='\" + id + \"']/gml:domainSet/wml2dr:TimePositionList/wml2dr:timePositionList\", doc);\r\n    assertXpathEvaluatesTo(\"missing missing 8.9 7.9 14.2 15.4 18.1 19.1 21.7 20.8 19.6 14.9 10.8 8.8 8.5 10.4\", \"//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='\" + id + \"']/gml:rangeSet/gml:QuantityList\", doc);\r\n    assertXpathEvaluatesTo(\"degC\", \"//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='\" + id + \"']/gml:rangeSet/gml:QuantityList/@uom\", doc);\r\n    assertXpathEvaluatesTo(\"string\", \"//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='\" + id + \"']/gml:coverageFunction/gml:MappingRule\", doc);\r\n    assertXpathEvaluatesTo(\"http://ns.bgs.ac.uk/thesaurus/lithostratigraphy\", \"//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='\" + id + \"']/gmlcov:rangeType/@xlink:href\", doc);\r\n    id = \"ID2\";\r\n    assertXpathEvaluatesTo(id, \"(//wml2dr:MeasurementTimeseriesDomainRange)[2]/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(\"tpl.\" + id, \"//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='\" + id + \"']/gml:domainSet/wml2dr:TimePositionList/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(\"1949-05-01T00:00:00Z 1949-06-01T00:00:00Z 1949-07-01T00:00:00Z 1949-08-01T00:00:00Z 1949-09-01T00:00:00Z \" + \"1949-10-01T00:00:00Z 1949-11-01T00:00:00Z 1949-12-01T00:00:00Z 1950-01-01T00:00:00Z 1950-02-01T00:00:00Z \" + \"1950-03-01T00:00:00Z 1950-04-01T00:00:00Z 1950-05-01T00:00:00Z 1950-06-01T00:00:00Z 1950-07-01T00:00:00Z \" + \"1950-08-01T00:00:00Z 1950-09-01T00:00:00Z 1950-10-01T00:00:00Z 1950-11-01T00:00:00Z 1950-12-01T00:00:00Z\", \"//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='\" + id + \"']/gml:domainSet/wml2dr:TimePositionList/wml2dr:timePositionList\", doc);\r\n    assertXpathEvaluatesTo(\"16.2 17.1 22.0 25.1 23.9 22.8 17.0 10.2 9.2 7.1 12.3 12.9 17.2 23.6 21.6 21.9 17.6 14.0 9.3 3.8\", \"//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='\" + id + \"']/gml:rangeSet/gml:QuantityList\", doc);\r\n    assertXpathEvaluatesTo(\"degC\", \"//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='\" + id + \"']/gml:rangeSet/gml:QuantityList/@uom\", doc);\r\n    assertXpathEvaluatesTo(\"string\", \"//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='\" + id + \"']/gml:coverageFunction/gml:MappingRule\", doc);\r\n    assertXpathEvaluatesTo(\"http://ns.bgs.ac.uk/thesaurus/lithostratigraphy\", \"//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='\" + id + \"']/gmlcov:rangeType/@xlink:href\", doc);\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.arcsde.ArcSDECoverageStoreEditPanelTest.testRefreshRasterTableListBadConnectionParams",
	"Comment": "connection parameters are not properly set and the refresh raster tables button is hit",
	"Method": "void testRefreshRasterTableListBadConnectionParams(){\r\n    startPanelForNewStore();\r\n    final FormTester formTester = tester.newFormTester(\"rasterStoreForm\");\r\n    final String base = \"rasterStoreForm:parametersPanel:\";\r\n    RasterTableSelectionPanel tableChooserPanel = (RasterTableSelectionPanel) tester.getComponentFromLastRenderedPage(base + \"tableNamePanel\");\r\n    tableChooserPanel.setSessionFactory(new ISessionPoolFactory() {\r\n        public ISessionPool createPool(final ArcSDEConnectionConfig config) throws IOException {\r\n            throw new IOException(\"can't connect for some reason\");\r\n        }\r\n    });\r\n    String submitLink = base + \"tableNamePanel:refresh\";\r\n    tester.executeAjaxEvent(submitLink, \"click\");\r\n    FeedbackMessage feedbackMessage = formTester.getForm().getFeedbackMessages().first();\r\n    assertNotNull(feedbackMessage);\r\n    Serializable message = feedbackMessage.getMessage();\r\n    assertNotNull(message);\r\n    String expectedMessage = \"Refreshing raster tables list: can't connect for some reason\";\r\n    assertEquals(expectedMessage, message.toString());\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.arcsde.ArcSDECoverageStoreEditPanelTest.testRefreshRasterTableListBadConnectionParams",
	"Comment": "connection parameters are not properly set and the refresh raster tables button is hit",
	"Method": "void testRefreshRasterTableListBadConnectionParams(){\r\n    throw new IOException(\"can't connect for some reason\");\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDimensionsValueParser.setAsDateRange",
	"Comment": "set the 2 strings as a daterange. return true in case of success",
	"Method": "boolean setAsDateRange(String low,String high,List<Object> selectedValues){\r\n    final Date l = parseAsDate(low);\r\n    final Date h = parseAsDate(high);\r\n    if (l != null && h != null) {\r\n        if (l.compareTo(h) > 0) {\r\n            throwInvalidRangeException(low, high);\r\n        }\r\n        selectedValues.add(new DateRange(l, h));\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.wps.ppio.XMLPPIO.getElement",
	"Comment": "the qualified name of the xml element in the xml representation of the object.",
	"Method": "QName getElement(){\r\n    return element;\r\n}"
}, {
	"Path": "org.geoserver.util.XmlTestUtil.addNamespace",
	"Comment": "add a namespace to be used when resolving xpath expressions.",
	"Method": "void addNamespace(String prefix,String uri){\r\n    namespaces.put(prefix, uri);\r\n    regenerateContext();\r\n}"
}, {
	"Path": "org.geoserver.security.decorators.SecuredGetMapRequest.buildCQLFilter",
	"Comment": "checks security and build the eventual cql filter to cascade",
	"Method": "String buildCQLFilter(){\r\n    List<Filter> layerFilters = new ArrayList<Filter>();\r\n    boolean layerFiltersFound = false;\r\n    for (int i = 0; i < layers.size(); i++) {\r\n        Layer layer = layers.get(i);\r\n        if (layer instanceof SecuredWMSLayer) {\r\n            SecuredWMSLayer secured = (SecuredWMSLayer) layer;\r\n            final WrapperPolicy policy = secured.getPolicy();\r\n            if (policy.getResponse() == org.geoserver.security.Response.CHALLENGE) {\r\n                SecureCatalogImpl.unauthorizedAccess(layer.getName());\r\n            }\r\n            if (policy.getLimits() instanceof WMSAccessLimits) {\r\n                WMSAccessLimits limits = (WMSAccessLimits) policy.getLimits();\r\n                layerFilters.add(limits.getReadFilter());\r\n                layerFiltersFound |= limits.getReadFilter() != null;\r\n                if (limits.getRasterFilter() != null) {\r\n                    LOGGER.severe(\"Sorry, raster filters for cascaded wms layers \" + \"have not been implemented yet\");\r\n                }\r\n            }\r\n            if (!layersAddedToDelegate) {\r\n                delegate.addLayer(layer, styles.get(i));\r\n            }\r\n        }\r\n    }\r\n    String encodedFilter = null;\r\n    if (layerFiltersFound) {\r\n        StringBuilder sb = new StringBuilder();\r\n        for (Filter filter : layerFilters) {\r\n            if (filter != null) {\r\n                sb.append(CQL.toCQL(filter));\r\n            }\r\n            sb.append(\";\");\r\n        }\r\n        sb.setLength(sb.length() - 1);\r\n        encodedFilter = ResponseUtils.urlEncode(sb.toString());\r\n    }\r\n    layersAddedToDelegate = true;\r\n    return encodedFilter;\r\n}"
}, {
	"Path": "org.vfny.geoserver.util.requests.readers.KvpRequestReader.parseBbox",
	"Comment": "parses the bbox parameter, wich must be a string of the form minx,miny,maxx,maxyand returns a corresponding envelope object",
	"Method": "Envelope parseBbox(String bboxParam){\r\n    Envelope bbox = null;\r\n    Object[] bboxValues = readFlat(bboxParam, INNER_DELIMETER).toArray();\r\n    if (bboxValues.length != 4) {\r\n        throw new ServiceException(bboxParam + \" is not a valid pair of coordinates\", getClass().getName());\r\n    }\r\n    try {\r\n        double minx = Double.parseDouble(bboxValues[0].toString());\r\n        double miny = Double.parseDouble(bboxValues[1].toString());\r\n        double maxx = Double.parseDouble(bboxValues[2].toString());\r\n        double maxy = Double.parseDouble(bboxValues[3].toString());\r\n        bbox = new Envelope(minx, maxx, miny, maxy);\r\n        if (minx > maxx) {\r\n            throw new ServiceException(\"illegal bbox, minX: \" + minx + \" is \" + \"greater than maxX: \" + maxx);\r\n        }\r\n        if (miny > maxy) {\r\n            throw new ServiceException(\"illegal bbox, minY: \" + miny + \" is \" + \"greater than maxY: \" + maxy);\r\n        }\r\n    } catch (NumberFormatException ex) {\r\n        throw new ServiceException(ex, \"Illegal value for BBOX parameter: \" + bboxParam, getClass().getName() + \"::parseBbox()\");\r\n    }\r\n    return bbox;\r\n}"
}, {
	"Path": "org.geoserver.wfs.WFSReprojectionUtil.applyDefaultCRS",
	"Comment": "applies a default crs to all geometric filter elements that do not already have one",
	"Method": "Filter applyDefaultCRS(Filter filter,CoordinateReferenceSystem defaultCRS){\r\n    DefaultCRSFilterVisitor defaultVisitor = new DefaultCRSFilterVisitor(ff, defaultCRS);\r\n    return (Filter) filter.accept(defaultVisitor, null);\r\n}"
}, {
	"Path": "org.geoserver.h2.RestTest.readSqLiteDatabaseFile",
	"Comment": "helper method that just reads the test h2 database file and stores it in a array of bytes.",
	"Method": "byte[] readSqLiteDatabaseFile(){\r\n    InputStream input = RestTest.class.getResourceAsStream(\"/test-database.data.db\");\r\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\r\n    try {\r\n        IOUtils.copy(input, output);\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error reading SQLite database file to byte array.\", exception);\r\n    }\r\n    return output.toByteArray();\r\n}"
}, {
	"Path": "org.geoserver.security.oauth2.services.GoogleAccessTokenConverter.setUserTokenConverter",
	"Comment": "converter for the part of the data in the token representing a user.",
	"Method": "void setUserTokenConverter(UserAuthenticationConverter userTokenConverter){\r\n    this.userTokenConverter = userTokenConverter;\r\n    super.setUserTokenConverter(userTokenConverter);\r\n}"
}, {
	"Path": "org.geoserver.rest.catalog.MapXMLConverter.insert",
	"Comment": "generate the jdom element needed to represent an object and insert it into the parent elementgiven.",
	"Method": "void insert(Element elem,Object object){\r\n    if (object instanceof Map) {\r\n        Map<?, ?> map = (Map<?, ?>) object;\r\n        for (Map.Entry<?, ?> entry : map.entrySet()) {\r\n            Element newElem = new Element(entry.getKey().toString());\r\n            insert(newElem, entry.getValue());\r\n            elem.addContent(newElem);\r\n        }\r\n    } else if (object instanceof Collection) {\r\n        Collection<?> collection = (Collection<?>) object;\r\n        for (Object entry : collection) {\r\n            Element newElem = new Element(\"entry\");\r\n            insert(newElem, entry);\r\n            elem.addContent(newElem);\r\n        }\r\n    } else {\r\n        elem.addContent(object == null ? \"\" : object.toString());\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.getStyles",
	"Comment": "retrieve a resource in the the styles directory of a workspace. an empty path will retrievethe directory itself. a null workspace will return the resource in the global stylesdirectory",
	"Method": "Resource getStyles(String path,Resource getStyles,WorkspaceInfo wsi,String path){\r\n    Resource r = get(wsi, Paths.path(STYLE_DIR, Paths.path(path)));\r\n    assert r != null;\r\n    return r;\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.GeorectifyCoverage.storeImage",
	"Comment": "store a gridcoverage2d and returns the file where the underlying image have been stored.",
	"Method": "File storeImage(RenderedImage image,File tempFolder){\r\n    File file = File.createTempFile(\"readCoverage\", \".tif\", tempFolder);\r\n    new ImageWorker(image).writeTIFF(file, null, 0, 256, 256);\r\n    return file;\r\n}"
}, {
	"Path": "org.geoserver.wfs.xml.v1_0_0.XmlSchemaEncoder.printElement",
	"Comment": "internal method to print xml element information for table.",
	"Method": "String printElement(FeatureTypeInfo type){\r\n    return \"\\n  <xs:element name=\\\"\" + type.getName() + \"\\\" type=\\\"\" + type.getNamespace().getPrefix() + \":\" + type.getName() + \"_Type\" + \"\\\" substitutionGroup=\\\"gml:_Feature\\\"/>\";\r\n}"
}, {
	"Path": "org.geoserver.sldservice.utils.classifier.RulesBuilder.equalIntervalClassification",
	"Comment": "generate a list of rules using equal interval classification sets up only filter notsymbolizer",
	"Method": "List<Rule> equalIntervalClassification(FeatureCollection features,String property,Class<?> propertyType,int intervals,boolean open,boolean normalize){\r\n    return getRules(features, property, propertyType, intervals, open, normalize, \"EqualInterval\");\r\n}"
}, {
	"Path": "org.geoserver.flow.controller.PriorityThreadBlocker.getPriorityProvider",
	"Comment": "returns the priority provider, issuing a priority for each request to be put in queue",
	"Method": "PriorityProvider getPriorityProvider(){\r\n    return priorityProvider;\r\n}"
}, {
	"Path": "org.geoserver.sldservice.utils.classifier.RulesBuilder.uniqueIntervalClassification",
	"Comment": "generate a list of rules using unique interval classification sets up only filter notsymbolizer",
	"Method": "List<Rule> uniqueIntervalClassification(FeatureCollection features,String property,Class<?> propertyType,int intervals,boolean normalize){\r\n    List<Rule> rules = getRules(features, property, propertyType, features.size(), false, normalize, \"UniqueInterval\");\r\n    if (intervals > 0 && rules.size() > intervals) {\r\n        throw new IllegalArgumentException(\"Intervals: \" + rules.size());\r\n    }\r\n    return rules;\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerApplication.init",
	"Comment": "initialization override which sets up a locator for i18n resources.",
	"Method": "void init(){\r\n    getResourceSettings().setUseMinifiedResources(false);\r\n    getResourceSettings().setResourceStreamLocator(new GeoServerResourceStreamLocator());\r\n    List<IStringResourceLoader> alternateResourceLoaders = getBeansOfType(IStringResourceLoader.class);\r\n    for (IStringResourceLoader loader : alternateResourceLoaders) {\r\n        LOGGER.info(\"Registering alternate resource loader: \" + loader);\r\n        getResourceSettings().getStringResourceLoaders().add(loader);\r\n    }\r\n    getResourceSettings().getStringResourceLoaders().add(0, new GeoServerStringResourceLoader());\r\n    getDebugSettings().setAjaxDebugModeEnabled(false);\r\n    getApplicationSettings().setPageExpiredErrorPage(GeoServerExpiredPage.class);\r\n    GeoServerSecurityManager securityManager = getBeanOfType(GeoServerSecurityManager.class);\r\n    setRootRequestMapper(new DynamicCryptoMapper(getRootRequestMapper(), securityManager, this));\r\n    getRequestCycleListeners().add(new CallbackRequestCycleListener(this));\r\n    WebUIMode webUIMode = getGeoServer().getGlobal().getWebUIMode();\r\n    if (webUIMode == null) {\r\n        webUIMode = WebUIMode.DEFAULT;\r\n    }\r\n    switch(webUIMode) {\r\n        case DO_NOT_REDIRECT:\r\n            getRequestCycleSettings().setRenderStrategy(RenderStrategy.ONE_PASS_RENDER);\r\n            break;\r\n        case REDIRECT:\r\n            getRequestCycleSettings().setRenderStrategy(RenderStrategy.REDIRECT_TO_BUFFER);\r\n            break;\r\n        case DEFAULT:\r\n            getRequestCycleSettings().setRenderStrategy(defaultIsRedirect ? RenderStrategy.REDIRECT_TO_BUFFER : RenderStrategy.ONE_PASS_RENDER);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.wicket.DecimalConverter.getMaximumFractionDigits",
	"Comment": "returns the maximum number of fraction digits allowed in the configuration",
	"Method": "int getMaximumFractionDigits(){\r\n    return maximumFractionDigits;\r\n}"
}, {
	"Path": "org.geoserver.wfs.WFSGetFeatureOutputFormat.encodeMeasures",
	"Comment": "helper method that checks if coordinates measured values should be encoded for the providedfeature collections. by default coordinates measures are not encoded.",
	"Method": "boolean encodeMeasures(List featureCollections,Catalog catalog){\r\n    boolean encodeMeasures = true;\r\n    for (int i = 0; i < featureCollections.size(); i++) {\r\n        Boolean measures = getFeatureTypeInfoProperty(catalog, (FeatureCollection) featureCollections.get(i), fti -> fti.getEncodeMeasures());\r\n        if (Boolean.FALSE.equals(measures)) {\r\n            encodeMeasures = false;\r\n        }\r\n    }\r\n    return encodeMeasures;\r\n}"
}, {
	"Path": "org.geoserver.kml.regionate.CachedHierarchyRegionatingStrategy.getDatabaseName",
	"Comment": "returns the name to be used for the database. should be unique for this specific regionatedlayer.",
	"Method": "String getDatabaseName(WMSMapContent con,Layer layer,String getDatabaseName,FeatureTypeInfo cfg){\r\n    return cfg.getNamespace().getPrefix() + \"_\" + cfg.getName();\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.DimensionsUtils.getValuesWithDuplicates",
	"Comment": "helper method that simply extract from a feature collection the values of a specificattribute keeping duplicate values.",
	"Method": "List<Object> getValuesWithDuplicates(String attributeName,FeatureCollection featureCollection){\r\n    List<Object> values = new ArrayList();\r\n    FeatureIterator featuresIterator = featureCollection.features();\r\n    while (featuresIterator.hasNext()) {\r\n        SimpleFeature feature = (SimpleFeature) featuresIterator.next();\r\n        values.add(feature.getAttribute(attributeName));\r\n    }\r\n    Collections.sort(values, new ComparableComparator());\r\n    return values;\r\n}"
}, {
	"Path": "org.geoserver.wms.ncwms.NcWmsGetTimeSeriesTest.testCsvXY",
	"Comment": "tests that x y values are returned for a projected crs request",
	"Method": "void testCsvXY(){\r\n    setupRasterDimension(WATTEMP, ResourceInfo.ELEVATION, DimensionPresentation.LIST, null, UNITS, UNIT_SYMBOL);\r\n    setupRasterDimension(WATTEMP, ResourceInfo.TIME, DimensionPresentation.LIST, null, null, \"degrees\");\r\n    String url = BASE_URL_3857 + CSV_FORMAT + TIME_RANGE_COMPLETE;\r\n    String rawCsv = getAsString(url);\r\n    String[] csvLines = rawCsv.split(\"\\\\r?\\\\n\");\r\n    Assert.assertTrue(\"Projected output\", csvLines[0].startsWith(\"# X:\"));\r\n    double x = Double.parseDouble(csvLines[0].substring(5));\r\n    double y = Double.parseDouble(csvLines[1].substring(5));\r\n    Assert.assertEquals(\"x\", 5163802.004897614, x, 0.000001);\r\n    Assert.assertEquals(\"y\", 1130001.6216064095, y, 0.000001);\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.Dimension.getPagedDomainValuesAsStrings",
	"Comment": "returns this dimension values represented as strings taking in account this dimensionrepresentation strategy. the returned values will be sorted. the provided filter will be usedto filter the domain values. the provided filter can be null.",
	"Method": "Tuple<Integer, List<String>> getPagedDomainValuesAsStrings(Query query,int maxValues,SortOrder sortOrder){\r\n    DomainSummary summary = getPagedDomainValues(query, maxValues, sortOrder);\r\n    return Tuple.tuple(summary.getCount(), DimensionsUtils.getDomainValuesAsStrings(summary));\r\n}"
}, {
	"Path": "org.geoserver.wfs.xslt.config.TransformRepository.putTransformSheet",
	"Comment": "writes the stylesheet of a transformation. this method will close the provided input stream.",
	"Method": "void putTransformSheet(TransformInfo info,InputStream sheet){\r\n    Resource txFile = getTransformFile(info);\r\n    OutputStream fos = null;\r\n    try {\r\n        fos = txFile.out();\r\n        IOUtils.copy(sheet, fos);\r\n    } finally {\r\n        IOUtils.closeQuietly(sheet);\r\n        IOUtils.closeQuietly(fos);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.getAsDOM",
	"Comment": "executes an ows request using the get method and returns the result as an xml document.",
	"Method": "Document getAsDOM(String path,Document getAsDOM,String path,boolean skipDTD){\r\n    return dom(get(path), skipDTD);\r\n}"
}, {
	"Path": "org.geoserver.test.NormalizedMultiValuesTest.checkStation1Gml31",
	"Comment": "helper method that checks that station 1 is present in the provided document.",
	"Method": "void checkStation1Gml31(Document document){\r\n    checkCount(WFS11_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/gml:featureMember/st_gml31:Station_gml31[@gml:id='st.1']\");\r\n    checkCount(WFS11_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/gml:featureMember/st_gml31:Station_gml31\" + \"[@gml:id='st.1']\" + \"[st_gml31:tag='st_1_tag_a']/st_gml31:tag[@st_gml31:code='1']\");\r\n    checkCount(WFS11_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/gml:featureMember/st_gml31:Station_gml31\" + \"[@gml:id='st.1']\" + \"[st_gml31:tag='st_1_tag_b']/st_gml31:tag[@st_gml31:code='2']\");\r\n    checkCount(WFS11_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/gml:featureMember/st_gml31:Station_gml31\" + \"[@gml:id='st.1']\" + \"[st_gml31:tag='europe']/st_gml31:tag[@st_gml31:code='3']\");\r\n    checkCount(WFS11_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/gml:featureMember/st_gml31:Station_gml31\" + \"[@gml:id='st.1']\" + \"/st_gml31:measurements/ms_gml31:Measurement_gml31\" + \"[@gml:id='ms.1']\" + \"[ms_gml31:tag='temperature_tag']\" + \"[ms_gml31:tag='desert_tag']\");\r\n    checkCount(WFS11_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/gml:featureMember/st_gml31:Station_gml31\" + \"[@gml:id='st.1']\" + \"/st_gml31:measurements/ms_gml31:Measurement_gml31\" + \"[@gml:id='ms.2']\" + \"[ms_gml31:tag='wind_tag']\");\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.assertStatusCodeForPut",
	"Comment": "assert that a put request to a path will have a particular status code for the response.",
	"Method": "void assertStatusCodeForPut(int code,String path,String body,String type){\r\n    assertStatusCodeForRequest(code, \"PUT\", path, body, type);\r\n}"
}, {
	"Path": "org.geoserver.test.FeatureChainingWfsTest.testGetFeatureWithMappingName",
	"Comment": "geologicunit mapping has mappingname specified, to override targetelementname when featurechained to mappedfeature. this is to test that querying geologicunit as top level featurestill works, when its real type name is specified in the query.",
	"Method": "void testGetFeatureWithMappingName(){\r\n    Document doc = getAsDOM(\"wfs?request=GetFeature&version=1.1.0&typename=gsml:GeologicUnit\");\r\n    LOGGER.info(\"WFS GetFeature&typename=gsml:GeologicUnit response:\\n\" + prettyString(doc));\r\n    assertEquals(\"wfs:FeatureCollection\", doc.getDocumentElement().getNodeName());\r\n    assertXpathEvaluatesTo(\"3\", \"/wfs:FeatureCollection/@numberOfFeatures\", doc);\r\n    assertXpathCount(3, \"//gsml:GeologicUnit\", doc);\r\n}"
}, {
	"Path": "org.geoserver.test.NormalizedMultiValuesTest.checkStation1Gml32",
	"Comment": "helper method that checks that station 1 is present in the provided document.",
	"Method": "void checkStation1Gml32(Document document){\r\n    checkCount(WFS20_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/wfs:member/st_gml32:Station_gml32[@gml:id='st.1']\");\r\n    checkCount(WFS20_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/wfs:member/st_gml32:Station_gml32\" + \"[@gml:id='st.1']\" + \"[st_gml32:tag='st_1_tag_a']/st_gml32:tag[@st_gml32:code='1']\");\r\n    checkCount(WFS20_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/wfs:member/st_gml32:Station_gml32\" + \"[@gml:id='st.1']\" + \"[st_gml32:tag='st_1_tag_b']/st_gml32:tag[@st_gml32:code='2']\");\r\n    checkCount(WFS20_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/wfs:member/st_gml32:Station_gml32\" + \"[@gml:id='st.1']\" + \"[st_gml32:tag='europe']/st_gml32:tag[@st_gml32:code='3']\");\r\n    checkCount(WFS20_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/wfs:member/st_gml32:Station_gml32\" + \"[@gml:id='st.1']\" + \"/st_gml32:measurements/ms_gml32:Measurement_gml32\" + \"[@gml:id='ms.1']\" + \"[ms_gml32:tag='temperature_tag']\" + \"[ms_gml32:tag='desert_tag']\");\r\n    checkCount(WFS20_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/wfs:member/st_gml32:Station_gml32\" + \"[@gml:id='st.1']\" + \"/st_gml32:measurements/ms_gml32:Measurement_gml32\" + \"[@gml:id='ms.2']\" + \"[ms_gml32:tag='wind_tag']\");\r\n}"
}, {
	"Path": "org.geoserver.ows.NestedKvpParser.parseTokenSet",
	"Comment": "parses the set of tokens into a final represetnation.subclasses may choose to override this method. the default implementation just return thelist passed in.",
	"Method": "Object parseTokenSet(List tokenSet){\r\n    return tokenSet;\r\n}"
}, {
	"Path": "org.geoserver.security.filter.GeoServerPreAuthenticatedUserNameFilter.getRolesFromHttpAttribute",
	"Comment": "calculates roles using the string found in the http header attribute if no role string isfound, anempty collection is returnedthe result contains personalized roles",
	"Method": "Collection<GeoServerRole> getRolesFromHttpAttribute(HttpServletRequest request,String principal){\r\n    Collection<GeoServerRole> roles = new ArrayList<GeoServerRole>();\r\n    String rolesString = request.getHeader(getRolesHeaderAttribute());\r\n    if (rolesString == null || rolesString.trim().length() == 0) {\r\n        LOGGER.log(Level.WARNING, \"No roles in header attribute: \" + getRolesHeaderAttribute());\r\n        return roles;\r\n    }\r\n    roles.addAll(getConverter().convertRolesFromString(rolesString, principal));\r\n    LOGGER.log(Level.FINE, \"for principal \" + principal + \" found roles \" + StringUtils.collectionToCommaDelimitedString(roles) + \" in header \" + getRolesHeaderAttribute());\r\n    return roles;\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.MultiDimensionalExtensionTest.registerLayerDimension",
	"Comment": "helper method that will register a dimension for some layer.",
	"Method": "void registerLayerDimension(ResourceInfo info,String dimensionName,String attributeName,DimensionPresentation presentation,DimensionDefaultValueSetting defaultValue){\r\n    DimensionInfo dimension = new DimensionInfoImpl();\r\n    dimension.setEnabled(true);\r\n    dimension.setPresentation(presentation);\r\n    dimension.setDefaultValue(defaultValue);\r\n    dimension.setAttribute(attributeName);\r\n    info.getMetadata().put(dimensionName, dimension);\r\n    getCatalog().save(info);\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.DownloadProcessTest.testDownloadRasterSelectedBandsScaledWithROI",
	"Comment": "test download of selected bands of raster data, scald and using a roi area. result containsonly band 1.",
	"Method": "void testDownloadRasterSelectedBandsScaledWithROI(){\r\n    DownloadEstimatorProcess limits = new DownloadEstimatorProcess(new StaticDownloadServiceConfiguration(), getGeoServer());\r\n    final WPSResourceManager resourceManager = getResourceManager();\r\n    DownloadProcess downloadProcess = new DownloadProcess(getGeoServer(), limits, resourceManager);\r\n    Polygon roi = (Polygon) new WKTReader2().read(\"POLYGON (( \" + \"-127.57473954542964 54.06575021619523, \" + \"-130.88669845369998 52.00807146727025, \" + \"-129.50812897394974 49.85372324691927, \" + \"-130.5300633861675 49.20465679591609, \" + \"-129.25955033314003 48.60392508062591, \" + \"-128.00975216684665 50.986137055052474, \" + \"-125.8623089087404 48.63154492960477, \" + \"-123.984159178178 50.68231871628503, \" + \"-126.91186316993704 52.15307567440926, \" + \"-125.3444367403868 53.54787804784162, \" + \"-127.57473954542964 54.06575021619523 \" + \"))\");\r\n    roi.setSRID(4326);\r\n    File rasterZip = // layerName\r\n    downloadProcess.execute(getLayerId(MockData.USA_WORLDIMG), null, \"image/tiff\", null, CRS.decode(\"EPSG:4326\", true), roi, false, null, 40, 40, new int[] { 1 }, null, new NullProgressListener());\r\n    Assert.assertNotNull(rasterZip);\r\n    GeoTiffReader reader = null;\r\n    GridCoverage2D gc = null;\r\n    try {\r\n        final File[] tiffFiles = extractFiles(rasterZip, \"GTIFF\");\r\n        Assert.assertNotNull(tiffFiles);\r\n        Assert.assertTrue(tiffFiles.length > 0);\r\n        reader = new GeoTiffReader(tiffFiles[0]);\r\n        gc = reader.read(null);\r\n        Assert.assertNotNull(gc);\r\n        Assert.assertEquals(1, gc.getNumSampleDimensions());\r\n        Rectangle2D originalGridRange = (GridEnvelope2D) reader.getOriginalGridRange();\r\n        Assert.assertEquals(40, Math.round(originalGridRange.getWidth()));\r\n        Assert.assertEquals(40, Math.round(originalGridRange.getHeight()));\r\n        Assert.assertEquals(-130.88669845369998, gc.getEnvelope().getLowerCorner().getOrdinate(0), 1E-6);\r\n        Assert.assertEquals(48.5552612829, gc.getEnvelope().getLowerCorner().getOrdinate(1), 1E-6);\r\n        Assert.assertEquals(-124.05382943906582, gc.getEnvelope().getUpperCorner().getOrdinate(0), 1E-6);\r\n        Assert.assertEquals(54.00577111704634, gc.getEnvelope().getUpperCorner().getOrdinate(1), 1E-6);\r\n    } finally {\r\n        if (gc != null) {\r\n            CoverageCleanerCallback.disposeCoverage(gc);\r\n        }\r\n        if (reader != null) {\r\n            reader.dispose();\r\n        }\r\n        resourceManager.finished(resourceManager.getExecutionId(true));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.support.DatabaseUtil.splitOracleSQLScript",
	"Comment": "splits the oracle sql script file into individual statements.",
	"Method": "List<String> splitOracleSQLScript(InputStream inputStream){\r\n    StringBuilder contents = new StringBuilder();\r\n    ArrayList<String> statements = new ArrayList<String>();\r\n    try {\r\n        BufferedReader input = new BufferedReader(new InputStreamReader(new DataInputStream(inputStream)));\r\n        try {\r\n            String line = null, suffix = null;\r\n            boolean start = true;\r\n            while ((line = input.readLine()) != null) {\r\n                String trimedLine = line.trim();\r\n                if (trimedLine.startsWith(\"--\") || trimedLine.equals(\"\")) {\r\n                    continue;\r\n                }\r\n                if (start) {\r\n                    boolean match = false;\r\n                    for (OracleScriptRule ps : OracleScriptRule.values()) {\r\n                        if (trimedLine.startsWith(ps.getPrefix())) {\r\n                            match = true;\r\n                            suffix = ps.getSuffix();\r\n                            start = trimedLine.endsWith(suffix) ? true : false;\r\n                            contents.append(trimedLine + NEWLINE);\r\n                            if (start) {\r\n                                statements.add((contents.toString().trim()).substring(0, contents.toString().trim().length() - 1));\r\n                                contents.setLength(0);\r\n                                suffix = null;\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!match) {\r\n                        throw new Exception(\"Can't match \" + trimedLine);\r\n                    }\r\n                } else {\r\n                    if (trimedLine.endsWith(suffix)) {\r\n                        trimedLine = trimedLine.trim().substring(0, trimedLine.length() - 1);\r\n                        contents.append(trimedLine);\r\n                        statements.add(contents.toString());\r\n                        contents.setLength(0);\r\n                        start = true;\r\n                        suffix = null;\r\n                    } else {\r\n                        contents.append(trimedLine + NEWLINE);\r\n                    }\r\n                }\r\n            }\r\n            return statements;\r\n        } finally {\r\n            input.close();\r\n        }\r\n    } catch (Exception e) {\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.publish.PublishedConfigurationPage.onCancel",
	"Comment": "by default brings back the user to layerpage, subclasses can override this behavior",
	"Method": "void onCancel(){\r\n    doReturn();\r\n}"
}, {
	"Path": "org.geoserver.config.util.XStreamPersister.initImplementationDefaults",
	"Comment": "sets up mappings from interface to implementation classes.",
	"Method": "void initImplementationDefaults(XStream xs){\r\n    xs.addDefaultImplementation(GeoServerInfoImpl.class, GeoServerInfo.class);\r\n    xs.addDefaultImplementation(SettingsInfoImpl.class, SettingsInfo.class);\r\n    xs.addDefaultImplementation(LoggingInfoImpl.class, LoggingInfo.class);\r\n    xs.addDefaultImplementation(JAIInfoImpl.class, JAIInfo.class);\r\n    xs.addDefaultImplementation(JAIEXTInfoImpl.class, JAIEXTInfo.class);\r\n    xs.addDefaultImplementation(CoverageAccessInfoImpl.class, CoverageAccessInfo.class);\r\n    xs.addDefaultImplementation(ContactInfoImpl.class, ContactInfo.class);\r\n    xs.addDefaultImplementation(AttributionInfoImpl.class, AttributionInfo.class);\r\n    xs.addDefaultImplementation(CatalogImpl.class, Catalog.class);\r\n    xs.addDefaultImplementation(NamespaceInfoImpl.class, NamespaceInfo.class);\r\n    xs.addDefaultImplementation(WorkspaceInfoImpl.class, WorkspaceInfo.class);\r\n    xs.addDefaultImplementation(DataStoreInfoImpl.class, DataStoreInfo.class);\r\n    xs.addDefaultImplementation(WMSStoreInfoImpl.class, WMSStoreInfo.class);\r\n    xs.addDefaultImplementation(WMTSStoreInfoImpl.class, WMTSStoreInfo.class);\r\n    xs.addDefaultImplementation(CoverageStoreInfoImpl.class, CoverageStoreInfo.class);\r\n    xs.addDefaultImplementation(StyleInfoImpl.class, StyleInfo.class);\r\n    xs.addDefaultImplementation(LegendInfoImpl.class, LegendInfo.class);\r\n    xs.addDefaultImplementation(FeatureTypeInfoImpl.class, FeatureTypeInfo.class);\r\n    xs.addDefaultImplementation(CoverageInfoImpl.class, CoverageInfo.class);\r\n    xs.addDefaultImplementation(WMSLayerInfoImpl.class, WMSLayerInfo.class);\r\n    xs.addDefaultImplementation(WMTSLayerInfoImpl.class, WMTSLayerInfo.class);\r\n    xs.addDefaultImplementation(CoverageDimensionImpl.class, CoverageDimensionInfo.class);\r\n    xs.addDefaultImplementation(MetadataLinkInfoImpl.class, MetadataLinkInfo.class);\r\n    xs.addDefaultImplementation(AttributeTypeInfoImpl.class, AttributeTypeInfo.class);\r\n    xs.addDefaultImplementation(LayerInfoImpl.class, LayerInfo.class);\r\n    xs.addDefaultImplementation(LayerGroupInfoImpl.class, LayerGroupInfo.class);\r\n    xs.addDefaultImplementation(LayerIdentifier.class, LayerIdentifierInfo.class);\r\n    xs.addDefaultImplementation(AuthorityURL.class, AuthorityURLInfo.class);\r\n    xs.addDefaultImplementation(GridGeometry2D.class, GridGeometry.class);\r\n    xs.addDefaultImplementation(DefaultGeographicCRS.class, CoordinateReferenceSystem.class);\r\n    xs.addDefaultImplementation(ArrayList.class, List.class);\r\n    xs.addDefaultImplementation(ArrayListMultimap.class, Multimap.class);\r\n}"
}, {
	"Path": "org.geoserver.gwc.layer.CatalogConfiguration.reset",
	"Comment": "invalidates the later cache and resets the tile layer catalog.",
	"Method": "void reset(){\r\n    lock.acquireWriteLock();\r\n    try {\r\n        this.layerCache.invalidateAll();\r\n        this.tileLayerCatalog.reset();\r\n    } finally {\r\n        lock.releaseWriteLock();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.impl.EditableUserDAO.syncChanges",
	"Comment": "write the changes to persistant storage. this should happen automatically when changes aremade, so no code outside of this class should need to call this method.",
	"Method": "void syncChanges(){\r\n    Properties prop = new Properties();\r\n    for (UserDetails details : myDetailStorage.values()) {\r\n        String key = details.getUsername();\r\n        String value = details.getPassword();\r\n        for (GrantedAuthority auth : details.getAuthorities()) {\r\n            value += \",\" + auth.getAuthority();\r\n        }\r\n        if (!details.isEnabled()) {\r\n            value += \",disabled\";\r\n        }\r\n        prop.setProperty(key, value);\r\n    }\r\n    OutputStream os = new BufferedOutputStream(getUserFile().out());\r\n    prop.store(os, \"Geoserver user data. Format is username=password,role1,role2,...[enabled|disabled]\");\r\n}"
}, {
	"Path": "org.geoserver.sldservice.utils.classifier.RulesBuilder.quantileClassification",
	"Comment": "generate a list of rules using quantile classification sets up only filter not symbolizer",
	"Method": "List<Rule> quantileClassification(FeatureCollection features,String property,Class<?> propertyType,int classNumber,boolean open,boolean normalize){\r\n    return getRules(features, property, propertyType, classNumber, open, normalize, \"Quantile\");\r\n}"
}, {
	"Path": "org.geoserver.security.RESTfulDefinitionSource.getAttributes",
	"Comment": "override the method in filterinvocationsecuritymetadatasource",
	"Method": "Collection<ConfigAttribute> getAttributes(Object object){\r\n    if ((object == null) || !this.supports(object.getClass())) {\r\n        throw new IllegalArgumentException(\"Object must be a FilterInvocation\");\r\n    }\r\n    String url = ((FilterInvocation) object).getRequestUrl();\r\n    String method = ((FilterInvocation) object).getHttpRequest().getMethod();\r\n    return delegate().lookupAttributes(cleanURL(url), method);\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.LocalWorkspaceCatalog.list",
	"Comment": "returns a decorating iterator over the one returned by the delegate that wraps every objectit returns, if possible.",
	"Method": "CloseableIterator<T> list(Class<T> of,Filter filter,CloseableIterator<T> list,Class<T> of,Filter filter,Integer offset,Integer count,SortBy sortBy){\r\n    CloseableIterator<T> iterator = delegate.list(of, filter, offset, count, sortBy);\r\n    if (iterator.hasNext() && useNameDequalifyingProxy()) {\r\n        return CloseableIteratorAdapter.transform(iterator, obj -> obj == null ? null : NameDequalifyingProxy.create(obj, of));\r\n    }\r\n    return iterator;\r\n}"
}, {
	"Path": "org.geoserver.catalog.ResourcePool.getTemporaryName",
	"Comment": "builds a temporary name for a feature type making sure there is no conflict with otherexisting type names in the store",
	"Method": "Name getTemporaryName(FeatureTypeInfo info,DataAccess<? extends FeatureType, ? extends Feature> dataAccess,FeatureTypeCallback initializer){\r\n    Name temporaryName;\r\n    List<Name> typeNames = dataAccess.getNames();\r\n    String nsURI = null;\r\n    if (typeNames.size() > 0) {\r\n        nsURI = typeNames.get(0).getNamespaceURI();\r\n    }\r\n    do {\r\n        String name = UUID.randomUUID().toString();\r\n        temporaryName = new NameImpl(nsURI, name);\r\n    } while (Arrays.asList(typeNames).contains(temporaryName));\r\n    if (!initializer.initialize(info, dataAccess, temporaryName)) {\r\n        temporaryName = null;\r\n    }\r\n    return temporaryName;\r\n}"
}, {
	"Path": "org.geoserver.wps.executor.ProcessListenerNotifier.checkDismissed",
	"Comment": "throws a process cancelled exception if the process has been cancelled",
	"Method": "void checkDismissed(){\r\n    if (status.getPhase() == ProcessState.DISMISSING) {\r\n        throw new ProcessDismissedException();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.getResourceLoader",
	"Comment": "accessor for global resource loader instance from the test application context.",
	"Method": "GeoServerResourceLoader getResourceLoader(){\r\n    return (GeoServerResourceLoader) applicationContext.getBean(\"resourceLoader\");\r\n}"
}, {
	"Path": "org.geoserver.web.treeview.TreeView.setSelectedNodesInternal",
	"Comment": "select the node without automatic expansion but with event dispatching.",
	"Method": "void setSelectedNodesInternal(Collection<TreeNode<T>> selectedNodes,AjaxRequestTarget target){\r\n    selectedNodeModel.setObject(selectedNodes);\r\n    if (target != null) {\r\n        for (SelectionListener<T> listener : selectionListeners) {\r\n            listener.onSelect(target);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.impl.Util.loadUniversal",
	"Comment": "determines if the the input stream is xml if it is, use create properties loaded from xmlformat, otherwise create properties from default format.",
	"Method": "Properties loadUniversal(InputStream in){\r\n    final String xmlDeclarationStart = \"<?xml\";\r\n    BufferedInputStream bin = new BufferedInputStream(in);\r\n    bin.mark(4096);\r\n    BufferedReader reader = new BufferedReader(new InputStreamReader(bin));\r\n    String line = reader.readLine();\r\n    boolean isXML = line.startsWith(xmlDeclarationStart);\r\n    bin.reset();\r\n    Properties props = new Properties();\r\n    if (isXML)\r\n        props.loadFromXML(bin);\r\n    else\r\n        props.load(bin);\r\n    return props;\r\n}"
}, {
	"Path": "org.geoserver.security.jdbc.JDBCUserGroupStore.preparePassword",
	"Comment": "validates and encodes the password. do nothing for a not changed password of an existing user",
	"Method": "void preparePassword(GeoServerUser user){\r\n    char[] passwordArray = user.getPassword() != null ? user.getPassword().toCharArray() : null;\r\n    if (PasswordValidatorImpl.passwordStartsWithEncoderPrefix(passwordArray) != null)\r\n        return;\r\n    getSecurityManager().loadPasswordValidator(getPasswordValidatorName()).validatePassword(passwordArray);\r\n    GeoServerPasswordEncoder enc = getSecurityManager().loadPasswordEncoder(getPasswordEncoderName());\r\n    enc.initializeFor(this);\r\n    user.setPassword(enc.encodePassword(user.getPassword(), null));\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.DimensionsUtils.getMinMax",
	"Comment": "return the min a max values of a tree set of values converted to the provided type.",
	"Method": "Tuple<T, T> getMinMax(List<Object> values,Class<T> type){\r\n    Object minValue = getMinValue(values);\r\n    Object maxValue = getMaxValue(values);\r\n    return Tuple.tuple(Converters.convert(minValue, type), Converters.convert(maxValue, type));\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.GSFixtureUtilitiesDelegate.printSkipNotice",
	"Comment": "print a notice that tests are being skipped, identifying the property file whose absence isresponsible.",
	"Method": "void printSkipNotice(String fixtureId,File fixtureFile){\r\n    FixtureUtilities.printSkipNotice(fixtureId, fixtureFile);\r\n}"
}, {
	"Path": "org.vfny.geoserver.global.xml.NameSpaceTranslator.isValidTypeRef",
	"Comment": "isvalidtyperef purpose.checks to see if the reference provided is found in the list of elements for thisnamespace.",
	"Method": "boolean isValidTypeRef(String type){\r\n    if ((type == null) || (type == \"\")) {\r\n        return false;\r\n    }\r\n    Set elems = getElements();\r\n    Iterator i = elems.iterator();\r\n    while (i.hasNext()) {\r\n        NameSpaceElement nse = (NameSpaceElement) i.next();\r\n        if (nse == null) {\r\n            continue;\r\n        }\r\n        String tp = nse.getTypeRefName();\r\n        if ((tp != null) && tp.equals(type)) {\r\n            return true;\r\n        }\r\n        tp = nse.getQualifiedTypeRefName();\r\n        if ((tp != null) && tp.equals(type)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.web.data.workspace.WorkspaceNewPageTest.createWorkspace",
	"Comment": "helper method that submits a new workspace using the provided parameters.",
	"Method": "void createWorkspace(String name,String namespace,boolean isolated){\r\n    init();\r\n    FormTester form = tester.newFormTester(\"form\");\r\n    form.setValue(\"name\", name);\r\n    form.setValue(\"uri\", namespace);\r\n    form.setValue(\"isolated\", isolated);\r\n    form.submit();\r\n}"
}, {
	"Path": "org.geoserver.csw.records.GenericRecordBuilder.createAttribute",
	"Comment": "helper method for creating attributes in the tree structure",
	"Method": "void createAttribute(TreeBranch branch,int index,ComplexType type,String[] path,List<Object> value,Map<Object, Object> userData,int splitIndex){\r\n    AttributeDescriptor descriptor = (AttributeDescriptor) Types.findDescriptor(type, path[index]);\r\n    if (descriptor == null) {\r\n        throw new IllegalArgumentException(\"Cannot find descriptor for attribute \" + path[index] + \" in type \" + type.getName().toString());\r\n    }\r\n    List<TreeNode> treenodes = branch.children.get(path[index]);\r\n    if (treenodes == null) {\r\n        treenodes = new ArrayList<TreeNode>();\r\n        branch.children.put(path[index], treenodes);\r\n    }\r\n    if (index == path.length - 1) {\r\n        for (Object item : value) {\r\n            SimpleTreeLeaf leaf = new SimpleTreeLeaf();\r\n            leaf.userData = userData;\r\n            leaf.descriptor = descriptor;\r\n            leaf.value = item;\r\n            leaf.userData = userData;\r\n            treenodes.add(leaf);\r\n        }\r\n    } else if (index == path.length - 2) {\r\n        if (treenodes.isEmpty()) {\r\n            for (int i = 0; i < value.size(); i++) {\r\n                ComplexTreeLeaf leaf = new ComplexTreeLeaf();\r\n                treenodes.add(leaf);\r\n                leaf.descriptor = descriptor;\r\n            }\r\n        } else if (treenodes.size() == 1) {\r\n            for (int i = 1; i < value.size(); i++) {\r\n                treenodes.add(treenodes.get(0).clone());\r\n            }\r\n        } else if (value.size() != 1 && treenodes.size() != value.size()) {\r\n            throw new IllegalArgumentException(\"Error in mapping: Number of values not matching.\");\r\n        }\r\n        for (int i = 0; i < value.size(); i++) {\r\n            ComplexTreeLeaf leaf = (ComplexTreeLeaf) treenodes.get(i);\r\n            leaf.value.put(path[index + 1], value.size() == 1 ? value.get(0) : value.get(i));\r\n            leaf.userData = userData;\r\n        }\r\n    } else {\r\n        if (index != splitIndex) {\r\n            if (treenodes.isEmpty()) {\r\n                TreeNode child = new TreeBranch();\r\n                child.descriptor = descriptor;\r\n                treenodes.add(child);\r\n            }\r\n            for (int i = 0; i < treenodes.size(); i++) {\r\n                createAttribute((TreeBranch) treenodes.get(i), index + 1, (ComplexType) descriptor.getType(), path, value, userData, splitIndex);\r\n            }\r\n        } else {\r\n            if (treenodes.isEmpty()) {\r\n                for (int i = 0; i < value.size(); i++) {\r\n                    TreeNode child = new TreeBranch();\r\n                    child.descriptor = descriptor;\r\n                    treenodes.add(child);\r\n                }\r\n            } else if (treenodes.size() == 1) {\r\n                for (int i = 1; i < value.size(); i++) {\r\n                    treenodes.add(treenodes.get(0).clone());\r\n                }\r\n            } else if (treenodes.size() != value.size()) {\r\n                throw new IllegalArgumentException(\"Error in mapping: Number of values not matching.\");\r\n            }\r\n            for (int i = 0; i < value.size(); i++) {\r\n                createAttribute((TreeBranch) treenodes.get(i), index + 1, (ComplexType) descriptor.getType(), path, Collections.singletonList(value.get(i)), userData, splitIndex);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.WFSGetFeatureOutputFormat.getCapabilitiesElementNames",
	"Comment": "returns the list of output format names generated by this format, for inclusion in the wfs1.0 capabilities document as xml element names",
	"Method": "List<String> getCapabilitiesElementNames(){\r\n    String name = getCapabilitiesElementName();\r\n    if (name == null) {\r\n        return Collections.emptyList();\r\n    } else {\r\n        return Arrays.asList(name);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.JoinExtractingVisitor.buildNameToAlias",
	"Comment": "builds a map going from type name, qualified or unqualified, to alias",
	"Method": "Map<String, String> buildNameToAlias(){\r\n    Map<String, String> nameToAlias = new HashMap();\r\n    nameToAlias.put(primaryFeatureType.prefixedName(), primaryAlias);\r\n    nameToAlias.put(primaryFeatureType.getName(), primaryAlias);\r\n    String localTypeName = getLocalTypeName(primaryFeatureType);\r\n    if (localTypeName != null) {\r\n        nameToAlias.put(localTypeName, primaryAlias);\r\n    }\r\n    for (int i = 0; i < aliases.size(); i++) {\r\n        String alias = aliases.get(i);\r\n        FeatureTypeInfo ft = featureTypes.get(i);\r\n        nameToAlias.put(ft.getName(), alias);\r\n        nameToAlias.put(ft.prefixedName(), alias);\r\n        localTypeName = getLocalTypeName(ft);\r\n        if (localTypeName != null) {\r\n            nameToAlias.put(localTypeName, alias);\r\n        }\r\n    }\r\n    return nameToAlias;\r\n}"
}, {
	"Path": "org.geoserver.wps.jdbc.GSFixtureUtilitiesDelegate.printSkipNotice",
	"Comment": "print a notice that tests are being skipped, identifying the property file whose absence isresponsible.",
	"Method": "void printSkipNotice(String fixtureId,File fixtureFile){\r\n    FixtureUtilities.printSkipNotice(fixtureId, fixtureFile);\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaMockData.getNamespaces",
	"Comment": "return the namespace prefixx to namespace uri map for this data.",
	"Method": "Map<String, String> getNamespaces(){\r\n    return Collections.unmodifiableMap(namespaces);\r\n}"
}, {
	"Path": "org.geoserver.wps.ppio.ProcessParameterIO.findEncoder",
	"Comment": "look for ppio matching the parameter type and suitable for output handling",
	"Method": "List<ProcessParameterIO> findEncoder(Parameter<?> p,ApplicationContext context){\r\n    return findByDirection(p, context, PPIODirection.ENCODING);\r\n}"
}, {
	"Path": "org.geoserver.gwc.JDBCPasswordEncryptionHelper.encryptPassword",
	"Comment": "encrypts the connection pool password, if not null, using the geoserver password encoders.",
	"Method": "JDBCConfiguration encryptPassword(JDBCConfiguration configuration){\r\n    ConnectionPoolConfiguration pool = configuration.getConnectionPool();\r\n    if (pool != null && pool.getPassword() != null) {\r\n        String password = pool.getPassword();\r\n        String encoded = passwords.encode(password);\r\n        configuration = cloneAndSetPassword(configuration, encoded);\r\n    }\r\n    return configuration;\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.IsolatedCatalogFacade.enforceLayerIsolation",
	"Comment": "checks if the provided layer is visible in the current context.",
	"Method": "T enforceLayerIsolation(T layer){\r\n    if (layer == null) {\r\n        return null;\r\n    }\r\n    ResourceInfo resource = layer.getResource();\r\n    if (resource == null) {\r\n        return layer;\r\n    }\r\n    StoreInfo store = resource.getStore();\r\n    if (store == null) {\r\n        return layer;\r\n    }\r\n    WorkspaceInfo workspace = store.getWorkspace();\r\n    return canSeeWorkspace(workspace) ? layer : null;\r\n}"
}, {
	"Path": "org.geoserver.geofence.config.GeoFenceConfiguration.isGrantWriteToWorkspacesToAuthenticatedUsers",
	"Comment": "allows write access to resources to authenticated users, if false only admins have writeaccess.",
	"Method": "boolean isGrantWriteToWorkspacesToAuthenticatedUsers(){\r\n    return grantWriteToWorkspacesToAuthenticatedUsers;\r\n}"
}, {
	"Path": "org.vfny.geoserver.global.GeoServerFeatureSource.makeDefinitionQuery",
	"Comment": "takes a query and adapts it to match re definitionquery filter configured for a feature type.",
	"Method": "Query makeDefinitionQuery(Query query,SimpleFeatureType schema){\r\n    if ((query == Query.ALL) || query.equals(Query.ALL)) {\r\n        return query;\r\n    }\r\n    try {\r\n        String[] propNames = extractAllowedAttributes(query, schema);\r\n        Filter filter = query.getFilter();\r\n        filter = makeDefinitionFilter(filter);\r\n        Query defQuery = new Query(query);\r\n        defQuery.setFilter(filter);\r\n        defQuery.setPropertyNames(propNames);\r\n        if (query.getSortBy() != null) {\r\n            defQuery.setSortBy(query.getSortBy());\r\n        }\r\n        if (linearizationTolerance != null) {\r\n            query.getHints().put(Hints.LINEARIZATION_TOLERANCE, linearizationTolerance);\r\n        }\r\n        return defQuery;\r\n    } catch (Exception ex) {\r\n        throw new DataSourceException(\"Could not restrict the query to the definition criteria: \" + ex.getMessage(), ex);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.opensearch.rest.AbstractOpenSearchController.singleton",
	"Comment": "turns a complex feature into a single item feature collection",
	"Method": "FeatureCollection singleton(Feature f){\r\n    ListComplexFeatureCollection fc = new ListComplexFeatureCollection(f);\r\n    return fc;\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.ComplexFeatureAccessor.value",
	"Comment": "returns a single attribute value looking it up by qualified name",
	"Method": "Object value(Feature feature,String attribute,Object value,Feature feature,String namespace,String attribute){\r\n    Property property = feature.getProperty(new NameImpl(namespace, attribute));\r\n    if (property == null) {\r\n        return null;\r\n    } else {\r\n        Object value = property.getValue();\r\n        return value;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.password.ConfigurationPasswordEncryptionHelper.encode",
	"Comment": "encrypts a parameter value.if no encoder is configured then the value is returned as is.",
	"Method": "String encode(String value){\r\n    String encoderName = securityManager.getSecurityConfig().getConfigPasswordEncrypterName();\r\n    if (encoderName != null) {\r\n        GeoServerPasswordEncoder pwEncoder = securityManager.loadPasswordEncoder(encoderName);\r\n        if (pwEncoder != null) {\r\n            String prefix = pwEncoder.getPrefix();\r\n            if (value.startsWith(prefix + GeoServerPasswordEncoder.PREFIX_DELIMTER)) {\r\n                throw new RuntimeException(\"Cannot encode a password with prefix: \" + prefix + GeoServerPasswordEncoder.PREFIX_DELIMTER);\r\n            }\r\n            value = pwEncoder.encodePassword(value, null);\r\n        }\r\n    } else {\r\n        LOGGER.warning(\"Encryption disabled, no password encoder set\");\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.geoserver.test.PolymorphismWfsTest.testSecondValueFilters",
	"Comment": "test filtering polymorphism with no feature chaining works. also tests filtering whenmappingname is used as linkelement.",
	"Method": "void testSecondValueFilters(){\r\n    String xml = \"<wfs:GetFeature \" + \"service=\\\"WFS\\\" \" + \"version=\\\"1.1.0\\\" \" + \"xmlns:cdf=\\\"http://www.opengis.net/cite/data\\\" \" + \"xmlns:ogc=\\\"http://www.opengis.net/ogc\\\" \" + \"xmlns:wfs=\\\"http://www.opengis.net/wfs\\\" \" + \"xmlns:gml=\\\"http://www.opengis.net/gml\\\" \" + \"xmlns:ex=\\\"http://example.com\\\" \" + \"xmlns:gsml=\\\"\" + AbstractAppSchemaMockData.GSML_URI + \"\\\" \" + \">\" + \"    <wfs:Query typeName=\\\"ex:PolymorphicFeature\\\">\" + \"        <ogc:Filter>\" + \"            <ogc:PropertyIsEqualTo>\" + \"                <ogc:PropertyName>ex:secondValue/gsml:CGI_NumericValue/gsml:principalValue/@uom<\/ogc:PropertyName>\" + \"                <ogc:Literal>m<\/ogc:Literal>\" + \"            <\/ogc:PropertyIsEqualTo>\" + \"        <\/ogc:Filter>\" + \"    <\/wfs:Query> \" + \"<\/wfs:GetFeature>\";\r\n    Document doc = postAsDOM(\"wfs\", xml);\r\n    LOGGER.info(\"WFS filter GetFeature response:\\n\" + prettyString(doc));\r\n    assertXpathEvaluatesTo(\"2\", \"/wfs:FeatureCollection/@numberOfFeatures\", doc);\r\n    assertXpathCount(2, \"//ex:PolymorphicFeature\", doc);\r\n    assertXpathEvaluatesTo(\"f1\", \"(//ex:PolymorphicFeature)[1]/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(\"1.0\", \"//ex:PolymorphicFeature[@gml:id='f1']/ex:secondValue/gsml:CGI_NumericValue/gsml:principalValue\", doc);\r\n    assertXpathEvaluatesTo(\"m\", \"//ex:PolymorphicFeature[@gml:id='f1']/ex:secondValue/gsml:CGI_NumericValue/gsml:principalValue/@uom\", doc);\r\n    assertXpathEvaluatesTo(\"f3\", \"(//ex:PolymorphicFeature)[2]/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(\"0.0\", \"//ex:PolymorphicFeature[@gml:id='f3']/ex:secondValue/gsml:CGI_NumericValue/gsml:principalValue\", doc);\r\n    assertXpathEvaluatesTo(\"m\", \"//ex:PolymorphicFeature[@gml:id='f3']/ex:secondValue/gsml:CGI_NumericValue/gsml:principalValue/@uom\", doc);\r\n}"
}, {
	"Path": "org.geoserver.web.LogoutFormInfo.setLogoutPath",
	"Comment": "authentication security endpoint invoked by the pluggable form",
	"Method": "void setLogoutPath(String logoutPath){\r\n    this.logoutPath = logoutPath;\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.store.AbstractMappingStore.hasOutputProperty",
	"Comment": "searches for an optional property among the query attributes. returns true only if theproperty is explicitly listed",
	"Method": "boolean hasOutputProperty(Query query,Name property,boolean includedByDefault){\r\n    if (query.getProperties() == null) {\r\n        return includedByDefault;\r\n    }\r\n    final String localPart = property.getLocalPart();\r\n    final String namespaceURI = property.getNamespaceURI();\r\n    for (PropertyName pn : query.getProperties()) {\r\n        if (localPart.equals(pn.getPropertyName()) && (pn.getNamespaceContext() == null || namespaceURI.equals(pn.getNamespaceContext().getURI(\"\")))) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.csw.DownloadLinkHandler.extractFullDownloadLink",
	"Comment": "given a file download link, extract the link with no file references, used to request thefull layer download.",
	"Method": "String extractFullDownloadLink(String link){\r\n    int resourceIdIndex = link.indexOf(RESOURCE_ID_PARAMETER);\r\n    int nextParamIndex = link.indexOf(\"&\" + FILE_PARAMETER, resourceIdIndex);\r\n    return link.substring(0, nextParamIndex);\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.Ogr2OgrOutputFormat.getEnvironment",
	"Comment": "returns the environment variables that are set prior to invoking ogr2ogr",
	"Method": "Map<String, String> getEnvironment(){\r\n    return environment;\r\n}"
}, {
	"Path": "org.geoserver.gwc.layer.TileLayerInfoUtil.create",
	"Comment": "creates a default tile layer info based on the global defaults, public only for unit testingpurposes.",
	"Method": "GeoServerTileLayerInfoImpl create(GWCConfig defaults){\r\n    GeoServerTileLayerInfoImpl info = new GeoServerTileLayerInfoImpl();\r\n    info.setEnabled(defaults.isCacheLayersByDefault());\r\n    info.setAutoCacheStyles(defaults.isCacheNonDefaultStyles());\r\n    for (String gsetId : defaults.getDefaultCachingGridSetIds()) {\r\n        XMLGridSubset subset = new XMLGridSubset();\r\n        subset.setGridSetName(gsetId);\r\n        info.getGridSubsets().add(subset);\r\n    }\r\n    info.getMimeFormats().addAll(defaults.getDefaultOtherCacheFormats());\r\n    info.setGutter(defaults.getGutter());\r\n    info.setMetaTilingX(defaults.getMetaTilingX());\r\n    info.setMetaTilingY(defaults.getMetaTilingY());\r\n    info.setInMemoryCached(true);\r\n    return info;\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.GeoTIFFCoverageResponseDelegate.handleCompression",
	"Comment": "handle compression encoding parameters for wcs.notice that not all the encoding params are supported by the underlying tiff imagewriterfloating point predictor is not supported for lzwhuffman is supported only for 1 bit images",
	"Method": "void handleCompression(Map<String, String> econdingParameters,GeoTiffWriterHelper helper){\r\n    if (econdingParameters.containsKey(\"compression\")) {\r\n        GeoTiffWriteParams wp = helper.getImageIoWriteParams();\r\n        helper.disableSourceCopyOptimization();\r\n        String compressionS = econdingParameters.get(\"compression\");\r\n        if (compressionS != null && !compressionS.equalsIgnoreCase(\"none\")) {\r\n            if (compressionS.equals(\"LZW\")) {\r\n                wp.setCompressionMode(GeoTiffWriteParams.MODE_EXPLICIT);\r\n                wp.setCompressionType(\"LZW\");\r\n                String predictorS = econdingParameters.get(\"predictor\");\r\n                if (predictorS != null) {\r\n                    if (predictorS.equals(\"None\")) {\r\n                    } else if (predictorS.equals(\"Horizontal\")) {\r\n                        wp.setTIFFCompressor(new TIFFLZWCompressor(BaselineTIFFTagSet.PREDICTOR_HORIZONTAL_DIFFERENCING));\r\n                    } else if (predictorS.equals(\"Floatingpoint\")) {\r\n                        throw new OWS20Exception(\"Floating Point predictor is not supported\", ows20Code(WcsExceptionCode.PredictorNotSupported), predictorS);\r\n                    } else {\r\n                        throw new OWS20Exception(\"Invalid Predictor provided\", ows20Code(WcsExceptionCode.PredictorInvalid), predictorS);\r\n                    }\r\n                }\r\n            } else if (compressionS.equals(\"JPEG\")) {\r\n                wp.setCompressionMode(GeoTiffWriteParams.MODE_EXPLICIT);\r\n                wp.setCompressionType(\"JPEG\");\r\n                wp.setCompressionQuality(DEFAULT_JPEG_COMPRESSION_QUALITY);\r\n                if (econdingParameters.containsKey(\"jpeg_quality\")) {\r\n                    final String quality_ = econdingParameters.get(\"jpeg_quality\");\r\n                    if (quality_ != null) {\r\n                        try {\r\n                            final int quality = Integer.valueOf(quality_);\r\n                            if (quality > 0 && quality <= 100) {\r\n                                wp.setCompressionQuality(quality / 100.f);\r\n                            } else {\r\n                                throw new OWS20Exception(\"Provided quality value for the jpeg compression in invalid\", ows20Code(WcsExceptionCode.JpegQualityInvalid), quality_);\r\n                            }\r\n                        } catch (Exception e) {\r\n                            throw new OWS20Exception(\"Provided quality value for the jpeg compression in invalid\", ows20Code(WcsExceptionCode.JpegQualityInvalid), quality_);\r\n                        }\r\n                    }\r\n                }\r\n            } else if (compressionS.equals(\"PackBits\")) {\r\n                wp.setCompressionMode(GeoTiffWriteParams.MODE_EXPLICIT);\r\n                wp.setCompressionType(\"PackBits\");\r\n            } else if (compressionS.equals(\"DEFLATE\") || compressionS.equals(\"Deflate\")) {\r\n                wp.setCompressionMode(GeoTiffWriteParams.MODE_EXPLICIT);\r\n                wp.setCompressionType(\"Deflate\");\r\n            } else if (compressionS.equals(\"Huffman\")) {\r\n                wp.setCompressionMode(GeoTiffWriteParams.MODE_EXPLICIT);\r\n                wp.setCompressionType(\"CCITT RLE\");\r\n            } else {\r\n                throw new OWS20Exception(\"Provided compression does not seem supported\", ows20Code(WcsExceptionCode.CompressionInvalid), compressionS);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTest.applyAddModifyConfigurationChanges",
	"Comment": "helper method that adds some new services and settings to the provided geoserver instance andalso modifies some existing ones.",
	"Method": "void applyAddModifyConfigurationChanges(GeoServerInstance instance){\r\n    GeoServer geoServer = instance.getGeoServer();\r\n    Catalog catalog = instance.getCatalog();\r\n    WorkspaceInfo workspace = catalog.getWorkspaceByName(MockData.DEFAULT_PREFIX);\r\n    GeoServerInfo geoServerInfo = geoServer.getGlobal();\r\n    SettingsInfo geoServerSettings = geoServerInfo.getSettings();\r\n    ContactInfo geoServerContact = geoServerSettings.getContact();\r\n    geoServerContact.setContactPerson(randomString());\r\n    geoServerSettings.setContact(geoServerContact);\r\n    geoServerInfo.setSettings(geoServerSettings);\r\n    geoServer.save(geoServerInfo);\r\n    assertThat(workspace, notNullValue());\r\n    SettingsInfo workspaceSettings = new SettingsInfoImpl();\r\n    workspaceSettings.setTitle(randomString());\r\n    workspaceSettings.setWorkspace(workspace);\r\n    geoServer.add(workspaceSettings);\r\n    ServiceInfo wmsService = geoServer.getService(WMSInfo.class);\r\n    wmsService.setAbstract(randomString());\r\n    geoServer.save(wmsService);\r\n    WMSInfoImpl workspaceWmsService = new WMSInfoImpl();\r\n    workspaceWmsService.setName(randomString());\r\n    workspaceWmsService.setTitle(randomString());\r\n    workspaceWmsService.setWorkspace(workspace);\r\n    geoServer.add(workspaceWmsService);\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.NetCDFDimensionsManager.updateDimensionValues",
	"Comment": "update the dimension values of a dimension, by inspecting the coverage properties",
	"Method": "void updateDimensionValues(GridCoverage2D coverage){\r\n    Map properties = coverage.getProperties();\r\n    for (NetCDFDimensionsManager.NetCDFDimensionMapping dimension : getDimensions()) {\r\n        final String dimensionName = dimension.getName();\r\n        final Object value = properties.get(dimensionName);\r\n        if (value == null) {\r\n            if (LOGGER.isLoggable(Level.WARNING)) {\r\n                LOGGER.warning(\"No Dimensions available with the specified name: \" + dimensionName);\r\n            }\r\n        } else {\r\n            dimension.getDimensionValues().addValue(value);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.security.WpsAccessRule.compareTo",
	"Comment": "comparison implemented so that generic rules get first, specific one are compared by name,and if anything else is equal, read comes before write",
	"Method": "int compareTo(WpsAccessRule other){\r\n    int compareGroup = compareCatalogItems(groupName, other.groupName);\r\n    if (compareGroup != 0)\r\n        return compareGroup;\r\n    int compareName = compareCatalogItems(wpsName, other.wpsName);\r\n    return compareName;\r\n}"
}, {
	"Path": "org.geoserver.restupload.ResumableUploadResourceManager.uploadDone",
	"Comment": "executes the mapping to move uploaded file from temporary folder to rest upload root createsthe sidecar file",
	"Method": "String uploadDone(String uploadId){\r\n    ResumableUploadResource resource = getResource(uploadId);\r\n    Map<String, String> storeParams = new HashMap<String, String>();\r\n    String destinationPath = getDestinationPath(uploadId);\r\n    StringBuilder remappingPath = new StringBuilder(destinationPath);\r\n    String tempFile = resource.getFile().getCanonicalPath();\r\n    RESTUtils.remapping(null, FilenameUtils.getBaseName(destinationPath), remappingPath, tempFile, storeParams);\r\n    Resource destinationFile = Resources.fromPath(remappingPath.toString());\r\n    IOUtils.copyStream(new FileInputStream(resource.getFile()), destinationFile.out(), true, true);\r\n    resource.delete();\r\n    getSideCarFile(uploadId).createNewFile();\r\n    return destinationPath.toString();\r\n}"
}, {
	"Path": "org.geoserver.catalog.ValidationResult.getErrors",
	"Comment": "returns the list of errors associated to this validation result.",
	"Method": "List<RuntimeException> getErrors(){\r\n    return errorList;\r\n}"
}, {
	"Path": "org.geoserver.security.cas.LiveCasData.lookupFixture",
	"Comment": "looks up the fixture file in the home directory provided that the",
	"Method": "File lookupFixture(String fixtureId){\r\n    final String property = System.getProperty(\"gs.\" + fixtureId);\r\n    if (property != null && \"false\".equals(property.toLowerCase())) {\r\n        return null;\r\n    }\r\n    File base = new File(System.getProperty(\"user.home\"), \".geoserver\");\r\n    if (!base.exists())\r\n        base.mkdir();\r\n    File fixtureFile = new File(base, fixtureId + \".properties\");\r\n    if (!fixtureFile.exists()) {\r\n        final String warning = \"Disabling test based on fixture \" + fixtureId + \" since the file \" + fixtureFile + \" could not be found\";\r\n        disableTest(warning);\r\n        return null;\r\n    }\r\n    Properties props = new Properties();\r\n    try {\r\n        props.load(new FileInputStream(fixtureFile));\r\n        String tmp = props.getProperty(CAS_SERVER_PROPERTY);\r\n        if (tmp == null)\r\n            tmp = \"\";\r\n        serverURLPrefix = new URL(tmp);\r\n        loginURL = new URL(tmp + \"/login\");\r\n        tmp = props.getProperty(CAS_SERVICE_PROPERTY);\r\n        if (tmp == null)\r\n            tmp = \"\";\r\n        serviceURL = new URL(tmp);\r\n        tmp = props.getProperty(CAS_PROXYCALLBACK_PROPERTY);\r\n        if (tmp == null)\r\n            tmp = \"\";\r\n        proxyCallbackURLPrefix = new URL(tmp);\r\n    } catch (Exception e) {\r\n        disableTest(\"Error in fixture file: \" + e.getMessage());\r\n        return null;\r\n    }\r\n    try {\r\n        HttpURLConnection huc = (HttpURLConnection) loginURL.openConnection();\r\n        huc.setRequestMethod(\"GET\");\r\n        huc.connect();\r\n        if (huc.getResponseCode() != HttpServletResponse.SC_OK) {\r\n            disableTest(\"Cannot connect to \" + loginURL.toString());\r\n            return null;\r\n        }\r\n    } catch (Exception ex) {\r\n        disableTest(\"problem with cas connection: \" + ex.getMessage());\r\n        return null;\r\n    }\r\n    keyStoreFile = new File(base, \"keystore.jks\");\r\n    if (keyStoreFile.exists() == false) {\r\n        disableTest(\"Keystore not found: \" + keyStoreFile.getAbsolutePath());\r\n        return null;\r\n    }\r\n    return fixtureFile;\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.DimensionsUtils.formatDomainValue",
	"Comment": "helper method that converts a domain value to string, range will be correctly handled.",
	"Method": "String formatDomainValue(Object value){\r\n    if (value instanceof Range) {\r\n        Object minValue = ((Range) value).getMinValue();\r\n        Object maxValue = ((Range) value).getMaxValue();\r\n        return formatDomainSimpleValue(minValue) + \"--\" + formatDomainSimpleValue(maxValue);\r\n    }\r\n    return formatDomainSimpleValue(value);\r\n}"
}, {
	"Path": "org.geoserver.util.ReaderUtils.getChildElement",
	"Comment": "getchildelement purpose.used to help with xml manipulations. returns the first child element of the specifiedname.",
	"Method": "Element getChildElement(Element root,String name,boolean mandatory,Element getChildElement,Element root,String name){\r\n    try {\r\n        return getChildElement(root, name, false);\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.csw.records.AbstractRecordDescriptor.getFeatureType",
	"Comment": "the geotools feature type representing this kind of record the default method retrieves typefrom the descriptor",
	"Method": "FeatureType getFeatureType(){\r\n    return (FeatureType) getFeatureDescriptor().getType();\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.IsolatedCatalogFacade.enforceStyleIsolation",
	"Comment": "checks if the provided style is visible in the current context.",
	"Method": "T enforceStyleIsolation(T style){\r\n    if (style == null) {\r\n        return null;\r\n    }\r\n    WorkspaceInfo workspace = style.getWorkspace();\r\n    return canSeeWorkspace(workspace) ? style : null;\r\n}"
}, {
	"Path": "org.geoserver.importer.web.AbstractDbPanel.updatePanelVisibility",
	"Comment": "updates the panel visibility to show only the currently selected one. can also be used toperform actions when the panel visibility is updated",
	"Method": "void updatePanelVisibility(AjaxRequestTarget target){\r\n    for (String type : paramPanelMap.keySet()) {\r\n        Component panel = paramPanelMap.get(type);\r\n        panel.setVisible(connectionType.equals(type));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.InMemorySecurityFilter.buildUserAccessFilter",
	"Comment": "returns a filter that will check if the object passed to it can be accessed by the user",
	"Method": "Filter buildUserAccessFilter(ResourceAccessManager resourceAccesssManager,Authentication user){\r\n    org.opengis.filter.expression.Function visible = new InMemorySecurityFilter(resourceAccesssManager, user);\r\n    FilterFactory factory = Predicates.factory;\r\n    Filter filter = factory.equals(factory.literal(Boolean.TRUE), visible);\r\n    return filter;\r\n}"
}, {
	"Path": "org.geoserver.config.SpringResourceAdaptor.relative",
	"Comment": "spring resource is made relative to data directory if path is relative.",
	"Method": "org.springframework.core.io.Resource relative(org.springframework.core.io.Resource resource,ResourceStore store){\r\n    File f = resource.getFile();\r\n    if (f != null) {\r\n        if (!f.isAbsolute()) {\r\n            Resource res = store.get(Paths.convert(f.getPath()));\r\n            return new SpringResourceAdaptor(res);\r\n        } else {\r\n            return new SpringResourceAdaptor(Files.asResource(f));\r\n        }\r\n    } else {\r\n        return resource;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.platform.FileWatcher.setKnownLastModified",
	"Comment": "method to set the last modified time stamp. clients synchronized with the actual file contentand knowing the last modified time stamp can avoid unnecessary reload operations",
	"Method": "void setKnownLastModified(long lastModified){\r\n    this.lastModified = lastModified;\r\n}"
}, {
	"Path": "org.geoserver.platform.FileWatcher.parseFileContents",
	"Comment": "parses the contents of the file being watched.subclasses should override.",
	"Method": "T parseFileContents(InputStream in){\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.kml.KmlEncodingContext.getFeatureTypes",
	"Comment": "returns a list of the feature types to be encoded. will provide a feature type only for thevector layers, a null will be placed where a layer of different nature is found",
	"Method": "List<SimpleFeatureType> getFeatureTypes(){\r\n    List<SimpleFeatureType> results = new ArrayList<SimpleFeatureType>();\r\n    for (Layer layer : mapContent.layers()) {\r\n        if (layer instanceof FeatureLayer) {\r\n            results.add((SimpleFeatureType) layer.getFeatureSource().getSchema());\r\n        } else {\r\n            results.add(null);\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.geoserver.restupload.ResumableUploadCatalogResource.handlePost",
	"Comment": "post request returns upload url with uploadid to call with successive put request. thebody of post request must contains the desired final file path, it can be relative path withsubfolder.",
	"Method": "void handlePost(){\r\n    try {\r\n        String filePath = getRequest().getEntity().getText();\r\n        if (filePath == null || filePath.isEmpty()) {\r\n            getResponse().setStatus(new Status(Status.CLIENT_ERROR_BAD_REQUEST, \"POST data must contains upload file path\"));\r\n            return;\r\n        }\r\n        Reference ref = getRequest().getResourceRef();\r\n        String baseURL = ref.getIdentifier();\r\n        String uploadId = resumableUploadResourceManager.createUploadResource(filePath);\r\n        Representation output = new StringRepresentation(\"-----TO USE IN PUT-----\\n\" + baseURL + \"/\" + uploadId + \"\\n-----------------------\\n\", MediaType.TEXT_PLAIN);\r\n        Response response = getResponse();\r\n        Series<Parameter> headers = new Form();\r\n        headers.add(\"Location\", baseURL + uploadId);\r\n        getResponse().getAttributes().put(\"org.restlet.http.headers\", headers);\r\n        response.setEntity(output);\r\n        response.setStatus(Status.SUCCESS_CREATED);\r\n    } catch (Exception e) {\r\n        LOGGER.log(Level.SEVERE, e.getMessage(), e);\r\n        getResponse().setStatus(new Status(Status.SERVER_ERROR_INTERNAL, e.getMessage()));\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.DefaultDataStoreEditPanel.getInputComponent",
	"Comment": "creates a form input component for the given datastore param based on its type and metadataproperties.",
	"Method": "Panel getInputComponent(String componentId,IModel paramsModel,ParamInfo paramMetadata){\r\n    final GeoServerEnvironment gsEnvironment = GeoServerExtensions.bean(GeoServerEnvironment.class);\r\n    final String paramName = paramMetadata.getName();\r\n    final String paramLabel = paramMetadata.getName();\r\n    final boolean required = paramMetadata.isRequired();\r\n    final boolean deprecated = paramMetadata.isDeprecated();\r\n    final Class<?> binding = paramMetadata.getBinding();\r\n    final List<Serializable> options = paramMetadata.getOptions();\r\n    Panel parameterPanel;\r\n    if (\"namespace\".equals(paramName)) {\r\n        IModel namespaceModel = new NamespaceParamModel(paramsModel, paramName);\r\n        IModel paramLabelModel = new ResourceModel(paramLabel, paramLabel);\r\n        parameterPanel = new NamespacePanel(componentId, namespaceModel, paramLabelModel, true);\r\n    } else if (options != null && options.size() > 0) {\r\n        IModel<Serializable> valueModel = new MapModel(paramsModel, paramName);\r\n        IModel<String> labelModel = new ResourceModel(paramLabel, paramLabel);\r\n        parameterPanel = new DropDownChoiceParamPanel(componentId, valueModel, labelModel, options, required);\r\n    } else if (Boolean.class == binding) {\r\n        parameterPanel = new CheckBoxParamPanel(componentId, new MapModel(paramsModel, paramName), new ResourceModel(paramLabel, paramLabel));\r\n    } else if (File.class == binding) {\r\n        parameterPanel = new FileParamPanel(componentId, new MapModel(paramsModel, paramName), new ResourceModel(paramLabel, paramLabel), required);\r\n    } else if (String.class == binding && paramMetadata.isPassword()) {\r\n        parameterPanel = new PasswordParamPanel(componentId, new MapModel(paramsModel, paramName), new ResourceModel(paramLabel, paramLabel), required);\r\n    } else {\r\n        IModel model;\r\n        if (\"url\".equalsIgnoreCase(paramName)) {\r\n            model = new URLModel(paramsModel, paramName);\r\n        } else {\r\n            model = new MapModel(paramsModel, paramName);\r\n        }\r\n        Panel tp;\r\n        if (paramMetadata.isLargeText()) {\r\n            tp = new TextAreaParamPanel(componentId, model, new ResourceModel(paramLabel, paramLabel), required);\r\n        } else {\r\n            tp = new TextParamPanel(componentId, model, new ResourceModel(paramLabel, paramLabel), required);\r\n        }\r\n        FormComponent<String> fc = ((ParamPanel) tp).getFormComponent();\r\n        if (paramName.equalsIgnoreCase(\"url\")) {\r\n            if (gsEnvironment == null || !GeoServerEnvironment.ALLOW_ENV_PARAMETRIZATION) {\r\n                fc.add(new FileExistsValidator());\r\n            }\r\n        }\r\n        if (gsEnvironment == null || !GeoServerEnvironment.ALLOW_ENV_PARAMETRIZATION) {\r\n            if (binding != null && !String.class.equals(binding) && !File.class.equals(binding) && !URL.class.equals(binding) && !binding.isArray()) {\r\n                fc.setType(binding);\r\n            }\r\n        }\r\n        parameterPanel = tp;\r\n    }\r\n    Object parameterValue = parameterPanel.getDefaultModelObject();\r\n    boolean visible = !(deprecated && isEmpty(parameterValue)) && !paramMetadata.getLevel().equals(\"program\");\r\n    parameterPanel.setVisible(visible);\r\n    parameterPanel.setVisibilityAllowed(visible);\r\n    return parameterPanel;\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.JDBCOpenSearchAccessTest.createTables",
	"Comment": "takes the postgis.sql creation script, adapts it and runs it on h2",
	"Method": "void createTables(Connection conn){\r\n    List<String> statements = loadScriptCommands(\"/postgis.sql\");\r\n    try (Statement st = conn.createStatement()) {\r\n        for (String statement : statements) {\r\n            st.execute(statement);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerBasePage.getGeoServer",
	"Comment": "convenience method for pages to get access to the geoserver configuration.",
	"Method": "GeoServer getGeoServer(){\r\n    return getGeoServerApplication().getGeoServer();\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.RasterTimeDimensionTest.getGeneratedMaxValue",
	"Comment": "generates the current maximum date, this date is one year later than the current minimumdate.",
	"Method": "Date getGeneratedMaxValue(){\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\r\n    Calendar calendar = Calendar.getInstance();\r\n    calendar.set(Calendar.HOUR_OF_DAY, calendar.getActualMinimum(Calendar.HOUR_OF_DAY));\r\n    calendar.set(Calendar.MINUTE, calendar.getActualMinimum(Calendar.MINUTE));\r\n    calendar.set(Calendar.SECOND, calendar.getActualMinimum(Calendar.SECOND));\r\n    calendar.set(Calendar.MILLISECOND, calendar.getActualMinimum(Calendar.MILLISECOND));\r\n    calendar.set(Calendar.MONTH, calendar.get(Calendar.MONTH) + 1);\r\n    calendar.set(Calendar.MONTH, calendar.get(Calendar.MONTH) - 1);\r\n    calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR) + 1);\r\n    return calendar.getTime();\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.getWorkspaces",
	"Comment": "retrieve a resource in the the workspaces directory. an empty path will retrieve thedirectory itself.",
	"Method": "Resource getWorkspaces(String path){\r\n    Resource r = get(Paths.path(WORKSPACE_DIR, Paths.path(path)));\r\n    assert r != null;\r\n    return r;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.getResourceLoader",
	"Comment": "accessor for global resource loader instance from the test application context.",
	"Method": "GeoServerResourceLoader getResourceLoader(){\r\n    return (GeoServerResourceLoader) applicationContext.getBean(\"resourceLoader\");\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.kvp",
	"Comment": "helper method to create the kvp params from the query string.",
	"Method": "void kvp(MockHttpServletRequest request,String path){\r\n    Map<String, Object> params = KvpUtils.parseQueryString(path);\r\n    for (String key : params.keySet()) {\r\n        Object value = params.get(key);\r\n        if (value instanceof String) {\r\n            request.addParameter(key, (String) value);\r\n        } else {\r\n            String[] values = (String[]) value;\r\n            for (String v : values) {\r\n                request.addParameter(key, v);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.resource.WPSResourceManager.storeRequestObject",
	"Comment": "stores the request in a binary resource for efficient later retrieval",
	"Method": "void storeRequestObject(ExecuteType execute,String executionId){\r\n    Resource resource = getStoredRequest(executionId);\r\n    try (OutputStream out = resource.out()) {\r\n        WPSConfiguration config = new WPSConfiguration();\r\n        Encoder encoder = new Encoder(config);\r\n        encoder.encode(execute, WPS.Execute, out);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.getFilters",
	"Comment": "subclasses needed to do integration tests with servlet filters can override this method andreturn the list of filters to be used during mocked requests",
	"Method": "List<Filter> getFilters(){\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.security.onelogin.SAMLUserDetailsServiceImpl.loadUserBySAML",
	"Comment": "used to identify local account of user referenced by data in the saml assertion and returnuserdetails object describing the user roles",
	"Method": "Object loadUserBySAML(SAMLCredential credential){\r\n    String principal = credential.getNameID().getValue();\r\n    Collection<GeoServerRole> roles = null;\r\n    if (GeoServerUser.ROOT_USERNAME.equals(principal)) {\r\n        roles = Collections.singleton(GeoServerRole.ADMIN_ROLE);\r\n    } else {\r\n        try {\r\n            roles = getRoles(principal);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n        if (roles.contains(GeoServerRole.AUTHENTICATED_ROLE) == false)\r\n            roles.add(GeoServerRole.AUTHENTICATED_ROLE);\r\n    }\r\n    return new User(principal, \"\", true, true, true, true, roles);\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findResourceFile",
	"Comment": "returns the configuration file for the specified resource, if the file does not exist null isreturned.",
	"Method": "File findResourceFile(ResourceInfo r){\r\n    Resource resource = config(r);\r\n    return Resources.file(resource);\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.ReaderUtils.getElementText",
	"Comment": "getchildtext purpose.used to help with xml manipulations. returns the text value of the specified element name.an exception occurs when the node is required and not found.",
	"Method": "String getElementText(Element elem,String getElementText,Element elem,boolean mandatory){\r\n    String value = null;\r\n    if (LOGGER.isLoggable(Level.FINER)) {\r\n        LOGGER.finer(new StringBuffer(\"getting element text for \").append(elem).toString());\r\n    }\r\n    if (elem != null) {\r\n        Node child;\r\n        NodeList childs = elem.getChildNodes();\r\n        int nChilds = childs.getLength();\r\n        for (int i = 0; i < nChilds; i++) {\r\n            child = childs.item(i);\r\n            if (child.getNodeType() == Node.TEXT_NODE) {\r\n                value = child.getNodeValue();\r\n                if (mandatory && \"\".equals(value.trim())) {\r\n                    throw new Exception(elem.getNodeName() + \" text is empty\");\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        if (mandatory && (value == null)) {\r\n            throw new Exception(elem.getNodeName() + \" element does not contains text\");\r\n        }\r\n    } else {\r\n        throw new Exception(\"Argument element can't be null\");\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.geoserver.wfs.xml.ApplicationSchemaXSD1.containsComplexTypes",
	"Comment": "checks if the provided feature types contains complex types.",
	"Method": "boolean containsComplexTypes(FeatureTypeInfo[] featureTypes){\r\n    for (FeatureTypeInfo featureType : featureTypes) {\r\n        try {\r\n            if (!(featureType.getFeatureType() instanceof SimpleFeatureType)) {\r\n                return true;\r\n            }\r\n        } catch (Exception exception) {\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.security.impl.DigestAuthUtils.splitEachArrayElementAndCreateMap",
	"Comment": "takes an array of strings, and for each element removes any instances of removecharacter, and splits the element based on the delimiter. a map is then generated, with the left of the delimiter providing the key, and the rightof the delimiter providing the value.will trim both the key and value before adding to the map.",
	"Method": "Map<String, String> splitEachArrayElementAndCreateMap(String[] array,String delimiter,String removeCharacters){\r\n    if ((array == null) || (array.length == 0)) {\r\n        return null;\r\n    }\r\n    Map<String, String> map = new HashMap<String, String>();\r\n    for (int i = 0; i < array.length; i++) {\r\n        String postRemove;\r\n        if (removeCharacters == null) {\r\n            postRemove = array[i];\r\n        } else {\r\n            postRemove = StringUtils.replace(array[i], removeCharacters, \"\");\r\n        }\r\n        String[] splitThisArrayElement = split(postRemove, delimiter);\r\n        if (splitThisArrayElement == null) {\r\n            continue;\r\n        }\r\n        map.put(splitThisArrayElement[0].trim(), splitThisArrayElement[1].trim());\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.checkIfFeatureIsLinked",
	"Comment": "helper method that returns true if the provided complex property corresponds to a chainedfeature resolved as a link.",
	"Method": "boolean checkIfFeatureIsLinked(Property property,Map<NameImpl, String> attributes){\r\n    if (!(property instanceof ComplexAttribute)) {\r\n        return false;\r\n    }\r\n    ComplexAttribute complexProperty = (ComplexAttribute) property;\r\n    if (complexProperty.getProperties() != null && !complexProperty.getProperties().isEmpty()) {\r\n        return false;\r\n    }\r\n    for (NameImpl key : attributes.keySet()) {\r\n        if (key != null && key.getLocalPart().equalsIgnoreCase(\"href\")) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.StoreProvider.filteredItems",
	"Comment": "returns the requested page of layer objects after applying any keyword filtering set on thepage",
	"Method": "Iterator<StoreInfo> filteredItems(long first,long count){\r\n    final Catalog catalog = getCatalog();\r\n    final SortParam sort = getSort();\r\n    final Property<StoreInfo> property = getProperty(sort);\r\n    SortBy sortOrder = null;\r\n    if (sort != null) {\r\n        if (property instanceof BeanProperty) {\r\n            final String sortProperty = ((BeanProperty<StoreInfo>) property).getPropertyPath();\r\n            sortOrder = sortBy(sortProperty, sort.isAscending());\r\n        } else if (property == ENABLED) {\r\n            sortOrder = sortBy(\"enabled\", sort.isAscending());\r\n        } else if (property == TYPE) {\r\n            sortOrder = sortBy(\"type\", sort.isAscending());\r\n        }\r\n    } else {\r\n        sortOrder = sortBy(\"name\", true);\r\n    }\r\n    final Filter filter = getWorkspaceFilter(getFilter());\r\n    Iterator<StoreInfo> items = catalog.list(StoreInfo.class, filter, (int) first, (int) count, sortOrder);\r\n    return items;\r\n}"
}, {
	"Path": "org.geoserver.netcdf.NetCDFUnitsConfigurator.getMapResource",
	"Comment": "searches for a config file with an absolute path, or inside the netcdf data dir, or insidethe geoserver data dir. will return a map with the contents of the property file, with thesame order as the file contents.",
	"Method": "LinkedHashMap<String, String> getMapResource(String absolutePathProperty,String defaultFileName){\r\n    Resource aliasResource = getResource(absolutePathProperty, defaultFileName);\r\n    if (aliasResource != null) {\r\n        try (InputStream is = aliasResource.in()) {\r\n            return NetCDFUnitFormat.loadPropertiesOrdered(is);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.put",
	"Comment": "executes a request with a default mimetype using the put method.",
	"Method": "InputStream put(String path,InputStream put,String path,String body,InputStream put,String path,String body,String contentType,InputStream put,String path,byte[] body,String contentType){\r\n    MockHttpServletResponse response = putAsServletResponse(path, body, contentType);\r\n    return new ByteArrayInputStream(response.getContentAsString().getBytes());\r\n}"
}, {
	"Path": "org.geoserver.ows.util.RequestUtils.getBufferedXMLReader",
	"Comment": "wraps an xml reader in a buffered reader specifying a lookahead that can be used to preparsesome of the xml document, resetting it back to its original state for actual parsing.",
	"Method": "BufferedReader getBufferedXMLReader(InputStream stream,int xmlLookahead,BufferedReader getBufferedXMLReader,Reader reader,int xmlLookahead){\r\n    if (!(reader instanceof BufferedReader)) {\r\n        reader = new BufferedReader(reader);\r\n    }\r\n    reader.mark(xmlLookahead);\r\n    return (BufferedReader) reader;\r\n}"
}, {
	"Path": "org.geoserver.kml.GeoSearchKMLTest.testRandomRegionator",
	"Comment": "test that requests regionated by random criteria actually return stuff.",
	"Method": "void testRandomRegionator(){\r\n    final String path = \"wms?request=getmap&service=wms&version=1.1.1\" + \"&format=\" + KMLMapOutputFormat.MIME_TYPE + \"&layers=\" + MockData.DIVIDED_ROUTES.getPrefix() + \":\" + MockData.DIVIDED_ROUTES.getLocalPart() + \"&styles=\" + MockData.DIVIDED_ROUTES.getLocalPart() + \"&height=1024&width=1024&srs=EPSG:4326\" + \"&format_options=regionateBy:random\";\r\n    Document document = getAsDOM(path + \"&bbox=-180,-90,0,90\");\r\n    assertEquals(\"kml\", document.getDocumentElement().getTagName());\r\n    assertEquals(1, document.getDocumentElement().getElementsByTagName(\"Placemark\").getLength());\r\n    assertStatusCodeForGet(204, path + \"&bbox=0,-90,180,90\");\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.dxf.DXFWriterFinder.getServiceRegistry",
	"Comment": "returns the service registry. the registry will be created the first time this method isinvoked.",
	"Method": "FactoryRegistry getServiceRegistry(){\r\n    if (registry == null) {\r\n        registry = new FactoryCreator(Arrays.asList(new Class<?>[] { DXFWriter.class }));\r\n    }\r\n    return registry;\r\n}"
}, {
	"Path": "org.geoserver.config.util.XStreamServiceLoader.initXStreamPersister",
	"Comment": "hook for subclasses to configure the xstream.the most common use is to do some aliasing or omit some fields.",
	"Method": "void initXStreamPersister(XStreamPersister xp,GeoServer gs){\r\n    xp.setGeoServer(gs);\r\n    xp.setCatalog(gs.getCatalog());\r\n    xp.getXStream().alias(filenameBase, getServiceClass());\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.DownloadProcessTest.testDownloadPhysicalLimitsRaster",
	"Comment": "test download physical limit for raster data. it should throw an exception",
	"Method": "void testDownloadPhysicalLimitsRaster(){\r\n    final WPSResourceManager resourceManager = getResourceManager();\r\n    ProcessListener listener = new ProcessListener(new ExecutionStatus(new NameImpl(\"gs\", \"DownloadEstimator\"), resourceManager.getExecutionId(false), false));\r\n    DownloadEstimatorProcess limits = new DownloadEstimatorProcess(new StaticDownloadServiceConfiguration(), getGeoServer());\r\n    DownloadProcess downloadProcess = new DownloadProcess(getGeoServer(), limits, resourceManager);\r\n    Polygon roi = (Polygon) new WKTReader2().read(\"POLYGON (( -127.57473954542964 54.06575021619523, -130.88669845369998 52.00807146727025, -129.50812897394974 49.85372324691927, -130.5300633861675 49.20465679591609, -129.25955033314003 48.60392508062591, -128.00975216684665 50.986137055052474, -125.8623089087404 48.63154492960477, -123.984159178178 50.68231871628503, -126.91186316993704 52.15307567440926, -125.3444367403868 53.54787804784162, -127.57473954542964 54.06575021619523 ))\");\r\n    roi.setSRID(4326);\r\n    try {\r\n        // layerName\r\n        downloadProcess.execute(getLayerId(MockData.USA_WORLDIMG), null, \"image/tiff\", null, CRS.decode(\"EPSG:4326\", true), roi, true, null, null, null, null, null, listener);\r\n    } catch (Exception e) {\r\n        Throwable e1 = listener.exception;\r\n        Assert.assertNotNull(e1);\r\n        Assert.assertEquals(\"org.geotools.process.ProcessException: java.io.IOException: Download Exceeded the maximum HARD allowed size!: java.io.IOException: Download Exceeded the maximum HARD allowed size!\", e.getMessage() + (e.getCause() != null ? \": \" + e.getCause().getMessage() : \"\"));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.data.jdbc.GenericUnWrapper.unwrapInternal",
	"Comment": "safe unwrap method using invoke on the provided accessmethod.all errors are logged at finest detail, and null is returned.",
	"Method": "T unwrapInternal(Class<T> target,T conn,Map<Class<?>, Method> methods,T unwrapInternal,Class<T> target,T conn,Class<?> wrapper,Method accessMethod){\r\n    if (accessMethod == null) {\r\n        LOGGER.finest(\"Using \" + wrapper.getName() + \" does not have accessMethod to unwrap \" + target.getSimpleName());\r\n        return null;\r\n    }\r\n    try {\r\n        Object result = accessMethod.invoke(conn, (Object[]) null);\r\n        if (result == null) {\r\n            LOGGER.finest(\"Using \" + wrapper.getName() + \".\" + accessMethod.getName() + \"() to unwrap \" + target.getSimpleName() + \" produced a null\");\r\n            return null;\r\n        }\r\n        if (result == conn) {\r\n            LOGGER.finest(\"Using \" + wrapper.getName() + \".\" + accessMethod.getName() + \"() to unwrap did not result in native \" + target.getSimpleName() + \": \" + result.getClass().getSimpleName());\r\n            return null;\r\n        }\r\n        if (!target.isInstance(result)) {\r\n            LOGGER.finest(\"Using \" + wrapper.getName() + \".\" + accessMethod.getName() + \"() to unwrap did not result in native \" + target.getSimpleName() + \": \" + result.getClass().getSimpleName());\r\n            return null;\r\n        }\r\n        return target.cast(result);\r\n    } catch (IllegalArgumentException e) {\r\n        LOGGER.log(Level.FINEST, \"Using \" + wrapper.getName() + \".\" + accessMethod.getName() + \"() to unwrap \" + target.getSimpleName() + \" failed: \" + e);\r\n        return null;\r\n    } catch (IllegalAccessException e) {\r\n        LOGGER.log(Level.FINEST, \"Using \" + wrapper.getName() + \".\" + accessMethod.getName() + \"() to unwrap \" + target.getSimpleName() + \" failed: \" + e);\r\n        return null;\r\n    } catch (InvocationTargetException e) {\r\n        LOGGER.log(Level.FINEST, \"Using \" + wrapper.getName() + \".\" + accessMethod.getName() + \"() to unwrap \" + target.getSimpleName() + \" failed: \" + e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.PolymorphismWfsTest.checkPolymorphicFeatureChaining",
	"Comment": "this is to test that polymorphism with feature chaining works.",
	"Method": "void checkPolymorphicFeatureChaining(Document doc){\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f1']/ex:firstValue\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f1']/ex:firstValue/gsml:CGI_NumericValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f1']/ex:firstValue/gsml:CGI_TermValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f1']/ex:firstValue/gsml:CGI_TermValue\", doc);\r\n    assertXpathEvaluatesTo(\"1.0\", \"//ex:PolymorphicFeature[@gml:id='f1']/ex:firstValue/gsml:CGI_NumericValue/gsml:principalValue\", doc);\r\n    assertXpathEvaluatesTo(\"m\", \"//ex:PolymorphicFeature[@gml:id='f1']/ex:firstValue/gsml:CGI_NumericValue/gsml:principalValue/@uom\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f2']/ex:firstValue\", doc);\r\n    assertXpathEvaluatesTo(\"urn:value::x\", \"//ex:PolymorphicFeature[@gml:id='f2']/ex:firstValue/@xlink:href\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f2']/ex:firstValue/gsml:CGI_NumericValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f3']/ex:firstValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f4']/ex:firstValue\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f5']/ex:firstValue\", doc);\r\n    assertXpathEvaluatesTo(\"urn:value::y\", \"//ex:PolymorphicFeature[@gml:id='f5']/ex:firstValue/@xlink:href\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f5']/ex:firstValue/gsml:CGI_NumericValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f6']/ex:firstValue\", doc);\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTestsUtils.catalogDifferences",
	"Comment": "returns the catalog differences between two geoserver instances.",
	"Method": "List<InfoDiff> catalogDifferences(GeoServerInstance instanceA,GeoServerInstance instanceB){\r\n    CatalogDiffVisitor visitor = new CatalogDiffVisitor(instanceB.getCatalog(), instanceA.getDataDirectory(), instanceB.getDataDirectory());\r\n    instanceA.getCatalog().accept(visitor);\r\n    return visitor.differences();\r\n}"
}, {
	"Path": "org.geoserver.cluster.JmsStylesTest.addTestStyle",
	"Comment": "helper method that adds the test style to the catalog and consume the produced events.",
	"Method": "void addTestStyle(){\r\n    getTestData().addStyle(TEST_STYLE_NAME, TEST_STYLE_FILE, this.getClass(), getCatalog());\r\n    List<Message> messages = JmsEventsListener.getMessagesByHandlerKey(5000, (selected) -> selected.size() >= 2, CATALOG_ADD_EVENT_HANDLER_KEY, CATALOG_STYLES_FILE_EVENT_HANDLER_KEY);\r\n    assertThat(messages.size(), is(2));\r\n}"
}, {
	"Path": "org.geoserver.monitor.ows.ControlFlowCallbackProxy.getBlockedRequests",
	"Comment": "returns the number of blocked requests from the underlying control flow callback.",
	"Method": "long getBlockedRequests(){\r\n    return (Long) OwsUtils.get(target, \"blockedRequests\");\r\n}"
}, {
	"Path": "org.geoserver.wfs.xml.v1_0_0.WFSBindingUtils.outputFormat",
	"Comment": "sets the outputformat feature of the object passed in.the outputformat value is retreived as an attribute from the node, if null,the default default is used.",
	"Method": "void outputFormat(EObject object,Node node,String defalt){\r\n    String outputFormat = (String) node.getAttributeValue(\"outputFormat\");\r\n    if (outputFormat == null) {\r\n        outputFormat = defalt;\r\n    }\r\n    set(object, \"outputFormat\", outputFormat);\r\n}"
}, {
	"Path": "org.geoserver.web.data.layer.SQLViewAttributeProvider.fillVirtualTable",
	"Comment": "sets the geometries details and the primary key columns into the virtual table",
	"Method": "void fillVirtualTable(VirtualTable vt){\r\n    List<String> pks = new ArrayList<String>();\r\n    for (SQLViewAttribute att : attributes) {\r\n        if (Geometry.class.isAssignableFrom(att.getType())) {\r\n            if (att.getSrid() == null) {\r\n                vt.addGeometryMetadatata(att.getName(), (Class<? extends Geometry>) att.getType(), 4326);\r\n            } else {\r\n                vt.addGeometryMetadatata(att.getName(), (Class<? extends Geometry>) att.getType(), att.getSrid());\r\n            }\r\n        }\r\n        if (att.pk) {\r\n            pks.add(att.getName());\r\n        }\r\n    }\r\n    if (pks.size() > 0) {\r\n        vt.setPrimaryKeyColumns(pks);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.ConfigurationDiffVisitor.computeSettingsDifference",
	"Comment": "register settings differences between the two geoservers.",
	"Method": "void computeSettingsDifference(){\r\n    List<SettingsInfo> settingsA = getAllSettings(geoServerA);\r\n    List<SettingsInfo> settingsB = getAllSettings(geoServerB);\r\n    differences.addAll(settingsB.stream().filter(settings -> search(settings, settingsA) == null).map(settings -> new InfoDiff(null, settings)).collect(Collectors.toList()));\r\n    for (SettingsInfo settings : settingsA) {\r\n        SettingsInfo otherSettings = search(settings, settingsB);\r\n        if (!checkEquals(settings, otherSettings)) {\r\n            differences.add(new InfoDiff(settings, otherSettings));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.GetFeatureHitsIgnoreMaxFeaturesTest.testHitsIgnoreMaxFeaturesEnabled",
	"Comment": "check that max features is ignored when the hitsignoremaxfeatures flag is active",
	"Method": "void testHitsIgnoreMaxFeaturesEnabled(){\r\n    WFSInfo wfs = getWFS();\r\n    wfs.setMaxFeatures(1);\r\n    wfs.setHitsIgnoreMaxFeatures(true);\r\n    getGeoServer().save(wfs);\r\n    Document doc = getAsDOM(\"wfs?request=GetFeature&typename=cdf:Fifteen\" + \"&version=1.1.0&service=wfs&resultType=hits\");\r\n    XpathEngine xpath = XMLUnit.newXpathEngine();\r\n    assertEquals(\"15\", xpath.getMatchingNodes(\"//wfs:FeatureCollection/@numberOfFeatures\", doc).item(0).getNodeValue());\r\n}"
}, {
	"Path": "org.geoserver.nsg.wmts.GridSetsLoader.decodeSrs",
	"Comment": "helper method that just takes care of decoding a certain srs code taking care of the checkedexceptions.",
	"Method": "SRS decodeSrs(String srsCode){\r\n    try {\r\n        return SRS.getSRS(srsCode);\r\n    } catch (GeoWebCacheException exception) {\r\n        throw new RuntimeException(String.format(\"Error decoding SRS with code '%s'.\", srsCode), exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findNamespaceFile",
	"Comment": "returns the configuration file for the specified namespace, if the file does not exist nullis returned.",
	"Method": "File findNamespaceFile(WorkspaceInfo ws){\r\n    Resource directory = get(ws);\r\n    return Resources.directory(directory);\r\n}"
}, {
	"Path": "org.geoserver.rest.catalog.StyleController.writeStyle",
	"Comment": "writes a valid styledlayerdescriptor to a style resource in the requested format. if therequested format does not support encoding from a styledlayerdescriptor, instead writes theraw style to the style resource.if the styledlayerdescriptor contains multiple styledlayers, assumes it represents a stylegroup, and verifies that all styledlayers contain valid layer references.",
	"Method": "void writeStyle(StyleInfo info,StyledLayerDescriptor sld,byte[] rawData,StyleHandler handler,Version version){\r\n    ResourcePool resourcePool = catalog.getResourcePool();\r\n    if (sld.getStyledLayers().length > 1) {\r\n        List<Exception> validationErrors = SLDNamedLayerValidator.validate(catalog, sld);\r\n        if (validationErrors.size() > 0) {\r\n            throw validationErrors.get(0);\r\n        }\r\n    }\r\n    Style style = Styles.style(sld);\r\n    if (handler instanceof SLDHandler && sld.getStyledLayers().length <= 1) {\r\n        info.setFormat(handler.getFormat());\r\n        resourcePool.writeStyle(info, style, true);\r\n    } else {\r\n        info.setFormat(handler.getFormat());\r\n        info.setFormatVersion(version);\r\n        writeStyleRaw(info, new ByteArrayInputStream(rawData));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaTestSupport.getXpathEngine",
	"Comment": "return the xpathengine, configured for this namespace context.note that the engine is configured lazily, to ensure that the mock data has been createdand is ready to report data namespaces, which are then put into the namespace context.",
	"Method": "XpathEngine getXpathEngine(){\r\n    if (xpathEngine == null) {\r\n        xpathEngine = XMLUnit.newXpathEngine();\r\n        Map<String, String> namespaces = new HashMap<String, String>();\r\n        namespaces.putAll(WFS_NAMESPACES);\r\n        namespaces.putAll(getTestData().getNamespaces());\r\n        xpathEngine.setNamespaceContext(new SimpleNamespaceContext(namespaces));\r\n    }\r\n    return xpathEngine;\r\n}"
}, {
	"Path": "org.geoserver.data.test.MockData.registerNamespaces",
	"Comment": "populates a map with prefix to namespace uri mappings for all the mock data namespaces.",
	"Method": "void registerNamespaces(Map<String, String> namespaces){\r\n    namespaces.put(MockData.CITE_PREFIX, MockData.CITE_URI);\r\n    namespaces.put(MockData.CDF_PREFIX, MockData.CDF_URI);\r\n    namespaces.put(MockData.CGF_PREFIX, MockData.CGF_URI);\r\n    namespaces.put(MockData.SF_PREFIX, MockData.SF_URI);\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.LDAPTestUtils.shutdownEmbeddedServer",
	"Comment": "shuts down the embedded server, if there is one. if no server was previously started in thisjvm this is silently ignored.",
	"Method": "void shutdownEmbeddedServer(){\r\n    if (embeddedServer != null) {\r\n        embeddedServer.shutdown();\r\n        embeddedServer = null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.WCSNetCDFTest.testCosmoEuGribRotatedPole",
	"Comment": "test netcdf output from a cosmo eu grib2 file with a gds template 1 rotated pole projection.",
	"Method": "void testCosmoEuGribRotatedPole(){\r\n    MockHttpServletResponse response = getAsServletResponse(\"ows?request=GetCoverage&service=WCS&version=2.0.1\" + \"&coverageid=wcs__Snow_depth_water_equivalent_surface&format=application/x-netcdf\");\r\n    assertEquals(200, response.getStatus());\r\n    assertEquals(\"application/x-netcdf\", response.getContentType());\r\n    byte[] responseBytes = getBinary(response);\r\n    File file = File.createTempFile(\"cosmo-eu-grib-rotated-pole-\", \"-wcs__Snow_depth_water_equivalent_surface.nc\", new File(\"./target\"));\r\n    FileUtils.writeByteArrayToFile(file, responseBytes);\r\n    try (NetcdfDataset dataset = NetcdfDataset.openDataset(file.getAbsolutePath())) {\r\n        assertNotNull(dataset);\r\n        Dimension rlonDim = dataset.findDimension(\"rlon\");\r\n        assertNotNull(rlonDim);\r\n        assertEquals(5, rlonDim.getLength());\r\n        Dimension rlatDim = dataset.findDimension(\"rlat\");\r\n        assertNotNull(rlatDim);\r\n        assertEquals(5, rlatDim.getLength());\r\n        Variable rlonVar = dataset.findVariable(\"rlon\");\r\n        assertNotNull(rlonVar);\r\n        assertEquals(1, rlonVar.getDimensions().size());\r\n        assertEquals(rlonDim, rlonVar.getDimensions().get(0));\r\n        assertEquals(\"grid_longitude\", rlonVar.findAttribute(\"long_name\").getStringValue());\r\n        assertEquals(\"grid_longitude\", rlonVar.findAttribute(\"standard_name\").getStringValue());\r\n        assertEquals(\"degrees\", rlonVar.findAttribute(\"units\").getStringValue());\r\n        assertArrayEquals(new float[] { -18, -8, 2, 12, 22 }, (float[]) rlonVar.read().copyTo1DJavaArray(), (float) DELTA);\r\n        Variable rlatVar = dataset.findVariable(\"rlat\");\r\n        assertNotNull(rlatVar);\r\n        assertEquals(1, rlatVar.getDimensions().size());\r\n        assertEquals(rlatDim, rlatVar.getDimensions().get(0));\r\n        assertEquals(\"grid_latitude\", rlatVar.findAttribute(\"long_name\").getStringValue());\r\n        assertEquals(\"grid_latitude\", rlatVar.findAttribute(\"standard_name\").getStringValue());\r\n        assertEquals(\"degrees\", rlatVar.findAttribute(\"units\").getStringValue());\r\n        assertArrayEquals(new float[] { -20, -10, 0, 10, 20 }, (float[]) rlatVar.read().copyTo1DJavaArray(), (float) DELTA);\r\n        Variable projVar = dataset.findVariable(\"rotated_latitude_longitude\");\r\n        assertNotNull(projVar);\r\n        assertEquals(\"rotated_latitude_longitude\", projVar.findAttribute(\"grid_mapping_name\").getStringValue());\r\n        assertEquals(-170.0, projVar.findAttribute(\"grid_north_pole_longitude\").getNumericValue().doubleValue(), DELTA);\r\n        assertEquals(40.0, projVar.findAttribute(\"grid_north_pole_latitude\").getNumericValue().doubleValue(), DELTA);\r\n        Variable dataVar = dataset.findVariable(\"Snow_depth_water_equivalent_surface\");\r\n        assertNotNull(dataVar);\r\n        assertEquals(\"rotated_latitude_longitude\", dataVar.findAttribute(\"grid_mapping\").getStringValue());\r\n        assertEquals(2, dataVar.getDimensions().size());\r\n        assertEquals(rlatDim, dataVar.getDimensions().get(0));\r\n        assertEquals(rlonDim, dataVar.getDimensions().get(1));\r\n        assertArrayEquals(new float[] { 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124 }, (float[]) dataVar.read().copyTo1DJavaArray(), (float) DELTA);\r\n    } finally {\r\n        FileUtils.deleteQuietly(file);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findOrCreateResourceDir",
	"Comment": "returns the directory in which a resources configuration is persisted, if the directory doesnot exist it will be created.",
	"Method": "File findOrCreateResourceDir(ResourceInfo r){\r\n    Resource directory = get(r);\r\n    return directory.dir();\r\n}"
}, {
	"Path": "org.geoserver.test.SRSWfsTest.testReproject",
	"Comment": "test srs reprojection. ensure both geometry values and srs information are encoded correctly.",
	"Method": "void testReproject(){\r\n    CoordinateReferenceSystem sourceCRS = (CoordinateReferenceSystem) CRS.decode(EPSG_4283);\r\n    CoordinateReferenceSystem targetCRS = (CoordinateReferenceSystem) CRS.decode(EPSG_4326);\r\n    MathTransform transform = CRS.findMathTransform(sourceCRS, targetCRS);\r\n    GeometryFactory factory = new GeometryFactory();\r\n    Polygon srcPolygon = factory.createPolygon(factory.createLinearRing(factory.getCoordinateSequenceFactory().create(new Coordinate[] { new Coordinate(-1.2, 52.5), new Coordinate(-1.2, 52.6), new Coordinate(-1.1, 52.6), new Coordinate(-1.1, 52.5), new Coordinate(-1.2, 52.5) })), null);\r\n    Polygon targetPolygon = (Polygon) JTS.transform(srcPolygon, transform);\r\n    StringBuffer polygonBuffer = new StringBuffer();\r\n    CoordinateFormatter formatter = new CoordinateFormatter(8);\r\n    for (Coordinate coord : targetPolygon.getCoordinates()) {\r\n        formatter.format(coord.x, polygonBuffer).append(\" \");\r\n        formatter.format(coord.y, polygonBuffer).append(\" \");\r\n    }\r\n    String targetPolygonCoords = polygonBuffer.toString().trim();\r\n    Point targetPoint = (Point) JTS.transform(factory.createPoint(new Coordinate(42.58, 31.29)), transform);\r\n    String targetPointCoord = formatter.format(targetPoint.getCoordinate().x) + \" \" + formatter.format(targetPoint.getCoordinate().y);\r\n    Document doc = getAsDOM(\"wfs?request=GetFeature&version=1.1.0&typename=ex:geomContainer\" + \"&srsname=urn:x-ogc:def:crs:EPSG::4326\");\r\n    LOGGER.info(\"WFS GetFeature&typename=ex:geomContainer&srsname=urn:x-ogc:def:crs:EPSG::4326 response:\\n\" + prettyString(doc));\r\n    assertXpathEvaluatesTo(\"2\", \"/wfs:FeatureCollection/@numberOfFeatures\", doc);\r\n    assertXpathCount(2, \"//ex:geomContainer\", doc);\r\n    String id = \"1\";\r\n    assertXpathEvaluatesTo(id, \"(//ex:geomContainer)[1]/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(\"1.0\", \"(//ex:geomContainer)[1]/ex:length\", doc);\r\n    assertXpathEvaluatesTo(\"m\", \"(//ex:geomContainer)[1]/ex:length/@uom\", doc);\r\n    assertXpathEvaluatesTo(\"geom_\" + id, \"(//ex:geomContainer)[1]/ex:geom/gml:Polygon/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(EPSG_4326, \"//ex:geomContainer[1]/ex:geom/gml:Polygon/@srsName\", doc);\r\n    assertXpathEvaluatesTo(DIMENSION, \"(//ex:geomContainer)[1]/ex:geom/gml:Polygon/@srsDimension\", doc);\r\n    assertXpathEvaluatesTo(targetPolygonCoords, \"(//ex:geomContainer)[1]/ex:geom/gml:Polygon/gml:exterior/gml:LinearRing/gml:posList\", doc);\r\n    assertXpathEvaluatesTo(\"shape_\" + id, \"(//ex:geomContainer)[1]/ex:shape/gml:LineString/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(EPSG_4326, \"(//ex:geomContainer)[1]/ex:shape/gml:LineString/@srsName\", doc);\r\n    assertXpathEvaluatesTo(DIMENSION, \"(//ex:geomContainer)[1]/ex:shape/gml:LineString/@srsDimension\", doc);\r\n    assertXpathEvaluatesTo(targetPolygonCoords, \"(//ex:geomContainer)[1]/ex:shape/gml:LineString/gml:posList\", doc);\r\n    assertXpathEvaluatesTo(\"nested_one_2\", \"(//ex:geomContainer)[1]/ex:nestedFeature[1]/ex:nestedGeom/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(\"nested_one_geom_2\", \"(//ex:geomContainer)[1]/ex:nestedFeature[1]/ex:nestedGeom/ex:geom/gml:Point/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(EPSG_4326, \"(//ex:geomContainer)[1]/ex:nestedFeature[1]/ex:nestedGeom/ex:geom/gml:Point/@srsName\", doc);\r\n    assertXpathEvaluatesTo(DIMENSION, \"(//ex:geomContainer)[1]/ex:nestedFeature[1]/ex:nestedGeom/ex:geom/gml:Point/@srsDimension\", doc);\r\n    assertXpathEvaluatesTo(targetPointCoord, \"(//ex:geomContainer)[1]/ex:nestedFeature[1]/ex:nestedGeom/ex:geom/gml:Point/gml:pos\", doc);\r\n    assertXpathEvaluatesTo(\"nested_two_\" + id, \"(//ex:geomContainer)[1]/ex:nestedFeature[2]/ex:nestedGeom/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(\"nested_two_geom_\" + id, \"(//ex:geomContainer)[1]/ex:nestedFeature[2]/ex:nestedGeom/ex:geom/gml:Polygon/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(EPSG_4326, \"(//ex:geomContainer)[1]/ex:nestedFeature[2]/ex:nestedGeom/ex:geom/gml:Polygon/@srsName\", doc);\r\n    assertXpathEvaluatesTo(DIMENSION, \"(//ex:geomContainer)[1]/ex:nestedFeature[2]/ex:nestedGeom/ex:geom/gml:Polygon/@srsDimension\", doc);\r\n    assertXpathEvaluatesTo(targetPolygonCoords, \"(//ex:geomContainer)[1]/ex:nestedFeature[2]/ex:nestedGeom/ex:geom/gml:Polygon/gml:exterior/gml:LinearRing/gml:posList\", doc);\r\n    id = \"2\";\r\n    assertXpathEvaluatesTo(id, \"(//ex:geomContainer)[2]/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(\"1.0\", \"(//ex:geomContainer)[2]/ex:length\", doc);\r\n    assertXpathEvaluatesTo(\"m\", \"(//ex:geomContainer)[2]/ex:length/@uom\", doc);\r\n    assertXpathEvaluatesTo(\"geom_\" + id, \"(//ex:geomContainer)[2]/ex:geom/gml:Point/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(EPSG_4326, \"(//ex:geomContainer)[2]/ex:geom/gml:Point/@srsName\", doc);\r\n    assertXpathEvaluatesTo(DIMENSION, \"(//ex:geomContainer)[2]/ex:geom/gml:Point/@srsDimension\", doc);\r\n    assertXpathEvaluatesTo(targetPointCoord, \"(//ex:geomContainer)[2]/ex:geom/gml:Point/gml:pos\", doc);\r\n    assertXpathEvaluatesTo(\"shape_\" + id, \"(//ex:geomContainer)[2]/ex:shape/gml:LineString/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(EPSG_4326, \"(//ex:geomContainer)[2]/ex:shape/gml:LineString/@srsName\", doc);\r\n    assertXpathEvaluatesTo(DIMENSION, \"(//ex:geomContainer)[2]/ex:shape/gml:LineString/@srsDimension\", doc);\r\n    assertXpathEvaluatesTo(targetPointCoord + \" \" + targetPointCoord, \"(//ex:geomContainer)[2]/ex:shape/gml:LineString/gml:posList\", doc);\r\n    assertXpathEvaluatesTo(\"nested_one_1\", \"(//ex:geomContainer)[2]/ex:nestedFeature[1]/ex:nestedGeom/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(\"nested_one_geom_1\", \"(//ex:geomContainer)[2]/ex:nestedFeature[1]/ex:nestedGeom/ex:geom/gml:Polygon/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(EPSG_4326, \"(//ex:geomContainer)[2]/ex:nestedFeature[1]/ex:nestedGeom/ex:geom/gml:Polygon/@srsName\", doc);\r\n    assertXpathEvaluatesTo(DIMENSION, \"(//ex:geomContainer)[2]/ex:nestedFeature[1]/ex:nestedGeom/ex:geom/gml:Polygon/@srsDimension\", doc);\r\n    assertXpathEvaluatesTo(targetPolygonCoords, \"(//ex:geomContainer)[2]/ex:nestedFeature[1]/ex:nestedGeom/ex:geom/gml:Polygon/gml:exterior/gml:LinearRing/gml:posList\", doc);\r\n    assertXpathEvaluatesTo(\"nested_two_\" + id, \"(//ex:geomContainer)[2]/ex:nestedFeature[2]/ex:nestedGeom/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(\"nested_two_geom_\" + id, \"(//ex:geomContainer)[2]/ex:nestedFeature[2]/ex:nestedGeom/ex:geom/gml:Point/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(EPSG_4326, \"(//ex:geomContainer)[2]/ex:nestedFeature[2]/ex:nestedGeom/ex:geom/gml:Point/@srsName\", doc);\r\n    assertXpathEvaluatesTo(DIMENSION, \"(//ex:geomContainer)[2]/ex:nestedFeature[2]/ex:nestedGeom/ex:geom/gml:Point/@srsDimension\", doc);\r\n    assertXpathEvaluatesTo(targetPointCoord, \"(//ex:geomContainer)[2]/ex:nestedFeature[2]/ex:nestedGeom/ex:geom/gml:Point/gml:pos\", doc);\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.eo.EOCoverageResourceCodec.isValidDataset",
	"Comment": "checks if the specified coverage is a valid dataset, e.g., it has the dataset flag enabledand time dimension, and has a structured grid coverage reader backing it",
	"Method": "boolean isValidDataset(CoverageInfo ci){\r\n    Boolean dataset = ci.getMetadata().get(WCSEOMetadata.DATASET.key, Boolean.class);\r\n    DimensionInfo time = ci.getMetadata().get(ResourceInfo.TIME, DimensionInfo.class);\r\n    try {\r\n        GridCoverageReader reader = ci.getGridCoverageReader(null, GeoTools.getDefaultHints());\r\n        boolean structured = reader instanceof StructuredGridCoverage2DReader;\r\n        return dataset != null && dataset && time != null && time.isEnabled() && structured;\r\n    } catch (IOException e) {\r\n        throw new ServiceException(\"Failed to locate the grid coverage reader for coverage \" + ci.prefixedName());\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.CascadeRemovalReporter.add",
	"Comment": "adds a cataloginfo into the objects map, eventually overriding the type if the modificationis stronger that the one already registered",
	"Method": "void add(CatalogInfo ci,ModificationType type){\r\n    ModificationType oldType = objects.get(ci);\r\n    if (oldType == null || oldType.compareTo(type) > 0) {\r\n        objects.put(ci, type);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.script.ScriptPlugin.createWpsHook",
	"Comment": "creates the hook for wps processes.this default implementation returns null, subclass should override in orderto implement a custom hook.",
	"Method": "WpsHook createWpsHook(){\r\n    return new WpsHook(this);\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.support.DatabaseUtil.rebuildAsSingle",
	"Comment": "return a list of sql statements as a single string including a newline after each statement.",
	"Method": "String rebuildAsSingle(List<String> sqls){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (String sql : sqls) {\r\n        sb.append(sql).append(\"\\n\");\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.geoserver.importer.ImporterDataTest.writeStyleAndImport",
	"Comment": "helper for tests exercising the style file import function.",
	"Method": "StyleInfo writeStyleAndImport(String sld,String filename,File dir){\r\n    FileUtils.write(new File(dir, filename), sld);\r\n    ImportContext imp = importer.createContext(new Directory(dir));\r\n    importer.run(imp);\r\n    assertEquals(ImportContext.State.COMPLETE, imp.getState());\r\n    checkNoErrors(imp);\r\n    return getCatalog().getStyle(imp.getTasks().get(0).getLayer().getDefaultStyle().getId());\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.LegacyCatalogReader.namespaceTuple",
	"Comment": "convenience method for reading namespace prefix and uri from a namespace element.",
	"Method": "Map.Entry namespaceTuple(Element namespaceElement){\r\n    final String pre = namespaceElement.getAttribute(\"prefix\");\r\n    final String uri = namespaceElement.getAttribute(\"uri\");\r\n    return new Map.Entry() {\r\n        public Object getKey() {\r\n            return pre;\r\n        }\r\n        public Object getValue() {\r\n            return uri;\r\n        }\r\n        public Object setValue(Object value) {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.LegacyCatalogReader.namespaceTuple",
	"Comment": "convenience method for reading namespace prefix and uri from a namespace element.",
	"Method": "Map.Entry namespaceTuple(Element namespaceElement){\r\n    return pre;\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.LegacyCatalogReader.namespaceTuple",
	"Comment": "convenience method for reading namespace prefix and uri from a namespace element.",
	"Method": "Map.Entry namespaceTuple(Element namespaceElement){\r\n    return uri;\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.LegacyCatalogReader.namespaceTuple",
	"Comment": "convenience method for reading namespace prefix and uri from a namespace element.",
	"Method": "Map.Entry namespaceTuple(Element namespaceElement){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.HistogramUtils.getNumericBuckets",
	"Comment": "helper method that creates buckets for a numeric domain based on the provided resolution. thereturned tuple will contain the domain representation and the domain buckets.",
	"Method": "Tuple<String, List<Range>> getNumericBuckets(List<Object> domainValues,String resolution,Tuple<String, List<Range>> getNumericBuckets,double min,double max,String resolution){\r\n    resolution = resolution != null ? resolution : NUMERICAL_DEFAULT_RESOLUTION;\r\n    double finalResolution = Double.parseDouble(resolution);\r\n    int i = 0;\r\n    while ((max - min) / finalResolution >= HISTOGRAM_MAX_THRESHOLD && i < MAX_ITERATIONS) {\r\n        finalResolution += 10;\r\n        i++;\r\n    }\r\n    if ((max - min) % finalResolution == 0) {\r\n        max += finalResolution;\r\n    }\r\n    String domainString = min + \"/\" + max + \"/\" + finalResolution;\r\n    if ((max - min) / finalResolution == 1) {\r\n        boolean includeLast = (max - min) < finalResolution;\r\n        return Tuple.tuple(domainString, Collections.singletonList(NumberRange.create(min, true, max, includeLast)));\r\n    }\r\n    List<Range> buckets = new ArrayList();\r\n    for (double step = min; step < max; step += finalResolution) {\r\n        double limit = step + finalResolution;\r\n        if (limit > max) {\r\n            buckets.add(NumberRange.create(step, true, max, true));\r\n            break;\r\n        }\r\n        buckets.add(NumberRange.create(step, true, limit, false));\r\n    }\r\n    return Tuple.tuple(domainString, buckets);\r\n}"
}, {
	"Path": "org.geoserver.web.data.layer.LayerProvider.filteredItems",
	"Comment": "returns the requested page of layer objects after applying any keyword filtering set on thepage",
	"Method": "Iterator<LayerInfo> filteredItems(Long first,Long count){\r\n    final Catalog catalog = getCatalog();\r\n    final SortParam<?> sort = getSort();\r\n    final Property<LayerInfo> property = getProperty(sort);\r\n    SortBy sortOrder = null;\r\n    if (sort != null) {\r\n        if (property instanceof BeanProperty) {\r\n            final String sortProperty = ((BeanProperty<LayerInfo>) property).getPropertyPath();\r\n            sortOrder = sortBy(sortProperty, sort.isAscending());\r\n        } else if (property == ENABLED) {\r\n            sortOrder = sortBy(\"enabled\", sort.isAscending());\r\n        }\r\n    }\r\n    if (first > Integer.MAX_VALUE || first < Integer.MIN_VALUE || count > Integer.MAX_VALUE || count < Integer.MIN_VALUE) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    final Filter filter = getFilter();\r\n    Iterator<LayerInfo> items = catalog.list(LayerInfo.class, filter, first.intValue(), count.intValue(), sortOrder);\r\n    return items;\r\n}"
}, {
	"Path": "org.geoserver.script.ScriptPlugin.createFunctionHook",
	"Comment": "creates the hook for functions.this default implementation returns null, subclass should override in orderto implement a custom hook.",
	"Method": "FunctionHook createFunctionHook(){\r\n    return new FunctionHook(this);\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaTestSupport.assertXpathMatches",
	"Comment": "assert that the flattened value of an xpath expression in a document matches a regularexpression.",
	"Method": "void assertXpathMatches(String regex,String xpath,Document document){\r\n    assertTrue(evaluate(xpath, document).matches(regex));\r\n}"
}, {
	"Path": "org.geoserver.util.ReaderUtils.checkFile",
	"Comment": "checks to ensure the file is valid.returns the file passed in to allow this to wrap file creations.",
	"Method": "File checkFile(File file,boolean isDir){\r\n    if (!file.exists()) {\r\n        throw new FileNotFoundException((isDir ? \"Folder\" : \"File\") + \" does not exist: \" + file);\r\n    }\r\n    if (isDir && !file.isDirectory()) {\r\n        throw new FileNotFoundException(\"File exists but is not a directory:\" + file);\r\n    }\r\n    if (!isDir && !file.isFile()) {\r\n        throw new FileNotFoundException(\"File exists but is not a regular file:\" + file);\r\n    }\r\n    if (LOGGER.isLoggable(Level.FINER)) {\r\n        LOGGER.finer(new StringBuffer(\"File is valid: \").append(file).toString());\r\n    }\r\n    return file;\r\n}"
}, {
	"Path": "org.geoserver.wms.capabilities.LegendSampleImpl.getSampleFile",
	"Comment": "returns the cached sample for the given file, if it exists, null otherwise.",
	"Method": "Resource getSampleFile(StyleInfo style,Resource getSampleFile,String fileName){\r\n    return getSamplesFolder().get(fileName);\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.GetCoverage.handleReprojection",
	"Comment": "this method is responsible for handling reprojection of the source coverage to a certain crs.",
	"Method": "GridCoverage2D handleReprojection(GridCoverage2D coverage,CoordinateReferenceSystem targetCRS,Interpolation spatialInterpolation,Hints hints){\r\n    Utilities.ensureNonNull(\"interpolation\", spatialInterpolation);\r\n    if (CRS.equalsIgnoreMetadata(coverage.getCoordinateReferenceSystem2D(), targetCRS)) {\r\n        return coverage;\r\n    }\r\n    final CoverageProcessor processor = hints == null ? CoverageProcessor.getInstance() : CoverageProcessor.getInstance(hints);\r\n    final Operation operation = processor.getOperation(\"Resample\");\r\n    final ParameterValueGroup parameters = operation.getParameters();\r\n    parameters.parameter(\"Source\").setValue(coverage);\r\n    parameters.parameter(\"CoordinateReferenceSystem\").setValue(targetCRS);\r\n    parameters.parameter(\"GridGeometry\").setValue(null);\r\n    parameters.parameter(\"InterpolationType\").setValue(spatialInterpolation);\r\n    return (GridCoverage2D) processor.doOperation(parameters);\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDimensionsSubsetHelper.extractSubsettingEnvelope",
	"Comment": "this method is responsible for extracting the subsettingevelope from the incoming request.",
	"Method": "WCSEnvelope extractSubsettingEnvelope(){\r\n    final CoordinateReferenceSystem sourceCRS = reader.getCoordinateReferenceSystem();\r\n    WCSEnvelope sourceEnvelopeInSubsettingCRS = new WCSEnvelope(reader.getOriginalEnvelope());\r\n    if (!(subsettingCRS == null || CRS.equalsIgnoreMetadata(subsettingCRS, sourceCRS))) {\r\n        try {\r\n            sourceEnvelopeInSubsettingCRS = new WCSEnvelope(CRS.transform(reader.getOriginalEnvelope(), subsettingCRS));\r\n        } catch (Exception e) {\r\n            try {\r\n                ProjectionHandler handler = ProjectionHandlerFinder.getHandler(new ReferencedEnvelope(0, 1, 0, 1, subsettingCRS), sourceCRS, true);\r\n                if (handler != null) {\r\n                    ReferencedEnvelope validArea = handler.getValidAreaBounds();\r\n                    Envelope intersection = validArea.intersection(ReferencedEnvelope.reference(reader.getOriginalEnvelope()));\r\n                    ReferencedEnvelope re = new ReferencedEnvelope(intersection, sourceCRS);\r\n                    sourceEnvelopeInSubsettingCRS = new WCSEnvelope(re.transform(subsettingCRS, true));\r\n                } else {\r\n                    throw new WCS20Exception(\"Unable to initialize subsetting envelope\", WCS20Exception.WCS20ExceptionCode.SubsettingCrsNotSupported, subsettingCRS.toWKT(), e);\r\n                }\r\n            } catch (Exception e2) {\r\n                throw new WCS20Exception(\"Unable to initialize subsetting envelope\", WCS20Exception.WCS20ExceptionCode.SubsettingCrsNotSupported, subsettingCRS.toWKT(), e2);\r\n            }\r\n        }\r\n    }\r\n    final EList<DimensionSubsetType> requestedDimensions = request.getDimensionSubset();\r\n    if (requestedDimensions == null || requestedDimensions.size() <= 0) {\r\n        return sourceEnvelopeInSubsettingCRS;\r\n    }\r\n    int maxDimensions = 2 + enabledDimensions.size();\r\n    if (requestedDimensions.size() > maxDimensions) {\r\n        throw new WCS20Exception(\"Invalid number of dimensions\", WCS20Exception.WCS20ExceptionCode.InvalidSubsetting, Integer.toString(requestedDimensions.size()));\r\n    }\r\n    final List<String> axesNames = envelopeDimensionsMapper.getAxesNames(sourceEnvelopeInSubsettingCRS, true);\r\n    final List<String> foundDimensions = new ArrayList<String>();\r\n    WCSEnvelope subsettingEnvelope = new WCSEnvelope(sourceEnvelopeInSubsettingCRS);\r\n    Set<String> dimensionKeys = enabledDimensions.keySet();\r\n    for (DimensionSubsetType dim : requestedDimensions) {\r\n        String dimension = WCSDimensionsSubsetHelper.getDimensionName(dim);\r\n        if (WCSDimensionsSubsetHelper.TIME_NAMES.contains(dimension.toLowerCase())) {\r\n            if (dimensionKeys.contains(ResourceInfo.TIME)) {\r\n                continue;\r\n            } else {\r\n                throw new WCS20Exception(\"Invalid axis label provided: \" + dimension, WCS20Exception.WCS20ExceptionCode.InvalidAxisLabel, null);\r\n            }\r\n        }\r\n        if (WCSDimensionsSubsetHelper.ELEVATION_NAMES.contains(dimension.toLowerCase())) {\r\n            if (dimensionKeys.contains(ResourceInfo.ELEVATION)) {\r\n                continue;\r\n            } else {\r\n                throw new WCS20Exception(\"Invalid axis label provided: \" + dimension, WCS20Exception.WCS20ExceptionCode.InvalidAxisLabel, null);\r\n            }\r\n        }\r\n        boolean isCustomDimension = false;\r\n        for (String dimensionKey : dimensionKeys) {\r\n            if (dimensionKey.equalsIgnoreCase(dimension)) {\r\n                isCustomDimension = true;\r\n                break;\r\n            }\r\n        }\r\n        if (isCustomDimension) {\r\n            continue;\r\n        }\r\n        if (!axesNames.contains(dimension)) {\r\n            throw new WCS20Exception(\"Invalid axis label provided: \" + dimension, WCS20Exception.WCS20ExceptionCode.InvalidAxisLabel, dimension == null ? \"Null\" : dimension);\r\n        }\r\n        if (foundDimensions.contains(dimension)) {\r\n            throw new WCS20Exception(\"Axis label already used during subsetting\", WCS20Exception.WCS20ExceptionCode.InvalidAxisLabel, dimension);\r\n        }\r\n        foundDimensions.add(dimension);\r\n        if (dim instanceof DimensionTrimType) {\r\n            final DimensionTrimType trim = (DimensionTrimType) dim;\r\n            final double low = Double.parseDouble(trim.getTrimLow());\r\n            final double high = Double.parseDouble(trim.getTrimHigh());\r\n            final int axisIndex = envelopeDimensionsMapper.getAxisIndex(sourceEnvelopeInSubsettingCRS, dimension);\r\n            if (axisIndex < 0) {\r\n                throw new WCS20Exception(\"Invalid axis provided\", WCS20Exception.WCS20ExceptionCode.InvalidAxisLabel, dimension);\r\n            }\r\n            if (low > high && !subsettingEnvelope.isLongitude(axisIndex)) {\r\n                throw new WCS20Exception(\"Low greater than High\", WCS20Exception.WCS20ExceptionCode.InvalidSubsetting, trim.getTrimLow());\r\n            }\r\n            subsettingEnvelope.setRange(axisIndex, low, high);\r\n        } else if (dim instanceof DimensionSliceType) {\r\n            final DimensionSliceType slicing = (DimensionSliceType) dim;\r\n            final String slicePointS = slicing.getSlicePoint();\r\n            final double slicePoint = Double.parseDouble(slicePointS);\r\n            final int axisIndex = envelopeDimensionsMapper.getAxisIndex(sourceEnvelopeInSubsettingCRS, dimension);\r\n            if (axisIndex < 0) {\r\n                throw new WCS20Exception(\"Invalid axis provided\", WCS20Exception.WCS20ExceptionCode.InvalidAxisLabel, dimension);\r\n            }\r\n            AffineTransform affineTransform = RequestUtils.getAffineTransform(reader.getOriginalGridToWorld(PixelInCell.CELL_CENTER));\r\n            final double scale = axisIndex == 0 ? affineTransform.getScaleX() : -affineTransform.getScaleY();\r\n            subsettingEnvelope.setRange(axisIndex, slicePoint, slicePoint + scale);\r\n            if (sourceEnvelopeInSubsettingCRS.getMinimum(axisIndex) > slicePoint || slicePoint > sourceEnvelopeInSubsettingCRS.getMaximum(axisIndex)) {\r\n                throw new WCS20Exception(\"SlicePoint outside coverage envelope\", WCS20Exception.WCS20ExceptionCode.InvalidSubsetting, slicePointS);\r\n            }\r\n        } else {\r\n            throw new WCS20Exception(\"Invalid element found while attempting to parse dimension subsetting request\", WCS20Exception.WCS20ExceptionCode.InvalidSubsetting, dim.getClass().toString());\r\n        }\r\n    }\r\n    requestedEnvelope = new WCSEnvelope(subsettingEnvelope);\r\n    subsettingEnvelope.intersect(new GeneralEnvelope(sourceEnvelopeInSubsettingCRS));\r\n    if (subsettingEnvelope.isEmpty()) {\r\n        throw new // TODO spit our\r\n        WCS20Exception(// TODO spit our\r\n        \"Empty intersection after subsetting\", WCS20Exception.WCS20ExceptionCode.InvalidSubsetting, \"\");\r\n    }\r\n    return subsettingEnvelope;\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.response.QuickTemplate.replaceVariables",
	"Comment": "simple replacement of a set of variables in a string with their values",
	"Method": "String replaceVariables(CharSequence template,Map<String, String> variables){\r\n    StringBuilder sb = new StringBuilder(template);\r\n    for (Map.Entry<String, String> entry : variables.entrySet()) {\r\n        replaceVariable(sb, entry.getKey(), entry.getValue());\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.geoserver.sldservice.rest.ClassifierTest.getRasterSymbolizer",
	"Comment": "parses the dom, check there is just one feature type style and one rule, and a singlesymbolizer of type rastersymbolizer, and returns it",
	"Method": "RasterSymbolizer getRasterSymbolizer(Document dom){\r\n    List<Rule> rules = getRules(dom);\r\n    assertEquals(1, rules.size());\r\n    List<Symbolizer> symbolizers = rules.get(0).symbolizers();\r\n    assertEquals(1, symbolizers.size());\r\n    assertThat(symbolizers.get(0), instanceOf(RasterSymbolizer.class));\r\n    return (RasterSymbolizer) symbolizers.get(0);\r\n}"
}, {
	"Path": "org.geoserver.rest.catalog.AbstractCatalogController.isAuthenticatedAsAdmin",
	"Comment": "determines if the current user is authenticated as full administrator.",
	"Method": "boolean isAuthenticatedAsAdmin(){\r\n    return SecurityContextHolder.getContext() != null && GeoServerExtensions.bean(GeoServerSecurityManager.class).checkAuthenticationForAdminRole();\r\n}"
}, {
	"Path": "org.geoserver.wms.eo.web.EoCoverageSelectorPage.enableDimensions",
	"Comment": "check presence of time dimension and, if the layer is of band type, a custom dimension enableall dimensions found.",
	"Method": "boolean enableDimensions(CoverageInfo ci,EoLayerType type){\r\n    boolean timeDimension = false;\r\n    boolean customDimension = false;\r\n    GridCoverage2DReader reader = null;\r\n    try {\r\n        reader = (GridCoverage2DReader) ci.getGridCoverageReader(null, null);\r\n        if (reader == null) {\r\n            throw new RuntimeException(\"Unable to acquire reader for this coverageinfo: \" + ci.getName());\r\n        }\r\n        if (ci.getNativeCoverageName() != null) {\r\n            reader = SingleGridCoverage2DReader.wrap(reader, ci.getNativeCoverageName());\r\n        }\r\n        final ReaderDimensionsAccessor ra = new ReaderDimensionsAccessor(reader);\r\n        for (String domain : ra.getCustomDomains()) {\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                boolean hasRange = ra.hasRange(domain);\r\n                boolean hasResolution = ra.hasResolution(domain);\r\n                LOGGER.fine(ci.getName() + \": found \" + domain + \" dimension (hasRange: \" + hasRange + \", hasResolution: \" + hasResolution + \")\");\r\n            }\r\n            DimensionInfo dimension = new DimensionInfoImpl();\r\n            dimension.setEnabled(true);\r\n            dimension.setPresentation(DimensionPresentation.LIST);\r\n            ci.getMetadata().put(ResourceInfo.CUSTOM_DIMENSION_PREFIX + domain, dimension);\r\n            customDimension = true;\r\n        }\r\n        String elev = reader.getMetadataValue(GridCoverage2DReader.HAS_ELEVATION_DOMAIN);\r\n        if (Boolean.parseBoolean(elev)) {\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.fine(ci.getName() + \": found ELEVATION dimension\");\r\n            }\r\n            DimensionInfo dimension = new DimensionInfoImpl();\r\n            dimension.setEnabled(true);\r\n            dimension.setPresentation(DimensionPresentation.LIST);\r\n            ci.getMetadata().put(ResourceInfo.ELEVATION, dimension);\r\n        }\r\n        String time = reader.getMetadataValue(GridCoverage2DReader.HAS_TIME_DOMAIN);\r\n        if (Boolean.parseBoolean(time)) {\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.fine(ci.getName() + \": found TIME dimension\");\r\n            }\r\n            DimensionInfo dimension = new DimensionInfoImpl();\r\n            dimension.setEnabled(true);\r\n            dimension.setPresentation(DimensionPresentation.LIST);\r\n            ci.getMetadata().put(ResourceInfo.TIME, dimension);\r\n            timeDimension = true;\r\n        }\r\n    } catch (IOException e) {\r\n        if (LOGGER.isLoggable(Level.SEVERE)) {\r\n            LOGGER.log(Level.SEVERE, \"Failed to access coverage reader custom dimensions\", e);\r\n        }\r\n    }\r\n    if (type == EoLayerType.BAND_COVERAGE) {\r\n        return timeDimension && customDimension;\r\n    } else {\r\n        return timeDimension;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.sldservice.utils.classifier.RulesBuilder.jenksClassification",
	"Comment": "generate a list of rules using jenks natural breaks classification sets up only filter notsymbolizer",
	"Method": "List<Rule> jenksClassification(FeatureCollection features,String property,Class<?> propertyType,int classNumber,boolean open,boolean normalize){\r\n    return getRules(features, property, propertyType, classNumber, open, normalize, \"Jenks\");\r\n}"
}, {
	"Path": "org.geoserver.web.wicket.EnvelopePanel.setCrsRequired",
	"Comment": "makes the crs bounds a required component of the envelope. it is warmly suggested that thecrs field be made visible too",
	"Method": "void setCrsRequired(boolean crsRequired){\r\n    this.crsRequired = crsRequired;\r\n}"
}, {
	"Path": "org.geoserver.wps.remote.RemoteProcessClient.getGeoServer",
	"Comment": "accessor for global geoserver instance from the test application context.",
	"Method": "GeoServer getGeoServer(){\r\n    return (GeoServer) GeoServerExtensions.bean(\"geoServer\");\r\n}"
}, {
	"Path": "org.geoserver.ows.util.RewindableInputStream.read",
	"Comment": "reads next byte from this stream. this byte is either being read from underlying inputstreamor taken from the internal buffer in case it was already read at some point before.",
	"Method": "int read(int read,byte[] b,int off,int len){\r\n    if (null == b) {\r\n        throw new NullPointerException(\"Destination byte array is null.\");\r\n    } else if (0 == len) {\r\n        return 0;\r\n    } else if ((b.length < off) || (b.length < (off + len)) || (0 > off) || (0 > len)) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    int bytesLeft = fLength - fOffset;\r\n    if (bytesLeft == 0) {\r\n        if (fOffset == fEndOffset) {\r\n            return -1;\r\n        }\r\n        if (fMayReadChunks) {\r\n            return fInputStream.read(b, off, len);\r\n        }\r\n        int returnedVal = read();\r\n        if (returnedVal == -1) {\r\n            fEndOffset = fOffset;\r\n            return -1;\r\n        }\r\n        b[off] = (byte) returnedVal;\r\n        return 1;\r\n    }\r\n    if (fMayReadChunks) {\r\n        int readFromBuffer = (len < bytesLeft) ? len : bytesLeft;\r\n        System.arraycopy(fData, fOffset, b, off, readFromBuffer);\r\n        int readFromStream = 0;\r\n        if (len > bytesLeft) {\r\n            readFromStream = fInputStream.read(b, off + bytesLeft, len - bytesLeft);\r\n        }\r\n        fOffset += readFromBuffer;\r\n        return readFromBuffer + ((-1 == readFromStream) ? 0 : readFromStream);\r\n    } else {\r\n        if (len > bytesLeft) {\r\n            len = bytesLeft;\r\n        }\r\n        System.arraycopy(fData, fOffset, b, off, len);\r\n        fOffset += len;\r\n        return len;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.restupload.ResumableUploadCatalogResource.allowPut",
	"Comment": "put request is allow only if at least one upload is in progress",
	"Method": "boolean allowPut(){\r\n    return resumableUploadResourceManager.hasAnyResource();\r\n}"
}, {
	"Path": "org.geoserver.cluster.JmsStylesTest.searchPropertyNewValue",
	"Comment": "helper method that searches a modified property in a catalog modify event.",
	"Method": "T searchPropertyNewValue(CatalogModifyEvent event,String propertyName,Class<WorkspaceInfo> propertyType){\r\n    assertThat(event.getPropertyNames(), notNullValue());\r\n    assertThat(event.getPropertyNames().isEmpty(), not(true));\r\n    assertThat(event.getNewValues(), notNullValue());\r\n    assertThat(event.getNewValues().isEmpty(), not(true));\r\n    assertThat(event.getPropertyNames().size(), is(event.getNewValues().size()));\r\n    Object propertyValue = null;\r\n    for (int i = 0; i < event.getPropertyNames().size(); i++) {\r\n        String candidatePropertyName = event.getPropertyNames().get(i);\r\n        if (candidatePropertyName != null && candidatePropertyName.equalsIgnoreCase(propertyName)) {\r\n            propertyValue = event.getNewValues().get(i);\r\n        }\r\n    }\r\n    assertThat(propertyValue, notNullValue());\r\n    assertThat(propertyValue, instanceOf(propertyType));\r\n    return (T) propertyValue;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.eo.EOCoverageResourceCodec.getGranuleFilter",
	"Comment": "given a valid granule id returns a filter to extract it from the structured grid coveragereader",
	"Method": "Filter getGranuleFilter(String granuleId){\r\n    if (!granuleId.contains(GRANULE_SEPARATOR)) {\r\n        throw new IllegalArgumentException(\"Not a valid granule id: \" + granuleId);\r\n    }\r\n    String[] splitted = granuleId.split(GRANULE_SEPARATOR);\r\n    if (splitted.length != 2) {\r\n        throw new IllegalArgumentException(\"Not a valid granule id: \" + granuleId);\r\n    }\r\n    return FF.id(Collections.singleton(FF.featureId(splitted[1])));\r\n}"
}, {
	"Path": "org.geoserver.wps.process.GeoServerProcessors.getProcessFactory",
	"Comment": "returns the process factory instance corresponding to the specified class.",
	"Method": "ProcessFactory getProcessFactory(Class factoryClass,boolean applyFilters){\r\n    Set<ProcessFactory> factories = Processors.getProcessFactories();\r\n    for (ProcessFactory pf : factories) {\r\n        if (factoryClass.equals(pf.getClass())) {\r\n            if (!applyFilters) {\r\n                return pf;\r\n            } else {\r\n                pf = applyFilters(pf);\r\n                return pf;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.nsg.pagination.random.PageResultsWebFeatureService.getFeature",
	"Comment": "helper method that deserializes getfeature request and updates its last utilization",
	"Method": "GetFeatureType getFeature(String resultSetId){\r\n    GetFeatureType feature = null;\r\n    Transaction transaction = new DefaultTransaction(\"Update\");\r\n    try {\r\n        IndexConfigurationManager.READ_WRITE_LOCK.writeLock().lock();\r\n        DataStore currentDataStore = this.indexConfiguration.getCurrentDataStore();\r\n        SimpleFeatureStore store = (SimpleFeatureStore) currentDataStore.getFeatureSource(IndexConfigurationManager.STORE_SCHEMA_NAME);\r\n        store.setTransaction(transaction);\r\n        Filter filter = CQL.toFilter(\"ID = '\" + resultSetId + \"'\");\r\n        store.modifyFeatures(\"updated\", new Date().getTime(), filter);\r\n        Resource storageResource = this.indexConfiguration.getStorageResource();\r\n        try (ObjectInputStream is = new ObjectInputStream(new FileInputStream(new File(storageResource.dir(), resultSetId + \".feature\")))) {\r\n            RequestData data = (RequestData) is.readObject();\r\n            if (data == null) {\r\n                KvpRequestReader kvpReader = Dispatcher.findKvpRequestReader(GetFeatureType.class);\r\n                Object requestBean = kvpReader.createRequest();\r\n                feature = (GetFeatureType) kvpReader.read(requestBean, data.getKvp(), data.getRawKvp());\r\n            } else {\r\n                byte[] bytes = data.getPostRequest().getBytes(StandardCharsets.UTF_8.name());\r\n                ByteArrayInputStream input = new ByteArrayInputStream(bytes);\r\n                feature = (GetFeatureType) wfsXmlReader.read(null, new InputStreamReader(input), Collections.emptyMap());\r\n            }\r\n        }\r\n    } catch (Exception t) {\r\n        transaction.rollback();\r\n        throw new RuntimeException(\"Error on retrive feature\", t);\r\n    } finally {\r\n        transaction.close();\r\n        IndexConfigurationManager.READ_WRITE_LOCK.writeLock().unlock();\r\n    }\r\n    return feature;\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.OSEOTestSupport.setupBasicOpenSearch",
	"Comment": "sets up a h2 based opensearchaccess and configures opensearch for eo to use it",
	"Method": "void setupBasicOpenSearch(SystemTestData testData,Catalog cat,GeoServer gs,boolean populateGranulesTable){\r\n    DataStoreInfo jdbcDs = cat.getFactory().createDataStore();\r\n    jdbcDs.setName(\"oseo_jdbc\");\r\n    WorkspaceInfo ws = cat.getDefaultWorkspace();\r\n    jdbcDs.setWorkspace(ws);\r\n    jdbcDs.setEnabled(true);\r\n    Map params = jdbcDs.getConnectionParameters();\r\n    params.putAll(JDBCOpenSearchAccessTest.getFixture());\r\n    cat.add(jdbcDs);\r\n    JDBCDataStore h2 = (JDBCDataStore) jdbcDs.getDataStore(null);\r\n    JDBCOpenSearchAccessTest.populateTestDatabase(h2, populateGranulesTable);\r\n    DataStoreInfo osDs = cat.getFactory().createDataStore();\r\n    osDs.setName(\"oseo\");\r\n    osDs.setWorkspace(ws);\r\n    osDs.setEnabled(true);\r\n    params = osDs.getConnectionParameters();\r\n    params.put(\"dbtype\", \"opensearch-eo-jdbc\");\r\n    params.put(\"database\", jdbcDs.getWorkspace().getName() + \":\" + jdbcDs.getName());\r\n    params.put(\"store\", jdbcDs.getWorkspace().getName() + \":\" + jdbcDs.getName());\r\n    params.put(\"repository\", null);\r\n    cat.add(osDs);\r\n    OSEOInfo service = gs.getService(OSEOInfo.class);\r\n    service.setOpenSearchAccessStoreId(osDs.getId());\r\n    gs.save(service);\r\n    GeoServerInfo global = gs.getGlobal();\r\n    global.getSettings().getContact().setContactOrganization(\"GeoServer\");\r\n    gs.save(global);\r\n}"
}, {
	"Path": "org.geoserver.gwc.GWC.addEmbeddedGridSet",
	"Comment": "add the provided grid set id to the list of geoserver grid sets that cannot be edited by theuser.",
	"Method": "void addEmbeddedGridSet(String gridSetId){\r\n    geoserverEmbeddedGridSets.add(gridSetId);\r\n}"
}, {
	"Path": "org.geoserver.gwc.layer.GeoServerTileLayer.getLegendSample",
	"Comment": "helper that gets the legendsample bean from spring context when needed.",
	"Method": "LegendSample getLegendSample(){\r\n    if (legendSample == null) {\r\n        legendSample = GeoServerExtensions.bean(LegendSample.class);\r\n    }\r\n    return legendSample;\r\n}"
}, {
	"Path": "org.geoserver.util.ReaderUtils.getChildElements",
	"Comment": "getchildelements purpose.used to help with xml manipulations. returnschild elements of the specified name.an exception occurs when the node is required and not found.",
	"Method": "Element[] getChildElements(Element root,String name,Element[] getChildElements,Element root,String name,boolean mandatory){\r\n    final List<Element> elements = new ArrayList<Element>();\r\n    Node child = root.getFirstChild();\r\n    while (child != null) {\r\n        if (child.getNodeType() == Node.ELEMENT_NODE) {\r\n            if (name.equals(child.getNodeName())) {\r\n                elements.add((Element) child);\r\n            }\r\n        }\r\n        child = child.getNextSibling();\r\n    }\r\n    if (mandatory && (elements.isEmpty())) {\r\n        throw new Exception(root.getNodeName() + \" does not contains a child element named \" + name);\r\n    }\r\n    return (Element[]) elements.toArray(new Element[0]);\r\n}"
}, {
	"Path": "org.geoserver.kml.KmlEncodingContext.addKmzGroundOverlay",
	"Comment": "adds a layer to be generated as ground overlay in the kmz package",
	"Method": "void addKmzGroundOverlay(String imagePath,Layer layer){\r\n    if (!kmz) {\r\n        throw new IllegalStateException(\"Cannot add ground \" + \"overlay layers, the output is not supposed to be a KMZ\");\r\n    }\r\n    this.kmzGroundOverlays.put(imagePath, layer);\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.ReaderUtils.getIntAttribute",
	"Comment": "getintattribute purpose.used to help with xml manipulations. returns the first child integer attribute of thespecified name. an exception occurs when the node is required and not found.",
	"Method": "int getIntAttribute(Element elem,String attName,boolean mandatory,int defaultValue){\r\n    String attValue = getAttribute(elem, attName, mandatory);\r\n    if (!mandatory && (attValue == null)) {\r\n        return defaultValue;\r\n    }\r\n    try {\r\n        return Integer.parseInt(attValue);\r\n    } catch (Exception ex) {\r\n        if (mandatory) {\r\n            throw new Exception(attName + \" attribute of element \" + elem.getNodeName() + \" must be an integer, but it's '\" + attValue + \"'\");\r\n        } else {\r\n            return defaultValue;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.data.settings.SettingsPluginPanelInfo.setPriority",
	"Comment": "method for setting the priority of the object. this is used for ordering the various pluginpanels.",
	"Method": "void setPriority(int priority){\r\n    this.priority = priority;\r\n}"
}, {
	"Path": "org.geoserver.catalog.CatalogBuilder.getDefaultStyle",
	"Comment": "returns the default style for the specified resource, or null if the layer is vector andgeometryless",
	"Method": "StyleInfo getDefaultStyle(ResourceInfo resource){\r\n    if (resource instanceof CoverageInfo || resource instanceof WMSLayerInfo || resource instanceof WMTSLayerInfo)\r\n        return catalog.getStyleByName(StyleInfo.DEFAULT_RASTER);\r\n    String styleName;\r\n    FeatureTypeInfo featureType = (FeatureTypeInfo) resource;\r\n    if (featureType.getFeatureType() == null) {\r\n        return null;\r\n    }\r\n    GeometryDescriptor gd = featureType.getFeatureType().getGeometryDescriptor();\r\n    if (gd == null) {\r\n        return null;\r\n    }\r\n    Class gtype = gd.getType().getBinding();\r\n    if (Point.class.isAssignableFrom(gtype) || MultiPoint.class.isAssignableFrom(gtype)) {\r\n        styleName = StyleInfo.DEFAULT_POINT;\r\n    } else if (LineString.class.isAssignableFrom(gtype) || MultiLineString.class.isAssignableFrom(gtype)) {\r\n        styleName = StyleInfo.DEFAULT_LINE;\r\n    } else if (Polygon.class.isAssignableFrom(gtype) || MultiPolygon.class.isAssignableFrom(gtype)) {\r\n        styleName = StyleInfo.DEFAULT_POLYGON;\r\n    } else if (Point.class.isAssignableFrom(gtype) || MultiPoint.class.isAssignableFrom(gtype)) {\r\n        styleName = StyleInfo.DEFAULT_POINT;\r\n    } else {\r\n        styleName = StyleInfo.DEFAULT_GENERIC;\r\n    }\r\n    return catalog.getStyleByName(styleName);\r\n}"
}, {
	"Path": "org.geoserver.catalog.LayerGroupHelper.checkStyleGroupLoops",
	"Comment": "check if a style group contains the enclosing layer group, or other recursive structures.",
	"Method": "boolean checkStyleGroupLoops(StyleInfo styleGroup,LayerGroupInfo group,Stack<LayerGroupInfo> path){\r\n    try {\r\n        StyledLayerDescriptor sld = styleGroup.getSLD();\r\n        final boolean[] hasLoop = { false };\r\n        sld.accept(new GeoServerSLDVisitorAdapter((Catalog) GeoServerExtensions.bean(\"catalog\"), group.getBounds() == null ? null : group.getBounds().getCoordinateReferenceSystem()) {\r\n            private final IllegalStateException recursionException = new IllegalStateException(\"Style group contains recursive structure\");\r\n            @Override\r\n            public void visit(StyledLayerDescriptor sld) {\r\n                try {\r\n                    super.visit(sld);\r\n                } catch (IllegalStateException e) {\r\n                    if (recursionException.equals(e)) {\r\n                        hasLoop[0] = true;\r\n                    } else {\r\n                        throw e;\r\n                    }\r\n                }\r\n            }\r\n            @Override\r\n            public PublishedInfo visitNamedLayerInternal(StyledLayer namedLayer) {\r\n                if (namedLayer.getName() != null && namedLayer.getName().equals(group.getName())) {\r\n                    throw recursionException;\r\n                }\r\n                LayerGroupInfo child = catalog.getLayerGroupByName(namedLayer.getName());\r\n                if (child != null) {\r\n                    if (isGroupInStack(child, path)) {\r\n                        path.push(child);\r\n                        throw recursionException;\r\n                    } else if (checkLoops(child, path)) {\r\n                        throw recursionException;\r\n                    }\r\n                    return child;\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        return hasLoop[0];\r\n    } catch (IllegalStateException | IOException | ServiceException | UncheckedIOException | UnsupportedOperationException e) {\r\n        LOGGER.log(Level.WARNING, \"Error extracting layers from Style Group '\" + styleGroup.getName() + \"'. Skipping...\", e);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.LayerGroupHelper.checkStyleGroupLoops",
	"Comment": "check if a style group contains the enclosing layer group, or other recursive structures.",
	"Method": "boolean checkStyleGroupLoops(StyleInfo styleGroup,LayerGroupInfo group,Stack<LayerGroupInfo> path){\r\n    try {\r\n        super.visit(sld);\r\n    } catch (IllegalStateException e) {\r\n        if (recursionException.equals(e)) {\r\n            hasLoop[0] = true;\r\n        } else {\r\n            throw e;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.LayerGroupHelper.checkStyleGroupLoops",
	"Comment": "check if a style group contains the enclosing layer group, or other recursive structures.",
	"Method": "boolean checkStyleGroupLoops(StyleInfo styleGroup,LayerGroupInfo group,Stack<LayerGroupInfo> path){\r\n    if (namedLayer.getName() != null && namedLayer.getName().equals(group.getName())) {\r\n        throw recursionException;\r\n    }\r\n    LayerGroupInfo child = catalog.getLayerGroupByName(namedLayer.getName());\r\n    if (child != null) {\r\n        if (isGroupInStack(child, path)) {\r\n            path.push(child);\r\n            throw recursionException;\r\n        } else if (checkLoops(child, path)) {\r\n            throw recursionException;\r\n        }\r\n        return child;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.wms.capabilities.DimensionHelper.allDoubles",
	"Comment": "returns true if all the values in the set are double instances",
	"Method": "boolean allDoubles(TreeSet<? extends Object> values){\r\n    for (Object value : values) {\r\n        if (!(value instanceof Double)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexMongoDBSupport.insertJson",
	"Comment": "helper method that reads a json object from a file and inserts it in the provided databaseand collection.",
	"Method": "void insertJson(String databaseName,String collectionName,String json){\r\n    org.bson.Document document = org.bson.Document.parse(json);\r\n    MONGO_CLIENT.getDatabase(databaseName).getCollection(collectionName).insertOne(document);\r\n    BasicDBObject indexObject = new BasicDBObject();\r\n    indexObject.put(\"geometry\", \"2dsphere\");\r\n    MONGO_CLIENT.getDatabase(databaseName).getCollection(collectionName).createIndex(indexObject);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.postAsDOM",
	"Comment": "executes an ows request using the post method and returns the result as an xml document.",
	"Method": "Document postAsDOM(String path,Document postAsDOM,String path,List<Exception> validationErrors,Document postAsDOM,String path,String xml,Document postAsDOM,String path,String xml,int expectedStatusCode,Document postAsDOM,String path,String xml,List<Exception> validationErrors){\r\n    return dom(post(path, xml));\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.GeorectifyCoverage.buildWarpArguments",
	"Comment": "a simple utility method setting up the command arguments for gdalwarp",
	"Method": "List<String> buildWarpArguments(List<String> targetEnvelope,Integer width,Integer height,String targetCrs,Integer order,String inputFilePath,String outputFilePath,List<String> warpingParameters){\r\n    return new ArrayList<String>() {\r\n        {\r\n            if (targetEnvelope != null && targetEnvelope.size() > 0) {\r\n                add(\"-te\");\r\n                addAll(targetEnvelope);\r\n            }\r\n            if (width != null && height != null) {\r\n                add(\"-ts\");\r\n                add(Integer.toString(width));\r\n                add(Integer.toString(height));\r\n            }\r\n            add(\"-t_srs\");\r\n            add(targetCrs);\r\n            if (order != null) {\r\n                add(\"-order\");\r\n                add(Integer.toString(order));\r\n            }\r\n            addAll(warpingParameters);\r\n            add(inputFilePath);\r\n            add(outputFilePath);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.geoserver.security.SecureCatalogImpl.filterLayers",
	"Comment": "given a list of layers, returns a copy of it containing only the layers the user can access",
	"Method": "List<LayerInfo> filterLayers(Filter filter,List<LayerInfo> filterLayers,Authentication user,List<LayerInfo> layers){\r\n    List<LayerInfo> result = new ArrayList<LayerInfo>();\r\n    for (LayerInfo original : layers) {\r\n        LayerInfo secured = checkAccess(user, original, MixedModeBehavior.HIDE);\r\n        if (secured != null)\r\n            result.add(secured);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDimensionsSubsetHelper.setCoverageDimensionProperty",
	"Comment": "add an entry in the coverage properties map, containing the value of the specifiedcoveragedimension",
	"Method": "void setCoverageDimensionProperty(Map properties,GridCoverageRequest coverageRequest,DimensionBean coverageDimension){\r\n    Utilities.ensureNonNull(\"properties\", properties);\r\n    Utilities.ensureNonNull(\"coverageDimension\", coverageDimension);\r\n    final DimensionType dimensionType = coverageDimension.getDimensionType();\r\n    Object value = null;\r\n    switch(dimensionType) {\r\n        case TIME:\r\n            value = coverageRequest.getTemporalSubset();\r\n            break;\r\n        case ELEVATION:\r\n            value = coverageRequest.getElevationSubset();\r\n            break;\r\n        case CUSTOM:\r\n            Map<String, List<Object>> dimensionsSubset = coverageRequest.getDimensionsSubset();\r\n            List<Object> elements = dimensionsSubset == null ? null : dimensionsSubset.get(coverageDimension.getName().toUpperCase());\r\n            if (elements == null) {\r\n                throw new IllegalArgumentException(\"No dimension subset has been found\");\r\n            }\r\n            if (elements.size() > 1) {\r\n                throw new UnsupportedOperationException(\"Multiple elements in additional dimensions are not supported on splitted requests\");\r\n            }\r\n            value = elements.get(0);\r\n            break;\r\n    }\r\n    properties.put(coverageDimension.getName(), value);\r\n}"
}, {
	"Path": "org.geoserver.kml.icons.Icons.getSpecifiedSize",
	"Comment": "get the size of the given graphic when applied to the given feature",
	"Method": "Double getSpecifiedSize(Graphic g,Feature f){\r\n    if (g.getSize() != null) {\r\n        return g.getSize().evaluate(f, Double.class);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findLayerGroupDir",
	"Comment": "returns the directory in which global layer groups are persisted, if the directory does notexist null is returned.",
	"Method": "File findLayerGroupDir(){\r\n    Resource resource = getLayerGroups();\r\n    return Resources.directory(resource);\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaTestSupport.assertNotBlank",
	"Comment": "for wms tests.asserts that the image is not blank, in the sense that there must be pixels different fromthe passed background color.",
	"Method": "void assertNotBlank(String testName,BufferedImage image,Color bgColor){\r\n    int pixelsDiffer = countNonBlankPixels(testName, image, bgColor);\r\n    assertTrue(testName + \" image is completely blank\", 0 < pixelsDiffer);\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerApplication.getBean",
	"Comment": "loads a bean from the spring application context with a specific name.",
	"Method": "Object getBean(String name){\r\n    return GeoServerExtensions.bean(name);\r\n}"
}, {
	"Path": "org.geoserver.csw.store.CatalogStoreCapabilities.getDomainQueriables",
	"Comment": "returns the list of queriable properties for which an enumeration of the domain makes sense",
	"Method": "List<Name> getDomainQueriables(Name typeName){\r\n    return descriptors.get(typeName).getQueryables();\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexMongoDBSupport.moveResourceToTempDir",
	"Comment": "helper method that moves a resource to the tests temporary directory and return the resourcefile path.",
	"Method": "File moveResourceToTempDir(String resourcePath,String resourceName){\r\n    File outputFile = new File(ROOT_DIRECTORY.toFile(), resourceName);\r\n    try (InputStream input = ComplexMongoDBSupport.class.getResourceAsStream(resourcePath);\r\n        OutputStream output = new FileOutputStream(outputFile)) {\r\n        IOUtils.copy(input, output);\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error moving resource to temporary directory.\", exception);\r\n    }\r\n    return outputFile;\r\n}"
}, {
	"Path": "org.geoserver.ogr.core.Format.getFormatAdapters",
	"Comment": "returns the configured format adapters, or an empty list if none was setup",
	"Method": "List<FormatAdapter> getFormatAdapters(){\r\n    if (formatAdapters == null) {\r\n        formatAdapters = new ArrayList();\r\n    }\r\n    return formatAdapters;\r\n}"
}, {
	"Path": "org.geoserver.security.impl.DefaultResourceAccessManager.getLayerGroupPath",
	"Comment": "returns the possible location of the group in the secured tree based on name and workspace",
	"Method": "String[] getLayerGroupPath(LayerGroupInfo layerGroup){\r\n    if (layerGroup.getWorkspace() == null) {\r\n        return new String[] { layerGroup.getName() };\r\n    } else {\r\n        return new String[] { layerGroup.getWorkspace().getName(), layerGroup.getName() };\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.script.ScriptFileWatcher.readIfModified",
	"Comment": "create a new script engine and evaluate the script if modified since the last call to read.otherwise return the existing engine.",
	"Method": "ScriptEngine readIfModified(){\r\n    if (isModified()) {\r\n        return read();\r\n    } else {\r\n        return engine;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.ResolvingProxy.create",
	"Comment": "wraps an object in the proxy, specifying a prefix for the reference.",
	"Method": "T create(String ref,Class<T> clazz,T create,String ref,String prefix,Class<T> clazz){\r\n    InvocationHandler h = new ResolvingProxy(ref, prefix);\r\n    T proxy;\r\n    try {\r\n        Constructor<T> constructor = PROXY_CLASS_CONSTRUCTOR_CACHE.get(clazz);\r\n        if (constructor == null) {\r\n            Class proxyClass = Proxy.getProxyClass(clazz.getClassLoader(), clazz);\r\n            constructor = proxyClass.getConstructor(new Class[] { InvocationHandler.class });\r\n        }\r\n        proxy = (T) constructor.newInstance(new Object[] { h });\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    return proxy;\r\n}"
}, {
	"Path": "org.geoserver.taskmanager.util.TaskManagerTaskUtil.getDependentRawValues",
	"Comment": "get dependent values for an attribute with respect to a particular action",
	"Method": "List<String> getDependentRawValues(String action,Attribute attribute,Configuration config){\r\n    List<String> values = new ArrayList<String>();\r\n    for (Parameter parameter : dataUtil.getAssociatedParameters(attribute, config)) {\r\n        TaskType taskType = taskTypes.get(parameter.getTask().getType());\r\n        ParameterInfo info = taskType.getParameterInfo().get(parameter.getName());\r\n        if (info.getType().getActions().contains(action)) {\r\n            for (ParameterInfo dependsOn : info.getDependsOn()) {\r\n                values.add(getRawParameterValue(parameter.getTask().getParameters().get(dependsOn.getName())));\r\n            }\r\n            return values;\r\n        }\r\n    }\r\n    return values;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.GetCoverage.computeRequestedResolution",
	"Comment": "parse the scaling type applied to that request and return a resolution satisfying thatscaling.",
	"Method": "double[] computeRequestedResolution(ScalingType scaling,Envelope subset,double nativeResX,double nativeResY){\r\n    ScalingPolicy policy = ScalingPolicy.getPolicy(scaling);\r\n    double[] requestedResolution = new double[2];\r\n    if (policy == ScalingPolicy.ScaleToSize || policy == ScalingPolicy.ScaleToExtent) {\r\n        int[] scalingSize = ScalingPolicy.getTargetSize(scaling);\r\n        final GridToEnvelopeMapper mapper = new GridToEnvelopeMapper(new GridEnvelope2D(0, 0, scalingSize[0], scalingSize[1]), subset);\r\n        AffineTransform scalingTransform = mapper.createAffineTransform();\r\n        requestedResolution[0] = XAffineTransform.getScaleX0(scalingTransform);\r\n        requestedResolution[1] = XAffineTransform.getScaleY0(scalingTransform);\r\n    } else {\r\n        double[] scalingFactors = ScalingPolicy.getScaleFactors(scaling);\r\n        requestedResolution[0] = nativeResX / scalingFactors[0];\r\n        requestedResolution[1] = nativeResY / scalingFactors[1];\r\n    }\r\n    return requestedResolution;\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.NetCDFCRSWriter.addCoordinateVariable",
	"Comment": "add a coordinate variable to the dataset, along with the related dimension. finally, add thecreated dimension to the coordinates map",
	"Method": "void addCoordinateVariable(NetCDFCoordinate netCDFCoordinate,int size,double min,double period){\r\n    String dimensionName = netCDFCoordinate.getDimensionName();\r\n    String standardName = netCDFCoordinate.getStandardName();\r\n    final Dimension dimension = writer.addDimension(null, dimensionName, size);\r\n    final ArrayFloat dimensionData = new ArrayFloat(new int[] { size });\r\n    final Index index = dimensionData.getIndex();\r\n    final Variable coordinateVariable = writer.addVariable(null, netCDFCoordinate.getShortName(), DataType.FLOAT, dimensionName);\r\n    writer.addVariableAttribute(coordinateVariable, new Attribute(NetCDFUtilities.LONG_NAME, netCDFCoordinate.getLongName()));\r\n    writer.addVariableAttribute(coordinateVariable, new Attribute(NetCDFUtilities.UNITS, netCDFCoordinate.getUnits()));\r\n    if (standardName != null && !standardName.isEmpty()) {\r\n        writer.addVariableAttribute(coordinateVariable, new Attribute(NetCDFUtilities.STANDARD_NAME, standardName));\r\n    }\r\n    for (int pos = 0; pos < size; pos++) {\r\n        // new Float(ymax - (new Float(yPos).floatValue() * periodY)).floatValue());\r\n        dimensionData.setFloat(index.set(pos), new Float(min + (new Float(pos).floatValue() * period)).floatValue());\r\n    }\r\n    final NetCDFDimensionMapping dimensionMapper = new NetCDFDimensionMapping(dimensionName);\r\n    dimensionMapper.setNetCDFDimension(dimension);\r\n    dimensionMapper.setDimensionValues(new DimensionValuesArray(dimensionData));\r\n    coordinatesDimensions.put(dimensionName, dimensionMapper);\r\n}"
}, {
	"Path": "org.geoserver.GeoServerConfigurationLock.lock",
	"Comment": "opens a lock in the specified mode. to avoid deadlocks make sure the corresponding unlockmethod is called as well before the code exits",
	"Method": "void lock(LockType type){\r\n    if (!enabled) {\r\n        return;\r\n    }\r\n    Lock lock = getLock(type);\r\n    lock.lock();\r\n    currentLock.set(type);\r\n    if (LOGGER.isLoggable(LEVEL)) {\r\n        LOGGER.log(LEVEL, \"Thread \" + Thread.currentThread().getId() + \" got the lock in mode \" + type);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.platform.resource.Resources.exists",
	"Comment": "test if the file or directory denoted by this resource exists.",
	"Method": "boolean exists(Resource resource){\r\n    return resource != null && resource.getType() != Resource.Type.UNDEFINED;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.WCSEnvelope.intersect",
	"Comment": "checks if this envelope intersects the provided one, taking into account the case of datelinecrossing.",
	"Method": "void intersect(GeneralEnvelope other){\r\n    assert other.getDimension() == dimensions : other;\r\n    assert CRS.equalsIgnoreMetadata(crs, other.getCoordinateReferenceSystem()) : other;\r\n    if (isCrossingDateline()) {\r\n        GeneralEnvelope[] normalizedEnvelopes = getNormalizedEnvelopes();\r\n        for (GeneralEnvelope ge : normalizedEnvelopes) {\r\n            ge.intersect(other);\r\n        }\r\n        for (int i = 0; i < dimensions; i++) {\r\n            if (i == longitudeDimension) {\r\n                if (normalizedEnvelopes[0].getSpan(i) == 0) {\r\n                    ordinates[i] = normalizedEnvelopes[1].getMinimum(i);\r\n                    ordinates[i + dimensions] = normalizedEnvelopes[1].getMaximum(i);\r\n                } else if (normalizedEnvelopes[1].getSpan(i) == 0) {\r\n                    ordinates[i] = normalizedEnvelopes[0].getMinimum(i);\r\n                    ordinates[i + dimensions] = normalizedEnvelopes[0].getMaximum(i);\r\n                } else {\r\n                    ordinates[i] = normalizedEnvelopes[0].getMinimum(i);\r\n                    ordinates[i + dimensions] = normalizedEnvelopes[1].getMaximum(i);\r\n                }\r\n            } else {\r\n                ordinates[i] = normalizedEnvelopes[0].getMinimum(i);\r\n                ordinates[i + dimensions] = normalizedEnvelopes[0].getMaximum(i);\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = 0; i < dimensions; i++) {\r\n            double min = Math.max(ordinates[i], other.getMinimum(i));\r\n            double max = Math.min(ordinates[i + dimensions], other.getMaximum(i));\r\n            if (min > max) {\r\n                min = max = 0.5 * (min + max);\r\n            }\r\n            ordinates[i] = min;\r\n            ordinates[i + dimensions] = max;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.web.auth.SecurityFilterChainsPanel.handleException",
	"Comment": "helper for handling an exception by reporting it as an error on the feedback panel",
	"Method": "void handleException(Exception e,Component target){\r\n    Serializable msg = null;\r\n    if (e instanceof SecurityConfigException) {\r\n        SecurityConfigException sce = (SecurityConfigException) e;\r\n        msg = new StringResourceModel(\"security.\" + sce.getId()).setParameters(sce.getArgs()).getObject();\r\n    } else {\r\n        msg = e;\r\n    }\r\n    (target != null ? target : getPage()).error(msg);\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.ReaderUtils.getChildElements",
	"Comment": "getchildelements purpose.used to help with xml manipulations. returnschild elements of the specified name.an exception occurs when the node is required and not found.",
	"Method": "Element[] getChildElements(Element root,String name,Element[] getChildElements,Element root,String name,boolean mandatory){\r\n    ArrayList elements = new ArrayList();\r\n    Node child = root.getFirstChild();\r\n    while (child != null) {\r\n        if (child.getNodeType() == Node.ELEMENT_NODE) {\r\n            if (name.equals(child.getNodeName())) {\r\n                elements.add((Element) child);\r\n            }\r\n        }\r\n        child = child.getNextSibling();\r\n    }\r\n    if (mandatory && (elements.isEmpty())) {\r\n        throw new Exception(root.getNodeName() + \" does not contains a child element named \" + name);\r\n    }\r\n    return (Element[]) elements.toArray(new Element[0]);\r\n}"
}, {
	"Path": "org.vfny.geoserver.util.DataStoreUtils.listDataStoresDescriptions",
	"Comment": "returns the descriptions for the available datastores.arrrg! put these in the select box.",
	"Method": "List listDataStoresDescriptions(){\r\n    List list = new ArrayList();\r\n    for (Iterator i = getAvailableDataStoreFactories().iterator(); i.hasNext(); ) {\r\n        DataAccessFactory factory = (DataAccessFactory) i.next();\r\n        initializeDataStoreFactory(factory);\r\n        list.add(factory.getDisplayName());\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.eo.response.GranuleCoverageExtension.getGranuleId",
	"Comment": "returns the coverage identifier related to the specified coverageid, or null if the syntax isincorrect",
	"Method": "String getGranuleId(String coverageId){\r\n    if (!coverageId.contains(GRANULE_SEPARATOR)) {\r\n        return null;\r\n    }\r\n    String[] splitted = coverageId.split(GRANULE_SEPARATOR);\r\n    if (splitted.length != 2) {\r\n        return null;\r\n    } else {\r\n        return splitted[1];\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.config.util.LegacyConfigurationImporter.imprt",
	"Comment": "imports configuration from a geoserver data directory into the configuration.",
	"Method": "void imprt(File dir){\r\n    GeoServerFactory factory = geoServer.getFactory();\r\n    File servicesFile = new File(dir, \"services.xml\");\r\n    if (!servicesFile.exists()) {\r\n        throw new FileNotFoundException(\"Could not find services.xml under:\" + dir.getAbsolutePath());\r\n    }\r\n    LegacyServicesReader reader = new LegacyServicesReader();\r\n    reader.read(servicesFile);\r\n    GeoServerInfo info = factory.createGlobal();\r\n    Map<String, Object> global = reader.global();\r\n    info.setVerbose(get(global, \"verbose\", boolean.class));\r\n    info.setVerboseExceptions(get(global, \"verboseExceptions\", boolean.class));\r\n    info.setNumDecimals(get(global, \"numDecimals\", int.class, 4));\r\n    info.setCharset((String) global.get(\"charSet\"));\r\n    info.setUpdateSequence(get(global, \"updateSequence\", int.class).longValue());\r\n    info.setOnlineResource(get(global, \"onlineResource\", String.class));\r\n    info.setProxyBaseUrl(get(global, \"ProxyBaseUrl\", String.class));\r\n    Map<String, Object> contact = reader.contact();\r\n    ContactInfo contactInfo = factory.createContact();\r\n    contactInfo.setContactPerson((String) contact.get(\"ContactPerson\"));\r\n    contactInfo.setContactOrganization((String) contact.get(\"ContactOrganization\"));\r\n    contactInfo.setContactVoice((String) contact.get(\"ContactVoiceTelephone\"));\r\n    contactInfo.setContactFacsimile((String) contact.get(\"ContactFacsimileTelephone\"));\r\n    contactInfo.setContactPosition((String) contact.get(\"ContactPosition\"));\r\n    contactInfo.setContactEmail((String) contact.get(\"ContactElectronicMailAddress\"));\r\n    contactInfo.setAddress((String) contact.get(\"Address\"));\r\n    contactInfo.setAddressType((String) contact.get(\"AddressType\"));\r\n    contactInfo.setAddressCity((String) contact.get(\"City\"));\r\n    contactInfo.setAddressCountry((String) contact.get(\"Country\"));\r\n    contactInfo.setAddressState((String) contact.get(\"StateOrProvince\"));\r\n    contactInfo.setAddressPostalCode((String) contact.get(\"PostCode\"));\r\n    info.setContact(contactInfo);\r\n    JAIInfo jai = new JAIInfoImpl();\r\n    jai.setMemoryCapacity((Double) value(global.get(\"JaiMemoryCapacity\"), JAIInfoImpl.DEFAULT_MemoryCapacity));\r\n    jai.setMemoryThreshold((Double) value(global.get(\"JaiMemoryThreshold\"), JAIInfoImpl.DEFAULT_MemoryThreshold));\r\n    jai.setTileThreads((Integer) value(global.get(\"JaiTileThreads\"), JAIInfoImpl.DEFAULT_TileThreads));\r\n    jai.setTilePriority((Integer) value(global.get(\"JaiTilePriority\"), JAIInfoImpl.DEFAULT_TilePriority));\r\n    jai.setJpegAcceleration((Boolean) value(global.get(\"JaiJPEGNative\"), JAIInfoImpl.DEFAULT_JPEGNative));\r\n    jai.setPngAcceleration((Boolean) value(global.get(\"JaiPNGNative\"), JAIInfoImpl.DEFAULT_PNGNative));\r\n    jai.setRecycling((Boolean) value(global.get(\"JaiRecycling\"), JAIInfoImpl.DEFAULT_Recycling));\r\n    jai.setAllowNativeMosaic((Boolean) value(global.get(\"JaiMosaicNative\"), JAIInfoImpl.DEFAULT_MosaicNative));\r\n    info.setJAI(jai);\r\n    geoServer.setGlobal(info);\r\n    LoggingInfo logging = factory.createLogging();\r\n    logging.setLevel((String) global.get(\"log4jConfigFile\"));\r\n    logging.setLocation((String) global.get(\"logLocation\"));\r\n    if (global.get(\"suppressStdOutLogging\") != null) {\r\n        logging.setStdOutLogging(!get(global, \"suppressStdOutLogging\", Boolean.class));\r\n    } else {\r\n        logging.setStdOutLogging(true);\r\n    }\r\n    geoServer.setLogging(logging);\r\n    for (LegacyServiceLoader sl : GeoServerExtensions.extensions(LegacyServiceLoader.class)) {\r\n        try {\r\n            sl.setReader(reader);\r\n            ServiceInfo service = sl.load(geoServer);\r\n            if (service != null) {\r\n                LOGGER.info(\"Loading service '\" + service.getId() + \"'\");\r\n                geoServer.add(service);\r\n            }\r\n        } catch (Exception e) {\r\n            String msg = \"Error occured loading service: \" + sl.getServiceClass().getSimpleName();\r\n            LOGGER.warning(msg);\r\n            LOGGER.log(Level.INFO, \"\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.vfny.geoserver.global.xml.WriterHelper.writeln",
	"Comment": "writeln purpose.writes the string specified to the stored output writer.",
	"Method": "void writeln(String s){\r\n    try {\r\n        writer.write(indentBuffer.subSequence(0, indent) + s + \"\\n\");\r\n        writer.flush();\r\n    } catch (IOException e) {\r\n        throw new ConfigurationException(\"Writeln\" + writer, e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.migrateFrom22",
	"Comment": "migration from 2.2.x to 2.3.x return true if migration has taken place",
	"Method": "boolean migrateFrom22(boolean migratedFrom21){\r\n    String filterName = GeoServerSecurityFilterChain.ROLE_FILTER;\r\n    GeoServerSecurityFilter filter = loadFilter(filterName);\r\n    Resource logoutFilterDir = filterRoot().get(GeoServerSecurityFilterChain.FORM_LOGOUT_FILTER);\r\n    Resource oldLogoutFilterConfig = logoutFilterDir.get(\"config.xml.2.2.x\");\r\n    Resource oldSecManagerConfig = security().get(\"config.xml.2.2.x\");\r\n    if (filter != null) {\r\n        if (oldLogoutFilterConfig.getType() == Type.RESOURCE)\r\n            LOGGER.warning(oldLogoutFilterConfig.path() + \" could be removed manually\");\r\n        if (oldSecManagerConfig.getType() == Type.RESOURCE)\r\n            LOGGER.warning(oldSecManagerConfig.path() + \" could be removed manually\");\r\n        return false;\r\n    }\r\n    RoleFilterConfig rfConfig = new RoleFilterConfig();\r\n    rfConfig.setClassName(GeoServerRoleFilter.class.getName());\r\n    rfConfig.setName(filterName);\r\n    rfConfig.setHttpResponseHeaderAttrForIncludedRoles(GeoServerRoleFilter.DEFAULT_HEADER_ATTRIBUTE);\r\n    rfConfig.setRoleConverterName(GeoServerRoleFilter.DEFAULT_ROLE_CONVERTER);\r\n    saveFilter(rfConfig);\r\n    SSLFilterConfig sslConfig = new SSLFilterConfig();\r\n    sslConfig.setClassName(GeoServerSSLFilter.class.getName());\r\n    sslConfig.setName(GeoServerSecurityFilterChain.SSL_FILTER);\r\n    sslConfig.setSslPort(443);\r\n    saveFilter(sslConfig);\r\n    if (!migratedFrom21)\r\n        org.geoserver.util.IOUtils.copy(logoutFilterDir.get(\"config.xml\").in(), oldLogoutFilterConfig.out());\r\n    LogoutFilterConfig loConfig = (LogoutFilterConfig) loadFilterConfig(GeoServerSecurityFilterChain.FORM_LOGOUT_FILTER);\r\n    loConfig.setRedirectURL(GeoServerLogoutFilter.URL_AFTER_LOGOUT);\r\n    saveFilter(loConfig);\r\n    if (!migratedFrom21)\r\n        org.geoserver.util.IOUtils.copy(security().get(\"config.xml\").in(), oldSecManagerConfig.out());\r\n    SecurityManagerConfig config = loadSecurityConfig();\r\n    for (RequestFilterChain chain : config.getFilterChain().getRequestChains()) {\r\n        if (chain.getFilterNames().contains(GeoServerSecurityFilterChain.SECURITY_CONTEXT_ASC_FILTER)) {\r\n            chain.setAllowSessionCreation(true);\r\n            chain.getFilterNames().remove(GeoServerSecurityFilterChain.SECURITY_CONTEXT_ASC_FILTER);\r\n        }\r\n        if (chain.getFilterNames().contains(GeoServerSecurityFilterChain.SECURITY_CONTEXT_NO_ASC_FILTER)) {\r\n            chain.setAllowSessionCreation(false);\r\n            chain.getFilterNames().remove(GeoServerSecurityFilterChain.SECURITY_CONTEXT_NO_ASC_FILTER);\r\n        }\r\n        if (GeoServerSecurityFilterChain.WEB_CHAIN_NAME.equals(chain.getName())) {\r\n            int index = chain.getFilterNames().indexOf(GeoServerSecurityFilterChain.GUI_EXCEPTION_TRANSLATION_FILTER);\r\n            if (index != -1)\r\n                chain.getFilterNames().set(index, GeoServerSecurityFilterChain.DYNAMIC_EXCEPTION_TRANSLATION_FILTER);\r\n            if (chain.getFilterNames().indexOf(GeoServerSecurityFilterChain.FORM_LOGIN_FILTER) == -1) {\r\n                index = chain.getFilterNames().indexOf(GeoServerSecurityFilterChain.ANONYMOUS_FILTER);\r\n                if (index == -1)\r\n                    index = chain.getFilterNames().indexOf(GeoServerSecurityFilterChain.FILTER_SECURITY_INTERCEPTOR);\r\n                if (index != -1)\r\n                    chain.getFilterNames().add(index, GeoServerSecurityFilterChain.FORM_LOGIN_FILTER);\r\n            }\r\n        }\r\n        chain.getFilterNames().remove(GeoServerSecurityFilterChain.DYNAMIC_EXCEPTION_TRANSLATION_FILTER);\r\n        chain.getFilterNames().remove(GeoServerSecurityFilterChain.FILTER_SECURITY_INTERCEPTOR);\r\n        chain.getFilterNames().remove(GeoServerSecurityFilterChain.FILTER_SECURITY_REST_INTERCEPTOR);\r\n    }\r\n    removeFilter(loadFilterConfig(GeoServerSecurityFilterChain.GUI_EXCEPTION_TRANSLATION_FILTER));\r\n    saveSecurityConfig(config);\r\n    if (!migratedFrom21) {\r\n        for (String fName : listFilters()) {\r\n            SecurityFilterConfig fConfig = loadFilterConfig(fName);\r\n            if (fConfig != null)\r\n                saveFilter(fConfig);\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.web.LoginFormInfo.getLoginPath",
	"Comment": "authentication security endpoint invoked by the pluggable form",
	"Method": "String getLoginPath(){\r\n    return loginPath;\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaMockData.createTablesInTestDatabase",
	"Comment": "determine which setup class to use based on the fixture id specified in the vm arg.",
	"Method": "void createTablesInTestDatabase(){\r\n    AbstractReferenceDataSetup setup = null;\r\n    if (isOracleOnlineTest()) {\r\n        if (is3D) {\r\n            setup = AppSchemaTestOracleSetup.get3DInstance(propertiesFiles);\r\n        } else {\r\n            setup = AppSchemaTestOracleSetup.getInstance(propertiesFiles);\r\n        }\r\n        setup.setUp();\r\n        setup.tearDown();\r\n    } else if (isPostgisOnlineTest()) {\r\n        setup = AppSchemaTestPostgisSetup.getInstance(propertiesFiles);\r\n        setup.setUp();\r\n        setup.tearDown();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.JoinExtractingVisitor.buildTypeMap",
	"Comment": "builds a map going from alias, prefixed type name and simple type name to featuretypeinfo. incase of conflicts aliases will override the type names",
	"Method": "Map<String, FeatureTypeInfo> buildTypeMap(){\r\n    Map<String, FeatureTypeInfo> typeMap = new HashMap();\r\n    typeMap.put(primaryFeatureType.prefixedName(), primaryFeatureType);\r\n    typeMap.put(primaryFeatureType.getName(), primaryFeatureType);\r\n    typeMap.put(primaryAlias, primaryFeatureType);\r\n    for (int i = 0; i < aliases.size(); i++) {\r\n        String alias = aliases.get(i);\r\n        FeatureTypeInfo ft = featureTypes.get(i);\r\n        typeMap.put(ft.getName(), ft);\r\n        typeMap.put(ft.prefixedName(), ft);\r\n        String localTypeName = getLocalTypeName(ft);\r\n        if (localTypeName != null) {\r\n            typeMap.put(localTypeName, ft);\r\n        }\r\n        typeMap.put(alias, ft);\r\n    }\r\n    return typeMap;\r\n}"
}, {
	"Path": "org.geoserver.ows.kvp.TimeKvpParserTest.testInterval",
	"Comment": "compares the dates obtained by parsing the time parameter with the expected values.",
	"Method": "void testInterval(){\r\n    TimeKvpParser timeKvpParser = new TimeKvpParser(\"TIME\");\r\n    List l = new ArrayList((Collection) timeKvpParser.parse(PERIOD));\r\n    assertFalse(l.isEmpty());\r\n    assertInstant(format.parse(\"2007-01-01T12Z\"), l.get(0));\r\n    assertInstant(format.parse(\"2007-01-03T00Z\"), l.get(1));\r\n    assertInstant(format.parse(\"2007-01-04T12Z\"), l.get(2));\r\n    assertInstant(format.parse(\"2007-01-06T00Z\"), l.get(3));\r\n    assertInstant(format.parse(\"2007-01-07T12Z\"), l.get(4));\r\n    assertInstant(format.parse(\"2007-01-09T00Z\"), l.get(5));\r\n    assertInstant(format.parse(\"2007-01-10T12Z\"), l.get(6));\r\n    assertInstant(format.parse(\"2007-01-12T00Z\"), l.get(7));\r\n    l = new ArrayList((Collection) timeKvpParser.parse(\"2007-01-01T12Z/2007-01-01T13Z/PT10M\"));\r\n    assertFalse(l.isEmpty());\r\n    assertEquals(12, l.size());\r\n    assertInstant(format.parse(\"2007-01-01T12Z\"), l.get(0));\r\n}"
}, {
	"Path": "org.geoserver.wms.animate.FrameCatalog.getFrames",
	"Comment": "creates frames visitors. still not producing any image here.",
	"Method": "void getFrames(FrameCatalogVisitor visitor){\r\n    for (String value : values) {\r\n        visitor.visit(this.getMapRequest, this.wms, this.wmsConfiguration, this.parameter, value);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.gwc.GWCIntegrationTest.getWorkspaceLayers",
	"Comment": "helper method that will return the layers that belong to a certain workspace.",
	"Method": "List<LayerInfo> getWorkspaceLayers(String workspaceName){\r\n    List<LayerInfo> layers = new ArrayList();\r\n    for (LayerInfo layer : getCatalog().getLayers()) {\r\n        WorkspaceInfo workspace = layer.getResource().getStore().getWorkspace();\r\n        if (workspace != null && workspace.getName().equals(workspaceName)) {\r\n            layers.add(layer);\r\n        }\r\n    }\r\n    return layers;\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.store.AbstractMappingStore.removeChildFeatures",
	"Comment": "removes the child features associated to a given main feature, the subclasses can override tocustomize",
	"Method": "void removeChildFeatures(List<String> collectionIdentifiers){\r\n    List<Filter> filters = collectionIdentifiers.stream().map(id -> FF.equal(FF.property(\"mid\"), FF.literal(id), false)).collect(Collectors.toList());\r\n    Filter metadataFilter = FF.or(filters);\r\n    SimpleFeatureStore metadataStore = getFeatureStoreForTable(getMetadataTable());\r\n    metadataStore.setTransaction(getTransaction());\r\n    metadataStore.removeFeatures(metadataFilter);\r\n    filters = collectionIdentifiers.stream().map(id -> FF.equal(FF.property(getLinkForeignKey()), FF.literal(id), false)).collect(Collectors.toList());\r\n    Filter linksFilter = FF.or(filters);\r\n    SimpleFeatureStore linkStore = getFeatureStoreForTable(getLinkTable());\r\n    linkStore.setTransaction(getTransaction());\r\n    linkStore.removeFeatures(linksFilter);\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.LDAPAuthenticationProviderTest.testColonPassword",
	"Comment": "test that ldapauthenticationprovider finds roles even if there is a colon in the password",
	"Method": "void testColonPassword(){\r\n    Assume.assumeTrue(LDAPTestUtils.initLdapServer(true, ldapServerUrl, basePath, \"data3.ldif\"));\r\n    ((LDAPSecurityServiceConfig) config).setUserDnPattern(\"uid={0},ou=People\");\r\n    createAuthenticationProvider();\r\n    authentication = new UsernamePasswordAuthenticationToken(\"colon\", \"da:da\");\r\n    Authentication result = authProvider.authenticate(authentication);\r\n    assertEquals(2, result.getAuthorities().size());\r\n}"
}, {
	"Path": "org.geoserver.wfs.kvp.Filter_1_0_0_KvpParser.getParserConfiguration",
	"Comment": "provides the 1.0 filter configuration for the superclass to perform the parameter parsing.",
	"Method": "Configuration getParserConfiguration(){\r\n    return new org.geotools.filter.v1_0.OGCConfiguration();\r\n}"
}, {
	"Path": "org.geoserver.gwc.layer.CatalogConfiguration.removeWorkspacePrefix",
	"Comment": "helper method that will remove the workspace prefix from a layer name. if the layer is notprefixed by an workspace name the layer name will be returned as is.",
	"Method": "String removeWorkspacePrefix(String layerName,Catalog catalog){\r\n    int workspaceSeparatorIndex = layerName.indexOf(\":\");\r\n    if (workspaceSeparatorIndex >= 0 && workspaceSeparatorIndex + 1 < layerName.length()) {\r\n        String workspaceName = layerName.substring(0, workspaceSeparatorIndex);\r\n        if (catalog.getWorkspaceByName(workspaceName) != null) {\r\n            return layerName.substring(workspaceSeparatorIndex + 1);\r\n        }\r\n    }\r\n    return layerName;\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.GeorectifyConfiguration.onApplicationEvent",
	"Comment": "kill all threads on web app context shutdown to avoid permgen leaks",
	"Method": "void onApplicationEvent(ApplicationEvent event){\r\n    if (event instanceof ContextClosedEvent) {\r\n        timer.cancel();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerApplication.getBeanOfType",
	"Comment": "loads a bean from the spring application context of a specific type.if there are multiple beans of the specfied type in the context an exception is thrown.",
	"Method": "T getBeanOfType(Class<T> type){\r\n    return GeoServerExtensions.bean(type, getApplicationContext());\r\n}"
}, {
	"Path": "org.geoserver.wps.executor.WPSExecutionManager.submitChained",
	"Comment": "this call should only be used by process chaining to avoid deadlocking due to executionthreads starvation",
	"Method": "Map<String, Object> submitChained(ExecuteRequest request,ProgressListener listener){\r\n    Name processName = request.getProcessName();\r\n    ProcessManager processManager = getProcessManager(processName);\r\n    String executionId = resourceManager.getExecutionId(true);\r\n    LazyInputMap inputs = request.getProcessInputs(this);\r\n    int inputsLongSteps = inputs.longStepCount();\r\n    int longSteps = inputsLongSteps + 1;\r\n    float longStepPercentage = 100f / longSteps;\r\n    float inputPercentage = inputsLongSteps * longStepPercentage;\r\n    float executionPercentage = 100 - inputPercentage;\r\n    inputs.setListener(new SubProgressListener(listener, inputPercentage));\r\n    ProgressListener executionListener = new SubProgressListener(listener, inputPercentage, executionPercentage);\r\n    return processManager.submitChained(executionId, processName, inputs, executionListener);\r\n}"
}, {
	"Path": "org.geoserver.gwc.config.GWCConfig.setEnabledPersistence",
	"Comment": "this method sets a flag indicating if gwc tiles must be stored in file system even if theyare also cached in memory",
	"Method": "void setEnabledPersistence(boolean persistenceEnabled){\r\n    this.persistenceEnabled = persistenceEnabled;\r\n}"
}, {
	"Path": "org.geoserver.wcs.DefaultWebCoverageService111.checkRangeSubset",
	"Comment": "checks that the elements of the rangesubset part of the request do make sense by comparingthem to the coverage metadata",
	"Method": "void checkRangeSubset(CoverageInfo info,RangeSubsetType rangeSubset){\r\n    if (rangeSubset == null)\r\n        return;\r\n    if (rangeSubset.getFieldSubset().size() > 1) {\r\n        throw new WcsException(\"Multi field coverages are not supported yet\", InvalidParameterValue, \"RangeSubset\");\r\n    }\r\n    FieldSubsetType field = (FieldSubsetType) rangeSubset.getFieldSubset().get(0);\r\n    final String fieldId = field.getIdentifier().getValue();\r\n    if (!fieldId.equalsIgnoreCase(\"contents\"))\r\n        throw new WcsException(\"Unknown field \" + fieldId, InvalidParameterValue, \"RangeSubset\");\r\n    String interpolation = field.getInterpolationType();\r\n    if (interpolation != null) {\r\n        boolean interpolationSupported = false;\r\n        if (interpolation.equalsIgnoreCase(\"nearest\")) {\r\n            interpolation = \"nearest\";\r\n        } else if (interpolation.equalsIgnoreCase(\"cubic\") || interpolation.equalsIgnoreCase(\"bicubic\")) {\r\n            interpolation = \"bicubic\";\r\n        } else if (interpolation.equalsIgnoreCase(\"linear\") || interpolation.equalsIgnoreCase(\"bilinear\")) {\r\n            interpolation = \"bilinear\";\r\n        }\r\n        for (String method : info.getInterpolationMethods()) {\r\n            if (method.toLowerCase().startsWith(interpolation)) {\r\n                interpolationSupported = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!interpolationSupported)\r\n            throw new WcsException(\"The requested Interpolation method is not supported by this Coverage.\", InvalidParameterValue, \"RangeSubset\");\r\n    }\r\n    if (field.getAxisSubset().size() > 1) {\r\n        throw new WcsException(\"Multi axis coverages are not supported yet\", InvalidParameterValue, \"RangeSubset\");\r\n    } else if (field.getAxisSubset().size() == 0)\r\n        return;\r\n    AxisSubsetType axisSubset = (AxisSubsetType) field.getAxisSubset().get(0);\r\n    final String axisId = axisSubset.getIdentifier();\r\n    if (!axisId.equalsIgnoreCase(\"Bands\"))\r\n        throw new WcsException(\"Unknown axis \" + axisId + \" in field \" + fieldId, InvalidParameterValue, \"RangeSubset\");\r\n    List<CoverageDimensionInfo> dimensions = info.getDimensions();\r\n    Set<String> dimensionMap = new HashSet<String>();\r\n    for (int i = 0; i < dimensions.size(); i++) {\r\n        String keyName = dimensions.get(i).getName().replace(' ', '_');\r\n        dimensionMap.add(keyName);\r\n    }\r\n    List keys = axisSubset.getKey();\r\n    int[] bands = new int[keys.size()];\r\n    for (int j = 0; j < bands.length; j++) {\r\n        final String key = (String) keys.get(j);\r\n        String parsedKey = null;\r\n        for (String dimensionName : dimensionMap) {\r\n            if (dimensionName.equalsIgnoreCase(key)) {\r\n                parsedKey = dimensionName;\r\n                break;\r\n            }\r\n        }\r\n        if (parsedKey == null)\r\n            throw new WcsException(\"Unknown field/axis/key combination \" + fieldId + \"/\" + axisSubset.getIdentifier() + \"/\" + key, InvalidParameterValue, \"RangeSubset\");\r\n        else\r\n            keys.set(j, parsedKey);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.GetPropertyValueTest.testGetPropertyValue",
	"Comment": "test getpropertyvalue for a simple property, tests only selected property is returned",
	"Method": "void testGetPropertyValue(){\r\n    Document doc = getAsDOM(\"wfs?request=GetPropertyValue&version=2.0.0&typename=gsml:MappedFeature&valueReference=gml:name\");\r\n    LOGGER.info(\"WFS GetPropertyValue response:\\n\" + prettyString(doc));\r\n    assertXpathEvaluatesTo(\"GUNTHORPE FORMATION\", \"//wfs:member[1]/gml:name\", doc);\r\n    assertXpathCount(4, \"//gml:name\", doc);\r\n    assertXpathCount(0, \"//gsml:shape\", doc);\r\n    assertXpathCount(0, \"//gsml:specification\", doc);\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findSuppLegacyResourceFile",
	"Comment": "returns a supplementary configuration file for a resource in a 1.x data directory format. ifthe file does not exist null is returned.",
	"Method": "File findSuppLegacyResourceFile(ResourceInfo r,String filename){\r\n    File rdir = findLegacyResourceDir(r);\r\n    if (rdir != null) {\r\n        File file = new File(rdir, filename);\r\n        return file.exists() ? file : null;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.VectorEstimator.execute",
	"Comment": "checks whether or not the requests exceed download limits for vector data.",
	"Method": "boolean execute(FeatureTypeInfo resourceInfo,Geometry roi,boolean clip,Filter filter,CoordinateReferenceSystem targetCRS,ProgressListener progressListener){\r\n    if (downloadServiceConfiguration.getMaxFeatures() <= 0) {\r\n        return true;\r\n    }\r\n    CoordinateReferenceSystem nativeCRS = DownloadUtilities.getNativeCRS(resourceInfo);\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.fine(\"Native CRS is \" + nativeCRS.toWKT());\r\n    }\r\n    ROIManager roiManager = null;\r\n    if (roi != null) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Pushing ROI to native CRS\");\r\n        }\r\n        CoordinateReferenceSystem roiCRS = (CoordinateReferenceSystem) roi.getUserData();\r\n        roiManager = new ROIManager(roi, roiCRS);\r\n        roiManager.useNativeCRS(nativeCRS);\r\n    }\r\n    final SimpleFeatureSource featureSource = (SimpleFeatureSource) resourceInfo.getFeatureSource(null, GeoTools.getDefaultHints());\r\n    Filter ra = Filter.INCLUDE;\r\n    if (filter != null) {\r\n        ra = filter;\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Using filter \" + ra);\r\n        }\r\n    }\r\n    if (roi != null) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Adding Geometry filter with ROI\");\r\n        }\r\n        final String dataGeomName = featureSource.getSchema().getGeometryDescriptor().getLocalName();\r\n        final Intersects intersectionFilter = FeatureUtilities.DEFAULT_FILTER_FACTORY.intersects(FeatureUtilities.DEFAULT_FILTER_FACTORY.property(dataGeomName), FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(roiManager.getSafeRoiInNativeCRS()));\r\n        ra = FeatureUtilities.DEFAULT_FILTER_FACTORY.and(ra, intersectionFilter);\r\n    }\r\n    ra = (Filter) ra.accept(new SimplifyingFilterVisitor(), null);\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.log(Level.FINE, \"Counting features\");\r\n    }\r\n    int count = featureSource.getCount(new Query(\"counter\", ra));\r\n    if (count < 0) {\r\n        SimpleFeatureCollection features = featureSource.getFeatures(ra);\r\n        count = features.size();\r\n    }\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.log(Level.FINE, \"Feature size is \" + count);\r\n    }\r\n    final long maxFeatures = downloadServiceConfiguration.getMaxFeatures();\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.log(Level.FINE, \"Max features limit is \" + maxFeatures);\r\n    }\r\n    if (maxFeatures > 0 && count > maxFeatures) {\r\n        if (LOGGER.isLoggable(Level.SEVERE)) {\r\n            LOGGER.log(Level.SEVERE, \"MaxFeatures limit exceeded. \" + count + \" > \" + maxFeatures);\r\n        }\r\n        return false;\r\n    }\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.log(Level.FINE, \"MaxFeatures limit not exceeded.\");\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.template.TemplateUtils.getSafeConfiguration",
	"Comment": "get a freemarker configuration that is safe against malicious templates",
	"Method": "Configuration getSafeConfiguration(){\r\n    Configuration config = new Configuration();\r\n    config.setNewBuiltinClassResolver((name, env, template) -> {\r\n        if (ILLEGAL_FREEMARKER_CLASSES.stream().anyMatch(name::equals)) {\r\n            throw new TemplateException(String.format(\"Class %s is not allowed in Freemarker templates\", name), env);\r\n        }\r\n        if (LEGAL_FREEMARKER_CLASSES.stream().anyMatch(name::equals)) {\r\n            try {\r\n                ClassUtil.forName(name);\r\n            } catch (ClassNotFoundException e) {\r\n                throw new TemplateException(e, env);\r\n            }\r\n        }\r\n        return TemplateClassResolver.SAFER_RESOLVER.resolve(name, env, template);\r\n    });\r\n    return config;\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.GeoServerInstance.getConsumedEventsCount",
	"Comment": "returns the total number of jms events consumed by this geoserver instance.",
	"Method": "int getConsumedEventsCount(){\r\n    return (int) jmsQueueListener.getConsumedEvents();\r\n}"
}, {
	"Path": "org.geoserver.kml.KMLSuperOverlayTest.testCrossingSuperoverlay",
	"Comment": "checks what happens when the data bbox is at the crossing of a parent tile that is two levelsabove the bbox itself",
	"Method": "void testCrossingSuperoverlay(){\r\n    Document document = getAsDOM(\"wms/kml?layers=\" + getLayerId(BOULDER) + \"&mode=superoverlay\");\r\n    assertXpathEvaluatesTo(\"40.78125\", \"//kml:Region/kml:LatLonAltBox/kml:north\", document);\r\n    assertXpathEvaluatesTo(\"39.375\", \"//kml:Region/kml:LatLonAltBox/kml:south\", document);\r\n    assertXpathEvaluatesTo(\"-104.0625\", \"//kml:Region/kml:LatLonAltBox/kml:east\", document);\r\n    assertXpathEvaluatesTo(\"-105.46875\", \"//kml:Region/kml:LatLonAltBox/kml:west\", document);\r\n    assertXpathEvaluatesTo(\"-105.22419118401743\", \"//kml:Document/kml:LookAt/kml:longitude\", document);\r\n    assertXpathEvaluatesTo(\"40.008056082289826\", \"//kml:Document/kml:LookAt/kml:latitude\", document);\r\n    assertEquals(-105.2243, Double.parseDouble(xpath.evaluate(\"//kml:Document/kml:Folder/kml:LookAt/kml:longitude\", document)), 1E-4);\r\n    assertEquals(40.0081, Double.parseDouble(xpath.evaluate(\"//kml:Document/kml:Folder/kml:LookAt/kml:latitude\", document)), 1E-4);\r\n}"
}, {
	"Path": "org.geoserver.kml.utils.KMLFeatureAccessor.getFeatureCount",
	"Comment": "counts how many features will be returned for the specified layer in the current request",
	"Method": "int getFeatureCount(Layer layer,WMSMapContent mapContent,WMS wms,double scaleDenominator){\r\n    Query q = getFeaturesQuery(layer, mapContent, wms, scaleDenominator);\r\n    SimpleFeatureSource featureSource = (SimpleFeatureSource) layer.getFeatureSource();\r\n    int count = featureSource.getCount(q);\r\n    if (count == -1) {\r\n        count = featureSource.getFeatures(q).size();\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "org.geoserver.wfs3.response.FreemarkerTemplateSupport.getTemplate",
	"Comment": "returns the template for the specified feature type. looking up templates is prettyexpensive, so we cache templates by feture type and template.",
	"Method": "Template getTemplate(ResourceInfo resource,String templateName){\r\n    GeoServerTemplateLoader templateLoader = new GeoServerTemplateLoader(getClass(), resoureLoader);\r\n    if (resource != null) {\r\n        templateLoader.setResource(resource);\r\n    } else {\r\n        WorkspaceInfo ws = LocalWorkspace.get();\r\n        if (ws != null) {\r\n            templateLoader.setWorkspace(ws);\r\n        }\r\n    }\r\n    synchronized (templateConfig) {\r\n        templateConfig.setTemplateLoader(templateLoader);\r\n        Template t = templateConfig.getTemplate(templateName);\r\n        t.setEncoding(\"UTF-8\");\r\n        return t;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wms.web.data.StyleEditPageTest.testDiscardLegendWithBadValues",
	"Comment": "test that while editing a style, the user can discard a legend, even if the legend hasinvalid values at the time, and then continue to save the style.",
	"Method": "void testDiscardLegendWithBadValues(){\r\n    tester.executeAjaxEvent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:showhide:show\", \"click\");\r\n    tester.assertComponent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:onlineResource\", TextField.class);\r\n    tester.assertComponent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:width\", TextField.class);\r\n    tester.assertComponent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:height\", TextField.class);\r\n    tester.assertComponent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:format\", TextField.class);\r\n    FormTester form = tester.newFormTester(\"styleForm\", false);\r\n    form.setValue(\"context:panel:legendPanel:externalGraphicContainer:list:onlineResource\", \"missing.ong\");\r\n    form.setValue(\"context:panel:legendPanel:externalGraphicContainer:list:width\", \"-100\");\r\n    form.setValue(\"context:panel:legendPanel:externalGraphicContainer:list:height\", \"\");\r\n    form.setValue(\"context:panel:legendPanel:externalGraphicContainer:list:format\", \"bad/value\");\r\n    tester.executeAjaxEvent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:showhide:hide\", \"click\");\r\n    form = tester.newFormTester(\"styleForm\", false);\r\n    form.submit();\r\n    tester.assertNoErrorMessage();\r\n    StyleInfo style = getCatalog().getStyleByName(MockData.BUILDINGS.getLocalPart());\r\n    assertNotNull(style);\r\n    assertNull(style.getLegend());\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.WCSEnvelope.setRange",
	"Comment": "sets the range for the given dimension. if the dimension is the longitude, it is allowed toset a minimum greater than the maximum, this envelope will be assumed to span the dateline",
	"Method": "void setRange(int dimension,double minimum,double maximum){\r\n    if (minimum > maximum && (longitudeDimension != LONGIDUTE_NOT_FOUND && dimension != longitudeDimension)) {\r\n        minimum = maximum = 0.5 * (minimum + maximum);\r\n    } else if (dimension >= 0 && dimension < ordinates.length / 2) {\r\n        ordinates[dimension + ordinates.length / 2] = maximum;\r\n        ordinates[dimension] = minimum;\r\n    } else {\r\n        throw indexOutOfBounds(dimension);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.HeaderContribution.getFavicon",
	"Comment": "returns the resource reference to a replacement favicon for the header contribution, or nullif there is no favicon replacement",
	"Method": "PackageResourceReference getFavicon(){\r\n    if (scope != null && faviconFilename != null) {\r\n        return new PackageResourceReference(scope, faviconFilename);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.kml.KMLSuperOverlayTest.testWorldBoundsSuperOverlay",
	"Comment": "verify that the tiles are produced for a request that encompasses the world.",
	"Method": "void testWorldBoundsSuperOverlay(){\r\n    Document document = getAsDOM(\"wms/kml?layers=\" + getLayerId(MockData.BASIC_POLYGONS) + \",\" + getLayerId(DISPERSED_FEATURES) + \"&mode=superoverlay\");\r\n    assertEquals(\"kml\", document.getDocumentElement().getNodeName());\r\n    assertEquals(\"2\", xpath.evaluate(\"count(//kml:Folder)\", document));\r\n    assertEquals(9, document.getElementsByTagName(\"Region\").getLength());\r\n    assertEquals(\"8\", xpath.evaluate(\"count(//kml:NetworkLink)\", document));\r\n    assertEquals(\"0\", xpath.evaluate(\"count(//kml:GroundOverlay)\", document));\r\n    assertXpathEvaluatesTo(\"90.0\", \"//kml:Region/kml:LatLonAltBox/kml:north\", document);\r\n    assertXpathEvaluatesTo(\"-90.0\", \"//kml:Region/kml:LatLonAltBox/kml:south\", document);\r\n    assertXpathEvaluatesTo(\"180.0\", \"//kml:Region/kml:LatLonAltBox/kml:east\", document);\r\n    assertXpathEvaluatesTo(\"-180.0\", \"//kml:Region/kml:LatLonAltBox/kml:west\", document);\r\n    assertXpathExists(\"//kml:NetworkLink[kml:name='contents-0']\", document);\r\n    assertXpathExists(\"//kml:NetworkLink[kml:name='contents-1']\", document);\r\n}"
}, {
	"Path": "org.geoserver.security.VectorAccessLimits.getWriteQuery",
	"Comment": "returns a geotools query wrapping the write attributes and the write filter",
	"Method": "Query getWriteQuery(){\r\n    return buildQuery(writeAttributes, writeFilter);\r\n}"
}, {
	"Path": "org.geoserver.nsg.pagination.random.IndexConfigurationManager.isDBTheSame",
	"Comment": "helper method that check id the db is the same, matching the jdbc configurations parameters.",
	"Method": "Boolean isDBTheSame(Map<String, Object> newParams){\r\n    Map<String, Object> currentParams = indexConfiguration.getCurrentDataStoreParams();\r\n    boolean isTheSame = (currentParams.get(JDBCDataStoreFactory.DBTYPE.key) == null && newParams.get(JDBCDataStoreFactory.DBTYPE.key) == null) || (currentParams.get(JDBCDataStoreFactory.DBTYPE.key) != null && newParams.get(JDBCDataStoreFactory.DBTYPE.key) != null && currentParams.get(JDBCDataStoreFactory.DBTYPE.key).equals(newParams.get(JDBCDataStoreFactory.DBTYPE.key)));\r\n    isTheSame = isTheSame && (currentParams.get(JDBCDataStoreFactory.DATABASE.key) == null && newParams.get(JDBCDataStoreFactory.DATABASE.key) == null) || (currentParams.get(JDBCDataStoreFactory.DATABASE.key) != null && newParams.get(JDBCDataStoreFactory.DATABASE.key) != null && currentParams.get(JDBCDataStoreFactory.DATABASE.key).equals(newParams.get(JDBCDataStoreFactory.DATABASE.key)));\r\n    isTheSame = isTheSame && (currentParams.get(JDBCDataStoreFactory.HOST.key) == null && newParams.get(JDBCDataStoreFactory.HOST.key) == null) || (currentParams.get(JDBCDataStoreFactory.HOST.key) != null && newParams.get(JDBCDataStoreFactory.HOST.key) != null && currentParams.get(JDBCDataStoreFactory.HOST.key).equals(newParams.get(JDBCDataStoreFactory.HOST.key)));\r\n    isTheSame = isTheSame && (currentParams.get(JDBCDataStoreFactory.PORT.key) == null && newParams.get(JDBCDataStoreFactory.PORT.key) == null) || (currentParams.get(JDBCDataStoreFactory.PORT.key) != null && newParams.get(JDBCDataStoreFactory.PORT.key) != null && currentParams.get(JDBCDataStoreFactory.PORT.key).equals(newParams.get(JDBCDataStoreFactory.PORT.key)));\r\n    isTheSame = isTheSame && (currentParams.get(JDBCDataStoreFactory.SCHEMA.key) == null && newParams.get(JDBCDataStoreFactory.SCHEMA.key) == null) || (currentParams.get(JDBCDataStoreFactory.SCHEMA.key) != null && newParams.get(JDBCDataStoreFactory.SCHEMA.key) != null && currentParams.get(JDBCDataStoreFactory.SCHEMA.key).equals(newParams.get(JDBCDataStoreFactory.SCHEMA.key)));\r\n    return isTheSame;\r\n}"
}, {
	"Path": "org.geoserver.platform.FileWatcher.isModified",
	"Comment": "determines if the underlying file has been modified since the last check.",
	"Method": "boolean isModified(){\r\n    long now = System.currentTimeMillis();\r\n    if ((now - lastCheck) > 1000) {\r\n        lastCheck = now;\r\n        stale = (resource.getType() != Type.UNDEFINED) && (resource.lastmodified() != lastModified);\r\n    }\r\n    return stale;\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerApplication.getBeansOfType",
	"Comment": "loads beans from the spring application context of a specific type.",
	"Method": "List<T> getBeansOfType(Class<T> type){\r\n    return GeoServerExtensions.extensions(type, getApplicationContext());\r\n}"
}, {
	"Path": "org.geoserver.kml.utils.KmlCentroidOptions.create",
	"Comment": "creates centroid options from the specified format options.",
	"Method": "KmlCentroidOptions create(KmlEncodingContext context,KmlCentroidOptions create,Map formatOptions){\r\n    if (formatOptions != null) {\r\n        for (Object key : formatOptions.keySet()) {\r\n            if (key.toString().toLowerCase().startsWith(PREFIX)) {\r\n                return new KmlCentroidOptions(CaseInsensitiveMap.wrap(formatOptions));\r\n            }\r\n        }\r\n    }\r\n    return KmlCentroidOptions.DEFAULT;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.WCSTestSupport.getTiffField",
	"Comment": "gets a tifffield node with the given tag number. this is done by searching for a tifffieldwith attribute number whose value is the specified tag value.",
	"Method": "IIOMetadataNode getTiffField(Node rootNode,int tag){\r\n    Node node = rootNode.getFirstChild();\r\n    if (node != null) {\r\n        node = node.getFirstChild();\r\n        for (; node != null; node = node.getNextSibling()) {\r\n            Node number = node.getAttributes().getNamedItem(GeoTiffConstants.NUMBER_ATTRIBUTE);\r\n            if (number != null && tag == Integer.parseInt(number.getNodeValue())) {\r\n                return (IIOMetadataNode) node;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.security.jdbc.config.JDBCSecurityServiceConfig.initBeforeSave",
	"Comment": "initializes the ddl and dml property files based on the database type.",
	"Method": "void initBeforeSave(){\r\n    if (propertyFileNameDDL == null) {\r\n        propertyFileNameDDL = isMySQL() ? defaultDDLFilenameMySQL() : defaultDDLFilename();\r\n    }\r\n    if (propertyFileNameDML == null) {\r\n        propertyFileNameDML = isMySQL() ? defaultDMLFilenameMySQL() : defaultDMLFilename();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.WCSMultiDimSubsetTest.sliceLambert",
	"Comment": "tests if we can select a single pixel value using a wcs request",
	"Method": "void sliceLambert(){\r\n    GridCoverage2D targetCoverage = null, sourceCoverage = null;\r\n    GridCoverageReader coverageReader = null;\r\n    try {\r\n        CoverageInfo coverageInfo = this.getCatalog().getCoverageByName(LAMBERTMOSAIC.getLocalPart());\r\n        coverageReader = coverageInfo.getGridCoverageReader(null, null);\r\n        final ParameterValue<Boolean> useJAI = ImageMosaicFormat.USE_JAI_IMAGEREAD.createValue();\r\n        useJAI.setValue(false);\r\n        sourceCoverage = (GridCoverage2D) coverageReader.read(new GeneralParameterValue[] { useJAI });\r\n        final Envelope2D sourceEnvelope = sourceCoverage.getEnvelope2D();\r\n        MockHttpServletResponse response = getAsServletResponse(\"wcs?request=GetCoverage&service=WCS&version=2.0.1\" + \"&coverageId=wcs__lambert&&Format=application/custom\" + \"&subset=E,http://www.opengis.net/def/crs/EPSG/0/31300(\" + sourceEnvelope.x + \",\" + (sourceEnvelope.x + 25) + \")\" + \"&subset=N,http://www.opengis.net/def/crs/EPSG/0/31300(\" + sourceEnvelope.y + \",\" + (sourceEnvelope.y + 25) + \")\");\r\n        assertNotNull(response);\r\n        targetCoverage = applicationContext.getBean(WCSResponseInterceptor.class).getLastResult();\r\n        assertEquals((Object) sourceCoverage.getCoordinateReferenceSystem(), (Object) targetCoverage.getCoordinateReferenceSystem());\r\n        assertTrue(targetCoverage instanceof GranuleStack);\r\n        GridCoverage2D firstResult = ((GranuleStack) targetCoverage).getGranules().get(0);\r\n        assertEquals(1, firstResult.getGridGeometry().getGridRange().getSpan(0));\r\n        assertEquals(1, firstResult.getGridGeometry().getGridRange().getSpan(1));\r\n        assertEquals(0, firstResult.getGridGeometry().getGridRange().getLow(0));\r\n        assertEquals(1, firstResult.getGridGeometry().getGridRange().getLow(1));\r\n    } finally {\r\n        if (coverageReader != null) {\r\n            try {\r\n                coverageReader.dispose();\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        if (targetCoverage != null) {\r\n            try {\r\n                CoverageCleanerCallback.disposeCoverage(targetCoverage);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        if (sourceCoverage != null) {\r\n            try {\r\n                CoverageCleanerCallback.disposeCoverage(sourceCoverage);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.ows.OWS11ServiceExceptionHandler.setUseServiceVersion",
	"Comment": "flag that controls what version to use in the ows exception report.setting to true will cause the service version to be used rather than the ows specversion.",
	"Method": "void setUseServiceVersion(boolean useServiceVersion){\r\n    this.useServiceVersion = useServiceVersion;\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.ScaleToTarget.getScaleTransform",
	"Comment": "computes the scaling transformation for the overview which would be picked for the requestedresolution.",
	"Method": "AffineTransform getScaleTransform(){\r\n    final double[] nativeResolution = computeNativeResolution();\r\n    final double[] requestedResolution = computeRequestedResolution();\r\n    final double[] readResolution = computeReadingResolution(requestedResolution);\r\n    AffineTransform scaleTransform = new AffineTransform();\r\n    double[] scaleFactors = new double[] { readResolution[0] / nativeResolution[0], readResolution[1] / nativeResolution[1] };\r\n    scaleTransform.scale(scaleFactors[0], scaleFactors[1]);\r\n    return scaleTransform;\r\n}"
}, {
	"Path": "org.geoserver.wms.ncwms.NcWmsService.getTimeSeries",
	"Comment": "implements the gettimeseries method, which can retrieve a time series of values on a certainpoint, using a syntax similar to the getfeatureinfo operation.",
	"Method": "FeatureCollectionType getTimeSeries(GetFeatureInfoRequest request){\r\n    FeatureCollectionType result = WfsFactory.eINSTANCE.createFeatureCollectionType();\r\n    WfsFactory.eINSTANCE.createFeatureCollectionType();\r\n    result.setTimeStamp(Calendar.getInstance());\r\n    if (request.getGetMapRequest().getTime() == null || request.getGetMapRequest().getTime().size() != 1) {\r\n        throw new ServiceException(\"The TIME parameter was not a valid WMS time range or was missing\");\r\n    }\r\n    Object queryRangePlain = (DateRange) request.getGetMapRequest().getTime().get(0);\r\n    if (queryRangePlain == null || !(queryRangePlain instanceof DateRange)) {\r\n        throw new ServiceException(\"The TIME parameter was not a valid WMS time range\");\r\n    }\r\n    DateRange queryRange = (DateRange) queryRangePlain;\r\n    final List<MapLayerInfo> requestedLayers = request.getQueryLayers();\r\n    if (requestedLayers.size() != 1) {\r\n        throw new ServiceException(\"The QUERY_LAYERS parameter must specify a single coverage layer for the GetTimeSeries operation\");\r\n    }\r\n    final MapLayerInfo layer = requestedLayers.get(0);\r\n    CoverageInfo coverage;\r\n    try {\r\n        coverage = layer.getCoverage();\r\n    } catch (Exception cex) {\r\n        throw new ServiceException(\"The GetTimeSeries operation is only defined for coverage layers\");\r\n    }\r\n    if (request.getPropertyNames() == null || request.getPropertyNames().size() == 0 || request.getPropertyNames().get(0).isEmpty()) {\r\n        String firstBand = coverage.getDimensions().get(0).getName();\r\n        request.setPropertyNames(Arrays.asList(Arrays.asList(firstBand)));\r\n    }\r\n    int maxRenderingTime = wms.getMaxRenderingTime(request.getGetMapRequest());\r\n    CountdownClock countdownClock = new CountdownClock(maxRenderingTime);\r\n    LayerIdentifier identifier = getLayerIdentifier(layer);\r\n    SimpleFeatureBuilder featureBuilder = getResultFeatureBuilder(layer.getName(), buildTypeDescription(layer));\r\n    try {\r\n        TreeSet availableDates = wms.queryCoverageTimes(coverage, queryRange, Query.DEFAULT_MAX);\r\n        ListFeatureCollection features = new ListFeatureCollection(featureBuilder.getFeatureType());\r\n        for (Object d : availableDates) {\r\n            countdownClock.checkTimeout();\r\n            Date date = (Date) d;\r\n            DateRange currentDate = new DateRange(date, date);\r\n            request.getGetMapRequest().getTime().remove(0);\r\n            request.getGetMapRequest().getTime().add(currentDate);\r\n            FeatureInfoRequestParameters requestParams = new FeatureInfoRequestParameters(request);\r\n            List<FeatureCollection> identifiedCollections = identifier.identify(requestParams, 1);\r\n            if (identifiedCollections != null) {\r\n                for (FeatureCollection c : identifiedCollections) {\r\n                    try (FeatureIterator featIter = c.features()) {\r\n                        if (featIter.hasNext()) {\r\n                            Feature inFeat = featIter.next();\r\n                            Iterator<Property> propIter = inFeat.getProperties().iterator();\r\n                            if (propIter.hasNext()) {\r\n                                Property prop = propIter.next();\r\n                                featureBuilder.add(date);\r\n                                featureBuilder.add(prop.getValue());\r\n                                SimpleFeature newFeat = featureBuilder.buildFeature(null);\r\n                                features.add(newFeat);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        result.getFeature().add(features);\r\n    } catch (Exception e) {\r\n        throw new ServiceException(\"Error processing the operation\", e);\r\n    } finally {\r\n        request.getGetMapRequest().getTime().remove(0);\r\n        request.getGetMapRequest().getTime().add(queryRange);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.kml.icons.Icons.getRotation",
	"Comment": "get the rotation of the given graphic when applied to the given feature",
	"Method": "Double getRotation(Graphic g,Feature f){\r\n    if (g.getRotation() != null) {\r\n        return g.getRotation().evaluate(f, Double.class);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.rest.catalog.CoverageController.getExistingCoverageStore",
	"Comment": "helper method that find a store based on the workspace name and store name.",
	"Method": "CoverageStoreInfo getExistingCoverageStore(String workspaceName,String storeName){\r\n    CoverageStoreInfo original = catalog.getCoverageStoreByName(workspaceName, storeName);\r\n    if (original == null) {\r\n        throw new ResourceNotFoundException(\"No such coverage store: \" + workspaceName + \",\" + storeName);\r\n    }\r\n    return original;\r\n}"
}, {
	"Path": "org.geoserver.wms.vector.VectorTileMapOutputFormat.setClipToMapBounds",
	"Comment": "does this format use features clipped to the extent of the tile instead of whole features",
	"Method": "void setClipToMapBounds(boolean clip){\r\n    this.clipToMapBounds = clip;\r\n}"
}, {
	"Path": "org.geoserver.wfs.xml.v1_0_0.XmlSchemaEncoder.allSameType",
	"Comment": "checks that the collection of featuretypenames all have the same prefix. used to determine iftheir schemas are all in the same namespace or if imports need to be done.",
	"Method": "boolean allSameType(FeatureTypeInfo[] infos){\r\n    boolean sameType = true;\r\n    if (infos.length == 0) {\r\n        return false;\r\n    }\r\n    FeatureTypeInfo first = infos[0];\r\n    for (int i = 0; i < infos.length; i++) {\r\n        FeatureTypeInfo ftInfo = infos[i];\r\n        if (!first.getNamespace().equals(ftInfo.getNamespace())) {\r\n            return false;\r\n        }\r\n    }\r\n    return sameType;\r\n}"
}, {
	"Path": "org.geoserver.security.password.ConfigurationPasswordEncryptionHelper.decode",
	"Comment": "decrypts previously encrypted store connection parameters.",
	"Method": "void decode(StoreInfo info,String decode,String value,String decode,String value,List<GeoServerPasswordEncoder> encoders){\r\n    for (GeoServerPasswordEncoder encoder : encoders) {\r\n        if (encoder.isReversible() == false)\r\n            continue;\r\n        if (encoder.isResponsibleForEncoding(value)) {\r\n            return encoder.decode(value);\r\n        }\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.geoserver.wps.security.WpsAccessRuleDAO.loadRules",
	"Comment": "loads rules from in memory wpsinfo and builds the wps access rules tree",
	"Method": "void loadRules(){\r\n    WPSInfo wps = this.gs.getService(WPSInfo.class);\r\n    TreeSet<WpsAccessRule> result = new TreeSet<WpsAccessRule>();\r\n    if (wps != null) {\r\n        catalogMode = CatalogMode.HIDE;\r\n        if (wps.getCatalogMode() != null) {\r\n            catalogMode = wps.getCatalogMode();\r\n        }\r\n        for (ProcessGroupInfo group : wps.getProcessGroups()) {\r\n            Set<String> prefixes = new HashSet<String>();\r\n            ProcessFactory pf = GeoServerProcessors.getProcessFactory(group.getFactoryClass(), false);\r\n            if (pf != null) {\r\n                Set<Name> names = pf.getNames();\r\n                for (Name name : names) {\r\n                    prefixes.add(name.getNamespaceURI());\r\n                }\r\n            }\r\n            for (String prefix : prefixes) {\r\n                if (group.getRoles() != null && !group.getRoles().isEmpty()) {\r\n                    result.add(new WpsAccessRule(prefix, ANY, new HashSet<String>(group.getRoles())));\r\n                }\r\n            }\r\n            for (ProcessInfo process : group.getFilteredProcesses()) {\r\n                if (process.getRoles() != null && !process.getRoles().isEmpty()) {\r\n                    result.add(new WpsAccessRule(process.getName().getNamespaceURI(), process.getName().getLocalPart(), new HashSet<String>(process.getRoles())));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (result.size() == 0) {\r\n        result.add(new WpsAccessRule(WpsAccessRule.EXECUTE_ALL));\r\n    }\r\n    root = buildAuthorizationTree(result);\r\n}"
}, {
	"Path": "org.geoserver.wps.executor.LazyInputMap.setListener",
	"Comment": "the listener will be informed of the parse progress, when it happens",
	"Method": "void setListener(ProgressListener listener){\r\n    this.listener = listener;\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaMockData.addFeatureType",
	"Comment": "add one feature type, copying its resources and registering, creating its info.xml, andadding it to catalog.xml.",
	"Method": "void addFeatureType(String namespacePrefix,String typeName,String mappingFileName,String supportFileNames){\r\n    File featureTypeDir = getFeatureTypeDir(featureTypesBaseDir, namespacePrefix, typeName);\r\n    String dataStoreName = getDataStoreName(namespacePrefix, typeName);\r\n    try {\r\n        writeInfoFile(namespacePrefix, typeName, featureTypeDir, dataStoreName);\r\n        copyMappingAndSupportFiles(namespacePrefix, typeName, mappingFileName, supportFileNames);\r\n        addDataStore(dataStoreName, namespacePrefix, buildAppSchemaDatastoreParams(namespacePrefix, typeName, getFileNamePart(mappingFileName), featureTypesBaseDir, dataStoreName));\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.ConfigurationDiffVisitor.search",
	"Comment": "searches settings by is title and workspace on a collection of settings.",
	"Method": "ServiceInfo search(ServiceInfo info,Collection<ServiceInfo> collection,SettingsInfo search,SettingsInfo info,Collection<SettingsInfo> collection){\r\n    for (SettingsInfo candidateInfo : collection) {\r\n        if (Objects.equals(info.getId(), candidateInfo.getId())) {\r\n            return candidateInfo;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.isMultipleType",
	"Comment": "check if a property type should appear multiple times or be encoded as a list.",
	"Method": "PropertyDescriptor isMultipleType(PropertyType parentType,PropertyType type){\r\n    if (!(parentType instanceof ComplexType)) {\r\n        return null;\r\n    }\r\n    ComplexType complexType = (ComplexType) parentType;\r\n    PropertyDescriptor foundType = null;\r\n    for (PropertyDescriptor descriptor : complexType.getDescriptors()) {\r\n        if (descriptor.getType().equals(type)) {\r\n            foundType = descriptor;\r\n        }\r\n    }\r\n    if (foundType == null) {\r\n        return null;\r\n    }\r\n    if (foundType.getMaxOccurs() > 1) {\r\n        return foundType;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.spatialite.RestTest.readSqLiteDatabaseFile",
	"Comment": "helper method that just reads the test spatialite database file and stores it in a array ofbytes.",
	"Method": "byte[] readSqLiteDatabaseFile(){\r\n    InputStream input = new FileInputStream(DATABASE_FILE);\r\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\r\n    try {\r\n        IOUtils.copy(input, output);\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error reading SQLite database file to byte array.\", exception);\r\n    }\r\n    return output.toByteArray();\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.ShapeZipTest.writeOut",
	"Comment": "saves the feature source contents into a zipped shapefile, returns the output as a byte array",
	"Method": "byte[] writeOut(FeatureCollection fc,long maxShpSize,long maxDbfSize,byte[] writeOut,FeatureCollection fc){\r\n    ShapeZipOutputFormat zip = new ShapeZipOutputFormat();\r\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    FeatureCollectionResponse fct = FeatureCollectionResponse.adapt(WfsFactory.eINSTANCE.createFeatureCollectionType());\r\n    fct.getFeature().add(fc);\r\n    zip.write(fct, bos, op);\r\n    return bos.toByteArray();\r\n}"
}, {
	"Path": "org.geoserver.config.util.XStreamPersister.setLoggingLevel",
	"Comment": "sets the minimum level at which messages should be logged by the persister.when this level is set even messages that the underlying logger is configured to emit willbe skipped.",
	"Method": "void setLoggingLevel(Level level){\r\n    this.forceLevel = level;\r\n}"
}, {
	"Path": "org.geoserver.script.ScriptManager.getEngineManager",
	"Comment": "returns the underlying engine manager used to create and manage script engines.",
	"Method": "ScriptEngineManager getEngineManager(){\r\n    return engineMgr;\r\n}"
}, {
	"Path": "org.vfny.geoserver.util.ResponseUtils.proxifyDataLink",
	"Comment": "profixies a data link url interpreting a localhost url as a back reference to the server.if link is not a localhost url it is left untouched.",
	"Method": "String proxifyDataLink(DataLinkInfo link,String baseURL){\r\n    String content = link.getContent();\r\n    content = proxifyLink(content, baseURL);\r\n    return content;\r\n}"
}, {
	"Path": "org.vfny.geoserver.servlets.Dispatcher.doGet",
	"Comment": "handles all get requests. this method implements the main matching logic for the class.",
	"Method": "void doGet(HttpServletRequest request,HttpServletResponse response){\r\n    int targetRequest = 0;\r\n    if (request.getQueryString() != null) {\r\n        Map kvPairs = KvpRequestReader.parseKvpSet(request.getQueryString());\r\n        targetRequest = DispatcherKvpReader.getRequestType(kvPairs);\r\n    } else {\r\n        targetRequest = UNKNOWN;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityFilterChain.insertBefore",
	"Comment": "inserts a filter as before another in the list corresponding to the specified pattern.",
	"Method": "boolean insertBefore(String pattern,String filterName,String positionName){\r\n    RequestFilterChain requestChain = findAndCheck(pattern, filterName);\r\n    if (requestChain == null) {\r\n        return false;\r\n    }\r\n    List<String> filterNames = requestChain.getFilterNames();\r\n    int index = filterNames.indexOf(positionName);\r\n    if (index == -1) {\r\n        return false;\r\n    }\r\n    filterNames.add(index, filterName);\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.importer.Directory.format",
	"Comment": "returns the data format of the files in the directory iff all the files are of the sameformat, if they are not this returns null.",
	"Method": "DataFormat format(){\r\n    if (files.isEmpty()) {\r\n        LOGGER.warning(\"no files recognized\");\r\n        return null;\r\n    }\r\n    FileData file = files.get(0);\r\n    DataFormat format = file.getFormat();\r\n    for (int i = 1; i < files.size(); i++) {\r\n        FileData other = files.get(i);\r\n        if (format != null && !format.equals(other.getFormat())) {\r\n            logFormatMismatch();\r\n            return null;\r\n        }\r\n        if (format == null && other.getFormat() != null) {\r\n            logFormatMismatch();\r\n            return null;\r\n        }\r\n    }\r\n    return format;\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.ReaderUtils.getFirstChildElement",
	"Comment": "getfirstchildelement purpose.used to help with xml manipulations. returns the element which represents the first child.",
	"Method": "Element getFirstChildElement(Element root){\r\n    Node child = root.getFirstChild();\r\n    while (child != null) {\r\n        if (child.getNodeType() == Node.ELEMENT_NODE) {\r\n            return (Element) child;\r\n        }\r\n        child = child.getNextSibling();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.test.RestconfigWfsTest.copyFiles",
	"Comment": "copy the mapping and properties files to the data directory.",
	"Method": "void copyFiles(){\r\n    File dir = new File(new File(new File(getTestData().getDataDirectoryRoot(), \"workspaces\"), \"gsml\"), \"MappedFeature\");\r\n    dir.mkdirs();\r\n    File propertiesFile = new File(dir, \"MAPPEDFEATURE.properties\");\r\n    IOUtils.copy(new ByteArrayInputStream(PROPERTIES.getBytes(\"UTF-8\")), propertiesFile);\r\n    String mapping = MAPPING;\r\n    String onlineTestId = System.getProperty(\"testDatabase\");\r\n    if (onlineTestId != null) {\r\n        onlineTestId = onlineTestId.trim().toLowerCase();\r\n        Map<String, File> propertyFiles = new HashMap<String, File>();\r\n        propertyFiles.put(propertiesFile.getName(), dir);\r\n        AbstractReferenceDataSetup setup;\r\n        if (onlineTestId.equals(\"oracle\")) {\r\n            mapping = mapping.replaceAll(DS_PARAMETERS, Matcher.quoteReplacement(AppSchemaTestOracleSetup.DB_PARAMS));\r\n            setup = AppSchemaTestOracleSetup.getInstance(propertyFiles);\r\n        } else {\r\n            mapping = mapping.replaceAll(DS_PARAMETERS, Matcher.quoteReplacement(AppSchemaTestPostgisSetup.DB_PARAMS));\r\n            setup = AppSchemaTestPostgisSetup.getInstance(propertyFiles);\r\n        }\r\n        setup.setUp();\r\n        setup.tearDown();\r\n    }\r\n    IOUtils.copy(new ByteArrayInputStream(mapping.getBytes(\"UTF-8\")), new File(dir, \"MappedFeature.xml\"));\r\n}"
}, {
	"Path": "org.geoserver.ows.Request.setError",
	"Comment": "allows callbacks to override the operation execution error",
	"Method": "void setError(Throwable error){\r\n    this.error = error;\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.CoverageStoreEditPage.doSaveStore",
	"Comment": "performs the save of the store.this method may be subclasses to provide custom save functionality.",
	"Method": "void doSaveStore(CoverageStoreInfo info){\r\n    try {\r\n        Catalog catalog = getCatalog();\r\n        final String prefix = info.getWorkspace().getName();\r\n        final NamespaceInfo namespace = catalog.getNamespaceByPrefix(prefix);\r\n        List<CoverageInfo> alreadyConfigured;\r\n        alreadyConfigured = catalog.getResourcesByStore(info, CoverageInfo.class);\r\n        for (CoverageInfo coverage : alreadyConfigured) {\r\n            coverage.setNamespace(namespace);\r\n        }\r\n        ResourcePool resourcePool = catalog.getResourcePool();\r\n        resourcePool.clear(info);\r\n        CoverageStoreInfo expandedStore = resourcePool.clone(info, true);\r\n        catalog.validate(expandedStore, false).throwIfInvalid();\r\n        catalog.save(info);\r\n        for (CoverageInfo coverage : alreadyConfigured) {\r\n            catalog.save(coverage);\r\n        }\r\n        LOGGER.finer(\"Saved store \" + info.getName());\r\n    } catch (RuntimeException e) {\r\n        LOGGER.log(Level.WARNING, \"Saving the store for \" + info.getURL(), e);\r\n        throw new IllegalArgumentException(\"Unable to save the store: \" + e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.platform.resource.Resources.renameByCopy",
	"Comment": "renames a resource by reading it and writing to the new resource, then deleting the old one.this is not atomic.",
	"Method": "boolean renameByCopy(Resource source,Resource destination){\r\n    try {\r\n        copy(source, destination);\r\n        return source.delete();\r\n    } catch (IOException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wms.web.data.ExternalGraphicPanel.getExternalGraphic",
	"Comment": "validates the external graphic and returns a connection to the graphic. if validation fails,error messages will be added to the passed form",
	"Method": "URLConnection getExternalGraphic(AjaxRequestTarget target,Form<?> form){\r\n    onlineResource.processInput();\r\n    if (onlineResource.getModelObject() != null) {\r\n        URL url = null;\r\n        try {\r\n            String baseUrl = baseURL(form);\r\n            String external = onlineResource.getModelObject().toString();\r\n            URI uri = new URI(external);\r\n            if (uri.isAbsolute()) {\r\n                url = uri.toURL();\r\n                if (!external.startsWith(baseUrl)) {\r\n                    form.warn(\"Recommend use of styles directory at \" + baseUrl);\r\n                }\r\n            } else {\r\n                WorkspaceInfo wsInfo = ((StyleInfo) getDefaultModelObject()).getWorkspace();\r\n                if (wsInfo != null) {\r\n                    url = new URL(ResponseUtils.appendPath(baseUrl, \"styles\", wsInfo.getName(), external));\r\n                } else {\r\n                    url = new URL(ResponseUtils.appendPath(baseUrl, \"styles\", external));\r\n                }\r\n            }\r\n            URLConnection conn = url.openConnection();\r\n            if (\"text/html\".equals(conn.getContentType())) {\r\n                form.error(\"Unable to access url\");\r\n                return null;\r\n            }\r\n            return conn;\r\n        } catch (FileNotFoundException notFound) {\r\n            form.error(\"Unable to access \" + url);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            form.error(\"Recommend use of styles directory at \" + e);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.vfny.geoserver.global.xml.WriterHelper.closeTag",
	"Comment": "closetag purpose.writes an close xml tag with the name specified to the stored output writer.",
	"Method": "void closeTag(String tagName){\r\n    decreaseIndent();\r\n    writeln(\"<\/\" + tagName + \">\");\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaMockData.copyMappingAndSupportFiles",
	"Comment": "copy the mapping and property files to the feature type directory.",
	"Method": "void copyMappingAndSupportFiles(String namespacePrefix,String typeName,String mappingFileName,String supportFileNames){\r\n    onlineTestId = System.getProperty(\"testDatabase\");\r\n    if (onlineTestId != null) {\r\n        onlineTestId = onlineTestId.toLowerCase().trim();\r\n        try {\r\n            String newContent = modifyOnlineMappingFileContent(mappingFileName);\r\n            copy(newContent, \"featureTypes/\" + getDataStoreName(namespacePrefix, typeName) + \"/\" + getFileNamePart(mappingFileName));\r\n            for (String propertyFileName : supportFileNames) {\r\n                if (propertyFileName.endsWith(\".xml\")) {\r\n                    newContent = modifyOnlineMappingFileContent(propertyFileName);\r\n                    copy(newContent, \"featureTypes/\" + getDataStoreName(namespacePrefix, typeName) + \"/\" + getFileNamePart(propertyFileName));\r\n                } else {\r\n                    copyFileToFeatureTypeDir(namespacePrefix, typeName, propertyFileName);\r\n                    if (propertyFileName.endsWith(\".properties\")) {\r\n                        File file = new File(propertyFileName);\r\n                        if (file.exists()) {\r\n                            propertyFileName = file.getName();\r\n                        }\r\n                        propertiesFiles.put(propertyFileName, getFeatureTypeDir(featureTypesBaseDir, namespacePrefix, typeName));\r\n                    }\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    } else {\r\n        copyFileToFeatureTypeDir(namespacePrefix, typeName, mappingFileName);\r\n        for (String propertyFileName : supportFileNames) {\r\n            copyFileToFeatureTypeDir(namespacePrefix, typeName, propertyFileName);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.impl.RoleHierarchyHelper.getAncestors",
	"Comment": "calculate an ordered list of ancestors, starting with the parent",
	"Method": "List<String> getAncestors(String roleName){\r\n    checkRole(roleName);\r\n    List<String> ancestors = new ArrayList<String>();\r\n    fillAncestors(parentMappings.get(roleName), ancestors);\r\n    return ancestors;\r\n}"
}, {
	"Path": "org.geoserver.security.keycloak.GeoServerKeycloakFilterConfig.readAdapterConfig",
	"Comment": "convert the adapter configuration into an object we can use to configure the rest of thecontext.",
	"Method": "AdapterConfig readAdapterConfig(){\r\n    LOG.log(Level.FINER, \"GeoServerKeycloakFilterConfig.readAdapterConfig ENTRY\");\r\n    try {\r\n        return KeycloakDeploymentBuilder.loadAdapterConfig(IOUtils.toInputStream(getAdapterConfig()));\r\n    } catch (RuntimeException e) {\r\n        throw new IOException(e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.util.ReaderUtils.getKeyWords",
	"Comment": "getkeywords purpose.used to help with xml manipulations. returns a list of keywords that were found.",
	"Method": "List getKeyWords(Element keywordsElem){\r\n    if (keywordsElem == null) {\r\n        return Collections.EMPTY_LIST;\r\n    }\r\n    NodeList klist = keywordsElem.getElementsByTagName(\"keyword\");\r\n    int kCount = klist.getLength();\r\n    List keywords = new ArrayList(kCount);\r\n    String kword;\r\n    Element kelem;\r\n    for (int i = 0; i < kCount; i++) {\r\n        kelem = (Element) klist.item(i);\r\n        kword = getElementText(kelem);\r\n        if (kword != null) {\r\n            keywords.add(kword);\r\n        }\r\n    }\r\n    Object[] s = (Object[]) keywords.toArray();\r\n    if (s == null) {\r\n        return new ArrayList();\r\n    }\r\n    ArrayList ss = new ArrayList(s.length);\r\n    for (int i = 0; i < s.length; i++) ss.add(s[i]);\r\n    return ss;\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexSolrTest.checkNoStationId",
	"Comment": "helper method that just checks that there is no station that matches the provided id in thexml response.",
	"Method": "void checkNoStationId(Integer id,XpathEngine engine,Document document){\r\n    checkCount(engine, document, 0, String.format(\"/wfs:FeatureCollection/gml:featureMembers/st:Station[@gml:id='%s']\", id));\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDimensionsSubsetHelper.extractTemporalSubset",
	"Comment": "parses a date range out of the dimension subsetting directives",
	"Method": "DateRange extractTemporalSubset(){\r\n    DateRange timeSubset = null;\r\n    if (timeDimension != null) {\r\n        for (DimensionSubsetType dim : request.getDimensionSubset()) {\r\n            String dimension = WCSDimensionsSubsetHelper.getDimensionName(dim);\r\n            if (!TIME_NAMES.contains(dimension.toLowerCase())) {\r\n                continue;\r\n            }\r\n            if (timeSubset != null) {\r\n                throw new WCS20Exception(\"Time dimension trimming/slicing specified twice in the request\", WCS20Exception.WCS20ExceptionCode.InvalidSubsetting, \"subset\");\r\n            }\r\n            if (dim instanceof DimensionTrimType) {\r\n                final DimensionTrimType trim = (DimensionTrimType) dim;\r\n                final Date low = PARSER.parseDateTime(trim.getTrimLow());\r\n                final Date high = PARSER.parseDateTime(trim.getTrimHigh());\r\n                if (low.compareTo(high) > 0) {\r\n                    throw new WCS20Exception(\"Low greater than High: \" + trim.getTrimLow() + \", \" + trim.getTrimHigh(), WCS20Exception.WCS20ExceptionCode.InvalidSubsetting, \"subset\");\r\n                }\r\n                timeSubset = new DateRange(low, high);\r\n            } else if (dim instanceof DimensionSliceType) {\r\n                final DimensionSliceType slicing = (DimensionSliceType) dim;\r\n                final String slicePointS = slicing.getSlicePoint();\r\n                final Date slicePoint = PARSER.parseDateTime(slicePointS);\r\n                timeSubset = new DateRange(slicePoint, slicePoint);\r\n            } else {\r\n                throw new WCS20Exception(\"Invalid element found while attempting to parse dimension subsetting request: \" + dim.getClass().toString(), WCS20Exception.WCS20ExceptionCode.InvalidSubsetting, \"subset\");\r\n            }\r\n        }\r\n        if (!(reader instanceof StructuredGridCoverage2DReader) && timeSubset != null && !timeSubset.getMinValue().equals(timeSubset.getMaxValue())) {\r\n            throw new WCS20Exception(\"Trimming on time is not supported at the moment on not StructuredGridCoverage2DReaders, only slicing is\");\r\n        }\r\n        if (timeSubset != null && timeSubset.getMinValue().equals(timeSubset.getMaxValue())) {\r\n            timeSubset = interpolateTime(timeSubset, accessor);\r\n        }\r\n    }\r\n    return timeSubset;\r\n}"
}, {
	"Path": "org.geoserver.web.demo.MapPreviewPage.buildJSWMSSelect",
	"Comment": "builds a select that reacts like a menu, fully javascript based, for wms outputs",
	"Method": "Component buildJSWMSSelect(String id,List<String> wmsOutputFormats,List<String> wfsOutputFormats,PreviewLayer layer){\r\n    Fragment f = new Fragment(id, \"menuFragment\", MapPreviewPage.this);\r\n    WebMarkupContainer menu = new WebMarkupContainer(\"menu\");\r\n    WebMarkupContainer wmsFormatsGroup = new WebMarkupContainer(\"wms\");\r\n    RepeatingView wmsFormats = new RepeatingView(\"wmsFormats\");\r\n    for (int i = 0; i < wmsOutputFormats.size(); i++) {\r\n        String wmsOutputFormat = wmsOutputFormats.get(i);\r\n        String label = translateFormat(\"format.wms.\", wmsOutputFormat);\r\n        Label format = new Label(i + \"\", label);\r\n        format.add(new AttributeModifier(\"value\", new Model<String>(ResponseUtils.urlEncode(wmsOutputFormat))));\r\n        wmsFormats.add(format);\r\n    }\r\n    wmsFormatsGroup.add(wmsFormats);\r\n    wmsFormatsGroup.setVisible(CollectionUtils.isNotEmpty(wmsOutputFormats));\r\n    menu.add(wmsFormatsGroup);\r\n    boolean vector = layer.groupInfo == null && (layer.layerInfo.getType() == PublishedType.VECTOR || layer.layerInfo.getType() == PublishedType.REMOTE);\r\n    WebMarkupContainer wfsFormatsGroup = new WebMarkupContainer(\"wfs\");\r\n    RepeatingView wfsFormats = new RepeatingView(\"wfsFormats\");\r\n    if (vector) {\r\n        for (int i = 0; i < wfsOutputFormats.size(); i++) {\r\n            String wfsOutputFormat = wfsOutputFormats.get(i);\r\n            String label = translateFormat(\"format.wfs.\", wfsOutputFormat);\r\n            Label format = new Label(i + \"\", label);\r\n            format.add(new AttributeModifier(\"value\", new Model<String>(ResponseUtils.urlEncode(wfsOutputFormat))));\r\n            wfsFormats.add(format);\r\n        }\r\n    }\r\n    wfsFormatsGroup.add(wfsFormats);\r\n    wfsFormatsGroup.setVisible(CollectionUtils.isNotEmpty(wfsOutputFormats));\r\n    menu.add(wfsFormatsGroup);\r\n    String wmsUrl = \"'\" + layer.getWmsLink() + \"&format=' + this.options[this.selectedIndex].value\";\r\n    String wfsUrl = \"'\" + layer.buildWfsLink() + getMaxFeatures() + \"&outputFormat=' + this.options[this.selectedIndex].value\";\r\n    String choice = \"(this.options[this.selectedIndex].parentNode.label == 'WMS') ? \" + wmsUrl + \" : \" + wfsUrl;\r\n    menu.add(new AttributeAppender(\"onchange\", new Model<String>(\"window.open(\" + choice + \");this.selectedIndex=0\"), \";\"));\r\n    f.add(menu);\r\n    return f;\r\n}"
}, {
	"Path": "org.geoserver.kml.KMLReflectorTest.testWMSElevationRequest",
	"Comment": "method testwmselevationrequest tests if the elevation parameter of the request is also passedto the kml wms request.",
	"Method": "void testWMSElevationRequest(){\r\n    String layerId = getLayerId(MockData.BASIC_POLYGONS);\r\n    String expectedTS = \"elevation=500\";\r\n    final String requestUrl = \"wms/kml?layers=\" + layerId + \"&styles=polygon&mode=refresh&bbox=10.56,46.99,11.50,47.26&\" + expectedTS;\r\n    Document doc = getAsDOM(requestUrl);\r\n    NodeList nodes = doc.getElementsByTagName(\"href\");\r\n    for (int i = 0; i < nodes.getLength(); ++i) {\r\n        Element e = (Element) nodes.item(i);\r\n        String actualTS = e.getTextContent();\r\n        Assert.assertTrue(\"Elevation parameter missing\", actualTS.contains(expectedTS));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.ppio.XStreamPPIO.buildXStream",
	"Comment": "subclasses can override the xstream configuration here. by default xstream is setup to strippackage names, have tags starts with a capital letter, and flatten out collections",
	"Method": "SecureXStream buildXStream(){\r\n    SecureXStream stream = new SecureXStream() {\r\n        protected MapperWrapper wrapMapper(MapperWrapper next) {\r\n            return new UppercaseTagMapper(new PackageStrippingMapper(next));\r\n        }\r\n    };\r\n    return stream;\r\n}"
}, {
	"Path": "org.geoserver.wps.ppio.XStreamPPIO.buildXStream",
	"Comment": "subclasses can override the xstream configuration here. by default xstream is setup to strippackage names, have tags starts with a capital letter, and flatten out collections",
	"Method": "SecureXStream buildXStream(){\r\n    return new UppercaseTagMapper(new PackageStrippingMapper(next));\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDimensionsSubsetHelper.getDimensionName",
	"Comment": "extracts the simplified dimension name, throws exception if the dimension name is empty",
	"Method": "String getDimensionName(DimensionSubsetType dim){\r\n    String dimension = dim.getDimension();\r\n    if (dimension.startsWith(\"http://www.opengis.net/def/axis/OGC/0/\")) {\r\n        dimension = dimension.substring(\"http://www.opengis.net/def/axis/OGC/0/\".length());\r\n    } else if (dimension.startsWith(\"http://opengis.net/def/axis/OGC/0/\")) {\r\n        dimension = dimension.substring(\"http://opengis.net/def/axis/OGC/0/\".length());\r\n    } else if (dimension.startsWith(\"http://opengis.net/def/crs/ISO/2004/\")) {\r\n        dimension = dimension.substring(\"http://opengis.net/def/crs/ISO/2004/\".length());\r\n    }\r\n    if (dimension == null || dimension.length() <= 0) {\r\n        throw new WCS20Exception(\"Empty/invalid axis label provided: \" + dim.getDimension(), WCS20Exception.WCS20ExceptionCode.InvalidAxisLabel, \"subset\");\r\n    }\r\n    return dimension;\r\n}"
}, {
	"Path": "org.geoserver.kml.builder.SuperOverlayNetworkLinkBuilder.encodeNetworkLinks",
	"Comment": "encode the network links for the specified envelope and zoom level",
	"Method": "void encodeNetworkLinks(Folder folder,Layer layer,Envelope top,int zoomLevel){\r\n    if (top != KmlEncodingContext.WORLD_BOUNDS_WGS84) {\r\n        Envelope e00 = new Envelope(top.getMinX(), top.getMinX() + (top.getWidth() / 2d), top.getMaxY() - (top.getHeight() / 2d), top.getMaxY());\r\n        Envelope e01 = new Envelope(e00.getMaxX(), top.getMaxX(), e00.getMinY(), e00.getMaxY());\r\n        Envelope e10 = new Envelope(e00.getMinX(), e00.getMaxX(), top.getMinY(), e00.getMinY());\r\n        Envelope e11 = new Envelope(e01.getMinX(), e01.getMaxX(), e10.getMinY(), e10.getMaxY());\r\n        addNetworkLink(folder, e00, \"00\", layer);\r\n        addNetworkLink(folder, e01, \"01\", layer);\r\n        addNetworkLink(folder, e10, \"10\", layer);\r\n        addNetworkLink(folder, e11, \"11\", layer);\r\n    } else {\r\n        Envelope e0 = new Envelope(top.getMinX(), top.getMinX() + (top.getWidth() / 2d), top.getMinY(), top.getMaxY());\r\n        Envelope e1 = new Envelope(e0.getMaxX(), top.getMaxX(), top.getMinY(), top.getMaxY());\r\n        addNetworkLink(folder, e0, \"0\", layer);\r\n        addNetworkLink(folder, e1, \"1\", layer);\r\n    }\r\n    if (top == KmlEncodingContext.WORLD_BOUNDS_WGS84) {\r\n        encodeTileContents(folder, layer, \"contents-0\", zoomLevel, new Envelope(-180, 0, -90, 90));\r\n        encodeTileContents(folder, layer, \"contents-1\", zoomLevel, new Envelope(0, 180, -90, 90));\r\n    } else {\r\n        encodeTileContents(folder, layer, \"contents\", zoomLevel, top);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.DimensionsUtils.getMaxValue",
	"Comment": "helper method that return the maximum value. if the first value of the tree set is a rangethe maximum value of the range is returned.",
	"Method": "Object getMaxValue(List<Object> values){\r\n    Object maxValue = values.get(values.size() - 1);\r\n    if (maxValue instanceof Range) {\r\n        return ((Range) maxValue).getMaxValue();\r\n    }\r\n    return maxValue;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.dom",
	"Comment": "helper method that extracts the content of http response assuming that the content is xml andparse it.",
	"Method": "Document dom(MockHttpServletResponse response,boolean skipSchemaValidation,Document dom,InputStream is,Document dom,InputStream input,boolean skipDTD,Document dom,InputStream stream,boolean skipDTD,String encoding){\r\n    InputSource input = new InputSource(stream);\r\n    if (encoding != null) {\r\n        input.setEncoding(encoding);\r\n    } else {\r\n        input.setEncoding(Charset.defaultCharset().name());\r\n    }\r\n    if (skipDTD) {\r\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\r\n        factory.setNamespaceAware(true);\r\n        factory.setValidating(false);\r\n        DocumentBuilder builder = factory.newDocumentBuilder();\r\n        builder.setEntityResolver(new EmptyResolver());\r\n        Document dom = builder.parse(input);\r\n        return dom;\r\n    } else {\r\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\r\n        factory.setNamespaceAware(true);\r\n        DocumentBuilder builder = factory.newDocumentBuilder();\r\n        return builder.parse(input);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.cluster.JmsEventsListener.getMessagesForHandler",
	"Comment": "searches the events that match a certain handler and apply the handler to those elements.",
	"Method": "List<T> getMessagesForHandler(List<Message> messages,String handlerName,JMSEventHandler<String, T> handler){\r\n    List<T> found = new ArrayList();\r\n    for (Message message : messages) {\r\n        try {\r\n            String handlerKey = message.getStringProperty(JMSEventHandlerSPI.getKeyName());\r\n            if (handlerKey.equals(handlerName) && message instanceof ObjectMessage) {\r\n                String object = ((ObjectMessage) message).getObject().toString();\r\n                found.add(handler.deserialize(object));\r\n            }\r\n        } catch (Exception exception) {\r\n        }\r\n    }\r\n    return found;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findResourceDir",
	"Comment": "returns the directory in which a resources configuration is persisted, if the directory doesnot exist null is returned.",
	"Method": "File findResourceDir(ResourceInfo resource){\r\n    Resource directory = get(resource);\r\n    return Resources.directory(directory);\r\n}"
}, {
	"Path": "org.geoserver.rest.catalog.StyleController.getSldFileFromDirectory",
	"Comment": "returns the sld file in the given directory. if no sld file, throws an appropriate exception",
	"Method": "File getSldFileFromDirectory(File directory){\r\n    File[] matchingFiles = directory.listFiles((dir, name) -> name.endsWith(\"sld\"));\r\n    if (matchingFiles == null || matchingFiles.length == 0) {\r\n        throw new RestException(\"No sld file provided:\", HttpStatus.FORBIDDEN);\r\n    }\r\n    LOGGER.fine(\"getSldFileFromDirectory (sldFile): \" + matchingFiles[0].getAbsolutePath());\r\n    return matchingFiles[0];\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.loadFilter",
	"Comment": "loads an authentication provider from a named configuration.",
	"Method": "GeoServerSecurityFilter loadFilter(String name){\r\n    return filterHelper.load(name);\r\n}"
}, {
	"Path": "org.geoserver.wps.remote.plugin.XMPPClient.setupChat",
	"Comment": "conversation setup!messages should be moved here once we get this working properly",
	"Method": "Chat setupChat(String origin){\r\n    synchronized (openChat) {\r\n        if (openChat.get(origin) != null) {\r\n            return openChat.get(origin);\r\n        }\r\n        MessageListener listener = new MessageListener() {\r\n            public void processMessage(Chat chat, Message message) {\r\n            }\r\n        };\r\n        Chat chat = chatManager.createChat(origin, listener);\r\n        openChat.put(origin, chat);\r\n        return chat;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.remote.plugin.XMPPClient.setupChat",
	"Comment": "conversation setup!messages should be moved here once we get this working properly",
	"Method": "Chat setupChat(String origin){\r\n}"
}, {
	"Path": "org.geoserver.csw.GetRecordsTest.testSpatialFilterNonGeomProperty",
	"Comment": "from cite compliance, throw an error if a non spatial property is used in a spatial filter",
	"Method": "void testSpatialFilterNonGeomProperty(){\r\n    String request = \"csw?service=CSW&version=2.0.2&request=GetRecords&typeNames=csw:Record&resultType=results\" + \"&elementName=dc:identifier,ows:BoundingBox&constraint=BBOX(dct:spatial, 47.0, -4.5, 52.0, 1.0)\";\r\n    Document d = getAsDOM(request);\r\n    checkOws10Exception(d);\r\n}"
}, {
	"Path": "org.geoserver.wps.executor.WPSExecutionManager.getConnectionTimeout",
	"Comment": "returns the http connection timeout for remote resource fetching",
	"Method": "int getConnectionTimeout(){\r\n    return connectionTimeout;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.parsedStyle",
	"Comment": "retrieve the style prepared for direct geotools use. all file references have been madeabsolute.",
	"Method": "Style parsedStyle(StyleInfo s){\r\n    final StyledLayerDescriptor sld = parsedSld(s);\r\n    final Style style = Styles.style(sld);\r\n    assert style != null;\r\n    return style;\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.WMSStoreEditPage.doSaveStore",
	"Comment": "performs the save of the store.this method may be subclasses to provide custom save functionality.",
	"Method": "void doSaveStore(WMSStoreInfo info){\r\n    Catalog catalog = getCatalog();\r\n    WMSStoreInfo expandedStore = catalog.getResourcePool().clone(info, true);\r\n    getCatalog().validate(expandedStore, false).throwIfInvalid();\r\n    getCatalog().save(info);\r\n    doReturn(StorePage.class);\r\n}"
}, {
	"Path": "org.geoserver.web.HeaderContribution.getCSS",
	"Comment": "returns the resource reference to the css for the header contribution, or null if there is nocss contribution.",
	"Method": "PackageResourceReference getCSS(){\r\n    if (scope != null && cssFilename != null) {\r\n        return new PackageResourceReference(scope, cssFilename);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.community.css.web.StyleEditCssRecoveryTest.testRecoverLostCssStyle",
	"Comment": "test recovery of a css style generated by the old css extension, when the styleinfo has nodeclaredand its filename points to a derived sld.",
	"Method": "void testRecoverLostCssStyle(){\r\n    StyleInfo styleInfo = catalog.getStyleByName(oldCssStyle);\r\n    StyleEditPage edit = new StyleEditPage(styleInfo);\r\n    tester.startPage(edit);\r\n    tester.assertRenderedPage(StyleEditPage.class);\r\n    tester.assertNoErrorMessage();\r\n    tester.assertModelValue(\"styleForm:context:panel:format\", \"css\");\r\n    String editorContents = (String) tester.getComponentFromLastRenderedPage(\"styleForm:styleEditor:editorContainer:editorParent:editor\").getDefaultModelObject();\r\n    Styles.handler(\"css\").parse(editorContents, null, null, null);\r\n    StyleInfo si = catalog.getStyleByName(oldCssStyle);\r\n    assertEquals(\"css\", si.getFormat());\r\n    assertEquals(oldCssStyle + \".css\", si.getFilename());\r\n}"
}, {
	"Path": "org.geoserver.rest.security.AbstractAclController.validateMap",
	"Comment": "validates the string representation of rule keys and values",
	"Method": "void validateMap(Map<String, String> ruleMap){\r\n    for (Entry<String, String> entry : ruleMap.entrySet()) {\r\n        String msg = validateRule(entry.getKey(), entry.getValue());\r\n        if (msg != null) {\r\n            throw new RestException(msg, HttpStatus.UNPROCESSABLE_ENTITY);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.get",
	"Comment": "retrieve a resource in the the configuration directory of a resource. an empty path willretrieve the directory itself.",
	"Method": "Resource get(String path,Resource get,WorkspaceInfo ws,String path,Resource get,NamespaceInfo ns,String path,Resource get,StoreInfo store,String path,Resource get,ResourceInfo ri,String path,Resource get,LayerInfo l,String path,Resource get,LayerGroupInfo lgi,String path,Resource get,StyleInfo si,String path){\r\n    WorkspaceInfo workspace = si != null ? si.getWorkspace() : null;\r\n    final Resource r = getStyles(workspace, path);\r\n    assert r != null;\r\n    return r;\r\n}"
}, {
	"Path": "org.geoserver.config.util.XStreamPersister.unwrapProxies",
	"Comment": "unwraps any proxies around the object.if the object is not being proxied it is passed back.",
	"Method": "Object unwrapProxies(Object obj){\r\n    obj = SecureCatalogImpl.unwrap(obj);\r\n    obj = GeoServerImpl.unwrap(obj);\r\n    obj = CatalogImpl.unwrap(obj);\r\n    return obj;\r\n}"
}, {
	"Path": "org.geoserver.ows.util.RewindableInputStream.setStartOffset",
	"Comment": "sets the position somewhere in the stream to which the stream pointer will be reset afterrewind invocation. by default this position is the beginning of the stream.",
	"Method": "void setStartOffset(int offset){\r\n    fStartOffset = offset;\r\n}"
}, {
	"Path": "org.geoserver.ows.util.KvpUtils.getSingleValue",
	"Comment": "returns a single value for the specified key from the raw kvp, or throws an exception ifmultiple different values are found",
	"Method": "String getSingleValue(Map kvp,String key){\r\n    Object value = kvp.get(key);\r\n    if (value == null) {\r\n        return null;\r\n    } else if (value instanceof String) {\r\n        return (String) value;\r\n    } else {\r\n        String[] strings = (String[]) value;\r\n        if (strings.length == 0) {\r\n            return null;\r\n        }\r\n        String result = strings[0];\r\n        for (int i = 1; i < strings.length; i++) {\r\n            if (!result.equals(strings[i])) {\r\n                throw new ServiceException(\"Single value expected for request parameter \" + key + \" but instead found: \" + Arrays.toString(strings), ServiceException.INVALID_PARAMETER_VALUE, key);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.PropertyEncodingOrderTest.testPropertyEncodingOrder_GeologicUnit",
	"Comment": "test elements are encoded in the order as defined in the schema geologicunit is tested here",
	"Method": "void testPropertyEncodingOrder_GeologicUnit(){\r\n    WFSInfo wfs = getGeoServer().getService(WFSInfo.class);\r\n    wfs.setEncodeFeatureMember(true);\r\n    getGeoServer().save(wfs);\r\n    String path = \"wfs?request=GetFeature&version=1.1.0&typename=gsml:GeologicUnit&featureid=gu.25699\";\r\n    Document doc = getAsDOM(path);\r\n    LOGGER.info(\"WFS GetFeature&typename=gsml:GeologicUnit&featureid=gu.25699:\\n\" + prettyString(doc));\r\n    assertEquals(1, doc.getElementsByTagName(\"gml:featureMember\").getLength());\r\n    assertXpathCount(1, \"//gsml:GeologicUnit[@gml:id='gu.25699']\", doc);\r\n    Node feature = doc.getElementsByTagName(\"gsml:GeologicUnit\").item(0);\r\n    assertEquals(\"gsml:GeologicUnit\", feature.getNodeName());\r\n    Node description = feature.getFirstChild();\r\n    assertEquals(\"gml:description\", description.getNodeName());\r\n    assertXpathEvaluatesTo(\"Olivine basalt, tuff, microgabbro, minor sedimentary rocks\", \"//gsml:GeologicUnit[@gml:id='gu.25699']/gml:description\", doc);\r\n    Node name1 = description.getNextSibling();\r\n    assertEquals(\"gml:name\", name1.getNodeName());\r\n    assertXpathEvaluatesTo(\"Yaugher Volcanic Group\", \"//gsml:GeologicUnit[@gml:id='gu.25699']/gml:name[1]\", doc);\r\n    Node name2 = name1.getNextSibling();\r\n    assertEquals(\"gml:name\", name2.getNodeName());\r\n    assertXpathEvaluatesTo(\"-Py\", \"//gsml:GeologicUnit[@gml:id='gu.25699']/gml:name[2]\", doc);\r\n    Node observationMethod = name2.getNextSibling();\r\n    assertEquals(\"gsml:observationMethod\", observationMethod.getNodeName());\r\n    assertXpathEvaluatesTo(\"urn:ogc:def:nil:OGC::missing\", \"//gsml:GeologicUnit[@gml:id='gu.25699']/gsml:observationMethod/gsml:CGI_TermValue/gsml:value\", doc);\r\n    assertXpathEvaluatesTo(\"http://urn.opengis.net\", \"//gsml:GeologicUnit[@gml:id='gu.25699']/gsml:observationMethod/gsml:CGI_TermValue/gsml:value/@codeSpace\", doc);\r\n    Node purpose = observationMethod.getNextSibling();\r\n    assertEquals(\"gsml:purpose\", purpose.getNodeName());\r\n    assertXpathEvaluatesTo(\"instance\", \"//gsml:GeologicUnit[@gml:id='gu.25699']/gsml:purpose\", doc);\r\n    Node occurrence = purpose.getNextSibling();\r\n    assertEquals(\"gsml:occurrence\", occurrence.getNodeName());\r\n    assertXpathCount(1, \"//gsml:GeologicUnit[@gml:id='gu.25699']/gsml:occurrence[@xlink:href='urn:cgi:feature:MappedFeature:mf1']\", doc);\r\n    Node geologicUnitType = occurrence.getNextSibling();\r\n    assertEquals(\"gsml:geologicUnitType\", geologicUnitType.getNodeName());\r\n    assertXpathEvaluatesTo(\"urn:ogc:def:nil:OGC::unknown\", \"//gsml:GeologicUnit[@gml:id='gu.25699']/gsml:geologicUnitType/@xlink:href\", doc);\r\n    Node exposureColor = geologicUnitType.getNextSibling();\r\n    assertEquals(\"gsml:exposureColor\", exposureColor.getNodeName());\r\n    assertXpathEvaluatesTo(\"Blue\", \"//gsml:GeologicUnit[@gml:id='gu.25699']/gsml:exposureColor/gsml:CGI_TermValue/gsml:value\", doc);\r\n    Node outcropCharacter = exposureColor.getNextSibling();\r\n    assertEquals(\"gsml:outcropCharacter\", outcropCharacter.getNodeName());\r\n    assertXpathEvaluatesTo(\"x\", \"//gsml:GeologicUnit[@gml:id='gu.25699']/gsml:outcropCharacter/gsml:CGI_TermValue/gsml:value\", doc);\r\n    Node composition = outcropCharacter.getNextSibling();\r\n    assertEquals(\"gsml:composition\", composition.getNodeName());\r\n    Node compositionPart = doc.getElementsByTagName(\"gsml:CompositionPart\").item(0);\r\n    assertEquals(\"gsml:CompositionPart\", compositionPart.getNodeName());\r\n    Node role = compositionPart.getFirstChild();\r\n    assertEquals(\"gsml:role\", role.getNodeName());\r\n    assertXpathEvaluatesTo(\"fictitious component\", \"//gsml:GeologicUnit[@gml:id='gu.25699']/gsml:composition/gsml:CompositionPart/gsml:role\", doc);\r\n    Node lithology = role.getNextSibling();\r\n    assertEquals(\"gsml:lithology\", lithology.getNodeName());\r\n    assertXpathEvaluatesTo(\"urn:ogc:def:nil:OGC::missing\", \"//gsml:GeologicUnit[@gml:id='gu.25699']/gsml:composition/gsml:CompositionPart/gsml:lithology\" + \"/gsml:ControlledConcept/gsml:vocabulary/@xlink:href\", doc);\r\n    Node proportion = lithology.getNextSibling();\r\n    assertEquals(\"gsml:proportion\", proportion.getNodeName());\r\n    assertXpathEvaluatesTo(\"nonexistent\", \"//gsml:GeologicUnit[@gml:id='gu.25699']/gsml:composition/gsml:CompositionPart/gsml:proportion\" + \"/gsml:CGI_TermValue/gsml:value\", doc);\r\n    validateGet(path);\r\n}"
}, {
	"Path": "org.geoserver.wms.web.data.StyleEditPageWorkspaceRenameAndEditTest.testMoveWorkspaceAndEdit",
	"Comment": "test that a user can update the .sld file contents and move the style into a workspace in a single edit.",
	"Method": "void testMoveWorkspaceAndEdit(){\r\n    final boolean[] gotValidEvent = { false };\r\n    getCatalog().addListener(new CatalogListener() {\r\n        @Override\r\n        public void handleAddEvent(CatalogAddEvent event) throws CatalogException {\r\n        }\r\n        @Override\r\n        public void handleRemoveEvent(CatalogRemoveEvent event) throws CatalogException {\r\n        }\r\n        @Override\r\n        public void handleModifyEvent(CatalogModifyEvent event) throws CatalogException {\r\n        }\r\n        @Override\r\n        public void handlePostModifyEvent(CatalogPostModifyEvent event) throws CatalogException {\r\n            assertThat(event, notNullValue());\r\n            assertThat(event.getSource(), notNullValue());\r\n            if (!(event.getSource() instanceof StyleInfo)) {\r\n                return;\r\n            }\r\n            try {\r\n                StyleInfo styleInfo = (StyleInfo) event.getSource();\r\n                assertThat(styleInfo, notNullValue());\r\n                Style style = getCatalog().getResourcePool().getStyle(styleInfo);\r\n                assertThat(style, notNullValue());\r\n                assertThat(style.featureTypeStyles().size(), is(2));\r\n                gotValidEvent[0] = true;\r\n            } catch (Exception exception) {\r\n                LOGGER.log(Level.SEVERE, \"Error handling catalog modified style event.\", exception);\r\n            }\r\n        }\r\n        @Override\r\n        public void reloaded() {\r\n        }\r\n    });\r\n    edit = new StyleEditPage(styleInfoToMove);\r\n    tester.startPage(edit);\r\n    assertEquals(1, styleInfoToMove.getStyle().featureTypeStyles().size());\r\n    FormTester form = tester.newFormTester(\"styleForm\", false);\r\n    DropDownChoice<WorkspaceInfo> typeDropDown = (DropDownChoice<WorkspaceInfo>) tester.getComponentFromLastRenderedPage(\"styleForm:context:panel:workspace\");\r\n    for (int wsIdx = 0; wsIdx < typeDropDown.getChoices().size(); wsIdx++) {\r\n        WorkspaceInfo ws = typeDropDown.getChoices().get(wsIdx);\r\n        if (\"sf\".equalsIgnoreCase(ws.getName())) {\r\n            form.select(\"context:panel:workspace\", wsIdx);\r\n            break;\r\n        }\r\n    }\r\n    File styleFile = new File(getClass().getResource(STYLE_TO_MOVE_FILENAME_UPDATED).toURI());\r\n    String updatedSld = IOUtils.toString(new FileReader(styleFile)).replaceAll(\"\\r\\n\", \"\\n\").replaceAll(\"\\r\", \"\\n\");\r\n    form.setValue(\"styleEditor:editorContainer:editorParent:editor\", updatedSld);\r\n    form.submit();\r\n    StyleInfo si = getCatalog().getStyleByName(getCatalog().getWorkspaceByName(\"sf\"), STYLE_TO_MOVE_NAME);\r\n    assertNotNull(si);\r\n    assertNotNull(si.getWorkspace());\r\n    assertEquals(\"sf\", si.getWorkspace().getName());\r\n    assertEquals(2, si.getStyle().featureTypeStyles().size());\r\n    assertThat(gotValidEvent[0], is(true));\r\n}"
}, {
	"Path": "org.geoserver.wms.web.data.StyleEditPageWorkspaceRenameAndEditTest.testMoveWorkspaceAndEdit",
	"Comment": "test that a user can update the .sld file contents and move the style into a workspace in a single edit.",
	"Method": "void testMoveWorkspaceAndEdit(){\r\n}"
}, {
	"Path": "org.geoserver.wms.web.data.StyleEditPageWorkspaceRenameAndEditTest.testMoveWorkspaceAndEdit",
	"Comment": "test that a user can update the .sld file contents and move the style into a workspace in a single edit.",
	"Method": "void testMoveWorkspaceAndEdit(){\r\n}"
}, {
	"Path": "org.geoserver.wms.web.data.StyleEditPageWorkspaceRenameAndEditTest.testMoveWorkspaceAndEdit",
	"Comment": "test that a user can update the .sld file contents and move the style into a workspace in a single edit.",
	"Method": "void testMoveWorkspaceAndEdit(){\r\n}"
}, {
	"Path": "org.geoserver.wms.web.data.StyleEditPageWorkspaceRenameAndEditTest.testMoveWorkspaceAndEdit",
	"Comment": "test that a user can update the .sld file contents and move the style into a workspace in a single edit.",
	"Method": "void testMoveWorkspaceAndEdit(){\r\n    assertThat(event, notNullValue());\r\n    assertThat(event.getSource(), notNullValue());\r\n    if (!(event.getSource() instanceof StyleInfo)) {\r\n        return;\r\n    }\r\n    try {\r\n        StyleInfo styleInfo = (StyleInfo) event.getSource();\r\n        assertThat(styleInfo, notNullValue());\r\n        Style style = getCatalog().getResourcePool().getStyle(styleInfo);\r\n        assertThat(style, notNullValue());\r\n        assertThat(style.featureTypeStyles().size(), is(2));\r\n        gotValidEvent[0] = true;\r\n    } catch (Exception exception) {\r\n        LOGGER.log(Level.SEVERE, \"Error handling catalog modified style event.\", exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wms.web.data.StyleEditPageWorkspaceRenameAndEditTest.testMoveWorkspaceAndEdit",
	"Comment": "test that a user can update the .sld file contents and move the style into a workspace in a single edit.",
	"Method": "void testMoveWorkspaceAndEdit(){\r\n}"
}, {
	"Path": "org.geoserver.security.SecureCatalogImpl.filterWorkspaces",
	"Comment": "given a list of workspaces, returns a copy of it containing only the workspaces the user canaccess",
	"Method": "List<T> filterWorkspaces(Authentication user,List<T> workspaces){\r\n    List<T> result = new ArrayList<T>();\r\n    for (T original : workspaces) {\r\n        T secured = checkAccess(user, original, MixedModeBehavior.HIDE);\r\n        if (secured != null)\r\n            result.add(secured);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findOrCreateStyleSldFile",
	"Comment": "returns the sld file for the specified style, if the file does not exist a file object isstill returned.",
	"Method": "File findOrCreateStyleSldFile(StyleInfo s){\r\n    Resource resource = style(s);\r\n    return resource.file();\r\n}"
}, {
	"Path": "org.geoserver.web.data.layer.CoverageViewAbstractPage.getFirstErrorMessage",
	"Comment": "data stores tend to return ioexceptions with no explanation, and the actual error coming fromthe db is in the cause. this method extracts the first not null message in the cause chain",
	"Method": "String getFirstErrorMessage(Throwable t){\r\n    Throwable original = t;\r\n    while (!(t instanceof SQLException)) {\r\n        t = t.getCause();\r\n        if (t == null) {\r\n            break;\r\n        }\r\n    }\r\n    if (t == null) {\r\n        return original.getMessage();\r\n    } else {\r\n        return t.getMessage();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.data.workspace.WorkspaceNewPage.cleanAndReport",
	"Comment": "helper method that checks in the case of an exception if both the workspace and namespacewhere created or removed, if it is not the case then removes the remaining one. the invokeris responsible to log the exception as needed.",
	"Method": "void cleanAndReport(Exception exception,Form form){\r\n    Catalog catalog = getCatalog();\r\n    WorkspaceInfo workspace = (WorkspaceInfo) form.getModelObject();\r\n    WorkspaceInfo foundWorkspace = catalog.getWorkspaceByName(workspace.getName());\r\n    if (foundWorkspace != null) {\r\n        NamespaceInfo foundNamespace = catalog.getNamespaceByPrefix(workspace.getName());\r\n        if (foundNamespace == null) {\r\n            catalog.remove(foundWorkspace);\r\n        }\r\n    }\r\n    form.error(exception.getMessage());\r\n}"
}, {
	"Path": "org.vfny.geoserver.util.Requests.isLoggedIn",
	"Comment": "tests is user is loggin in.true if usercontainer exists has been created.",
	"Method": "boolean isLoggedIn(HttpServletRequest request){\r\n    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\r\n    return (authentication != null) && !(authentication instanceof AnonymousAuthenticationToken);\r\n}"
}, {
	"Path": "org.geoserver.wps.security.WpsAccessRule.getKey",
	"Comment": "returns the key for the current rule. no other rule should have the same",
	"Method": "String getKey(){\r\n    return groupName + \".\" + wpsName;\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.encodePropertiesByType",
	"Comment": "encode feature properties by type, we do this way so we can handle the case were theseproperties should be encoded as a list or as elements that appear multiple times.",
	"Method": "void encodePropertiesByType(PropertyType parentType,PropertyType type,List<Property> properties){\r\n    PropertyDescriptor multipleType = isMultipleType(parentType, type);\r\n    if (multipleType == null) {\r\n        properties.forEach(this::encodeProperty);\r\n    } else {\r\n        List<Feature> chainedFeatures = getChainedFeatures(properties);\r\n        if (chainedFeatures == null || chainedFeatures.isEmpty()) {\r\n            List<Map<NameImpl, String>> linkedFeatures = getLinkedFeatures(properties);\r\n            if (!linkedFeatures.isEmpty()) {\r\n                encodeLinkedFeatures(multipleType.getName().getLocalPart(), linkedFeatures);\r\n            } else {\r\n                properties.forEach(this::encodeProperty);\r\n            }\r\n        } else {\r\n            encodeChainedFeatures(multipleType.getName().getLocalPart(), chainedFeatures);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.ImportProcessTest.testCreateDataStore",
	"Comment": "test creating a vector store when a store name is specified but does not exist",
	"Method": "void testCreateDataStore(){\r\n    FeatureTypeInfo ti = getCatalog().getFeatureTypeByName(getLayerId(SystemTestData.BUILDINGS));\r\n    SimpleFeatureCollection rawSource = (SimpleFeatureCollection) ti.getFeatureSource(null, null).getFeatures();\r\n    ForceCoordinateSystemFeatureResults sampleData = new ForceCoordinateSystemFeatureResults(rawSource, CRS.decode(\"EPSG:4326\"));\r\n    String storeName = SystemTestData.CITE_PREFIX + \"data\";\r\n    DataStoreInfo storeInfo = catalog.getDataStoreByName(storeName);\r\n    assertNull(\"Store already exists \" + storeInfo, storeInfo);\r\n    ImportProcess importer = new ImportProcess(getCatalog());\r\n    String result = importer.execute(sampleData, null, SystemTestData.CITE_PREFIX, storeName, \"Buildings5\", CRS.decode(\"EPSG:4326\"), null, null, null);\r\n    assertEquals(result, SystemTestData.CITE_PREFIX + \":\" + \"Buildings5\");\r\n}"
}, {
	"Path": "org.vfny.geoserver.crs.OvverideTransformationsTest.testFallbackOnEPSGDatabaseStd",
	"Comment": "check we are actually using the epsg database for anything not in override",
	"Method": "void testFallbackOnEPSGDatabaseStd(){\r\n    CoordinateReferenceSystem source = CRS.decode(\"EPSG:3002\");\r\n    CoordinateReferenceSystem target = CRS.decode(\"EPSG:4326\");\r\n    CoordinateOperation co = CRS.getCoordinateOperationFactory(true).createOperation(source, target);\r\n    ConcatenatedOperation cco = (ConcatenatedOperation) co;\r\n    assertEquals(2, cco.getOperations().size());\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.GridCoverage2DRIA.computeRect",
	"Comment": "warps a rectangle.copied and adapted from warpgeneralopimage",
	"Method": "void computeRect(PlanarImage[] sources,WritableRaster dest,Rectangle destRect){\r\n    RasterFormatTag[] formatTags = getFormatTags();\r\n    RasterAccessor d = new RasterAccessor(dest, destRect, formatTags[1], getColorModel());\r\n    switch(d.getDataType()) {\r\n        case DataBuffer.TYPE_BYTE:\r\n            computeRectByte(sources[0], d);\r\n            break;\r\n        case DataBuffer.TYPE_USHORT:\r\n            computeRectUShort(sources[0], d);\r\n            break;\r\n        case DataBuffer.TYPE_SHORT:\r\n            computeRectShort(sources[0], d);\r\n            break;\r\n        case DataBuffer.TYPE_INT:\r\n            computeRectInt(sources[0], d);\r\n            break;\r\n        case DataBuffer.TYPE_FLOAT:\r\n            computeRectFloat(sources[0], d);\r\n            break;\r\n        case DataBuffer.TYPE_DOUBLE:\r\n            computeRectDouble(sources[0], d);\r\n            break;\r\n    }\r\n    if (d.isDataCopy()) {\r\n        d.clampDataArrays();\r\n        d.copyDataToRaster();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.csw.records.AbstractRecordDescriptor.createNameList",
	"Comment": "helper method to create a list of names from namespace support and a sequence of strings",
	"Method": "List<Name> createNameList(NamespaceSupport ns,String names){\r\n    List<Name> result = new LinkedList<Name>();\r\n    for (String name : names) {\r\n        String[] splitted = name.split(\":\");\r\n        String uri, localName;\r\n        if (splitted.length == 1) {\r\n            uri = ns.getURI(\"\");\r\n            localName = splitted[0];\r\n        } else {\r\n            uri = ns.getURI(splitted[0]);\r\n            localName = splitted[1];\r\n        }\r\n        result.add(new NameImpl(uri, localName));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.DownloadProcessTest.testDownloadEstimatorIntegerMaxValueLimitRaster",
	"Comment": "test download estimator for raster data. the result should exceed the integer limits",
	"Method": "void testDownloadEstimatorIntegerMaxValueLimitRaster(){\r\n    DownloadEstimatorProcess limits = new DownloadEstimatorProcess(new StaticDownloadServiceConfiguration(new // huge number, way above integer limits\r\n    DownloadServiceConfiguration(DownloadServiceConfiguration.NO_LIMIT, (long) 1E12, DownloadServiceConfiguration.NO_LIMIT, DownloadServiceConfiguration.NO_LIMIT, DownloadServiceConfiguration.DEFAULT_COMPRESSION_LEVEL, DownloadServiceConfiguration.NO_LIMIT)), getGeoServer());\r\n    final WPSResourceManager resourceManager = getResourceManager();\r\n    DownloadProcess downloadProcess = new DownloadProcess(getGeoServer(), limits, resourceManager);\r\n    Polygon roi = (Polygon) new WKTReader2().read(\"POLYGON (( -127.57473954542964 54.06575021619523, -130.8545966116691 52.00807146727025, -129.50812897394974 49.85372324691927, -130.5300633861675 49.20465679591609, -129.25955033314003 48.60392508062591, -128.00975216684665 50.986137055052474, -125.8623089087404 48.63154492960477, -123.984159178178 50.68231871628503, -126.91186316993704 52.15307567440926, -125.3444367403868 53.54787804784162, -127.57473954542964 54.06575021619523 ))\");\r\n    roi.setSRID(4326);\r\n    try {\r\n        // layerName\r\n        downloadProcess.execute(getLayerId(MockData.USA_WORLDIMG), null, \"image/tiff\", null, CRS.decode(\"EPSG:4326\", true), roi, false, null, 100000, 60000, null, null, new NullProgressListener());\r\n        Assert.fail();\r\n    } catch (ProcessException e) {\r\n        Assert.assertEquals(\"java.lang.IllegalArgumentException: Download Limits Exceeded. Unable to proceed!\", e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.DataReferenceWfsOnlineTest.testGetFeatureWithFeatureIdFilter",
	"Comment": "test if we can get gsml.geologicunit.16777549126932776 with a featureid fid filter.",
	"Method": "void testGetFeatureWithFeatureIdFilter(){\r\n    String xml = \"<wfs:GetFeature \" + \"service=\\\"WFS\\\" \" + \"version=\\\"1.1.0\\\" \" + \"xmlns:cdf=\\\"http://www.opengis.net/cite/data\\\" \" + \"xmlns:ogc=\\\"http://www.opengis.net/ogc\\\" \" + \"xmlns:wfs=\\\"http://www.opengis.net/wfs\\\" \" + \"xmlns:gml=\\\"http://www.opengis.net/gml\\\" \" + \"xmlns:gsml=\\\"\" + AbstractAppSchemaMockData.GSML_URI + \"\\\" \" + \">\" + \"    <wfs:Query typeName=\\\"gsml:GeologicUnit\\\">\" + \"        <ogc:Filter>\" + \"            <ogc:FeatureId fid=\\\"gsml.geologicunit.16777549126932776\\\"/>\" + \"        <\/ogc:Filter>\" + \"    <\/wfs:Query> \" + \"<\/wfs:GetFeature>\";\r\n    Document doc = postAsDOM(\"wfs\", xml);\r\n    if (printDoc) {\r\n        LOGGER.info(\"WFS filter GetFeature response:\\n\" + prettyString(doc));\r\n    }\r\n    assertXpathCount(1, \"//gsml:GeologicUnit\", doc);\r\n    checkGU16777549126932776(doc);\r\n}"
}, {
	"Path": "org.geoserver.security.config.FileBasedSecurityServiceConfig.getCheckInterval",
	"Comment": "the time interval, in milliseconds, in which to check the underlying file for changes.",
	"Method": "long getCheckInterval(){\r\n    return checkInterval;\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.WMTSStoreEditPage.doSaveStore",
	"Comment": "performs the save of the store.this method may be subclasses to provide custom save functionality.",
	"Method": "void doSaveStore(WMTSStoreInfo info){\r\n    Catalog catalog = getCatalog();\r\n    WMTSStoreInfo expandedStore = (WMTSStoreInfo) catalog.getResourcePool().clone(info, true);\r\n    getCatalog().validate(expandedStore, false).throwIfInvalid();\r\n    getCatalog().save(info);\r\n    doReturn(StorePage.class);\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerSecuredPage.isAuthenticatedAsAdmin",
	"Comment": "convenience method to determine if the current user is authenticated as full administartor.",
	"Method": "boolean isAuthenticatedAsAdmin(){\r\n    return ComponentAuthorizer.ADMIN.isAccessAllowed(GeoServerSecuredPage.class, SecurityContextHolder.getContext().getAuthentication());\r\n}"
}, {
	"Path": "org.vfny.geoserver.util.WCSUtils.replaceParameter",
	"Comment": "replace or add the provided parameter in the read parameters",
	"Method": "GeneralParameterValue[] replaceParameter(GeneralParameterValue[] readParameters,Object value,ParameterDescriptor<T> pd){\r\n    for (GeneralParameterValue gpv : readParameters) {\r\n        if (gpv.getDescriptor().getName().equals(pd.getName())) {\r\n            ((ParameterValue) gpv).setValue(value);\r\n            return readParameters;\r\n        }\r\n    }\r\n    GeneralParameterValue[] readParametersClone = new GeneralParameterValue[readParameters.length + 1];\r\n    System.arraycopy(readParameters, 0, readParametersClone, 0, readParameters.length);\r\n    final ParameterValue<T> pv = pd.createValue();\r\n    pv.setValue(value);\r\n    readParametersClone[readParameters.length] = pv;\r\n    return readParametersClone;\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.DXFOutputFormatTest.testWriteAttributesPosition",
	"Comment": "test writeattributes option, check position of attributes.",
	"Method": "void testWriteAttributesPosition(){\r\n    MockHttpServletResponse resp = getAsServletResponse(\"wfs?request=GetFeature&version=1.1.0&typeName=Polygons&outputFormat=dxf&format_options=withattributes:true\");\r\n    String sResponse = testBasicResult(resp, \"Polygons\");\r\n    int pos = getGeometrySearchStart(sResponse);\r\n    assertTrue(pos != -1);\r\n    checkSequence(sResponse, new String[] { \"POLYGONS_attributes\", \"POLYGONS_attributes\", \"POLYGONS_attributes\", \"ATTRIB\", \"POLYGONS_attributes\", \"AcDbText\", \"10\", \"500237.5\", \"20\", \"500062.5\", \"t0002\" }, pos);\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.DownloadEstimatorProcess.execute",
	"Comment": "this process returns a boolean value which indicates if the requested download does notexceed the imposed limits, if present",
	"Method": "Boolean execute(String layerName,Filter filter,CoordinateReferenceSystem targetCRS,CoordinateReferenceSystem roiCRS,Geometry roi,Boolean clip,Integer targetSizeX,Integer targetSizeY,int[] bandIndices,ProgressListener progressListener){\r\n    if (layerName == null || layerName.length() <= 0) {\r\n        throw new IllegalArgumentException(\"Empty or null layerName provided!\");\r\n    }\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.log(Level.FINE, \"Estimator process called on resource: \" + layerName);\r\n    }\r\n    if (clip == null) {\r\n        clip = false;\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Clipping disabled\");\r\n        }\r\n    }\r\n    if (roi != null) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"ROI present\");\r\n        }\r\n        DownloadUtilities.checkPolygonROI(roi);\r\n        if (roiCRS == null) {\r\n            throw new IllegalArgumentException(\"ROI without a CRS is not usable!\");\r\n        }\r\n        roi.setUserData(roiCRS);\r\n    }\r\n    LayerInfo layerInfo = catalog.getLayerByName(layerName);\r\n    if (layerInfo == null) {\r\n        throw new IllegalArgumentException(\"Unable to locate layer: \" + layerName);\r\n    }\r\n    ResourceInfo resourceInfo = layerInfo.getResource();\r\n    if (resourceInfo == null) {\r\n        throw new IllegalArgumentException(\"Unable to locate ResourceInfo for layer:\" + layerName);\r\n    }\r\n    DownloadServiceConfiguration limits = downloadServiceConfigurationGenerator.getConfiguration();\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.log(Level.FINE, \"Getting configuration limits\");\r\n    }\r\n    if (resourceInfo instanceof FeatureTypeInfo) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Working with Vectorial dataset\");\r\n        }\r\n        final FeatureTypeInfo featureTypeInfo = (FeatureTypeInfo) resourceInfo;\r\n        return new VectorEstimator(limits).execute(featureTypeInfo, roi, clip, filter, targetCRS, progressListener);\r\n    } else if (resourceInfo instanceof CoverageInfo) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Working with Raster dataset\");\r\n        }\r\n        final CoverageInfo coverage = (CoverageInfo) resourceInfo;\r\n        return new RasterEstimator(limits, catalog).execute(progressListener, coverage, roi, targetCRS, clip, filter, targetSizeX, targetSizeY, bandIndices);\r\n    }\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.log(Level.FINE, \"Working with a wrong Resource\");\r\n    }\r\n    final ProcessException ex = new ProcessException(\"Could not complete the Download Process: target resource is of Illegal type --> \" + resourceInfo != null ? resourceInfo.getClass().getCanonicalName() : \"null\");\r\n    if (progressListener != null) {\r\n        progressListener.exceptionOccurred(ex);\r\n    }\r\n    throw ex;\r\n}"
}, {
	"Path": "org.geoserver.data.CatalogReader.read",
	"Comment": "parses the catalog.xml file into a dom.this methodbe called before any other methods.",
	"Method": "void read(File file){\r\n    FileReader reader = new FileReader(file);\r\n    try {\r\n        catalog = ReaderUtils.parse(reader);\r\n    } finally {\r\n        reader.close();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.BindingLdapAuthoritiesPopulator.setIgnorePartialResultException",
	"Comment": "sets the corresponding property on the underlying template, avoiding specific issues withactive directory.",
	"Method": "void setIgnorePartialResultException(boolean ignore){\r\n    ldapTemplate.setIgnorePartialResultException(ignore);\r\n}"
}, {
	"Path": "org.geoserver.security.file.FileWatcher.isTerminated",
	"Comment": "check if filewatcher has been terminated.a terminated filewatcher no longer listens for resource notification, and will ignore anylast minuet notifications that sneak in.",
	"Method": "boolean isTerminated(){\r\n    synchronized (terminateLock) {\r\n        return terminate;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.OSEOTestSupport.populateGranulesTable",
	"Comment": "allows subclasses to decide if to populate the granules table, or not",
	"Method": "boolean populateGranulesTable(){\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.copyToWorkspacesDir",
	"Comment": "copies data into the root workspaces configuration directory.if the workspace configuration directory does exist it will be created",
	"Method": "void copyToWorkspacesDir(InputStream data,String filename){\r\n    Resources.copy(data, getWorkspaces(), filename);\r\n}"
}, {
	"Path": "org.geoserver.ows.FlatKvpParser.parse",
	"Comment": "parses the parsed tokens into a final representation.subclasses may choose to override this method. the default implementation just return thearray passed in.",
	"Method": "Object parse(String value,Object parse,List values){\r\n    return values;\r\n}"
}, {
	"Path": "org.geoserver.test.BBoxFilterTest.testQueryBboxLatLong",
	"Comment": "the following performs a wfs request specifying a bbox parameter of axis ordering latitudelongitude. this test should return features since wfs 1.1.0 defaults to lat long ifunspecified.",
	"Method": "void testQueryBboxLatLong(){\r\n    Document doc = getAsDOM(WFS_GET_FEATURE + LATLONG);\r\n    LOGGER.info(WFS_GET_FEATURE_LOG + LATLONG + prettyString(doc));\r\n    assertXpathEvaluatesTo(\"2\", \"/wfs:FeatureCollection/@numberOfFeatures\", doc);\r\n    assertXpathCount(2, \"//ex:geomContainer\", doc);\r\n}"
}, {
	"Path": "org.geoserver.wps.remote.plugin.XMPPClient.getEndpointsLoadAverages",
	"Comment": "scan remote processing machines availability and average load",
	"Method": "void getEndpointsLoadAverages(){\r\n    synchronized (registeredProcessingMachines) {\r\n        List<String> nodeJIDs = new ArrayList<String>();\r\n        for (RemoteMachineDescriptor node : registeredProcessingMachines) {\r\n            nodeJIDs.add(node.getNodeJID());\r\n        }\r\n        for (MultiUserChat mucServiceChannel : mucServiceChannels) {\r\n            for (String occupant : mucServiceChannel.getOccupants()) {\r\n                if (!nodeJIDs.contains(occupant)) {\r\n                    registeredProcessingMachines.add(new RemoteMachineDescriptor(occupant, extractServiceName(occupant), false, 0.0, 0.0));\r\n                }\r\n                String[] serviceJIDParts = occupant.split(\"/\");\r\n                if (serviceJIDParts.length == 3 && (serviceJIDParts[2].startsWith(\"master\") || serviceJIDParts[2].indexOf(\"@\") < 0)) {\r\n                    sendMessage(occupant, \"topic=getloadavg\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.dxf.AbstractDXFWriter.getLineType",
	"Comment": "assign a line type to the collection, cycling through the available line types list.",
	"Method": "int getLineType(FeatureCollection coll){\r\n    int ltype = ltypePos;\r\n    if (ltypePos < (lineTypes.length - 1))\r\n        ltypePos++;\r\n    else\r\n        ltypePos = 0;\r\n    return ltype;\r\n}"
}, {
	"Path": "org.geoserver.ows.util.OwsUtils.parameter",
	"Comment": "returns an object of a particular type in a list of objects of various types.",
	"Method": "T parameter(Object[] parameters,Class<T> type){\r\n    for (int i = 0; i < parameters.length; i++) {\r\n        Object parameter = parameters[i];\r\n        if ((parameter != null) && type.isAssignableFrom(parameter.getClass())) {\r\n            return (T) parameter;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.kml.KMLReflectorTest.testWMSTimeRequest",
	"Comment": "method testwmstimerequest tests if the time parameter of the request is also passed to thekml wms request.",
	"Method": "void testWMSTimeRequest(){\r\n    String layerId = getLayerId(MockData.BASIC_POLYGONS);\r\n    String expectedTS = \"time=2014-03-01\";\r\n    final String requestUrl = \"wms/kml?layers=\" + layerId + \"&styles=polygon&mode=refresh&bbox=10.56,46.99,11.50,47.26&\" + expectedTS;\r\n    Document doc = getAsDOM(requestUrl);\r\n    NodeList nodes = doc.getElementsByTagName(\"href\");\r\n    for (int i = 0; i < nodes.getLength(); ++i) {\r\n        Element e = (Element) nodes.item(i);\r\n        String actualTS = e.getTextContent();\r\n        Assert.assertTrue(\"Time parameter missing\", actualTS.contains(expectedTS));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.platform.GeoServerExtensions.extensions",
	"Comment": "loads all extensions implementing or extending extensionpoint.",
	"Method": "List<T> extensions(Class<T> extensionPoint,ApplicationContext context,List<T> extensions,Class<T> extensionPoint){\r\n    return extensions(extensionPoint, context);\r\n}"
}, {
	"Path": "org.geoserver.catalog.CoverageDimensionCustomizerReaderTest.testNoDataCategoryWrapping",
	"Comment": "test that the wrapped nodata categories contains the defined nodata",
	"Method": "void testNoDataCategoryWrapping(){\r\n    final CoverageDimensionImpl coverageDim = new CoverageDimensionImpl();\r\n    final String wrappedName = \"wrapped\";\r\n    coverageDim.setName(wrappedName);\r\n    coverageDim.setDimensionType(SampleDimensionType.REAL_64BITS);\r\n    final List<Double> nullValues = new ArrayList<Double>();\r\n    final double noData1 = -32768d;\r\n    final double noData2 = -32767d;\r\n    nullValues.add(noData1);\r\n    nullValues.add(noData2);\r\n    coverageDim.setNullValues(nullValues);\r\n    GridSampleDimension sampleDim = new GridSampleDimension(\"original\", new Category[] { new Category(Vocabulary.formatInternational(VocabularyKeys.NODATA), new Color(0, 0, 0, 0), Double.NaN) }, null);\r\n    GridSampleDimension wrappedDim = WrappedSampleDimension.build(sampleDim, coverageDim);\r\n    GridSampleDimension copy = new GridSampleDimension(wrappedDim) {\r\n    };\r\n    List<Category> categories = copy.getCategories();\r\n    Category category = categories.get(0);\r\n    assertTrue(category.getName().equals(Category.NODATA.getName()));\r\n    assertEquals(category.getRange().getMinimum(), Double.NaN, DELTA);\r\n    assertEquals(category.getRange().getMaximum(), Double.NaN, DELTA);\r\n    sampleDim = new GridSampleDimension(\"original\", new Category[] { new Category(Vocabulary.formatInternational(VocabularyKeys.NODATA), new Color[] { new Color(0, 0, 0, 0) }, NumberRange.create(-9999, -9999)) }, null);\r\n    copy = WrappedSampleDimension.build(sampleDim, coverageDim);\r\n    categories = copy.getCategories();\r\n    category = categories.get(0);\r\n    assertTrue(category.getName().equals(Category.NODATA.getName()));\r\n    assertEquals(category.getRange().getMinimum(), noData1, DELTA);\r\n    assertEquals(category.getRange().getMaximum(), noData1, DELTA);\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexMongoDBSupport.setupStationsMappings",
	"Comment": "helper method that setup stations data set mappings files and schemas.",
	"Method": "void setupStationsMappings(){\r\n    File fixtureFile = getFixtureFile();\r\n    if (!fixtureFile.exists()) {\r\n        createFixtureExample(fixtureFile);\r\n        LOGGER.warning(String.format(\"No fixture file '%s' for MongoDB exists, example file created. Tests will eb skipped.\", fixtureFile.getAbsolutePath()));\r\n    }\r\n    assumeTrue(fixtureFile.exists());\r\n    Properties properties = loadFixtureProperties(fixtureFile);\r\n    String hostAsString = properties.getProperty(\"mongo.host\", \"127.0.0.1\");\r\n    String portAsString = properties.getProperty(\"mongo.port\", \"27017\");\r\n    ServerAddress serverAddress = new ServerAddress(hostAsString, Integer.parseInt(portAsString));\r\n    MONGO_CLIENT = new MongoClient(serverAddress, new MongoClientOptions.Builder().serverSelectionTimeout(2000).build());\r\n    try {\r\n        MONGO_CLIENT.listDatabaseNames().first();\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(String.format(\"Could not connect to MongoDB database with host '%s' and port '%s'.\", hostAsString, portAsString));\r\n    }\r\n    moveResourceToTempDir(\"/schemas/stations.xsd\", \"stations.xsd\");\r\n    APP_SCHEMA_MAPPINGS = moveResourceToTempDir(getPathOfMappingsToUse(), \"stations.xml\");\r\n    String mappingsContent = new String(Files.readAllBytes(APP_SCHEMA_MAPPINGS.toPath()));\r\n    mappingsContent = mappingsContent.replaceAll(\"\\\\{dataBaseName\\\\}\", STATIONS_DATA_BASE_NAME);\r\n    mappingsContent = mappingsContent.replaceAll(\"\\\\{collectionName\\\\}\", STATIONS_COLLECTION_NAME);\r\n    mappingsContent = mappingsContent.replaceAll(\"\\\\{mongoHost\\\\}\", hostAsString);\r\n    mappingsContent = mappingsContent.replaceAll(\"\\\\{mongoPort\\\\}\", portAsString);\r\n    mappingsContent = mappingsContent.replaceAll(\"\\\\{schemaStore\\\\}\", new File(ROOT_DIRECTORY.toFile(), \"schema-store\").getAbsolutePath());\r\n    Files.write(APP_SCHEMA_MAPPINGS.toPath(), mappingsContent.getBytes());\r\n    File stationsFile1 = moveResourceToTempDir(\"/data/stations1.json\", \"stations1.json\");\r\n    File stationsFile2 = moveResourceToTempDir(\"/data/stations2.json\", \"stations2.json\");\r\n    String stationsContent1 = new String(Files.readAllBytes(stationsFile1.toPath()));\r\n    String stationsContent2 = new String(Files.readAllBytes(stationsFile2.toPath()));\r\n    insertJson(STATIONS_DATA_BASE_NAME, STATIONS_COLLECTION_NAME, stationsContent1);\r\n    insertJson(STATIONS_DATA_BASE_NAME, STATIONS_COLLECTION_NAME, stationsContent2);\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexIndexesTest.loadFixtureProperties",
	"Comment": "helper method that just loads the fixture files properties.",
	"Method": "Properties loadFixtureProperties(File fixtureFile){\r\n    Properties properties = new Properties();\r\n    try (InputStream input = new FileInputStream(fixtureFile)) {\r\n        properties.load(input);\r\n        return properties;\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(String.format(\"Error reading fixture file '%s'.\", fixtureFile.getAbsolutePath()), exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wms.animate.FrameCatalogVisitor.visit",
	"Comment": "adds a new visitor to the runnables list and initializes the animatorexecutor service is notyet initialied.",
	"Method": "void visit(GetMapRequest request,WebMapService wms,WMS wmsConfiguration,String aparam,String avalue){\r\n    if (this.tasks == null) {\r\n        this.tasks = new LinkedList<Future<RenderedImage>>();\r\n    }\r\n    FrameLoader loader = new FrameLoader(request, wms, wmsConfiguration, aparam, avalue);\r\n    final FutureTask<RenderedImage> task = new FutureTask<RenderedImage>(loader);\r\n    this.tasks.add(task);\r\n    this.framesNumber++;\r\n    wmsConfiguration.getAnimatorExecutorService().execute(task);\r\n}"
}, {
	"Path": "org.geoserver.security.password.JasyptPasswordEncoderWrapper.setStringDigester",
	"Comment": "sets a string digester to be used. only one of setpasswordencryptor orsetstringdigester should be called. if both are, the last call will define whichmethod will be used.",
	"Method": "void setStringDigester(StringDigester stringDigester){\r\n    this.stringDigester = stringDigester;\r\n    this.useEncryptor = Boolean.FALSE;\r\n}"
}, {
	"Path": "org.geoserver.wcs.kvp.Wcs10GetCoverageRequestReader.decodeCRS100",
	"Comment": "decode the requested crs following the wcs 1.0 style with lon,lat axes order.",
	"Method": "CoordinateReferenceSystem decodeCRS100(String crsName){\r\n    if (\"WGS84(DD)\".equals(crsName)) {\r\n        crsName = \"EPSG:4326\";\r\n    }\r\n    try {\r\n        return CRS.decode(crsName, true);\r\n    } catch (NoSuchAuthorityCodeException e) {\r\n        throw new WcsException(\"Could not recognize crs \" + crsName, InvalidParameterValue, \"crs\");\r\n    } catch (FactoryException e) {\r\n        throw new WcsException(\"Could not recognize crs \" + crsName, InvalidParameterValue, \"crs\");\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.panel.WorkspacePanel.getFormComponent",
	"Comment": "returns the form component used in the panel in case it is needed for related form componentsvalidation",
	"Method": "FormComponent getFormComponent(){\r\n    return choice;\r\n}"
}, {
	"Path": "org.vfny.geoserver.util.WCSUtils.formatBytes",
	"Comment": "utility function to format a byte amount into a human readable string",
	"Method": "String formatBytes(long bytes){\r\n    if (bytes < 1024) {\r\n        return bytes + \"B\";\r\n    } else if (bytes < 1024 * 1024) {\r\n        return new DecimalFormat(\"#.##\").format(bytes / 1024.0) + \"KB\";\r\n    } else {\r\n        return new DecimalFormat(\"#.##\").format(bytes / 1024.0 / 1024.0) + \"MB\";\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.data.test.SystemTestData.addSettings",
	"Comment": "adds a settings configuration to the test setup. if the settings object already exists it issimply reverted to its original state.",
	"Method": "void addSettings(String workspace,GeoServer geoServer){\r\n    WorkspaceInfo ws = workspace != null ? geoServer.getCatalog().getWorkspaceByName(workspace) : null;\r\n    GeoServerInfo global = geoServer.getGlobal();\r\n    SettingsInfo settings = ws != null ? geoServer.getSettings(ws) : global.getSettings();\r\n    if (settings == null) {\r\n        settings = geoServer.getFactory().createSettings();\r\n    }\r\n    settings.setWorkspace(ws);\r\n    settings.getContact().setContactPerson(\"Andrea Aime\");\r\n    settings.getContact().setAddressElectronicMailAddress(\"andrea@geoserver.org\");\r\n    settings.getContact().setAddressDeliveryPoint(\"1600 Pennsylvania Ave NW, Washington DC 20500, United States\");\r\n    settings.setNumDecimals(8);\r\n    settings.setOnlineResource(\"http://geoserver.org\");\r\n    settings.setVerbose(false);\r\n    settings.setVerboseExceptions(false);\r\n    settings.setLocalWorkspaceIncludesPrefix(false);\r\n    if (ws != null) {\r\n        if (settings.getId() != null) {\r\n            geoServer.save(settings);\r\n        } else {\r\n            geoServer.add(settings);\r\n        }\r\n    } else {\r\n        geoServer.save(global);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.executor.ExecuteRequest.getProcessInputs",
	"Comment": "returns the process inputs according to the geotools api expectations",
	"Method": "LazyInputMap getProcessInputs(WPSExecutionManager manager){\r\n    if (inputs == null) {\r\n        inputs = getInputsInternal(manager);\r\n    }\r\n    return inputs;\r\n}"
}, {
	"Path": "org.geoserver.rest.catalog.StyleController.parseSld",
	"Comment": "parses the sld file from a zipfile upload, returning it as a style object",
	"Method": "Style parseSld(File sldFile){\r\n    Style style = null;\r\n    InputStream is = null;\r\n    try {\r\n        is = new FileInputStream(sldFile);\r\n        SLDParser parser = new SLDParser(CommonFactoryFinder.getStyleFactory(null), is);\r\n        EntityResolver resolver = catalog.getResourcePool().getEntityResolver();\r\n        if (resolver != null) {\r\n            parser.setEntityResolver(resolver);\r\n        }\r\n        Style[] styles = parser.readXML();\r\n        if (styles.length > 0) {\r\n            style = styles[0];\r\n        }\r\n        if (style == null) {\r\n            throw new RestException(\"Style error.\", HttpStatus.BAD_REQUEST);\r\n        }\r\n        return style;\r\n    } catch (Exception ex) {\r\n        LOGGER.severe(ex.getMessage());\r\n        throw new RestException(\"Style error. \" + ex.getMessage(), HttpStatus.BAD_REQUEST);\r\n    } finally {\r\n        IOUtils.closeQuietly(is);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.CoverageResponseDelegateFinder.encoderFor",
	"Comment": "locates an encoder for a specific getcoverage results output format",
	"Method": "CoverageResponseDelegate encoderFor(String outputFormat){\r\n    List<CoverageResponseDelegate> delegates = GeoServerExtensions.extensions(CoverageResponseDelegate.class, applicationContext);\r\n    for (CoverageResponseDelegate delegate : delegates) {\r\n        if (delegate.isAvailable() && delegate.canProduce(outputFormat)) {\r\n            return delegate;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.security.impl.ServiceAccessRule.getValue",
	"Comment": "returns the list of roles as a comma separated string for this rule",
	"Method": "String getValue(){\r\n    if (roles.isEmpty()) {\r\n        return ServiceAccessRule.ANY;\r\n    } else {\r\n        StringBuffer sb = new StringBuffer();\r\n        for (String role : roles) {\r\n            sb.append(role);\r\n            sb.append(\",\");\r\n        }\r\n        sb.setLength(sb.length() - 1);\r\n        return sb.toString();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityProvider.createMasterPasswordProvider",
	"Comment": "creates a new role group service.if the extension does not provide a master password provider this method should simplyreturn null.",
	"Method": "MasterPasswordProvider createMasterPasswordProvider(MasterPasswordProviderConfig config){\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerApplication.newConverterLocator",
	"Comment": "overrides to return a custom converter locator which loads converters from the geotoools converter subsystem.",
	"Method": "IConverterLocator newConverterLocator(){\r\n    ConverterLocator locator = new ConverterLocator();\r\n    locator.set(ReferencedEnvelope.class, new GeoToolsConverterAdapter(new StringBBoxConverter(), ReferencedEnvelope.class));\r\n    DataDirectoryConverterLocator dd = new DataDirectoryConverterLocator(getResourceLoader());\r\n    locator.set(File.class, dd.getConverter(File.class));\r\n    locator.set(URI.class, dd.getConverter(URI.class));\r\n    locator.set(URL.class, dd.getConverter(URL.class));\r\n    locator.set(Measure.class, new GeoToolsConverterAdapter(MeasureConverterFactory.CONVERTER, Measure.class));\r\n    return locator;\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.RasterDownload.getBackgroundValues",
	"Comment": "extract the backgroundvalues which will be used for mosaicking operations.",
	"Method": "double[] getBackgroundValues(Map<String, Serializable> coverageParameters,GeneralParameterValue[] readParameters){\r\n    double[] backgroundValues = null;\r\n    if (coverageParameters != null && coverageParameters.containsKey(\"BackgroundValues\")) {\r\n        for (GeneralParameterValue readParameter : readParameters) {\r\n            if (\"BackgroundValues\".equalsIgnoreCase(readParameter.getDescriptor().getName().toString())) {\r\n                Object bgValue = ((ParameterValue) readParameter).getValue();\r\n                if (bgValue != null && bgValue instanceof double[]) {\r\n                    backgroundValues = ((double[]) bgValue);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return backgroundValues;\r\n}"
}, {
	"Path": "org.geoserver.rest.util.RESTUtils.loadMapFromGlobal",
	"Comment": "this method is used for extracting the metadata map from the global settings",
	"Method": "MetadataMap loadMapFromGlobal(){\r\n    GeoServerInfo gsInfo = GeoServerExtensions.bean(GeoServer.class).getGlobal();\r\n    if (gsInfo != null) {\r\n        SettingsInfo info = gsInfo.getSettings();\r\n        return info != null ? info.getMetadata() : null;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.ows.util.RequestUtils.getVersionPreOws",
	"Comment": "given a list of provided versions, and a list of accepted versions, this method will returnthe negotiated version to be used for response according to the pre ows 1.1 specifications,that is, wms 1.1, wms 1.3, wfs 1.0, wfs 1.1 and wcs 1.0",
	"Method": "String getVersionPreOws(List<String> providedList,List<String> acceptedList){\r\n    TreeSet<Version> provided = new TreeSet<Version>();\r\n    for (String v : providedList) {\r\n        provided.add(new Version(v));\r\n    }\r\n    if (acceptedList == null || acceptedList.isEmpty())\r\n        return provided.last().toString();\r\n    TreeSet<Version> accepted = new TreeSet<Version>();\r\n    for (String v : acceptedList) {\r\n        checkVersionNumber(v, null);\r\n        accepted.add(new Version(v));\r\n    }\r\n    for (Iterator<Version> v = accepted.iterator(); v.hasNext(); ) {\r\n        Version version = (Version) v.next();\r\n        if (!provided.contains(version)) {\r\n            v.remove();\r\n        }\r\n    }\r\n    String version = null;\r\n    if (!accepted.isEmpty()) {\r\n        version = ((Version) accepted.last()).toString();\r\n    } else {\r\n        for (String v : acceptedList) {\r\n            accepted.add(new Version(v));\r\n        }\r\n        if ((accepted.last()).compareTo(provided.first()) < 0) {\r\n            version = (provided.first()).toString();\r\n        }\r\n        if ((accepted.first()).compareTo(provided.last()) > 0) {\r\n            version = (provided.last()).toString();\r\n        }\r\n        if (version == null) {\r\n            Iterator<Version> v = provided.iterator();\r\n            Version last = v.next();\r\n            for (; v.hasNext(); ) {\r\n                Version current = v.next();\r\n                if (current.compareTo(accepted.last()) > 0) {\r\n                    break;\r\n                }\r\n                last = current;\r\n            }\r\n            version = last.toString();\r\n        }\r\n    }\r\n    return version;\r\n}"
}, {
	"Path": "org.geoserver.catalog.CoverageViewReaderTest.testOutputWithMoreBandsThanInputCoverageView",
	"Comment": "test creation of a coverage from a multi band coverageview which has more bands compared tothe input coverageview",
	"Method": "void testOutputWithMoreBandsThanInputCoverageView(){\r\n    final Catalog cat = getCatalog();\r\n    final CoverageInfo coverageInfo = cat.getCoverageByName(\"multiband_select\");\r\n    final MetadataMap metadata = coverageInfo.getMetadata();\r\n    final ResourcePool resPool = cat.getResourcePool();\r\n    final ReferencedEnvelope bbox = coverageInfo.getLatLonBoundingBox();\r\n    final GridCoverage coverage = resPool.getGridCoverage(coverageInfo, \"multiband_select\", bbox, null);\r\n    RenderedImage srcImage = coverage.getRenderedImage();\r\n    assertEquals(coverage.getNumSampleDimensions(), 5);\r\n    ((GridCoverage2D) coverage).dispose(true);\r\n    final GridCoverageReader reader = resPool.getGridCoverageReader(coverageInfo, \"multiband_select\", null);\r\n    int[] bandIndices = new int[] { 2, 0, 1, 0, 2, 2, 2, 3, 4, 0, 1, 0, 4, 2, 3 };\r\n    Parameter<int[]> bandIndicesParam = null;\r\n    if (bandIndices != null) {\r\n        bandIndicesParam = (Parameter<int[]>) AbstractGridFormat.BANDS.createValue();\r\n        bandIndicesParam.setValue(bandIndices);\r\n    }\r\n    GridCoverage2DReader myReader = (GridCoverage2DReader) reader;\r\n    ImageLayout layout = myReader.getImageLayout();\r\n    SampleModel sampleModel = layout.getSampleModel(null);\r\n    assertEquals(5, sampleModel.getNumBands());\r\n    reader.dispose();\r\n    List<GeneralParameterValue> paramList = new ArrayList<GeneralParameterValue>();\r\n    paramList.addAll(Arrays.asList(bandIndicesParam));\r\n    GeneralParameterValue[] readParams = paramList.toArray(new GeneralParameterValue[paramList.size()]);\r\n    GridCoverage result = myReader.read(readParams);\r\n    assertEquals(15, result.getNumSampleDimensions());\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.getServicesFile",
	"Comment": "returns a default services.xml file with wms, wfs and wcs enabled. subclasses may need tooverride this in order to test extra services or specific configurations",
	"Method": "URL getServicesFile(){\r\n    return GeoServerAbstractTestSupport.class.getResource(\"services.xml\");\r\n}"
}, {
	"Path": "org.geoserver.test.StationsMockData.getDirectoryForGmlPrefix",
	"Comment": "helper method that returns the directory, relative to tests root directory, that will containthe mappings, schemas, properties, etc ... of the target gml version.",
	"Method": "File getDirectoryForGmlPrefix(String gmlPrefix){\r\n    if (testRootDirectory == null) {\r\n        testRootDirectory = createTestRootDirectory();\r\n    }\r\n    if (gmlPrefix == null || gmlPrefix.isEmpty()) {\r\n        return testRootDirectory;\r\n    }\r\n    return new File(testRootDirectory, gmlPrefix);\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.checkMasterPassword",
	"Comment": "checks the specified password against the master password.",
	"Method": "boolean checkMasterPassword(String passwd,boolean checkMasterPassword,char[] passwd){\r\n    try {\r\n        if (!this.masterPasswordProviderHelper.loadConfig(this.masterPasswordConfig.getProviderName()).isLoginEnabled()) {\r\n            return false;\r\n        }\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(\"Unable to load master password provider config\", e);\r\n    }\r\n    GeoServerDigestPasswordEncoder pwEncoder = loadPasswordEncoder(GeoServerDigestPasswordEncoder.class);\r\n    if (masterPasswdDigest == null) {\r\n        synchronized (this) {\r\n            if (masterPasswdDigest == null) {\r\n                try {\r\n                    masterPasswdDigest = loadMasterPasswordDigest();\r\n                } catch (IOException e) {\r\n                    throw new RuntimeException(\"Unable to create master password digest\", e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return pwEncoder.isPasswordValid(masterPasswdDigest, passwd, null);\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDimensionsValueParser.setValues",
	"Comment": "set the slice value as proper object depending on the datatype",
	"Method": "void setValues(String slicePointS,List<Object> selectedValues,String domainDatatype){\r\n    if (domainDatatype.endsWith(\"Timestamp\") || domainDatatype.endsWith(\"Date\")) {\r\n        setAsDate(slicePointS, selectedValues);\r\n    } else if (domainDatatype.endsWith(\"Integer\")) {\r\n        setAsInteger(slicePointS, selectedValues);\r\n    } else if (domainDatatype.endsWith(\"Double\")) {\r\n        setAsDouble(slicePointS, selectedValues);\r\n    } else if (domainDatatype.endsWith(\"String\")) {\r\n        selectedValues.add(slicePointS);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.ppio.ProcessParameterIO.findDecoder",
	"Comment": "look for ppio matching the parameter type and suitable for input handling",
	"Method": "List<ProcessParameterIO> findDecoder(Parameter<?> p,ApplicationContext context){\r\n    return findByDirection(p, context, PPIODirection.DECODING);\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityFilterChain.insertFirst",
	"Comment": "inserts a filter as the first of the filter list corresponding to the specified pattern.",
	"Method": "boolean insertFirst(String pattern,String filterName){\r\n    RequestFilterChain requestChain = findAndCheck(pattern, filterName);\r\n    if (requestChain == null) {\r\n        return false;\r\n    }\r\n    requestChain.getFilterNames().add(0, filterName);\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.data.CatalogReader.namespaceTuple",
	"Comment": "convenience method for reading namespace prefix and uri from a namespace element.",
	"Method": "Map.Entry namespaceTuple(Element namespaceElement){\r\n    final String pre = namespaceElement.getAttribute(\"prefix\");\r\n    final String uri = namespaceElement.getAttribute(\"uri\");\r\n    return new Map.Entry() {\r\n        public Object getKey() {\r\n            return pre;\r\n        }\r\n        public Object getValue() {\r\n            return uri;\r\n        }\r\n        public Object setValue(Object value) {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.geoserver.data.CatalogReader.namespaceTuple",
	"Comment": "convenience method for reading namespace prefix and uri from a namespace element.",
	"Method": "Map.Entry namespaceTuple(Element namespaceElement){\r\n    return pre;\r\n}"
}, {
	"Path": "org.geoserver.data.CatalogReader.namespaceTuple",
	"Comment": "convenience method for reading namespace prefix and uri from a namespace element.",
	"Method": "Map.Entry namespaceTuple(Element namespaceElement){\r\n    return uri;\r\n}"
}, {
	"Path": "org.geoserver.data.CatalogReader.namespaceTuple",
	"Comment": "convenience method for reading namespace prefix and uri from a namespace element.",
	"Method": "Map.Entry namespaceTuple(Element namespaceElement){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.geoserver.security.validation.PasswordValidatorImpl.passwordStartsWithEncoderPrefix",
	"Comment": "checks if the password starts with an encoder prefix, if true return the prefix, if falsereturn null",
	"Method": "String passwordStartsWithEncoderPrefix(char[] password){\r\n    if (password == null)\r\n        return null;\r\n    O: for (String prefix : getNotAllowedPrefixes()) {\r\n        if (prefix.length() > password.length)\r\n            continue;\r\n        for (int i = 0; i < prefix.length(); i++) {\r\n            if (prefix.charAt(i) != password[i])\r\n                continue O;\r\n        }\r\n        return prefix;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findSuppResourceFile",
	"Comment": "returns a supplementary configuration file for a resource, if the file does not exist null isreturned.",
	"Method": "File findSuppResourceFile(ResourceInfo r,String filename){\r\n    Resource resource = get(r, filename);\r\n    return Resources.file(resource);\r\n}"
}, {
	"Path": "org.geoserver.data.test.MockData.addWellKnownType",
	"Comment": "adds a single well known type with the custom properties specified",
	"Method": "void addWellKnownType(QName name,Map extraProperties){\r\n    URL properties = MockData.class.getResource(name.getLocalPart() + \".properties\");\r\n    URL style = MockData.class.getResource(name.getLocalPart() + \".sld\");\r\n    String styleName = null;\r\n    if (style != null) {\r\n        styleName = name.getLocalPart();\r\n        addStyle(styleName, style);\r\n    }\r\n    if (extraProperties == null)\r\n        addPropertiesType(name, properties, Collections.singletonMap(KEY_STYLE, styleName));\r\n    else {\r\n        Map props = new HashMap(extraProperties);\r\n        props.put(KEY_STYLE, styleName);\r\n        addPropertiesType(name, properties, props);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.DownloadProcessTest.testDownloadPhysicalLimitsVector",
	"Comment": "test download physical limit for vectorial data. it should throw an exception",
	"Method": "void testDownloadPhysicalLimitsVector(){\r\n    final WPSResourceManager resourceManager = getResourceManager();\r\n    ProcessListener listener = new ProcessListener(new ExecutionStatus(new NameImpl(\"gs\", \"DownloadEstimator\"), resourceManager.getExecutionId(false), false));\r\n    DownloadEstimatorProcess limits = new DownloadEstimatorProcess(new StaticDownloadServiceConfiguration(new DownloadServiceConfiguration(DownloadServiceConfiguration.NO_LIMIT, DownloadServiceConfiguration.NO_LIMIT, DownloadServiceConfiguration.NO_LIMIT, 1, DownloadServiceConfiguration.DEFAULT_COMPRESSION_LEVEL, DownloadServiceConfiguration.NO_LIMIT)), getGeoServer());\r\n    DownloadProcess downloadProcess = new DownloadProcess(getGeoServer(), limits, resourceManager);\r\n    try {\r\n        // layerName\r\n        downloadProcess.execute(getLayerId(MockData.POLYGONS), null, \"application/zip\", null, CRS.decode(\"EPSG:32615\"), roi, false, null, null, null, null, null, listener);\r\n    } catch (ProcessException e) {\r\n        Assert.assertEquals(\"java.io.IOException: Download Exceeded the maximum HARD allowed size!: Download Exceeded the maximum HARD allowed size!\", e.getMessage() + (e.getCause() != null ? \": \" + e.getCause().getMessage() : \"\"));\r\n        Throwable le = listener.exception;\r\n        Assert.assertEquals(\"java.io.IOException: Download Exceeded the maximum HARD allowed size!: Download Exceeded the maximum HARD allowed size!\", le.getMessage() + (le.getCause() != null ? \": \" + le.getCause().getMessage() : \"\"));\r\n        return;\r\n    }\r\n    Assert.assertFalse(true);\r\n}"
}, {
	"Path": "org.geoserver.rest.security.RuleMapXMLConverter.insert",
	"Comment": "generate the jdom element needed to represent an access control rule and insert it into theparent element given.",
	"Method": "void insert(Element elem,Object o){\r\n    if (o instanceof RuleMap) {\r\n        Map<String, String> ruleMap = (Map<String, String>) o;\r\n        for (Map.Entry<String, String> entry : ruleMap.entrySet()) {\r\n            Element ruleElement = new Element(RULEELEMENT);\r\n            ruleElement.setAttribute(RESOURCEATTR, entry.getKey());\r\n            ruleElement.setText(entry.getValue());\r\n            elem.getChildren().add(ruleElement);\r\n        }\r\n    } else {\r\n        throw new IllegalArgumentException();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.GetFeature.isPreComputed",
	"Comment": "returns true if all count executors are given a static count value",
	"Method": "boolean isPreComputed(List<CountExecutor> totalCountExecutors){\r\n    for (CountExecutor q : totalCountExecutors) {\r\n        if (!q.isCountSet()) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.script.ScriptPlugin.getScriptEngineFactoryClass",
	"Comment": "the associated script engine factory for the script plugin.",
	"Method": "Class<? extends ScriptEngineFactory> getScriptEngineFactoryClass(){\r\n    return scriptEngineFactoryClass;\r\n}"
}, {
	"Path": "org.geoserver.wps.ppio.BoundingBoxPPIO.encode",
	"Comment": "encodes the internal representation of the object to an xml stream.",
	"Method": "BoundingBoxType encode(Object object){\r\n    if (object == null) {\r\n        throw new IllegalArgumentException(\"Cannot encode a null bounding box\");\r\n    }\r\n    return fromTargetType(object);\r\n}"
}, {
	"Path": "org.geoserver.sldservice.utils.classifier.RulesBuilder.pointStyle",
	"Comment": "generate polygon symbolyzer for each rule in list fill color is choose from rampcolor",
	"Method": "void pointStyle(List<Rule> rules,ColorRamp fillRamp,boolean reverseColors){\r\n    Iterator<Rule> it;\r\n    Rule rule;\r\n    Iterator<Color> colors;\r\n    Color color;\r\n    try {\r\n        fillRamp.setNumClasses(rules.size());\r\n        if (reverseColors) {\r\n            fillRamp.revert();\r\n        }\r\n        colors = fillRamp.getRamp().iterator();\r\n        it = rules.iterator();\r\n        while (it.hasNext() && colors.hasNext()) {\r\n            color = colors.next();\r\n            rule = it.next();\r\n            Mark mark = sb.createMark(StyleBuilder.MARK_CIRCLE, sb.createFill(color), includeStrokeForPoints && strokeWeight >= 0 ? sb.createStroke(strokeColor, strokeWeight) : null);\r\n            rule.setSymbolizers(new Symbolizer[] { sb.createPointSymbolizer(sb.createGraphic(null, mark, null, 1.0, pointSize, 0.0)) });\r\n        }\r\n    } catch (Exception e) {\r\n        if (LOGGER.isLoggable(Level.INFO))\r\n            LOGGER.log(Level.INFO, \"Failed to build polygon Symbolizer\" + e.getLocalizedMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.data.test.CiteTestData.registerNamespaces",
	"Comment": "populates a map with prefix to namespace uri mappings for all the mock data namespaces.",
	"Method": "void registerNamespaces(Map<String, String> namespaces){\r\n    namespaces.put(CITE_PREFIX, CITE_URI);\r\n    namespaces.put(CDF_PREFIX, CDF_URI);\r\n    namespaces.put(CGF_PREFIX, CGF_URI);\r\n    namespaces.put(SF_PREFIX, SF_URI);\r\n}"
}, {
	"Path": "org.geoserver.wfs.xml.v1_0_0.XmlSchemaEncoder.getNSImport",
	"Comment": "creates a import namespace element, for cases when requests contain multiple namespaces, asyou can not have more than one target namespace. see wfs spec. 8.3.1. all the typenames thathave the correct prefix are added to the import statement.",
	"Method": "StringBuffer getNSImport(String prefix,FeatureTypeInfo[] infos,String baseUrl,String service){\r\n    LOGGER.finer(\"prefix is \" + prefix);\r\n    StringBuffer retBuffer = new StringBuffer(\"\\n  <xs:import namespace=\\\"\");\r\n    String namespace = catalog.getNamespaceByPrefix(prefix).getURI();\r\n    retBuffer.append(namespace + \"\\\"\");\r\n    Map<String, String> params = new HashMap<String, String>();\r\n    params.put(\"request\", \"DescribeFeatureType\");\r\n    params.put(\"service\", \"wfs\");\r\n    params.put(\"version\", \"1.0.0\");\r\n    StringBuilder typeNames = new StringBuilder();\r\n    for (int i = 0; i < infos.length; i++) {\r\n        FeatureTypeInfo info = infos[i];\r\n        String typeName = info.getPrefixedName();\r\n        if (typeName.startsWith(prefix + \":\")) {\r\n            typeNames.append(typeName).append(\",\");\r\n        }\r\n    }\r\n    typeNames.deleteCharAt(retBuffer.length() - 1);\r\n    params.put(\"typeName\", typeNames.toString());\r\n    String ftLocation = buildURL(baseUrl, service, params, URLType.SERVICE);\r\n    retBuffer.append(\"\\n        schemaLocation=\\\"\" + ResponseUtils.encodeXML(ftLocation));\r\n    retBuffer.append(\"\\\"/>\");\r\n    return retBuffer;\r\n}"
}, {
	"Path": "org.geoserver.test.FeatureChainingWfsTest.testFilterAnd",
	"Comment": "similar to above test case but using and as a wrapper for 2 filters involving nestedattributes.",
	"Method": "void testFilterAnd(){\r\n    String xml = \"<wfs:GetFeature \" + GETFEATURE_ATTRIBUTES + \">\" + \"<wfs:Query typeName=\\\"gsml:MappedFeature\\\">\" + \"    <ogc:Filter>\" + \"        <ogc:And>\" + \"            <ogc:PropertyIsEqualTo>\" + \"                <ogc:Literal>significant<\/ogc:Literal>\" + \"                <ogc:PropertyName>gsml:specification/gsml:GeologicUnit/gsml:composition/gsml:CompositionPart/gsml:proportion/gsml:CGI_TermValue/gsml:value<\/ogc:PropertyName>\" + \"            <\/ogc:PropertyIsEqualTo>\" + \"            <ogc:PropertyIsEqualTo>\" + \"                 <ogc:Literal>New Group<\/ogc:Literal>\" + \"                 <ogc:PropertyName>gsml:specification/gsml:GeologicUnit/gml:name<\/ogc:PropertyName>\" + \"            <\/ogc:PropertyIsEqualTo>\" + \"        <\/ogc:And>\" + \"    <\/ogc:Filter>\" + \"<\/wfs:Query> \" + \"<\/wfs:GetFeature>\";\r\n    validate(xml);\r\n    Document doc = postAsDOM(\"wfs\", xml);\r\n    LOGGER.info(\"WFS filter GetFeature response:\\n\" + prettyString(doc));\r\n    assertEquals(\"wfs:FeatureCollection\", doc.getDocumentElement().getNodeName());\r\n    assertXpathEvaluatesTo(\"1\", \"/wfs:FeatureCollection/@numberOfFeatures\", doc);\r\n    assertXpathCount(1, \"//gsml:MappedFeature\", doc);\r\n    assertXpathEvaluatesTo(\"mf4\", \"//gsml:MappedFeature/@gml:id\", doc);\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.LDAPUtils.getLdapTemplateInContext",
	"Comment": "returns an ldap template bounded to the given context, if not null.",
	"Method": "SpringSecurityLdapTemplate getLdapTemplateInContext(DirContext ctx,SpringSecurityLdapTemplate template){\r\n    SpringSecurityLdapTemplate authTemplate;\r\n    if (ctx == null) {\r\n        authTemplate = template;\r\n        ((AbstractContextSource) authTemplate.getContextSource()).setAnonymousReadOnly(true);\r\n    } else {\r\n        authTemplate = new SpringSecurityLdapTemplate(new ContextSource() {\r\n            @Override\r\n            public DirContext getReadOnlyContext() throws NamingException {\r\n                return ctx;\r\n            }\r\n            @Override\r\n            public DirContext getReadWriteContext() throws NamingException {\r\n                return ctx;\r\n            }\r\n            @Override\r\n            public DirContext getContext(String principal, String credentials) throws NamingException {\r\n                return ctx;\r\n            }\r\n        });\r\n    }\r\n    return authTemplate;\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.LDAPUtils.getLdapTemplateInContext",
	"Comment": "returns an ldap template bounded to the given context, if not null.",
	"Method": "SpringSecurityLdapTemplate getLdapTemplateInContext(DirContext ctx,SpringSecurityLdapTemplate template){\r\n    return ctx;\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.LDAPUtils.getLdapTemplateInContext",
	"Comment": "returns an ldap template bounded to the given context, if not null.",
	"Method": "SpringSecurityLdapTemplate getLdapTemplateInContext(DirContext ctx,SpringSecurityLdapTemplate template){\r\n    return ctx;\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.LDAPUtils.getLdapTemplateInContext",
	"Comment": "returns an ldap template bounded to the given context, if not null.",
	"Method": "SpringSecurityLdapTemplate getLdapTemplateInContext(DirContext ctx,SpringSecurityLdapTemplate template){\r\n    return ctx;\r\n}"
}, {
	"Path": "org.geoserver.wfs3.GetFeatureMapboxOutputFormatTest.testItemsFeatureBuildingsBBOX",
	"Comment": "tests mapbox protobuf encoding for features in items, with bbox filter",
	"Method": "void testItemsFeatureBuildingsBBOX(){\r\n    String roadSegments = getEncodedName(MockData.BUILDINGS);\r\n    String path = \"wfs3/collections/\" + roadSegments + \"/items?f=application/x-protobuf;type=mapbox-vector&resolution=10000\" + \"&BBOX=0.002,0.001,0.0024,0.0003\";\r\n    MockHttpServletResponse response = getAsServletResponse(path);\r\n    byte[] responseBytes = response.getContentAsByteArray();\r\n    VectorTileDecoder decoder = new VectorTileDecoder();\r\n    FeatureIterable fiter = decoder.decode(responseBytes);\r\n    List<Feature> featuresList = fiter.asList();\r\n    assertEquals(1, featuresList.size());\r\n    assertEquals(\"cite__Buildings\", featuresList.get(0).getLayerName());\r\n    assertEquals(\"POLYGON ((0 73.1392, 0 0, 256 0, 256 73.1392, 0 73.1392))\", featuresList.get(0).getGeometry().toText());\r\n}"
}, {
	"Path": "org.geoserver.data.CatalogWriter.write",
	"Comment": "writes the catalog.xml file.this methodbe called after any other methods.",
	"Method": "void write(File file){\r\n    try (FileOutputStream os = new FileOutputStream(file)) {\r\n        Transformer tx = TransformerFactory.newInstance().newTransformer();\r\n        tx.setOutputProperty(OutputKeys.INDENT, \"yes\");\r\n        DOMSource source = new DOMSource(document);\r\n        StreamResult result = new StreamResult(os);\r\n        tx.transform(source, result);\r\n    } catch (Exception e) {\r\n        String msg = \"Could not write catalog to \" + file;\r\n        throw (IOException) new IOException(msg).initCause(e);\r\n    }\r\n}"
}, {
	"Path": "org.vfny.geoserver.util.WCSUtils.resample",
	"Comment": "reprojectingthe new grid geometry can have a different coordinate reference system than the underlyinggrid geometry. for example, a grid coverage can be reprojected from a geodetic coordinatereference system to universal transverse mercator crs.",
	"Method": "GridCoverage2D resample(GridCoverage2D coverage,CoordinateReferenceSystem sourceCRS,CoordinateReferenceSystem targetCRS,GridGeometry2D gridGeometry,Interpolation interpolation){\r\n    final ParameterValueGroup param = (ParameterValueGroup) PROCESSOR.getOperation(\"Resample\").getParameters();\r\n    param.parameter(\"Source\").setValue(coverage);\r\n    param.parameter(\"CoordinateReferenceSystem\").setValue(targetCRS);\r\n    param.parameter(\"GridGeometry\").setValue(gridGeometry);\r\n    param.parameter(\"InterpolationType\").setValue(interpolation);\r\n    return (GridCoverage2D) ((Resample) PROCESSOR.getOperation(\"Resample\")).doOperation(param, hints);\r\n}"
}, {
	"Path": "org.geoserver.nsg.pagination.random.IndexConfigurationManager.manageStorageChange",
	"Comment": "helper method that move resources files form current folder to the new one, current storageis deleted",
	"Method": "void manageStorageChange(Object newStorage){\r\n    try {\r\n        if (newStorage != null) {\r\n            String newStorageStr = (String) newStorage;\r\n            Resource newResource = new FileSystemResourceStore(new File(newStorageStr)).get(\"\");\r\n            Resource exResource = indexConfiguration.getStorageResource();\r\n            if (exResource != null && !newResource.dir().getAbsolutePath().equals(exResource.dir().getAbsolutePath())) {\r\n                exResource.delete();\r\n            }\r\n            indexConfiguration.setStorageResource(newResource);\r\n        }\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error on change store\", exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.store.AbstractMappingStore.mapPropertiesToComplex",
	"Comment": "performs the common mappings, subclasses can override to add more",
	"Method": "void mapPropertiesToComplex(ComplexFeatureBuilder builder,SimpleFeature fi){\r\n    AttributeBuilder ab = new AttributeBuilder(FEATURE_FACTORY);\r\n    for (PropertyDescriptor pd : schema.getDescriptors()) {\r\n        if (!(pd instanceof AttributeDescriptor)) {\r\n            continue;\r\n        }\r\n        String localName = (String) pd.getUserData().get(JDBCOpenSearchAccess.SOURCE_ATTRIBUTE);\r\n        if (localName == null) {\r\n            continue;\r\n        }\r\n        Object value = fi.getAttribute(localName);\r\n        if (value == null) {\r\n            continue;\r\n        }\r\n        ab.setDescriptor((AttributeDescriptor) pd);\r\n        Attribute attribute = ab.buildSimple(null, value);\r\n        builder.append(pd.getName(), attribute);\r\n    }\r\n    Object metadataValue = fi.getAttribute(\"metadata\");\r\n    if (metadataValue instanceof SimpleFeature) {\r\n        SimpleFeature metadataFeature = (SimpleFeature) metadataValue;\r\n        ab.setDescriptor((AttributeDescriptor) schema.getDescriptor(METADATA_PROPERTY_NAME));\r\n        Attribute attribute = ab.buildSimple(null, metadataFeature.getAttribute(\"metadata\"));\r\n        builder.append(METADATA_PROPERTY_NAME, attribute);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityProvider.createAuthenticationProvider",
	"Comment": "creates an authentication provider.if the extension does not provide an authentication provider this method should simplyreturn null.",
	"Method": "GeoServerAuthenticationProvider createAuthenticationProvider(SecurityNamedServiceConfig config){\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.GeoServerInstance.initInstance",
	"Comment": "instantiates this geoserver instance, i.e. a resource loader based on this instance datadirectory is instantiated, a mocked servlet context is created and an application context isinitiated.",
	"Method": "GeoServerTestApplicationContext initInstance(){\r\n    GeoServerResourceLoader loader = new GeoServerResourceLoader(dataDirectory);\r\n    LoggingUtils.configureGeoServerLogging(loader, this.getClass().getResourceAsStream(\"/TEST_LOGGING.properties\"), false, true, null);\r\n    MockServletContext servletContext = createServletContext();\r\n    GeoServerTestApplicationContext applicationContext = new GeoServerTestApplicationContext(new String[] { \"classpath*:/applicationContext.xml\", \"classpath*:/applicationSecurityContext.xml\" }, servletContext);\r\n    applicationContext.setUseLegacyGeoServerLoader(false);\r\n    applicationContext.refresh();\r\n    applicationContext.publishEvent(new ContextLoadedEvent(applicationContext));\r\n    servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, applicationContext);\r\n    return applicationContext;\r\n}"
}, {
	"Path": "org.geoserver.data.test.MockData.addWellKnownTypes",
	"Comment": "adds the list of well known types to the data directory. well known types are listed asconstants in the mockdata class header, and are organized as arrays based on the cite testthey do come from",
	"Method": "void addWellKnownTypes(QName[] names){\r\n    for (int i = 0; i < names.length; i++) {\r\n        QName name = names[i];\r\n        addWellKnownType(name, null);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.CatalogBuilder.initFeatureType",
	"Comment": "initializes a feature type object setting any info that has not been set.",
	"Method": "void initFeatureType(FeatureTypeInfo featureType){\r\n    if (featureType.getCatalog() == null) {\r\n        featureType.setCatalog(catalog);\r\n    }\r\n    initResourceInfo(featureType);\r\n    if (featureType.getSRS() == null) {\r\n        lookupSRS(featureType, true);\r\n    }\r\n    if (featureType.getProjectionPolicy() == null) {\r\n        setupProjectionPolicy(featureType);\r\n    }\r\n    CoordinateReferenceSystem crs = featureType.getCRS();\r\n    if (featureType.getLatLonBoundingBox() == null && featureType.getNativeBoundingBox() == null) {\r\n        setupBounds(featureType);\r\n    } else if (featureType.getLatLonBoundingBox() == null) {\r\n        setupBounds(featureType);\r\n    } else if (featureType.getNativeBoundingBox() == null && crs != null) {\r\n        ReferencedEnvelope boundsLatLon = featureType.getLatLonBoundingBox();\r\n        featureType.setNativeBoundingBox(boundsLatLon.transform(crs, true));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.v1_1.DescribeFeatureTypeTest.testNoWfsSchemaImport",
	"Comment": "tests that wfs schema is not imported in a describefeaturetype response.",
	"Method": "void testNoWfsSchemaImport(){\r\n    final String typeName = CiteTestData.POLYGONS.getLocalPart();\r\n    String path = \"ows?service=WFS&version=1.1.0&request=DescribeFeatureType&typeName=\" + typeName;\r\n    Document doc = getAsDOM(path);\r\n    assertEquals(\"xsd:schema\", doc.getDocumentElement().getNodeName());\r\n    assertXpathExists(\"//xsd:complexType[@name='\" + typeName + \"Type']\", doc);\r\n    assertXpathExists(\"//xsd:element[@name='\" + typeName + \"']\", doc);\r\n    assertXpathExists(\"//xsd:import[@namespace='\" + GML.NAMESPACE + \"']\", doc);\r\n    assertXpathNotExists(\"//xsd:import[@namespace='\" + WFS.NAMESPACE + \"']\", doc);\r\n}"
}, {
	"Path": "org.geoserver.wfs.GetFeatureContext.getFeatureTypeInfo",
	"Comment": "the feature type being queried. the object returned may be mutable, but the callback isstrongly suggested not to attempt any modification, the behavior of doing so is undefined andmight change over time",
	"Method": "FeatureTypeInfo getFeatureTypeInfo(){\r\n    return featureTypeInfo;\r\n}"
}, {
	"Path": "org.geoserver.security.impl.DigestAuthUtils.split",
	"Comment": "splits a string at the first instance of the delimiter.does not include the delimiter in the response.",
	"Method": "String[] split(String toSplit,String delimiter){\r\n    Assert.hasLength(toSplit, \"Cannot split a null or empty string\");\r\n    Assert.hasLength(delimiter, \"Cannot use a null or empty delimiter to split a string\");\r\n    if (delimiter.length() != 1) {\r\n        throw new IllegalArgumentException(\"Delimiter can only be one character in length\");\r\n    }\r\n    int offset = toSplit.indexOf(delimiter);\r\n    if (offset < 0) {\r\n        return null;\r\n    }\r\n    String beforeDelimiter = toSplit.substring(0, offset);\r\n    String afterDelimiter = toSplit.substring(offset + 1);\r\n    return new String[] { beforeDelimiter, afterDelimiter };\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.LimitedOutputStream.checkLimit",
	"Comment": "called to check, whether the input streams limit is reached.",
	"Method": "void checkLimit(){\r\n    if (count > sizeMax) {\r\n        raiseError(sizeMax, count);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.remote.RemoteProcessFactoryConfigurationWatcher.parseConfigurationValues",
	"Comment": "parses the properties file for the remote process factory configuration. when it runs intoproblems it uses default values",
	"Method": "RemoteProcessFactoryConfiguration parseConfigurationValues(Properties remoteProcessFactoryProperties){\r\n    Utilities.ensureNonNull(\"remoteProcessFactoryProperties\", remoteProcessFactoryProperties);\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.log(Level.FINE, \"Parsing the properties file\");\r\n    }\r\n    long remoteProcessStubCycleSleepTime = RemoteProcessFactoryConfiguration.DEFAULT_SLEEP_TIME;\r\n    Map<String, String> configKvPs = new HashMap<String, String>();\r\n    Set<Object> properties = remoteProcessFactoryProperties.keySet();\r\n    for (Object property : properties) {\r\n        String prop = (String) property;\r\n        if (prop.equalsIgnoreCase(RemoteProcessFactoryConfiguration.DEFAULT_SLEEP_TIME_NAME)) {\r\n            String value = (String) remoteProcessFactoryProperties.get(RemoteProcessFactoryConfiguration.DEFAULT_SLEEP_TIME_NAME);\r\n            try {\r\n                final long parseLong = Long.parseLong(value);\r\n                if (LOGGER.isLoggable(Level.FINE)) {\r\n                    LOGGER.fine(\"maxFeatures parsed to \" + parseLong);\r\n                }\r\n                if (parseLong > 0) {\r\n                    remoteProcessStubCycleSleepTime = parseLong;\r\n                }\r\n            } catch (NumberFormatException e) {\r\n                if (LOGGER.isLoggable(Level.INFO)) {\r\n                    LOGGER.log(Level.INFO, e.getLocalizedMessage(), e);\r\n                }\r\n            }\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.fine(\"remoteProcessStubCycleSleepTime assigned to \" + remoteProcessStubCycleSleepTime);\r\n            }\r\n        } else {\r\n            configKvPs.put(prop, remoteProcessFactoryProperties.getProperty(prop));\r\n        }\r\n    }\r\n    return new RemoteProcessFactoryConfiguration(remoteProcessStubCycleSleepTime, configKvPs);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.getPixelColor",
	"Comment": "gets a specific pixel color from the specified buffered image",
	"Method": "Color getPixelColor(BufferedImage image,int i,int j){\r\n    ColorModel cm = image.getColorModel();\r\n    Raster raster = image.getRaster();\r\n    Object pixel = raster.getDataElements(i, j, null);\r\n    Color actual;\r\n    if (cm.hasAlpha()) {\r\n        actual = new Color(cm.getRed(pixel), cm.getGreen(pixel), cm.getBlue(pixel), cm.getAlpha(pixel));\r\n    } else {\r\n        actual = new Color(cm.getRed(pixel), cm.getGreen(pixel), cm.getBlue(pixel), 255);\r\n    }\r\n    return actual;\r\n}"
}, {
	"Path": "org.geoserver.catalog.NamespaceWorkspaceConsistencyListener.handlePostModifyEvent",
	"Comment": "takes care of keeping the stores namespace uri in synch with namespace changes",
	"Method": "void handlePostModifyEvent(CatalogPostModifyEvent event){\r\n    if (event.getSource() instanceof NamespaceInfo) {\r\n        NamespaceInfo ns = (NamespaceInfo) event.getSource();\r\n        String namespaceURI = ns.getURI();\r\n        WorkspaceInfo ws = catalog.getWorkspaceByName(ns.getPrefix());\r\n        if (ws != null) {\r\n            List<DataStoreInfo> stores = catalog.getDataStoresByWorkspace(ws);\r\n            if (stores.size() > 0) {\r\n                for (DataStoreInfo store : stores) {\r\n                    String oldURI = (String) store.getConnectionParameters().get(\"namespace\");\r\n                    if (oldURI != null && !namespaceURI.equals(oldURI)) {\r\n                        store.getConnectionParameters().put(\"namespace\", namespaceURI);\r\n                        catalog.save(store);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    syncIsolation(event.getSource());\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.panel.CharsetPanel.getFormComponent",
	"Comment": "returns the form component used in the panel in case it is needed for related form componentsvalidation",
	"Method": "FormComponent<String> getFormComponent(){\r\n    return choice;\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.AbstractNetCDFEncoder.collectStats",
	"Comment": "collects stats for future datapacking from the provided coverage and update the statistics.",
	"Method": "void collectStats(GridCoverage2D coverage,List<DataPacking.DataStats> statsList){\r\n    ImageWorker iw = new ImageWorker(coverage.getRenderedImage());\r\n    double[] minimum = iw.getMinimums();\r\n    double[] maximum = iw.getMaximums();\r\n    int count = Math.min(minimum.length, statsList.size());\r\n    for (int i = 0; i < count; i++) {\r\n        DataPacking.DataStats stats = statsList.get(i);\r\n        double min = minimum[i];\r\n        double max = maximum[i];\r\n        stats.update(min, max);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.postAsDOM",
	"Comment": "executes an ows request using the post method and returns the result as an xml document.",
	"Method": "Document postAsDOM(String path,Document postAsDOM,String path,List<Exception> validationErrors,Document postAsDOM,String path,String xml,Document postAsDOM,String path,String xml,List<Exception> validationErrors){\r\n    return dom(post(path, xml));\r\n}"
}, {
	"Path": "org.vfny.geoserver.util.WCSUtils.guessSizeFromRange",
	"Comment": "guesses the size of the sample able to contain the range fully",
	"Method": "int guessSizeFromRange(NumberRange range){\r\n    double min = range.getMinimum();\r\n    double max = range.getMaximum();\r\n    double diff = max - min;\r\n    if (diff <= ((int) Byte.MAX_VALUE - (int) Byte.MIN_VALUE)) {\r\n        return 8;\r\n    } else if (diff <= ((int) Short.MAX_VALUE - (int) Short.MIN_VALUE)) {\r\n        return 16;\r\n    } else if (diff <= ((double) Integer.MAX_VALUE - (double) Integer.MIN_VALUE)) {\r\n        return 32;\r\n    } else if (diff <= ((double) Float.MAX_VALUE - (double) Float.MIN_VALUE)) {\r\n        return 32;\r\n    } else {\r\n        return 64;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.gwc.config.GWCConfig.getOldDefaults",
	"Comment": "returns a config suitable to match the old defaults when the integrated gwc behaivour was notconfigurable.",
	"Method": "GWCConfig getOldDefaults(){\r\n    GWCConfig config = new GWCConfig();\r\n    config.setOldDefaults();\r\n    return config;\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.DownloadProcessTest.testDownloadEstimatorReadLimitsRaster",
	"Comment": "test download estimator for raster data. the result should exceed the limits",
	"Method": "void testDownloadEstimatorReadLimitsRaster(){\r\n    DownloadEstimatorProcess limits = new DownloadEstimatorProcess(new StaticDownloadServiceConfiguration(new DownloadServiceConfiguration(DownloadServiceConfiguration.NO_LIMIT, 10, DownloadServiceConfiguration.NO_LIMIT, DownloadServiceConfiguration.NO_LIMIT, DownloadServiceConfiguration.DEFAULT_COMPRESSION_LEVEL, DownloadServiceConfiguration.NO_LIMIT)), getGeoServer());\r\n    final WPSResourceManager resourceManager = getResourceManager();\r\n    DownloadProcess downloadProcess = new DownloadProcess(getGeoServer(), limits, resourceManager);\r\n    Polygon roi = (Polygon) new WKTReader2().read(\"POLYGON (( -127.57473954542964 54.06575021619523, -130.8545966116691 52.00807146727025, -129.50812897394974 49.85372324691927, -130.5300633861675 49.20465679591609, -129.25955033314003 48.60392508062591, -128.00975216684665 50.986137055052474, -125.8623089087404 48.63154492960477, -123.984159178178 50.68231871628503, -126.91186316993704 52.15307567440926, -125.3444367403868 53.54787804784162, -127.57473954542964 54.06575021619523 ))\");\r\n    roi.setSRID(4326);\r\n    try {\r\n        // layerName\r\n        downloadProcess.execute(getLayerId(MockData.USA_WORLDIMG), null, \"image/tiff\", null, CRS.decode(\"EPSG:4326\", true), roi, true, null, null, null, null, null, new NullProgressListener());\r\n        Assert.assertFalse(true);\r\n    } catch (ProcessException e) {\r\n        Assert.assertEquals(\"java.lang.IllegalArgumentException: Download Limits Exceeded. Unable to proceed!: Download Limits Exceeded. Unable to proceed!\", e.getMessage() + (e.getCause() != null ? \": \" + e.getCause().getMessage() : \"\"));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.data.util.CoverageStoreUtils.listDataFormatsDescriptions",
	"Comment": "returns the descriptions for the available dataformats.arrrg! put these in the select box.",
	"Method": "List listDataFormatsDescriptions(){\r\n    List list = new ArrayList();\r\n    Format[] formats = GridFormatFinder.getFormatArray();\r\n    final int length = formats.length;\r\n    for (int i = 0; i < length; i++) {\r\n        if (!list.contains(formats[i].getDescription())) {\r\n            list.add(formats[i].getDescription());\r\n        }\r\n    }\r\n    return Collections.synchronizedList(list);\r\n}"
}, {
	"Path": "org.geoserver.security.VectorAccessLimits.getReadQuery",
	"Comment": "returns a geotools query wrapping the read attributes and the read filter",
	"Method": "Query getReadQuery(){\r\n    return buildQuery(readAttributes, readFilter);\r\n}"
}, {
	"Path": "org.geoserver.wms.capabilities.CapabilityUtil.computeScaleHint",
	"Comment": "computes the rendering scale taking into account the standard pixel size and the real worldscale denominator.",
	"Method": "Double computeScaleHint(Double scaleDenominator){\r\n    final Double sizeStandardRenderPixel = 0.00028;\r\n    Double scaleHint = Math.sqrt(Math.pow((scaleDenominator * sizeStandardRenderPixel), 2) * 2);\r\n    return scaleHint;\r\n}"
}, {
	"Path": "org.geoserver.security.password.JasyptPasswordEncoderWrapper.setPasswordEncryptor",
	"Comment": "sets a password encryptor to be used. only one of setpasswordencryptor orsetstringdigester should be called. if both are, the last call will define whichmethod will be used.",
	"Method": "void setPasswordEncryptor(PasswordEncryptor passwordEncryptor){\r\n    this.passwordEncryptor = passwordEncryptor;\r\n    this.useEncryptor = Boolean.TRUE;\r\n}"
}, {
	"Path": "org.geoserver.wms.animate.FrameCatalogVisitor.dispose",
	"Comment": "suddenly stops the executor service and clear instantiated visitors.",
	"Method": "void dispose(){\r\n    this.framesNumber = 0;\r\n    if (this.tasks != null)\r\n        this.tasks.clear();\r\n    this.tasks = null;\r\n}"
}, {
	"Path": "org.geoserver.csw.store.internal.CatalogStoreMapping.subMapping",
	"Comment": "create a submapping from a list of property names required properties will also be included.",
	"Method": "CatalogStoreMapping subMapping(List<PropertyName> properties,RecordDescriptor rd){\r\n    Set<String> paths = new HashSet<String>();\r\n    for (PropertyName prop : properties) {\r\n        paths.add(toDotPath(XPathUtil.steps(rd.getFeatureDescriptor(), prop.toString(), rd.getNamespaceSupport())));\r\n    }\r\n    CatalogStoreMapping mapping = new CatalogStoreMapping();\r\n    for (Entry<String, CatalogStoreMappingElement> element : mappingElements.entrySet()) {\r\n        if (element.getValue().isRequired() || paths.contains(element.getKey())) {\r\n            mapping.mappingElements.put(element.getKey(), element.getValue());\r\n        }\r\n    }\r\n    mapping.identifier = identifier;\r\n    mapping.includeEnvelope = includeEnvelope && paths.contains(rd.getBoundingBoxPropertyName());\r\n    return mapping;\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.IsolatedCatalogFacade.enforceResourceIsolation",
	"Comment": "checks if the provided resource is visible in the current context.",
	"Method": "T enforceResourceIsolation(T resource){\r\n    if (resource == null) {\r\n        return null;\r\n    }\r\n    StoreInfo store = resource.getStore();\r\n    if (store == null) {\r\n        return resource;\r\n    }\r\n    WorkspaceInfo workspace = store.getWorkspace();\r\n    return canSeeWorkspace(workspace) ? resource : null;\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTestsUtils.checkNoDifferences",
	"Comment": "helper method that checks that provided instances are the same. the first instance is used asreference.",
	"Method": "void checkNoDifferences(GeoServerInstance instances){\r\n    if (instances.length <= 1) {\r\n        return;\r\n    }\r\n    GeoServerInstance instance = instances[0];\r\n    for (int i = 1; i < instances.length; i++) {\r\n        List<InfoDiff> differences = differences(instance, instances[i]);\r\n        assertThat(differences.size(), is(0));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.importer.rest.ImportTaskControllerTest.testPutItemSRSOnLayer",
	"Comment": "this variant matches exactly the documentation and puts the changes directly on the layer",
	"Method": "void testPutItemSRSOnLayer(){\r\n    File dir = unpack(\"shape/archsites_no_crs.zip\");\r\n    importer.createContext(new SpatialFile(new File(dir, \"archsites.shp\")));\r\n    JSONObject json = (JSONObject) getAsJSON(RestBaseController.ROOT_PATH + \"/imports/1/tasks/0\");\r\n    JSONObject task = json.getJSONObject(\"task\");\r\n    assertEquals(\"NO_CRS\", task.get(\"state\"));\r\n    assertFalse(task.getJSONObject(\"layer\").containsKey(\"srs\"));\r\n    setSRSRequest(RestBaseController.ROOT_PATH + \"/imports/1/tasks/0/layer\", \"EPSG:26713\");\r\n    ImportContext context = importer.getContext(1);\r\n    json = (JSONObject) getAsJSON(RestBaseController.ROOT_PATH + \"/imports/1/tasks/0?expand=2\");\r\n    task = json.getJSONObject(\"task\");\r\n    assertEquals(\"READY\", task.get(\"state\"));\r\n    assertEquals(\"EPSG:26713\", task.getJSONObject(\"layer\").getString(\"srs\"));\r\n    State state = context.getState();\r\n    assertEquals(\"Invalid context state\", State.PENDING, state);\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.PolygonExtractionProcessTest.testProcessStandaloneBasic",
	"Comment": "test basic capabilities for the contour process. it works on the dem tiff and produces ashapefile. nothing more nothing less.",
	"Method": "void testProcessStandaloneBasic(){\r\n    final GridCoverage2D gc = (GridCoverage2D) getCatalog().getCoverageByName(DEM.getLocalPart()).getGridCoverage(null, GeoTools.getDefaultHints());\r\n    scheduleForDisposal(gc);\r\n    final PolygonExtractionProcess process = new PolygonExtractionProcess();\r\n    final SimpleFeatureCollection fc = process.execute(gc, 0, true, null, null, new ArrayList<Range>() {\r\n        {\r\n            add(new Range(0d, true, 1000d, false));\r\n            add(new Range(1000d, true, 2000d, false));\r\n        }\r\n    }, new NullProgressListener());\r\n    assertNotNull(fc);\r\n    assertTrue(fc.size() > 0);\r\n    SimpleFeatureIterator fi = fc.features();\r\n    while (fi.hasNext()) {\r\n        SimpleFeature sf = fi.next();\r\n        Double value = (Double) sf.getAttribute(\"value\");\r\n        assertTrue(value > 0 && value < 8);\r\n    }\r\n    fi.close();\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.ReaderUtils.getBooleanAttribute",
	"Comment": "getbooleanattribute purpose.used to help with xml manipulations. returns the first child integer attribute of thespecified name. an exception occurs when the node is required and not found.",
	"Method": "boolean getBooleanAttribute(Element elem,String attName,boolean mandatory,boolean defaultValue){\r\n    String value = getAttribute(elem, attName, mandatory);\r\n    if ((value == null) || (value == \"\")) {\r\n        return defaultValue;\r\n    }\r\n    return Boolean.valueOf(value).booleanValue();\r\n}"
}, {
	"Path": "org.geoserver.wps.remote.RemoteProcessFactoryConfiguration.get",
	"Comment": "a method to access generic parsed property keys from the properties configuration file",
	"Method": "String get(String prop){\r\n    return (configKvPs != null ? configKvPs.get(prop) : null);\r\n}"
}, {
	"Path": "org.geoserver.wcs.AbstractGetCoverageTest.executeGetCoverageKvp",
	"Comment": "runs getcoverage on the specified parameters and returns an array of coverages",
	"Method": "GridCoverage[] executeGetCoverageKvp(Map<String, Object> raw){\r\n    GetCoverageType getCoverage = (GetCoverageType) kvpreader.read(kvpreader.createRequest(), parseKvp(raw), raw);\r\n    GridCoverage[] result = service.getCoverage(getCoverage);\r\n    coverages.addAll(Arrays.asList(result));\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.HistogramUtils.getHistogramMaxThreshold",
	"Comment": "helper method that get the threshold value that will be used to check if the resolution is tohigh.",
	"Method": "long getHistogramMaxThreshold(){\r\n    String value = System.getProperty(HISTOGRAM_MAX_THRESHOLD_VARIABLE);\r\n    if (value == null) {\r\n        return HISTOGRAM_MAX_THRESHOLD_DEFAULT;\r\n    }\r\n    return Long.parseLong(value);\r\n}"
}, {
	"Path": "org.geoserver.test.FeatureChainingWfsTest.testEncodeFeatureMembersGML",
	"Comment": "test featurecollection is encoded with one featuremembers element",
	"Method": "void testEncodeFeatureMembersGML(){\r\n    WFSInfo wfs = getGeoServer().getService(WFSInfo.class);\r\n    boolean encodeFeatureMember = wfs.isEncodeFeatureMember();\r\n    wfs.setEncodeFeatureMember(false);\r\n    getGeoServer().save(wfs);\r\n    Document doc = getAsDOM(\"wfs?request=GetFeature&version=1.1.0&typename=gsml:MappedFeature,gsml:GeologicUnit\");\r\n    LOGGER.info(\"WFS GetFeature&typename=gsml:MappedFeature,gsml:GeologicUnit response:\\n\" + prettyString(doc));\r\n    checkSchemaLocation(doc);\r\n    assertXpathEvaluatesTo(\"7\", \"/wfs:FeatureCollection/@numberOfFeatures\", doc);\r\n    assertXpathCount(4, \"//gsml:MappedFeature\", doc);\r\n    assertEquals(1, doc.getElementsByTagName(\"gml:featureMembers\").getLength());\r\n    assertEquals(0, doc.getElementsByTagName(\"gml:featureMember\").getLength());\r\n    {\r\n        String id = \"mf1\";\r\n        checkMf1Content(id, doc);\r\n    }\r\n    {\r\n        String id = \"mf2\";\r\n        checkMf2Content(id, doc);\r\n    }\r\n    {\r\n        String id = \"mf3\";\r\n        checkMf3Content(id, doc);\r\n    }\r\n    {\r\n        String id = \"mf4\";\r\n        checkMf4Content(id, doc);\r\n    }\r\n    assertXpathCount(1, \"//gsml:GeologicUnit[@gml:id='gu.25699']\", doc);\r\n    assertXpathCount(1, \"//gsml:GeologicUnit[@gml:id='gu.25678']\", doc);\r\n    assertXpathCount(1, \"//gsml:GeologicUnit[@gml:id='gu.25682']\", doc);\r\n    assertXpathCount(1, \"//gsml:GeologicUnit[@xlink:href='#gu.25699']\", doc);\r\n    assertXpathCount(1, \"//gsml:GeologicUnit[@xlink:href='#gu.25678']\", doc);\r\n    assertXpathCount(1, \"//gsml:GeologicUnit[@xlink:href='#gu.25682']\", doc);\r\n    wfs = getGeoServer().getService(WFSInfo.class);\r\n    wfs.setEncodeFeatureMember(encodeFeatureMember);\r\n    getGeoServer().save(wfs);\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.RasterDownload.readAndReproject",
	"Comment": "read and reproject. it may delegate the operations to a gridcoveragerenderer in case targetsize has been specified.",
	"Method": "GridCoverage2D readAndReproject(GridCoverage2DReader reader,GeneralParameterValue[] readParameters,CoordinateReferenceSystem targetCRS,ReferencedEnvelope targetEnvelope,Integer targetSizeX,Integer targetSizeY,Interpolation interpolation,double[] backgroundValues,boolean isImposedTargetSize,boolean reproject,List<GridCoverage2D> disposableSources){\r\n    if (isImposedTargetSize) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Target Size has been imposed. Delegating to GridCoverageRenderer\");\r\n        }\r\n        GridCoverageRenderer renderer = new GridCoverageRenderer(targetCRS, targetEnvelope, new Rectangle(0, 0, targetSizeX, targetSizeY), null, null);\r\n        Color color = backgroundValues != null ? new Color((int) backgroundValues[0], (int) backgroundValues[0], (int) backgroundValues[0]) : Color.BLACK;\r\n        RenderedImage ri = renderer.renderImage(reader, readParameters, RS, interpolation, color, 512, 512);\r\n        if (ri == null) {\r\n            throw new WPSException(\"The reader did not return anything\" + \"It normally means there is nothing there, or the data got filtered out by the ROI or filter\");\r\n        }\r\n        return (GridCoverage2D) ri.getProperty(\"ParentCoverage\");\r\n    } else {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Reading the coverage\");\r\n        }\r\n        GridCoverage2D gridCoverage = reader.read(readParameters);\r\n        if (gridCoverage == null) {\r\n            throw new WPSException(\"The reader did not return any data for current input \" + \"parameters. It normally means there is nothing there, or the data got filtered out by the ROI or filter\");\r\n        }\r\n        if (reproject) {\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.log(Level.FINE, \"Reprojecting the coverage\");\r\n            }\r\n            disposableSources.add(gridCoverage);\r\n            gridCoverage = (GridCoverage2D) Operations.DEFAULT.resample(gridCoverage, targetCRS, null, interpolation, backgroundValues);\r\n        }\r\n        return gridCoverage;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.DimensionsUtils.getValuesWithoutDuplicates",
	"Comment": "helper method that simply extract from a feature collection the values of a specificattribute removing duplicate values.",
	"Method": "Set<Object> getValuesWithoutDuplicates(String attributeName,FeatureCollection featureCollection){\r\n    Set uniques = getUniqueValues(featureCollection, attributeName, NO_LIMIT);\r\n    Set<Object> values = new TreeSet(uniques);\r\n    return values;\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityProvider.isAvailable",
	"Comment": "flag determining if this provider is available.this default implementation returns true, subclasses should override in caseswhere a meaningful check can be made... for instance checking for a jdbc driver, etc...",
	"Method": "boolean isAvailable(){\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.ReaderUtils.getKeyWords",
	"Comment": "getkeywords purpose.used to help with xml manipulations. returns a list of keywords that were found.",
	"Method": "List getKeyWords(Element keywordsElem){\r\n    NodeList klist = keywordsElem.getElementsByTagName(\"keyword\");\r\n    int kCount = klist.getLength();\r\n    List keywords = new ArrayList(kCount);\r\n    String kword;\r\n    Element kelem;\r\n    for (int i = 0; i < kCount; i++) {\r\n        kelem = (Element) klist.item(i);\r\n        kword = getElementText(kelem);\r\n        if (kword != null) {\r\n            keywords.add(kword);\r\n        }\r\n    }\r\n    Object[] s = (Object[]) keywords.toArray();\r\n    if (s == null) {\r\n        return new ArrayList();\r\n    }\r\n    ArrayList ss = new ArrayList(s.length);\r\n    for (int i = 0; i < s.length; i++) ss.add(s[i]);\r\n    return ss;\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.LegacyCatalogReader.readNamespaces",
	"Comment": "helper method that retrieves namespaces from the catalog.xml file. if readisolated parameteris true isolated workspace will be read, otherwise only non isolated workspaces will be read.",
	"Method": "Map<String, String> readNamespaces(boolean readIsolated){\r\n    Element namespacesElement = ReaderUtils.getChildElement(catalog, \"namespaces\", true);\r\n    if (namespacesElement == null) {\r\n        LOGGER.log(Level.INFO, \"No namespaces available.\");\r\n        return Collections.emptyMap();\r\n    }\r\n    NodeList namespaceElements = namespacesElement.getElementsByTagName(\"namespace\");\r\n    Map<String, String> namespaces = new HashMap();\r\n    for (int i = 0; i < namespaceElements.getLength(); i++) {\r\n        Element namespaceElement = (Element) namespaceElements.item(i);\r\n        try {\r\n            String prefix = namespaceElement.getAttribute(\"prefix\");\r\n            String uri = namespaceElement.getAttribute(\"uri\");\r\n            boolean isDefault = namespaceElement.getAttribute(\"default\").equalsIgnoreCase(\"true\");\r\n            boolean isIsolated = namespaceElement.getAttribute(\"isolated\").equalsIgnoreCase(\"true\");\r\n            if ((!readIsolated && isIsolated) || (readIsolated && !isIsolated)) {\r\n                continue;\r\n            }\r\n            namespaces.put(prefix, uri);\r\n            if (isDefault) {\r\n                namespaces.put(\"\", uri);\r\n            }\r\n        } catch (Exception exception) {\r\n            LOGGER.log(Level.WARNING, \"Error parsing namespace XML element.\", exception);\r\n        }\r\n    }\r\n    return namespaces;\r\n}"
}, {
	"Path": "org.geoserver.wfs.StoredQueryProvider.createStoredQuery",
	"Comment": "creates a new stored query specifying whether to persist the query to disk or not.",
	"Method": "StoredQuery createStoredQuery(StoredQueryDescriptionType query,StoredQuery createStoredQuery,StoredQueryDescriptionType query,boolean store){\r\n    StoredQuery sq = new StoredQuery(query, catalog);\r\n    if (store) {\r\n        putStoredQuery(sq);\r\n    }\r\n    return sq;\r\n}"
}, {
	"Path": "org.geoserver.web.publish.PublishedConfigurationPage.onSuccessfulSave",
	"Comment": "by default brings back the user to layerpage, subclasses can override this behavior",
	"Method": "void onSuccessfulSave(){\r\n    doReturn();\r\n}"
}, {
	"Path": "org.geoserver.wps.Execute.run",
	"Comment": "main method for performing decoding, execution, and response",
	"Method": "ExecuteResponseType run(ExecuteType execute){\r\n    ResponseDocumentType responseDocument = null;\r\n    OutputDefinitionType rawDataOutput = null;\r\n    if (execute.getResponseForm() != null) {\r\n        responseDocument = execute.getResponseForm().getResponseDocument();\r\n        rawDataOutput = execute.getResponseForm().getRawDataOutput();\r\n    }\r\n    if (responseDocument != null && rawDataOutput != null) {\r\n        throw new WPSException(\"Invalid request, only one of the raw data output or the \" + \"response document should be specified in the request\");\r\n    }\r\n    ExecuteRequest request = new ExecuteRequest(execute);\r\n    ExecuteResponseType response = executionManager.submit(request, !request.isAsynchronous());\r\n    return response;\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.LegacyFeatureTypeInfoReader.read",
	"Comment": "parses the info.xml file into a dom.this methodbe called before any other methods.",
	"Method": "void read(Resource file){\r\n    parentDirectory = file.parent();\r\n    Reader reader = XmlCharsetDetector.getCharsetAwareReader(file.in());\r\n    try {\r\n        featureType = ReaderUtils.parse(reader);\r\n    } finally {\r\n        reader.close();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.GeoServerInstance.createTempDirectory",
	"Comment": "helper method that just creates a temporary directory using the provide prefix.",
	"Method": "File createTempDirectory(String prefix){\r\n    try {\r\n        return IOUtils.createTempDirectory(prefix + \"-\");\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error creating temporary directory.\", exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wcs.AbstractGetCoverageTest.executeGetCoverageXml",
	"Comment": "runs getcoverage on the specified parameters and returns an array of coverages",
	"Method": "GridCoverage[] executeGetCoverageXml(String request){\r\n    GetCoverageType getCoverage = (GetCoverageType) xmlReader.read(null, new StringReader(request), null);\r\n    return service.getCoverage(getCoverage);\r\n}"
}, {
	"Path": "org.geoserver.geofence.config.GeoFenceConfigurationController.storeConfiguration",
	"Comment": "updates the configuration.sets the config into the manager and forces the classes needing to refresh to do so. thenstores the config to disk.",
	"Method": "void storeConfiguration(GeoFenceConfiguration gfConfig,CacheConfiguration cacheConfig){\r\n    configurationManager.setConfiguration(gfConfig);\r\n    configurationManager.setCacheConfiguration(cacheConfig);\r\n    cachedRuleReader.init();\r\n    configurationManager.storeConfiguration();\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.logout",
	"Comment": "clears the authentication context.this method is called after each test case",
	"Method": "void logout(){\r\n    SecurityContextHolder.clearContext();\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.store.AbstractMappingStore.modifySecondaryTable",
	"Comment": "modifies the contents of a secondary table by removing the old values completely and addingthe new mapped values as built by the feature build",
	"Method": "void modifySecondaryTable(Filter mainTypeFilter,Object value,String tableName,Function<String, Filter> secondaryTableFilterSupplier,IOBiFunction<String, SimpleFeatureStore, SimpleFeatureCollection> featureBuilder){\r\n    SimpleFeatureStore secondaryStore = getFeatureStoreForTable(tableName);\r\n    secondaryStore.setTransaction(getTransaction());\r\n    for (String id : getMainTypeDatabaseIdentifiers(mainTypeFilter)) {\r\n        Filter secondaryTableFilter = secondaryTableFilterSupplier.apply(id);\r\n        secondaryStore.removeFeatures(secondaryTableFilter);\r\n        if (value != null) {\r\n            SimpleFeatureCollection collection = featureBuilder.apply(id, secondaryStore);\r\n            secondaryStore.addFeatures(collection);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.ows.LocalWorkspaceCatalogFilter.workspaceLayerGroupInherit",
	"Comment": "should local workspaces include layer groups from the global workspace",
	"Method": "boolean workspaceLayerGroupInherit(){\r\n    if (groupInherit == null) {\r\n        String value = GeoServerExtensions.getProperty(\"GEOSERVER_GLOBAL_LAYER_GROUP_INHERIT\");\r\n        if (value != null) {\r\n            groupInherit = Boolean.parseBoolean(value);\r\n        } else {\r\n            groupInherit = true;\r\n        }\r\n    }\r\n    return groupInherit;\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.CatalogImpl.resolveCollections",
	"Comment": "method which reflectively sets all collections when they are null.",
	"Method": "void resolveCollections(Object object){\r\n    OwsUtils.resolveCollections(object);\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.ReaderUtils.getChildElement",
	"Comment": "getchildelement purpose.used to help with xml manipulations. returns the first child element of the specifiedname.",
	"Method": "Element getChildElement(Element root,String name,boolean mandatory,Element getChildElement,Element root,String name){\r\n    try {\r\n        return getChildElement(root, name, false);\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.data.resource.BasicResourceConfig.computeBoundsFromSRS",
	"Comment": "compute the native bounds from the native crs. acts as an alternative to computing the boundsfrom the data itself.",
	"Method": "AjaxSubmitLink computeBoundsFromSRS(Form<ResourceInfo> refForm,EnvelopePanel nativeBoundsPanel){\r\n    return new AjaxSubmitLink(\"computeLatLonFromNativeSRS\", refForm) {\r\n        private static final long serialVersionUID = 9211250161114770325L;\r\n        @Override\r\n        protected void onSubmit(AjaxRequestTarget target, Form<?> form) {\r\n            LOGGER.log(Level.FINE, \"Computing bounds from native CRS\");\r\n            ResourceInfo resource = (ResourceInfo) BasicResourceConfig.this.getDefaultModelObject();\r\n            CatalogBuilder cb = new CatalogBuilder(GeoServerApplication.get().getCatalog());\r\n            ReferencedEnvelope nativeBBox = cb.getBoundsFromCRS(resource);\r\n            if (nativeBBox != null) {\r\n                nativeBoundsPanel.setModelObject(nativeBBox);\r\n            }\r\n            target.add(nativeBoundsPanel);\r\n        }\r\n        @Override\r\n        public boolean getDefaultFormProcessing() {\r\n            return false;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.geoserver.web.data.resource.BasicResourceConfig.computeBoundsFromSRS",
	"Comment": "compute the native bounds from the native crs. acts as an alternative to computing the boundsfrom the data itself.",
	"Method": "AjaxSubmitLink computeBoundsFromSRS(Form<ResourceInfo> refForm,EnvelopePanel nativeBoundsPanel){\r\n    LOGGER.log(Level.FINE, \"Computing bounds from native CRS\");\r\n    ResourceInfo resource = (ResourceInfo) BasicResourceConfig.this.getDefaultModelObject();\r\n    CatalogBuilder cb = new CatalogBuilder(GeoServerApplication.get().getCatalog());\r\n    ReferencedEnvelope nativeBBox = cb.getBoundsFromCRS(resource);\r\n    if (nativeBBox != null) {\r\n        nativeBoundsPanel.setModelObject(nativeBBox);\r\n    }\r\n    target.add(nativeBoundsPanel);\r\n}"
}, {
	"Path": "org.geoserver.web.data.resource.BasicResourceConfig.computeBoundsFromSRS",
	"Comment": "compute the native bounds from the native crs. acts as an alternative to computing the boundsfrom the data itself.",
	"Method": "AjaxSubmitLink computeBoundsFromSRS(Form<ResourceInfo> refForm,EnvelopePanel nativeBoundsPanel){\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.catalog.ValidationResult.getErrosAsString",
	"Comment": "concatenates all the messages of the exceptions associated to this validation results usingthe provided separator.",
	"Method": "String getErrosAsString(String separator){\r\n    return errorList.stream().map(RuntimeException::getMessage).collect(Collectors.joining(separator));\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.ModificationProxy.shouldProxyProperty",
	"Comment": "helper method for determining if a property of a proxied object should also be proxied.",
	"Method": "boolean shouldProxyProperty(Class propertyType){\r\n    if (Catalog.class.isAssignableFrom(propertyType)) {\r\n        return false;\r\n    }\r\n    return Info.class.isAssignableFrom(propertyType);\r\n}"
}, {
	"Path": "org.geoserver.catalog.ResourcePool.create",
	"Comment": "creates a new instance of the resource pool explicitly supplying the application context.",
	"Method": "ResourcePool create(Catalog catalog,ApplicationContext appContext,ResourcePool create,Catalog catalog){\r\n    return create(catalog, null);\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.LayerGroupInfoImpl.setKeywords",
	"Comment": "set the keywords of this layer group. the provided keywords will override any existingkeywords no merge will be done.",
	"Method": "void setKeywords(List<KeywordInfo> keywords){\r\n    this.keywords = keywords == null ? new ArrayList() : keywords;\r\n}"
}, {
	"Path": "org.vfny.geoserver.util.ResponseUtils.proxifyLink",
	"Comment": "profixies a link url interpreting a localhost url as a back reference to the server.",
	"Method": "String proxifyLink(String content,String baseURL){\r\n    try {\r\n        URI uri = new URI(content);\r\n        try {\r\n            if (uri.getHost() == null) {\r\n                Map<String, String> kvp = null;\r\n                if (uri.getQuery() != null && !\"\".equals(uri.getQuery())) {\r\n                    Map<String, Object> parsed = KvpUtils.parseQueryString(\"?\" + uri.getQuery());\r\n                    kvp = new HashMap<String, String>();\r\n                    for (Entry<String, Object> entry : parsed.entrySet()) {\r\n                        kvp.put(entry.getKey(), (String) entry.getValue());\r\n                    }\r\n                }\r\n                content = buildURL(baseURL, uri.getPath(), kvp, URLType.RESOURCE);\r\n            }\r\n        } catch (Exception e) {\r\n            LOGGER.log(Level.WARNING, \"Unable to create proper back reference for url: \" + content, e);\r\n        }\r\n    } catch (URISyntaxException e) {\r\n    }\r\n    return content;\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.encodeProperties",
	"Comment": "encode a feature properties. geometry attribute will be ignored.",
	"Method": "void encodeProperties(Property geometryAttribute,PropertyType parentType,Collection<Property> properties){\r\n    Map<PropertyType, List<Property>> index = indexPropertiesByType(geometryAttribute, properties);\r\n    for (Map.Entry<PropertyType, List<Property>> entry : index.entrySet()) {\r\n        encodePropertiesByType(parentType, entry.getKey(), entry.getValue());\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.community.css.web.StyleEditCssRecoveryTest.testIgnoreCssStyleIfSLDWasEdited",
	"Comment": "test that the recovery code does not overwrite generated sld styles if they were subsequentlyedited.",
	"Method": "void testIgnoreCssStyleIfSLDWasEdited(){\r\n    StyleInfo styleInfo = catalog.getStyleByName(oldCssStyleWithSLDManuallyEdited);\r\n    StyleEditPage edit = new StyleEditPage(styleInfo);\r\n    tester.startPage(edit);\r\n    tester.assertRenderedPage(StyleEditPage.class);\r\n    tester.assertNoErrorMessage();\r\n    tester.assertModelValue(\"styleForm:context:panel:format\", \"sld\");\r\n    String editorContents = (String) tester.getComponentFromLastRenderedPage(\"styleForm:styleEditor:editorContainer:editorParent:editor\").getDefaultModelObject();\r\n    Styles.handler(\"sld\").parse(editorContents, null, null, null);\r\n    StyleInfo si = catalog.getStyleByName(oldCssStyleWithSLDManuallyEdited);\r\n    assertEquals(\"sld\", si.getFormat());\r\n    assertEquals(oldCssStyleWithSLDManuallyEdited + \".sld\", si.getFilename());\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.GeorectifyCoverage.invertQuery",
	"Comment": "given a target query and a target grid geometry returns the query to be used to read theinput data of the process involved in rendering. this method will be called only if the inputdata is a feature collection.",
	"Method": "Query invertQuery(Query targetQuery,GridGeometry gridGeometry){\r\n    return targetQuery;\r\n}"
}, {
	"Path": "org.geoserver.qos.util.XstreamQosFactory.getInstance",
	"Comment": "creates a securexstream instance with all qos classes allowed",
	"Method": "XStream getInstance(){\r\n    XStream xstream = new SecureXStream();\r\n    QosXstreamAliasConfigurator.instance().configure(xstream);\r\n    return xstream;\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.dxf.Rel14DXFWriter.writeAttributeDefinitionBlocks",
	"Comment": "writes all the given attribute definition blocks to be used for later insert entities",
	"Method": "void writeAttributeDefinitionBlocks(List<FeatureCollection> featureList){\r\n    LOGGER.warning(\"Rel14DXFWriter.writeAttributeDefinitionBlocks\");\r\n    for (FeatureCollection coll : featureList) {\r\n        String fid = coll.hashCode() + \"\";\r\n        if (blockNames.containsKey(coll.hashCode() + \"\")) {\r\n            String ownerHandle = blockHandles.get(coll.hashCode() + \"\");\r\n            String name = blockNames.get(coll.hashCode() + \"\");\r\n            String startHandle = getNewHandle(\"Block\");\r\n            String endHandle = getNewHandle(\"Block\");\r\n            writeStartBlock(startHandle, ownerHandle, false, \"0\", name);\r\n            String attributesLayer = getLayerName(coll) + \"_attributes\";\r\n            writeGeometryStart(\"POINT\", attributesLayer, ownerHandle);\r\n            writeSubClass(\"AcDbPoint\");\r\n            writePoint(0.0, 0.0, 0.0);\r\n            writeAttributeDefinitions(attributesLayer, ownerHandle, coll);\r\n            writeEndBlock(endHandle, ownerHandle, false, \"0\", name);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.sextante.SextanteProcessFactory.getAdditionalInfoMap",
	"Comment": "returns a map with additional info about a given parameter. it takes a sextante parameter andproduces a map suitable to be added to a geotools parameter",
	"Method": "Map getAdditionalInfoMap(es.unex.sextante.parameters.Parameter param){\r\n    HashMap map = new HashMap();\r\n    AdditionalInfo ai;\r\n    try {\r\n        ai = param.getParameterAdditionalInfo();\r\n    } catch (NullParameterAdditionalInfoException e) {\r\n        return map;\r\n    }\r\n    if (param instanceof ParameterRasterLayer) {\r\n        AdditionalInfoRasterLayer airl = (AdditionalInfoRasterLayer) ai;\r\n        map.put(PARAMETER_MANDATORY, airl.getIsMandatory());\r\n    }\r\n    if (param instanceof ParameterVectorLayer) {\r\n        AdditionalInfoVectorLayer aivl = (AdditionalInfoVectorLayer) ai;\r\n        map.put(PARAMETER_MANDATORY, aivl.getIsMandatory());\r\n        map.put(SHAPE_TYPE, aivl.getShapeType());\r\n    }\r\n    if (param instanceof ParameterVectorLayer) {\r\n        AdditionalInfoVectorLayer aiv = (AdditionalInfoVectorLayer) ai;\r\n        map.put(PARAMETER_MANDATORY, aiv.getIsMandatory());\r\n    }\r\n    if (param instanceof ParameterString) {\r\n        AdditionalInfoString ais = (AdditionalInfoString) ai;\r\n        map.put(DEFAULT_STRING_VALUE, ais.getDefaultString());\r\n    }\r\n    if (param instanceof ParameterNumericalValue) {\r\n        AdditionalInfoNumericalValue ainv = (AdditionalInfoNumericalValue) ai;\r\n        map.put(DEFAULT_NUMERICAL_VALUE, ainv.getDefaultValue());\r\n        map.put(MAX_NUMERICAL_VALUE, ainv.getMaxValue());\r\n        map.put(MIN_NUMERICAL_VALUE, ainv.getMinValue());\r\n        map.put(NUMERICAL_VALUE_TYPE, ainv.getType());\r\n    }\r\n    if (param instanceof ParameterBoolean) {\r\n        AdditionalInfoBoolean aib = (AdditionalInfoBoolean) ai;\r\n        map.put(DEFAULT_BOOLEAN_VALUE, aib.getDefaultValue());\r\n    }\r\n    if (param instanceof ParameterMultipleInput) {\r\n        AdditionalInfoMultipleInput aimi = (AdditionalInfoMultipleInput) ai;\r\n        map.put(MULTIPLE_INPUT_TYPE, aimi.getDataType());\r\n        map.put(PARAMETER_MANDATORY, aimi.getIsMandatory());\r\n    }\r\n    if (param instanceof ParameterFixedTable) {\r\n        AdditionalInfoFixedTable aift = (AdditionalInfoFixedTable) ai;\r\n        map.put(FIXED_TABLE_NUM_COLS, aift.getColsCount());\r\n        map.put(FIXED_TABLE_NUM_ROWS, aift.getRowsCount());\r\n        map.put(FIXED_TABLE_FIXED_NUM_ROWS, aift.isNumberOfRowsFixed());\r\n    }\r\n    if (param instanceof ParameterTableField) {\r\n        AdditionalInfoTableField aitf = (AdditionalInfoTableField) ai;\r\n        map.put(PARENT_PARAMETER_NAME, aitf.getParentParameterName());\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "org.geoserver.wfs.v2_0.SrsNameRequestTest.testHttpUrl",
	"Comment": "test response numberreturned, feature identity, srsname, and axis order for a request with anogc http url srsname.",
	"Method": "void testHttpUrl(){\r\n    runTest(HTTP_URL_SRSNAME, null, 5, HTTP_URL_SRSNAME, LON_LAT_DATA);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.assertStatusCodeForGet",
	"Comment": "assert that a get request to a path will have a particular status code for the response.",
	"Method": "void assertStatusCodeForGet(int code,String path){\r\n    assertStatusCodeForRequest(code, \"GET\", path, \"\", \"\");\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.checkValidationErrors",
	"Comment": "given a dom and a schema, checks that the dom validates against the schema of the validationerrors instead",
	"Method": "void checkValidationErrors(Document dom,Schema schema){\r\n    final Validator validator = schema.newValidator();\r\n    final List<Exception> validationErrors = new ArrayList<Exception>();\r\n    validator.setErrorHandler(new ErrorHandler() {\r\n        public void warning(SAXParseException exception) throws SAXException {\r\n            System.out.println(exception.getMessage());\r\n        }\r\n        public void fatalError(SAXParseException exception) throws SAXException {\r\n            validationErrors.add(exception);\r\n        }\r\n        public void error(SAXParseException exception) throws SAXException {\r\n            validationErrors.add(exception);\r\n        }\r\n    });\r\n    validator.validate(new DOMSource(dom));\r\n    if (validationErrors != null && validationErrors.size() > 0) {\r\n        StringBuilder sb = new StringBuilder();\r\n        for (Exception ve : validationErrors) {\r\n            sb.append(ve.getMessage()).append(\"\\n\");\r\n        }\r\n        fail(sb.toString());\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.checkValidationErrors",
	"Comment": "given a dom and a schema, checks that the dom validates against the schema of the validationerrors instead",
	"Method": "void checkValidationErrors(Document dom,Schema schema){\r\n    System.out.println(exception.getMessage());\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.checkValidationErrors",
	"Comment": "given a dom and a schema, checks that the dom validates against the schema of the validationerrors instead",
	"Method": "void checkValidationErrors(Document dom,Schema schema){\r\n    validationErrors.add(exception);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.checkValidationErrors",
	"Comment": "given a dom and a schema, checks that the dom validates against the schema of the validationerrors instead",
	"Method": "void checkValidationErrors(Document dom,Schema schema){\r\n    validationErrors.add(exception);\r\n}"
}, {
	"Path": "org.geoserver.wfs.v2_0.SrsNameRequestTest.testHttpUri",
	"Comment": "test response numberreturned, feature identity, srsname, and axis order for a request with anogc http uri srsname.",
	"Method": "void testHttpUri(){\r\n    runTest(HTTP_URI_SRSNAME, null, 5, URN_SRSNAME, LAT_LON_DATA);\r\n}"
}, {
	"Path": "org.geoserver.sldservice.utils.classifier.RulesBuilder.lineStyle",
	"Comment": "generate line symbolyzer for each rule in list stroke color is choose from rampcolor",
	"Method": "void lineStyle(List<Rule> rules,ColorRamp fillRamp,boolean reverseColors){\r\n    Iterator<Rule> it;\r\n    Rule rule;\r\n    Iterator<Color> colors;\r\n    Color color;\r\n    try {\r\n        fillRamp.setNumClasses(rules.size());\r\n        if (reverseColors) {\r\n            fillRamp.revert();\r\n        }\r\n        colors = fillRamp.getRamp().iterator();\r\n        it = rules.iterator();\r\n        while (it.hasNext() && colors.hasNext()) {\r\n            color = colors.next();\r\n            rule = it.next();\r\n            rule.setSymbolizers(new Symbolizer[] { sb.createLineSymbolizer(color) });\r\n        }\r\n    } catch (Exception e) {\r\n        if (LOGGER.isLoggable(Level.INFO))\r\n            LOGGER.log(Level.INFO, \"Failed to build Line Symbolizer\" + e.getLocalizedMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.ResourcePool.handleDescriptor",
	"Comment": "helper method which overrides geometric attributes based on the reprojection policy.",
	"Method": "AttributeDescriptor handleDescriptor(AttributeDescriptor ad,FeatureTypeInfo info){\r\n    if (ad instanceof GeometryDescriptor) {\r\n        GeometryDescriptor old = (GeometryDescriptor) ad;\r\n        try {\r\n            boolean rebuild = false;\r\n            if (old.getCoordinateReferenceSystem() == null) {\r\n                if (info.getProjectionPolicy() != ProjectionPolicy.FORCE_DECLARED) {\r\n                    if (Proxy.isProxyClass(info.getClass())) {\r\n                        FeatureTypeInfo inner = ModificationProxy.unwrap(info);\r\n                        inner.setProjectionPolicy(ProjectionPolicy.FORCE_DECLARED);\r\n                    } else {\r\n                        info.setProjectionPolicy(ProjectionPolicy.FORCE_DECLARED);\r\n                    }\r\n                }\r\n                rebuild = true;\r\n            } else {\r\n                ProjectionPolicy projPolicy = info.getProjectionPolicy();\r\n                if (projPolicy == ProjectionPolicy.REPROJECT_TO_DECLARED || projPolicy == ProjectionPolicy.FORCE_DECLARED) {\r\n                    rebuild = true;\r\n                }\r\n            }\r\n            if (rebuild) {\r\n                AttributeTypeBuilder b = new AttributeTypeBuilder();\r\n                b.init(old);\r\n                b.setCRS(getCRS(info.getSRS()));\r\n                ad = b.buildDescriptor(old.getLocalName());\r\n            }\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return ad;\r\n}"
}, {
	"Path": "org.geoserver.catalog.CoverageDimensionCustomizerReaderTest.testIntegerNoDataCategoryWrapping",
	"Comment": "test that the wrapped nodata categories contains the defined nodata as an int",
	"Method": "void testIntegerNoDataCategoryWrapping(){\r\n    final CoverageDimensionImpl coverageDim = new CoverageDimensionImpl();\r\n    final String wrappedName = \"wrapped\";\r\n    coverageDim.setName(wrappedName);\r\n    coverageDim.setDimensionType(SampleDimensionType.SIGNED_16BITS);\r\n    coverageDim.setRange(NumberRange.create(0d, 10000d));\r\n    final List<Double> nullValues = new ArrayList<Double>();\r\n    final double noData1 = -32768d;\r\n    nullValues.add(noData1);\r\n    coverageDim.setNullValues(nullValues);\r\n    GridSampleDimension sampleDim = new GridSampleDimension(\"original\", new Category[] { new Category(Vocabulary.formatInternational(VocabularyKeys.NODATA), new Color[] { new Color(0, 0, 0, 0) }, NumberRange.create(-9999, -9999)) }, null);\r\n    GridSampleDimension copy = WrappedSampleDimension.build(sampleDim, coverageDim);\r\n    List<Category> categories = copy.getCategories();\r\n    Category category = categories.get(0);\r\n    assertTrue(category.getName().equals(Category.NODATA.getName()));\r\n    assertEquals(category.getRange().getMinimum(), noData1, DELTA);\r\n    assertEquals(category.getRange().getMaximum(), noData1, DELTA);\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.loadAuthenticationProvider",
	"Comment": "loads an authentication provider from a named configuration.",
	"Method": "GeoServerAuthenticationProvider loadAuthenticationProvider(String name){\r\n    return authProviderHelper.load(name);\r\n}"
}, {
	"Path": "org.geoserver.test.FeatureChainingWfsTest.testEncodeFeatureMember",
	"Comment": "test featurecollection is encoded with multiple featuremember elements",
	"Method": "void testEncodeFeatureMember(){\r\n    WFSInfo wfs = getGeoServer().getService(WFSInfo.class);\r\n    boolean encodeFeatureMember = wfs.isEncodeFeatureMember();\r\n    wfs.setEncodeFeatureMember(true);\r\n    getGeoServer().save(wfs);\r\n    Document doc = getAsDOM(\"wfs?request=GetFeature&version=1.1.0&typename=gsml:MappedFeature,gsml:GeologicUnit\");\r\n    LOGGER.info(\"WFS GetFeature&typename=gsml:MappedFeature,gsml:GeologicUnit response:\\n\" + prettyString(doc));\r\n    checkSchemaLocation(doc);\r\n    assertXpathEvaluatesTo(\"7\", \"/wfs:FeatureCollection/@numberOfFeatures\", doc);\r\n    assertXpathCount(4, \"//gsml:MappedFeature\", doc);\r\n    assertEquals(7, doc.getElementsByTagName(\"gml:featureMember\").getLength());\r\n    assertEquals(0, doc.getElementsByTagName(\"gml:featureMembers\").getLength());\r\n    {\r\n        String id = \"mf1\";\r\n        checkMf1Content(id, doc);\r\n    }\r\n    {\r\n        String id = \"mf2\";\r\n        checkMf2Content(id, doc);\r\n    }\r\n    {\r\n        String id = \"mf3\";\r\n        checkMf3Content(id, doc);\r\n    }\r\n    {\r\n        String id = \"mf4\";\r\n        checkMf4Content(id, doc);\r\n    }\r\n    assertXpathCount(1, \"//gsml:GeologicUnit[@gml:id='gu.25699']\", doc);\r\n    assertXpathCount(1, \"//gsml:GeologicUnit[@gml:id='gu.25678']\", doc);\r\n    assertXpathCount(1, \"//gsml:GeologicUnit[@gml:id='gu.25682']\", doc);\r\n    assertXpathCount(1, \"//gml:featureMember[@xlink:href='#gu.25699']\", doc);\r\n    assertXpathCount(1, \"//gml:featureMember[@xlink:href='#gu.25678']\", doc);\r\n    assertXpathCount(1, \"//gml:featureMember[@xlink:href='#gu.25682']\", doc);\r\n    wfs = getGeoServer().getService(WFSInfo.class);\r\n    wfs.setEncodeFeatureMember(encodeFeatureMember);\r\n    getGeoServer().save(wfs);\r\n}"
}, {
	"Path": "org.geoserver.catalog.IsolatedWorkspacesTest.executeAndValidateException",
	"Comment": "helper method that executes a statement where an exception of a certain type is expected tohappen. this method will check hat the obtained exception contains the expected message andis an instance expected type.",
	"Method": "void executeAndValidateException(Statement statement,Class<?> expectedException,String expectedMessage){\r\n    boolean exceptionHappen = false;\r\n    try {\r\n        statement.execute();\r\n    } catch (Exception exception) {\r\n        assertThat(exception, instanceOf(expectedException));\r\n        assertThat(exception.getMessage(), Matchers.containsString(expectedMessage));\r\n        exceptionHappen = true;\r\n    }\r\n    assertThat(exceptionHappen, is(true));\r\n}"
}, {
	"Path": "org.geoserver.security.password.MasterPasswordProviderConfig.isReadOnly",
	"Comment": "flag determining if the url is read only and may not be written back to.",
	"Method": "boolean isReadOnly(){\r\n    return readOnly;\r\n}"
}, {
	"Path": "org.geoserver.test.MappingNameTest.testGetFeature",
	"Comment": "test whether getfeature returns a featurecollection with the right content based on thefeature chaining.",
	"Method": "void testGetFeature(){\r\n    Document doc = getAsDOM(\"wfs?request=GetFeature&version=1.1.0&typeName=gsml:MappedFeature\");\r\n    LOGGER.info(\"WFS GetFeature response:\\n\" + prettyString(doc));\r\n    assertXpathCount(1, \"//wfs:FeatureCollection\", doc);\r\n    assertXpathEvaluatesTo(\"4\", \"/wfs:FeatureCollection/@numberOfFeatures\", doc);\r\n    assertXpathCount(4, \"//gsml:MappedFeature\", doc);\r\n    assertXpathEvaluatesTo(\"value01\", \"/wfs:FeatureCollection/gml:featureMember/gsml:MappedFeature[@gml:id='gsml.mappedfeature.mf1']/gsml:observationMethod/gsml:CGI_TermValue/gsml:value[@codeSpace='codespace01']\", doc);\r\n    assertXpathEvaluatesTo(\"value02\", \"/wfs:FeatureCollection/gml:featureMember//gsml:MappedFeature[@gml:id='gsml.mappedfeature.mf1']/gsml:observationMethod/gsml:CGI_TermValue/gsml:value[@codeSpace='codespace02']\", doc);\r\n    assertXpathEvaluatesTo(\"value02\", \"/wfs:FeatureCollection/gml:featureMember//gsml:MappedFeature[@gml:id='gsml.mappedfeature.mf1']/gsml:observationMethod/gsml:CGI_TermValue/gsml:value[@codeSpace='codespace02']\", doc);\r\n    assertXpathEvaluatesTo(\"value03\", \"/wfs:FeatureCollection/gml:featureMember//gsml:MappedFeature[@gml:id='gsml.mappedfeature.mf2']/gsml:observationMethod/gsml:CGI_TermValue/gsml:value[@codeSpace='codespace03']\", doc);\r\n}"
}, {
	"Path": "org.geoserver.wfs.xslt.config.FileItemCache.getFileKey",
	"Comment": "the key used in the item cache to represent this file. it uses the file name, assuming we aregoing to cache files originating from the same directory. subclasses may override to get adifferent behavior",
	"Method": "String getFileKey(Resource file){\r\n    return file.name();\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.Ogr2OgrConfigurator.buildXStream",
	"Comment": "ensures compatibility with old style configuration files.",
	"Method": "XStream buildXStream(){\r\n    XStream xstream = super.buildXStream();\r\n    xstream.alias(\"OgrConfiguration\", OgrConfiguration.class);\r\n    xstream.alias(\"Format\", OgrFormat.class);\r\n    xstream.allowTypes(new Class[] { OgrConfiguration.class, OgrFormat.class });\r\n    return xstream;\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.LocalWorkspaceCatalogTest.testGetNoGeoserverLocalWorkspacePrefixedLayerNameBehaviour",
	"Comment": "no local workspace is set this means the prefix should be included since the globalcapabilities is probably being created.the no geoserver part is just to verify there are no nullpointer exceptions because of acoding error",
	"Method": "void testGetNoGeoserverLocalWorkspacePrefixedLayerNameBehaviour(){\r\n    boolean includePrefix = true;\r\n    boolean setLocalWorkspace = false;\r\n    boolean createGeoServer = false;\r\n    assertPrefixInclusion(includePrefix, setLocalWorkspace, createGeoServer);\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.GetCoverage.extractSubsettingCRS",
	"Comment": "this method is responsible for extracting the subsettingcrs.in case it is not provided the subsettingcrs falls back on the nativecrs.",
	"Method": "CoordinateReferenceSystem extractSubsettingCRS(GridCoverage2DReader reader,Map<String, ExtensionItemType> extensions){\r\n    Utilities.ensureNonNull(\"reader\", reader);\r\n    return extractCRSInternal(extensions, reader.getCoordinateReferenceSystem(), false);\r\n}"
}, {
	"Path": "org.geoserver.wfs.WFSDescribeFeatureTypeOutputFormat.canHandle",
	"Comment": "ensures that the operation being executed is a describefeaturetype operation.this method may be extended to add additional checks, it should not be overriden.",
	"Method": "boolean canHandle(Operation operation){\r\n    if (\"DescribeFeatureType\".equalsIgnoreCase(operation.getId())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.wfs.v2_0.SrsNameRequestTest.testEpsgCode",
	"Comment": "test response numberreturned, feature identity, srsname, and axis order for a request with anepsg code srsname.",
	"Method": "void testEpsgCode(){\r\n    runTest(EPSG_CODE_SRSNAME, null, 5, HTTP_URL_SRSNAME, LON_LAT_DATA);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.getFilters",
	"Comment": "subclasses needed to do integration tests with servlet filters can override this method andreturn the list of filters to be used during mocked requests",
	"Method": "List<Filter> getFilters(){\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.assertStatusCodeForGet",
	"Comment": "assert that a get request to a path will have a particular status code for the response.",
	"Method": "void assertStatusCodeForGet(int code,String path){\r\n    assertStatusCodeForRequest(code, \"GET\", path, \"\", \"\");\r\n}"
}, {
	"Path": "org.geoserver.util.ReaderUtils.getFirstChildElement",
	"Comment": "getfirstchildelement purpose.used to help with xml manipulations. returns the element which represents the first child.",
	"Method": "Element getFirstChildElement(Element root){\r\n    Node child = root.getFirstChild();\r\n    while (child != null) {\r\n        if (child.getNodeType() == Node.ELEMENT_NODE) {\r\n            return (Element) child;\r\n        }\r\n        child = child.getNextSibling();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.ows.Request.getSOAPNamespace",
	"Comment": "returns the soap namespace used in the request, or null if the request was not a soap one",
	"Method": "String getSOAPNamespace(){\r\n    return soapNamespace;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findStoreDir",
	"Comment": "returns the directory in which a stores configuration is persisted, if the directory does notexists null is returned.",
	"Method": "File findStoreDir(StoreInfo store){\r\n    Resource directory = get(store);\r\n    return Resources.directory(directory);\r\n}"
}, {
	"Path": "org.geoserver.wps.web.ProcessLimitsPage.buildInputLimits",
	"Comment": "go from the available process validator to a ui representation, adding also the possiblevalidators that are not yet set",
	"Method": "List<InputLimit> buildInputLimits(FilteredProcess process){\r\n    ApplicationContext applicationContext = GeoServerApplication.get().getApplicationContext();\r\n    Multimap<String, WPSInputValidator> validators = process.getValidators();\r\n    ProcessFactory pf = GeoServerProcessors.createProcessFactory(process.getName(), false);\r\n    Map<String, Parameter<?>> parameters = pf.getParameterInfo(process.getName());\r\n    List<InputLimit> result = new ArrayList();\r\n    for (Parameter param : parameters.values()) {\r\n        String name = param.getName();\r\n        Collection<WPSInputValidator> paramValidators = validators != null ? validators.get(name) : null;\r\n        Set<Class> validatorTypes = new HashSet();\r\n        if (paramValidators != null) {\r\n            for (WPSInputValidator validator : paramValidators) {\r\n                validatorTypes.add(validator.getClass());\r\n                result.add(new InputLimit(name, validator.copy()));\r\n            }\r\n        }\r\n        if (param.getMaxOccurs() > 1 && !validatorTypes.contains(MultiplicityValidator.class)) {\r\n            int max = 0;\r\n            if (param.getMaxOccurs() < Integer.MAX_VALUE) {\r\n                max = param.getMaxOccurs();\r\n            }\r\n            result.add(new InputLimit(name, new MultiplicityValidator(max)));\r\n        }\r\n        boolean isComplex = ProcessParameterIO.isComplex(param, applicationContext);\r\n        if (isComplex) {\r\n            if (!validatorTypes.contains(MaxSizeValidator.class)) {\r\n                result.add(new InputLimit(name, new MaxSizeValidator(0)));\r\n            }\r\n        } else {\r\n            if (isNumeric(param) && !validatorTypes.contains(NumberRangeValidator.class)) {\r\n                result.add(new InputLimit(name, new NumberRangeValidator(null)));\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.kml.KmlEncodingContext.getKmzGroundOverlays",
	"Comment": "returns the list of ground overlay layers to be included in the kmz response",
	"Method": "Map<String, Layer> getKmzGroundOverlays(){\r\n    return kmzGroundOverlays;\r\n}"
}, {
	"Path": "org.geoserver.security.impl.EditableUserDAO.makeUser",
	"Comment": "convenience method for creating users from a userattribute and a username.",
	"Method": "UserDetails makeUser(String username,UserAttribute attrs){\r\n    return new // account not expired\r\n    User(// account not expired\r\n    username, // account not expired\r\n    attrs.getPassword(), attrs.isEnabled(), true, true, true, attrs.getAuthorities());\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.LDAPAuthenticationProviderTest.testBindBeforeGroupSearch",
	"Comment": "ldaptestutils test that bindbeforegroupsearch correctly enables roles fetching on a serverwithout anonymous access enabled.",
	"Method": "void testBindBeforeGroupSearch(){\r\n    Assume.assumeTrue(LDAPTestUtils.initLdapServer(false, ldapServerUrl, basePath));\r\n    ((LDAPSecurityServiceConfig) config).setUserDnPattern(\"uid={0},ou=People\");\r\n    config.setBindBeforeGroupSearch(true);\r\n    createAuthenticationProvider();\r\n    Authentication result = authProvider.authenticate(authentication);\r\n    assertNotNull(result);\r\n    assertEquals(\"admin\", result.getName());\r\n    assertEquals(3, result.getAuthorities().size());\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.WCSNetCDFTest.testRapNativeGribRotatedPole",
	"Comment": "test netcdf output from an rap native grib2 file with a gds template 32769 rotated poleprojection.",
	"Method": "void testRapNativeGribRotatedPole(){\r\n    MockHttpServletResponse response = getAsServletResponse(\"ows?request=GetCoverage&service=WCS&version=2.0.1\" + \"&coverageid=wcs__Temperature_surface&format=application/x-netcdf\");\r\n    assertEquals(200, response.getStatus());\r\n    assertEquals(\"application/x-netcdf\", response.getContentType());\r\n    byte[] responseBytes = getBinary(response);\r\n    File file = File.createTempFile(\"rap-native-grib-rotated-pole-\", \"-wcs__Temperature_surface.nc\", new File(\"./target\"));\r\n    FileUtils.writeByteArrayToFile(file, responseBytes);\r\n    try (NetcdfDataset dataset = NetcdfDataset.openDataset(file.getAbsolutePath())) {\r\n        assertNotNull(dataset);\r\n        Dimension rlonDim = dataset.findDimension(\"rlon\");\r\n        assertNotNull(rlonDim);\r\n        assertEquals(7, rlonDim.getLength());\r\n        Dimension rlatDim = dataset.findDimension(\"rlat\");\r\n        assertNotNull(rlatDim);\r\n        assertEquals(5, rlatDim.getLength());\r\n        Variable rlonVar = dataset.findVariable(\"rlon\");\r\n        assertNotNull(rlonVar);\r\n        assertEquals(1, rlonVar.getDimensions().size());\r\n        assertEquals(rlonDim, rlonVar.getDimensions().get(0));\r\n        assertEquals(\"grid_longitude\", rlonVar.findAttribute(\"long_name\").getStringValue());\r\n        assertEquals(\"grid_longitude\", rlonVar.findAttribute(\"standard_name\").getStringValue());\r\n        assertEquals(\"degrees\", rlonVar.findAttribute(\"units\").getStringValue());\r\n        assertArrayEquals(new float[] { -30, -20, -10, 0, 10, 20, 30 }, (float[]) rlonVar.read().copyTo1DJavaArray(), (float) DELTA);\r\n        Variable rlatVar = dataset.findVariable(\"rlat\");\r\n        assertNotNull(rlatVar);\r\n        assertEquals(1, rlatVar.getDimensions().size());\r\n        assertEquals(rlatDim, rlatVar.getDimensions().get(0));\r\n        assertEquals(\"grid_latitude\", rlatVar.findAttribute(\"long_name\").getStringValue());\r\n        assertEquals(\"grid_latitude\", rlatVar.findAttribute(\"standard_name\").getStringValue());\r\n        assertEquals(\"degrees\", rlatVar.findAttribute(\"units\").getStringValue());\r\n        assertArrayEquals(new float[] { -20, -10, 0, 10, 20 }, (float[]) rlatVar.read().copyTo1DJavaArray(), (float) DELTA);\r\n        Variable projVar = dataset.findVariable(\"rotated_latitude_longitude\");\r\n        assertNotNull(projVar);\r\n        assertEquals(\"rotated_latitude_longitude\", projVar.findAttribute(\"grid_mapping_name\").getStringValue());\r\n        assertEquals(74.0, projVar.findAttribute(\"grid_north_pole_longitude\").getNumericValue().doubleValue(), DELTA);\r\n        assertEquals(36.0, projVar.findAttribute(\"grid_north_pole_latitude\").getNumericValue().doubleValue(), DELTA);\r\n        Variable dataVar = dataset.findVariable(\"Temperature_surface\");\r\n        assertNotNull(dataVar);\r\n        assertEquals(\"rotated_latitude_longitude\", dataVar.findAttribute(\"grid_mapping\").getStringValue());\r\n        assertEquals(\"K\", dataVar.findAttribute(\"units\").getStringValue());\r\n        assertEquals(2, dataVar.getDimensions().size());\r\n        assertEquals(rlatDim, dataVar.getDimensions().get(0));\r\n        assertEquals(rlonDim, dataVar.getDimensions().get(1));\r\n        assertArrayEquals(new float[] { 300, 299, 298, 297, 296, 295, 294, 299, 300, 299, 298, 297, 296, 295, 298, 299, 300, 299, 298, 297, 296, 297, 298, 299, 300, 299, 298, 297, 296, 297, 298, 299, 300, 299, 298 }, (float[]) dataVar.read().copyTo1DJavaArray(), (float) DELTA);\r\n    } finally {\r\n        FileUtils.deleteQuietly(file);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTestsUtils.resetJmsConfiguration",
	"Comment": "helper method that just reset the jms configuration of the provided geoserve instances.",
	"Method": "void resetJmsConfiguration(GeoServerInstance instances){\r\n    Arrays.stream(instances).forEach(GeoServerInstance::setJmsDefaultConfiguration);\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaTestSupport.evaluate",
	"Comment": "return the flattened value corresponding to an xpath expression from a document.",
	"Method": "String evaluate(String xpath,Document document){\r\n    try {\r\n        return getXpathEngine().evaluate(xpath, document);\r\n    } catch (XpathException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerApplication.servletRequest",
	"Comment": "convenience method to get the underlying servlet request backing the current wicket request.",
	"Method": "HttpServletRequest servletRequest(HttpServletRequest servletRequest,Request req){\r\n    if (req == null || !(req instanceof ServletWebRequest)) {\r\n        throw new IllegalStateException(\"Request not of type ServletWebRequest, was: \" + req.getClass().getName());\r\n    }\r\n    return ((ServletWebRequest) req).getContainerRequest();\r\n}"
}, {
	"Path": "org.geoserver.util.XmlTestUtil.setShowXML",
	"Comment": "set an output stream to print xml to when a matcher fails. null to disable.",
	"Method": "void setShowXML(OutputStream showXML){\r\n    this.showXML = showXML;\r\n}"
}, {
	"Path": "org.geoserver.ows.LocalWorkspaceCatalogFilter.subLayersHidden",
	"Comment": "returns true if the sublayers of a layer group are all hidden.",
	"Method": "boolean subLayersHidden(LayerGroupInfo layerGroup){\r\n    boolean anySublayersVisible = false;\r\n    for (PublishedInfo subLayer : layerGroup.getLayers()) {\r\n        if (subLayer instanceof LayerInfo) {\r\n            if (!hideLayer((LayerInfo) subLayer)) {\r\n                anySublayersVisible = true;\r\n                break;\r\n            }\r\n            ;\r\n        } else if (subLayer instanceof LayerGroupInfo) {\r\n            if (!hideLayerGroup((LayerGroupInfo) subLayer)) {\r\n                anySublayersVisible = true;\r\n                break;\r\n            }\r\n            ;\r\n        }\r\n    }\r\n    return !anySublayersVisible;\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerNodeInfo.getId",
	"Comment": "the node id, displayed as a label in the gui. if null is returned, the element will behidden.",
	"Method": "String getId(){\r\n    return getData().getId();\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexIndexesTest.checkCount",
	"Comment": "helper method that checks if the provided xpath expression evaluated against the provided xmldocument yields the expected number of matches.",
	"Method": "void checkCount(XpathEngine xpathEngine,Document document,int expectedCount,String xpath){\r\n    try {\r\n        assertEquals(expectedCount, xpathEngine.getMatchingNodes(xpath, document).getLength());\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error evaluating xpath.\", exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.loadPasswordEncoder",
	"Comment": "loads the first password encoder that matches the specified criteria.",
	"Method": "GeoServerPasswordEncoder loadPasswordEncoder(String name,T loadPasswordEncoder,Class<T> filter,T loadPasswordEncoder,Class<T> filter,Boolean reversible,Boolean strong){\r\n    List<T> pw = loadPasswordEncoders(filter, reversible, strong);\r\n    return pw.isEmpty() ? null : pw.get(0);\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.DownloadServiceConfigurationWatcher.parseConfigurationValues",
	"Comment": "parses the properties file for the download process configuration. when it runs into problemsit uses default values",
	"Method": "DownloadServiceConfiguration parseConfigurationValues(Properties downloadProcessProperties){\r\n    Utilities.ensureNonNull(\"downloadProcessProperties\", downloadProcessProperties);\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.log(Level.FINE, \"Parsing the properties file\");\r\n    }\r\n    long maxFeatures = getLongValue(downloadProcessProperties, DownloadServiceConfiguration.MAX_FEATURES_NAME, DownloadServiceConfiguration.DEFAULT_MAX_FEATURES);\r\n    long rasterSizeLimits = getLongValue(downloadProcessProperties, DownloadServiceConfiguration.RASTER_SIZE_LIMITS_NAME, DownloadServiceConfiguration.DEFAULT_RASTER_SIZE_LIMITS);\r\n    long writeLimits = getLongValue(downloadProcessProperties, DownloadServiceConfiguration.WRITE_LIMITS_NAME, DownloadServiceConfiguration.DEFAULT_RASTER_SIZE_LIMITS);\r\n    long hardOutputLimit = getLongValue(downloadProcessProperties, \"hardOutputLimit\", DownloadServiceConfiguration.DEFAULT_WRITE_LIMITS);\r\n    int compressionLevel = getIntValue(downloadProcessProperties, \"compressionLevel\", DownloadServiceConfiguration.DEFAULT_COMPRESSION_LEVEL);\r\n    int maxFrames = getIntValue(downloadProcessProperties, DownloadServiceConfiguration.MAX_ANIMATION_FRAMES_NAME, DownloadServiceConfiguration.DEFAULT_MAX_ANIMATION_FRAMES);\r\n    return new DownloadServiceConfiguration(maxFeatures, rasterSizeLimits, writeLimits, hardOutputLimit, compressionLevel, maxFrames);\r\n}"
}, {
	"Path": "org.geoserver.web.data.resource.FeatureResourceConfigurationPanel.validateCqlFilter",
	"Comment": "validate that cql filter syntax is valid, and attribute names used in the cql filter are actually part of the layer",
	"Method": "void validateCqlFilter(FeatureTypeInfo typeInfo,String cqlFilterString){\r\n    Filter cqlFilter = null;\r\n    if (cqlFilterString != null && !cqlFilterString.isEmpty()) {\r\n        cqlFilter = ECQL.toFilter(cqlFilterString);\r\n        FeatureType ft = typeInfo.getFeatureType();\r\n        if (ft instanceof SimpleFeatureType) {\r\n            SimpleFeatureType sft = (SimpleFeatureType) ft;\r\n            BeanToPropertyValueTransformer transformer = new BeanToPropertyValueTransformer(\"localName\");\r\n            Collection<String> featureAttributesNames = CollectionUtils.collect(sft.getAttributeDescriptors(), transformer);\r\n            FilterAttributeExtractor filterAttriubtes = new FilterAttributeExtractor(null);\r\n            cqlFilter.accept(filterAttriubtes, null);\r\n            Set<String> filterAttributesNames = filterAttriubtes.getAttributeNameSet();\r\n            for (String filterAttributeName : filterAttributesNames) {\r\n                if (!featureAttributesNames.contains(filterAttributeName)) {\r\n                    throw new ResourceConfigurationException(ResourceConfigurationException.CQL_ATTRIBUTE_NAME_NOT_FOUND_$1, new Object[] { filterAttributeName });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.wicket.GeoServerTablePanel.hiddenSubmit",
	"Comment": "the hidden button that will submit the form when the user presses enter in the text field",
	"Method": "AjaxButton hiddenSubmit(){\r\n    return new AjaxButton(\"submit\") {\r\n        static final long serialVersionUID = 5334592790005438960L;\r\n        @Override\r\n        protected void onSubmit(AjaxRequestTarget target, Form<?> form) {\r\n            updateFilter(target, filter.getDefaultModelObjectAsString());\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.geoserver.web.wicket.GeoServerTablePanel.hiddenSubmit",
	"Comment": "the hidden button that will submit the form when the user presses enter in the text field",
	"Method": "AjaxButton hiddenSubmit(){\r\n    updateFilter(target, filter.getDefaultModelObjectAsString());\r\n}"
}, {
	"Path": "org.geoserver.platform.GeoServerExtensions.bean",
	"Comment": "loads a single bean by its type from the specified application context.this method returns null if there is no such bean. an exception is thrown if multiplebeans of the specified type exist.",
	"Method": "Object bean(String name,Object bean,String name,ApplicationContext context,T bean,Class<T> type,T bean,Class<T> type,ApplicationContext context){\r\n    List<T> beans = extensions(type, context);\r\n    if (beans.isEmpty()) {\r\n        return null;\r\n    }\r\n    if (beans.size() > 1) {\r\n        throw new MultipleBeansException(type, extensionNames(type, context));\r\n    }\r\n    return beans.get(0);\r\n}"
}, {
	"Path": "org.geoserver.test.PolymorphismWfsTest.testFirstValueFilters",
	"Comment": "test filtering polymorphism with feature chaining set up works. also tests filtering whenmappingname is used as linkelement.",
	"Method": "void testFirstValueFilters(){\r\n    String xml = \"<wfs:GetFeature \" + \"service=\\\"WFS\\\" \" + \"version=\\\"1.1.0\\\" \" + \"xmlns:cdf=\\\"http://www.opengis.net/cite/data\\\" \" + \"xmlns:ogc=\\\"http://www.opengis.net/ogc\\\" \" + \"xmlns:wfs=\\\"http://www.opengis.net/wfs\\\" \" + \"xmlns:gml=\\\"http://www.opengis.net/gml\\\" \" + \"xmlns:ex=\\\"http://example.com\\\" \" + \"xmlns:gsml=\\\"\" + AbstractAppSchemaMockData.GSML_URI + \"\\\" \" + \">\" + \"    <wfs:Query typeName=\\\"ex:PolymorphicFeature\\\">\" + \"        <ogc:Filter>\" + \"            <ogc:PropertyIsEqualTo>\" + \"                <ogc:PropertyName>ex:firstValue/gsml:CGI_NumericValue/gsml:principalValue<\/ogc:PropertyName>\" + \"                <ogc:Literal>1.0<\/ogc:Literal>\" + \"            <\/ogc:PropertyIsEqualTo>\" + \"        <\/ogc:Filter>\" + \"    <\/wfs:Query> \" + \"<\/wfs:GetFeature>\";\r\n    Document doc = postAsDOM(\"wfs\", xml);\r\n    LOGGER.info(\"WFS filter GetFeature response:\\n\" + prettyString(doc));\r\n    assertXpathEvaluatesTo(\"1\", \"/wfs:FeatureCollection/@numberOfFeatures\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature\", doc);\r\n    assertXpathEvaluatesTo(\"f1\", \"//ex:PolymorphicFeature/@gml:id\", doc);\r\n    assertXpathEvaluatesTo(\"1.0\", \"//ex:PolymorphicFeature[@gml:id='f1']/ex:firstValue/gsml:CGI_NumericValue/gsml:principalValue\", doc);\r\n    assertXpathEvaluatesTo(\"m\", \"//ex:PolymorphicFeature[@gml:id='f1']/ex:firstValue/gsml:CGI_NumericValue/gsml:principalValue/@uom\", doc);\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.IsolatedCatalogFacade.enforceStoreIsolation",
	"Comment": "checks if the provided store is visible in the current context.",
	"Method": "T enforceStoreIsolation(T store){\r\n    if (store == null) {\r\n        return null;\r\n    }\r\n    WorkspaceInfo workspace = store.getWorkspace();\r\n    return canSeeWorkspace(workspace) ? store : null;\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.GeoServerInstance.waitEvents",
	"Comment": "will wait until the expected number of events was consumed or the timeout is reached.",
	"Method": "void waitEvents(int number,int timeoutMs){\r\n    int loops = timeoutMs / 25;\r\n    for (int i = 0; i <= loops && jmsQueueListener.getConsumedEvents() < number; i++) {\r\n        try {\r\n            Thread.sleep(25);\r\n        } catch (InterruptedException exception) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findOrResolveNamespaceFile",
	"Comment": "returns the configuration file for the specified namespace, if the file does not exist a fileobject is still returned.",
	"Method": "File findOrResolveNamespaceFile(WorkspaceInfo ws){\r\n    Resource directory = get(ws);\r\n    return directory.dir();\r\n}"
}, {
	"Path": "org.geoserver.gwc.web.layer.ParameterFilterEditor.getSubform",
	"Comment": "returns an appropriate subform for the given parameterfilter model",
	"Method": "Component getSubform(String id,IModel<? extends ParameterFilter> model){\r\n    if (model.getObject() instanceof RegexParameterFilter) {\r\n        return new RegexParameterFilterSubform(id, (IModel<RegexParameterFilter>) model);\r\n    }\r\n    if (model.getObject() instanceof StyleParameterFilter) {\r\n        return new StyleParameterFilterSubform(id, (IModel<StyleParameterFilter>) model);\r\n    }\r\n    if (model.getObject() instanceof StringParameterFilter) {\r\n        return new StringParameterFilterSubform(id, (IModel<StringParameterFilter>) model);\r\n    }\r\n    if (model.getObject() instanceof FloatParameterFilter) {\r\n        return new FloatParameterFilterSubform(id, (IModel<FloatParameterFilter>) model);\r\n    }\r\n    if (model.getObject() instanceof IntegerParameterFilter) {\r\n        return new IntegerParameterFilterSubform(id, (IModel<IntegerParameterFilter>) model);\r\n    }\r\n    return new DefaultParameterFilterSubform(id, (IModel<ParameterFilter>) model);\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.AbstractNetCDFEncoder.updateIndexing",
	"Comment": "setup the proper netcdf array indexing, taking current dimension values from the currentcoverage",
	"Method": "void updateIndexing(int[] indexing,GridCoverage2D currentCoverage){\r\n    int i = 0;\r\n    int dimElement = 0;\r\n    final Map properties = currentCoverage.getProperties();\r\n    for (NetCDFDimensionsManager.NetCDFDimensionMapping manager : dimensionsManager.getDimensions()) {\r\n        final DimensionBean coverageDimension = manager.getCoverageDimension();\r\n        if (coverageDimension != null) {\r\n            final String dimensionName = manager.getName();\r\n            final Object val = properties.get(dimensionName);\r\n            final Set<Object> values = (Set<Object>) manager.getDimensionValues().getValues();\r\n            final Iterator<Object> it = values.iterator();\r\n            while (it.hasNext()) {\r\n                Object value = it.next();\r\n                if (value.equals(val)) {\r\n                    indexing[i++] = dimElement;\r\n                    dimElement = 0;\r\n                    break;\r\n                }\r\n                dimElement++;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.ows.util.ClassProperties.gp",
	"Comment": "returns the name of the property corresponding to the getter method.",
	"Method": "String gp(Method getter){\r\n    String name = getter.getName();\r\n    if (COMMON_DERIVED_PROPERTIES.contains(name)) {\r\n        return name;\r\n    }\r\n    return name.substring(name.startsWith(\"get\") ? 3 : 2);\r\n}"
}, {
	"Path": "org.geoserver.test.PolymorphismWfsTest.checkFeatureChainingOnly",
	"Comment": "this is to test that polymorphism can be achieved with feature chaining alone.",
	"Method": "void checkFeatureChainingOnly(Document doc){\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f1']/ex:thirdValue\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f1']/ex:thirdValue/gsml:CGI_NumericValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f1']/ex:thirdValue/gsml:CGI_TermValue\", doc);\r\n    assertXpathEvaluatesTo(\"1.0\", \"//ex:PolymorphicFeature[@gml:id='f1']/ex:thirdValue/gsml:CGI_NumericValue/gsml:principalValue\", doc);\r\n    assertXpathEvaluatesTo(\"m\", \"//ex:PolymorphicFeature[@gml:id='f1']/ex:thirdValue/gsml:CGI_NumericValue/gsml:principalValue/@uom\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f2']/ex:thirdValue\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f2']/ex:thirdValue/gsml:CGI_TermValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f2']/ex:thirdValue/gsml:CGI_NumericValue\", doc);\r\n    assertXpathEvaluatesTo(\"x\", \"//ex:PolymorphicFeature[@gml:id='f2']/ex:thirdValue/gsml:CGI_TermValue/gsml:value\", doc);\r\n    assertXpathEvaluatesTo(\"some:uri\", \"//ex:PolymorphicFeature[@gml:id='f2']/ex:thirdValue/gsml:CGI_TermValue/gsml:value/@codeSpace\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f3']/ex:thirdValue\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f3']/ex:thirdValue/gsml:CGI_TermValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f3']/ex:thirdValue/gsml:CGI_NumericValue\", doc);\r\n    assertXpathEvaluatesTo(\"y\", \"//ex:PolymorphicFeature[@gml:id='f3']/ex:thirdValue/gsml:CGI_TermValue/gsml:value\", doc);\r\n    assertXpathEvaluatesTo(\"some:uri\", \"//ex:PolymorphicFeature[@gml:id='f3']/ex:thirdValue/gsml:CGI_TermValue/gsml:value/@codeSpace\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f4']/ex:thirdValue\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f4']/ex:thirdValue/gsml:CGI_NumericValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f4']/ex:thirdValue/gsml:CGI_TermValue\", doc);\r\n    assertXpathEvaluatesTo(\"1.0\", \"//ex:PolymorphicFeature[@gml:id='f4']/ex:thirdValue/gsml:CGI_NumericValue/gsml:principalValue\", doc);\r\n    assertXpathEvaluatesTo(\"m\", \"//ex:PolymorphicFeature[@gml:id='f4']/ex:thirdValue/gsml:CGI_NumericValue/gsml:principalValue/@uom\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f5']/ex:thirdValue\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f5']/ex:thirdValue/gsml:CGI_TermValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f5']/ex:thirdValue/gsml:CGI_NumericValue\", doc);\r\n    assertXpathEvaluatesTo(\"y\", \"//ex:PolymorphicFeature[@gml:id='f5']/ex:thirdValue/gsml:CGI_TermValue/gsml:value\", doc);\r\n    assertXpathEvaluatesTo(\"some:uri\", \"//ex:PolymorphicFeature[@gml:id='f5']/ex:thirdValue/gsml:CGI_TermValue/gsml:value/@codeSpace\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f6']/ex:thirdValue\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f6']/ex:thirdValue/gsml:CGI_NumericValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f6']/ex:thirdValue/gsml:CGI_TermValue\", doc);\r\n    assertXpathEvaluatesTo(\"1000.0\", \"//ex:PolymorphicFeature[@gml:id='f6']/ex:thirdValue/gsml:CGI_NumericValue/gsml:principalValue\", doc);\r\n    assertXpathEvaluatesTo(\"m\", \"//ex:PolymorphicFeature[@gml:id='f6']/ex:thirdValue/gsml:CGI_NumericValue/gsml:principalValue/@uom\", doc);\r\n}"
}, {
	"Path": "org.geoserver.jai.ConcurrentTileFactory.createTile",
	"Comment": "builds a new tile, eventually recycling the data array backing it",
	"Method": "WritableRaster createTile(SampleModel sampleModel,Point location){\r\n    if (sampleModel == null) {\r\n        throw new NullPointerException(\"sampleModel cannot be null\");\r\n    }\r\n    if (location == null) {\r\n        location = new Point(0, 0);\r\n    }\r\n    DataBuffer db = null;\r\n    int type = sampleModel.getTransferType();\r\n    long numBanks = 0;\r\n    long size = 0;\r\n    if (sampleModel instanceof ComponentSampleModel) {\r\n        ComponentSampleModel csm = (ComponentSampleModel) sampleModel;\r\n        numBanks = getNumBanksCSM(csm);\r\n        size = getBufferSizeCSM(csm);\r\n    } else if (sampleModel instanceof MultiPixelPackedSampleModel) {\r\n        MultiPixelPackedSampleModel mppsm = (MultiPixelPackedSampleModel) sampleModel;\r\n        numBanks = 1;\r\n        int dataTypeSize = DataBuffer.getDataTypeSize(type);\r\n        size = mppsm.getScanlineStride() * mppsm.getHeight() + (mppsm.getDataBitOffset() + dataTypeSize - 1) / dataTypeSize;\r\n    } else if (sampleModel instanceof SinglePixelPackedSampleModel) {\r\n        SinglePixelPackedSampleModel sppsm = (SinglePixelPackedSampleModel) sampleModel;\r\n        numBanks = 1;\r\n        size = sppsm.getScanlineStride() * (sppsm.getHeight() - 1) + sppsm.getWidth();\r\n    }\r\n    if (size > 0) {\r\n        Object array = recycledArrays.getRecycledArray(type, numBanks, size);\r\n        if (array != null) {\r\n            switch(type) {\r\n                case DataBuffer.TYPE_BYTE:\r\n                    {\r\n                        byte[][] bankData = (byte[][]) array;\r\n                        for (int i = 0; i < numBanks; i++) {\r\n                            Arrays.fill(bankData[i], (byte) 0);\r\n                        }\r\n                        db = new DataBufferByte(bankData, (int) size);\r\n                    }\r\n                    break;\r\n                case DataBuffer.TYPE_USHORT:\r\n                    {\r\n                        short[][] bankData = (short[][]) array;\r\n                        for (int i = 0; i < numBanks; i++) {\r\n                            Arrays.fill(bankData[i], (short) 0);\r\n                        }\r\n                        db = new DataBufferUShort(bankData, (int) size);\r\n                    }\r\n                    break;\r\n                case DataBuffer.TYPE_SHORT:\r\n                    {\r\n                        short[][] bankData = (short[][]) array;\r\n                        for (int i = 0; i < numBanks; i++) {\r\n                            Arrays.fill(bankData[i], (short) 0);\r\n                        }\r\n                        db = new DataBufferShort(bankData, (int) size);\r\n                    }\r\n                    break;\r\n                case DataBuffer.TYPE_INT:\r\n                    {\r\n                        int[][] bankData = (int[][]) array;\r\n                        for (int i = 0; i < numBanks; i++) {\r\n                            Arrays.fill(bankData[i], 0);\r\n                        }\r\n                        db = new DataBufferInt(bankData, (int) size);\r\n                    }\r\n                    break;\r\n                case DataBuffer.TYPE_FLOAT:\r\n                    {\r\n                        float[][] bankData = (float[][]) array;\r\n                        for (int i = 0; i < numBanks; i++) {\r\n                            Arrays.fill(bankData[i], 0.0F);\r\n                        }\r\n                        db = DataBufferUtils.createDataBufferFloat(bankData, (int) size);\r\n                    }\r\n                    break;\r\n                case DataBuffer.TYPE_DOUBLE:\r\n                    {\r\n                        double[][] bankData = (double[][]) array;\r\n                        for (int i = 0; i < numBanks; i++) {\r\n                            Arrays.fill(bankData[i], 0.0);\r\n                        }\r\n                        db = DataBufferUtils.createDataBufferDouble(bankData, (int) size);\r\n                    }\r\n                    break;\r\n                default:\r\n                    throw new IllegalArgumentException(\"Unknown array type\");\r\n            }\r\n        }\r\n    }\r\n    if (db == null) {\r\n        db = sampleModel.createDataBuffer();\r\n    }\r\n    return Raster.createWritableRaster(sampleModel, db, location);\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDefaultValuesHelper.setAdditionalDimensionsFilter",
	"Comment": "set filter to match specified additional dimensions values",
	"Method": "Filter setAdditionalDimensionsFilter(Map<String, List<Object>> dimensionSubset,List<DimensionDescriptor> additionalDimensions){\r\n    Filter additionalDimensionsFilter = null;\r\n    if (additionalDimensions != null && dimensionSubset != null && additionalDimensions.size() != dimensionSubset.size() && dimensionSubset.size() > 0) {\r\n        List<Filter> additionalDimensionFilterList = new ArrayList<Filter>();\r\n        Set<String> dimensionKeys = dimensionSubset.keySet();\r\n        for (String dimension : dimensionKeys) {\r\n            Filter dimensionFilter = createCustomDimensionFilter(dimension, dimensionSubset, additionalDimensions);\r\n            if (dimensionFilter != null) {\r\n                additionalDimensionFilterList.add(dimensionFilter);\r\n            }\r\n        }\r\n        if (!additionalDimensionFilterList.isEmpty()) {\r\n            additionalDimensionsFilter = FF.and(additionalDimensionFilterList);\r\n        }\r\n    }\r\n    return additionalDimensionsFilter;\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaTestSupport.onTearDown",
	"Comment": "unregister all data access from registry to avoid stale data access being used by other unittests.",
	"Method": "void onTearDown(SystemTestData testData){\r\n    DataAccessRegistry.unregisterAndDisposeAll();\r\n    AppSchemaDataAccessRegistry.clearAppSchemaProperties();\r\n    AppSchemaXSDRegistry.getInstance().dispose();\r\n    catalog = null;\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityProvider.createRoleService",
	"Comment": "creates a new role group service.if the extension does not provide a role service this method should simply return null.",
	"Method": "GeoServerRoleService createRoleService(SecurityNamedServiceConfig config){\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.postAsJSON",
	"Comment": "executes a request using the post method and parses the result as a json object.",
	"Method": "JSON postAsJSON(String path,String body,String contentType){\r\n    MockHttpServletResponse response = postAsServletResponse(path, body, contentType);\r\n    return json(response);\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findOrCreateWorkspaceDir",
	"Comment": "returns the directory for the specified workspace, if the directory does not exist it will becreated.",
	"Method": "File findOrCreateWorkspaceDir(WorkspaceInfo ws){\r\n    Resource directory = get(ws);\r\n    return directory.dir();\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexSolrTest.loadFixture",
	"Comment": "try to load the fixture file associated with this tests, if the load file the tests areskipped.",
	"Method": "Properties loadFixture(){\r\n    File fixFile = getFixtureFile();\r\n    assumeTrue(fixFile.exists());\r\n    return loadFixtureProperties(fixFile);\r\n}"
}, {
	"Path": "org.geoserver.wps.security.WpsAccessRule.getValue",
	"Comment": "returns the list of roles as a comma separated string for this rule",
	"Method": "String getValue(){\r\n    if (roles.isEmpty()) {\r\n        return WpsAccessRule.ANY;\r\n    } else {\r\n        StringBuffer sb = new StringBuffer();\r\n        for (String role : roles) {\r\n            sb.append(role);\r\n            sb.append(\",\");\r\n        }\r\n        sb.setLength(sb.length() - 1);\r\n        return sb.toString();\r\n    }\r\n}"
}, {
	"Path": "org.vfny.geoserver.global.xml.WriterHelper.comment",
	"Comment": "comment purpose.writes an xml comment with the text specified to the stored output writer.",
	"Method": "void comment(String comment){\r\n    writeln(\"<!--\");\r\n    increaseIndent();\r\n    String ib = indentBuffer.substring(0, indent);\r\n    comment = comment.trim();\r\n    comment = comment.replaceAll(\"\\n\", \"\\n\" + ib);\r\n    writeln(comment);\r\n    decreaseIndent();\r\n    writeln(\"-->\");\r\n}"
}, {
	"Path": "org.geoserver.wps.ExecuteTest.testBoundsPost",
	"Comment": "tests a process execution with a boudingbox as the output and check internal layer requesthandling as well",
	"Method": "void testBoundsPost(){\r\n    String request = streamsBoundsRequest();\r\n    Document dom = postAsDOM(root(), request);\r\n    print(dom);\r\n    checkStreamsProcessBounds(dom);\r\n}"
}, {
	"Path": "org.geoserver.security.web.SecurityNamedServicesPanel.handleException",
	"Comment": "helper for handling an exception by reporting it as an error on the feedback panel",
	"Method": "void handleException(Exception e,Component target){\r\n    (target != null ? target : getPage()).error(e);\r\n}"
}, {
	"Path": "org.geoserver.ogr.core.AbstractToolWrapper.run",
	"Comment": "runs the specified command appending the output to the string builder and returning the exitcode.",
	"Method": "int run(List<String> cmd,StringBuilder sb){\r\n    ProcessBuilder builder = new ProcessBuilder(cmd);\r\n    if (environment != null)\r\n        builder.environment().putAll(environment);\r\n    builder.redirectErrorStream(true);\r\n    Process p = builder.start();\r\n    BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));\r\n    String line = null;\r\n    while ((line = reader.readLine()) != null) {\r\n        if (sb != null) {\r\n            sb.append(\"\\n\");\r\n            sb.append(line);\r\n        }\r\n    }\r\n    return p.waitFor();\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityProvider.getProvider",
	"Comment": "find the provider for a service type and a concrete class name. may return null",
	"Method": "GeoServerSecurityProvider getProvider(Class<?> serviceClass,String className){\r\n    for (GeoServerSecurityProvider prov : GeoServerExtensions.extensions(GeoServerSecurityProvider.class)) {\r\n        if (GeoServerAuthenticationProvider.class == serviceClass && prov.getAuthenticationProviderClass() != null) {\r\n            if (prov.getAuthenticationProviderClass().getName().equals(className))\r\n                return prov;\r\n        }\r\n        if (GeoServerUserGroupService.class == serviceClass && prov.getUserGroupServiceClass() != null) {\r\n            if (prov.getUserGroupServiceClass().getName().equals(className))\r\n                return prov;\r\n        }\r\n        if (GeoServerRoleService.class == serviceClass && prov.getRoleServiceClass() != null) {\r\n            if (prov.getRoleServiceClass().getName().equals(className))\r\n                return prov;\r\n        }\r\n        if (PasswordValidator.class == serviceClass && prov.getPasswordValidatorClass() != null) {\r\n            if (prov.getPasswordValidatorClass().getName().equals(className))\r\n                return prov;\r\n        }\r\n        if (GeoServerSecurityFilter.class == serviceClass && prov.getFilterClass() != null) {\r\n            if (prov.getFilterClass().getName().equals(className))\r\n                return prov;\r\n        }\r\n        if (MasterPasswordProvider.class == serviceClass && prov.getMasterPasswordProviderClass() != null) {\r\n            if (prov.getMasterPasswordProviderClass().getName().equals(className)) {\r\n                return prov;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.feature.FlatteningFeatureCollection.flatten",
	"Comment": "flattens a simplefeaturecollection that may contain simplefeatures as attributes of otherfeatures.",
	"Method": "SimpleFeatureCollection flatten(SimpleFeatureCollection collection){\r\n    SimpleFeatureType schema = collection.getSchema();\r\n    List<AttributeDescriptor> attributeDescriptors = new ArrayList<AttributeDescriptor>();\r\n    scanAttributeDescriptors(attributeDescriptors, schema, null);\r\n    SimpleFeatureTypeBuilder builder = new SimpleFeatureTypeBuilder();\r\n    builder.setName(schema.getName());\r\n    for (AttributeDescriptor desc : attributeDescriptors) builder.add(desc);\r\n    SimpleFeatureType flattenedType = builder.buildFeatureType();\r\n    if (collection.getSchema().getAttributeCount() == flattenedType.getAttributeCount()) {\r\n        return collection;\r\n    }\r\n    return new FlatteningFeatureCollection(collection, flattenedType);\r\n}"
}, {
	"Path": "org.geoserver.security.VectorAccessLimits.buildQuery",
	"Comment": "returns a geotools query build with the provided attributes and filters",
	"Method": "Query buildQuery(List<PropertyName> attributes,Filter filter){\r\n    if (attributes == null && (filter == null || filter == Filter.INCLUDE)) {\r\n        return Query.ALL;\r\n    } else {\r\n        Query q = new Query();\r\n        q.setFilter(filter);\r\n        q.setPropertyNames(flattenNames(attributes));\r\n        return q;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.indexPropertiesByType",
	"Comment": "index the provided properties by their type, geometry property will be ignored.",
	"Method": "Map<PropertyType, List<Property>> indexPropertiesByType(Property geometryAttribute,Collection<Property> properties){\r\n    Map<PropertyType, List<Property>> index = new HashMap();\r\n    for (Property property : properties) {\r\n        if (geometryAttribute != null && property.equals(geometryAttribute)) {\r\n            continue;\r\n        }\r\n        List<Property> propertiesWithSameType = index.get(property.getType());\r\n        if (propertiesWithSameType == null) {\r\n            propertiesWithSameType = new ArrayList();\r\n            index.put(property.getType(), propertiesWithSameType);\r\n        }\r\n        propertiesWithSameType.add(property);\r\n    }\r\n    return index;\r\n}"
}, {
	"Path": "org.geoserver.wfs3.GetTileTest.testGetTileGeoJSONMercator",
	"Comment": "tests gettile with geojson format, web mercator tilingschema",
	"Method": "void testGetTileGeoJSONMercator(){\r\n    String roadSegments = getEncodedName(MockData.ROAD_SEGMENTS);\r\n    String path = \"wfs3/collections/\" + roadSegments + \"/tiles/GoogleMapsCompatible/16/32768/32767\" + \"?f=\" + URLEncoder.encode(RFCGeoJSONFeaturesResponse.MIME, \"UTF-8\");\r\n    ;\r\n    DocumentContext jsdoc = getAsJSONPath(path, 200);\r\n    assertEquals(jsdoc.read(\"features[0].geometry.type\", String.class), \"MultiLineString\");\r\n    List<Double> list = jsdoc.read(\"features[0].geometry.coordinates[0][0]\", List.class);\r\n    assertEquals(-467.54, list.get(0), 0.0001d);\r\n    assertEquals(-66.79, list.get(1), 0.0001d);\r\n    list = jsdoc.read(\"features[0].geometry.coordinates[0][1]\", List.class);\r\n    assertEquals(-356.22, list.get(0), 0.0001d);\r\n    assertEquals(-33.4, list.get(1), 0.0001d);\r\n    list = jsdoc.read(\"features[0].geometry.coordinates[0][2]\", List.class);\r\n    assertEquals(-289.43, list.get(0), 0.0001d);\r\n    assertEquals(-11.13, list.get(1), 0.0001d);\r\n    list = jsdoc.read(\"features[0].geometry.coordinates[0][3]\", List.class);\r\n    assertEquals(-155.85, list.get(0), 0.0001d);\r\n    assertEquals(22.26, list.get(1), 0.0001d);\r\n    list = jsdoc.read(\"features[0].geometry.coordinates[0][4]\", List.class);\r\n    assertEquals(22.26, list.get(0), 0.0001d);\r\n    assertEquals(77.92, list.get(1), 0.0001d);\r\n    assertEquals(jsdoc.read(\"numberReturned\", Integer.class).intValue(), 2);\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.NetCDFCRSWriter.updateProjectionInformation",
	"Comment": "add georeferencing information to the writer, starting from the coordinatereferencesystem andthe mathtransform",
	"Method": "void updateProjectionInformation(NetCDFCoordinateReferenceSystemType crsType,NetcdfFileWriter writer,CoordinateReferenceSystem crs,MathTransform transform){\r\n    NetCDFProjection projection = crsType.getNetCDFProjection();\r\n    if (projection != null) {\r\n        String name = projection.getName();\r\n        Variable var = writer.findVariable(name);\r\n        setGridMappingVariableAttributes(writer, crs, var, projection);\r\n        setGeoreferencingAttributes(writer, crs, transform, var);\r\n    } else {\r\n        addGlobalAttributes(writer, crs, transform);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.ModificationProxy.isDirty",
	"Comment": "flag which indicates whether any properties of the object being proxied are changed.",
	"Method": "boolean isDirty(){\r\n    boolean dirty = false;\r\n    for (Iterator i = properties().entrySet().iterator(); i.hasNext() && !dirty; ) {\r\n        Map.Entry e = (Map.Entry) i.next();\r\n        if (e.getValue() instanceof Proxy) {\r\n            ModificationProxy h = handler(e.getValue());\r\n            if (h != null && !h.isDirty()) {\r\n                continue;\r\n            }\r\n        } else {\r\n            try {\r\n                Object orig = unwrap(getter((String) e.getKey()).invoke(proxyObject, null));\r\n                if (orig == null) {\r\n                    if (e.getValue() == null) {\r\n                        continue;\r\n                    }\r\n                } else if (e.getValue() != null && orig.equals(e.getValue())) {\r\n                    continue;\r\n                }\r\n            } catch (Exception ex) {\r\n                throw new RuntimeException(ex);\r\n            }\r\n        }\r\n        dirty = true;\r\n    }\r\n    return dirty;\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.RasterDownload.writeRaster",
	"Comment": "writes the provided gridcoverage to the requested output format",
	"Method": "Resource writeRaster(String mimeType,CoverageInfo coverageInfo,GridCoverage2D gridCoverage,Parameters writeParams){\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.log(Level.FINE, \"Writing raster\");\r\n    }\r\n    long limit = DownloadServiceConfiguration.NO_LIMIT;\r\n    if (limits.getHardOutputLimit() > 0) {\r\n        limit = limits.getHardOutputLimit();\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Hard output limits set to \" + limit);\r\n        }\r\n    } else {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Hard output limit unset\");\r\n        }\r\n    }\r\n    Parameter<GridCoverage2D> gridParam = new Parameter<GridCoverage2D>(\"fakeParam\", GridCoverage2D.class);\r\n    ProcessParameterIO ppio_ = DownloadUtilities.find(gridParam, context, mimeType, false);\r\n    if (ppio_ == null) {\r\n        throw new ProcessException(\"Don't know how to encode in mime type \" + mimeType);\r\n    } else if (!(ppio_ instanceof ComplexPPIO)) {\r\n        throw new ProcessException(\"Invalid PPIO found \" + ppio_.getIdentifer());\r\n    }\r\n    final ComplexPPIO complexPPIO = (ComplexPPIO) ppio_;\r\n    String extension = complexPPIO.getFileExtension();\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.log(Level.FINE, \"Writing file in a temporary folder\");\r\n    }\r\n    final Resource output = resourceManager.getTemporaryResource(\".\" + extension);\r\n    final ImageOutputStream fileImageOutputStreamExtImpl = new ImageOutputStreamAdapter(output.out());\r\n    ImageOutputStream os = null;\r\n    try {\r\n        if (limit > DownloadServiceConfiguration.NO_LIMIT) {\r\n            os = new LimitedImageOutputStream(fileImageOutputStreamExtImpl, limit) {\r\n                @Override\r\n                protected void raiseError(long pSizeMax, long pCount) throws IOException {\r\n                    IOException e = new IOException(\"Download Exceeded the maximum HARD allowed size!\");\r\n                    throw e;\r\n                }\r\n            };\r\n        } else {\r\n            os = fileImageOutputStreamExtImpl;\r\n        }\r\n        Map encodingParams = writeParams != null ? writeParams.getParametersMap() : null;\r\n        complexPPIO.encode(gridCoverage, encodingParams, new OutputStreamAdapter(os));\r\n        os.flush();\r\n    } finally {\r\n        try {\r\n            if (os != null) {\r\n                os.close();\r\n            }\r\n        } catch (Exception e) {\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.log(Level.FINE, e.getLocalizedMessage(), e);\r\n            }\r\n        }\r\n    }\r\n    return output;\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.RasterDownload.writeRaster",
	"Comment": "writes the provided gridcoverage to the requested output format",
	"Method": "Resource writeRaster(String mimeType,CoverageInfo coverageInfo,GridCoverage2D gridCoverage,Parameters writeParams){\r\n    IOException e = new IOException(\"Download Exceeded the maximum HARD allowed size!\");\r\n    throw e;\r\n}"
}, {
	"Path": "org.geoserver.feature.retype.RetypingDataStore.retypeQuery",
	"Comment": "retypes a query from the extenal type to the internal one using the provided typemap",
	"Method": "Query retypeQuery(Query q,FeatureTypeMap typeMap){\r\n    Query modified = new Query(q);\r\n    modified.setTypeName(typeMap.getOriginalName());\r\n    modified.setFilter(retypeFilter(q.getFilter(), typeMap));\r\n    List<Join> joins = q.getJoins();\r\n    if (!joins.isEmpty()) {\r\n        modified.getJoins().clear();\r\n        for (Join join : joins) {\r\n            FeatureTypeMap map = (FeatureTypeMap) backwardsMap.get(join.getTypeName());\r\n            if (map == null) {\r\n                modified.getJoins().add(join);\r\n            } else {\r\n                final FeatureTypeMap joinTypeMap = getTypeMapBackwards(join.getTypeName(), true);\r\n                String originalName = joinTypeMap.getOriginalName();\r\n                Join mj = new Join(originalName, join.getJoinFilter());\r\n                mj.setType(join.getType());\r\n                mj.setAlias(join.getAlias());\r\n                mj.setProperties(join.getProperties());\r\n                mj.setFilter(join.getFilter());\r\n                modified.getJoins().add(mj);\r\n            }\r\n        }\r\n    }\r\n    return modified;\r\n}"
}, {
	"Path": "org.geoserver.security.web.SecurityNamedServicePanel.isNew",
	"Comment": "determines if the configuration object represents a new configuration, or an existing one.",
	"Method": "boolean isNew(){\r\n    return configModel.getObject().getId() == null;\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.LocalWorkspaceCatalogTest.testGetNonPrefixedLayerNames",
	"Comment": "the setting says to not include the prefix. this is default behaviour",
	"Method": "void testGetNonPrefixedLayerNames(){\r\n    boolean includePrefix = false;\r\n    boolean setLocalWorkspace = true;\r\n    boolean createGeoServer = true;\r\n    assertPrefixInclusion(includePrefix, setLocalWorkspace, createGeoServer);\r\n}"
}, {
	"Path": "org.geoserver.web.demo.DemoRequestsPageTest.testStructure",
	"Comment": "kind of smoke test to make sure the page structure was correctly set up once loaded",
	"Method": "void testStructure(){\r\n    assertTrue(tester.getLastRenderedPage() instanceof DemoRequestsPage);\r\n    tester.assertComponent(\"demoRequestsForm\", Form.class);\r\n    tester.assertComponent(\"demoRequestsForm:demoRequestsList\", DropDownChoice.class);\r\n    tester.assertComponent(\"demoRequestsForm:url\", TextField.class);\r\n    tester.assertComponent(\"demoRequestsForm:body:editorContainer:editorParent:editor\", TextArea.class);\r\n    tester.assertComponent(\"demoRequestsForm:username\", TextField.class);\r\n    tester.assertComponent(\"demoRequestsForm:password\", PasswordTextField.class);\r\n    tester.assertComponent(\"demoRequestsForm:submit\", AjaxSubmitLink.class);\r\n    tester.assertComponent(\"responseWindow\", ModalWindow.class);\r\n}"
}, {
	"Path": "org.geoserver.catalog.CatalogBuilder.initWMTSLayer",
	"Comment": "initializes a wmts layer object setting any info that has not been set.",
	"Method": "void initWMTSLayer(WMTSLayerInfo layer){\r\n    layer.setCatalog(catalog);\r\n    initResourceInfo(layer);\r\n    OwsUtils.resolveCollections(layer);\r\n    WMTSLayerInfo full = buildWMTSLayer(store, layer.getNativeName());\r\n    if (layer.getSRS() == null) {\r\n        layer.setSRS(full.getSRS());\r\n    }\r\n    if (layer.getNativeCRS() == null) {\r\n        layer.setNativeCRS(full.getNativeCRS());\r\n    }\r\n    if (layer.getProjectionPolicy() == null) {\r\n        layer.setProjectionPolicy(full.getProjectionPolicy());\r\n    }\r\n    if (layer.getLatLonBoundingBox() == null && layer.getNativeBoundingBox() == null) {\r\n        layer.setLatLonBoundingBox(full.getLatLonBoundingBox());\r\n        layer.setNativeBoundingBox(full.getNativeBoundingBox());\r\n    } else if (layer.getLatLonBoundingBox() == null) {\r\n        setupBounds(layer);\r\n    } else if (layer.getNativeBoundingBox() == null && layer.getNativeCRS() != null) {\r\n        ReferencedEnvelope boundsLatLon = layer.getLatLonBoundingBox();\r\n        layer.setNativeBoundingBox(boundsLatLon.transform(layer.getNativeCRS(), true));\r\n    }\r\n    if (layer.getTitle() == null) {\r\n        layer.setTitle(full.getTitle());\r\n    }\r\n    if (layer.getDescription() == null) {\r\n        layer.setDescription(full.getDescription());\r\n    }\r\n    if (layer.getAbstract() == null) {\r\n        layer.setAbstract(full.getAbstract());\r\n    }\r\n    if (layer.getKeywords().isEmpty()) {\r\n        layer.getKeywords().addAll(full.getKeywords());\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findOrResolveResourceFile",
	"Comment": "returns the configuration file for the specified resource, if the file does not exist a fileobject is still returned.",
	"Method": "File findOrResolveResourceFile(ResourceInfo r){\r\n    Resource resource = config(r);\r\n    return resource.file();\r\n}"
}, {
	"Path": "org.geoserver.wms.web.data.StyleEditPageTest.testDiscardExistingLegend",
	"Comment": "test that while editing a style, the user can discard a previously saved legend.",
	"Method": "void testDiscardExistingLegend(){\r\n    StyleInfo style = getCatalog().getStyleByName(MockData.BUILDINGS.getLocalPart());\r\n    LegendInfo legendInfo = getCatalog().getFactory().createLegend();\r\n    legendInfo.setFormat(\"jpg\");\r\n    legendInfo.setOnlineResource(\"test.jpg\");\r\n    legendInfo.setHeight(100);\r\n    legendInfo.setWidth(100);\r\n    style.setLegend(legendInfo);\r\n    getCatalog().save(style);\r\n    tester.startPage(new StyleEditPage(getCatalog().getStyleByName(MockData.BUILDINGS.getLocalPart())));\r\n    tester.assertComponent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:onlineResource\", TextField.class);\r\n    tester.assertModelValue(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:onlineResource\", \"test.jpg\");\r\n    tester.assertComponent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:width\", TextField.class);\r\n    tester.assertModelValue(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:width\", 100);\r\n    tester.assertComponent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:height\", TextField.class);\r\n    tester.assertModelValue(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:height\", 100);\r\n    tester.assertComponent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:format\", TextField.class);\r\n    tester.assertModelValue(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:format\", \"jpg\");\r\n    tester.executeAjaxEvent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:showhide:hide\", \"click\");\r\n    FormTester form = tester.newFormTester(\"styleForm\", false);\r\n    form.submit();\r\n    tester.assertNoErrorMessage();\r\n    style = getCatalog().getStyleByName(MockData.BUILDINGS.getLocalPart());\r\n    assertNotNull(style);\r\n    assertNull(style.getLegend());\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.GeoTIFFCoverageResponseDelegate.ows20Code",
	"Comment": "all ows 2.0 exceptions for the geotiff extension come with a 404 error code",
	"Method": "OWS20Exception.OWSExceptionCode ows20Code(WcsExceptionCode code){\r\n    return new OWS20Exception.OWSExceptionCode(code.toString(), 404);\r\n}"
}, {
	"Path": "org.geoserver.wfs.Transaction.lockRefresh",
	"Comment": "refresh lock by authorizationshould use your own transaction?",
	"Method": "void lockRefresh(String lockId){\r\n    LockFeature lockFeature = new LockFeature(wfs, catalog);\r\n    lockFeature.refresh(lockId, false);\r\n}"
}, {
	"Path": "org.geoserver.ows.NestedKvpParser.parse",
	"Comment": "parses the set of token sets into a final representation.subclasses may choose to override this method. the default implementation just return thelist passed in.",
	"Method": "Object parse(String value,Object parse,List values){\r\n    return values;\r\n}"
}, {
	"Path": "org.geoserver.sldservice.utils.classifier.RulesBuilder.polygonStyle",
	"Comment": "generate polygon symbolyzer for each rule in list fill color is choose from rampcolor",
	"Method": "void polygonStyle(List<Rule> rules,ColorRamp fillRamp,boolean reverseColors){\r\n    Iterator<Rule> it;\r\n    Rule rule;\r\n    Iterator<Color> colors;\r\n    Color color;\r\n    try {\r\n        fillRamp.setNumClasses(rules.size());\r\n        if (reverseColors) {\r\n            fillRamp.revert();\r\n        }\r\n        colors = fillRamp.getRamp().iterator();\r\n        it = rules.iterator();\r\n        while (it.hasNext() && colors.hasNext()) {\r\n            color = colors.next();\r\n            rule = it.next();\r\n            rule.setSymbolizers(new Symbolizer[] { sb.createPolygonSymbolizer(strokeWeight < 0 ? null : sb.createStroke(strokeColor, strokeWeight), sb.createFill(color)) });\r\n        }\r\n    } catch (Exception e) {\r\n        if (LOGGER.isLoggable(Level.INFO))\r\n            LOGGER.log(Level.INFO, \"Failed to build polygon Symbolizer\" + e.getLocalizedMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.platform.resource.Resources.listRecursively",
	"Comment": "recursively loops through directory to provide all children",
	"Method": "List<Resource> listRecursively(Resource dir){\r\n    return list(dir, AnyFilter.INSTANCE, true);\r\n}"
}, {
	"Path": "org.geoserver.ows.util.RewindableInputStream.skip",
	"Comment": "skips over and discards n bytes of data from this input stream. the skip methodmay, for a variety of reasons, end up skipping over some smaller number of bytes, possibly0. the actual number of bytes skipped is returned. if n isnegative, no bytes are skipped.",
	"Method": "long skip(long n){\r\n    int bytesLeft;\r\n    if (n <= 0) {\r\n        return 0;\r\n    }\r\n    bytesLeft = fLength - fOffset;\r\n    if (bytesLeft == 0) {\r\n        if (fOffset == fEndOffset) {\r\n            return 0;\r\n        }\r\n        return fInputStream.skip(n);\r\n    }\r\n    if (n <= bytesLeft) {\r\n        fOffset += n;\r\n        return n;\r\n    }\r\n    fOffset += bytesLeft;\r\n    if (fOffset == fEndOffset) {\r\n        return bytesLeft;\r\n    }\r\n    n -= bytesLeft;\r\n    return fInputStream.skip(n) + bytesLeft;\r\n}"
}, {
	"Path": "org.geoserver.web.demo.MapPreviewPage.hasServiceSupport",
	"Comment": "returns true if servicename is available for resource, otherwise false",
	"Method": "boolean hasServiceSupport(String layerName,String serviceName){\r\n    LayerInfo linfo = getGeoServer().getCatalog().getLayerByName(layerName);\r\n    if (linfo != null && linfo.getResource() != null && serviceName != null) {\r\n        List<String> disabledServices = DisabledServiceResourceFilter.disabledServices(linfo.getResource());\r\n        return disabledServices.stream().noneMatch(d -> d.equalsIgnoreCase(serviceName));\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.catalog.CatalogBuilder.removeStore",
	"Comment": "removes a store from the catalog.the recursive flag controls whether objects linked to the store such as resourcesshould also be deleted.",
	"Method": "void removeStore(StoreInfo store,boolean recursive){\r\n    if (recursive) {\r\n        store.accept(new CascadeDeleteVisitor(catalog));\r\n    } else {\r\n        catalog.remove(store);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.ResourcePool.createDataStoreCache",
	"Comment": "datastorecache implementation responsible for freeing dataaccess resources when they are nolonger in use.",
	"Method": "DataStoreCache createDataStoreCache(){\r\n    return new DataStoreCache();\r\n}"
}, {
	"Path": "org.geoserver.script.ScriptManager.initEngine",
	"Comment": "initializes a new script engine by looking up the plugin matching the engines factory.",
	"Method": "ScriptEngine initEngine(ScriptEngine engine){\r\n    if (engine == null) {\r\n        return null;\r\n    }\r\n    for (ScriptPlugin plugin : plugins()) {\r\n        if (plugin.getScriptEngineFactoryClass().isInstance(engine.getFactory())) {\r\n            plugin.initScriptEngine(engine);\r\n            break;\r\n        }\r\n    }\r\n    return engine;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.cloneVectorLayerIntoWorkspace",
	"Comment": "helper method that clones a vector layer and adds it to a certain workspace updating thelayer name with the provided one. the provided layer name should correspond to an existinglayer otherwise an exception will be throw. the provided target workspace and namespaceshould also exist.",
	"Method": "LayerInfo cloneVectorLayerIntoWorkspace(WorkspaceInfo targetWorkspace,NamespaceInfo targetNameSpace,String layerName,LayerInfo cloneVectorLayerIntoWorkspace,WorkspaceInfo targetWorkspace,NamespaceInfo targetNameSpace,String layerName,String targetLayerName){\r\n    Catalog catalog = getCatalog();\r\n    LayerInfo originalLayerInfo = catalog.getLayerByName(layerName);\r\n    if (originalLayerInfo == null) {\r\n        throw new RuntimeException(String.format(\"Could not retrieve a layer for name '%s'.\", layerName));\r\n    }\r\n    FeatureTypeInfo originalFeatureTypeInfo = (FeatureTypeInfo) originalLayerInfo.getResource();\r\n    DataStoreInfo originalStoreInfo = originalFeatureTypeInfo.getStore();\r\n    DataStoreInfoImpl copyDataStoreInfo = new DataStoreInfoImpl(catalog);\r\n    OwsUtils.copy(originalStoreInfo, copyDataStoreInfo, DataStoreInfo.class);\r\n    copyDataStoreInfo.setId(UUID.randomUUID().toString());\r\n    copyDataStoreInfo.setName(UUID.randomUUID().toString());\r\n    copyDataStoreInfo.setWorkspace(targetWorkspace);\r\n    FeatureTypeInfoImpl copyFeatureTypeInfo = new FeatureTypeInfoImpl(catalog);\r\n    OwsUtils.copy(originalFeatureTypeInfo, copyFeatureTypeInfo, FeatureTypeInfo.class);\r\n    copyFeatureTypeInfo.setNamespace(targetNameSpace);\r\n    copyFeatureTypeInfo.setStore(copyDataStoreInfo);\r\n    copyFeatureTypeInfo.setName(targetLayerName);\r\n    LayerInfoImpl copyLayerInfo = new LayerInfoImpl();\r\n    OwsUtils.copy(originalLayerInfo, copyLayerInfo, LayerInfo.class);\r\n    copyLayerInfo.setId(layerName);\r\n    copyLayerInfo.setName(targetLayerName);\r\n    copyLayerInfo.setResource(copyFeatureTypeInfo);\r\n    catalog.add(copyDataStoreInfo);\r\n    catalog.add(copyFeatureTypeInfo);\r\n    catalog.add(copyLayerInfo);\r\n    return catalog.getLayerByName(new NameImpl(targetNameSpace.getPrefix(), targetLayerName));\r\n}"
}, {
	"Path": "org.geoserver.security.oauth2.GeoServerOAuth2SecurityConfiguration.getDetailsId",
	"Comment": "returns the details id for the authorizationcoderesourcedetails.",
	"Method": "String getDetailsId(){\r\n    return \"oauth2-client\";\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.isMemoryCleanRequired",
	"Comment": "subclasses may override this method to force memory cleaning before the test data dir iscleaned up. this is necessary on windows if coverages are used in the test, since readersmight still be around in the heap as garbage without having been disposed of",
	"Method": "boolean isMemoryCleanRequired(){\r\n    return false;\r\n}"
}, {
	"Path": "org.vfny.geoserver.util.WCSUtils.getReaderHints",
	"Comment": "returns the reader hints based on the current wcs configuration",
	"Method": "Hints getReaderHints(WCSInfo wcs){\r\n    Hints hints = new Hints();\r\n    hints.add(new Hints(Hints.LENIENT_DATUM_SHIFT, Boolean.TRUE));\r\n    if (wcs.getOverviewPolicy() == null) {\r\n        hints.add(new Hints(Hints.OVERVIEW_POLICY, OverviewPolicy.IGNORE));\r\n    } else {\r\n        hints.add(new Hints(Hints.OVERVIEW_POLICY, wcs.getOverviewPolicy()));\r\n    }\r\n    hints.put(Hints.DECIMATION_POLICY, wcs.isSubsamplingEnabled() ? DecimationPolicy.ALLOW : DecimationPolicy.DISALLOW);\r\n    return hints;\r\n}"
}, {
	"Path": "org.vfny.geoserver.Request.getBaseUrl",
	"Comment": "gets the base url that made this request. this is used to return the referenced schemas andwhatnot relative to the request.",
	"Method": "String getBaseUrl(){\r\n    return baseUrl;\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.Domains.getMaxReturnedValues",
	"Comment": "the maximum number of returned values in a getdomainvalues request",
	"Method": "int getMaxReturnedValues(){\r\n    return maxReturnedValues;\r\n}"
}, {
	"Path": "org.geoserver.feature.retype.RetypingDataStore.transformFeatureTypeName",
	"Comment": "just transform the feature type name, or return null if the original type name is to behidden",
	"Method": "String transformFeatureTypeName(String originalName){\r\n    return originalName.replaceAll(\":\", \"_\");\r\n}"
}, {
	"Path": "org.vfny.geoserver.global.xml.WriterHelper.attrTag",
	"Comment": "attrtag purpose.writes an xml tag with the name and attributes specified to the stored output writer.",
	"Method": "void attrTag(String tagName,Map attributes){\r\n    StringBuffer sb = new StringBuffer();\r\n    sb.append(\"<\" + tagName + \" \");\r\n    Iterator i = attributes.keySet().iterator();\r\n    while (i.hasNext()) {\r\n        String s = (String) i.next();\r\n        if (attributes.get(s) != null) {\r\n            sb.append(s + \" = \" + \"\\\"\" + escape((attributes.get(s)).toString()) + \"\\\" \");\r\n        }\r\n    }\r\n    sb.append(\"/>\");\r\n    writeln(sb.toString());\r\n}"
}, {
	"Path": "org.geoserver.security.jdbc.AbstractJDBCService.checkSQLStatements",
	"Comment": "checks if the sql statements contained in props can be prepared against the db",
	"Method": "Map<String, SQLException> checkSQLStatements(Properties props){\r\n    Map<String, SQLException> reportMap = new HashMap<String, SQLException>();\r\n    Connection con = null;\r\n    try {\r\n        con = getConnection();\r\n        for (Object key : props.keySet()) {\r\n            String stmt = props.getProperty(key.toString()).trim();\r\n            try {\r\n                con.prepareStatement(stmt.trim());\r\n            } catch (SQLException ex) {\r\n                reportMap.put(key.toString() + \"|\" + stmt, ex);\r\n            }\r\n        }\r\n    } catch (SQLException ex) {\r\n        throw new IOException(ex);\r\n    } finally {\r\n        closeFinally(con, null, null);\r\n    }\r\n    return reportMap;\r\n}"
}, {
	"Path": "org.geoserver.rest.util.RESTUtils.loadMapfromStore",
	"Comment": "this method is used for extracting the metadata map from the selected store",
	"Method": "MetadataMap loadMapfromStore(String storeName,Catalog catalog){\r\n    StoreInfo storeInfo = catalog.getStoreByName(storeName, CoverageStoreInfo.class);\r\n    if (storeInfo == null) {\r\n        storeInfo = catalog.getStoreByName(storeName, DataStoreInfo.class);\r\n    }\r\n    if (storeInfo != null) {\r\n        return storeInfo.getMetadata();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.resolveLayerName",
	"Comment": "get the qname for a layer specified by the layername that would be used in a request.",
	"Method": "QName resolveLayerName(String typename){\r\n    int i = typename.indexOf(\":\");\r\n    String prefix = typename.substring(0, i);\r\n    String name = typename.substring(i + 1);\r\n    NamespaceInfo ns = getCatalog().getNamespaceByPrefix(prefix);\r\n    QName qname = new QName(ns.getURI(), name, ns.getPrefix());\r\n    return qname;\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTest.applyDeleteConfigurationChanges",
	"Comment": "helper method that removes some services and settings from the provided geoserver instance.",
	"Method": "void applyDeleteConfigurationChanges(GeoServerInstance instance){\r\n    GeoServer geoServer = instance.getGeoServer();\r\n    Catalog catalog = instance.getCatalog();\r\n    WorkspaceInfo workspace = catalog.getWorkspaceByName(MockData.DEFAULT_PREFIX);\r\n    geoServer.remove(geoServer.getSettings(workspace));\r\n    geoServer.remove(geoServer.getService(workspace, WMSInfo.class));\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.WCSNetCDFTest.testOutputMemoryExceeded",
	"Comment": "this test checks if an exception is thrown when is requested an image with a total sizegreater than the maximum geoserver output memory allowed.",
	"Method": "void testOutputMemoryExceeded(){\r\n    setOutputLimit(40);\r\n    MockHttpServletResponse response = getAsServletResponse(\"ows?request=GetCoverage&service=WCS&version=2.0.1\" + \"&coverageId=wcs__NO2&format=application/x-netcdf\");\r\n    assertEquals(\"application/xml\", response.getContentType());\r\n    setOutputLimit(-1);\r\n}"
}, {
	"Path": "org.geoserver.util.IOUtils.getZipOutputFile",
	"Comment": "gets the output file for the provided zip entry and checks that it will not be writtenoutside of the target directory.",
	"Method": "File getZipOutputFile(File destDir,ZipEntry entry){\r\n    String canonicalDirectory = destDir.getCanonicalPath();\r\n    File file = new File(destDir, entry.getName());\r\n    String canonicalFile = file.getCanonicalPath();\r\n    if (canonicalFile.startsWith(canonicalDirectory + File.separator)) {\r\n        return file;\r\n    }\r\n    throw new IOException(\"Entry is outside of the target directory: \" + entry.getName());\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexMongoDBSupport.checkCount",
	"Comment": "helper method that evaluates a xpath and checks if the number of nodes found correspond tothe expected number,",
	"Method": "void checkCount(XpathEngine xpathEngine,Document document,int expectedCount,String xpath){\r\n    try {\r\n        MatcherAssert.assertThat(xpathEngine.getMatchingNodes(xpath, document).getLength(), is(expectedCount));\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error evaluating xpath.\", exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTestsUtils.getInfoInterface",
	"Comment": "helper method that find the interface of an implementation.",
	"Method": "Class<?> getInfoInterface(Class<?> type){\r\n    Class<?>[] classInterfaces = type.getInterfaces();\r\n    for (Class<?> classInterface : classInterfaces) {\r\n        if (Info.class.isAssignableFrom(classInterface)) {\r\n            return classInterface;\r\n        }\r\n    }\r\n    return Info.class;\r\n}"
}, {
	"Path": "org.geoserver.test.IsolatedNamespacesWfsTest.checkCount",
	"Comment": "helper method that evaluates a xpath and checks if the number of nodes found correspond tothe expected number,",
	"Method": "void checkCount(XpathEngine xpathEngine,Document document,int expectedCount,String xpath){\r\n    try {\r\n        assertThat(xpathEngine.getMatchingNodes(xpath, document).getLength(), is(expectedCount));\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error evaluating xpath.\", exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.ReaderUtils.getChildText",
	"Comment": "getchildtext purpose.used to help with xml manipulations. returns the first child text value of the specifiedelement name. an exception occurs when the node is required and not found.",
	"Method": "String getChildText(Element root,String childName,String getChildText,Element root,String childName,boolean mandatory){\r\n    Element elem = getChildElement(root, childName, mandatory);\r\n    if (elem != null) {\r\n        return getElementText(elem, mandatory);\r\n    } else {\r\n        if (mandatory) {\r\n            String msg = \"Mandatory child \" + childName + \"not found in \" + \" element: \" + root;\r\n            throw new Exception(msg);\r\n        }\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.vfny.geoserver.global.GeoServerFeatureSource.adaptQuery",
	"Comment": "transforms the query applying the definition query in this layer, removes reprojection sincedata stores cannot be trusted",
	"Method": "Query adaptQuery(Query query,SimpleFeatureType schema){\r\n    Query newQuery = makeDefinitionQuery(query, schema);\r\n    if (newQuery.getCoordinateSystemReproject() != null) {\r\n        newQuery.setCoordinateSystemReproject(null);\r\n    }\r\n    if (newQuery.getCoordinateSystem() != null) {\r\n        newQuery.setCoordinateSystem(null);\r\n    }\r\n    return newQuery;\r\n}"
}, {
	"Path": "org.geoserver.flow.controller.HttpHeaderPriorityProvider.getDefaultPriority",
	"Comment": "the default priority value, in case the header does not return a priority value",
	"Method": "int getDefaultPriority(){\r\n    return defaultPriority;\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.LegacyCatalogImporter.imprt",
	"Comment": "imports configuration from a geoserver data directory into the catalog.",
	"Method": "void imprt(File dir){\r\n    CatalogFactory factory = catalog.getFactory();\r\n    File catalogFile = new File(dir, \"catalog.xml\");\r\n    if (!catalogFile.exists()) {\r\n        throw new FileNotFoundException(\"Could not find catalog.xml under:\" + dir.getAbsolutePath());\r\n    }\r\n    importCatalog(catalogFile);\r\n    File featureTypes = new File(dir, \"featureTypes\");\r\n    if (!featureTypes.exists())\r\n        featureTypes.mkdir();\r\n    File[] featureTypeDirectories = featureTypes.listFiles();\r\n    for (int i = 0; i < featureTypeDirectories.length; i++) {\r\n        File featureTypeDirectory = featureTypeDirectories[i];\r\n        if (!featureTypeDirectory.isDirectory() || featureTypeDirectory.isHidden())\r\n            continue;\r\n        File ftInfoFile = new File(featureTypeDirectory, \"info.xml\");\r\n        if (!ftInfoFile.exists()) {\r\n            LOGGER.fine(\"No info.xml found in directory: '\" + featureTypeDirectory.getName() + \"', ignoring\");\r\n            continue;\r\n        }\r\n        LegacyFeatureTypeInfoReader ftInfoReader = new LegacyFeatureTypeInfoReader();\r\n        try {\r\n            ftInfoReader.read(Files.asResource(ftInfoFile));\r\n            FeatureTypeInfo featureType = readFeatureType(ftInfoReader, featureTypeDirectory);\r\n            if (featureType == null) {\r\n                continue;\r\n            }\r\n            catalog.add(featureType);\r\n            LOGGER.info(\"Loaded feature type '\" + featureType.getPrefixedName() + \"'\");\r\n            LayerInfo layer = factory.createLayer();\r\n            layer.setResource(featureType);\r\n            layer.setName(featureType.getName());\r\n            layer.setPath(ftInfoReader.wmsPath());\r\n            if (layer.getPath() == null) {\r\n                layer.setPath(\"/\");\r\n            }\r\n            layer.setType(PublishedType.VECTOR);\r\n            String defaultStyleName = ftInfoReader.defaultStyle();\r\n            if (defaultStyleName != null) {\r\n                StyleInfo style = catalog.getStyleByName(defaultStyleName);\r\n                if (style != null) {\r\n                    layer.setDefaultStyle(style);\r\n                }\r\n            }\r\n            List<String> styles = ftInfoReader.styles();\r\n            if (styles != null) {\r\n                for (String styleName : styles) {\r\n                    StyleInfo style = catalog.getStyleByName(styleName);\r\n                    if (style != null) {\r\n                        layer.getStyles().add(style);\r\n                    }\r\n                }\r\n            }\r\n            Map legendURL = ftInfoReader.legendURL();\r\n            if (legendURL != null) {\r\n                LegendInfo legend = factory.createLegend();\r\n                legend.setHeight((Integer) legendURL.get(\"height\"));\r\n                legend.setWidth((Integer) legendURL.get(\"width\"));\r\n                legend.setFormat((String) legendURL.get(\"format\"));\r\n                legend.setOnlineResource((String) legendURL.get(\"onlineResource\"));\r\n                layer.setLegend(legend);\r\n            }\r\n            layer.setEnabled(featureType.isEnabled());\r\n            catalog.add(layer);\r\n        } catch (Exception e) {\r\n            LOGGER.warning(\"Error loadin '\" + featureTypeDirectory.getName() + \"/info.xml', ignoring\");\r\n            LOGGER.log(Level.INFO, \"\", e);\r\n            continue;\r\n        }\r\n    }\r\n    File coverages = new File(dir, \"coverages\");\r\n    if (!coverages.exists())\r\n        coverages.mkdir();\r\n    File[] coverageDirectories = coverages.listFiles();\r\n    for (int i = 0; i < coverageDirectories.length; i++) {\r\n        File coverageDirectory = coverageDirectories[i];\r\n        if (!coverageDirectory.isDirectory() || coverageDirectory.isHidden())\r\n            continue;\r\n        File cInfoFile = new File(coverageDirectory, \"info.xml\");\r\n        if (!cInfoFile.exists()) {\r\n            LOGGER.fine(\"No info.xml found in directory: '\" + coverageDirectory.getName() + \"', ignoring\");\r\n            continue;\r\n        }\r\n        LegacyCoverageInfoReader cInfoReader = new LegacyCoverageInfoReader();\r\n        try {\r\n            cInfoReader.read(cInfoFile);\r\n            CoverageInfo coverage = readCoverage(cInfoReader);\r\n            if (coverage == null) {\r\n                continue;\r\n            }\r\n            catalog.add(coverage);\r\n            LayerInfo layer = factory.createLayer();\r\n            layer.setResource(coverage);\r\n            layer.setName(coverage.getName());\r\n            layer.setPath(cInfoReader.wmsPath());\r\n            if (layer.getPath() == null) {\r\n                layer.setPath(\"/\");\r\n            }\r\n            layer.setType(PublishedType.RASTER);\r\n            String defaultStyleName = cInfoReader.defaultStyle();\r\n            if (defaultStyleName != null) {\r\n                StyleInfo style = catalog.getStyleByName(defaultStyleName);\r\n                if (style != null) {\r\n                    layer.setDefaultStyle(style);\r\n                }\r\n            }\r\n            List<String> styles = cInfoReader.styles();\r\n            if (styles != null) {\r\n                for (String styleName : styles) {\r\n                    StyleInfo style = catalog.getStyleByName(styleName);\r\n                    if (style != null) {\r\n                        layer.getStyles().add(style);\r\n                    }\r\n                }\r\n            }\r\n            layer.setEnabled(coverage.isEnabled());\r\n            catalog.add(layer);\r\n        } catch (Exception e) {\r\n            LOGGER.warning(\"Error loading '\" + coverageDirectory.getName() + \"/info.xml', ignoring\");\r\n            LOGGER.log(Level.INFO, \"\", e);\r\n            continue;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wms.ncwms.NcWmsGetTimeSeriesTest.testCsvLatLon",
	"Comment": "tests that lat lon values are returned for a geographic crs request",
	"Method": "void testCsvLatLon(){\r\n    setupRasterDimension(WATTEMP, ResourceInfo.ELEVATION, DimensionPresentation.LIST, null, UNITS, UNIT_SYMBOL);\r\n    setupRasterDimension(WATTEMP, ResourceInfo.TIME, DimensionPresentation.LIST, null, null, \"degrees\");\r\n    String url = BASE_URL_4326 + CSV_FORMAT + TIME_RANGE_COMPLETE;\r\n    String rawCsv = getAsString(url);\r\n    String[] csvLines = rawCsv.split(\"\\\\r?\\\\n\");\r\n    Assert.assertTrue(\"Geographic output\", csvLines[0].startsWith(\"# Latitude:\"));\r\n    double latitude = Double.parseDouble(csvLines[0].substring(12));\r\n    double longitude = Double.parseDouble(csvLines[1].substring(13));\r\n    Assert.assertEquals(\"latitude\", 41.93481445312501, latitude, 0.000001);\r\n    Assert.assertEquals(\"longitude\", 4.822998046875, longitude, 0.000001);\r\n}"
}, {
	"Path": "org.geoserver.importer.ImporterTestSupport.removeStore",
	"Comment": "adding special treatment for h2 databases, we want to also kill the db itself",
	"Method": "void removeStore(String workspaceName,String name){\r\n    Catalog cat = getCatalog();\r\n    StoreInfo store = cat.getStoreByName(workspaceName, name, StoreInfo.class);\r\n    if (store == null) {\r\n        return;\r\n    }\r\n    Map<String, Serializable> params = store.getConnectionParameters();\r\n    String databaseLocation = null;\r\n    if (\"h2\".equals(params.get(\"dbtype\"))) {\r\n        databaseLocation = (String) params.get(\"database\");\r\n    }\r\n    CascadeDeleteVisitor v = new CascadeDeleteVisitor(getCatalog());\r\n    store.accept(v);\r\n    if (databaseLocation != null) {\r\n        final File dbFile = new File(databaseLocation);\r\n        File container = dbFile.getParentFile();\r\n        File[] dbFiles = container.listFiles(new FilenameFilter() {\r\n            @Override\r\n            public boolean accept(File dir, String name) {\r\n                return name.startsWith(dbFile.getName());\r\n            }\r\n        });\r\n        for (File f : dbFiles) {\r\n            assertTrue(\"Failed to remove file \" + f.getPath(), FileUtils.deleteQuietly(f));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.importer.ImporterTestSupport.removeStore",
	"Comment": "adding special treatment for h2 databases, we want to also kill the db itself",
	"Method": "void removeStore(String workspaceName,String name){\r\n    return name.startsWith(dbFile.getName());\r\n}"
}, {
	"Path": "org.geoserver.wms.web.data.StyleAdminPanel.clearFeedbackMessages",
	"Comment": "clears validation messages from form input elements. called when it is necessary to submitthe form without needing to show validation, such as when you are generating a new style",
	"Method": "void clearFeedbackMessages(){\r\n    nameTextField.getFeedbackMessages().clear();\r\n    wsChoice.getFeedbackMessages().clear();\r\n    formatChoice.getFeedbackMessages().clear();\r\n    stylePage.editor.getFeedbackMessages().clear();\r\n}"
}, {
	"Path": "org.geoserver.ows.kvp.TimeParser.parsePeriod",
	"Comment": "parses the increment part of a period and returns it in milliseconds.",
	"Method": "long parsePeriod(String period){\r\n    final int length = period.length();\r\n    if (length != 0 && Character.toUpperCase(period.charAt(0)) != 'P') {\r\n        throw new ParseException(\"Invalid period increment given: \" + period, 0);\r\n    }\r\n    long millis = 0;\r\n    boolean time = false;\r\n    int lower = 0;\r\n    while (++lower < length) {\r\n        char letter = Character.toUpperCase(period.charAt(lower));\r\n        if (letter == 'T') {\r\n            time = true;\r\n            if (++lower >= length) {\r\n                break;\r\n            }\r\n        }\r\n        int upper = lower;\r\n        letter = period.charAt(upper);\r\n        while (!Character.isLetter(letter) || letter == 'e' || letter == 'E') {\r\n            if (++upper >= length) {\r\n                throw new ParseException(\"Missing symbol in \\\"\" + period + \"\\\".\", lower);\r\n            }\r\n            letter = period.charAt(upper);\r\n        }\r\n        letter = Character.toUpperCase(letter);\r\n        final double value = Double.parseDouble(period.substring(lower, upper));\r\n        final double factor;\r\n        if (time) {\r\n            switch(letter) {\r\n                case 'S':\r\n                    factor = 1000;\r\n                    break;\r\n                case 'M':\r\n                    factor = 60 * 1000;\r\n                    break;\r\n                case 'H':\r\n                    factor = 60 * 60 * 1000;\r\n                    break;\r\n                default:\r\n                    throw new ParseException(\"Unknown time symbol: \" + letter, upper);\r\n            }\r\n        } else {\r\n            switch(letter) {\r\n                case 'D':\r\n                    factor = MILLIS_IN_DAY;\r\n                    break;\r\n                case 'W':\r\n                    factor = 7 * MILLIS_IN_DAY;\r\n                    break;\r\n                case 'M':\r\n                    factor = 30 * MILLIS_IN_DAY;\r\n                    break;\r\n                case 'Y':\r\n                    factor = 365.25 * MILLIS_IN_DAY;\r\n                    break;\r\n                default:\r\n                    throw new ParseException(\"Unknown period symbol: \" + letter, upper);\r\n            }\r\n        }\r\n        millis += Math.round(value * factor);\r\n        lower = upper;\r\n    }\r\n    return millis;\r\n}"
}, {
	"Path": "org.vfny.geoserver.global.GeoServerFeatureSource.create",
	"Comment": "factory that make the correct decorator for the provided featuresource.this factory method is public and will be used to create all required subclasses. bycomparison the constructors for this class have package visibility.",
	"Method": "GeoServerFeatureSource create(FeatureSource<SimpleFeatureType, SimpleFeature> featureSource,SimpleFeatureType schema,Filter definitionQuery,CoordinateReferenceSystem declaredCRS,int srsHandling,Double linearizationTolerance,MetadataMap metadata,GeoServerFeatureSource create,FeatureSource<SimpleFeatureType, SimpleFeature> featureSource,Settings settings){\r\n    if (featureSource instanceof FeatureLocking) {\r\n        return new GeoServerFeatureLocking((FeatureLocking<SimpleFeatureType, SimpleFeature>) featureSource, settings);\r\n    } else if (featureSource instanceof FeatureStore) {\r\n        return new GeoServerFeatureStore((FeatureStore<SimpleFeatureType, SimpleFeature>) featureSource, settings);\r\n    }\r\n    return new GeoServerFeatureSource(featureSource, settings);\r\n}"
}, {
	"Path": "org.geoserver.rest.ecql.RESTECQLTest.testExpression",
	"Comment": "private method for adding the selected coverage inside the defined workspace via rest andthen checking if the coverage has been placed inside the defined directory",
	"Method": "void testExpression(String workspace,String coverageStore,String expression,List<String> fileNames){\r\n    initialSetup(expression);\r\n    URL zip = MockData.class.getResource(\"watertemp.zip\");\r\n    InputStream is = null;\r\n    byte[] bytes;\r\n    try {\r\n        is = zip.openStream();\r\n        bytes = IOUtils.toByteArray(is);\r\n    } finally {\r\n        IOUtils.closeQuietly(is);\r\n    }\r\n    createWorkSpace(workspace);\r\n    MockHttpServletResponse response = putAsServletResponse(\"/rest/workspaces/\" + workspace + \"/coveragestores/\" + coverageStore + \"/file.imagemosaic\", bytes, \"application/zip\");\r\n    assertEquals(201, response.getStatus());\r\n    String content = response.getContentAsString();\r\n    Document d = dom(new ByteArrayInputStream(content.getBytes()));\r\n    assertEquals(\"coverageStore\", d.getDocumentElement().getNodeName());\r\n    CoverageStoreInfo cs = getCatalog().getCoverageStoreByName(workspace, coverageStore);\r\n    assertNotNull(cs);\r\n    CoverageInfo ci = getCatalog().getCoverageByName(workspace, coverageStore);\r\n    assertNotNull(ci);\r\n    for (String fileName : fileNames) {\r\n        File finalFile = extractFile(expression, cs, fileName, fileName);\r\n        assertTrue(finalFile.exists());\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.impl.DataAccessRule.getKey",
	"Comment": "returns the key for the current rule. no other rule should have the same",
	"Method": "String getKey(){\r\n    if (globalGroupRule) {\r\n        return root + \".\" + accessMode.getAlias();\r\n    } else {\r\n        return root + \".\" + layer + \".\" + accessMode.getAlias();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.WFSWorkspaceQualifier.ensureFeatureNamespaceUriMatches",
	"Comment": "iterates the given features and ensures their namespaceuri matches the given namespace",
	"Method": "void ensureFeatureNamespaceUriMatches(List features,NamespaceInfo ns,TransactionRequest t){\r\n    for (Iterator j = features.iterator(); j.hasNext(); ) {\r\n        Object next = j.next();\r\n        if (next instanceof Feature) {\r\n            Feature f = (Feature) next;\r\n            Name n = f.getType().getName();\r\n            if (n.getNamespaceURI() != null && !ns.getURI().equals(n.getNamespaceURI())) {\r\n                throw new WFSException(t, \"No such feature type \" + n);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.ows.util.OwsUtils.has",
	"Comment": "reflectively determines if an object has a specified property.",
	"Method": "boolean has(Object object,String property){\r\n    return getter(object.getClass(), property, null) != null;\r\n}"
}, {
	"Path": "org.geoserver.ows.util.OwsUtils.method",
	"Comment": "returns a method with a pariticular name of a class, ignoring method paramters.",
	"Method": "Method method(Class clazz,String name){\r\n    return classProperties(clazz).method(name);\r\n}"
}, {
	"Path": "org.geoserver.kml.utils.KMLFeatureAccessor.loadFeatureCollection",
	"Comment": "loads the feature collection based on the current styling and the scale denominator. if nofeature is going to be returned a null feature collection will be returned instead",
	"Method": "SimpleFeatureCollection loadFeatureCollection(Layer layer,WMSMapContent mapContent,WMS wms,double scaleDenominator){\r\n    SimpleFeatureSource featureSource = (SimpleFeatureSource) layer.getFeatureSource();\r\n    Query q = getFeaturesQuery(layer, mapContent, wms, scaleDenominator);\r\n    CoordinateReferenceSystem wgs84;\r\n    try {\r\n        wgs84 = CRS.decode(\"EPSG:4326\", true);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(\"Cannot decode EPSG:4326, the CRS subsystem must be badly broken...\", e);\r\n    }\r\n    SimpleFeatureCollection features = featureSource.getFeatures(q);\r\n    SimpleFeatureType schema = featureSource.getSchema();\r\n    CoordinateReferenceSystem nativeCRS = schema.getCoordinateReferenceSystem();\r\n    if (nativeCRS != null && !CRS.equalsIgnoreMetadata(wgs84, nativeCRS)) {\r\n        features = new ReprojectFeatureResults(features, wgs84);\r\n    }\r\n    return features;\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.StoreEditPanel.onSave",
	"Comment": "gives an option to store panels to raise an opinion before saving",
	"Method": "boolean onSave(){\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.kml.icons.Icons.rotationScale",
	"Comment": "find the size of a square needed to accommodate the rotated image of another square",
	"Method": "Integer rotationScale(Integer size,Double rotation,Double rotationScale,Double size,Double rotation){\r\n    if (size == null)\r\n        return null;\r\n    if (rotation == null || rotation % 90 == 0)\r\n        return size;\r\n    return rotationScaleFactor(rotation) * size;\r\n}"
}, {
	"Path": "org.geoserver.wps.executor.AbstractInputProvider.kvpParse",
	"Comment": "simulates what the dispatcher is doing when parsing a kvp request",
	"Method": "Object kvpParse(String href,KvpRequestReader reader){\r\n    Map original = new KvpMap(KvpUtils.parseQueryString(href));\r\n    KvpUtils.normalize(original);\r\n    Map parsed = new KvpMap(original);\r\n    List<Throwable> errors = KvpUtils.parse(parsed);\r\n    if (errors.size() > 0) {\r\n        throw new WPSException(\"Failed to parse KVP request\", errors.get(0));\r\n    }\r\n    Request r = Dispatcher.REQUEST.get();\r\n    if (r != null) {\r\n        Map kvp = new HashMap(r.getKvp());\r\n        r.setKvp(new CaseInsensitiveMap(parsed));\r\n    }\r\n    return reader.read(reader.createRequest(), parsed, original);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.kvp",
	"Comment": "helper method to create the kvp params from the query string.",
	"Method": "void kvp(MockHttpServletRequest request,String path){\r\n    Map<String, Object> params = KvpUtils.parseQueryString(path);\r\n    for (String key : params.keySet()) {\r\n        Object value = params.get(key);\r\n        if (value instanceof String) {\r\n            request.addParameter(key, (String) value);\r\n        } else {\r\n            String[] values = (String[]) value;\r\n            request.addParameter(key, values);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.IsolatedCatalogFacade.filterIsolated",
	"Comment": "removes from a list of catalog objects the ones that are not visible in the current context.",
	"Method": "List<T> filterIsolated(List<T> objects,Class<T> type,Function<T, T> filter,CloseableIterator<T> filterIsolated,CloseableIterator<T> objects,Function<T, T> filter,CloseableIterator<T> filterIsolated,Class<T> type,CloseableIterator<T> objects){\r\n    if (StoreInfo.class.isAssignableFrom(type)) {\r\n        return (CloseableIterator<T>) filterIsolated((CloseableIterator<StoreInfo>) objects, this::enforceStoreIsolation);\r\n    } else if (ResourceInfo.class.isAssignableFrom(type)) {\r\n        return (CloseableIterator<T>) filterIsolated((CloseableIterator<ResourceInfo>) objects, this::enforceResourceIsolation);\r\n    } else if (LayerInfo.class.isAssignableFrom(type)) {\r\n        return (CloseableIterator<T>) filterIsolated((CloseableIterator<LayerInfo>) objects, this::enforceLayerIsolation);\r\n    } else if (LayerGroupInfo.class.isAssignableFrom(type)) {\r\n        return (CloseableIterator<T>) filterIsolated((CloseableIterator<LayerGroupInfo>) objects, this::enforceLayerGroupIsolation);\r\n    } else if (StyleInfo.class.isAssignableFrom(type)) {\r\n        return (CloseableIterator<T>) filterIsolated((CloseableIterator<StyleInfo>) objects, this::enforceStyleIsolation);\r\n    }\r\n    return objects;\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.checkStackTrace",
	"Comment": "checks if the stack trace contains allowed methods. it it contains allowed methods, returnnull, if not return a string listing the methods.",
	"Method": "String checkStackTrace(int countMethodsToCheck,String[][] allowedMethods){\r\n    StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();\r\n    boolean isAllowed = false;\r\n    for (int i = 0; i < countMethodsToCheck; i++) {\r\n        StackTraceElement element = stackTraceElements[i];\r\n        for (String[] methodEntry : allowedMethods) {\r\n            if (methodEntry[0].equals(element.getClassName()) && methodEntry[1].equals(element.getMethodName())) {\r\n                isAllowed = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (isAllowed) {\r\n        return null;\r\n    } else {\r\n        StringBuffer buff = new StringBuffer();\r\n        for (int i = 0; i < countMethodsToCheck; i++) {\r\n            StackTraceElement element = stackTraceElements[i];\r\n            buff.append(element.getClassName()).append(\" : \").append(element.getMethodName()).append(\"\\n\");\r\n        }\r\n        return buff.toString();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.DataAccessEditPage.doSaveStore",
	"Comment": "performs the save of the store.this method may be subclasses to provide custom save functionality.",
	"Method": "void doSaveStore(DataStoreInfo info){\r\n    try {\r\n        final Catalog catalog = getCatalog();\r\n        NamespaceInfo namespace = catalog.getNamespaceByPrefix(info.getWorkspace().getName());\r\n        List<FeatureTypeInfo> configuredResources = catalog.getResourcesByStore(info, FeatureTypeInfo.class);\r\n        for (FeatureTypeInfo alreadyConfigured : configuredResources) {\r\n            alreadyConfigured.setNamespace(namespace);\r\n        }\r\n        ResourcePool resourcePool = catalog.getResourcePool();\r\n        resourcePool.clear(info);\r\n        DataStoreInfo expandedStore = catalog.getResourcePool().clone(info, true);\r\n        catalog.validate(expandedStore, false).throwIfInvalid();\r\n        catalog.save(info);\r\n        for (FeatureTypeInfo alreadyConfigured : configuredResources) {\r\n            catalog.save(alreadyConfigured);\r\n        }\r\n        LOGGER.finer(\"Saved store \" + info.getName());\r\n    } catch (Exception e) {\r\n        LOGGER.log(Level.WARNING, \"Error saving data store to catalog\", e);\r\n        throw new IllegalArgumentException(\"Error saving data store:\" + e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.addKeywordsToLayerGroup",
	"Comment": "helper method that adds some tests keywords to a layer group. the provided layer group nameshould not be null, if the layer group cannot be found an exception will be throw.",
	"Method": "void addKeywordsToLayerGroup(String layerGroupName){\r\n    List<KeywordInfo> keywords = new ArrayList();\r\n    Keyword keyword1 = new Keyword(\"keyword1\");\r\n    keyword1.setLanguage(\"en\");\r\n    keyword1.setVocabulary(\"vocabulary1\");\r\n    keywords.add(keyword1);\r\n    Keyword keyword2 = new Keyword(\"keyword2\");\r\n    keyword2.setLanguage(\"pt\");\r\n    keyword2.setVocabulary(\"vocabulary2\");\r\n    keywords.add(keyword2);\r\n    LayerGroupInfo layerGroup = getCatalog().getLayerGroupByName(layerGroupName);\r\n    if (layerGroup == null) {\r\n        throw new RuntimeException(String.format(\"Layer group '%s' doesn't exists.\", layerGroupName));\r\n    }\r\n    layerGroup.getKeywords().addAll(keywords);\r\n    getCatalog().save(layerGroup);\r\n}"
}, {
	"Path": "org.geoserver.catalog.CatalogBuilder.update",
	"Comment": "update method which uses reflection to grab property values from one object and set them onanother.null values from the update object are ignored.",
	"Method": "void update(T original,T update,Class<T> clazz){\r\n    OwsUtils.copy(update, original, clazz);\r\n}"
}, {
	"Path": "org.geoserver.catalog.ResourcePool.setCoverageExecutor",
	"Comment": "sets the size of the feature type cache.a warning that calling this method will blow away the existing cache.",
	"Method": "void setCoverageExecutor(ThreadPoolExecutor coverageExecutor){\r\n    synchronized (this) {\r\n        this.coverageExecutor = coverageExecutor;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTest.waitAndCheckEvents",
	"Comment": "waits for the expected number of events to be consumed or for the timeout of two seconds tobe reached and then checks if the expected number of events were consumed.",
	"Method": "void waitAndCheckEvents(GeoServerInstance instance,int expectedEvents){\r\n    instance.waitEvents(expectedEvents, 2000);\r\n    assertThat(instance.getConsumedEventsCount(), is(expectedEvents));\r\n    instance.resetConsumedEventsCount();\r\n}"
}, {
	"Path": "org.geoserver.wps.executor.DefaultProcessManager.canHandle",
	"Comment": "we can handle everything, other process managers will have to use a higher priority than us",
	"Method": "boolean canHandle(Name processName){\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDefaultValuesHelper.setDefaultDimensionsSubset",
	"Comment": "set default for custom dimensions, taking values from the feature resulting from the query.",
	"Method": "Map<String, List<Object>> setDefaultDimensionsSubset(List<DimensionDescriptor> customDimensions,SimpleFeature feature){\r\n    Map<String, List<Object>> dimensionsSubset = new HashMap<String, List<Object>>();\r\n    for (DimensionDescriptor dimensionDescriptor : customDimensions) {\r\n        final String start = dimensionDescriptor.getStartAttribute();\r\n        Object value = feature.getAttribute(start);\r\n        List<Object> dimensionValues = new ArrayList<Object>();\r\n        dimensionValues.add(value);\r\n        dimensionsSubset.put(dimensionDescriptor.getName().toUpperCase(), dimensionValues);\r\n    }\r\n    return dimensionsSubset;\r\n}"
}, {
	"Path": "org.geoserver.catalog.CatalogBuilder.removeResource",
	"Comment": "removes a resource from the catalog.the recursive flag controls whether objects linked to the resource such as layersshould also be deleted.",
	"Method": "void removeResource(ResourceInfo resource,boolean recursive){\r\n    if (recursive) {\r\n        resource.accept(new CascadeDeleteVisitor(catalog));\r\n    } else {\r\n        catalog.remove(resource);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.SecureCatalogImpl.buildWrapperPolicy",
	"Comment": "check how an access manager responds to a user accessing a catalog object and return theresult.",
	"Method": "WrapperPolicy buildWrapperPolicy(ResourceAccessManager accessManager,Authentication user,CatalogInfo info,MixedModeBehavior mixedModeBehavior,WrapperPolicy buildWrapperPolicy,Authentication user,CatalogInfo info,MixedModeBehavior mixedModeBehavior,WrapperPolicy buildWrapperPolicy,Authentication user,CatalogInfo info,String resourceName,MixedModeBehavior mixedModeBehavior,WrapperPolicy buildWrapperPolicy,Authentication user,CatalogInfo info,String resourceName,MixedModeBehavior mixedModeBehavior,List<LayerGroupInfo> containers,WrapperPolicy buildWrapperPolicy,ResourceAccessManager accessManager,Authentication user,CatalogInfo info,String resourceName,MixedModeBehavior mixedModeBehavior,WrapperPolicy buildWrapperPolicy,ResourceAccessManager accessManager,Authentication user,CatalogInfo info,String resourceName,MixedModeBehavior mixedModeBehavior,List<LayerGroupInfo> containers){\r\n    boolean canRead = true;\r\n    boolean canWrite = true;\r\n    AccessLimits limits;\r\n    if (info instanceof WorkspaceInfo) {\r\n        limits = accessManager.getAccessLimits(user, (WorkspaceInfo) info);\r\n        WorkspaceAccessLimits wl = (WorkspaceAccessLimits) limits;\r\n        if (wl != null) {\r\n            if (wl.isAdminable()) {\r\n                canRead = canWrite = true;\r\n            } else {\r\n                canRead = wl.isReadable();\r\n                canWrite = wl.isWritable();\r\n            }\r\n        }\r\n        if (AdminRequest.get() != null) {\r\n            if (wl == null || !wl.isAdminable()) {\r\n                canRead = canWrite = false;\r\n            }\r\n        }\r\n    } else if (info instanceof LayerInfo || info instanceof ResourceInfo) {\r\n        DataAccessLimits dl;\r\n        WorkspaceAccessLimits wl;\r\n        if (info instanceof LayerInfo) {\r\n            dl = accessManager.getAccessLimits(user, (LayerInfo) info, containers);\r\n            wl = accessManager.getAccessLimits(user, ((LayerInfo) info).getResource().getStore().getWorkspace());\r\n        } else {\r\n            dl = accessManager.getAccessLimits(user, (ResourceInfo) info);\r\n            wl = accessManager.getAccessLimits(user, ((ResourceInfo) info).getStore().getWorkspace());\r\n        }\r\n        if (dl != null) {\r\n            canRead = dl.getReadFilter() != Filter.EXCLUDE;\r\n            if (dl instanceof VectorAccessLimits) {\r\n                canWrite = ((VectorAccessLimits) dl).getWriteFilter() != Filter.EXCLUDE;\r\n            } else {\r\n                canWrite = false;\r\n            }\r\n        }\r\n        limits = dl;\r\n        if (AdminRequest.get() != null) {\r\n            if (wl != null && !wl.isAdminable()) {\r\n                canRead = false;\r\n            }\r\n        }\r\n    } else if (info instanceof StyleInfo || info instanceof LayerGroupInfo) {\r\n        WorkspaceInfo ws = null;\r\n        if (info instanceof StyleInfo) {\r\n            limits = accessManager.getAccessLimits(user, (StyleInfo) info);\r\n            ws = ((StyleInfo) info).getWorkspace();\r\n        } else {\r\n            limits = accessManager.getAccessLimits(user, (LayerGroupInfo) info, containers);\r\n            ws = ((LayerGroupInfo) info).getWorkspace();\r\n        }\r\n        if (limits != null) {\r\n            canRead = false;\r\n        }\r\n        if (ws != null && AdminRequest.get() != null) {\r\n            WorkspaceAccessLimits wl = accessManager.getAccessLimits(user, ws);\r\n            if (wl != null) {\r\n                if (!wl.isAdminable()) {\r\n                    canRead = false;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        throw new IllegalArgumentException(\"Can't build the wrapper policy for objects \" + \"other than workspace, layer or resource: \" + info);\r\n    }\r\n    final CatalogMode mode = limits != null ? limits.getMode() : CatalogMode.HIDE;\r\n    if (!canRead) {\r\n        if (mode == CatalogMode.HIDE) {\r\n            return WrapperPolicy.hide(limits);\r\n        } else if (mode == CatalogMode.MIXED) {\r\n            if (mixedModeBehavior == MixedModeBehavior.HIDE) {\r\n                return WrapperPolicy.hide(limits);\r\n            } else {\r\n                throw unauthorizedAccess(resourceName);\r\n            }\r\n        } else {\r\n            return WrapperPolicy.metadata(limits);\r\n        }\r\n    } else if (!canWrite) {\r\n        if (mode == CatalogMode.HIDE) {\r\n            return WrapperPolicy.readOnlyHide(limits);\r\n        } else {\r\n            return WrapperPolicy.readOnlyChallenge(limits);\r\n        }\r\n    }\r\n    return WrapperPolicy.readWrite(limits);\r\n}"
}, {
	"Path": "org.geoserver.security.SecureCatalogImpl.filterGroups",
	"Comment": "given a list of layer groups, returns a copy of it containing only the groups the user canaccess",
	"Method": "List<LayerGroupInfo> filterGroups(Authentication user,List<LayerGroupInfo> groups){\r\n    List<LayerGroupInfo> result = new ArrayList<LayerGroupInfo>();\r\n    for (LayerGroupInfo original : groups) {\r\n        LayerGroupInfo secured = checkAccess(user, original, MixedModeBehavior.HIDE);\r\n        if (secured != null)\r\n            result.add(secured);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.test.PolymorphismWfsTest.checkPolymorphismOnly",
	"Comment": "this is to test that polymorphism with no feature chaining works.",
	"Method": "void checkPolymorphismOnly(Document doc){\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f1']/ex:secondValue\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f1']/ex:secondValue/gsml:CGI_NumericValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f1']/ex:secondValue/gsml:CGI_TermValue\", doc);\r\n    assertXpathEvaluatesTo(\"1.0\", \"//ex:PolymorphicFeature[@gml:id='f1']/ex:secondValue/gsml:CGI_NumericValue/gsml:principalValue\", doc);\r\n    assertXpathEvaluatesTo(\"m\", \"//ex:PolymorphicFeature[@gml:id='f1']/ex:secondValue/gsml:CGI_NumericValue/gsml:principalValue/@uom\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f2']/ex:secondValue\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f2']/ex:secondValue/gsml:CGI_TermValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f2']/ex:secondValue/gsml:CGI_NumericValue\", doc);\r\n    assertXpathEvaluatesTo(\"0\", \"//ex:PolymorphicFeature[@gml:id='f2']/ex:secondValue/gsml:CGI_TermValue/gsml:value\", doc);\r\n    assertXpathEvaluatesTo(\"approximate\", \"//ex:PolymorphicFeature[@gml:id='f2']/ex:secondValue/gsml:CGI_TermValue/@gsml:qualifier\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f3']/ex:secondValue\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f3']/ex:secondValue/gsml:CGI_NumericValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f3']/ex:secondValue/gsml:CGI_TermValue\", doc);\r\n    assertXpathEvaluatesTo(\"0.0\", \"//ex:PolymorphicFeature[@gml:id='f3']/ex:secondValue/gsml:CGI_NumericValue/gsml:principalValue\", doc);\r\n    assertXpathEvaluatesTo(\"m\", \"//ex:PolymorphicFeature[@gml:id='f3']/ex:secondValue/gsml:CGI_NumericValue/gsml:principalValue/@uom\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f4']/ex:secondValue\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f5']/ex:secondValue\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f5']/ex:secondValue/gsml:CGI_TermValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f5']/ex:secondValue/gsml:CGI_NumericValue\", doc);\r\n    assertXpathEvaluatesTo(\"0\", \"//ex:PolymorphicFeature[@gml:id='f5']/ex:secondValue/gsml:CGI_TermValue/gsml:value\", doc);\r\n    assertXpathEvaluatesTo(\"approximate\", \"//ex:PolymorphicFeature[@gml:id='f5']/ex:secondValue/gsml:CGI_TermValue/@gsml:qualifier\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f6']/ex:secondValue\", doc);\r\n    assertXpathCount(1, \"//ex:PolymorphicFeature[@gml:id='f6']/ex:secondValue/gsml:CGI_TermValue\", doc);\r\n    assertXpathCount(0, \"//ex:PolymorphicFeature[@gml:id='f6']/ex:secondValue/gsml:CGI_NumericValue\", doc);\r\n    assertXpathEvaluatesTo(\"1000\", \"//ex:PolymorphicFeature[@gml:id='f6']/ex:secondValue/gsml:CGI_TermValue/gsml:value\", doc);\r\n    assertXpathEvaluatesTo(\"approximate\", \"//ex:PolymorphicFeature[@gml:id='f6']/ex:secondValue/gsml:CGI_TermValue/@gsml:qualifier\", doc);\r\n}"
}, {
	"Path": "org.vfny.geoserver.global.GeoServerFeatureSource.getBounds",
	"Comment": "retrieves the total extent of this featuresource.please note this extent will reflect the provided definitionquery.",
	"Method": "ReferencedEnvelope getBounds(ReferencedEnvelope getBounds,Query query){\r\n    try {\r\n        query = makeDefinitionQuery(query, schema);\r\n    } catch (IOException ex) {\r\n        return null;\r\n    }\r\n    return source.getBounds(query);\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexSolrTest.readResourceContent",
	"Comment": "helper method that reads the content of a resource to a string.",
	"Method": "String readResourceContent(String resource){\r\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\r\n    try (InputStream input = ComplexSolrTest.class.getResourceAsStream(resource)) {\r\n        IOUtils.copy(input, output);\r\n        return new String(output.toByteArray());\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(String.format(\"Error reading resource '%s' content.\", resource), exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.ModificationProxy.createList",
	"Comment": "wraps a list in a decorator which proxies each item in the list.",
	"Method": "List<T> createList(List<T> proxyList,Class<T> clazz){\r\n    return new list(proxyList, clazz);\r\n}"
}, {
	"Path": "org.geoserver.sldservice.rest.ClassifierTest.testQuantileContinuousSrtmReverse",
	"Comment": "same as testquantilecontinuoussrtm, but with reversed colormap",
	"Method": "void testQuantileContinuousSrtmReverse(){\r\n    final String restPath = RestBaseController.ROOT_PATH + \"/sldservice/cite:srtm/\" + getServiceUrl() + \".xml?\" + \"method=quantile&intervals=5&ramp=jet&fullSLD=true&continuous=true&reverse=true\";\r\n    Document dom = getAsDOM(restPath, 200);\r\n    RasterSymbolizer rs = getRasterSymbolizer(dom);\r\n    ColorMap cm = rs.getColorMap();\r\n    ColorMapEntry[] entries = cm.getColorMapEntries();\r\n    assertEquals(5, entries.length);\r\n    assertEntry(entries[0], -2, \"-2\", \"#FF0000\", 1);\r\n    assertEntry(entries[1], 292, \"292.984375\", \"#FF5500\", 1, 10);\r\n    assertEntry(entries[2], 536, \"538.804688\", \"#FFAA00\", 1, 10);\r\n    assertEntry(entries[3], 825, \"826.765625\", \"#FFFF00\", 1, 10);\r\n    assertEntry(entries[4], 1796, \"1796\", \"#0000FF\", 1);\r\n}"
}, {
	"Path": "org.geoserver.web.DefaultGeoServerNodeInfo.isNodeIdVisible",
	"Comment": "the element is visible if an admin is logged in, and the id is not null",
	"Method": "boolean isNodeIdVisible(WebMarkupContainer parent){\r\n    if (NODE_DATA.getId() == null) {\r\n        return false;\r\n    }\r\n    Authentication auth = ((GeoServerSession) parent.getSession()).getAuthentication();\r\n    if (auth == null || !auth.isAuthenticated() || auth instanceof AnonymousAuthenticationToken) {\r\n        return false;\r\n    } else {\r\n        GeoServerSecurityManager securityManager = GeoServerApplication.get().getSecurityManager();\r\n        return securityManager.checkAuthenticationForAdminRole(auth);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wms.eo.EoCatalogBuilder.enableDimensions",
	"Comment": "check presence of time dimension . enable all dimensions found.",
	"Method": "boolean enableDimensions(CoverageInfo ci,boolean enableDimensions,FeatureTypeInfo fi,String coverageName,StructuredGridCoverage2DReader reader){\r\n    Utilities.ensureNonNull(\"FeatureTypeInfo\", fi);\r\n    Utilities.ensureNonNull(\"reader\", reader);\r\n    List<DimensionDescriptor> dimensionDescriptors = reader.getDimensionDescriptors(coverageName == null ? reader.getGridCoverageNames()[0] : coverageName);\r\n    boolean timeDimension = false;\r\n    for (DimensionDescriptor dd : dimensionDescriptors) {\r\n        DimensionInfo di = new DimensionInfoImpl();\r\n        String key;\r\n        String units = dd.getUnits();\r\n        String symbol = dd.getUnitSymbol();\r\n        if (ResourceInfo.TIME.equalsIgnoreCase(dd.getName())) {\r\n            timeDimension = true;\r\n            key = ResourceInfo.TIME;\r\n            units = DimensionInfo.TIME_UNITS;\r\n        } else if (ResourceInfo.ELEVATION.equalsIgnoreCase(dd.getName())) {\r\n            key = ResourceInfo.ELEVATION;\r\n            units = DimensionInfo.ELEVATION_UNITS;\r\n            symbol = DimensionInfo.ELEVATION_UNIT_SYMBOL;\r\n        } else {\r\n            key = ResourceInfo.CUSTOM_DIMENSION_PREFIX + dd.getName();\r\n        }\r\n        di.setEnabled(true);\r\n        di.setAttribute(dd.getStartAttribute());\r\n        di.setEndAttribute(dd.getEndAttribute());\r\n        di.setPresentation(DimensionPresentation.LIST);\r\n        di.setUnits(units);\r\n        di.setUnitSymbol(symbol);\r\n        fi.getMetadata().put(key, di);\r\n    }\r\n    return timeDimension;\r\n}"
}, {
	"Path": "org.geoserver.wps.remote.plugin.XMPPClient.getFixedInputs",
	"Comment": "utility method to extract the process inputs accordingly to whatever declared from theendpoint.",
	"Method": "Object getFixedInputs(Map<String, Object> input){\r\n    Map<String, Object> fixedInputs = new HashMap<String, Object>();\r\n    for (Entry<String, Object> entry : input.entrySet()) {\r\n        final String key = entry.getKey();\r\n        final Object value = entry.getValue();\r\n        Object fixedValue = value;\r\n        if (value instanceof RawData) {\r\n            fixedValue = IOUtils.toString(((RawData) value).getInputStream(), \"UTF-8\");\r\n        } else if (value instanceof List) {\r\n            List<Object> values = (List<Object>) value;\r\n            if (values != null && values.size() > 0 && values.get(0) instanceof RawData) {\r\n                fixedValue = new ArrayList<String>();\r\n                for (Object o : values) {\r\n                    ((List<String>) fixedValue).add(IOUtils.toString(((RawData) o).getInputStream(), \"UTF-8\"));\r\n                }\r\n            }\r\n        }\r\n        if (value != null && !(value instanceof JSONNull)) {\r\n            fixedInputs.put(key, fixedValue);\r\n        }\r\n    }\r\n    return fixedInputs;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.getFeatureTypeInfo",
	"Comment": "get the featuretypeinfo for a featuretype by the layername that would be used in a request.",
	"Method": "FeatureTypeInfo getFeatureTypeInfo(QName typename,FeatureTypeInfo getFeatureTypeInfo,String typename){\r\n    return getFeatureTypeInfo(resolveLayerName(typename));\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexSolrTest.loadFixtureProperties",
	"Comment": "helper method that just loads the fixture files properties.",
	"Method": "Properties loadFixtureProperties(File fixtureFile){\r\n    Properties properties = new Properties();\r\n    try (InputStream input = new FileInputStream(fixtureFile)) {\r\n        properties.load(input);\r\n        return properties;\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(String.format(\"Error reading fixture file '%s'.\", fixtureFile.getAbsolutePath()), exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.encodeAttributes",
	"Comment": "utility method that encode an attributes map, only the attribute name local part will beused. attributes with a null value will not be encoded. this method assumes that it isalready in an array context.",
	"Method": "void encodeAttributes(Map<NameImpl, String> attributes){\r\n    attributes.forEach((name, value) -> {\r\n        if (value != null) {\r\n            jsonWriter.object();\r\n            jsonWriter.key(name.getLocalPart()).value(value);\r\n            jsonWriter.endObject();\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDimensionsSubsetHelper.domainContainsPoint",
	"Comment": "check whether the provided domain contains the specified slicepoint.",
	"Method": "boolean domainContainsPoint(Object slicePoint,TreeSet<Object> domain){\r\n    if (slicePoint instanceof Date) {\r\n        Date sliceDate = (Date) slicePoint;\r\n        for (Object curr : domain) {\r\n            if (curr instanceof Date) {\r\n                Date date = (Date) curr;\r\n                int result = date.compareTo(sliceDate);\r\n                if (result > 0) {\r\n                    return false;\r\n                } else if (result == 0) {\r\n                    return true;\r\n                }\r\n            } else if (curr instanceof DateRange) {\r\n                DateRange range = (DateRange) curr;\r\n                if (range.contains(sliceDate)) {\r\n                    return true;\r\n                } else if (range.getMaxValue().compareTo(sliceDate) < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    } else if (slicePoint instanceof Number) {\r\n        Number sliceNumber = (Number) slicePoint;\r\n        for (Object curr : domain) {\r\n            if (curr instanceof Number) {\r\n                Double num = (Double) curr;\r\n                int result = num.compareTo((Double) sliceNumber);\r\n                if (result > 0) {\r\n                    return false;\r\n                } else if (result == 0) {\r\n                    return true;\r\n                }\r\n            } else if (curr instanceof NumberRange) {\r\n                NumberRange range = (NumberRange) curr;\r\n                if (range.contains(sliceNumber)) {\r\n                    return true;\r\n                } else if (range.getMaxValue().compareTo(sliceNumber) < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.gwc.GWCIntegrationTest.testRemoveCachedLayer",
	"Comment": "test that removing a layer from the catalog also removes its tile cache.",
	"Method": "void testRemoveCachedLayer(){\r\n    String layerName = getLayerId(MockData.BASIC_POLYGONS);\r\n    assertEquals(\"cite:BasicPolygons\", layerName);\r\n    String cacheDirectory = \"gwc/cite_BasicPolygons\";\r\n    String cachedTile = \"gwc/cite_BasicPolygons/EPSG_4326_00/0_0/00_00.png\";\r\n    GeoServerResourceLoader loader = getResourceLoader();\r\n    assertNull(\"Unexpected cache directory \" + cacheDirectory, loader.find(cacheDirectory));\r\n    assertNull(\"Unexpected cached tile \" + cachedTile, loader.find(cachedTile));\r\n    MockHttpServletResponse response = getAsServletResponse(\"gwc/service/wmts\" + \"?request=GetTile\" + \"&layer=\" + layerName + \"&format=image/png\" + \"&tilematrixset=EPSG:4326\" + \"&tilematrix=EPSG:4326:0\" + \"&tilerow=0\" + \"&tilecol=0\");\r\n    assertEquals(200, response.getStatus());\r\n    assertEquals(\"image/png\", response.getContentType());\r\n    assertNotNull(\"Missing cache directory \" + cacheDirectory, loader.find(cacheDirectory));\r\n    assertNotNull(\"Missing cached tile \" + cachedTile, loader.find(cachedTile));\r\n    getCatalog().remove(getCatalog().getLayerByName(layerName));\r\n    assertNull(\"Unexpected cache directory \" + cacheDirectory, loader.find(cacheDirectory));\r\n    assertNull(\"Unexpected cached tile \" + cachedTile, loader.find(cachedTile));\r\n}"
}, {
	"Path": "org.geoserver.rest.catalog.StyleController.writeStyleRaw",
	"Comment": "writes the content of an input stream to a style resource, without validation",
	"Method": "void writeStyleRaw(StyleInfo info,InputStream input){\r\n    try {\r\n        catalog.getResourcePool().writeStyle(info, input);\r\n    } finally {\r\n        IOUtils.closeQuietly(input);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTest.copyStyle",
	"Comment": "helper method that copies a style file to the provided geoserver instance.",
	"Method": "void copyStyle(GeoServerInstance instance,String resource,String fileName){\r\n    Resource styleResource = instance.getDataDirectory().get(\"styles\" + File.separator + fileName);\r\n    try (OutputStream output = styleResource.out();\r\n        InputStream input = this.getClass().getResourceAsStream(resource)) {\r\n        IOUtils.copy(input, output);\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error copying test style.\", exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.util.ReaderUtils.getAttribute",
	"Comment": "getintattribute purpose.used to help with xml manipulations. returns the first child integer attribute of thespecified name. an exception occurs when the node is required and not found.",
	"Method": "String getAttribute(Element elem,String attName,boolean mandatory){\r\n    if (elem == null) {\r\n        if (mandatory) {\r\n            throw new NullPointerException();\r\n        }\r\n        return \"\";\r\n    }\r\n    Attr att = elem.getAttributeNode(attName);\r\n    String value = null;\r\n    if (att != null) {\r\n        value = att.getValue();\r\n    }\r\n    if (mandatory) {\r\n        if (att == null) {\r\n            throw new Exception(\"element \" + elem.getNodeName() + \" does not contains an attribute named \" + attName);\r\n        } else if (\"\".equals(value)) {\r\n            throw new Exception(\"attribute \" + attName + \"in element \" + elem.getNodeName() + \" is empty\");\r\n        }\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.geoserver.config.util.XStreamServiceLoader.initializeService",
	"Comment": "fills in all the bits that are normally not loaded automatically by xstream, such as emptycollections",
	"Method": "void initializeService(ServiceInfo info){\r\n    initialize((T) info);\r\n}"
}, {
	"Path": "org.vfny.geoserver.crs.OvverideTransformationsTest.testNadCon",
	"Comment": "see if we can use the stgeorge grid shift files as the espg db would like us to",
	"Method": "void testNadCon(){\r\n    CoordinateReferenceSystem crs4138 = CRS.decode(\"EPSG:4138\");\r\n    CoordinateReferenceSystem crs4326 = CRS.decode(\"EPSG:4326\");\r\n    MathTransform mt = CRS.findMathTransform(crs4138, crs4326);\r\n    assertTrue(mt.toWKT().contains(\"NADCON\"));\r\n    double[] src = new double[] { -169.625, 56.575 };\r\n    double[] expected = new double[] { -169.62744, 56.576034 };\r\n    double[] p = new double[2];\r\n    mt.transform(src, 0, p, 0, 1);\r\n    assertEquals(expected[0], p[0], 1e-6);\r\n    assertEquals(expected[1], p[1], 1e-6);\r\n}"
}, {
	"Path": "org.geoserver.geofence.config.GeoFenceConfiguration.setAcceptedRoles",
	"Comment": "list of mutually exclusive roles used for rule matching when userolestofilter is true.",
	"Method": "void setAcceptedRoles(String acceptedRoles){\r\n    if (acceptedRoles == null) {\r\n        acceptedRoles = \"\";\r\n    }\r\n    this.acceptedRoles = acceptedRoles;\r\n    roles = Lists.newArrayList(acceptedRoles.split(\",\"));\r\n}"
}, {
	"Path": "org.geoserver.csw.store.simple.SimpleCatalogStore.getRepositoryItem",
	"Comment": "this dummy implementation returns the file backing the record, verbatim",
	"Method": "RepositoryItem getRepositoryItem(String recordId){\r\n    SimpleRecordIterator it = new SimpleRecordIterator(root, 0);\r\n    while (it.hasNext()) {\r\n        Feature f = it.next();\r\n        if (recordId.equals(f.getIdentifier().getID())) {\r\n            final Resource resource = it.getLastFile();\r\n            return new RepositoryItem() {\r\n                @Override\r\n                public String getMime() {\r\n                    return \"application/xml\";\r\n                }\r\n                @Override\r\n                public InputStream getContents() throws IOException {\r\n                    return resource.in();\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.csw.store.simple.SimpleCatalogStore.getRepositoryItem",
	"Comment": "this dummy implementation returns the file backing the record, verbatim",
	"Method": "RepositoryItem getRepositoryItem(String recordId){\r\n    return \"application/xml\";\r\n}"
}, {
	"Path": "org.geoserver.csw.store.simple.SimpleCatalogStore.getRepositoryItem",
	"Comment": "this dummy implementation returns the file backing the record, verbatim",
	"Method": "RepositoryItem getRepositoryItem(String recordId){\r\n    return resource.in();\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.Dimension.getPagedDomainValues",
	"Comment": "returns the domain summary. if the count is lower than expandlimit then only thecount will be returned, otherwise min and max will also be returned",
	"Method": "DomainSummary getPagedDomainValues(FeatureCollection features,String attribute,int maxValues,DomainSummary getPagedDomainValues,Query query,int maxNumberOfValues,SortOrder sortOrder){\r\n    Set uniqueValues = DimensionsUtils.getUniqueValues(features, attribute, maxValues);\r\n    return new DomainSummary(uniqueValues);\r\n}"
}, {
	"Path": "org.geoserver.kml.utils.KmlCentroidBuilder.geometryCentroid",
	"Comment": "returns the centroid of the geometry, handling a geometry collection.in the case of a collection a multi point containing the centroid of each geometry in thecollection is calculated. the first point in the multi point is returned as the controid.the opts parameter is used to provide additional options controlling how thecentroid is computed.",
	"Method": "Coordinate geometryCentroid(Geometry g,Coordinate geometryCentroid,Geometry g,Envelope bbox,KmlCentroidOptions opts){\r\n    if (opts == null) {\r\n        opts = KmlCentroidOptions.DEFAULT;\r\n    }\r\n    if (opts.isClip()) {\r\n        if (bbox != null) {\r\n            g = clipGeometry(g, bbox);\r\n        } else {\r\n            LOG.warning(\"Clip option specified for kml centroids, but no bbox available\");\r\n        }\r\n    }\r\n    if (g instanceof GeometryCollection) {\r\n        g = selectRepresentativeGeometry((GeometryCollection) g);\r\n    }\r\n    if (g == null) {\r\n        return null;\r\n    } else if (g instanceof Point) {\r\n        return g.getCoordinate();\r\n    } else if (g instanceof LineString) {\r\n        LineString line = (LineString) g;\r\n        LengthIndexedLine lil = new LengthIndexedLine(line);\r\n        return lil.extractPoint(line.getLength() / 2.0);\r\n    } else if (g instanceof Polygon) {\r\n        if (opts.isContain()) {\r\n            try {\r\n                Point p = RendererUtilities.sampleForInternalPoint((Polygon) g, null, null, null, -1, opts.getSamples());\r\n                if (p != null && !p.isEmpty()) {\r\n                    return p.getCoordinate();\r\n                }\r\n            } catch (Exception e) {\r\n                LOG.log(Level.WARNING, \"Unable to calculate central point for polygon\", e);\r\n            }\r\n        }\r\n    }\r\n    return g.getCentroid().getCoordinate();\r\n}"
}, {
	"Path": "org.geoserver.security.file.FileWatcher.start",
	"Comment": "used to register filewatcher as a resource notification listener.",
	"Method": "void start(){\r\n    resource.addListener(this);\r\n}"
}, {
	"Path": "org.geoserver.wms.animate.Animator.produce",
	"Comment": "produce method. returns the full animation webmap request.",
	"Method": "org.geoserver.wms.WebMap produce(GetMapRequest request,WebMapService wms,WMS wmsConfiguration){\r\n    FrameCatalog frameCatalog = initRequestManager(request, wms, wmsConfiguration);\r\n    if (frameCatalog == null) {\r\n        throw new RuntimeException(\"Animator initialization error!\");\r\n    }\r\n    if (request.getFormat() == null) {\r\n        request.setFormat(GIF_ANIMATED_FORMAT);\r\n    }\r\n    if (frameCatalog.getParameter().equalsIgnoreCase(\"LAYERS\")) {\r\n        List<String> layers0 = Arrays.asList(frameCatalog.getValues()[0].replaceAll(\"\\\\\\\\,\", \",\").split(\"\\\\s*,\\\\s*\"));\r\n        LayerParser parser = new LayerParser(wmsConfiguration);\r\n        List<MapLayerInfo> layers = parser.parseLayerInfos(layers0, request.getRemoteOwsURL(), request.getRemoteOwsType());\r\n        request.setLayers(layers);\r\n    }\r\n    request = DefaultWebMapService.autoSetMissingProperties(request);\r\n    if (frameCatalog.getParameter().equalsIgnoreCase(\"LAYERS\")) {\r\n        Envelope bbox = request.getBbox();\r\n        request.getRawKvp().put(\"BBOX\", bbox.getMinX() + \",\" + request.getBbox().getMinY() + \",\" + request.getBbox().getMaxX() + \",\" + request.getBbox().getMaxY());\r\n        request.getRawKvp().put(\"WIDTH\", String.valueOf(request.getWidth()));\r\n        request.getRawKvp().put(\"HEIGHT\", String.valueOf(request.getHeight()));\r\n    }\r\n    FrameCatalogVisitor visitor = new FrameCatalogVisitor();\r\n    frameCatalog.getFrames(visitor);\r\n    RenderedImage imageList = visitor.produce(frameCatalog.getWmsConfiguration());\r\n    WebMap wmsResponse = wms.getMap(request);\r\n    return new RenderedImageMap(((RenderedImageMap) wmsResponse).getMapContext(), imageList, wmsResponse.getMimeType());\r\n}"
}, {
	"Path": "org.geoserver.wfs.xml.NameSpaceTranslatorFactory.getInstance",
	"Comment": "getinstance purpose.completes the singleton pattern of this factory class.",
	"Method": "NameSpaceTranslatorFactory getInstance(){\r\n    return instance;\r\n}"
}, {
	"Path": "org.geoserver.security.impl.DigestAuthUtils.generateDigest",
	"Comment": "computes the response portion of a digest authentication header. both the serverand user agent should compute the response independently. provided as a staticmethod to simplify the coding of user agents.",
	"Method": "String generateDigest(boolean passwordAlreadyEncoded,String username,String realm,String password,String httpMethod,String uri,String qop,String nonce,String nc,String cnonce){\r\n    String a1Md5 = null;\r\n    String a2 = httpMethod + \":\" + uri;\r\n    String a2Md5 = md5Hex(a2);\r\n    if (passwordAlreadyEncoded) {\r\n        a1Md5 = password;\r\n    } else {\r\n        a1Md5 = DigestAuthUtils.encodePasswordInA1Format(username, realm, password);\r\n    }\r\n    String digest;\r\n    if (qop == null) {\r\n        digest = a1Md5 + \":\" + nonce + \":\" + a2Md5;\r\n    } else if (\"auth\".equals(qop)) {\r\n        digest = a1Md5 + \":\" + nonce + \":\" + nc + \":\" + cnonce + \":\" + qop + \":\" + a2Md5;\r\n    } else {\r\n        throw new IllegalArgumentException(\"This method does not support a qop: '\" + qop + \"'\");\r\n    }\r\n    String digestMd5 = new String(md5Hex(digest));\r\n    return digestMd5;\r\n}"
}, {
	"Path": "org.geoserver.csw.GetRecordsTest.testUnsupportedOutputFormat",
	"Comment": "from cite compliance, throw an error the output format is not supported",
	"Method": "void testUnsupportedOutputFormat(){\r\n    String request = \"csw?service=CSW&version=2.0.2&request=GetRecords&typeNames=csw:Record&outputFormat=application/xhtml+xml\";\r\n    Document d = getAsDOM(request);\r\n    checkOws10Exception(d, ServiceException.INVALID_PARAMETER_VALUE, \"outputFormat\");\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.getCatalog",
	"Comment": "accessor for global catalog instance from the test application context.",
	"Method": "Catalog getCatalog(){\r\n    return (Catalog) applicationContext.getBean(\"catalog\");\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexMongoDBSupport.createFixtureExample",
	"Comment": "write fixture example file for mongodb, if the file already exists nothing will be done.",
	"Method": "void createFixtureExample(File fixtureFile){\r\n    File exampleFixtureFile = new File(fixtureFile.getAbsolutePath() + \".example\");\r\n    if (exampleFixtureFile.exists()) {\r\n        return;\r\n    }\r\n    Properties properties = new Properties();\r\n    properties.put(\"mongo.host\", \"127.0.0.1\");\r\n    properties.put(\"mongo.port\", \"27017\");\r\n    try (OutputStream output = new FileOutputStream(exampleFixtureFile)) {\r\n        properties.store(output, \"This is an example fixture. Update the values \" + \"and remove the .example suffix to enable the test\");\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(String.format(\"Error writing example fixture file '%s'.\", fixtureFile.getAbsolutePath()), exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.CatalogBuilder.removeWorkspace",
	"Comment": "removes a workspace from the catalog.the recursive flag controls whether objects linked to the workspace such asstores should also be deleted.",
	"Method": "void removeWorkspace(WorkspaceInfo workspace,boolean recursive){\r\n    if (recursive) {\r\n        workspace.accept(new CascadeDeleteVisitor(catalog));\r\n    } else {\r\n        catalog.remove(workspace);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.WPSTestSupport.submitAsynchronous",
	"Comment": "submits an asynch execute request and waits for the final result, which is then returned",
	"Method": "Document submitAsynchronous(String xml,long maxWaitSeconds){\r\n    Document dom = postAsDOM(\"wps\", xml);\r\n    assertXpathExists(\"//wps:ProcessAccepted\", dom);\r\n    XpathEngine xpath = XMLUnit.newXpathEngine();\r\n    String fullStatusLocation = xpath.evaluate(\"//wps:ExecuteResponse/@statusLocation\", dom);\r\n    String statusLocation = fullStatusLocation.substring(fullStatusLocation.indexOf('?') - 3);\r\n    return waitForProcessEnd(statusLocation, maxWaitSeconds);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.assertStatusCodeForPost",
	"Comment": "assert that a post request to a path will have a particular status code for the response.",
	"Method": "void assertStatusCodeForPost(int code,String path,String body,String type){\r\n    assertStatusCodeForRequest(code, \"POST\", path, body, type);\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaTestSupport.assertXpathCount",
	"Comment": "assert that there are count matches of and xpath expression in a document.",
	"Method": "void assertXpathCount(int count,String xpath,Document document){\r\n    assertEquals(count, getMatchingNodes(xpath, document).getLength());\r\n}"
}, {
	"Path": "org.geoserver.nsg.versioning.TimeVersioningTest.buildXpathEngine",
	"Comment": "helper method that builds a xpath engine using some predefined namespaces and all the catalognamespaces. the provided namespaces will be added overriding any existing namespace.",
	"Method": "XpathEngine buildXpathEngine(String namespaces){\r\n    XpathEngine xpathEngine = XMLUnit.newXpathEngine();\r\n    Map<String, String> finalNamespaces = new HashMap();\r\n    finalNamespaces.put(\"ows\", \"http://www.opengis.net/ows\");\r\n    finalNamespaces.put(\"ogc\", \"http://www.opengis.net/ogc\");\r\n    finalNamespaces.put(\"xs\", \"http://www.w3.org/2001/XMLSchema\");\r\n    finalNamespaces.put(\"xsd\", \"http://www.w3.org/2001/XMLSchema\");\r\n    finalNamespaces.put(\"xlink\", \"http://www.w3.org/1999/xlink\");\r\n    finalNamespaces.put(\"xsi\", \"http://www.w3.org/2001/XMLSchema-instance\");\r\n    getCatalog().getNamespaces().forEach(namespace -> finalNamespaces.put(namespace.getPrefix(), namespace.getURI()));\r\n    if (namespaces.length % 2 != 0) {\r\n        throw new RuntimeException(\"Invalid number of namespaces provided.\");\r\n    }\r\n    for (int i = 0; i < namespaces.length; i += 2) {\r\n        finalNamespaces.put(namespaces[i], namespaces[i + 1]);\r\n    }\r\n    xpathEngine.setNamespaceContext(new SimpleNamespaceContext(finalNamespaces));\r\n    return xpathEngine;\r\n}"
}, {
	"Path": "org.geoserver.catalog.ResourcePool.getEntityResolverProvider",
	"Comment": "returns the entity resolver provider injected in the code doing xml parsing",
	"Method": "EntityResolverProvider getEntityResolverProvider(){\r\n    return entityResolverProvider;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findOrCreateStoreDir",
	"Comment": "returns the directory in which a stores configuration is persisted, if the directory does notexist it is created.",
	"Method": "File findOrCreateStoreDir(StoreInfo store){\r\n    Resource resource = get(store);\r\n    return resource.dir();\r\n}"
}, {
	"Path": "org.geoserver.kml.icons.IconRenderer.renderIcon",
	"Comment": "render a point icon for the given style. this operation will fail if any style properties inthe given style are dynamic. this method is intended to work with styles that have beenpreprocessed by iconpropertyextractor and iconpropertyinjector.",
	"Method": "BufferedImage renderIcon(Style style){\r\n    int size = findIconSize(style) + 2;\r\n    MapContent mapContent = new MapContent();\r\n    mapContent.addLayer(new FeatureLayer(sampleData, style));\r\n    BufferedImage image = new BufferedImage(size * Icons.RENDER_SCALE_FACTOR, size * Icons.RENDER_SCALE_FACTOR, BufferedImage.TYPE_INT_ARGB);\r\n    Graphics2D graphics = image.createGraphics();\r\n    graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\r\n    graphics.scale(Icons.RENDER_SCALE_FACTOR, Icons.RENDER_SCALE_FACTOR);\r\n    StreamingRenderer renderer = new StreamingRenderer();\r\n    renderer.setMapContent(mapContent);\r\n    try {\r\n        try {\r\n            renderer.paint(graphics, new Rectangle(size, size), sampleArea);\r\n        } finally {\r\n            graphics.dispose();\r\n        }\r\n    } finally {\r\n        mapContent.dispose();\r\n    }\r\n    return image;\r\n}"
}, {
	"Path": "org.geoserver.catalog.Styles.sld",
	"Comment": "convenience method to wrap a userstyle in a styledlayerdescriptor object.this method wraps the userstyle in a namedlayer, and wraps the result in astyledlayerdescriptor.",
	"Method": "StyledLayerDescriptor sld(Style style){\r\n    StyledLayerDescriptor sld = styleFactory.createStyledLayerDescriptor();\r\n    NamedLayer layer = styleFactory.createNamedLayer();\r\n    layer.setName(style.getName());\r\n    sld.addStyledLayer(layer);\r\n    layer.addStyle(style);\r\n    return sld;\r\n}"
}, {
	"Path": "org.geoserver.gwc.layer.StyleParameterFilter.getRealDefault",
	"Comment": "returns the default style name, or an empty string if set to use the layer specified default",
	"Method": "String getRealDefault(){\r\n    return super.getDefaultValue();\r\n}"
}, {
	"Path": "org.geoserver.security.impl.SecureTreeNode.getNode",
	"Comment": "utility method that drills down from the current node using the specified list of childnames, and returns an element only if it fully matches the provided path",
	"Method": "SecureTreeNode getNode(String pathElements){\r\n    SecureTreeNode curr = this;\r\n    for (int i = 0; i < pathElements.length; i++) {\r\n        final SecureTreeNode next = curr.getChild(pathElements[i]);\r\n        if (next == null) {\r\n            return null;\r\n        } else {\r\n            curr = next;\r\n        }\r\n    }\r\n    return curr;\r\n}"
}, {
	"Path": "org.geoserver.nsg.pagination.random.IndexOutputFormat.storeGetFeature",
	"Comment": "helper method that serialize getfeature request, store it in the file system and associate itwith resultsetid",
	"Method": "void storeGetFeature(String resultSetId,Request request){\r\n    try {\r\n        IndexConfigurationManager.READ_WRITE_LOCK.writeLock().lock();\r\n        DataStore dataStore = this.indexConfiguration.getCurrentDataStore();\r\n        SimpleFeatureStore featureStore = (SimpleFeatureStore) dataStore.getFeatureSource(IndexConfigurationManager.STORE_SCHEMA_NAME);\r\n        SimpleFeatureBuilder builder = new SimpleFeatureBuilder(featureStore.getSchema());\r\n        Long now = System.currentTimeMillis();\r\n        builder.add(resultSetId);\r\n        builder.add(now);\r\n        builder.add(now);\r\n        SimpleFeature feature = builder.buildFeature(null);\r\n        SimpleFeatureCollection collection = new ListFeatureCollection(featureStore.getSchema(), Arrays.asList(feature));\r\n        featureStore.addFeatures(collection);\r\n        Resource storageResource = this.indexConfiguration.getStorageResource();\r\n        Map kvp = request.getKvp();\r\n        Map rawKvp = request.getRawKvp();\r\n        RequestData data = new RequestData();\r\n        data.setKvp(kvp);\r\n        data.setRawKvp(rawKvp);\r\n        if (kvp.containsKey(\"POST_REQUEST\")) {\r\n            data.setPostRequest((String) kvp.get(\"POST_REQUEST\"));\r\n        }\r\n        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(storageResource.dir(), resultSetId + \".feature\")))) {\r\n            oos.writeObject(data);\r\n        }\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error storing feature.\", exception);\r\n    } finally {\r\n        IndexConfigurationManager.READ_WRITE_LOCK.writeLock().unlock();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.RasterTimeDimensionTest.formatDate",
	"Comment": "helper method that simply formats a date using the iso8601 formatter.",
	"Method": "String formatDate(Date date){\r\n    ISO8601Formatter formatter = new ISO8601Formatter();\r\n    return formatter.format(date);\r\n}"
}, {
	"Path": "org.geoserver.wms.capabilities.DimensionHelper.getCustomDomainRepresentation",
	"Comment": "builds the proper presentation given the specified value domain",
	"Method": "String getCustomDomainRepresentation(DimensionInfo dimension,List<String> values){\r\n    String metadata = null;\r\n    final StringBuilder buff = new StringBuilder();\r\n    if (DimensionPresentation.LIST == dimension.getPresentation()) {\r\n        for (String value : values) {\r\n            buff.append(value.trim());\r\n            buff.append(\",\");\r\n        }\r\n        metadata = buff.substring(0, buff.length() - 1);\r\n    } else if (DimensionPresentation.DISCRETE_INTERVAL == dimension.getPresentation()) {\r\n        buff.append(values.get(0));\r\n        buff.append(\"/\");\r\n        buff.append(values.get(0));\r\n        buff.append(\"/\");\r\n        final BigDecimal resolution = dimension.getResolution();\r\n        if (resolution != null) {\r\n            buff.append(resolution);\r\n        }\r\n        metadata = buff.toString();\r\n    }\r\n    return metadata;\r\n}"
}, {
	"Path": "org.geoserver.catalog.NamespaceWorkspaceConsistencyListener.handleRemoveEvent",
	"Comment": "when a namespace is removed, makes sure the associated workspace is removed as well.",
	"Method": "void handleRemoveEvent(CatalogRemoveEvent event){\r\n    if (event.getSource() instanceof NamespaceInfo) {\r\n        NamespaceInfo ns = (NamespaceInfo) event.getSource();\r\n        WorkspaceInfo ws = catalog.getWorkspaceByName(ns.getPrefix());\r\n        if (ws != null) {\r\n            catalog.remove(ws);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.InsertElementHandler.checkFeatureCoordinatesRange",
	"Comment": "checks that all features coordinates are within the expected coordinate range",
	"Method": "void checkFeatureCoordinatesRange(SimpleFeatureCollection collection){\r\n    List types = collection.getSchema().getAttributeDescriptors();\r\n    SimpleFeatureIterator fi = collection.features();\r\n    try {\r\n        while (fi.hasNext()) {\r\n            SimpleFeature f = fi.next();\r\n            for (int i = 0; i < types.size(); i++) {\r\n                if (types.get(i) instanceof GeometryDescriptor) {\r\n                    GeometryDescriptor gat = (GeometryDescriptor) types.get(i);\r\n                    if (gat.getCoordinateReferenceSystem() != null) {\r\n                        Geometry geom = (Geometry) f.getAttribute(i);\r\n                        if (geom != null)\r\n                            JTS.checkCoordinatesRange(geom, gat.getCoordinateReferenceSystem());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        fi.close();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTestsUtils.configurationDifferences",
	"Comment": "return the configuration differences between two geoserver instances.",
	"Method": "List<InfoDiff> configurationDifferences(GeoServerInstance instanceA,GeoServerInstance instanceB){\r\n    ConfigurationDiffVisitor visitor = new ConfigurationDiffVisitor(instanceA.getGeoServer(), instanceB.getGeoServer());\r\n    return visitor.differences();\r\n}"
}, {
	"Path": "org.geoserver.util.XmlTestUtil.hasOneNode",
	"Comment": "match a document where one node matches the xpath expression.",
	"Method": "Matcher<Document> hasOneNode(String xPath,Matcher<? super Node> matcher,Matcher<Document> hasOneNode,String xPath){\r\n    return hasOneNode(xPath, any(Node.class));\r\n}"
}, {
	"Path": "org.geoserver.rest.util.RESTUtils.isZipMediaType",
	"Comment": "determines if the specified media type represents a zip stream.",
	"Method": "boolean isZipMediaType(HttpServletRequest request,boolean isZipMediaType,MediaType mediaType){\r\n    return ZIP_MIME_TYPES.contains(mediaType.toString());\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.ImportProcess.buildAttributeMapping",
	"Comment": "applies a set of heuristics to find which target attribute corresponds to a certain inputattribute",
	"Method": "Map<String, String> buildAttributeMapping(SimpleFeatureType sourceType,SimpleFeatureType targetType){\r\n    Set<String> sourceNames = new HashSet<String>();\r\n    for (AttributeDescriptor sd : sourceType.getAttributeDescriptors()) {\r\n        sourceNames.add(sd.getLocalName());\r\n    }\r\n    Map<String, String> result = new HashMap<String, String>();\r\n    for (String name : sourceNames) {\r\n        if (targetType.getDescriptor(name) != null) {\r\n            result.put(name, name);\r\n        }\r\n    }\r\n    sourceNames.removeAll(result.keySet());\r\n    for (String name : sourceNames) {\r\n        for (AttributeDescriptor td : targetType.getAttributeDescriptors()) {\r\n            if (td.getLocalName().equalsIgnoreCase(name)) {\r\n                result.put(name, td.getLocalName());\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    sourceNames.removeAll(result.keySet());\r\n    for (String name : sourceNames) {\r\n        String loName = name.toLowerCase();\r\n        for (AttributeDescriptor td : targetType.getAttributeDescriptors()) {\r\n            String tdName = td.getLocalName().toLowerCase();\r\n            if (loName.startsWith(tdName)) {\r\n                result.put(name, td.getLocalName());\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    sourceNames.removeAll(result.keySet());\r\n    if (targetType.getGeometryDescriptor() != null && \"the_geom\".equals(targetType.getGeometryDescriptor().getLocalName()) && !\"the_geom\".equalsIgnoreCase(sourceType.getGeometryDescriptor().getLocalName())) {\r\n        result.put(sourceType.getGeometryDescriptor().getLocalName(), \"the_geom\");\r\n    }\r\n    if (!sourceNames.isEmpty()) {\r\n        LOGGER.warning(\"Could not match the following attributes \" + sourceNames + \" to the target feature type ones: \" + targetType);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.getMasterPasswordForREST",
	"Comment": "get master password for rest configuratonthe method inspects the stack trace to check for an authorized calling method. theauthenticated principal has to be an administratorif authorization fails, an ioexception is thrown",
	"Method": "char[] getMasterPasswordForREST(){\r\n    if (checkAuthenticationForAdminRole() == false) {\r\n        throw new IOException(\"Unauthorized user tries to read master password\");\r\n    }\r\n    String[][] allowedMethods = new String[][] { { \"org.geoserver.rest.security.MasterPasswordController\", \"masterPasswordGet\" } };\r\n    String result = checkStackTrace(10, allowedMethods);\r\n    if (result != null) {\r\n        throw new IOException(\"Unauthorized method wants to read master password\\n\" + result);\r\n    }\r\n    return getMasterPassword();\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.DownloadUtilities.find",
	"Comment": "looks for a valid ppio given the provided mime type and process parameter.",
	"Method": "ProcessParameterIO find(Parameter<?> p,ApplicationContext context,String mime,boolean lenient){\r\n    if (lenient) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Lenient approach used\");\r\n        }\r\n        return ProcessParameterIO.find(p, context, mime);\r\n    }\r\n    if (p.type.isEnum()) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Trying to find the PPIO for the Enum = \" + p.type);\r\n        }\r\n        return new LiteralPPIO(p.type);\r\n    }\r\n    List<ProcessParameterIO> all = ProcessParameterIO.findAll(p, context);\r\n    if (all.isEmpty()) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"No PPIO found for the parameter \" + p.getName());\r\n        }\r\n        return null;\r\n    }\r\n    if (mime != null) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Trying to search for a PPIO for the parameter \" + p.getName());\r\n        }\r\n        for (ProcessParameterIO ppio : all) {\r\n            if (ppio instanceof ComplexPPIO && ((ComplexPPIO) ppio).getMimeType().equals(mime)) {\r\n                return ppio;\r\n            }\r\n        }\r\n    }\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.log(Level.FINE, \"Unable to find a PPIO for the parameter \" + p.getName());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.ows.util.RequestObjectLogger.isRequestObject",
	"Comment": "determines if an object is the request object.subclasses should override this to do explict checks for the request object.",
	"Method": "boolean isRequestObject(Object obj){\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.web.data.workspace.WorkspaceNewPage.handleOnSubmit",
	"Comment": "helper method that takes care of storing the user entered workspace information andassociated namespace. this method makes sure that or both the workspace and namespace aresuccessfully stored or none is stored.",
	"Method": "void handleOnSubmit(Form form){\r\n    Catalog catalog = getCatalog();\r\n    WorkspaceInfo workspace = (WorkspaceInfo) form.getModelObject();\r\n    NamespaceInfo namespace = catalog.getFactory().createNamespace();\r\n    namespace.setPrefix(workspace.getName());\r\n    namespace.setURI(nsUriTextField.getDefaultModelObjectAsString());\r\n    namespace.setIsolated(workspace.isIsolated());\r\n    if (!validateAndReport(() -> catalog.validate(workspace, true), form) || !validateAndReport(() -> catalog.validate(namespace, true), form)) {\r\n        return;\r\n    }\r\n    try {\r\n        catalog.add(workspace);\r\n        catalog.add(namespace);\r\n    } catch (Exception exception) {\r\n        LOGGER.log(Level.INFO, \"Error storing workspace related objects.\", exception);\r\n        cleanAndReport(exception, form);\r\n    }\r\n    if (defaultWs) {\r\n        catalog.setDefaultWorkspace(workspace);\r\n    }\r\n    doReturn(WorkspacePage.class);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.assertStatusCodeForPost",
	"Comment": "assert that a post request to a path will have a particular status code for the response.",
	"Method": "void assertStatusCodeForPost(int code,String path,String body,String type){\r\n    assertStatusCodeForRequest(code, \"POST\", path, body, type);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.getAsJSON",
	"Comment": "executes a request using the get method and parses the result as a json object.",
	"Method": "JSON getAsJSON(String path){\r\n    MockHttpServletResponse response = getAsServletResponse(path);\r\n    return json(response);\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.GetCoverage.handleRangeSubsettingExtension",
	"Comment": "this method is responsible for performing the rangesubsetting operation which can be used tosubset of actually remix or even duplicate bands from the input source coverage.the method tries to enforce the wcs resource limits specified at config time.",
	"Method": "GridCoverage2D handleRangeSubsettingExtension(GridCoverage2D coverage,Map<String, ExtensionItemType> extensions,Hints hints){\r\n    final List<String> returnValue = new ArrayList<String>();\r\n    if (extensions == null || extensions.size() == 0 || !extensions.containsKey(\"rangeSubset\")) {\r\n        return coverage;\r\n    }\r\n    final GridSampleDimension[] bands = coverage.getSampleDimensions();\r\n    final List<String> bandsNames = new ArrayList<String>();\r\n    for (GridSampleDimension band : bands) {\r\n        bandsNames.add(band.getDescription().toString());\r\n    }\r\n    final ExtensionItemType extensionItem = extensions.get(\"rangeSubset\");\r\n    assert extensionItem != null;\r\n    final RangeSubsetType range = (RangeSubsetType) extensionItem.getObjectContent();\r\n    for (RangeItemType rangeItem : range.getRangeItems()) {\r\n        final String rangeComponent = rangeItem.getRangeComponent();\r\n        if (rangeComponent == null) {\r\n            final RangeIntervalType rangeInterval = rangeItem.getRangeInterval();\r\n            final String startRangeComponent = rangeInterval.getStartComponent();\r\n            final String endRangeComponent = rangeInterval.getEndComponent();\r\n            if (!bandsNames.contains(startRangeComponent)) {\r\n                throw new WCS20Exception(\"Invalid Band Name\", WCS20Exception.WCS20ExceptionCode.NoSuchField, rangeComponent);\r\n            }\r\n            if (!bandsNames.contains(endRangeComponent)) {\r\n                throw new WCS20Exception(\"Invalid Band Name\", WCS20Exception.WCS20ExceptionCode.NoSuchField, rangeComponent);\r\n            }\r\n            boolean add = false;\r\n            for (SampleDimension sd : bands) {\r\n                if (sd instanceof GridSampleDimension) {\r\n                    final GridSampleDimension band = (GridSampleDimension) sd;\r\n                    final String name = band.getDescription().toString();\r\n                    if (name.equals(startRangeComponent)) {\r\n                        returnValue.add(startRangeComponent);\r\n                        add = true;\r\n                    } else if (name.equals(endRangeComponent)) {\r\n                        returnValue.add(endRangeComponent);\r\n                        add = false;\r\n                    } else if (add) {\r\n                        returnValue.add(name);\r\n                    }\r\n                }\r\n            }\r\n            if (add) {\r\n                throw new IllegalStateException(\"Unable to close range in band identifiers\");\r\n            }\r\n        } else {\r\n            if (bandsNames.contains(rangeComponent)) {\r\n                returnValue.add(rangeComponent);\r\n            } else {\r\n                throw new WCS20Exception(\"Invalid Band Name\", WCS20Exception.WCS20ExceptionCode.NoSuchField, rangeComponent);\r\n            }\r\n        }\r\n    }\r\n    if (returnValue.isEmpty()) {\r\n        return coverage;\r\n    }\r\n    final int[] indexes = new int[returnValue.size()];\r\n    int i = 0;\r\n    for (String bandName : returnValue) {\r\n        indexes[i++] = // I am assuming there is no duplication in band names which\r\n        bandsNames.indexOf(bandName);\r\n    }\r\n    if (coverage.getNumSampleDimensions() < indexes.length) {\r\n        WCSUtils.checkOutputLimits(wcs, coverage, indexes);\r\n    }\r\n    return (GridCoverage2D) WCSUtils.bandSelect(coverage, indexes);\r\n}"
}, {
	"Path": "org.geoserver.web.wicket.WicketHierarchyPrinter.walkHierarchy",
	"Comment": "walks down the containment hierarchy depth first and prints each component found",
	"Method": "void walkHierarchy(Component c,int level){\r\n    printComponent(c, level);\r\n    if (c instanceof MarkupContainer) {\r\n        MarkupContainer mc = (MarkupContainer) c;\r\n        for (Iterator<?> it = mc.iterator(); it.hasNext(); ) {\r\n            walkHierarchy((Component) it.next(), level + 1);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findLayerFile",
	"Comment": "returns the configuration file for the specified layer, if the file does not exist null isreturned.",
	"Method": "File findLayerFile(LayerInfo layer){\r\n    Resource resource = get(layer);\r\n    return Resources.file(resource);\r\n}"
}, {
	"Path": "org.geoserver.security.impl.EditableUserDAO.deleteUser",
	"Comment": "remove a user specified by name. if the username is not used by any known user, nothinghappens.",
	"Method": "void deleteUser(String username){\r\n    update();\r\n    myDetailStorage.remove(username);\r\n    syncChanges();\r\n}"
}, {
	"Path": "org.geoserver.feature.RetypingFeatureCollection.reTypeId",
	"Comment": "given a feature id following the . convention, the original type andthe destination type, this converts the id from . to.",
	"Method": "FeatureId reTypeId(FeatureId sourceId,SimpleFeatureType original,SimpleFeatureType target){\r\n    final String originalTypeName = original.getName().getLocalPart();\r\n    final String destTypeName = target.getName().getLocalPart();\r\n    if (destTypeName.equals(originalTypeName))\r\n        return sourceId;\r\n    final String prefix = originalTypeName + \".\";\r\n    if (sourceId.getID().startsWith(prefix)) {\r\n        return new FeatureIdImpl(destTypeName + \".\" + sourceId.getID().substring(prefix.length()));\r\n    } else\r\n        return sourceId;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.resolveLayerName",
	"Comment": "get the qname for a layer specified by the layername that would be used in a request.",
	"Method": "QName resolveLayerName(String typename){\r\n    int i = typename.indexOf(\":\");\r\n    String prefix = typename.substring(0, i);\r\n    String name = typename.substring(i + 1);\r\n    NamespaceInfo ns = getCatalog().getNamespaceByPrefix(prefix);\r\n    QName qname = new QName(ns.getURI(), name, ns.getPrefix());\r\n    return qname;\r\n}"
}, {
	"Path": "org.geoserver.catalog.LayerGroupInfo.getKeywords",
	"Comment": "return the keywords associated with this layer group. if no keywords are available an emptylist should be returned.",
	"Method": "List<KeywordInfo> getKeywords(){\r\n    return new ArrayList();\r\n}"
}, {
	"Path": "org.geoserver.security.impl.ServiceAccessRule.getKey",
	"Comment": "returns the key for the current rule. no other rule should have the same",
	"Method": "String getKey(){\r\n    return service + \".\" + method;\r\n}"
}, {
	"Path": "org.geoserver.data.util.CoverageStoreUtils.aquireFactoryByType",
	"Comment": "when loading from dto use the params to locate factory.bleck",
	"Method": "Format aquireFactoryByType(String type){\r\n    final Format[] formats = GridFormatFinder.getFormatArray();\r\n    Format format = null;\r\n    final int length = formats.length;\r\n    for (int i = 0; i < length; i++) {\r\n        format = formats[i];\r\n        if (format.getName().equals(type)) {\r\n            return format;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.sldservice.utils.classifier.RulesBuilder.openRangedRules",
	"Comment": "generate rules from rangedclassifier groups build a list of rules",
	"Method": "List<Rule> openRangedRules(RangedClassifier groups,String property,Class<?> propertyType,boolean normalize){\r\n    Rule r;\r\n    Filter f;\r\n    List<Rule> list = new ArrayList();\r\n    Expression att = normalizeProperty(FF.property(property), propertyType, normalize);\r\n    try {\r\n        r = SF.createRule();\r\n        f = FF.less(att, FF.literal(groups.getMax(0)));\r\n        r.setFilter(f);\r\n        r.setTitle(\" < \" + FF.literal(groups.getMax(0)));\r\n        list.add(r);\r\n        for (int i = 1; i < groups.getSize() - 1; i++) {\r\n            r = SF.createRule();\r\n            if (groups.getMin(i).equals(groups.getMax(i))) {\r\n                f = FF.equals(att, FF.literal(groups.getMax(i)));\r\n                r.setTitle(FF.literal(groups.getMin(i)).toString());\r\n                r.setFilter(f);\r\n                list.add(r);\r\n            } else {\r\n                f = FF.and(FF.greaterOrEqual(att, FF.literal(groups.getMin(i))), FF.less(att, FF.literal(groups.getMax(i))));\r\n                r.setTitle(\" >= \" + FF.literal(groups.getMin(i)) + \" AND < \" + FF.literal(groups.getMax(i)));\r\n                r.setFilter(f);\r\n                list.add(r);\r\n            }\r\n        }\r\n        r = SF.createRule();\r\n        f = FF.greaterOrEqual(att, FF.literal(groups.getMin(groups.getSize() - 1)));\r\n        r.setFilter(f);\r\n        r.setTitle(\" >= \" + FF.literal(groups.getMin(groups.getSize() - 1)));\r\n        list.add(r);\r\n        return list;\r\n    } catch (Exception e) {\r\n        if (LOGGER.isLoggable(Level.INFO))\r\n            LOGGER.log(Level.INFO, \"Failed to build Open Ranged rules\" + e.getLocalizedMessage(), e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.wfs.xml.NameSpaceTranslator.getElements",
	"Comment": "getelements purpose.returns a set of all elements with the exact class specified.",
	"Method": "Set getElements(Set getElements,Class type){\r\n    if (type == null) {\r\n        return null;\r\n    }\r\n    HashSet r = new HashSet();\r\n    Set elems = getElements();\r\n    Iterator i = elems.iterator();\r\n    while (i.hasNext()) {\r\n        NameSpaceElement nse = (NameSpaceElement) i.next();\r\n        if ((nse != null) && type.equals(nse.getJavaClass())) {\r\n            r.add(nse);\r\n        }\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTest.applyModifyCatalogChanges",
	"Comment": "helper method that apply some catalog changes to the provided geoserver instance.",
	"Method": "void applyModifyCatalogChanges(GeoServerInstance instance){\r\n    Catalog catalog = instance.getCatalog();\r\n    NamespaceInfo namespace = catalog.getNamespaceByPrefix(\"workspace-Name\");\r\n    namespace.setURI(\"namespace-URI-modified\");\r\n    catalog.save(namespace);\r\n    DataStoreInfo dataStore = catalog.getDataStoreByName(\"dataStore-Name\");\r\n    dataStore.setDescription(\"dataStore-Description-modified\");\r\n    catalog.save(dataStore);\r\n    CoverageStoreInfo coverageStore = catalog.getCoverageStoreByName(\"coverageStore-Name\");\r\n    coverageStore.setDescription(\"coverageStore-Description-modified\");\r\n    catalog.save(coverageStore);\r\n    WMSStoreInfo wmsStore = catalog.getStoreByName(\"wmsStore-Name\", WMSStoreInfo.class);\r\n    wmsStore.setDescription(\"wmsStore-Description-modified\");\r\n    catalog.save(wmsStore);\r\n    FeatureTypeInfo featureType = catalog.getFeatureTypeByName(\"featureType-Name\");\r\n    featureType.setDescription(\"featureType-Description-modified\");\r\n    catalog.save(featureType);\r\n    CoverageInfo coverage = catalog.getCoverageByName(\"coverage-Name\");\r\n    coverage.setAbstract(\"coverage-Abstract-modified\");\r\n    catalog.save(coverage);\r\n    StyleInfo style = catalog.getStyleByName(\"style-Name\");\r\n    style.setName(\"style-Name-modified\");\r\n    catalog.save(style);\r\n    LayerInfo layer = catalog.getLayerByName(\"featureType-Name\");\r\n    layer.setAbstract(\"layer-Abstract-modified\");\r\n    catalog.save(layer);\r\n    WMSLayerInfo wmsLayer = catalog.getResourceByName(\"wmsLayer-Name\", WMSLayerInfo.class);\r\n    wmsLayer.setAbstract(\"wmsLayer-Abstract-modified\");\r\n    catalog.save(wmsLayer);\r\n    LayerGroupInfo layerGroup = catalog.getLayerGroupByName(\"layerGroup-Name\");\r\n    layerGroup.setTitle(\"layerGroup-Title-modified\");\r\n    catalog.save(layerGroup);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoJsonOutputFormatWfsTest.checkStation1Exists",
	"Comment": "helper method that station 1 exists and was correctly encoded in the geojson response.",
	"Method": "void checkStation1Exists(JSON geoJson){\r\n    JSONObject station = getStationPropertiesById(geoJson, \"st.1\");\r\n    assertThat(station, notNullValue());\r\n    JSONArray contact = station.getJSONArray(\"contact\");\r\n    assertThat(contact.size(), is(2));\r\n    JSONArray phone = contact.getJSONObject(0).getJSONArray(\"phone\");\r\n    assertThat(phone.size(), is(2));\r\n    assertThat(phone.getString(0), is(\"95482156\"));\r\n    JSONObject timezone = phone.getJSONObject(1);\r\n    assertThat(timezone.get(\"timeZone\"), is(\"CET\"));\r\n    JSONArray measurements = station.getJSONArray(\"measurements\");\r\n    assertThat(measurements.size(), is(2));\r\n    assertThat(measurements.getJSONObject(0).getString(\"href\"), containsString(\"http://www.stations.org/ms.\"));\r\n    assertThat(measurements.getJSONObject(1).getString(\"href\"), containsString(\"http://www.stations.org/ms.\"));\r\n}"
}, {
	"Path": "org.geoserver.platform.resource.Resources.file",
	"Comment": "if create is true or if a file exists returns resource.file, otherwise it returns null.",
	"Method": "File file(Resource resource,File file,Resource resource,boolean create,File file){\r\n    final File f;\r\n    if (resource == null) {\r\n        f = null;\r\n    } else if (create) {\r\n        f = resource.file();\r\n    } else {\r\n        if (resource.getType() == Type.RESOURCE) {\r\n            f = resource.file();\r\n        } else {\r\n            f = null;\r\n        }\r\n    }\r\n    return f;\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexMongoDBSupport.readResourceContent",
	"Comment": "helper method that reads the content of a resource to a string.",
	"Method": "String readResourceContent(String resourcePath){\r\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\r\n    try (InputStream input = ComplexMongoDBSupport.class.getResourceAsStream(resourcePath)) {\r\n        IOUtils.copy(input, output);\r\n        return new String(output.toByteArray());\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(String.format(\"Error reading resource '%s' content.\", resourcePath), exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.MultiDimensionalExtensionTest.checkXpathCount",
	"Comment": "helper method that perform a xpath count and check the result.",
	"Method": "void checkXpathCount(Document result,String path,String count){\r\n    String finalPath = String.format(\"count(/%s)\", path);\r\n    assertThat(xpath.evaluate(finalPath, result), is(count));\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDefaultValuesHelper.setEnevelopeFilter",
	"Comment": "set envelope filter to restrict the results to the specified envelope",
	"Method": "Filter setEnevelopeFilter(Envelope envelopeSubset,StructuredGridCoverage2DReader reader){\r\n    Filter envelopeFilter = null;\r\n    if (envelopeSubset != null) {\r\n        Polygon polygon = JTS.toGeometry(new ReferencedEnvelope(envelopeSubset));\r\n        GeometryDescriptor geom = reader.getGranules(coverageName, true).getSchema().getGeometryDescriptor();\r\n        PropertyName geometryProperty = FF.property(geom.getLocalName());\r\n        Geometry nativeCRSPolygon;\r\n        try {\r\n            nativeCRSPolygon = JTS.transform(polygon, CRS.findMathTransform(DefaultGeographicCRS.WGS84, reader.getCoordinateReferenceSystem()));\r\n            Literal polygonLiteral = FF.literal(nativeCRSPolygon);\r\n            envelopeFilter = FF.intersects(geometryProperty, polygonLiteral);\r\n        } catch (Exception e) {\r\n            throw new IOException(e);\r\n        }\r\n    }\r\n    return envelopeFilter;\r\n}"
}, {
	"Path": "org.geoserver.feature.retype.RetypingDataStoreTest.testAppend",
	"Comment": "this test is made with mock objects because the property data store does not generate fids inthe . form",
	"Method": "void testAppend(){\r\n    SimpleFeatureType type = DataUtilities.createType(\"trees\", \"the_geom:Point,FID:String,NAME:String\");\r\n    SimpleFeatureStore fs = createMock(SimpleFeatureStore.class);\r\n    expect(fs.addFeatures(isA(FeatureCollection.class))).andReturn(Collections.singletonList((FeatureId) (new FeatureIdImpl(\"trees.105\"))));\r\n    replay(fs);\r\n    DataStore ds = createMock(DataStore.class);\r\n    expect(ds.getTypeNames()).andReturn(new String[] { \"trees\" }).anyTimes();\r\n    expect(ds.getSchema(\"trees\")).andReturn(type).anyTimes();\r\n    expect(ds.getFeatureSource(\"trees\")).andReturn(fs);\r\n    replay(ds);\r\n    RetypingDataStore rts = new RetypingDataStore(ds) {\r\n        @Override\r\n        protected String transformFeatureTypeName(String originalName) {\r\n            return \"oaks\";\r\n        }\r\n    };\r\n    SimpleFeatureBuilder sfb = new SimpleFeatureBuilder(type);\r\n    WKTReader reader = new WKTReader();\r\n    sfb.set(\"the_geom\", reader.read(\"POINT (0.002 0.0008)\"));\r\n    sfb.set(\"FID\", \"023\");\r\n    sfb.set(\"NAME\", \"Old oak\");\r\n    SimpleFeature feature = sfb.buildFeature(null);\r\n    SimpleFeatureCollection fc = DataUtilities.collection(feature);\r\n    SimpleFeatureStore store = (SimpleFeatureStore) rts.getFeatureSource(\"oaks\");\r\n    List<FeatureId> ids = store.addFeatures(fc);\r\n    assertEquals(1, ids.size());\r\n    String id = ((FeatureId) ids.iterator().next()).getID();\r\n    assertTrue(\"Id does not start with \" + \"oaks\" + \" it's \" + id, id.startsWith(\"oaks\"));\r\n}"
}, {
	"Path": "org.geoserver.feature.retype.RetypingDataStoreTest.testAppend",
	"Comment": "this test is made with mock objects because the property data store does not generate fids inthe . form",
	"Method": "void testAppend(){\r\n    return \"oaks\";\r\n}"
}, {
	"Path": "org.geoserver.ows.util.XmlCharsetDetector.getXmlEncoding",
	"Comment": "gets the encoding of the xml request made to the dispatcher. this works by reading the tempfile where we are storing the request, looking to match the header specified encoding thatshould be present on all xml files. this call should only be made after the temp file hasbeen set. if no encoding is found, or if an ioerror is encountered then null shall bereturned.",
	"Method": "String getXmlEncoding(Reader reader){\r\n    try {\r\n        StringWriter sw = new StringWriter(MAX_XMLDECL_SIZE);\r\n        int c;\r\n        int count = 0;\r\n        for (; (6 > count) && (-1 != (c = reader.read())); count++) {\r\n            sw.write(c);\r\n        }\r\n        if ((6 > count) || (!\"<?xml \".equals(sw.toString()))) {\r\n            if (LOGGER.isLoggable(Level.FINER)) {\r\n                LOGGER.finer(\"Invalid(?) XML declaration: \" + sw.toString() + \".\");\r\n            }\r\n            return null;\r\n        }\r\n        for (; (MAX_XMLDECL_SIZE > count) && (-1 != (c = reader.read())) && (RIGHT_ANGLE_BRACKET != (char) c); count++) {\r\n            sw.write(c);\r\n        }\r\n        Matcher m = ENCODING_PATTERN.matcher(sw.toString());\r\n        if (m.find()) {\r\n            String result = m.group(1);\r\n            return result;\r\n        } else {\r\n            return null;\r\n        }\r\n    } catch (IOException e) {\r\n        if (LOGGER.isLoggable(Level.WARNING)) {\r\n            LOGGER.warning(\"Failed to extract charset info from XML \" + \"declaration due to IOException: \" + e.getMessage());\r\n        }\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.CatalogBuilder.initWMSLayer",
	"Comment": "initializes a wms layer object setting any info that has not been set.",
	"Method": "void initWMSLayer(WMSLayerInfo wmsLayer){\r\n    wmsLayer.setCatalog(catalog);\r\n    initResourceInfo(wmsLayer);\r\n    OwsUtils.resolveCollections(wmsLayer);\r\n    WMSLayerInfo full = buildWMSLayer(store, wmsLayer.getNativeName());\r\n    if (wmsLayer.getSRS() == null) {\r\n        wmsLayer.setSRS(full.getSRS());\r\n    }\r\n    if (wmsLayer.getNativeCRS() == null) {\r\n        wmsLayer.setNativeCRS(full.getNativeCRS());\r\n    }\r\n    if (wmsLayer.getProjectionPolicy() == null) {\r\n        wmsLayer.setProjectionPolicy(full.getProjectionPolicy());\r\n    }\r\n    if (wmsLayer.getLatLonBoundingBox() == null && wmsLayer.getNativeBoundingBox() == null) {\r\n        wmsLayer.setLatLonBoundingBox(full.getLatLonBoundingBox());\r\n        wmsLayer.setNativeBoundingBox(full.getNativeBoundingBox());\r\n    } else if (wmsLayer.getLatLonBoundingBox() == null) {\r\n        setupBounds(wmsLayer);\r\n    } else if (wmsLayer.getNativeBoundingBox() == null && wmsLayer.getNativeCRS() != null) {\r\n        ReferencedEnvelope boundsLatLon = wmsLayer.getLatLonBoundingBox();\r\n        wmsLayer.setNativeBoundingBox(boundsLatLon.transform(wmsLayer.getNativeCRS(), true));\r\n    }\r\n    if (wmsLayer.getTitle() == null) {\r\n        wmsLayer.setTitle(full.getTitle());\r\n    }\r\n    if (wmsLayer.getDescription() == null) {\r\n        wmsLayer.setDescription(full.getDescription());\r\n    }\r\n    if (wmsLayer.getAbstract() == null) {\r\n        wmsLayer.setAbstract(full.getAbstract());\r\n    }\r\n    if (wmsLayer.getKeywords().isEmpty()) {\r\n        wmsLayer.getKeywords().addAll(full.getKeywords());\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.csw.feature.AbstractFeatureCollection.getOpenIterators",
	"Comment": "returns the set of open iterators.contents are a mix of iterator and featureiterator",
	"Method": "Set getOpenIterators(){\r\n    return open;\r\n}"
}, {
	"Path": "org.geoserver.opensearch.rest.AbstractOpenSearchController.runTransactionOnStore",
	"Comment": "factors out the boilerplate to create a transaction, run it, commit it if successful, revertotherwise, and finally close it",
	"Method": "void runTransactionOnStore(FeatureStore store,IOConsumer<FeatureStore> featureStoreConsumer){\r\n    try (Transaction t = new DefaultTransaction()) {\r\n        store.setTransaction(t);\r\n        try {\r\n            featureStoreConsumer.accept(store);\r\n            t.commit();\r\n        } catch (Exception e) {\r\n            t.rollback();\r\n            throw new IOException(\"Failed to run modification on storage:\" + e.getMessage(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.geofence.server.rest.AdminRulesRestController.move",
	"Comment": "move the provided rules to the target priority. rules will be sorted by their priority, firstrule will be updated with a priority equal to the target priority and the next ones will getan incremented priority value.",
	"Method": "ResponseEntity<JaxbAdminRuleList> move(int targetPriority,String rulesIds){\r\n    List<AdminRule> rules = findRules(rulesIds);\r\n    if (rules.isEmpty()) {\r\n        return ResponseEntity.ok(null);\r\n    }\r\n    adminService.shift(targetPriority, rules.size());\r\n    long priority = targetPriority;\r\n    for (AdminRule rule : rules) {\r\n        rule.setPriority(priority);\r\n        adminService.update(rule);\r\n        priority++;\r\n    }\r\n    return ResponseEntity.ok(new JaxbAdminRuleList(rules));\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.getSimpleContent",
	"Comment": "helper method that try to extract a simple content from a complex attribute, null is returnedif no simple content is present.",
	"Method": "Object getSimpleContent(ComplexAttribute property){\r\n    Collection<Property> properties = property.getProperties();\r\n    if (properties.isEmpty() || properties.size() > 1) {\r\n        return null;\r\n    }\r\n    Property simpleContent = getElementAt(properties, 0);\r\n    if (simpleContent == null) {\r\n        return null;\r\n    }\r\n    Name name = simpleContent.getName();\r\n    if (name == null || !name.getLocalPart().equals(\"simpleContent\")) {\r\n        return null;\r\n    }\r\n    Object value = simpleContent.getValue();\r\n    if (value instanceof Number || value instanceof String || value instanceof Character) {\r\n        return value;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.web.wicket.GeoServerTablePanel.setSelectable",
	"Comment": "when set to false, will prevent the selection checkboxes from showing up",
	"Method": "void setSelectable(boolean selectable){\r\n    this.selectable = selectable;\r\n    selectAll.setVisible(selectable);\r\n}"
}, {
	"Path": "org.geoserver.feature.retype.RetypingDataStore.retypeFilter",
	"Comment": "retypes a filter making sure the fids are using the internal typename prefix",
	"Method": "Filter retypeFilter(Filter filter,FeatureTypeMap typeMap){\r\n    FidTransformeVisitor visitor = new FidTransformeVisitor(typeMap);\r\n    return (Filter) filter.accept(visitor, null);\r\n}"
}, {
	"Path": "org.geoserver.security.xml.XMLSecurityProvider.createAuthenticationProvider",
	"Comment": "creates an authentication provider.if the extension does not provide an authentication provider this method should simplyreturn null.",
	"Method": "GeoServerAuthenticationProvider createAuthenticationProvider(SecurityNamedServiceConfig config){\r\n    return new UsernamePasswordAuthenticationProvider();\r\n}"
}, {
	"Path": "org.geoserver.ows.kvp.TimeParser.getMaxTimes",
	"Comment": "maximum number of times this parser will parse before throwing an exception",
	"Method": "int getMaxTimes(){\r\n    if (maxTimes != null) {\r\n        return maxTimes;\r\n    } else {\r\n        return DEFAULT_MAX_ELEMENTS_TIMES_KVP;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.impl.AbstractUserGroupStore.preparePassword",
	"Comment": "validates and encodes the password. do nothing for a not changed password of an existing user",
	"Method": "void preparePassword(GeoServerUser user){\r\n    char[] passwordArray = user.getPassword() != null ? user.getPassword().toCharArray() : null;\r\n    if (PasswordValidatorImpl.passwordStartsWithEncoderPrefix(passwordArray) != null)\r\n        return;\r\n    getSecurityManager().loadPasswordValidator(getPasswordValidatorName()).validatePassword(passwordArray);\r\n    GeoServerPasswordEncoder enc = getSecurityManager().loadPasswordEncoder(getPasswordEncoderName());\r\n    enc.initializeFor(this);\r\n    user.setPassword(enc.encodePassword(user.getPassword(), null));\r\n}"
}, {
	"Path": "org.geoserver.importer.Dates.patterns",
	"Comment": "returns list of all patterns, optionally filtering out ones that require a strict match.",
	"Method": "Collection<DatePattern> patterns(boolean strict){\r\n    Collection<DatePattern> patterns = PATTERNS;\r\n    if (!strict) {\r\n        patterns = Collections2.filter(patterns, new Predicate<DatePattern>() {\r\n            @Override\r\n            public boolean apply(DatePattern input) {\r\n                return !input.isStrict();\r\n            }\r\n        });\r\n    }\r\n    return patterns;\r\n}"
}, {
	"Path": "org.geoserver.importer.Dates.patterns",
	"Comment": "returns list of all patterns, optionally filtering out ones that require a strict match.",
	"Method": "Collection<DatePattern> patterns(boolean strict){\r\n    return !input.isStrict();\r\n}"
}, {
	"Path": "org.geoserver.catalog.TestHttpClientProvider.testModeEnabled",
	"Comment": "used to check if any binding is associated into the mock server",
	"Method": "boolean testModeEnabled(){\r\n    return TEST_MODE;\r\n}"
}, {
	"Path": "org.geoserver.wfs.WFSGetFeatureOutputFormat.canHandle",
	"Comment": "allows to have version specific output formats. by default a wfs format is allowed on everyversion, override to filter specific ones",
	"Method": "boolean canHandle(Operation operation,boolean canHandle,Version version){\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.catalog.CoverageDimensionCustomizerReaderTest.testNoRange",
	"Comment": "test that if no range is defined, category values or default values are used",
	"Method": "void testNoRange(){\r\n    GridSampleDimension sampleDim = new GridSampleDimension(\"original\", SampleDimensionType.REAL_64BITS, ColorInterpretation.GRAY_INDEX, null, null, new double[] { -9999.0 }, -1000d, 1000d, 1d, 0d, null);\r\n    final CoverageDimensionImpl coverageDim = new CoverageDimensionImpl();\r\n    final String wrappedName = \"wrapped\";\r\n    coverageDim.setName(wrappedName);\r\n    coverageDim.setDimensionType(SampleDimensionType.REAL_64BITS);\r\n    SampleDimension wrappedDim = WrappedSampleDimension.build(sampleDim, coverageDim);\r\n    NumberRange<? extends Number> wrappedRange = ((WrappedSampleDimension) wrappedDim).getRange();\r\n    assertNull(wrappedRange);\r\n    assertEquals(-9999, wrappedDim.getMinimumValue(), DELTA);\r\n    assertEquals(1000, wrappedDim.getMaximumValue(), DELTA);\r\n    assertEquals(wrappedName, wrappedDim.getDescription().toString());\r\n    sampleDim = new GridSampleDimension(\"original\", null, new BaseUnit<Dimensionless>(\"test\"));\r\n    wrappedDim = WrappedSampleDimension.build(sampleDim, coverageDim);\r\n    wrappedRange = ((WrappedSampleDimension) wrappedDim).getRange();\r\n    assertNull(wrappedRange);\r\n    assertEquals(Double.NEGATIVE_INFINITY, wrappedDim.getMinimumValue(), DELTA);\r\n    assertEquals(Double.POSITIVE_INFINITY, wrappedDim.getMaximumValue(), DELTA);\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.loadConfig",
	"Comment": "reads a config file from the specified directly using the specified xstream persister",
	"Method": "T loadConfig(Class<T> config,Resource resource,XStreamPersister xp,C loadConfig,String name,MigrationHelper migrationHelper,C loadConfig,String name){\r\n    InputStream in = resource.in();\r\n    try {\r\n        Object loaded = xp.load(in, SecurityConfig.class).clone(true);\r\n        return config.cast(loaded);\r\n    } finally {\r\n        in.close();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.ExecuteTest.testWrongOutputIdentifierRawOutput",
	"Comment": "tests a process execution an invalid output identifier fails immediately with an appropriateerror message",
	"Method": "void testWrongOutputIdentifierRawOutput(){\r\n    String responseFormContents = \"    <wps:RawDataOutput>\\n\" + \"      <ows:Identifier>fooBar<\/ows:Identifier>\\n\" + \"    <\/wps:RawDataOutput>\\n\";\r\n    String request = buildGetBoundsRequest(responseFormContents);\r\n    Document dom = postAsDOM(root(), request);\r\n    String message = checkOws11Exception(dom, ServiceException.INVALID_PARAMETER_VALUE, \"RawDataOutput\");\r\n    assertThat(message, containsString(\"fooBar\"));\r\n}"
}, {
	"Path": "org.geoserver.taskmanager.AbstractTaskManagerTest.login",
	"Comment": "sets up the authentication context for the test.this context lasts only for a single test case, it is cleared after every test hascompleted.",
	"Method": "void login(String username,String password,String roles){\r\n    SecurityContextHolder.setContext(new SecurityContextImpl());\r\n    List<GrantedAuthority> l = new ArrayList<GrantedAuthority>();\r\n    for (String role : roles) {\r\n        l.add(new SimpleGrantedAuthority(role));\r\n    }\r\n    SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(username, password, l));\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.getLayerGroups",
	"Comment": "retrieve a resource in the the layer groups directory of a workspace. an empty path willretrieve the directory itself. a null workspace will return the resource in the global layergroups directory",
	"Method": "Resource getLayerGroups(String path,Resource getLayerGroups,WorkspaceInfo wsi,String path){\r\n    Resource r = get(wsi, Paths.path(LAYERGROUP_DIR, Paths.path(path)));\r\n    assert r != null;\r\n    return r;\r\n}"
}, {
	"Path": "org.geoserver.config.CapabilitiesCacheHeadersCallback.handleCachingHeaders",
	"Comment": "returns true if the caching headers are enabled and the request is a getcapabilities one",
	"Method": "boolean handleCachingHeaders(Request request){\r\n    return capabilitiesCacheHeadersEnabled && \"GetCapabilities\".equalsIgnoreCase(request.getRequest());\r\n}"
}, {
	"Path": "org.vfny.geoserver.servlets.FileStrategy.getDestination",
	"Comment": "provides a outputs stream on a temporary file.i have changed this to use a bufferedwriter to agree with speedstrategy.",
	"Method": "DispatcherOutputStream getDestination(HttpServletResponse response){\r\n    sequence++;\r\n    try {\r\n        temp = File.createTempFile(\"wfs\" + sequence, \"tmp\");\r\n        if (!temp.canRead() || !temp.canWrite()) {\r\n            String errorMsg = \"Temporary-file permission problem for location: \" + temp.getPath();\r\n            throw new IOException(errorMsg);\r\n        }\r\n    } catch (IOException e) {\r\n        String errorMsg = \"Possible file permission problem. Root cause: \\n\" + e.toString();\r\n        IOException newE = new IOException(errorMsg);\r\n        throw newE;\r\n    }\r\n    safe = new BufferedOutputStream(new FileOutputStream(temp));\r\n    return new DispatcherOutputStream(safe);\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.kvp.WCSKVPTestSupport.executeGetCoverage",
	"Comment": "runs getcoverage on the specified parameters and returns an array of coverages",
	"Method": "GridCoverage executeGetCoverage(String url){\r\n    GridCoverage coverage = service.getCoverage(parse(url));\r\n    super.scheduleForCleaning(coverage);\r\n    return coverage;\r\n}"
}, {
	"Path": "org.geoserver.catalog.CascadeRemovalReporter.reset",
	"Comment": "resets the visitor so that it can be reused for another search",
	"Method": "void reset(){\r\n    this.objects = new HashMap<CatalogInfo, ModificationType>();\r\n    this.groups = new HashMap<LayerGroupInfo, Set<LayerInfo>>();\r\n}"
}, {
	"Path": "org.geoserver.wps.executor.ExecutionStatus.getProgress",
	"Comment": "returns the progress percentage, as a number between 0 and 100",
	"Method": "float getProgress(){\r\n    return progress;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.getAsDOM",
	"Comment": "executes an ows request using the get method and returns the result as an xml document.",
	"Method": "Document getAsDOM(String path,Document getAsDOM,String path,int statusCode,Document getAsDOM,String path,String encoding,Document getAsDOM,String path,boolean skipDTD,Document getAsDOM,String path,boolean skipDTD,String encoding){\r\n    return dom(get(path), skipDTD, encoding);\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findWorkspaceDir",
	"Comment": "returns the directory for the specified workspace, if the directory does not exist null isreturned.",
	"Method": "File findWorkspaceDir(WorkspaceInfo ws){\r\n    Resource directory = get(ws);\r\n    return Resources.directory(directory);\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.DefaultOpenSearchEoService.guessImageMimeType",
	"Comment": "used to guess the mime type of an encoded image until we start storing the mime in the db",
	"Method": "String guessImageMimeType(byte[] payload){\r\n    if (payload.length >= 4 && (payload[0] == (byte) 0xFF) && (payload[1] == (byte) 0xD8) && (payload[2] == (byte) 0xFF) && (payload[3] == (byte) 0xE0)) {\r\n        return JPEG_MIME;\r\n    } else if (payload.length >= 8 && (payload[0] == (byte) 0x89) && (payload[1] == (byte) 0x50) && (payload[2] == (byte) 0x4E) && (payload[3] == (byte) 0x47) && (payload[4] == (byte) 0x0D) && (payload[5] == (byte) 0x0A) && (payload[6] == (byte) 0x1A) && (payload[7] == (byte) 0x0A)) {\r\n        return PNG_MIME;\r\n    } else {\r\n        return BINARY_MIME;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.ows.util.CaseInsensitiveMap.wrap",
	"Comment": "wraps a map in case insensitive one.if the instance is already a case insensitive map it is returned as is.",
	"Method": "Map wrap(Map other){\r\n    if (other instanceof CaseInsensitiveMap) {\r\n        return other;\r\n    }\r\n    return new CaseInsensitiveMap(other);\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findStyleFile",
	"Comment": "returns the configuration file for the specified style, if the file does not exist null isreturned.",
	"Method": "File findStyleFile(StyleInfo s){\r\n    Resource resource = config(s);\r\n    return Resources.file(resource);\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.DimensionsUtils.getDomainValuesAsStrings",
	"Comment": "helper method that simply returns a string representation of the values of a dimension. datesand ranges will have a special handling. this method will take in account the dimensionrequired presentation.",
	"Method": "List<String> getDomainValuesAsStrings(DomainSummary summary){\r\n    if (summary.getMin() == null && (summary.getUniqueValues() == null || summary.getUniqueValues().isEmpty())) {\r\n        return Collections.emptyList();\r\n    }\r\n    List<String> stringValues = new ArrayList();\r\n    if (summary.getUniqueValues() != null) {\r\n        for (Object value : summary.getUniqueValues()) {\r\n            stringValues.add(formatDomainValue(value));\r\n        }\r\n    } else {\r\n        Object minValue = summary.getMin();\r\n        Object maxValue = summary.getMax();\r\n        stringValues.add(formatDomainSimpleValue(minValue) + \"--\" + formatDomainSimpleValue(maxValue));\r\n    }\r\n    return stringValues;\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.CoverageResponseDelegate.getFileName",
	"Comment": "allows the delegate to specify the output format given the object to encode and the",
	"Method": "String getFileName(GridCoverage2D value,String coverageId,String format){\r\n    return coverageId + \".\" + getFileExtension(format);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.assertDeferredLoading",
	"Comment": "checks the image and its sources are all deferred loaded, that is, there is no bufferedimagein the chain",
	"Method": "void assertDeferredLoading(RenderedImage image){\r\n    if (image instanceof BufferedImage) {\r\n        fail(\"Found a buffered image in the chain, the original image is not fully deferred loaded\");\r\n    } else {\r\n        for (RenderedImage ri : image.getSources()) {\r\n            assertDeferredLoading(ri);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wms.web.data.StyleEditPageTest.testDiscardNewLegendInfo",
	"Comment": "test that while editing a style, the user can create and then discard a legend without eversaving it.",
	"Method": "void testDiscardNewLegendInfo(){\r\n    tester.assertRenderedPage(StyleEditPage.class);\r\n    tester.assertNoErrorMessage();\r\n    tester.executeAjaxEvent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:showhide:show\", \"click\");\r\n    tester.assertComponent(\"styleForm:context:panel:legendPanel\", ExternalGraphicPanel.class);\r\n    tester.assertComponent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:onlineResource\", TextField.class);\r\n    tester.assertComponent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:width\", TextField.class);\r\n    tester.assertComponent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:height\", TextField.class);\r\n    tester.assertComponent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:list:format\", TextField.class);\r\n    tester.executeAjaxEvent(\"styleForm:context:panel:legendPanel:externalGraphicContainer:showhide:hide\", \"click\");\r\n    tester.assertNoErrorMessage();\r\n    tester.executeAjaxEvent(\"submit\", \"click\");\r\n    StyleInfo style = getCatalog().getStyleByName(MockData.BUILDINGS.getLocalPart());\r\n    assertNotNull(style);\r\n    assertNull(style.getLegend());\r\n}"
}, {
	"Path": "org.geoserver.wfs.v2_0.WFS20TestSupport.setGmlMimeTypeOverride",
	"Comment": "helper method that just sets the gml 3.2 mime type to force. if null is provided then gmlmime type overriding will be deactivated. this changes will be applied to wfs globalconfiguration.",
	"Method": "void setGmlMimeTypeOverride(String mimeTypeToForce){\r\n    WFSInfo info = getGeoServer().getService(WFSInfo.class);\r\n    GMLInfo gmlInfo = info.getGML().get(WFSInfo.Version.V_20);\r\n    gmlInfo.setMimeTypeToForce(mimeTypeToForce);\r\n    getGeoServer().save(info);\r\n}"
}, {
	"Path": "org.geoserver.ows.Request.getOperation",
	"Comment": "the operation used to call the service code. available only after dispatching is done, itprovides access to the current service object, and the parsed request",
	"Method": "Operation getOperation(){\r\n    return operation;\r\n}"
}, {
	"Path": "org.geoserver.wps.web.WPSRequestBuilderTest.testNameRequest",
	"Comment": "tests initializing page to specific process via name request parameter.",
	"Method": "void testNameRequest(){\r\n    login();\r\n    tester.startPage(new WPSRequestBuilder(new PageParameters().add(\"name\", \"JTS:area\")));\r\n    tester.assertComponent(\"form:requestBuilder:process\", DropDownChoice.class);\r\n    tester.assertModelValue(\"form:requestBuilder:process\", \"JTS:area\");\r\n    tester.assertComponent(\"form:requestBuilder:inputContainer:inputs:0:paramValue:editor:textarea\", TextArea.class);\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.CoverageDimensionsReader.instantiateFrom",
	"Comment": "instantiate a coverage reader from the provided read. if the reader is a structured one goodwe can use some optimizations otherwise we will have to really on the layer metadata.",
	"Method": "CoverageDimensionsReader instantiateFrom(CoverageInfo typeInfo){\r\n    GridCoverage2DReader reader;\r\n    try {\r\n        reader = (GridCoverage2DReader) typeInfo.getGridCoverageReader(null, null);\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error getting coverage reader.\", exception);\r\n    }\r\n    if (reader instanceof StructuredGridCoverage2DReader) {\r\n        return new WrapStructuredGridCoverageDimensions2DReader((StructuredGridCoverage2DReader) reader);\r\n    }\r\n    return new WrapNonStructuredReader(typeInfo, reader);\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerWicketTestSupport.findComponentByContent",
	"Comment": "finds the component whose model value equals to the specified content, and the componentclass is equal, subclass or implementor of the specified class",
	"Method": "Component findComponentByContent(MarkupContainer root,Object content,Class<?> componentClass){\r\n    ComponentContentFinder finder = new ComponentContentFinder(content);\r\n    root.visitChildren(componentClass, finder);\r\n    return finder.candidate;\r\n}"
}, {
	"Path": "org.geoserver.test.NormalizedMultiValuesTest.notJdbcBased",
	"Comment": "helper method that checks if this is an online test not based on a jdbc data store.",
	"Method": "boolean notJdbcBased(){\r\n    FeatureTypeInfo featureTypeInfo = getCatalog().getFeatureTypeByName(\"Station_gml31\");\r\n    DataAccess dataAccess = featureTypeInfo.getStore().getDataStore(null);\r\n    AppSchemaDataAccess appSchemaDataAccess = (AppSchemaDataAccess) dataAccess;\r\n    Name name = new NameImpl(\"http://www.stations_gml31.org/1.0\", \"Station_gml31\");\r\n    FeatureSource featureSource = appSchemaDataAccess.getMappingByName(name).getSource();\r\n    return !(featureSource instanceof JDBCFeatureStore);\r\n}"
}, {
	"Path": "org.geoserver.geofence.rest.RulesRestControllerTest.prepareGeoFenceTestRules",
	"Comment": "helper method that checks if the rule already exists and create a new one by returning itsid.",
	"Method": "long prepareGeoFenceTestRules(JaxbRule rule){\r\n    if (adminService.getCountAll() > 0) {\r\n        for (ShortRule r : adminService.getAll()) {\r\n            controller.delete(r.getId());\r\n        }\r\n    }\r\n    long id = controller.insert(rule).getBody();\r\n    return id;\r\n}"
}, {
	"Path": "org.geoserver.catalog.CatalogFacade.getNamespacesByURI",
	"Comment": "loads all namespaces from persistent storage that match the provided uri.",
	"Method": "List<NamespaceInfo> getNamespacesByURI(String uri){\r\n    return getNamespaces().stream().filter(namespace -> namespace.getURI().equals(uri)).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.geoserver.wcs.GetCoverageMultipartEncodingTest.testArcgridException",
	"Comment": "arcgrid cannot encode rotate coverages, yet due to a bug the output was a garbled mimemultipart instead of a service exception. this makes sure an exception is returned instead.",
	"Method": "void testArcgridException(){\r\n    String request = \"wcs?service=WCS&version=1.1.1&request=GetCoverage&identifier=\" + getLayerId(TASMANIA_BM) + \"&format=application/arcgrid\" + \"&boundingbox=-90,-180,90,180,urn:ogc:def:crs:EPSG:6.6:4326\";\r\n    Document dom = getAsDOM(request);\r\n    checkOws11Exception(dom);\r\n}"
}, {
	"Path": "org.geoserver.security.jdbc.config.JDBCSecurityServiceConfig.setConnectURL",
	"Comment": "the jdbc url with which to obtain a database connection with.",
	"Method": "void setConnectURL(String connectURL){\r\n    this.connectURL = connectURL;\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.LDAPAuthenticationProviderTest.testUserFilterAndFormat",
	"Comment": "test that authentication can be done using the couple userfilter and userformat instead ofuserdnpattern.",
	"Method": "void testUserFilterAndFormat(){\r\n    Assume.assumeTrue(LDAPTestUtils.initLdapServer(true, ldapServerUrl, basePath));\r\n    ((LDAPSecurityServiceConfig) config).setUserFilter(\"(telephonenumber=1)\");\r\n    ((LDAPSecurityServiceConfig) config).setUserFormat(\"uid={0},ou=People,dc=example,dc=com\");\r\n    createAuthenticationProvider();\r\n    Authentication result = authProvider.authenticate(authentication);\r\n    assertEquals(3, result.getAuthorities().size());\r\n}"
}, {
	"Path": "org.geoserver.wfs.WFSReprojectionUtil.getDeclaredCrs",
	"Comment": "returns the declared crs given a feature type and the request wfs version",
	"Method": "CoordinateReferenceSystem getDeclaredCrs(CoordinateReferenceSystem nativeCRS,String wfsVersion,CoordinateReferenceSystem getDeclaredCrs,FeatureType schema,String wfsVersion){\r\n    if (schema == null)\r\n        return null;\r\n    CoordinateReferenceSystem crs = (schema.getGeometryDescriptor() != null) ? schema.getGeometryDescriptor().getCoordinateReferenceSystem() : null;\r\n    return getDeclaredCrs(crs, wfsVersion);\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.GeorectifyCoverage.addGroundControlPoints",
	"Comment": "first processing step which setup a vrt by adding ground control points to the specifiedinput file.",
	"Method": "File addGroundControlPoints(String originalFilePath,List<String> gcp,List<String> parameters){\r\n    final File vrtFile = File.createTempFile(\"vrt_\", \".vrt\", config.getTempFolder());\r\n    @SuppressWarnings(\"serial\")\r\n    final List<String> arguments = new ArrayList<String>() {\r\n        {\r\n            add(\"-of\");\r\n            add(\"VRT\");\r\n            addAll(parameters);\r\n            addAll(gcp);\r\n            add(originalFilePath);\r\n            add(vrtFile.getAbsolutePath());\r\n        }\r\n    };\r\n    final String gdalCommand = config.getTranslateCommand();\r\n    executeCommand(gdalCommand, arguments, config.getLoggingFolder(), config.getEnvVariables());\r\n    if (vrtFile != null && vrtFile.exists() && vrtFile.canRead()) {\r\n        return vrtFile;\r\n    }\r\n    return vrtFile;\r\n}"
}, {
	"Path": "org.geoserver.monitor.RequestData.getBody",
	"Comment": "the body of the http requestmay be trimmed to a maximum length. if so, check getbodycontentlength for the length ofthe untrimmed body.",
	"Method": "byte[] getBody(){\r\n    return body;\r\n}"
}, {
	"Path": "org.geoserver.wcs.GetCoverageTest.executeGetCoverageXml",
	"Comment": "runs getcoverage on the specified parameters and returns an array of coverages",
	"Method": "GridCoverage[] executeGetCoverageXml(String request){\r\n    GetCoverageType getCoverage = (GetCoverageType) xmlReader.read(null, new StringReader(request), null);\r\n    return service.getCoverage(getCoverage);\r\n}"
}, {
	"Path": "org.geoserver.security.oauth2.GeoServerOAuth2SecurityConfiguration.getAccessTokenRequest",
	"Comment": "returns the resource bean containing the access token request info.",
	"Method": "AccessTokenRequest getAccessTokenRequest(){\r\n    return accessTokenRequest;\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.setup.AppSchemaTestOracleSetup.createTables",
	"Comment": "write sql string to create tables in the test database based on the property files.",
	"Method": "void createTables(Map<String, File> propertyFiles,String parser){\r\n    StringBuffer buf = new StringBuffer();\r\n    StringBuffer spatialIndex = new StringBuffer();\r\n    // drop views too\r\n    buf.append(\"CREATE OR REPLACE PROCEDURE DROP_TABLE_OR_VIEW(TabName in Varchar2) IS \").append(\"temp number:=0;\").append(\" tes VARCHAR2 (200) := TabName;\").append(\" drp_stmt VARCHAR2 (200):=null;\").append(\"BEGIN select count(*) into temp from user_tables where TABLE_NAME = tes;\").append(\"if temp = 1 then drp_stmt := 'Drop Table '||tes;\").append(\"EXECUTE IMMEDIATE drp_stmt;\").append(\"else select count(*) into temp from user_views where VIEW_NAME = tes;\").append(\"if temp = 1 then drp_stmt := 'Drop VIEW '||tes;\").append(\"EXECUTE IMMEDIATE drp_stmt;end if;end if;\").append(\"EXCEPTION WHEN OTHERS THEN \").append(\"raise_application_error(-20001,'An error was encountered - '||SQLCODE||' -ERROR- '||SQLERRM);\").append(\"END DROP_TABLE_OR_VIEW;\\n\");\r\n    for (String fileName : propertyFiles.keySet()) {\r\n        File file = new File(propertyFiles.get(fileName), fileName);\r\n        try (PropertyFeatureReader reader = new PropertyFeatureReader(\"test\", file)) {\r\n            SimpleFeatureType schema = reader.getFeatureType();\r\n            String tableName = schema.getName().getLocalPart().toUpperCase();\r\n            buf.append(\"CALL DROP_TABLE_OR_VIEW('\").append(tableName).append(\"')\\n\");\r\n            buf.append(\"CREATE TABLE \").append(tableName).append(\"(\");\r\n            int size = schema.getAttributeCount() + 1;\r\n            String[] fieldNames = new String[size];\r\n            List<String> createParams = new ArrayList<String>();\r\n            int j = 0;\r\n            String type;\r\n            String field;\r\n            int spatialIndexCounter = 0;\r\n            for (PropertyDescriptor desc : schema.getDescriptors()) {\r\n                field = desc.getName().toString().toUpperCase();\r\n                fieldNames[j] = field;\r\n                if (desc instanceof GeometryDescriptor) {\r\n                    type = \"SDO_GEOMETRY\";\r\n                    int srid = getSrid(((GeometryType) desc.getType()));\r\n                    spatialIndex.append(\"DELETE FROM user_sdo_geom_metadata WHERE table_name = '\").append(tableName).append(\"'\\n\");\r\n                    // support 3d index\r\n                    spatialIndex.append(\"Insert into user_sdo_geom_metadata \").append(\"(TABLE_NAME,COLUMN_NAME,DIMINFO,SRID)\").append(\"values ('\").append(tableName).append(\"','\").append(field).append(\"',MDSYS.SDO_DIM_ARRAY(MDSYS.SDO_DIM_ELEMENT('X',140.962,144.909,0.00001),\").append(\"MDSYS.SDO_DIM_ELEMENT('Y',-38.858,-33.98,0.00001)\").append(((GeometryDescriptor) desc).getCoordinateReferenceSystem() != null && ((GeometryDescriptor) desc).getCoordinateReferenceSystem().getCoordinateSystem().getDimension() == 3 ? \", MDSYS.SDO_DIM_ELEMENT('Z',-100000, 100000, 1) ),\" : \"),\").append(srid).append(\")\\n\");\r\n                    String indexName = (tableName.length() <= 26 ? tableName : tableName.substring(0, 26)) + \"_IDX\";\r\n                    if (spatialIndexCounter > 0) {\r\n                        indexName += spatialIndexCounter;\r\n                    }\r\n                    spatialIndex.append(\"CREATE INDEX \\\"\").append(indexName).append(\"\\\" ON \\\"\").append(tableName).append(\"\\\"(\\\"\").append(field).append(\"\\\") \").append(\"INDEXTYPE IS \\\"MDSYS\\\".\\\"SPATIAL_INDEX\\\"\\n\");\r\n                    spatialIndexCounter++;\r\n                } else {\r\n                    type = Classes.getShortName(desc.getType().getBinding());\r\n                    if (type.equalsIgnoreCase(\"String\")) {\r\n                        type = \"NVARCHAR2(250)\";\r\n                    } else if (type.equalsIgnoreCase(\"Double\")) {\r\n                        type = \"NUMBER\";\r\n                    }\r\n                }\r\n                createParams.add(field + \" \" + type);\r\n                j++;\r\n            }\r\n            fieldNames[j] = \"PKEY\";\r\n            createParams.add(\"PKEY VARCHAR2(30)\");\r\n            buf.append(StringUtils.join(createParams.iterator(), \", \"));\r\n            buf.append(\")\\n\");\r\n            buf.append(\"ALTER TABLE \" + tableName + \" ADD CONSTRAINT \" + tableName + \" PRIMARY KEY (PKEY)\\n\");\r\n            SimpleFeature feature;\r\n            FeatureId id;\r\n            while (reader.hasNext()) {\r\n                buf.append(\"INSERT INTO \").append(tableName).append(\"(\");\r\n                feature = reader.next();\r\n                buf.append(StringUtils.join(fieldNames, \", \"));\r\n                buf.append(\") \");\r\n                buf.append(\"VALUES (\");\r\n                Collection<Property> properties = feature.getProperties();\r\n                String[] values = new String[size];\r\n                int valueIndex = 0;\r\n                for (Property prop : properties) {\r\n                    Object value = prop.getValue();\r\n                    if (value instanceof Geometry) {\r\n                        Geometry geom = (Geometry) value;\r\n                        value = new WKTWriter(geom.getCoordinate().z == Double.NaN ? 2 : 3).write(geom);\r\n                    }\r\n                    if (value == null || value.toString().equalsIgnoreCase(\"null\")) {\r\n                        values[valueIndex] = \"null\";\r\n                    } else if (prop.getType() instanceof GeometryType) {\r\n                        int srid = getSrid(((GeometryType) prop.getType()));\r\n                        StringBuffer geomValue = new StringBuffer(parser + \"('\");\r\n                        geomValue.append(value).append(\"'\");\r\n                        if (srid > -1) {\r\n                            geomValue.append(\", \").append(srid);\r\n                        }\r\n                        geomValue.append(\")\");\r\n                        values[valueIndex] = geomValue.toString();\r\n                    } else if (prop.getType().getBinding().getSimpleName().equalsIgnoreCase(\"DATE\")) {\r\n                        values[valueIndex] = \"TO_DATE('\" + value + \"', 'yyyy-MM-dd')\";\r\n                    } else {\r\n                        values[valueIndex] = \"'\" + value + \"'\";\r\n                    }\r\n                    valueIndex++;\r\n                }\r\n                id = feature.getIdentifier();\r\n                values[valueIndex] = \"'\" + id.toString() + \"'\";\r\n                buf.append(StringUtils.join(values, \",\"));\r\n                buf.append(\")\\n\");\r\n            }\r\n        }\r\n        buf.append(spatialIndex.toString());\r\n        spatialIndex.delete(0, spatialIndex.length());\r\n        if (buf.length() > 0) {\r\n            this.sql = buf.toString();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.getRoot",
	"Comment": "retrieve a resource relative to the root of the data directory. an empty path will retrievethe directory itself.",
	"Method": "Resource getRoot(String path){\r\n    Resource r = get(Paths.path(path));\r\n    assert r != null;\r\n    return r;\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityFilterChain.insertAfter",
	"Comment": "inserts a filter as after another in the list corresponding to the specified pattern.",
	"Method": "boolean insertAfter(String pattern,String filterName,String positionName){\r\n    RequestFilterChain requestChain = findAndCheck(pattern, filterName);\r\n    if (requestChain == null) {\r\n        return false;\r\n    }\r\n    List<String> filterNames = requestChain.getFilterNames();\r\n    int index = filterNames.indexOf(positionName);\r\n    if (index == -1) {\r\n        return false;\r\n    }\r\n    filterNames.add(index + 1, filterName);\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.wps.resource.WPSResourceManager.getOutputResourceUrl",
	"Comment": "returns the url to fetch a output resource using the getexecutionresult call",
	"Method": "String getOutputResourceUrl(String name,String mimeType,String getOutputResourceUrl,String executionId,String name,String baseUrl,String mimeType){\r\n    Map<String, String> kvp = new LinkedHashMap<String, String>();\r\n    kvp.put(\"service\", \"WPS\");\r\n    kvp.put(\"version\", \"1.0.0\");\r\n    kvp.put(\"request\", \"GetExecutionResult\");\r\n    kvp.put(\"executionId\", getExecutionId(executionId));\r\n    kvp.put(\"outputId\", name);\r\n    kvp.put(\"mimetype\", mimeType);\r\n    if (baseUrl == null) {\r\n        Operation op = Dispatcher.REQUEST.get().getOperation();\r\n        ExecuteType execute = (ExecuteType) op.getParameters()[0];\r\n        baseUrl = execute.getBaseUrl();\r\n    }\r\n    String url = ResponseUtils.buildURL(baseUrl, \"ows\", kvp, URLType.SERVICE);\r\n    return url;\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaMockData.getFeatureTypesBaseDir",
	"Comment": "return the featuretypes directory under which individual feature type folders are stored.",
	"Method": "File getFeatureTypesBaseDir(){\r\n    return featureTypesBaseDir;\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.GeoServerInstance.resetConsumedEventsCount",
	"Comment": "resets the total number of jms events consumed by this geoserver instance.",
	"Method": "void resetConsumedEventsCount(){\r\n    jmsQueueListener.resetconsumedevents();\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findSuppWorkspaceFile",
	"Comment": "returns a supplementary configuration file for a workspace, if the file does not exist nullis returned.",
	"Method": "File findSuppWorkspaceFile(WorkspaceInfo ws,String filename){\r\n    Resource resource = get(ws, filename);\r\n    return Resources.file(resource);\r\n}"
}, {
	"Path": "org.geoserver.security.impl.DataAccessRule.getValue",
	"Comment": "returns the list of roles as a comma separated string for this rule",
	"Method": "String getValue(){\r\n    if (roles.isEmpty()) {\r\n        return DataAccessRule.ANY;\r\n    } else {\r\n        StringBuffer sb = new StringBuffer();\r\n        for (String role : roles) {\r\n            sb.append(role);\r\n            sb.append(\",\");\r\n        }\r\n        sb.setLength(sb.length() - 1);\r\n        return sb.toString();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.CatalogBuilder.buildLayer",
	"Comment": "builds a layer wrapping a wms layer resourcethe resulting object is not added to the catalog, it must be done by the calling codeafter the fact.",
	"Method": "LayerInfo buildLayer(FeatureTypeInfo featureType,LayerInfo buildLayer,CoverageInfo coverage,LayerInfo buildLayer,WMSLayerInfo wms,LayerInfo buildLayer,ResourceInfo resource){\r\n    LayerInfo layer = catalog.getFactory().createLayer();\r\n    layer.setResource(resource);\r\n    layer.setName(resource.getName());\r\n    layer.setEnabled(true);\r\n    if (layer.getResource() instanceof FeatureTypeInfo) {\r\n        layer.setType(PublishedType.VECTOR);\r\n    } else if (layer.getResource() instanceof CoverageInfo) {\r\n        layer.setType(PublishedType.RASTER);\r\n    } else if (layer.getResource() instanceof WMTSLayerInfo) {\r\n        layer.setType(PublishedType.WMTS);\r\n    } else if (layer.getResource() instanceof WMSLayerInfo) {\r\n        layer.setType(PublishedType.WMS);\r\n    }\r\n    return layer;\r\n}"
}, {
	"Path": "org.geoserver.web.wicket.SRSListPanel.createLinkForCode",
	"Comment": "creates a link for an epsgcode.subclasses may override to perform an action when an epsg code has been selected. thisdefault implementation returns a link that does nothing.",
	"Method": "Component createLinkForCode(String linkId,IModel<SRS> itemModel){\r\n    return new SimpleAjaxLink<Object>(linkId, (IModel<Object>) SRSProvider.CODE.getModel(itemModel)) {\r\n        private static final long serialVersionUID = -1330723116026268069L;\r\n        @Override\r\n        protected void onClick(AjaxRequestTarget target) {\r\n            onCodeClicked(target, getDefaultModelObjectAsString());\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.geoserver.web.wicket.SRSListPanel.createLinkForCode",
	"Comment": "creates a link for an epsgcode.subclasses may override to perform an action when an epsg code has been selected. thisdefault implementation returns a link that does nothing.",
	"Method": "Component createLinkForCode(String linkId,IModel<SRS> itemModel){\r\n    onCodeClicked(target, getDefaultModelObjectAsString());\r\n}"
}, {
	"Path": "org.geoserver.wps.remote.RemoteProcessClient.getImporter",
	"Comment": "accessor for global geoserver instance from the test application context.",
	"Method": "Importer getImporter(){\r\n    return (Importer) GeoServerExtensions.bean(\"importer\");\r\n}"
}, {
	"Path": "org.geoserver.web.LoginFormInfo.setFilterClass",
	"Comment": "sets the geoserversecurityfilter class requiring the login button",
	"Method": "void setFilterClass(Class<GeoServerSecurityProvider> filterClass){\r\n    this.filterClass = filterClass;\r\n}"
}, {
	"Path": "org.geoserver.wfs.xslt.config.TransformRepository.getTypeTransforms",
	"Comment": "returns transformations associated to a specific feature type",
	"Method": "List<TransformInfo> getTypeTransforms(FeatureTypeInfo featureType){\r\n    List<TransformInfo> allTransformations = getAllTransforms();\r\n    List<TransformInfo> result = new ArrayList<TransformInfo>();\r\n    for (TransformInfo ti : allTransformations) {\r\n        if (ti.getFeatureType() != null && ti.getFeatureType().getId().equals(featureType.getId())) {\r\n            result.add(ti);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaTestSupport.assertXpathNotMatches",
	"Comment": "assert that the flattened value of an xpath expression in a document doe not match a regularexpression.",
	"Method": "void assertXpathNotMatches(String regex,String xpath,Document document){\r\n    assertFalse(evaluate(xpath, document).matches(regex));\r\n}"
}, {
	"Path": "org.geoserver.script.ScriptManager.ext",
	"Comment": "helper method for extracting extension from filename throwing exception if the file has noextension.",
	"Method": "String ext(String scriptName){\r\n    String ext = FilenameUtils.getExtension(scriptName);\r\n    if (ext == null) {\r\n        throw new IllegalArgumentException(scriptName + \" has no extension\");\r\n    }\r\n    return ext;\r\n}"
}, {
	"Path": "org.geoserver.community.css.web.StyleEditCssRecoveryTest.testRecoverLostCssStyleWithFormatSetToSLD",
	"Comment": "test recovery of a css style generated by the old css extension, when the styleinfo declaressld and its filename points to a derived sld.",
	"Method": "void testRecoverLostCssStyleWithFormatSetToSLD(){\r\n    StyleInfo styleInfo = catalog.getStyleByName(oldCssStyleWithFormatSLD);\r\n    StyleEditPage edit = new StyleEditPage(styleInfo);\r\n    tester.startPage(edit);\r\n    tester.assertRenderedPage(StyleEditPage.class);\r\n    tester.assertNoErrorMessage();\r\n    tester.assertModelValue(\"styleForm:context:panel:format\", \"css\");\r\n    String editorContents = (String) tester.getComponentFromLastRenderedPage(\"styleForm:styleEditor:editorContainer:editorParent:editor\").getDefaultModelObject();\r\n    Styles.handler(\"css\").parse(editorContents, null, null, null);\r\n    StyleInfo si = catalog.getStyleByName(oldCssStyleWithFormatSLD);\r\n    assertEquals(\"css\", si.getFormat());\r\n    assertEquals(oldCssStyleWithFormatSLD + \".css\", si.getFilename());\r\n}"
}, {
	"Path": "org.geoserver.web.wicket.GeoServerTablePanel.getPropertyTitle",
	"Comment": "returns a model for this property title. default behaviour is to lookup for a resource name.th.",
	"Method": "IModel<String> getPropertyTitle(Property<T> property){\r\n    ResourceModel resMod = new ResourceModel(\"th.\" + property.getName(), property.getName());\r\n    return resMod;\r\n}"
}, {
	"Path": "org.geoserver.geofence.config.GeoFenceConfiguration.setInstanceName",
	"Comment": "name of this geoserver instance for geofence rule configuration.",
	"Method": "void setInstanceName(String instanceName){\r\n    this.instanceName = instanceName;\r\n}"
}, {
	"Path": "org.geoserver.wcs.GetCoverageTest.executeGetCoverageKvp",
	"Comment": "runs getcoverage on the specified parameters and returns an array of coverages",
	"Method": "GridCoverage[] executeGetCoverageKvp(Map<String, Object> raw){\r\n    final GetCoverageType getCoverage = (GetCoverageType) kvpreader.read(kvpreader.createRequest(), parseKvp(raw), raw);\r\n    return service.getCoverage(getCoverage);\r\n}"
}, {
	"Path": "org.geoserver.rest.util.RESTUtils.handleBinUpload",
	"Comment": "reads content from the body of a request and writes it to a file.",
	"Method": "org.geoserver.platform.resource.Resource handleBinUpload(String fileName,org.geoserver.platform.resource.Resource directory,boolean deleteDirectoryContent,HttpServletRequest request,org.geoserver.platform.resource.Resource handleBinUpload,String fileName,org.geoserver.platform.resource.Resource directory,boolean deleteDirectoryContent,HttpServletRequest request,String workSpace){\r\n    StringBuilder itemPath = new StringBuilder(fileName);\r\n    MediaType mediaType = request.getContentType() == null ? null : MediaType.valueOf(request.getContentType());\r\n    if (mediaType == null || !isZipMediaType(mediaType)) {\r\n        String baseName = FilenameUtils.getBaseName(fileName);\r\n        String itemName = FilenameUtils.getName(fileName);\r\n        Map<String, String> storeParams = new HashMap();\r\n        remapping(workSpace, baseName, itemPath, itemName, storeParams);\r\n    }\r\n    final org.geoserver.platform.resource.Resource newFile = directory.get(itemPath.toString());\r\n    if (Resources.exists(newFile)) {\r\n        if (deleteDirectoryContent) {\r\n            for (Resource file : directory.list()) {\r\n                file.delete();\r\n            }\r\n        } else {\r\n            newFile.delete();\r\n        }\r\n    }\r\n    try (OutputStream os = newFile.out()) {\r\n        IOUtils.copy(request.getInputStream(), os);\r\n    }\r\n    return newFile;\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.HistogramUtils.getEnumeratedBuckets",
	"Comment": "helper method that creates buckets for an enumerated domain. the returned tuple will containthe domain representation and the domain buckets. note that in this case the resolution willbe ignored.",
	"Method": "Tuple<String, List<Range>> getEnumeratedBuckets(List<Object> domainValues){\r\n    StringBuilder domain = new StringBuilder();\r\n    List<Range> buckets = new ArrayList();\r\n    for (Object value : domainValues) {\r\n        String stringValue = value.toString();\r\n        domain.append(stringValue).append(',');\r\n        buckets.add(new EnumeratedRange(stringValue));\r\n    }\r\n    domain.delete(domain.length() - 1, domain.length());\r\n    return Tuple.tuple(domain.toString(), buckets);\r\n}"
}, {
	"Path": "org.geoserver.web.data.resource.DimensionEditor.disablePresentationMode",
	"Comment": "allows to remove presentation modes from the editor. if only a single presentation mode isleft the editor will setup in non enabled mode and will return that fixed value",
	"Method": "void disablePresentationMode(DimensionPresentation mode){\r\n    presentationModes.remove(mode);\r\n    if (presentationModes.size() <= 1) {\r\n        presentation.setModelObject(presentationModes.get(0));\r\n        presentation.setEnabled(false);\r\n    }\r\n}"
}, {
	"Path": "org.vfny.geoserver.wms.responses.map.htmlimagemap.EncodeHTMLImageMap.processRuleForQuery",
	"Comment": "applies filters from style rules to the given query, to optimize datastore queries. similarto the method in streamingrenderer.",
	"Method": "Filter processRuleForQuery(FeatureTypeStyle[] styles){\r\n    try {\r\n        final List<Filter> filtersToDS = new ArrayList<Filter>();\r\n        final int stylesLength = styles.length;\r\n        int styleRulesLength;\r\n        FeatureTypeStyle style;\r\n        int u = 0;\r\n        Rule r;\r\n        for (int t = 0; t < stylesLength; t++) {\r\n            style = styles[t];\r\n            Rule[] rules = style.getRules();\r\n            styleRulesLength = rules.length;\r\n            for (u = 0; u < styleRulesLength; u++) {\r\n                r = rules[u];\r\n                if (r.getFilter() == null)\r\n                    return null;\r\n                if (r.hasElseFilter())\r\n                    return null;\r\n                filtersToDS.add(r.getFilter());\r\n            }\r\n        }\r\n        Filter ruleFiltersCombined = null;\r\n        Filter newFilter;\r\n        if (filtersToDS.size() == 1) {\r\n            ruleFiltersCombined = filtersToDS.get(0);\r\n        } else if (filtersToDS.size() < maxFilterSize) {\r\n            ruleFiltersCombined = filtersToDS.get(0);\r\n            final int size = filtersToDS.size();\r\n            for (int t = 1; t < size; t++) {\r\n                newFilter = filtersToDS.get(t);\r\n                ruleFiltersCombined = filterFactory.or(ruleFiltersCombined, newFilter);\r\n            }\r\n        }\r\n        return ruleFiltersCombined;\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.SecureCatalogImpl.filterStores",
	"Comment": "given a list of stores, returns a copy of it containing only the resources the user canaccess",
	"Method": "List<T> filterStores(Authentication user,List<T> resources){\r\n    List<T> result = new ArrayList<T>();\r\n    for (T original : resources) {\r\n        T secured = checkAccess(user, original, MixedModeBehavior.HIDE);\r\n        if (secured != null)\r\n            result.add(secured);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.script.ScriptManager.findOrCreateScriptFile",
	"Comment": "finds a script file at the specified path, creating it if necessary.",
	"Method": "File findOrCreateScriptFile(String path){\r\n    return script(path).file();\r\n}"
}, {
	"Path": "org.geoserver.security.file.FileWatcher.setLastModified",
	"Comment": "method intended to set last modified from a client which is up to date. this avoidsunnecessary reloads",
	"Method": "void setLastModified(long lastModified){\r\n    synchronized (lastModifiedLock) {\r\n        this.lastModified = lastModified;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerBasePage.setReturnPage",
	"Comment": "sets the return page class to navigate to when this page is done its task.",
	"Method": "GeoServerBasePage setReturnPage(Page returnPage,GeoServerBasePage setReturnPage,Class<? extends Page> returnPageClass){\r\n    this.returnPageClass = returnPageClass;\r\n    return this;\r\n}"
}, {
	"Path": "org.geoserver.util.XmlTestUtil.printDom",
	"Comment": "print a dom tree to an output stream or if there is an exception while doing so, print thestack trace.",
	"Method": "void printDom(Node dom,OutputStream os){\r\n    Transformer trans;\r\n    PrintWriter w = new PrintWriter(os);\r\n    try {\r\n        TransformerFactory fact = TransformerFactory.newInstance();\r\n        trans = fact.newTransformer();\r\n        trans.transform(new DOMSource(dom), new StreamResult(new OutputStreamWriter(os)));\r\n    } catch (TransformerException e) {\r\n        w.println(\"An error ocurred while transforming the given DOM:\");\r\n        e.printStackTrace(w);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wcs.DefaultWebCoverageService100.checkOutput",
	"Comment": "checks that the elements of the output part of the request do make sense by comparing them tothe coverage metadata",
	"Method": "void checkOutput(CoverageInfo meta,OutputType output){\r\n    if (output == null)\r\n        return;\r\n    String format = output.getFormat().getValue();\r\n    String declaredFormat = getDeclaredFormat(meta.getSupportedFormats(), format);\r\n    if (declaredFormat == null)\r\n        throw new WcsException(\"format \" + format + \" is not supported for this coverage\", InvalidParameterValue, \"format\");\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.listAuthenticationProviders",
	"Comment": "lists all available authentication provider configurations.",
	"Method": "SortedSet<String> listAuthenticationProviders(){\r\n    return listFiles(auth());\r\n}"
}, {
	"Path": "org.geoserver.inspire.ViewServicesTestSupport.testNoMediaType",
	"Comment": "test extendedcapabilities response when optional settings missing",
	"Method": "void testNoMediaType(){\r\n    final ServiceInfo serviceInfo = getServiceInfo();\r\n    final MetadataMap metadata = serviceInfo.getMetadata();\r\n    clearInspireMetadata(metadata);\r\n    metadata.put(CREATE_EXTENDED_CAPABILITIES.key, true);\r\n    metadata.put(SERVICE_METADATA_URL.key, getMetadataUrl());\r\n    metadata.put(LANGUAGE.key, getLanguage());\r\n    getGeoServer().save(serviceInfo);\r\n    final Document dom = getAsDOM(getGetCapabilitiesRequestPath());\r\n    NodeList nodeList = dom.getElementsByTagNameNS(getInspireNameSpace(), \"ExtendedCapabilities\");\r\n    assertEquals(\"Number of INSPIRE ExtendedCapabilities elements\", 1, nodeList.getLength());\r\n    nodeList = dom.getElementsByTagNameNS(COMMON_NAMESPACE, \"MediaType\");\r\n    assertEquals(\"Number of MediaType elements\", 0, nodeList.getLength());\r\n}"
}, {
	"Path": "org.geoserver.ows.util.OwsUtils.updateMapProperty",
	"Comment": "helper method for updating a map based property. only used if setter is null.",
	"Method": "void updateMapProperty(Object object,Map newValue,Method getter){\r\n    Map oldValue = (Map) getter.invoke(object, null);\r\n    if (oldValue != null) {\r\n        oldValue.clear();\r\n        oldValue.putAll(newValue);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexMongoDBSupport.getFixtureFile",
	"Comment": "gets the fixture file for mongodb, parent directories are created if needed.",
	"Method": "File getFixtureFile(){\r\n    File directory = new File(System.getProperty(\"user.home\") + File.separator + \".geoserver\");\r\n    if (!directory.exists()) {\r\n        directory.mkdir();\r\n    }\r\n    return new File(directory, \"mongodb.properties\");\r\n}"
}, {
	"Path": "org.geoserver.flow.controller.AbstractFlowControllerTest.waitAndKill",
	"Comment": "waits maxwait for the thread to finish by itself, then forcefully kills it",
	"Method": "void waitAndKill(Thread t,long maxWait){\r\n    try {\r\n        long start = System.currentTimeMillis();\r\n        while (t.isAlive()) {\r\n            if (System.currentTimeMillis() > (start + maxWait)) {\r\n                t.interrupt();\r\n            }\r\n            Thread.sleep(20);\r\n        }\r\n    } catch (InterruptedException e) {\r\n        fail(\"Sometime interrupeted our wait: \" + e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.geofence.config.GeoFenceConfiguration.setUseRolesToFilter",
	"Comment": "use authenticated users roles to match rules, instead of username.",
	"Method": "void setUseRolesToFilter(boolean useRolesToFilter){\r\n    this.useRolesToFilter = useRolesToFilter;\r\n}"
}, {
	"Path": "org.geoserver.csw.DirectDownloadTest.getMatchingNodes",
	"Comment": "return the list of nodes in a document that match an xpath expression.",
	"Method": "NodeList getMatchingNodes(String xpath,Document document){\r\n    try {\r\n        return getXpathEngine().getMatchingNodes(xpath, document);\r\n    } catch (XpathException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.ContourProcessTest.testProcessStandaloneBasicInterval",
	"Comment": "test basic capabilities for the contour process. it works on the dem tiff and produces ashapefile. nothing more nothing less.",
	"Method": "void testProcessStandaloneBasicInterval(){\r\n    final GridCoverage2D gc = extractCoverageSubset();\r\n    final double step = 100;\r\n    final ContourProcess process = new ContourProcess();\r\n    final SimpleFeatureCollection fc = process.execute(gc, 0, null, Double.valueOf(step), false, false, null, new NullProgressListener());\r\n    assertNotNull(fc);\r\n    assertTrue(fc.size() > 0);\r\n    SimpleFeatureIterator fi = fc.features();\r\n    while (fi.hasNext()) {\r\n        SimpleFeature sf = fi.next();\r\n        Double value = (Double) sf.getAttribute(\"value\");\r\n        assertTrue(value > 0);\r\n    }\r\n    fi.close();\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.MultiDimensionalExtensionTest.getResultAsDocument",
	"Comment": "helper method that simply extracts the result of a request to a string and build a document.also checks the content type of the response.",
	"Method": "Document getResultAsDocument(MockHttpServletResponse response,Document getResultAsDocument,MockHttpServletResponse response,String contentType,Document getResultAsDocument,MockHttpServletResponse response,String contentType,HttpStatus expectedStatus){\r\n    String result = response.getContentAsString();\r\n    assertThat(response.getStatus(), is(expectedStatus.value()));\r\n    assertThat(response.getContentType(), is(contentType));\r\n    return XMLUnit.buildTestDocument(result);\r\n}"
}, {
	"Path": "org.geoserver.ows.XmlObjectEncodingResponse.getSchemaLocations",
	"Comment": "subclasses can override this method to return the necessary schema location declarations",
	"Method": "Map<String, String> getSchemaLocations(){\r\n    return Collections.emptyMap();\r\n}"
}, {
	"Path": "org.geoserver.util.ReaderUtils.getDoubleAttribute",
	"Comment": "getdoubleattribute purpose.used to help with xml manipulations. returns the first child integer attribute of thespecified name. an exception occurs when the node is required and not found.",
	"Method": "double getDoubleAttribute(Element elem,String attName,boolean mandatory){\r\n    String value = getAttribute(elem, attName, mandatory);\r\n    if ((value == null) || (value == \"\")) {\r\n        return 0.0;\r\n    }\r\n    double d = Double.NaN;\r\n    if (value != null) {\r\n        try {\r\n            d = Double.parseDouble(value);\r\n        } catch (NumberFormatException ex) {\r\n            throw new ConfigurationException(\"Illegal attribute value for \" + attName + \" in element \" + elem.getNodeName() + \". Expected double, but was \" + value);\r\n        }\r\n    }\r\n    return d;\r\n}"
}, {
	"Path": "org.geoserver.security.file.UserGroupFileWatcher.usersAndGroupsChanged",
	"Comment": "another method to avoid reloads if this object is registered",
	"Method": "void usersAndGroupsChanged(UserGroupLoadedEvent event){\r\n    setLastModified(resource.lastmodified());\r\n    LOGGER.info(\"Adjusted last modified for file: \" + path);\r\n}"
}, {
	"Path": "org.geoserver.test.FeatureChainingWfsTest.readJsonObject",
	"Comment": "helper method that just reads a json object from a resource file.",
	"Method": "JSONObject readJsonObject(String resourcePath){\r\n    InputStream input = this.getClass().getResourceAsStream(resourcePath);\r\n    assertThat(input, notNullValue());\r\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\r\n    IOUtils.copy(input, output);\r\n    String jsonText = new String(output.toByteArray());\r\n    return JSONObject.fromObject(jsonText);\r\n}"
}, {
	"Path": "org.geoserver.rest.security.AccessControllersTest.checkRolesStringsForEquality",
	"Comment": "checks role strings for equalitye. g. role1,role2 is equal to role2,role1",
	"Method": "boolean checkRolesStringsForEquality(String roleString1,String roleString2){\r\n    String[] roleArray1 = roleString1.split(\",\");\r\n    String[] roleArray2 = roleString2.split(\",\");\r\n    if (roleArray1.length != roleArray2.length)\r\n        return false;\r\n    Set<String> roleSet1 = new HashSet();\r\n    for (String role : roleArray1) roleSet1.add(role.trim());\r\n    Set<String> roleSet2 = new HashSet();\r\n    for (String role : roleArray2) roleSet2.add(role.trim());\r\n    for (String role : roleSet1) {\r\n        if (!roleSet2.contains(role))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.feature.retype.FullyRetypingDataStoreTest.testAppend",
	"Comment": "this test is made with mock objects because the property data store does not generate fids inthe . form",
	"Method": "void testAppend(){\r\n    SimpleFeatureType type = DataUtilities.createType(\"trees\", \"the_geom:Point,FID:String,NAME:String\");\r\n    SimpleFeatureStore fs = createMock(SimpleFeatureStore.class);\r\n    expect(fs.addFeatures(isA(FeatureCollection.class))).andReturn(Collections.singletonList((FeatureId) (new FeatureIdImpl(\"trees.105\"))));\r\n    replay(fs);\r\n    DataStore ds = createMock(DataStore.class);\r\n    expect(ds.getTypeNames()).andReturn(new String[] { \"trees\" }).anyTimes();\r\n    expect(ds.getSchema(\"trees\")).andReturn(type).anyTimes();\r\n    expect(ds.getFeatureSource(\"trees\")).andReturn(fs);\r\n    replay(ds);\r\n    RetypingDataStore rts = new RetypingDataStore(ds) {\r\n        @Override\r\n        protected String transformFeatureTypeName(String originalName) {\r\n            return \"oaks\";\r\n        }\r\n    };\r\n    SimpleFeatureBuilder sfb = new SimpleFeatureBuilder(type);\r\n    WKTReader reader = new WKTReader();\r\n    sfb.set(\"the_geom\", reader.read(\"POINT (0.002 0.0008)\"));\r\n    sfb.set(\"FID\", \"023\");\r\n    sfb.set(\"NAME\", \"Old oak\");\r\n    SimpleFeature feature = sfb.buildFeature(null);\r\n    SimpleFeatureCollection fc = DataUtilities.collection(feature);\r\n    SimpleFeatureStore store = (SimpleFeatureStore) rts.getFeatureSource(\"oaks\");\r\n    List<FeatureId> ids = store.addFeatures(fc);\r\n    assertEquals(1, ids.size());\r\n    String id = ((FeatureId) ids.iterator().next()).getID();\r\n    assertTrue(\"Id does not start with \" + \"oaks\" + \" it's \" + id, id.startsWith(\"oaks\"));\r\n}"
}, {
	"Path": "org.geoserver.feature.retype.FullyRetypingDataStoreTest.testAppend",
	"Comment": "this test is made with mock objects because the property data store does not generate fids inthe . form",
	"Method": "void testAppend(){\r\n    return \"oaks\";\r\n}"
}, {
	"Path": "org.geoserver.security.AbstractCatalogFilter.getSecurityFilter",
	"Comment": "returns a filter equivalent to this catalogfilter when applied to an object of the specifiedtype. implementers should override and return an appropriate well known filter",
	"Method": "Filter getSecurityFilter(Class<? extends CatalogInfo> clazz){\r\n    org.opengis.filter.expression.Function visible;\r\n    if (ResourceInfo.class.isAssignableFrom(clazz)) {\r\n        visible = new InternalVolatileFunction() {\r\n            @Override\r\n            public Boolean evaluate(Object object) {\r\n                return !hideResource((ResourceInfo) object);\r\n            }\r\n        };\r\n    } else if (WorkspaceInfo.class.isAssignableFrom(clazz)) {\r\n        visible = new InternalVolatileFunction() {\r\n            @Override\r\n            public Boolean evaluate(Object object) {\r\n                return !hideWorkspace((WorkspaceInfo) object);\r\n            }\r\n        };\r\n    } else if (LayerGroupInfo.class.isAssignableFrom(clazz)) {\r\n        visible = new InternalVolatileFunction() {\r\n            @Override\r\n            public Boolean evaluate(Object object) {\r\n                return !hideLayerGroup((LayerGroupInfo) object);\r\n            }\r\n        };\r\n    } else if (StyleInfo.class.isAssignableFrom(clazz)) {\r\n        visible = new InternalVolatileFunction() {\r\n            @Override\r\n            public Boolean evaluate(Object object) {\r\n                return !hideStyle((StyleInfo) object);\r\n            }\r\n        };\r\n    } else if (LayerInfo.class.isAssignableFrom(clazz)) {\r\n        visible = new InternalVolatileFunction() {\r\n            @Override\r\n            public Boolean evaluate(Object object) {\r\n                return !hideLayer((LayerInfo) object);\r\n            }\r\n        };\r\n    } else if (NamespaceInfo.class.isAssignableFrom(clazz)) {\r\n        visible = new InternalVolatileFunction() {\r\n            @Override\r\n            public Boolean evaluate(Object object) {\r\n                WorkspaceInfo wsInfo = getCatalog().getWorkspaceByName(((NamespaceInfo) object).getPrefix());\r\n                return !hideWorkspace(wsInfo);\r\n            }\r\n        };\r\n    } else {\r\n        LOGGER.log(Level.FINE, \"CatalogFilter does not recognize interface {0} accepting all.\", clazz);\r\n        return Predicates.acceptAll();\r\n    }\r\n    FilterFactory factory = Predicates.factory;\r\n    Filter filter = factory.equals(factory.literal(Boolean.TRUE), visible);\r\n    return filter;\r\n}"
}, {
	"Path": "org.geoserver.security.AbstractCatalogFilter.getSecurityFilter",
	"Comment": "returns a filter equivalent to this catalogfilter when applied to an object of the specifiedtype. implementers should override and return an appropriate well known filter",
	"Method": "Filter getSecurityFilter(Class<? extends CatalogInfo> clazz){\r\n    return !hideResource((ResourceInfo) object);\r\n}"
}, {
	"Path": "org.geoserver.security.AbstractCatalogFilter.getSecurityFilter",
	"Comment": "returns a filter equivalent to this catalogfilter when applied to an object of the specifiedtype. implementers should override and return an appropriate well known filter",
	"Method": "Filter getSecurityFilter(Class<? extends CatalogInfo> clazz){\r\n    return !hideWorkspace((WorkspaceInfo) object);\r\n}"
}, {
	"Path": "org.geoserver.security.AbstractCatalogFilter.getSecurityFilter",
	"Comment": "returns a filter equivalent to this catalogfilter when applied to an object of the specifiedtype. implementers should override and return an appropriate well known filter",
	"Method": "Filter getSecurityFilter(Class<? extends CatalogInfo> clazz){\r\n    return !hideLayerGroup((LayerGroupInfo) object);\r\n}"
}, {
	"Path": "org.geoserver.security.AbstractCatalogFilter.getSecurityFilter",
	"Comment": "returns a filter equivalent to this catalogfilter when applied to an object of the specifiedtype. implementers should override and return an appropriate well known filter",
	"Method": "Filter getSecurityFilter(Class<? extends CatalogInfo> clazz){\r\n    return !hideStyle((StyleInfo) object);\r\n}"
}, {
	"Path": "org.geoserver.security.AbstractCatalogFilter.getSecurityFilter",
	"Comment": "returns a filter equivalent to this catalogfilter when applied to an object of the specifiedtype. implementers should override and return an appropriate well known filter",
	"Method": "Filter getSecurityFilter(Class<? extends CatalogInfo> clazz){\r\n    return !hideLayer((LayerInfo) object);\r\n}"
}, {
	"Path": "org.geoserver.security.AbstractCatalogFilter.getSecurityFilter",
	"Comment": "returns a filter equivalent to this catalogfilter when applied to an object of the specifiedtype. implementers should override and return an appropriate well known filter",
	"Method": "Filter getSecurityFilter(Class<? extends CatalogInfo> clazz){\r\n    WorkspaceInfo wsInfo = getCatalog().getWorkspaceByName(((NamespaceInfo) object).getPrefix());\r\n    return !hideWorkspace(wsInfo);\r\n}"
}, {
	"Path": "org.vfny.geoserver.wms.responses.map.htmlimagemap.EncodeHTMLImageMap.filterRules",
	"Comment": "filter given rules, to consider only the rules compatible with the current scale.",
	"Method": "Rule[] filterRules(Rule[] rules){\r\n    List<Rule> result = new ArrayList<Rule>();\r\n    for (int count = 0; count < rules.length; count++) {\r\n        Rule rule = rules[count];\r\n        double scaleDenominator;\r\n        try {\r\n            scaleDenominator = RendererUtilities.calculateScale(mapContent.getRenderingArea(), mapContent.getMapWidth(), mapContent.getMapHeight(), 90);\r\n            if (EncodeHTMLImageMap.isWithInScale(rule, scaleDenominator)) {\r\n                result.add(rule);\r\n            }\r\n        } catch (TransformException e) {\r\n            e.printStackTrace();\r\n        } catch (FactoryException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    return result.toArray(new Rule[result.size()]);\r\n}"
}, {
	"Path": "org.geoserver.security.SecureCatalogImpl.checkAccess",
	"Comment": "given a workspace and user, returns it back if the user can access it, null otherwise",
	"Method": "T checkAccess(Authentication user,T info,MixedModeBehavior mixedModeBehavior,T checkAccess,Authentication user,T info,MixedModeBehavior mixedModeBehavior,List<LayerGroupInfo> containers,T checkAccess,Authentication user,T info,MixedModeBehavior mixedModeBehavior,StyleInfo checkAccess,Authentication user,StyleInfo style,MixedModeBehavior mixedModeBehavior,T checkAccess,Authentication user,T store,MixedModeBehavior mixedModeBehavior,LayerInfo checkAccess,Authentication user,LayerInfo layer,MixedModeBehavior mixedModeBehavior,List<LayerGroupInfo> containers,LayerGroupInfo checkAccess,Authentication user,LayerGroupInfo group,MixedModeBehavior mixedModeBehavior,List<LayerGroupInfo> containers,T checkAccess,Authentication user,T ns,MixedModeBehavior mixedModeBehavior,T checkAccess,Authentication user,T ws,MixedModeBehavior mixedModeBehavior){\r\n    if (ws == null)\r\n        return null;\r\n    WrapperPolicy policy = buildWrapperPolicy(user, ws, ws.getName(), mixedModeBehavior);\r\n    if (policy.level == AccessLevel.HIDDEN)\r\n        return null;\r\n    else\r\n        return ws;\r\n}"
}, {
	"Path": "org.geoserver.nsg.pagination.random.IndexOutputFormat.addResultSetIdElement",
	"Comment": "helper method that adds the resultsetid attribute to xml result. if no featurecollectionelement can be found nothing will be done.",
	"Method": "void addResultSetIdElement(Document document,String resultSetId){\r\n    NodeList nodes = document.getElementsByTagName(\"wfs:FeatureCollection\");\r\n    if (nodes.getLength() != 1) {\r\n        LOGGER.warning(\"No feature collection element could be found, resultSetID attribute will not be added.\");\r\n        return;\r\n    }\r\n    Node node = nodes.item(0);\r\n    if (node.getNodeType() == Node.ELEMENT_NODE) {\r\n        Element element = (Element) node;\r\n        element.setAttribute(\"resultSetID\", resultSetId);\r\n    } else {\r\n        LOGGER.warning(\"Feature collection node is not a XML element, resultSetID attribute will not be added.\");\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.StationsMockData.getGml31StandardParamaters",
	"Comment": "return a map containing the standard placeholders with the corresponding gml31 values.",
	"Method": "Map<String, String> getGml31StandardParamaters(){\r\n    Map<String, String> gml31Parameters = new HashMap();\r\n    gml31Parameters.put(\"GML_PREFIX\", \"gml31\");\r\n    gml31Parameters.put(\"GML_PREFIX_UPPER\", \"GML31\");\r\n    gml31Parameters.put(\"GML_NAMESPACE\", \"http://www.opengis.net/gml\");\r\n    gml31Parameters.put(\"GML_LOCATION\", \"http://schemas.opengis.net/gml/3.1.1/base/gml.xsd\");\r\n    return gml31Parameters;\r\n}"
}, {
	"Path": "org.geoserver.wps.remote.plugin.server.XMPPBoshEndpoint.createHandler",
	"Comment": "create handler for bosh. for a different handler setup, override in a subclass. for more thanone handler, add them to a org.eclipse.jetty.server.handler.contexthandlercollection andreturn the collection",
	"Method": "Handler createHandler(){\r\n    ServletContextHandler boshContext = new ServletContextHandler(ServletContextHandler.SESSIONS);\r\n    boshContext.setContextPath(contextPath);\r\n    BoshServlet boshServlet = new BoshServlet();\r\n    boshServlet.setServerRuntimeContext(serverRuntimeContext);\r\n    boshServlet.setAccessControlAllowOrigin(accessControlAllowOrigin);\r\n    boshContext.addServlet(new ServletHolder(boshServlet), \"/\");\r\n    return boshContext;\r\n}"
}, {
	"Path": "org.geoserver.wms.capabilities.DimensionHelper.getMinMaxZInterval",
	"Comment": "builds a single z range from the domain, be it made of double or numberrange objects",
	"Method": "NumberRange<Double> getMinMaxZInterval(TreeSet<? extends Object> values){\r\n    Object minValue = values.first();\r\n    Object maxValue = values.last();\r\n    Double min, max;\r\n    if (minValue instanceof NumberRange) {\r\n        min = ((NumberRange<Double>) minValue).getMinValue();\r\n    } else {\r\n        min = (Double) minValue;\r\n    }\r\n    if (maxValue instanceof NumberRange) {\r\n        max = ((NumberRange<Double>) maxValue).getMaxValue();\r\n    } else {\r\n        max = (Double) maxValue;\r\n    }\r\n    return new NumberRange<Double>(Double.class, min, max);\r\n}"
}, {
	"Path": "org.geoserver.wps.executor.WPSExecutionManager.setConnectionTimeout",
	"Comment": "sets the http connection timeout for remote resource fetching",
	"Method": "void setConnectionTimeout(int connectionTimeout){\r\n    this.connectionTimeout = connectionTimeout;\r\n}"
}, {
	"Path": "org.geoserver.ows.TestBufferStrategy.abort",
	"Comment": "clears the buffer with out writing anything out to response.",
	"Method": "void abort(){\r\n    buffer = null;\r\n}"
}, {
	"Path": "org.geoserver.kml.KMLReflectorTest.testSuperOverlayReflection",
	"Comment": "do some spot checks on the kml generated when an overlay hierarchy is requested.",
	"Method": "void testSuperOverlayReflection(){\r\n    final String layerName = MockData.BASIC_POLYGONS.getPrefix() + \":\" + MockData.BASIC_POLYGONS.getLocalPart();\r\n    final String requestUrl = \"wms/kml?layers=\" + layerName + \"&styles=&mode=superoverlay\";\r\n    Document dom = getAsDOM(requestUrl);\r\n    assertEquals(\"kml\", dom.getDocumentElement().getLocalName());\r\n    assertXpathExists(\"kml:kml/kml:Document/kml:Folder/kml:NetworkLink/kml:Link/kml:href\", dom);\r\n    assertXpathExists(\"kml:kml/kml:Document/kml:LookAt/kml:longitude\", dom);\r\n}"
}, {
	"Path": "org.geoserver.security.impl.GeoServerRoleConverterImpl.splitString",
	"Comment": "internal helper method to split strings based on delimiter strings",
	"Method": "List<String> splitString(String theString,String delim){\r\n    List<String> result = new ArrayList<String>();\r\n    int startIndex = 0;\r\n    while (true) {\r\n        int index = theString.indexOf(delim, startIndex);\r\n        if (index == -1) {\r\n            result.add(theString.substring(startIndex));\r\n            break;\r\n        } else {\r\n            result.add(theString.substring(startIndex, index));\r\n            startIndex = index + delim.length();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.vfny.geoserver.util.requests.readers.KvpRequestReader.parseXMLFilter",
	"Comment": "reads the filter xml request into a geotools feature object.",
	"Method": "Filter parseXMLFilter(Reader rawRequest){\r\n    InputSource requestSource = new InputSource(rawRequest);\r\n    EntityResolver entityResolver = entityResolverProvider.getEntityResolver();\r\n    FilterHandlerImpl contentHandler = new FilterHandlerImpl();\r\n    contentHandler.setEntityResolver(entityResolver);\r\n    FilterFilter filterParser = new FilterFilter(contentHandler, null);\r\n    GMLFilterGeometry geometryFilter = new GMLFilterGeometry(filterParser);\r\n    GMLFilterDocument documentFilter = new GMLFilterDocument(geometryFilter);\r\n    try {\r\n        SAXParserFactory factory = SAXParserFactory.newInstance();\r\n        SAXParser parser = factory.newSAXParser();\r\n        ParserAdapter adapter = new ParserAdapter(parser.getParser());\r\n        adapter.setEntityResolver(entityResolver);\r\n        adapter.setContentHandler(documentFilter);\r\n        adapter.parse(requestSource);\r\n        LOGGER.fine(\"just parsed: \" + requestSource);\r\n    } catch (SAXException e) {\r\n        if (e.getException() != null && e.getCause() == null) {\r\n            e.initCause(e.getException());\r\n        }\r\n        throw new ServiceException(e, \"XML getFeature request SAX parsing error\", XmlRequestReader.class.getName());\r\n    } catch (IOException e) {\r\n        throw new ServiceException(e, \"XML get feature request input error\", XmlRequestReader.class.getName());\r\n    } catch (ParserConfigurationException e) {\r\n        throw new ServiceException(e, \"Some sort of issue creating parser\", XmlRequestReader.class.getName());\r\n    }\r\n    LOGGER.fine(\"passing filter: \" + contentHandler.getFilter());\r\n    return contentHandler.getFilter();\r\n}"
}, {
	"Path": "org.geoserver.catalog.StyleHandler.getStyle",
	"Comment": "generates a style from a template using the provided substitutions.",
	"Method": "String getStyle(StyleType type,Color color,String colorName,String layerName){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.GeoTiffWriterHelper.getSourceFile",
	"Comment": "returns the original source file, is present in the metadata, and if the coverage",
	"Method": "File getSourceFile(GridCoverage2D coverage){\r\n    final Object fileSource = coverage.getProperty(AbstractGridCoverage2DReader.FILE_SOURCE_PROPERTY);\r\n    if (fileSource != null && fileSource instanceof String) {\r\n        File file = new File((String) fileSource);\r\n        if (file.exists()) {\r\n            GeoTiffReader reader = null;\r\n            try {\r\n                reader = new GeoTiffReader(file);\r\n                GeneralEnvelope originalEnvelope = reader.getOriginalEnvelope();\r\n                Envelope envelope = coverage.getEnvelope();\r\n                if (originalEnvelope.equals(envelope, 1e-9, false)) {\r\n                    GridCoverage2D test = reader.read(null);\r\n                    ImageUtilities.disposeImage(test.getRenderedImage());\r\n                    return file;\r\n                }\r\n            } catch (Exception e) {\r\n            } finally {\r\n                if (reader != null) {\r\n                    reader.dispose();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexMongoDBSupport.createTempDir",
	"Comment": "helper method that creates a temporary directory taking care of the io exception.",
	"Method": "Path createTempDir(){\r\n    try {\r\n        return Files.createTempDirectory(\"app-schema-mongo\");\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error creating temporary directory.\", exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wms.mapbox.MapBoxTileBuilderFactory.getOversampleY",
	"Comment": "use 16x oversampling to match actual mapbox tile extent, which is 4096 for 900913 tiles",
	"Method": "int getOversampleY(){\r\n    return 16;\r\n}"
}, {
	"Path": "org.geoserver.wms.mapbox.MapBoxTileBuilderFactory.getOversampleX",
	"Comment": "use 16x oversampling to match actual mapbox tile extent, which is 4096 for 900913 tiles",
	"Method": "int getOversampleX(){\r\n    return 16;\r\n}"
}, {
	"Path": "org.geoserver.catalog.FeatureTypeInfo.getEncodeMeasures",
	"Comment": "controls if coordinates measures should be included in wfs outputs.",
	"Method": "boolean getEncodeMeasures(){\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.test.PropertySelectionTest.testGetFeatureInvalidName",
	"Comment": "test getfeature with property selection, with an invalid column name.",
	"Method": "void testGetFeatureInvalidName(){\r\n    Document doc = getAsDOM(\"wfs?service=WFS&version=1.1.0&request=GetFeature&typeName=gsml:MappedFeature&propertyname=gml:name\");\r\n    LOGGER.info(\"wfs?service=WFS&version=1.1.0&request=GetFeature&typeName=gsml:MappedFeature&propertyname=gml:name response:\\n\" + prettyString(doc));\r\n    assertTrue(evaluate(\"//ows:ExceptionText\", doc).contains(\"Could not find working property accessor for attribute (DOESNT_EXIST)\"));\r\n}"
}, {
	"Path": "org.geoserver.wps.ExecuteTest.testWrongOutputIdentifierDocumentOutputAsynch",
	"Comment": "tests a process execution an invalid output identifier fails immediately with an appropriateerror message",
	"Method": "void testWrongOutputIdentifierDocumentOutputAsynch(){\r\n    String responseFormContents = \"<wps:ResponseDocument storeExecuteResponse='true' status='true'>\" + \"<wps:Output>\" + \"<ows:Identifier>fooBar<\/ows:Identifier>\" + \"<\/wps:Output>\" + \"<\/wps:ResponseDocument>\";\r\n    String request = buildGetBoundsRequest(responseFormContents);\r\n    Document dom = postAsDOM(root(), request);\r\n    String message = checkOws11Exception(dom, ServiceException.INVALID_PARAMETER_VALUE, \"ResponseDocument\");\r\n    assertThat(message, containsString(\"fooBar\"));\r\n}"
}, {
	"Path": "org.geoserver.security.config.BaseSecurityNamedServiceConfig.setClassName",
	"Comment": "the class name of the service to be constructed the class must have a constructor with astring argument, specifying the name of the service",
	"Method": "void setClassName(String className){\r\n    this.className = className;\r\n}"
}, {
	"Path": "org.geoserver.wfs.FeatureSizeFeatureCollection.setFeatureCacheLimit",
	"Comment": "allows to programmatically set the maximum number of cacheable features.",
	"Method": "void setFeatureCacheLimit(int featureCacheLimit){\r\n    FEATURE_CACHE_LIMIT = featureCacheLimit;\r\n}"
}, {
	"Path": "org.geoserver.wps.ppio.ProcessParameterIO.findByDirection",
	"Comment": "look for ppio matching the parameter type and suitable for direction handling",
	"Method": "List<ProcessParameterIO> findByDirection(Parameter<?> p,ApplicationContext context,PPIODirection direction){\r\n    List<ProcessParameterIO> ppios = new ArrayList<ProcessParameterIO>();\r\n    List<ProcessParameterIO> matches = findAll(p, context);\r\n    for (ProcessParameterIO ppio : matches) {\r\n        if (ppio.getDirection() == PPIODirection.BOTH || ppio.getDirection() == direction) {\r\n            ppios.add(ppio);\r\n        }\r\n    }\r\n    return ppios;\r\n}"
}, {
	"Path": "org.geoserver.security.CatalogFilterAccessManager.setCatalogFilters",
	"Comment": "designed for testing, allows to manually configure the catalog filters bypassing the springcontext lookup",
	"Method": "void setCatalogFilters(List<? extends CatalogFilter> filters){\r\n    this.filters = filters;\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.Dimension.getDefaultValueAsString",
	"Comment": "return this dimension default value as a string taking in account this dimension defaultstrategy.",
	"Method": "String getDefaultValueAsString(){\r\n    DimensionDefaultValueSelectionStrategy strategy = wms.getDefaultValueStrategy(resourceInfo, dimensionName, dimensionInfo);\r\n    String defaultValue = strategy.getCapabilitiesRepresentation(resourceInfo, dimensionName, dimensionInfo);\r\n    return defaultValue != null ? defaultValue : getDefaultValueFallbackAsString();\r\n}"
}, {
	"Path": "org.geoserver.sldservice.utils.classifier.RasterSymbolizerBuilder.getImageWorker",
	"Comment": "builds a imageworker with subsampling factors suitable to respect the configured max pixels",
	"Method": "ImageWorker getImageWorker(RenderedImage image){\r\n    ImageWorker iw = new ImageWorker(image);\r\n    long pixels = image.getWidth() * (long) image.getHeight();\r\n    if (pixels > maxPixels) {\r\n        int yPeriod = (int) Math.round(Math.sqrt(pixels / (double) maxPixels));\r\n        int xPeriod = (int) Math.ceil(pixels / (yPeriod * maxPixels));\r\n        iw.setXPeriod(xPeriod).setYPeriod(yPeriod);\r\n    }\r\n    return iw;\r\n}"
}, {
	"Path": "org.geoserver.kml.GeoSearchKMLTest.testBigGeometries",
	"Comment": "test whether geometries that cross tiles get put into both of them.",
	"Method": "void testBigGeometries(){\r\n    final String path = \"wms?request=getmap&service=wms&version=1.1.1\" + \"&format=\" + KMLMapOutputFormat.MIME_TYPE + \"&layers=\" + CENTERED_POLY.getPrefix() + \":\" + CENTERED_POLY.getLocalPart() + \"&styles=\" + \"&height=1024&width=1024&srs=EPSG:4326\" + \"&format_options=regionateBy:external-sorting;regionateattr:foo\";\r\n    assertStatusCodeForGet(204, path + \"&bbox=-180,-90,0,90\");\r\n    Document document = getAsDOM(path + \"&bbox=0,-90,180,90\");\r\n    assertEquals(\"kml\", document.getDocumentElement().getTagName());\r\n    assertEquals(1, document.getDocumentElement().getElementsByTagName(\"Placemark\").getLength());\r\n}"
}, {
	"Path": "org.geoserver.wfs.v2_0.SrsNameRequestTest.testUrnExperimental",
	"Comment": "test response numberreturned, feature identity, srsname, and axis order for a request with anogc urn experimental srsname.",
	"Method": "void testUrnExperimental(){\r\n    runTest(URN_EXPERIMENTAL_SRSNAME, null, 5, URN_SRSNAME, LAT_LON_DATA);\r\n}"
}, {
	"Path": "org.geoserver.web.LogoutFormInfo.getLogoutPath",
	"Comment": "authentication security endpoint invoked by the pluggable form",
	"Method": "String getLogoutPath(){\r\n    return logoutPath;\r\n}"
}, {
	"Path": "org.geoserver.platform.exception.GeoServerExceptions.localize",
	"Comment": "returns a localized message for the specific exception for the default system locale.",
	"Method": "String localize(IGeoServerException e,String localize,IGeoServerException e,Locale locale){\r\n    Class<? extends IGeoServerException> clazz = e.getClass();\r\n    while (clazz != null) {\r\n        String localized = doLocalize(e.getId(), e.getArgs(), clazz, locale);\r\n        if (localized != null) {\r\n            return localized;\r\n        }\r\n        if (IGeoServerException.class.isAssignableFrom(clazz.getSuperclass())) {\r\n            clazz = (Class<? extends IGeoServerException>) clazz.getSuperclass();\r\n        } else {\r\n            clazz = null;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.platform.resource.Resources.directory",
	"Comment": "if create is true or if a directory exists returns resource.dir, otherwise it returns null.",
	"Method": "File directory(Resource resource,File directory,Resource resource,boolean create){\r\n    final File f;\r\n    if (resource == null) {\r\n        f = null;\r\n    } else if (create) {\r\n        f = resource.dir();\r\n    } else {\r\n        if (resource.getType() == Type.DIRECTORY) {\r\n            f = resource.dir();\r\n        } else {\r\n            f = null;\r\n        }\r\n    }\r\n    return f;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findOrResolveLayerFile",
	"Comment": "returns the configuration file for the specified layer, if the file does not exist a fileobject is still returned.",
	"Method": "File findOrResolveLayerFile(LayerInfo layer){\r\n    Resource resource = get(layer);\r\n    return resource.file();\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.getSecurityManager",
	"Comment": "accesssor for global security manager instance from the test application context.",
	"Method": "GeoServerSecurityManager getSecurityManager(){\r\n    return (GeoServerSecurityManager) applicationContext.getBean(\"geoServerSecurityManager\");\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.Ogr2OgrOutputFormat.isShapefileCompatible",
	"Comment": "returns true if the schema has just one geometry and the geom type is known",
	"Method": "boolean isShapefileCompatible(SimpleFeatureType schema){\r\n    GeometryType gt = null;\r\n    for (AttributeDescriptor at : schema.getAttributeDescriptors()) {\r\n        if (at instanceof GeometryDescriptor) {\r\n            if (gt == null)\r\n                gt = ((GeometryDescriptor) at).getType();\r\n            else\r\n                return false;\r\n        }\r\n    }\r\n    return gt != null && SHAPEFILE_GEOM_TYPES.contains(gt.getBinding());\r\n}"
}, {
	"Path": "org.geoserver.data.test.MockData.addPropertiesType",
	"Comment": "adds a property file as a feature type in a property datastore.",
	"Method": "void addPropertiesType(QName name,URL properties,Map extraParams){\r\n    if (extraParams == null)\r\n        extraParams = Collections.EMPTY_MAP;\r\n    File directory = new File(data, name.getPrefix());\r\n    if (!directory.exists()) {\r\n        directory.mkdir();\r\n    }\r\n    File f = new File(directory, name.getLocalPart() + \".properties\");\r\n    InputStream propertiesContents;\r\n    if (properties == null)\r\n        propertiesContents = new ByteArrayInputStream(\"-=\".getBytes());\r\n    else\r\n        propertiesContents = properties.openStream();\r\n    IOUtils.copy(propertiesContents, f);\r\n    info(name, extraParams);\r\n    namespaces.put(name.getPrefix(), name.getNamespaceURI());\r\n    dataStoreNamepaces.put(name.getPrefix(), name.getPrefix());\r\n    Map params = new HashMap();\r\n    params.put(PropertyDataStoreFactory.DIRECTORY.key, directory);\r\n    params.put(PropertyDataStoreFactory.NAMESPACE.key, name.getNamespaceURI());\r\n    dataStores.put(name.getPrefix(), params);\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.foundCrs",
	"Comment": "return a crs if one was found during the features collections encoding.",
	"Method": "CoordinateReferenceSystem foundCrs(){\r\n    return crs;\r\n}"
}, {
	"Path": "org.geoserver.geofence.ServicesTest.getFilters",
	"Comment": "enable the spring security auth filters, otherwise there will be no auth",
	"Method": "List<javax.servlet.Filter> getFilters(){\r\n    return Collections.singletonList((javax.servlet.Filter) GeoServerExtensions.bean(\"filterChainProxy\"));\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.OgrConfiguration.getExecutable",
	"Comment": "ensures compatibility with old style configuration files.",
	"Method": "String getExecutable(){\r\n    if (ogr2ogrLocation != null) {\r\n        return ogr2ogrLocation;\r\n    } else {\r\n        return executable;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.NetCDFEncoder.getSettings",
	"Comment": "extracts the netcdf encoding settings from the coverage identifier",
	"Method": "NetCDFLayerSettingsContainer getSettings(Map<String, String> encodingParameters,NetCDFLayerSettingsContainer getSettings,String coverageId){\r\n    GeoServer geoserver = GeoServerExtensions.bean(GeoServer.class);\r\n    MetadataMap map = null;\r\n    if (geoserver != null) {\r\n        Catalog gsCatalog = geoserver.getCatalog();\r\n        LayerInfo info = NCNameResourceCodec.getCoverage(gsCatalog, coverageId);\r\n        if (info != null) {\r\n            map = info.getResource().getMetadata();\r\n        }\r\n    }\r\n    if (map != null && !map.isEmpty() && map.containsKey(NetCDFSettingsContainer.NETCDFOUT_KEY)) {\r\n        NetCDFLayerSettingsContainer settings = (NetCDFLayerSettingsContainer) map.get(NetCDFSettingsContainer.NETCDFOUT_KEY, NetCDFLayerSettingsContainer.class);\r\n        return settings;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.catalog.NamespaceWorkspaceConsistencyListener.handleModifyEvent",
	"Comment": "takes care of keeping in synch namespace and workspaces in face of modifications",
	"Method": "void handleModifyEvent(CatalogModifyEvent event){\r\n    List<String> properties = event.getPropertyNames();\r\n    if (event.getSource() instanceof NamespaceInfo && !editing && properties.contains(\"prefix\")) {\r\n        int prefixIdx = properties.indexOf(\"prefix\");\r\n        String oldPrefix = (String) event.getOldValues().get(prefixIdx);\r\n        String newPrefix = (String) event.getNewValues().get(prefixIdx);\r\n        WorkspaceInfo ws = catalog.getWorkspaceByName(oldPrefix);\r\n        if (ws != null) {\r\n            try {\r\n                editing = true;\r\n                ws.setName(newPrefix);\r\n                catalog.save(ws);\r\n            } finally {\r\n                editing = false;\r\n            }\r\n        }\r\n    } else if (event.getSource() instanceof Catalog && properties.contains(\"defaultNamespace\") && !editing) {\r\n        NamespaceInfo newDefault = (NamespaceInfo) event.getNewValues().get(properties.indexOf(\"defaultNamespace\"));\r\n        if (newDefault != null) {\r\n            WorkspaceInfo ws = catalog.getWorkspaceByName(newDefault.getPrefix());\r\n            if (ws != null && !catalog.getDefaultWorkspace().equals(ws)) {\r\n                try {\r\n                    editing = true;\r\n                    catalog.setDefaultWorkspace(ws);\r\n                } finally {\r\n                    editing = false;\r\n                }\r\n            }\r\n        }\r\n    } else if (event.getSource() instanceof WorkspaceInfo && !editing && properties.contains(\"name\")) {\r\n        WorkspaceInfo ws = (WorkspaceInfo) event.getSource();\r\n        int nameIdx = properties.indexOf(\"name\");\r\n        String oldName = (String) event.getOldValues().get(nameIdx);\r\n        String newName = (String) event.getNewValues().get(nameIdx);\r\n        NamespaceInfo ns = catalog.getNamespaceByPrefix(oldName);\r\n        if (ns != null) {\r\n            try {\r\n                editing = true;\r\n                ns.setPrefix(newName);\r\n                catalog.save(ns);\r\n            } finally {\r\n                editing = false;\r\n            }\r\n        }\r\n    } else if (event.getSource() instanceof Catalog && properties.contains(\"defaultWorkspace\") && !editing) {\r\n        WorkspaceInfo newDefault = (WorkspaceInfo) event.getNewValues().get(properties.indexOf(\"defaultWorkspace\"));\r\n        if (newDefault != null) {\r\n            NamespaceInfo ns = catalog.getNamespaceByPrefix(newDefault.getName());\r\n            if (ns != null && !catalog.getDefaultNamespace().equals(ns)) {\r\n                try {\r\n                    editing = true;\r\n                    catalog.setDefaultNamespace(ns);\r\n                } finally {\r\n                    editing = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.dumpMasterPassword",
	"Comment": "method to dump master password to a filethe file name is the shared secret between the administrator and geoserver.the method inspects the stack trace to check for an authorized calling method. theauthenticated principal has to be an administratorif authorization fails, a warning is written in the log and the return code is false. on success, the return code is true.",
	"Method": "boolean dumpMasterPassword(File file,boolean dumpMasterPassword,Resource file){\r\n    if (file.getType() != Resource.Type.UNDEFINED) {\r\n        LOGGER.warning(\"Master password dump attempted to overwrite existing resource\");\r\n        return false;\r\n    }\r\n    if (checkAuthenticationForAdminRole() == false) {\r\n        LOGGER.warning(\"Unautorized user tries to dump master password\");\r\n        return false;\r\n    }\r\n    String[][] allowedMethods = new String[][] { { \"org.geoserver.security.GeoServerSecurityManagerTest\", \"testMasterPasswordDump\" }, { \"org.geoserver.security.web.passwd.MasterPasswordInfoPage\", \"dumpMasterPassword\" } };\r\n    String result = checkStackTrace(10, allowedMethods);\r\n    if (result != null) {\r\n        LOGGER.warning(\"Dump master password is called by an unautorized method\\n\" + result);\r\n        return false;\r\n    }\r\n    String message = \"The current master password is: \";\r\n    writeMasterPasswordInfo(file, message, getMasterPassword());\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.GeoTiffWriterHelper.getImageIoWriteParams",
	"Comment": "returns the write parameters, allowing their customization",
	"Method": "GeoTiffWriteParams getImageIoWriteParams(){\r\n    return imageIoWriteParams;\r\n}"
}, {
	"Path": "org.geoserver.security.xml.XMLSecurityConfigValidator.validateAddRoleService",
	"Comment": "additional validation, check if the file exists or can be created",
	"Method": "void validateAddRoleService(SecurityRoleServiceConfig config){\r\n    super.validateAddRoleService(config);\r\n    XMLRoleServiceConfig xmlConfig = (XMLRoleServiceConfig) config;\r\n    File file = new File(xmlConfig.getFileName());\r\n    if (checkFile(file) == false)\r\n        throw createSecurityException(FILE_CREATE_FAILED_$1, file.getPath());\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.ShapeZipOutputFormat.getShapefileCharset",
	"Comment": "looks up the charset parameter, either in the getfeature request or as a global parameter",
	"Method": "Charset getShapefileCharset(Operation getFeature){\r\n    Charset result = null;\r\n    GetFeatureRequest gft = GetFeatureRequest.adapt(getFeature.getParameters()[0]);\r\n    if (gft.getFormatOptions() != null && gft.getFormatOptions().get(\"CHARSET\") != null) {\r\n        result = (Charset) gft.getFormatOptions().get(\"CHARSET\");\r\n    } else {\r\n        final String charsetName = GeoServerExtensions.getProperty(GS_SHAPEFILE_CHARSET, applicationContext);\r\n        if (charsetName != null)\r\n            result = Charset.forName(charsetName);\r\n    }\r\n    return result != null ? result : Charset.forName(\"ISO-8859-1\");\r\n}"
}, {
	"Path": "org.vfny.geoserver.servlets.BufferStrategy.abort",
	"Comment": "clears the buffer with out writing anything out to response.",
	"Method": "void abort(){\r\n    buffer = null;\r\n}"
}, {
	"Path": "org.geoserver.wps.resource.WPSResourceManager.getStoredResponse",
	"Comment": "gets the stored response file for the specified execution id",
	"Method": "Resource getStoredResponse(String executionId){\r\n    return artifactsStore.getArtifact(executionId, ArtifactType.Response, null);\r\n}"
}, {
	"Path": "org.geoserver.security.file.RoleFileWatcher.rolesChanged",
	"Comment": "another method to avoid reloads if this object is registered",
	"Method": "void rolesChanged(RoleLoadedEvent event){\r\n    setLastModified(resource.lastmodified());\r\n    LOGGER.info(\"Adjusted last modified for file: \" + path);\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.ScaleToTarget.getGridToCRSTransform",
	"Comment": "computes the transformation between raster and world coordinates, taking scaling intoaccount.",
	"Method": "MathTransform getGridToCRSTransform(){\r\n    AffineTransform scaleTransform = getScaleTransform();\r\n    AffineTransform g2w = (AffineTransform) reader.getOriginalGridToWorld(PixelInCell.CELL_CENTER);\r\n    AffineTransform finalTransform = new AffineTransform(g2w);\r\n    finalTransform.concatenate(scaleTransform);\r\n    return ProjectiveTransform.create(finalTransform);\r\n}"
}, {
	"Path": "org.geoserver.web.data.layergroup.LayerGroupEditPageTest.assertElementExist",
	"Comment": "checks that an element that match the provided matcher exists.",
	"Method": "void assertElementExist(List<T> elements,Function<T, Boolean> matcher){\r\n    boolean found = false;\r\n    for (T element : elements) {\r\n        if (matcher.apply(element)) {\r\n            found = true;\r\n            break;\r\n        }\r\n    }\r\n    assertThat(found, is(true));\r\n}"
}, {
	"Path": "org.vfny.geoserver.util.ResponseUtils.proxifyMetadataLink",
	"Comment": "profixies a metadata link url interpreting a localhost url as a back reference to the server.if link is not a localhost url it is left untouched.",
	"Method": "String proxifyMetadataLink(MetadataLinkInfo link,String baseURL){\r\n    String content = link.getContent();\r\n    content = proxifyLink(content, baseURL);\r\n    return content;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.GetCoverage.extractOutputCRS",
	"Comment": "this method is responsible for etracting the outputcrs.in case it is not provided the subsettingcrs falls back on the subsettingcrs.",
	"Method": "CoordinateReferenceSystem extractOutputCRS(GridCoverage2DReader reader,Map<String, ExtensionItemType> extensions,CoordinateReferenceSystem subsettingCRS){\r\n    return extractCRSInternal(extensions, subsettingCRS, true);\r\n}"
}, {
	"Path": "org.geoserver.security.xml.XMLSecurityConfigValidator.validateAddUserGroupService",
	"Comment": "additional validation, check if the file exists or can be created",
	"Method": "void validateAddUserGroupService(SecurityUserGroupServiceConfig config){\r\n    super.validateAddUserGroupService(config);\r\n    XMLUserGroupServiceConfig xmlConfig = (XMLUserGroupServiceConfig) config;\r\n    File file = new File(xmlConfig.getFileName());\r\n    if (checkFile(file) == false)\r\n        throw createSecurityException(FILE_CREATE_FAILED_$1, file.getPath());\r\n}"
}, {
	"Path": "org.geoserver.gwc.layer.GeoServerTileLayer.getWms",
	"Comment": "helper that gets the wms bean from spring context when needed.",
	"Method": "WMS getWms(){\r\n    if (wms == null) {\r\n        wms = GeoServerExtensions.bean(WMS.class);\r\n    }\r\n    return wms;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDimensionsValueParser.setRangeValues",
	"Comment": "set the slice value as proper object depending on the datatype",
	"Method": "void setRangeValues(String low,String high,List<Object> selectedValues,String domainDatatype){\r\n    if (domainDatatype.endsWith(\"Timestamp\") || domainDatatype.endsWith(\"Date\")) {\r\n        setAsDateRange(low, high, selectedValues);\r\n    } else if (domainDatatype.endsWith(\"Integer\")) {\r\n        setAsIntegerRange(low, high, selectedValues);\r\n    } else if (domainDatatype.endsWith(\"Double\")) {\r\n        setAsDoubleRange(low, high, selectedValues);\r\n    } else if (domainDatatype.endsWith(\"String\")) {\r\n        selectedValues.add(low + \"/\" + high);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.geometryFound",
	"Comment": "return true if a geometry was found during the features collections encoding.",
	"Method": "boolean geometryFound(){\r\n    return geometryFound;\r\n}"
}, {
	"Path": "org.geoserver.wps.executor.WPSExecutionManager.cancel",
	"Comment": "cancels the execution of the given process, notifying the process managers if needs be",
	"Method": "void cancel(String executionId){\r\n    ExecutionStatus status = statusTracker.getStatus(executionId);\r\n    if (status == null) {\r\n        throw new UnknownExecutionIdException(executionId);\r\n    }\r\n    if (status.getPhase() == ProcessState.RUNNING) {\r\n        ProcessListenerNotifier notifier = localProcesses.get(executionId);\r\n        if (notifier != null) {\r\n            notifier.dismiss();\r\n        } else {\r\n            status.setPhase(ProcessState.DISMISSING);\r\n            statusTracker.dismissing(new ProcessEvent(status, null, null));\r\n        }\r\n        status = statusTracker.getStatus(executionId);\r\n        if (!status.getPhase().isExecutionCompleted()) {\r\n            return;\r\n        }\r\n    }\r\n    ProcessEvent event = new ProcessEvent(status, null);\r\n    statusTracker.dismissed(event);\r\n    resourceManager.dismissed(event);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.checkValidationErrors",
	"Comment": "given a dom and a schema, checks that the dom validates against the schema of the validationerrors instead",
	"Method": "void checkValidationErrors(Document dom,Schema schema){\r\n    final Validator validator = schema.newValidator();\r\n    final List<Exception> validationErrors = new ArrayList<Exception>();\r\n    validator.setErrorHandler(new ErrorHandler() {\r\n        public void warning(SAXParseException exception) throws SAXException {\r\n            System.out.println(exception.getMessage());\r\n        }\r\n        public void fatalError(SAXParseException exception) throws SAXException {\r\n            validationErrors.add(exception);\r\n        }\r\n        public void error(SAXParseException exception) throws SAXException {\r\n            validationErrors.add(exception);\r\n        }\r\n    });\r\n    validator.validate(new DOMSource(dom));\r\n    if (validationErrors != null && validationErrors.size() > 0) {\r\n        StringBuilder sb = new StringBuilder();\r\n        for (Exception ve : validationErrors) {\r\n            sb.append(ve.getMessage()).append(\"\\n\");\r\n        }\r\n        fail(sb.toString());\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.checkValidationErrors",
	"Comment": "given a dom and a schema, checks that the dom validates against the schema of the validationerrors instead",
	"Method": "void checkValidationErrors(Document dom,Schema schema){\r\n    System.out.println(exception.getMessage());\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.checkValidationErrors",
	"Comment": "given a dom and a schema, checks that the dom validates against the schema of the validationerrors instead",
	"Method": "void checkValidationErrors(Document dom,Schema schema){\r\n    validationErrors.add(exception);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.checkValidationErrors",
	"Comment": "given a dom and a schema, checks that the dom validates against the schema of the validationerrors instead",
	"Method": "void checkValidationErrors(Document dom,Schema schema){\r\n    validationErrors.add(exception);\r\n}"
}, {
	"Path": "org.geoserver.ows.Request.getError",
	"Comment": "the eventual error thrown during request parsing, execution or output writing",
	"Method": "Throwable getError(){\r\n    return error;\r\n}"
}, {
	"Path": "org.geoserver.gwc.GWC.getCachedStyles",
	"Comment": "returns the names of the styles for the layer, including the default style",
	"Method": "Set<String> getCachedStyles(String layerName){\r\n    final TileLayer l = getTileLayerByName(layerName);\r\n    Set<String> cachedStyles = new HashSet<String>();\r\n    String defaultStyle = l.getStyles();\r\n    if (defaultStyle != null) {\r\n        cachedStyles.add(defaultStyle);\r\n    }\r\n    List<ParameterFilter> parameterFilters = l.getParameterFilters();\r\n    if (parameterFilters != null) {\r\n        for (ParameterFilter pf : parameterFilters) {\r\n            if (!\"STYLES\".equalsIgnoreCase(pf.getKey())) {\r\n                continue;\r\n            }\r\n            cachedStyles.add(pf.getDefaultValue());\r\n            cachedStyles.addAll(pf.getLegalValues());\r\n            break;\r\n        }\r\n    }\r\n    return cachedStyles;\r\n}"
}, {
	"Path": "org.geoserver.security.ResourceAccessManager.getAccessLimits",
	"Comment": "returns the access limits for the specified layer group, or null if there are no limits.",
	"Method": "WorkspaceAccessLimits getAccessLimits(Authentication user,WorkspaceInfo workspace,DataAccessLimits getAccessLimits,Authentication user,LayerInfo layer,DataAccessLimits getAccessLimits,Authentication user,LayerInfo layer,List<LayerGroupInfo> containers,DataAccessLimits getAccessLimits,Authentication user,ResourceInfo resource,StyleAccessLimits getAccessLimits,Authentication user,StyleInfo style,LayerGroupAccessLimits getAccessLimits,Authentication user,LayerGroupInfo layerGroup,LayerGroupAccessLimits getAccessLimits,Authentication user,LayerGroupInfo layerGroup,List<LayerGroupInfo> containers){\r\n    return getAccessLimits(user, layerGroup);\r\n}"
}, {
	"Path": "org.geoserver.importer.transform.AbstractCommandLinePreTransform.getExecutableFromPath",
	"Comment": "locates and executable in the system path. on windows it will automatically append .exe tothe searched file name",
	"Method": "File getExecutableFromPath(String name){\r\n    if (SystemUtils.IS_OS_WINDOWS) {\r\n        name = name + \".exe\";\r\n    }\r\n    String systemPath = System.getenv(\"PATH\");\r\n    if (systemPath == null) {\r\n        systemPath = System.getenv(\"path\");\r\n    }\r\n    if (systemPath == null) {\r\n        throw new IOException(\"Path is not set, cannot locate \" + name);\r\n    }\r\n    String[] paths = systemPath.split(File.pathSeparator);\r\n    for (String pathDir : paths) {\r\n        File file = new File(pathDir, name);\r\n        if (file.exists() && file.isFile() && file.canExecute()) {\r\n            return file;\r\n        }\r\n    }\r\n    throw new IOException(\"Could not locate executable (or could locate, but does not have execution rights): \" + name);\r\n}"
}, {
	"Path": "org.geotools.renderer.lite.VectorMapRenderUtils.getStyleQuery",
	"Comment": "creates a query selecting those features relevant to the style and extent of the given map,for the given layer.",
	"Method": "Query getStyleQuery(Layer layer,WMSMapContent mapContent,Query getStyleQuery,FeatureSource<?, ?> source,List<LiteFeatureTypeStyle> styleList,ReferencedEnvelope queryArea,Rectangle screenSize,GeometryDescriptor geometryAttribute){\r\n    final FeatureType schema = source.getSchema();\r\n    Query query = new Query(schema.getName().getLocalPart());\r\n    query.setProperties(Query.ALL_PROPERTIES);\r\n    String geomName = geometryAttribute.getLocalName();\r\n    Filter filter = reprojectSpatialFilter(queryArea.getCoordinateReferenceSystem(), schema, FF.bbox(FF.property(geomName), queryArea));\r\n    query.setFilter(filter);\r\n    LiteFeatureTypeStyle[] styles = styleList.toArray(new LiteFeatureTypeStyle[styleList.size()]);\r\n    try {\r\n        processRuleForQuery(styles, query);\r\n    } catch (Exception e) {\r\n        throw Throwables.propagate(e);\r\n    }\r\n    SimplifyingFilterVisitor simplifier = new SimplifyingFilterVisitor();\r\n    simplifier.setFeatureType(source.getSchema());\r\n    Filter simplifiedFilter = (Filter) query.getFilter().accept(simplifier, null);\r\n    query.setFilter(simplifiedFilter);\r\n    return query;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.postAsServletResponse",
	"Comment": "executes an ows request using the post method, with xml as body content.",
	"Method": "MockHttpServletResponse postAsServletResponse(String path,String xml,MockHttpServletResponse postAsServletResponse,String path,String body,String contentType,MockHttpServletResponse postAsServletResponse,String path,String body,String contentType,String charset,MockHttpServletResponse postAsServletResponse,String path,byte[] body,String contentType){\r\n    MockHttpServletRequest request = createRequest(path);\r\n    request.setMethod(\"POST\");\r\n    request.setContentType(contentType);\r\n    request.setContent(body);\r\n    return dispatch(request);\r\n}"
}, {
	"Path": "org.geoserver.catalog.Styles.handler",
	"Comment": "looks up a style handler by format, file extension, or mime type.",
	"Method": "StyleHandler handler(String format){\r\n    if (format == null) {\r\n        throw new IllegalArgumentException(\"Style format must not be null\");\r\n    }\r\n    List<StyleHandler> allHandlers = handlers();\r\n    List<StyleHandler> matches = new ArrayList();\r\n    for (StyleHandler h : allHandlers) {\r\n        if (format.equalsIgnoreCase(h.getFormat())) {\r\n            matches.add(h);\r\n        }\r\n    }\r\n    if (matches.isEmpty()) {\r\n        for (StyleHandler h : allHandlers) {\r\n            for (Version ver : h.getVersions()) {\r\n                if (h.mimeType(ver).equals(format)) {\r\n                    matches.add(h);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (matches.isEmpty()) {\r\n        for (StyleHandler h : allHandlers) {\r\n            if (format.equalsIgnoreCase(h.getFileExtension())) {\r\n                matches.add(h);\r\n            }\r\n        }\r\n    }\r\n    if (matches.isEmpty()) {\r\n        throw new RuntimeException(\"No such style handler: format = \" + format);\r\n    }\r\n    if (matches.size() == 1) {\r\n        return matches.get(0);\r\n    }\r\n    List<String> handlerNames = Lists.transform(matches, new Function<StyleHandler, String>() {\r\n        @Nullable\r\n        @Override\r\n        public String apply(@Nullable StyleHandler styleHandler) {\r\n            return styleHandler.getName();\r\n        }\r\n    });\r\n    throw new IllegalArgumentException(\"Multiple style handlers: \" + handlerNames + \" found for format: \" + format);\r\n}"
}, {
	"Path": "org.geoserver.catalog.Styles.handler",
	"Comment": "looks up a style handler by format, file extension, or mime type.",
	"Method": "StyleHandler handler(String format){\r\n    return styleHandler.getName();\r\n}"
}, {
	"Path": "org.geoserver.gwc.config.GWCExternalConfigTest.testUseCase",
	"Comment": "helper method that setup the correct configuration variables, force spring beans to bereloaded and checks gwc configuration beans.",
	"Method": "void testUseCase(String configDirPath,String cacheDirPath,String expectedConfigFirPath){\r\n    if (configDirPath == null) {\r\n        configProp.clearValue();\r\n    } else {\r\n        configProp.setValue(configDirPath);\r\n    }\r\n    if (cacheDirPath == null) {\r\n        cacheProp.clearValue();\r\n    } else {\r\n        cacheProp.setValue(cacheDirPath);\r\n    }\r\n    applicationContext.refresh();\r\n    applicationContext.getBeansOfType(GeoserverXMLResourceProvider.class).values().forEach(bean -> {\r\n        try {\r\n            assertThat(bean.getConfigDirectory(), notNullValue());\r\n            assertThat(bean.getConfigDirectory().dir().getCanonicalPath(), is(expectedConfigFirPath));\r\n            assertThat(new File(bean.getLocation()).getCanonicalPath(), is(new File(expectedConfigFirPath, bean.getConfigFileName()).getCanonicalPath()));\r\n        } catch (Exception exception) {\r\n            throw new RuntimeException(exception);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.geoserver.importer.transform.AbstractCommandLinePreTransform.isOutputAfterInput",
	"Comment": "returns true if in the command line the output file comes after the input one. the defaultimplementation returns true",
	"Method": "boolean isOutputAfterInput(){\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.solr.SolrConfigurationPage.fillSolrAttributes",
	"Comment": "load solrlayerconfiguration configuration before shows on table reloads solr attributes fromdatastore and merge it with user attributes configurations",
	"Method": "SolrLayerConfiguration fillSolrAttributes(ResourceInfo ri){\r\n    SolrLayerConfiguration solrLayerConfiguration = (SolrLayerConfiguration) ri.getMetadata().get(SolrLayerConfiguration.KEY);\r\n    try {\r\n        ArrayList<SolrAttribute> result = new ArrayList<SolrAttribute>();\r\n        Map<String, SolrAttribute> tempMap = new HashMap<String, SolrAttribute>();\r\n        if (solrLayerConfiguration != null) {\r\n            for (SolrAttribute att : solrLayerConfiguration.getAttributes()) {\r\n                tempMap.put(att.getName(), att);\r\n            }\r\n        } else {\r\n            tempMap.clear();\r\n            solrLayerConfiguration = new SolrLayerConfiguration(new ArrayList<SolrAttribute>());\r\n            solrLayerConfiguration.setLayerName(ri.getName());\r\n            ri.getMetadata().put(SolrLayerConfiguration.KEY, solrLayerConfiguration);\r\n        }\r\n        SolrDataStore dataStore = (SolrDataStore) ((DataStoreInfo) ri.getStore()).getDataStore(new NullProgressListener());\r\n        ArrayList<SolrAttribute> attributes = dataStore.getSolrAttributes(solrLayerConfiguration.getLayerName());\r\n        for (SolrAttribute at : attributes) {\r\n            if (tempMap.containsKey(at.getName())) {\r\n                SolrAttribute prev = tempMap.get(at.getName());\r\n                prev.setEmpty(at.getEmpty());\r\n                at = prev;\r\n            }\r\n            result.add(at);\r\n        }\r\n        solrLayerConfiguration.getAttributes().clear();\r\n        solrLayerConfiguration.getAttributes().addAll(result);\r\n    } catch (Exception e) {\r\n        LOGGER.log(Level.SEVERE, e.getMessage(), e);\r\n    }\r\n    return solrLayerConfiguration;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.GetCoverage.requestingLatLonAxesOrder",
	"Comment": "this utility method tells me whether or not we should do a final reverse on the axis of thedata.",
	"Method": "boolean requestingLatLonAxesOrder(CoordinateReferenceSystem outputCRS){\r\n    try {\r\n        final Integer epsgCode = CRS.lookupEpsgCode(outputCRS, false);\r\n        if (epsgCode != null && epsgCode > 0) {\r\n            CoordinateReferenceSystem originalCRS = CRS.decode(SRS_STARTER + epsgCode);\r\n            return !CRS.getAxisOrder(originalCRS).equals(CRS.getAxisOrder(outputCRS));\r\n        }\r\n    } catch (FactoryException e) {\r\n        LOGGER.log(Level.INFO, e.getMessage(), e);\r\n        return false;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.csw.feature.AbstractFeatureCollection.contains",
	"Comment": "returns true if this collection contains the specified element. .this implementation iterates over the elements in the collection, checking each element inturn for equality with the specified element.",
	"Method": "boolean contains(Object o){\r\n    Iterator<F> e = null;\r\n    try {\r\n        e = iterator();\r\n        if (o == null) {\r\n            while (e.hasNext()) if (e.next() == null)\r\n                return true;\r\n        } else {\r\n            while (e.hasNext()) if (o.equals(e.next()))\r\n                return true;\r\n        }\r\n        return false;\r\n    } finally {\r\n        close(e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.GeoServerInstance.setJmsDefaultConfiguration",
	"Comment": "makes this geoserver instance belong to the default jms cluster, propagate jms events andconsume jms events.",
	"Method": "void setJmsDefaultConfiguration(){\r\n    jmsController.setBrokerURL(\"\");\r\n    jmsController.setGroup(\"geoserver-cluster\");\r\n    enableJmsMaster();\r\n    enableJmsSlave();\r\n}"
}, {
	"Path": "org.geoserver.rest.security.AbstractAclController.nonExistingKeys",
	"Comment": "calculate the keys not contained in the rule data access object",
	"Method": "Set<Object> nonExistingKeys(Map map){\r\n    List<Comparable<?>> rules = ruleDAO.getRules();\r\n    if (rules.isEmpty())\r\n        return map.keySet();\r\n    Set<Object> result = new HashSet();\r\n    Set<Object> ruleKeys = new HashSet();\r\n    for (Comparable<?> rule : rules) {\r\n        ruleKeys.add(keyFor(rule));\r\n    }\r\n    for (Object key : map.keySet()) {\r\n        if (!ruleKeys.contains(key))\r\n            result.add(key);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTest.applyAddCatalogChanges",
	"Comment": "helper method that add some new catalog elements to the provided geoserver instance.",
	"Method": "void applyAddCatalogChanges(GeoServerInstance instance){\r\n    Catalog catalog = instance.getCatalog();\r\n    ReferencedEnvelope envelope = new ReferencedEnvelope(-1.0, 1.0, -2.0, 2.0, DefaultGeographicCRS.WGS84);\r\n    AttributionInfo attribution = new AttributionInfoImpl();\r\n    attribution.setTitle(\"attribution-Title\");\r\n    attribution.setHref(\"attribution-Href\");\r\n    attribution.setLogoURL(\"attribution-LogoURL\");\r\n    attribution.setLogoType(\"attribution-LogoType\");\r\n    attribution.setLogoWidth(500);\r\n    attribution.setLogoHeight(600);\r\n    WorkspaceInfo workspace = new WorkspaceInfoImpl();\r\n    workspace.setName(\"workspace-Name\");\r\n    catalog.add(workspace);\r\n    NamespaceInfo namespace = new NamespaceInfoImpl();\r\n    namespace.setPrefix(workspace.getName());\r\n    namespace.setURI(\"namespace-URI\");\r\n    catalog.add(namespace);\r\n    DataStoreInfo dataStore = new DataStoreInfoImpl(catalog);\r\n    dataStore.setEnabled(false);\r\n    dataStore.setName(\"dataStore-Name\");\r\n    dataStore.setWorkspace(workspace);\r\n    dataStore.setType(\"dataStore-Type\");\r\n    dataStore.setDescription(\"dataStore-Description\");\r\n    catalog.add(dataStore);\r\n    CoverageStoreInfo coverageStore = new CoverageStoreInfoImpl(catalog);\r\n    coverageStore.setEnabled(false);\r\n    coverageStore.setName(\"coverageStore-Name\");\r\n    coverageStore.setWorkspace(workspace);\r\n    coverageStore.setType(\"coverageStore-Type\");\r\n    coverageStore.setDescription(\"coverageStore-Description\");\r\n    catalog.add(coverageStore);\r\n    WMSStoreInfo wmsStore = new WMSStoreInfoImpl(catalog);\r\n    wmsStore.setEnabled(false);\r\n    wmsStore.setName(\"wmsStore-Name\");\r\n    wmsStore.setWorkspace(workspace);\r\n    wmsStore.setType(\"wmsStore-Type\");\r\n    wmsStore.setDescription(\"wmsStore-Description\");\r\n    wmsStore.setCapabilitiesURL(\"wmsStore-CapabilitiesURL\");\r\n    wmsStore.setUseConnectionPooling(false);\r\n    wmsStore.setUsername(\"wmsStore-Username\");\r\n    wmsStore.setPassword(\"wmsStore-Password\");\r\n    wmsStore.setMaxConnections(0);\r\n    wmsStore.setReadTimeout(0);\r\n    wmsStore.setConnectTimeout(0);\r\n    catalog.add(wmsStore);\r\n    FeatureTypeInfo featureType = new FeatureTypeInfoImpl(catalog);\r\n    featureType.setName(\"featureType-Name\");\r\n    featureType.setNativeName(\"featureType-NativeName\");\r\n    featureType.setNamespace(namespace);\r\n    featureType.setTitle(\"featureType-Title\");\r\n    featureType.setDescription(\"featureType-Description\");\r\n    featureType.setAbstract(\"featureType-Abstract\");\r\n    featureType.setSRS(\"EPSG:4326\");\r\n    featureType.setLatLonBoundingBox(envelope);\r\n    featureType.setEnabled(false);\r\n    featureType.setStore(dataStore);\r\n    featureType.setNativeBoundingBox(envelope);\r\n    featureType.setNativeCRS(DefaultGeographicCRS.WGS84);\r\n    featureType.setAdvertised(false);\r\n    featureType.setMaxFeatures(100);\r\n    featureType.setNumDecimals(4);\r\n    featureType.setOverridingServiceSRS(false);\r\n    featureType.setSkipNumberMatched(false);\r\n    featureType.setProjectionPolicy(ProjectionPolicy.FORCE_DECLARED);\r\n    catalog.add(featureType);\r\n    CoverageInfo coverage = new CoverageInfoImpl(catalog);\r\n    coverage.setName(\"coverage-Name\");\r\n    coverage.setNativeName(\"coverage-NativeName\");\r\n    coverage.setNamespace(namespace);\r\n    coverage.setAbstract(\"coverage-Abstract\");\r\n    coverage.setDescription(\"coverage-Description\");\r\n    coverage.setLatLonBoundingBox(envelope);\r\n    coverage.setNativeBoundingBox(envelope);\r\n    coverage.setSRS(\"EPSG:4326\");\r\n    coverage.setNativeCRS(DefaultGeographicCRS.WGS84);\r\n    coverage.setEnabled(false);\r\n    coverage.setStore(coverageStore);\r\n    coverage.setAdvertised(false);\r\n    coverage.setNativeCoverageName(\"coverage-NativeCoverageName\");\r\n    coverage.setProjectionPolicy(ProjectionPolicy.FORCE_DECLARED);\r\n    catalog.add(coverage);\r\n    copyStyle(instance, \"/test_style.sld\", \"test_style.sld\");\r\n    StyleInfo style = new StyleInfoImpl(catalog);\r\n    style.setName(\"style-Name\");\r\n    style.setFormat(\"sld\");\r\n    style.setFilename(\"test_style.sld\");\r\n    catalog.add(style);\r\n    LayerInfo layer = new LayerInfoImpl();\r\n    layer.setResource(featureType);\r\n    layer.setAbstract(\"layer-Abstract\");\r\n    layer.setAttribution(attribution);\r\n    layer.setType(PublishedType.VECTOR);\r\n    layer.setDefaultStyle(style);\r\n    layer.setEnabled(false);\r\n    layer.setQueryable(false);\r\n    layer.setOpaque(false);\r\n    layer.setAdvertised(false);\r\n    catalog.add(layer);\r\n    WMSLayerInfo wmsLayer = new WMSLayerInfoImpl(catalog);\r\n    wmsLayer.setName(\"wmsLayer-Name\");\r\n    wmsLayer.setNativeName(\"wmsLayer-NativeName\");\r\n    wmsLayer.setNamespace(namespace);\r\n    wmsLayer.setTitle(\"wmsLayer-Title\");\r\n    wmsLayer.setAbstract(\"wmsLayer-Abstract\");\r\n    wmsLayer.setDescription(\"wmsLayer-Description\");\r\n    wmsLayer.setLatLonBoundingBox(envelope);\r\n    wmsLayer.setNativeBoundingBox(envelope);\r\n    wmsLayer.setSRS(\"EPSG:4326\");\r\n    wmsLayer.setNativeCRS(DefaultGeographicCRS.WGS84);\r\n    wmsLayer.setEnabled(false);\r\n    wmsLayer.setStore(wmsStore);\r\n    wmsLayer.setAdvertised(false);\r\n    catalog.add(wmsLayer);\r\n    LayerGroupInfo layerGroup = new LayerGroupInfoImpl();\r\n    layerGroup.setTitle(\"layerGroup-Title\");\r\n    layerGroup.setName(\"layerGroup-Name\");\r\n    layerGroup.setMode(Mode.SINGLE);\r\n    layerGroup.setQueryDisabled(false);\r\n    layerGroup.setBounds(envelope);\r\n    layerGroup.getLayers().add(layer);\r\n    layerGroup.getStyles().add(style);\r\n    catalog.add(layerGroup);\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findOrResolveWorkspaceFile",
	"Comment": "returns the configuration file for the specified workspace, if the file does not exist a fileobject will still be returned.",
	"Method": "File findOrResolveWorkspaceFile(WorkspaceInfo ws){\r\n    Resource workspaceFile = config(ws);\r\n    return workspaceFile.file();\r\n}"
}, {
	"Path": "org.geoserver.script.ScriptPlugin.createWfsTxHook",
	"Comment": "creates the hook for wfs transactions.this default implementation returns a default implementation, subclass should override inorder to implement a custom hook.",
	"Method": "WfsTxHook createWfsTxHook(){\r\n    return new WfsTxHook(this);\r\n}"
}, {
	"Path": "org.geoserver.util.IOUtils.createRandomDirectory",
	"Comment": "creates a directory as a child of basedir. the directory name will be preceded by prefix andfollowed by suffix",
	"Method": "File createRandomDirectory(String baseDir,String prefix,String suffix){\r\n    File tempDir = File.createTempFile(prefix, suffix, new File(baseDir));\r\n    tempDir.delete();\r\n    if (!tempDir.mkdir())\r\n        throw new IOException(\"Could not create the temp directory \" + tempDir.getPath());\r\n    return tempDir;\r\n}"
}, {
	"Path": "org.geoserver.rest.DispatcherCallback.getControllerBean",
	"Comment": "attempts to unwrap the controller in case the handler is annotation driven, returns thehandler otherwise",
	"Method": "Object getControllerBean(Object handler){\r\n    if (handler instanceof HandlerMethod) {\r\n        return ((HandlerMethod) handler).getBean();\r\n    }\r\n    return handler;\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.dxf.Rel14DXFWriter.isBlockGeometry",
	"Comment": "checks if a geometry is complex and should be exported as a block.",
	"Method": "boolean isBlockGeometry(Geometry geom){\r\n    if (geom != null) {\r\n        if (Polygon.class.isAssignableFrom(geom.getClass())) {\r\n            return ((Polygon) geom).getNumInteriorRing() > 0;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.loadAuthenticationProviderConfig",
	"Comment": "loads an authentication provider config from a named configuration. null if notfound",
	"Method": "SecurityAuthProviderConfig loadAuthenticationProviderConfig(String name){\r\n    return authProviderHelper.loadConfig(name);\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTestsUtils.equalize",
	"Comment": "equalizes two geoserver instances, the first instance will be used as reference.",
	"Method": "void equalize(GeoServerInstance instanceA,GeoServerInstance instanceB){\r\n    List<InfoDiff> differences = differences(instanceA, instanceB);\r\n    for (InfoDiff difference : differences) {\r\n        Info infoA = difference.getInfoA();\r\n        Info infoB = difference.getInfoB();\r\n        if (infoA == null) {\r\n            remove(instanceB.getGeoServer(), instanceB.getCatalog(), infoB);\r\n        } else if (infoB == null) {\r\n            add(instanceB.getGeoServer(), instanceB.getCatalog(), (Info) SerializationUtils.clone(infoA));\r\n        } else {\r\n            save(instanceB.getGeoServer(), instanceB.getCatalog(), ModificationProxy.unwrap(infoA), ModificationProxy.unwrap(infoB));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.GeorectifyCoverage.invertGridGeometry",
	"Comment": "given a target query and a target grid geometry returns the grid geometry to be used to readthe input data of the process involved in rendering. this method will be called only if theinput data is a grid coverage or a grid coverage reader",
	"Method": "GridGeometry invertGridGeometry(Query targetQuery,GridGeometry targetGridGeometry){\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.AbstractNetCDFEncoder.initializeHigherRankDimensions",
	"Comment": "initialize higher rank dimensions, such as time, elevation, custom, ...",
	"Method": "void initializeHigherRankDimensions(){\r\n    Dimension boundDimension = null;\r\n    for (NetCDFDimensionsManager.NetCDFDimensionMapping dimension : dimensionsManager.getDimensions()) {\r\n        final DimensionBean dim = dimension.getCoverageDimension();\r\n        final boolean isRange = dim.isRange();\r\n        String dimensionName = dimension.getName();\r\n        final int dimensionLength = dimension.getDimensionValues().getSize();\r\n        if (dimensionName.equalsIgnoreCase(\"TIME\") || dimensionName.equalsIgnoreCase(\"ELEVATION\")) {\r\n            dimensionName = dimensionName.toLowerCase();\r\n        }\r\n        if (isRange) {\r\n            if (boundDimension == null) {\r\n                boundDimension = writer.addDimension(null, NetCDFUtilities.BOUNDARY_DIMENSION, 2);\r\n            }\r\n        }\r\n        final Dimension netcdfDimension = writer.addDimension(null, dimensionName, dimensionLength);\r\n        dimension.setNetCDFDimension(netcdfDimension);\r\n        Variable var = writer.addVariable(null, dimensionName, NetCDFUtilities.getNetCDFDataType(dim.getDatatype()), dimensionName);\r\n        writer.addVariableAttribute(var, new Attribute(NetCDFUtilities.LONG_NAME, dimensionName));\r\n        writer.addVariableAttribute(var, new Attribute(NetCDFUtilities.DESCRIPTION, dimensionName));\r\n        if (NetCDFUtilities.isATime(dim.getDatatype())) {\r\n            writer.addVariableAttribute(var, new Attribute(NetCDFUtilities.UNITS, NetCDFUtilities.TIME_ORIGIN));\r\n        } else {\r\n            writer.addVariableAttribute(var, new Attribute(NetCDFUtilities.UNITS, dim.getSymbol()));\r\n        }\r\n        if (isRange) {\r\n            final List<Dimension> boundsDimensions = new ArrayList<Dimension>();\r\n            boundsDimensions.add(netcdfDimension);\r\n            boundsDimensions.add(boundDimension);\r\n            final String boundName = dimensionName + NetCDFUtilities.BOUNDS_SUFFIX;\r\n            writer.addVariableAttribute(var, new Attribute(NetCDFUtilities.BOUNDS, boundName));\r\n            writer.addVariable(null, boundName, NetCDFUtilities.getNetCDFDataType(dim.getDatatype()), boundsDimensions);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.BruteForceListener.getUserName",
	"Comment": "returns the username for this authentication, or null if missing or cannot be determined",
	"Method": "String getUserName(Authentication authentication){\r\n    if (authentication == null) {\r\n        return null;\r\n    }\r\n    Object principal = authentication.getPrincipal();\r\n    if (principal != null) {\r\n        if (principal instanceof UserDetails) {\r\n            return ((UserDetails) principal).getUsername();\r\n        } else if (principal instanceof String) {\r\n            return (String) principal;\r\n        }\r\n    }\r\n    return authentication.getName();\r\n}"
}, {
	"Path": "org.geoserver.ows.util.ResponseUtils.getExtension",
	"Comment": "returns the file extension from a uri string.if the uri does not specify an extension, null is returned.",
	"Method": "String getExtension(String uri){\r\n    int slash = uri.lastIndexOf('/');\r\n    if (slash != -1) {\r\n        uri = uri.substring(slash + 1);\r\n    }\r\n    int dot = uri.lastIndexOf('.');\r\n    if (dot != -1) {\r\n        return uri.substring(dot + 1);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.gwc.GWC.loadGroupParents",
	"Comment": "given a list of groups, recursively loads all other groups containing any of them",
	"Method": "void loadGroupParents(List<LayerGroupInfo> layerGroups){\r\n    boolean foundNewParents = true;\r\n    List<LayerGroupInfo> newGroups = new ArrayList(layerGroups);\r\n    while (foundNewParents && !newGroups.isEmpty()) {\r\n        List<Filter> parentFilters = new ArrayList();\r\n        for (LayerGroupInfo lg : newGroups) {\r\n            parentFilters.add(ff.equal(ff.property(\"layers.id\"), ff.literal(lg.getId()), true, MatchAction.ANY));\r\n        }\r\n        Or parentFilter = ff.or(parentFilters);\r\n        newGroups.clear();\r\n        foundNewParents = false;\r\n        try (CloseableIterator<LayerGroupInfo> it = getCatalog().list(LayerGroupInfo.class, parentFilter)) {\r\n            while (it.hasNext()) {\r\n                LayerGroupInfo lg = it.next();\r\n                if (!layerGroups.contains(lg)) {\r\n                    newGroups.add(lg);\r\n                    layerGroups.add(lg);\r\n                    foundNewParents = true;\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            log.log(Level.SEVERE, \"Failed to recursively load parents group parents \");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.dxf.AbstractDXFWriter.writeGroup",
	"Comment": "writes the simplest dxf object, a group, composed of a numeric code and a value. the valuetype can be interpreted looking at the code.",
	"Method": "void writeGroup(int code,String value){\r\n    writer.write(StringUtils.leftPad(code + \"\", 3) + EOL);\r\n    writer.write(value + EOL);\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.WMTSStoreNewPageTest.testPageRendersOnLoad",
	"Comment": "a kind of smoke test that only asserts the page is rendered when first loaded",
	"Method": "void testPageRendersOnLoad(){\r\n    startPage();\r\n    tester.assertComponent(\"form:workspacePanel\", WorkspacePanel.class);\r\n}"
}, {
	"Path": "org.geoserver.test.NormalizedMultiValuesTest.checkStation2Gml32",
	"Comment": "helper method that checks that station 2 is present in the provided document.",
	"Method": "void checkStation2Gml32(Document document){\r\n    checkCount(WFS20_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/wfs:member/st_gml32:Station_gml32[@gml:id='st.2']\");\r\n    checkCount(WFS20_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/wfs:member/st_gml32:Station_gml32\" + \"[@gml:id='st.2']\" + \"[st_gml32:tag='st_2_tag_a']/st_gml32:tag[@st_gml32:code='4']\");\r\n    checkCount(WFS20_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/wfs:member/st_gml32:Station_gml32\" + \"[@gml:id='st.2']\" + \"[st_gml32:tag='st_2_tag_b']/st_gml32:tag[@st_gml32:code='5']\");\r\n    checkCount(WFS20_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/wfs:member/st_gml32:Station_gml32\" + \"[@gml:id='st.2']\" + \"[st_gml32:tag='europe']/st_gml32:tag[@st_gml32:code='6']\");\r\n    checkCount(WFS20_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/wfs:member/st_gml32:Station_gml32\" + \"[@gml:id='st.2']\" + \"/st_gml32:measurements/ms_gml32:Measurement_gml32\" + \"[@gml:id='ms.3']\" + \"[ms_gml32:tag='pressure_tag']\");\r\n}"
}, {
	"Path": "org.geoserver.importer.bdb.BDBImportStoreTest.testSerialVersionUIDChange",
	"Comment": "in order to test this, run once, then change the serialversionuid of importcontext2",
	"Method": "void testSerialVersionUIDChange(){\r\n    Importer imp = new Importer(null) {\r\n        @Override\r\n        public File getImportRoot() {\r\n            File root = new File(\"target\");\r\n            root.mkdirs();\r\n            return root;\r\n        }\r\n    };\r\n    ImportContext ctx = new ImportContext2();\r\n    ctx.setState(ImportContext.State.PENDING);\r\n    ctx.setUser(\"fooboo\");\r\n    BDBImportStore store = new BDBImportStore(imp);\r\n    try {\r\n        store.init();\r\n        store.add(ctx);\r\n        Iterator<ImportContext> iterator = store.iterator();\r\n        while (iterator.hasNext()) {\r\n            ctx = iterator.next();\r\n            assertEquals(\"fooboo\", ctx.getUser());\r\n        }\r\n        store.add(ctx);\r\n    } finally {\r\n        store.destroy();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.importer.bdb.BDBImportStoreTest.testSerialVersionUIDChange",
	"Comment": "in order to test this, run once, then change the serialversionuid of importcontext2",
	"Method": "void testSerialVersionUIDChange(){\r\n    File root = new File(\"target\");\r\n    root.mkdirs();\r\n    return root;\r\n}"
}, {
	"Path": "org.geoserver.test.NormalizedMultiValuesTest.checkStation2Gml31",
	"Comment": "helper method that checks that station 2 is present in the provided document.",
	"Method": "void checkStation2Gml31(Document document){\r\n    checkCount(WFS11_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/gml:featureMember/st_gml31:Station_gml31[@gml:id='st.2']\");\r\n    checkCount(WFS11_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/gml:featureMember/st_gml31:Station_gml31\" + \"[@gml:id='st.2']\" + \"[st_gml31:tag='st_2_tag_a']/st_gml31:tag[@st_gml31:code='4']\");\r\n    checkCount(WFS11_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/gml:featureMember/st_gml31:Station_gml31\" + \"[@gml:id='st.2']\" + \"[st_gml31:tag='st_2_tag_b']/st_gml31:tag[@st_gml31:code='5']\");\r\n    checkCount(WFS11_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/gml:featureMember/st_gml31:Station_gml31\" + \"[@gml:id='st.2']\" + \"[st_gml31:tag='europe']/st_gml31:tag[@st_gml31:code='6']\");\r\n    checkCount(WFS11_XPATH_ENGINE, document, 1, \"/wfs:FeatureCollection/gml:featureMember/st_gml31:Station_gml31\" + \"[@gml:id='st.2']\" + \"/st_gml31:measurements/ms_gml31:Measurement_gml31\" + \"[@gml:id='ms.3']\" + \"[ms_gml31:tag='pressure_tag']\");\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDefaultValuesHelper.betweenFilter",
	"Comment": "a simple filter making sure a property is contained between minvalue and maxvalue",
	"Method": "Filter betweenFilter(String start,Object minValue,Object maxValue){\r\n    return FF.between(FF.property(start), FF.literal(minValue), FF.literal(maxValue));\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.LegacyCatalogReader.dataStoreParams",
	"Comment": "convenience method for reading connection parameters from a datastore element.",
	"Method": "Map dataStoreParams(Element dataStoreElement){\r\n    Element paramsElement = ReaderUtils.getChildElement(dataStoreElement, \"connectionParams\", true);\r\n    NodeList paramList = paramsElement.getElementsByTagName(\"parameter\");\r\n    Map params = new HashMap();\r\n    for (int i = 0; i < paramList.getLength(); i++) {\r\n        Element paramElement = (Element) paramList.item(i);\r\n        String key = ReaderUtils.getAttribute(paramElement, \"name\", true);\r\n        String value = ReaderUtils.getAttribute(paramElement, \"value\", false);\r\n        params.put(key, value);\r\n    }\r\n    return params;\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityProvider.createFilter",
	"Comment": "creates a security filter.if the extension does not provide an filter this method should simply return null.",
	"Method": "GeoServerSecurityFilter createFilter(SecurityNamedServiceConfig config){\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.ReaderUtils.getAttribute",
	"Comment": "getintattribute purpose.used to help with xml manipulations. returns the first child integer attribute of thespecified name. an exception occurs when the node is required and not found.",
	"Method": "String getAttribute(Element elem,String attName,boolean mandatory){\r\n    if (elem == null) {\r\n        if (mandatory) {\r\n            throw new NullPointerException();\r\n        }\r\n        return \"\";\r\n    }\r\n    Attr att = elem.getAttributeNode(attName);\r\n    String value = null;\r\n    if (att != null) {\r\n        value = att.getValue();\r\n    }\r\n    if (mandatory) {\r\n        if (att == null) {\r\n            throw new Exception(\"element \" + elem.getNodeName() + \" does not contains an attribute named \" + attName);\r\n        } else if (\"\".equals(value)) {\r\n            throw new Exception(\"attribute \" + attName + \"in element \" + elem.getNodeName() + \" is empty\");\r\n        }\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.geoserver.config.util.LegacyServicesReader.read",
	"Comment": "parses the servivces.xml file into a dom.this methodbe called before any other methods.",
	"Method": "void read(File file){\r\n    Reader reader = XmlCharsetDetector.getCharsetAwareReader(new FileInputStream(file));\r\n    try {\r\n        serverConfiguration = ReaderUtils.parse(reader);\r\n        global = null;\r\n        contact = null;\r\n        wfs = null;\r\n        wms = null;\r\n        wcs = null;\r\n    } finally {\r\n        reader.close();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.setup.AppSchemaTestPostgisSetup.createTables",
	"Comment": "write sql string to create tables in the test database based on the property files.",
	"Method": "void createTables(Map<String, File> propertyFiles){\r\n    StringBuffer buf = new StringBuffer();\r\n    buf.append(\"DROP SCHEMA IF EXISTS \").append(ONLINE_DB_SCHEMA).append(\" CASCADE;\\n\");\r\n    buf.append(\"CREATE SCHEMA \").append(ONLINE_DB_SCHEMA).append(\";\\n\");\r\n    for (String fileName : propertyFiles.keySet()) {\r\n        File file = new File(propertyFiles.get(fileName), fileName);\r\n        try (PropertyFeatureReader reader = new PropertyFeatureReader(\"test\", file)) {\r\n            SimpleFeatureType schema = reader.getFeatureType();\r\n            String tableName = schema.getName().getLocalPart().toUpperCase();\r\n            buf.append(\"CREATE TABLE \").append(ONLINE_DB_SCHEMA).append(\".\\\"\").append(tableName).append(\"\\\"(\");\r\n            List<GeometryDescriptor> geoms = new ArrayList<GeometryDescriptor>();\r\n            int size = schema.getAttributeCount() + 1;\r\n            String[] fieldNames = new String[size];\r\n            List<String> createParams = new ArrayList<String>();\r\n            int j = 0;\r\n            String field;\r\n            String type;\r\n            for (PropertyDescriptor desc : schema.getDescriptors()) {\r\n                if (desc instanceof GeometryDescriptor) {\r\n                    geoms.add((GeometryDescriptor) desc);\r\n                } else {\r\n                    field = \"\\\"\" + desc.getName() + \"\\\" \";\r\n                    type = Classes.getShortName(desc.getType().getBinding());\r\n                    if (type.equalsIgnoreCase(\"String\")) {\r\n                        type = \"TEXT\";\r\n                    } else if (type.equalsIgnoreCase(\"Double\")) {\r\n                        type = \"DOUBLE PRECISION\";\r\n                    }\r\n                    field += type;\r\n                    createParams.add(field);\r\n                }\r\n                fieldNames[j] = desc.getName().toString();\r\n                j++;\r\n            }\r\n            fieldNames[j] = \"PKEY\";\r\n            createParams.add(\"\\\"PKEY\\\" TEXT\");\r\n            buf.append(StringUtils.join(createParams.iterator(), \", \"));\r\n            buf.append(\");\\n\");\r\n            buf.append(\"ALTER TABLE \" + ONLINE_DB_SCHEMA + \".\\\"\" + tableName + \"\\\" ADD CONSTRAINT \" + tableName + \"_PK PRIMARY KEY (\\\"PKEY\\\")\\n\");\r\n            for (GeometryDescriptor geom : geoms) {\r\n                buf.append(\"SELECT AddGeometryColumn ('\").append(ONLINE_DB_SCHEMA).append(\"', \");\r\n                buf.append(\"'\").append(tableName).append(\"', \");\r\n                buf.append(\"'\").append(geom.getName().toString()).append(\"', \");\r\n                int srid = getSrid(geom.getType());\r\n                buf.append(srid).append(\", \");\r\n                buf.append(\"'GEOMETRY'\").append(\", \");\r\n                buf.append(geom.getType().getCoordinateReferenceSystem() == null ? 2 : geom.getType().getCoordinateReferenceSystem().getCoordinateSystem().getDimension());\r\n                buf.append(\");\\n\");\r\n            }\r\n            SimpleFeature feature;\r\n            FeatureId id;\r\n            while (reader.hasNext()) {\r\n                buf.append(\"INSERT INTO \").append(ONLINE_DB_SCHEMA).append(\".\\\"\").append(tableName).append(\"\\\"(\\\"\");\r\n                feature = reader.next();\r\n                buf.append(StringUtils.join(fieldNames, \"\\\", \\\"\"));\r\n                buf.append(\"\\\") \");\r\n                buf.append(\"VALUES (\");\r\n                Collection<Property> properties = feature.getProperties();\r\n                String[] values = new String[size];\r\n                int valueIndex = 0;\r\n                for (Property prop : properties) {\r\n                    Object value = prop.getValue();\r\n                    if (value instanceof Geometry) {\r\n                        Geometry geom = (Geometry) value;\r\n                        value = new WKTWriter(geom.getCoordinate().z == Double.NaN ? 2 : 3).write(geom);\r\n                    }\r\n                    if (value == null || value.toString().equalsIgnoreCase(\"null\")) {\r\n                        values[valueIndex] = \"null\";\r\n                    } else if (prop.getType() instanceof GeometryType) {\r\n                        int srid = getSrid(((GeometryType) prop.getType()));\r\n                        if (srid > -1) {\r\n                            values[valueIndex] = \"ST_GeomFromText('\" + value + \"', \" + srid + \")\";\r\n                        } else {\r\n                            values[valueIndex] = \"ST_GeomFromText('\" + value + \"')\";\r\n                        }\r\n                    } else {\r\n                        values[valueIndex] = \"'\" + value + \"'\";\r\n                    }\r\n                    valueIndex++;\r\n                }\r\n                id = feature.getIdentifier();\r\n                values[valueIndex] = \"'\" + id.toString() + \"'\";\r\n                buf.append(StringUtils.join(values, \",\"));\r\n                buf.append(\");\\n\");\r\n            }\r\n        }\r\n        if (buf.length() > 0) {\r\n            this.sql = buf.toString();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.ppio.CoordinateReferenceSystemPPIO.encode",
	"Comment": "encodes the internal object representation of a parameter as a string.",
	"Method": "String encode(Object value){\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    return CRS.lookupIdentifier(((CoordinateReferenceSystem) value), true);\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexIndexesTest.loadFixture",
	"Comment": "try to load the fixture file associated with this tests, if the load file the tests areskipped.",
	"Method": "Properties loadFixture(){\r\n    File fixFile = getFixtureFile();\r\n    assumeTrue(fixFile.exists());\r\n    return loadFixtureProperties(fixFile);\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTestsUtils.resetEventsCount",
	"Comment": "helper method that just reset the count of consumed events of the provided geoserveinstances.",
	"Method": "void resetEventsCount(GeoServerInstance instances){\r\n    Arrays.stream(instances).forEach(GeoServerInstance::resetConsumedEventsCount);\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.LegacyCatalogReader.read",
	"Comment": "parses the catalog.xml file into a dom.this methodbe called before any other methods.",
	"Method": "void read(Resource file){\r\n    Reader reader = XmlCharsetDetector.getCharsetAwareReader(file.in());\r\n    try {\r\n        catalog = ReaderUtils.parse(reader);\r\n    } finally {\r\n        reader.close();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.rememberme.GeoServerTokenBasedRememberMeServices.makeTokenSignature",
	"Comment": "create the signature by removing the user group service name suffix from the user name",
	"Method": "String makeTokenSignature(long tokenExpiryTime,String username,String password){\r\n    Matcher m = RememberMeUserDetailsService.TOKEN_PATTERN.matcher(username);\r\n    String uName;\r\n    if (!m.matches()) {\r\n        uName = username;\r\n    } else {\r\n        uName = m.group(1).replace(\"\\\\@\", \"@\");\r\n    }\r\n    return super.makeTokenSignature(tokenExpiryTime, uName, password);\r\n}"
}, {
	"Path": "org.geoserver.test.BBoxFilterTest.testQueryBboxLatLongURN",
	"Comment": "the following performs a wfs request specifying a bbox parameter of axis ordering latitudelongitude and srsname in urn format. this test should return features if the axis orderingbehaves similar to queries to simple features.",
	"Method": "void testQueryBboxLatLongURN(){\r\n    Document doc = getAsDOM(WFS_GET_FEATURE + LATLONG + \",urn:x-ogc:def:crs:EPSG:4326\");\r\n    LOGGER.info(WFS_GET_FEATURE_LOG + LATLONG + prettyString(doc));\r\n    assertXpathEvaluatesTo(\"2\", \"/wfs:FeatureCollection/@numberOfFeatures\", doc);\r\n    assertXpathCount(2, \"//ex:geomContainer\", doc);\r\n}"
}, {
	"Path": "org.geoserver.wps.executor.MaxExecutionTimeListener.isExpired",
	"Comment": "returns true if the execution went beyond the allowed max time",
	"Method": "boolean isExpired(){\r\n    boolean maxExecutionTimeExceeded = maxExecutionTime > 0 && startTime > 0 && (System.currentTimeMillis() - startTime) > maxExecutionTime;\r\n    boolean maxTotalTimeExceeded = maxTotalTime > 0 && (System.currentTimeMillis() - queuedTime) > maxTotalTime;\r\n    return maxExecutionTimeExceeded || maxTotalTimeExceeded;\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.BaseCoverageResponseDelegate.getConformanceClass",
	"Comment": "provides a fallback, a value that looks like a gmlcov conformance class. delegates that canbe actually associated to an official conformance class should override this method",
	"Method": "String getConformanceClass(String format){\r\n    return \"http://www.opengis.net/spec/WCS_coverage-encoding-x\" + getMimeType(format);\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.WCSNetCDFTest.testInputMemoryExceeded",
	"Comment": "this test checks if an exception is thrown when is requested an image with a total sizegreater than the maximum geoserver input memory allowed.",
	"Method": "void testInputMemoryExceeded(){\r\n    setInputLimit(40);\r\n    MockHttpServletResponse response = getAsServletResponse(\"ows?request=GetCoverage&service=WCS&version=2.0.1\" + \"&coverageId=wcs__NO2&format=application/x-netcdf\");\r\n    assertEquals(\"application/xml\", response.getContentType());\r\n    setInputLimit(-1);\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.DownloadProcessTest.testDownloadEstimatorHardOutputLimit",
	"Comment": "test download estimator for vectorial data. the result should be exceed the hard outputlimits",
	"Method": "void testDownloadEstimatorHardOutputLimit(){\r\n    DownloadEstimatorProcess limits = new DownloadEstimatorProcess(new StaticDownloadServiceConfiguration(new DownloadServiceConfiguration(DownloadServiceConfiguration.NO_LIMIT, DownloadServiceConfiguration.NO_LIMIT, DownloadServiceConfiguration.NO_LIMIT, 10, DownloadServiceConfiguration.DEFAULT_COMPRESSION_LEVEL, DownloadServiceConfiguration.NO_LIMIT)), getGeoServer());\r\n    final WPSResourceManager resourceManager = getResourceManager();\r\n    DownloadProcess downloadProcess = new DownloadProcess(getGeoServer(), limits, resourceManager);\r\n    try {\r\n        // layerName\r\n        downloadProcess.execute(getLayerId(MockData.POLYGONS), null, \"application/zip\", null, CRS.decode(\"EPSG:32615\"), roi, false, null, null, null, null, null, new NullProgressListener());\r\n        Assert.assertFalse(true);\r\n    } catch (ProcessException e) {\r\n        Assert.assertEquals(\"java.io.IOException: Download Exceeded the maximum HARD allowed size!: Download Exceeded the maximum HARD allowed size!\", e.getMessage() + (e.getCause() != null ? \": \" + e.getCause().getMessage() : \"\"));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.getLastResponse",
	"Comment": "returns the last mockhttpservletrequest response. warning, not thread safe. last response iscleared at before each test method run.",
	"Method": "MockHttpServletResponse getLastResponse(){\r\n    return lastResponse;\r\n}"
}, {
	"Path": "org.geoserver.security.impl.ServiceAccessRule.compareTo",
	"Comment": "comparison implemented so that generic rules get first, specific one are compared by serviceand method",
	"Method": "int compareTo(ServiceAccessRule other){\r\n    int compareService = compareServiceItems(service, other.service);\r\n    if (compareService != 0)\r\n        return compareService;\r\n    return compareServiceItems(method, other.method);\r\n}"
}, {
	"Path": "org.geoserver.wps.ProcessEvent.getOutputs",
	"Comment": "the process outputs. the field is available only when the process is complete",
	"Method": "Map<String, Object> getOutputs(){\r\n    return outputs;\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.Dimension.getDomainSummary",
	"Comment": "returns the domain summary. if the count is lower than expandlimit then only thecount will be returned, otherwise min and max will also be returned",
	"Method": "DomainSummary getDomainSummary(FeatureCollection features,String attribute,int expandLimit,DomainSummary getDomainSummary,Query query,int expandLimit){\r\n    if (expandLimit != 0) {\r\n        Set uniqueValues = DimensionsUtils.getUniqueValues(features, attribute, expandLimit + 1);\r\n        if (uniqueValues.size() <= expandLimit || expandLimit < 0) {\r\n            return new DomainSummary(new TreeSet(uniqueValues));\r\n        }\r\n    }\r\n    Map<Aggregate, Object> minMax = DimensionsUtils.getAggregates(attribute, features, Aggregate.MIN, Aggregate.MAX);\r\n    return new DomainSummary(minMax.get(Aggregate.MIN), minMax.get(Aggregate.MAX), minMax.values().stream().filter(v -> v != null).count());\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaMockData.getFeatureTypeDir",
	"Comment": "get the file for the directory that contains the mapping and property files.",
	"Method": "File getFeatureTypeDir(File featureTypesBaseDir,String namespacePrefix,String typeName){\r\n    return new File(featureTypesBaseDir, getDataStoreName(namespacePrefix, typeName));\r\n}"
}, {
	"Path": "org.geoserver.security.file.LockFile.writeLockFileContent",
	"Comment": "write some info into the lock file hostname, ip, user and lock file path",
	"Method": "void writeLockFileContent(Resource lockFile){\r\n    Properties props = new Properties();\r\n    try (OutputStream out = lockFile.out()) {\r\n        props.store(out, \"Locking info\");\r\n        String hostname = \"UNKNOWN\";\r\n        String ip = \"UNKNOWN\";\r\n        try {\r\n            hostname = InetAddress.getLocalHost().getHostName();\r\n            InetAddress[] addrs = InetAddress.getAllByName(hostname);\r\n            for (InetAddress addr : addrs) {\r\n                if (!addr.isLoopbackAddress() && addr.isSiteLocalAddress())\r\n                    ip = addr.getHostAddress();\r\n            }\r\n        } catch (UnknownHostException ex) {\r\n        }\r\n        props.put(\"hostname\", hostname);\r\n        props.put(\"ip\", ip);\r\n        props.put(\"location\", lockFile.path());\r\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\r\n        props.put(\"principal\", auth == null ? \"UNKNOWN\" : auth.getName());\r\n        props.store(out, \"Locking info\");\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.DimensionsUtils.formatDomainSimpleValue",
	"Comment": "helper method that converts a domain value to string. date values are formatted using theiso8601 format.",
	"Method": "String formatDomainSimpleValue(Object value){\r\n    if (value instanceof Date) {\r\n        ISO8601Formatter formatter = new ISO8601Formatter();\r\n        return formatter.format(value);\r\n    }\r\n    return value.toString();\r\n}"
}, {
	"Path": "org.geoserver.wfs.JoinExtractingVisitor.setupPrimary",
	"Comment": "find the center of the star join, and remove it from the feature types and aliases arrays therest of the algorithm is setup to have only the secondary types in these arrays",
	"Method": "void setupPrimary(){\r\n    if (primaryFeatureType == null) {\r\n        int idx = getPrimaryFeatureTypeIndex(this.joinFilters);\r\n        primaryFeatureType = featureTypes.get(idx);\r\n        primaryAlias = aliases.get(idx);\r\n        featureTypes.remove(idx);\r\n        aliases.remove(idx);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.BBoxFilterTest.testQuery",
	"Comment": "the following performs a wfs request and obtains all features specified inbboxtestpropertyfile.properties",
	"Method": "void testQuery(){\r\n    Document doc = getAsDOM(WFS_GET_FEATURE);\r\n    LOGGER.info(WFS_GET_FEATURE_LOG + prettyString(doc));\r\n    assertXpathEvaluatesTo(\"3\", \"/wfs:FeatureCollection/@numberOfFeatures\", doc);\r\n    assertXpathCount(3, \"//ex:geomContainer\", doc);\r\n}"
}, {
	"Path": "org.vfny.geoserver.util.DataStoreUtils.aquireFactory",
	"Comment": "when loading from dto use the params to locate factory.bleck",
	"Method": "DataAccessFactory aquireFactory(Map params,DataAccessFactory aquireFactory,String displayName){\r\n    if (displayName == null) {\r\n        return null;\r\n    }\r\n    for (Iterator i = getAvailableDataStoreFactories().iterator(); i.hasNext(); ) {\r\n        DataAccessFactory factory = (DataAccessFactory) i.next();\r\n        initializeDataStoreFactory(factory);\r\n        if (displayName.equals(factory.getDisplayName())) {\r\n            return factory;\r\n        }\r\n        if (displayName.equals(factory.getClass().toString())) {\r\n            return factory;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.NetCDFCoverageResponseDelegate.streamBack",
	"Comment": "stream back the content of the temporary file to the output stream",
	"Method": "void streamBack(File file,OutputStream output){\r\n    final byte[] buffer = new byte[8 * 1024];\r\n    if (file.exists()) {\r\n        final InputStream in = new FileInputStream(file);\r\n        int c;\r\n        try {\r\n            while (-1 != (c = in.read(buffer))) {\r\n                output.write(buffer, 0, c);\r\n            }\r\n        } finally {\r\n            in.close();\r\n        }\r\n    }\r\n    output.flush();\r\n}"
}, {
	"Path": "org.geoserver.wfs.WFSReprojectionUtil.reprojectFilter",
	"Comment": "reprojects all geometric filter elements to the native crs of the provided schema",
	"Method": "Filter reprojectFilter(Filter filter,FeatureType schema){\r\n    ReprojectingFilterVisitor visitor = new ReprojectingFilterVisitor(ff, schema);\r\n    return (Filter) filter.accept(visitor, null);\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTest.waitNoEvents",
	"Comment": "helper methods that waits a specified amount of time and checks that no events were consumed.",
	"Method": "void waitNoEvents(GeoServerInstance instance,int waitTimeMs){\r\n    try {\r\n        Thread.sleep(waitTimeMs);\r\n    } catch (InterruptedException exception) {\r\n        Thread.currentThread().interrupt();\r\n    }\r\n    assertThat(instance.getConsumedEventsCount(), is(0));\r\n}"
}, {
	"Path": "org.geoserver.flow.controller.AbstractFlowControllerTest.waitState",
	"Comment": "waits for he flow controller testing thread to get into a specified state for a max givenamount of time, fail otherwise",
	"Method": "void waitState(ThreadState state,FlowControllerTestingThread tt,long maxWait){\r\n    long start = System.currentTimeMillis();\r\n    while (!state.equals(tt.state) && System.currentTimeMillis() - start < maxWait) {\r\n        Thread.sleep(20);\r\n    }\r\n    ThreadState finalState = tt.state;\r\n    if (!state.equals(finalState)) {\r\n        fail(\"Waited \" + maxWait + \"ms for FlowControllerTestingThread to get into \" + state + \", but it is still in state \" + finalState);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.LoginFormInfo.getFilterClass",
	"Comment": "returns the geoserversecurityfilter class requiring the login button",
	"Method": "Class<GeoServerSecurityProvider> getFilterClass(){\r\n    return filterClass;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findOrCreateStyleFile",
	"Comment": "returns the configuration file for the specified style, if the file does not exist a fileobject is still returned.",
	"Method": "File findOrCreateStyleFile(StyleInfo s){\r\n    Resource resource = config(s);\r\n    return resource.file();\r\n}"
}, {
	"Path": "org.geoserver.rest.catalog.FeatureTypeControllerWFSTest.addPropertyDataStoreOnlyConfigureFirst",
	"Comment": "add a property data store with multiple feature types, but only configure the first.",
	"Method": "void addPropertyDataStoreOnlyConfigureFirst(){\r\n    ByteArrayOutputStream zbytes = new ByteArrayOutputStream();\r\n    ZipOutputStream zout = new ZipOutputStream(zbytes);\r\n    ByteArrayOutputStream bytes = new ByteArrayOutputStream();\r\n    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(bytes));\r\n    writer.write(\"_=name:String,pointProperty:Point\\n\");\r\n    writer.write(\"pdsa.0='zero'|POINT(0 0)\\n\");\r\n    writer.write(\"pdsa.1='one'|POINT(1 1)\\n\");\r\n    writer.flush();\r\n    zout.putNextEntry(new ZipEntry(\"pdsa.properties\"));\r\n    zout.write(bytes.toByteArray());\r\n    bytes.reset();\r\n    writer.write(\"_=name:String,pointProperty:Point\\n\");\r\n    writer.write(\"pdsb.0='two'|POINT(2 2)\\n\");\r\n    writer.write(\"pdsb.1='trhee'|POINT(3 3)\\n\");\r\n    writer.flush();\r\n    zout.putNextEntry(new ZipEntry(\"pdsb.properties\"));\r\n    zout.write(bytes.toByteArray());\r\n    zout.flush();\r\n    zout.close();\r\n    String q = \"configure=first\";\r\n    put(BASEPATH + \"/workspaces/gs/datastores/pds/file.properties?\" + q, zbytes.toByteArray(), \"application/zip\");\r\n}"
}, {
	"Path": "org.geoserver.catalog.SLDPackageHandler.unzipSldPackage",
	"Comment": "unzips a sld package to a temporal folder, returning the sld file path.",
	"Method": "File unzipSldPackage(Object input){\r\n    File myTempDir = Files.createTempDir();\r\n    org.geoserver.util.IOUtils.decompress((InputStream) input, myTempDir);\r\n    File[] files = myTempDir.listFiles(new FilenameFilter() {\r\n        public boolean accept(File dir, String name) {\r\n            return name.toLowerCase().endsWith(\".sld\");\r\n        }\r\n    });\r\n    if (files.length != 1) {\r\n        throw new IOException(\"No SLD file\");\r\n    }\r\n    return files[0];\r\n}"
}, {
	"Path": "org.geoserver.catalog.SLDPackageHandler.unzipSldPackage",
	"Comment": "unzips a sld package to a temporal folder, returning the sld file path.",
	"Method": "File unzipSldPackage(Object input){\r\n    return name.toLowerCase().endsWith(\".sld\");\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.Domains.getFeatureCollection",
	"Comment": "helper method that just gets a feature collection from a raster.",
	"Method": "FeatureCollection getFeatureCollection(FeatureCollection getFeatureCollection,CoverageInfo typeInfo){\r\n    GridCoverage2DReader reader = (GridCoverage2DReader) typeInfo.getGridCoverageReader(null, null);\r\n    if (!(reader instanceof StructuredGridCoverage2DReader)) {\r\n        throw new RuntimeException(\"Is not possible to obtain a feature collection from a non structured reader.\");\r\n    }\r\n    StructuredGridCoverage2DReader structuredReader = (StructuredGridCoverage2DReader) reader;\r\n    String coverageName = structuredReader.getGridCoverageNames()[0];\r\n    GranuleSource source = structuredReader.getGranules(coverageName, true);\r\n    Query query = new Query(source.getSchema().getName().getLocalPart());\r\n    if (filter != null) {\r\n        query.setFilter(filter);\r\n    }\r\n    return source.getGranules(query);\r\n}"
}, {
	"Path": "org.geoserver.wfs.xml.NameSpaceTranslator.isValidDefinition",
	"Comment": "isvaliddefinition purpose.checks to see if the definition provided is found in the list of elements for thisnamespace.",
	"Method": "boolean isValidDefinition(String definition){\r\n    if ((definition == null) || (definition == \"\")) {\r\n        return false;\r\n    }\r\n    Set elems = getElements();\r\n    Iterator i = elems.iterator();\r\n    while (i.hasNext()) {\r\n        NameSpaceElement nse = (NameSpaceElement) i.next();\r\n        if (nse == null) {\r\n            continue;\r\n        }\r\n        String def = nse.getTypeDefName();\r\n        if ((def != null) && def.equals(definition)) {\r\n            return true;\r\n        }\r\n        def = nse.getQualifiedTypeDefName();\r\n        if ((def != null) && def.equals(definition)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.wcs.kvp.Wcs10GetCoverageRequestReader.parseInterpolation",
	"Comment": "parses the interpolation parameter from the kvp. if nothing is present the default nearestneighbor is set.",
	"Method": "InterpolationMethodType parseInterpolation(Map kvp){\r\n    if (kvp.containsKey(\"interpolation\")) {\r\n        return (InterpolationMethodType) kvp.get(\"interpolation\");\r\n    }\r\n    return InterpolationMethodType.NEAREST_NEIGHBOR_LITERAL;\r\n}"
}, {
	"Path": "org.vfny.geoserver.ServiceException.getXmlMessage",
	"Comment": "gets the message, encoding it with the proper escaped xml characters. if requested it printsthe whole stack trace in the response.",
	"Method": "String getXmlMessage(boolean printStackTrace){\r\n    String indent = \"   \";\r\n    StringBuffer mesg = new StringBuffer();\r\n    if (printStackTrace) {\r\n        mesg.append(createStackTrace());\r\n    } else {\r\n        mesg.append(this.getMessage());\r\n    }\r\n    return ResponseUtils.encodeXML(mesg.toString());\r\n}"
}, {
	"Path": "org.geoserver.script.ScriptManager.findScriptFile",
	"Comment": "finds a script file at the specified path, returning null if the file does notexist.",
	"Method": "File findScriptFile(String dirPath,String filename,File findScriptFile,String path,File findScriptFile,String name,ScriptType type,String extension){\r\n    return scriptFile(name, type, extension).file();\r\n}"
}, {
	"Path": "org.geoserver.util.ReaderUtils.getBooleanAttribute",
	"Comment": "getbooleanattribute purpose.used to help with xml manipulations. returns the first child integer attribute of thespecified name. an exception occurs when the node is required and not found.",
	"Method": "boolean getBooleanAttribute(Element elem,String attName,boolean mandatory,boolean defaultValue){\r\n    String value = getAttribute(elem, attName, mandatory);\r\n    if ((value == null) || (value == \"\")) {\r\n        return defaultValue;\r\n    }\r\n    return Boolean.valueOf(value).booleanValue();\r\n}"
}, {
	"Path": "org.geoserver.rest.ecql.RESTECQLTest.extractFile",
	"Comment": "private method for creating a new file object associated to the input path.",
	"Method": "File extractFile(String expression,CoverageStoreInfo cs,String itemPath,String filename){\r\n    String url = cs.getURL();\r\n    Expression exp = ECQL.toExpression(expression);\r\n    SimpleFeature feature = SimpleFeatureBuilder.build(type, new Object[] { itemPath, filename }, null);\r\n    String newPath = exp.evaluate(feature, String.class);\r\n    return new File(url, newPath);\r\n}"
}, {
	"Path": "org.geoserver.csw.records.GenericRecordBuilder.addBoundingBox",
	"Comment": "adds a bounding box to the record. the envelope must be in wgs84",
	"Method": "void addBoundingBox(ReferencedEnvelope env){\r\n    boxes.add(env);\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.CatalogInfoLookup.setCatalog",
	"Comment": "sets the specified catalog into all cataloginfo objects contained in this lookup",
	"Method": "CatalogInfoLookup setCatalog(Catalog catalog){\r\n    for (Map<Name, T> valueMap : nameMultiMap.values()) {\r\n        if (valueMap != null) {\r\n            for (T v : valueMap.values()) {\r\n                if (v instanceof CatalogInfo) {\r\n                    Method setter = OwsUtils.setter(v.getClass(), \"catalog\", Catalog.class);\r\n                    if (setter != null) {\r\n                        try {\r\n                            setter.invoke(v, catalog);\r\n                        } catch (Exception e) {\r\n                            LOGGER.log(Level.FINE, \"Failed to switch CatalogInfo to new catalog impl\", e);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.HistogramUtils.findHistogramType",
	"Comment": "helper method that just founds the histogram type based on domains values.",
	"Method": "HistogramType findHistogramType(List<Object> domainValues){\r\n    Object value = domainValues.get(domainValues.size() - 1);\r\n    if (value instanceof Range) {\r\n        value = ((Range) value).getMinValue();\r\n    }\r\n    if (value instanceof Number) {\r\n        return HistogramType.NUMERIC;\r\n    }\r\n    if (value instanceof Date) {\r\n        return HistogramType.TIME;\r\n    }\r\n    return HistogramType.ENUMERATED;\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.assertStatusCodeForPut",
	"Comment": "assert that a put request to a path will have a particular status code for the response.",
	"Method": "void assertStatusCodeForPut(int code,String path,String body,String type){\r\n    assertStatusCodeForRequest(code, \"PUT\", path, body, type);\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerLoader.persist",
	"Comment": "helper method which uses xstream to persist an object as xml on disk.",
	"Method": "void persist(XStreamPersister xp,Object obj,Resource f){\r\n    BufferedOutputStream out = new BufferedOutputStream(f.out());\r\n    xp.save(obj, out);\r\n    out.flush();\r\n    out.close();\r\n}"
}, {
	"Path": "org.geoserver.catalog.StyleGenerator.createStyle",
	"Comment": "generate a style for a resource in the catalog, and add the created style to the catalog.",
	"Method": "StyleInfo createStyle(StyleHandler handler,FeatureTypeInfo featureType,StyleInfo createStyle,StyleHandler handler,FeatureTypeInfo featureType,FeatureType nativeFeatureType,StyleInfo createStyle,StyleHandler handler,CoverageInfo coverage){\r\n    return doCreateStyle(handler, StyleType.RASTER, coverage);\r\n}"
}, {
	"Path": "org.geoserver.test.PropertySelectionTest.testGetFeatureClientProperty",
	"Comment": "test getfeature with property selection, using client properties.",
	"Method": "void testGetFeatureClientProperty(){\r\n    Document doc = getAsDOM(\"wfs?service=WFS&version=1.1.0&request=GetFeature&typeName=gsml:MappedFeature&propertyname=gsml:metadata\");\r\n    LOGGER.info(\"wfs?service=WFS&version=1.1.0&request=GetFeature&typeName=gsml:MappedFeature&propertyname=gsml:metadata response:\\n\" + prettyString(doc));\r\n    assertXpathEvaluatesTo(\"zzzgu.25699\", \"//gsml:MappedFeature[@gml:id='gsml.mappedfeature.mf1']/gsml:metadata/@xlink:href\", doc);\r\n}"
}, {
	"Path": "org.geoserver.ows.util.OwsUtils.dumpExceptionMessages",
	"Comment": "dumps a stack of service exception messages to a string buffer.",
	"Method": "void dumpExceptionMessages(ServiceException e,StringBuffer s,boolean xmlEscape){\r\n    Throwable ex = e;\r\n    do {\r\n        Throwable cause = ex.getCause();\r\n        final String message = ex.getMessage();\r\n        String lastMessage = message;\r\n        if (message != null && !\"\".equals(message)) {\r\n            if (xmlEscape)\r\n                s.append(ResponseUtils.encodeXML(message));\r\n            else\r\n                s.append(message);\r\n            if (ex instanceof ServiceException) {\r\n                for (Iterator t = ((ServiceException) ex).getExceptionText().iterator(); t.hasNext(); ) {\r\n                    s.append(\"\\n\");\r\n                    String msg = (String) t.next();\r\n                    if (!lastMessage.equals(msg)) {\r\n                        if (xmlEscape)\r\n                            s.append(ResponseUtils.encodeXML(msg));\r\n                        else\r\n                            s.append(msg);\r\n                        lastMessage = msg;\r\n                    }\r\n                }\r\n            }\r\n            if (cause != null && cause.getMessage() != null && !\"\".equals(cause.getMessage()))\r\n                s.append(\"\\n\");\r\n        }\r\n        if (ex == cause || cause == null)\r\n            break;\r\n        else\r\n            ex = cause;\r\n    } while (true);\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.DataAccessEditPage.onSaveDataStore",
	"Comment": "callback method called when the submit button have been hit and the parameters validation hassucceed.",
	"Method": "void onSaveDataStore(DataStoreInfo info,AjaxRequestTarget requestTarget){\r\n    if (!storeEditPanel.onSave()) {\r\n        return;\r\n    }\r\n    final Catalog catalog = getCatalog();\r\n    final ResourcePool resourcePool = catalog.getResourcePool();\r\n    resourcePool.clear(info);\r\n    if (info.isEnabled()) {\r\n        DataAccess<? extends FeatureType, ? extends Feature> dataStore;\r\n        try {\r\n            dataStore = catalog.getResourcePool().getDataStore(info);\r\n            LOGGER.finer(\"connection parameters verified for store \" + info.getName() + \". Got a \" + dataStore.getClass().getName());\r\n            doSaveStore(info);\r\n            doReturn(StorePage.class);\r\n        } catch (IOException e) {\r\n            LOGGER.log(Level.WARNING, \"Error obtaining datastore with the modified values\", e);\r\n            confirmSaveOnConnectionFailure(info, requestTarget, e);\r\n        } catch (RuntimeException e) {\r\n            LOGGER.log(Level.WARNING, \"Error obtaining datastore with the modified values\", e);\r\n            confirmSaveOnConnectionFailure(info, requestTarget, e);\r\n        }\r\n    } else {\r\n        doSaveStore(info);\r\n        doReturn(StorePage.class);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexSolrTest.checkStationData",
	"Comment": "helper method that just checks that a station that matches the provided attributes exists inthe xml response.",
	"Method": "void checkStationData(Integer id,String name,String position,XpathEngine engine,Document document){\r\n    checkCount(engine, document, 1, String.format(\"/wfs:FeatureCollection/gml:featureMembers\" + \"/st:Station[@gml:id='%s'][st:stationName='%s'][st:position='%s']\", id, name, position));\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.GeoJSONBuilder.setAxisOrder",
	"Comment": "set the axis order to assume all input will be provided in. has no effect on geometries thathave already been written.",
	"Method": "void setAxisOrder(CRS.AxisOrder axisOrder){\r\n    this.axisOrder = axisOrder;\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.getElementAt",
	"Comment": "helper method that just gets an element from a collection at a certain index.",
	"Method": "T getElementAt(Collection<T> collection,int index){\r\n    Iterator<T> iterator = collection.iterator();\r\n    T element = null;\r\n    for (int i = 0; i <= index && iterator.hasNext(); i++) {\r\n        element = iterator.next();\r\n    }\r\n    return element;\r\n}"
}, {
	"Path": "org.geoserver.security.DataAccessLimits.readFilter",
	"Comment": "reads from the object input stream a string representing a filter in ogc xml encoding andparses it back to a filter object",
	"Method": "Filter readFilter(ObjectInputStream in){\r\n    byte[] serializedReadFilter = (byte[]) in.readObject();\r\n    if (serializedReadFilter != null) {\r\n        try {\r\n            Parser p = new Parser(CONFIGURATION);\r\n            return (Filter) p.parse(new ByteArrayInputStream(serializedReadFilter));\r\n        } catch (Exception e) {\r\n            throw (IOException) new IOException(\"Failed to parse filter\").initCause(e);\r\n        }\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.IsolatedWorkspacesTest.updateWorkspaceIsolationState",
	"Comment": "helper method that updates the isolation state of an workspace and the correspondingnamespace.",
	"Method": "void updateWorkspaceIsolationState(String prefix,boolean isolated){\r\n    Catalog catalog = getCatalog();\r\n    WorkspaceInfo workspace = catalog.getWorkspaceByName(prefix);\r\n    workspace.setIsolated(isolated);\r\n    catalog.save(workspace);\r\n    NamespaceInfo namespace = catalog.getNamespaceByPrefix(prefix);\r\n    namespace.setIsolated(isolated);\r\n    catalog.save(namespace);\r\n}"
}, {
	"Path": "org.geoserver.platform.GeoServerResourceLoader.findOrCreateDirectory",
	"Comment": "performs a directory lookup, creating the file if it does not exist.",
	"Method": "File findOrCreateDirectory(String location,File findOrCreateDirectory,File parentFile,String location,File findOrCreateDirectory,String location,File findOrCreateDirectory,File parentFile,String location){\r\n    Resource directory = get(Paths.convert(getBaseDirectory(), parentFile, location));\r\n    return directory.dir();\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.AbstractFilteredCatalog.checkAccess",
	"Comment": "given a workspace, returns it back if the user can access it, null otherwise",
	"Method": "T checkAccess(T info,T checkAccess,T info,StyleInfo checkAccess,StyleInfo style,T checkAccess,T store,LayerInfo checkAccess,LayerInfo layer,LayerGroupInfo checkAccess,LayerGroupInfo group,T checkAccess,T ns,T checkAccess,T ws){\r\n    if (info instanceof WorkspaceInfo) {\r\n        return (T) checkAccess((WorkspaceInfo) info);\r\n    }\r\n    if (info instanceof NamespaceInfo) {\r\n        return (T) checkAccess((NamespaceInfo) info);\r\n    }\r\n    if (info instanceof StoreInfo) {\r\n        return (T) checkAccess((StoreInfo) info);\r\n    }\r\n    if (info instanceof ResourceInfo) {\r\n        return (T) checkAccess((ResourceInfo) info);\r\n    }\r\n    if (info instanceof LayerInfo) {\r\n        return (T) checkAccess((LayerInfo) info);\r\n    }\r\n    if (info instanceof LayerGroupInfo) {\r\n        return (T) checkAccess((LayerGroupInfo) info);\r\n    }\r\n    return info;\r\n}"
}, {
	"Path": "org.vfny.geoserver.wms.responses.map.htmlimagemap.EncodeHTMLImageMap.isWithInScale",
	"Comment": "evaluates if the supplied scaledenominator is congruent with a rule defined scale range.",
	"Method": "boolean isWithInScale(Rule r,double scaleDenominator){\r\n    return ((r.getMinScaleDenominator()) <= scaleDenominator) && ((r.getMaxScaleDenominator()) > scaleDenominator);\r\n}"
}, {
	"Path": "org.geoserver.security.config.SecurityManagerConfig.getConfigPasswordEncrypterName",
	"Comment": "the name of the password encrypter for encrypting password in configuration files.",
	"Method": "String getConfigPasswordEncrypterName(){\r\n    return configPasswordEncrypterName;\r\n}"
}, {
	"Path": "org.geoserver.rest.catalog.StyleController.unzipSldPackage",
	"Comment": "extracts an input stream representing a zipped directory containing an sld file and anynumber of image files to a temporary location on the filesystem.",
	"Method": "File unzipSldPackage(InputStream object){\r\n    File tempDir = Files.createTempDir();\r\n    org.geoserver.util.IOUtils.decompress(object, tempDir);\r\n    return tempDir;\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.LDAPAuthenticationProviderTest.testUserFilterPlacemarks",
	"Comment": "test that authentication can be done using the couple userfilter and userformat instead ofuserdnpattern, using placemarks in userfilter.",
	"Method": "void testUserFilterPlacemarks(){\r\n    Assume.assumeTrue(LDAPTestUtils.initLdapServer(true, ldapServerUrl, basePath));\r\n    ((LDAPSecurityServiceConfig) config).setUserFilter(\"(givenName={1})\");\r\n    ((LDAPSecurityServiceConfig) config).setUserFormat(\"uid={0},ou=People,dc=example,dc=com\");\r\n    createAuthenticationProvider();\r\n    Authentication result = authProvider.authenticate(authentication);\r\n    assertEquals(3, result.getAuthorities().size());\r\n    ((LDAPSecurityServiceConfig) config).setUserFilter(\"(cn={0})\");\r\n    ((LDAPSecurityServiceConfig) config).setUserFormat(\"uid={0},ou=People,dc=example,dc=com\");\r\n    createAuthenticationProvider();\r\n    result = authProvider.authenticate(authentication);\r\n    assertEquals(3, result.getAuthorities().size());\r\n}"
}, {
	"Path": "org.vfny.geoserver.global.xml.WriterHelper.valueTag",
	"Comment": "valuetag purpose.writes an xml tag with the name and value specified to the stored output writer.",
	"Method": "void valueTag(String tagName,String value){\r\n    writeln(\"<\" + tagName + \" value = \\\"\" + escape(value) + \"\\\" />\");\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.AbstractNetCDFEncoder.initializeDimensions",
	"Comment": "initialize the dimensions by creating netcdf dimensions of the proper type.",
	"Method": "void initializeDimensions(){\r\n    initializeHigherRankDimensions();\r\n    dimensionsManager.addDimensions(crsWriter.initialize2DCoordinatesDimensions());\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findSuppStoreFile",
	"Comment": "returns a supplementary configuration file for a store, if the file does not exist null isreturned.",
	"Method": "File findSuppStoreFile(StoreInfo store,String filename){\r\n    Resource resource = get(store, filename);\r\n    return Resources.file(resource);\r\n}"
}, {
	"Path": "org.geoserver.gwc.web.layer.GeoServerTileLayerEditor.mergeExisting",
	"Comment": "merges the elements of existingformats missing from formats into formats",
	"Method": "void mergeExisting(List<String> formats,Collection<String> existingFormats){\r\n    for (String x : existingFormats) {\r\n        if (!formats.contains(x))\r\n            formats.add(x);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.loadConfigFile",
	"Comment": "reads a config file from the specified directly using the specified xstream persister",
	"Method": "SecurityConfig loadConfigFile(Resource directory,String filename,XStreamPersister xp,SecurityConfig loadConfigFile,Resource directory,XStreamPersister xp){\r\n    return loadConfigFile(directory, CONFIG_FILENAME, xp);\r\n}"
}, {
	"Path": "org.geoserver.wms.capabilities.CapabilitiesTransformerProjectionHandler.create",
	"Comment": "create a capabilitiestransformerprojectionhandler for transformations from sourcecrs totargetcrs.",
	"Method": "CapabilitiesTransformerProjectionHandler create(CoordinateReferenceSystem sourceCrs,CoordinateReferenceSystem targetCrs){\r\n    ProjectionHandler handler = ProjectionHandlerFinder.getHandler(new ReferencedEnvelope(targetCrs), sourceCrs, false);\r\n    if (handler != null) {\r\n        return new CapabilitiesTransformerProjectionHandler(handler);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.web.WorkspaceAdminComponentAuthorizer.isWorkspaceAdmin",
	"Comment": "check if the current user has any admin privilege on at least one workspace.",
	"Method": "boolean isWorkspaceAdmin(Authentication authentication){\r\n    Catalog catalog = getSecurityManager().getCatalog();\r\n    SecureCatalogImpl secureCatalog = GeoServerApplication.get().getBeanOfType(SecureCatalogImpl.class);\r\n    ResourceAccessManager manager = secureCatalog.getResourceAccessManager();\r\n    if (manager != null) {\r\n        for (WorkspaceInfo workspace : catalog.getWorkspaces()) {\r\n            WorkspaceAccessLimits accessLimits = manager.getAccessLimits(authentication, workspace);\r\n            if (accessLimits != null && accessLimits.isAdminable()) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.csw.records.CSWRecordDescriptor.getDescriptor",
	"Comment": "locates the attributedescriptor corresponding to the specified element name",
	"Method": "AttributeDescriptor getDescriptor(String elementName){\r\n    return (AttributeDescriptor) Types.findDescriptor(RECORD_TYPE, elementName);\r\n}"
}, {
	"Path": "org.geoserver.platform.GeoServerResourceLoader.find",
	"Comment": "performs a resource lookup, optionally specifying the containing directory.",
	"Method": "File find(String location,File find,File parentFile,String location,File find,String location,File find,File parentFile,String location){\r\n    Resource resource = get(Paths.convert(getBaseDirectory(), parentFile, location));\r\n    return Resources.find(resource);\r\n}"
}, {
	"Path": "org.geoserver.wms.capabilities.LegendSampleImpl.isStyleNewerThanSample",
	"Comment": "checks if the given sld resource is newer than the given sample file.",
	"Method": "boolean isStyleNewerThanSample(Resource styleResource,Resource sampleFile){\r\n    return styleResource != null && styleResource.getType() == Resource.Type.RESOURCE && styleResource.lastmodified() > sampleFile.lastmodified();\r\n}"
}, {
	"Path": "org.geoserver.util.ReaderUtils.getIntAttribute",
	"Comment": "getintattribute purpose.used to help with xml manipulations. returns the first child integer attribute of thespecified name. an exception occurs when the node is required and not found.",
	"Method": "int getIntAttribute(Element elem,String attName,boolean mandatory,int defaultValue){\r\n    String attValue = getAttribute(elem, attName, mandatory);\r\n    if (!mandatory && (attValue == null)) {\r\n        return defaultValue;\r\n    }\r\n    try {\r\n        return Integer.parseInt(attValue);\r\n    } catch (Exception ex) {\r\n        if (mandatory) {\r\n            throw new Exception(attName + \" attribute of element \" + elem.getNodeName() + \" must be an integer, but it's '\" + attValue + \"'\");\r\n        } else {\r\n            return defaultValue;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.data.workspace.WorkspaceEditPageTest.updateWorkspace",
	"Comment": "helper method that edits an workspace and submits the editions.",
	"Method": "void updateWorkspace(String originalName,String name,String namespace,boolean isolated){\r\n    WorkspaceInfo originalWorkspace = getCatalog().getWorkspaceByName(originalName);\r\n    tester.startPage(new WorkspaceEditPage(originalWorkspace));\r\n    FormTester form = tester.newFormTester(\"form\");\r\n    form.setValue(\"name\", name);\r\n    form.setValue(\"uri\", namespace);\r\n    form.setValue(\"isolated\", isolated);\r\n    form.submit();\r\n}"
}, {
	"Path": "org.geoserver.csw.feature.AbstractFeatureCollection.containsAll",
	"Comment": "returns true if this collection contains all of the elements in the specifiedcollection.",
	"Method": "boolean containsAll(Collection<?> c){\r\n    Iterator<?> e = c.iterator();\r\n    try {\r\n        while (e.hasNext()) if (!contains(e.next()))\r\n            return false;\r\n        return true;\r\n    } finally {\r\n        close(e);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.SecureCatalogImpl.filterNamespaces",
	"Comment": "given a list of namespaces, returns a copy of it containing only the namespaces the user canaccess",
	"Method": "List<T> filterNamespaces(Authentication user,List<T> namespaces){\r\n    List<T> result = new ArrayList<T>();\r\n    for (T original : namespaces) {\r\n        T secured = checkAccess(user, original, MixedModeBehavior.HIDE);\r\n        if (secured != null)\r\n            result.add(secured);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.VectorDimension.getDomain",
	"Comment": "helper method used to get domain values from a vector type in the form of a featurecollection.",
	"Method": "FeatureCollection getDomain(Query query){\r\n    FeatureTypeInfo typeInfo = (FeatureTypeInfo) getResourceInfo();\r\n    FeatureSource source;\r\n    try {\r\n        source = typeInfo.getFeatureSource(null, GeoTools.getDefaultHints());\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(String.format(\"Error getting feature source of vector '%s'.\", resourceInfo.getName()), exception);\r\n    }\r\n    query = new Query(query);\r\n    query.setTypeName(source.getSchema().getName().getLocalPart());\r\n    try {\r\n        return source.getFeatures(query);\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(String.format(\"Error reading feature from layer '%s' for dimension '%s'.\", resourceInfo.getName(), getDimensionName()), exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.DimensionsUtils.extractDimensions",
	"Comment": "helper method that will extract the dimensions from a coverage type info.",
	"Method": "List<Dimension> extractDimensions(WMS wms,LayerInfo layerInfo,Set<String> requestedDimensions,List<Dimension> extractDimensions,WMS wms,LayerInfo layerInfo,FeatureTypeInfo typeInfo,List<Dimension> extractDimensions,WMS wms,LayerInfo layerInfo,CoverageInfo typeInfo){\r\n    List<Dimension> dimensions = new ArrayList();\r\n    for (Map.Entry<String, Serializable> entry : typeInfo.getMetadata().entrySet()) {\r\n        String key = entry.getKey();\r\n        Serializable value = entry.getValue();\r\n        if (key.equals(ResourceInfo.TIME)) {\r\n            DimensionInfo dimensionInfo = Converters.convert(value, DimensionInfo.class);\r\n            checkAndAddDimension(dimensions, new RasterTimeDimension(wms, layerInfo, dimensionInfo));\r\n        } else if (key.equals(ResourceInfo.ELEVATION)) {\r\n            DimensionInfo dimensionInfo = Converters.convert(value, DimensionInfo.class);\r\n            checkAndAddDimension(dimensions, new RasterElevationDimension(wms, layerInfo, dimensionInfo));\r\n        } else if (key.startsWith(ResourceInfo.CUSTOM_DIMENSION_PREFIX)) {\r\n            DimensionInfo dimensionInfo = Converters.convert(value, DimensionInfo.class);\r\n            String dimensionName = key.substring(ResourceInfo.CUSTOM_DIMENSION_PREFIX.length());\r\n            checkAndAddDimension(dimensions, new RasterCustomDimension(wms, layerInfo, dimensionName, dimensionInfo));\r\n        }\r\n    }\r\n    return dimensions;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.config",
	"Comment": "retrieve the coverage store configuration xml as a resource",
	"Method": "Resource config(WorkspaceInfo ws,Resource config,NamespaceInfo ns,Resource config,DataStoreInfo ds,Resource config,CoverageStoreInfo cs,Resource config,WMSStoreInfo wmss,Resource config,WMTSStoreInfo wmss,Resource config,StoreInfo si,Resource config,ResourceInfo si,Resource config,FeatureTypeInfo fti,Resource config,CoverageInfo c,Resource config,WMSLayerInfo wmsl,Resource config,WMTSLayerInfo wmsl,Resource config,LayerInfo li,Resource config,LayerGroupInfo lgi,Resource config,StyleInfo s,Resource config,SettingsInfo s,Resource config,LoggingInfo l,Resource config,GeoServerInfo g){\r\n    Resource r = getRoot(\"global.xml\");\r\n    assert r != null;\r\n    return r;\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.ShapeZipTest.testMultiLineStringZMShp",
	"Comment": "test for multilinestring zm support on getfeature shapefile output",
	"Method": "void testMultiLineStringZMShp(){\r\n    GeometryFactory gf = JTSFactoryFinder.getGeometryFactory();\r\n    SimpleFeatureType featureType = DataUtilities.createType(\"linestringmz\", \"name:String,geom:MultiLineString:4326\");\r\n    SimpleFeatureBuilder fb = new SimpleFeatureBuilder(featureType);\r\n    fb.add(\"line1\");\r\n    fb.add(gf.createMultiLineString(new LineString[] { gf.createLineString(new CoordinateXYZM[] { new CoordinateXYZM(1, 2, 3, 4), new CoordinateXYZM(5, 6, 7, 8) }) }));\r\n    List<SimpleFeature> features = new ArrayList<SimpleFeature>();\r\n    features.add(fb.buildFeature(\"1\"));\r\n    SimpleFeatureCollection featureCollection = DataUtilities.collection(features);\r\n    byte[] zipBytes = writeOut(featureCollection);\r\n    byte[] resultBytes = getShpOnlyBytes(zipBytes);\r\n    InputStream is = getClass().getClassLoader().getResourceAsStream(\"org/geoserver/wfs/response/lineStringZm.shp\");\r\n    byte[] expectedBytes = IOUtils.toByteArray(is);\r\n    is.close();\r\n    assertTrue(Arrays.equals(resultBytes, expectedBytes));\r\n}"
}, {
	"Path": "org.geoserver.geofence.server.rest.RulesRestController.move",
	"Comment": "move the provided rules to the target priority. rules will be sorted by their priority, firstrule will be updated with a priority equal to the target priority and the next ones will getan incremented priority value.",
	"Method": "ResponseEntity<JaxbRuleList> move(int targetPriority,String rulesIds){\r\n    List<Rule> rules = findRules(rulesIds);\r\n    if (rules.isEmpty()) {\r\n        return ResponseEntity.ok(null);\r\n    }\r\n    adminService.shift(targetPriority, rules.size());\r\n    long priority = targetPriority;\r\n    for (Rule rule : rules) {\r\n        rule.setPriority(priority);\r\n        adminService.update(rule);\r\n        priority++;\r\n    }\r\n    return ResponseEntity.ok(new JaxbRuleList(rules));\r\n}"
}, {
	"Path": "org.geoserver.security.jdbc.config.JDBCSecurityServiceConfig.setJndi",
	"Comment": "set flag controlling whether to connect through jndi or through creation of a directconnection.",
	"Method": "void setJndi(boolean jndi){\r\n    this.jndi = jndi;\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.Dimension.getAttributes",
	"Comment": "return dimension start and end attributes, values may be null.",
	"Method": "Tuple<String, String> getAttributes(){\r\n    ResourceInfo resourceInfo = layerInfo.getResource();\r\n    if (resourceInfo instanceof FeatureTypeInfo) {\r\n        return Tuple.tuple(dimensionInfo.getAttribute(), dimensionInfo.getEndAttribute());\r\n    }\r\n    if (resourceInfo instanceof CoverageInfo) {\r\n        return CoverageDimensionsReader.instantiateFrom((CoverageInfo) resourceInfo).getDimensionAttributesNames(getDimensionName());\r\n    }\r\n    return Tuple.tuple(null, null);\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.FilteredList.unwrap",
	"Comment": "allows to unwrap an element before setting it into the delegate list",
	"Method": "T unwrap(T element){\r\n    return element;\r\n}"
}, {
	"Path": "org.geoserver.importer.transform.AbstractCommandLinePreTransform.isInline",
	"Comment": "returns true if the command line manipulates the input file directly",
	"Method": "boolean isInline(){\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.security.jdbc.AbstractJDBCService.checkORCreateJDBCPropertyFile",
	"Comment": "check for the existence of the file, if the file exists do nothing.if the file does not exist, check for a template file contained in the jar with the samename, if found, use it.if no template was found, use the default template",
	"Method": "Resource checkORCreateJDBCPropertyFile(String fileName,Resource namedRoot,String defaultResource){\r\n    Resource resource;\r\n    fileName = fileName != null ? fileName : defaultResource;\r\n    File file = new File(fileName);\r\n    if (file.isAbsolute()) {\r\n        resource = Files.asResource(file);\r\n    } else {\r\n        resource = namedRoot.get(fileName);\r\n    }\r\n    if (Resources.exists(resource)) {\r\n        return resource;\r\n    }\r\n    InputStream is = this.getClass().getResourceAsStream(fileName);\r\n    if (is != null)\r\n        IOUtils.copy(is, resource.out());\r\n    else\r\n        FileUtils.copyURLToFile(getClass().getResource(defaultResource), file);\r\n    return resource;\r\n}"
}, {
	"Path": "org.geoserver.web.HeaderContribution.getJavaScript",
	"Comment": "returns the resource reference to the javascript for the header contribution, or null ifthere is no javascript contribution.",
	"Method": "PackageResourceReference getJavaScript(){\r\n    if (scope != null && javaScriptFilename != null) {\r\n        return new PackageResourceReference(scope, javaScriptFilename);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.security.MasterPasswordProvider.getMasterPassword",
	"Comment": "getter the master password in plain text.this method is package visibility only to prevent extensions from obtaining the masterpassword in plain text.",
	"Method": "char[] getMasterPassword(){\r\n    return doGetMasterPassword();\r\n}"
}, {
	"Path": "org.geoserver.wps.resource.WPSResourceManager.cleanProcess",
	"Comment": "cleans up all the resources associated to a certain id. it is called automatically when therequest ends for synchronous processes, for asynch ones it will be triggered by the processcompletion",
	"Method": "void cleanProcess(String id,boolean cancelled){\r\n    ExecutionResources executionResources = resourceCache.get(id);\r\n    for (WPSResource resource : executionResources.temporary) {\r\n        try {\r\n            resource.delete();\r\n        } catch (Throwable t) {\r\n            LOGGER.log(Level.WARNING, \"Failed to clean up the WPS resource \" + resource.getName(), t);\r\n        }\r\n    }\r\n    if (cancelled) {\r\n        try {\r\n            artifactsStore.clearArtifacts(id);\r\n        } catch (IOException e) {\r\n            throw new WPSException(\"Failed to clear the process artifacts\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.catalog.util.ReaderUtils.getChildAttribute",
	"Comment": "returns a particular attribute value of a specified child of an element.",
	"Method": "String getChildAttribute(Element root,String childName,String attName,String getChildAttribute,Element root,String childName,String attName,boolean mandatory){\r\n    Element elem = getChildElement(root, childName);\r\n    if (elem == null) {\r\n        if (mandatory) {\r\n            throw new Exception(\"No such child: \" + childName);\r\n        }\r\n        return null;\r\n    }\r\n    if (mandatory && !elem.hasAttribute(attName)) {\r\n        throw new Exception(\"No such attribute: \" + attName);\r\n    }\r\n    return elem.getAttribute(attName);\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaTestSupport.assertXpathEvaluatesTo",
	"Comment": "assertion that the flattened value of an xpath expression in document is equal to theexpected value.",
	"Method": "void assertXpathEvaluatesTo(String expected,String xpath,Document document){\r\n    assertEquals(expected, evaluate(xpath, document));\r\n}"
}, {
	"Path": "org.geoserver.gwc.GWC.updateLockProvider",
	"Comment": "updates the configurable lock provider to use the specified bean",
	"Method": "void updateLockProvider(String lockProviderName){\r\n    LockProvider delegate = null;\r\n    if (lockProviderName == null) {\r\n        delegate = new MemoryLockProvider();\r\n    } else {\r\n        Object provider = GeoWebCacheExtensions.bean(lockProviderName);\r\n        if (provider == null) {\r\n            throw new RuntimeException(\"Could not find lock provider \" + lockProvider + \" in the spring application context\");\r\n        } else if (!(provider instanceof LockProvider)) {\r\n            throw new RuntimeException(\"Found bean \" + lockProvider + \" in the spring application context, but it was not a LockProvider\");\r\n        } else {\r\n            delegate = (LockProvider) provider;\r\n        }\r\n    }\r\n    lockProvider.setDelegate(delegate);\r\n}"
}, {
	"Path": "org.geoserver.platform.resource.Paths.toFile",
	"Comment": "convert a resource path to file reference for provided base directory.this method requires the base directory of the resourcestore. note resourcestoreimplementations may not create the file until needed. in the case of an absolute path, baseshould be null.",
	"Method": "File toFile(File base,String path){\r\n    for (String item : Paths.names(path)) {\r\n        base = new File(base, item);\r\n    }\r\n    return base;\r\n}"
}, {
	"Path": "org.geoserver.kml.builder.StreamingKMLBuilder.buildKMLDocument",
	"Comment": "builds a lazily evaluated kml document given a encoding context",
	"Method": "Kml buildKMLDocument(KmlEncodingContext context){\r\n    Kml kml = new Kml();\r\n    Document document = kml.createAndSetDocument();\r\n    String kmltitle = (String) context.getRequest().getFormatOptions().get(\"kmltitle\");\r\n    document.setName(kmltitle);\r\n    List<KmlDecorator> decorators = context.getDecoratorsForClass(Document.class);\r\n    for (KmlDecorator decorator : decorators) {\r\n        document = (Document) decorator.decorate(document, context);\r\n        if (document == null) {\r\n            throw new ServiceException(\"Coding error in decorator \" + decorator + \", document objects cannot be set to null\");\r\n        }\r\n    }\r\n    IteratorFactory<Feature> generatorFactory = new PlainFolderIteratorFactory(context);\r\n    IteratorList<Feature> folders = new IteratorList<Feature>(generatorFactory);\r\n    context.addFeatures(document, folders);\r\n    return kml;\r\n}"
}, {
	"Path": "org.geoserver.catalog.NamespaceWorkspaceConsistencyListener.syncIsolation",
	"Comment": "if post modify event catalog object is a namespace or an workspace this method will make sureboth have the same isolation.the namespaces or the workspace will only be saved if the the isolation is not the same,avoiding infinite loops.",
	"Method": "void syncIsolation(CatalogInfo info){\r\n    if (info instanceof WorkspaceInfo) {\r\n        syncNamespaceIsolation((WorkspaceInfo) info);\r\n    } else if (info instanceof NamespaceInfo) {\r\n        syncWorkspaceIsolation((NamespaceInfo) info);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerDataDirectory.findStoreFile",
	"Comment": "returns the configuration file for the specified store, if the file does not exist null isreturned.",
	"Method": "File findStoreFile(StoreInfo store){\r\n    Resource resource = config(store);\r\n    return Resources.file(resource);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.post",
	"Comment": "executes an ows request using the post method with key value pairs form encoded.",
	"Method": "InputStream post(String path,InputStream post,String path,String xml,InputStream post,String path,String body,String contentType){\r\n    MockHttpServletResponse response = postAsServletResponse(path, body, contentType);\r\n    return new ByteArrayInputStream(response.getContentAsString().getBytes());\r\n}"
}, {
	"Path": "org.geoserver.restupload.ResumableUploadResourceManager.validateUpload",
	"Comment": "executes validations on resume parameters to check if successive start position index matchesactual partial file length",
	"Method": "Boolean validateUpload(String uploadId,Long totalByteToUpload,Long startPosition,Long endPosition,Long totalFileSize){\r\n    Boolean validated = false;\r\n    ResumableUploadResource uploadResource = getResource(uploadId);\r\n    if (uploadResource != null && uploadResource.getFile().exists()) {\r\n        if (uploadResource.getFile().length() == startPosition) {\r\n            validated = true;\r\n        }\r\n    }\r\n    return validated;\r\n}"
}, {
	"Path": "org.geoserver.wps.resource.WPSResourceManager.getStoredRequest",
	"Comment": "gets the stored request file for the specified execution id. it will be available only if theprocess is executing asynchronously",
	"Method": "Resource getStoredRequest(String executionId){\r\n    return artifactsStore.getArtifact(executionId, ArtifactType.Request, null);\r\n}"
}, {
	"Path": "org.geoserver.csw.DirectDownload.getExtraFiles",
	"Comment": "get extra files for the specified reader and add them to the result list. extra files areusually auxiliary files like, as an instance, indexer, properties, config files for a mosaic.",
	"Method": "void getExtraFiles(GridCoverage2DReader reader,List<File> result){\r\n    ServiceInfo info = reader.getInfo();\r\n    if (info instanceof FileServiceInfo) {\r\n        FileServiceInfo fileInfo = (FileServiceInfo) info;\r\n        FileGroupProvider provider = (FileGroupProvider) fileInfo;\r\n        FilesCollector collector = new FilesCollector(provider);\r\n        collector.collectFull(result);\r\n    } else {\r\n        throw new ServiceException(\"Unable to get files from the specified ServiceInfo which\" + \" doesn't implement FileServiceInfo\");\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.ppio.WFSPPIO.getCollectionCRS",
	"Comment": "gets the collection crs, either from metadata or by scanning the collection contents",
	"Method": "CoordinateReferenceSystem getCollectionCRS(SimpleFeatureCollection fc){\r\n    if (fc.getSchema().getCoordinateReferenceSystem() != null) {\r\n        return fc.getSchema().getCoordinateReferenceSystem();\r\n    }\r\n    CoordinateReferenceSystem crs = null;\r\n    SimpleFeatureIterator fi = null;\r\n    try {\r\n        fi = fc.features();\r\n        while (fi.hasNext()) {\r\n            SimpleFeature f = fi.next();\r\n            CoordinateReferenceSystem featureCrs = null;\r\n            GeometryDescriptor gd = f.getType().getGeometryDescriptor();\r\n            if (gd != null && gd.getCoordinateReferenceSystem() != null) {\r\n                featureCrs = gd.getCoordinateReferenceSystem();\r\n            }\r\n            if (f.getDefaultGeometry() != null) {\r\n                Geometry g = (Geometry) f.getDefaultGeometry();\r\n                if (g.getUserData() instanceof CoordinateReferenceSystem) {\r\n                    featureCrs = (CoordinateReferenceSystem) g.getUserData();\r\n                }\r\n            }\r\n            if (featureCrs != null) {\r\n                if (crs == null) {\r\n                    crs = featureCrs;\r\n                } else if (!CRS.equalsIgnoreMetadata(featureCrs, crs)) {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        fi.close();\r\n    }\r\n    return crs;\r\n}"
}, {
	"Path": "org.geoserver.web.data.workspace.WorkspaceEditPageTest.createWorkspace",
	"Comment": "helper method that creates a workspace and add it to the catalog. this method will firstcreate the namespace and then the workspace.",
	"Method": "void createWorkspace(String prefix,String namespaceUri,boolean isolated){\r\n    Catalog catalog = getCatalog();\r\n    NamespaceInfoImpl namespace = new NamespaceInfoImpl();\r\n    namespace.setPrefix(prefix);\r\n    namespace.setURI(namespaceUri);\r\n    namespace.setIsolated(isolated);\r\n    catalog.add(namespace);\r\n    WorkspaceInfoImpl workspace = new WorkspaceInfoImpl();\r\n    workspace.setName(prefix);\r\n    workspace.setIsolated(isolated);\r\n    catalog.add(workspace);\r\n}"
}, {
	"Path": "org.geoserver.wps.sextante.SextanteProcess.setAlgorithmInputs",
	"Comment": "sets the input of the sextante algorithm from the input map of this process",
	"Method": "void setAlgorithmInputs(Map<String, Object> input){\r\n    ParametersSet paramSet = (ParametersSet) m_Algorithm.getParameters();\r\n    boolean gridExtendRequired = false;\r\n    for (String sKey : input.keySet()) {\r\n        if (SEXTANTE_GRID_CELL_SIZE.equals(sKey) || SEXTANTE_GRID_ENVELOPE.equals(sKey)) {\r\n            continue;\r\n        }\r\n        Object paramValue = input.get(sKey);\r\n        Parameter param = paramSet.getParameter(sKey);\r\n        if (paramValue instanceof FeatureCollection) {\r\n            GTVectorLayer layer = new GTVectorLayer();\r\n            layer.create(DataUtilities.source((FeatureCollection) paramValue));\r\n            param.setParameterValue(layer);\r\n        } else if (paramValue instanceof GridCoverage2D) {\r\n            GTRasterLayer layer = new GTRasterLayer();\r\n            gridExtendRequired = true;\r\n            layer.create(paramValue);\r\n            param.setParameterValue(layer);\r\n        } else {\r\n            param.setParameterValue(paramValue);\r\n        }\r\n    }\r\n    OutputObjectsSet outputs = m_Algorithm.getOutputObjects();\r\n    for (int i = 0; i < outputs.getOutputObjectsCount(); i++) {\r\n        Output output = outputs.getOutput(i);\r\n        if (output instanceof OutputRasterLayer) {\r\n            gridExtendRequired = true;\r\n        }\r\n    }\r\n    if (gridExtendRequired) {\r\n        double cellSize = Double.NaN;\r\n        if (input.get(SEXTANTE_GRID_CELL_SIZE) != null) {\r\n            cellSize = (Double) input.get(SEXTANTE_GRID_CELL_SIZE);\r\n        } else {\r\n            for (String sKey : input.keySet()) {\r\n                Object value = paramSet.getParameter(sKey).getParameterValueAsObject();\r\n                if (value instanceof GTRasterLayer) {\r\n                    cellSize = ((GTRasterLayer) value).getLayerCellSize();\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        if (Double.isNaN(cellSize)) {\r\n            throw new GeoAlgorithmExecutionException(SEXTANTE_GRID_CELL_SIZE + \" parameter could not be derived from inputs, and is not available among \");\r\n        }\r\n        Envelope envelope = null;\r\n        if (input.get(SEXTANTE_GRID_ENVELOPE) != null) {\r\n            envelope = (Envelope) input.get(SEXTANTE_GRID_ENVELOPE);\r\n        } else {\r\n            for (String sKey : input.keySet()) {\r\n                Object value = paramSet.getParameter(sKey).getParameterValueAsObject();\r\n                if (value instanceof GTRasterLayer) {\r\n                    AnalysisExtent ge = ((GTRasterLayer) value).getLayerGridExtent();\r\n                    Envelope genv = new Envelope(ge.getXMin(), ge.getXMax(), ge.getYMin(), ge.getYMax());\r\n                    if (envelope == null) {\r\n                        envelope = genv;\r\n                    } else {\r\n                        envelope.expandToInclude(genv);\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        if (envelope == null) {\r\n            if (Double.isNaN(cellSize)) {\r\n                throw new GeoAlgorithmExecutionException(SEXTANTE_GRID_ENVELOPE + \" parameter could not be derived from inputs, and is not available among \");\r\n            }\r\n        }\r\n        AnalysisExtent extent = new AnalysisExtent();\r\n        extent.setXRange(envelope.getMinX(), envelope.getMaxX(), false);\r\n        extent.setYRange(envelope.getMinY(), envelope.getMaxY(), false);\r\n        extent.setCellSize(cellSize);\r\n        m_Algorithm.setAnalysisExtent(extent);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.HistogramUtils.getDateIntervals",
	"Comment": "helper method that computes the time intervals for a certain resolution.",
	"Method": "Tuple<String, List<Date>> getDateIntervals(Tuple<Date, Date> minMax,String resolution){\r\n    ISO8601Formatter dateFormatter = new ISO8601Formatter();\r\n    String domainString = dateFormatter.format(minMax.first);\r\n    domainString += \"/\" + dateFormatter.format(minMax.second) + \"/\" + resolution;\r\n    TimeParser timeParser = new TimeParser();\r\n    try {\r\n        List<Date> intervals = timeParser.parse(domainString);\r\n        Date last = intervals.get(intervals.size() - 1);\r\n        long resolutionInMs = org.geoserver.ows.kvp.TimeParser.parsePeriod(resolution);\r\n        if (last.getTime() < minMax.second.getTime()) {\r\n            intervals.add(new Date(last.getTime() + resolutionInMs));\r\n        }\r\n        return Tuple.tuple(domainString, intervals);\r\n    } catch (ParseException exception) {\r\n        throw new RuntimeException(String.format(\"Error parsing time resolution '%s'.\", resolution), exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.config.SecurityManagerConfig.isEncryptingUrlParams",
	"Comment": "flag controlling if web admin should encrypt url parameters.",
	"Method": "boolean isEncryptingUrlParams(){\r\n    return encryptingUrlParams;\r\n}"
}, {
	"Path": "org.geoserver.security.impl.AbstractAccessRuleDAO.getRules",
	"Comment": "returns the list of rules contained in the property file. the returned rules are sortedagainst the r natural order",
	"Method": "List<R> getRules(){\r\n    checkPropertyFile(false);\r\n    return new ArrayList<R>(rules);\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerAbstractTestSupport.assertStatusCodeForRequest",
	"Comment": "assert that an http request will have a particular status code for the response.",
	"Method": "void assertStatusCodeForRequest(int code,String method,String path,String body,String type){\r\n    MockHttpServletRequest request = createRequest(path);\r\n    request.setMethod(method);\r\n    request.setContent(body.getBytes(\"UTF-8\"));\r\n    request.setContentType(type);\r\n    CodeExpectingHttpServletResponse response = new CodeExpectingHttpServletResponse(new MockHttpServletResponse());\r\n    dispatch(request, response);\r\n    assertEquals(code, response.getErrorCode());\r\n}"
}, {
	"Path": "org.geoserver.test.onlineTest.ComplexSolrTest.checkCount",
	"Comment": "helper method that checks if the provided xpath expression evaluated against the provided xmldocument yields the expected number of matches.",
	"Method": "void checkCount(XpathEngine xpathEngine,Document document,int expectedCount,String xpath){\r\n    try {\r\n        assertEquals(expectedCount, xpathEngine.getMatchingNodes(xpath, document).getLength());\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(\"Error evaluating xpath.\", exception);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.executor.ExecuteRequest.getRequestedOutputs",
	"Comment": "returns null if nothing specific was requested, the list otherwise",
	"Method": "List<OutputDefinitionType> getRequestedOutputs(){\r\n    ResponseFormType responseForm = request.getResponseForm();\r\n    if (responseForm == null) {\r\n        return null;\r\n    }\r\n    if (responseForm.getRawDataOutput() != null) {\r\n        return Collections.singletonList(responseForm.getRawDataOutput());\r\n    } else if (responseForm.getResponseDocument() != null && responseForm.getResponseDocument().getOutput() != null) {\r\n        List<OutputDefinitionType> result = new ArrayList();\r\n        EList outputs = responseForm.getResponseDocument().getOutput();\r\n        for (Object output : outputs) {\r\n            result.add((DocumentOutputDefinitionType) output);\r\n        }\r\n        return result;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.nsg.versioning.TimeVersioningCallback.transformUpdate",
	"Comment": "takes an update and transforms it in an insert if the feature type is versioned, leave it asis otherwise",
	"Method": "TransactionElement transformUpdate(TransactionRequest request,Update update,Date referenceTime){\r\n    FeatureTypeInfo featureTypeInfo = getFeatureTypeInfo(new NameImpl(update.getTypeName()));\r\n    if (!TimeVersioning.isEnabled(featureTypeInfo)) {\r\n        return update;\r\n    }\r\n    SimpleFeatureCollection features = getTransactionFeatures(update);\r\n    List<SimpleFeature> recent = getMostRecentFeatures(features, featureTypeInfo);\r\n    List<SimpleFeature> newFeatures = recent.stream().map(f -> prepareInsertFeature(f, update, referenceTime)).collect(Collectors.toList());\r\n    Insert insert = request.createInsert();\r\n    insert.setHandle(update.getHandle());\r\n    insert.getFeatures().addAll(newFeatures);\r\n    return insert;\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.BindingLdapTemplate.authenticate",
	"Comment": "alternative authenticate implementation, requiring a username instead of a filter.",
	"Method": "boolean authenticate(Name base,String username,String password,AuthenticatedLdapEntryContextCallback callback,AuthenticationErrorCallback errorCallback){\r\n    try {\r\n        DirContext ctx = getContextSource().getContext(username, password);\r\n        ContextExecutor ce = new ContextExecutor() {\r\n            public Object executeWithContext(DirContext ctx) throws javax.naming.NamingException {\r\n                callback.executeWithContext(ctx, null);\r\n                return null;\r\n            }\r\n        };\r\n        try {\r\n            ce.executeWithContext(ctx);\r\n        } catch (javax.naming.NamingException e) {\r\n            throw LdapUtils.convertLdapException(e);\r\n        } catch (Exception e) {\r\n            throw e;\r\n        } finally {\r\n            if (ctx != null) {\r\n                try {\r\n                    ctx.close();\r\n                } catch (Exception e) {\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    } catch (Exception e) {\r\n        errorCallback.execute(e);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.BindingLdapTemplate.authenticate",
	"Comment": "alternative authenticate implementation, requiring a username instead of a filter.",
	"Method": "boolean authenticate(Name base,String username,String password,AuthenticatedLdapEntryContextCallback callback,AuthenticationErrorCallback errorCallback){\r\n    callback.executeWithContext(ctx, null);\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.listFilters",
	"Comment": "lists all available pre authentication filter configurations whose implentation class is aninstance of the specified class.",
	"Method": "SortedSet<String> listFilters(SortedSet<String> listFilters,Class<?> type){\r\n    SortedSet<String> configs = new TreeSet<String>();\r\n    for (String name : listFilters()) {\r\n        SecurityFilterConfig config = loadFilterConfig(name);\r\n        if (config.getClassName() == null) {\r\n            continue;\r\n        }\r\n        try {\r\n            if (type.isAssignableFrom(Class.forName(config.getClassName()))) {\r\n                configs.add(config.getName());\r\n            }\r\n        } catch (ClassNotFoundException e) {\r\n            LOGGER.log(Level.WARNING, e.getMessage(), e);\r\n        }\r\n    }\r\n    return configs;\r\n}"
}, {
	"Path": "org.geoserver.console.Browser.locateBrowser",
	"Comment": "attempts to locate the default web browser on the local system.caches results so it only locates the browser once for each use of this class per jvm instance.",
	"Method": "Object locateBrowser(){\r\n    if (browser != null) {\r\n        return browser;\r\n    }\r\n    switch(jvm) {\r\n        case MRJ_2_0:\r\n            try {\r\n                Integer finderCreatorCode = (Integer) makeOSType.invoke(null, new Object[] { FINDER_CREATOR });\r\n                Object aeTarget = aeTargetConstructor.newInstance(new Object[] { finderCreatorCode });\r\n                Integer gurlType = (Integer) makeOSType.invoke(null, new Object[] { GURL_EVENT });\r\n                Object appleEvent = appleEventConstructor.newInstance(new Object[] { gurlType, gurlType, aeTarget, kAutoGenerateReturnID, kAnyTransactionID });\r\n                return appleEvent;\r\n            } catch (IllegalAccessException iae) {\r\n                browser = null;\r\n                errorMessage = iae.getMessage();\r\n                return browser;\r\n            } catch (InstantiationException ie) {\r\n                browser = null;\r\n                errorMessage = ie.getMessage();\r\n                return browser;\r\n            } catch (InvocationTargetException ite) {\r\n                browser = null;\r\n                errorMessage = ite.getMessage();\r\n                return browser;\r\n            }\r\n        case MRJ_2_1:\r\n            File systemFolder;\r\n            try {\r\n                systemFolder = (File) findFolder.invoke(null, new Object[] { kSystemFolderType });\r\n            } catch (IllegalArgumentException iare) {\r\n                browser = null;\r\n                errorMessage = iare.getMessage();\r\n                return browser;\r\n            } catch (IllegalAccessException iae) {\r\n                browser = null;\r\n                errorMessage = iae.getMessage();\r\n                return browser;\r\n            } catch (InvocationTargetException ite) {\r\n                browser = null;\r\n                errorMessage = ite.getTargetException().getClass() + \": \" + ite.getTargetException().getMessage();\r\n                return browser;\r\n            }\r\n            String[] systemFolderFiles = systemFolder.list();\r\n            for (int i = 0; i < systemFolderFiles.length; i++) {\r\n                try {\r\n                    File file = new File(systemFolder, systemFolderFiles[i]);\r\n                    if (!file.isFile()) {\r\n                        continue;\r\n                    }\r\n                    Object fileType = getFileType.invoke(null, new Object[] { file });\r\n                    if (FINDER_TYPE.equals(fileType.toString())) {\r\n                        Object fileCreator = getFileCreator.invoke(null, new Object[] { file });\r\n                        if (FINDER_CREATOR.equals(fileCreator.toString())) {\r\n                            browser = file.toString();\r\n                            return browser;\r\n                        }\r\n                    }\r\n                } catch (IllegalArgumentException iare) {\r\n                    browser = browser;\r\n                    errorMessage = iare.getMessage();\r\n                    return null;\r\n                } catch (IllegalAccessException iae) {\r\n                    browser = null;\r\n                    errorMessage = iae.getMessage();\r\n                    return browser;\r\n                } catch (InvocationTargetException ite) {\r\n                    browser = null;\r\n                    errorMessage = ite.getTargetException().getClass() + \": \" + ite.getTargetException().getMessage();\r\n                    return browser;\r\n                }\r\n            }\r\n            browser = null;\r\n            break;\r\n        case MRJ_3_0:\r\n        case MRJ_3_1:\r\n            browser = \"\";\r\n            break;\r\n        case WINDOWS_NT:\r\n            browser = \"cmd.exe\";\r\n            break;\r\n        case WINDOWS_9x:\r\n            browser = \"command.com\";\r\n            break;\r\n        case OTHER:\r\n        default:\r\n            browser = \"netscape\";\r\n            break;\r\n    }\r\n    return browser;\r\n}"
}, {
	"Path": "org.geoserver.wps.DataTransformer.isTransmutable",
	"Comment": "tests if all inputs and outputs of a process are transmutable",
	"Method": "boolean isTransmutable(ProcessFactory pf,Name name){\r\n    for (Parameter<?> param : pf.getParameterInfo(name).values()) {\r\n        try {\r\n            this.getDefaultTransmuter(param.type);\r\n        } catch (Exception e) {\r\n            return false;\r\n        }\r\n    }\r\n    for (Parameter<?> param : pf.getResultInfo(name, null).values()) {\r\n        try {\r\n            this.getDefaultTransmuter(param.type);\r\n        } catch (Exception e) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.geoserver.wfs.TransactionEvent.getAffectedFeatures",
	"Comment": "a collection of the features that are being manipulated. accessible and usable only when theevent is being thrown, if you store the event and try to access the collection later there isno guarantee it will still be usable.",
	"Method": "SimpleFeatureCollection getAffectedFeatures(){\r\n    return affectedFeatures;\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.ConfigurationDiffVisitor.checkEqualsByNameAndWorkspace",
	"Comment": "returns true if the services have the same name and the same workspace.",
	"Method": "boolean checkEqualsByNameAndWorkspace(ServiceInfo infoA,ServiceInfo infoB){\r\n    return Objects.equals(infoA.getName(), infoB.getName()) && Objects.equals(infoA.getWorkspace(), infoB.getWorkspace());\r\n}"
}, {
	"Path": "org.geoserver.wps.sextante.SextanteProcess.createReturnMapFromOutputObjects",
	"Comment": "creates a suitable return map for this process from the outputs generated by the sextantealgorithm",
	"Method": "Map<String, Object> createReturnMapFromOutputObjects(){\r\n    try {\r\n        Map<String, Object> results = new HashMap<String, Object>();\r\n        OutputObjectsSet outputs = m_Algorithm.getOutputObjects();\r\n        for (int i = 0; i < outputs.getOutputObjectsCount(); i++) {\r\n            Output output = outputs.getOutput(i);\r\n            Object outputObject = output.getOutputObject();\r\n            if (outputObject instanceof IDataObject) {\r\n                IDataObject dataObject = (IDataObject) outputObject;\r\n                Object wrapped = dataObject.getBaseDataObject();\r\n                if (wrapped instanceof FeatureSource) {\r\n                    results.put(output.getName(), ((FeatureSource) wrapped).getFeatures());\r\n                } else if (wrapped instanceof GridCoverage2D) {\r\n                    results.put(output.getName(), wrapped);\r\n                } else {\r\n                    results.put(output.getName(), wrapped);\r\n                }\r\n            } else {\r\n                results.put(output.getName(), outputObject);\r\n            }\r\n        }\r\n        return results;\r\n    } catch (Throwable t) {\r\n        throw new RuntimeException(t);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.onelogin.SAMLUserDetailsServiceImpl.getRolesFromHttpAttribute",
	"Comment": "calculates roles using the string found in the http header attribute if no role string isfound, anempty collection is returnedthe result contains personalized roles",
	"Method": "Collection<GeoServerRole> getRolesFromHttpAttribute(String principal){\r\n    Collection<GeoServerRole> roles = new ArrayList<GeoServerRole>();\r\n    if (request != null) {\r\n        String rolesString = request.getHeader(rolesHeaderAttribute);\r\n        if (rolesString == null || rolesString.trim().length() == 0) {\r\n            LOGGER.log(Level.WARNING, \"No roles in header attribute: \" + rolesHeaderAttribute);\r\n            return roles;\r\n        }\r\n        roles.addAll(converter.convertRolesFromString(rolesString, principal));\r\n        LOGGER.log(Level.FINE, \"for principal \" + principal + \" found roles \" + StringUtils.collectionToCommaDelimitedString(roles) + \" in header \" + rolesHeaderAttribute);\r\n    }\r\n    return roles;\r\n}"
}, {
	"Path": "org.geoserver.ows.util.RewindableInputStream.setChunkedMode",
	"Comment": "allows to change the behavior of the stream regarding chunked reading at runtime. if youallowed chunked reading and then read some data from the stream, you better forget aboutresetting or rewinding it after that.",
	"Method": "void setChunkedMode(boolean chunkedMode){\r\n    fMayReadChunks = chunkedMode;\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.OSEOTestSupport.getAsDOM",
	"Comment": "returns the dom after checking the status code is 200 and the returned mime type is theexpected one",
	"Method": "Document getAsDOM(String path,int expectedStatusCode,String expectedMimeType){\r\n    MockHttpServletResponse response = getAsServletResponse(path);\r\n    assertEquals(expectedMimeType, response.getContentType());\r\n    assertEquals(expectedStatusCode, response.getStatus());\r\n    Document dom = dom(new ByteArrayInputStream(response.getContentAsByteArray()));\r\n    return dom;\r\n}"
}, {
	"Path": "org.geoserver.web.GeoServerBasePage.getFeedbackPanel",
	"Comment": "returns the top feedback panel included in the geoserver base page",
	"Method": "FeedbackPanel getFeedbackPanel(){\r\n    return topFeedbackPanel;\r\n}"
}, {
	"Path": "org.geoserver.wfs.GetFeatureHitsIgnoreMaxFeaturesTest.testHitsIgnoreMaxFeaturesDisabled",
	"Comment": "check that max features is respected when the hitsignoremaxfeatures flag is active",
	"Method": "void testHitsIgnoreMaxFeaturesDisabled(){\r\n    WFSInfo wfs = getWFS();\r\n    wfs.setMaxFeatures(1);\r\n    wfs.setHitsIgnoreMaxFeatures(false);\r\n    getGeoServer().save(wfs);\r\n    Document doc = getAsDOM(\"wfs?request=GetFeature&typename=cdf:Fifteen\" + \"&version=1.1.0&service=wfs&resultType=hits\");\r\n    XpathEngine xpath = XMLUnit.newXpathEngine();\r\n    assertEquals(\"1\", xpath.getMatchingNodes(\"//wfs:FeatureCollection/@numberOfFeatures\", doc).item(0).getNodeValue());\r\n}"
}, {
	"Path": "org.geoserver.csw.feature.sort.CatalogComparatorFactory.buildComparator",
	"Comment": "builds a single comparator based on the sortby specification",
	"Method": "Comparator<Info> buildComparator(SortBy sortBy,Comparator<Info> buildComparator,SortBy sortBy){\r\n    if (sortBy == null) {\r\n        throw new NullPointerException(\"The sortBy argument must be not null\");\r\n    }\r\n    if (sortBy == SortBy.NATURAL_ORDER) {\r\n        return new InfoComparator(true);\r\n    } else if (sortBy == SortBy.REVERSE_ORDER) {\r\n        return new InfoComparator(false);\r\n    } else {\r\n        return new PropertyComparator<Info>(sortBy.getPropertyName(), sortBy.getSortOrder() == SortOrder.ASCENDING);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.rest.catalog.CoverageController.handleObjectPost",
	"Comment": "helper method that handles the post of a coverage. this handles both the cases when the storeis provided and when the store is not provided.",
	"Method": "String handleObjectPost(CoverageInfo coverage,String workspace,String coverageStoreName){\r\n    if (coverage.getStore() == null) {\r\n        CoverageStoreInfo ds = catalog.getCoverageStoreByName(workspace, coverageStoreName);\r\n        coverage.setStore(ds);\r\n    }\r\n    final boolean isNew = isNewCoverage(coverage);\r\n    String nativeCoverageName = coverage.getNativeCoverageName();\r\n    if (nativeCoverageName == null) {\r\n        nativeCoverageName = coverage.getNativeName();\r\n    }\r\n    CatalogBuilder builder = new CatalogBuilder(catalog);\r\n    CoverageStoreInfo store = coverage.getStore();\r\n    builder.setStore(store);\r\n    if (!isNew) {\r\n        builder.initCoverage(coverage, nativeCoverageName);\r\n    } else {\r\n        String specifiedName = coverage.getName();\r\n        coverage = builder.buildCoverageByName(nativeCoverageName, specifiedName);\r\n    }\r\n    NamespaceInfo ns = coverage.getNamespace();\r\n    if (ns != null && !ns.getPrefix().equals(workspace)) {\r\n        LOGGER.warning(\"Namespace: \" + ns.getPrefix() + \" does not match workspace: \" + workspace + \", overriding.\");\r\n        ns = null;\r\n    }\r\n    if (ns == null) {\r\n        ns = catalog.getNamespaceByPrefix(workspace);\r\n        coverage.setNamespace(ns);\r\n    }\r\n    coverage.setEnabled(true);\r\n    catalog.validate(coverage, true).throwIfInvalid();\r\n    catalog.add(coverage);\r\n    catalog.add(builder.buildLayer(coverage));\r\n    LOGGER.info(\"POST coverage \" + coverageStoreName + \",\" + coverage.getName());\r\n    return coverage.getName();\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.LDAPBaseSecurityService.authenticateIfNeeded",
	"Comment": "execute authentication, if configured to do so, and then call the given callback onauthenticated context, or simply call the given callback if no authentication is needed.",
	"Method": "void authenticateIfNeeded(AuthenticatedLdapEntryContextCallback callback){\r\n    if (user != null && password != null) {\r\n        template.authenticate(DistinguishedName.EMPTY_PATH, user, password, callback);\r\n    } else {\r\n        callback.executeWithContext(null, null);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDefaultValuesHelper.createCustomDimensionFilter",
	"Comment": "create a filter matching the specified additional dimension value",
	"Method": "Filter createCustomDimensionFilter(String dimension,Map<String, List<Object>> dimensionSubset,List<DimensionDescriptor> customDimensions){\r\n    List<Object> dimensionSelection = dimensionSubset.get(dimension);\r\n    Object dimensionValue = dimensionSelection.get(0);\r\n    for (DimensionDescriptor dimensionDescriptor : customDimensions) {\r\n        if (dimensionDescriptor.getName().equalsIgnoreCase(dimension)) {\r\n            String attribute = dimensionDescriptor.getStartAttribute();\r\n            return FF.equals(FF.property(attribute), FF.literal(dimensionValue));\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.monitor.MonitorConfig.getProperty",
	"Comment": "allows to retrieve a generic property from the configuration. extensions and plugins aresupposed to use the plugin.property naming convention, passing both a prefix and a name",
	"Method": "T getProperty(String prefix,String name,Class<T> target){\r\n    String key = prefix == null ? name : prefix + \".\" + name;\r\n    Object value = props().get(key);\r\n    if (value != null) {\r\n        T converted = Converters.convert(value, target, new Hints(ConverterFactory.SAFE_CONVERSION, true));\r\n        if (converted == null) {\r\n            throw new IllegalArgumentException(\"Object \" + value + \" could not be converted to the target class \" + target);\r\n        }\r\n        return converted;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.security.jdbc.AbstractJDBCService.getJDBCStatement",
	"Comment": "get a prepared jdbc statement by looking into the props for the given key",
	"Method": "PreparedStatement getJDBCStatement(String key,Properties props,Connection con){\r\n    String statementString = props.getProperty(key);\r\n    if (statementString == null || statementString.trim().length() == 0)\r\n        throw new IOException(\"No sql statement for key : \" + key);\r\n    return con.prepareStatement(statementString.trim());\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.DataAccessNewPage.onSaveDataStore",
	"Comment": "callback method called when the submit button have been pressed and the parameters validationhas succeed.",
	"Method": "void onSaveDataStore(DataStoreInfo info,AjaxRequestTarget target){\r\n    if (!storeEditPanel.onSave()) {\r\n        return;\r\n    }\r\n    final Catalog catalog = getCatalog();\r\n    DataStoreInfo expandedStore = catalog.getResourcePool().clone(info, true);\r\n    DataAccess<? extends FeatureType, ? extends Feature> dataStore;\r\n    try {\r\n        dataStore = expandedStore.getDataStore(new NullProgressListener());\r\n        dataStore.dispose();\r\n    } catch (IOException e) {\r\n        LOGGER.log(Level.WARNING, \"Error obtaining new data store\", e);\r\n        String message = e.getMessage();\r\n        if (message == null && e.getCause() != null) {\r\n            message = e.getCause().getMessage();\r\n        }\r\n        throw new IllegalArgumentException(\"Error creating data store, check the parameters. Error message: \" + message);\r\n    }\r\n    DataStoreInfo savedStore = catalog.getResourcePool().clone(info, true);\r\n    try {\r\n        catalog.validate(savedStore, true).throwIfInvalid();\r\n        savedStore = catalog.getResourcePool().clone(info, false);\r\n        catalog.add(savedStore);\r\n    } catch (Exception e) {\r\n        LOGGER.log(Level.WARNING, \"Error adding data store to catalog\", e);\r\n        String message = e.getMessage();\r\n        if (message == null && e.getCause() != null) {\r\n            message = e.getCause().getMessage();\r\n        }\r\n        throw new IllegalArgumentException(\"Error creating data store with the provided parameters: \" + message);\r\n    }\r\n    final NewLayerPage newLayerPage;\r\n    try {\r\n        newLayerPage = new NewLayerPage(savedStore.getId());\r\n    } catch (RuntimeException e) {\r\n        try {\r\n            catalog.remove(expandedStore);\r\n            catalog.remove(savedStore);\r\n        } catch (Exception removeEx) {\r\n            LOGGER.log(Level.WARNING, \"Error removing just added datastore!\", e);\r\n        }\r\n        throw new IllegalArgumentException(e.getMessage(), e);\r\n    }\r\n    setResponsePage(newLayerPage);\r\n}"
}, {
	"Path": "org.geoserver.wps.resource.WPSResourceManager.getTemporaryResource",
	"Comment": "returns a resource that will be used to store some temporary file for processing sake, andwill mark it for deletion when the process ends",
	"Method": "Resource getTemporaryResource(String extension){\r\n    String executionId = getExecutionId((Boolean) null);\r\n    Resource resource = artifactsStore.getArtifact(executionId, ArtifactType.Temporary, UUID.randomUUID().toString() + extension);\r\n    addResource(new WPSResourceResource(resource));\r\n    return resource;\r\n}"
}, {
	"Path": "org.geoserver.config.GeoServerReinitializer.reinitialize",
	"Comment": "performs initialization of geoserver configuration, as well as any actions that should beperformed only when reloading the configuration.",
	"Method": "void reinitialize(GeoServer geoServer){\r\n    initialize(geoServer);\r\n}"
}, {
	"Path": "org.geoserver.script.ScriptHook.invokeOptional",
	"Comment": "helper method to invoke an optional function through the script engine.if the function does not exist null is returned.",
	"Method": "Object invokeOptional(ScriptEngine engine,String name,Object args){\r\n    return doInvoke(engine, false, name, args);\r\n}"
}, {
	"Path": "org.geoserver.catalog.ResourcePool.getParams",
	"Comment": "process connection parameters into a synchronized map.this is used to smooth any relative path kind of issues for any file urls or directory.this code should be expanded to deal with any other context sensitive issues data stores tendto have.key ends in url, and value is a stringvalue is a urlkey is directory, and value is a string",
	"Method": "Map<K, V> getParams(Map<K, V> m,GeoServerResourceLoader loader){\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<K, V> params = Collections.synchronizedMap(new HashMap<K, V>(m));\r\n    final GeoServerEnvironment gsEnvironment = GeoServerExtensions.bean(GeoServerEnvironment.class);\r\n    for (Entry<K, V> entry : params.entrySet()) {\r\n        String key = (String) entry.getKey();\r\n        Object value = entry.getValue();\r\n        if (gsEnvironment != null && GeoServerEnvironment.ALLOW_ENV_PARAMETRIZATION) {\r\n            value = gsEnvironment.resolveValue(value);\r\n        }\r\n        if ((key != null) && key.matches(\".* *url\") && value instanceof String) {\r\n            String path = (String) value;\r\n            if (path.startsWith(\"file:\")) {\r\n                File fixedPath = loader.url(path);\r\n                URL url = URLs.fileToUrl(fixedPath);\r\n                entry.setValue((V) url.toExternalForm());\r\n            }\r\n        } else if (value instanceof URL && ((URL) value).getProtocol().equals(\"file\")) {\r\n            URL url = (URL) value;\r\n            File fixedPath = loader.url(url.toString());\r\n            entry.setValue((V) URLs.fileToUrl(fixedPath));\r\n        } else if ((key != null) && (key.equals(\"directory\") || key.equals(\"database\")) && value instanceof String) {\r\n            String path = (String) value;\r\n            if (path.startsWith(\"file:\")) {\r\n                File fixedPath = loader.url(path);\r\n                entry.setValue((V) fixedPath.toString());\r\n            }\r\n        }\r\n    }\r\n    return params;\r\n}"
}, {
	"Path": "org.geoserver.data.test.MockCreator.createResourceLoader",
	"Comment": "creates geoserverresouceloader around provided test data.created bean is registered with geoserverextensions as the singleton resourceloader.",
	"Method": "GeoServerResourceLoader createResourceLoader(MockTestData testData){\r\n    File data = testData.getDataDirectoryRoot();\r\n    GeoServerResourceLoader loader = new GeoServerResourceLoader(data);\r\n    GeoServerExtensionsHelper.singleton(\"resourceLoader\", loader);\r\n    return loader;\r\n}"
}, {
	"Path": "org.geoserver.rest.util.IOUtils.copyChannel",
	"Comment": "copies the content of the source channel onto the destination channel.",
	"Method": "void copyChannel(int bufferSize,ReadableByteChannel source,WritableByteChannel destination){\r\n    inputNotNull(source, destination);\r\n    if (!source.isOpen() || !destination.isOpen())\r\n        throw new IllegalStateException(\"Source and destination channels must be open.\");\r\n    final java.nio.ByteBuffer buffer = java.nio.ByteBuffer.allocateDirect(bufferSize);\r\n    while (source.read(buffer) != -1) {\r\n        buffer.flip();\r\n        while (buffer.hasRemaining()) destination.write(buffer);\r\n        buffer.clear();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.WCSNetCDFTest.testOutputMemoryNotExceeded",
	"Comment": "this test checks if an exception is not thrown when is requested an image with a total sizelower than the maximum geoserver output size.",
	"Method": "void testOutputMemoryNotExceeded(){\r\n    setOutputLimit(40);\r\n    MockHttpServletResponse response = getAsServletResponse(\"ows?request=GetCoverage&service=WCS&version=2.0.1\" + \"&coverageId=wcs__NO2&format=application/x-netcdf&subset=http://www.opengis.net/def/axis/OGC/0/elevation(450)\");\r\n    assertEquals(200, response.getStatus());\r\n    assertEquals(\"application/x-netcdf\", response.getContentType());\r\n    setOutputLimit(-1);\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.GetCoverage.extractExtensions",
	"Comment": "this method id responsible for extracting the extensions from the incoming request tofacilitate the work of successive methods.",
	"Method": "Map<String, ExtensionItemType> extractExtensions(GetCoverageType request){\r\n    Utilities.ensureNonNull(\"request\", request);\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.fine(\"Extracting extensions from provided request\");\r\n    }\r\n    final ExtensionType extension = request.getExtension();\r\n    final Map<String, ExtensionItemType> parsedExtensions = new HashMap<String, ExtensionItemType>();\r\n    if (extension != null) {\r\n        final EList<ExtensionItemType> extensions = extension.getContents();\r\n        for (final ExtensionItemType extensionItem : extensions) {\r\n            final String extensionName = extensionItem.getName();\r\n            if (extensionName == null || extensionName.length() <= 0) {\r\n                throw new WCS20Exception(\"Null extension\");\r\n            }\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.fine(\"Parsing extension \" + extensionName);\r\n            }\r\n            if (extensionName.equals(\"subsettingCrs\")) {\r\n                parsedExtensions.put(\"subsettingCrs\", extensionItem);\r\n                if (LOGGER.isLoggable(Level.FINE)) {\r\n                    LOGGER.fine(\"Added extension subsettingCrs\");\r\n                }\r\n            } else if (extensionName.equals(\"outputCrs\")) {\r\n                parsedExtensions.put(\"outputCrs\", extensionItem);\r\n                if (LOGGER.isLoggable(Level.FINE)) {\r\n                    LOGGER.fine(\"Added extension outputCrs\");\r\n                }\r\n            } else if (extensionName.equals(\"Scaling\")) {\r\n                parsedExtensions.put(\"Scaling\", extensionItem);\r\n                if (LOGGER.isLoggable(Level.FINE)) {\r\n                    LOGGER.fine(\"Added extension Scaling\");\r\n                }\r\n            } else if (extensionName.equals(\"Interpolation\")) {\r\n                parsedExtensions.put(\"Interpolation\", extensionItem);\r\n                if (LOGGER.isLoggable(Level.FINE)) {\r\n                    LOGGER.fine(\"Added extension Interpolation\");\r\n                }\r\n            } else if (extensionName.equals(\"rangeSubset\") || extensionName.equals(\"RangeSubset\")) {\r\n                parsedExtensions.put(\"rangeSubset\", extensionItem);\r\n                if (LOGGER.isLoggable(Level.FINE)) {\r\n                    LOGGER.fine(\"Added extension rangeSubset\");\r\n                }\r\n            } else if (extensionName.equals(WCS20Const.OVERVIEW_POLICY_EXTENSION)) {\r\n                parsedExtensions.put(WCS20Const.OVERVIEW_POLICY_EXTENSION, extensionItem);\r\n                if (LOGGER.isLoggable(Level.FINE)) {\r\n                    LOGGER.fine(\"Added extension overviewPolicy \");\r\n                }\r\n            }\r\n        }\r\n    } else if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.fine(\"No extensions found in provided request\");\r\n    }\r\n    return parsedExtensions;\r\n}"
}, {
	"Path": "org.geoserver.web.data.store.CoverageStoreNewPageTest.testPageRendersOnLoad",
	"Comment": "a kind of smoke test that only asserts the page is rendered when first loaded",
	"Method": "void testPageRendersOnLoad(){\r\n    startPage();\r\n    tester.assertLabel(\"rasterStoreForm:storeType\", formatType);\r\n    tester.assertLabel(\"rasterStoreForm:storeTypeDescription\", formatDescription);\r\n    tester.assertComponent(\"rasterStoreForm:workspacePanel\", WorkspacePanel.class);\r\n}"
}, {
	"Path": "org.geoserver.wfs.xml.v1_0_0.XmlSchemaEncoder.generateTypes",
	"Comment": "internal method to generate the xml response object, using feature types.",
	"Method": "String generateTypes(FeatureTypeInfo[] infos,DescribeFeatureTypeType request){\r\n    StringBuffer tempResponse = new StringBuffer();\r\n    tempResponse.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"\" + getInfo().getGeoServer().getSettings().getCharset() + \"\\\"?>\" + \"\\n<xs:schema \");\r\n    if (allSameType(infos)) {\r\n        FeatureTypeInfo ftInfo = infos[0];\r\n        String targetNs = ftInfo.getNamespace().getURI();\r\n        tempResponse.append(TARGETNS_PREFIX + targetNs + TARGETNS_SUFFIX);\r\n        tempResponse.append(\"\\n  \" + \"xmlns:\" + ftInfo.getNamespace().getPrefix() + \"=\\\"\" + targetNs + \"\\\"\");\r\n        tempResponse.append(GML_NAMESPACE);\r\n        tempResponse.append(XS_NAMESPACE);\r\n        tempResponse.append(ELEMENT_FORM_DEFAULT + ATTR_FORM_DEFAULT);\r\n        tempResponse.append(\"\\n\\n<xs:import namespace=\" + GML_URL + \" schemaLocation=\\\"\" + buildSchemaURL(request.getBaseUrl(), \"gml/2.1.2.1/feature.xsd\") + \"\\\"/>\\n\\n\");\r\n        tempResponse.append(generateSpecifiedTypes(infos));\r\n    } else {\r\n        tempResponse.append(XS_NAMESPACE);\r\n        tempResponse.append(ELEMENT_FORM_DEFAULT + ATTR_FORM_DEFAULT);\r\n        Set prefixes = new HashSet();\r\n        for (int i = 0; i < infos.length; i++) {\r\n            FeatureTypeInfo ftInfo = infos[i];\r\n            prefixes.add(ftInfo.getNamespace().getPrefix());\r\n        }\r\n        Iterator prefixIter = prefixes.iterator();\r\n        while (prefixIter.hasNext()) {\r\n            String prefix = prefixIter.next().toString();\r\n            tempResponse.append(getNSImport(prefix, infos, request.getBaseUrl(), request.getService().toLowerCase()));\r\n        }\r\n    }\r\n    tempResponse.append(FOOTER);\r\n    return tempResponse.toString();\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDimensionsSubsetHelper.prepareDimensionsQuery",
	"Comment": "prepare a query by inspecting the specified dimensions and setting the proper attributevalues",
	"Method": "Query prepareDimensionsQuery(StructuredGridCoverage2DReader reader,String coverageName,GridCoverageRequest gcr,GranuleSource source){\r\n    Filter filter = filterSpatial(gcr, reader, source);\r\n    ;\r\n    filter = filterTime(filter, gcr, coverageName, reader);\r\n    filter = filterElevation(filter, gcr, coverageName, reader);\r\n    filter = filterDimensions(filter, gcr, coverageName, reader);\r\n    Query query = new Query(null, filter);\r\n    return query;\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.ConfigurationDiffVisitor.getAllSettings",
	"Comment": "get all settings info objects of a geoserver instance, this will not include global settingsonly per workspace settings will be included.",
	"Method": "List<SettingsInfo> getAllSettings(GeoServer geoServer){\r\n    List<SettingsInfo> allSettings = new ArrayList();\r\n    List<WorkspaceInfo> workspaces = geoServer.getCatalog().getWorkspaces();\r\n    for (WorkspaceInfo workspace : workspaces) {\r\n        SettingsInfo settings = geoServer.getSettings(workspace);\r\n        if (settings != null) {\r\n            allSettings.add(settings);\r\n        }\r\n    }\r\n    return allSettings;\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.ModificationProxyTest.modProxy",
	"Comment": "matches a modification proxy wrapping an object matching the given matcher",
	"Method": "Matcher<T> modProxy(Matcher<T> objectMatcher){\r\n    return new BaseMatcher<T>() {\r\n        @Override\r\n        public boolean matches(Object item) {\r\n            ModificationProxy handler = ModificationProxy.handler(item);\r\n            if (handler == null) {\r\n                return false;\r\n            }\r\n            return objectMatcher.matches(handler.getProxyObject());\r\n        }\r\n        @Override\r\n        public void describeTo(Description description) {\r\n            description.appendText(\"ModificationProxy wrapping \").appendDescriptionOf(objectMatcher);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.ModificationProxyTest.modProxy",
	"Comment": "matches a modification proxy wrapping an object matching the given matcher",
	"Method": "Matcher<T> modProxy(Matcher<T> objectMatcher){\r\n    ModificationProxy handler = ModificationProxy.handler(item);\r\n    if (handler == null) {\r\n        return false;\r\n    }\r\n    return objectMatcher.matches(handler.getProxyObject());\r\n}"
}, {
	"Path": "org.geoserver.catalog.impl.ModificationProxyTest.modProxy",
	"Comment": "matches a modification proxy wrapping an object matching the given matcher",
	"Method": "Matcher<T> modProxy(Matcher<T> objectMatcher){\r\n    description.appendText(\"ModificationProxy wrapping \").appendDescriptionOf(objectMatcher);\r\n}"
}, {
	"Path": "org.geoserver.gwc.web.CachingOptionsPanel.mergeExisting",
	"Comment": "merges the elements of existingformats missing from formats into formats",
	"Method": "void mergeExisting(List<String> formats,Collection<String> existingFormats){\r\n    for (String x : existingFormats) {\r\n        if (!formats.contains(x))\r\n            formats.add(x);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.web.wicket.browser.GeoServerFileChooser.directoryClicked",
	"Comment": "action undertaken as a directory is clicked. default behavior is to drill down into thedirectory.",
	"Method": "void directoryClicked(File file,AjaxRequestTarget target){\r\n    GeoServerFileChooser.this.file.setObject(file);\r\n    fileTable.getProvider().setDirectory(new Model<File>(file));\r\n    breadcrumbs.setSelection(file);\r\n    target.add(fileTable);\r\n    target.add(breadcrumbs);\r\n}"
}, {
	"Path": "org.geoserver.security.password.JasyptPBEPasswordEncoderWrapper.createCharEncoder",
	"Comment": "creates the encoder instance used when source is a char array.",
	"Method": "CharArrayPasswordEncoder createCharEncoder(){\r\n    return new CharArrayPasswordEncoder() {\r\n        @Override\r\n        public boolean isPasswordValid(String encPass, char[] rawPass, Object salt) {\r\n            return false;\r\n        }\r\n        @Override\r\n        public String encodePassword(char[] rawPass, Object salt) {\r\n            return \"\";\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.geoserver.security.password.JasyptPBEPasswordEncoderWrapper.createCharEncoder",
	"Comment": "creates the encoder instance used when source is a char array.",
	"Method": "CharArrayPasswordEncoder createCharEncoder(){\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.security.password.JasyptPBEPasswordEncoderWrapper.createCharEncoder",
	"Comment": "creates the encoder instance used when source is a char array.",
	"Method": "CharArrayPasswordEncoder createCharEncoder(){\r\n    return \"\";\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDefaultValuesHelper.sortBy",
	"Comment": "current policy is to use the max value as default for time and min value as default forelevation.",
	"Method": "void sortBy(Query query,DimensionDescriptor timeDimension,DimensionDescriptor elevationDimension){\r\n    final List<SortBy> clauses = new ArrayList<SortBy>();\r\n    if (timeDimension != null) {\r\n        clauses.add(new SortByImpl(FeatureUtilities.DEFAULT_FILTER_FACTORY.property(timeDimension.getStartAttribute()), SortOrder.DESCENDING));\r\n    }\r\n    if (elevationDimension != null) {\r\n        clauses.add(new SortByImpl(FeatureUtilities.DEFAULT_FILTER_FACTORY.property(elevationDimension.getStartAttribute()), SortOrder.ASCENDING));\r\n    }\r\n    final SortBy[] sb = clauses.toArray(new SortBy[] {});\r\n    query.setSortBy(sb);\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.NetCDFEncoderFactory.getOutputFileName",
	"Comment": "builds a file name from the object to be encoded, or returns null",
	"Method": "String getOutputFileName(GranuleStack granuleStack,String coverageId,String format){\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.wps.ExecuteTest.testBoundsGet",
	"Comment": "tests a process execution with a boudingbox as the output and check internal layer requesthandling as well",
	"Method": "void testBoundsGet(){\r\n    String request = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<wps:Execute version=\\\"1.0.0\\\" service=\\\"WPS\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns=\\\"http://www.opengis.net/wps/1.0.0\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\" xmlns:wps=\\\"http://www.opengis.net/wps/1.0.0\\\" xmlns:ows=\\\"http://www.opengis.net/ows/1.1\\\" xmlns:gml=\\\"http://www.opengis.net/gml\\\" xmlns:ogc=\\\"http://www.opengis.net/ogc\\\" xmlns:wcs=\\\"http://www.opengis.net/wcs/1.1.1\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" xsi:schemaLocation=\\\"http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd\\\">\\n\" + \"  <ows:Identifier>gs:Bounds<\/ows:Identifier>\\n\" + \"  <wps:DataInputs>\\n\" + \"    <wps:Input>\\n\" + \"      <ows:Identifier>features<\/ows:Identifier>\\n\" + \"      <wps:Reference mimeType=\\\"text/xml; subtype=wfs-collection/1.0\\\" xlink:href=\\\"http://geoserver/wfs?service=WFS&amp;request=GetFeature&amp;typename=cite:Streams\\\" method=\\\"GET\\\"/>\\n\" + \"    <\/wps:Input>\\n\" + \"  <\/wps:DataInputs>\\n\" + \"  <wps:ResponseForm>\\n\" + \"    <wps:RawDataOutput>\\n\" + \"      <ows:Identifier>bounds<\/ows:Identifier>\\n\" + \"    <\/wps:RawDataOutput>\\n\" + \"  <\/wps:ResponseForm>\\n\" + \"<\/wps:Execute>\";\r\n    Document dom = postAsDOM(root(), request);\r\n    checkStreamsProcessBounds(dom);\r\n}"
}, {
	"Path": "org.geoserver.platform.resource.Paths.toPath",
	"Comment": "internal method used to convert a list of names to a normal resource path.",
	"Method": "String toPath(boolean strictPath,List<String> names){\r\n    StringBuilder buf = new StringBuilder();\r\n    final int LIMIT = names.size();\r\n    for (int i = 0; i < LIMIT; i++) {\r\n        String item = names.get(i);\r\n        if (item == null) {\r\n            continue;\r\n        }\r\n        if (INVALID.contains(item)) {\r\n            throw new IllegalArgumentException(\"Contains invalid \" + item + \" path: \" + buf);\r\n        }\r\n        if (!VALID.matcher(item).matches()) {\r\n            throw new IllegalArgumentException(\"Contains invalid \" + item + \" path: \" + buf);\r\n        }\r\n        if (!WARN.matcher(item).matches()) {\r\n            if (strictPath) {\r\n                throw new IllegalArgumentException(\"Contains invalid \" + item + \" path: \" + buf);\r\n            }\r\n        }\r\n        buf.append(item);\r\n        if (i < LIMIT - 1) {\r\n            buf.append(\"/\");\r\n        }\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.geoserver.rest.util.IOUtils.moveFileTo",
	"Comment": "move the specified input file to the specified destination directory.",
	"Method": "void moveFileTo(File source,File destDir,boolean removeInputFile){\r\n    inputNotNull(source, destDir);\r\n    if (!source.exists() || !source.canRead() || source.isDirectory())\r\n        throw new IllegalStateException(\"Source is not in a legal state.\");\r\n    if (!destDir.exists() || !destDir.canWrite() || !destDir.isDirectory())\r\n        throw new IllegalStateException(\"Source is not in a legal state.\");\r\n    if (destDir.getAbsolutePath().equalsIgnoreCase(source.getParentFile().getAbsolutePath()))\r\n        return;\r\n    copyFile(source, new File(destDir, source.getName()));\r\n    if (removeInputFile)\r\n        FILE_CLEANER.addFile(source);\r\n}"
}, {
	"Path": "org.geoserver.wps.validator.Validators.filterOutClasses",
	"Comment": "returns a clone of the validators collection where none of the validators implementing one ofthe specified filter classes is available",
	"Method": "List<Validator> filterOutClasses(Collection<Validator> validators,Class filteredClasses){\r\n    if (validators == null) {\r\n        return null;\r\n    }\r\n    List<Validator> result = new ArrayList();\r\n    for (Validator v : validators) {\r\n        Class<? extends Validator> validatorClass = v.getClass();\r\n        boolean skip = false;\r\n        for (Class filteredClass : filteredClasses) {\r\n            if (filteredClass.isAssignableFrom(validatorClass)) {\r\n                skip = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!skip) {\r\n            result.add(v);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.catalog.Styles.style",
	"Comment": "convenience method to pull a usersyle from a styledlayerdescriptor.this method will return the first userstyle it encounters in the styledlayerdescriptortree.",
	"Method": "Style style(StyledLayerDescriptor sld){\r\n    for (int i = 0; i < sld.getStyledLayers().length; i++) {\r\n        Style[] styles = null;\r\n        if (sld.getStyledLayers()[i] instanceof NamedLayer) {\r\n            NamedLayer layer = (NamedLayer) sld.getStyledLayers()[i];\r\n            styles = layer.getStyles();\r\n        } else if (sld.getStyledLayers()[i] instanceof UserLayer) {\r\n            UserLayer layer = (UserLayer) sld.getStyledLayers()[i];\r\n            styles = layer.getUserStyles();\r\n        }\r\n        if (styles != null) {\r\n            for (int j = 0; j < styles.length; j++) {\r\n                if (!(styles[j] instanceof NamedStyle)) {\r\n                    return styles[j];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.opensearch.eo.store.AbstractMappingStore.modifySecondaryAttribute",
	"Comment": "allows subclasses to handle other attributes mapped in secondary tables",
	"Method": "boolean modifySecondaryAttribute(Name name,Object value,Filter mappedFilter){\r\n    return false;\r\n}"
}, {
	"Path": "org.geoserver.test.SRSReprojectionTest.testChainingXlink",
	"Comment": "tests that xlink href works fine in nested feature chaining with features that containsgeometry",
	"Method": "void testChainingXlink(){\r\n    Document doc = getAsDOM(\"wfs?request=GetFeature&version=1.1.0&typename=ex:geomContainer\");\r\n    LOGGER.info(\"WFS GetFeature&typename=ex:geomContainer response:\\n\" + prettyString(doc));\r\n    assertXpathEvaluatesTo(\"http://example.com/UrnResolver/?uri=1\", \"//ex:geomContainer[@gml:id='1']/ex:nestedFeature[3]/@xlink:href\", doc);\r\n    assertXpathEvaluatesTo(\"http://example.com/UrnResolver/?uri=2\", \"//ex:geomContainer[@gml:id='2']/ex:nestedFeature[3]/@xlink:href\", doc);\r\n}"
}, {
	"Path": "org.geoserver.wps.resource.WPSResourceManager.getExecutionId",
	"Comment": "create a new unique id for the process. all resources linked to the process should use thistoken to register themselves against the manager",
	"Method": "String getExecutionId(String executionId,String getExecutionId,Boolean synch){\r\n    String id = executionId.get();\r\n    if (id == null) {\r\n        id = UUID.randomUUID().toString();\r\n        executionId.set(id);\r\n        resourceCache.put(id, new ExecutionResources(synch != null ? synch : true));\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Associating process with execution id: \" + id);\r\n        }\r\n    }\r\n    return id;\r\n}"
}, {
	"Path": "org.geoserver.security.jdbc.config.JDBCSecurityServiceConfig.isMySQL",
	"Comment": "helper method to determine if the backing database is mysql.",
	"Method": "boolean isMySQL(){\r\n    return \"com.mysql.jdbc.Driver\".equals(driverClassName);\r\n}"
}, {
	"Path": "org.geoserver.wfs.GetFeatureContext.getFeatureSource",
	"Comment": "the feature source being queried. the object returned may be mutable, but the callback isstrongly suggested not to attempt any modification, the behavior of doing so is undefined andmight change over time",
	"Method": "FeatureSource<? extends FeatureType, ? extends Feature> getFeatureSource(){\r\n    return featureSource;\r\n}"
}, {
	"Path": "org.geoserver.test.AbstractAppSchemaTestSupport.readResource",
	"Comment": "helper method that reads a resource from the class path converting it to text.",
	"Method": "String readResource(String resourcePath){\r\n    try (InputStream input = NormalizedMultiValuesTest.class.getResourceAsStream(resourcePath)) {\r\n        return IOUtils.toString(input);\r\n    } catch (Exception exception) {\r\n        throw new RuntimeException(String.format(\"Error reading resource '%s'.\", resourcePath));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.nsg.pagination.random.IndexConfigurationManager.moveData",
	"Comment": "helper method that move resource informations from current db to the new one",
	"Method": "void moveData(DataStore exDataStore,DataStore newDataStore){\r\n    Transaction session = new DefaultTransaction(\"Moving\");\r\n    try {\r\n        SimpleFeatureSource exFs = exDataStore.getFeatureSource(STORE_SCHEMA_NAME);\r\n        SimpleFeatureStore newFs = (SimpleFeatureStore) newDataStore.getFeatureSource(STORE_SCHEMA_NAME);\r\n        newFs.setTransaction(session);\r\n        newFs.addFeatures(exFs.getFeatures());\r\n        session.commit();\r\n    } catch (Throwable t) {\r\n        session.rollback();\r\n        throw new RuntimeException(\"Error on move data\", t);\r\n    } finally {\r\n        session.close();\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wps.ExecuteTest.testWrongOutputIdentifierDocumentOutputSynch",
	"Comment": "tests a process execution an invalid output identifier fails immediately with an appropriateerror message",
	"Method": "void testWrongOutputIdentifierDocumentOutputSynch(){\r\n    String responseFormContents = \"<wps:ResponseDocument>\" + \"<wps:Output>\" + \"<ows:Identifier>fooBar<\/ows:Identifier>\" + \"<\/wps:Output>\" + \"<\/wps:ResponseDocument>\";\r\n    String request = buildGetBoundsRequest(responseFormContents);\r\n    Document dom = postAsDOM(root(), request);\r\n    String message = checkOws11Exception(dom, ServiceException.INVALID_PARAMETER_VALUE, \"ResponseDocument\");\r\n    assertThat(message, containsString(\"fooBar\"));\r\n}"
}, {
	"Path": "org.geoserver.wcs.DefaultWebCoverageService100.checkRangeSubset",
	"Comment": "checks that the elements of the rangesubset part of the request do make sense by comparingthem to the coverage metadata",
	"Method": "void checkRangeSubset(CoverageInfo info,RangeSubsetType rangeSubset){\r\n    if (rangeSubset == null)\r\n        return;\r\n    for (int a = 0; a < rangeSubset.getAxisSubset().size(); a++) {\r\n        AxisSubsetType axisSubset = (AxisSubsetType) rangeSubset.getAxisSubset().get(a);\r\n        if (axisSubset.getName().equalsIgnoreCase(\"Band\")) {\r\n            int[] bands = null;\r\n            if (axisSubset.getSingleValue().size() > 0) {\r\n                bands = new int[1];\r\n                bands[0] = Integer.parseInt(((TypedLiteralType) axisSubset.getSingleValue().get(0)).getValue());\r\n            } else if (axisSubset.getInterval().size() > 0) {\r\n                IntervalType interval = (IntervalType) axisSubset.getInterval().get(0);\r\n                int min = Integer.parseInt(interval.getMin().getValue());\r\n                int max = Integer.parseInt(interval.getMax().getValue());\r\n                int res = (interval.getRes() != null ? Integer.parseInt(interval.getRes().getValue()) : 1);\r\n                bands = new int[(max - min) / res];\r\n                for (int b = 0; b < bands.length; b++) bands[b] = min + (b * res);\r\n            }\r\n            if (bands == null)\r\n                throw new WcsException(\"Invalid values for axis \" + axisSubset.getName(), InvalidParameterValue, \"AxisSubset\");\r\n        } else if (axisSubset.getName().equalsIgnoreCase(WCSUtils.ELEVATION)) {\r\n            double[] elevations = null;\r\n            if (axisSubset.getSingleValue().size() > 0) {\r\n                elevations = new double[axisSubset.getSingleValue().size()];\r\n                for (int s = 0; s < axisSubset.getSingleValue().size(); s++) {\r\n                    elevations[s] = Double.parseDouble(((TypedLiteralType) axisSubset.getSingleValue().get(s)).getValue());\r\n                }\r\n            } else if (axisSubset.getInterval().size() > 0) {\r\n                IntervalType interval = (IntervalType) axisSubset.getInterval().get(0);\r\n                int min = Integer.parseInt(interval.getMin().getValue());\r\n                int max = Integer.parseInt(interval.getMax().getValue());\r\n                int res = (interval.getRes() != null ? Integer.parseInt(interval.getRes().getValue()) : 1);\r\n                elevations = new double[(int) (Math.floor(max - min) / res + 1)];\r\n                for (int b = 0; b < elevations.length; b++) elevations[b] = (min + b * res);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.wfs.xslt.config.TransformRepository.getTransformSheet",
	"Comment": "returns the stylesheet of a transformation. it is the duty of the caller to close the inputstream after reading it.",
	"Method": "InputStream getTransformSheet(TransformInfo info){\r\n    Resource txFile = getTransformFile(info);\r\n    return txFile.in();\r\n}"
}, {
	"Path": "org.geoserver.wfs.json.ComplexGeoJsonWriter.getFeatures",
	"Comment": "helper method that try to extract a list of features from an attribute. if no features can befound null is returned.",
	"Method": "List<Feature> getFeatures(Attribute attribute){\r\n    Object value = attribute.getValue();\r\n    if (value instanceof Feature) {\r\n        return Collections.singletonList((Feature) value);\r\n    }\r\n    if (!(value instanceof Collection)) {\r\n        return null;\r\n    }\r\n    Collection collection = (Collection) value;\r\n    if (collection.isEmpty()) {\r\n        return Collections.emptyList();\r\n    }\r\n    if (!(getElementAt(collection, 0) instanceof Feature)) {\r\n        return null;\r\n    }\r\n    List<Feature> features = new ArrayList();\r\n    for (Object object : collection) {\r\n        if (!(object instanceof Feature)) {\r\n            throw new RuntimeException(String.format(\"Unable to handle attribute '%s'.\", attribute));\r\n        }\r\n        features.add((Feature) object);\r\n    }\r\n    return features;\r\n}"
}, {
	"Path": "org.geoserver.wfs.response.ShapeZipTest.testMultiPointZMShp",
	"Comment": "test for multipoint zm support on getfeature shapefile output",
	"Method": "void testMultiPointZMShp(){\r\n    GeometryFactory gf = JTSFactoryFinder.getGeometryFactory();\r\n    SimpleFeatureType featureType = DataUtilities.createType(\"multipointmz\", \"name:String,geom:MultiPoint:4326\");\r\n    SimpleFeatureBuilder fb = new SimpleFeatureBuilder(featureType);\r\n    fb.add(\"points1\");\r\n    fb.add(gf.createMultiPoint(new Point[] { gf.createPoint(new CoordinateXYZM(1, 2, 3, 4)), gf.createPoint(new CoordinateXYZM(5, 6, 7, 8)) }));\r\n    List<SimpleFeature> features = new ArrayList<SimpleFeature>();\r\n    features.add(fb.buildFeature(\"1\"));\r\n    SimpleFeatureCollection featureCollection = DataUtilities.collection(features);\r\n    byte[] zipBytes = writeOut(featureCollection);\r\n    byte[] resultBytes = getShpOnlyBytes(zipBytes);\r\n    InputStream in = getClass().getClassLoader().getResourceAsStream(\"org/geoserver/wfs/response/multiPointZm.shp\");\r\n    byte[] expectedBytes = IOUtils.toByteArray(in);\r\n    in.close();\r\n    assertTrue(Arrays.equals(resultBytes, expectedBytes));\r\n}"
}, {
	"Path": "org.geoserver.wms.animate.FrameCatalogVisitor.produce",
	"Comment": "invokes the executor service and produces the frames images.",
	"Method": "RenderedImageList produce(WMS wmsConfiguration){\r\n    List<RenderedImage> images = new ArrayList<RenderedImage>();\r\n    long gifAnimatedSize = 0;\r\n    for (Future<RenderedImage> future : tasks) {\r\n        RenderedImage image = null;\r\n        try {\r\n            image = future.get();\r\n        } catch (InterruptedException e) {\r\n            dispose();\r\n            throw new IOException(e);\r\n        } catch (ExecutionException e) {\r\n            dispose();\r\n            throw new IOException(e);\r\n        }\r\n        if (image == null) {\r\n            continue;\r\n        }\r\n        gifAnimatedSize += getImageSizeInBytes(image);\r\n        if (wmsConfiguration.getMaxRenderingSize() != null && gifAnimatedSize >= wmsConfiguration.getMaxRenderingSize()) {\r\n            dispose();\r\n            throw new IOException(\"Max rendering size exceed!\");\r\n        }\r\n        images.add(image);\r\n    }\r\n    if (images == null || images.size() == 0) {\r\n        dispose();\r\n        throw new IOException(\"Empty list of frames.\");\r\n    }\r\n    dispose();\r\n    return new RenderedImageList(images);\r\n}"
}, {
	"Path": "org.geoserver.security.ldap.LDAPAuthenticationProviderTest.testRoleService",
	"Comment": "test that active role service is applied in the ldapauthenticationprovider",
	"Method": "void testRoleService(){\r\n    Assume.assumeTrue(LDAPTestUtils.initLdapServer(true, ldapServerUrl, basePath));\r\n    ((LDAPSecurityServiceConfig) config).setUserDnPattern(\"uid={0},ou=People\");\r\n    createAuthenticationProvider();\r\n    authProvider.setSecurityManager(securityManager);\r\n    securityManager.setProviders(Collections.singletonList(authProvider));\r\n    MemoryRoleStore roleService = new MemoryRoleStore();\r\n    roleService.initializeFromService(new MemoryRoleService());\r\n    roleService.setSecurityManager(securityManager);\r\n    GeoServerRole role = roleService.createRoleObject(\"MyRole\");\r\n    roleService.addRole(role);\r\n    roleService.associateRoleToUser(role, \"other\");\r\n    securityManager.setActiveRoleService(roleService);\r\n    Authentication result = authProvider.authenticate(authenticationOther);\r\n    assertTrue(result.getAuthorities().contains(role));\r\n    assertEquals(3, result.getAuthorities().size());\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.getAsImage",
	"Comment": "retries the request result as a bufferedimage, checking the mime type is the expected one",
	"Method": "BufferedImage getAsImage(String path,String mime){\r\n    MockHttpServletResponse resp = getAsServletResponse(path);\r\n    assertEquals(mime, resp.getContentType());\r\n    InputStream is = getBinaryInputStream(resp);\r\n    return ImageIO.read(is);\r\n}"
}, {
	"Path": "org.geoserver.importer.Importer.createStyleFromFile",
	"Comment": "creates a style for the layer being imported from a resource that was included in thedirectory or archive that the data is being imported from.",
	"Method": "StyleInfo createStyleFromFile(File styleFile,ImportTask task){\r\n    String ext = FilenameUtils.getExtension(styleFile.getName());\r\n    if (ext != null) {\r\n        StyleHandler styleHandler = Styles.handler(ext);\r\n        if (styleHandler != null) {\r\n            try {\r\n                StyledLayerDescriptor sld = styleHandler.parse(styleFile, null, null, new EntityResolverProvider(getGeoServer()).getEntityResolver());\r\n                Style style = Styles.style(sld);\r\n                if (style != null) {\r\n                    StyleInfo info = catalog.getFactory().createStyle();\r\n                    String styleName = styleGen.generateUniqueStyleName(task.getLayer().getResource());\r\n                    info.setName(styleName);\r\n                    info.setFilename(styleName + \".\" + ext);\r\n                    info.setFormat(styleHandler.getFormat());\r\n                    info.setFormatVersion(styleHandler.version(styleFile));\r\n                    info.setWorkspace(task.getStore().getWorkspace());\r\n                    try (InputStream in = new FileInputStream(styleFile)) {\r\n                        catalog.getResourcePool().writeStyle(info, in);\r\n                    }\r\n                    return info;\r\n                } else {\r\n                    LOGGER.warning(\"Style file contained no styling: \" + styleFile.getPath());\r\n                }\r\n            } catch (Exception e) {\r\n                LOGGER.log(Level.WARNING, \"Error parsing style: \" + styleFile.getPath(), e);\r\n            }\r\n        } else {\r\n            LOGGER.warning(\"Unable to find style handler for file extension: \" + ext);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.wps.ppio.ProcessParameterIO.getDirection",
	"Comment": "used to advertise if the ppio can support encoding, decoding, or both. by default both isreturned, subclass can override with their specific abilities",
	"Method": "PPIODirection getDirection(){\r\n    return PPIODirection.BOTH;\r\n}"
}, {
	"Path": "org.geoserver.kml.utils.KMLFeatureAccessor.getFeaturesQuery",
	"Comment": "builds the query object that will return the features for the specified layer and scaledenominator, based also on the current wms configuration",
	"Method": "Query getFeaturesQuery(Layer layer,WMSMapContent mapContent,WMS wms,double scaleDenominator){\r\n    SimpleFeatureType schema = ((SimpleFeatureSource) layer.getFeatureSource()).getSchema();\r\n    ReferencedEnvelope aoi = mapContent.getRenderingArea();\r\n    Filter filter = createBBoxFilter(schema, aoi);\r\n    Query q = new Query(schema.getTypeName());\r\n    q.setFilter(filter);\r\n    q = DataUtilities.mixQueries(q, layer.getQuery(), \"KMLEncoder\");\r\n    q.setSortBy(layer.getQuery().getSortBy());\r\n    RegionatingStrategy regionatingStrategy = null;\r\n    String stratname = (String) mapContent.getRequest().getFormatOptions().get(\"regionateBy\");\r\n    if ((\"auto\").equals(stratname)) {\r\n        Catalog catalog = wms.getGeoServer().getCatalog();\r\n        Name name = layer.getFeatureSource().getName();\r\n        stratname = catalog.getFeatureTypeByName(name).getMetadata().get(\"kml.regionateStrategy\", String.class);\r\n        if (stratname == null || \"\".equals(stratname)) {\r\n            stratname = \"best_guess\";\r\n            LOGGER.log(Level.FINE, \"No default regionating strategy has been configured in \" + name + \"; using automatic best-guess strategy.\");\r\n        }\r\n    }\r\n    Filter regionatingFilter = Filter.INCLUDE;\r\n    if (stratname != null) {\r\n        regionatingStrategy = findStrategyByName(stratname);\r\n        if (regionatingStrategy == null) {\r\n            throw new ServiceException(\"Unknown regionating strategy \" + stratname);\r\n        } else {\r\n            regionatingFilter = regionatingStrategy.getFilter(mapContent, layer);\r\n        }\r\n    }\r\n    Filter ruleFilter = getStyleFilter(schema, layer.getStyle(), scaleDenominator);\r\n    Filter finalFilter = joinFilters(q.getFilter(), ruleFilter, regionatingFilter);\r\n    if (finalFilter == Filter.EXCLUDE) {\r\n        return null;\r\n    }\r\n    q.setFilter(finalFilter);\r\n    return q;\r\n}"
}, {
	"Path": "org.geoserver.gwc.wmts.dimensions.DimensionsUtils.getAggregates",
	"Comment": "helper method that extracts a set of aggregates on the given collection and attribute andreturns the results",
	"Method": "Map<Aggregate, Object> getAggregates(String attributeName,FeatureCollection featureCollection,Aggregate aggregates){\r\n    Map<Aggregate, Object> result = new HashMap();\r\n    PropertyName property = FF.property(attributeName);\r\n    for (Aggregate aggregate : aggregates) {\r\n        FeatureCalc featureCalc = aggregate.create(property);\r\n        try {\r\n            featureCollection.accepts(featureCalc, null);\r\n            Object value = featureCalc.getResult().getValue();\r\n            result.put(aggregate, value);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(\"Failed to collect summary aggregates on attribute \" + attributeName, e);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.geoserver.wcs.responses.NetCDFDimensionsManager.collectCoverageDimensions",
	"Comment": "initialize the manager by collecting all dimensions from the granule stack and preparing themapping.",
	"Method": "void collectCoverageDimensions(GranuleStack granuleStack){\r\n    final List<DimensionBean> dimensions = granuleStack.getDimensions();\r\n    for (DimensionBean dimension : dimensions) {\r\n        final String name = dimension.getName();\r\n        final NetCDFDimensionsManager.NetCDFDimensionMapping mapper = new NetCDFDimensionsManager.NetCDFDimensionMapping(name);\r\n        mapper.setCoverageDimension(dimension);\r\n        final DimensionBean.DimensionType dimensionType = dimension.getDimensionType();\r\n        final boolean isRange = dimension.isRange();\r\n        TreeSet<Object> tree = null;\r\n        switch(dimensionType) {\r\n            case TIME:\r\n                tree = new TreeSet(new DateRangeComparator());\r\n                break;\r\n            case ELEVATION:\r\n                tree = new TreeSet(new NumberRangeComparator());\r\n                break;\r\n            case CUSTOM:\r\n                String dataType = dimension.getDatatype();\r\n                if (NetCDFUtilities.isATime(dataType)) {\r\n                    tree = isRange ? new TreeSet(new DateRangeComparator()) : new TreeSet<Object>();\r\n                } else {\r\n                    tree = isRange ? new TreeSet(new NumberRangeComparator()) : new TreeSet<Object>();\r\n                }\r\n        }\r\n        mapper.setDimensionValues(new NetCDFDimensionsManager.NetCDFDimensionMapping.DimensionValuesSet(tree));\r\n        add(name, mapper);\r\n    }\r\n    for (GridCoverage2D coverage : granuleStack.getGranules()) {\r\n        updateDimensionValues(coverage);\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.test.GeoServerSystemTestSupport.getGeoServer",
	"Comment": "accessor for global geoserver instance from the test application context.",
	"Method": "GeoServer getGeoServer(){\r\n    return (GeoServer) applicationContext.getBean(\"geoServer\");\r\n}"
}, {
	"Path": "org.geoserver.security.GeoServerSecurityManager.loadPasswordEncoders",
	"Comment": "loads all the password encoders that match the specified criteria.",
	"Method": "List<GeoServerPasswordEncoder> loadPasswordEncoders(List<T> loadPasswordEncoders,Class<T> filter,List<T> loadPasswordEncoders,Class<T> filter,Boolean reversible,Boolean strong){\r\n    filter = (Class<T>) (filter != null ? filter : GeoServerPasswordEncoder.class);\r\n    List list = GeoServerExtensions.extensions(filter);\r\n    for (Iterator it = list.iterator(); it.hasNext(); ) {\r\n        boolean remove = false;\r\n        T pw = (T) it.next();\r\n        if (reversible != null && !reversible.equals(pw.isReversible())) {\r\n            remove = true;\r\n        }\r\n        if (!remove && strong != null && strong.equals(pw.isAvailableWithoutStrongCryptogaphy())) {\r\n            remove = true;\r\n        }\r\n        if (remove) {\r\n            it.remove();\r\n        } else {\r\n            try {\r\n                pw.initialize(this);\r\n            } catch (IOException e) {\r\n                LOGGER.log(Level.WARNING, \"Error initializing password encoder \" + pw.getName() + \", skipping\", e);\r\n                it.remove();\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.geoserver.sldservice.utils.classifier.RulesBuilder.explicitRules",
	"Comment": "generate rules from explicit classifier groups build a list of rules",
	"Method": "List<Rule> explicitRules(ExplicitClassifier groups,String property,Class<?> propertyType){\r\n    Rule r;\r\n    Filter f;\r\n    List<Rule> list = new ArrayList();\r\n    PropertyName att = FF.property(property);\r\n    String szFilter = \"\";\r\n    String szTitle = \"\";\r\n    Literal val;\r\n    try {\r\n        for (int i = 0; i < groups.getSize(); i++) {\r\n            r = SF.createRule();\r\n            Set ls = groups.getValues(i);\r\n            Iterator it = ls.iterator();\r\n            val = FF.literal(it.next());\r\n            szFilter = att + \"=\\'\" + val + \"\\'\";\r\n            szTitle = \"\" + val;\r\n            while (it.hasNext()) {\r\n                val = FF.literal(it.next());\r\n                szFilter += \" OR \" + att + \"=\\'\" + val + \"\\'\";\r\n                szTitle += \" OR \" + val;\r\n            }\r\n            f = CQL.toFilter(szFilter);\r\n            r.setTitle(szTitle);\r\n            r.setFilter(f);\r\n            list.add(r);\r\n        }\r\n        return list;\r\n    } catch (CQLException e) {\r\n        if (LOGGER.isLoggable(Level.INFO))\r\n            LOGGER.log(Level.INFO, \"Failed to build explicit Rules\" + e.getLocalizedMessage(), e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.security.WrapperPolicy.derive",
	"Comment": "builds a new wrapperpolicy copying this one, but with a different access limits object",
	"Method": "WrapperPolicy derive(AccessLimits limits){\r\n    return new WrapperPolicy(this.level, this.response, limits);\r\n}"
}, {
	"Path": "org.geoserver.importer.transform.AbstractCommandLinePreTransform.getOutputDirectory",
	"Comment": "the directory used for outputs, by default, a subdirectory of the input file parent",
	"Method": "File getOutputDirectory(ImportData data){\r\n    File input = getInputFile(data);\r\n    File parent = input.getParentFile();\r\n    File tempFile = File.createTempFile(\"tmp\", null, parent);\r\n    tempFile.delete();\r\n    if (!tempFile.mkdir()) {\r\n        throw new IOException(\"Could not create work directory \" + tempFile.getAbsolutePath());\r\n    }\r\n    return tempFile;\r\n}"
}, {
	"Path": "org.geoserver.kml.icons.Icons.rotationScaleFactor",
	"Comment": "find the scale factor needed for a square to accommodate a rotated square.",
	"Method": "double rotationScaleFactor(double rotation){\r\n    return Math.abs(Math.sin(Math.toRadians(rotation))) + Math.abs(Math.cos(Math.toRadians(rotation)));\r\n}"
}, {
	"Path": "org.geoserver.test.FeatureChainingWfsTest.testDescribeFeatureTypeNoTypes",
	"Comment": "test describefeaturetype response when no types are specified.",
	"Method": "void testDescribeFeatureTypeNoTypes(){\r\n    Document doc = getAsDOM(\"wfs?request=DescribeFeatureType&version=1.1.0\");\r\n    LOGGER.info(\"WFS DescribeFeatureType response:\\n\" + prettyString(doc));\r\n    assertEquals(\"xsd:schema\", doc.getDocumentElement().getNodeName());\r\n    String targetNamespace = evaluate(\"//@targetNamespace\", doc);\r\n    assertFalse(targetNamespace.isEmpty());\r\n    int numberOfImports = getMatchingNodes(\"//xsd:import\", doc).getLength();\r\n    int numberOfIncludes = getMatchingNodes(\"//xsd:include\", doc).getLength();\r\n    ArrayList<String> namespaces = new ArrayList<String>();\r\n    namespaces.add(AbstractAppSchemaMockData.GSML_URI);\r\n    namespaces.add(FeatureChainingMockData.OM_URI);\r\n    namespaces.add(FeatureChainingMockData.EX_URI);\r\n    if (targetNamespace.equals(FeatureChainingMockData.EX_URI)) {\r\n        assertEquals(2, numberOfImports);\r\n        assertEquals(3, numberOfIncludes);\r\n        @SuppressWarnings(\"serial\")\r\n        Set<String> expectedExSchemaLocations = new HashSet<String>() {\r\n            {\r\n                add(getExSchemaOneLocation());\r\n                add(getExSchemaTwoLocation());\r\n                add(getExSchemaThreeLocation());\r\n            }\r\n        };\r\n        assertEquals(numberOfIncludes, expectedExSchemaLocations.size());\r\n        Set<String> foundExSchemaLocations = new HashSet<String>();\r\n        for (int i = 1; i <= numberOfIncludes; i++) {\r\n            foundExSchemaLocations.add(evaluate(\"//xsd:include[\" + i + \"]/@schemaLocation\", doc));\r\n        }\r\n        assertEquals(expectedExSchemaLocations, foundExSchemaLocations);\r\n        namespaces.remove(FeatureChainingMockData.EX_URI);\r\n    } else {\r\n        assertEquals(2, numberOfImports);\r\n        assertEquals(1, numberOfIncludes);\r\n        String schemaLocation = \"//xsd:include[\" + 1 + \"]/@schemaLocation\";\r\n        if (targetNamespace.equals(AbstractAppSchemaMockData.GSML_URI)) {\r\n            assertXpathEvaluatesTo(AbstractAppSchemaMockData.GSML_SCHEMA_LOCATION_URL, schemaLocation, doc);\r\n            namespaces.remove(AbstractAppSchemaMockData.GSML_URI);\r\n        } else {\r\n            assertEquals(FeatureChainingMockData.OM_URI, targetNamespace);\r\n            assertXpathEvaluatesTo(FeatureChainingMockData.OM_SCHEMA_LOCATION_URL, schemaLocation, doc);\r\n            namespaces.remove(FeatureChainingMockData.OM_URI);\r\n        }\r\n    }\r\n    for (int i = 1; i <= numberOfImports; i++) {\r\n        String namespace = evaluate(\"//xsd:import[\" + i + \"]/@namespace\", doc);\r\n        String schemaLocation = \"//xsd:import[\" + i + \"]/@schemaLocation\";\r\n        if (namespace.equals(AbstractAppSchemaMockData.GSML_URI)) {\r\n            assertXpathEvaluatesTo(AbstractAppSchemaMockData.GSML_SCHEMA_LOCATION_URL, schemaLocation, doc);\r\n            namespaces.remove(AbstractAppSchemaMockData.GSML_URI);\r\n        } else if (namespace.equals(FeatureChainingMockData.EX_URI)) {\r\n            String loc = evaluate(schemaLocation, doc);\r\n            assertTrue(loc.equals(getExSchemaOneLocation()) || loc.equals(getExSchemaTwoLocation()) || loc.equals(getExSchemaThreeLocation()));\r\n            namespaces.remove(FeatureChainingMockData.EX_URI);\r\n        } else {\r\n            assertEquals(FeatureChainingMockData.OM_URI, namespace);\r\n            assertXpathEvaluatesTo(FeatureChainingMockData.OM_SCHEMA_LOCATION_URL, schemaLocation, doc);\r\n            namespaces.remove(FeatureChainingMockData.OM_URI);\r\n        }\r\n    }\r\n    assertTrue(namespaces.isEmpty());\r\n    assertXpathCount(0, \"//xsd:complexType\", doc);\r\n    assertXpathCount(0, \"//xsd:element\", doc);\r\n}"
}, {
	"Path": "org.geoserver.cluster.integration.IntegrationTestsUtils.differences",
	"Comment": "returns the catalog and configuration differences between two geoserver instance.",
	"Method": "List<InfoDiff> differences(GeoServerInstance instanceA,GeoServerInstance instanceB){\r\n    List<InfoDiff> differences = new ArrayList();\r\n    differences.addAll(catalogDifferences(instanceA, instanceB));\r\n    differences.addAll(configurationDifferences(instanceA, instanceB));\r\n    return differences;\r\n}"
}, {
	"Path": "org.geoserver.wps.gs.download.DownloadProcessTest.testDownloadScaledRaster",
	"Comment": "test download of raster data. the output is scaled to fit exactly the provided size.",
	"Method": "void testDownloadScaledRaster(){\r\n    DownloadEstimatorProcess limits = new DownloadEstimatorProcess(new StaticDownloadServiceConfiguration(), getGeoServer());\r\n    final WPSResourceManager resourceManager = getResourceManager();\r\n    DownloadProcess downloadProcess = new DownloadProcess(getGeoServer(), limits, resourceManager);\r\n    File rasterZip = // layerName\r\n    downloadProcess.execute(getLayerId(MockData.USA_WORLDIMG), null, \"image/tiff\", null, CRS.decode(\"EPSG:4326\", true), null, false, null, 80, 80, null, null, new NullProgressListener());\r\n    Assert.assertNotNull(rasterZip);\r\n    GeoTiffReader reader = null;\r\n    GridCoverage2D gc = null;\r\n    try {\r\n        final File[] tiffFiles = extractFiles(rasterZip, \"GTIFF\");\r\n        Assert.assertNotNull(tiffFiles);\r\n        Assert.assertTrue(tiffFiles.length > 0);\r\n        reader = new GeoTiffReader(tiffFiles[0]);\r\n        gc = reader.read(null);\r\n        Assert.assertNotNull(gc);\r\n        Rectangle2D originalGridRange = (GridEnvelope2D) reader.getOriginalGridRange();\r\n        Assert.assertEquals(80, Math.round(originalGridRange.getWidth()));\r\n        Assert.assertEquals(80, Math.round(originalGridRange.getHeight()));\r\n        Assert.assertEquals(-130.8866985, gc.getEnvelope().getLowerCorner().getOrdinate(0), 1E-6);\r\n        Assert.assertEquals(48.5552613, gc.getEnvelope().getLowerCorner().getOrdinate(1), 1E-6);\r\n        Assert.assertEquals(-123.8830077, gc.getEnvelope().getUpperCorner().getOrdinate(0), 1E-6);\r\n        Assert.assertEquals(54.1420339, gc.getEnvelope().getUpperCorner().getOrdinate(1), 1E-6);\r\n    } finally {\r\n        if (gc != null) {\r\n            CoverageCleanerCallback.disposeCoverage(gc);\r\n        }\r\n        if (reader != null) {\r\n            reader.dispose();\r\n        }\r\n        resourceManager.finished(resourceManager.getExecutionId(true));\r\n    }\r\n    File largerZip = // layerName\r\n    downloadProcess.execute(getLayerId(MockData.USA_WORLDIMG), null, \"image/tiff\", null, CRS.decode(\"EPSG:4326\", true), null, false, null, 160, null, null, null, new NullProgressListener());\r\n    Assert.assertNotNull(largerZip);\r\n    try {\r\n        final File[] tiffFiles = extractFiles(largerZip, \"GTIFF\");\r\n        Assert.assertNotNull(tiffFiles);\r\n        Assert.assertTrue(tiffFiles.length > 0);\r\n        reader = new GeoTiffReader(tiffFiles[0]);\r\n        gc = reader.read(null);\r\n        Assert.assertNotNull(gc);\r\n        Rectangle2D originalGridRange = (GridEnvelope2D) reader.getOriginalGridRange();\r\n        Assert.assertEquals(160, Math.round(originalGridRange.getWidth()));\r\n        Assert.assertEquals(160, Math.round(originalGridRange.getHeight()));\r\n    } finally {\r\n        if (gc != null) {\r\n            CoverageCleanerCallback.disposeCoverage(gc);\r\n        }\r\n        if (reader != null) {\r\n            reader.dispose();\r\n        }\r\n        resourceManager.finished(resourceManager.getExecutionId(true));\r\n    }\r\n    Polygon roi = (Polygon) new WKTReader2().read(\"POLYGON (( -127.57473954542964 54.06575021619523, -130.88669845369998 52.00807146727025, -129.50812897394974 49.85372324691927, -130.5300633861675 49.20465679591609, -129.25955033314003 48.60392508062591, -128.00975216684665 50.986137055052474, -125.8623089087404 48.63154492960477, -123.984159178178 50.68231871628503, -126.91186316993704 52.15307567440926, -125.3444367403868 53.54787804784162, -127.57473954542964 54.06575021619523 ))\");\r\n    roi.setSRID(4326);\r\n    File resampledZip = // layerName\r\n    downloadProcess.execute(getLayerId(MockData.USA_WORLDIMG), null, \"image/tiff\", null, CRS.decode(\"EPSG:4326\", true), roi, true, null, 80, 80, null, null, new NullProgressListener());\r\n    Assert.assertNotNull(resampledZip);\r\n    try {\r\n        final File[] tiffFiles = extractFiles(resampledZip, \"GTIFF\");\r\n        Assert.assertNotNull(tiffFiles);\r\n        Assert.assertTrue(tiffFiles.length > 0);\r\n        reader = new GeoTiffReader(tiffFiles[0]);\r\n        gc = reader.read(null);\r\n        Assert.assertNotNull(gc);\r\n        Rectangle2D originalGridRange = (GridEnvelope2D) reader.getOriginalGridRange();\r\n        Assert.assertEquals(80, Math.round(originalGridRange.getWidth()));\r\n        Assert.assertEquals(80, Math.round(originalGridRange.getHeight()));\r\n        Assert.assertEquals(-130.88669845369998, gc.getEnvelope().getLowerCorner().getOrdinate(0), 1E-6);\r\n        Assert.assertEquals(48.623544058877776, gc.getEnvelope().getLowerCorner().getOrdinate(1), 1E-6);\r\n        Assert.assertEquals(-123.95304462109999, gc.getEnvelope().getUpperCorner().getOrdinate(0), 1E-6);\r\n        Assert.assertEquals(54.0861661371, gc.getEnvelope().getUpperCorner().getOrdinate(1), 1E-6);\r\n    } finally {\r\n        if (gc != null) {\r\n            CoverageCleanerCallback.disposeCoverage(gc);\r\n        }\r\n        if (reader != null) {\r\n            reader.dispose();\r\n        }\r\n        resourceManager.finished(resourceManager.getExecutionId(true));\r\n    }\r\n}"
}, {
	"Path": "org.geoserver.data.util.CoverageStoreUtils.aquireFactory",
	"Comment": "after user has selected description can aquire format based on description.",
	"Method": "Format aquireFactory(String description){\r\n    Format[] formats = GridFormatFinder.getFormatArray();\r\n    Format format = null;\r\n    final int length = formats.length;\r\n    for (int i = 0; i < length; i++) {\r\n        format = formats[i];\r\n        if (format.getDescription().equals(description)) {\r\n            return format;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.web.data.layer.NewLayerPage.getSelectedStoreId",
	"Comment": "returns the storeid provided during construction, or the one pointed by the drop down if nonewas provided during construction",
	"Method": "String getSelectedStoreId(){\r\n    return provider.getStoreId();\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDimensionsValueParser.parseAsDoubleRange",
	"Comment": "parse a string as a range of double or return null if impossible.",
	"Method": "NumberRange<Double> parseAsDoubleRange(String text){\r\n    try {\r\n        if (text.contains(\"/\")) {\r\n            String[] range = text.split(\"/\");\r\n            if (range.length == 2) {\r\n                String min = range[0];\r\n                String max = range[1];\r\n                final Double minValue = XML_CONVERTER.parseDouble(min);\r\n                final Double maxValue = XML_CONVERTER.parseDouble(max);\r\n                return new NumberRange<Double>(Double.class, minValue, maxValue);\r\n            }\r\n        }\r\n    } catch (NumberFormatException nfe) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.fine(text + \" can't be parsed as an Double.\");\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.GetCoverage.extractCRSInternal",
	"Comment": "extract the specified crs being it subsetting or output with proper defaults.",
	"Method": "CoordinateReferenceSystem extractCRSInternal(Map<String, ExtensionItemType> extensions,CoordinateReferenceSystem defaultCRS,boolean isOutputCRS){\r\n    Utilities.ensureNonNull(\"defaultCRS\", defaultCRS);\r\n    final String identifier = isOutputCRS ? \"outputCrs\" : \"subsettingCrs\";\r\n    if (extensions == null || extensions.size() == 0 || !extensions.containsKey(identifier)) {\r\n        return defaultCRS;\r\n    }\r\n    final ExtensionItemType extensionItem = extensions.get(identifier);\r\n    if (extensionItem.getName().equals(identifier)) {\r\n        String crsName = extensionItem.getSimpleContent();\r\n        if (crsName == null) {\r\n            throw new WCS20Exception(identifier + \" was null\", WCS20ExceptionCode.NotACrs, \"null\");\r\n        }\r\n        try {\r\n            CoordinateReferenceSystem crs = CRS.decode(crsName);\r\n            final Integer epsgCode = CRS.lookupEpsgCode(crs, false);\r\n            if (epsgCode != null && epsgCode > 0) {\r\n                return CRS.decode(\"EPSG:\" + epsgCode);\r\n            } else {\r\n                return crs;\r\n            }\r\n        } catch (Exception e) {\r\n            final WCS20Exception exception = new WCS20Exception(\"Invalid \" + identifier, isOutputCRS ? WCS20Exception.WCS20ExceptionCode.OutputCrsNotSupported : WCS20Exception.WCS20ExceptionCode.SubsettingCrsNotSupported, crsName);\r\n            exception.initCause(e);\r\n            throw exception;\r\n        }\r\n    }\r\n    return defaultCRS;\r\n}"
}, {
	"Path": "org.geoserver.geofence.config.GeoFenceConfiguration.setGrantWriteToWorkspacesToAuthenticatedUsers",
	"Comment": "allows write access to resources to authenticated users, if false only admins have writeaccess.",
	"Method": "void setGrantWriteToWorkspacesToAuthenticatedUsers(boolean grantWriteToWorkspacesToAuthenticatedUsers){\r\n    this.grantWriteToWorkspacesToAuthenticatedUsers = grantWriteToWorkspacesToAuthenticatedUsers;\r\n}"
}, {
	"Path": "org.geoserver.rest.util.RESTUtils.handleURLUpload",
	"Comment": "reads a url from the body of a request, reads the contents of the url and writes it to afile.",
	"Method": "org.geoserver.platform.resource.Resource handleURLUpload(String fileName,String workSpace,org.geoserver.platform.resource.Resource directory,HttpServletRequest request){\r\n    StringBuilder itemPath = new StringBuilder(fileName);\r\n    MediaType mediaType = request.getContentType() != null ? MediaType.valueOf(request.getContentType()) : null;\r\n    if (mediaType == null || !isZipMediaType(mediaType)) {\r\n        String baseName = FilenameUtils.getBaseName(fileName);\r\n        Map<String, String> storeParams = new HashMap();\r\n        String itemName = FilenameUtils.getName(fileName);\r\n        remapping(workSpace, baseName, itemPath, itemName, storeParams);\r\n    }\r\n    org.geoserver.platform.resource.Resource newFile = directory.get(itemPath.toString());\r\n    final InputStream inStream = request.getInputStream();\r\n    final String stringURL = IOUtils.getStringFromStream(inStream);\r\n    final URL fileURL = new URL(stringURL);\r\n    final InputStream inputStream = fileURL.openStream();\r\n    final OutputStream outStream = newFile.out();\r\n    IOUtils.copyStream(inputStream, outStream, true, true);\r\n    return newFile;\r\n}"
}, {
	"Path": "org.geoserver.wcs2_0.response.WCSDefaultValuesHelper.setFilters",
	"Comment": "setup filter query on top of specified subsets values to return only granules satisfying thespecified conditions.",
	"Method": "Filter setFilters(Filter originalFilter,DateRange temporalSubset,NumberRange<?> elevationSubset,Envelope envelopeSubset,Map<String, List<Object>> dimensionSubset,StructuredGridCoverage2DReader reader,DimensionDescriptor timeDimension,DimensionDescriptor elevationDimension,List<DimensionDescriptor> additionalDimensions){\r\n    List<Filter> filters = new ArrayList<Filter>();\r\n    Filter timeFilter = temporalSubset == null && timeDimension == null ? null : setTimeFilter(temporalSubset, timeDimension.getStartAttribute(), timeDimension.getEndAttribute());\r\n    Filter elevationFilter = elevationSubset == null && elevationDimension == null ? null : setElevationFilter(elevationSubset, elevationDimension.getStartAttribute(), elevationDimension.getEndAttribute());\r\n    Filter envelopeFilter = setEnevelopeFilter(envelopeSubset, reader);\r\n    Filter additionalDimensionsFilter = setAdditionalDimensionsFilter(dimensionSubset, additionalDimensions);\r\n    if (originalFilter != null) {\r\n        filters.add(originalFilter);\r\n    }\r\n    if (elevationFilter != null) {\r\n        filters.add(elevationFilter);\r\n    }\r\n    if (timeFilter != null) {\r\n        filters.add(timeFilter);\r\n    }\r\n    if (envelopeFilter != null) {\r\n        filters.add(envelopeFilter);\r\n    }\r\n    if (additionalDimensionsFilter != null) {\r\n        filters.add(additionalDimensionsFilter);\r\n    }\r\n    Filter finalFilter = FF.and(filters);\r\n    return finalFilter;\r\n}"
}, {
	"Path": "org.geoserver.wfs.xslt.config.TransformRepository.getTransformName",
	"Comment": "the transform name is the same as the config file, minus the extension",
	"Method": "String getTransformName(Resource file){\r\n    String name = file.name();\r\n    int idx = name.indexOf(\".\");\r\n    if (idx > 0) {\r\n        return name.substring(0, idx);\r\n    } else {\r\n        return name;\r\n    }\r\n}"
}]