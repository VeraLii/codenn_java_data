[{
	"Path": "com.graphhopper.routing.DijkstraBidirectionRefTest.configs",
	"Comment": "runs the same test with each of the supported traversal modes",
	"Method": "Collection<Object[]> configs(){\r\n    return Arrays.asList(new Object[][] { { TraversalMode.NODE_BASED }, { TraversalMode.EDGE_BASED_1DIR }, { TraversalMode.EDGE_BASED_2DIR }, { TraversalMode.EDGE_BASED_2DIR_UTURN } });\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.getLocker",
	"Comment": "returns the locker associated with this runtime. the locker allowsthreads to give up control of the runtime and other threads to acquirecontrol.",
	"Method": "V8Locker getLocker(){\r\n    return locker;\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.BikeCommonFlagEncoder.handlePriority",
	"Comment": "in this method we prefer cycleways or roads with designated bike access and avoid big roadsor roads with trams or pedestrian.",
	"Method": "int handlePriority(ReaderWay way,double wayTypeSpeed,int priorityFromRelation){\r\n    TreeMap<Double, Integer> weightToPrioMap = new TreeMap();\r\n    if (priorityFromRelation == 0)\r\n        weightToPrioMap.put(0d, UNCHANGED.getValue());\r\n    else\r\n        weightToPrioMap.put(110d, priorityFromRelation);\r\n    collect(way, wayTypeSpeed, weightToPrioMap);\r\n    return weightToPrioMap.lastEntry().getValue();\r\n}"
}, {
	"Path": "org.javaee7.cdi.instance.GreetingTest.test",
	"Comment": "only instance of simplegreeting class should be available.\twhen dependent scoped bean is retrieved via an instance then explicit destroy action should be taken.\tthis is a known memory leak in cdi 1.0 fixed in cdi 1.1 see the link bellow for details.",
	"Method": "void test(){\r\n    assertFalse(instance.isUnsatisfied());\r\n    assertFalse(instance.isAmbiguous());\r\n    Greeting bean = instance.get();\r\n    assertThat(bean, instanceOf(SimpleGreeting.class));\r\n    instance.destroy(bean);\r\n    Instance<Greeting> anotherInstance = instance.select(new AnnotationLiteral<Default>() {\r\n    });\r\n    Greeting anotherBean = anotherInstance.get();\r\n    assertThat(anotherBean, instanceOf(SimpleGreeting.class));\r\n    anotherInstance.destroy(anotherBean);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.Graphics2DRenderer.renderToImage",
	"Comment": "a static utility method to automatically create an image from adocument. the buffered image type must be specified.",
	"Method": "BufferedImage renderToImage(String url,int width,int height,BufferedImage renderToImage,String url,int width,int height,int bufferedImageType){\r\n    Graphics2DRenderer g2r = new Graphics2DRenderer();\r\n    g2r.setDocument(url);\r\n    Dimension dim = new Dimension(width, height);\r\n    BufferedImage buff = new BufferedImage((int) dim.getWidth(), (int) dim.getHeight(), bufferedImageType);\r\n    Graphics2D g = (Graphics2D) buff.getGraphics();\r\n    g2r.layout(g, dim);\r\n    g2r.render(g);\r\n    g.dispose();\r\n    return buff;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.constants.CSSName.addProperty",
	"Comment": "adds a feature to the property attribute of the cssname class",
	"Method": "CSSName addProperty(String propName,Object type,String initialValue,Object inherit,PropertyBuilder builder,CSSName addProperty,String propName,Object type,String initialValue,Object inherit,boolean implemented,PropertyBuilder builder){\r\n    CSSName cssName = new CSSName(propName, initialValue, (inherit == INHERITS), implemented, builder);\r\n    ALL_PROPERTY_NAMES.put(propName, cssName);\r\n    if (type == PRIMITIVE) {\r\n        ALL_PRIMITIVE_PROPERTY_NAMES.put(propName, cssName);\r\n    }\r\n    return cssName;\r\n}"
}, {
	"Path": "com.spotify.helios.servicescommon.ServiceRegistrars.createServiceRegistrar",
	"Comment": "create a registrar. attempts to load it from a plugin if path is not null or using the appclass loader otherwise. if no registrar plugin was found, returns a nop registrar.",
	"Method": "ServiceRegistrar createServiceRegistrar(Path path,String address,String domain){\r\n    final ServiceRegistrarFactory factory;\r\n    if (path == null) {\r\n        factory = createFactory();\r\n    } else {\r\n        factory = createFactory(path);\r\n    }\r\n    if (address != null) {\r\n        log.info(\"Creating service registrar with address: {}\", address);\r\n        return factory.create(address);\r\n    } else if (!Strings.isNullOrEmpty(domain)) {\r\n        log.info(\"Creating service registrar for domain: {}\", domain);\r\n        return domain.equals(\"localhost\") ? factory.create(\"tcp://localhost:4999\") : factory.createForDomain(domain);\r\n    } else {\r\n        log.info(\"No address nor domain configured, not creating service registrar.\");\r\n        return new NopServiceRegistrar();\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.debug.DebugHandler.removeBreakHandler",
	"Comment": "removes a handler from the list of breakpoint handlers.if the handler is not present in the list, the list is unchanged.",
	"Method": "void removeBreakHandler(BreakHandler handler){\r\n    runtime.getLocker().checkThread();\r\n    breakHandlers.remove(handler);\r\n}"
}, {
	"Path": "com.spotify.helios.master.ZooKeeperMasterModel.removeJob",
	"Comment": "deletes a job from zookeeper.ensures that job is not currently running anywhere.",
	"Method": "Job removeJob(JobId jobId,Job removeJob,JobId id,String token){\r\n    log.info(\"removing job: id={}\", id);\r\n    final ZooKeeperClient client = provider.get(\"removeJob\");\r\n    final Job job = getJob(client, id);\r\n    if (job == null) {\r\n        throw new JobDoesNotExistException(id);\r\n    }\r\n    verifyToken(token, job);\r\n    try {\r\n        final ImmutableList.Builder<ZooKeeperOperation> operations = ImmutableList.builder();\r\n        final UUID jobCreationOperationId = getJobCreation(client, id);\r\n        if (jobCreationOperationId != null) {\r\n            operations.add(delete(Paths.configJobCreation(id, jobCreationOperationId)));\r\n        }\r\n        // change down the tree. Effectively, make it that version == cVersion.\r\n        operations.add(// change down the tree. Effectively, make it that version == cVersion.\r\n        delete(Paths.configJobHosts(id)), // change down the tree. Effectively, make it that version == cVersion.\r\n        delete(Paths.configJobRefShort(id)), delete(Paths.configJob(id)), set(Paths.configJobs(), UUID.randomUUID().toString().getBytes()));\r\n        client.transaction(operations.build());\r\n    } catch (final NoNodeException e) {\r\n        throw new JobDoesNotExistException(id);\r\n    } catch (final NotEmptyException e) {\r\n        throw new JobStillDeployedException(id, listJobHosts(client, id));\r\n    } catch (final KeeperException e) {\r\n        throw new HeliosRuntimeException(\"removing job \" + id + \" failed\", e);\r\n    }\r\n    try {\r\n        client.deleteRecursive(Paths.historyJob(id));\r\n    } catch (NoNodeException ignored) {\r\n    } catch (KeeperException e) {\r\n        log.warn(\"error removing job history for job {}\", id, e);\r\n    }\r\n    return job;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.RootPanel.removeDocumentListener",
	"Comment": "removes the specified document listener from receive document events from thiscomponent. if listener l is null, no exception is thrown and no action isperformed.",
	"Method": "void removeDocumentListener(DocumentListener listener){\r\n    if (listener == null) {\r\n        return;\r\n    }\r\n    documentListeners.remove(listener);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.layout.SharedContext.setMedia",
	"Comment": "set the current media type. this is usually something like screenor print . see the media section of the css 2.1 spec for more information on mediatypes.",
	"Method": "void setMedia(String media){\r\n    this.media = media;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.newmatch.Matcher.getPECascadedStyle",
	"Comment": "may return null.we assume that restyle has already been done by a getcascadedstyle if necessary.",
	"Method": "CascadedStyle getPECascadedStyle(Object e,String pseudoElement,CascadedStyle getPECascadedStyle,Object e,String pseudoElement){\r\n    synchronized (e) {\r\n        Mapper em = getMapper(e);\r\n        return em.getPECascadedStyle(e, pseudoElement);\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.demo.browser.BrowserStartup.initUI",
	"Comment": "initializes all ui components but does not display frame and does not load any pages.",
	"Method": "void initUI(){\r\n    if (GeneralUtil.isMacOSX()) {\r\n        try {\r\n            System.setProperty(\"apple.laf.useScreenMenuBar\", \"true\");\r\n            System.setProperty(\"com.apple.mrj.application.apple.menu.about.name\", \"FS Browser\");\r\n        } catch (Exception ex) {\r\n            try {\r\n                logger.log(Level.SEVERE, \"error initalizing the mac properties\", ex);\r\n            } catch (Exception ex2) {\r\n            }\r\n        }\r\n    } else {\r\n        setLookAndFeel();\r\n    }\r\n    JFrame frame = new JFrame();\r\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n    this.frame = frame;\r\n    logger.info(\"creating UI\");\r\n    actions = new BrowserActions(this);\r\n    actions.init();\r\n    panel = new BrowserPanel(this, new FrameBrowserPanelListener());\r\n    panel.init();\r\n    panel.createActions();\r\n    menu = new BrowserMenuBar(this);\r\n    menu.init();\r\n    menu.createLayout();\r\n    menu.createActions();\r\n    frame.setJMenuBar(menu);\r\n    frame.getContentPane().add(panel.toolbar, BorderLayout.PAGE_START);\r\n    frame.getContentPane().add(panel, BorderLayout.CENTER);\r\n    panel.setBorder(new EtchedBorder(EtchedBorder.LOWERED));\r\n    frame.getContentPane().add(panel.status, BorderLayout.PAGE_END);\r\n    frame.pack();\r\n    frame.setSize(1024, 768);\r\n}"
}, {
	"Path": "com.spotify.helios.cli.CliParser.handleError",
	"Comment": "use this instead of calling parser.handle error directly. this will print a header withlinks to jira and documentation before the standard error message is printed.",
	"Method": "void handleError(ArgumentParser parser,ArgumentParserException ex){\r\n    System.err.println(\"# \" + HELP_ISSUES);\r\n    System.err.println(\"# \" + HELP_WIKI);\r\n    System.err.println(\"# ---------------------------------------------------------------\");\r\n    parser.handleError(ex);\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeInjectActuatorTest.SameTokenNameOpenSuccessExchangeInject",
	"Comment": "sametokenname open, first inject exchange,result is success.",
	"Method": "void SameTokenNameOpenSuccessExchangeInject(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    InitExchangeSameTokenNameActive();\r\n    long exchangeId = 1;\r\n    String firstTokenId = \"123\";\r\n    long firstTokenQuant = 200000000L;\r\n    String secondTokenId = \"456\";\r\n    long secondTokenQuant = 400000000L;\r\n    AssetIssueCapsule assetIssueCapsule1 = new AssetIssueCapsule(AssetIssueContract.newBuilder().setName(ByteString.copyFrom(firstTokenId.getBytes())).build());\r\n    assetIssueCapsule1.setId(String.valueOf(1L));\r\n    dbManager.getAssetIssueStore().put(assetIssueCapsule1.getName().toByteArray(), assetIssueCapsule1);\r\n    AssetIssueCapsule assetIssueCapsule2 = new AssetIssueCapsule(AssetIssueContract.newBuilder().setName(ByteString.copyFrom(secondTokenId.getBytes())).build());\r\n    assetIssueCapsule2.setId(String.valueOf(2L));\r\n    dbManager.getAssetIssueStore().put(assetIssueCapsule2.getName().toByteArray(), assetIssueCapsule2);\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmountV2(firstTokenId.getBytes(), firstTokenQuant, dbManager);\r\n    accountCapsule.addAssetAmountV2(secondTokenId.getBytes(), secondTokenQuant, dbManager);\r\n    accountCapsule.setBalance(10000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeInjectActuator actuator = new ExchangeInjectActuator(getContract(OWNER_ADDRESS_FIRST, exchangeId, firstTokenId, firstTokenQuant), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        Assert.assertEquals(ret.getInstance().getRet(), code.SUCESS);\r\n        long id = 1;\r\n        ExchangeCapsule exchangeCapsuleV2 = dbManager.getExchangeV2Store().get(ByteArray.fromLong(id));\r\n        Assert.assertNotNull(exchangeCapsuleV2);\r\n        Assert.assertEquals(ByteString.copyFrom(ownerAddress), exchangeCapsuleV2.getCreatorAddress());\r\n        Assert.assertEquals(id, exchangeCapsuleV2.getID());\r\n        Assert.assertEquals(1000000, exchangeCapsuleV2.getCreateTime());\r\n        Assert.assertTrue(Arrays.equals(firstTokenId.getBytes(), exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenId, ByteArray.toStr(exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(300000000L, exchangeCapsuleV2.getFirstTokenBalance());\r\n        Assert.assertEquals(secondTokenId, ByteArray.toStr(exchangeCapsuleV2.getSecondTokenId()));\r\n        Assert.assertEquals(600000000L, exchangeCapsuleV2.getSecondTokenBalance());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        Map<String, Long> assetV2Map = accountCapsule.getAssetMapV2();\r\n        Assert.assertEquals(10000_000000L, accountCapsule.getBalance());\r\n        Assert.assertEquals(0L, assetV2Map.get(firstTokenId).longValue());\r\n        Assert.assertEquals(0L, assetV2Map.get(secondTokenId).longValue());\r\n    } catch (ContractValidateException e) {\r\n        logger.info(e.getMessage());\r\n        Assert.assertFalse(e instanceof ContractValidateException);\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    } catch (ItemNotFoundException e) {\r\n        Assert.assertFalse(e instanceof ItemNotFoundException);\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.AbstractFlagEncoder.setBlockByDefault",
	"Comment": "should potential barriers block when no access limits are given?",
	"Method": "void setBlockByDefault(boolean blockByDefault){\r\n    this.blockByDefault = blockByDefault;\r\n}"
}, {
	"Path": "com.spotify.helios.cli.command.JobCreateCommand.defaultMetadata",
	"Comment": "metadata to associate with jobs by default. currently sets some metadata based upon environmentvariables set when the cli command is run.",
	"Method": "Map<String, String> defaultMetadata(){\r\n    final Builder<String, String> builder = ImmutableMap.builder();\r\n    final Map<String, String> envVars = envVarSupplier.get();\r\n    for (final Map.Entry<String, String> entry : DEFAULT_METADATA_ENVVARS.entrySet()) {\r\n        final String envKey = entry.getKey();\r\n        final String metadataKey = entry.getValue();\r\n        final String envValue = envVars.get(envKey);\r\n        if (envValue != null) {\r\n            builder.put(metadataKey, envValue);\r\n        }\r\n    }\r\n    return builder.build();\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.constants.CSSName.compareTo",
	"Comment": "assumed to be consistent with equals because cssname is in essence an enum",
	"Method": "int compareTo(Object object){\r\n    if (object == null)\r\n        throw new NullPointerException();\r\n    return FS_ID - ((CSSName) object).FS_ID;\r\n}"
}, {
	"Path": "org.tron.core.actuator.TransferAssetActuatorTest.SameTokenNameOpenInvalidOwnerAddress",
	"Comment": "sametokenname open,invalid owneraddress,result is error",
	"Method": "void SameTokenNameOpenInvalidOwnerAddress(){\r\n    createAssertSameTokenNameActive();\r\n    TransferAssetActuator actuator = new TransferAssetActuator(getContract(100L, OWNER_ADDRESS_INVALID, TO_ADDRESS), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail(\"Invalid ownerAddress\");\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"Invalid ownerAddress\", e.getMessage());\r\n        AccountCapsule owner = dbManager.getAccountStore().get(ByteArray.fromHexString(OWNER_ADDRESS));\r\n        AccountCapsule toAccount = dbManager.getAccountStore().get(ByteArray.fromHexString(TO_ADDRESS));\r\n        long tokenIdNum = dbManager.getDynamicPropertiesStore().getTokenIdNum();\r\n        Assert.assertEquals(owner.getAssetMapV2().get(String.valueOf(tokenIdNum)).longValue(), OWNER_ASSET_BALANCE);\r\n        Assert.assertTrue(isNullOrZero(toAccount.getAssetMapV2().get(String.valueOf(tokenIdNum))));\r\n    } catch (ContractExeException e) {\r\n        Assert.assertTrue(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.Configuration.valueAsChar",
	"Comment": "returns the value for key in the configuration as a character, or adefault value if not found. a warning is issued to the log if theproperty is not defined, or if the configuration value is too longto be a char. if the configuration value is longer than a singlecharacter, only the first character is returned.",
	"Method": "char valueAsChar(String key,char defaultVal){\r\n    String val = valueFor(key);\r\n    if (val == null) {\r\n        return defaultVal;\r\n    }\r\n    if (val.length() > 1) {\r\n        XRLog.exception(\"Property '\" + key + \"' was requested as a character. The value of '\" + val + \"' is too long to be a char. Returning only the first character.\");\r\n    }\r\n    return val.charAt(0);\r\n}"
}, {
	"Path": "com.graphhopper.storage.GraphHopperStorage.create",
	"Comment": "after configuring this storage you need to create it explicitly.",
	"Method": "GraphHopperStorage create(long byteCount){\r\n    baseGraph.checkInit();\r\n    if (encodingManager == null)\r\n        throw new IllegalStateException(\"EncodingManager can only be null if you call loadExisting\");\r\n    dir.create();\r\n    long initSize = Math.max(byteCount, 100);\r\n    properties.create(100);\r\n    properties.put(\"graph.bytes_for_flags\", encodingManager.getBytesForFlags());\r\n    properties.put(\"graph.flag_encoders\", encodingManager.toDetailsString());\r\n    properties.put(\"graph.byte_order\", dir.getByteOrder());\r\n    properties.put(\"graph.dimension\", baseGraph.nodeAccess.getDimension());\r\n    properties.putCurrentVersions();\r\n    baseGraph.create(initSize);\r\n    for (CHGraphImpl cg : chGraphs) {\r\n        cg.create(byteCount);\r\n    }\r\n    properties.put(\"graph.ch.weightings\", getCHWeightings().toString());\r\n    return this;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Object.getObject",
	"Comment": "returns the v8object value associated with this key. if the valueassociated with this key does not exist then undefined is returned.if the value exists but is not an js object thenv8resultundefined exception is thrown.",
	"Method": "V8Object getObject(String key,V8Object getObject,String key){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    checkKey(key);\r\n    Object result = v8.get(v8.getV8RuntimePtr(), V8_OBJECT, objectHandle, key);\r\n    if ((result == null) || (result instanceof V8Object)) {\r\n        return (V8Object) result;\r\n    }\r\n    throw new V8ResultUndefined();\r\n}"
}, {
	"Path": "org.tron.common.crypto.ECKey.getNodeId",
	"Comment": "generates the nodeid based on this key, that is the public key without first format byte",
	"Method": "byte[] getNodeId(){\r\n    if (nodeId == null) {\r\n        nodeId = pubBytesWithoutFormat(this.pub);\r\n    }\r\n    return nodeId;\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.getOpenProfileAnimatorSet",
	"Comment": "this method creates if needed the set of transition animations, which show profile toolbar and profiledetails views, right after the passed delay.",
	"Method": "AnimatorSet getOpenProfileAnimatorSet(int profileDetailsAnimationDelay){\r\n    if (mOpenProfileAnimatorSet == null) {\r\n        List<Animator> profileAnimators = new ArrayList();\r\n        profileAnimators.add(getOpenProfileToolbarAnimator());\r\n        profileAnimators.add(getOpenProfileDetailsAnimator());\r\n        mOpenProfileAnimatorSet = new AnimatorSet();\r\n        mOpenProfileAnimatorSet.playTogether(profileAnimators);\r\n        mOpenProfileAnimatorSet.setDuration(getAnimationDurationShowProfileDetails());\r\n    }\r\n    mOpenProfileAnimatorSet.setStartDelay(profileDetailsAnimationDelay);\r\n    mOpenProfileAnimatorSet.setInterpolator(new DecelerateInterpolator());\r\n    return mOpenProfileAnimatorSet;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.XHTMLPanel.getMaxFontScale",
	"Comment": "returns the maximum font scaling that may be applied, e.g. 3 times assigned font size.",
	"Method": "float getMaxFontScale(){\r\n    return maxFontScale;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swt.BasicRenderer.getMinFontScale",
	"Comment": "returns the minimum font scaling that may be applied, e.g. 0.5 timesassigned font size.",
	"Method": "float getMinFontScale(){\r\n    return _minFontScale;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.context.AWTFontResolver.getFontInstanceHashName",
	"Comment": "gets the fontinstancehashname attribute of the fontresolvertest object",
	"Method": "String getFontInstanceHashName(SharedContext ctx,String name,float size,IdentValue weight,IdentValue style,IdentValue variant){\r\n    return name + \"-\" + (size * ctx.getTextRenderer().getFontScale()) + \"-\" + weight + \"-\" + style + \"-\" + variant;\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.JavaOutput.flush",
	"Comment": "flush any incomplete last line, then add the eof token into our data structures.",
	"Method": "void flush(){\r\n    String lastLine = lineBuilder.toString();\r\n    if (!CharMatcher.whitespace().matchesAllOf(lastLine)) {\r\n        mutableLines.add(lastLine);\r\n    }\r\n    int jN = mutableLines.size();\r\n    Range<Integer> eofRange = Range.closedOpen(kN, kN + 1);\r\n    while (ranges.size() < jN) {\r\n        ranges.add(Formatter.EMPTY_RANGE);\r\n    }\r\n    ranges.add(eofRange);\r\n    setLines(ImmutableList.copyOf(mutableLines));\r\n}"
}, {
	"Path": "org.fnlp.nlp.langmodel.lda.LdaGibbsSampler.updateParams",
	"Comment": "add to the statistics the values of theta and phi for the current state.",
	"Method": "void updateParams(){\r\n    for (int m = 0; m < documents.length; m++) {\r\n        for (int k = 0; k < K; k++) {\r\n            thetasum[m][k] += (nd[m][k] + alpha) / (ndsum[m] + K * alpha);\r\n        }\r\n    }\r\n    for (int k = 0; k < K; k++) {\r\n        for (int w = 0; w < V; w++) {\r\n            phisum[k][w] += (word_topic_matrix[w][k] + beta) / (nwsum[k] + V * beta);\r\n        }\r\n    }\r\n    numstats++;\r\n}"
}, {
	"Path": "com.graphhopper.routing.AStarBidirectionTest.configs",
	"Comment": "runs the same test with each of the supported traversal modes",
	"Method": "Collection<Object[]> configs(){\r\n    return Arrays.asList(new Object[][] { { TraversalMode.NODE_BASED }, { TraversalMode.EDGE_BASED_1DIR }, { TraversalMode.EDGE_BASED_2DIR }, { TraversalMode.EDGE_BASED_2DIR_UTURN } });\r\n}"
}, {
	"Path": "org.xhtmlrenderer.context.StandardAttributeResolver.getElementStyling",
	"Comment": "gets the elementstyling attribute of the standardattributeresolver object",
	"Method": "String getElementStyling(Object e){\r\n    return nsh.getElementStyling((Element) e);\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.MotorcycleFlagEncoder.correctErrors",
	"Comment": "a really small bendiness or a bendiness greater than 1 indicates an error in the calculation.just ignore them. we use bendiness greater 1.2 since the beelinedistance is onlyapproximated, therefore it can happen on straight roads, that the beeline is longer than theroad.",
	"Method": "double correctErrors(double bendiness){\r\n    if (bendiness < 0.01 || bendiness > 1) {\r\n        return 1;\r\n    }\r\n    return bendiness;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.SwingReplacedElementFactory.getForm",
	"Comment": "returns the xhtmlform associated with an element in cache, or null if not found.",
	"Method": "XhtmlForm getForm(Element e){\r\n    if (forms == null) {\r\n        return null;\r\n    }\r\n    return (XhtmlForm) forms.get(e);\r\n}"
}, {
	"Path": "com.graphhopper.coll.SparseIntIntArray.put",
	"Comment": "adds a mapping from the specified key to the specified value, replacing the previous mappingfrom the specified key if there was one.",
	"Method": "int put(int key,int value){\r\n    int i = binarySearch(mKeys, 0, mSize, key);\r\n    if (i >= 0) {\r\n        mValues[i] = value;\r\n    } else {\r\n        i = ~i;\r\n        if (i < mSize && mValues[i] == DELETED) {\r\n            mKeys[i] = key;\r\n            mValues[i] = value;\r\n            return i;\r\n        }\r\n        if (mGarbage && mSize >= mKeys.length) {\r\n            gc();\r\n            i = ~binarySearch(mKeys, 0, mSize, key);\r\n        }\r\n        if (mSize >= mKeys.length) {\r\n            int n = Helper.idealIntArraySize(mSize + 1);\r\n            int[] nkeys = new int[n];\r\n            int[] nvalues = new int[n];\r\n            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);\r\n            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);\r\n            mKeys = nkeys;\r\n            mValues = nvalues;\r\n        }\r\n        if (mSize - i != 0) {\r\n            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);\r\n            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);\r\n        }\r\n        mKeys[i] = key;\r\n        mValues[i] = value;\r\n        mSize++;\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeWithdrawActuatorTest.SameTokenNameOpenTokenQuantLessThanZero",
	"Comment": "sametokenname open, withdraw token quant must greater than zero",
	"Method": "void SameTokenNameOpenTokenQuantLessThanZero(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    InitExchangeSameTokenNameActive();\r\n    long exchangeId = 1;\r\n    String firstTokenId = \"123\";\r\n    long firstTokenQuant = -1L;\r\n    String secondTokenId = \"456\";\r\n    long secondTokenQuant = 400000000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmountV2(firstTokenId.getBytes(), 1000L, dbManager);\r\n    accountCapsule.addAssetAmountV2(secondTokenId.getBytes(), secondTokenQuant, dbManager);\r\n    accountCapsule.setBalance(10000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeWithdrawActuator actuator = new ExchangeWithdrawActuator(getContract(OWNER_ADDRESS_FIRST, exchangeId, firstTokenId, firstTokenQuant), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"withdraw token quant must greater than zero\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "org.tron.common.crypto.ECKey.verify",
	"Comment": "verifies the given asn.1 encoded ecdsa signature against a hash using the public key.",
	"Method": "boolean verify(byte[] data,ECDSASignature signature,byte[] pub,boolean verify,byte[] data,byte[] signature,byte[] pub,boolean verify,byte[] data,byte[] signature,boolean verify,byte[] sigHash,ECDSASignature signature){\r\n    return ECKey.verify(sigHash, signature, getPubKey());\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeInjectActuatorTest.SameTokenNameOpenTokenBalanceGreaterThanBalanceLimit",
	"Comment": "sametokenname open, token balance must less than balancelimit",
	"Method": "void SameTokenNameOpenTokenBalanceGreaterThanBalanceLimit(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    InitExchangeSameTokenNameActive();\r\n    long exchangeId = 2;\r\n    String firstTokenId = \"_\";\r\n    long firstTokenQuant = 1_000_000_000_000_001L;\r\n    String secondTokenId = \"456\";\r\n    long secondTokenQuant = 400000000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmountV2(secondTokenId.getBytes(), secondTokenQuant, dbManager);\r\n    accountCapsule.setBalance(firstTokenQuant);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeInjectActuator actuator = new ExchangeInjectActuator(getContract(OWNER_ADDRESS_FIRST, exchangeId, firstTokenId, firstTokenQuant), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"token balance must less than 1000000000000000\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "com.spotify.helios.testing.JobPrefixFile.deleteIfExists",
	"Comment": "helper method to delete file if it exists. this will not thrown an exception.",
	"Method": "void deleteIfExists(Path file){\r\n    if (file != null) {\r\n        try {\r\n            Files.deleteIfExists(file);\r\n        } catch (Exception e) {\r\n            log.warn(\"Failed to delete file {}\", file, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.context.StandardAttributeResolver.isActive",
	"Comment": "gets the active attribute of the standardattributeresolver object",
	"Method": "boolean isActive(Object e){\r\n    return ui.isActive((Element) e);\r\n}"
}, {
	"Path": "com.graphhopper.util.details.AbstractPathDetailsBuilder.endInterval",
	"Comment": "ending intervals multiple times is safe, we only write the interval if it was open and not empty.writes the interval to the pathdetails",
	"Method": "void endInterval(int lastIndex){\r\n    if (isOpen) {\r\n        currentDetail.setLast(lastIndex);\r\n        pathDetails.add(currentDetail);\r\n    }\r\n    isOpen = false;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.style.CalculatedStyle.deriveStyle",
	"Comment": "derives a child style from this style.depends on the ability to return the identical cascadedstyle each time a child style is needed",
	"Method": "CalculatedStyle deriveStyle(CascadedStyle matched){\r\n    String fingerprint = matched.getFingerprint();\r\n    CalculatedStyle cs = (CalculatedStyle) _childCache.get(fingerprint);\r\n    if (cs == null) {\r\n        cs = new CalculatedStyle(this, matched);\r\n        _childCache.put(fingerprint, cs);\r\n    }\r\n    return cs;\r\n}"
}, {
	"Path": "com.notnoop.apns.ApnsServiceBuilder.withProxySocket",
	"Comment": "specify the socket to be used as underlying socket to connectto the apn service.this assumes that the socket connects to a socks proxy.",
	"Method": "ApnsServiceBuilder withProxySocket(Socket proxySocket){\r\n    return this.withProxy(new Proxy(Proxy.Type.SOCKS, proxySocket.getRemoteSocketAddress()));\r\n}"
}, {
	"Path": "com.eclipsesource.v8.NodeJS.getNodeVersion",
	"Comment": "returns the version of node.js that is runtime is built against.this uses process.versions.node to get the version.",
	"Method": "String getNodeVersion(){\r\n    if (nodeVersion != null) {\r\n        return nodeVersion;\r\n    }\r\n    V8Object process = null;\r\n    V8Object versions = null;\r\n    try {\r\n        process = v8.getObject(PROCESS);\r\n        versions = process.getObject(VERSIONS);\r\n        nodeVersion = versions.getString(NODE);\r\n    } finally {\r\n        safeRelease(process);\r\n        safeRelease(versions);\r\n    }\r\n    return nodeVersion;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.ImageLoadQueue.kill",
	"Comment": "indicates that no more items will be added to the queue, no more items currently in the queue will be loaded,and that worker threads polling this queue should shut down.",
	"Method": "void kill(){\r\n    _loadQueue.addLast(KILL_SWITCH);\r\n    notifyAll();\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.HoverListener.getHoveredElement",
	"Comment": "look up the element that corresponds to the box we are hovering over",
	"Method": "Element getHoveredElement(StyleReference style,Box ib){\r\n    if (ib == null) {\r\n        return null;\r\n    }\r\n    Element element = ib.getElement();\r\n    while (element != null && !style.isHoverStyled(element)) {\r\n        Node node = element.getParentNode();\r\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\r\n            element = (Element) node;\r\n        } else {\r\n            element = null;\r\n        }\r\n    }\r\n    return element;\r\n}"
}, {
	"Path": "com.spotify.helios.master.resources.VersionResource.versionCheck",
	"Comment": "given the client version, returns the version status, i.e. whether or not they should becompatible or not.",
	"Method": "VersionCheckResponse versionCheck(String client){\r\n    final PomVersion serverVersion = PomVersion.parse(Version.POM_VERSION);\r\n    final VersionCompatibility.Status status;\r\n    if (isNullOrEmpty(client)) {\r\n        return new VersionCheckResponse(VersionCompatibility.Status.MISSING, serverVersion, Version.RECOMMENDED_VERSION);\r\n    }\r\n    final PomVersion clientVersion = PomVersion.parse(client);\r\n    status = VersionCompatibility.getStatus(serverVersion, clientVersion);\r\n    return new VersionCheckResponse(status, serverVersion, Version.RECOMMENDED_VERSION);\r\n}"
}, {
	"Path": "com.notnoop.apns.PayloadBuilder.buildBytes",
	"Comment": "returns the bytes representation of the payload according toapple apns specification",
	"Method": "byte[] buildBytes(){\r\n    return Utilities.toUTF8Bytes(build());\r\n}"
}, {
	"Path": "com.eclipsesource.v8.debug.ScriptBreakPoint.setCondition",
	"Comment": "sets a condition to be evaluated before determining ifthe breakpoint event should be fired.",
	"Method": "void setCondition(String condition){\r\n    V8Array parameters = new V8Array(v8Object.getRuntime());\r\n    parameters.push(condition);\r\n    try {\r\n        v8Object.executeVoidFunction(SET_CONDITION, parameters);\r\n    } finally {\r\n        parameters.close();\r\n    }\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.animateCloseProfileDetails",
	"Comment": "this method starts set of transition animations, which hides profile toolbar, profile avatarand profile details views.",
	"Method": "void animateCloseProfileDetails(){\r\n    mState = EuclidState.Closing;\r\n    getCloseProfileAnimatorSet().start();\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.newmatch.Selector.getElementStylingOrder",
	"Comment": "gets the elementstylingorder attribute of the selector class",
	"Method": "String getElementStylingOrder(){\r\n    return \"1\" + \"000\" + \"000\" + \"000\" + \"00000\";\r\n}"
}, {
	"Path": "com.spotify.helios.master.resources.HostsResource.delete",
	"Comment": "deregisters the host from the cluster.will delete just about everything the cluster knowsabout it.",
	"Method": "HostDeregisterResponse delete(String host){\r\n    try {\r\n        model.deregisterHost(host);\r\n        return new HostDeregisterResponse(HostDeregisterResponse.Status.OK, host);\r\n    } catch (HostNotFoundException e) {\r\n        throw notFound(new HostDeregisterResponse(HostDeregisterResponse.Status.NOT_FOUND, host));\r\n    } catch (HostStillInUseException e) {\r\n        throw badRequest(new HostDeregisterResponse(HostDeregisterResponse.Status.JOBS_STILL_DEPLOYED, host));\r\n    }\r\n}"
}, {
	"Path": "org.tron.common.crypto.ECKey.isPubKeyCanonical",
	"Comment": "returns true if this pubkey is canonical, i.e. the correct length taking into accountcompression.",
	"Method": "boolean isPubKeyCanonical(byte[] pubkey,boolean isPubKeyCanonical){\r\n    return isPubKeyCanonical(pub.getEncoded(false));\r\n}"
}, {
	"Path": "org.xhtmlrenderer.context.StylesheetFactoryImpl.putStylesheet",
	"Comment": "adds a stylesheet to the factory cache. will overwrite older entry forsame key.",
	"Method": "void putStylesheet(Object key,Stylesheet sheet){\r\n    _cache.put(key, sheet);\r\n}"
}, {
	"Path": "com.spotify.helios.common.descriptors.RolloutOptionsTest.testCanDeserializeWithoutIgnoreFailuresField",
	"Comment": "test that a json representing a rolloutoptions instance prior to the addition of theignorefailures field can be deserialized properly.",
	"Method": "void testCanDeserializeWithoutIgnoreFailuresField(){\r\n    final ObjectMapper mapper = new ObjectMapper();\r\n    final ObjectNode node = mapper.createObjectNode().put(\"migrate\", false).put(\"parallalism\", 2).put(\"timeout\", 1000).put(\"overlap\", true).put(\"token\", \"blah\");\r\n    final RolloutOptions options = Json.read(node.toString(), RolloutOptions.class);\r\n    assertThat(\"RolloutOptions.ignoreFailures should default to null\", options.getIgnoreFailures(), is(nullValue()));\r\n}"
}, {
	"Path": "com.eclipsesource.v8.debug.mirror.Frame.getScopeCount",
	"Comment": "returns the number of accessible scopes from this stack frame.",
	"Method": "int getScopeCount(){\r\n    return v8Object.executeIntegerFunction(SCOPE_COUNT, null);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.Configuration.keysByPrefix",
	"Comment": "returns all configuration keys that start with prefix. iterator will beempty if no such keys are found.",
	"Method": "Iterator keysByPrefix(String prefix){\r\n    Configuration conf = instance();\r\n    Iterator iter = conf.properties.keySet().iterator();\r\n    List l = new ArrayList();\r\n    while (iter.hasNext()) {\r\n        String key = (String) iter.next();\r\n        if (key.startsWith(prefix)) {\r\n            l.add(key);\r\n        }\r\n    }\r\n    return l.iterator();\r\n}"
}, {
	"Path": "com.graphhopper.util.PointList.shallowCopy",
	"Comment": "create a shallow copy of this pointlist from from to end, excluding end.",
	"Method": "PointList shallowCopy(int from,int end,boolean makeImmutable){\r\n    if (makeImmutable)\r\n        this.makeImmutable();\r\n    return new ShallowImmutablePointList(from, end, this);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.SwingReplacedElementFactory.reset",
	"Comment": "clears out any references to elements or items created by this factory so far.",
	"Method": "void reset(){\r\n    forms = null;\r\n}"
}, {
	"Path": "org.immutables.value.processor.meta.AttributeBuilderReflection.cachingKey",
	"Comment": "the same class included in two parents, may or may not be nested builders based on that discovery pattern",
	"Method": "String cachingKey(ValueAttribute valueAttribute){\r\n    return String.format(\"%s-%s\", valueAttribute.containedTypeElement.getQualifiedName(), Joiner.on(\".\").join(valueAttribute.containingType.constitution.style().attributeBuilder()));\r\n}"
}, {
	"Path": "com.eclipsesource.v8.NodeJS.isRunning",
	"Comment": "returns true if there are more messages to process, false otherwise.",
	"Method": "boolean isRunning(){\r\n    v8.checkThread();\r\n    return v8.isRunning();\r\n}"
}, {
	"Path": "org.tron.common.runtime.vm.DataWord.longValue",
	"Comment": "converts this dataword to a long, checking for lost information.if this dataword is out of the possible range for a long resultthen an arithmeticexception is thrown.",
	"Method": "long longValue(){\r\n    long longVal = 0;\r\n    for (byte aData : data) {\r\n        longVal = (longVal << 8) + (aData & 0xff);\r\n    }\r\n    return longVal;\r\n}"
}, {
	"Path": "com.graphhopper.util.Helper.keepIn",
	"Comment": "this methods returns the value or min if too small or max if too big.",
	"Method": "double keepIn(double value,double min,double max){\r\n    return Math.max(min, Math.min(value, max));\r\n}"
}, {
	"Path": "org.tron.common.crypto.ECKey.signatureToAddress",
	"Comment": "compute the address of the key that signed the given signature.",
	"Method": "byte[] signatureToAddress(byte[] messageHash,String signatureBase64,byte[] signatureToAddress,byte[] messageHash,ECDSASignature sig){\r\n    return computeAddress(signatureToKeyBytes(messageHash, sig));\r\n}"
}, {
	"Path": "com.spotify.helios.cli.command.HostResolver.scoreMatches",
	"Comment": "score matches based upon the position in the dns search domain that matches the result",
	"Method": "List<ScoredHost> scoreMatches(List<String> results){\r\n    final ImmutableList.Builder<ScoredHost> scored = ImmutableList.builder();\r\n    for (final String name : results) {\r\n        int score = Integer.MAX_VALUE;\r\n        for (int i = 0; i < searchPath.length; i++) {\r\n            if (name.endsWith(searchPath[i].toString())) {\r\n                if (i < score) {\r\n                    score = i;\r\n                }\r\n            }\r\n        }\r\n        scored.add(new ScoredHost(name, score));\r\n    }\r\n    return scored.build();\r\n}"
}, {
	"Path": "com.graphhopper.api.GHMatrixBatchRequester.setMaxIterations",
	"Comment": "internal parameter. increase only if you have very large matrices.",
	"Method": "GHMatrixBatchRequester setMaxIterations(int maxIterations){\r\n    this.maxIterations = maxIterations;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.JavaInputAstVisitor.visitDotWithPrefix",
	"Comment": "output a chain of dereferences where some prefix should be treated as a single syntactic unit,either because it looks like a type name or because there is only a single method invocation inthe chain.",
	"Method": "void visitDotWithPrefix(List<ExpressionTree> items,boolean needDot,Collection<Integer> prefixes){\r\n    boolean trailingDereferences = !prefixes.isEmpty() && getLast(prefixes) < items.size() - 1;\r\n    builder.open(plusFour);\r\n    for (int times = 0; times < prefixes.size(); times++) {\r\n        builder.open(ZERO);\r\n    }\r\n    Deque<Integer> unconsumedPrefixes = new ArrayDeque(ImmutableSortedSet.copyOf(prefixes));\r\n    BreakTag nameTag = genSym();\r\n    for (int i = 0; i < items.size(); i++) {\r\n        ExpressionTree e = items.get(i);\r\n        if (needDot) {\r\n            FillMode fillMode;\r\n            if (!unconsumedPrefixes.isEmpty() && i <= unconsumedPrefixes.peekFirst()) {\r\n                fillMode = FillMode.INDEPENDENT;\r\n            } else {\r\n                fillMode = FillMode.UNIFIED;\r\n            }\r\n            builder.breakOp(fillMode, \"\", ZERO, Optional.of(nameTag));\r\n            token(\".\");\r\n        }\r\n        BreakTag tyargTag = genSym();\r\n        dotExpressionUpToArgs(e, Optional.of(tyargTag));\r\n        if (!unconsumedPrefixes.isEmpty() && i == unconsumedPrefixes.peekFirst()) {\r\n            builder.close();\r\n            unconsumedPrefixes.removeFirst();\r\n        }\r\n        Indent tyargIndent = Indent.If.make(tyargTag, plusFour, ZERO);\r\n        Indent argsIndent = Indent.If.make(nameTag, plusFour, trailingDereferences ? plusFour : ZERO);\r\n        dotExpressionArgsAndParen(e, tyargIndent, argsIndent);\r\n        needDot = true;\r\n    }\r\n    builder.close();\r\n}"
}, {
	"Path": "org.immutables.value.processor.meta.ValueAttributeFunctions.isGenerateDerived",
	"Comment": "predicate on instance of discoveredattribute that evaluates attribute isgeneratederived.",
	"Method": "Predicate<ValueAttribute> isGenerateDerived(){\r\n    return IsGenerateDerivedPredicate.INSTANCE;\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeInjectActuatorTest.SameTokenNameCloseSuccessExchangeInject2",
	"Comment": "sametokenname close, second inject exchange,result is success.",
	"Method": "void SameTokenNameCloseSuccessExchangeInject2(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(0);\r\n    InitExchangeBeforeSameTokenNameActive();\r\n    long exchangeId = 2;\r\n    String firstTokenId = \"_\";\r\n    long firstTokenQuant = 100_000_000000L;\r\n    String secondTokenId = \"def\";\r\n    long secondTokenQuant = 4_000_000L;\r\n    AssetIssueCapsule assetIssueCapsule = new AssetIssueCapsule(AssetIssueContract.newBuilder().setName(ByteString.copyFrom(secondTokenId.getBytes())).build());\r\n    assetIssueCapsule.setId(String.valueOf(2L));\r\n    dbManager.getAssetIssueStore().put(assetIssueCapsule.getName().toByteArray(), assetIssueCapsule);\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmount(secondTokenId.getBytes(), secondTokenQuant);\r\n    accountCapsule.setBalance(firstTokenQuant);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeInjectActuator actuator = new ExchangeInjectActuator(getContract(OWNER_ADDRESS_FIRST, exchangeId, firstTokenId, firstTokenQuant), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        Assert.assertEquals(ret.getInstance().getRet(), code.SUCESS);\r\n        ExchangeCapsule exchangeCapsule = dbManager.getExchangeStore().get(ByteArray.fromLong(exchangeId));\r\n        Assert.assertNotNull(exchangeCapsule);\r\n        Assert.assertEquals(ByteString.copyFrom(ownerAddress), exchangeCapsule.getCreatorAddress());\r\n        Assert.assertEquals(exchangeId, exchangeCapsule.getID());\r\n        Assert.assertEquals(1000000, exchangeCapsule.getCreateTime());\r\n        Assert.assertTrue(Arrays.equals(firstTokenId.getBytes(), exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenId, ByteArray.toStr(exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(1_100_000_000000L, exchangeCapsule.getFirstTokenBalance());\r\n        Assert.assertEquals(secondTokenId, ByteArray.toStr(exchangeCapsule.getSecondTokenId()));\r\n        Assert.assertEquals(11_000_000L, exchangeCapsule.getSecondTokenBalance());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        Map<String, Long> assetMap = accountCapsule.getAssetMap();\r\n        Assert.assertEquals(0L, accountCapsule.getBalance());\r\n        Assert.assertEquals(3_000_000L, assetMap.get(secondTokenId).longValue());\r\n    } catch (ContractValidateException e) {\r\n        logger.info(e.getMessage());\r\n        Assert.assertFalse(e instanceof ContractValidateException);\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    } catch (ItemNotFoundException e) {\r\n        Assert.assertFalse(e instanceof ItemNotFoundException);\r\n    }\r\n}"
}, {
	"Path": "org.immutables.mongo.types.TypeAdapters.objectIdAdapter",
	"Comment": "use this adapter to easily delagate marshaling of custom objectid wrapper.",
	"Method": "TypeAdapter<byte[]> objectIdAdapter(){\r\n    return OBJECT_ID_ADAPTER;\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.EncodedValue.swap",
	"Comment": "swap the contents controlled by this value encoder with the given value.",
	"Method": "long swap(long flags,EncodedValue otherEncoder){\r\n    long otherValue = otherEncoder.getValue(flags);\r\n    flags = otherEncoder.setValue(flags, getValue(flags));\r\n    return setValue(flags, otherValue);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.resource.FSCatalog.addHandlers",
	"Comment": "adds the default entityresolved and errorhandler for the sax parser.",
	"Method": "void addHandlers(XMLReader xmlReader,ContentHandler ch){\r\n    try {\r\n        xmlReader.setContentHandler(ch);\r\n        xmlReader.setErrorHandler(new ErrorHandler() {\r\n            public void error(SAXParseException ex) {\r\n                if (XRLog.isLoggingEnabled()) {\r\n                    XRLog.xmlEntities(Level.WARNING, ex.getMessage());\r\n                }\r\n            }\r\n            public void fatalError(SAXParseException ex) {\r\n                if (XRLog.isLoggingEnabled()) {\r\n                    XRLog.xmlEntities(Level.WARNING, ex.getMessage());\r\n                }\r\n            }\r\n            public void warning(SAXParseException ex) {\r\n                if (XRLog.isLoggingEnabled()) {\r\n                    XRLog.xmlEntities(Level.WARNING, ex.getMessage());\r\n                }\r\n            }\r\n        });\r\n    } catch (Exception ex) {\r\n        throw new XRRuntimeException(\"Failed on configuring SAX parser/XMLReader.\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.resource.FSCatalog.addHandlers",
	"Comment": "adds the default entityresolved and errorhandler for the sax parser.",
	"Method": "void addHandlers(XMLReader xmlReader,ContentHandler ch){\r\n    if (XRLog.isLoggingEnabled()) {\r\n        XRLog.xmlEntities(Level.WARNING, ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.resource.FSCatalog.addHandlers",
	"Comment": "adds the default entityresolved and errorhandler for the sax parser.",
	"Method": "void addHandlers(XMLReader xmlReader,ContentHandler ch){\r\n    if (XRLog.isLoggingEnabled()) {\r\n        XRLog.xmlEntities(Level.WARNING, ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.resource.FSCatalog.addHandlers",
	"Comment": "adds the default entityresolved and errorhandler for the sax parser.",
	"Method": "void addHandlers(XMLReader xmlReader,ContentHandler ch){\r\n    if (XRLog.isLoggingEnabled()) {\r\n        XRLog.xmlEntities(Level.WARNING, ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.spotify.helios.system.ZooKeeperAclTest.testAgentCreatedNodesHaveAcls",
	"Comment": "simple test to make sure nodes created by agents use the acls provided by the acl provider.",
	"Method": "void testAgentCreatedNodesHaveAcls(){\r\n    startDefaultMaster();\r\n    startDefaultAgent(TEST_HOST);\r\n    awaitHostRegistered(TEST_HOST, WAIT_TIMEOUT_SECONDS, TimeUnit.SECONDS);\r\n    final CuratorFramework curator = zk().curatorWithSuperAuth();\r\n    final String path = Paths.configHost(TEST_HOST);\r\n    final List<ACL> acls = curator.getACL().forPath(path);\r\n    assertEquals(Sets.newHashSet(aclProvider.getAclForPath(path)), Sets.newHashSet(acls));\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.FSScrollPane.addResizeListener",
	"Comment": "adds a component listener on the view for resize events, to adjust the scroll increment.",
	"Method": "void addResizeListener(Component view){\r\n    view.addComponentListener(new ComponentAdapter() {\r\n        public void componentResized(ComponentEvent e) {\r\n            JScrollBar bar = getVerticalScrollBar();\r\n            int incr = (int) (getSize().getHeight() - (bar.getUnitIncrement(1) * 3));\r\n            getVerticalScrollBar().setBlockIncrement(incr);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.FSScrollPane.addResizeListener",
	"Comment": "adds a component listener on the view for resize events, to adjust the scroll increment.",
	"Method": "void addResizeListener(Component view){\r\n    JScrollBar bar = getVerticalScrollBar();\r\n    int incr = (int) (getSize().getHeight() - (bar.getUnitIncrement(1) * 3));\r\n    getVerticalScrollBar().setBlockIncrement(incr);\r\n}"
}, {
	"Path": "com.notnoop.apns.internal.SSLContextBuilder.getKeyStoreWithSingleKey",
	"Comment": "workaround for keystores containing multiple keys. java will take the first key that matchesand this way we can still offer configuration for a keystore with multiple keys and a selectionbased on alias. also much easier than making a subclass of a keymanagerfactory",
	"Method": "KeyStore getKeyStoreWithSingleKey(KeyStore keyStore,String keyStorePassword,String keyAlias){\r\n    KeyStore singleKeyKeyStore = KeyStore.getInstance(keyStore.getType(), keyStore.getProvider());\r\n    final char[] password = keyStorePassword.toCharArray();\r\n    singleKeyKeyStore.load(null, password);\r\n    Key key = keyStore.getKey(keyAlias, password);\r\n    Certificate[] chain = keyStore.getCertificateChain(keyAlias);\r\n    singleKeyKeyStore.setKeyEntry(keyAlias, key, password, chain);\r\n    return singleKeyKeyStore;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Object.executeBooleanFunction",
	"Comment": "invoke a javascript function and return the result as a boolean. if theresult is not a boolean, or does not exist, then v8resultundefined is thrown.",
	"Method": "boolean executeBooleanFunction(String name,V8Array parameters,boolean executeBooleanFunction,String name,V8Array parameters){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    v8.checkRuntime(parameters);\r\n    long parametersHandle = parameters == null ? 0 : parameters.getHandle();\r\n    return v8.executeBooleanFunction(v8.getV8RuntimePtr(), getHandle(), name, parametersHandle);\r\n}"
}, {
	"Path": "org.tron.common.crypto.ECKey.isECPrivateKey",
	"Comment": "test if a generic private key is an ec private keyit is not sufficient to check that privkey is a subtype of ecprivatekeyas the sunpkcs11 provider will return a generic privatekey instancea fallback that covers this case is to check the key algorithm",
	"Method": "boolean isECPrivateKey(PrivateKey privKey){\r\n    return privKey instanceof ECPrivateKey || privKey.getAlgorithm().equals(\"EC\");\r\n}"
}, {
	"Path": "com.graphhopper.storage.GraphEdgeIdFinder.parseBlockArea",
	"Comment": "this method reads the blockareastring and creates a collection of shapes or a set of found edges if area is small enough.",
	"Method": "BlockArea parseBlockArea(String blockAreaString,EdgeFilter filter,double useEdgeIdsUntilAreaSize){\r\n    final String objectSeparator = \";\";\r\n    final String innerObjSep = \",\";\r\n    BlockArea blockArea = new BlockArea(graph);\r\n    if (!blockAreaString.isEmpty()) {\r\n        String[] blockedCircularAreasArr = blockAreaString.split(objectSeparator);\r\n        for (int i = 0; i < blockedCircularAreasArr.length; i++) {\r\n            String objectAsString = blockedCircularAreasArr[i];\r\n            String[] splittedObject = objectAsString.split(innerObjSep);\r\n            if (splittedObject.length > 4) {\r\n                final Polygon polygon = Polygon.parsePoints(objectAsString, 0.003);\r\n                findEdgesInShape(blockArea.blockedEdges, polygon, filter);\r\n            } else if (splittedObject.length == 4) {\r\n                final BBox bbox = BBox.parseTwoPoints(objectAsString);\r\n                if (bbox.calculateArea() > useEdgeIdsUntilAreaSize)\r\n                    blockArea.add(bbox);\r\n                else\r\n                    findEdgesInShape(blockArea.blockedEdges, bbox, filter);\r\n            } else if (splittedObject.length == 3) {\r\n                double lat = Double.parseDouble(splittedObject[0]);\r\n                double lon = Double.parseDouble(splittedObject[1]);\r\n                int radius = Integer.parseInt(splittedObject[2]);\r\n                Circle circle = new Circle(lat, lon, radius);\r\n                if (circle.calculateArea() > useEdgeIdsUntilAreaSize) {\r\n                    blockArea.add(circle);\r\n                } else {\r\n                    findEdgesInShape(blockArea.blockedEdges, circle, filter);\r\n                }\r\n            } else if (splittedObject.length == 2) {\r\n                double lat = Double.parseDouble(splittedObject[0]);\r\n                double lon = Double.parseDouble(splittedObject[1]);\r\n                findClosestEdge(blockArea.blockedEdges, lat, lon, filter);\r\n            } else {\r\n                throw new IllegalArgumentException(objectAsString + \" at index \" + i + \" need to be defined as lat,lon \" + \"or as a circle lat,lon,radius or rectangular lat1,lon1,lat2,lon2\");\r\n            }\r\n        }\r\n    }\r\n    return blockArea;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.demo.browser.ValidationHandler.setTextArea",
	"Comment": "sets the textarea attribute of the validationhandler object",
	"Method": "void setTextArea(JTextArea jta){\r\n    this.jta = jta;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.context.StandardAttributeResolver.isVisited",
	"Comment": "gets the visited attribute of the standardattributeresolver object",
	"Method": "boolean isVisited(Object e){\r\n    return isLink(e) && uac.isVisited(nsh.getLinkUri((Element) e));\r\n}"
}, {
	"Path": "com.graphhopper.routing.ch.CHAlgoFactoryDecorator.getNodeBase",
	"Comment": "for now only node based will work, later on we can easily find usage of this method to removeit.",
	"Method": "TraversalMode getNodeBase(){\r\n    return TraversalMode.NODE_BASED;\r\n}"
}, {
	"Path": "stest.tron.wallet.common.client.utils.DataWord.intValue",
	"Comment": "converts this dataword to an int, checking for lost information.if this dataword is out of the possible range for an int resultthen an arithmeticexception is thrown.",
	"Method": "int intValue(){\r\n    int intVal = 0;\r\n    for (byte aaData : data) {\r\n        intVal = (intVal << 8) + (aaData & 0xff);\r\n    }\r\n    return intVal;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.render.BorderPainter.generateBorderBounds",
	"Comment": "generates a full round rectangle that is made of bounds and border",
	"Method": "Path2D generateBorderBounds(Rectangle bounds,BorderPropertySet border,boolean inside){\r\n    Path2D path = generateBorderShape(bounds, TOP, border, false, inside ? 1 : 0, 1);\r\n    path.append(generateBorderShape(bounds, RIGHT, border, false, inside ? 1 : 0, 1), true);\r\n    path.append(generateBorderShape(bounds, BOTTOM, border, false, inside ? 1 : 0, 1), true);\r\n    path.append(generateBorderShape(bounds, LEFT, border, false, inside ? 1 : 0, 1), true);\r\n    return path;\r\n}"
}, {
	"Path": "com.google.googlejavaformat.OpsBuilder.checkClosed",
	"Comment": "checks that all open ops in the op stream have matching close ops.",
	"Method": "void checkClosed(int previous){\r\n    if (depth != previous) {\r\n        throw new FormattingError(diagnostic(String.format(\"saw %d unclosed ops\", depth)));\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.routing.AlgorithmOptions.start",
	"Comment": "this method clones the specified algorithmoption object with the possibility for furtherchanges.",
	"Method": "Builder start(Builder start,AlgorithmOptions opts){\r\n    Builder b = new Builder();\r\n    if (opts.algorithm != null)\r\n        b.algorithm(opts.getAlgorithm());\r\n    if (opts.traversalMode != null)\r\n        b.traversalMode(opts.getTraversalMode());\r\n    if (opts.weighting != null)\r\n        b.weighting(opts.getWeighting());\r\n    if (opts.maxVisitedNodes >= 0)\r\n        b.maxVisitedNodes(opts.maxVisitedNodes);\r\n    if (!opts.hints.isEmpty())\r\n        b.hints(opts.hints);\r\n    return b;\r\n}"
}, {
	"Path": "com.google.googlejavaformat.Input.createDiagnostic",
	"Comment": "construct a diagnostic. populates the input filename, and converts character offsets tonumbers.",
	"Method": "FormatterDiagnostic createDiagnostic(int inputPosition,String message){\r\n    return FormatterDiagnostic.create(getLineNumber(inputPosition), getColumnNumber(inputPosition), message);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.context.StyleReference.getPseudoElementStyle",
	"Comment": "gets the pseudoelementstyle attribute of the stylereference object",
	"Method": "CascadedStyle getPseudoElementStyle(Node node,String pseudoElement){\r\n    Element e = null;\r\n    if (node.getNodeType() == Node.ELEMENT_NODE) {\r\n        e = (Element) node;\r\n    } else {\r\n        e = (Element) node.getParentNode();\r\n    }\r\n    return _matcher.getPECascadedStyle(e, pseudoElement);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.debug.V8DebugServer.setTraceCommunication",
	"Comment": "output all communication to the console. for purpose of debugging v8debugserver itself.",
	"Method": "void setTraceCommunication(boolean value){\r\n    traceCommunication = value;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Object.get",
	"Comment": "returns the value associated with this key. values are java objects.if the value is a primitive, its boxed type is returned. if thevalue is a v8value, it must be released.",
	"Method": "Object get(String key){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    checkKey(key);\r\n    return v8.get(v8.getV8RuntimePtr(), V8_OBJECT, objectHandle, key);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.context.StandardAttributeResolver.getLang",
	"Comment": "gets the lang attribute of the standardattributeresolver object",
	"Method": "String getLang(Object e){\r\n    return nsh.getLang((Element) e);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.pdf.ITextRenderer.setDidValues",
	"Comment": "sets the document information dictionary values from html metadata",
	"Method": "void setDidValues(com.lowagie.text.Document doc){\r\n    String v = _outputDevice.getMetadataByName(\"title\");\r\n    if (v != null) {\r\n        doc.addTitle(v);\r\n    }\r\n    v = _outputDevice.getMetadataByName(\"author\");\r\n    if (v != null) {\r\n        doc.addAuthor(v);\r\n    }\r\n    v = _outputDevice.getMetadataByName(\"subject\");\r\n    if (v != null) {\r\n        doc.addSubject(v);\r\n    }\r\n    v = _outputDevice.getMetadataByName(\"keywords\");\r\n    if (v != null) {\r\n        doc.addKeywords(v);\r\n    }\r\n}"
}, {
	"Path": "org.tron.core.actuator.TransferAssetActuatorTest.SameTokenNameCloseTransferToYourself",
	"Comment": "sametokenname close,transfer asset to yourself,result is error",
	"Method": "void SameTokenNameCloseTransferToYourself(){\r\n    createAssertBeforSameTokenNameActive();\r\n    TransferAssetActuator actuator = new TransferAssetActuator(getContract(100L, OWNER_ADDRESS, OWNER_ADDRESS), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail(\"Cannot transfer asset to yourself.\");\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"Cannot transfer asset to yourself.\", e.getMessage());\r\n        AccountCapsule owner = dbManager.getAccountStore().get(ByteArray.fromHexString(OWNER_ADDRESS));\r\n        AccountCapsule toAccount = dbManager.getAccountStore().get(ByteArray.fromHexString(TO_ADDRESS));\r\n        Assert.assertEquals(owner.getAssetMap().get(ASSET_NAME).longValue(), OWNER_ASSET_BALANCE);\r\n        Assert.assertTrue(isNullOrZero(toAccount.getAssetMap().get(ASSET_NAME)));\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.storage.EdgeAccess.internalEdgeAdd",
	"Comment": "write new edge between nodes fromnodeid, and tonodeid both to nodes index and edges index",
	"Method": "int internalEdgeAdd(int newEdgeId,int fromNodeId,int toNodeId){\r\n    writeEdge(newEdgeId, fromNodeId, toNodeId, EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);\r\n    connectNewEdge(fromNodeId, toNodeId, newEdgeId);\r\n    if (fromNodeId != toNodeId)\r\n        connectNewEdge(toNodeId, fromNodeId, newEdgeId);\r\n    return newEdgeId;\r\n}"
}, {
	"Path": "com.spotify.helios.testing.TemporaryJob.port",
	"Comment": "returns the port that a job can be reached at given the host and name of registered port.this is useful to discover the value of a dynamically allocated port.",
	"Method": "Integer port(String host,String port){\r\n    checkArgument(hosts.contains(host), \"host %s not found\", host);\r\n    checkArgument(job.getPorts().containsKey(port), \"port %s not found\", port);\r\n    final TaskStatus status = statuses.get(host);\r\n    if (status == null) {\r\n        return null;\r\n    }\r\n    final PortMapping portMapping = status.getPorts().get(port);\r\n    if (portMapping == null) {\r\n        return null;\r\n    }\r\n    return portMapping.getExternalPort();\r\n}"
}, {
	"Path": "com.higherfrequencytrading.chronicle.impl.IndexedChronicle.clear",
	"Comment": "clear any previous data in the chronicle.added for testing purposes.",
	"Method": "void clear(){\r\n    size = 0;\r\n    setIndexData(1, 0);\r\n}"
}, {
	"Path": "com.graphhopper.util.PointList.copy",
	"Comment": "this method does a deep copy of this object for the specified range.",
	"Method": "PointList copy(int from,int end){\r\n    if (from > end)\r\n        throw new IllegalArgumentException(\"from must be smaller or equal to end\");\r\n    if (from < 0 || end > getSize())\r\n        throw new IllegalArgumentException(\"Illegal interval: \" + from + \", \" + end + \", size:\" + getSize());\r\n    PointList thisPL = this;\r\n    if (this instanceof ShallowImmutablePointList) {\r\n        ShallowImmutablePointList spl = (ShallowImmutablePointList) this;\r\n        thisPL = spl.wrappedPointList;\r\n        from = spl.fromOffset + from;\r\n        end = spl.fromOffset + end;\r\n    }\r\n    int len = end - from;\r\n    PointList copyPL = new PointList(len, is3D());\r\n    copyPL.size = len;\r\n    copyPL.isImmutable = isImmutable();\r\n    System.arraycopy(thisPL.latitudes, from, copyPL.latitudes, 0, len);\r\n    System.arraycopy(thisPL.longitudes, from, copyPL.longitudes, 0, len);\r\n    if (is3D())\r\n        System.arraycopy(thisPL.elevations, from, copyPL.elevations, 0, len);\r\n    return copyPL;\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeCreateActuatorTest.sameTokenNameCloseMoreThanBalanceLimit",
	"Comment": "sametokenname close,token balance must less than balancelimit",
	"Method": "void sameTokenNameCloseMoreThanBalanceLimit(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(0);\r\n    String firstTokenId = \"abc\";\r\n    long firstTokenBalance = 1_000_000_000_000_001L;\r\n    String secondTokenId = \"def\";\r\n    long secondTokenBalance = 100000000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmount(firstTokenId.getBytes(), firstTokenBalance);\r\n    accountCapsule.addAssetAmount(secondTokenId.getBytes(), secondTokenBalance);\r\n    accountCapsule.setBalance(10000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeCreateActuator actuator = new ExchangeCreateActuator(getContract(OWNER_ADDRESS_FIRST, firstTokenId, firstTokenBalance, secondTokenId, secondTokenBalance), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    Assert.assertEquals(dbManager.getDynamicPropertiesStore().getLatestExchangeNum(), 0);\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"token balance must less than 1000000000000000\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeCreateActuatorTest.sameTokenNameOpenExchangeCreateFailure2",
	"Comment": "sametokenname open,second create exchange, result is failure.",
	"Method": "void sameTokenNameOpenExchangeCreateFailure2(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    String firstTokenId = \"_\";\r\n    long firstTokenBalance = 100_000_000_000000L;\r\n    String secondTokenId = \"abc\";\r\n    long secondTokenBalance = 100_000_000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.setBalance(200_000_000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeCreateActuator actuator = new ExchangeCreateActuator(getContract(OWNER_ADDRESS_FIRST, firstTokenId, firstTokenBalance, secondTokenId, secondTokenBalance), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    Assert.assertEquals(dbManager.getDynamicPropertiesStore().getLatestExchangeNum(), 0);\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"second token id is not a valid number\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeTransactionActuatorTest.SameTokenNameCloseTokenBalanceGreaterThanBalanceLimit",
	"Comment": "sametokenname close,token balance must less than balancelimit",
	"Method": "void SameTokenNameCloseTokenBalanceGreaterThanBalanceLimit(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(0);\r\n    InitExchangeBeforeSameTokenNameActive();\r\n    long exchangeId = 2;\r\n    String tokenId = \"abc\";\r\n    long quant = 1_000_000_000_000_001L;\r\n    String buyTokenId = \"def\";\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_SECOND);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmount(tokenId.getBytes(), 10000);\r\n    Map<String, Long> assetMap = accountCapsule.getAssetMap();\r\n    Assert.assertEquals(20000_000000L, accountCapsule.getBalance());\r\n    Assert.assertEquals(null, assetMap.get(buyTokenId));\r\n    dbManager.getAccountStore().put(accountCapsule.createDbKey(), accountCapsule);\r\n    ExchangeTransactionActuator actuator = new ExchangeTransactionActuator(getContract(OWNER_ADDRESS_SECOND, exchangeId, tokenId, quant, 1), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"token balance must less than 1000000000000000\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.pdf.ITextOutputDevice.setMetadata",
	"Comment": "replaces all copies of the named metadata with a single value. a a newvalue of null will result in the removal of all copies of the namedmetadata. use addmetadata to append additional values withthe same name.",
	"Method": "void setMetadata(String name,String value){\r\n    if (name != null) {\r\n        boolean remove = (value == null);\r\n        int free = -1;\r\n        for (int i = 0, len = _metadata.size(); i < len; i++) {\r\n            Metadata m = (Metadata) _metadata.get(i);\r\n            if (m != null) {\r\n                if (m.getName().equalsIgnoreCase(name)) {\r\n                    if (!remove) {\r\n                        remove = true;\r\n                        m.setContent(value);\r\n                    } else {\r\n                        _metadata.set(i, null);\r\n                    }\r\n                }\r\n            } else if (free == -1) {\r\n                free = i;\r\n            }\r\n        }\r\n        if (!remove) {\r\n            Metadata m = new Metadata(name, value);\r\n            if (free == -1) {\r\n                _metadata.add(m);\r\n            } else {\r\n                _metadata.set(free, m);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.routing.ch.CHAlgoFactoryDecorator.addWeighting",
	"Comment": "decouple weightings from preparecontractionhierarchies as we need weightings for thegraphstorage and the graphstorage for the preparation.",
	"Method": "CHAlgoFactoryDecorator addWeighting(Weighting weighting,CHAlgoFactoryDecorator addWeighting,String weighting){\r\n    weightingsAsStrings.add(weighting);\r\n    return this;\r\n}"
}, {
	"Path": "com.graphhopper.util.shapes.BBox.parseBBoxString",
	"Comment": "this method creates a bbox out of a string in format lon1,lon2,lat1,lat2",
	"Method": "BBox parseBBoxString(String objectAsString){\r\n    String[] splittedObject = objectAsString.split(\",\");\r\n    if (splittedObject.length != 4)\r\n        throw new IllegalArgumentException(\"BBox should have 4 parts but was \" + objectAsString);\r\n    double minLon = Double.parseDouble(splittedObject[0]);\r\n    double maxLon = Double.parseDouble(splittedObject[1]);\r\n    double minLat = Double.parseDouble(splittedObject[2]);\r\n    double maxLat = Double.parseDouble(splittedObject[3]);\r\n    return new BBox(minLon, maxLon, minLat, maxLat);\r\n}"
}, {
	"Path": "org.immutables.ordinal.ImmutableOrdinalSet.removeAll",
	"Comment": "will throw an exception and leave the collection unmodified.",
	"Method": "boolean removeAll(Collection<?> oldElements){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.graphhopper.reader.osm.OSMReader.setCreateStorage",
	"Comment": "per default the storage used in this osmreader is uninitialized and created i.e. createstorage is true. specifyfalse if you call the create method outside of osmreader.",
	"Method": "void setCreateStorage(boolean createStorage){\r\n    this.createStorage = createStorage;\r\n}"
}, {
	"Path": "org.tron.common.crypto.zksnark.BN128.toAffine",
	"Comment": "transforms given jacobian to affine coordinates and then creates a point",
	"Method": "BN128<T> toAffine(){\r\n    if (isZero()) {\r\n        BN128<T> zero = zero();\r\n        return instance(zero.x, one(), zero.z);\r\n    }\r\n    T zInv = z.inverse();\r\n    T zInv2 = zInv.squared();\r\n    T zInv3 = zInv2.mul(zInv);\r\n    T ax = x.mul(zInv2);\r\n    T ay = y.mul(zInv3);\r\n    return instance(ax, ay, one());\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.getStepDelayHideDetailsAnimation",
	"Comment": "duration of delay between profile toolbar, profile avatar and profile details close animations.",
	"Method": "int getStepDelayHideDetailsAnimation(){\r\n    return STEP_DELAY_HIDE_DETAILS_ANIMATION;\r\n}"
}, {
	"Path": "com.spotify.helios.testing.InMemoryLogStreamFollower.writeAndFlush",
	"Comment": "write the contents of the given bytebuffer to the outputstream and flush the stream.",
	"Method": "void writeAndFlush(ByteBuffer buffer,OutputStream outputStream){\r\n    if (buffer.hasArray()) {\r\n        outputStream.write(buffer.array(), buffer.position(), buffer.remaining());\r\n    } else {\r\n        while (buffer.hasRemaining()) {\r\n            final int size = Math.min(buffer.remaining(), 8 * 1024);\r\n            final byte[] chunk = new byte[size];\r\n            buffer.get(chunk);\r\n            outputStream.write(chunk);\r\n        }\r\n    }\r\n    outputStream.flush();\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.setProfileDetailsInfo",
	"Comment": "this method sets data of the clicked list item to profile details view.",
	"Method": "void setProfileDetailsInfo(Map<String, Object> item){\r\n    mTextViewProfileName.setText((String) item.get(EuclidListAdapter.KEY_NAME));\r\n    mTextViewProfileDescription.setText((String) item.get(EuclidListAdapter.KEY_DESCRIPTION_FULL));\r\n}"
}, {
	"Path": "org.xhtmlrenderer.context.StandardAttributeResolver.getID",
	"Comment": "gets the id attribute of the standardattributeresolver object",
	"Method": "String getID(Object e){\r\n    return nsh.getID((Element) e);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Object.registerJavaMethod",
	"Comment": "register a void java method as a javascript function. when the js function is invokedthe java method will be called.",
	"Method": "V8Object registerJavaMethod(JavaCallback callback,String jsFunctionName,V8Object registerJavaMethod,JavaVoidCallback callback,String jsFunctionName,V8Object registerJavaMethod,Object object,String methodName,String jsFunctionName,Class<?>[] parameterTypes,V8Object registerJavaMethod,Object object,String methodName,String jsFunctionName,Class<?>[] parameterTypes,boolean includeReceiver,V8Object registerJavaMethod,JavaCallback callback,String jsFunctionName,V8Object registerJavaMethod,JavaVoidCallback callback,String jsFunctionName,V8Object registerJavaMethod,Object object,String methodName,String jsFunctionName,Class<?>[] parameterTypes,boolean includeReceiver){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    try {\r\n        Method method = object.getClass().getMethod(methodName, parameterTypes);\r\n        method.setAccessible(true);\r\n        v8.registerCallback(object, method, getHandle(), jsFunctionName, includeReceiver);\r\n    } catch (NoSuchMethodException e) {\r\n        throw new IllegalStateException(e);\r\n    } catch (SecurityException e) {\r\n        throw new IllegalStateException(e);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.Configuration.valueAsInt",
	"Comment": "returns the value for key in the configuration as an integer, or adefault value if not found or if the value is not a valid integer. awarning is issued to the log if the property is not defined, or if theconversion from string fails.",
	"Method": "int valueAsInt(String key,int defaultVal){\r\n    String val = valueFor(key);\r\n    if (val == null) {\r\n        return defaultVal;\r\n    }\r\n    int ival;\r\n    try {\r\n        ival = Integer.valueOf(val).intValue();\r\n    } catch (NumberFormatException nex) {\r\n        XRLog.exception(\"Property '\" + key + \"' was requested as an integer, but \" + \"value of '\" + val + \"' is not an integer. Check configuration.\");\r\n        ival = defaultVal;\r\n    }\r\n    return ival;\r\n}"
}, {
	"Path": "com.graphhopper.reader.dem.SRTMProvider.init",
	"Comment": "the urls are a bit ugly and so we need to find out which area name a certain lat,loncoordinate has.",
	"Method": "SRTMProvider init(){\r\n    try {\r\n        String[] strs = { \"Africa\", \"Australia\", \"Eurasia\", \"Islands\", \"North_America\", \"South_America\" };\r\n        for (String str : strs) {\r\n            InputStream is = getClass().getResourceAsStream(str + \"_names.txt\");\r\n            for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS))) {\r\n                int lat = Integer.parseInt(line.substring(1, 3));\r\n                if (line.substring(0, 1).charAt(0) == 'S')\r\n                    lat = -lat;\r\n                int lon = Integer.parseInt(line.substring(4, 7));\r\n                if (line.substring(3, 4).charAt(0) == 'W')\r\n                    lon = -lon;\r\n                int intKey = calcIntKey(lat, lon);\r\n                String key = areas.put(intKey, str);\r\n                if (key != null)\r\n                    throw new IllegalStateException(\"do not overwrite existing! key \" + intKey + \" \" + key + \" vs. \" + str);\r\n            }\r\n        }\r\n        return this;\r\n    } catch (Exception ex) {\r\n        throw new IllegalStateException(\"Cannot load area names from classpath\", ex);\r\n    }\r\n}"
}, {
	"Path": "com.spotify.helios.master.resources.HostsResource.jobPatch",
	"Comment": "alters the current deployment of a deployed job identified by its job id on the specifiedhost.",
	"Method": "SetGoalResponse jobPatch(String host,JobId jobId,Deployment deployment,String token){\r\n    if (!deployment.getJobId().equals(jobId)) {\r\n        throw badRequest(new SetGoalResponse(SetGoalResponse.Status.ID_MISMATCH, host, jobId));\r\n    }\r\n    try {\r\n        model.updateDeployment(host, deployment, token);\r\n    } catch (HostNotFoundException e) {\r\n        throw notFound(new SetGoalResponse(SetGoalResponse.Status.HOST_NOT_FOUND, host, jobId));\r\n    } catch (JobNotDeployedException e) {\r\n        throw notFound(new SetGoalResponse(SetGoalResponse.Status.JOB_NOT_DEPLOYED, host, jobId));\r\n    } catch (TokenVerificationException e) {\r\n        throw forbidden(new SetGoalResponse(SetGoalResponse.Status.FORBIDDEN, host, jobId));\r\n    }\r\n    log.info(\"patched job {} on host {}\", deployment, host);\r\n    return new SetGoalResponse(SetGoalResponse.Status.OK, host, jobId);\r\n}"
}, {
	"Path": "com.graphhopper.util.Downloader.fetch",
	"Comment": "this method initiates a connect call of the provided connection and returns the responsestream. it only returns the error stream if it is available and readerrorstreamnoexception istrue otherwise it throws an ioexception if an error happens. furthermore it wraps the streamto decompress it if the connection content encoding is specified.",
	"Method": "InputStream fetch(HttpURLConnection connection,boolean readErrorStreamNoException,InputStream fetch,String url){\r\n    return fetch((HttpURLConnection) createConnection(url), false);\r\n}"
}, {
	"Path": "com.graphhopper.util.GHUtility.getProblems",
	"Comment": "this method could throw exception if uncatched problems like index out of bounds etc",
	"Method": "List<String> getProblems(Graph g){\r\n    List<String> problems = new ArrayList();\r\n    int nodes = g.getNodes();\r\n    int nodeIndex = 0;\r\n    NodeAccess na = g.getNodeAccess();\r\n    try {\r\n        EdgeExplorer explorer = g.createEdgeExplorer();\r\n        for (; nodeIndex < nodes; nodeIndex++) {\r\n            double lat = na.getLatitude(nodeIndex);\r\n            if (lat > 90 || lat < -90)\r\n                problems.add(\"latitude is not within its bounds \" + lat);\r\n            double lon = na.getLongitude(nodeIndex);\r\n            if (lon > 180 || lon < -180)\r\n                problems.add(\"longitude is not within its bounds \" + lon);\r\n            EdgeIterator iter = explorer.setBaseNode(nodeIndex);\r\n            while (iter.next()) {\r\n                if (iter.getAdjNode() >= nodes) {\r\n                    problems.add(\"edge of \" + nodeIndex + \" has a node \" + iter.getAdjNode() + \" greater or equal to getNodes\");\r\n                }\r\n                if (iter.getAdjNode() < 0) {\r\n                    problems.add(\"edge of \" + nodeIndex + \" has a negative node \" + iter.getAdjNode());\r\n                }\r\n            }\r\n        }\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(\"problem with node \" + nodeIndex, ex);\r\n    }\r\n    return problems;\r\n}"
}, {
	"Path": "com.graphhopper.util.TranslationMap.getWithFallBack",
	"Comment": "returns the translation object for the specified locale and falls back to english if thelocale was not found.",
	"Method": "Translation getWithFallBack(Locale locale){\r\n    Translation tr = get(locale.toString());\r\n    if (tr == null) {\r\n        tr = get(locale.getLanguage());\r\n        if (tr == null)\r\n            tr = get(\"en\");\r\n    }\r\n    return tr;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.Configuration.logAfterLoad",
	"Comment": "writes a log of loaded properties to the plumbing.init logger.",
	"Method": "void logAfterLoad(){\r\n    Enumeration elem = properties.keys();\r\n    List lp = Collections.list(elem);\r\n    Collections.sort(lp);\r\n    Iterator iter = lp.iterator();\r\n    finer(\"Configuration contains \" + properties.size() + \" keys.\");\r\n    finer(\"List of configuration properties, after override:\");\r\n    while (iter.hasNext()) {\r\n        String key = (String) iter.next();\r\n        String val = properties.getProperty(key);\r\n        finer(\"  \" + key + \" = \" + val);\r\n    }\r\n    finer(\"Properties list complete.\");\r\n}"
}, {
	"Path": "org.kie.test.util.db.PersistenceUtil.setupWithPoolingDataSource",
	"Comment": "this method does all of the setup for the test and returns a hashmapcontaining the persistence objects that the test might need.",
	"Method": "Map<String, Object> setupWithPoolingDataSource(String persistenceUnitName,Map<String, Object> setupWithPoolingDataSource,String persistenceUnitName,boolean testMarshalling,Map<String, Object> setupWithPoolingDataSource,String persistenceUnitName,String dataSourceName,boolean testMarshalling){\r\n    PoolingDataSourceWrapper ds1 = setupPoolingDataSource(getDatasourceProperties(), dataSourceName);\r\n    Map<String, Object> context = new HashMap<String, Object>();\r\n    context.put(DATASOURCE, ds1);\r\n    EntityManagerFactory emf = Persistence.createEntityManagerFactory(persistenceUnitName);\r\n    context.put(ENTITY_MANAGER_FACTORY, emf);\r\n    return context;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.BasicPanel.scrollTo",
	"Comment": "scroll the panel to make the specified point be on screen. typicallythis will scroll the screen down to the y component of the point.",
	"Method": "void scrollTo(Point pt){\r\n    JScrollPane scrollPane = getEnclosingScrollPane();\r\n    if (scrollPane != null) {\r\n        JScrollBar scrollBar = scrollPane.getVerticalScrollBar();\r\n        if (scrollBar != null) {\r\n            scrollBar.setValue(pt.y);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.utils.MemoryManager.isReleased",
	"Comment": "checks if the memory manager has been released or not. released memorymanagers can no longer be used.",
	"Method": "boolean isReleased(){\r\n    return released;\r\n}"
}, {
	"Path": "org.tron.common.runtime.vm.DataWord.intValue",
	"Comment": "converts this dataword to an int, checking for lost information.if this dataword is out of the possible range for an int resultthen an arithmeticexception is thrown.",
	"Method": "int intValue(){\r\n    int intVal = 0;\r\n    for (byte aData : data) {\r\n        intVal = (intVal << 8) + (aData & 0xff);\r\n    }\r\n    return intVal;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.style.derived.BorderPropertySet.lighten",
	"Comment": "returns the colors for brighter parts of each side for a particular decoration style",
	"Method": "BorderPropertySet lighten(IdentValue style){\r\n    BorderPropertySet bc = new BorderPropertySet(this);\r\n    bc._topColor = _topColor == null ? null : _topColor.lightenColor();\r\n    bc._bottomColor = _bottomColor == null ? null : _bottomColor.lightenColor();\r\n    bc._leftColor = _leftColor == null ? null : _leftColor.lightenColor();\r\n    bc._rightColor = _rightColor == null ? null : _rightColor.lightenColor();\r\n    return bc;\r\n}"
}, {
	"Path": "com.spotify.helios.testing.HeliosConfig.loadConfig",
	"Comment": "return the root configuration loaded from the helios configuration files.",
	"Method": "Config loadConfig(){\r\n    final ConfigResolveOptions resolveOptions = ConfigResolveOptions.defaults().setAllowUnresolved(true);\r\n    final ConfigParseOptions parseOptions = ConfigParseOptions.defaults();\r\n    final Config baseConfig = ConfigFactory.load(BASE_CONFIG_FILE, parseOptions, resolveOptions);\r\n    final Config appConfig = ConfigFactory.load(APP_CONFIG_FILE, parseOptions, resolveOptions);\r\n    return appConfig.withFallback(baseConfig);\r\n}"
}, {
	"Path": "com.conveyal.gtfs.model.Frequency.compareTo",
	"Comment": "must have a comparator since they go in a navigable set that is serialized",
	"Method": "int compareTo(Frequency o){\r\n    return this.start_time - o.start_time;\r\n}"
}, {
	"Path": "com.spotify.helios.agent.PortAllocator.allocate",
	"Comment": "allocate ports for port mappings with no external ports configured.",
	"Method": "Map<String, Integer> allocate(Map<String, PortMapping> ports,Set<Integer> used){\r\n    return allocate0(ports, Sets.newHashSet(used));\r\n}"
}, {
	"Path": "com.graphhopper.routing.lm.LMAlgoFactoryDecorator.setPreparationThreads",
	"Comment": "this method changes the number of threads used for preparation on import. default is 1. makesure that you have enough memory when increasing this number!",
	"Method": "void setPreparationThreads(int preparationThreads){\r\n    this.preparationThreads = preparationThreads;\r\n    this.threadPool = java.util.concurrent.Executors.newFixedThreadPool(preparationThreads);\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.GoogleJavaFormatter.formatInternal",
	"Comment": "runs the google java formatter on the given source, with only the given ranges specified.",
	"Method": "TextEdit formatInternal(int kind,String source,IRegion[] regions,int initialIndent){\r\n    try {\r\n        boolean includeComments = (kind & CodeFormatter.F_INCLUDE_COMMENTS) == CodeFormatter.F_INCLUDE_COMMENTS;\r\n        kind &= ~CodeFormatter.F_INCLUDE_COMMENTS;\r\n        SnippetKind snippetKind;\r\n        switch(kind) {\r\n            case ASTParser.K_EXPRESSION:\r\n                snippetKind = SnippetKind.EXPRESSION;\r\n                break;\r\n            case ASTParser.K_STATEMENTS:\r\n                snippetKind = SnippetKind.STATEMENTS;\r\n                break;\r\n            case ASTParser.K_CLASS_BODY_DECLARATIONS:\r\n                snippetKind = SnippetKind.CLASS_BODY_DECLARATIONS;\r\n                break;\r\n            case ASTParser.K_COMPILATION_UNIT:\r\n                snippetKind = SnippetKind.COMPILATION_UNIT;\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(String.format(\"Unknown snippet kind: %d\", kind));\r\n        }\r\n        List<Replacement> replacements = new SnippetFormatter().format(snippetKind, source, rangesFromRegions(regions), initialIndent, includeComments);\r\n        if (idempotent(source, regions, replacements)) {\r\n            return null;\r\n        }\r\n        return editFromReplacements(replacements);\r\n    } catch (IllegalArgumentException | FormatterException exception) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.spotify.helios.agent.AgentParser.validateArgument",
	"Comment": "verifies that all entries in the collection satisfy the predicate. if any do not, throw anillegalargumentexception with the specified message for the first invalid entry.",
	"Method": "List<T> validateArgument(List<T> list,Predicate<T> predicate,Function<T, String> msgFn){\r\n    final Optional<T> firstInvalid = list.stream().filter(predicate.negate()).findAny();\r\n    if (firstInvalid.isPresent()) {\r\n        throw new IllegalArgumentException(firstInvalid.map(msgFn).get());\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.ImportOrderer.reorderedImportsString",
	"Comment": "produces the sorted output based on the imports we have scanned.",
	"Method": "String reorderedImportsString(ImmutableSortedSet<Import> imports){\r\n    Preconditions.checkArgument(!imports.isEmpty(), \"imports\");\r\n    Import firstImport = imports.iterator().next();\r\n    boolean lastWasStatic = firstImport.isStatic;\r\n    StringBuilder sb = new StringBuilder();\r\n    for (Import thisImport : imports) {\r\n        if (lastWasStatic && !thisImport.isStatic) {\r\n            sb.append(lineSeparator);\r\n        }\r\n        lastWasStatic = thisImport.isStatic;\r\n        sb.append(thisImport);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.parser.Lexer.yypushback",
	"Comment": "pushes the specified amount of characters back into the input stream.they will be read again by then next call of the scanning method",
	"Method": "void yypushback(int number){\r\n    if (number > yylength())\r\n        zzScanError(ZZ_PUSHBACK_2BIG);\r\n    zzMarkedPos -= number;\r\n}"
}, {
	"Path": "com.notnoop.apns.ApnsServiceBuilder.asQueued",
	"Comment": "constructs a new thread with a processing queue to processnotification requests.",
	"Method": "ApnsServiceBuilder asQueued(ApnsServiceBuilder asQueued,ThreadFactory threadFactory){\r\n    this.isQueued = true;\r\n    this.queueThreadFactory = threadFactory;\r\n    return this;\r\n}"
}, {
	"Path": "com.graphhopper.routing.Path.forEveryEdge",
	"Comment": "iterates over all edges in this path sorted from start to end and calls the visitor callbackfor every edge.",
	"Method": "void forEveryEdge(EdgeVisitor visitor){\r\n    int tmpNode = getFromNode();\r\n    int len = edgeIds.size();\r\n    int prevEdgeId = EdgeIterator.NO_EDGE;\r\n    for (int i = 0; i < len; i++) {\r\n        EdgeIteratorState edgeBase = graph.getEdgeIteratorState(edgeIds.get(i), tmpNode);\r\n        if (edgeBase == null)\r\n            throw new IllegalStateException(\"Edge \" + edgeIds.get(i) + \" was empty when requested with node \" + tmpNode + \", array index:\" + i + \", edges:\" + edgeIds.size());\r\n        tmpNode = edgeBase.getBaseNode();\r\n        edgeBase = graph.getEdgeIteratorState(edgeBase.getEdge(), tmpNode);\r\n        visitor.next(edgeBase, i, prevEdgeId);\r\n        prevEdgeId = edgeBase.getEdge();\r\n    }\r\n    visitor.finish();\r\n}"
}, {
	"Path": "org.xhtmlrenderer.render.AbstractOutputDevice.getFontSpecification",
	"Comment": "gets the fontspecification for this abstractoutputdevice.",
	"Method": "FontSpecification getFontSpecification(){\r\n    return _fontSpec;\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeTransactionActuatorTest.SameTokenNameCloseSuccessExchangeTransaction",
	"Comment": "sametokenname close,first transaction exchange,result is success.",
	"Method": "void SameTokenNameCloseSuccessExchangeTransaction(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(0);\r\n    InitExchangeBeforeSameTokenNameActive();\r\n    long exchangeId = 1;\r\n    String tokenId = \"_\";\r\n    long quant = 100_000_000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_SECOND);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    Map<String, Long> assetMap = accountCapsule.getAssetMap();\r\n    Assert.assertEquals(20000_000000L, accountCapsule.getBalance());\r\n    Assert.assertEquals(null, assetMap.get(\"def\"));\r\n    ExchangeTransactionActuator actuator = new ExchangeTransactionActuator(getContract(OWNER_ADDRESS_SECOND, exchangeId, tokenId, quant, 1), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        ExchangeCapsule exchangeCapsule = dbManager.getExchangeStore().get(ByteArray.fromLong(exchangeId));\r\n        Assert.assertNotNull(exchangeCapsule);\r\n        long firstTokenBalance = exchangeCapsule.getFirstTokenBalance();\r\n        long secondTokenBalance = exchangeCapsule.getSecondTokenBalance();\r\n        Assert.assertEquals(exchangeId, exchangeCapsule.getID());\r\n        Assert.assertEquals(tokenId, ByteArray.toStr(exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(1_000_000_000_000L, firstTokenBalance);\r\n        Assert.assertEquals(\"abc\", ByteArray.toStr(exchangeCapsule.getSecondTokenId()));\r\n        Assert.assertEquals(10_000_000L, secondTokenBalance);\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        Assert.assertEquals(ret.getInstance().getRet(), code.SUCESS);\r\n        exchangeCapsule = dbManager.getExchangeStore().get(ByteArray.fromLong(exchangeId));\r\n        Assert.assertNotNull(exchangeCapsule);\r\n        Assert.assertEquals(exchangeId, exchangeCapsule.getID());\r\n        Assert.assertEquals(1000000, exchangeCapsule.getCreateTime());\r\n        Assert.assertTrue(Arrays.equals(tokenId.getBytes(), exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(tokenId, ByteArray.toStr(exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenBalance + quant, exchangeCapsule.getFirstTokenBalance());\r\n        Assert.assertEquals(\"abc\", ByteArray.toStr(exchangeCapsule.getSecondTokenId()));\r\n        Assert.assertEquals(9999001L, exchangeCapsule.getSecondTokenBalance());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        assetMap = accountCapsule.getAssetMap();\r\n        Assert.assertEquals(20000_000000L - quant, accountCapsule.getBalance());\r\n        Assert.assertEquals(999L, assetMap.get(\"abc\").longValue());\r\n    } catch (ContractValidateException e) {\r\n        logger.info(e.getMessage());\r\n        Assert.assertFalse(e instanceof ContractValidateException);\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    } catch (ItemNotFoundException e) {\r\n        Assert.assertFalse(e instanceof ItemNotFoundException);\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.BasicPanel.isOpaque",
	"Comment": "returns whether the background of this basicpanel willbe painted when it is rendered.",
	"Method": "boolean isOpaque(){\r\n    checkOpacityMethodClient();\r\n    return explicitlyOpaque;\r\n}"
}, {
	"Path": "com.graphhopper.storage.GraphHopperStorage.getBaseGraph",
	"Comment": "instead directly the storage can be used to traverse the base graph",
	"Method": "Graph getBaseGraph(){\r\n    return baseGraph;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Object.getType",
	"Comment": "returns the type of the value associated with this key, orundefined if the key does not exist. types are specified asinteger constants. the types are all defined in v8value.",
	"Method": "int getType(String key,int getType,String key){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    checkKey(key);\r\n    return v8.getType(v8.getV8RuntimePtr(), objectHandle, key);\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeTransactionActuatorTest.SameTokenNameCloseSuccessExchangeTransaction2",
	"Comment": "sametokenname close,second transaction exchange,result is success.",
	"Method": "void SameTokenNameCloseSuccessExchangeTransaction2(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(0);\r\n    InitExchangeBeforeSameTokenNameActive();\r\n    long exchangeId = 2;\r\n    String tokenId = \"abc\";\r\n    long quant = 1_000L;\r\n    String buyTokenId = \"def\";\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_SECOND);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmount(tokenId.getBytes(), 10000);\r\n    Map<String, Long> assetMap = accountCapsule.getAssetMap();\r\n    Assert.assertEquals(20000_000000L, accountCapsule.getBalance());\r\n    Assert.assertEquals(null, assetMap.get(buyTokenId));\r\n    dbManager.getAccountStore().put(accountCapsule.createDbKey(), accountCapsule);\r\n    ExchangeTransactionActuator actuator = new ExchangeTransactionActuator(getContract(OWNER_ADDRESS_SECOND, exchangeId, tokenId, quant, 1), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        ExchangeCapsule exchangeCapsule = dbManager.getExchangeStore().get(ByteArray.fromLong(exchangeId));\r\n        Assert.assertNotNull(exchangeCapsule);\r\n        long firstTokenBalance = exchangeCapsule.getFirstTokenBalance();\r\n        long secondTokenBalance = exchangeCapsule.getSecondTokenBalance();\r\n        Assert.assertEquals(exchangeId, exchangeCapsule.getID());\r\n        Assert.assertEquals(tokenId, ByteArray.toStr(exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(100000000L, firstTokenBalance);\r\n        Assert.assertEquals(\"def\", ByteArray.toStr(exchangeCapsule.getSecondTokenId()));\r\n        Assert.assertEquals(200000000L, secondTokenBalance);\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        Assert.assertEquals(ret.getInstance().getRet(), code.SUCESS);\r\n        exchangeCapsule = dbManager.getExchangeStore().get(ByteArray.fromLong(exchangeId));\r\n        Assert.assertNotNull(exchangeCapsule);\r\n        Assert.assertEquals(exchangeId, exchangeCapsule.getID());\r\n        Assert.assertEquals(1000000, exchangeCapsule.getCreateTime());\r\n        Assert.assertTrue(Arrays.equals(tokenId.getBytes(), exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(tokenId, ByteArray.toStr(exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenBalance + quant, exchangeCapsule.getFirstTokenBalance());\r\n        Assert.assertEquals(\"def\", ByteArray.toStr(exchangeCapsule.getSecondTokenId()));\r\n        Assert.assertEquals(199998001L, exchangeCapsule.getSecondTokenBalance());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        assetMap = accountCapsule.getAssetMap();\r\n        Assert.assertEquals(9000L, assetMap.get(\"abc\").longValue());\r\n        Assert.assertEquals(1999L, assetMap.get(\"def\").longValue());\r\n    } catch (ContractValidateException e) {\r\n        logger.info(e.getMessage());\r\n        Assert.assertFalse(e instanceof ContractValidateException);\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    } catch (ItemNotFoundException e) {\r\n        Assert.assertFalse(e instanceof ItemNotFoundException);\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.debug.BreakEvent.getSourceColumn",
	"Comment": "returns the source column that this break event occurred on.",
	"Method": "int getSourceColumn(){\r\n    return v8Object.executeIntegerFunction(SOURCE_COLUMN, null);\r\n}"
}, {
	"Path": "org.tron.core.actuator.TransferAssetActuatorTest.SameTokenNameCloseOwnerNoThisAsset",
	"Comment": "sametokenname close,account do not have this asset,transfer this asset result is failed",
	"Method": "void SameTokenNameCloseOwnerNoThisAsset(){\r\n    createAssertBeforSameTokenNameActive();\r\n    AccountCapsule ownerAssetCapsule = new AccountCapsule(ByteString.copyFrom(ByteArray.fromHexString(ownerAsset_ADDRESS)), ByteString.copyFromUtf8(\"ownerAsset\"), AccountType.AssetIssue);\r\n    ownerAssetCapsule.addAsset(ownerASSET_NAME.getBytes(), OWNER_ASSET_Test_BALANCE);\r\n    AssetIssueContract assetIssueTestContract = AssetIssueContract.newBuilder().setOwnerAddress(ByteString.copyFrom(ByteArray.fromHexString(ownerAsset_ADDRESS))).setName(ByteString.copyFrom(ByteArray.fromString(ownerASSET_NAME))).setTotalSupply(TOTAL_SUPPLY).setTrxNum(TRX_NUM).setNum(NUM).setStartTime(START_TIME).setEndTime(END_TIME).setVoteScore(VOTE_SCORE).setDescription(ByteString.copyFrom(ByteArray.fromString(DESCRIPTION))).setUrl(ByteString.copyFrom(ByteArray.fromString(URL))).build();\r\n    AssetIssueCapsule assetIssueCapsule = new AssetIssueCapsule(assetIssueTestContract);\r\n    dbManager.getAccountStore().put(ownerAssetCapsule.getAddress().toByteArray(), ownerAssetCapsule);\r\n    dbManager.getAssetIssueStore().put(assetIssueCapsule.createDbKey(), assetIssueCapsule);\r\n    TransferAssetActuator actuator = new TransferAssetActuator(getContract(1, ownerASSET_NAME), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        Assert.assertTrue(false);\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertTrue(\"assetBalance must greater than 0.\".equals(e.getMessage()));\r\n        AccountCapsule owner = dbManager.getAccountStore().get(ByteArray.fromHexString(OWNER_ADDRESS));\r\n        AccountCapsule toAccount = dbManager.getAccountStore().get(ByteArray.fromHexString(TO_ADDRESS));\r\n        Assert.assertEquals(owner.getAssetMap().get(ASSET_NAME).longValue(), OWNER_ASSET_BALANCE);\r\n        Assert.assertTrue(isNullOrZero(toAccount.getAssetMap().get(ASSET_NAME)));\r\n        AccountCapsule ownerAsset = dbManager.getAccountStore().get(ByteArray.fromHexString(ownerAsset_ADDRESS));\r\n        Assert.assertEquals(ownerAsset.getAssetMap().get(ownerASSET_NAME).longValue(), OWNER_ASSET_Test_BALANCE);\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "org.tron.core.capsule.utils.BlockUtil.isParentOf",
	"Comment": "whether the hash of the judge block is equal to the hash of the parent block.",
	"Method": "boolean isParentOf(BlockCapsule blockCapsule1,BlockCapsule blockCapsule2){\r\n    return blockCapsule1.getBlockId().equals(blockCapsule2.getParentHash());\r\n}"
}, {
	"Path": "org.immutables.value.processor.meta.ValueAttributeFunctions.isGenerateDefault",
	"Comment": "predicate on instance of discoveredattribute that evaluates attribute isgeneratedefault.",
	"Method": "Predicate<ValueAttribute> isGenerateDefault(){\r\n    return IsGenerateDefaultPredicate.INSTANCE;\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeTransactionActuatorTest.SameTokenNameCloseTokenRequiredNotEnough",
	"Comment": "sametokenname close,token required must greater than expected",
	"Method": "void SameTokenNameCloseTokenRequiredNotEnough(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(0);\r\n    InitExchangeBeforeSameTokenNameActive();\r\n    long exchangeId = 2;\r\n    String tokenId = \"abc\";\r\n    long quant = 1_000L;\r\n    String buyTokenId = \"def\";\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_SECOND);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmount(tokenId.getBytes(), quant);\r\n    Map<String, Long> assetMap = accountCapsule.getAssetMap();\r\n    Assert.assertEquals(20000_000000L, accountCapsule.getBalance());\r\n    Assert.assertEquals(null, assetMap.get(buyTokenId));\r\n    dbManager.getAccountStore().put(accountCapsule.createDbKey(), accountCapsule);\r\n    long expected = 0;\r\n    try {\r\n        ExchangeCapsule exchangeCapsule = dbManager.getExchangeStore().get(ByteArray.fromLong(exchangeId));\r\n        expected = exchangeCapsule.transaction(tokenId.getBytes(), quant);\r\n    } catch (ItemNotFoundException e) {\r\n        fail();\r\n    }\r\n    ExchangeTransactionActuator actuator = new ExchangeTransactionActuator(getContract(OWNER_ADDRESS_SECOND, exchangeId, tokenId, quant, expected + 1), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail(\"should not run here\");\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"token required must greater than expected\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.DownscaleQuality.forString",
	"Comment": "retrieves the downscalequality instance for the corresponding string.",
	"Method": "DownscaleQuality forString(String type,DownscaleQuality dflt){\r\n    DownscaleQuality q = (DownscaleQuality) constList.get(type);\r\n    return q == null ? dflt : q;\r\n}"
}, {
	"Path": "com.graphhopper.util.Instruction.calcAzimuth",
	"Comment": "return the azimuth in degree based on the first tracksegment of this instruction. if thisinstruction contains less than 2 points then nan will be returned or the specifiedinstruction will be used if that is the finish instruction.",
	"Method": "double calcAzimuth(Instruction nextI){\r\n    double nextLat;\r\n    double nextLon;\r\n    if (points.getSize() >= 2) {\r\n        nextLat = points.getLatitude(1);\r\n        nextLon = points.getLongitude(1);\r\n    } else if (nextI != null && points.getSize() == 1) {\r\n        nextLat = nextI.points.getLatitude(0);\r\n        nextLon = nextI.points.getLongitude(0);\r\n    } else {\r\n        return Double.NaN;\r\n    }\r\n    double lat = points.getLatitude(0);\r\n    double lon = points.getLongitude(0);\r\n    return AC.calcAzimuth(lat, lon, nextLat, nextLon);\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.MotorcycleFlagEncoder.increaseBendinessImpact",
	"Comment": "a good bendiness should become a greater impact. a bendiness close to 1 should not bechanged.",
	"Method": "double increaseBendinessImpact(double bendiness){\r\n    return (Math.pow(bendiness, 2));\r\n}"
}, {
	"Path": "com.notnoop.apns.APNS.newService",
	"Comment": "returns a new apns service for sending iphone notifications",
	"Method": "ApnsServiceBuilder newService(){\r\n    return new ApnsServiceBuilder();\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.extend.XhtmlCssOnlyNamespaceHandler.getStylesheets",
	"Comment": "gets the stylesheetlinks attribute of the xhtmlnamespacehandler object",
	"Method": "StylesheetInfo[] getStylesheets(org.w3c.dom.Document doc){\r\n    List result = new ArrayList();\r\n    result.addAll(Arrays.asList(super.getStylesheets(doc)));\r\n    Element html = doc.getDocumentElement();\r\n    Element head = findFirstChild(html, \"head\");\r\n    if (head != null) {\r\n        Node current = head.getFirstChild();\r\n        while (current != null) {\r\n            if (current.getNodeType() == Node.ELEMENT_NODE) {\r\n                Element elem = (Element) current;\r\n                StylesheetInfo info = null;\r\n                String elemName = elem.getLocalName();\r\n                if (elemName == null) {\r\n                    elemName = elem.getTagName();\r\n                }\r\n                if (elemName.equals(\"link\")) {\r\n                    info = readLinkElement(elem);\r\n                } else if (elemName.equals(\"style\")) {\r\n                    info = readStyleElement(elem);\r\n                }\r\n                if (info != null) {\r\n                    result.add(info);\r\n                }\r\n            }\r\n            current = current.getNextSibling();\r\n        }\r\n    }\r\n    return (StylesheetInfo[]) result.toArray(new StylesheetInfo[result.size()]);\r\n}"
}, {
	"Path": "stest.tron.wallet.common.client.utils.Sha256Hash.twiceOf",
	"Comment": "creates a new instance containing the hash of the calculated hash of the given bytes.",
	"Method": "Sha256Hash twiceOf(byte[] contents){\r\n    return wrap(hashTwice(contents));\r\n}"
}, {
	"Path": "org.kie.pmml.pmml_4_2.PMML4Helper.copy",
	"Comment": "returns a copy of the object, or null if the object cannotbe serialized.",
	"Method": "Object copy(Object orig){\r\n    Object obj = null;\r\n    try {\r\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n        ObjectOutputStream out = new ObjectOutputStream(bos);\r\n        out.writeObject(orig);\r\n        out.flush();\r\n        out.close();\r\n        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));\r\n        obj = in.readObject();\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } catch (ClassNotFoundException cnfe) {\r\n        cnfe.printStackTrace();\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeTransactionActuatorTest.SameTokenNameOpenSuccessExchangeTransaction2",
	"Comment": "sametokenname open,second transaction exchange,result is success.",
	"Method": "void SameTokenNameOpenSuccessExchangeTransaction2(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    InitExchangeSameTokenNameActive();\r\n    long exchangeId = 2;\r\n    String tokenId = \"123\";\r\n    long quant = 1_000L;\r\n    String buyTokenId = \"456\";\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_SECOND);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmountV2(tokenId.getBytes(), 10000, dbManager);\r\n    Map<String, Long> assetV2Map = accountCapsule.getAssetMapV2();\r\n    Assert.assertEquals(20000_000000L, accountCapsule.getBalance());\r\n    Assert.assertEquals(null, assetV2Map.get(buyTokenId));\r\n    dbManager.getAccountStore().put(accountCapsule.createDbKey(), accountCapsule);\r\n    ExchangeTransactionActuator actuator = new ExchangeTransactionActuator(getContract(OWNER_ADDRESS_SECOND, exchangeId, tokenId, quant, 1), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        ExchangeCapsule exchangeCapsuleV2 = dbManager.getExchangeV2Store().get(ByteArray.fromLong(exchangeId));\r\n        Assert.assertNotNull(exchangeCapsuleV2);\r\n        long firstTokenBalance = exchangeCapsuleV2.getFirstTokenBalance();\r\n        long secondTokenBalance = exchangeCapsuleV2.getSecondTokenBalance();\r\n        Assert.assertEquals(exchangeId, exchangeCapsuleV2.getID());\r\n        Assert.assertEquals(tokenId, ByteArray.toStr(exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(100000000L, firstTokenBalance);\r\n        Assert.assertEquals(\"456\", ByteArray.toStr(exchangeCapsuleV2.getSecondTokenId()));\r\n        Assert.assertEquals(200000000L, secondTokenBalance);\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        Assert.assertEquals(ret.getInstance().getRet(), code.SUCESS);\r\n        exchangeCapsuleV2 = dbManager.getExchangeV2Store().get(ByteArray.fromLong(exchangeId));\r\n        Assert.assertNotNull(exchangeCapsuleV2);\r\n        Assert.assertEquals(exchangeId, exchangeCapsuleV2.getID());\r\n        Assert.assertEquals(1000000, exchangeCapsuleV2.getCreateTime());\r\n        Assert.assertTrue(Arrays.equals(tokenId.getBytes(), exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(tokenId, ByteArray.toStr(exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenBalance + quant, exchangeCapsuleV2.getFirstTokenBalance());\r\n        Assert.assertEquals(\"456\", ByteArray.toStr(exchangeCapsuleV2.getSecondTokenId()));\r\n        Assert.assertEquals(199998001L, exchangeCapsuleV2.getSecondTokenBalance());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        assetV2Map = accountCapsule.getAssetMapV2();\r\n        Assert.assertEquals(9000L, assetV2Map.get(\"123\").longValue());\r\n        Assert.assertEquals(1999L, assetV2Map.get(\"456\").longValue());\r\n    } catch (ContractValidateException e) {\r\n        logger.info(e.getMessage());\r\n        Assert.assertFalse(e instanceof ContractValidateException);\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    } catch (ItemNotFoundException e) {\r\n        Assert.assertFalse(e instanceof ItemNotFoundException);\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.reader.osm.OSMReader.preProcess",
	"Comment": "preprocessing of osm file to select nodes which are used for highways. this allows a morecompact graph data structure.",
	"Method": "void preProcess(File osmFile){\r\n    try (OSMInput in = openOsmInputFile(osmFile)) {\r\n        long tmpWayCounter = 1;\r\n        long tmpRelationCounter = 1;\r\n        ReaderElement item;\r\n        while ((item = in.getNext()) != null) {\r\n            if (item.isType(ReaderElement.WAY)) {\r\n                final ReaderWay way = (ReaderWay) item;\r\n                boolean valid = filterWay(way);\r\n                if (valid) {\r\n                    LongIndexedContainer wayNodes = way.getNodes();\r\n                    int s = wayNodes.size();\r\n                    for (int index = 0; index < s; index++) {\r\n                        prepareHighwayNode(wayNodes.get(index));\r\n                    }\r\n                    if (++tmpWayCounter % 10_000_000 == 0) {\r\n                        LOGGER.info(nf(tmpWayCounter) + \" (preprocess), osmIdMap:\" + nf(getNodeMap().getSize()) + \" (\" + getNodeMap().getMemoryUsage() + \"MB) \" + Helper.getMemInfo());\r\n                    }\r\n                }\r\n            } else if (item.isType(ReaderElement.RELATION)) {\r\n                final ReaderRelation relation = (ReaderRelation) item;\r\n                if (!relation.isMetaRelation() && relation.hasTag(\"type\", \"route\"))\r\n                    prepareWaysWithRelationInfo(relation);\r\n                if (relation.hasTag(\"type\", \"restriction\"))\r\n                    prepareRestrictionRelation(relation);\r\n                if (++tmpRelationCounter % 100_000 == 0) {\r\n                    LOGGER.info(nf(tmpRelationCounter) + \" (preprocess), osmWayMap:\" + nf(getRelFlagsMap().size()) + \" \" + Helper.getMemInfo());\r\n                }\r\n            } else if (item.isType(ReaderElement.FILEHEADER)) {\r\n                final OSMFileHeader fileHeader = (OSMFileHeader) item;\r\n                osmDataDate = Helper.createFormatter().parse(fileHeader.getTag(\"timestamp\"));\r\n            }\r\n        }\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(\"Problem while parsing file\", ex);\r\n    }\r\n}"
}, {
	"Path": "com.google.googlejavaformat.OpsBuilder.guessToken",
	"Comment": "emit an optional token iff it exists on the input. this is used to emit tokens whose existencehas been lost in the ast.",
	"Method": "void guessToken(String token){\r\n    token(token, Doc.Token.RealOrImaginary.IMAGINARY, ZERO, Optional.empty());\r\n}"
}, {
	"Path": "org.kie.pmml.pmml_4_2.predictive.models.ScorecardTest.testScorecardWithCompoundPredicate",
	"Comment": "the scorecard used in the following test contains multiple outputsand thus tests to make sure that no duplicate rule names are generated",
	"Method": "void testScorecardWithCompoundPredicate(){\r\n    PMML4ExecutionHelper helper = PMML4ExecutionHelperFactory.getExecutionHelper(\"ScorecardCompoundPredicate\", ResourceFactory.newClassPathResource(SOURCE_COMPOUND_PREDICATE_SCORECARD), null);\r\n    PMMLRequestData requestData = new PMMLRequestDataBuilder(\"123\", helper.getModelName()).addParameter(\"param1\", 41.0, Double.class).addParameter(\"param2\", 21.0, Double.class).build();\r\n    PMML4Result resultHolder = helper.submitRequest(requestData);\r\n    double score = resultHolder.getResultValue(\"ScoreCard\", \"score\", Double.class).get();\r\n    Assertions.assertThat(score).isEqualTo(120.8);\r\n    Map<String, Double> rankingMap = (Map<String, Double>) resultHolder.getResultValue(\"ScoreCard\", \"ranking\");\r\n    Assertions.assertThat(rankingMap.get(\"reasonCh1\")).isEqualTo(50);\r\n    Assertions.assertThat(rankingMap.get(\"reasonCh2\")).isEqualTo(5);\r\n    requestData = new PMMLRequestData(\"123\", \"ScorecardCompoundPredicate\");\r\n    requestData.addRequestParam(\"param1\", 40.0);\r\n    requestData.addRequestParam(\"param2\", 25.0);\r\n    resultHolder = helper.submitRequest(requestData);\r\n    score = resultHolder.getResultValue(\"ScoreCard\", \"score\", Double.class).get();\r\n    Assertions.assertThat(score).isEqualTo(120.8);\r\n    requestData = new PMMLRequestData(\"123\", \"ScorecardCompoundPredicate\");\r\n    requestData.addRequestParam(\"param1\", 40.0);\r\n    requestData.addRequestParam(\"param2\", 55.0);\r\n    resultHolder = helper.submitRequest(requestData);\r\n    score = resultHolder.getResultValue(\"ScoreCard\", \"score\", Double.class).get();\r\n    Assertions.assertThat(score).isEqualTo(210.8);\r\n    requestData = new PMMLRequestData(\"123\", \"ScorecardCompoundPredicate\");\r\n    requestData.addRequestParam(\"param1\", 4.0);\r\n    requestData.addRequestParam(\"param2\", -25.0);\r\n    resultHolder = helper.submitRequest(requestData);\r\n    score = resultHolder.getResultValue(\"ScoreCard\", \"score\", Double.class).get();\r\n    Assertions.assertThat(score).isEqualTo(30.8);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.resource.FSCatalog.parseCatalog",
	"Comment": "parses an xml catalog file and returns a map of public ids to local uris readfrom the catalog. only the catalog public elements are parsed.",
	"Method": "Map parseCatalog(String catalogURI,Map parseCatalog,InputSource inputSource){\r\n    XMLReader xmlReader = XMLResource.newXMLReader();\r\n    CatalogContentHandler ch = new CatalogContentHandler();\r\n    addHandlers(xmlReader, ch);\r\n    setFeature(xmlReader, \"http://xml.org/sax/features/validation\", false);\r\n    try {\r\n        xmlReader.parse(inputSource);\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(\"Failed on configuring SAX to DOM transformer.\", ex);\r\n    }\r\n    return ch.getEntityMap();\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeCreateActuatorTest.sameTokenNameOpenSecondTokenNotExist",
	"Comment": "sametokenname open,not trx,ont token is ok, but the second one is not exist.",
	"Method": "void sameTokenNameOpenSecondTokenNotExist(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    String firstTokenId = \"123\";\r\n    long firstTokenBalance = 100_000_000_000000L;\r\n    String secondTokenId = \"456\";\r\n    long secondTokenBalance = 100_000_000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmount(firstTokenId.getBytes(), firstTokenBalance);\r\n    accountCapsule.setBalance(10000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeCreateActuator actuator = new ExchangeCreateActuator(getContract(OWNER_ADDRESS_FIRST, firstTokenId, firstTokenBalance, secondTokenId, secondTokenBalance), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    Assert.assertEquals(dbManager.getDynamicPropertiesStore().getLatestExchangeNum(), 0);\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"first token balance is not enough\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "com.spotify.helios.servicescommon.ZooKeeperAclProvidersTest.testOnlyAgentsAndMastersHaveAccess",
	"Comment": "none but masters and agents should have any permissions to any paths",
	"Method": "void testOnlyAgentsAndMastersHaveAccess(){\r\n    final List<String> paths = Lists.newArrayList(\"/\", \"/some/random/path\", \"/config/hosts\");\r\n    for (final String path : paths) {\r\n        final List<ACL> acls = aclProvider.getAclForPath(path);\r\n        for (final ACL acl : acls) {\r\n            assertThat(acl.getId(), anyOf(equalTo(AGENT_ID), equalTo(MASTER_ID)));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.googlejavaformat.FormatterDiagnostic.message",
	"Comment": "returns a description of the problem that prevented formatting from succeeding.",
	"Method": "String message(){\r\n    return message;\r\n}"
}, {
	"Path": "org.tron.common.crypto.cryptohash.DigestEngine.flush",
	"Comment": "flush internal buffers, so that less than a block of data may at most be upheld.",
	"Method": "int flush(){\r\n    return inputLen;\r\n}"
}, {
	"Path": "com.spotify.helios.client.HeliosClient.jobs",
	"Comment": "lists all jobs in the cluster whose name starts with the given string, and that are deployed tohosts that match the given name pattern.",
	"Method": "ListenableFuture<Map<JobId, Job>> jobs(ListenableFuture<Map<JobId, Job>> jobs,String jobQuery,ListenableFuture<Map<JobId, Job>> jobs,String jobQuery,String hostNamePattern){\r\n    final Map<String, String> params = new HashMap();\r\n    if (!Strings.isNullOrEmpty(jobQuery)) {\r\n        params.put(\"q\", jobQuery);\r\n    }\r\n    if (!Strings.isNullOrEmpty(hostNamePattern)) {\r\n        params.put(\"hostPattern\", hostNamePattern);\r\n    }\r\n    return get(uri(\"/jobs\", params), jobIdMap);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.getSCMRevision",
	"Comment": "returns the revision id of this version as specifiedby the source code management system. currently we usegit, so this will return the commit id for this revision.",
	"Method": "String getSCMRevision(){\r\n    return \"Unknown revision ID\";\r\n}"
}, {
	"Path": "com.graphhopper.routing.lm.LMAlgoFactoryDecorator.setWeightingsAsStrings",
	"Comment": "enables the use of contraction hierarchies to reduce query times. enabled by default.",
	"Method": "LMAlgoFactoryDecorator setWeightingsAsStrings(List<String> weightingList){\r\n    if (weightingList.isEmpty())\r\n        throw new IllegalArgumentException(\"It is not allowed to pass an emtpy weightingList\");\r\n    weightingsAsStrings.clear();\r\n    for (String strWeighting : weightingList) {\r\n        strWeighting = toLowerCase(strWeighting);\r\n        strWeighting = strWeighting.trim();\r\n        addWeighting(strWeighting);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.graphhopper.GraphHopper.calcPaths",
	"Comment": "this method calculates the alternative path list using the low level path objects.",
	"Method": "List<Path> calcPaths(GHRequest request,GHResponse ghRsp){\r\n    if (ghStorage == null || !fullyLoaded)\r\n        throw new IllegalStateException(\"Do a successful call to load or importOrLoad before routing\");\r\n    if (ghStorage.isClosed())\r\n        throw new IllegalStateException(\"You need to create a new GraphHopper instance as it is already closed\");\r\n    String vehicle = request.getVehicle();\r\n    if (vehicle.isEmpty()) {\r\n        vehicle = getDefaultVehicle().toString();\r\n        request.setVehicle(vehicle);\r\n    }\r\n    Lock readLock = readWriteLock.readLock();\r\n    readLock.lock();\r\n    try {\r\n        if (!encodingManager.supports(vehicle))\r\n            throw new IllegalArgumentException(\"Vehicle not supported: \" + vehicle + \". Supported are: \" + encodingManager.toString());\r\n        HintsMap hints = request.getHints();\r\n        String tModeStr = hints.get(\"traversal_mode\", traversalMode.toString());\r\n        TraversalMode tMode = TraversalMode.fromString(tModeStr);\r\n        if (hints.has(Routing.EDGE_BASED))\r\n            tMode = hints.getBool(Routing.EDGE_BASED, false) ? TraversalMode.EDGE_BASED_2DIR : TraversalMode.NODE_BASED;\r\n        FlagEncoder encoder = encodingManager.getEncoder(vehicle);\r\n        boolean disableCH = hints.getBool(CH.DISABLE, false);\r\n        if (!chFactoryDecorator.isDisablingAllowed() && disableCH)\r\n            throw new IllegalArgumentException(\"Disabling CH not allowed on the server-side\");\r\n        boolean disableLM = hints.getBool(Landmark.DISABLE, false);\r\n        if (!lmFactoryDecorator.isDisablingAllowed() && disableLM)\r\n            throw new IllegalArgumentException(\"Disabling LM not allowed on the server-side\");\r\n        String algoStr = request.getAlgorithm();\r\n        if (algoStr.isEmpty())\r\n            algoStr = chFactoryDecorator.isEnabled() && !disableCH ? DIJKSTRA_BI : ASTAR_BI;\r\n        List<GHPoint> points = request.getPoints();\r\n        checkIfPointsAreInBounds(points);\r\n        RoutingTemplate routingTemplate;\r\n        if (ROUND_TRIP.equalsIgnoreCase(algoStr))\r\n            routingTemplate = new RoundTripRoutingTemplate(request, ghRsp, locationIndex, maxRoundTripRetries);\r\n        else if (ALT_ROUTE.equalsIgnoreCase(algoStr))\r\n            routingTemplate = new AlternativeRoutingTemplate(request, ghRsp, locationIndex);\r\n        else\r\n            routingTemplate = new ViaRoutingTemplate(request, ghRsp, locationIndex);\r\n        List<Path> altPaths = null;\r\n        int maxRetries = routingTemplate.getMaxRetries();\r\n        Locale locale = request.getLocale();\r\n        Translation tr = trMap.getWithFallBack(locale);\r\n        for (int i = 0; i < maxRetries; i++) {\r\n            StopWatch sw = new StopWatch().start();\r\n            List<QueryResult> qResults = routingTemplate.lookup(points, encoder);\r\n            ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\r\n            if (ghRsp.hasErrors())\r\n                return Collections.emptyList();\r\n            RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory(hints);\r\n            Weighting weighting;\r\n            QueryGraph queryGraph;\r\n            if (chFactoryDecorator.isEnabled() && !disableCH) {\r\n                boolean forceCHHeading = hints.getBool(CH.FORCE_HEADING, false);\r\n                if (!forceCHHeading && request.hasFavoredHeading(0))\r\n                    throw new IllegalArgumentException(\"Heading is not (fully) supported for CHGraph. See issue #483\");\r\n                RoutingAlgorithmFactory chAlgoFactory = tmpAlgoFactory;\r\n                if (tmpAlgoFactory instanceof LMAlgoFactoryDecorator.LMRAFactory)\r\n                    chAlgoFactory = ((LMAlgoFactoryDecorator.LMRAFactory) tmpAlgoFactory).getDefaultAlgoFactory();\r\n                if (chAlgoFactory instanceof PrepareContractionHierarchies)\r\n                    weighting = ((PrepareContractionHierarchies) chAlgoFactory).getWeighting();\r\n                else\r\n                    throw new IllegalStateException(\"Although CH was enabled a non-CH algorithm factory was returned \" + tmpAlgoFactory);\r\n                tMode = getCHFactoryDecorator().getNodeBase();\r\n                queryGraph = new QueryGraph(ghStorage.getGraph(CHGraph.class, weighting));\r\n                queryGraph.lookup(qResults);\r\n            } else {\r\n                checkNonChMaxWaypointDistance(points);\r\n                queryGraph = new QueryGraph(ghStorage);\r\n                queryGraph.lookup(qResults);\r\n                weighting = createWeighting(hints, encoder, queryGraph);\r\n                ghRsp.addDebugInfo(\"tmode:\" + tMode.toString());\r\n            }\r\n            int maxVisitedNodesForRequest = hints.getInt(Routing.MAX_VISITED_NODES, maxVisitedNodes);\r\n            if (maxVisitedNodesForRequest > maxVisitedNodes)\r\n                throw new IllegalArgumentException(\"The max_visited_nodes parameter has to be below or equal to:\" + maxVisitedNodes);\r\n            weighting = createTurnWeighting(queryGraph, weighting, tMode);\r\n            AlgorithmOptions algoOpts = AlgorithmOptions.start().algorithm(algoStr).traversalMode(tMode).weighting(weighting).maxVisitedNodes(maxVisitedNodesForRequest).hints(hints).build();\r\n            altPaths = routingTemplate.calcPaths(queryGraph, tmpAlgoFactory, algoOpts);\r\n            boolean tmpEnableInstructions = hints.getBool(Routing.INSTRUCTIONS, enableInstructions);\r\n            boolean tmpCalcPoints = hints.getBool(Routing.CALC_POINTS, calcPoints);\r\n            double wayPointMaxDistance = hints.getDouble(Routing.WAY_POINT_MAX_DISTANCE, 1d);\r\n            DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);\r\n            PathMerger pathMerger = new PathMerger().setCalcPoints(tmpCalcPoints).setDouglasPeucker(peucker).setEnableInstructions(tmpEnableInstructions).setPathDetailsBuilders(pathBuilderFactory, request.getPathDetails()).setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0);\r\n            if (request.hasFavoredHeading(0))\r\n                pathMerger.setFavoredHeading(request.getFavoredHeading(0));\r\n            if (routingTemplate.isReady(pathMerger, tr))\r\n                break;\r\n        }\r\n        return altPaths;\r\n    } catch (IllegalArgumentException ex) {\r\n        ghRsp.addError(ex);\r\n        return Collections.emptyList();\r\n    } finally {\r\n        readLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.immutables.value.processor.meta.ValueAttributeFunctions.isGenerateAbstract",
	"Comment": "predicate on instance of discoveredattribute that evaluates attribute isgenerateabstract.",
	"Method": "Predicate<ValueAttribute> isGenerateAbstract(){\r\n    return IsGenerateAbstractPredicate.INSTANCE;\r\n}"
}, {
	"Path": "com.graphhopper.reader.osm.OSMReader.addBarrierEdge",
	"Comment": "add a zero length edge with reduced routing options to the graph.",
	"Method": "Collection<EdgeIteratorState> addBarrierEdge(long fromId,long toId,long flags,long nodeFlags,long wayOsmId){\r\n    flags &= ~nodeFlags;\r\n    barrierNodeIds.clear();\r\n    barrierNodeIds.add(fromId);\r\n    barrierNodeIds.add(toId);\r\n    return addOSMWay(barrierNodeIds, flags, wayOsmId);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.utils.V8Executor.hasException",
	"Comment": "determines if an exception was thrown during the javascript execution.",
	"Method": "boolean hasException(){\r\n    return exception != null;\r\n}"
}, {
	"Path": "com.graphhopper.util.Instruction.getFirstLat",
	"Comment": "latitude of the location where this instruction should take place.",
	"Method": "double getFirstLat(){\r\n    return points.getLatitude(0);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.newmatch.CascadedStyle.createLayoutStyle",
	"Comment": "creates a cascadedstyle using style information fromstartingpoint and then adding the property declarationsfrom decls.",
	"Method": "CascadedStyle createLayoutStyle(PropertyDeclaration[] decls,CascadedStyle createLayoutStyle,List decls,CascadedStyle createLayoutStyle,CascadedStyle startingPoint,PropertyDeclaration[] decls){\r\n    return new CascadedStyle(startingPoint, Arrays.asList(decls).iterator());\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8TypedArray.getStructureSize",
	"Comment": "computes the size of the structures required for each typedarray variation.",
	"Method": "int getStructureSize(int type){\r\n    switch(type) {\r\n        case V8Value.FLOAT_64_ARRAY:\r\n            return 8;\r\n        case V8Value.INT_32_ARRAY:\r\n        case V8Value.UNSIGNED_INT_32_ARRAY:\r\n        case V8Value.FLOAT_32_ARRAY:\r\n            return 4;\r\n        case V8Value.UNSIGNED_INT_16_ARRAY:\r\n        case V8Value.INT_16_ARRAY:\r\n            return 2;\r\n        case V8Value.INT_8_ARRAY:\r\n        case V8Value.UNSIGNED_INT_8_ARRAY:\r\n        case V8Value.UNSIGNED_INT_8_CLAMPED_ARRAY:\r\n            return 1;\r\n        default:\r\n            throw new IllegalArgumentException(\"Cannot create a typed array of type \" + V8Value.getStringRepresentation(type));\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.BoxRenderer.render",
	"Comment": "renders the xml document if necessary and returns the root box. if already rendered, same box\treference will be returned.",
	"Method": "Box render(){\r\n    if (!rendered) {\r\n        setDocument(loadDocument(sourceDocument), sourceDocumentBase, new XhtmlNamespaceHandler());\r\n        layout(this.width);\r\n        height = this.height == -1 ? root.getHeight() : this.height;\r\n        BufferedImage outputImage = createBufferedImage(this.width, height);\r\n        outputDevice = new Java2DOutputDevice(outputImage);\r\n        Graphics2D newG = (Graphics2D) outputImage.getGraphics();\r\n        try {\r\n            if (renderingHints != null) {\r\n                newG.getRenderingHints().putAll(renderingHints);\r\n            }\r\n            RenderingContext rc = sharedContext.newRenderingContextInstance();\r\n            rc.setFontContext(new Java2DFontContext(newG));\r\n            rc.setOutputDevice(outputDevice);\r\n            sharedContext.getTextRenderer().setup(rc.getFontContext());\r\n            root.getLayer().paint(rc);\r\n        } finally {\r\n            if (newG != null)\r\n                newG.dispose();\r\n        }\r\n        rendered = true;\r\n    }\r\n    return root;\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeWithdrawActuatorTest.SameTokenNameOpenTnotherTokenQuantLessThanZero",
	"Comment": "sametokenname open, withdraw another token quant must greater than zero",
	"Method": "void SameTokenNameOpenTnotherTokenQuantLessThanZero(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    InitExchangeSameTokenNameActive();\r\n    long exchangeId = 1;\r\n    String firstTokenId = \"123\";\r\n    long quant = 1L;\r\n    String secondTokenId = \"456\";\r\n    long secondTokenQuant = 400000000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmountV2(firstTokenId.getBytes(), 1000L, dbManager);\r\n    accountCapsule.addAssetAmountV2(secondTokenId.getBytes(), secondTokenQuant, dbManager);\r\n    accountCapsule.setBalance(10000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeWithdrawActuator actuator = new ExchangeWithdrawActuator(getContract(OWNER_ADDRESS_FIRST, exchangeId, secondTokenId, quant), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"withdraw another token quant must greater than zero\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.utils.V8ObjectUtils.toMap",
	"Comment": "creates a map from a v8object using a deep copy and a typeadapter to handletype conversions. all elements in the v8object are released after they are accessed.however, the root object itself is not released.",
	"Method": "Map<String, ? super Object> toMap(V8Object object,Map<String, ? super Object> toMap,V8Object object,TypeAdapter adapter,Map<String, ? super Object> toMap,V8Object v8Object,V8Map<Object> cache,TypeAdapter adapter){\r\n    if (v8Object == null) {\r\n        return Collections.emptyMap();\r\n    }\r\n    if (cache.containsKey(v8Object)) {\r\n        return (Map<String, ? super Object>) cache.get(v8Object);\r\n    }\r\n    Map<String, ? super Object> result = new V8PropertyMap<Object>();\r\n    cache.put(v8Object, result);\r\n    String[] keys = v8Object.getKeys();\r\n    for (String key : keys) {\r\n        Object object = null;\r\n        int type = V8Value.UNDEFINED;\r\n        try {\r\n            object = v8Object.get(key);\r\n            type = v8Object.getType(key);\r\n            Object value = getValue(object, type, cache, adapter);\r\n            if (value != IGNORE) {\r\n                result.put(key, value);\r\n            }\r\n        } finally {\r\n            if (object instanceof Releasable) {\r\n                ((Releasable) object).release();\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.constants.CSSName.toString",
	"Comment": "returns a string representation of the object, in this case, always thefull css property name in lowercase.",
	"Method": "String toString(){\r\n    return this.propName;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.ImageRenderer.renderToImage",
	"Comment": "renders the xml file as an image file at the target location. width must be provided, height is determined\tautomatically based on content and css.",
	"Method": "BufferedImage renderToImage(String url,String path,int width,BufferedImage renderToImage,String url,String path,int width,int height,BufferedImage renderToImage,File inFile,String path,int width,BufferedImage renderToImage,File inFile,String path,int width,int height){\r\n    return renderToImage(inFile.toURI().toURL().toExternalForm(), path, width, height);\r\n}"
}, {
	"Path": "org.immutables.fixture.encoding.defs.OptionalMap.getImmutable",
	"Comment": "alternatively it can be exposed as optional of immutablemap",
	"Method": "Optional<ImmutableMap<K, V>> getImmutable(){\r\n    return Optional.ofNullable(map);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.GeneralUtil.dumpShortException",
	"Comment": "dumps an exception to the console, only the last 5 lines of the stacktrace.",
	"Method": "void dumpShortException(Exception ex){\r\n    String s = ex.getMessage();\r\n    if (s == null || s.trim().equals(\"null\")) {\r\n        s = \"{no ex. message}\";\r\n    }\r\n    System.out.println(s + \", \" + ex.getClass());\r\n    StackTraceElement[] stes = ex.getStackTrace();\r\n    for (int i = 0; i < stes.length && i < 5; i++) {\r\n        StackTraceElement ste = stes[i];\r\n        System.out.println(\"  \" + ste.getClassName() + \".\" + ste.getMethodName() + \"(ln \" + ste.getLineNumber() + \")\");\r\n    }\r\n}"
}, {
	"Path": "com.spotify.helios.agent.TaskMonitor.throttle",
	"Comment": "get the current task throttle as derived from task runner events.",
	"Method": "ThrottleState throttle(){\r\n    return throttle;\r\n}"
}, {
	"Path": "org.tron.common.crypto.ECKey.fromPrivateAndPrecalculatedPublic",
	"Comment": "creates an eckey that simply trusts the caller to ensure that point is really the result ofmultiplying the generator point by the private key. this is used to speed things up when youknow you have the right values already. the compression state of the point will be preserved.",
	"Method": "ECKey fromPrivateAndPrecalculatedPublic(BigInteger priv,ECPoint pub,ECKey fromPrivateAndPrecalculatedPublic,byte[] priv,byte[] pub){\r\n    check(priv != null, \"Private key must not be null\");\r\n    check(pub != null, \"Public key must not be null\");\r\n    return new ECKey(new BigInteger(1, priv), CURVE.getCurve().decodePoint(pub));\r\n}"
}, {
	"Path": "com.spotify.helios.testing.TemporaryJobBuilder.expires",
	"Comment": "the helios master will undeploy and delete the job at the specified date, if it has notalready been removed. if not set, jobs will be removed after 30 minutes. this is for thecase when a temporaryjob is not cleaned up properly, perhaps because the process terminatedprematurely.",
	"Method": "TemporaryJobBuilder expires(Date expires){\r\n    this.builder.setExpires(expires);\r\n    return this;\r\n}"
}, {
	"Path": "org.fnlp.util.hash.MurmurHash.hash32",
	"Comment": "generates 32 bit hash from byte array with default seed value.",
	"Method": "int hash32(byte[] data,int length,int seed,int hash32,byte[] data,int length){\r\n    return hash32(data, length, 0x9747b28c);\r\n}"
}, {
	"Path": "com.graphhopper.routing.ch.CHAlgoFactoryDecorator.setWeightingsAsStrings",
	"Comment": "enables the use of contraction hierarchies to reduce query times. enabled by default.",
	"Method": "CHAlgoFactoryDecorator setWeightingsAsStrings(String weightingNames,CHAlgoFactoryDecorator setWeightingsAsStrings,List<String> weightingList){\r\n    if (weightingList.isEmpty())\r\n        throw new IllegalArgumentException(\"It is not allowed to pass an emtpy weightingList\");\r\n    weightingsAsStrings.clear();\r\n    for (String strWeighting : weightingList) {\r\n        strWeighting = toLowerCase(strWeighting);\r\n        strWeighting = strWeighting.trim();\r\n        addWeighting(strWeighting);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.spotify.helios.common.Json.asString",
	"Comment": "serialize an object to a json string. use when it is not know whether an object can be jsonserializable.",
	"Method": "String asString(Object value){\r\n    return OBJECT_MAPPER.writeValueAsString(value);\r\n}"
}, {
	"Path": "com.notnoop.apns.PayloadBuilder.alertBody",
	"Comment": "sets the alert body text, the text the appears to the user,to the passed value",
	"Method": "PayloadBuilder alertBody(String alert){\r\n    customAlert.put(\"body\", alert);\r\n    return this;\r\n}"
}, {
	"Path": "com.spotify.helios.cli.Utils.parseTimeout",
	"Comment": "return the timeout value to use, first checking the argument provided to the cli invocation,then an environment variable, then the default value.",
	"Method": "int parseTimeout(Namespace options,String dest,String envVarName,int defaultValue){\r\n    if (options.getInt(dest) != null) {\r\n        return options.getInt(dest);\r\n    }\r\n    if (System.getenv(envVarName) != null) {\r\n        return Integer.parseInt(System.getenv(envVarName));\r\n    }\r\n    return defaultValue;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.SwingReplacedElementFactory.storeImageReplacedElement",
	"Comment": "adds a replacedelement containing an image to a cache of images for quick lookup.",
	"Method": "void storeImageReplacedElement(Element e,ReplacedElement cc,String uri,int cssWidth,int cssHeight){\r\n    if (imageComponents == null) {\r\n        imageComponents = new HashMap();\r\n    }\r\n    CacheKey key = new CacheKey(e, uri, cssWidth, cssHeight);\r\n    imageComponents.put(key, cc);\r\n}"
}, {
	"Path": "com.graphhopper.util.DepthFirstSearch.start",
	"Comment": "beginning with startnode add all following nodes to lifo queue. if node has been alreadyexplored before, skip reexploration.",
	"Method": "void start(EdgeExplorer explorer,int startNode){\r\n    IntArrayDeque stack = new IntArrayDeque();\r\n    GHBitSet explored = createBitSet();\r\n    stack.addLast(startNode);\r\n    int current;\r\n    while (stack.size() > 0) {\r\n        current = stack.removeLast();\r\n        if (!explored.contains(current) && goFurther(current)) {\r\n            EdgeIterator iter = explorer.setBaseNode(current);\r\n            while (iter.next()) {\r\n                int connectedId = iter.getAdjNode();\r\n                if (checkAdjacent(iter)) {\r\n                    stack.addLast(connectedId);\r\n                }\r\n            }\r\n            explored.add(current);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.routing.weighting.AbstractWeighting.weightingToFileName",
	"Comment": "replaces all characters which are not numbers, characters or underscores with underscores",
	"Method": "String weightingToFileName(Weighting w){\r\n    return toLowerCase(w.toString()).replaceAll(\"\\\\|\", \"_\");\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.IOUtil.openStreamAtUrl",
	"Comment": "attempts to open a connection, and a stream, to the uri provided. timeouts will be set for opening the connectionand reading from it. will return the stream, or null if unable to open or read or a timeout occurred. does notbuffer the stream.",
	"Method": "InputStream openStreamAtUrl(String uri){\r\n    InputStream is = null;\r\n    try {\r\n        final URLConnection uc = new URL(uri).openConnection();\r\n        System.setProperty(\"sun.net.client.defaultConnectTimeout\", String.valueOf(10 * 1000));\r\n        System.setProperty(\"sun.net.client.defaultReadTimeout\", String.valueOf(30 * 1000));\r\n        uc.connect();\r\n        is = uc.getInputStream();\r\n    } catch (java.net.MalformedURLException e) {\r\n        XRLog.exception(\"bad URL given: \" + uri, e);\r\n    } catch (FileNotFoundException e) {\r\n        XRLog.exception(\"item at URI \" + uri + \" not found\");\r\n    } catch (IOException e) {\r\n        XRLog.exception(\"IO problem for \" + uri, e);\r\n    }\r\n    return is;\r\n}"
}, {
	"Path": "com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks.findSubnetworks",
	"Comment": "this method finds the double linked components according to the specified filter.",
	"Method": "List<IntArrayList> findSubnetworks(PrepEdgeFilter filter){\r\n    final FlagEncoder encoder = filter.getEncoder();\r\n    final EdgeExplorer explorer = ghStorage.createEdgeExplorer(filter);\r\n    int locs = ghStorage.getNodes();\r\n    List<IntArrayList> list = new ArrayList(100);\r\n    final GHBitSet bs = new GHBitSetImpl(locs);\r\n    for (int start = 0; start < locs; start++) {\r\n        if (bs.contains(start))\r\n            continue;\r\n        final IntArrayList intList = new IntArrayList(20);\r\n        list.add(intList);\r\n        new BreadthFirstSearch() {\r\n            int tmpCounter = 0;\r\n            @Override\r\n            protected GHBitSet createBitSet() {\r\n                return bs;\r\n            }\r\n            @Override\r\n            protected final boolean goFurther(int nodeId) {\r\n                if (tmpCounter > maxEdgesPerNode.get())\r\n                    maxEdgesPerNode.set(tmpCounter);\r\n                tmpCounter = 0;\r\n                intList.add(nodeId);\r\n                return true;\r\n            }\r\n            @Override\r\n            protected final boolean checkAdjacent(EdgeIteratorState edge) {\r\n                if (encoder.isForward(edge.getFlags()) || encoder.isBackward(edge.getFlags())) {\r\n                    tmpCounter++;\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n        }.start(explorer, start);\r\n        intList.trimToSize();\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks.findSubnetworks",
	"Comment": "this method finds the double linked components according to the specified filter.",
	"Method": "List<IntArrayList> findSubnetworks(PrepEdgeFilter filter){\r\n    return bs;\r\n}"
}, {
	"Path": "com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks.findSubnetworks",
	"Comment": "this method finds the double linked components according to the specified filter.",
	"Method": "List<IntArrayList> findSubnetworks(PrepEdgeFilter filter){\r\n    if (tmpCounter > maxEdgesPerNode.get())\r\n        maxEdgesPerNode.set(tmpCounter);\r\n    tmpCounter = 0;\r\n    intList.add(nodeId);\r\n    return true;\r\n}"
}, {
	"Path": "com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks.findSubnetworks",
	"Comment": "this method finds the double linked components according to the specified filter.",
	"Method": "List<IntArrayList> findSubnetworks(PrepEdgeFilter filter){\r\n    if (encoder.isForward(edge.getFlags()) || encoder.isBackward(edge.getFlags())) {\r\n        tmpCounter++;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.layout.WhitespaceStripper.stripWhitespace",
	"Comment": "this function strips all whitespace from the text according to the css2.1 spec on whitespace handling. it accounts for the different whitespacesettings like normal, nowrap, pre, etc",
	"Method": "boolean stripWhitespace(InlineBox iB,boolean collapseLeading){\r\n    IdentValue whitespace = iB.getStyle().getIdent(CSSName.WHITE_SPACE);\r\n    String text = iB.getText();\r\n    text = collapseWhitespace(iB, whitespace, text, collapseLeading);\r\n    boolean collapseNext = (text.endsWith(SPACE) && (whitespace == IdentValue.NORMAL || whitespace == IdentValue.NOWRAP || whitespace == IdentValue.PRE));\r\n    iB.setText(text);\r\n    if (text.trim().equals(\"\")) {\r\n        if (whitespace == IdentValue.NORMAL || whitespace == IdentValue.NOWRAP) {\r\n            iB.setRemovableWhitespace(true);\r\n        } else if (whitespace == IdentValue.PRE) {\r\n            iB.setRemovableWhitespace(false);\r\n        } else if (text.indexOf(EOL) < 0) {\r\n            iB.setRemovableWhitespace(true);\r\n        }\r\n    }\r\n    return text.equals(\"\") ? collapseLeading : collapseNext;\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.AbstractFlagEncoder.reverseFlags",
	"Comment": "swapping directions means swapping bits which are dependent on the direction of an edge likethe access bits. but also direction dependent speed values should be swapped too. keep inmind that this method is performance critical!",
	"Method": "long reverseFlags(long flags){\r\n    long dir = flags & directionBitMask;\r\n    if (dir == directionBitMask || dir == 0)\r\n        return flags;\r\n    return flags ^ directionBitMask;\r\n}"
}, {
	"Path": "com.graphhopper.util.TranslationMap.postImportHook",
	"Comment": "this method does some checks and fills missing translation from en",
	"Method": "void postImportHook(){\r\n    Map<String, String> enMap = get(\"en\").asMap();\r\n    StringBuilder sb = new StringBuilder();\r\n    for (Translation tr : translations.values()) {\r\n        Map<String, String> trMap = tr.asMap();\r\n        for (Entry<String, String> enEntry : enMap.entrySet()) {\r\n            String value = trMap.get(enEntry.getKey());\r\n            if (isEmpty(value)) {\r\n                trMap.put(enEntry.getKey(), enEntry.getValue());\r\n                continue;\r\n            }\r\n            int expectedCount = countOccurence(enEntry.getValue(), \"\\\\%\");\r\n            if (expectedCount != countOccurence(value, \"\\\\%\")) {\r\n                sb.append(tr.getLocale()).append(\" - error in \").append(enEntry.getKey()).append(\"->\").append(value).append(\"\\n\");\r\n            } else {\r\n                Object[] strs = new String[expectedCount];\r\n                Arrays.fill(strs, \"tmp\");\r\n                try {\r\n                    String.format(Locale.ROOT, value, strs);\r\n                } catch (Exception ex) {\r\n                    sb.append(tr.getLocale()).append(\" - error \").append(ex.getMessage()).append(\"in \").append(enEntry.getKey()).append(\"->\").append(value).append(\"\\n\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (sb.length() > 0) {\r\n        System.out.println(sb);\r\n        throw new IllegalStateException(sb.toString());\r\n    }\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.JavaInputAstVisitor.canLocalHaveHorizontalAnnotations",
	"Comment": "can a local with a set of modifiers be declared with horizontal annotations? this is currentlytrue if there is at most one marker annotation, and no others.",
	"Method": "Direction canLocalHaveHorizontalAnnotations(ModifiersTree modifiers){\r\n    int markerAnnotations = 0;\r\n    for (AnnotationTree annotation : modifiers.getAnnotations()) {\r\n        if (annotation.getArguments().isEmpty()) {\r\n            markerAnnotations++;\r\n        }\r\n    }\r\n    return markerAnnotations <= 1 && markerAnnotations == modifiers.getAnnotations().size() ? Direction.HORIZONTAL : Direction.VERTICAL;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.executeArrayScript",
	"Comment": "executes a js script on this runtime and returns the result as a v8array.if the result is not a v8array, then a v8resultundefinedexception is thrown.",
	"Method": "V8Array executeArrayScript(String script,V8Array executeArrayScript,String script,String scriptName,int lineNumber){\r\n    checkThread();\r\n    Object result = this.executeScript(script, scriptName, lineNumber);\r\n    if (result instanceof V8Array) {\r\n        return (V8Array) result;\r\n    }\r\n    throw new V8ResultUndefined();\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Array.getBytes",
	"Comment": "gets the bytes contained in a subset of a v8array. if the subsetcontains elements that cannot be cast to bytes, then a v8resultundefined exceptionis thrown. furthermore, if the subset is not entirely contained within the array,then v8resultundefined exception is also thrown. finally, if the resultarrayis not large enough to hold the results then indexoutofboundsexception is thrown.",
	"Method": "byte[] getBytes(int index,int length,int getBytes,int index,int length,byte[] resultArray,byte[] getBytes,int index,int length,int getBytes,int index,int length,byte[] resultArray){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    if (length > resultArray.length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    return v8.arrayGetBytes(v8.getV8RuntimePtr(), getHandle(), index, length, resultArray);\r\n}"
}, {
	"Path": "com.graphhopper.util.GHUtility.createEdgeKey",
	"Comment": "creates unique positive number for specified edgeid taking into account the direction definedby nodea, nodeb and reverse.",
	"Method": "int createEdgeKey(int nodeA,int nodeB,int edgeId,boolean reverse){\r\n    edgeId = edgeId << 1;\r\n    if (reverse)\r\n        return (nodeA > nodeB) ? edgeId : edgeId + 1;\r\n    return (nodeA > nodeB) ? edgeId + 1 : edgeId;\r\n}"
}, {
	"Path": "com.graphhopper.util.PointList.makeImmutable",
	"Comment": "once immutable, there is no way to make this object mutable again. this is done to ensure the consistency ofshallow copies. if you need to modify this object again, you have to create a deep copy of it.",
	"Method": "void makeImmutable(){\r\n    this.isImmutable = true;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swt.SWTReplacedElementFactory.lookupImageReplacedElement",
	"Comment": "retrieves a replacedelement for an image from cache, or null if notfound.",
	"Method": "ReplacedElement lookupImageReplacedElement(Element e){\r\n    if (_imageComponents == null) {\r\n        return null;\r\n    }\r\n    return (ReplacedElement) _imageComponents.get(e);\r\n}"
}, {
	"Path": "com.spotify.helios.cli.command.JobCreateCommandTest.testAddCapabilitiesFromJsonFile",
	"Comment": "ensure that creating a job from a json file which has added and dropped capabilities is notoverwritten by empty arguments in the cli switches.",
	"Method": "void testAddCapabilitiesFromJsonFile(){\r\n    when(options.getString(\"id\")).thenReturn(JOB_ID);\r\n    when(options.getString(\"image\")).thenReturn(\"foobar\");\r\n    when(options.get(\"file\")).thenReturn(new File(\"src/test/resources/job_config_extra_capabilities.json\"));\r\n    when(options.getList(\"add-capability\")).thenReturn(Collections.emptyList());\r\n    when(options.getList(\"drop-capability\")).thenReturn(Collections.emptyList());\r\n    assertEquals(0, runCommand());\r\n    verify(client).createJob(argThat(hasCapabilities(ImmutableSet.of(\"cap_one\", \"cap_two\"), ImmutableSet.of(\"cap_three\", \"cap_four\"))));\r\n}"
}, {
	"Path": "org.immutables.mongo.types.TypeAdapters.binaryAdapter",
	"Comment": "use this adapter to easily delagate marshaling of custom binary wrapper.",
	"Method": "TypeAdapter<byte[]> binaryAdapter(){\r\n    return BINARY_ADAPTER;\r\n}"
}, {
	"Path": "com.spotify.helios.agent.TaskConfig.fullyQualifiedRegistrationDomain",
	"Comment": "given the registration domain in the job, and the default registration domain for the agent,figure out what domain we should actually register the job in.",
	"Method": "String fullyQualifiedRegistrationDomain(){\r\n    if (job.getRegistrationDomain().endsWith(\".\")) {\r\n        return job.getRegistrationDomain();\r\n    } else if (\"\".equals(job.getRegistrationDomain())) {\r\n        return defaultRegistrationDomain;\r\n    } else {\r\n        return job.getRegistrationDomain() + \".\" + defaultRegistrationDomain;\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.EncodingManager.create",
	"Comment": "create the encodingmanager from the provided graphhopper location. throws anillegalstateexception if it fails. used if no encodingmanager specified on load.",
	"Method": "EncodingManager create(FlagEncoderFactory factory,String ghLoc){\r\n    Directory dir = new RAMDirectory(ghLoc, true);\r\n    StorableProperties properties = new StorableProperties(dir);\r\n    if (!properties.loadExisting())\r\n        throw new IllegalStateException(\"Cannot load properties to fetch EncodingManager configuration at: \" + dir.getLocation());\r\n    properties.checkVersions(false);\r\n    String acceptStr = properties.get(\"graph.flag_encoders\");\r\n    if (acceptStr.isEmpty())\r\n        throw new IllegalStateException(\"EncodingManager was not configured. And no one was found in the graph: \" + dir.getLocation());\r\n    int bytesForFlags = 4;\r\n    if (\"8\".equals(properties.get(\"graph.bytes_for_flags\")))\r\n        bytesForFlags = 8;\r\n    return new EncodingManager(factory, acceptStr, bytesForFlags);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Array.getStrings",
	"Comment": "gets the strings contained in a subset of a v8array. if the subsetcontains elements other than strings, then a v8resultundefined exceptionis thrown. furthermore, if the subset is not entirely contained within the array,then v8resultundefined exception is also thrown. finally, if the resultarrayis not large enough to hold the results then indexoutofboundsexception is thrown.",
	"Method": "String[] getStrings(int index,int length,int getStrings,int index,int length,String[] resultArray,String[] getStrings,int index,int length,int getStrings,int index,int length,String[] resultArray){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    if (length > resultArray.length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    return v8.arrayGetStrings(v8.getV8RuntimePtr(), getHandle(), index, length, resultArray);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Object.executeIntegerFunction",
	"Comment": "invoke a javascript function and return the result as a integer. if theresult is not an integer, or does not exist, then v8resultundefined is thrown.",
	"Method": "int executeIntegerFunction(String name,V8Array parameters,int executeIntegerFunction,String name,V8Array parameters){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    v8.checkRuntime(parameters);\r\n    long parametersHandle = parameters == null ? 0 : parameters.getHandle();\r\n    return v8.executeIntegerFunction(v8.getV8RuntimePtr(), getHandle(), name, parametersHandle);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.registerResource",
	"Comment": "registers a resource with this runtime. all registeredresources will be released before the runtime is released.",
	"Method": "void registerResource(Releasable resource){\r\n    checkThread();\r\n    if (resources == null) {\r\n        resources = new ArrayList<Releasable>();\r\n    }\r\n    resources.add(resource);\r\n}"
}, {
	"Path": "com.notnoop.apns.ApnsServiceBuilder.withSandboxDestination",
	"Comment": "specify to use the apple sandbox servers as iphone gatewayand feedback servers.this is desired when in testing and pushing notificationswith a development provision.",
	"Method": "ApnsServiceBuilder withSandboxDestination(){\r\n    return withGatewayDestination(SANDBOX_GATEWAY_HOST, SANDBOX_GATEWAY_PORT).withFeedbackDestination(SANDBOX_FEEDBACK_HOST, SANDBOX_FEEDBACK_PORT);\r\n}"
}, {
	"Path": "com.conveyal.gtfs.model.Frequency.getId",
	"Comment": "frequency entries have no id in gtfs so we define one based on the fields in the frequency entry.it is possible to have two identical frequency entries in the gtfs, which under our understanding of the situationwould mean that two sets of vehicles were randomly running the same trip at the same headway, but uncorrelatedwith each other, which is almost certain to be an error.",
	"Method": "String getId(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(trip_id);\r\n    sb.append('_');\r\n    sb.append(convertToGtfsTime(start_time));\r\n    sb.append(\"_to_\");\r\n    sb.append(convertToGtfsTime(end_time));\r\n    sb.append(\"_every_\");\r\n    sb.append(String.format(Locale.getDefault(), \"%dmds\", headway_secs / 60, headway_secs % 60));\r\n    if (exact_times == 1)\r\n        sb.append(\"_exact\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.setFlags",
	"Comment": "sets the v8 flags on the platform. all runtimes will be createdwith the same flags. flags must be set before the runtime iscreated.",
	"Method": "void setFlags(String flags){\r\n    v8Flags = flags;\r\n    initialized = false;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Array.get",
	"Comment": "gets the value at a given index as a java object. primitives are boxed.",
	"Method": "Object get(int index,Object get,int index){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    return v8.arrayGet(v8.getV8RuntimePtr(), V8_OBJECT, objectHandle, index);\r\n}"
}, {
	"Path": "com.graphhopper.GraphHopper.createWeighting",
	"Comment": "based on the hintsmap and the specified encoder a weighting instance can becreated. note that all url parameters are available in the hintsmap as string ifyou use the web module.",
	"Method": "Weighting createWeighting(HintsMap hintsMap,FlagEncoder encoder,Graph graph){\r\n    String weightingStr = toLowerCase(hintsMap.getWeighting());\r\n    Weighting weighting = null;\r\n    if (encoder.supports(GenericWeighting.class)) {\r\n        weighting = new GenericWeighting((DataFlagEncoder) encoder, hintsMap);\r\n    } else if (\"shortest\".equalsIgnoreCase(weightingStr)) {\r\n        weighting = new ShortestWeighting(encoder);\r\n    } else if (\"fastest\".equalsIgnoreCase(weightingStr) || weightingStr.isEmpty()) {\r\n        if (encoder.supports(PriorityWeighting.class))\r\n            weighting = new PriorityWeighting(encoder, hintsMap);\r\n        else\r\n            weighting = new FastestWeighting(encoder, hintsMap);\r\n    } else if (\"curvature\".equalsIgnoreCase(weightingStr)) {\r\n        if (encoder.supports(CurvatureWeighting.class))\r\n            weighting = new CurvatureWeighting(encoder, hintsMap);\r\n    } else if (\"short_fastest\".equalsIgnoreCase(weightingStr)) {\r\n        weighting = new ShortFastestWeighting(encoder, hintsMap);\r\n    }\r\n    if (weighting == null)\r\n        throw new IllegalArgumentException(\"weighting \" + weightingStr + \" not supported\");\r\n    if (hintsMap.has(Routing.BLOCK_AREA)) {\r\n        String blockAreaStr = hintsMap.get(Parameters.Routing.BLOCK_AREA, \"\");\r\n        GraphEdgeIdFinder.BlockArea blockArea = new GraphEdgeIdFinder(graph, locationIndex).parseBlockArea(blockAreaStr, DefaultEdgeFilter.allEdges(encoder), hintsMap.getDouble(\"block_area.edge_id_max_area\", 1000 * 1000));\r\n        return new BlockAreaWeighting(weighting, blockArea);\r\n    }\r\n    return weighting;\r\n}"
}, {
	"Path": "com.graphhopper.routing.AlternativeRouteTest.configs",
	"Comment": "runs the same test with each of the supported traversal modes",
	"Method": "Collection<Object[]> configs(){\r\n    return Arrays.asList(new Object[][] { { TraversalMode.NODE_BASED }, { TraversalMode.EDGE_BASED_2DIR } });\r\n}"
}, {
	"Path": "com.notnoop.apns.ApnsServerSocketBuilder.withFeedbackDestination",
	"Comment": "specify the feedback for getting failed devices from apple iphone push\tservers.",
	"Method": "ApnsServerSocketBuilder withFeedbackDestination(int port){\r\n    this.feedbackPort = port;\r\n    return this;\r\n}"
}, {
	"Path": "org.fnlp.util.hash.MurmurHash.hash64",
	"Comment": "generates 64 bit hash from byte array with default seed value.",
	"Method": "long hash64(byte[] data,int length,int seed,long hash64,byte[] data,int length){\r\n    return hash64(data, length, 0xe17a1465);\r\n}"
}, {
	"Path": "com.spotify.helios.testing.JobPrefixFile.create",
	"Comment": "creates a jobprefixfile using the specified prefix and directory.",
	"Method": "JobPrefixFile create(Path directory,JobPrefixFile create,String prefix,Path directory){\r\n    return new JobPrefixFile(prefix, directory);\r\n}"
}, {
	"Path": "com.spotify.helios.agent.AgentService.setupZookeeperClient",
	"Comment": "create a zookeeper client and create the control and state nodes if needed.",
	"Method": "ZooKeeperClient setupZookeeperClient(AgentConfig config,String id,CountDownLatch zkRegistrationSignal){\r\n    ACLProvider aclProvider = null;\r\n    List<AuthInfo> authorization = null;\r\n    final String agentUser = config.getZookeeperAclAgentUser();\r\n    final String agentPassword = config.getZooKeeperAclAgentPassword();\r\n    final String masterUser = config.getZookeeperAclMasterUser();\r\n    final String masterDigest = config.getZooKeeperAclMasterDigest();\r\n    if (!isNullOrEmpty(agentPassword)) {\r\n        if (isNullOrEmpty(agentUser)) {\r\n            throw new HeliosRuntimeException(\"Agent username must be set if a password is set\");\r\n        }\r\n        authorization = Lists.newArrayList(new AuthInfo(\"digest\", String.format(\"%s:%s\", agentUser, agentPassword).getBytes()));\r\n    }\r\n    if (config.isZooKeeperEnableAcls()) {\r\n        if (isNullOrEmpty(agentUser) || isNullOrEmpty(agentPassword)) {\r\n            throw new HeliosRuntimeException(\"ZooKeeper ACLs enabled but agent username and/or password not set\");\r\n        }\r\n        if (isNullOrEmpty(masterUser) || isNullOrEmpty(masterDigest)) {\r\n            throw new HeliosRuntimeException(\"ZooKeeper ACLs enabled but master username and/or digest not set\");\r\n        }\r\n        aclProvider = heliosAclProvider(masterUser, masterDigest, agentUser, digest(agentUser, agentPassword));\r\n    }\r\n    final RetryPolicy zooKeeperRetryPolicy = new ExponentialBackoffRetry(1000, 3);\r\n    final CuratorFramework curator = new CuratorClientFactoryImpl().newClient(config.getZooKeeperConnectionString(), config.getZooKeeperSessionTimeoutMillis(), config.getZooKeeperConnectionTimeoutMillis(), zooKeeperRetryPolicy, aclProvider, authorization);\r\n    final ZooKeeperClient client = new DefaultZooKeeperClient(curator, config.getZooKeeperClusterId());\r\n    client.start();\r\n    final AgentZooKeeperRegistrar agentZooKeeperRegistrar = new AgentZooKeeperRegistrar(config.getName(), id, config.getZooKeeperRegistrationTtlMinutes(), new SystemClock());\r\n    zkRegistrar = ZooKeeperRegistrarService.newBuilder().setZooKeeperClient(client).setZooKeeperRegistrar(agentZooKeeperRegistrar).setZkRegistrationSignal(zkRegistrationSignal).build();\r\n    return client;\r\n}"
}, {
	"Path": "com.spotify.helios.agent.ZooKeeperAgentModel.removeListener",
	"Comment": "remove a listener that will be notified when tasks are changed.",
	"Method": "void removeListener(AgentModel.Listener listener){\r\n    listeners.remove(listener);\r\n}"
}, {
	"Path": "com.spotify.helios.testing.HeliosSoloDeployment.builder",
	"Comment": "return a builder that can be used to instantiate a heliossolodeployment.",
	"Method": "Builder builder(Builder builder,String profile){\r\n    return new Builder(profile, HeliosConfig.loadConfig());\r\n}"
}, {
	"Path": "org.tron.common.overlay.server.Channel.initNode",
	"Comment": "set node and register it in nodemanager if it is not registered yet.",
	"Method": "void initNode(byte[] nodeId,int remotePort){\r\n    node = new Node(nodeId, inetSocketAddress.getHostString(), remotePort);\r\n    nodeStatistics = nodeManager.getNodeStatistics(node);\r\n    nodeManager.getNodeHandler(node).setNode(node);\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeCreateActuatorTest.sameTokenNameCloseSuccessExchangeCreate",
	"Comment": "sametokenname close,first createexchange,result is success.",
	"Method": "void sameTokenNameCloseSuccessExchangeCreate(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(0);\r\n    String firstTokenId = \"abc\";\r\n    long firstTokenBalance = 100000000L;\r\n    String secondTokenId = \"def\";\r\n    long secondTokenBalance = 100000000L;\r\n    AssetIssueCapsule assetIssueCapsule1 = new AssetIssueCapsule(AssetIssueContract.newBuilder().setName(ByteString.copyFrom(firstTokenId.getBytes())).build());\r\n    assetIssueCapsule1.setId(String.valueOf(1L));\r\n    AssetIssueCapsule assetIssueCapsule2 = new AssetIssueCapsule(AssetIssueContract.newBuilder().setName(ByteString.copyFrom(secondTokenId.getBytes())).build());\r\n    assetIssueCapsule2.setId(String.valueOf(2L));\r\n    dbManager.getAssetIssueStore().put(assetIssueCapsule1.getName().toByteArray(), assetIssueCapsule1);\r\n    dbManager.getAssetIssueStore().put(assetIssueCapsule2.getName().toByteArray(), assetIssueCapsule2);\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmount(firstTokenId.getBytes(), firstTokenBalance);\r\n    accountCapsule.addAssetAmount(secondTokenId.getBytes(), secondTokenBalance);\r\n    accountCapsule.setBalance(10000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeCreateActuator actuator = new ExchangeCreateActuator(getContract(OWNER_ADDRESS_FIRST, firstTokenId, firstTokenBalance, secondTokenId, secondTokenBalance), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    Assert.assertEquals(dbManager.getDynamicPropertiesStore().getLatestExchangeNum(), 0);\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        Assert.assertEquals(ret.getInstance().getExchangeId(), 1L);\r\n        Assert.assertEquals(ret.getInstance().getRet(), code.SUCESS);\r\n        long id = 1;\r\n        Assert.assertEquals(dbManager.getDynamicPropertiesStore().getLatestExchangeNum(), id);\r\n        ExchangeCapsule exchangeCapsule = dbManager.getExchangeStore().get(ByteArray.fromLong(id));\r\n        Assert.assertNotNull(exchangeCapsule);\r\n        Assert.assertEquals(ByteString.copyFrom(ownerAddress), exchangeCapsule.getCreatorAddress());\r\n        Assert.assertEquals(id, exchangeCapsule.getID());\r\n        Assert.assertEquals(1000000, exchangeCapsule.getCreateTime());\r\n        Assert.assertTrue(Arrays.equals(firstTokenId.getBytes(), exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenId, ByteArray.toStr(exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenBalance, exchangeCapsule.getFirstTokenBalance());\r\n        Assert.assertEquals(secondTokenId, ByteArray.toStr(exchangeCapsule.getSecondTokenId()));\r\n        Assert.assertEquals(secondTokenBalance, exchangeCapsule.getSecondTokenBalance());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        Map<String, Long> assetMap = accountCapsule.getAssetMap();\r\n        Assert.assertEquals(10000_000000L - 1024_000000L, accountCapsule.getBalance());\r\n        Assert.assertEquals(0L, assetMap.get(firstTokenId).longValue());\r\n        Assert.assertEquals(0L, assetMap.get(secondTokenId).longValue());\r\n        ExchangeCapsule exchangeCapsuleV2 = dbManager.getExchangeV2Store().get(ByteArray.fromLong(id));\r\n        Assert.assertNotNull(exchangeCapsuleV2);\r\n        Assert.assertEquals(ByteString.copyFrom(ownerAddress), exchangeCapsuleV2.getCreatorAddress());\r\n        Assert.assertEquals(id, exchangeCapsuleV2.getID());\r\n        Assert.assertEquals(1000000, exchangeCapsuleV2.getCreateTime());\r\n        firstTokenId = dbManager.getAssetIssueStore().get(firstTokenId.getBytes()).getId();\r\n        secondTokenId = dbManager.getAssetIssueStore().get(secondTokenId.getBytes()).getId();\r\n        Assert.assertTrue(Arrays.equals(firstTokenId.getBytes(), exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenId, ByteArray.toStr(exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenBalance, exchangeCapsuleV2.getFirstTokenBalance());\r\n        Assert.assertEquals(secondTokenId, ByteArray.toStr(exchangeCapsuleV2.getSecondTokenId()));\r\n        Assert.assertEquals(secondTokenBalance, exchangeCapsuleV2.getSecondTokenBalance());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        Map<String, Long> getAssetV2Map = accountCapsule.getAssetMapV2();\r\n        Assert.assertEquals(10000_000000L - 1024_000000L, accountCapsule.getBalance());\r\n        Assert.assertEquals(0L, getAssetV2Map.get(firstTokenId).longValue());\r\n        Assert.assertEquals(0L, getAssetV2Map.get(secondTokenId).longValue());\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertFalse(e instanceof ContractValidateException);\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    } catch (ItemNotFoundException e) {\r\n        Assert.assertFalse(e instanceof ItemNotFoundException);\r\n    }\r\n}"
}, {
	"Path": "com.spotify.helios.common.Json.asPrettyStringUnchecked",
	"Comment": "serialize an object to a json string. use when object is expected to be json serializable.",
	"Method": "String asPrettyStringUnchecked(Object value){\r\n    try {\r\n        return asPrettyString(value);\r\n    } catch (JsonProcessingException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.notnoop.apns.ApnsServiceBuilder.withErrorDetectionThreadFactory",
	"Comment": "provide a custom source for threads used for monitoring connections.this setting is desired when the application must obtain threads from acontrolled environment google app engine.",
	"Method": "ApnsServiceBuilder withErrorDetectionThreadFactory(ThreadFactory threadFactory){\r\n    this.errorDetectionThreadFactory = threadFactory;\r\n    return this;\r\n}"
}, {
	"Path": "com.graphhopper.reader.osm.pbf.PbfBlobResult.isSuccess",
	"Comment": "gets the success flag. this is only valid after complete becomes true.",
	"Method": "boolean isSuccess(){\r\n    return success;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.extend.XhtmlCssOnlyNamespaceHandler.getElementStyling",
	"Comment": "gets the elementstyling attribute of the xhtmlnamespacehandler object",
	"Method": "String getElementStyling(org.w3c.dom.Element e){\r\n    StringBuffer style = new StringBuffer();\r\n    if (e.getNodeName().equals(\"td\") || e.getNodeName().equals(\"th\")) {\r\n        String s;\r\n        s = getAttribute(e, \"colspan\");\r\n        if (s != null) {\r\n            style.append(\"-fs-table-cell-colspan: \");\r\n            style.append(s);\r\n            style.append(\";\");\r\n        }\r\n        s = getAttribute(e, \"rowspan\");\r\n        if (s != null) {\r\n            style.append(\"-fs-table-cell-rowspan: \");\r\n            style.append(s);\r\n            style.append(\";\");\r\n        }\r\n    } else if (e.getNodeName().equals(\"img\")) {\r\n        String s;\r\n        s = getAttribute(e, \"width\");\r\n        if (s != null) {\r\n            style.append(\"width: \");\r\n            style.append(convertToLength(s));\r\n            style.append(\";\");\r\n        }\r\n        s = getAttribute(e, \"height\");\r\n        if (s != null) {\r\n            style.append(\"height: \");\r\n            style.append(convertToLength(s));\r\n            style.append(\";\");\r\n        }\r\n    } else if (e.getNodeName().equals(\"colgroup\") || e.getNodeName().equals(\"col\")) {\r\n        String s;\r\n        s = getAttribute(e, \"span\");\r\n        if (s != null) {\r\n            style.append(\"-fs-table-cell-colspan: \");\r\n            style.append(s);\r\n            style.append(\";\");\r\n        }\r\n        s = getAttribute(e, \"width\");\r\n        if (s != null) {\r\n            style.append(\"width: \");\r\n            style.append(convertToLength(s));\r\n            style.append(\";\");\r\n        }\r\n    }\r\n    style.append(e.getAttribute(\"style\"));\r\n    return style.toString();\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.DelegatingUserAgent.isVisited",
	"Comment": "returns true if the given uri was visited, meaning it was requested at some point since initialization.",
	"Method": "boolean isVisited(String uri){\r\n    return false;\r\n}"
}, {
	"Path": "com.conveyal.gtfs.model.Service.checkOverlap",
	"Comment": "checks for overlapping days of week between two service calendars",
	"Method": "boolean checkOverlap(Service s1,Service s2){\r\n    if (s1.calendar == null || s2.calendar == null) {\r\n        return false;\r\n    }\r\n    boolean overlappingDays = s1.calendar.monday == 1 && s2.calendar.monday == 1 || s1.calendar.tuesday == 1 && s2.calendar.tuesday == 1 || s1.calendar.wednesday == 1 && s2.calendar.wednesday == 1 || s1.calendar.thursday == 1 && s2.calendar.thursday == 1 || s1.calendar.friday == 1 && s2.calendar.friday == 1 || s1.calendar.saturday == 1 && s2.calendar.saturday == 1 || s1.calendar.sunday == 1 && s2.calendar.sunday == 1;\r\n    return overlappingDays;\r\n}"
}, {
	"Path": "org.tron.core.actuator.TransferAssetActuatorTest.SameTokenNameCloseInvalidOwnerAddress",
	"Comment": "sametokenname close,invalid owneraddress,result is error",
	"Method": "void SameTokenNameCloseInvalidOwnerAddress(){\r\n    createAssertBeforSameTokenNameActive();\r\n    TransferAssetActuator actuator = new TransferAssetActuator(getContract(100L, OWNER_ADDRESS_INVALID, TO_ADDRESS), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail(\"Invalid ownerAddress\");\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"Invalid ownerAddress\", e.getMessage());\r\n        AccountCapsule owner = dbManager.getAccountStore().get(ByteArray.fromHexString(OWNER_ADDRESS));\r\n        AccountCapsule toAccount = dbManager.getAccountStore().get(ByteArray.fromHexString(TO_ADDRESS));\r\n        Assert.assertEquals(owner.getAssetMap().get(ASSET_NAME).longValue(), OWNER_ASSET_BALANCE);\r\n        Assert.assertTrue(isNullOrZero(toAccount.getAssetMap().get(ASSET_NAME)));\r\n    } catch (ContractExeException e) {\r\n        Assert.assertTrue(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.executeScript",
	"Comment": "executes a js script on this runtime and returns the result as a java object.primitives will be boxed.",
	"Method": "Object executeScript(String script,Object executeScript,String script,String scriptName,int lineNumber,Object executeScript,long v8RuntimePtr,int expectedType,String script,String scriptName,int lineNumber){\r\n    return _executeScript(v8RuntimePtr, expectedType, script, scriptName, lineNumber);\r\n}"
}, {
	"Path": "com.notnoop.apns.ApnsServiceBuilder.withConnectTimeout",
	"Comment": "specify the timeout value to use for connectiontimeout in createdsockets, for both feedback and push connections, in milliseconds.",
	"Method": "ApnsServiceBuilder withConnectTimeout(int connectTimeout){\r\n    this.connectTimeout = connectTimeout;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.Trees.operatorName",
	"Comment": "returns the string name of an operator, including assignment and compound assignment.",
	"Method": "String operatorName(ExpressionTree expression){\r\n    JCTree.Tag tag = ((JCTree) expression).getTag();\r\n    if (tag == JCTree.Tag.ASSIGN) {\r\n        return \"=\";\r\n    }\r\n    boolean assignOp = expression instanceof CompoundAssignmentTree;\r\n    if (assignOp) {\r\n        tag = tag.noAssignOp();\r\n    }\r\n    String name = new Pretty(null, true).operatorName(tag);\r\n    return assignOp ? name + \"=\" : name;\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.spatialrules.SpatialRuleLookupArray.addRuleContainer",
	"Comment": "this method adds the container if no such rule container exists in this lookup and returns the index otherwise.",
	"Method": "int addRuleContainer(SpatialRuleContainer container){\r\n    int newIndex = this.ruleContainers.indexOf(container);\r\n    if (newIndex >= 0)\r\n        return newIndex;\r\n    newIndex = ruleContainers.size();\r\n    if (newIndex >= 255)\r\n        throw new IllegalStateException(\"No more spatial rule container fit into this lookup as 255 combination of ruleContainers reached\");\r\n    this.ruleContainers.add(container);\r\n    return newIndex;\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeCreateActuatorTest.sameTokenNameOpenMoreThanBalanceLimit",
	"Comment": "sametokenname open,token balance must less than balancelimit",
	"Method": "void sameTokenNameOpenMoreThanBalanceLimit(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    String firstTokenId = \"123\";\r\n    long firstTokenBalance = 1_000_000_000_000_001L;\r\n    String secondTokenId = \"456\";\r\n    long secondTokenBalance = 100000000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmount(firstTokenId.getBytes(), firstTokenBalance);\r\n    accountCapsule.addAssetAmount(secondTokenId.getBytes(), secondTokenBalance);\r\n    accountCapsule.setBalance(10000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeCreateActuator actuator = new ExchangeCreateActuator(getContract(OWNER_ADDRESS_FIRST, firstTokenId, firstTokenBalance, secondTokenId, secondTokenBalance), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    Assert.assertEquals(dbManager.getDynamicPropertiesStore().getLatestExchangeNum(), 0);\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"token balance must less than 1000000000000000\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "com.spotify.helios.master.ZooKeeperMasterModel.getRunningMasters",
	"Comment": "returns a list of the host names of the currently running masters.",
	"Method": "List<String> getRunningMasters(){\r\n    final ZooKeeperClient client = provider.get(\"getRunningMasters\");\r\n    try {\r\n        final List<String> masters = client.getChildren(Paths.statusMaster());\r\n        final ImmutableList.Builder<String> upMasters = ImmutableList.builder();\r\n        for (final String master : masters) {\r\n            if (client.exists(Paths.statusMasterUp(master)) != null) {\r\n                upMasters.add(master);\r\n            }\r\n        }\r\n        return upMasters.build();\r\n    } catch (KeeperException e) {\r\n        throw new HeliosRuntimeException(\"listing masters failed\", e);\r\n    }\r\n}"
}, {
	"Path": "org.immutables.value.processor.meta.ValueAttribute.getRawCollectionType",
	"Comment": "suitable for javadocs, intemediate name mangling and for guava intergration.",
	"Method": "String getRawCollectionType(){\r\n    return typeKind.rawSimpleName(rawTypeName);\r\n}"
}, {
	"Path": "org.tron.common.runtime.TVMTestUtils.generateDeploySmartContractAndGetTransaction",
	"Comment": "return generated smart contract transaction, just before we use it to broadcast and pushtransaction",
	"Method": "Transaction generateDeploySmartContractAndGetTransaction(String contractName,byte[] callerAddress,String ABI,String code,long value,long feeLimit,long consumeUserResourcePercent,String libraryAddressPair,Transaction generateDeploySmartContractAndGetTransaction,String contractName,byte[] callerAddress,String ABI,String code,long value,long feeLimit,long consumeUserResourcePercent,long tokenValue,long tokenId,String libraryAddressPair,Transaction generateDeploySmartContractAndGetTransaction,String contractName,byte[] callerAddress,String ABI,String code,long value,long feeLimit,long consumeUserResourcePercent,String libraryAddressPair,long orginEngeryLimit,Transaction generateDeploySmartContractAndGetTransaction,String contractName,byte[] callerAddress,String ABI,String code,long value,long feeLimit,long consumeUserResourcePercent,String libraryAddressPair,long orginEngeryLimit,long tokenValue,long tokenId){\r\n    CreateSmartContract contract = buildCreateSmartContract(contractName, callerAddress, ABI, code, value, consumeUserResourcePercent, libraryAddressPair, orginEngeryLimit, tokenValue, tokenId);\r\n    TransactionCapsule trxCapWithoutFeeLimit = new TransactionCapsule(contract, ContractType.CreateSmartContract);\r\n    Transaction.Builder transactionBuilder = trxCapWithoutFeeLimit.getInstance().toBuilder();\r\n    Transaction.raw.Builder rawBuilder = trxCapWithoutFeeLimit.getInstance().getRawData().toBuilder();\r\n    rawBuilder.setFeeLimit(feeLimit);\r\n    transactionBuilder.setRawData(rawBuilder);\r\n    Transaction trx = transactionBuilder.build();\r\n    return trx;\r\n}"
}, {
	"Path": "com.graphhopper.PathWrapper.getRouteWeight",
	"Comment": "this method returns a double value which is better than the time for comparison of routes butonly if you know what you are doing, e.g. only to compare routes gained with the same queryparameters like vehicle.",
	"Method": "double getRouteWeight(){\r\n    check(\"getRouteWeight\");\r\n    return routeWeight;\r\n}"
}, {
	"Path": "com.google.googlejavaformat.intellij.GoogleJavaFormatCodeStyleManager.overrideFormatterForFile",
	"Comment": "return whether or not this formatter can handle formatting the given file.",
	"Method": "boolean overrideFormatterForFile(PsiFile file){\r\n    return StdFileTypes.JAVA.equals(file.getFileType()) && GoogleJavaFormatSettings.getInstance(getProject()).isEnabled();\r\n}"
}, {
	"Path": "com.graphhopper.storage.BaseGraph.inPlaceNodeRemove",
	"Comment": "this methods disconnects all edges from removed nodes. it does no edge compaction. then itmoves the last nodes into the deleted nodes, where it needs to update the node ids in everyedge.",
	"Method": "void inPlaceNodeRemove(int removeNodeCount){\r\n    int toMoveNodes = getNodes();\r\n    int itemsToMove = 0;\r\n    final SparseIntIntArray oldToNewMap = new SparseIntIntArray(removeNodeCount);\r\n    GHBitSet toRemoveSet = new GHBitSetImpl(removeNodeCount);\r\n    removedNodes.copyTo(toRemoveSet);\r\n    Logger logger = LoggerFactory.getLogger(getClass());\r\n    if (removeNodeCount > getNodes() / 2.0)\r\n        logger.warn(\"More than a half of the network should be removed!? \" + \"Nodes:\" + getNodes() + \", remove:\" + removeNodeCount);\r\n    EdgeExplorer delExplorer = createEdgeExplorer();\r\n    for (int removeNode = removedNodes.next(0); removeNode >= 0; removeNode = removedNodes.next(removeNode + 1)) {\r\n        EdgeIterator delEdgesIter = delExplorer.setBaseNode(removeNode);\r\n        while (delEdgesIter.next()) {\r\n            toRemoveSet.add(delEdgesIter.getAdjNode());\r\n        }\r\n        toMoveNodes--;\r\n        for (; toMoveNodes >= 0; toMoveNodes--) {\r\n            if (!removedNodes.contains(toMoveNodes))\r\n                break;\r\n        }\r\n        if (toMoveNodes >= removeNode)\r\n            oldToNewMap.put(toMoveNodes, removeNode);\r\n        itemsToMove++;\r\n    }\r\n    EdgeIterable adjNodesToDelIter = (EdgeIterable) createEdgeExplorer();\r\n    for (int removeNode = toRemoveSet.next(0); removeNode >= 0; removeNode = toRemoveSet.next(removeNode + 1)) {\r\n        adjNodesToDelIter.setBaseNode(removeNode);\r\n        long prev = EdgeIterator.NO_EDGE;\r\n        while (adjNodesToDelIter.next()) {\r\n            int nodeId = adjNodesToDelIter.getAdjNode();\r\n            if (nodeId != EdgeAccess.NO_NODE && removedNodes.contains(nodeId)) {\r\n                int edgeToRemove = adjNodesToDelIter.getEdge();\r\n                long edgeToRemovePointer = edgeAccess.toPointer(edgeToRemove);\r\n                edgeAccess.internalEdgeDisconnect(edgeToRemove, prev, removeNode, nodeId);\r\n                edgeAccess.invalidateEdge(edgeToRemovePointer);\r\n            } else {\r\n                prev = adjNodesToDelIter.edgePointer;\r\n            }\r\n        }\r\n    }\r\n    GHBitSet toMoveSet = new GHBitSetImpl(removeNodeCount * 3);\r\n    EdgeExplorer movedEdgeExplorer = createEdgeExplorer();\r\n    for (int i = 0; i < itemsToMove; i++) {\r\n        int oldI = oldToNewMap.keyAt(i);\r\n        EdgeIterator movedEdgeIter = movedEdgeExplorer.setBaseNode(oldI);\r\n        while (movedEdgeIter.next()) {\r\n            int nodeId = movedEdgeIter.getAdjNode();\r\n            if (nodeId == EdgeAccess.NO_NODE)\r\n                continue;\r\n            if (removedNodes.contains(nodeId))\r\n                throw new IllegalStateException(\"shouldn't happen the edge to the node \" + nodeId + \" should be already deleted. \" + oldI);\r\n            toMoveSet.add(nodeId);\r\n        }\r\n    }\r\n    for (int i = 0; i < itemsToMove; i++) {\r\n        int oldI = oldToNewMap.keyAt(i);\r\n        int newI = oldToNewMap.valueAt(i);\r\n        long newOffset = (long) newI * nodeEntryBytes;\r\n        long oldOffset = (long) oldI * nodeEntryBytes;\r\n        for (long j = 0; j < nodeEntryBytes; j += 4) {\r\n            nodes.setInt(newOffset + j, nodes.getInt(oldOffset + j));\r\n        }\r\n    }\r\n    EdgeIterator iter = getAllEdges();\r\n    while (iter.next()) {\r\n        int nodeA = iter.getBaseNode();\r\n        int nodeB = iter.getAdjNode();\r\n        if (!toMoveSet.contains(nodeA) && !toMoveSet.contains(nodeB))\r\n            continue;\r\n        int updatedA = oldToNewMap.get(nodeA);\r\n        if (updatedA < 0)\r\n            updatedA = nodeA;\r\n        int updatedB = oldToNewMap.get(nodeB);\r\n        if (updatedB < 0)\r\n            updatedB = nodeB;\r\n        int edgeId = iter.getEdge();\r\n        long edgePointer = edgeAccess.toPointer(edgeId);\r\n        int linkA = edgeAccess.getEdgeRef(nodeA, nodeB, edgePointer);\r\n        int linkB = edgeAccess.getEdgeRef(nodeB, nodeA, edgePointer);\r\n        long flags = edgeAccess.getFlags_(edgePointer, false);\r\n        edgeAccess.writeEdge(edgeId, updatedA, updatedB, linkA, linkB);\r\n        edgeAccess.setFlags_(edgePointer, updatedA > updatedB, flags);\r\n        if (updatedA < updatedB != nodeA < nodeB)\r\n            setWayGeometry_(fetchWayGeometry_(edgePointer, true, 0, -1, -1), edgePointer, false);\r\n    }\r\n    if (removeNodeCount >= nodeCount)\r\n        throw new IllegalStateException(\"graph is empty after in-place removal but was \" + removeNodeCount);\r\n    initNodeRefs(((long) nodeCount - removeNodeCount) * nodeEntryBytes, (long) nodeCount * nodeEntryBytes);\r\n    nodeCount -= removeNodeCount;\r\n    if (isTestingEnabled()) {\r\n        EdgeExplorer explorer = createEdgeExplorer();\r\n        iter = getAllEdges();\r\n        while (iter.next()) {\r\n            int base = iter.getBaseNode();\r\n            int adj = iter.getAdjNode();\r\n            String str = iter.getEdge() + \", r.contains(\" + base + \"):\" + removedNodes.contains(base) + \", r.contains(\" + adj + \"):\" + removedNodes.contains(adj) + \", tr.contains(\" + base + \"):\" + toRemoveSet.contains(base) + \", tr.contains(\" + adj + \"):\" + toRemoveSet.contains(adj) + \", base:\" + base + \", adj:\" + adj + \", nodeCount:\" + nodeCount;\r\n            if (adj >= nodeCount)\r\n                throw new RuntimeException(\"Adj.node problem with edge \" + str);\r\n            if (base >= nodeCount)\r\n                throw new RuntimeException(\"Base node problem with edge \" + str);\r\n            try {\r\n                explorer.setBaseNode(adj).toString();\r\n            } catch (Exception ex) {\r\n                org.slf4j.LoggerFactory.getLogger(getClass()).error(\"adj:\" + adj);\r\n            }\r\n            try {\r\n                explorer.setBaseNode(base).toString();\r\n            } catch (Exception ex) {\r\n                org.slf4j.LoggerFactory.getLogger(getClass()).error(\"base:\" + base);\r\n            }\r\n        }\r\n        explorer.setBaseNode(nodeCount - 1).toString();\r\n    }\r\n    removedNodes = null;\r\n}"
}, {
	"Path": "org.kie.dmn.model.v1_2.dmndi.DMNShape.getDMNDecisionServiceDividerLine",
	"Comment": "gets the value of the dmndecisionservicedividerline property.",
	"Method": "org.kie.dmn.model.api.dmndi.DMNDecisionServiceDividerLine getDMNDecisionServiceDividerLine(){\r\n    return dmnDecisionServiceDividerLine;\r\n}"
}, {
	"Path": "com.spotify.helios.client.HeliosClient.listHosts",
	"Comment": "returns a list of all hosts registered in the helios cluster that match both the given hostnamepattern and set of host selectors.",
	"Method": "ListenableFuture<List<String>> listHosts(ListenableFuture<List<String>> listHosts,String namePattern,ListenableFuture<List<String>> listHosts,Set<String> unparsedHostSelectors,ListenableFuture<List<String>> listHosts,String namePattern,Set<String> unparsedHostSelectors,ListenableFuture<List<String>> listHosts,Multimap<String, String> query){\r\n    return get(uri(\"/hosts/\", query), new TypeReference<List<String>>() {\r\n    });\r\n}"
}, {
	"Path": "com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks.detectNodeRemovedForAllEncoders",
	"Comment": "this method checks if the node is removed or inaccessible for all encoders.",
	"Method": "boolean detectNodeRemovedForAllEncoders(EdgeExplorer edgeExplorerAllEdges,int nodeIndex){\r\n    EdgeIterator iter = edgeExplorerAllEdges.setBaseNode(nodeIndex);\r\n    while (iter.next()) {\r\n        for (FlagEncoder encoder : encoders) {\r\n            if (encoder.isBackward(iter.getFlags()) || encoder.isForward(iter.getFlags()))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.spotify.helios.master.MasterService.setupZookeeperClient",
	"Comment": "create a zookeeper client and create the control and state nodes if needed.",
	"Method": "ZooKeeperClient setupZookeeperClient(MasterConfig config){\r\n    ACLProvider aclProvider = null;\r\n    List<AuthInfo> authorization = null;\r\n    final String masterUser = config.getZookeeperAclMasterUser();\r\n    final String masterPassword = config.getZooKeeperAclMasterPassword();\r\n    final String agentUser = config.getZookeeperAclAgentUser();\r\n    final String agentDigest = config.getZooKeeperAclAgentDigest();\r\n    if (!isNullOrEmpty(masterPassword)) {\r\n        if (isNullOrEmpty(masterUser)) {\r\n            throw new HeliosRuntimeException(\"Master username must be set if a password is set\");\r\n        }\r\n        authorization = Lists.newArrayList(new AuthInfo(\"digest\", String.format(\"%s:%s\", masterUser, masterPassword).getBytes()));\r\n    }\r\n    if (config.isZooKeeperEnableAcls()) {\r\n        if (isNullOrEmpty(masterUser) || isNullOrEmpty(masterPassword)) {\r\n            throw new HeliosRuntimeException(\"ZooKeeper ACLs enabled but master username and/or password not set\");\r\n        }\r\n        if (isNullOrEmpty(agentUser) || isNullOrEmpty(agentDigest)) {\r\n            throw new HeliosRuntimeException(\"ZooKeeper ACLs enabled but agent username and/or digest not set\");\r\n        }\r\n        aclProvider = heliosAclProvider(masterUser, digest(masterUser, masterPassword), agentUser, agentDigest);\r\n    }\r\n    final RetryPolicy zooKeeperRetryPolicy = new ExponentialBackoffRetry(1000, 3);\r\n    final CuratorFramework curator = curatorClientFactory.newClient(config.getZooKeeperConnectionString(), config.getZooKeeperSessionTimeoutMillis(), config.getZooKeeperConnectionTimeoutMillis(), zooKeeperRetryPolicy, aclProvider, authorization);\r\n    final ZooKeeperClient client = new DefaultZooKeeperClient(curator, config.getZooKeeperClusterId());\r\n    client.start();\r\n    zkRegistrar = ZooKeeperRegistrarService.newBuilder().setZooKeeperClient(client).setZooKeeperRegistrar(new MasterZooKeeperRegistrar(config.getName())).build();\r\n    if (aclProvider != null) {\r\n        try {\r\n            final List<ACL> curAcls = client.getAcl(\"/\");\r\n            final List<ACL> wantedAcls = aclProvider.getAclForPath(\"/\");\r\n            if (!Sets.newHashSet(curAcls).equals(Sets.newHashSet(wantedAcls))) {\r\n                log.info(\"Current ACL's on the zookeeper root node differ from desired, updating: {} -> {}\", curAcls, wantedAcls);\r\n                client.getCuratorFramework().setACL().withACL(wantedAcls).forPath(\"/\");\r\n            }\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to get/set ACLs on the zookeeper root node\", e);\r\n        }\r\n    }\r\n    return client;\r\n}"
}, {
	"Path": "com.spotify.helios.system.ApiTest.testHashLessJobCreation",
	"Comment": "verify that the helios master generates and returns a hash if the submitted job creationrequest does not include one.",
	"Method": "void testHashLessJobCreation(){\r\n    startDefaultMaster();\r\n    final Job job = Job.newBuilder().setName(testJobName).setVersion(testJobVersion).setImage(BUSYBOX).setCommand(IDLE_COMMAND).setCreatingUser(TEST_USER).build();\r\n    final ObjectNode json = (ObjectNode) Json.reader().readTree(Json.asString(job));\r\n    json.set(\"id\", TextNode.valueOf(testJobName + \":\" + testJobVersion));\r\n    final HttpURLConnection req = post(\"/jobs?user=\" + TEST_USER, Json.asBytes(json));\r\n    assertEquals(req.getResponseCode(), 200);\r\n    final CreateJobResponse res = Json.read(toByteArray(req.getInputStream()), CreateJobResponse.class);\r\n    assertEquals(OK, res.getStatus());\r\n    assertTrue(res.getErrors().isEmpty());\r\n    assertEquals(job.getId().toString(), res.getId());\r\n}"
}, {
	"Path": "info.debatty.java.stringsimilarity.JaroWinkler.getThreshold",
	"Comment": "returns the current value of the threshold used for adding the winklerbonus. the default value is 0.7.",
	"Method": "double getThreshold(){\r\n    return threshold;\r\n}"
}, {
	"Path": "com.graphhopper.routing.InstructionsOutgoingEdges.nrOfAllOutgoingEdges",
	"Comment": "this method calculates the number of all outgoing edges, which could be considered the number of roads you seeat the intersection. this excludes the road your are coming from.",
	"Method": "int nrOfAllOutgoingEdges(){\r\n    return 1 + allOutgoingEdges.size();\r\n}"
}, {
	"Path": "com.notnoop.apns.PayloadBuilder.localizedKey",
	"Comment": "set the notification localized key for the alert bodymessage.",
	"Method": "PayloadBuilder localizedKey(String key){\r\n    customAlert.put(\"loc-key\", key);\r\n    return this;\r\n}"
}, {
	"Path": "com.graphhopper.routing.lm.LandmarkStorage.createLandmarks",
	"Comment": "this method calculates the landmarks and initial weightings to & from them.",
	"Method": "void createLandmarks(){\r\n    if (isInitialized())\r\n        throw new IllegalStateException(\"Initialize the landmark storage only once!\");\r\n    long maxBytes = (long) graph.getNodes() * LM_ROW_LENGTH;\r\n    this.landmarkWeightDA.create(2000);\r\n    this.landmarkWeightDA.ensureCapacity(maxBytes);\r\n    for (long pointer = 0; pointer < maxBytes; pointer += 4) {\r\n        landmarkWeightDA.setInt(pointer, (DELTA_INF << FROM_WEIGHT_BITS) | FROM_WEIGHT_INF);\r\n    }\r\n    String additionalInfo = \"\";\r\n    if (factor <= 0) {\r\n        BBox bounds = graph.getBounds();\r\n        double distanceInMeter = Helper.DIST_EARTH.calcDist(bounds.maxLat, bounds.maxLon, bounds.minLat, bounds.minLon) * 7;\r\n        if (distanceInMeter > 50_000 * 7 || !bounds.isValid())\r\n            distanceInMeter = 30_000_000;\r\n        double maxWeight = weighting.getMinWeight(distanceInMeter);\r\n        setMaximumWeight(maxWeight);\r\n        additionalInfo = \", maxWeight:\" + maxWeight + \", from max distance:\" + distanceInMeter / 1000f + \"km\";\r\n    }\r\n    if (logDetails)\r\n        LOGGER.info(\"init landmarks for subnetworks with node count greater than \" + minimumNodes + \" with factor:\" + factor + additionalInfo);\r\n    int[] empty = new int[landmarks];\r\n    Arrays.fill(empty, UNSET_SUBNETWORK);\r\n    landmarkIDs.add(empty);\r\n    byte[] subnetworks = new byte[graph.getNodes()];\r\n    Arrays.fill(subnetworks, (byte) UNSET_SUBNETWORK);\r\n    EdgeFilter tarjanFilter = DefaultEdgeFilter.outEdges(encoder);\r\n    IntHashSet blockedEdges = new IntHashSet();\r\n    if (ruleLookup != null && ruleLookup.size() > 0) {\r\n        StopWatch sw = new StopWatch().start();\r\n        blockedEdges = findBorderEdgeIds(ruleLookup);\r\n        tarjanFilter = new BlockedEdgesFilter(encoder, true, false, blockedEdges);\r\n        if (logDetails)\r\n            LOGGER.info(\"Made \" + blockedEdges.size() + \" edges inaccessible. Calculated country cut in \" + sw.stop().getSeconds() + \"s, \" + Helper.getMemInfo());\r\n    }\r\n    StopWatch sw = new StopWatch().start();\r\n    TarjansSCCAlgorithm tarjanAlgo = new TarjansSCCAlgorithm(graph, tarjanFilter, true);\r\n    List<IntArrayList> graphComponents = tarjanAlgo.findComponents();\r\n    if (logDetails)\r\n        LOGGER.info(\"Calculated \" + graphComponents.size() + \" subnetworks via tarjan in \" + sw.stop().getSeconds() + \"s, \" + Helper.getMemInfo());\r\n    EdgeExplorer tmpExplorer = graph.createEdgeExplorer(new RequireBothDirectionsEdgeFilter(encoder));\r\n    int nodes = 0;\r\n    for (IntArrayList subnetworkIds : graphComponents) {\r\n        nodes += subnetworkIds.size();\r\n        if (subnetworkIds.size() < minimumNodes)\r\n            continue;\r\n        int index = subnetworkIds.size() - 1;\r\n        for (; index >= 0; index--) {\r\n            int nextStartNode = subnetworkIds.get(index);\r\n            if (subnetworks[nextStartNode] == UNSET_SUBNETWORK && GHUtility.count(tmpExplorer.setBaseNode(nextStartNode)) > 0) {\r\n                GHPoint p = createPoint(graph, nextStartNode);\r\n                if (logDetails)\r\n                    LOGGER.info(\"start node: \" + nextStartNode + \" (\" + p + \") subnetwork size: \" + subnetworkIds.size() + \", \" + Helper.getMemInfo() + ((ruleLookup == null) ? \"\" : \" area:\" + ruleLookup.lookupRule(p).getId()));\r\n                if (createLandmarksForSubnetwork(nextStartNode, subnetworks, blockedEdges))\r\n                    break;\r\n            }\r\n        }\r\n        if (index < 0)\r\n            LOGGER.warn(\"next start node not found in big enough network of size \" + subnetworkIds.size() + \", first element is \" + subnetworkIds.get(0) + \", \" + createPoint(graph, subnetworkIds.get(0)));\r\n    }\r\n    int subnetworkCount = landmarkIDs.size();\r\n    this.landmarkWeightDA.ensureCapacity(maxBytes + subnetworkCount * landmarks);\r\n    long bytePos = maxBytes;\r\n    for (int[] landmarks : landmarkIDs) {\r\n        for (int lmNodeId : landmarks) {\r\n            landmarkWeightDA.setInt(bytePos, lmNodeId);\r\n            bytePos += 4L;\r\n        }\r\n    }\r\n    landmarkWeightDA.setHeader(0 * 4, getVersion());\r\n    landmarkWeightDA.setHeader(1 * 4, landmarks);\r\n    landmarkWeightDA.setHeader(2 * 4, subnetworkCount);\r\n    if (factor * DOUBLE_MLTPL > Integer.MAX_VALUE)\r\n        throw new UnsupportedOperationException(\"landmark weight factor cannot be bigger than Integer.MAX_VALUE \" + factor * DOUBLE_MLTPL);\r\n    landmarkWeightDA.setHeader(3 * 4, (int) Math.round(factor * DOUBLE_MLTPL));\r\n    landmarkWeightDA.setHeader(4 * 4, graph.getNodes());\r\n    subnetworkStorage.create(graph.getNodes());\r\n    for (int nodeId = 0; nodeId < subnetworks.length; nodeId++) {\r\n        subnetworkStorage.setSubnetwork(nodeId, subnetworks[nodeId]);\r\n    }\r\n    if (logDetails)\r\n        LOGGER.info(\"Finished landmark creation. Subnetwork node count sum \" + nodes + \" vs. nodes \" + graph.getNodes());\r\n    initialized = true;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swt.BasicRenderer.getMaxFontScale",
	"Comment": "returns the maximum font scaling that may be applied, e.g. 3 timesassigned font size.",
	"Method": "float getMaxFontScale(){\r\n    return _maxFontScale;\r\n}"
}, {
	"Path": "com.spotify.helios.system.ZooKeeperAclTest.testMasterCreatedNodesHaveAcls",
	"Comment": "simple test to make sure nodes created by master use the acls provided by the acl provider.",
	"Method": "void testMasterCreatedNodesHaveAcls(){\r\n    startDefaultMaster();\r\n    Polling.await(WAIT_TIMEOUT_SECONDS, TimeUnit.SECONDS, new Callable<Boolean>() {\r\n        @Override\r\n        public Boolean call() throws Exception {\r\n            return defaultClient().listMasters().get().isEmpty() ? null : true;\r\n        }\r\n    });\r\n    final CuratorFramework curator = zk().curatorWithSuperAuth();\r\n    final String path = Paths.statusMasterUp(TEST_MASTER);\r\n    final List<ACL> acls = curator.getACL().forPath(path);\r\n    assertEquals(Sets.newHashSet(aclProvider.getAclForPath(path)), Sets.newHashSet(acls));\r\n}"
}, {
	"Path": "com.spotify.helios.system.ZooKeeperAclTest.testMasterCreatedNodesHaveAcls",
	"Comment": "simple test to make sure nodes created by master use the acls provided by the acl provider.",
	"Method": "void testMasterCreatedNodesHaveAcls(){\r\n    return defaultClient().listMasters().get().isEmpty() ? null : true;\r\n}"
}, {
	"Path": "com.graphhopper.storage.TurnCostExtension.mergeOrOverwriteTurnInfo",
	"Comment": "add a new turn cost entry or clear an existing. see turnflagsreadwritetest for usage examples.",
	"Method": "void mergeOrOverwriteTurnInfo(int fromEdge,int viaNode,int toEdge,long turnFlags,boolean merge){\r\n    int newEntryIndex = turnCostsCount;\r\n    ensureTurnCostIndex(newEntryIndex);\r\n    boolean oldEntryFound = false;\r\n    long newFlags = turnFlags;\r\n    int next = NO_TURN_ENTRY;\r\n    int previousEntryIndex = nodeAccess.getAdditionalNodeField(viaNode);\r\n    if (previousEntryIndex == NO_TURN_ENTRY) {\r\n        nodeAccess.setAdditionalNodeField(viaNode, newEntryIndex);\r\n    } else {\r\n        int i = 0;\r\n        next = turnCosts.getInt((long) previousEntryIndex * turnCostsEntryBytes + TC_NEXT);\r\n        long existingFlags = 0;\r\n        while (true) {\r\n            long costsIdx = (long) previousEntryIndex * turnCostsEntryBytes;\r\n            if (fromEdge == turnCosts.getInt(costsIdx + TC_FROM) && toEdge == turnCosts.getInt(costsIdx + TC_TO)) {\r\n                oldEntryFound = true;\r\n                existingFlags = turnCosts.getInt(costsIdx + TC_FLAGS);\r\n                break;\r\n            } else if (next == NO_TURN_ENTRY) {\r\n                break;\r\n            }\r\n            previousEntryIndex = next;\r\n            if (i++ > 1000) {\r\n                throw new IllegalStateException(\"Something unexpected happened. A node probably will not have 1000+ relations.\");\r\n            }\r\n            next = turnCosts.getInt((long) next * turnCostsEntryBytes + TC_NEXT);\r\n        }\r\n        if (!oldEntryFound) {\r\n            turnCosts.setInt((long) previousEntryIndex * turnCostsEntryBytes + TC_NEXT, newEntryIndex);\r\n        } else if (merge) {\r\n            newFlags = existingFlags | newFlags;\r\n        } else {\r\n        }\r\n    }\r\n    long costsBase;\r\n    if (!oldEntryFound) {\r\n        costsBase = (long) newEntryIndex * turnCostsEntryBytes;\r\n        turnCostsCount++;\r\n    } else {\r\n        costsBase = (long) previousEntryIndex * turnCostsEntryBytes;\r\n    }\r\n    turnCosts.setInt(costsBase + TC_FROM, fromEdge);\r\n    turnCosts.setInt(costsBase + TC_TO, toEdge);\r\n    turnCosts.setInt(costsBase + TC_FLAGS, (int) newFlags);\r\n    turnCosts.setInt(costsBase + TC_NEXT, next);\r\n}"
}, {
	"Path": "com.graphhopper.GraphHopper.forServer",
	"Comment": "configures the underlying storage and response to be used on a well equipped server. resultalso optimized for usage in the web module i.e. try reduce network io.",
	"Method": "GraphHopper forServer(){\r\n    setSimplifyResponse(true);\r\n    return setInMemory();\r\n}"
}, {
	"Path": "com.graphhopper.routing.Path.getWeight",
	"Comment": "this weight will be updated during the algorithm. the initial value is maximum double.",
	"Method": "double getWeight(){\r\n    return weight;\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeInjectActuatorTest.SameTokenNameCloseTokenBalanceGreaterThanBalanceLimit",
	"Comment": "sametokenname close, token balance must less than balancelimit",
	"Method": "void SameTokenNameCloseTokenBalanceGreaterThanBalanceLimit(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(0);\r\n    InitExchangeBeforeSameTokenNameActive();\r\n    long exchangeId = 2;\r\n    String firstTokenId = \"_\";\r\n    long firstTokenQuant = 1_000_000_000_000_001L;\r\n    String secondTokenId = \"def\";\r\n    long secondTokenQuant = 400000000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmount(secondTokenId.getBytes(), secondTokenQuant);\r\n    accountCapsule.setBalance(firstTokenQuant);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeInjectActuator actuator = new ExchangeInjectActuator(getContract(OWNER_ADDRESS_FIRST, exchangeId, firstTokenId, firstTokenQuant), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"token balance must less than 1000000000000000\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.debug.V8DebugServer.configureV8ForDebugging",
	"Comment": "utility method for simplification of configuring v8 for debugging support.",
	"Method": "void configureV8ForDebugging(){\r\n    try {\r\n        V8.setFlags(\"-expose-debug-as=\" + DEBUG_OBJECT_NAME);\r\n    } catch (Throwable t) {\r\n        t.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.GraphHopper.setElevation",
	"Comment": "enable storing and fetching elevation data. default is false",
	"Method": "GraphHopper setElevation(boolean includeElevation){\r\n    this.elevation = includeElevation;\r\n    return this;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.context.StandardAttributeResolver.isLink",
	"Comment": "gets the link attribute of the standardattributeresolver object",
	"Method": "boolean isLink(Object e){\r\n    return nsh.getLinkUri((Element) e) != null;\r\n}"
}, {
	"Path": "com.graphhopper.GHResponse.hasAlternatives",
	"Comment": "this method returns true if there are alternative paths available besides the best.",
	"Method": "boolean hasAlternatives(){\r\n    return pathWrappers.size() > 1;\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.addOverlayListItem",
	"Comment": "this method inflates a clone of clicked view directly above it. sets data into it.",
	"Method": "void addOverlayListItem(Map<String, Object> item,View view){\r\n    if (mOverlayListItemView == null) {\r\n        mOverlayListItemView = getLayoutInflater().inflate(R.layout.overlay_list_item, mWrapper, false);\r\n    } else {\r\n        mWrapper.removeView(mOverlayListItemView);\r\n    }\r\n    mOverlayListItemView.findViewById(R.id.view_avatar_overlay).setBackground(sOverlayShape);\r\n    Picasso.with(EuclidActivity.this).load((Integer) item.get(EuclidListAdapter.KEY_AVATAR)).resize(sScreenWidth, sProfileImageHeight).centerCrop().placeholder(R.color.blue).into((ImageView) mOverlayListItemView.findViewById(R.id.image_view_reveal_avatar));\r\n    Picasso.with(EuclidActivity.this).load((Integer) item.get(EuclidListAdapter.KEY_AVATAR)).resize(sScreenWidth, sProfileImageHeight).centerCrop().placeholder(R.color.blue).into((ImageView) mOverlayListItemView.findViewById(R.id.image_view_avatar));\r\n    ((TextView) mOverlayListItemView.findViewById(R.id.text_view_name)).setText((String) item.get(EuclidListAdapter.KEY_NAME));\r\n    ((TextView) mOverlayListItemView.findViewById(R.id.text_view_description)).setText((String) item.get(EuclidListAdapter.KEY_DESCRIPTION_SHORT));\r\n    setProfileDetailsInfo(item);\r\n    RelativeLayout.LayoutParams params = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);\r\n    params.topMargin = view.getTop() + mToolbar.getHeight();\r\n    params.bottomMargin = -(view.getBottom() - mListView.getHeight());\r\n    mWrapper.addView(mOverlayListItemView, params);\r\n    mToolbar.bringToFront();\r\n}"
}, {
	"Path": "org.tron.common.crypto.ECKey.recoverPubBytesFromSignature",
	"Comment": "given the components of a signature and a selector value, recover and return the public keythat generated the signature according to the algorithm in sec1v2 section 4.1.6. the recid is an index from 0 to 3 which indicates which of the 4 possible allkeys is thecorrect one. because the key recovery operation yields multiple potential allkeys, the correctkey must either be stored alongside the signature, or you must be willing to try each recid inturn until you find one that outputs the key you are expecting. if this method returns null it means recovery was not possible and recid should beiterated. given the above two points, a correct usage of this method is inside a for loop from 0to 3, and if the output is null or a key that is not the one you expect, you try again with thenext recid.",
	"Method": "byte[] recoverPubBytesFromSignature(int recId,ECDSASignature sig,byte[] messageHash){\r\n    check(recId >= 0, \"recId must be positive\");\r\n    check(sig.r.signum() >= 0, \"r must be positive\");\r\n    check(sig.s.signum() >= 0, \"s must be positive\");\r\n    check(messageHash != null, \"messageHash must not be null\");\r\n    BigInteger n = CURVE.getN();\r\n    BigInteger i = BigInteger.valueOf((long) recId / 2);\r\n    BigInteger x = sig.r.add(i.multiply(n));\r\n    ECCurve.Fp curve = (ECCurve.Fp) CURVE.getCurve();\r\n    BigInteger prime = curve.getQ();\r\n    if (x.compareTo(prime) >= 0) {\r\n        return null;\r\n    }\r\n    ECPoint R = decompressKey(x, (recId & 1) == 1);\r\n    if (!R.multiply(n).isInfinity()) {\r\n        return null;\r\n    }\r\n    BigInteger e = new BigInteger(1, messageHash);\r\n    BigInteger eInv = BigInteger.ZERO.subtract(e).mod(n);\r\n    BigInteger rInv = sig.r.modInverse(n);\r\n    BigInteger srInv = rInv.multiply(sig.s).mod(n);\r\n    BigInteger eInvrInv = rInv.multiply(eInv).mod(n);\r\n    ECPoint.Fp q = (ECPoint.Fp) ECAlgorithms.sumOfTwoMultiplies(CURVE.getG(), eInvrInv, R, srInv);\r\n    return q.getEncoded(false);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.extend.XhtmlCssOnlyNamespaceHandler.getClass",
	"Comment": "gets the class attribute of the xhtmlnamespacehandler object",
	"Method": "String getClass(org.w3c.dom.Element e){\r\n    return e.getAttribute(\"class\");\r\n}"
}, {
	"Path": "com.spotify.helios.common.descriptors.RolloutOptions.withFallback",
	"Comment": "return a new rolloutoptions instance by merging this instance with another one.",
	"Method": "RolloutOptions withFallback(RolloutOptions that){\r\n    return RolloutOptions.newBuilder().setTimeout(firstNonNull(timeout, that.timeout)).setParallelism(firstNonNull(parallelism, that.parallelism)).setMigrate(firstNonNull(migrate, that.migrate)).setOverlap(firstNonNull(overlap, that.overlap)).setToken(firstNonNull(token, that.token)).setIgnoreFailures(firstNonNull(ignoreFailures, that.ignoreFailures)).build();\r\n}"
}, {
	"Path": "com.graphhopper.util.PMap.toMap",
	"Comment": "this method copies the underlying structure into a new map object",
	"Method": "Map<String, String> toMap(){\r\n    return new HashMap(map);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.Configuration.valueAsDouble",
	"Comment": "returns the value for key in the configuration as a double, or thedefault provided value if not found or if the value is not a validdouble. a warning is issued to the log if the property is not defined, orif the conversion from string fails.",
	"Method": "double valueAsDouble(String key,double defaultVal){\r\n    String val = valueFor(key);\r\n    if (val == null) {\r\n        return defaultVal;\r\n    }\r\n    double dval;\r\n    try {\r\n        dval = Double.valueOf(val).doubleValue();\r\n    } catch (NumberFormatException nex) {\r\n        XRLog.exception(\"Property '\" + key + \"' was requested as a double, but \" + \"value of '\" + val + \"' is not a double. Check configuration.\");\r\n        dval = defaultVal;\r\n    }\r\n    return dval;\r\n}"
}, {
	"Path": "org.kie.dmn.model.v1_2.dmndi.DMNStyle.getLabelHorizontalAlignement",
	"Comment": "gets the value of the labelhorizontalalignement property.",
	"Method": "AlignmentKind getLabelHorizontalAlignement(){\r\n    return labelHorizontalAlignement;\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeInjectActuatorTest.SameTokenNameOpenTokenQuantLessThanZero",
	"Comment": "sametokenname open, injected token quant must greater than zero",
	"Method": "void SameTokenNameOpenTokenQuantLessThanZero(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    InitExchangeSameTokenNameActive();\r\n    long exchangeId = 1;\r\n    String firstTokenId = \"123\";\r\n    long firstTokenQuant = -1L;\r\n    String secondTokenId = \"456\";\r\n    long secondTokenQuant = 400000000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmountV2(firstTokenId.getBytes(), 1000L, dbManager);\r\n    accountCapsule.addAssetAmountV2(secondTokenId.getBytes(), secondTokenQuant, dbManager);\r\n    accountCapsule.setBalance(10000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeInjectActuator actuator = new ExchangeInjectActuator(getContract(OWNER_ADDRESS_FIRST, exchangeId, firstTokenId, firstTokenQuant), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"injected token quant must greater than zero\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "com.spotify.helios.common.JobValidatorTest.testValidateGracePeriodAndExternalPorts",
	"Comment": "tests that jobs cannot have both grace period and external ports.",
	"Method": "void testValidateGracePeriodAndExternalPorts(){\r\n    final Job noPorts = Json.read(stringFromResource(\"job-with-no-ports.json\"), Job.class);\r\n    assertThat(validator.validate(noPorts), Matchers.<String>empty());\r\n    final Job noExternalPorts = Json.read(stringFromResource(\"job-with-no-external-ports.json\"), Job.class);\r\n    assertThat(validator.validate(noExternalPorts), Matchers.<String>empty());\r\n    final Job externalPorts = Json.read(stringFromResource(\"job-with-external-ports.json\"), Job.class);\r\n    assertThat(validator.validate(externalPorts), Matchers.<String>empty());\r\n    final Job gracePeriod = Json.read(stringFromResource(\"job-with-grace-period.json\"), Job.class);\r\n    assertThat(validator.validate(gracePeriod), Matchers.<String>empty());\r\n    final Job externalPortsAndGracePeriod = Json.read(stringFromResource(\"job-with-external-ports-and-grace-period.json\"), Job.class);\r\n    assertThat(validator.validate(externalPortsAndGracePeriod), hasItem(\"Job has both grace period and static/external ports. External ports will \" + \"prevent new containers from deploying during the gracePeriod because of port \" + \"conflicts. Please choose one or the other.\"));\r\n}"
}, {
	"Path": "com.spotify.helios.cli.command.RollingUpdateCommand.nullableWithFallback",
	"Comment": "return first argument if not null. otherwise return second argument.",
	"Method": "T nullableWithFallback(T first,T second){\r\n    return first != null ? first : second;\r\n}"
}, {
	"Path": "com.graphhopper.reader.osm.OSMReader.filterWay",
	"Comment": "filter ways but do not analyze properties waynodes will be filled with participating nodeids.",
	"Method": "boolean filterWay(ReaderWay item){\r\n    if (item.getNodes().size() < 2)\r\n        return false;\r\n    if (!item.hasTags())\r\n        return false;\r\n    return encodingManager.acceptWay(item) > 0;\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeWithdrawActuatorTest.SameTokenNameCloseSuccessExchangeWithdraw",
	"Comment": "sametokenname close, first withdraw exchange,result is success.",
	"Method": "void SameTokenNameCloseSuccessExchangeWithdraw(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(0);\r\n    InitExchangeBeforeSameTokenNameActive();\r\n    long exchangeId = 1;\r\n    String firstTokenId = \"abc\";\r\n    long firstTokenQuant = 100000000L;\r\n    String secondTokenId = \"def\";\r\n    long secondTokenQuant = 200000000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    Map<String, Long> assetMap = accountCapsule.getAssetMap();\r\n    Assert.assertEquals(10000_000000L, accountCapsule.getBalance());\r\n    Assert.assertEquals(null, assetMap.get(firstTokenId));\r\n    Assert.assertEquals(null, assetMap.get(secondTokenId));\r\n    ExchangeWithdrawActuator actuator = new ExchangeWithdrawActuator(getContract(OWNER_ADDRESS_FIRST, exchangeId, firstTokenId, firstTokenQuant), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        Assert.assertEquals(ret.getInstance().getRet(), code.SUCESS);\r\n        long id = 1;\r\n        ExchangeCapsule exchangeCapsule = dbManager.getExchangeStore().get(ByteArray.fromLong(id));\r\n        Assert.assertNotNull(exchangeCapsule);\r\n        Assert.assertEquals(ByteString.copyFrom(ownerAddress), exchangeCapsule.getCreatorAddress());\r\n        Assert.assertEquals(id, exchangeCapsule.getID());\r\n        Assert.assertEquals(1000000, exchangeCapsule.getCreateTime());\r\n        Assert.assertTrue(Arrays.equals(firstTokenId.getBytes(), exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenId, ByteArray.toStr(exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(0L, exchangeCapsule.getFirstTokenBalance());\r\n        Assert.assertEquals(secondTokenId, ByteArray.toStr(exchangeCapsule.getSecondTokenId()));\r\n        Assert.assertEquals(0L, exchangeCapsule.getSecondTokenBalance());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        assetMap = accountCapsule.getAssetMap();\r\n        Assert.assertEquals(10000_000000L, accountCapsule.getBalance());\r\n        Assert.assertEquals(firstTokenQuant, assetMap.get(firstTokenId).longValue());\r\n        Assert.assertEquals(secondTokenQuant, assetMap.get(secondTokenId).longValue());\r\n        Assert.assertEquals(secondTokenQuant, ret.getExchangeWithdrawAnotherAmount());\r\n    } catch (ContractValidateException e) {\r\n        logger.info(e.getMessage());\r\n        Assert.assertFalse(e instanceof ContractValidateException);\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    } catch (ItemNotFoundException e) {\r\n        Assert.assertFalse(e instanceof ItemNotFoundException);\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.routing.subnetwork.SubnetworkStorage.getSubnetwork",
	"Comment": "returns the subnetwork id for the specified nodeid or 0 if non is associated e.g. because thesubnetwork is too small.",
	"Method": "int getSubnetwork(int nodeId){\r\n    byte[] bytes = new byte[1];\r\n    da.getBytes(nodeId, bytes, bytes.length);\r\n    return (int) bytes[0];\r\n}"
}, {
	"Path": "com.google.googlejavaformat.Newlines.isNewline",
	"Comment": "returns true if the entire input string is a recognized line break.",
	"Method": "boolean isNewline(String input){\r\n    return BREAKS.contains(input);\r\n}"
}, {
	"Path": "com.graphhopper.PathWrapper.setWaypoints",
	"Comment": "this method initializes this path with the snapped input points.",
	"Method": "void setWaypoints(PointList wpList){\r\n    if (waypointList != PointList.EMPTY)\r\n        throw new IllegalStateException(\"Cannot call setWaypoints twice\");\r\n    this.waypointList = wpList;\r\n}"
}, {
	"Path": "stest.tron.wallet.common.client.utils.DataWord.longValue",
	"Comment": "converts this dataword to a long, checking for lost information.if this dataword is out of the possible range for a long resultthen an arithmeticexception is thrown.",
	"Method": "long longValue(){\r\n    long longVal = 0;\r\n    for (byte aaData : data) {\r\n        longVal = (longVal << 8) + (aaData & 0xff);\r\n    }\r\n    return longVal;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.utils.V8Executor.getException",
	"Comment": "gets the exception that was thrown during the javascript execution.",
	"Method": "Exception getException(){\r\n    return exception;\r\n}"
}, {
	"Path": "org.tron.common.utils.Sha256Hash.twiceOf",
	"Comment": "creates a new instance containing the hash of the calculated hash of the given bytes.",
	"Method": "Sha256Hash twiceOf(byte[] contents){\r\n    return wrap(hashTwice(contents));\r\n}"
}, {
	"Path": "org.xhtmlrenderer.test.SwingImageReplacer.storeImageReplacedElement",
	"Comment": "adds a replacedelement containing an image to a cache of images for quick lookup.",
	"Method": "void storeImageReplacedElement(Element e,ReplacedElement cc){\r\n    System.out.println(\"\\n*** Cached image for element\");\r\n    imageComponents.put(e, cc);\r\n}"
}, {
	"Path": "com.graphhopper.api.GraphHopperGeocoding.geocode",
	"Comment": "perform a geocoding request. both forward and revers are possible, just configure the requestaccordingly.",
	"Method": "GHGeocodingResponse geocode(GHGeocodingRequest request){\r\n    String url = buildUrl(request);\r\n    try {\r\n        Request okRequest = new Request.Builder().url(url).build();\r\n        ResponseBody rspBody = getClientForRequest(request).newCall(okRequest).execute().body();\r\n        return objectMapper.readValue(rspBody.bytes(), GHGeocodingResponse.class);\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(\"Problem performing geocoding for \" + url + \": \" + ex.getMessage(), ex);\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Object.executeStringFunction",
	"Comment": "invoke a javascript function and return the result as a string. if theresult is not a string, or does not exist, then v8resultundefined is thrown.",
	"Method": "String executeStringFunction(String name,V8Array parameters,String executeStringFunction,String name,V8Array parameters){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    v8.checkRuntime(parameters);\r\n    long parametersHandle = parameters == null ? 0 : parameters.getHandle();\r\n    return v8.executeStringFunction(v8.getV8RuntimePtr(), getHandle(), name, parametersHandle);\r\n}"
}, {
	"Path": "org.fnlp.nlp.langmodel.lda.LdaGibbsSampler.shadefloat",
	"Comment": "create a string representation whose gray value appears as an indicatorof magnitude, cf. hinton diagrams in statistics.",
	"Method": "String shadefloat(float d,float max){\r\n    int a = (int) Math.floor(d * 10 / max + 0.5);\r\n    if (a > 10 || a < 0) {\r\n        String x = lnf.format(d);\r\n        a = 5 - x.length();\r\n        for (int i = 0; i < a; i++) {\r\n            x += \" \";\r\n        }\r\n        return \"<\" + x + \">\";\r\n    }\r\n    return \"[\" + shades[a] + \"]\";\r\n}"
}, {
	"Path": "com.graphhopper.routing.lm.LandmarkStorage.setSpatialRuleLookup",
	"Comment": "this method specifies the polygons which should be used to split the world wide area to improve performance andquality in this scenario.",
	"Method": "void setSpatialRuleLookup(SpatialRuleLookup ruleLookup){\r\n    this.ruleLookup = ruleLookup;\r\n}"
}, {
	"Path": "com.graphhopper.storage.BaseGraph.nextEdgeId",
	"Comment": "determine next free edgeid and ensure byte capacity to store edge",
	"Method": "int nextEdgeId(){\r\n    int nextEdge = edgeCount;\r\n    edgeCount++;\r\n    if (edgeCount < 0)\r\n        throw new IllegalStateException(\"too many edges. new edge id would be negative. \" + toString());\r\n    edges.ensureCapacity(((long) edgeCount + 1) * edgeEntryBytes);\r\n    return nextEdge;\r\n}"
}, {
	"Path": "com.notnoop.apns.PayloadBuilder.localizedTitleKey",
	"Comment": "the key to a title string in the localizable.strings file for the current localization.",
	"Method": "PayloadBuilder localizedTitleKey(String key){\r\n    customAlert.put(\"title-loc-key\", key);\r\n    return this;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.ImageUtil.convertToBufferedImage",
	"Comment": "utility method to convert an awt image to a bufferedimage. size is preserved, bufferedimage is compatiblewith current display device.",
	"Method": "BufferedImage convertToBufferedImage(Image awtImg,int type){\r\n    BufferedImage bimg;\r\n    if (awtImg instanceof BufferedImage) {\r\n        bimg = (BufferedImage) awtImg;\r\n    } else {\r\n        bimg = createCompatibleBufferedImage(awtImg.getWidth(null), awtImg.getHeight(null), type);\r\n        Graphics2D g = bimg.createGraphics();\r\n        g.drawImage(awtImg, 0, 0, null, null);\r\n        g.dispose();\r\n    }\r\n    return bimg;\r\n}"
}, {
	"Path": "com.graphhopper.debatty.java.stringsimilarity.JaroWinkler.getThreshold",
	"Comment": "returns the current value of the threshold used for adding the winklerbonus. the default value is 0.7.",
	"Method": "double getThreshold(){\r\n    return threshold;\r\n}"
}, {
	"Path": "org.tron.common.utils.Sha256Hash.getBytes",
	"Comment": "returns the internal byte array, without defensively copying. therefore do not modify thereturned array.",
	"Method": "byte[] getBytes(){\r\n    return bytes;\r\n}"
}, {
	"Path": "org.kie.dmn.signavio.SignavioTest.testUsingSignavioFunctionsInLiteralExpression",
	"Comment": "check the custom signavio functions work in the literalexpression too",
	"Method": "void testUsingSignavioFunctionsInLiteralExpression(){\r\n    final KieServices ks = KieServices.Factory.get();\r\n    final KieFileSystem kfs = ks.newKieFileSystem();\r\n    KieModuleModel kmm = ks.newKieModuleModel();\r\n    kmm.setConfigurationProperty(\"org.kie.dmn.profiles.signavio\", \"org.kie.dmn.signavio.KieDMNSignavioProfile\");\r\n    kfs.writeKModuleXML(kmm.toXML());\r\n    kfs.write(ks.getResources().newClassPathResource(\"Starts_with_an_A.dmn\", this.getClass()));\r\n    KieBuilder kieBuilder = ks.newKieBuilder(kfs).buildAll();\r\n    Results results = kieBuilder.getResults();\r\n    LOG.info(\"buildAll() completed.\");\r\n    results.getMessages(Level.WARNING).forEach(e -> LOG.warn(\"{}\", e));\r\n    assertTrue(results.getMessages(Level.WARNING).size() == 0);\r\n    final KieContainer kieContainer = ks.newKieContainer(ks.getRepository().getDefaultReleaseId());\r\n    DMNRuntime runtime = kieContainer.newKieSession().getKieRuntime(DMNRuntime.class);\r\n    assertStartsWithAnA(runtime, \"Abc\", true);\r\n    assertStartsWithAnA(runtime, \"Xyz\", false);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.RootPanel.getFixedRectangle",
	"Comment": "gets the fixedrectangle attribute of the basicpanel object",
	"Method": "Rectangle getFixedRectangle(){\r\n    if (enclosingScrollPane != null) {\r\n        return enclosingScrollPane.getViewportBorderBounds();\r\n    }\r\n    Dimension dim = getSize();\r\n    return new Rectangle(0, 0, dim.width, dim.height);\r\n}"
}, {
	"Path": "com.spotify.helios.client.HeliosClient.create",
	"Comment": "create a new helios client as a specific user, connecting to a helios master cluster in aspecific domain.",
	"Method": "ConvertResponseToPojo<T> create(JavaType type,Set<Integer> decodeableStatusCodes,ConvertResponseToPojo<T> create,Class<T> clazz,Set<Integer> decodeableStatusCodes,HeliosClient create,String domain,String user){\r\n    return HeliosClient.newBuilder().setDomain(domain).setUser(user).build();\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeCreateActuatorTest.sameTokenNameCloseSuccessExchangeCreate2",
	"Comment": "sametokenname close,second create exchange, result is success.",
	"Method": "void sameTokenNameCloseSuccessExchangeCreate2(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(0);\r\n    String firstTokenId = \"_\";\r\n    long firstTokenBalance = 100_000_000_000000L;\r\n    String secondTokenId = \"abc\";\r\n    long secondTokenBalance = 100_000_000L;\r\n    AssetIssueCapsule assetIssueCapsule = new AssetIssueCapsule(AssetIssueContract.newBuilder().setName(ByteString.copyFrom(secondTokenId.getBytes())).build());\r\n    assetIssueCapsule.setId(String.valueOf(1L));\r\n    dbManager.getAssetIssueStore().put(assetIssueCapsule.getName().toByteArray(), assetIssueCapsule);\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.setBalance(200_000_000_000000L);\r\n    accountCapsule.addAssetAmount(secondTokenId.getBytes(), 200_000_000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeCreateActuator actuator = new ExchangeCreateActuator(getContract(OWNER_ADDRESS_FIRST, firstTokenId, firstTokenBalance, secondTokenId, secondTokenBalance), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    Assert.assertEquals(dbManager.getDynamicPropertiesStore().getLatestExchangeNum(), 0);\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        Assert.assertEquals(ret.getInstance().getRet(), code.SUCESS);\r\n        long id = 1;\r\n        Assert.assertEquals(dbManager.getDynamicPropertiesStore().getLatestExchangeNum(), id);\r\n        ExchangeCapsule exchangeCapsule = dbManager.getExchangeStore().get(ByteArray.fromLong(id));\r\n        Assert.assertNotNull(exchangeCapsule);\r\n        Assert.assertEquals(ByteString.copyFrom(ownerAddress), exchangeCapsule.getCreatorAddress());\r\n        Assert.assertEquals(id, exchangeCapsule.getID());\r\n        Assert.assertEquals(1000000, exchangeCapsule.getCreateTime());\r\n        Assert.assertTrue(Arrays.equals(firstTokenId.getBytes(), exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenId, ByteArray.toStr(exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenBalance, exchangeCapsule.getFirstTokenBalance());\r\n        Assert.assertEquals(secondTokenId, ByteArray.toStr(exchangeCapsule.getSecondTokenId()));\r\n        Assert.assertEquals(secondTokenBalance, exchangeCapsule.getSecondTokenBalance());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        Map<String, Long> assetMap = accountCapsule.getAssetMap();\r\n        Assert.assertEquals(200_000_000_000000L - 1024_000000L - firstTokenBalance, accountCapsule.getBalance());\r\n        Assert.assertEquals(100_000_000L, assetMap.get(secondTokenId).longValue());\r\n        ExchangeCapsule exchangeCapsuleV2 = dbManager.getExchangeV2Store().get(ByteArray.fromLong(id));\r\n        Assert.assertNotNull(exchangeCapsuleV2);\r\n        Assert.assertEquals(ByteString.copyFrom(ownerAddress), exchangeCapsuleV2.getCreatorAddress());\r\n        Assert.assertEquals(id, exchangeCapsuleV2.getID());\r\n        Assert.assertEquals(1000000, exchangeCapsuleV2.getCreateTime());\r\n        secondTokenId = dbManager.getAssetIssueStore().get(secondTokenId.getBytes()).getId();\r\n        Assert.assertTrue(Arrays.equals(firstTokenId.getBytes(), exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenId, ByteArray.toStr(exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenBalance, exchangeCapsuleV2.getFirstTokenBalance());\r\n        Assert.assertEquals(secondTokenId, ByteArray.toStr(exchangeCapsuleV2.getSecondTokenId()));\r\n        Assert.assertEquals(secondTokenBalance, exchangeCapsuleV2.getSecondTokenBalance());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        Map<String, Long> getAssetV2Map = accountCapsule.getAssetMapV2();\r\n        Assert.assertEquals(200_000_000_000000L - 1024_000000L - firstTokenBalance, accountCapsule.getBalance());\r\n        Assert.assertEquals(100_000_000L, getAssetV2Map.get(secondTokenId).longValue());\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertFalse(e instanceof ContractValidateException);\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    } catch (ItemNotFoundException e) {\r\n        Assert.assertFalse(e instanceof ItemNotFoundException);\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.GraphHopper.setEnableInstructions",
	"Comment": "this method specifies if the import should include way names to be able to returninstructions for a route.",
	"Method": "GraphHopper setEnableInstructions(boolean b){\r\n    ensureNotLoaded();\r\n    enableInstructions = b;\r\n    return this;\r\n}"
}, {
	"Path": "com.graphhopper.PathWrapper.addPathDetails",
	"Comment": "adds the given pathdetails to the existing ones. if there are already pathdetails set, the numberdetails has to be equal to details.",
	"Method": "void addPathDetails(Map<String, List<PathDetail>> details){\r\n    if (!this.pathDetails.isEmpty() && !details.isEmpty() && this.pathDetails.size() != details.size()) {\r\n        throw new IllegalStateException(\"Details have to be the same size\");\r\n    }\r\n    for (Map.Entry<String, List<PathDetail>> detailEntry : details.entrySet()) {\r\n        if (this.pathDetails.containsKey(detailEntry.getKey())) {\r\n            List<PathDetail> pd = this.pathDetails.get(detailEntry.getKey());\r\n            merge(pd, detailEntry.getValue());\r\n        } else {\r\n            this.pathDetails.put(detailEntry.getKey(), detailEntry.getValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.spotify.helios.common.descriptors.JobId.parse",
	"Comment": "parse a job id string.this parsing method can be used when input is not know to be correct. i.e. when parsing ajob id supplied by the user in the cli or when parsing a request in the master restinterface.",
	"Method": "JobId parse(String id){\r\n    final String[] parts = id.split(\":\");\r\n    switch(parts.length) {\r\n        case 1:\r\n            return new JobId(parts[0], true);\r\n        case 2:\r\n            return new JobId(parts[0], parts[1]);\r\n        case 3:\r\n            return new JobId(parts[0], parts[1], parts[2]);\r\n        default:\r\n            throw new JobIdParseException(\"Invalid Job id: \" + id);\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.storage.AbstractDataAccess.writeHeader",
	"Comment": "writes some internal data into the beginning of the specified file.",
	"Method": "void writeHeader(RandomAccessFile file,long length,int segmentSize){\r\n    file.seek(0);\r\n    file.writeUTF(\"GH\");\r\n    file.writeLong(length);\r\n    file.writeInt(segmentSize);\r\n    for (int i = 0; i < header.length; i++) {\r\n        file.writeInt(header[i]);\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.reader.osm.conditional.ConditionalParser.addConditionalValueParser",
	"Comment": "this method adds a new value parser. the one added last has a higher priority.",
	"Method": "ConditionalParser addConditionalValueParser(ConditionalValueParser vp){\r\n    valueParsers.add(0, vp);\r\n    return this;\r\n}"
}, {
	"Path": "com.graphhopper.coll.SparseIntIntArray.get",
	"Comment": "gets the object mapped from the specified key, or the specified object if no such mapping hasbeen made.",
	"Method": "int get(int key,int get,int key,int valueIfKeyNotFound){\r\n    int i = binarySearch(mKeys, 0, mSize, key);\r\n    if (i < 0 || mValues[i] == DELETED) {\r\n        return valueIfKeyNotFound;\r\n    } else {\r\n        return mValues[i];\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.ScalingOptions.applyRenderingHints",
	"Comment": "applies any rendering hints configured for these scalingoptions to a graphics2d instance before image\toperations are called on it. these might be",
	"Method": "void applyRenderingHints(Graphics2D g2){\r\n    g2.setRenderingHints(getRenderingHints());\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.MouseTracker.removeListener",
	"Comment": "removes the given listener, after which it will no longer receive callbacks on mouse events.",
	"Method": "void removeListener(FSMouseListener l){\r\n    if (l == null) {\r\n        return;\r\n    }\r\n    if (_handlers.containsKey(l)) {\r\n        _handlers.remove(l);\r\n    }\r\n    if (_enabled && _handlers.size() == 0) {\r\n        _panel.removeMouseListener(this);\r\n        _panel.removeMouseMotionListener(this);\r\n        _enabled = false;\r\n    }\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeInjectActuatorTest.SameTokenNameOpenSuccessExchangeInject2",
	"Comment": "sametokenname open, second inject exchange,result is success.",
	"Method": "void SameTokenNameOpenSuccessExchangeInject2(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    InitExchangeSameTokenNameActive();\r\n    long exchangeId = 2;\r\n    String firstTokenId = \"_\";\r\n    long firstTokenQuant = 100_000_000000L;\r\n    String secondTokenId = \"456\";\r\n    long secondTokenQuant = 4_000_000L;\r\n    AssetIssueCapsule assetIssueCapsule = new AssetIssueCapsule(AssetIssueContract.newBuilder().setName(ByteString.copyFrom(secondTokenId.getBytes())).build());\r\n    assetIssueCapsule.setId(String.valueOf(2L));\r\n    dbManager.getAssetIssueV2Store().put(assetIssueCapsule.getName().toByteArray(), assetIssueCapsule);\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmountV2(secondTokenId.getBytes(), secondTokenQuant, dbManager);\r\n    accountCapsule.setBalance(firstTokenQuant);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeInjectActuator actuator = new ExchangeInjectActuator(getContract(OWNER_ADDRESS_FIRST, exchangeId, firstTokenId, firstTokenQuant), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        Assert.assertEquals(ret.getInstance().getRet(), code.SUCESS);\r\n        ExchangeCapsule exchangeV2Capsule = dbManager.getExchangeV2Store().get(ByteArray.fromLong(exchangeId));\r\n        Assert.assertNotNull(exchangeV2Capsule);\r\n        Assert.assertEquals(ByteString.copyFrom(ownerAddress), exchangeV2Capsule.getCreatorAddress());\r\n        Assert.assertEquals(exchangeId, exchangeV2Capsule.getID());\r\n        Assert.assertEquals(1000000, exchangeV2Capsule.getCreateTime());\r\n        Assert.assertTrue(Arrays.equals(firstTokenId.getBytes(), exchangeV2Capsule.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenId, ByteArray.toStr(exchangeV2Capsule.getFirstTokenId()));\r\n        Assert.assertEquals(1_100_000_000000L, exchangeV2Capsule.getFirstTokenBalance());\r\n        Assert.assertEquals(secondTokenId, ByteArray.toStr(exchangeV2Capsule.getSecondTokenId()));\r\n        Assert.assertEquals(11_000_000L, exchangeV2Capsule.getSecondTokenBalance());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        Map<String, Long> assetV2Map = accountCapsule.getAssetMapV2();\r\n        Assert.assertEquals(0L, accountCapsule.getBalance());\r\n        Assert.assertEquals(3_000_000L, assetV2Map.get(secondTokenId).longValue());\r\n    } catch (ContractValidateException e) {\r\n        logger.info(e.getMessage());\r\n        Assert.assertFalse(e instanceof ContractValidateException);\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    } catch (ItemNotFoundException e) {\r\n        Assert.assertFalse(e instanceof ItemNotFoundException);\r\n    }\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.ImportOrderer.unindent",
	"Comment": "returns the given token, or the preceding token if it is a whitespace token.",
	"Method": "int unindent(int i){\r\n    if (i > 0 && isSpaceToken(i - 1)) {\r\n        return i - 1;\r\n    } else {\r\n        return i;\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.context.StandardAttributeResolver.isFocus",
	"Comment": "gets the focus attribute of the standardattributeresolver object",
	"Method": "boolean isFocus(Object e){\r\n    return ui.isFocus((Element) e);\r\n}"
}, {
	"Path": "com.google.googlejavaformat.Newlines.lineOffsetIterator",
	"Comment": "returns an iterator over the start offsets of lines in the input.",
	"Method": "Iterator<Integer> lineOffsetIterator(String input){\r\n    return new LineOffsetIterator(input);\r\n}"
}, {
	"Path": "com.graphhopper.util.Instruction.getFirstLon",
	"Comment": "longitude of the location where this instruction should take place.",
	"Method": "double getFirstLon(){\r\n    return points.getLongitude(0);\r\n}"
}, {
	"Path": "com.graphhopper.api.GHMatrixBatchRequester.setSleepAfterGET",
	"Comment": "internal parameter. increase only if you have very large matrices.",
	"Method": "GHMatrixBatchRequester setSleepAfterGET(long sleepAfterGETMillis){\r\n    this.sleepAfterGET = sleepAfterGETMillis;\r\n    return this;\r\n}"
}, {
	"Path": "com.graphhopper.storage.GraphEdgeIdFinder.findEdgesInShape",
	"Comment": "this method fills the edgeids hash with edgeids found inside the specified shape",
	"Method": "void findEdgesInShape(GHIntHashSet edgeIds,Shape shape,EdgeFilter filter){\r\n    GHPoint center = shape.getCenter();\r\n    QueryResult qr = locationIndex.findClosest(center.getLat(), center.getLon(), filter);\r\n    if (!qr.isValid())\r\n        throw new IllegalArgumentException(\"Shape \" + shape + \" does not cover graph\");\r\n    if (shape.contains(qr.getSnappedPoint().lat, qr.getSnappedPoint().lon))\r\n        edgeIds.add(qr.getClosestEdge().getEdge());\r\n    final boolean isPolygon = shape instanceof Polygon;\r\n    BreadthFirstSearch bfs = new BreadthFirstSearch() {\r\n        final NodeAccess na = graph.getNodeAccess();\r\n        final Shape localShape = shape;\r\n        @Override\r\n        protected boolean goFurther(int nodeId) {\r\n            if (isPolygon)\r\n                return isInsideBBox(nodeId);\r\n            return localShape.contains(na.getLatitude(nodeId), na.getLongitude(nodeId));\r\n        }\r\n        @Override\r\n        protected boolean checkAdjacent(EdgeIteratorState edge) {\r\n            int adjNodeId = edge.getAdjNode();\r\n            if (localShape.contains(na.getLatitude(adjNodeId), na.getLongitude(adjNodeId))) {\r\n                edgeIds.add(edge.getEdge());\r\n                return true;\r\n            }\r\n            return isPolygon && isInsideBBox(adjNodeId);\r\n        }\r\n        private boolean isInsideBBox(int nodeId) {\r\n            BBox bbox = localShape.getBounds();\r\n            double lat = na.getLatitude(nodeId);\r\n            double lon = na.getLongitude(nodeId);\r\n            return lat <= bbox.maxLat && lat >= bbox.minLat && lon <= bbox.maxLon && lon >= bbox.minLon;\r\n        }\r\n    };\r\n    bfs.start(graph.createEdgeExplorer(filter), qr.getClosestNode());\r\n}"
}, {
	"Path": "com.graphhopper.storage.GraphEdgeIdFinder.findEdgesInShape",
	"Comment": "this method fills the edgeids hash with edgeids found inside the specified shape",
	"Method": "void findEdgesInShape(GHIntHashSet edgeIds,Shape shape,EdgeFilter filter){\r\n    if (isPolygon)\r\n        return isInsideBBox(nodeId);\r\n    return localShape.contains(na.getLatitude(nodeId), na.getLongitude(nodeId));\r\n}"
}, {
	"Path": "com.graphhopper.storage.GraphEdgeIdFinder.findEdgesInShape",
	"Comment": "this method fills the edgeids hash with edgeids found inside the specified shape",
	"Method": "void findEdgesInShape(GHIntHashSet edgeIds,Shape shape,EdgeFilter filter){\r\n    int adjNodeId = edge.getAdjNode();\r\n    if (localShape.contains(na.getLatitude(adjNodeId), na.getLongitude(adjNodeId))) {\r\n        edgeIds.add(edge.getEdge());\r\n        return true;\r\n    }\r\n    return isPolygon && isInsideBBox(adjNodeId);\r\n}"
}, {
	"Path": "com.graphhopper.storage.GraphEdgeIdFinder.findEdgesInShape",
	"Comment": "this method fills the edgeids hash with edgeids found inside the specified shape",
	"Method": "void findEdgesInShape(GHIntHashSet edgeIds,Shape shape,EdgeFilter filter){\r\n    BBox bbox = localShape.getBounds();\r\n    double lat = na.getLatitude(nodeId);\r\n    double lon = na.getLongitude(nodeId);\r\n    return lat <= bbox.maxLat && lat >= bbox.minLat && lon <= bbox.maxLon && lon >= bbox.minLon;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.newmatch.CascadedStyle.createAnonymousStyle",
	"Comment": "creates a cascadedstyle, setting the display property toto the value of the display parameter.",
	"Method": "CascadedStyle createAnonymousStyle(IdentValue display){\r\n    CSSPrimitiveValue val = new PropertyValue(display);\r\n    List props = Collections.singletonList(new PropertyDeclaration(CSSName.DISPLAY, val, true, StylesheetInfo.USER));\r\n    return new CascadedStyle(props.iterator());\r\n}"
}, {
	"Path": "org.kie.pmml.pmml_4_2.model.PMML4UnitImpl.initFromPMML",
	"Comment": "this method initializes the internal map structures. theorder of initialization is important. the internal structuresfor many models will require that the data dictionary be available",
	"Method": "void initFromPMML(){\r\n    if (this.rawPmml != null) {\r\n        initDataDictionaryMap();\r\n        initModelsMap();\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.apache.commons.collections.IntDoubleBinaryHeap.percolateDownMinHeap",
	"Comment": "percolates element down heap from the array position given by the index.",
	"Method": "void percolateDownMinHeap(int index){\r\n    final int element = elements[index];\r\n    final float key = keys[index];\r\n    int hole = index;\r\n    while (hole * 2 <= size) {\r\n        int child = hole * 2;\r\n        if (child != size && keys[child + 1] < keys[child]) {\r\n            child++;\r\n        }\r\n        if (keys[child] >= key) {\r\n            break;\r\n        }\r\n        elements[hole] = elements[child];\r\n        keys[hole] = keys[child];\r\n        hole = child;\r\n    }\r\n    elements[hole] = element;\r\n    keys[hole] = key;\r\n}"
}, {
	"Path": "com.graphhopper.reader.ReaderElement.getFirstPriorityTag",
	"Comment": "returns the first existing tag of the specified list where the order is important.",
	"Method": "String getFirstPriorityTag(List<String> restrictions){\r\n    for (String str : restrictions) {\r\n        if (hasTag(str))\r\n            return getTag(str);\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "com.graphhopper.storage.index.Location2IDQuadtree.loadExisting",
	"Comment": "loads the index from disc if exists. make sure you are using the identical graph which wasused while flushing this index.",
	"Method": "boolean loadExisting(){\r\n    if (!index.loadExisting())\r\n        return false;\r\n    if (index.getHeader(0) != MAGIC_INT)\r\n        throw new IllegalStateException(\"incorrect loc2id index version\");\r\n    int lat = index.getHeader(1 * 4);\r\n    int lon = index.getHeader(2 * 4);\r\n    int checksum = index.getHeader(3 * 4);\r\n    if (checksum != graph.getNodes())\r\n        throw new IllegalStateException(\"index was created from a different graph with \" + checksum + \". Current nodes:\" + graph.getNodes());\r\n    initAlgo(lat, lon);\r\n    return true;\r\n}"
}, {
	"Path": "org.kie.dmn.validation.AbstractValidatorTest.getReader",
	"Comment": "return the reader for the specified resource with resourcefilename, using the supplied class to locate it.",
	"Method": "Reader getReader(String resourceFileName,Reader getReader,String resourceFileName,Class<?> clazz){\r\n    return new InputStreamReader(clazz.getResourceAsStream(resourceFileName));\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.newmatch.Selector.getAppropriateSibling",
	"Comment": "gets the appropriatesibling attribute of the selector object",
	"Method": "Object getAppropriateSibling(Object e,TreeResolver treeRes){\r\n    Object sibling = null;\r\n    switch(_axis) {\r\n        case IMMEDIATE_SIBLING_AXIS:\r\n            sibling = treeRes.getPreviousSiblingElement(e);\r\n            break;\r\n        default:\r\n            XRLog.exception(\"Bad sibling axis\");\r\n    }\r\n    return sibling;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.style.derived.BorderPropertySet.getSideWidth",
	"Comment": "helper function for normalizeborderradius. gets the max side width for each of the corners or the side width whichever is larger",
	"Method": "float getSideWidth(BorderRadiusCorner left,BorderRadiusCorner right,float sideWidth){\r\n    return Math.max(sideWidth, left.getMaxRight(sideWidth) + right.getMaxLeft(sideWidth));\r\n}"
}, {
	"Path": "com.graphhopper.routing.Path.processEdge",
	"Comment": "calculates the distance and time of the specified edgeid. also it adds the edgeid to the path list.",
	"Method": "void processEdge(int edgeId,int adjNode,int prevEdgeId){\r\n    EdgeIteratorState iter = graph.getEdgeIteratorState(edgeId, adjNode);\r\n    distance += iter.getDistance();\r\n    time += weighting.calcMillis(iter, false, prevEdgeId);\r\n    addEdge(edgeId);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Object.executeObjectFunction",
	"Comment": "invoke a javascript function and return the result as a v8object. if theresult is not a v8object then v8resultundefined is thrown.",
	"Method": "V8Object executeObjectFunction(String name,V8Array parameters,V8Object executeObjectFunction,String name,V8Array parameters){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    v8.checkRuntime(parameters);\r\n    long parametersHandle = parameters == null ? 0 : parameters.getHandle();\r\n    Object result = v8.executeFunction(v8.getV8RuntimePtr(), V8_OBJECT, objectHandle, name, parametersHandle);\r\n    if (result instanceof V8Object) {\r\n        return (V8Object) result;\r\n    }\r\n    throw new V8ResultUndefined();\r\n}"
}, {
	"Path": "com.spotify.helios.testing.HeliosSoloDeployment.checkDockerAndGetGateway",
	"Comment": "checks that the local docker daemon is reachable from inside a container.this method also gets the gateway ip address for this heliossolodeployment.",
	"Method": "String checkDockerAndGetGateway(){\r\n    log.info(\"checking that docker can be reached from within a container\");\r\n    final String probeName = randomString();\r\n    final HostConfig hostConfig = HostConfig.builder().binds(binds).build();\r\n    final ContainerConfig containerConfig = ContainerConfig.builder().env(env).hostConfig(hostConfig).image(PROBE_IMAGE).cmd(probeCommand(probeName)).build();\r\n    final ContainerCreation creation;\r\n    try {\r\n        pullIfAbsent(PROBE_IMAGE);\r\n        creation = dockerClient.createContainer(containerConfig, probeName);\r\n    } catch (DockerException | InterruptedException e) {\r\n        throw new HeliosDeploymentException(\"helios-solo probe container creation failed\", e);\r\n    }\r\n    final ContainerExit exit;\r\n    final String gateway;\r\n    try {\r\n        dockerClient.startContainer(creation.id());\r\n        gateway = dockerClient.inspectContainer(creation.id()).networkSettings().gateway();\r\n        exit = dockerClient.waitContainer(creation.id());\r\n    } catch (DockerException | InterruptedException e) {\r\n        killContainer(creation.id());\r\n        throw new HeliosDeploymentException(\"helios-solo probe container failed\", e);\r\n    } finally {\r\n        removeContainer(creation.id());\r\n    }\r\n    if (exit.statusCode() != 0) {\r\n        throw new HeliosDeploymentException(String.format(\"Docker was not reachable (curl exit status %d) using DOCKER_HOST=%s and \" + \"DOCKER_CERT_PATH=%s from within a container. Please ensure that \" + \"DOCKER_HOST contains a full hostname or IP address, not localhost, \" + \"127.0.0.1, etc.\", exit.statusCode(), containerDockerHost.bindUri(), containerDockerHost.dockerCertPath()));\r\n    }\r\n    return gateway;\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.CommandLineOptions.dryRun",
	"Comment": "print the paths of the files whose contents would change if the formatter were run normally.",
	"Method": "boolean dryRun(Builder dryRun,boolean dryRun){\r\n    return dryRun;\r\n}"
}, {
	"Path": "org.tron.core.capsule.ExchangeCapsule.resetTokenWithID",
	"Comment": "be carefully, this function should be used only before allowsametokenname proposal is not active",
	"Method": "void resetTokenWithID(Manager manager){\r\n    if (manager.getDynamicPropertiesStore().getAllowSameTokenName() == 0) {\r\n        byte[] firstTokenName = this.exchange.getFirstTokenId().toByteArray();\r\n        byte[] secondTokenName = this.exchange.getSecondTokenId().toByteArray();\r\n        byte[] firstTokenID = firstTokenName;\r\n        byte[] secondTokenID = secondTokenName;\r\n        if (!Arrays.equals(firstTokenName, \"_\".getBytes())) {\r\n            firstTokenID = manager.getAssetIssueStore().get(firstTokenName).getId().getBytes();\r\n        }\r\n        if (!Arrays.equals(secondTokenName, \"_\".getBytes())) {\r\n            secondTokenID = manager.getAssetIssueStore().get(secondTokenName).getId().getBytes();\r\n        }\r\n        this.exchange = this.exchange.toBuilder().setFirstTokenId(ByteString.copyFrom(firstTokenID)).setSecondTokenId(ByteString.copyFrom(secondTokenID)).build();\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.GraphHopper.importOrLoad",
	"Comment": "imports provided data from disc and creates graph. depending on the settings the resultinggraph will be stored to disc so on a second call this method will only load the graph fromdisc which is usually a lot faster.",
	"Method": "GraphHopper importOrLoad(){\r\n    if (!load(ghLocation)) {\r\n        printInfo();\r\n        process(ghLocation);\r\n    } else {\r\n        printInfo();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.javaee7.cdi.instance.AnyGreetingTest.test",
	"Comment": "both bean instances of greeting interface should be available.\twhen dependent scoped bean is retrieved via an instance then explicit destroy action should be taken.\tthis is a known memory leak in cdi 1.0 fixed in cdi 1.1 see the link bellow for details.",
	"Method": "void test(){\r\n    assertFalse(instance.isUnsatisfied());\r\n    assertTrue(instance.isAmbiguous());\r\n    Instance<Greeting> businessInstance = instance.select(new AnnotationLiteral<Business>() {\r\n    });\r\n    Greeting businessBean = businessInstance.get();\r\n    assertThat(businessBean, instanceOf(FormalGreeting.class));\r\n    businessInstance.destroy(businessBean);\r\n    Instance<Greeting> defaultInstance = instance.select(new AnnotationLiteral<Default>() {\r\n    });\r\n    Greeting defaultBean = defaultInstance.get();\r\n    assertThat(defaultBean, instanceOf(SimpleGreeting.class));\r\n    defaultInstance.destroy(defaultBean);\r\n}"
}, {
	"Path": "com.spotify.helios.common.Json.asBytes",
	"Comment": "serialize an object to json. use when it is not know whether an object can be jsonserializable.",
	"Method": "byte[] asBytes(Object value){\r\n    return OBJECT_MAPPER.writeValueAsBytes(value);\r\n}"
}, {
	"Path": "org.immutables.value.processor.meta.ValueAttributeFunctions.isPrimitive",
	"Comment": "predicate on instance of discoveredattribute that evaluates attribute isprimitive.",
	"Method": "Predicate<ValueAttribute> isPrimitive(){\r\n    return IsPrimitivePredicate.INSTANCE;\r\n}"
}, {
	"Path": "org.immutables.ordinal.ImmutableOrdinalSet.addAll",
	"Comment": "will throw an exception and leave the collection unmodified.",
	"Method": "boolean addAll(Collection<? extends E> newElements,Builder<E> addAll,Iterable<E> elements){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.spotify.helios.testing.TemporaryJob.endpointFromHost",
	"Comment": "returns the ip address mapped to the given hostname. if no mapping exists, the hostname isreturned.",
	"Method": "String endpointFromHost(String host){\r\n    final String ip = hostToIp.get(host);\r\n    return ip == null ? host : ip;\r\n}"
}, {
	"Path": "org.kie.dmn.model.v1_2.dmndi.DMNShape.setDMNDecisionServiceDividerLine",
	"Comment": "sets the value of the dmndecisionservicedividerline property.",
	"Method": "void setDMNDecisionServiceDividerLine(org.kie.dmn.model.api.dmndi.DMNDecisionServiceDividerLine value){\r\n    this.dmnDecisionServiceDividerLine = value;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.Configuration.valueAsByte",
	"Comment": "returns the value for key in the configuration as a byte, or the defaultprovided value if not found or if the value is not a valid byte. awarning is issued to the log if the property is not defined, or if theconversion from string fails.",
	"Method": "int valueAsByte(String key,byte defaultVal){\r\n    String val = valueFor(key);\r\n    if (val == null) {\r\n        return defaultVal;\r\n    }\r\n    byte bval;\r\n    try {\r\n        bval = Byte.valueOf(val).byteValue();\r\n    } catch (NumberFormatException nex) {\r\n        XRLog.exception(\"Property '\" + key + \"' was requested as a byte, but \" + \"value of '\" + val + \"' is not a byte. Check configuration.\");\r\n        bval = defaultVal;\r\n    }\r\n    return bval;\r\n}"
}, {
	"Path": "com.graphhopper.GraphHopper.forDesktop",
	"Comment": "configures the underlying storage to be used on a desktop computer or within another javaapplication with enough ram but no network latency.",
	"Method": "GraphHopper forDesktop(){\r\n    setSimplifyResponse(false);\r\n    return setInMemory();\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.constants.CSSName.countCSSNames",
	"Comment": "returns a count of all css properties known to this class, shorthand and primitive.",
	"Method": "int countCSSNames(){\r\n    return CSSName.maxAssigned;\r\n}"
}, {
	"Path": "com.spotify.helios.agent.TaskMonitor.updateState",
	"Comment": "propagate a new task state by setting it and committing the status update.",
	"Method": "void updateState(TaskStatus.State state){\r\n    statusUpdater.setState(state);\r\n    try {\r\n        statusUpdater.update();\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.style.derived.BorderPropertySet.darken",
	"Comment": "returns the colors for brighter parts of each side for a particular decoration style",
	"Method": "BorderPropertySet darken(IdentValue style){\r\n    BorderPropertySet bc = new BorderPropertySet(this);\r\n    bc._topColor = _topColor == null ? null : _topColor.darkenColor();\r\n    bc._bottomColor = _bottomColor == null ? null : _bottomColor.darkenColor();\r\n    bc._leftColor = _leftColor == null ? null : _leftColor.darkenColor();\r\n    bc._rightColor = _rightColor == null ? null : _rightColor.darkenColor();\r\n    return bc;\r\n}"
}, {
	"Path": "com.graphhopper.routing.weighting.AbstractAdjustedWeighting.getFlagEncoder",
	"Comment": "returns the flagencoder of the superweighting. usually we do not have a flagencoder here.",
	"Method": "FlagEncoder getFlagEncoder(){\r\n    return superWeighting.getFlagEncoder();\r\n}"
}, {
	"Path": "com.graphhopper.routing.DijkstraOneToManyTest.configs",
	"Comment": "runs the same test with each of the supported traversal modes",
	"Method": "Collection<Object[]> configs(){\r\n    return Arrays.asList(new Object[][] { { TraversalMode.NODE_BASED } });\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeWithdrawActuatorTest.SameTokenNameCloseTokenQuantLessThanZero",
	"Comment": "sametokenname close, withdraw token quant must greater than zero",
	"Method": "void SameTokenNameCloseTokenQuantLessThanZero(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(0);\r\n    InitExchangeBeforeSameTokenNameActive();\r\n    long exchangeId = 1;\r\n    String firstTokenId = \"abc\";\r\n    long firstTokenQuant = -1L;\r\n    String secondTokenId = \"def\";\r\n    long secondTokenQuant = 400000000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmount(firstTokenId.getBytes(), 1000L);\r\n    accountCapsule.addAssetAmount(secondTokenId.getBytes(), secondTokenQuant);\r\n    accountCapsule.setBalance(10000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeWithdrawActuator actuator = new ExchangeWithdrawActuator(getContract(OWNER_ADDRESS_FIRST, exchangeId, firstTokenId, firstTokenQuant), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"withdraw token quant must greater than zero\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.GraphHopper.setEnableCalcPoints",
	"Comment": "this methods enables gps point calculation. if disabled only distance will be calculated.",
	"Method": "GraphHopper setEnableCalcPoints(boolean b){\r\n    calcPoints = b;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.JavaOutput.startPosition",
	"Comment": "the earliest position of any tok in the token, including leading whitespace.",
	"Method": "int startPosition(Token token){\r\n    int min = token.getTok().getPosition();\r\n    for (Input.Tok tok : token.getToksBefore()) {\r\n        min = Math.min(min, tok.getPosition());\r\n    }\r\n    return min;\r\n}"
}, {
	"Path": "com.spotify.helios.common.Json.asNormalizedStringUnchecked",
	"Comment": "serialize an object to a json string, ordering fields and omitting null and empty fields.use when object is expected to be json serializable.",
	"Method": "String asNormalizedStringUnchecked(Object value){\r\n    try {\r\n        return asNormalizedString(value);\r\n    } catch (JsonProcessingException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.util.Helper.isFileMapped",
	"Comment": "determines if the specified bytebuffer is one which maps to a file!",
	"Method": "boolean isFileMapped(ByteBuffer bb){\r\n    if (bb instanceof MappedByteBuffer) {\r\n        try {\r\n            ((MappedByteBuffer) bb).isLoaded();\r\n            return true;\r\n        } catch (UnsupportedOperationException ex) {\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.graphhopper.api.GraphHopperWeb.setCalcPoints",
	"Comment": "enable or disable calculating points for the way. the default is true.",
	"Method": "GraphHopperWeb setCalcPoints(boolean calcPoints){\r\n    this.calcPoints = calcPoints;\r\n    return this;\r\n}"
}, {
	"Path": "com.spotify.helios.common.Json.asNormalizedString",
	"Comment": "serialize an object to a json string, ordering fields and omitting null and empty fields.use when it is not know whether an object can be json serializable.",
	"Method": "String asNormalizedString(Object value){\r\n    return NORMALIZING_OBJECT_WRITER.writeValueAsString(value);\r\n}"
}, {
	"Path": "org.javaee7.cdi.dynamic.interceptor.extension.DynamicHelloInterceptor.getBeanClass",
	"Comment": "the annotated class that contains the priority and causes the interceptor to be enabled",
	"Method": "Class<?> getBeanClass(){\r\n    return HelloInterceptorEnabler.class;\r\n}"
}, {
	"Path": "org.kie.dmn.model.v1_2.dmndi.Shape.getBounds",
	"Comment": "the optional bounds of the shape relative to the origin of its nesting plane.",
	"Method": "org.kie.dmn.model.api.dmndi.Bounds getBounds(){\r\n    return bounds;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.render.RenderingContext.isPaged",
	"Comment": "returns true if the currently set media type is paged. currently returnstrue only for print , projection , and embossed ,handheld , and tv . see the media section of the css2.1 spec for more information on media types.",
	"Method": "boolean isPaged(){\r\n    return sharedContext.isPaged();\r\n}"
}, {
	"Path": "com.graphhopper.routing.lm.LandmarkStorage.setLandmarkSuggestions",
	"Comment": "this method forces the landmark preparation to skip the landmark search and uses the specified landmark list instead.useful for manual tuning of larger areas to safe import time or improve quality.",
	"Method": "LandmarkStorage setLandmarkSuggestions(List<LandmarkSuggestion> landmarkSuggestions){\r\n    if (landmarkSuggestions == null)\r\n        throw new IllegalArgumentException(\"landmark suggestions cannot be null\");\r\n    this.landmarkSuggestions = landmarkSuggestions;\r\n    return this;\r\n}"
}, {
	"Path": "com.notnoop.apns.ApnsServerSocketBuilder.withGatewayDestination",
	"Comment": "specify the gateway server for sending apple iphone notifications.",
	"Method": "ApnsServerSocketBuilder withGatewayDestination(int port){\r\n    this.gatewayPort = port;\r\n    return this;\r\n}"
}, {
	"Path": "com.graphhopper.api.GraphHopperWeb.setInstructions",
	"Comment": "enable or disable calculating and returning turn instructions. thedefault is true.",
	"Method": "GraphHopperWeb setInstructions(boolean b){\r\n    instructions = b;\r\n    return this;\r\n}"
}, {
	"Path": "com.notnoop.apns.integration.ApnsConnectionCacheTest.cacheLengthNotification",
	"Comment": "test to make sure that if the cache length is violated we geta notification",
	"Method": "void cacheLengthNotification(){\r\n    server = new ApnsServerStub(FixedCertificates.serverContext().getServerSocketFactory());\r\n    final CountDownLatch sync = new CountDownLatch(1);\r\n    int ORIGINAL_CACHE_LENGTH = 100;\r\n    final AtomicInteger modifiedCacheLength = new AtomicInteger();\r\n    server.getWaitForError().acquire();\r\n    server.start();\r\n    ApnsService service = APNS.newService().withSSLContext(clientContext()).withGatewayDestination(LOCALHOST, server.getEffectiveGatewayPort()).withDelegate(new ApnsDelegate() {\r\n        public void messageSent(ApnsNotification message, boolean resent) {\r\n        }\r\n        public void messageSendFailed(ApnsNotification message, Throwable e) {\r\n        }\r\n        public void connectionClosed(DeliveryError e, int messageIdentifier) {\r\n        }\r\n        public void cacheLengthExceeded(int newCacheLength) {\r\n            modifiedCacheLength.set(newCacheLength);\r\n            sync.countDown();\r\n        }\r\n        public void notificationsResent(int resendCount) {\r\n        }\r\n    }).build();\r\n    server.stopAt(eMsg1.length() * 5 + eMsg2.length() + eMsg3.length() * 14);\r\n    for (int i = 0; i < 5; ++i) {\r\n        service.push(eMsg1);\r\n    }\r\n    service.push(eMsg2);\r\n    for (int i = 0; i < 101; ++i) {\r\n        service.push(eMsg3);\r\n    }\r\n    server.sendError(8, eMsg2.getIdentifier());\r\n    server.getWaitForError().release();\r\n    server.getMessages().acquire();\r\n    sync.await();\r\n    Assert.assertTrue(ORIGINAL_CACHE_LENGTH < modifiedCacheLength.get());\r\n}"
}, {
	"Path": "com.notnoop.apns.integration.ApnsConnectionCacheTest.cacheLengthNotification",
	"Comment": "test to make sure that if the cache length is violated we geta notification",
	"Method": "void cacheLengthNotification(){\r\n}"
}, {
	"Path": "com.notnoop.apns.integration.ApnsConnectionCacheTest.cacheLengthNotification",
	"Comment": "test to make sure that if the cache length is violated we geta notification",
	"Method": "void cacheLengthNotification(){\r\n}"
}, {
	"Path": "com.notnoop.apns.integration.ApnsConnectionCacheTest.cacheLengthNotification",
	"Comment": "test to make sure that if the cache length is violated we geta notification",
	"Method": "void cacheLengthNotification(){\r\n}"
}, {
	"Path": "com.notnoop.apns.integration.ApnsConnectionCacheTest.cacheLengthNotification",
	"Comment": "test to make sure that if the cache length is violated we geta notification",
	"Method": "void cacheLengthNotification(){\r\n    modifiedCacheLength.set(newCacheLength);\r\n    sync.countDown();\r\n}"
}, {
	"Path": "com.notnoop.apns.integration.ApnsConnectionCacheTest.cacheLengthNotification",
	"Comment": "test to make sure that if the cache length is violated we geta notification",
	"Method": "void cacheLengthNotification(){\r\n}"
}, {
	"Path": "org.xhtmlrenderer.layout.SharedContext.setTextRenderer",
	"Comment": "sets the textrenderer attribute of the renderingcontext object",
	"Method": "void setTextRenderer(TextRenderer text_renderer){\r\n    this.text_renderer = text_renderer;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.Configuration.valueAsShort",
	"Comment": "returns the value for key in the configuration as a short, or the defaultprovided value if not found or if the value is not a valid short. awarning is issued to the log if the property is not defined, or if theconversion from string fails.",
	"Method": "int valueAsShort(String key,short defaultVal){\r\n    String val = valueFor(key);\r\n    if (val == null) {\r\n        return defaultVal;\r\n    }\r\n    short sval;\r\n    try {\r\n        sval = Short.valueOf(val).shortValue();\r\n    } catch (NumberFormatException nex) {\r\n        XRLog.exception(\"Property '\" + key + \"' was requested as a short, but \" + \"value of '\" + val + \"' is not a short. Check configuration.\");\r\n        sval = defaultVal;\r\n    }\r\n    return sval;\r\n}"
}, {
	"Path": "com.graphhopper.reader.osm.pbf.PbfRawBlob.getType",
	"Comment": "gets the type of data represented by this blob. this corresponds to the type field in theblob header.",
	"Method": "String getType(){\r\n    return type;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.context.StyleReference.setDocumentContext",
	"Comment": "sets the documentcontext attribute of the stylereference object",
	"Method": "void setDocumentContext(SharedContext context,NamespaceHandler nsh,Document doc,UserInterface ui){\r\n    _context = context;\r\n    _nsh = nsh;\r\n    _doc = doc;\r\n    AttributeResolver attRes = new StandardAttributeResolver(_nsh, _uac, ui);\r\n    List infos = getStylesheets();\r\n    XRLog.match(\"media = \" + _context.getMedia());\r\n    _matcher = new org.xhtmlrenderer.css.newmatch.Matcher(new DOMTreeResolver(), attRes, _stylesheetFactory, readAndParseAll(infos, _context.getMedia()), _context.getMedia());\r\n}"
}, {
	"Path": "com.spotify.helios.master.reaper.OldJobReaperTest.jobDeployedWithHistoryLastUsedTooLongAgoInDgNotReaped",
	"Comment": "a job not deployed, with history, last used too long ago and part of a deployment groupshould not be reaped.",
	"Method": "void jobDeployedWithHistoryLastUsedTooLongAgoInDgNotReaped(){\r\n    final MasterModel masterModel = mock(MasterModel.class);\r\n    when(masterModel.getDeploymentGroups()).thenReturn(ImmutableMap.of(\"testdg\", new DeploymentGroup(\"name\", new ArrayList(), JobId.fromString(name.getMethodName()), RolloutOptions.getDefault(), DeploymentGroup.RollingUpdateReason.MANUAL)));\r\n    testReap(name.getMethodName(), emptyMap(), events(ImmutableList.of(HOURS.toMillis(2), HOURS.toMillis(3))), null, masterModel, false);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.parser.Lexer.yytext",
	"Comment": "returns the text matched by the current regular expression.",
	"Method": "String yytext(){\r\n    return new String(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);\r\n}"
}, {
	"Path": "com.spotify.helios.system.HealthCheckTest.pokeJob",
	"Comment": "starts a container that listens on a poke port, and once poked listens on the healthcheckport.",
	"Method": "Job pokeJob(HealthCheck healthCheck){\r\n    return Job.newBuilder().setName(testJobName).setVersion(testJobVersion).setImage(ALPINE).setCommand(asList(\"sh\", \"-c\", \"nc -l -p 4711 && nc -lk -p 4712 -e hostname\")).addPort(\"poke\", PortMapping.of(4711)).addPort(\"health\", PortMapping.of(4712)).addRegistration(ServiceEndpoint.of(\"foo_service\", \"foo_proto\"), ServicePorts.of(\"health\")).setHealthCheck(healthCheck).build();\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.EncodingManager.acceptWay",
	"Comment": "determine whether a way is routable for one of the added encoders.",
	"Method": "long acceptWay(ReaderWay way){\r\n    long includeWay = 0;\r\n    for (AbstractFlagEncoder encoder : edgeEncoders) {\r\n        includeWay |= encoder.acceptWay(way);\r\n    }\r\n    return includeWay;\r\n}"
}, {
	"Path": "com.graphhopper.util.GHUtility.newStorage",
	"Comment": "create a new storage from the specified one without copying the data.",
	"Method": "GraphHopperStorage newStorage(GraphHopperStorage store){\r\n    Directory outdir = guessDirectory(store);\r\n    boolean is3D = store.getNodeAccess().is3D();\r\n    return new GraphHopperStorage(store.getCHWeightings(), outdir, store.getEncodingManager(), is3D, store.getExtension()).create(store.getNodes());\r\n}"
}, {
	"Path": "org.xhtmlrenderer.test.XLayout.getIntrinsicDimensions",
	"Comment": "gets the intrinsicdimensions attribute of the xlayout object",
	"Method": "Dimension getIntrinsicDimensions(LayoutContext c,Element elem){\r\n    return new Dimension(50, 50);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.NaiveUserAgent.isVisited",
	"Comment": "returns true if the given uri was visited, meaning it was requested at some point since initialization.",
	"Method": "boolean isVisited(String uri){\r\n    return false;\r\n}"
}, {
	"Path": "com.graphhopper.storage.GraphHopperStorage.freeze",
	"Comment": "avoid that edges and nodes of the base graph are further modified. necessary as hook for e.g.ch graphs on top to initialize themselves",
	"Method": "void freeze(){\r\n    if (!baseGraph.isFrozen())\r\n        baseGraph.freeze();\r\n}"
}, {
	"Path": "org.tron.common.crypto.zksnark.BN128G1.create",
	"Comment": "checks whether point is a member of subgroup,returns a point if check has been passed and null otherwise",
	"Method": "BN128G1 create(byte[] x,byte[] y){\r\n    BN128<Fp> p = BN128Fp.create(x, y);\r\n    if (p == null)\r\n        return null;\r\n    if (!isGroupMember(p))\r\n        return null;\r\n    return new BN128G1(p);\r\n}"
}, {
	"Path": "com.graphhopper.routing.subnetwork.TarjansSCCAlgorithm.findComponents",
	"Comment": "find and return list of all strongly connected components in g.",
	"Method": "List<IntArrayList> findComponents(){\r\n    int nodes = graph.getNodes();\r\n    for (int start = 0; start < nodes; start++) {\r\n        if (nodeIndex[start] == 0 && !ignoreSet.contains(start) && !graph.isNodeRemoved(start))\r\n            strongConnect(start);\r\n    }\r\n    return components;\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeWithdrawActuatorTest.SameTokenNameOpenSuccessExchangeWithdraw",
	"Comment": "sametokenname open, first withdraw exchange,result is success.",
	"Method": "void SameTokenNameOpenSuccessExchangeWithdraw(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    InitExchangeSameTokenNameActive();\r\n    long exchangeId = 1;\r\n    String firstTokenId = \"123\";\r\n    long firstTokenQuant = 100000000L;\r\n    String secondTokenId = \"456\";\r\n    long secondTokenQuant = 200000000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    Map<String, Long> assetV2Map = accountCapsule.getAssetMapV2();\r\n    Assert.assertEquals(10000_000000L, accountCapsule.getBalance());\r\n    Assert.assertEquals(null, assetV2Map.get(firstTokenId));\r\n    Assert.assertEquals(null, assetV2Map.get(secondTokenId));\r\n    ExchangeWithdrawActuator actuator = new ExchangeWithdrawActuator(getContract(OWNER_ADDRESS_FIRST, exchangeId, firstTokenId, firstTokenQuant), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        Assert.assertEquals(ret.getInstance().getRet(), code.SUCESS);\r\n        long id = 1;\r\n        ExchangeCapsule exchangeCapsuleV2 = dbManager.getExchangeV2Store().get(ByteArray.fromLong(id));\r\n        Assert.assertNotNull(exchangeCapsuleV2);\r\n        Assert.assertEquals(ByteString.copyFrom(ownerAddress), exchangeCapsuleV2.getCreatorAddress());\r\n        Assert.assertEquals(id, exchangeCapsuleV2.getID());\r\n        Assert.assertEquals(1000000, exchangeCapsuleV2.getCreateTime());\r\n        Assert.assertTrue(Arrays.equals(firstTokenId.getBytes(), exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenId, ByteArray.toStr(exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(0L, exchangeCapsuleV2.getFirstTokenBalance());\r\n        Assert.assertEquals(secondTokenId, ByteArray.toStr(exchangeCapsuleV2.getSecondTokenId()));\r\n        Assert.assertEquals(0L, exchangeCapsuleV2.getSecondTokenBalance());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        assetV2Map = accountCapsule.getAssetMapV2();\r\n        Assert.assertEquals(10000_000000L, accountCapsule.getBalance());\r\n        Assert.assertEquals(firstTokenQuant, assetV2Map.get(firstTokenId).longValue());\r\n        Assert.assertEquals(secondTokenQuant, assetV2Map.get(secondTokenId).longValue());\r\n    } catch (ContractValidateException e) {\r\n        logger.info(e.getMessage());\r\n        Assert.assertFalse(e instanceof ContractValidateException);\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    } catch (ItemNotFoundException e) {\r\n        Assert.assertFalse(e instanceof ItemNotFoundException);\r\n    }\r\n}"
}, {
	"Path": "org.tron.core.actuator.WitnessUpdateActuatorTest.notExistAccount",
	"Comment": "if account does not exist in accountstore, the test will throw a exception",
	"Method": "void notExistAccount(){\r\n    WitnessUpdateActuator actuator = new WitnessUpdateActuator(getContract(OWNER_ADDRESS_NOTEXIST, URL), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail(\"account does not exist\");\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"account does not exist\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.Configuration.info",
	"Comment": "used internally to log a message about the class at level info",
	"Method": "void info(String msg){\r\n    if (logLevel.intValue() <= Level.INFO.intValue()) {\r\n        println(Level.INFO, msg);\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.PathWrapper.getPoints",
	"Comment": "this method returns all points on the path. keep in mind that calculating the distance fromthese points might yield different results compared to getdistance as points could have beensimplified on import or after querying.",
	"Method": "PointList getPoints(){\r\n    check(\"getPoints\");\r\n    return pointList;\r\n}"
}, {
	"Path": "com.graphhopper.reader.osm.pbf.PbfBlobResult.storeSuccessResult",
	"Comment": "stores the results of a successful blob decoding operation.",
	"Method": "void storeSuccessResult(List<ReaderElement> decodedEntities){\r\n    entities = decodedEntities;\r\n    complete = true;\r\n    success = true;\r\n}"
}, {
	"Path": "com.spotify.helios.testing.HeliosSoloDeployment.getHostPort",
	"Comment": "return the first host port bound to the requested container port.",
	"Method": "String getHostPort(String containerId,int containerPort){\r\n    final String heliosPort = String.format(\"%d/tcp\", containerPort);\r\n    try {\r\n        final NetworkSettings settings = dockerClient.inspectContainer(containerId).networkSettings();\r\n        for (final Map.Entry<String, List<PortBinding>> entry : settings.ports().entrySet()) {\r\n            if (entry.getKey().equals(heliosPort)) {\r\n                return entry.getValue().get(0).hostPort();\r\n            }\r\n        }\r\n    } catch (DockerException | InterruptedException e) {\r\n        throw new HeliosDeploymentException(String.format(\"unable to find port binding for %s in container %s.\", heliosPort, containerId), e);\r\n    }\r\n    throw new HeliosDeploymentException(String.format(\"unable to find port binding for %s in container %s.\", heliosPort, containerId));\r\n}"
}, {
	"Path": "com.graphhopper.util.shapes.BBox.calculateIntersection",
	"Comment": "calculates the intersecting bbox between this and the specified bbox",
	"Method": "BBox calculateIntersection(BBox bBox){\r\n    if (!this.intersect(bBox))\r\n        return null;\r\n    double minLon = Math.max(this.minLon, bBox.minLon);\r\n    double maxLon = Math.min(this.maxLon, bBox.maxLon);\r\n    double minLat = Math.max(this.minLat, bBox.minLat);\r\n    double maxLat = Math.min(this.maxLat, bBox.maxLat);\r\n    return new BBox(minLon, maxLon, minLat, maxLat);\r\n}"
}, {
	"Path": "com.graphhopper.routing.InstructionsOutgoingEdges.getOtherContinue",
	"Comment": "returns an edge that has more or less in the same orientation as the prevedge, but is not the currentedge.if there is one, this indicates that we might need an instruction to help finding the correct edge out of the different choices.if there is none, return null.",
	"Method": "EdgeIteratorState getOtherContinue(double prevLat,double prevLon,double prevOrientation){\r\n    int tmpSign;\r\n    for (EdgeIteratorState edge : allowedOutgoingEdges) {\r\n        GHPoint point = InstructionsHelper.getPointForOrientationCalculation(edge, nodeAccess);\r\n        tmpSign = InstructionsHelper.calculateSign(prevLat, prevLon, point.getLat(), point.getLon(), prevOrientation);\r\n        if (Math.abs(tmpSign) <= 1) {\r\n            return edge;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.graphhopper.util.StopWatch.getCurrentSeconds",
	"Comment": "returns the total elapsed time on this stopwatch without the need of stopping it",
	"Method": "float getCurrentSeconds(){\r\n    if (notStarted()) {\r\n        return 0;\r\n    }\r\n    long lastNanos = lastTime < 0 ? 0 : System.nanoTime() - lastTime;\r\n    return (elapsedNanos + lastNanos) / 1e9f;\r\n}"
}, {
	"Path": "com.graphhopper.routing.QueryGraph.addVirtualEdges",
	"Comment": "creates a fake edge iterator pointing to multiple edge states.",
	"Method": "void addVirtualEdges(IntObjectMap<VirtualEdgeIterator> node2EdgeMap,EdgeFilter filter,boolean base,int node,int virtNode){\r\n    VirtualEdgeIterator existingIter = node2EdgeMap.get(node);\r\n    if (existingIter == null) {\r\n        existingIter = new VirtualEdgeIterator(10);\r\n        node2EdgeMap.put(node, existingIter);\r\n    }\r\n    EdgeIteratorState edge = base ? virtualEdges.get(virtNode * 4 + VE_BASE) : virtualEdges.get(virtNode * 4 + VE_ADJ_REV);\r\n    if (filter.accept(edge))\r\n        existingIter.add(edge);\r\n}"
}, {
	"Path": "org.kie.pmml.assembler.PMMLAssemblerService.getPackageDescrs",
	"Comment": "this method calls the pmml compiler to get pmmlresource objects which are used to\tcreate one or more packagedescr objects",
	"Method": "List<PackageDescr> getPackageDescrs(Resource resource){\r\n    List<PMMLResource> resources = pmmlCompiler.precompile(resource.getInputStream(), null, null);\r\n    if (resources != null && !resources.isEmpty()) {\r\n        return generatedResourcesToPackageDescr(resource, resources);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.immutables.mongo.types.TypeAdapters.create",
	"Comment": "safe unchecked, typecheck performed by type token equality",
	"Method": "TypeAdapter<T> create(Gson gson,TypeToken<T> type){\r\n    if (ID_TYPE_TOKEN.equals(type)) {\r\n        return (TypeAdapter<T>) WRAPPED_ID_ADAPTER;\r\n    }\r\n    if (TIME_INSTANT_TYPE_TOKEN.equals(type)) {\r\n        return (TypeAdapter<T>) WRAPPED_TIME_INSTANT_ADAPTER;\r\n    }\r\n    if (BINARY_TYPE_TOKEN.equals(type)) {\r\n        return (TypeAdapter<T>) WRAPPED_BINARY_ADAPTER;\r\n    }\r\n    if (PATTERN_TYPE_TOKEN.equals(type)) {\r\n        return (TypeAdapter<T>) PATTERN_ADAPTER;\r\n    }\r\n    if (DECIMAL128_TYPE_TOKEN.equals(type)) {\r\n        return (TypeAdapter<T>) DECIMAL128_ADAPTER;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.graphhopper.storage.index.LocationIndexTree.setMinResolutionInMeter",
	"Comment": "minimum width in meter of one tile. decrease this if you need faster queries, but keep inmind that then queries with different coordinates are more likely to fail.",
	"Method": "LocationIndexTree setMinResolutionInMeter(int minResolutionInMeter){\r\n    this.minResolutionInMeter = minResolutionInMeter;\r\n    return this;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Array.getByte",
	"Comment": "returns the byte value associated at this index. if the value atthis index does not exist, or cannot be cast to a byte, thenv8resultundefined exception is thrown.",
	"Method": "byte getByte(int index,byte getByte,int index){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    return v8.arrayGetByte(v8.getV8RuntimePtr(), getHandle(), index);\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.FootFlagEncoder.getSpeed",
	"Comment": "this method is a current hack, to allow ferries to be actually faster than our current storable maxspeed.",
	"Method": "double getSpeed(long flags){\r\n    double speed = super.getSpeed(flags);\r\n    if (speed == getMaxSpeed()) {\r\n        return SHORT_TRIP_FERRY_SPEED;\r\n    }\r\n    return speed;\r\n}"
}, {
	"Path": "com.graphhopper.storage.BaseGraph.initNodeRefs",
	"Comment": "initializes the node area with the empty edge value and default additional value.",
	"Method": "void initNodeRefs(long oldCapacity,long newCapacity){\r\n    for (long pointer = oldCapacity + N_EDGE_REF; pointer < newCapacity; pointer += nodeEntryBytes) {\r\n        nodes.setInt(pointer, EdgeIterator.NO_EDGE);\r\n    }\r\n    if (extStorage.isRequireNodeField()) {\r\n        for (long pointer = oldCapacity + N_ADDITIONAL; pointer < newCapacity; pointer += nodeEntryBytes) {\r\n            nodes.setInt(pointer, extStorage.getDefaultNodeFieldValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.spotify.helios.testing.HeliosSoloDeployment.client",
	"Comment": "return a helios client connected to the master of this heliossolodeployment.",
	"Method": "HeliosClient client(){\r\n    return this.heliosClient;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.context.StandardAttributeResolver.getAttributeValue",
	"Comment": "gets the attributevalue attribute of the standardattributeresolver object",
	"Method": "String getAttributeValue(Object e,String attrName,String getAttributeValue,Object e,String namespaceURI,String attrName){\r\n    return nsh.getAttributeValue((Element) e, namespaceURI, attrName);\r\n}"
}, {
	"Path": "com.spotify.helios.agent.TaskRunner.unregister",
	"Comment": "unregister a set of service endpoints previously registered.",
	"Method": "boolean unregister(){\r\n    if (serviceRegistrationHandle.isPresent()) {\r\n        registrar.unregister(serviceRegistrationHandle.get());\r\n        serviceRegistrationHandle = Optional.absent();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.graphhopper.util.TranslationMap.doImport",
	"Comment": "this loads the translation files from the specified folder.",
	"Method": "TranslationMap doImport(File folder,TranslationMap doImport,TranslationHashMap doImport,InputStream is){\r\n    try {\r\n        for (String locale : LOCALES) {\r\n            TranslationHashMap trMap = new TranslationHashMap(getLocale(locale));\r\n            trMap.doImport(TranslationMap.class.getResourceAsStream(locale + \".txt\"));\r\n            add(trMap);\r\n        }\r\n        postImportHook();\r\n        return this;\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.routing.lm.LandmarkStorage.setLMSelectionWeighting",
	"Comment": "this weighting is used for the selection heuristic and is per default not the weighting specified in the contructor.the special weighting leads to a much better distribution of the landmarks and results in better response times.",
	"Method": "void setLMSelectionWeighting(Weighting lmSelectionWeighting){\r\n    this.lmSelectionWeighting = lmSelectionWeighting;\r\n}"
}, {
	"Path": "com.graphhopper.storage.MMapDataAccess.clean",
	"Comment": "cleans up mappedbytebuffers. be sure you bring the segments list in a consistent stateafterwards.",
	"Method": "void clean(int from,int to){\r\n    for (int i = from; i < to; i++) {\r\n        ByteBuffer bb = segments.get(i);\r\n        cleanMappedByteBuffer(bb);\r\n        segments.set(i, null);\r\n    }\r\n}"
}, {
	"Path": "org.kie.pmml.assembler.PMMLAssemblerService.addPackage",
	"Comment": "this method does the work of calling the pmml compiler and then assembling the results\tinto packages that are added to the knowledgebuilder",
	"Method": "void addPackage(Resource resource){\r\n    if (pmmlCompiler != null) {\r\n        if (pmmlCompiler.getResults().isEmpty()) {\r\n            addPMMLPojos(pmmlCompiler, resource);\r\n            if (pmmlCompiler.getResults().isEmpty()) {\r\n                List<PackageDescr> packages = getPackageDescrs(resource);\r\n                if (packages != null && !packages.isEmpty()) {\r\n                    for (PackageDescr descr : packages) {\r\n                        this.kbuilder.addPackage(descr);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeTransactionActuatorTest.SameTokenNameOpenTokenRequiredNotEnough",
	"Comment": "sametokenname open,token required must greater than expected",
	"Method": "void SameTokenNameOpenTokenRequiredNotEnough(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    InitExchangeSameTokenNameActive();\r\n    long exchangeId = 2;\r\n    String tokenId = \"123\";\r\n    long quant = 1_000L;\r\n    String buyTokenId = \"456\";\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_SECOND);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmountV2(tokenId.getBytes(), quant, dbManager);\r\n    Map<String, Long> assetV2Map = accountCapsule.getAssetMapV2();\r\n    Assert.assertEquals(20000_000000L, accountCapsule.getBalance());\r\n    Assert.assertEquals(null, assetV2Map.get(buyTokenId));\r\n    dbManager.getAccountStore().put(accountCapsule.createDbKey(), accountCapsule);\r\n    long expected = 0;\r\n    try {\r\n        ExchangeCapsule exchangeCapsuleV2 = dbManager.getExchangeV2Store().get(ByteArray.fromLong(exchangeId));\r\n        expected = exchangeCapsuleV2.transaction(tokenId.getBytes(), quant);\r\n    } catch (ItemNotFoundException e) {\r\n        fail();\r\n    }\r\n    ExchangeTransactionActuator actuator = new ExchangeTransactionActuator(getContract(OWNER_ADDRESS_SECOND, exchangeId, tokenId, quant, expected + 1), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail(\"should not run here\");\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"token required must greater than expected\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.layout.BoxBuilder.reorderTableContent",
	"Comment": "reorganizes a table so that the header is the first row group and thefooter the last.if the table has caption boxes, they will be pulledout and added to an anonymous block box along with the table itself.if not, the table is returned.",
	"Method": "BlockBox reorderTableContent(LayoutContext c,TableBox table){\r\n    List topCaptions = new LinkedList();\r\n    Box header = null;\r\n    List bodies = new LinkedList();\r\n    Box footer = null;\r\n    List bottomCaptions = new LinkedList();\r\n    for (Iterator i = table.getChildIterator(); i.hasNext(); ) {\r\n        Box b = (Box) i.next();\r\n        IdentValue display = b.getStyle().getIdent(CSSName.DISPLAY);\r\n        if (display == IdentValue.TABLE_CAPTION) {\r\n            IdentValue side = b.getStyle().getIdent(CSSName.CAPTION_SIDE);\r\n            if (side == IdentValue.BOTTOM) {\r\n                bottomCaptions.add(b);\r\n            } else {\r\n                topCaptions.add(b);\r\n            }\r\n        } else if (display == IdentValue.TABLE_HEADER_GROUP && header == null) {\r\n            header = b;\r\n        } else if (display == IdentValue.TABLE_FOOTER_GROUP && footer == null) {\r\n            footer = b;\r\n        } else {\r\n            bodies.add(b);\r\n        }\r\n    }\r\n    table.removeAllChildren();\r\n    if (header != null) {\r\n        ((TableSectionBox) header).setHeader(true);\r\n        table.addChild(header);\r\n    }\r\n    table.addAllChildren(bodies);\r\n    if (footer != null) {\r\n        ((TableSectionBox) footer).setFooter(true);\r\n        table.addChild(footer);\r\n    }\r\n    if (topCaptions.size() == 0 && bottomCaptions.size() == 0) {\r\n        return table;\r\n    } else {\r\n        CalculatedStyle anonStyle;\r\n        if (table.getStyle().isFloated()) {\r\n            CascadedStyle cascadedStyle = CascadedStyle.createLayoutStyle(new PropertyDeclaration[] { CascadedStyle.createLayoutPropertyDeclaration(CSSName.DISPLAY, IdentValue.BLOCK), CascadedStyle.createLayoutPropertyDeclaration(CSSName.FLOAT, table.getStyle().getIdent(CSSName.FLOAT)) });\r\n            anonStyle = table.getStyle().deriveStyle(cascadedStyle);\r\n        } else {\r\n            anonStyle = table.getStyle().createAnonymousStyle(IdentValue.BLOCK);\r\n        }\r\n        BlockBox anonBox = new BlockBox();\r\n        anonBox.setStyle(anonStyle);\r\n        anonBox.setAnonymous(true);\r\n        anonBox.setFromCaptionedTable(true);\r\n        anonBox.setElement(table.getElement());\r\n        anonBox.setChildrenContentType(BlockBox.CONTENT_BLOCK);\r\n        anonBox.addAllChildren(topCaptions);\r\n        anonBox.addChild(table);\r\n        anonBox.addAllChildren(bottomCaptions);\r\n        if (table.getStyle().isFloated()) {\r\n            anonBox.setFloatedBoxData(new FloatedBoxData());\r\n            table.setFloatedBoxData(null);\r\n            CascadedStyle original = c.getSharedContext().getCss().getCascadedStyle(table.getElement(), false);\r\n            CascadedStyle modified = CascadedStyle.createLayoutStyle(original, new PropertyDeclaration[] { CascadedStyle.createLayoutPropertyDeclaration(CSSName.FLOAT, IdentValue.NONE) });\r\n            table.setStyle(table.getStyle().getParent().deriveStyle(modified));\r\n        }\r\n        return anonBox;\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.routing.weighting.AvoidEdgesWeighting.addEdges",
	"Comment": "this method adds the specified path to this weighting which should be penalized in thecalcweight method.",
	"Method": "void addEdges(Collection<EdgeIteratorState> edges){\r\n    for (EdgeIteratorState edge : edges) {\r\n        visitedEdges.add(edge.getEdge());\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.GeneralUtil.classNameOnly",
	"Comment": "given a string classname, returns just the classname with no package",
	"Method": "String classNameOnly(Object o,String classNameOnly,String cname){\r\n    String s = \"[null object ref]\";\r\n    if (cname != null) {\r\n        s = cname.substring(cname.lastIndexOf('.') + 1);\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Object.executeJSFunction",
	"Comment": "invoke a javascript function and return the result as a java object.",
	"Method": "Object executeJSFunction(String name,Object executeJSFunction,String name,Object parameters,Object executeJSFunction,String name,Object parameters){\r\n    if (parameters == null) {\r\n        return executeFunction(name, null);\r\n    }\r\n    V8Array parameterArray = new V8Array(v8.getRuntime());\r\n    try {\r\n        for (Object object : parameters) {\r\n            if (object == null) {\r\n                parameterArray.pushNull();\r\n            } else if (object instanceof V8Value) {\r\n                parameterArray.push((V8Value) object);\r\n            } else if (object instanceof Integer) {\r\n                parameterArray.push(object);\r\n            } else if (object instanceof Double) {\r\n                parameterArray.push(object);\r\n            } else if (object instanceof Long) {\r\n                parameterArray.push(((Long) object).doubleValue());\r\n            } else if (object instanceof Float) {\r\n                parameterArray.push(((Float) object).floatValue());\r\n            } else if (object instanceof Boolean) {\r\n                parameterArray.push(object);\r\n            } else if (object instanceof String) {\r\n                parameterArray.push((String) object);\r\n            } else {\r\n                throw new IllegalArgumentException(\"Unsupported Object of type: \" + object.getClass());\r\n            }\r\n        }\r\n        return executeFunction(name, parameterArray);\r\n    } finally {\r\n        parameterArray.close();\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.Configuration.valueFor",
	"Comment": "returns the value for key in the configuration, or the default providedvalue if not found. a warning is issued to the log if the property is notdefined, and if the default is null.",
	"Method": "String valueFor(String key,String valueFor,String key,String defaultVal){\r\n    Configuration conf = instance();\r\n    String val = conf.properties.getProperty(key);\r\n    val = (val == null ? defaultVal : val);\r\n    if (val == null) {\r\n        conf.warning(\"CONFIGURATION: no value found for key \" + key + \" and no default given.\");\r\n    }\r\n    return val;\r\n}"
}, {
	"Path": "com.graphhopper.routing.AStarTest.configs",
	"Comment": "runs the same test with each of the supported traversal modes",
	"Method": "Collection<Object[]> configs(){\r\n    return Arrays.asList(new Object[][] { { TraversalMode.NODE_BASED }, { TraversalMode.EDGE_BASED_1DIR }, { TraversalMode.EDGE_BASED_2DIR }, { TraversalMode.EDGE_BASED_2DIR_UTURN } });\r\n}"
}, {
	"Path": "org.xhtmlrenderer.render.PageBox.retrievePageMetadata",
	"Comment": "but given the existing api, this is about the only place it can be done",
	"Method": "void retrievePageMetadata(LayoutContext c){\r\n    List props = getPageInfo().getXMPPropertyList();\r\n    if (props != null && props.size() > 0) {\r\n        for (Iterator i = props.iterator(); i.hasNext(); ) {\r\n            PropertyDeclaration decl = (PropertyDeclaration) i.next();\r\n            if (decl.getCSSName() == CSSName.CONTENT) {\r\n                PropertyValue value = (PropertyValue) decl.getValue();\r\n                List values = value.getValues();\r\n                if (values.size() == 1) {\r\n                    PropertyValue funcVal = (PropertyValue) values.get(0);\r\n                    if (funcVal.getPropertyValueType() == PropertyValue.VALUE_TYPE_FUNCTION) {\r\n                        FSFunction func = funcVal.getFunction();\r\n                        if (BoxBuilder.isElementFunction(func)) {\r\n                            BlockBox metadata = BoxBuilder.getRunningBlock(c, funcVal);\r\n                            if (metadata != null) {\r\n                                _metadata = metadata.getElement();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.CommandLineOptions.assumeFilename",
	"Comment": "return the name to use for diagnostics when formatting standard input.",
	"Method": "Optional<String> assumeFilename(Builder assumeFilename,String assumeFilename){\r\n    return assumeFilename;\r\n}"
}, {
	"Path": "com.notnoop.apns.ApnsServiceBuilder.withAuthProxy",
	"Comment": "specify the proxy and the authentication parameters to be usedto establish the connections to apple servers.read the java networking and proxies guide to understand theproxies complexity.",
	"Method": "ApnsServiceBuilder withAuthProxy(Proxy proxy,String proxyUsername,String proxyPassword){\r\n    this.proxy = proxy;\r\n    this.proxyUsername = proxyUsername;\r\n    this.proxyPassword = proxyPassword;\r\n    return this;\r\n}"
}, {
	"Path": "com.graphhopper.util.Instruction.getPoints",
	"Comment": "this method returns the points associated to this instruction. please note that it will not include the last point,i.e. the first point of the next instruction object.",
	"Method": "PointList getPoints(){\r\n    return points;\r\n}"
}, {
	"Path": "com.spotify.helios.testing.HeliosSoloDeployment.containerDockerHost",
	"Comment": "returns the dockerhost that the container should use to refer to the docker daemon.",
	"Method": "DockerHost containerDockerHost(Info dockerInfo,Builder containerDockerHost,DockerHost containerDockerHost){\r\n    if (isBoot2Docker(dockerInfo)) {\r\n        return DockerHost.from(DockerHost.defaultUnixEndpoint(), null);\r\n    }\r\n    if (dockerHostAddressIsLocalhost()) {\r\n        final String endpoint = DockerHost.defaultUnixEndpoint();\r\n        log.warn(\"DOCKER_HOST points to localhost or 127.0.0.1. Replacing this with {} \" + \"as localhost/127.0.0.1 will not work inside a container to talk to the docker \" + \"daemon on the host itself.\", endpoint);\r\n        return DockerHost.from(endpoint, dockerHost.dockerCertPath());\r\n    }\r\n    return dockerHost;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.sheet.PropertyDeclaration.getCSSName",
	"Comment": "gets the cssname attribute of the propertydeclaration object",
	"Method": "CSSName getCSSName(){\r\n    return cssName;\r\n}"
}, {
	"Path": "com.graphhopper.routing.InstructionsOutgoingEdges.isLeavingCurrentStreet",
	"Comment": "if the name and prevname changes this method checks if either the current street is continued on adifferent edge or if the edge we are turning onto is continued on a different edge.if either of these properties is true, we can be quite certain that a turn instruction should be provided.",
	"Method": "boolean isLeavingCurrentStreet(String prevName,String name){\r\n    if (InstructionsHelper.isNameSimilar(name, prevName)) {\r\n        return false;\r\n    }\r\n    boolean checkFlag = currentEdge.getFlags() != prevEdge.getFlags();\r\n    for (EdgeIteratorState edge : allowedOutgoingEdges) {\r\n        String edgeName = edge.getName();\r\n        long edgeFlag = edge.getFlags();\r\n        if (isTheSameStreet(prevName, prevEdge.getFlags(), edgeName, edgeFlag, checkFlag) || isTheSameStreet(name, currentEdge.getFlags(), edgeName, edgeFlag, checkFlag)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.spotify.helios.testing.LoggingLogStreamFollower.createStreamDecoders",
	"Comment": "creates charset decoders for all available log message streams.",
	"Method": "Map<LogMessage.Stream, Decoder> createStreamDecoders(){\r\n    final Map<LogMessage.Stream, Decoder> streamDecoders = new EnumMap(LogMessage.Stream.class);\r\n    for (final LogMessage.Stream stream : LogMessage.Stream.values()) {\r\n        final CharsetDecoder charsetDecoder = Charsets.UTF_8.newDecoder().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE);\r\n        final ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\r\n        final CharBuffer charBuffer = CharBuffer.allocate(1024);\r\n        streamDecoders.put(stream, new Decoder(charsetDecoder, byteBuffer, charBuffer));\r\n    }\r\n    return streamDecoders;\r\n}"
}, {
	"Path": "com.graphhopper.GraphHopper.forMobile",
	"Comment": "configures the underlying storage to be used on a less powerful machine like android orraspberry pi with only few mb of ram.",
	"Method": "GraphHopper forMobile(){\r\n    setSimplifyResponse(false);\r\n    return setMemoryMapped();\r\n}"
}, {
	"Path": "org.tron.common.crypto.ECKey.getPrivKeyBytes",
	"Comment": "returns a 32 byte array containing the private key, or null if the key is encrypted or publiconly",
	"Method": "byte[] getPrivKeyBytes(){\r\n    if (privKey == null) {\r\n        return null;\r\n    } else if (privKey instanceof BCECPrivateKey) {\r\n        return bigIntegerToBytes(((BCECPrivateKey) privKey).getD(), 32);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.Configuration.finer",
	"Comment": "used internally to log a message about the class at level finer",
	"Method": "void finer(String msg){\r\n    if (logLevel.intValue() <= Level.FINER.intValue()) {\r\n        println(Level.FINER, msg);\r\n    }\r\n}"
}, {
	"Path": "com.google.googlejavaformat.Newlines.lineIterator",
	"Comment": "returns an iterator over lines in the input, including trailing whitespace.",
	"Method": "Iterator<String> lineIterator(String input){\r\n    return new LineIterator(input);\r\n}"
}, {
	"Path": "com.spotify.helios.master.ZooKeeperMasterModel.updateOnHostChange",
	"Comment": "determines whether we should trigger a rolling update when deployment group hosts change.we want to avoid triggering an automatic rolling update if the most recent rolling updatewas triggered manually, and failed.",
	"Method": "boolean updateOnHostChange(DeploymentGroup group,DeploymentGroupStatus status){\r\n    if (status == null) {\r\n        return true;\r\n    }\r\n    if (group.getRollingUpdateReason() == null) {\r\n        return status.getState() != FAILED;\r\n    }\r\n    if (group.getRollingUpdateReason() == HOSTS_CHANGED && status.getState() == FAILED) {\r\n        return true;\r\n    }\r\n    return status.getState() != FAILED;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Object.getKeys",
	"Comment": "returns all the keys associated with this javascript object.keys associated with the objects prototype are not returned.",
	"Method": "String[] getKeys(String[] getKeys){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    return v8.getKeys(v8.getV8RuntimePtr(), objectHandle);\r\n}"
}, {
	"Path": "com.graphhopper.storage.index.QueryResult.calcSnappedPoint",
	"Comment": "calculates the closet point on the edge from the query point.",
	"Method": "void calcSnappedPoint(DistanceCalc distCalc){\r\n    if (closestEdge == null)\r\n        throw new IllegalStateException(\"No closest edge?\");\r\n    if (snappedPoint != null)\r\n        throw new IllegalStateException(\"Calculate snapped point only once\");\r\n    PointList fullPL = getClosestEdge().fetchWayGeometry(3);\r\n    double tmpLat = fullPL.getLatitude(wayIndex);\r\n    double tmpLon = fullPL.getLongitude(wayIndex);\r\n    double tmpEle = fullPL.getElevation(wayIndex);\r\n    if (snappedPosition != Position.EDGE) {\r\n        snappedPoint = new GHPoint3D(tmpLat, tmpLon, tmpEle);\r\n        return;\r\n    }\r\n    double queryLat = getQueryPoint().lat, queryLon = getQueryPoint().lon;\r\n    double adjLat = fullPL.getLatitude(wayIndex + 1), adjLon = fullPL.getLongitude(wayIndex + 1);\r\n    if (distCalc.validEdgeDistance(queryLat, queryLon, tmpLat, tmpLon, adjLat, adjLon)) {\r\n        GHPoint tmpPoint = distCalc.calcCrossingPointToEdge(queryLat, queryLon, tmpLat, tmpLon, adjLat, adjLon);\r\n        double adjEle = fullPL.getElevation(wayIndex + 1);\r\n        snappedPoint = new GHPoint3D(tmpPoint.lat, tmpPoint.lon, (tmpEle + adjEle) / 2);\r\n    } else\r\n        snappedPoint = new GHPoint3D(tmpLat, tmpLon, tmpEle);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.FSScrollPane.setDefaultActionMap",
	"Comment": "assigns the default actions for document navigation on the view.",
	"Method": "void setDefaultActionMap(JComponent view){\r\n    view.getActionMap().put(PAGE_DOWN, new AbstractAction() {\r\n        private static final long serialVersionUID = 1L;\r\n        public void actionPerformed(ActionEvent evt) {\r\n            JScrollBar sb = getVerticalScrollBar();\r\n            sb.getModel().setValue(sb.getModel().getValue() + sb.getBlockIncrement(1));\r\n        }\r\n    });\r\n    view.getActionMap().put(PAGE_END, new AbstractAction() {\r\n        private static final long serialVersionUID = 1L;\r\n        public void actionPerformed(ActionEvent evt) {\r\n            JScrollBar sb = getVerticalScrollBar();\r\n            sb.getModel().setValue(sb.getModel().getMaximum());\r\n        }\r\n    });\r\n    view.getActionMap().put(PAGE_UP, new AbstractAction() {\r\n        private static final long serialVersionUID = 1L;\r\n        public void actionPerformed(ActionEvent evt) {\r\n            JScrollBar sb = getVerticalScrollBar();\r\n            sb.getModel().setValue(sb.getModel().getValue() - sb.getBlockIncrement(-1));\r\n        }\r\n    });\r\n    view.getActionMap().put(PAGE_START, new AbstractAction() {\r\n        private static final long serialVersionUID = 1L;\r\n        public void actionPerformed(ActionEvent evt) {\r\n            JScrollBar sb = getVerticalScrollBar();\r\n            sb.getModel().setValue(0);\r\n        }\r\n    });\r\n    view.getActionMap().put(LINE_DOWN, new AbstractAction() {\r\n        private static final long serialVersionUID = 1L;\r\n        public void actionPerformed(ActionEvent evt) {\r\n            JScrollBar sb = getVerticalScrollBar();\r\n            sb.getModel().setValue(sb.getModel().getValue() + sb.getUnitIncrement(1));\r\n        }\r\n    });\r\n    view.getActionMap().put(LINE_UP, new AbstractAction() {\r\n        private static final long serialVersionUID = 1L;\r\n        public void actionPerformed(ActionEvent evt) {\r\n            JScrollBar sb = getVerticalScrollBar();\r\n            sb.getModel().setValue(sb.getModel().getValue() - sb.getUnitIncrement(-1));\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.FSScrollPane.setDefaultActionMap",
	"Comment": "assigns the default actions for document navigation on the view.",
	"Method": "void setDefaultActionMap(JComponent view){\r\n    JScrollBar sb = getVerticalScrollBar();\r\n    sb.getModel().setValue(sb.getModel().getValue() + sb.getBlockIncrement(1));\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.FSScrollPane.setDefaultActionMap",
	"Comment": "assigns the default actions for document navigation on the view.",
	"Method": "void setDefaultActionMap(JComponent view){\r\n    JScrollBar sb = getVerticalScrollBar();\r\n    sb.getModel().setValue(sb.getModel().getMaximum());\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.FSScrollPane.setDefaultActionMap",
	"Comment": "assigns the default actions for document navigation on the view.",
	"Method": "void setDefaultActionMap(JComponent view){\r\n    JScrollBar sb = getVerticalScrollBar();\r\n    sb.getModel().setValue(sb.getModel().getValue() - sb.getBlockIncrement(-1));\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.FSScrollPane.setDefaultActionMap",
	"Comment": "assigns the default actions for document navigation on the view.",
	"Method": "void setDefaultActionMap(JComponent view){\r\n    JScrollBar sb = getVerticalScrollBar();\r\n    sb.getModel().setValue(0);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.FSScrollPane.setDefaultActionMap",
	"Comment": "assigns the default actions for document navigation on the view.",
	"Method": "void setDefaultActionMap(JComponent view){\r\n    JScrollBar sb = getVerticalScrollBar();\r\n    sb.getModel().setValue(sb.getModel().getValue() + sb.getUnitIncrement(1));\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.FSScrollPane.setDefaultActionMap",
	"Comment": "assigns the default actions for document navigation on the view.",
	"Method": "void setDefaultActionMap(JComponent view){\r\n    JScrollBar sb = getVerticalScrollBar();\r\n    sb.getModel().setValue(sb.getModel().getValue() - sb.getUnitIncrement(-1));\r\n}"
}, {
	"Path": "com.graphhopper.routing.Path.setFromNode",
	"Comment": "we need to remember fromnode explicitly as its not saved in one edgeid of edgeids.",
	"Method": "Path setFromNode(int from){\r\n    fromNode = from;\r\n    return this;\r\n}"
}, {
	"Path": "info.debatty.java.stringsimilarity.CosineTest.testSmallString",
	"Comment": "if one of the strings is smaller than k, the similarity should be 0.",
	"Method": "void testSmallString(){\r\n    System.out.println(\"test small string\");\r\n    Cosine instance = new Cosine(3);\r\n    double result = instance.similarity(\"AB\", \"ABCE\");\r\n    assertEquals(0.0, result, 0.00001);\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.AbstractFlagEncoder.defineTurnBits",
	"Comment": "defines the bits reserved for storing turn restriction and turn cost",
	"Method": "int defineTurnBits(int index,int shift){\r\n    if (maxTurnCosts == 0)\r\n        return shift;\r\n    else if (maxTurnCosts == 1) {\r\n        turnRestrictionBit = 1L << shift;\r\n        return shift + 1;\r\n    }\r\n    int turnBits = Helper.countBitValue(maxTurnCosts);\r\n    turnCostEncoder = new EncodedValue(\"TurnCost\", shift, turnBits, 1, 0, maxTurnCosts) {\r\n        @Override\r\n        public final long getValue(long flags) {\r\n            flags &= mask;\r\n            flags >>>= shift;\r\n            return flags;\r\n        }\r\n    };\r\n    return shift + turnBits;\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.AbstractFlagEncoder.defineTurnBits",
	"Comment": "defines the bits reserved for storing turn restriction and turn cost",
	"Method": "int defineTurnBits(int index,int shift){\r\n    flags &= mask;\r\n    flags >>>= shift;\r\n    return flags;\r\n}"
}, {
	"Path": "org.immutables.ordinal.ImmutableOrdinalSet.retainAll",
	"Comment": "will throw an exception and leave the collection unmodified.",
	"Method": "boolean retainAll(Collection<?> elementsToKeep){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.graphhopper.storage.change.ChangeGraphHelper.applyChanges",
	"Comment": "this method applies changes to the graph, specified by the json features.",
	"Method": "long applyChanges(EncodingManager em,Collection<JsonFeature> features){\r\n    if (em == null)\r\n        throw new NullPointerException(\"EncodingManager cannot be null to change existing graph\");\r\n    long updates = 0;\r\n    for (JsonFeature jsonFeature : features) {\r\n        if (!jsonFeature.hasProperties())\r\n            throw new IllegalArgumentException(\"One feature has no properties, please specify properties e.g. speed or access\");\r\n        List<String> encodersAsStr = (List) jsonFeature.getProperty(\"vehicles\");\r\n        if (encodersAsStr == null) {\r\n            for (FlagEncoder encoder : em.fetchEdgeEncoders()) {\r\n                updates += applyChange(jsonFeature, encoder);\r\n            }\r\n        } else {\r\n            for (String encoderStr : encodersAsStr) {\r\n                updates += applyChange(jsonFeature, em.getEncoder(encoderStr));\r\n            }\r\n        }\r\n    }\r\n    return updates;\r\n}"
}, {
	"Path": "com.spotify.helios.master.reaper.OldJobReaperTest.jobNotDeployedWithHistoryLastUsedRecentlyNotReaped",
	"Comment": "a job not deployed, with history, and last used recently should not be reaped.",
	"Method": "void jobNotDeployedWithHistoryLastUsedRecentlyNotReaped(){\r\n    final MasterModel masterModel = mock(MasterModel.class);\r\n    testReap(name.getMethodName(), emptyMap(), events(ImmutableList.of(HOURS.toMillis(20), HOURS.toMillis(40))), null, masterModel, false);\r\n}"
}, {
	"Path": "com.spotify.helios.testing.HostPickingStrategies.deterministicOneHost",
	"Comment": "deterministically, choose a single host for all jobs in the test.that is, it willchoose the same host given equal values of key.if you want multiple test classes touse the same host, share the strategy between tests as a constant.",
	"Method": "HostPickingStrategy deterministicOneHost(String key){\r\n    return new RandomOneHostPickingStrategy(getSeededRandom(key));\r\n}"
}, {
	"Path": "com.eclipsesource.v8.NodeJS.handleMessage",
	"Comment": "handles the next message in the message loop. returns trueif there are more messages to handle, false otherwise.",
	"Method": "boolean handleMessage(){\r\n    v8.checkThread();\r\n    return v8.pumpMessageLoop();\r\n}"
}, {
	"Path": "org.kie.dmn.model.v1_2.KieDMNModelInstrumentedBase.getLocation",
	"Comment": "returns an approximated location of the xml origin for this dmn model node.",
	"Method": "Location getLocation(){\r\n    return location;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8ScriptException.getFileName",
	"Comment": "get the file name contains the script that was currently executing.",
	"Method": "String getFileName(){\r\n    return fileName;\r\n}"
}, {
	"Path": "com.graphhopper.GraphHopper.setMemoryMapped",
	"Comment": "enable memory mapped configuration if not enough memory is available on the target platform.",
	"Method": "GraphHopper setMemoryMapped(){\r\n    ensureNotLoaded();\r\n    dataAccessType = DAType.MMAP;\r\n    return this;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.HTMLTest.addFileLoadAction",
	"Comment": "adds a feature to the fileloadaction attribute of the htmltest object",
	"Method": "void addFileLoadAction(JMenu menu,String display,String file){\r\n    menu.add(new AbstractAction(display) {\r\n        private static final long serialVersionUID = 1L;\r\n        public void actionPerformed(ActionEvent evt) {\r\n            loadDocument(file);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.HTMLTest.addFileLoadAction",
	"Comment": "adds a feature to the fileloadaction attribute of the htmltest object",
	"Method": "void addFileLoadAction(JMenu menu,String display,String file){\r\n    loadDocument(file);\r\n}"
}, {
	"Path": "com.graphhopper.reader.osm.OSMReader.createTurnRelation",
	"Comment": "creates an osm turn relation out of an unspecified osm relation",
	"Method": "OSMTurnRelation createTurnRelation(ReaderRelation relation){\r\n    OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(relation.getTag(\"restriction\"));\r\n    if (type != OSMTurnRelation.Type.UNSUPPORTED) {\r\n        long fromWayID = -1;\r\n        long viaNodeID = -1;\r\n        long toWayID = -1;\r\n        for (ReaderRelation.Member member : relation.getMembers()) {\r\n            if (ReaderElement.WAY == member.getType()) {\r\n                if (\"from\".equals(member.getRole())) {\r\n                    fromWayID = member.getRef();\r\n                } else if (\"to\".equals(member.getRole())) {\r\n                    toWayID = member.getRef();\r\n                }\r\n            } else if (ReaderElement.NODE == member.getType() && \"via\".equals(member.getRole())) {\r\n                viaNodeID = member.getRef();\r\n            }\r\n        }\r\n        if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0) {\r\n            return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.createV8Runtime",
	"Comment": "creates a new v8runtime and loads the requirednative libraries if they are not already loaded.the current thread is given the lock to this runtime.",
	"Method": "V8 createV8Runtime(V8 createV8Runtime,String globalAlias,V8 createV8Runtime,String globalAlias,String tempDirectory){\r\n    if (!nativeLibraryLoaded) {\r\n        synchronized (lock) {\r\n            if (!nativeLibraryLoaded) {\r\n                load(tempDirectory);\r\n            }\r\n        }\r\n    }\r\n    checkNativeLibraryLoaded();\r\n    if (!initialized) {\r\n        _setFlags(v8Flags);\r\n        initialized = true;\r\n    }\r\n    V8 runtime = new V8(globalAlias);\r\n    synchronized (lock) {\r\n        runtimeCounter++;\r\n    }\r\n    return runtime;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.style.DerivedValue.isDeclaredInherit",
	"Comment": "if value is declared inherit should always be the identvalue.inherit,not a derivedvalue",
	"Method": "boolean isDeclaredInherit(){\r\n    return false;\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.DataFlagEncoder.getHighwayAsString",
	"Comment": "do not use within weighting as this is suboptimal from performance point of view.",
	"Method": "String getHighwayAsString(EdgeIteratorState edge){\r\n    int val = getHighway(edge);\r\n    for (Entry<String, Integer> e : highwayMap.entrySet()) {\r\n        if (e.getValue() == val)\r\n            return e.getKey();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.AbstractFlagEncoder.defineNodeBits",
	"Comment": "defines the bits for the node flags, which are currently used for barriers only.",
	"Method": "int defineNodeBits(int index,int shift){\r\n    return shift;\r\n}"
}, {
	"Path": "info.debatty.java.stringsimilarity.LongestCommonSubsequenceTest.testDistance",
	"Comment": "test of distance method, of class longestcommonsubsequence.",
	"Method": "void testDistance(){\r\n    System.out.println(\"distance\");\r\n    LongestCommonSubsequence instance = new LongestCommonSubsequence();\r\n    assertEquals(4, instance.distance(\"AGCAT\", \"GAC\"), 0.0);\r\n    assertEquals(1, instance.distance(\"AGCAT\", \"AGCT\"), 0.0);\r\n    NullEmptyTests.testDistance(instance);\r\n}"
}, {
	"Path": "com.graphhopper.GraphHopper.createTurnWeighting",
	"Comment": "potentially wraps the specified weighting into a turnweighting instance.",
	"Method": "Weighting createTurnWeighting(Graph graph,Weighting weighting,TraversalMode tMode){\r\n    FlagEncoder encoder = weighting.getFlagEncoder();\r\n    if (encoder.supports(TurnWeighting.class) && !tMode.equals(TraversalMode.NODE_BASED))\r\n        return new TurnWeighting(weighting, (TurnCostExtension) graph.getExtension());\r\n    return weighting;\r\n}"
}, {
	"Path": "com.spotify.helios.master.DeploymentGroupTest.testUpdateFailedHostsChangedDeploymentGroupHosts",
	"Comment": "changing hosts will perform a new rolling update if the hosts change again.",
	"Method": "void testUpdateFailedHostsChangedDeploymentGroupHosts(){\r\n    final ZooKeeperClient client = spy(this.client);\r\n    final ZooKeeperMasterModel masterModel = spy(newMasterModel(client));\r\n    final Job job = Job.newBuilder().setCommand(ImmutableList.of(\"COMMAND\")).setImage(\"IMAGE\").setName(\"JOB_NAME\").setVersion(\"VERSION\").build();\r\n    doReturn(job).when(masterModel).getJob(job.getId());\r\n    final DeploymentGroup dg = DeploymentGroup.newBuilder().setName(GROUP_NAME).setHostSelectors(ImmutableList.of(HostSelector.parse(\"role=melmac\"))).setJobId(job.getId()).setRolloutOptions(RolloutOptions.getDefault()).setRollingUpdateReason(HOSTS_CHANGED).build();\r\n    masterModel.addDeploymentGroup(dg);\r\n    client.setData(Paths.statusDeploymentGroupHosts(dg.getName()), Json.asBytes(ImmutableList.of(\"host1\")));\r\n    client.setData(Paths.statusDeploymentGroup(dg.getName()), DeploymentGroupStatus.newBuilder().setState(FAILED).build().toJsonBytes());\r\n    final HostStatus statusUp = mock(HostStatus.class);\r\n    doReturn(HostStatus.Status.UP).when(statusUp).getStatus();\r\n    doReturn(statusUp).when(masterModel).getHostStatus(\"host2\");\r\n    masterModel.updateDeploymentGroupHosts(dg.getName(), ImmutableList.of(\"host2\"));\r\n    final ZooKeeperOperation setDeploymentGroup = set(Paths.configDeploymentGroup(dg.getName()), dg);\r\n    verify(client, times(2)).transaction(opCaptor.capture());\r\n    assertThat(opCaptor.getValue(), hasItem(setDeploymentGroup));\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.createOpenProfileButtonAnimation",
	"Comment": "this method, if needed, creates and setups animation of scaling button from 0 to 1.",
	"Method": "void createOpenProfileButtonAnimation(){\r\n    if (mProfileButtonShowAnimation == null) {\r\n        mProfileButtonShowAnimation = AnimationUtils.loadAnimation(this, R.anim.profile_button_scale);\r\n        mProfileButtonShowAnimation.setDuration(getAnimationDurationShowProfileButton());\r\n        mProfileButtonShowAnimation.setInterpolator(new AccelerateInterpolator());\r\n        mProfileButtonShowAnimation.setAnimationListener(new Animation.AnimationListener() {\r\n            @Override\r\n            public void onAnimationStart(Animation animation) {\r\n                mButtonProfile.setVisibility(View.VISIBLE);\r\n            }\r\n            @Override\r\n            public void onAnimationEnd(Animation animation) {\r\n            }\r\n            @Override\r\n            public void onAnimationRepeat(Animation animation) {\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.createOpenProfileButtonAnimation",
	"Comment": "this method, if needed, creates and setups animation of scaling button from 0 to 1.",
	"Method": "void createOpenProfileButtonAnimation(){\r\n    mButtonProfile.setVisibility(View.VISIBLE);\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.createOpenProfileButtonAnimation",
	"Comment": "this method, if needed, creates and setups animation of scaling button from 0 to 1.",
	"Method": "void createOpenProfileButtonAnimation(){\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.createOpenProfileButtonAnimation",
	"Comment": "this method, if needed, creates and setups animation of scaling button from 0 to 1.",
	"Method": "void createOpenProfileButtonAnimation(){\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeInjectActuatorTest.SameTokenNameCloseTokenQuantLessThanZero",
	"Comment": "sametokenname close, injected token quant must greater than zero",
	"Method": "void SameTokenNameCloseTokenQuantLessThanZero(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(0);\r\n    InitExchangeBeforeSameTokenNameActive();\r\n    long exchangeId = 1;\r\n    String firstTokenId = \"abc\";\r\n    long firstTokenQuant = -1L;\r\n    String secondTokenId = \"def\";\r\n    long secondTokenQuant = 400000000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmount(firstTokenId.getBytes(), 1000L);\r\n    accountCapsule.addAssetAmount(secondTokenId.getBytes(), secondTokenQuant);\r\n    accountCapsule.setBalance(10000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeInjectActuator actuator = new ExchangeInjectActuator(getContract(OWNER_ADDRESS_FIRST, exchangeId, firstTokenId, firstTokenQuant), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"injected token quant must greater than zero\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.LinkListener.linkClicked",
	"Comment": "utility method to request the panel navigate to the given uri.",
	"Method": "void linkClicked(BasicPanel panel,String uri){\r\n    panel.setDocumentRelative(uri);\r\n}"
}, {
	"Path": "com.spotify.helios.agent.SupervisorTest.verifySupervisorHandlesUndeployingOfNotRunningContainerWithGracePeriod",
	"Comment": "verifies a fix for a npe that is thrown when the supervisor receives a goal of undeploy for ajob with graceperiod that has never been started.",
	"Method": "void verifySupervisorHandlesUndeployingOfNotRunningContainerWithGracePeriod(){\r\n    final int gracePeriod = 5;\r\n    final Job job = JOB.toBuilder().setGracePeriod(gracePeriod).build();\r\n    final Supervisor sut = createSupervisor(job);\r\n    sut.setGoal(Goal.UNDEPLOY);\r\n    verify(model, timeout(30000)).setTaskStatus(eq(job.getId()), argThat(is(taskStatusWithState(TaskStatus.State.STOPPING))));\r\n    verify(model, timeout(30000)).setTaskStatus(eq(job.getId()), argThat(is(taskStatusWithState(TaskStatus.State.STOPPED))));\r\n    verify(sleeper, never()).sleep(gracePeriod * 1000);\r\n}"
}, {
	"Path": "com.notnoop.apns.ApnsServiceBuilder.withReadTimeout",
	"Comment": "specify the timeout value to be set in new setsotimeout in createdsockets, for both feedback and push connections, in milliseconds.",
	"Method": "ApnsServiceBuilder withReadTimeout(int readTimeout){\r\n    this.readTimeout = readTimeout;\r\n    return this;\r\n}"
}, {
	"Path": "com.graphhopper.reader.osm.OSMReader.writeOsm2Graph",
	"Comment": "creates the graph with edges and nodes from the specified osm file.",
	"Method": "void writeOsm2Graph(File osmFile){\r\n    int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);\r\n    LOGGER.info(\"creating graph. Found nodes (pillar+tower):\" + nf(getNodeMap().getSize()) + \", \" + Helper.getMemInfo());\r\n    if (createStorage)\r\n        ghStorage.create(tmp);\r\n    long wayStart = -1;\r\n    long relationStart = -1;\r\n    long counter = 1;\r\n    try (OSMInput in = openOsmInputFile(osmFile)) {\r\n        LongIntMap nodeFilter = getNodeMap();\r\n        ReaderElement item;\r\n        while ((item = in.getNext()) != null) {\r\n            switch(item.getType()) {\r\n                case ReaderElement.NODE:\r\n                    if (nodeFilter.get(item.getId()) != EMPTY_NODE) {\r\n                        processNode((ReaderNode) item);\r\n                    }\r\n                    break;\r\n                case ReaderElement.WAY:\r\n                    if (wayStart < 0) {\r\n                        LOGGER.info(nf(counter) + \", now parsing ways\");\r\n                        wayStart = counter;\r\n                    }\r\n                    processWay((ReaderWay) item);\r\n                    break;\r\n                case ReaderElement.RELATION:\r\n                    if (relationStart < 0) {\r\n                        LOGGER.info(nf(counter) + \", now parsing relations\");\r\n                        relationStart = counter;\r\n                    }\r\n                    processRelation((ReaderRelation) item);\r\n                    break;\r\n                case ReaderElement.FILEHEADER:\r\n                    break;\r\n                default:\r\n                    throw new IllegalStateException(\"Unknown type \" + item.getType());\r\n            }\r\n            if (++counter % 200_000_000 == 0) {\r\n                LOGGER.info(nf(counter) + \", locs:\" + nf(locations) + \" (\" + skippedLocations + \") \" + Helper.getMemInfo());\r\n            }\r\n        }\r\n        if (in.getUnprocessedElements() > 0)\r\n            throw new IllegalStateException(\"Still unprocessed elements in reader queue \" + in.getUnprocessedElements());\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(\"Couldn't process file \" + osmFile + \", error: \" + ex.getMessage(), ex);\r\n    }\r\n    finishedReading();\r\n    if (graph.getNodes() == 0)\r\n        throw new RuntimeException(\"Graph after reading OSM must not be empty. Read \" + counter + \" items and \" + locations + \" locations\");\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.BasicPanel.setOpaque",
	"Comment": "specifies whether the background of this basicpanel willbe painted when it is rendered.",
	"Method": "void setOpaque(boolean opaque){\r\n    checkOpacityMethodClient();\r\n    explicitlyOpaque = opaque;\r\n}"
}, {
	"Path": "com.graphhopper.routing.ch.CHAlgoFactoryDecorator.setDisablingAllowed",
	"Comment": "this method specifies if it is allowed to disable ch routing at runtime via routing hints.",
	"Method": "CHAlgoFactoryDecorator setDisablingAllowed(boolean disablingAllowed){\r\n    this.disablingAllowed = disablingAllowed;\r\n    return this;\r\n}"
}, {
	"Path": "com.spotify.helios.master.reaper.OldJobReaperTest.jobNotDeployedWithoutHistoryCreateAfterRetentionNotReaped",
	"Comment": "a job not deployed, without history, created after retention time should not be reaped.",
	"Method": "void jobNotDeployedWithoutHistoryCreateAfterRetentionNotReaped(){\r\n    final MasterModel masterModel = mock(MasterModel.class);\r\n    testReap(name.getMethodName(), emptyMap(), emptyList(), HOURS.toMillis(25), masterModel, false);\r\n}"
}, {
	"Path": "org.tron.common.crypto.ECKey.getPubKeyPoint",
	"Comment": "gets the public key in the form of an elliptic curve point object from bouncy castle.",
	"Method": "ECPoint getPubKeyPoint(){\r\n    return pub;\r\n}"
}, {
	"Path": "com.notnoop.apns.utils.ApnsServerStub.prepareAndStartServer",
	"Comment": "create an apnsserverstub that uses any free port for gateway and feedback.",
	"Method": "ApnsServerStub prepareAndStartServer(int gatePort,int feedPort,ApnsServerStub prepareAndStartServer){\r\n    ApnsServerStub server = new ApnsServerStub(FixedCertificates.serverContext().getServerSocketFactory());\r\n    server.start();\r\n    return server;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Array.getIntegers",
	"Comment": "gets the integers contained in a subset of a v8array. if the subsetcontains elements other than integers, then a v8resultundefined exceptionis thrown. furthermore, if the subset is not entirely contained within the array,then v8resultundefined exception is also thrown. finally, if the resultarrayis not large enough to hold the results then indexoutofboundsexception is thrown.",
	"Method": "int[] getIntegers(int index,int length,int getIntegers,int index,int length,int[] resultArray,int[] getIntegers,int index,int length,int getIntegers,int index,int length,int[] resultArray){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    if (length > resultArray.length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    return v8.arrayGetIntegers(v8.getV8RuntimePtr(), getHandle(), index, length, resultArray);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8TypedArray.getBuffer",
	"Comment": "provide access to the underlying bytebuffer used for this typedarray.the v8arraybuffer must be released.",
	"Method": "V8ArrayBuffer getBuffer(){\r\n    return (V8ArrayBuffer) get(\"buffer\");\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.JavaInputAstVisitor.fieldAnnotationDirection",
	"Comment": "should a field with a set of modifiers be declared with horizontal annotations? this iscurrently true if all annotations are marker annotations.",
	"Method": "Direction fieldAnnotationDirection(ModifiersTree modifiers){\r\n    for (AnnotationTree annotation : modifiers.getAnnotations()) {\r\n        if (!annotation.getArguments().isEmpty()) {\r\n            return Direction.VERTICAL;\r\n        }\r\n    }\r\n    return Direction.HORIZONTAL;\r\n}"
}, {
	"Path": "com.graphhopper.routing.ch.CHAlgoFactoryDecorator.setPreparationThreads",
	"Comment": "this method changes the number of threads used for preparation on import. default is 1. makesure that you have enough memory when increasing this number!",
	"Method": "void setPreparationThreads(int preparationThreads){\r\n    this.preparationThreads = preparationThreads;\r\n    this.threadPool = java.util.concurrent.Executors.newFixedThreadPool(preparationThreads);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.debug.mirror.FunctionMirror.getScriptName",
	"Comment": "returns the name of the script associated withthis functionmirror.",
	"Method": "String getScriptName(){\r\n    V8Object script = v8Object.executeObjectFunction(SCRIPT, null);\r\n    try {\r\n        return script.executeStringFunction(NAME, null);\r\n    } finally {\r\n        script.close();\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.FSImageWriter.newJpegWriter",
	"Comment": "convenience method for initializing a writer for the jpeg image format.",
	"Method": "FSImageWriter newJpegWriter(float quality){\r\n    FSImageWriter writer = new FSImageWriter(\"jpg\");\r\n    writer.setWriteCompressionMode(ImageWriteParam.MODE_EXPLICIT);\r\n    writer.setWriteCompressionType(\"JPEG\");\r\n    writer.setWriteCompressionQuality(quality);\r\n    return writer;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.executeIntegerScript",
	"Comment": "executes a js script on this runtime and returns the result as an integer.if the result is not an integer, then a v8resultundefinedexception is thrown.",
	"Method": "int executeIntegerScript(String script,int executeIntegerScript,String script,String scriptName,int lineNumber,int executeIntegerScript,long v8RuntimePtr,String script,String scriptName,int lineNumber){\r\n    return _executeIntegerScript(v8RuntimePtr, script, scriptName, lineNumber);\r\n}"
}, {
	"Path": "com.spotify.helios.common.descriptors.JobId.fromString",
	"Comment": "parse a job id string.this parsing method can be used when input is trusted, i.e. failing to parse it indicatesprogramming error and not bad input.",
	"Method": "JobId fromString(String id){\r\n    try {\r\n        return parse(id);\r\n    } catch (JobIdParseException e) {\r\n        throw new IllegalArgumentException(e);\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.test.SwingImageReplacer.lookupImageReplacedElement",
	"Comment": "retrieves a replacedelement for an image from cache, or null if not found.",
	"Method": "ReplacedElement lookupImageReplacedElement(Element e){\r\n    if (imageComponents.size() == 0) {\r\n        return null;\r\n    }\r\n    ReplacedElement replacedElement = (ReplacedElement) imageComponents.get(e);\r\n    return replacedElement;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.utils.V8Executor.shutdown",
	"Comment": "indicates to the executor that it should shutdown. any currentlyexecuting javascript will be allowed to finish, and any outstandingmessages will be processed. only once the message queue is empty,will the executor actually shtutdown.",
	"Method": "void shutdown(){\r\n    synchronized (this) {\r\n        shuttingDown = true;\r\n        notify();\r\n    }\r\n}"
}, {
	"Path": "org.kie.pmml.pmml_4_2.model.AbstractModel.generateModelId",
	"Comment": "a method that tries to generate a model identifierfor those times when models arrive without an identifier",
	"Method": "String generateModelId(){\r\n    String mt = this.modelType.toString();\r\n    StringBuilder mid = new StringBuilder(mt);\r\n    Integer lastId = null;\r\n    if (generatedModelIds.containsKey(mt)) {\r\n        lastId = generatedModelIds.get(mt);\r\n    } else {\r\n        lastId = new Integer(-1);\r\n    }\r\n    lastId++;\r\n    mid.append(lastId);\r\n    generatedModelIds.put(mt, lastId);\r\n    return mid.toString();\r\n}"
}, {
	"Path": "com.graphhopper.GHRequest.setWeighting",
	"Comment": "by default it supports fastest and shortest. or specify empty to use default.",
	"Method": "GHRequest setWeighting(String w){\r\n    hints.setWeighting(w);\r\n    return this;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.Configuration.fine",
	"Comment": "used internally to log a message about the class at level fine",
	"Method": "void fine(String msg){\r\n    if (logLevel.intValue() <= Level.FINE.intValue()) {\r\n        println(Level.FINE, msg);\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.Configuration.valueAsFloat",
	"Comment": "returns the value for key in the configuration as a float, or the defaultprovided value if not found or if the value is not a valid float. awarning is issued to the log if the property is not defined, or if theconversion from string fails.",
	"Method": "float valueAsFloat(String key,float defaultVal){\r\n    String val = valueFor(key);\r\n    if (val == null) {\r\n        return defaultVal;\r\n    }\r\n    float fval;\r\n    try {\r\n        fval = Float.valueOf(val).floatValue();\r\n    } catch (NumberFormatException nex) {\r\n        XRLog.exception(\"Property '\" + key + \"' was requested as a float, but \" + \"value of '\" + val + \"' is not a float. Check configuration.\");\r\n        fval = defaultVal;\r\n    }\r\n    return fval;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swt.BasicRenderer.setDocumentRelative",
	"Comment": "sets the new current document, where the new document is locatedrelative, e.g using a relative url.",
	"Method": "void setDocumentRelative(String filename){\r\n    String url = _sharedContext.getUac().resolveURI(filename);\r\n    if (isAnchorInCurrentDocument(filename)) {\r\n        String id = getAnchorId(filename);\r\n        Box box = _sharedContext.getBoxById(id);\r\n        if (box != null) {\r\n            Point pt;\r\n            if (box.getStyle().isInline()) {\r\n                pt = new Point(0, box.getAbsY());\r\n            } else {\r\n                RectPropertySet margin = box.getMargin(_layout_context);\r\n                pt = new Point(0, box.getAbsY() + (int) margin.top());\r\n            }\r\n            setOrigin(pt);\r\n            return;\r\n        }\r\n    }\r\n    Document dom = loadDocument(url);\r\n    setDocument(dom, url);\r\n}"
}, {
	"Path": "com.graphhopper.routing.Path.calcDetails",
	"Comment": "calculates the pathdetails for this path. this method will return fast, if there are no calculators.",
	"Method": "Map<String, List<PathDetail>> calcDetails(List<String> requestedPathDetails,PathDetailsBuilderFactory pathBuilderFactory,int previousIndex){\r\n    if (!isFound() || requestedPathDetails.isEmpty())\r\n        return Collections.EMPTY_MAP;\r\n    List<PathDetailsBuilder> pathBuilders = pathBuilderFactory.createPathDetailsBuilders(requestedPathDetails, encoder, weighting);\r\n    if (pathBuilders.isEmpty())\r\n        return Collections.EMPTY_MAP;\r\n    forEveryEdge(new PathDetailsFromEdges(pathBuilders, previousIndex));\r\n    Map<String, List<PathDetail>> pathDetails = new HashMap(pathBuilders.size());\r\n    for (PathDetailsBuilder builder : pathBuilders) {\r\n        Map.Entry<String, List<PathDetail>> entry = builder.build();\r\n        List<PathDetail> existing = pathDetails.put(entry.getKey(), entry.getValue());\r\n        if (existing != null)\r\n            throw new IllegalStateException(\"Some PathDetailsBuilders use duplicate key: \" + entry.getKey());\r\n    }\r\n    return pathDetails;\r\n}"
}, {
	"Path": "org.kie.pmml.pmml_4_2.model.PMML4UnitImpl.getMiningFieldsForModel",
	"Comment": "retrieves a list of the raw miningfield objects for agiven model",
	"Method": "List<MiningField> getMiningFieldsForModel(String modelId){\r\n    PMML4Model model = modelsMap.get(modelId);\r\n    if (model != null) {\r\n        return model.getRawMiningFields();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.animateOpenProfileDetails",
	"Comment": "this method starts set of transition animations, which show profile toolbar and profiledetails views, right after the passed delay.",
	"Method": "void animateOpenProfileDetails(int profileDetailsAnimationDelay){\r\n    createOpenProfileButtonAnimation();\r\n    getOpenProfileAnimatorSet(profileDetailsAnimationDelay).start();\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.removeReferenceHandler",
	"Comment": "removes an existing referencehandler from the collection of reference handlers.if the referencehandler does not exist in the collection, it is ignored.",
	"Method": "void removeReferenceHandler(ReferenceHandler handler){\r\n    referenceHandlers.remove(handler);\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeInjectActuatorTest.SameTokenNameCloseSuccessExchangeInject",
	"Comment": "sametokenname close, first inject exchange,result is success.",
	"Method": "void SameTokenNameCloseSuccessExchangeInject(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(0);\r\n    InitExchangeBeforeSameTokenNameActive();\r\n    long exchangeId = 1;\r\n    String firstTokenId = \"abc\";\r\n    long firstTokenQuant = 200000000L;\r\n    String secondTokenId = \"def\";\r\n    long secondTokenQuant = 400000000L;\r\n    AssetIssueCapsule assetIssueCapsule1 = new AssetIssueCapsule(AssetIssueContract.newBuilder().setName(ByteString.copyFrom(firstTokenId.getBytes())).build());\r\n    assetIssueCapsule1.setId(String.valueOf(1L));\r\n    dbManager.getAssetIssueStore().put(assetIssueCapsule1.getName().toByteArray(), assetIssueCapsule1);\r\n    AssetIssueCapsule assetIssueCapsule2 = new AssetIssueCapsule(AssetIssueContract.newBuilder().setName(ByteString.copyFrom(secondTokenId.getBytes())).build());\r\n    assetIssueCapsule2.setId(String.valueOf(2L));\r\n    dbManager.getAssetIssueStore().put(assetIssueCapsule2.getName().toByteArray(), assetIssueCapsule2);\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmount(firstTokenId.getBytes(), firstTokenQuant);\r\n    accountCapsule.addAssetAmount(secondTokenId.getBytes(), secondTokenQuant);\r\n    accountCapsule.setBalance(10000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeInjectActuator actuator = new ExchangeInjectActuator(getContract(OWNER_ADDRESS_FIRST, exchangeId, firstTokenId, firstTokenQuant), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        Assert.assertEquals(ret.getInstance().getRet(), code.SUCESS);\r\n        long id = 1;\r\n        ExchangeCapsule exchangeCapsule = dbManager.getExchangeStore().get(ByteArray.fromLong(id));\r\n        Assert.assertNotNull(exchangeCapsule);\r\n        Assert.assertEquals(ByteString.copyFrom(ownerAddress), exchangeCapsule.getCreatorAddress());\r\n        Assert.assertEquals(id, exchangeCapsule.getID());\r\n        Assert.assertEquals(1000000, exchangeCapsule.getCreateTime());\r\n        Assert.assertTrue(Arrays.equals(firstTokenId.getBytes(), exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenId, ByteArray.toStr(exchangeCapsule.getFirstTokenId()));\r\n        Assert.assertEquals(300000000L, exchangeCapsule.getFirstTokenBalance());\r\n        Assert.assertEquals(secondTokenId, ByteArray.toStr(exchangeCapsule.getSecondTokenId()));\r\n        Assert.assertEquals(600000000L, exchangeCapsule.getSecondTokenBalance());\r\n        Assert.assertEquals(secondTokenQuant, ret.getExchangeInjectAnotherAmount());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        Map<String, Long> assetMap = accountCapsule.getAssetMap();\r\n        Assert.assertEquals(10000_000000L, accountCapsule.getBalance());\r\n        Assert.assertEquals(0L, assetMap.get(firstTokenId).longValue());\r\n        Assert.assertEquals(0L, assetMap.get(secondTokenId).longValue());\r\n    } catch (ContractValidateException e) {\r\n        logger.info(e.getMessage());\r\n        Assert.assertFalse(e instanceof ContractValidateException);\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    } catch (ItemNotFoundException e) {\r\n        Assert.assertFalse(e instanceof ItemNotFoundException);\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Value.release",
	"Comment": "releases the native resources associated with this v8value.",
	"Method": "void release(){\r\n    close();\r\n}"
}, {
	"Path": "org.kie.dmn.model.v1_1.KieDMNModelInstrumentedBase.getChildren",
	"Comment": "children element references are populated during deserialization, enabling fast access for validation.",
	"Method": "java.util.List<DMNModelInstrumentedBase> getChildren(){\r\n    return Collections.unmodifiableList(children);\r\n}"
}, {
	"Path": "com.graphhopper.reader.osm.pbf.PbfBlobResult.getEntities",
	"Comment": "gets the entities decoded from the blob. this is only valid after complete becomes true, andif success is true.",
	"Method": "List<ReaderElement> getEntities(){\r\n    return entities;\r\n}"
}, {
	"Path": "com.graphhopper.reader.osm.OSMTurnRelation.getRestrictionAsEntries",
	"Comment": "transforms this relation into a collection of turn cost entries",
	"Method": "Collection<TurnCostTableEntry> getRestrictionAsEntries(TurnCostEncoder encoder,EdgeExplorer edgeOutExplorer,EdgeExplorer edgeInExplorer,OSMReader osmReader){\r\n    int nodeVia = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);\r\n    try {\r\n        if (nodeVia == OSMReader.EMPTY_NODE)\r\n            return Collections.emptyList();\r\n        int edgeIdFrom = EdgeIterator.NO_EDGE;\r\n        EdgeIterator iter = edgeInExplorer.setBaseNode(nodeVia);\r\n        while (iter.next()) {\r\n            if (osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsmWayId) {\r\n                edgeIdFrom = iter.getEdge();\r\n                break;\r\n            }\r\n        }\r\n        if (edgeIdFrom == EdgeIterator.NO_EDGE)\r\n            return Collections.emptyList();\r\n        final Collection<TurnCostTableEntry> entries = new ArrayList();\r\n        iter = edgeOutExplorer.setBaseNode(nodeVia);\r\n        while (iter.next()) {\r\n            int edgeId = iter.getEdge();\r\n            long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);\r\n            if (edgeId != edgeIdFrom && this.restriction == Type.ONLY && wayId != this.toOsmWayId || this.restriction == Type.NOT && wayId == this.toOsmWayId && wayId >= 0) {\r\n                final TurnCostTableEntry entry = new TurnCostTableEntry();\r\n                entry.nodeVia = nodeVia;\r\n                entry.edgeFrom = edgeIdFrom;\r\n                entry.edgeTo = iter.getEdge();\r\n                entry.flags = encoder.getTurnFlags(true, 0);\r\n                entries.add(entry);\r\n                if (this.restriction == Type.NOT)\r\n                    break;\r\n            }\r\n        }\r\n        return entries;\r\n    } catch (Exception e) {\r\n        throw new IllegalStateException(\"Could not built turn table entry for relation of node with osmId:\" + this.viaOsmNodeId, e);\r\n    }\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeCreateActuatorTest.sameTokenNameOpenExchangeCreateFailure",
	"Comment": "sametokenname open,first createexchange,result is failure.",
	"Method": "void sameTokenNameOpenExchangeCreateFailure(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    String firstTokenId = \"abc\";\r\n    long firstTokenBalance = 100000000L;\r\n    String secondTokenId = \"def\";\r\n    long secondTokenBalance = 100000000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.setBalance(10000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeCreateActuator actuator = new ExchangeCreateActuator(getContract(OWNER_ADDRESS_FIRST, firstTokenId, firstTokenBalance, secondTokenId, secondTokenBalance), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    Assert.assertEquals(dbManager.getDynamicPropertiesStore().getLatestExchangeNum(), 0);\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"first token id is not a valid number\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "com.spotify.helios.testing.HostPickingStrategies.randomOneHost",
	"Comment": "pick a single host and use that for all jobs to be deployed in the tests used by thisstrategy.if you want multiple test classes to use the same host, share the strategybetween tests as a constant.",
	"Method": "HostPickingStrategy randomOneHost(){\r\n    return new RandomOneHostPickingStrategy(new Random());\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.Configuration.valueAsLong",
	"Comment": "returns the value for key in the configurationas a long, or the defaultprovided value if not found or if the value is not a valid long. awarning is issued to the log if the property is not defined, or if theconversion from string fails.",
	"Method": "long valueAsLong(String key,long defaultVal){\r\n    String val = valueFor(key);\r\n    if (val == null) {\r\n        return defaultVal;\r\n    }\r\n    long lval;\r\n    try {\r\n        lval = Long.valueOf(val).longValue();\r\n    } catch (NumberFormatException nex) {\r\n        XRLog.exception(\"Property '\" + key + \"' was requested as a long, but \" + \"value of '\" + val + \"' is not a long. Check configuration.\");\r\n        lval = defaultVal;\r\n    }\r\n    return lval;\r\n}"
}, {
	"Path": "org.immutables.check.ObjectChecker.allOf",
	"Comment": "evaluates to true only if all of the passed in matchers evaluate to true.",
	"Method": "void allOf(Matcher<? super T> matchers){\r\n    verifyUsingMatcher(CoreMatchers.allOf(matchers));\r\n}"
}, {
	"Path": "com.graphhopper.routing.AlternativeRoute.setApproximation",
	"Comment": "this method sets the approximation used for the internal bidirectional a",
	"Method": "void setApproximation(WeightApproximator weightApproximator){\r\n    this.weightApproximator = weightApproximator;\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.DataFlagEncoder.createWeightingConfig",
	"Comment": "this method creates a config map out of the pmap. later on this conversion should not benecessary when we read json.",
	"Method": "WeightingConfig createWeightingConfig(PMap pMap){\r\n    HashMap<String, Double> map = new HashMap(DEFAULT_SPEEDS.size());\r\n    for (Entry<String, Double> e : DEFAULT_SPEEDS.entrySet()) {\r\n        map.put(e.getKey(), pMap.getDouble(e.getKey(), e.getValue()));\r\n    }\r\n    return new WeightingConfig(getHighwaySpeedMap(map));\r\n}"
}, {
	"Path": "org.immutables.fixture.builder.AttributeBuilderTest.assertBasicApi",
	"Comment": "allows sharing tests between guava collections, jdk only collections and whatever other combinations are needed.",
	"Method": "void assertBasicApi(Class<ImmutableClassT> immutableType,Class<AbstractClassT> returnType,CopyFunction<ImmutableClassT, AbstractClassT> copyFunction,BuilderFunction<AbstractClassT> newBuilder){\r\n    FirstPartyImmutable firstPartyImmutable = ImmutableFirstPartyImmutable.builder().value(\"first party\").build();\r\n    FirstPartyImmutableWithDifferentStyle firstPartyImmutableWithDifferentStyle = ImmutableFirstPartyImmutableWithDifferentStyle.getTheBuilder().value(\"first party\").doIIT();\r\n    ThirdPartyImmutable thirdPartyImmutable = ThirdPartyImmutable.generateNewBuilder().setValue(\"third party\").doTheBuild();\r\n    ThirdPartyImmutableWithPrimitive thirdPartyImmutableWithPrimitive = ThirdPartyImmutableWithPrimitive.generateNewBuilder().setValue(1).doTheBuild();\r\n    {\r\n        AttributeBuilderBuilderI<AbstractClassT> builder = newBuilder.newBuilder();\r\n        builder.firstPartyImmutableWithDifferentStyle(firstPartyImmutableWithDifferentStyle);\r\n        builder.thirdPartyImmutable(thirdPartyImmutable);\r\n        builder.addFirstPartyImmutable(firstPartyImmutable);\r\n        builder.addThirdPartyImmutable(thirdPartyImmutable);\r\n        builder.thirdPartyImmutableWithPrimitive(thirdPartyImmutableWithPrimitive);\r\n        ImmutableFirstPartyImmutable.Builder _firstPartyBuilder = builder.firstPartyImmutableBuilder().value(\"first party through attributeBuilder\");\r\n        ImmutableClassT copy = copyFunction.copy(builder.build());\r\n        check(copy.firstPartyImmutable().value()).is(\"first party through attributeBuilder\");\r\n    }\r\n    {\r\n        AttributeBuilderBuilderI<AbstractClassT> builder = newBuilder.newBuilder();\r\n        builder.firstPartyImmutable(firstPartyImmutable);\r\n        builder.thirdPartyImmutable(thirdPartyImmutable);\r\n        builder.addFirstPartyImmutable(firstPartyImmutable);\r\n        builder.addThirdPartyImmutable(thirdPartyImmutable);\r\n        builder.thirdPartyImmutableWithPrimitive(thirdPartyImmutableWithPrimitive);\r\n        ImmutableFirstPartyImmutableWithDifferentStyle.Abonabon _firstPartyBuilderWithDifferentStyle = builder.firstPartyImmutableWithDifferentStyleBuilder().value(\"first party through attributeBuilder\");\r\n        ImmutableClassT copy = copyFunction.copy(builder.build());\r\n        check(copy.firstPartyImmutableWithDifferentStyle().value()).is(\"first party through attributeBuilder\");\r\n    }\r\n    {\r\n        AttributeBuilderBuilderI<AbstractClassT> builder = newBuilder.newBuilder();\r\n        builder.firstPartyImmutable(firstPartyImmutable);\r\n        builder.firstPartyImmutableWithDifferentStyle(firstPartyImmutableWithDifferentStyle);\r\n        builder.addFirstPartyImmutable(firstPartyImmutable);\r\n        builder.addThirdPartyImmutable(thirdPartyImmutable);\r\n        builder.thirdPartyImmutableWithPrimitive(thirdPartyImmutableWithPrimitive);\r\n        ThirdPartyImmutable.Builder thirdPartyImmutableBuilder = builder.thirdPartyImmutableBuilder().setValue(\"third party through attributeBuilder\");\r\n        ImmutableClassT copy = copyFunction.copy(builder.build());\r\n        check(copy.thirdPartyImmutable().getValue()).is(\"third party through attributeBuilder\");\r\n    }\r\n    {\r\n        AttributeBuilderBuilderI<AbstractClassT> builder = newBuilder.newBuilder();\r\n        builder.firstPartyImmutable(firstPartyImmutable);\r\n        builder.firstPartyImmutableWithDifferentStyle(firstPartyImmutableWithDifferentStyle);\r\n        builder.thirdPartyImmutable(thirdPartyImmutable);\r\n        builder.addThirdPartyImmutable(thirdPartyImmutable);\r\n        builder.thirdPartyImmutableWithPrimitive(thirdPartyImmutableWithPrimitive);\r\n        ImmutableFirstPartyImmutable.Builder firstPartyBuilder = builder.addFirstPartyImmutableBuilder().value(\"first party through attributeBuilder\");\r\n        ImmutableClassT copy = copyFunction.copy(builder.build());\r\n        check(copy.firstPartyImmutableList().get(0).value()).is(\"first party through attributeBuilder\");\r\n    }\r\n    {\r\n        AttributeBuilderBuilderI<AbstractClassT> builder = newBuilder.newBuilder();\r\n        builder.firstPartyImmutable(firstPartyImmutable);\r\n        builder.firstPartyImmutableWithDifferentStyle(firstPartyImmutableWithDifferentStyle);\r\n        builder.thirdPartyImmutable(thirdPartyImmutable);\r\n        builder.addFirstPartyImmutable(firstPartyImmutable);\r\n        builder.thirdPartyImmutableWithPrimitive(thirdPartyImmutableWithPrimitive);\r\n        ThirdPartyImmutable.Builder thirdPartyBuilder = builder.addThirdPartyImmutableBuilder().setValue(\"third party through attributeBuilder\");\r\n        ImmutableClassT copy = copyFunction.copy(builder.build());\r\n        check(copy.thirdPartyImmutableList().get(0).getValue()).is(\"third party through attributeBuilder\");\r\n    }\r\n    {\r\n        AttributeBuilderBuilderI<AbstractClassT> builder = newBuilder.newBuilder();\r\n        builder.firstPartyImmutable(firstPartyImmutable);\r\n        builder.firstPartyImmutableWithDifferentStyle(firstPartyImmutableWithDifferentStyle);\r\n        builder.thirdPartyImmutable(thirdPartyImmutable);\r\n        builder.addFirstPartyImmutable(firstPartyImmutable);\r\n        builder.addThirdPartyImmutable(thirdPartyImmutable);\r\n        ThirdPartyImmutableWithPrimitive.Builder thirdPartyBuilder = builder.thirdPartyImmutableWithPrimitiveBuilder().setValue(2);\r\n        ImmutableClassT copy = copyFunction.copy(builder.build());\r\n        check(copy.thirdPartyImmutableWithPrimitive().getValue()).is(2);\r\n    }\r\n    {\r\n        AttributeBuilderBuilderI<AbstractClassT> builder = newBuilder.newBuilder();\r\n        builder.firstPartyImmutableWithDifferentStyle(firstPartyImmutableWithDifferentStyle);\r\n        builder.thirdPartyImmutable(thirdPartyImmutable);\r\n        builder.addFirstPartyImmutable(firstPartyImmutable);\r\n        builder.addThirdPartyImmutable(thirdPartyImmutable);\r\n        builder.thirdPartyImmutableWithPrimitive(thirdPartyImmutableWithPrimitive);\r\n        ImmutableFirstPartyImmutable.Builder firstPartyBuilder = ImmutableFirstPartyImmutable.builder().value(\"first party through setter\");\r\n        builder.firstPartyImmutableBuilder(firstPartyBuilder);\r\n        ImmutableClassT copy = copyFunction.copy(builder.build());\r\n        check(copy.firstPartyImmutable().value()).is(\"first party through setter\");\r\n        firstPartyBuilder.value(\"another value\");\r\n        ImmutableClassT copy2 = copyFunction.copy(builder.build());\r\n        check(copy2.firstPartyImmutable().value()).is(\"another value\");\r\n    }\r\n    {\r\n        AttributeBuilderBuilderI<AbstractClassT> builder = newBuilder.newBuilder();\r\n        builder.firstPartyImmutable(firstPartyImmutable);\r\n        builder.firstPartyImmutableWithDifferentStyle(firstPartyImmutableWithDifferentStyle);\r\n        builder.thirdPartyImmutable(thirdPartyImmutable);\r\n        builder.addThirdPartyImmutable(thirdPartyImmutable);\r\n        builder.thirdPartyImmutableWithPrimitive(thirdPartyImmutableWithPrimitive);\r\n        ImmutableFirstPartyImmutable.Builder first = ImmutableFirstPartyImmutable.builder().value(\"first party through setter 1\");\r\n        ImmutableFirstPartyImmutable.Builder second = ImmutableFirstPartyImmutable.builder().value(\"first party through setter 2\");\r\n        ImmutableFirstPartyImmutable.Builder third = ImmutableFirstPartyImmutable.builder().value(\"first party through setter 3\");\r\n        builder.addAllFirstPartyImmutableBuilders(first);\r\n        builder.addAllFirstPartyImmutableBuilders(Arrays.asList(second, third));\r\n        List<Builder> builderList = builder.firstPartyImmutableBuilders();\r\n        check(builderList.size()).is(3);\r\n        boolean thrown = false;\r\n        try {\r\n            builderList.add(ImmutableFirstPartyImmutable.builder());\r\n        } catch (Exception e) {\r\n            thrown = true;\r\n        }\r\n        check(\"Should not have been able to modify builder list, but could\", thrown);\r\n        check(builderList.size()).is(3);\r\n        builderList.get(1).value(\"first party through setter munged\");\r\n        ImmutableClassT copy = copyFunction.copy(builder.build());\r\n        check(copy.firstPartyImmutableList().size()).is(3);\r\n        check(copy.firstPartyImmutableList().get(0).value()).is(\"first party through setter 1\");\r\n        check(copy.firstPartyImmutableList().get(1).value()).is(\"first party through setter munged\");\r\n        check(copy.firstPartyImmutableList().get(2).value()).is(\"first party through setter 3\");\r\n        third.value(\"MUNGING\");\r\n        ImmutableClassT copy2 = copyFunction.copy(builder.build());\r\n        check(copy2.firstPartyImmutableList().get(2).value()).is(\"MUNGING\");\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Array.getDoubles",
	"Comment": "gets the doubles contained in a subset of a v8array. if the subsetcontains elements other than doubles, then a v8resultundefined exceptionis thrown. furthermore, if the subset is not entirely contained within the array,then v8resultundefined exception is also thrown. finally, if the resultarrayis not large enough to hold the results then indexoutofboundsexception is thrown.",
	"Method": "double[] getDoubles(int index,int length,int getDoubles,int index,int length,double[] resultArray,double[] getDoubles,int index,int length,int getDoubles,int index,int length,double[] resultArray){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    if (length > resultArray.length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    return v8.arrayGetDoubles(v8.getV8RuntimePtr(), getHandle(), index, length, resultArray);\r\n}"
}, {
	"Path": "com.graphhopper.routing.DijkstraTest.configs",
	"Comment": "runs the same test with each of the supported traversal modes",
	"Method": "Collection<Object[]> configs(){\r\n    return Arrays.asList(new Object[][] { { TraversalMode.NODE_BASED }, { TraversalMode.EDGE_BASED_1DIR }, { TraversalMode.EDGE_BASED_2DIR }, { TraversalMode.EDGE_BASED_2DIR_UTURN } });\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeCreateActuatorTest.sameTokenNameOpenSuccessExchangeCreate2",
	"Comment": "sametokenname close,second create exchange, result is success.",
	"Method": "void sameTokenNameOpenSuccessExchangeCreate2(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    String firstTokenId = \"_\";\r\n    long firstTokenBalance = 100_000_000_000000L;\r\n    String secondTokenId = \"123\";\r\n    long secondTokenBalance = 100_000_000L;\r\n    AssetIssueCapsule assetIssueCapsule = new AssetIssueCapsule(AssetIssueContract.newBuilder().setName(ByteString.copyFrom(secondTokenId.getBytes())).build());\r\n    assetIssueCapsule.setId(String.valueOf(1L));\r\n    dbManager.getAssetIssueStore().put(assetIssueCapsule.getName().toByteArray(), assetIssueCapsule);\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.setBalance(200_000_000_000000L);\r\n    accountCapsule.addAssetAmountV2(secondTokenId.getBytes(), 200_000_000L, dbManager);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeCreateActuator actuator = new ExchangeCreateActuator(getContract(OWNER_ADDRESS_FIRST, firstTokenId, firstTokenBalance, secondTokenId, secondTokenBalance), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    Assert.assertEquals(dbManager.getDynamicPropertiesStore().getLatestExchangeNum(), 0);\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        Assert.assertEquals(ret.getInstance().getRet(), code.SUCESS);\r\n        long id = 1;\r\n        Assert.assertEquals(dbManager.getDynamicPropertiesStore().getLatestExchangeNum(), id);\r\n        ExchangeCapsule exchangeCapsuleV2 = dbManager.getExchangeV2Store().get(ByteArray.fromLong(id));\r\n        Assert.assertNotNull(exchangeCapsuleV2);\r\n        Assert.assertEquals(ByteString.copyFrom(ownerAddress), exchangeCapsuleV2.getCreatorAddress());\r\n        Assert.assertEquals(id, exchangeCapsuleV2.getID());\r\n        Assert.assertEquals(1000000, exchangeCapsuleV2.getCreateTime());\r\n        Assert.assertTrue(Arrays.equals(firstTokenId.getBytes(), exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenId, ByteArray.toStr(exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenBalance, exchangeCapsuleV2.getFirstTokenBalance());\r\n        Assert.assertEquals(secondTokenId, ByteArray.toStr(exchangeCapsuleV2.getSecondTokenId()));\r\n        Assert.assertEquals(secondTokenBalance, exchangeCapsuleV2.getSecondTokenBalance());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        Map<String, Long> getAssetV2Map = accountCapsule.getAssetMapV2();\r\n        Assert.assertEquals(200_000_000_000000L - 1024_000000L - firstTokenBalance, accountCapsule.getBalance());\r\n        Assert.assertEquals(100_000_000L, getAssetV2Map.get(secondTokenId).longValue());\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertFalse(e instanceof ContractValidateException);\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    } catch (ItemNotFoundException e) {\r\n        Assert.assertFalse(e instanceof ItemNotFoundException);\r\n    }\r\n}"
}, {
	"Path": "com.spotify.helios.master.reaper.OldJobReaperTest.jobNotDeployedWithoutHistoryCreateBeforeRetentionReaped",
	"Comment": "a job not deployed, without history, and created before retention time should be reaped.",
	"Method": "void jobNotDeployedWithoutHistoryCreateBeforeRetentionReaped(){\r\n    final MasterModel masterModel = mock(MasterModel.class);\r\n    testReap(name.getMethodName(), emptyMap(), emptyList(), HOURS.toMillis(23), masterModel, true);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.extend.XhtmlCssOnlyNamespaceHandler.getNamespace",
	"Comment": "gets the namespace attribute of the xhtmlnamespacehandler object",
	"Method": "String getNamespace(){\r\n    return _namespace;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.NaiveUserAgent.needsRedirect",
	"Comment": "verify that return code of connection represents a redirection.but it is final because redirection processing is determined.",
	"Method": "boolean needsRedirect(int status){\r\n    return status != HttpURLConnection.HTTP_OK && (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER);\r\n}"
}, {
	"Path": "com.graphhopper.storage.TurnCostExtensionTest.testMultipleTurnCosts",
	"Comment": "test if multiple turn costs can be safely written to the storage and read from it.",
	"Method": "void testMultipleTurnCosts(){\r\n    FlagEncoder carEncoder = new CarFlagEncoder(5, 5, 3);\r\n    FlagEncoder bikeEncoder = new BikeFlagEncoder(5, 5, 3);\r\n    EncodingManager manager = new EncodingManager(carEncoder, bikeEncoder);\r\n    GraphHopperStorage g = new GraphBuilder(manager).create();\r\n    initGraph(g);\r\n    TurnCostExtension tcs = (TurnCostExtension) g.getExtension();\r\n    long carRestricted = carEncoder.getTurnFlags(true, 0);\r\n    long carCosts = carEncoder.getTurnFlags(false, 2);\r\n    long bikeRestricted = bikeEncoder.getTurnFlags(true, 0);\r\n    long bikeCosts = bikeEncoder.getTurnFlags(false, 2);\r\n    int edge42 = getEdge(g, 4, 2).getEdge();\r\n    int edge23 = getEdge(g, 2, 3).getEdge();\r\n    int edge31 = getEdge(g, 3, 1).getEdge();\r\n    int edge10 = getEdge(g, 1, 0).getEdge();\r\n    int edge02 = getEdge(g, 0, 2).getEdge();\r\n    int edge24 = getEdge(g, 2, 4).getEdge();\r\n    tcs.mergeOrOverwriteTurnInfo(edge42, 2, edge23, carRestricted, true);\r\n    tcs.mergeOrOverwriteTurnInfo(edge42, 2, edge23, bikeRestricted, true);\r\n    tcs.mergeOrOverwriteTurnInfo(edge23, 3, edge31, carRestricted, true);\r\n    tcs.mergeOrOverwriteTurnInfo(edge23, 3, edge31, bikeCosts, true);\r\n    tcs.mergeOrOverwriteTurnInfo(edge31, 1, edge10, carCosts, true);\r\n    tcs.mergeOrOverwriteTurnInfo(edge31, 1, edge10, bikeRestricted, true);\r\n    tcs.mergeOrOverwriteTurnInfo(edge02, 2, edge24, carRestricted, false);\r\n    tcs.mergeOrOverwriteTurnInfo(edge02, 2, edge24, bikeRestricted, false);\r\n    long flags423 = tcs.getTurnCostFlags(edge42, 2, edge23);\r\n    assertEquals(Double.POSITIVE_INFINITY, carEncoder.getTurnCost(flags423), 0);\r\n    assertEquals(Double.POSITIVE_INFINITY, bikeEncoder.getTurnCost(flags423), 0);\r\n    long flags231 = tcs.getTurnCostFlags(edge23, 3, edge31);\r\n    assertEquals(Double.POSITIVE_INFINITY, carEncoder.getTurnCost(flags231), 0);\r\n    assertEquals(2.0, bikeEncoder.getTurnCost(flags231), 0);\r\n    long flags310 = tcs.getTurnCostFlags(edge31, 1, edge10);\r\n    assertEquals(2.0, carEncoder.getTurnCost(flags310), 0);\r\n    assertEquals(Double.POSITIVE_INFINITY, bikeEncoder.getTurnCost(flags310), 0);\r\n    long flags024 = tcs.getTurnCostFlags(edge02, 2, edge24);\r\n    assertEquals(0.0, carEncoder.getTurnCost(flags024), 0);\r\n    assertEquals(Double.POSITIVE_INFINITY, bikeEncoder.getTurnCost(flags024), 0);\r\n    tcs.addTurnInfo(edge02, 2, edge23, carRestricted);\r\n    tcs.addTurnInfo(edge02, 2, edge23, bikeRestricted);\r\n    long flags023 = tcs.getTurnCostFlags(edge02, 2, edge23);\r\n    assertEquals(Double.POSITIVE_INFINITY, carEncoder.getTurnCost(flags023), 0);\r\n    assertEquals(Double.POSITIVE_INFINITY, bikeEncoder.getTurnCost(flags023), 0);\r\n    tcs.mergeOrOverwriteTurnInfo(edge02, 2, edge23, bikeRestricted, false);\r\n    flags023 = tcs.getTurnCostFlags(edge02, 2, edge23);\r\n    assertEquals(0, carEncoder.getTurnCost(flags023), 0);\r\n    assertEquals(Double.POSITIVE_INFINITY, bikeEncoder.getTurnCost(flags023), 0);\r\n    tcs.mergeOrOverwriteTurnInfo(edge02, 2, edge23, 0, false);\r\n    flags023 = tcs.getTurnCostFlags(edge02, 2, edge23);\r\n    assertEquals(0, carEncoder.getTurnCost(flags023), 0);\r\n    assertEquals(0, bikeEncoder.getTurnCost(flags023), 0);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.debug.DebugHandler.changeBreakPointCondition",
	"Comment": "changes the current condition on the breakpoint as specified by the breakpoint id",
	"Method": "void changeBreakPointCondition(int breakpointID,String condition){\r\n    V8Array parameters = new V8Array(runtime);\r\n    parameters.push(breakpointID);\r\n    parameters.push(condition);\r\n    try {\r\n        debugObject.executeVoidFunction(CHANGE_BREAK_POINT_CONDITION, parameters);\r\n    } finally {\r\n        parameters.close();\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Object.executeArrayFunction",
	"Comment": "invoke a javascript function and return the result as a v8array. if theresult is not a v8array then v8resultundefined is thrown.",
	"Method": "V8Array executeArrayFunction(String name,V8Array parameters,V8Array executeArrayFunction,String name,V8Array parameters){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    v8.checkRuntime(parameters);\r\n    long parametersHandle = parameters == null ? 0 : parameters.getHandle();\r\n    Object result = v8.executeFunction(v8.getV8RuntimePtr(), V8_ARRAY, objectHandle, name, parametersHandle);\r\n    if (result instanceof V8Array) {\r\n        return (V8Array) result;\r\n    }\r\n    throw new V8ResultUndefined();\r\n}"
}, {
	"Path": "com.spotify.helios.common.Json.asPrettyString",
	"Comment": "serialize an object to a json string. use when it is not know whether an object can be jsonserializable.",
	"Method": "String asPrettyString(Object value){\r\n    return PRETTY_OBJECT_WRITER.writeValueAsString(value);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.executeBooleanScript",
	"Comment": "executes a js script on this runtime and returns the result as a boolean.if the result is not a boolean, then a v8resultundefinedexception is thrown.",
	"Method": "boolean executeBooleanScript(String script,boolean executeBooleanScript,String script,String scriptName,int lineNumber,boolean executeBooleanScript,long v8RuntimePtr,String script,String scriptName,int lineNumber){\r\n    return _executeBooleanScript(v8RuntimePtr, script, scriptName, lineNumber);\r\n}"
}, {
	"Path": "org.immutables.mongo.types.TypeAdapters.timeInstantAdapter",
	"Comment": "use this adapter to easily delagate marshaling of custom time instant wrapper.",
	"Method": "TypeAdapter<Long> timeInstantAdapter(){\r\n    return TIME_INSTANT_ADAPTER;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.executeStringScript",
	"Comment": "executes a js script on this runtime and returns the result as a string.if the result is not a string, then a v8resultundefinedexception is thrown.",
	"Method": "String executeStringScript(String script,String executeStringScript,String script,String scriptName,int lineNumber,String executeStringScript,long v8RuntimePtr,String script,String scriptName,int lineNumber){\r\n    return _executeStringScript(v8RuntimePtr, script, scriptName, lineNumber);\r\n}"
}, {
	"Path": "com.graphhopper.util.PointList.clone",
	"Comment": "clones this pointlist. if this pointlist was immutable, the cloned will be mutable. if this pointlist was ashallowimmutablepointlist, the cloned pointlist will be a regular pointlist.",
	"Method": "PointList clone(boolean reverse){\r\n    PointList clonePL = new PointList(getSize(), is3D());\r\n    if (is3D())\r\n        for (int i = 0; i < getSize(); i++) {\r\n            clonePL.add(getLatitude(i), getLongitude(i), getElevation(i));\r\n        }\r\n    else\r\n        for (int i = 0; i < getSize(); i++) {\r\n            clonePL.add(getLatitude(i), getLongitude(i));\r\n        }\r\n    if (reverse)\r\n        clonePL.reverse();\r\n    return clonePL;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Object.getArray",
	"Comment": "returns the v8array value associated with this key. if the valueassociated with this key does not exist then undefined is returned.if the value exists but is not an array thenv8resultundefined exception is thrown.",
	"Method": "V8Array getArray(String key,V8Array getArray,String key){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    checkKey(key);\r\n    Object result = v8.get(v8.getV8RuntimePtr(), V8_ARRAY, objectHandle, key);\r\n    if ((result == null) || (result instanceof V8Array)) {\r\n        return (V8Array) result;\r\n    }\r\n    throw new V8ResultUndefined();\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.constants.IdentValue.addValue",
	"Comment": "adds a feature to the value attribute of the identvalue class",
	"Method": "IdentValue addValue(String ident){\r\n    if (ALL_IDENT_VALUES == null) {\r\n        ALL_IDENT_VALUES = new HashMap();\r\n    }\r\n    IdentValue val = new IdentValue(ident);\r\n    ALL_IDENT_VALUES.put(ident, val);\r\n    return val;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.newmatch.Selector.addCondition",
	"Comment": "adds a feature to the condition attribute of the selector object",
	"Method": "void addCondition(Condition c){\r\n    if (conditions == null) {\r\n        conditions = new java.util.ArrayList();\r\n    }\r\n    if (_pe != null) {\r\n        conditions.add(Condition.createUnsupportedCondition());\r\n        XRLog.match(Level.WARNING, \"Trying to append conditions to pseudoElement \" + _pe);\r\n    }\r\n    conditions.add(c);\r\n}"
}, {
	"Path": "com.graphhopper.routing.InstructionsOutgoingEdges.nrOfAllowedOutgoingEdges",
	"Comment": "this method calculates the number of allowed outgoing edges, which could be considered the number of possibleroads one might take at the intersection. this excludes the road you are coming from and inaccessible roads.",
	"Method": "int nrOfAllowedOutgoingEdges(){\r\n    return 1 + allowedOutgoingEdges.size();\r\n}"
}, {
	"Path": "com.eclipsesource.v8.utils.V8ObjectUtils.toList",
	"Comment": "creates a list from a v8array using a deep copy and a typeadapter to handletype conversions. all elements in the v8array are released after they are accessed.however, the root array itself is not released.",
	"Method": "List<? super Object> toList(V8Array array,List<? super Object> toList,V8Array array,TypeAdapter adapter,List<? super Object> toList,V8Array array,V8Map<Object> cache,TypeAdapter adapter){\r\n    if (array == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    if (cache.containsKey(array)) {\r\n        return (List<? super Object>) cache.get(array);\r\n    }\r\n    List<? super Object> result = new ArrayList<Object>();\r\n    cache.put(array, result);\r\n    for (int i = 0; i < array.length(); i++) {\r\n        Object object = null;\r\n        int type = V8Value.UNDEFINED;\r\n        try {\r\n            object = array.get(i);\r\n            type = array.getType(i);\r\n            Object value = getValue(object, type, cache, adapter);\r\n            if (value != IGNORE) {\r\n                result.add(value);\r\n            }\r\n        } finally {\r\n            if (object instanceof Releasable) {\r\n                ((Releasable) object).release();\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swt.SWTReplacedElementFactory.storeImageReplacedElement",
	"Comment": "adds a replacedelement containing an image to a cache of images for quicklookup.",
	"Method": "void storeImageReplacedElement(Element e,ReplacedElement cc){\r\n    if (_imageComponents == null) {\r\n        _imageComponents = new HashMap();\r\n    }\r\n    _imageComponents.put(e, cc);\r\n}"
}, {
	"Path": "com.spotify.helios.testing.JobPrefixFile.tryFromExistingFile",
	"Comment": "attempts to lock the given file, and create a jobprefixfile for it. a new jobprefixfileinstance will be returned if a lock can be obtained for the file. null will be returned if thelock is already held by either this process or another. for all other cases, an exception willbe thrown.",
	"Method": "JobPrefixFile tryFromExistingFile(Path file){\r\n    Preconditions.checkNotNull(file);\r\n    final FileChannel channel = FileChannel.open(file, WRITE);\r\n    final FileLock lock;\r\n    try {\r\n        lock = channel.tryLock();\r\n    } catch (OverlappingFileLockException e) {\r\n        close(channel);\r\n        return null;\r\n    } catch (Exception e) {\r\n        close(channel);\r\n        throw e;\r\n    }\r\n    if (lock == null) {\r\n        close(channel);\r\n        return null;\r\n    }\r\n    return new JobPrefixFile(file, channel, lock);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.AWTFontResolver.getFontInstanceHashName",
	"Comment": "gets the fontinstancehashname attribute of the fontresolvertest object",
	"Method": "String getFontInstanceHashName(SharedContext ctx,String name,float size,IdentValue weight,IdentValue style,IdentValue variant){\r\n    return name + \"-\" + (size * ctx.getTextRenderer().getFontScale()) + \"-\" + weight + \"-\" + style + \"-\" + variant;\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.JavaInputAstVisitor.formatArrayIndices",
	"Comment": "lays out one or more array indices. does not output the expression for the array itself.",
	"Method": "void formatArrayIndices(Deque<ExpressionTree> indices){\r\n    if (indices.isEmpty()) {\r\n        return;\r\n    }\r\n    builder.open(ZERO);\r\n    do {\r\n        token(\"[\");\r\n        builder.breakToFill();\r\n        scan(indices.removeLast(), null);\r\n        token(\"]\");\r\n    } while (!indices.isEmpty());\r\n    builder.close();\r\n}"
}, {
	"Path": "com.graphhopper.GHResponse.getAll",
	"Comment": "this method returns the best path as well as all alternatives.",
	"Method": "List<PathWrapper> getAll(){\r\n    return pathWrappers;\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.MainTest.importRemoveErrorParseError",
	"Comment": "test that errors are reported on the right line when imports are removed",
	"Method": "void importRemoveErrorParseError(){\r\n    Locale backupLocale = Locale.getDefault();\r\n    try {\r\n        Locale.setDefault(Locale.ROOT);\r\n        String[] input = { \"import java.util.ArrayList;\", \"import java.util.List;\", \"class Test {\", \"}}\" };\r\n        StringWriter out = new StringWriter();\r\n        StringWriter err = new StringWriter();\r\n        Main main = new Main(new PrintWriter(out, true), new PrintWriter(err, true), new ByteArrayInputStream(joiner.join(input).getBytes(UTF_8)));\r\n        assertThat(main.format(\"-\")).isEqualTo(1);\r\n        assertThat(err.toString()).contains(\"<stdin>:4:3: error: class, interface, or enum expected\");\r\n    } finally {\r\n        Locale.setDefault(backupLocale);\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.addReleaseHandler",
	"Comment": "adds a handler that will be called when the runtime is being released.the runtime will still be available when the handler is executed.",
	"Method": "void addReleaseHandler(V8Runnable handler){\r\n    releaseHandlers.add(handler);\r\n}"
}, {
	"Path": "com.graphhopper.storage.EdgeAccess.internalEdgeDisconnect",
	"Comment": "this method disconnects the specified edge from the list of edges of the specified node. itdoes not release the freed space to be reused.",
	"Method": "long internalEdgeDisconnect(int edgeToRemove,long edgeToUpdatePointer,int baseNode,int adjNode){\r\n    long edgeToRemovePointer = toPointer(edgeToRemove);\r\n    int nextEdgeId = getEdgeRef(baseNode, adjNode, edgeToRemovePointer);\r\n    if (edgeToUpdatePointer < 0) {\r\n        setEdgeRef(baseNode, nextEdgeId);\r\n    } else {\r\n        long link = edges.getInt(edgeToUpdatePointer + E_NODEA) == baseNode ? edgeToUpdatePointer + E_LINKA : edgeToUpdatePointer + E_LINKB;\r\n        edges.setInt(link, nextEdgeId);\r\n    }\r\n    return edgeToRemovePointer;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.value.FSCssValue.toString",
	"Comment": "returns the string representation of the instance, in this case, the csstext value.",
	"Method": "String toString(){\r\n    return getCssText();\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.value.FSCssValue.getPrimitiveType",
	"Comment": "the type of the value as defined by the constants specified above.",
	"Method": "short getPrimitiveType(){\r\n    return primitiveType;\r\n}"
}, {
	"Path": "com.spotify.helios.testing.HeliosDeploymentResource.client",
	"Comment": "return a helios client connected to the helios deployment supplied when instantiating theheliosdeploymentresource.",
	"Method": "HeliosClient client(){\r\n    return deployment.client();\r\n}"
}, {
	"Path": "com.graphhopper.GHResponse.getErrors",
	"Comment": "this method returns all the explicitly added errors and the errors of all paths.",
	"Method": "List<Throwable> getErrors(){\r\n    List<Throwable> list = new ArrayList();\r\n    list.addAll(errors);\r\n    for (PathWrapper ar : pathWrappers) {\r\n        list.addAll(ar.getErrors());\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "com.spotify.helios.testing.Jobs.undeploy",
	"Comment": "undeploy the job from all specified hosts, and delete the job. any failures will be ignored,and we will keep trying each host. a list of errors encountered along the way will be returnedto the caller.",
	"Method": "List<AssertionError> undeploy(HeliosClient client,Job job,List<String> hosts,List<AssertionError> errors){\r\n    final JobId id = job.getId();\r\n    for (final String host : hosts) {\r\n        log.info(\"Undeploying {} from {}\", getJobDescription(job), host);\r\n        final JobUndeployResponse response;\r\n        try {\r\n            response = get(client.undeploy(id, host));\r\n            if (response.getStatus() != JobUndeployResponse.Status.OK && response.getStatus() != JobUndeployResponse.Status.JOB_NOT_FOUND) {\r\n                errors.add(new AssertionError(format(\"Failed to undeploy job %s - %s\", id, response)));\r\n            }\r\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\r\n            errors.add(new AssertionError(e));\r\n        }\r\n    }\r\n    try {\r\n        log.debug(\"Deleting job {}\", id);\r\n        final JobDeleteResponse response = get(client.deleteJob(id));\r\n        if (response.getStatus() != JobDeleteResponse.Status.OK && response.getStatus() != JobDeleteResponse.Status.JOB_NOT_FOUND) {\r\n            errors.add(new AssertionError(format(\"Failed to delete job %s - %s\", id.toString(), response.toString())));\r\n        }\r\n    } catch (InterruptedException | ExecutionException | TimeoutException e) {\r\n        errors.add(new AssertionError(e));\r\n    }\r\n    return errors;\r\n}"
}, {
	"Path": "com.spotify.helios.master.resources.HostsResourceTest.listHostsNameAndSelectorFilter",
	"Comment": "test behavior when both a name pattern and selector list is specified.",
	"Method": "void listHostsNameAndSelectorFilter(){\r\n    when(model.listHosts(\"foo.example.com\")).thenReturn(hosts);\r\n    assertThat(resource.list(\"foo.example.com\", ImmutableList.of(\"site=foo\")), equalTo(hosts));\r\n    when(model.listHosts(\"host3\")).thenReturn(ImmutableList.of(\"host3.foo.example.com\"));\r\n    assertThat(resource.list(\"host3\", ImmutableList.of(\"index =2\")), empty());\r\n    assertThat(resource.list(\"host3\", ImmutableList.of(\"index!=2\")), contains(\"host3.foo.example.com\"));\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeWithdrawActuatorTest.SameTokenNameCloseTnotherTokenQuantLessThanZero",
	"Comment": "sametokenname close, withdraw another token quant must greater than zero",
	"Method": "void SameTokenNameCloseTnotherTokenQuantLessThanZero(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(0);\r\n    InitExchangeBeforeSameTokenNameActive();\r\n    long exchangeId = 1;\r\n    String firstTokenId = \"abc\";\r\n    long quant = 1L;\r\n    String secondTokenId = \"def\";\r\n    long secondTokenQuant = 400000000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmount(firstTokenId.getBytes(), 1000L);\r\n    accountCapsule.addAssetAmount(secondTokenId.getBytes(), secondTokenQuant);\r\n    accountCapsule.setBalance(10000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeWithdrawActuator actuator = new ExchangeWithdrawActuator(getContract(OWNER_ADDRESS_FIRST, exchangeId, secondTokenId, quant), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"withdraw another token quant must greater than zero\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.sheet.Ruleset.getPropertyDeclarations",
	"Comment": "returns an iterator of propertydeclarations pulled from thiscssstylerule.",
	"Method": "List getPropertyDeclarations(){\r\n    return Collections.unmodifiableList(_props);\r\n}"
}, {
	"Path": "com.graphhopper.reader.osm.OSMReader.processWay",
	"Comment": "process properties, encode flags and create edges for the way.",
	"Method": "void processWay(ReaderWay way){\r\n    if (way.getNodes().size() < 2)\r\n        return;\r\n    if (!way.hasTags())\r\n        return;\r\n    long wayOsmId = way.getId();\r\n    long includeWay = encodingManager.acceptWay(way);\r\n    if (includeWay == 0)\r\n        return;\r\n    long relationFlags = getRelFlagsMap().get(way.getId());\r\n    LongArrayList osmNodeIds = way.getNodes();\r\n    if (osmNodeIds.size() > 1) {\r\n        int first = getNodeMap().get(osmNodeIds.get(0));\r\n        int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));\r\n        double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);\r\n        double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);\r\n        if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {\r\n            double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);\r\n            way.setTag(\"estimated_distance\", estimatedDist);\r\n            way.setTag(\"estimated_center\", new GHPoint((firstLat + lastLat) / 2, (firstLon + lastLon) / 2));\r\n        }\r\n    }\r\n    if (way.getTag(\"duration\") != null) {\r\n        try {\r\n            long dur = OSMTagParser.parseDuration(way.getTag(\"duration\"));\r\n            way.setTag(\"duration:seconds\", Long.toString(dur));\r\n        } catch (Exception ex) {\r\n            LOGGER.warn(\"Parsing error in way with OSMID=\" + way.getId() + \" : \" + ex.getMessage());\r\n        }\r\n    }\r\n    long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);\r\n    if (wayFlags == 0)\r\n        return;\r\n    List<EdgeIteratorState> createdEdges = new ArrayList();\r\n    final int size = osmNodeIds.size();\r\n    int lastBarrier = -1;\r\n    for (int i = 0; i < size; i++) {\r\n        long nodeId = osmNodeIds.get(i);\r\n        long nodeFlags = getNodeFlagsMap().get(nodeId);\r\n        if (nodeFlags > 0) {\r\n            if ((nodeFlags & wayFlags) > 0) {\r\n                getNodeFlagsMap().put(nodeId, 0);\r\n                long newNodeId = addBarrierNode(nodeId);\r\n                if (i > 0) {\r\n                    if (lastBarrier < 0)\r\n                        lastBarrier = 0;\r\n                    int length = i - lastBarrier + 1;\r\n                    LongArrayList partNodeIds = new LongArrayList();\r\n                    partNodeIds.add(osmNodeIds.buffer, lastBarrier, length);\r\n                    partNodeIds.set(length - 1, newNodeId);\r\n                    createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));\r\n                    createdEdges.addAll(addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId));\r\n                } else {\r\n                    createdEdges.addAll(addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags, wayOsmId));\r\n                    osmNodeIds.set(0, newNodeId);\r\n                }\r\n                lastBarrier = i;\r\n            }\r\n        }\r\n    }\r\n    if (lastBarrier >= 0) {\r\n        if (lastBarrier < size - 1) {\r\n            LongArrayList partNodeIds = new LongArrayList();\r\n            partNodeIds.add(osmNodeIds.buffer, lastBarrier, size - lastBarrier);\r\n            createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));\r\n        }\r\n    } else {\r\n        createdEdges.addAll(addOSMWay(way.getNodes(), wayFlags, wayOsmId));\r\n    }\r\n    for (EdgeIteratorState edge : createdEdges) {\r\n        encodingManager.applyWayTags(way, edge);\r\n    }\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeCreateActuatorTest.sameTokenNameOpenSuccessExchangeCreate",
	"Comment": "sametokenname open,first createexchange,result is success.",
	"Method": "void sameTokenNameOpenSuccessExchangeCreate(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    String firstTokenId = \"123\";\r\n    long firstTokenBalance = 100000000L;\r\n    String secondTokenId = \"456\";\r\n    long secondTokenBalance = 100000000L;\r\n    AssetIssueCapsule assetIssueCapsule1 = new AssetIssueCapsule(AssetIssueContract.newBuilder().setName(ByteString.copyFrom(firstTokenId.getBytes())).build());\r\n    assetIssueCapsule1.setId(String.valueOf(1L));\r\n    AssetIssueCapsule assetIssueCapsule2 = new AssetIssueCapsule(AssetIssueContract.newBuilder().setName(ByteString.copyFrom(secondTokenId.getBytes())).build());\r\n    assetIssueCapsule2.setId(String.valueOf(2L));\r\n    dbManager.getAssetIssueStore().put(assetIssueCapsule1.getName().toByteArray(), assetIssueCapsule1);\r\n    dbManager.getAssetIssueStore().put(assetIssueCapsule2.getName().toByteArray(), assetIssueCapsule2);\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmountV2(firstTokenId.getBytes(), firstTokenBalance, dbManager);\r\n    accountCapsule.addAssetAmountV2(secondTokenId.getBytes(), secondTokenBalance, dbManager);\r\n    accountCapsule.setBalance(10000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeCreateActuator actuator = new ExchangeCreateActuator(getContract(OWNER_ADDRESS_FIRST, firstTokenId, firstTokenBalance, secondTokenId, secondTokenBalance), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    Assert.assertEquals(dbManager.getDynamicPropertiesStore().getLatestExchangeNum(), 0);\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        Assert.assertEquals(ret.getInstance().getRet(), code.SUCESS);\r\n        long id = 1;\r\n        Assert.assertEquals(dbManager.getDynamicPropertiesStore().getLatestExchangeNum(), id);\r\n        ExchangeCapsule exchangeCapsuleV2 = dbManager.getExchangeV2Store().get(ByteArray.fromLong(id));\r\n        Assert.assertNotNull(exchangeCapsuleV2);\r\n        Assert.assertEquals(ByteString.copyFrom(ownerAddress), exchangeCapsuleV2.getCreatorAddress());\r\n        Assert.assertEquals(id, exchangeCapsuleV2.getID());\r\n        Assert.assertEquals(1000000, exchangeCapsuleV2.getCreateTime());\r\n        Assert.assertTrue(Arrays.equals(firstTokenId.getBytes(), exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenId, ByteArray.toStr(exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenBalance, exchangeCapsuleV2.getFirstTokenBalance());\r\n        Assert.assertEquals(secondTokenId, ByteArray.toStr(exchangeCapsuleV2.getSecondTokenId()));\r\n        Assert.assertEquals(secondTokenBalance, exchangeCapsuleV2.getSecondTokenBalance());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        Map<String, Long> getAssetV2Map = accountCapsule.getAssetMapV2();\r\n        Assert.assertEquals(10000_000000L - 1024_000000L, accountCapsule.getBalance());\r\n        Assert.assertEquals(0L, getAssetV2Map.get(firstTokenId).longValue());\r\n        Assert.assertEquals(0L, getAssetV2Map.get(secondTokenId).longValue());\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertFalse(e instanceof ContractValidateException);\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    } catch (ItemNotFoundException e) {\r\n        Assert.assertFalse(e instanceof ItemNotFoundException);\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.removeExecutor",
	"Comment": "removes the executor from this runtime. the executor isshutdown, simply removed from the list of knownexecutors.",
	"Method": "V8Executor removeExecutor(V8Object key){\r\n    checkThread();\r\n    if (executors == null) {\r\n        return null;\r\n    }\r\n    return executors.remove(key);\r\n}"
}, {
	"Path": "com.notnoop.apns.ApnsServerSocketBuilder.withSandboxDestination",
	"Comment": "specify to use the apple sandbox servers as iphone gateway and feedback\tservers.\tthis is desired when in testing and pushing notifications with a\tdevelopment provision.",
	"Method": "ApnsServerSocketBuilder withSandboxDestination(){\r\n    return withGatewayDestination(SANDBOX_GATEWAY_PORT).withFeedbackDestination(SANDBOX_FEEDBACK_PORT);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.XRLog.setLoggingEnabled",
	"Comment": "turns logging on or off, without affecting logging configuration.",
	"Method": "void setLoggingEnabled(boolean loggingEnabled){\r\n    XRLog.loggingEnabled = loggingEnabled;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.sheet.StylesheetInfo.setStylesheet",
	"Comment": "sets the stylesheet attribute of the stylesheetinfo object",
	"Method": "void setStylesheet(Stylesheet stylesheet){\r\n    this.stylesheet = stylesheet;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.FSScrollPane.setDefaultInputMap",
	"Comment": "assigns the default keyboard bindings on the view for document navigation.",
	"Method": "void setDefaultInputMap(JComponent view){\r\n    view.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_PAGE_DOWN, 0), PAGE_DOWN);\r\n    view.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_PAGE_UP, 0), PAGE_UP);\r\n    view.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0), LINE_DOWN);\r\n    view.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0), LINE_UP);\r\n    view.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_END, KeyEvent.CTRL_MASK), PAGE_END);\r\n    view.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_END, 0), PAGE_END);\r\n    view.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_HOME, KeyEvent.CTRL_MASK), PAGE_START);\r\n    view.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_HOME, 0), PAGE_START);\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.AbstractFlagEncoder.init",
	"Comment": "should be called as last method in constructor, move out of the flag encoder somehow",
	"Method": "void init(){\r\n    conditionalTagInspector = new ConditionalOSMTagInspector(DateRangeParser.createCalendar(), restrictions, restrictedValues, intendedValues);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.render.AbstractOutputDevice.setFontSpecification",
	"Comment": "sets the fontspecification for this abstractoutputdevice.",
	"Method": "void setFontSpecification(FontSpecification fs){\r\n    _fontSpec = fs;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.BasicPanel.setDocumentRelative",
	"Comment": "sets the new current document, where the new documentis located relative, e.g using a relative url.",
	"Method": "void setDocumentRelative(String filename){\r\n    String url = getSharedContext().getUac().resolveURI(filename);\r\n    if (isAnchorInCurrentDocument(filename)) {\r\n        String id = getAnchorId(filename);\r\n        Box box = getSharedContext().getBoxById(id);\r\n        if (box != null) {\r\n            Point pt;\r\n            if (box.getStyle().isInline()) {\r\n                pt = new Point(box.getAbsX(), box.getAbsY());\r\n            } else {\r\n                RectPropertySet margin = box.getMargin(getLayoutContext());\r\n                pt = new Point(box.getAbsX() + (int) margin.left(), box.getAbsY() + (int) margin.top());\r\n            }\r\n            scrollTo(pt);\r\n            return;\r\n        }\r\n    }\r\n    Document dom = loadDocument(url);\r\n    setDocument(dom, url);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.utils.V8Executor.isTerminating",
	"Comment": "returns true if forcetermination was called to shutdownthis executor.",
	"Method": "boolean isTerminating(){\r\n    return forceTerminating;\r\n}"
}, {
	"Path": "com.notnoop.apns.PayloadBuilder.alertTitle",
	"Comment": "sets the alert title text, the text the appears to the user,to the passed value.used on ios 8.2, iwatch and also safari",
	"Method": "PayloadBuilder alertTitle(String title){\r\n    customAlert.put(\"title\", title);\r\n    return this;\r\n}"
}, {
	"Path": "com.graphhopper.GHResponse.hasErrors",
	"Comment": "this method returns true if one of the paths has an error or if the response itself iserroneous.",
	"Method": "boolean hasErrors(){\r\n    if (!errors.isEmpty())\r\n        return true;\r\n    for (PathWrapper ar : pathWrappers) {\r\n        if (ar.hasErrors())\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Object.executeFunction",
	"Comment": "invoke a javascript function and return the result as a java object.",
	"Method": "Object executeFunction(String name,V8Array parameters,Object executeFunction,String name,V8Array parameters){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    v8.checkRuntime(parameters);\r\n    long parametersHandle = parameters == null ? 0 : parameters.getHandle();\r\n    return v8.executeFunction(v8.getV8RuntimePtr(), UNKNOWN, objectHandle, name, parametersHandle);\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.getAnimationDurationShowProfileDetails",
	"Comment": "duration of profile toolbar and profile details transition animations.",
	"Method": "int getAnimationDurationShowProfileDetails(){\r\n    return ANIMATION_DURATION_SHOW_PROFILE_DETAILS;\r\n}"
}, {
	"Path": "com.spotify.helios.master.reaper.OldJobReaperTest.jobNotDeployedWithoutHistoryWithCreateDateReaped",
	"Comment": "a job not deployed, without history, and without a creation date should be reaped.",
	"Method": "void jobNotDeployedWithoutHistoryWithCreateDateReaped(){\r\n    final MasterModel masterModel = mock(MasterModel.class);\r\n    testReap(name.getMethodName(), emptyMap(), emptyList(), null, masterModel, true);\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeTransactionActuatorTest.SameTokenNameOpenTokenBalanceGreaterThanBalanceLimit",
	"Comment": "sametokenname open,token balance must less than balancelimit",
	"Method": "void SameTokenNameOpenTokenBalanceGreaterThanBalanceLimit(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    InitExchangeSameTokenNameActive();\r\n    long exchangeId = 2;\r\n    String tokenId = \"123\";\r\n    long quant = 1_000_000_000_000_001L;\r\n    String buyTokenId = \"456\";\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_SECOND);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmountV2(tokenId.getBytes(), 10000, dbManager);\r\n    Map<String, Long> assetV2Map = accountCapsule.getAssetMapV2();\r\n    Assert.assertEquals(20000_000000L, accountCapsule.getBalance());\r\n    Assert.assertEquals(null, assetV2Map.get(buyTokenId));\r\n    dbManager.getAccountStore().put(accountCapsule.createDbKey(), accountCapsule);\r\n    ExchangeTransactionActuator actuator = new ExchangeTransactionActuator(getContract(OWNER_ADDRESS_SECOND, exchangeId, tokenId, quant, 1), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"token balance must less than 1000000000000000\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "org.tron.common.runtime.vm.program.Program.allocateMemory",
	"Comment": "allocates extra memory in the program for a specified size, calculated from a given offset",
	"Method": "void allocateMemory(int offset,int size){\r\n    memory.extend(offset, size);\r\n}"
}, {
	"Path": "org.kie.pmml.pmml_4_2.model.PMML4UnitImpl.initDataDictionaryMap",
	"Comment": "initializes the internal structure that holds data dictionary information.this initializer should be called prior to any other initializers, sincemany other structures may have a dependency on the data dictionary.",
	"Method": "void initDataDictionaryMap(){\r\n    DataDictionary dd = rawPmml.getDataDictionary();\r\n    if (dd != null) {\r\n        dataDictionaryMap = new HashMap();\r\n        for (DataField dataField : dd.getDataFields()) {\r\n            PMMLDataField df = new PMMLDataField(dataField);\r\n            dataDictionaryMap.put(df.getName(), df);\r\n        }\r\n    } else {\r\n        throw new IllegalStateException(\"BRMS-PMML requires a data dictionary section in the definition file\");\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.debug.mirror.Frame.getFunction",
	"Comment": "returns the function associated with this particular debug frame.",
	"Method": "FunctionMirror getFunction(){\r\n    V8Object function = null;\r\n    try {\r\n        function = v8Object.executeObjectFunction(FUNC, null);\r\n        return new FunctionMirror(function);\r\n    } finally {\r\n        if (function != null) {\r\n            function.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.registerV8Executor",
	"Comment": "registers an executor with this runtime. an executor is anotherruntime with its own thread. by registering an executor, it can beterminated when this runtime is released.",
	"Method": "void registerV8Executor(V8Object key,V8Executor executor){\r\n    checkThread();\r\n    if (executors == null) {\r\n        executors = new V8Map<V8Executor>();\r\n    }\r\n    executors.put(key, executor);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.sheet.StylesheetInfo.getStylesheet",
	"Comment": "gets the stylesheet attribute of the stylesheetinfo object",
	"Method": "Stylesheet getStylesheet(){\r\n    return stylesheet;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Array.getType",
	"Comment": "gets the type of a subset of the array. the subset is specified by a start indexand a length. undefined is returned if all the elements in the subset are notof the same type.",
	"Method": "int getType(int index,int getType,int getType,int index,int length,int getType,String key,int getType,int getType,int index,int getType,int index,int length){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    return v8.getType(v8.getV8RuntimePtr(), getHandle(), index, length);\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.getOpenProfileToolbarAnimator",
	"Comment": "this method creates and setups animator which shows profile toolbar.",
	"Method": "Animator getOpenProfileToolbarAnimator(){\r\n    Animator mOpenProfileToolbarAnimator = ObjectAnimator.ofFloat(mToolbarProfile, View.Y, -mToolbarProfile.getHeight(), 0);\r\n    mOpenProfileToolbarAnimator.addListener(new Animator.AnimatorListener() {\r\n        @Override\r\n        public void onAnimationStart(Animator animation) {\r\n            mToolbarProfile.setX(0);\r\n            mToolbarProfile.bringToFront();\r\n            mToolbarProfile.setVisibility(View.VISIBLE);\r\n            mProfileDetails.setX(0);\r\n            mProfileDetails.bringToFront();\r\n            mProfileDetails.setVisibility(View.VISIBLE);\r\n            mButtonProfile.setX(mInitialProfileButtonX);\r\n            mButtonProfile.bringToFront();\r\n        }\r\n        @Override\r\n        public void onAnimationEnd(Animator animation) {\r\n            mButtonProfile.startAnimation(mProfileButtonShowAnimation);\r\n            mState = EuclidState.Opened;\r\n        }\r\n        @Override\r\n        public void onAnimationCancel(Animator animation) {\r\n        }\r\n        @Override\r\n        public void onAnimationRepeat(Animator animation) {\r\n        }\r\n    });\r\n    return mOpenProfileToolbarAnimator;\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.getOpenProfileToolbarAnimator",
	"Comment": "this method creates and setups animator which shows profile toolbar.",
	"Method": "Animator getOpenProfileToolbarAnimator(){\r\n    mToolbarProfile.setX(0);\r\n    mToolbarProfile.bringToFront();\r\n    mToolbarProfile.setVisibility(View.VISIBLE);\r\n    mProfileDetails.setX(0);\r\n    mProfileDetails.bringToFront();\r\n    mProfileDetails.setVisibility(View.VISIBLE);\r\n    mButtonProfile.setX(mInitialProfileButtonX);\r\n    mButtonProfile.bringToFront();\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.getOpenProfileToolbarAnimator",
	"Comment": "this method creates and setups animator which shows profile toolbar.",
	"Method": "Animator getOpenProfileToolbarAnimator(){\r\n    mButtonProfile.startAnimation(mProfileButtonShowAnimation);\r\n    mState = EuclidState.Opened;\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.getOpenProfileToolbarAnimator",
	"Comment": "this method creates and setups animator which shows profile toolbar.",
	"Method": "Animator getOpenProfileToolbarAnimator(){\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.getOpenProfileToolbarAnimator",
	"Comment": "this method creates and setups animator which shows profile toolbar.",
	"Method": "Animator getOpenProfileToolbarAnimator(){\r\n}"
}, {
	"Path": "org.javaee7.cdi.dynamic.interceptor.extension.DynamicHelloInterceptor.getInterceptorBindings",
	"Comment": "the intercept binding this dynamic interceptor is doing its work for",
	"Method": "Set<Annotation> getInterceptorBindings(){\r\n    return singleton((Annotation) new HelloAnnotationLiteral());\r\n}"
}, {
	"Path": "com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks.markNodesRemovedIfUnreachable",
	"Comment": "removes nodes if all edges are not accessible. i.e. removes zero degree nodes.",
	"Method": "void markNodesRemovedIfUnreachable(){\r\n    EdgeExplorer edgeExplorer = ghStorage.createEdgeExplorer();\r\n    for (int nodeIndex = 0; nodeIndex < ghStorage.getNodes(); nodeIndex++) {\r\n        if (detectNodeRemovedForAllEncoders(edgeExplorer, nodeIndex))\r\n            ghStorage.markNodeRemoved(nodeIndex);\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.util.DistanceCalcEarth.calcNormalizedEdgeDistanceNew",
	"Comment": "new edge distance calculation where no validedgedistance check would be necessary",
	"Method": "double calcNormalizedEdgeDistanceNew(double r_lat_deg,double r_lon_deg,double a_lat_deg,double a_lon_deg,double b_lat_deg,double b_lon_deg,boolean reduceToSegment){\r\n    double shrinkFactor = calcShrinkFactor(a_lat_deg, b_lat_deg);\r\n    double a_lat = a_lat_deg;\r\n    double a_lon = a_lon_deg * shrinkFactor;\r\n    double b_lat = b_lat_deg;\r\n    double b_lon = b_lon_deg * shrinkFactor;\r\n    double r_lat = r_lat_deg;\r\n    double r_lon = r_lon_deg * shrinkFactor;\r\n    double delta_lon = b_lon - a_lon;\r\n    double delta_lat = b_lat - a_lat;\r\n    if (delta_lat == 0)\r\n        return calcNormalizedDist(a_lat_deg, r_lon_deg, r_lat_deg, r_lon_deg);\r\n    if (delta_lon == 0)\r\n        return calcNormalizedDist(r_lat_deg, a_lon_deg, r_lat_deg, r_lon_deg);\r\n    double norm = delta_lon * delta_lon + delta_lat * delta_lat;\r\n    double factor = ((r_lon - a_lon) * delta_lon + (r_lat - a_lat) * delta_lat) / norm;\r\n    if (reduceToSegment) {\r\n        if (factor > 1)\r\n            factor = 1;\r\n        else if (factor < 0)\r\n            factor = 0;\r\n    }\r\n    double c_lon = a_lon + factor * delta_lon;\r\n    double c_lat = a_lat + factor * delta_lat;\r\n    return calcNormalizedDist(c_lat, c_lon / shrinkFactor, r_lat_deg, r_lon_deg);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.XHTMLPanel.getMinFontScale",
	"Comment": "returns the minimum font scaling that may be applied, e.g. 0.5 times assigned font size.",
	"Method": "float getMinFontScale(){\r\n    return minFontScale;\r\n}"
}, {
	"Path": "com.graphhopper.routing.InstructionsOutgoingEdges.outgoingEdgesAreSlowerByFactor",
	"Comment": "checks if the outgoing edges are slower by the provided factor. if they are, this indicates, that we are stayingon the prominent street that one would follow anyway.",
	"Method": "boolean outgoingEdgesAreSlowerByFactor(double factor){\r\n    double tmpSpeed = getSpeed(currentEdge);\r\n    double pathSpeed = getSpeed(prevEdge);\r\n    if (pathSpeed != tmpSpeed || pathSpeed < 1) {\r\n        return false;\r\n    }\r\n    double maxSurroundingSpeed = -1;\r\n    for (EdgeIteratorState edge : allOutgoingEdges) {\r\n        tmpSpeed = getSpeed(edge);\r\n        if (tmpSpeed < 1) {\r\n            return false;\r\n        }\r\n        if (tmpSpeed > maxSurroundingSpeed) {\r\n            maxSurroundingSpeed = tmpSpeed;\r\n        }\r\n    }\r\n    return maxSurroundingSpeed * factor < pathSpeed;\r\n}"
}, {
	"Path": "org.immutables.ordinal.ImmutableOrdinalSet.add",
	"Comment": "will throw an exception and leave the collection unmodified.",
	"Method": "boolean add(E e,Builder<E> add,E element){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Object.executeDoubleFunction",
	"Comment": "invoke a javascript function and return the result as a double. if theresult is not a double, or does not exist, then v8resultundefined is thrown.",
	"Method": "double executeDoubleFunction(String name,V8Array parameters,double executeDoubleFunction,String name,V8Array parameters){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    v8.checkRuntime(parameters);\r\n    long parametersHandle = parameters == null ? 0 : parameters.getHandle();\r\n    return v8.executeDoubleFunction(v8.getV8RuntimePtr(), getHandle(), name, parametersHandle);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.layout.SharedContext.isPaged",
	"Comment": "returns true if the currently set media type is paged. currently returnstrue only for print , projection , and embossed ,handheld , and tv . see the media section of the css2.1 spec for more information on media types.",
	"Method": "boolean isPaged(){\r\n    if (media.equals(\"print\")) {\r\n        return true;\r\n    }\r\n    if (media.equals(\"projection\")) {\r\n        return true;\r\n    }\r\n    if (media.equals(\"embossed\")) {\r\n        return true;\r\n    }\r\n    if (media.equals(\"handheld\")) {\r\n        return true;\r\n    }\r\n    if (media.equals(\"tv\")) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.spotify.helios.cli.command.JobCreateCommandTest.testAddMetadataFromJsonFile",
	"Comment": "check that metadata from json file and cli switch is merged correctly. metadata from cliswitch takes precedence over those from json file.",
	"Method": "void testAddMetadataFromJsonFile(){\r\n    when(options.getString(\"id\")).thenReturn(JOB_ID);\r\n    when(options.getString(\"image\")).thenReturn(\"foobar\");\r\n    when(options.get(\"file\")).thenReturn(new File(\"src/test/resources/job_config_extra_metadata.json\"));\r\n    final List<Object> value = new ArrayList();\r\n    value.add(\"baz=qux2\");\r\n    when(options.getList(\"metadata\")).thenReturn(value);\r\n    assertEquals(0, runCommand());\r\n    final Map<String, String> of = ImmutableMap.of(\"foo\", \"bar\", \"baz\", \"qux2\");\r\n    verify(client).createJob(argThat(hasMetadata(equalTo(of))));\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Locker.checkThread",
	"Comment": "checks if the locker has access to the current thread.if the locker holds a different thread, than an erroris thrown.",
	"Method": "void checkThread(){\r\n    if (released && (thread == null)) {\r\n        throw new Error(\"Invalid V8 thread access: the locker has been released!\");\r\n    }\r\n    if ((thread != Thread.currentThread())) {\r\n        throw new Error(\"Invalid V8 thread access: current thread is \" + Thread.currentThread() + \" while the locker has thread \" + thread);\r\n    }\r\n}"
}, {
	"Path": "stest.tron.wallet.common.client.utils.Sha256Hash.getBytes",
	"Comment": "returns the internal byte array, without defensively copying. therefore do not modify thereturned array.",
	"Method": "byte[] getBytes(){\r\n    return bytes;\r\n}"
}, {
	"Path": "com.graphhopper.storage.EdgeAccess.distToInt",
	"Comment": "translates double distance to integer in order to save it in a dataaccess object",
	"Method": "int distToInt(double distance){\r\n    int integ = (int) (distance * INT_DIST_FACTOR);\r\n    if (integ < 0)\r\n        throw new IllegalArgumentException(\"Distance cannot be negative: \" + distance);\r\n    if (integ >= Integer.MAX_VALUE)\r\n        return Integer.MAX_VALUE;\r\n    return integ;\r\n}"
}, {
	"Path": "org.immutables.value.processor.meta.Constitution.typeAbstract",
	"Comment": "actual abstract value type that is definitive model for the value type.",
	"Method": "NameForms typeAbstract(){\r\n    if (protoclass().kind().isConstructor()) {\r\n        return typeValue();\r\n    }\r\n    List<String> classSegments = Lists.newArrayListWithExpectedSize(2);\r\n    Element e = SourceNames.collectClassSegments(protoclass().sourceElement(), classSegments);\r\n    verify(e instanceof PackageElement);\r\n    String packageOf = ((PackageElement) e).getQualifiedName().toString();\r\n    String relative = DOT_JOINER.join(classSegments);\r\n    boolean relativeAlreadyQualified = false;\r\n    if (!implementationPackage().equals(packageOf)) {\r\n        relative = DOT_JOINER.join(packageOf, relative);\r\n        relativeAlreadyQualified = true;\r\n    }\r\n    return ImmutableConstitution.NameForms.builder().simple(names().typeAbstract).relativeRaw(relative).packageOf(packageOf).genericArgs(generics().args()).relativeAlreadyQualified(relativeAlreadyQualified).visibility(protoclass().visibility()).build();\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.value.FSCssValue.setFloatValue",
	"Comment": "not supported, class is immutable. a method to set the float value with aspecified unit.",
	"Method": "void setFloatValue(short unitType,float floatValue){\r\n    throw new XRRuntimeException(\"FSCssValue is immutable.\");\r\n}"
}, {
	"Path": "com.notnoop.apns.ApnsServiceBuilder.withCacheLength",
	"Comment": "specify the number of notifications to cache for error purposes.default is 100",
	"Method": "ApnsServiceBuilder withCacheLength(int cacheLength){\r\n    this.cacheLength = cacheLength;\r\n    return this;\r\n}"
}, {
	"Path": "org.immutables.value.processor.meta.ValueType.gsonTypeAdapters",
	"Comment": "should be called when it is known that there type adapters generation provided.",
	"Method": "GsonMirrors.TypeAdapters gsonTypeAdapters(){\r\n    return constitution.protoclass().gsonTypeAdapters().get();\r\n}"
}, {
	"Path": "org.tron.common.crypto.ECKey.doSign",
	"Comment": "signs the given hash and returns the r and s components as bigintegers and putdata them inecdsasignature",
	"Method": "ECDSASignature doSign(byte[] input){\r\n    if (input.length != 32) {\r\n        throw new IllegalArgumentException(\"Expected 32 byte input to \" + \"ECDSA signature, not \" + input.length);\r\n    }\r\n    if (privKey == null) {\r\n        throw new MissingPrivateKeyException();\r\n    }\r\n    if (privKey instanceof BCECPrivateKey) {\r\n        ECDSASigner signer = new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest()));\r\n        ECPrivateKeyParameters privKeyParams = new ECPrivateKeyParameters(((BCECPrivateKey) privKey).getD(), CURVE);\r\n        signer.init(true, privKeyParams);\r\n        BigInteger[] components = signer.generateSignature(input);\r\n        return new ECDSASignature(components[0], components[1]).toCanonicalised();\r\n    } else {\r\n        try {\r\n            final Signature ecSig = ECSignatureFactory.getRawInstance(provider);\r\n            ecSig.initSign(privKey);\r\n            ecSig.update(input);\r\n            final byte[] derSignature = ecSig.sign();\r\n            return ECDSASignature.decodeFromDER(derSignature).toCanonicalised();\r\n        } catch (SignatureException | InvalidKeyException ex) {\r\n            throw new RuntimeException(\"ECKey signing error\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.JavaInputAstVisitor.visitAndBreakModifiers",
	"Comment": "output combined modifiers and annotations and the trailing break.",
	"Method": "void visitAndBreakModifiers(ModifiersTree modifiers,Direction annotationDirection,Optional<BreakTag> declarationAnnotationBreak){\r\n    builder.addAll(visitModifiers(modifiers, annotationDirection, declarationAnnotationBreak));\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeCreateActuatorTest.sameTokenNameCloseSecondTokenNotExist",
	"Comment": "sametokenname close,not trx,ont token is ok, but the second one is not exist.",
	"Method": "void sameTokenNameCloseSecondTokenNotExist(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(0);\r\n    String firstTokenId = \"abc\";\r\n    long firstTokenBalance = 100_000_000_000000L;\r\n    String secondTokenId = \"def\";\r\n    long secondTokenBalance = 100_000_000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    accountCapsule.addAssetAmount(firstTokenId.getBytes(), firstTokenBalance);\r\n    accountCapsule.setBalance(10000_000000L);\r\n    dbManager.getAccountStore().put(ownerAddress, accountCapsule);\r\n    ExchangeCreateActuator actuator = new ExchangeCreateActuator(getContract(OWNER_ADDRESS_FIRST, firstTokenId, firstTokenBalance, secondTokenId, secondTokenBalance), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    Assert.assertEquals(dbManager.getDynamicPropertiesStore().getLatestExchangeNum(), 0);\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        fail();\r\n    } catch (ContractValidateException e) {\r\n        Assert.assertTrue(e instanceof ContractValidateException);\r\n        Assert.assertEquals(\"second token balance is not enough\", e.getMessage());\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    }\r\n}"
}, {
	"Path": "org.xhtmlrenderer.layout.SharedContext.getMmPerPx",
	"Comment": "gets the dpi attribute in a more useful form of the renderingcontext object",
	"Method": "float getMmPerPx(){\r\n    return this.mm_per_dot;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.SwingReplacedElementFactory.lookupImageReplacedElement",
	"Comment": "retrieves a replacedelement for an image from cache, or null if not found.",
	"Method": "ReplacedElement lookupImageReplacedElement(Element elem,String ruri,int cssWidth,int cssHeight,ReplacedElement lookupImageReplacedElement,Element e,String uri){\r\n    return lookupImageReplacedElement(e, uri, -1, -1);\r\n}"
}, {
	"Path": "com.graphhopper.reader.osm.OSMReader.getTmpLatitude",
	"Comment": "todo remove this ugly stuff via better preparsing phase! e.g. putting every tags etc into a helper file!",
	"Method": "double getTmpLatitude(int id){\r\n    if (id == EMPTY_NODE)\r\n        return Double.NaN;\r\n    if (id < TOWER_NODE) {\r\n        id = -id - 3;\r\n        return nodeAccess.getLatitude(id);\r\n    } else if (id > -TOWER_NODE) {\r\n        id = id - 3;\r\n        return pillarInfo.getLatitude(id);\r\n    } else\r\n        return Double.NaN;\r\n}"
}, {
	"Path": "org.kie.dmn.model.v1_1.KieDMNModelInstrumentedBase.getLocation",
	"Comment": "returns an approximated location of the xml origin for this dmn model node.",
	"Method": "Location getLocation(){\r\n    return location;\r\n}"
}, {
	"Path": "com.graphhopper.PathWrapper.getWaypoints",
	"Comment": "this method returns the input points snapped to the road network.",
	"Method": "PointList getWaypoints(){\r\n    check(\"getWaypoints\");\r\n    return waypointList;\r\n}"
}, {
	"Path": "com.spotify.helios.cli.command.JobCreateCommandTest.testMetadataPicksUpEnvVars",
	"Comment": "test that when the environment variables we have defaults for are set, they are picked up inthe job metadata.",
	"Method": "void testMetadataPicksUpEnvVars(){\r\n    envVars.put(\"GIT_COMMIT\", \"abcdef1234\");\r\n    when(options.getString(\"id\")).thenReturn(JOB_ID);\r\n    when(options.getString(\"image\")).thenReturn(\"spotify/busybox:latest\");\r\n    when(options.getList(\"metadata\")).thenReturn(Lists.<Object>newArrayList(\"foo=bar\"));\r\n    final int ret = runCommand();\r\n    assertEquals(0, ret);\r\n    final String output = baos.toString();\r\n    final String expectedOutputPrefix = \"Creating job: \";\r\n    assertThat(output, startsWith(expectedOutputPrefix));\r\n    final ObjectMapper objectMapper = new ObjectMapper();\r\n    final String jsonFromOutput = output.split(\"\\n\")[0].substring(expectedOutputPrefix.length());\r\n    final JsonNode jsonNode = objectMapper.readTree(jsonFromOutput);\r\n    final ArrayList<String> fieldNames = Lists.newArrayList(jsonNode.fieldNames());\r\n    assertThat(fieldNames, hasItem(\"metadata\"));\r\n    assertThat(jsonNode.get(\"metadata\").isObject(), equalTo(true));\r\n    final ObjectNode metadataNode = (ObjectNode) jsonNode.get(\"metadata\");\r\n    assertThat(metadataNode.get(\"foo\").asText(), equalTo(\"bar\"));\r\n    assertThat(metadataNode.get(\"GIT_COMMIT\").asText(), equalTo(\"abcdef1234\"));\r\n}"
}, {
	"Path": "com.eclipsesource.v8.debug.ExecutionState.prepareStep",
	"Comment": "indicates to the debugger how to proceed. if not called,the debugger will continue running until the next breakpointis hit.",
	"Method": "void prepareStep(StepAction action){\r\n    V8Array parameters = new V8Array(v8Object.getRuntime());\r\n    parameters.push(action.index);\r\n    try {\r\n        v8Object.executeVoidFunction(PREPARE_STEP, parameters);\r\n    } finally {\r\n        parameters.close();\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.reader.osm.pbf.PbfDecoder.signalUpdate",
	"Comment": "any thread can call this method when they wish to signal another thread that an update hasoccurred.",
	"Method": "void signalUpdate(){\r\n    dataWaitCondition.signal();\r\n}"
}, {
	"Path": "org.xhtmlrenderer.context.StandardAttributeResolver.getClass",
	"Comment": "gets the class attribute of the standardattributeresolver object",
	"Method": "String getClass(Object e){\r\n    return nsh.getClass((Element) e);\r\n}"
}, {
	"Path": "com.notnoop.apns.SimpleApnsNotification.length",
	"Comment": "returns the length of the message in bytes as it is encoded on the wire.apple require the message to be of length 255 bytes or less.",
	"Method": "int length(){\r\n    int length = 1 + 2 + deviceToken.length + 2 + payload.length;\r\n    final int marshalledLength = marshall().length;\r\n    assert marshalledLength == length;\r\n    return length;\r\n}"
}, {
	"Path": "org.kie.dmn.model.v1_2.KieDMNModelInstrumentedBase.getChildren",
	"Comment": "children element references are populated during deserialization, enabling fast access for validation.",
	"Method": "java.util.List<DMNModelInstrumentedBase> getChildren(){\r\n    return Collections.unmodifiableList(children);\r\n}"
}, {
	"Path": "com.yalantis.euclid.library.EuclidActivity.getAvatarShowAnimator",
	"Comment": "this method creates transition animation to move clicked list item under the toolbar.",
	"Method": "Animator getAvatarShowAnimator(int profileDetailsAnimationDelay){\r\n    final Animator mAvatarShowAnimator = ObjectAnimator.ofFloat(mOverlayListItemView, View.Y, mOverlayListItemView.getTop(), mToolbarProfile.getBottom());\r\n    mAvatarShowAnimator.setDuration(profileDetailsAnimationDelay + getAnimationDurationShowProfileDetails());\r\n    mAvatarShowAnimator.setInterpolator(new DecelerateInterpolator());\r\n    return mAvatarShowAnimator;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.context.StandardAttributeResolver.isHover",
	"Comment": "gets the hover attribute of the standardattributeresolver object",
	"Method": "boolean isHover(Object e){\r\n    return ui.isHover((Element) e);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8Array.getBooleans",
	"Comment": "gets the booleans contained in a subset of a v8array. if the subsetcontains elements other than booleans, then a v8resultundefined exceptionis thrown. furthermore, if the subset is not entirely contained within the array,then v8resultundefined exception is also thrown. finally, if the resultarrayis not large enough to hold the results then indexoutofboundsexception is thrown.",
	"Method": "boolean[] getBooleans(int index,int length,int getBooleans,int index,int length,boolean[] resultArray,boolean[] getBooleans,int index,int length,int getBooleans,int index,int length,boolean[] resultArray){\r\n    v8.checkThread();\r\n    checkReleased();\r\n    if (length > resultArray.length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    return v8.arrayGetBooleans(v8.getV8RuntimePtr(), getHandle(), index, length, resultArray);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.executeObjectScript",
	"Comment": "executes a js script on this runtime and returns the result as a v8object.if the result is not a v8object, then a v8resultundefinedexception is thrown.",
	"Method": "V8Object executeObjectScript(String script,V8Object executeObjectScript,String script,String scriptName,int lineNumber){\r\n    checkThread();\r\n    Object result = this.executeScript(script, scriptName, lineNumber);\r\n    if (result instanceof V8Object) {\r\n        return (V8Object) result;\r\n    }\r\n    throw new V8ResultUndefined();\r\n}"
}, {
	"Path": "com.spotify.helios.master.reaper.OldJobReaperTest.jobNotDeployedWithHistoryLastUsedTooLongAgoReaped",
	"Comment": "a job not deployed, with history, and last used too long ago should be reaped.",
	"Method": "void jobNotDeployedWithHistoryLastUsedTooLongAgoReaped(){\r\n    final MasterModel masterModel = mock(MasterModel.class);\r\n    testReap(name.getMethodName(), emptyMap(), events(ImmutableList.of(HOURS.toMillis(20), HOURS.toMillis(22))), null, masterModel, true);\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.JavaInputAstVisitor.visitName",
	"Comment": "helper method for import declarations, names, and qualified names.",
	"Method": "void visitName(Tree node){\r\n    Deque<Name> stack = new ArrayDeque();\r\n    for (; node instanceof MemberSelectTree; node = ((MemberSelectTree) node).getExpression()) {\r\n        stack.addFirst(((MemberSelectTree) node).getIdentifier());\r\n    }\r\n    stack.addFirst(((IdentifierTree) node).getName());\r\n    boolean first = true;\r\n    for (Name name : stack) {\r\n        if (!first) {\r\n            token(\".\");\r\n        }\r\n        token(name.toString());\r\n        first = false;\r\n    }\r\n}"
}, {
	"Path": "org.kie.dmn.model.v1_2.dmndi.DMNStyle.setLabelHorizontalAlignement",
	"Comment": "sets the value of the labelhorizontalalignement property.",
	"Method": "void setLabelHorizontalAlignement(AlignmentKind value){\r\n    this.labelHorizontalAlignement = value;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.css.value.FSCssValue.setCssText",
	"Comment": "not supported, class is immutable. sets the string representation of thecurrent value.",
	"Method": "void setCssText(String cssText){\r\n    this._cssText = cssText;\r\n}"
}, {
	"Path": "com.graphhopper.GraphHopper.setWayPointMaxDistance",
	"Comment": "this parameter specifies how to reduce points via douglas peucker while osm import. highervalue means more details, unit is meter. default is 1. disable via 0.",
	"Method": "GraphHopper setWayPointMaxDistance(double wayPointMaxDistance){\r\n    this.dataReaderWayPointMaxDistance = wayPointMaxDistance;\r\n    return this;\r\n}"
}, {
	"Path": "com.graphhopper.storage.GraphHopperStorage.getGraph",
	"Comment": "this method returns the routing graph for the specified weighting, could be potentiallyfilled with shortcuts.",
	"Method": "T getGraph(Class<T> clazz,Weighting weighting,T getGraph,Class<T> clazz){\r\n    if (clazz.equals(Graph.class))\r\n        return (T) baseGraph;\r\n    if (chGraphs.isEmpty())\r\n        throw new IllegalStateException(\"Cannot find graph implementation for \" + clazz);\r\n    CHGraph cg = chGraphs.iterator().next();\r\n    return (T) cg;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.utils.V8Executor.postMessage",
	"Comment": "posts a message to the receiver to be processed by the executorand sent to the v8 runtime via the messagehandler.",
	"Method": "void postMessage(String message){\r\n    synchronized (this) {\r\n        messageQueue.add(message);\r\n        notify();\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.routing.AlternativeRoute.setMinPlateauFactor",
	"Comment": "this method sets the minimum plateau portion of every alternative path that is required.",
	"Method": "void setMinPlateauFactor(double minPlateauFactor){\r\n    this.minPlateauFactor = minPlateauFactor;\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.SnippetFormatter.format",
	"Comment": "runs the google java formatter on the given source, with only the given ranges specified.",
	"Method": "List<Replacement> format(SnippetKind kind,String source,List<Range<Integer>> ranges,int initialIndent,boolean includeComments){\r\n    RangeSet<Integer> rangeSet = TreeRangeSet.create();\r\n    for (Range<Integer> range : ranges) {\r\n        rangeSet.add(range);\r\n    }\r\n    if (includeComments) {\r\n        if (kind != SnippetKind.COMPILATION_UNIT) {\r\n            throw new IllegalArgumentException(\"comment formatting is only supported for compilation units\");\r\n        }\r\n        return formatter.getFormatReplacements(source, ranges);\r\n    }\r\n    SnippetWrapper wrapper = snippetWrapper(kind, source, initialIndent);\r\n    ranges = offsetRanges(ranges, wrapper.offset);\r\n    String replacement = formatter.formatSource(wrapper.contents.toString(), ranges);\r\n    replacement = replacement.substring(wrapper.offset, replacement.length() - (wrapper.contents.length() - wrapper.offset - source.length()));\r\n    List<Replacement> replacements = toReplacements(source, replacement);\r\n    List<Replacement> filtered = new ArrayList();\r\n    for (Replacement r : replacements) {\r\n        if (rangeSet.encloses(r.getReplaceRange())) {\r\n            filtered.add(r);\r\n        }\r\n    }\r\n    return filtered;\r\n}"
}, {
	"Path": "info.debatty.java.stringsimilarity.WeightedLevenshtein.distance",
	"Comment": "compute levenshtein distance using provided weights for substitution.",
	"Method": "double distance(String s1,String s2,double distance,String s1,String s2,double limit){\r\n    if (s1 == null) {\r\n        throw new NullPointerException(\"s1 must not be null\");\r\n    }\r\n    if (s2 == null) {\r\n        throw new NullPointerException(\"s2 must not be null\");\r\n    }\r\n    if (s1.equals(s2)) {\r\n        return 0;\r\n    }\r\n    if (s1.length() == 0) {\r\n        return s2.length();\r\n    }\r\n    if (s2.length() == 0) {\r\n        return s1.length();\r\n    }\r\n    double[] v0 = new double[s2.length() + 1];\r\n    double[] v1 = new double[s2.length() + 1];\r\n    double[] vtemp;\r\n    v0[0] = 0;\r\n    for (int i = 1; i < v0.length; i++) {\r\n        v0[i] = v0[i - 1] + insertionCost(s2.charAt(i - 1));\r\n    }\r\n    for (int i = 0; i < s1.length(); i++) {\r\n        char s1i = s1.charAt(i);\r\n        double deletion_cost = deletionCost(s1i);\r\n        v1[0] = v0[0] + deletion_cost;\r\n        double minv1 = v1[0];\r\n        for (int j = 0; j < s2.length(); j++) {\r\n            char s2j = s2.charAt(j);\r\n            double cost = 0;\r\n            if (s1i != s2j) {\r\n                cost = charsub.cost(s1i, s2j);\r\n            }\r\n            double insertion_cost = insertionCost(s2j);\r\n            v1[j + 1] = // Cost of insertion\r\n            Math.min(v1[j] + insertion_cost, // Cost of deletion\r\n            Math.min(v0[j + 1] + deletion_cost, v0[j] + cost));\r\n            minv1 = Math.min(minv1, v1[j + 1]);\r\n        }\r\n        if (minv1 >= limit) {\r\n            return limit;\r\n        }\r\n        vtemp = v0;\r\n        v0 = v1;\r\n        v1 = vtemp;\r\n    }\r\n    return v0[s2.length()];\r\n}"
}, {
	"Path": "com.graphhopper.routing.lm.LMAlgoFactoryDecorator.addWeighting",
	"Comment": "decouple weightings from preparelandmarks as we need weightings for the graphstorage and thegraphstorage for the preparation.",
	"Method": "LMAlgoFactoryDecorator addWeighting(String weighting,LMAlgoFactoryDecorator addWeighting,Weighting weighting){\r\n    weightings.add(weighting);\r\n    return this;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.executeDoubleScript",
	"Comment": "executes a js script on this runtime and returns the result as a double.if the result is not a double, then a v8resultundefinedexception is thrown.",
	"Method": "double executeDoubleScript(String script,double executeDoubleScript,String script,String scriptName,int lineNumber,double executeDoubleScript,long v8RuntimePtr,String script,String scriptName,int lineNumber){\r\n    return _executeDoubleScript(v8RuntimePtr, script, scriptName, lineNumber);\r\n}"
}, {
	"Path": "org.tron.core.actuator.ExchangeWithdrawActuatorTest.SameTokenNameOpenSuccessExchangeWithdraw2",
	"Comment": "sametokenname open, second withdraw exchange,result is success.",
	"Method": "void SameTokenNameOpenSuccessExchangeWithdraw2(){\r\n    dbManager.getDynamicPropertiesStore().saveAllowSameTokenName(1);\r\n    InitExchangeSameTokenNameActive();\r\n    long exchangeId = 2;\r\n    String firstTokenId = \"_\";\r\n    long firstTokenQuant = 1_000_000_000000L;\r\n    String secondTokenId = \"456\";\r\n    long secondTokenQuant = 4_000_000L;\r\n    byte[] ownerAddress = ByteArray.fromHexString(OWNER_ADDRESS_FIRST);\r\n    AccountCapsule accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n    Map<String, Long> assetV2Map = accountCapsule.getAssetMapV2();\r\n    Assert.assertEquals(10000_000000L, accountCapsule.getBalance());\r\n    Assert.assertEquals(null, assetV2Map.get(secondTokenId));\r\n    ExchangeWithdrawActuator actuator = new ExchangeWithdrawActuator(getContract(OWNER_ADDRESS_FIRST, exchangeId, firstTokenId, firstTokenQuant), dbManager);\r\n    TransactionResultCapsule ret = new TransactionResultCapsule();\r\n    try {\r\n        actuator.validate();\r\n        actuator.execute(ret);\r\n        Assert.assertEquals(ret.getInstance().getRet(), code.SUCESS);\r\n        ExchangeCapsule exchangeCapsuleV2 = dbManager.getExchangeV2Store().get(ByteArray.fromLong(exchangeId));\r\n        Assert.assertNotNull(exchangeCapsuleV2);\r\n        Assert.assertEquals(ByteString.copyFrom(ownerAddress), exchangeCapsuleV2.getCreatorAddress());\r\n        Assert.assertEquals(exchangeId, exchangeCapsuleV2.getID());\r\n        Assert.assertEquals(1000000, exchangeCapsuleV2.getCreateTime());\r\n        Assert.assertTrue(Arrays.equals(firstTokenId.getBytes(), exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(firstTokenId, ByteArray.toStr(exchangeCapsuleV2.getFirstTokenId()));\r\n        Assert.assertEquals(0L, exchangeCapsuleV2.getFirstTokenBalance());\r\n        Assert.assertEquals(secondTokenId, ByteArray.toStr(exchangeCapsuleV2.getSecondTokenId()));\r\n        Assert.assertEquals(0L, exchangeCapsuleV2.getSecondTokenBalance());\r\n        accountCapsule = dbManager.getAccountStore().get(ownerAddress);\r\n        assetV2Map = accountCapsule.getAssetMapV2();\r\n        Assert.assertEquals(firstTokenQuant + 10000_000000L, accountCapsule.getBalance());\r\n        Assert.assertEquals(10_000_000L, assetV2Map.get(secondTokenId).longValue());\r\n    } catch (ContractValidateException e) {\r\n        logger.info(e.getMessage());\r\n        Assert.assertFalse(e instanceof ContractValidateException);\r\n    } catch (ContractExeException e) {\r\n        Assert.assertFalse(e instanceof ContractExeException);\r\n    } catch (ItemNotFoundException e) {\r\n        Assert.assertFalse(e instanceof ItemNotFoundException);\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.routing.lm.LMAlgoFactoryDecorator.createPreparations",
	"Comment": "this method creates the landmark storages ready for landmark creation.",
	"Method": "void createPreparations(GraphHopperStorage ghStorage,LocationIndex locationIndex){\r\n    if (!isEnabled() || !preparations.isEmpty())\r\n        return;\r\n    if (weightings.isEmpty())\r\n        throw new IllegalStateException(\"No landmark weightings found\");\r\n    List<LandmarkSuggestion> lmSuggestions = new ArrayList(lmSuggestionsLocations.size());\r\n    if (!lmSuggestionsLocations.isEmpty()) {\r\n        try {\r\n            for (String loc : lmSuggestionsLocations) {\r\n                lmSuggestions.add(LandmarkSuggestion.readLandmarks(loc, locationIndex));\r\n            }\r\n        } catch (IOException ex) {\r\n            throw new RuntimeException(ex);\r\n        }\r\n    }\r\n    for (Weighting weighting : getWeightings()) {\r\n        Double maximumWeight = maximumWeights.get(weighting.getName());\r\n        if (maximumWeight == null)\r\n            throw new IllegalStateException(\"maximumWeight cannot be null. Default should be just negative. \" + \"Couldn't find \" + weighting.getName() + \" in \" + maximumWeights);\r\n        PrepareLandmarks tmpPrepareLM = new PrepareLandmarks(ghStorage.getDirectory(), ghStorage, weighting, landmarkCount, activeLandmarkCount).setLandmarkSuggestions(lmSuggestions).setMaximumWeight(maximumWeight).setLogDetails(logDetails);\r\n        if (minNodes > 1)\r\n            tmpPrepareLM.setMinimumNodes(minNodes);\r\n        addPreparation(tmpPrepareLM);\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.shutdownExecutors",
	"Comment": "shutdown all executors associated with this runtime.if force terminate is specified, it will forcefully terminatethe executors, otherwise it will simply signal that theyshould terminate.",
	"Method": "void shutdownExecutors(boolean forceTerminate){\r\n    checkThread();\r\n    if (executors == null) {\r\n        return;\r\n    }\r\n    for (V8Executor executor : executors.values()) {\r\n        if (forceTerminate) {\r\n            executor.forceTermination();\r\n        } else {\r\n            executor.shutdown();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.util.details.AbstractPathDetailsBuilder.startInterval",
	"Comment": "it is only possible to open one interval at a time. calling startinterval whenthe interval is already open results in an exception.",
	"Method": "void startInterval(int firstIndex){\r\n    Object value = getCurrentValue();\r\n    if (isOpen)\r\n        throw new IllegalStateException(\"PathDetailsBuilder is already in an open state with value: \" + currentDetail.getValue() + \" trying to open a new one with value: \" + value);\r\n    currentDetail = new PathDetail(value);\r\n    currentDetail.setFirst(firstIndex);\r\n    isOpen = true;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.NaiveUserAgent.openConnection",
	"Comment": "opens a connections to uri.this can be overwritten to customize handling of connections by type.",
	"Method": "URLConnection openConnection(String uri){\r\n    URLConnection connection = new URL(uri).openConnection();\r\n    if (connection instanceof HttpURLConnection) {\r\n        connection = onHttpConnection((HttpURLConnection) connection);\r\n    }\r\n    return connection;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.extend.XhtmlCssOnlyNamespaceHandler.getLinkUri",
	"Comment": "gets the linkuri attribute of the xhtmlnamespacehandler object",
	"Method": "String getLinkUri(org.w3c.dom.Element e){\r\n    String href = null;\r\n    if (e.getNodeName().equalsIgnoreCase(\"a\") && e.hasAttribute(\"href\")) {\r\n        href = e.getAttribute(\"href\");\r\n    }\r\n    return href;\r\n}"
}, {
	"Path": "com.graphhopper.GraphHopper.setTraversalMode",
	"Comment": "sets the default traversal mode used for the algorithms and preparation.",
	"Method": "GraphHopper setTraversalMode(TraversalMode traversalMode){\r\n    this.traversalMode = traversalMode;\r\n    return this;\r\n}"
}, {
	"Path": "org.immutables.check.ObjectChecker.anyOf",
	"Comment": "evaluates to true if any of the passed in matchers evaluate to true.",
	"Method": "void anyOf(Matcher<? super T> matchers){\r\n    verifyUsingMatcher(CoreMatchers.anyOf(matchers));\r\n}"
}, {
	"Path": "org.immutables.value.processor.meta.ValueAttribute.initAndValidate",
	"Comment": "initialized validates things that were not validated otherwise",
	"Method": "void initAndValidate(InstantiationCreator instantiationCreator){\r\n    initTypeName();\r\n    if (instantiationCreator != null && !isGenerateLazy) {\r\n        this.instantiation = instantiationCreator.tryInstantiateFor(reporter, returnTypeName, names, containingType, isGenerateDefault || isGenerateDerived);\r\n    }\r\n    initTypeKind();\r\n    initOrderKind();\r\n    initBuilderParamsIfApplicable();\r\n    initMiscellaneous();\r\n    initSpecialAnnotations();\r\n    validateTypeAndAnnotations();\r\n    if (supportBuiltinContainerTypes()) {\r\n        initAttributeValueType();\r\n        initImmutableCopyOf();\r\n    }\r\n    initAttributeBuilder();\r\n}"
}, {
	"Path": "com.graphhopper.routing.VirtualEdgeIteratorState.getOriginalTraversalKey",
	"Comment": "this method returns the original edge via its traversal key. i.e. also the direction isalready correctly encoded.",
	"Method": "int getOriginalTraversalKey(){\r\n    return originalTraversalKey;\r\n}"
}, {
	"Path": "com.graphhopper.reader.dem.AbstractTiffElevationProvider.downloadFile",
	"Comment": "download a file at the provided url and save it as the given downloadfile if the downloadfile does not exist.",
	"Method": "void downloadFile(File downloadFile,String url){\r\n    if (!downloadFile.exists()) {\r\n        int max = 3;\r\n        for (int trial = 0; trial < max; trial++) {\r\n            try {\r\n                downloader.downloadFile(url, downloadFile.getAbsolutePath());\r\n                return;\r\n            } catch (SocketTimeoutException ex) {\r\n                if (trial >= max - 1)\r\n                    throw new RuntimeException(ex);\r\n                try {\r\n                    Thread.sleep(sleep);\r\n                } catch (InterruptedException ignored) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.EncodingManager.handleWayTags",
	"Comment": "processes way properties of different kind to determine speed and direction. properties aredirectly encoded in 8 bytes.",
	"Method": "long handleWayTags(ReaderWay way,long includeWay,long relationFlags){\r\n    long flags = 0;\r\n    for (AbstractFlagEncoder encoder : edgeEncoders) {\r\n        flags |= encoder.handleWayTags(way, includeWay, relationFlags & encoder.getRelBitMask());\r\n    }\r\n    return flags;\r\n}"
}, {
	"Path": "com.notnoop.apns.integration.ApnsConnectionCacheTest.handleReTransmissionError1Bad",
	"Comment": "test to make sure single rejected notifications are returned",
	"Method": "void handleReTransmissionError1Bad(){\r\n    server = new ApnsServerStub(FixedCertificates.serverContext().getServerSocketFactory());\r\n    final CountDownLatch sync = new CountDownLatch(1);\r\n    final AtomicInteger numError = new AtomicInteger();\r\n    final AtomicInteger numStartSend = new AtomicInteger();\r\n    int EXPECTED_ERROR_COUNT = 1;\r\n    server.getWaitForError().acquire();\r\n    server.start();\r\n    ApnsService service = APNS.newService().withSSLContext(clientContext()).withGatewayDestination(LOCALHOST, server.getEffectiveGatewayPort()).withDelegate(new StartSendingApnsDelegate() {\r\n        public void startSending(final ApnsNotification message, final boolean resent) {\r\n            if (!resent) {\r\n                numStartSend.incrementAndGet();\r\n            }\r\n        }\r\n        public void messageSent(ApnsNotification message, boolean resent) {\r\n        }\r\n        public void messageSendFailed(ApnsNotification message, Throwable e) {\r\n            numError.incrementAndGet();\r\n            sync.countDown();\r\n        }\r\n        public void connectionClosed(DeliveryError e, int messageIdentifier) {\r\n        }\r\n        public void cacheLengthExceeded(int newCacheLength) {\r\n        }\r\n        public void notificationsResent(int resendCount) {\r\n        }\r\n    }).build();\r\n    server.stopAt(eMsg1.length());\r\n    service.push(eMsg1);\r\n    server.sendError(8, eMsg1.getIdentifier());\r\n    server.getWaitForError().release();\r\n    server.getMessages().acquire();\r\n    sync.await();\r\n    Assert.assertEquals(EXPECTED_ERROR_COUNT, numError.get());\r\n    Assert.assertEquals(EXPECTED_ERROR_COUNT, numStartSend.get());\r\n}"
}, {
	"Path": "com.notnoop.apns.integration.ApnsConnectionCacheTest.handleReTransmissionError1Bad",
	"Comment": "test to make sure single rejected notifications are returned",
	"Method": "void handleReTransmissionError1Bad(){\r\n    if (!resent) {\r\n        numStartSend.incrementAndGet();\r\n    }\r\n}"
}, {
	"Path": "com.notnoop.apns.integration.ApnsConnectionCacheTest.handleReTransmissionError1Bad",
	"Comment": "test to make sure single rejected notifications are returned",
	"Method": "void handleReTransmissionError1Bad(){\r\n}"
}, {
	"Path": "com.notnoop.apns.integration.ApnsConnectionCacheTest.handleReTransmissionError1Bad",
	"Comment": "test to make sure single rejected notifications are returned",
	"Method": "void handleReTransmissionError1Bad(){\r\n    numError.incrementAndGet();\r\n    sync.countDown();\r\n}"
}, {
	"Path": "com.notnoop.apns.integration.ApnsConnectionCacheTest.handleReTransmissionError1Bad",
	"Comment": "test to make sure single rejected notifications are returned",
	"Method": "void handleReTransmissionError1Bad(){\r\n}"
}, {
	"Path": "com.notnoop.apns.integration.ApnsConnectionCacheTest.handleReTransmissionError1Bad",
	"Comment": "test to make sure single rejected notifications are returned",
	"Method": "void handleReTransmissionError1Bad(){\r\n}"
}, {
	"Path": "com.notnoop.apns.integration.ApnsConnectionCacheTest.handleReTransmissionError1Bad",
	"Comment": "test to make sure single rejected notifications are returned",
	"Method": "void handleReTransmissionError1Bad(){\r\n}"
}, {
	"Path": "com.graphhopper.reader.ReaderElement.hasTag",
	"Comment": "check a number of tags in the given order for the any of the given values. used to parsehierarchical access restrictions",
	"Method": "boolean hasTag(String key,Object value,boolean hasTag,String key,String values,boolean hasTag,String key,Set<String> values,boolean hasTag,List<String> keyList,Set<String> values){\r\n    for (String key : keyList) {\r\n        if (values.contains(getTag(key, \"\")))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.graphhopper.routing.lm.LandmarkStorage.setMinimumNodes",
	"Comment": "this method sets the required number of nodes of a subnetwork for which landmarks should be calculated. everysubnetwork below this count will be ignored.",
	"Method": "void setMinimumNodes(int minimumNodes){\r\n    this.minimumNodes = minimumNodes;\r\n}"
}, {
	"Path": "com.graphhopper.coll.SparseIntIntArray.remove",
	"Comment": "removes the mapping from the specified key, if there was any.",
	"Method": "void remove(int key){\r\n    int i = binarySearch(mKeys, 0, mSize, key);\r\n    if (i >= 0 && mValues[i] != DELETED) {\r\n        mValues[i] = DELETED;\r\n        mGarbage = true;\r\n    }\r\n}"
}, {
	"Path": "org.immutables.ordinal.ImmutableOrdinalSet.clear",
	"Comment": "will throw an exception and leave the collection unmodified.",
	"Method": "void clear(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.graphhopper.storage.BaseGraph.ensureNodeIndex",
	"Comment": "check if byte capacity of dataacess nodes object is sufficient to include node index, elseextend byte capacity",
	"Method": "void ensureNodeIndex(int nodeIndex){\r\n    if (!initialized)\r\n        throw new AssertionError(\"The graph has not yet been initialized.\");\r\n    if (nodeIndex < nodeCount)\r\n        return;\r\n    long oldNodes = nodeCount;\r\n    nodeCount = nodeIndex + 1;\r\n    boolean capacityIncreased = nodes.ensureCapacity((long) nodeCount * nodeEntryBytes);\r\n    if (capacityIncreased) {\r\n        long newBytesCapacity = nodes.getCapacity();\r\n        initNodeRefs(oldNodes * nodeEntryBytes, newBytesCapacity);\r\n    }\r\n}"
}, {
	"Path": "com.spotify.helios.testing.TemporaryJobs.removeOldJobs",
	"Comment": "undeploys and deletes jobs leftover from previous runs of temporaryjobs. this would happen ifthe test was terminated before the cleanup code was called. this method will iterate over eachfile in the specified directory. each filename is the prefix that was used for job namesduring previous runs. the method will undeploy and delete any jobs that have a matchingprefix, and the delete the file. if the file is locked, it is currently in use, and will beskipped.",
	"Method": "void removeOldJobs(){\r\n    if (removedOldJobs) {\r\n        return;\r\n    }\r\n    final File[] files = prefixDirectory.toFile().listFiles();\r\n    if (files == null || files.length == 0) {\r\n        return;\r\n    }\r\n    log.info(\"Removing old temporary jobs\");\r\n    final Map<JobId, Job> jobs = client.jobs(jobPrefixFile.prefix()).get();\r\n    for (final File file : files) {\r\n        if (file.getName().endsWith(\".tmp\") || file.isDirectory()) {\r\n            continue;\r\n        }\r\n        try (JobPrefixFile prefixFile = JobPrefixFile.tryFromExistingFile(file.toPath())) {\r\n            if (prefixFile == null) {\r\n                log.debug(\"Unable to create JobPrefixFile for {}\", file.getPath());\r\n                continue;\r\n            }\r\n            boolean jobRemovalFailed = false;\r\n            for (final Map.Entry<JobId, Job> entry : jobs.entrySet()) {\r\n                final JobId jobId = entry.getKey();\r\n                if (!jobId.getName().startsWith(prefixFile.prefix())) {\r\n                    continue;\r\n                }\r\n                final JobStatus status = client.jobStatus(entry.getKey()).get();\r\n                final List<String> hosts = ImmutableList.copyOf(status.getDeployments().keySet());\r\n                final List<AssertionError> errors = undeploy(client, entry.getValue(), hosts, new ArrayList<AssertionError>());\r\n                if (!errors.isEmpty()) {\r\n                    jobRemovalFailed = true;\r\n                }\r\n            }\r\n            if (!jobRemovalFailed) {\r\n                prefixFile.delete();\r\n            }\r\n        } catch (NoSuchFileException e) {\r\n            log.debug(\"File {} already processed by somebody else.\", file.getPath());\r\n        } catch (Exception e) {\r\n            log.warn(\"Exception processing file {}\", file.getPath(), e);\r\n        }\r\n    }\r\n    removedOldJobs = true;\r\n}"
}, {
	"Path": "com.notnoop.apns.PayloadBuilder.build",
	"Comment": "returns the json string representation of the payloadaccording to apple apns specification",
	"Method": "String build(){\r\n    if (!root.containsKey(\"mdm\")) {\r\n        insertCustomAlert();\r\n        root.put(\"aps\", aps);\r\n    }\r\n    try {\r\n        return mapper.writeValueAsString(root);\r\n    } catch (final Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.google.googlejavaformat.java.ModifierOrderer.reorderModifiers",
	"Comment": "reorders all modifiers in the given text and within the given character ranges to be in jlsorder.",
	"Method": "JavaInput reorderModifiers(String text,JavaInput reorderModifiers,JavaInput javaInput,Collection<Range<Integer>> characterRanges){\r\n    if (javaInput.getTokens().isEmpty()) {\r\n        return javaInput;\r\n    }\r\n    RangeSet<Integer> tokenRanges = javaInput.characterRangesToTokenRanges(characterRanges);\r\n    Iterator<? extends Token> it = javaInput.getTokens().iterator();\r\n    TreeRangeMap<Integer, String> replacements = TreeRangeMap.create();\r\n    while (it.hasNext()) {\r\n        Token token = it.next();\r\n        if (!tokenRanges.contains(token.getTok().getIndex())) {\r\n            continue;\r\n        }\r\n        Modifier mod = asModifier(token);\r\n        if (mod == null) {\r\n            continue;\r\n        }\r\n        List<Token> modifierTokens = new ArrayList();\r\n        List<Modifier> mods = new ArrayList();\r\n        int begin = token.getTok().getPosition();\r\n        mods.add(mod);\r\n        modifierTokens.add(token);\r\n        int end = -1;\r\n        while (it.hasNext()) {\r\n            token = it.next();\r\n            mod = asModifier(token);\r\n            if (mod == null) {\r\n                break;\r\n            }\r\n            mods.add(mod);\r\n            modifierTokens.add(token);\r\n            end = token.getTok().getPosition() + token.getTok().length();\r\n        }\r\n        if (!Ordering.natural().isOrdered(mods)) {\r\n            Collections.sort(mods);\r\n            StringBuilder replacement = new StringBuilder();\r\n            for (int i = 0; i < mods.size(); i++) {\r\n                if (i > 0) {\r\n                    addTrivia(replacement, modifierTokens.get(i).getToksBefore());\r\n                }\r\n                replacement.append(mods.get(i).toString());\r\n                if (i < (modifierTokens.size() - 1)) {\r\n                    addTrivia(replacement, modifierTokens.get(i).getToksAfter());\r\n                }\r\n            }\r\n            replacements.put(Range.closedOpen(begin, end), replacement.toString());\r\n        }\r\n    }\r\n    return applyReplacements(javaInput, replacements);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.removeReleaseHandler",
	"Comment": "removes an existing release handler from the collection of release handlers.if the release handler does not exist in the collection, it is ignored.",
	"Method": "void removeReleaseHandler(V8Runnable handler){\r\n    releaseHandlers.remove(handler);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.XRSimpleLogFormatter.format",
	"Comment": "format the given log record and return the formatted string.",
	"Method": "String format(LogRecord record){\r\n    Throwable th = record.getThrown();\r\n    String thName = \"\";\r\n    String thMessage = \"\";\r\n    String trace = null;\r\n    if (th != null) {\r\n        StringWriter sw = new StringWriter();\r\n        th.printStackTrace(new PrintWriter(sw));\r\n        trace = sw.toString();\r\n        thName = th.getClass().getName();\r\n        thMessage = th.getMessage();\r\n    }\r\n    String[] args = { String.valueOf(record.getMillis()), record.getLoggerName(), record.getLevel().toString(), record.getSourceClassName(), record.getSourceMethodName(), record.getMessage(), thName, thMessage, trace };\r\n    return th == null ? mformat.format(args) : exmformat.format(args);\r\n}"
}, {
	"Path": "org.tron.common.crypto.ECKey.fromPublicOnly",
	"Comment": "creates an eckey that cannot be used for signing, only verifying signatures, from the givenencoded point. the compression state of pub will be preserved.",
	"Method": "ECKey fromPublicOnly(ECPoint pub,ECKey fromPublicOnly,byte[] pub){\r\n    return new ECKey(null, CURVE.getCurve().decodePoint(pub));\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swt.NaiveUserAgent.createImageResource",
	"Comment": "factory method to generate imageresources from a given image. may beoverridden in subclass.",
	"Method": "ImageResource createImageResource(String uri,InputStream is){\r\n    return new ImageResource(uri, new SWTFSImage(new Image(_device, is), this, uri));\r\n}"
}, {
	"Path": "org.tron.common.crypto.ECKey.isCompressed",
	"Comment": "returns whether this key is using the compressed form or not. compressed pubkeys are only 33bytes, not 64.",
	"Method": "boolean isCompressed(){\r\n    return pub.isCompressed();\r\n}"
}, {
	"Path": "com.graphhopper.routing.lm.LandmarkStorage.getFactor",
	"Comment": "the factor is used to convert double values into more compact int values.",
	"Method": "double getFactor(){\r\n    return factor;\r\n}"
}, {
	"Path": "com.graphhopper.routing.util.NameSimilarityEdgeFilterTest.testAcceptWithTypos",
	"Comment": "we ignore typos for now, most geocoders return pretty good results, we might allow some typos",
	"Method": "void testAcceptWithTypos(){\r\n    EdgeFilter edgeFilter = createNameSimilarityEdgeFilter(\"Laufamholzstrae 154 Nrnberg\");\r\n    EdgeIteratorState edge = createTestEdgeIterator(\"Laufamholzstrae, ST1333\");\r\n    assertTrue(edgeFilter.accept(edge));\r\n    edgeFilter = createNameSimilarityEdgeFilter(\"Kaufamholzstrae\");\r\n    assertTrue(edgeFilter.accept(edge));\r\n    edgeFilter = createNameSimilarityEdgeFilter(\"Kaufamholystrae\");\r\n    assertTrue(edgeFilter.accept(edge));\r\n    edgeFilter = createNameSimilarityEdgeFilter(\"Kaufmholystrae\");\r\n    assertFalse(edgeFilter.accept(edge));\r\n    edgeFilter = createNameSimilarityEdgeFilter(\"Hauptstrae\");\r\n    edge = createTestEdgeIterator(\"Hauptstrae\");\r\n    assertTrue(edgeFilter.accept(edge));\r\n    edgeFilter = createNameSimilarityEdgeFilter(\"Hauptstrase\");\r\n    assertTrue(edgeFilter.accept(edge));\r\n    edgeFilter = createNameSimilarityEdgeFilter(\"Lauptstrase\");\r\n}"
}, {
	"Path": "com.notnoop.apns.ApnsServiceBuilder.withProxy",
	"Comment": "specify the proxy to be used to establish the connectionsto apple serversread the java networking and proxies guide to understand theproxies complexity.",
	"Method": "ApnsServiceBuilder withProxy(Proxy proxy){\r\n    this.proxy = proxy;\r\n    return this;\r\n}"
}, {
	"Path": "com.notnoop.apns.EnhancedApnsNotification.length",
	"Comment": "returns the length of the message in bytes as it is encoded on the wire.apple require the message to be of length 255 bytes or less.",
	"Method": "int length(){\r\n    int length = 1 + 4 + 4 + 2 + deviceToken.length + 2 + payload.length;\r\n    final int marshalledLength = marshall().length;\r\n    assert marshalledLength == length;\r\n    return length;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.simple.Graphics2DRenderer.layout",
	"Comment": "lay out the document with the specified dimensions,without rendering.",
	"Method": "void layout(Graphics2D g2,Dimension dim){\r\n    this.dim = dim;\r\n    if (dim != null) {\r\n        panel.setSize(dim);\r\n    }\r\n    panel.doDocumentLayout(g2);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.demo.browser.PanelManager.isVisited",
	"Comment": "returns true if the link has been visited by the user in this session. visit tracking is not persisted.",
	"Method": "boolean isVisited(String uri){\r\n    if (uri == null)\r\n        return false;\r\n    uri = resolveURI(uri);\r\n    return history.contains(uri);\r\n}"
}, {
	"Path": "org.xhtmlrenderer.util.FSImageWriter.getImageWriteParameters",
	"Comment": "returns the image output parameters to control the output image quality, compression, etc. by defaultthis uses the compression values set in this class. override this method to get full control over theimagewriteparam used in image output.",
	"Method": "ImageWriteParam getImageWriteParameters(ImageWriter writer){\r\n    ImageWriteParam param = writer.getDefaultWriteParam();\r\n    if (param.canWriteCompressed()) {\r\n        if (writeCompressionMode != ImageWriteParam.MODE_COPY_FROM_METADATA) {\r\n            param.setCompressionMode(writeCompressionMode);\r\n            if (writeCompressionMode == ImageWriteParam.MODE_EXPLICIT) {\r\n                param.setCompressionType(writeCompressionType);\r\n                param.setCompressionQuality(writeCompressionQuality);\r\n            }\r\n        }\r\n    }\r\n    return param;\r\n}"
}, {
	"Path": "org.immutables.ordinal.ImmutableOrdinalSet.remove",
	"Comment": "will throw an exception and leave the collection unmodified.",
	"Method": "boolean remove(Object object){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.tron.common.crypto.zksnark.BN128G2.create",
	"Comment": "checks whether provided data are coordinates of a point belonging to subgroup,if check has been passed it returns a point, otherwise returns null",
	"Method": "BN128G2 create(byte[] a,byte[] b,byte[] c,byte[] d){\r\n    BN128<Fp2> p = BN128Fp2.create(a, b, c, d);\r\n    if (p == null) {\r\n        return null;\r\n    }\r\n    if (!isGroupMember(p))\r\n        return null;\r\n    return new BN128G2(p);\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.getData",
	"Comment": "returns the data object associated with this runtime, null if no objecthas been associated.",
	"Method": "Object getData(String key){\r\n    if (data == null) {\r\n        return null;\r\n    }\r\n    return data.get(key);\r\n}"
}, {
	"Path": "com.spotify.helios.common.Json.asBytesUnchecked",
	"Comment": "serialize an object to json. use when object is expected to be json serializable.",
	"Method": "byte[] asBytesUnchecked(Object value){\r\n    try {\r\n        return OBJECT_MAPPER.writeValueAsBytes(value);\r\n    } catch (JsonProcessingException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.eclipsesource.v8.V8.addReferenceHandler",
	"Comment": "adds a referencehandler to track when new v8objects are created.",
	"Method": "void addReferenceHandler(ReferenceHandler handler){\r\n    referenceHandlers.add(0, handler);\r\n}"
}, {
	"Path": "com.graphhopper.util.DouglasPeucker.simplify",
	"Comment": "simplifies a part of the points. the fromindex and lastindexare guaranteed to be kept.",
	"Method": "int simplify(PointList points,int simplify,PointList points,int fromIndex,int lastIndex){\r\n    int removed = 0;\r\n    int size = lastIndex - fromIndex;\r\n    if (approx) {\r\n        int delta = 500;\r\n        int segments = size / delta + 1;\r\n        int start = fromIndex;\r\n        for (int i = 0; i < segments; i++) {\r\n            removed += subSimplify(points, start, Math.min(lastIndex, start + delta));\r\n            start += delta;\r\n        }\r\n    } else {\r\n        removed = subSimplify(points, fromIndex, lastIndex);\r\n    }\r\n    if (removed > 0)\r\n        compressNew(points, removed);\r\n    return removed;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.utils.MemoryManager.release",
	"Comment": "releases this memory manager and all v8objects that were created whilethis memory manager was active.",
	"Method": "void release(){\r\n    v8.getLocker().checkThread();\r\n    if (released) {\r\n        return;\r\n    }\r\n    releasing = true;\r\n    try {\r\n        for (V8Value reference : references) {\r\n            reference.close();\r\n        }\r\n        v8.removeReferenceHandler(memoryManagerReferenceHandler);\r\n        references.clear();\r\n    } finally {\r\n        releasing = false;\r\n    }\r\n    released = true;\r\n}"
}, {
	"Path": "com.eclipsesource.v8.debug.mirror.Scope.getScopeObject",
	"Comment": "returns the underlying v8object that represents this scope.",
	"Method": "ObjectMirror getScopeObject(){\r\n    V8Object mirror = null;\r\n    try {\r\n        mirror = v8Object.executeObjectFunction(SCOPE_OBJECT, null);\r\n        return (ObjectMirror) createMirror(mirror);\r\n    } finally {\r\n        if (mirror != null) {\r\n            mirror.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.spotify.helios.cli.TestUtils.readFirstColumnFromOutput",
	"Comment": "get the first column from an output of a table whose entries are separated by newlines andcolumns are separated by spaces.",
	"Method": "List<String> readFirstColumnFromOutput(String output,boolean skipFirstRow){\r\n    final List<String> values = Lists.newArrayList();\r\n    for (final String line : output.split(\"\\n\")) {\r\n        final String col = line.split(\" \")[0];\r\n        values.add(col);\r\n    }\r\n    if (skipFirstRow) {\r\n        return values.subList(1, values.size());\r\n    }\r\n    return values;\r\n}"
}, {
	"Path": "com.graphhopper.storage.GraphEdgeIdFinder.fillEdgeIDs",
	"Comment": "this method fills the edgeids hash with edgeids found inside the specified geometry",
	"Method": "void fillEdgeIDs(GHIntHashSet edgeIds,Geometry geometry,EdgeFilter filter){\r\n    if (geometry instanceof Point) {\r\n        GHPoint point = GHPoint.create((Point) geometry);\r\n        findClosestEdgeToPoint(edgeIds, point, filter);\r\n    } else if (geometry instanceof LineString) {\r\n        PointList pl = PointList.fromLineString((LineString) geometry);\r\n        int lastIdx = pl.size() - 1;\r\n        if (pl.size() >= 2) {\r\n            double meanLat = (pl.getLatitude(0) + pl.getLatitude(lastIdx)) / 2;\r\n            double meanLon = (pl.getLongitude(0) + pl.getLongitude(lastIdx)) / 2;\r\n            findClosestEdge(edgeIds, meanLat, meanLon, filter);\r\n        }\r\n    } else if (geometry instanceof MultiPoint) {\r\n        for (Coordinate coordinate : geometry.getCoordinates()) {\r\n            findClosestEdge(edgeIds, coordinate.y, coordinate.x, filter);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.graphhopper.routing.lm.LandmarkStorage.getWeighting",
	"Comment": "this method returns the weighting for which the landmarks are originally created",
	"Method": "Weighting getWeighting(){\r\n    return weighting;\r\n}"
}, {
	"Path": "com.spotify.helios.master.reaper.OldJobReaperTest.jobDeployedWithHistoryLastUsedRecentlyNotReaped",
	"Comment": "a job deployed, with history, and last used recently should not be reaped.",
	"Method": "void jobDeployedWithHistoryLastUsedRecentlyNotReaped(){\r\n    final MasterModel masterModel = mock(MasterModel.class);\r\n    testReap(name.getMethodName(), deployments(JobId.fromString(name.getMethodName()), 3), events(ImmutableList.of(HOURS.toMillis(20), HOURS.toMillis(40))), null, masterModel, false);\r\n}"
}, {
	"Path": "stest.tron.wallet.common.client.utils.TransactionUtils.validTransaction",
	"Comment": "1. check hash2. check double spent3. check sign4. check balance",
	"Method": "boolean validTransaction(Transaction signedTransaction){\r\n    assert (signedTransaction.getSignatureCount() == signedTransaction.getRawData().getContractCount());\r\n    List<Transaction.Contract> listContract = signedTransaction.getRawData().getContractList();\r\n    byte[] hash = Sha256Hash.hash(signedTransaction.getRawData().toByteArray());\r\n    int count = signedTransaction.getSignatureCount();\r\n    if (count == 0) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < count; ++i) {\r\n        try {\r\n            Transaction.Contract contract = listContract.get(i);\r\n            byte[] owner = getOwner(contract);\r\n            byte[] address = ECKey.signatureToAddress(hash, getBase64FromByteString(signedTransaction.getSignature(i)));\r\n            if (!Arrays.equals(owner, address)) {\r\n                return false;\r\n            }\r\n        } catch (SignatureException e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.xhtmlrenderer.swing.NaiveUserAgent.createImageResource",
	"Comment": "factory method to generate imageresources from a given image. may be overridden in subclass.",
	"Method": "ImageResource createImageResource(String uri,Image img){\r\n    return new ImageResource(uri, AWTFSImage.createImage(img));\r\n}"
}, {
	"Path": "com.spotify.helios.testing.HostPickingStrategies.deterministic",
	"Comment": "for any given invocation returns a random host, but running the same test with the samekey should put jobs on the same hosts as they were the last time.",
	"Method": "HostPickingStrategy deterministic(String key){\r\n    return new RandomHostPickingStrategy(getSeededRandom(key));\r\n}"
}, {
	"Path": "com.graphhopper.routing.subnetwork.SubnetworkStorage.setSubnetwork",
	"Comment": "this method sets the subnetwork if of the specified nodeid. default is 0 and means subnetworkwas too small to be useful to be stored.",
	"Method": "void setSubnetwork(int nodeId,int subnetwork){\r\n    if (subnetwork > 127)\r\n        throw new IllegalArgumentException(\"Number of subnetworks is currently limited to 127 but requested \" + subnetwork);\r\n    byte[] bytes = new byte[1];\r\n    bytes[0] = (byte) subnetwork;\r\n    da.setBytes(nodeId, bytes, bytes.length);\r\n}"
}]