[{
	"Path": "com.github.javaparser.resolution.types.ResolvedReferenceType.getId",
	"Comment": "id of the declaration. it corresponds to the qualified name, unless for local classes.",
	"Method": "String getId(){\r\n    return typeDeclaration.getId();\r\n}"
}, {
	"Path": "org.eclipse.jetty.webapp.WebAppContext.setLogUrlOnStart",
	"Comment": "sets whether or not the web app name and url is logged on startup",
	"Method": "void setLogUrlOnStart(boolean logOnStart){\r\n    this._logUrlOnStart = logOnStart;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.UpgradeRequestAdapter.getUserPrincipal",
	"Comment": "get the user principal for this request.only applicable when using upgraderequest from server side.",
	"Method": "Principal getUserPrincipal(){\r\n    return null;\r\n}"
}, {
	"Path": "com.github.javaparser.GeneratedJavaParserBase.juggleArrayType",
	"Comment": "throws together a type, taking care of all the array brackets",
	"Method": "Type juggleArrayType(Type partialType,List<ArrayType.ArrayBracketPair> additionalBrackets){\r\n    Pair<Type, List<ArrayType.ArrayBracketPair>> partialParts = unwrapArrayTypes(partialType);\r\n    Type elementType = partialParts.a;\r\n    List<ArrayType.ArrayBracketPair> leftMostBrackets = partialParts.b;\r\n    return wrapInArrayTypes(elementType, leftMostBrackets, additionalBrackets).clone();\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.asEnum",
	"Comment": "return this as a enumdeclaration or throw unsupportedoperationexception.",
	"Method": "EnumDeclaration asEnum(){\r\n    throw new UnsupportedOperationException(String.format(\"%s is not an enum\", this));\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.OSGiWebInfConfiguration.findJars",
	"Comment": "consider the fragment bundles associated with the bundle of the webapp being deployed.",
	"Method": "List<Resource> findJars(WebAppContext context){\r\n    List<Resource> mergedResources = new ArrayList();\r\n    List<Resource> webInfJars = super.findJars(context);\r\n    if (webInfJars != null)\r\n        mergedResources.addAll(webInfJars);\r\n    Bundle[] bundles = PackageAdminServiceTracker.INSTANCE.getFragmentsAndRequiredBundles((Bundle) context.getAttribute(OSGiWebappConstants.JETTY_OSGI_BUNDLE));\r\n    if (bundles != null && bundles.length > 0) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Set<Bundle> fragsAndReqsBundles = (Set<Bundle>) context.getAttribute(FRAGMENT_AND_REQUIRED_BUNDLES);\r\n        if (fragsAndReqsBundles == null) {\r\n            fragsAndReqsBundles = new HashSet();\r\n            context.setAttribute(FRAGMENT_AND_REQUIRED_BUNDLES, fragsAndReqsBundles);\r\n        }\r\n        @SuppressWarnings(\"unchecked\")\r\n        Set<Resource> fragsAndReqsResources = (Set<Resource>) context.getAttribute(FRAGMENT_AND_REQUIRED_RESOURCES);\r\n        if (fragsAndReqsResources == null) {\r\n            fragsAndReqsResources = new HashSet();\r\n            context.setAttribute(FRAGMENT_AND_REQUIRED_RESOURCES, fragsAndReqsResources);\r\n        }\r\n        for (Bundle b : bundles) {\r\n            if (b.getState() == Bundle.UNINSTALLED)\r\n                continue;\r\n            fragsAndReqsBundles.add(b);\r\n            File f = BundleFileLocatorHelperFactory.getFactory().getHelper().getBundleInstallLocation(b);\r\n            Resource r = Resource.newResource(f.toURI());\r\n            fragsAndReqsResources.add(r);\r\n            mergedResources.add(r);\r\n        }\r\n    }\r\n    return mergedResources;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.types.ResolvedReferenceType.getAllMethods",
	"Comment": "get a list of all the methods available on this type. this list includes methods declared in this type andmethods inherited. this list includes methods of all sort of visibility. however it does not include methodsthat have been overwritten.",
	"Method": "List<ResolvedMethodDeclaration> getAllMethods(){\r\n    List<ResolvedMethodDeclaration> allMethods = new LinkedList();\r\n    allMethods.addAll(this.getDeclaredMethods().stream().map(MethodUsage::getDeclaration).collect(Collectors.toList()));\r\n    getDirectAncestors().forEach(a -> allMethods.addAll(a.getAllMethods()));\r\n    return allMethods;\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlets.DoSFilter.extractUserId",
	"Comment": "returns the user id, used to track this connection.this should be overridden by subclasses.",
	"Method": "String extractUserId(ServletRequest request){\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.utils.Util.createFilter",
	"Comment": "create an osgi filter for the given classname and server name.",
	"Method": "Filter createFilter(BundleContext bundleContext,String classname,String managedServerName){\r\n    if (StringUtil.isBlank(managedServerName) || managedServerName.equals(OSGiServerConstants.MANAGED_JETTY_SERVER_DEFAULT_NAME)) {\r\n        return bundleContext.createFilter(\"(&(objectclass=\" + classname + \")(|(managedServerName=\" + managedServerName + \")(!(managedServerName=*))))\");\r\n    } else {\r\n        return bundleContext.createFilter(\"(&(objectclass=\" + classname + \")(managedServerName=\" + managedServerName + \"))\");\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.runner.Runner.configure",
	"Comment": "configure a jetty instance and deploy the webapps presented as args",
	"Method": "void configure(String[] args){\r\n    for (int i = 0; i < args.length; i++) {\r\n        if (\"--lib\".equals(args[i])) {\r\n            try (Resource lib = Resource.newResource(args[++i])) {\r\n                if (!lib.exists() || !lib.isDirectory())\r\n                    usage(\"No such lib directory \" + lib);\r\n                _classpath.addJars(lib);\r\n            }\r\n        } else if (\"--jar\".equals(args[i])) {\r\n            try (Resource jar = Resource.newResource(args[++i])) {\r\n                if (!jar.exists() || jar.isDirectory())\r\n                    usage(\"No such jar \" + jar);\r\n                _classpath.addPath(jar);\r\n            }\r\n        } else if (\"--classes\".equals(args[i])) {\r\n            try (Resource classes = Resource.newResource(args[++i])) {\r\n                if (!classes.exists() || !classes.isDirectory())\r\n                    usage(\"No such classes directory \" + classes);\r\n                _classpath.addPath(classes);\r\n            }\r\n        } else if (args[i].startsWith(\"--\"))\r\n            i++;\r\n    }\r\n    initClassLoader();\r\n    LOG.info(\"Runner\");\r\n    LOG.debug(\"Runner classpath {}\", _classpath);\r\n    String contextPath = __defaultContextPath;\r\n    boolean contextPathSet = false;\r\n    int port = __defaultPort;\r\n    String host = null;\r\n    int stopPort = Integer.getInteger(\"STOP.PORT\", 0);\r\n    String stopKey = System.getProperty(\"STOP.KEY\", null);\r\n    boolean runnerServerInitialized = false;\r\n    for (int i = 0; i < args.length; i++) {\r\n        switch(args[i]) {\r\n            case \"--port\":\r\n                port = Integer.parseInt(args[++i]);\r\n                break;\r\n            case \"--host\":\r\n                host = args[++i];\r\n                break;\r\n            case \"--stop-port\":\r\n                stopPort = Integer.parseInt(args[++i]);\r\n                break;\r\n            case \"--stop-key\":\r\n                stopKey = args[++i];\r\n                break;\r\n            case \"--log\":\r\n                _logFile = args[++i];\r\n                break;\r\n            case \"--out\":\r\n                String outFile = args[++i];\r\n                PrintStream out = new PrintStream(new RolloverFileOutputStream(outFile, true, -1));\r\n                LOG.info(\"Redirecting stderr/stdout to \" + outFile);\r\n                System.setErr(out);\r\n                System.setOut(out);\r\n                break;\r\n            case \"--path\":\r\n                contextPath = args[++i];\r\n                contextPathSet = true;\r\n                break;\r\n            case \"--config\":\r\n                if (_configFiles == null)\r\n                    _configFiles = new ArrayList();\r\n                _configFiles.add(args[++i]);\r\n                break;\r\n            case \"--lib\":\r\n                ++i;\r\n                break;\r\n            case \"--jar\":\r\n                ++i;\r\n                break;\r\n            case \"--classes\":\r\n                ++i;\r\n                break;\r\n            case \"--stats\":\r\n                _enableStats = true;\r\n                _statsPropFile = args[++i];\r\n                _statsPropFile = (\"unsecure\".equalsIgnoreCase(_statsPropFile) ? null : _statsPropFile);\r\n                break;\r\n            default:\r\n                if (args[i].startsWith(\"-D\")) {\r\n                    String[] sysProps = args[i].substring(2).split(\"=\", 2);\r\n                    if (\"STOP.KEY\".equals(sysProps[0])) {\r\n                        stopKey = sysProps[1];\r\n                        break;\r\n                    } else if (\"STOP.PORT\".equals(sysProps[0])) {\r\n                        stopPort = Integer.valueOf(sysProps[1]);\r\n                        break;\r\n                    }\r\n                }\r\n                if (!runnerServerInitialized) {\r\n                    if (_server == null) {\r\n                        _server = new Server();\r\n                    }\r\n                    if (_configFiles != null) {\r\n                        for (String cfg : _configFiles) {\r\n                            try (Resource resource = Resource.newResource(cfg)) {\r\n                                XmlConfiguration xmlConfiguration = new XmlConfiguration(resource.getURL());\r\n                                xmlConfiguration.configure(_server);\r\n                            }\r\n                        }\r\n                    }\r\n                    HandlerCollection handlers = (HandlerCollection) _server.getChildHandlerByClass(HandlerCollection.class);\r\n                    if (handlers == null) {\r\n                        handlers = new HandlerCollection();\r\n                        _server.setHandler(handlers);\r\n                    }\r\n                    _contexts = (ContextHandlerCollection) handlers.getChildHandlerByClass(ContextHandlerCollection.class);\r\n                    if (_contexts == null) {\r\n                        _contexts = new ContextHandlerCollection();\r\n                        prependHandler(_contexts, handlers);\r\n                    }\r\n                    if (_enableStats) {\r\n                        if (handlers.getChildHandlerByClass(StatisticsHandler.class) == null) {\r\n                            StatisticsHandler statsHandler = new StatisticsHandler();\r\n                            Handler oldHandler = _server.getHandler();\r\n                            statsHandler.setHandler(oldHandler);\r\n                            _server.setHandler(statsHandler);\r\n                            ServletContextHandler statsContext = new ServletContextHandler(_contexts, \"/stats\");\r\n                            statsContext.addServlet(new ServletHolder(new StatisticsServlet()), \"/\");\r\n                            statsContext.setSessionHandler(new SessionHandler());\r\n                            if (_statsPropFile != null) {\r\n                                HashLoginService loginService = new HashLoginService(\"StatsRealm\", _statsPropFile);\r\n                                Constraint constraint = new Constraint();\r\n                                constraint.setName(\"Admin Only\");\r\n                                constraint.setRoles(new String[] { \"admin\" });\r\n                                constraint.setAuthenticate(true);\r\n                                ConstraintMapping cm = new ConstraintMapping();\r\n                                cm.setConstraint(constraint);\r\n                                cm.setPathSpec(\"/*\");\r\n                                ConstraintSecurityHandler securityHandler = new ConstraintSecurityHandler();\r\n                                securityHandler.setLoginService(loginService);\r\n                                securityHandler.setConstraintMappings(Collections.singletonList(cm));\r\n                                securityHandler.setAuthenticator(new BasicAuthenticator());\r\n                                statsContext.setSecurityHandler(securityHandler);\r\n                            }\r\n                        }\r\n                    }\r\n                    if (handlers.getChildHandlerByClass(DefaultHandler.class) == null) {\r\n                        handlers.addHandler(new DefaultHandler());\r\n                    }\r\n                    Connector[] connectors = _server.getConnectors();\r\n                    if (connectors == null || connectors.length == 0) {\r\n                        ServerConnector connector = new ServerConnector(_server);\r\n                        connector.setPort(port);\r\n                        if (host != null)\r\n                            connector.setHost(host);\r\n                        _server.addConnector(connector);\r\n                        if (_enableStats)\r\n                            connector.addBean(new ConnectionStatistics());\r\n                    } else {\r\n                        if (_enableStats) {\r\n                            for (Connector connector : connectors) {\r\n                                ((AbstractConnector) connector).addBean(new ConnectionStatistics());\r\n                            }\r\n                        }\r\n                    }\r\n                    runnerServerInitialized = true;\r\n                }\r\n                try (Resource ctx = Resource.newResource(args[i])) {\r\n                    if (!ctx.exists())\r\n                        usage(\"Context '\" + ctx + \"' does not exist\");\r\n                    if (contextPathSet && !(contextPath.startsWith(\"/\")))\r\n                        contextPath = \"/\" + contextPath;\r\n                    if (!ctx.isDirectory() && ctx.toString().toLowerCase(Locale.ENGLISH).endsWith(\".xml\")) {\r\n                        XmlConfiguration xmlConfiguration = new XmlConfiguration(ctx.getURL());\r\n                        xmlConfiguration.getIdMap().put(\"Server\", _server);\r\n                        ContextHandler handler = (ContextHandler) xmlConfiguration.configure();\r\n                        if (contextPathSet)\r\n                            handler.setContextPath(contextPath);\r\n                        _contexts.addHandler(handler);\r\n                        String containerIncludeJarPattern = (String) handler.getAttribute(WebInfConfiguration.CONTAINER_JAR_PATTERN);\r\n                        if (containerIncludeJarPattern == null)\r\n                            containerIncludeJarPattern = __containerIncludeJarPattern;\r\n                        else {\r\n                            if (!containerIncludeJarPattern.contains(__containerIncludeJarPattern)) {\r\n                                containerIncludeJarPattern = containerIncludeJarPattern + (StringUtil.isBlank(containerIncludeJarPattern) ? \"\" : \"|\") + __containerIncludeJarPattern;\r\n                            }\r\n                        }\r\n                        handler.setAttribute(WebInfConfiguration.CONTAINER_JAR_PATTERN, containerIncludeJarPattern);\r\n                        if (handler instanceof WebAppContext) {\r\n                            WebAppContext wac = (WebAppContext) handler;\r\n                            if (wac.getConfigurationClasses() == null || wac.getConfigurationClasses().length == 0)\r\n                                wac.setConfigurationClasses(__plusConfigurationClasses);\r\n                        }\r\n                    } else {\r\n                        WebAppContext webapp = new WebAppContext(_contexts, ctx.toString(), contextPath);\r\n                        webapp.setConfigurationClasses(__plusConfigurationClasses);\r\n                        webapp.setAttribute(WebInfConfiguration.CONTAINER_JAR_PATTERN, __containerIncludeJarPattern);\r\n                    }\r\n                }\r\n                contextPathSet = false;\r\n                contextPath = __defaultContextPath;\r\n                break;\r\n        }\r\n    }\r\n    if (_server == null)\r\n        usage(\"No Contexts defined\");\r\n    _server.setStopAtShutdown(true);\r\n    switch((stopPort > 0 ? 1 : 0) + (stopKey != null ? 2 : 0)) {\r\n        case 1:\r\n            usage(\"Must specify --stop-key when --stop-port is specified\");\r\n            break;\r\n        case 2:\r\n            usage(\"Must specify --stop-port when --stop-key is specified\");\r\n            break;\r\n        case 3:\r\n            ShutdownMonitor monitor = ShutdownMonitor.getInstance();\r\n            monitor.setPort(stopPort);\r\n            monitor.setKey(stopKey);\r\n            monitor.setExitVm(true);\r\n            break;\r\n    }\r\n    if (_logFile != null) {\r\n        NCSARequestLog requestLog = new NCSARequestLog(_logFile);\r\n        requestLog.setExtended(false);\r\n        _server.setRequestLog(requestLog);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.SearchPattern.startsWith",
	"Comment": "search for a possibly partial match of the pattern at the start of the data.",
	"Method": "int startsWith(byte[] data,int offset,int length,int matched){\r\n    validate(data, offset, length);\r\n    int matchedCount = 0;\r\n    for (int i = 0; i < pattern.length - matched && i < length; i++) {\r\n        if (data[offset + i] == pattern[i + matched])\r\n            matchedCount++;\r\n        else\r\n            return 0;\r\n    }\r\n    return matched + matchedCount;\r\n}"
}, {
	"Path": "org.eclipse.jetty.plus.jndi.NamingEntryUtil.lookupNamingEntries",
	"Comment": "build up a list of namingentry objects that are of a specific type.",
	"Method": "List<Object> lookupNamingEntries(Object scope,Class<?> clazz,List<Object> lookupNamingEntries,List<Object> list,Context context,Class<?> clazz){\r\n    try {\r\n        NamingEnumeration<Binding> nenum = context.listBindings(\"\");\r\n        while (nenum.hasMoreElements()) {\r\n            Binding binding = nenum.next();\r\n            if (binding.getObject() instanceof Context)\r\n                lookupNamingEntries(list, (Context) binding.getObject(), clazz);\r\n            else if (clazz.isInstance(binding.getObject()))\r\n                list.add(binding.getObject());\r\n        }\r\n    } catch (NameNotFoundException e) {\r\n        __log.debug(\"No entries of type \" + clazz.getName() + \" in context=\" + context);\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.internal.webapp.OSGiWebappClassLoader.addClassPath",
	"Comment": "parse the classpath ourselves to be able to filter things. this is aderivative work of the super class",
	"Method": "void addClassPath(String classPath){\r\n    StringTokenizer tokenizer = new StringTokenizer(classPath, \",;\");\r\n    while (tokenizer.hasMoreTokens()) {\r\n        String path = tokenizer.nextToken();\r\n        Resource resource = getContext().newResource(path);\r\n        File file = resource.getFile();\r\n        if (file != null && isAcceptableLibrary(file, JAR_WITH_SUCH_CLASS_MUST_BE_EXCLUDED)) {\r\n            super.addClassPath(path);\r\n        } else {\r\n            __logger.info(\"Did not add \" + path + \" to the classloader of the webapp \" + getContext());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.annotations.ResourceAnnotationHandler.doHandle",
	"Comment": "class level resource annotations declare a name in the environment that will be looked up at runtime. they do not specify an injection.",
	"Method": "void doHandle(Class<?> clazz){\r\n    if (supportsResourceInjection(clazz)) {\r\n        handleClass(clazz);\r\n        Method[] methods = clazz.getDeclaredMethods();\r\n        for (int i = 0; i < methods.length; i++) handleMethod(clazz, methods[i]);\r\n        Field[] fields = clazz.getDeclaredFields();\r\n        for (int i = 0; i < fields.length; i++) handleField(clazz, fields[i]);\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.ASTHelper.addParameter",
	"Comment": "adds the given parameter to the method. the list of parameters will beinitialized if it is null.",
	"Method": "void addParameter(MethodDeclaration method,Parameter parameter){\r\n    List<Parameter> parameters = method.getParameters();\r\n    if (parameters == null) {\r\n        parameters = new ArrayList<Parameter>();\r\n        method.setParameters(parameters);\r\n    }\r\n    parameters.add(parameter);\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.DateCache.format",
	"Comment": "format a date according to our stored formatter.if it happens to be in the same second as the last formatnowcall, then the format is reused.",
	"Method": "String format(Date inDate,String format,long inDate){\r\n    long seconds = inDate / 1000;\r\n    Tick tick = _tick;\r\n    if (tick == null || seconds != tick._seconds) {\r\n        return ZonedDateTime.ofInstant(Instant.ofEpochMilli(inDate), _zoneId).format(_tzFormat);\r\n    }\r\n    return tick._string;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.HttpConnectionTest.testOversizedBuffer",
	"Comment": "creates a request header over 1k in size, by creating a single header entry with an huge value.",
	"Method": "void testOversizedBuffer(){\r\n    String response = null;\r\n    try {\r\n        int offset = 0;\r\n        String cookie = \"thisisastringthatshouldreachover1kbytes\";\r\n        for (int i = 0; i < 100; i++) cookie += \"xxxxxxxxxxxx\";\r\n        response = connector.getResponse(\"GET / HTTP/1.1\\r\\n\" + \"Host: localhost\\r\\n\" + \"Cookie: \" + cookie + \"\\r\\n\" + \"\\r\\n\");\r\n        checkContains(response, offset, \"HTTP/1.1 431\");\r\n    } catch (Exception e) {\r\n        if (response != null)\r\n            System.err.println(response);\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.utils.SourceRoot.setParserConfiguration",
	"Comment": "set the parser configuration that is used for parsing when no configuration is passed to a method.",
	"Method": "SourceRoot setParserConfiguration(ParserConfiguration parserConfiguration){\r\n    assertNotNull(parserConfiguration);\r\n    this.parserConfiguration = parserConfiguration;\r\n    return this;\r\n}"
}, {
	"Path": "com.github.javaparser.ASTHelper.addMember",
	"Comment": "adds the given declaration to the specified type. the list of memberswill be initialized if it is null.",
	"Method": "void addMember(TypeDeclaration type,BodyDeclaration decl){\r\n    List<BodyDeclaration> members = type.getMembers();\r\n    if (members == null) {\r\n        members = new ArrayList<BodyDeclaration>();\r\n        type.setMembers(members);\r\n    }\r\n    members.add(decl);\r\n}"
}, {
	"Path": "com.github.javaparser.ast.Node.getChildNodes",
	"Comment": "contains all nodes that have this node set as their parent.you can add and remove nodes from this list by adding or removing nodes from the fields of this node.",
	"Method": "List<Node> getChildNodes(){\r\n    return unmodifiableList(childNodes);\r\n}"
}, {
	"Path": "net.bull.javamelody.internal.model.MBeans.getPlatformMBeanServer",
	"Comment": "retourne le javax.management.mbeanserver de la plateforme.",
	"Method": "MBeanServer getPlatformMBeanServer(){\r\n    return ManagementFactory.getPlatformMBeanServer();\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.OSGiWebInfConfiguration.getBundleAsResource",
	"Comment": "resolves the bundle. usually that would be a single url per bundle. but we do some more work if there are jars embedded in the bundle.",
	"Method": "List<Resource> getBundleAsResource(Bundle bundle){\r\n    List<Resource> resources = new ArrayList();\r\n    File file = BundleFileLocatorHelperFactory.getFactory().getHelper().getBundleInstallLocation(bundle);\r\n    if (file.isDirectory()) {\r\n        for (File f : file.listFiles()) {\r\n            if (f.getName().endsWith(\".jar\") && f.isFile()) {\r\n                resources.add(Resource.newResource(f));\r\n            } else if (f.isDirectory() && f.getName().equals(\"lib\")) {\r\n                for (File f2 : file.listFiles()) {\r\n                    if (f2.getName().endsWith(\".jar\") && f2.isFile()) {\r\n                        resources.add(Resource.newResource(f));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        resources.add(Resource.newResource(file));\r\n    } else {\r\n        resources.add(Resource.newResource(file));\r\n    }\r\n    return resources;\r\n}"
}, {
	"Path": "org.eclipse.jetty.client.HttpClient.FORM",
	"Comment": "performs a post request to the specified uri with the given form parameters.",
	"Method": "ContentResponse FORM(String uri,Fields fields,ContentResponse FORM,URI uri,Fields fields){\r\n    return POST(uri).content(new FormContentProvider(fields)).send();\r\n}"
}, {
	"Path": "com.github.javaparser.ast.PackageDeclaration.getAnnotations",
	"Comment": "retrieves the list of annotations declared before the packagedeclaration. return null if there are no annotations.",
	"Method": "NodeList<AnnotationExpr> getAnnotations(){\r\n    return annotations;\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.spi.TestSPIServer.testBoundHttpServer",
	"Comment": "test using a server that is created with a given inetsocketaddress",
	"Method": "void testBoundHttpServer(){\r\n    HttpServer server = null;\r\n    try {\r\n        server = new JettyHttpServerProvider().createHttpServer(new InetSocketAddress(\"localhost\", 0), 10);\r\n        final HttpContext httpContext = server.createContext(\"/\", exchange -> {\r\n            Headers responseHeaders = exchange.getResponseHeaders();\r\n            responseHeaders.set(\"Content-Type\", \"text/plain\");\r\n            exchange.sendResponseHeaders(200, 0);\r\n            OutputStream responseBody = exchange.getResponseBody();\r\n            Headers requestHeaders = exchange.getRequestHeaders();\r\n            Set<String> keySet = requestHeaders.keySet();\r\n            Iterator<String> iter = keySet.iterator();\r\n            while (iter.hasNext()) {\r\n                String key = iter.next();\r\n                List values = requestHeaders.get(key);\r\n                String s = key + \" = \" + values.toString() + \"\\n\";\r\n                responseBody.write(s.getBytes());\r\n            }\r\n            responseBody.close();\r\n        });\r\n        httpContext.setAuthenticator(new BasicAuthenticator(\"Test\") {\r\n            @Override\r\n            public boolean checkCredentials(String username, String password) {\r\n                if (\"username\".equals(username) && password.equals(\"password\"))\r\n                    return true;\r\n                return false;\r\n            }\r\n        });\r\n        server.start();\r\n        Server jetty = ((JettyHttpServer) server).getServer();\r\n        int port = ((NetworkConnector) jetty.getConnectors()[0]).getLocalPort();\r\n        HttpClient client = new HttpClient();\r\n        client.start();\r\n        try {\r\n            Request request = client.newRequest(\"http://localhost:\" + port + \"/\");\r\n            client.getAuthenticationStore().addAuthentication(new BasicAuthentication(URI.create(\"http://localhost:\" + port), \"Test\", \"username\", \"password\"));\r\n            ContentResponse response = request.send();\r\n            assertEquals(HttpServletResponse.SC_OK, response.getStatus());\r\n        } finally {\r\n            client.stop();\r\n        }\r\n    } finally {\r\n        if (server != null)\r\n            server.stop(5);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.spi.TestSPIServer.testBoundHttpServer",
	"Comment": "test using a server that is created with a given inetsocketaddress",
	"Method": "void testBoundHttpServer(){\r\n    if (\"username\".equals(username) && password.equals(\"password\"))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.javaee7.websocket.encoder.EncoderEndpointTest.createDeployment",
	"Comment": "arquillian specific method for creating a file which can be deployedwhile executing the test.",
	"Method": "WebArchive createDeployment(){\r\n    return ShrinkWrap.create(WebArchive.class).addClasses(MyEndpoint.class, MyMessage.class, MyMessageEncoder.class, MyMessageDecoder.class);\r\n}"
}, {
	"Path": "com.github.javaparser.JavaParser.parseModuleDirective",
	"Comment": "parses a module directive and returns it as a moduledirective.",
	"Method": "ModuleDirective parseModuleDirective(String moduleDirective){\r\n    return simplifiedParse(MODULE_DIRECTIVE, provider(moduleDirective));\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.HttpInput.asyncReadProduce",
	"Comment": "called by channel when asynchronous io needs to produce more content",
	"Method": "void asyncReadProduce(){\r\n    synchronized (_inputQ) {\r\n        produceContent();\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration.getContext",
	"Comment": "this method is deprecated because the context is an implementation detail that should not be exposed.ideally this method should become private. for this reason all further usages of this method are discouraged.",
	"Method": "Context getContext(){\r\n    return JavaParserFactory.getContext(wrappedNode, typeSolver);\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.pathmap.PathMappingsTest.testMixedMatchOrder",
	"Comment": "test the match order rules with a mixed servlet and regex path specsexact matchlongest prefix matchlongest suffix match",
	"Method": "void testMixedMatchOrder(){\r\n    PathMappings<String> p = new PathMappings();\r\n    p.put(new ServletPathSpec(\"/\"), \"default\");\r\n    p.put(new ServletPathSpec(\"/animal/bird/*\"), \"birds\");\r\n    p.put(new ServletPathSpec(\"/animal/fish/*\"), \"fishes\");\r\n    p.put(new ServletPathSpec(\"/animal/*\"), \"animals\");\r\n    p.put(new RegexPathSpec(\"^/animal/.*/chat$\"), \"animalChat\");\r\n    p.put(new RegexPathSpec(\"^/animal/.*/cam$\"), \"animalCam\");\r\n    p.put(new RegexPathSpec(\"^/entrance/cam$\"), \"entranceCam\");\r\n    assertMatch(p, \"/animal/bird/eagle\", \"birds\");\r\n    assertMatch(p, \"/animal/fish/bass/sea\", \"fishes\");\r\n    assertMatch(p, \"/animal/peccary/javalina/evolution\", \"animals\");\r\n    assertMatch(p, \"/\", \"default\");\r\n    assertMatch(p, \"/animal/bird/eagle/chat\", \"animalChat\");\r\n    assertMatch(p, \"/animal/bird/penguin/chat\", \"animalChat\");\r\n    assertMatch(p, \"/animal/fish/trout/cam\", \"animalCam\");\r\n    assertMatch(p, \"/entrance/cam\", \"entranceCam\");\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.IPAccessHandler.add",
	"Comment": "helper method to parse the new entry and add it tothe specified address pattern map.",
	"Method": "void add(String entry,PathMap<IPAddressMap<Boolean>> patternMap){\r\n    if (entry != null && entry.length() > 0) {\r\n        boolean deprecated = false;\r\n        int idx;\r\n        if (entry.indexOf('|') > 0) {\r\n            idx = entry.indexOf('|');\r\n        } else {\r\n            idx = entry.indexOf('/');\r\n            deprecated = (idx >= 0);\r\n        }\r\n        String addr = idx > 0 ? entry.substring(0, idx) : entry;\r\n        String path = idx > 0 ? entry.substring(idx) : \"/*\";\r\n        if (addr.endsWith(\".\"))\r\n            deprecated = true;\r\n        if (path != null && (path.startsWith(\"|\") || path.startsWith(\"/*.\")))\r\n            path = path.substring(1);\r\n        IPAddressMap<Boolean> addrMap = patternMap.get(path);\r\n        if (addrMap == null) {\r\n            addrMap = new IPAddressMap<Boolean>();\r\n            patternMap.put(path, addrMap);\r\n        }\r\n        if (addr != null && !\"\".equals(addr))\r\n            addrMap.put(addr, true);\r\n        if (deprecated)\r\n            LOG.debug(toString() + \" - deprecated specification syntax: \" + entry);\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.ast.body.FieldDeclaration.createSetter",
	"Comment": "create a setter for this field, will only work if this field declares only 1 identifier and if this field isalready added to a classorinterfacedeclaration",
	"Method": "MethodDeclaration createSetter(){\r\n    if (getVariables().size() != 1)\r\n        throw new IllegalStateException(\"You can use this only when the field declares only 1 variable name\");\r\n    ClassOrInterfaceDeclaration parentClass = getParentNodeOfType(ClassOrInterfaceDeclaration.class);\r\n    EnumDeclaration parentEnum = getParentNodeOfType(EnumDeclaration.class);\r\n    if ((parentClass == null && parentEnum == null) || (parentClass != null && parentClass.isInterface()))\r\n        throw new IllegalStateException(\"You can use this only when the field is attached to a class or an enum\");\r\n    VariableDeclarator variable = getVariables().get(0);\r\n    String fieldName = variable.getId().getName();\r\n    String fieldNameUpper = fieldName.toUpperCase().substring(0, 1) + fieldName.substring(1, fieldName.length());\r\n    final MethodDeclaration setter;\r\n    if (parentClass != null)\r\n        setter = parentClass.addMethod(\"set\" + fieldNameUpper, PUBLIC);\r\n    else\r\n        setter = parentEnum.addMethod(\"set\" + fieldNameUpper, PUBLIC);\r\n    setter.setType(VOID_TYPE);\r\n    setter.getParameters().add(new Parameter(variable.getType(), new VariableDeclaratorId(fieldName)));\r\n    BlockStmt blockStmt2 = new BlockStmt();\r\n    setter.setBody(blockStmt2);\r\n    blockStmt2.addStatement(new AssignExpr(new NameExpr(\"this.\" + fieldName), new NameExpr(fieldName), Operator.assign));\r\n    return setter;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "ResolvedTypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return new ResolvedTypeParameterDeclaration() {\r\n        @Override\r\n        public String getName() {\r\n            return name;\r\n        }\r\n        @Override\r\n        public boolean declaredOnType() {\r\n            return true;\r\n        }\r\n        @Override\r\n        public boolean declaredOnMethod() {\r\n            return false;\r\n        }\r\n        @Override\r\n        public boolean declaredOnConstructor() {\r\n            return false;\r\n        }\r\n        @Override\r\n        public String getContainerQualifiedName() {\r\n            return classQName;\r\n        }\r\n        @Override\r\n        public String getContainerId() {\r\n            return classQName;\r\n        }\r\n        @Override\r\n        public ResolvedTypeParametrizable getContainer() {\r\n            return null;\r\n        }\r\n        @Override\r\n        public List<Bound> getBounds() {\r\n            return bounds;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"TypeParameter onType \" + name;\r\n        }\r\n        @Override\r\n        public Optional<ResolvedReferenceTypeDeclaration> containerType() {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "ResolvedTypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return name;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "ResolvedTypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return true;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "ResolvedTypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return false;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "ResolvedTypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return false;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "ResolvedTypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return classQName;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "ResolvedTypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return classQName;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "ResolvedTypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return null;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "ResolvedTypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return bounds;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "ResolvedTypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return \"TypeParameter onType \" + name;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "ResolvedTypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.IteratingCallback.reset",
	"Comment": "resets this callback.a callback can only be reset to idle from thesucceeded or failed states or if it is already idle.",
	"Method": "boolean reset(){\r\n    try (Locker.Lock lock = _locker.lock()) {\r\n        switch(_state) {\r\n            case IDLE:\r\n                return true;\r\n            case SUCCEEDED:\r\n            case FAILED:\r\n                _iterate = false;\r\n                _state = State.IDLE;\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.bull.javamelody.internal.model.Base64Coder.encodeString",
	"Comment": "encodes a string into base64 format.\t no blanks or line breaks are inserted.",
	"Method": "String encodeString(String s){\r\n    return new String(encode(s.getBytes()));\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.jasper.ContainerTldBundleDiscoverer.findJstlBundle",
	"Comment": "find the bundle that contains a jstl implementation class, which assumes thatthe jstl taglibs will be inside the same bundle.",
	"Method": "Bundle findJstlBundle(){\r\n    Class<?> jstlClass = null;\r\n    try {\r\n        jstlClass = JSTLBundleDiscoverer.class.getClassLoader().loadClass(DEFAULT_JSTL_BUNDLE_CLASS);\r\n    } catch (ClassNotFoundException e) {\r\n        LOG.info(\"jstl not on classpath\", e);\r\n    }\r\n    if (jstlClass != null)\r\n        return FrameworkUtil.getBundle(jstlClass);\r\n    return null;\r\n}"
}, {
	"Path": "net.bull.javamelody.JavaMelodyConfigurationProperties.setEnabled",
	"Comment": "sets whether javamelody should be enabled within the application.",
	"Method": "void setEnabled(boolean enabled){\r\n    this.enabled = enabled;\r\n}"
}, {
	"Path": "com.github.javaparser.printer.PrettyPrinterConfiguration.setVisitorFactory",
	"Comment": "set the factory that creates the prettyprintvisitor. by changing this you can make the prettyprinter use a customprettyprintervisitor.",
	"Method": "PrettyPrinterConfiguration setVisitorFactory(Function<PrettyPrinterConfiguration, PrettyPrintVisitor> visitorFactory){\r\n    this.visitorFactory = assertNotNull(visitorFactory);\r\n    return this;\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.DefaultServletTest.testWelcomeRedirect_DirWithSemicolon",
	"Comment": "ensure that oddball directory names are served with proper escaping",
	"Method": "void testWelcomeRedirect_DirWithSemicolon(){\r\n    FS.ensureDirExists(docRoot);\r\n    context.setBaseResource(new PathResource(docRoot));\r\n    Path dir = assumeMkDirSupported(docRoot, \"dir;\");\r\n    Path index = dir.resolve(\"index.html\");\r\n    createFile(index, \"<h1>Hello Index<\/h1>\");\r\n    ServletHolder defholder = context.addServlet(DefaultServlet.class, \"/\");\r\n    defholder.setInitParameter(\"dirAllowed\", \"false\");\r\n    defholder.setInitParameter(\"redirectWelcome\", \"true\");\r\n    defholder.setInitParameter(\"welcomeServlets\", \"false\");\r\n    defholder.setInitParameter(\"gzip\", \"false\");\r\n    String rawResponse;\r\n    HttpTester.Response response;\r\n    rawResponse = connector.getResponse(\"GET /context/dir; HTTP/1.0\\r\\n\\r\\n\");\r\n    response = HttpTester.parseResponse(rawResponse);\r\n    assertThat(response.toString(), response.getStatus(), is(HttpStatus.MOVED_TEMPORARILY_302));\r\n    assertThat(response, containsHeaderValue(\"Location\", \"http://0.0.0.0/context/dir;/\"));\r\n    rawResponse = connector.getResponse(\"GET /context/dir;/ HTTP/1.0\\r\\n\\r\\n\");\r\n    response = HttpTester.parseResponse(rawResponse);\r\n    assertThat(response.toString(), response.getStatus(), is(HttpStatus.MOVED_TEMPORARILY_302));\r\n    assertThat(response, containsHeaderValue(\"Location\", \"http://0.0.0.0/context/dir;/index.html\"));\r\n}"
}, {
	"Path": "com.github.javaparser.ast.nodeTypes.NodeWithJavadoc.getJavadocComment",
	"Comment": "gets the javadoccomment for this node. you can set the javadoccomment by calling setjavadoccomment passing ajavadoccomment.",
	"Method": "Optional<JavadocComment> getJavadocComment(){\r\n    return getComment().filter(comment -> comment instanceof JavadocComment).map(comment -> (JavadocComment) comment);\r\n}"
}, {
	"Path": "com.github.javaparser.ast.CompilationUnit.addInterface",
	"Comment": "add a public interface class to the types of this compilation unit",
	"Method": "ClassOrInterfaceDeclaration addInterface(String name,ClassOrInterfaceDeclaration addInterface,String name,Modifier modifiers){\r\n    ClassOrInterfaceDeclaration classOrInterfaceDeclaration = new ClassOrInterfaceDeclaration(Arrays.stream(modifiers).collect(Collectors.toCollection(() -> EnumSet.noneOf(Modifier.class))), true, name);\r\n    getTypes().add(classOrInterfaceDeclaration);\r\n    classOrInterfaceDeclaration.setParentNode(this);\r\n    return classOrInterfaceDeclaration;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.api.util.WSURI.toHttp",
	"Comment": "convert to http http or https scheme uris.converting ws and wss uris to their http equivalent",
	"Method": "URI toHttp(URI inputUri){\r\n    Objects.requireNonNull(inputUri, \"Input URI must not be null\");\r\n    String wsScheme = inputUri.getScheme();\r\n    if (\"http\".equalsIgnoreCase(wsScheme) || \"https\".equalsIgnoreCase(wsScheme)) {\r\n        return inputUri;\r\n    }\r\n    if (\"ws\".equalsIgnoreCase(wsScheme)) {\r\n        return new URI(\"http\" + inputUri.toString().substring(wsScheme.length()));\r\n    }\r\n    if (\"wss\".equalsIgnoreCase(wsScheme)) {\r\n        return new URI(\"https\" + inputUri.toString().substring(wsScheme.length()));\r\n    }\r\n    throw new URISyntaxException(inputUri.toString(), \"Unrecognized WebSocket scheme\");\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.asClass",
	"Comment": "return this as a classdeclaration or throw unsupportedoperationexception.",
	"Method": "ClassDeclaration asClass(){\r\n    throw new UnsupportedOperationException(String.format(\"%s is not a class\", this));\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.HttpConfiguration.setOutputAggregationSize",
	"Comment": "set the max size of the response content write that is copied into the aggregate buffer.writes that are smaller of this size are copied into the aggregate buffer, whilewrites that are larger of this size will cause the aggregate buffer to be flushedand the write to be executed without being copied.",
	"Method": "void setOutputAggregationSize(int outputAggregationSize){\r\n    _outputAggregationSize = outputAggregationSize;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.resolution.SymbolReference.getCorrespondingDeclaration",
	"Comment": "the corresponding declaration. if not solve this throws unsupportedoperationexception.",
	"Method": "S getCorrespondingDeclaration(){\r\n    if (!isSolved()) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n    return correspondingDeclaration.get();\r\n}"
}, {
	"Path": "org.javaee7.jaspic.ejbpropagation.ProtectedEJBPropagationTest.publicServletCallingProtectedEJB",
	"Comment": "a small variation on the testprotectedservletwithlogincallingejb that tests if for authentication that happened forpublic resources the security context also propagates to ejb.",
	"Method": "void publicServletCallingProtectedEJB(){\r\n    String response = getFromServerPath(\"public/servlet-protected-ejb?doLogin=true\");\r\n    assertTrue(\"User should have been authenticated in the web layer and given name \\\"test\\\", \" + \" but does not appear to have this name\", response.contains(\"web username: test\"));\r\n    assertTrue(\"Web has user principal set, but EJB not.\", response.contains(\"EJB username: test\"));\r\n    assertTrue(response.contains(\"web user has role \\\"architect\\\": true\"));\r\n    assertTrue(\"Web user principal has role \\\"architect\\\", but one in EJB doesn't.\", response.contains(\"EJB user has role \\\"architect\\\": true\"));\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.pathmap.PathSpec.getPathDepth",
	"Comment": "get the number of path elements that this path spec declares.this is used to determine longest match logic.",
	"Method": "int getPathDepth(){\r\n    return pathDepth;\r\n}"
}, {
	"Path": "org.eclipse.jetty.maven.plugin.SystemProperty.setIfNotSetAlready",
	"Comment": "set a system.property with this valueif it is not already set.",
	"Method": "void setIfNotSetAlready(){\r\n    if (System.getProperty(getName()) == null) {\r\n        System.setProperty(getName(), (getValue() == null ? \"\" : getValue()));\r\n        isSet = true;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.Loader.loadClass",
	"Comment": "load a class.load a class either from the thread context classloader or if none, the systemloader",
	"Method": "Class loadClass(String name,Class loadClass,Class loaderClass,String name){\r\n    if (loaderClass != null && loaderClass.getClassLoader() != null)\r\n        return loaderClass.getClassLoader().loadClass(name);\r\n    return loadClass(name);\r\n}"
}, {
	"Path": "com.github.javaparser.printer.lexicalpreservation.RemovedGroup.of",
	"Comment": "factory method to create a removedgroup which consists of consecutive removed elements",
	"Method": "RemovedGroup of(Integer firstElementIndex,List<Removed> removedList){\r\n    return new RemovedGroup(firstElementIndex, removedList);\r\n}"
}, {
	"Path": "org.eclipse.jetty.security.SpnegoLoginService.login",
	"Comment": "username will be null since the credentials will contain all the relevant info",
	"Method": "UserIdentity login(String username,Object credentials,ServletRequest request){\r\n    String encodedAuthToken = (String) credentials;\r\n    byte[] authToken = B64Code.decode(encodedAuthToken);\r\n    GSSManager manager = GSSManager.getInstance();\r\n    try {\r\n        Oid krb5Oid = new Oid(\"1.3.6.1.5.5.2\");\r\n        GSSName gssName = manager.createName(_targetName, null);\r\n        GSSCredential serverCreds = manager.createCredential(gssName, GSSCredential.INDEFINITE_LIFETIME, krb5Oid, GSSCredential.ACCEPT_ONLY);\r\n        GSSContext gContext = manager.createContext(serverCreds);\r\n        if (gContext == null) {\r\n            LOG.debug(\"SpnegoUserRealm: failed to establish GSSContext\");\r\n        } else {\r\n            while (!gContext.isEstablished()) {\r\n                authToken = gContext.acceptSecContext(authToken, 0, authToken.length);\r\n            }\r\n            if (gContext.isEstablished()) {\r\n                String clientName = gContext.getSrcName().toString();\r\n                String role = clientName.substring(clientName.indexOf('@') + 1);\r\n                LOG.debug(\"SpnegoUserRealm: established a security context\");\r\n                LOG.debug(\"Client Principal is: \" + gContext.getSrcName());\r\n                LOG.debug(\"Server Principal is: \" + gContext.getTargName());\r\n                LOG.debug(\"Client Default Role: \" + role);\r\n                SpnegoUserPrincipal user = new SpnegoUserPrincipal(clientName, authToken);\r\n                Subject subject = new Subject();\r\n                subject.getPrincipals().add(user);\r\n                return _identityService.newUserIdentity(subject, user, new String[] { role });\r\n            }\r\n        }\r\n    } catch (GSSException gsse) {\r\n        LOG.warn(gsse);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.jetty.overlays.OverlayedAppProvider.redeploy",
	"Comment": "walks the defined webapps, templates, nodes and instances to determine what should be deployed, then adjust reality to match.",
	"Method": "void redeploy(){\r\n    Map<String, Template> templates = new ConcurrentHashMap<String, Template>();\r\n    for (Template template : _templates.values()) {\r\n        Template other = templates.get(template.getTemplateName());\r\n        if (other != null) {\r\n            __log.warn(\"Multiple Templates: {} & {}\", template.getName(), other.getName());\r\n            if (other.getName().compareToIgnoreCase(template.getName()) <= 0)\r\n                continue;\r\n        }\r\n        templates.put(template.getTemplateName(), template);\r\n    }\r\n    for (Template template : templates.values()) {\r\n        String webappname = template.getClassifier();\r\n        if (webappname == null)\r\n            continue;\r\n        Webapp webapp = _webapps.get(webappname);\r\n        if (webapp == null) {\r\n            __log.warn(\"No webapp found for template: {}\", template.getName());\r\n            templates.remove(template.getTemplateName());\r\n        } else {\r\n            template.setWebapp(webapp);\r\n        }\r\n    }\r\n    Set<String> deployed = new HashSet<String>();\r\n    List<Instance> deploy = new ArrayList<Instance>();\r\n    for (Instance instance : _instances.values()) {\r\n        Template template = templates.get(instance.getTemplateName());\r\n        instance.setTemplate(template);\r\n        if (template != null) {\r\n            String key = instance.getInstanceKey();\r\n            App app = _deployed.get(key);\r\n            if (app == null)\r\n                deploy.add(instance);\r\n            else\r\n                deployed.add(key);\r\n        }\r\n    }\r\n    List<String> undeploy = new ArrayList<String>();\r\n    for (String key : _deployed.keySet()) {\r\n        if (!deployed.contains(key))\r\n            undeploy.add(key);\r\n    }\r\n    for (String key : undeploy) {\r\n        App app = _deployed.remove(key);\r\n        if (app != null) {\r\n            __log.info(\"Undeploy {}\", key);\r\n            _deploymentManager.removeApp(app);\r\n        }\r\n    }\r\n    for (Instance instance : deploy) {\r\n        String key = instance.getInstanceKey();\r\n        OverlayedApp app = new OverlayedApp(_deploymentManager, this, key, instance);\r\n        _deployed.put(key, app);\r\n    }\r\n    Set<String> sharedKeys = new HashSet<String>(_shared.keySet());\r\n    for (OverlayedApp app : _deployed.values()) {\r\n        Instance instance = app.getInstance();\r\n        sharedKeys.remove(instance.getSharedKey());\r\n    }\r\n    for (String sharedKey : sharedKeys) {\r\n        __log.debug(\"Remove \" + sharedKey);\r\n        TemplateContext shared = _shared.remove(sharedKey);\r\n        if (shared != null) {\r\n            try {\r\n                shared.stop();\r\n            } catch (Exception e) {\r\n                __log.warn(e);\r\n            }\r\n            shared.destroy();\r\n        }\r\n    }\r\n    for (Instance instance : deploy) {\r\n        String key = instance.getInstanceKey();\r\n        OverlayedApp app = _deployed.get(key);\r\n        __log.info(\"Deploy {}\", key);\r\n        _deploymentManager.addApp(app);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.proxy.AfterContentTransformer.getMaxInputBufferSize",
	"Comment": "returns the maximum input buffer size, after which the input is overflown to disk.defaults to 1 mib, i.e. 1048576 bytes.",
	"Method": "long getMaxInputBufferSize(){\r\n    return maxInputBufferSize;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.Session.isIdleLongerThan",
	"Comment": "check if the session has been idle longer than a number of seconds.",
	"Method": "boolean isIdleLongerThan(int sec){\r\n    long now = System.currentTimeMillis();\r\n    try (Lock lock = _lock.lock()) {\r\n        return ((_sessionData.getAccessed() + (sec * 1000)) <= now);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.SessionHandler.setMaxInactiveInterval",
	"Comment": "sets the max period of inactivity, after which the session is invalidated, in seconds.",
	"Method": "void setMaxInactiveInterval(int seconds){\r\n    _dftMaxIdleSecs = seconds;\r\n    if (LOG.isDebugEnabled()) {\r\n        if (_dftMaxIdleSecs <= 0)\r\n            LOG.debug(\"Sessions created by this manager are immortal (default maxInactiveInterval={})\", _dftMaxIdleSecs);\r\n        else\r\n            LOG.debug(\"SessionManager default maxInactiveInterval={}\", _dftMaxIdleSecs);\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.clearInstances",
	"Comment": "this method is used to clear internal caches for the sake of releasing memory.",
	"Method": "void clearInstances(){\r\n    instances.clear();\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.gzip.GzipTester.prepareServerFile",
	"Comment": "create a file on the server resource path of a specified filename and size.",
	"Method": "File prepareServerFile(String filename,int filesize){\r\n    File dir = testdir.toFile();\r\n    File testFile = new File(dir, filename);\r\n    int i = 0;\r\n    while (testFile.exists()) {\r\n        testFile = new File(dir, (i++) + \"-\" + filename);\r\n    }\r\n    FileOutputStream fos = null;\r\n    ByteArrayInputStream in = null;\r\n    try {\r\n        fos = new FileOutputStream(testFile, false);\r\n        in = new ByteArrayInputStream(generateContent(filesize).getBytes(encoding));\r\n        IO.copy(in, fos);\r\n        return testFile;\r\n    } finally {\r\n        IO.close(in);\r\n        IO.close(fos);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.log.StdErrLog.setDebugEnabled",
	"Comment": "legacy interface where a programmatic configuration of the logger levelis done as a wholesale approach.",
	"Method": "void setDebugEnabled(boolean enabled){\r\n    if (enabled) {\r\n        this._level = LEVEL_DEBUG;\r\n        for (Logger log : Log.getLoggers().values()) {\r\n            if (log.getName().startsWith(getName()) && log instanceof StdErrLog)\r\n                ((StdErrLog) log).setLevel(LEVEL_DEBUG);\r\n        }\r\n    } else {\r\n        this._level = this._configuredLevel;\r\n        for (Logger log : Log.getLoggers().values()) {\r\n            if (log.getName().startsWith(getName()) && log instanceof StdErrLog)\r\n                ((StdErrLog) log).setLevel(((StdErrLog) log)._configuredLevel);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.ListenerHolder.setListener",
	"Comment": "set an explicit instance. in this case,just like servletholder and filterholder,the listener will not be introspected forannotations like resource etc.",
	"Method": "void setListener(EventListener listener){\r\n    _listener = listener;\r\n    _extInstance = true;\r\n    setHeldClass(_listener.getClass());\r\n}"
}, {
	"Path": "org.javaee7.websocket.encoder.EncoderEndpointTest.connectToServer",
	"Comment": "method used to supply connection to the server by passing the naming ofthe websocket endpoint",
	"Method": "Session connectToServer(Class<?> endpoint){\r\n    WebSocketContainer container = ContainerProvider.getWebSocketContainer();\r\n    URI uri = new URI(\"ws://\" + base.getHost() + \":\" + base.getPort() + base.getPath() + \"encoder\");\r\n    return container.connectToServer(endpoint, uri);\r\n}"
}, {
	"Path": "org.javaee7.jaspictest.dispatching.CDIForwardTest.testCDIForwardWithRequestProtected",
	"Comment": "tests that the forwarded resource has the correct servlet path",
	"Method": "void testCDIForwardWithRequestProtected(){\r\n    String response = getFromServerPath(\"protected/servlet\");\r\n    assertTrue(\"Servletpath reported by servlet request after forward from SAM not as expected.\", response.contains(\"servletPath via Servlet - /forwardedServlet\"));\r\n}"
}, {
	"Path": "com.github.javaparser.printer.PrettyPrinterConfiguration.setPrintComments",
	"Comment": "when true, all comments will be printed, unless printjavadoc is false, then only line and block comments will beprinted.",
	"Method": "PrettyPrinterConfiguration setPrintComments(boolean printComments){\r\n    this.printComments = printComments;\r\n    return this;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.ContextHandler.getClassPath",
	"Comment": "make best effort to extract a file classpath from the context classloader",
	"Method": "String getClassPath(){\r\n    if (_classLoader == null || !(_classLoader instanceof URLClassLoader))\r\n        return null;\r\n    URLClassLoader loader = (URLClassLoader) _classLoader;\r\n    URL[] urls = loader.getURLs();\r\n    StringBuilder classpath = new StringBuilder();\r\n    for (int i = 0; i < urls.length; i++) {\r\n        try {\r\n            Resource resource = newResource(urls[i]);\r\n            File file = resource.getFile();\r\n            if (file != null && file.exists()) {\r\n                if (classpath.length() > 0)\r\n                    classpath.append(File.pathSeparatorChar);\r\n                classpath.append(file.getAbsolutePath());\r\n            }\r\n        } catch (IOException e) {\r\n            LOG.debug(e);\r\n        }\r\n    }\r\n    if (classpath.length() == 0)\r\n        return null;\r\n    return classpath.toString();\r\n}"
}, {
	"Path": "com.github.javaparser.ast.nodeTypes.NodeWithParameters.addParameter",
	"Comment": "remember to import the class in the compilation unit yourself",
	"Method": "N addParameter(Type type,String name,N addParameter,Class<?> paramClass,String name,N addParameter,String className,String name,N addParameter,Parameter parameter){\r\n    getParameters().add(parameter);\r\n    parameter.setParentNode((Node) this);\r\n    return (T) this;\r\n}"
}, {
	"Path": "org.eclipse.jetty.annotations.AnnotationConfiguration.isUseMultiThreading",
	"Comment": "check if we should use multiple threads to scan for annotations or not",
	"Method": "boolean isUseMultiThreading(WebAppContext context){\r\n    Object o = context.getAttribute(MULTI_THREADED);\r\n    if (o instanceof Boolean) {\r\n        return ((Boolean) o).booleanValue();\r\n    }\r\n    o = context.getServer().getAttribute(MULTI_THREADED);\r\n    if (o instanceof Boolean) {\r\n        return ((Boolean) o).booleanValue();\r\n    }\r\n    return Boolean.parseBoolean(System.getProperty(MULTI_THREADED, Boolean.toString(DEFAULT_MULTI_THREADED)));\r\n}"
}, {
	"Path": "com.github.javaparser.utils.TestUtils.readResource",
	"Comment": "takes care of setting all the end of line character to platform specific ones.",
	"Method": "String readResource(String resourceName){\r\n    if (resourceName.startsWith(\"/\")) {\r\n        resourceName = resourceName.substring(1);\r\n    }\r\n    try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\r\n        if (resourceAsStream == null) {\r\n            fail(\"not found: \" + resourceName);\r\n        }\r\n        try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, \"utf-8\");\r\n            final BufferedReader br = new BufferedReader(reader)) {\r\n            final StringBuilder builder = new StringBuilder();\r\n            String line;\r\n            while ((line = br.readLine()) != null) {\r\n                builder.append(line).append(Utils.EOL);\r\n            }\r\n            return builder.toString();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.webapp.WebInfConfigurationTest.testFindAndFilterContainerPathsJDK9",
	"Comment": "assume target jdk9 or above. in this case we should extract what we needfrom the java.class.path. we should also examine the module path.",
	"Method": "void testFindAndFilterContainerPathsJDK9(){\r\n    WebInfConfiguration config = new WebInfConfiguration();\r\n    WebAppContext context = new WebAppContext();\r\n    context.setAttribute(WebInfConfiguration.CONTAINER_JAR_PATTERN, \".*/jetty-util-[^/]*\\\\.jar$|.*/jetty-util/target/classes/$|.*/foo-bar-janb.jar\");\r\n    WebAppClassLoader loader = new WebAppClassLoader(context);\r\n    context.setClassLoader(loader);\r\n    config.findAndFilterContainerPaths(context);\r\n    List<Resource> containerResources = context.getMetaData().getContainerResources();\r\n    assertEquals(2, containerResources.size());\r\n    for (Resource r : containerResources) {\r\n        String s = r.toString();\r\n        assertThat(s, anyOf(endsWith(\"foo-bar-janb.jar\"), containsString(\"jetty-util\")));\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.client.HostnameVerificationTest.simpleGetWithHostnameVerificationDisabledTest",
	"Comment": "this test has hostname verification disabled and connecting, ssl handshake and sending the request should justwork fine.",
	"Method": "void simpleGetWithHostnameVerificationDisabledTest(){\r\n    clientSslContextFactory.setEndpointIdentificationAlgorithm(null);\r\n    String uri = \"https://localhost:\" + connector.getLocalPort() + \"/\";\r\n    try {\r\n        client.GET(uri);\r\n    } catch (ExecutionException e) {\r\n        fail(\"SSLHandshake should work just fine as hostname verification is disabled!\", e);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.security.ConstraintSecurityHandler.omissionsExist",
	"Comment": "check if any http method omissions exist in the list of methodto auth info mappings.",
	"Method": "boolean omissionsExist(String path,Map<String, RoleInfo> methodMappings){\r\n    if (methodMappings == null)\r\n        return false;\r\n    boolean hasOmissions = false;\r\n    for (String m : methodMappings.keySet()) {\r\n        if (m.endsWith(OMISSION_SUFFIX))\r\n            hasOmissions = true;\r\n    }\r\n    return hasOmissions;\r\n}"
}, {
	"Path": "org.eclipse.jetty.ant.ServerProxyImpl.applyJettyXml",
	"Comment": "applies jetty.xml configuration to the jetty server instance.",
	"Method": "void applyJettyXml(){\r\n    if (jettyXml != null && jettyXml.exists()) {\r\n        TaskLog.log(\"Configuring jetty from xml configuration file = \" + jettyXml.getAbsolutePath());\r\n        XmlConfiguration configuration;\r\n        try {\r\n            configuration = new XmlConfiguration(Resource.toURL(jettyXml));\r\n            configuration.configure(server);\r\n        } catch (MalformedURLException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (SAXException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.Request.getRootURL",
	"Comment": "reconstructs the url the client used to make the request. the returned url contains a protocol, server name, port number, and, but it does not include apath.because this method returns a stringbuffer, not a string, you can modify the url easily, for example, to append path and query parameters.this method is useful for creating redirect messages and for reporting errors.",
	"Method": "StringBuilder getRootURL(){\r\n    StringBuilder url = new StringBuilder(128);\r\n    URIUtil.appendSchemeHostPort(url, getScheme(), getServerName(), getServerPort());\r\n    return url;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.io.IOState.onAbnormalClose",
	"Comment": "a websocket connection has been disconnected for abnormal close reasons.this is the low level disconnect of the socket. it could be the result of a normal close operation, from an io error, or even from a timeout.",
	"Method": "void onAbnormalClose(CloseInfo close){\r\n    if (LOG.isDebugEnabled())\r\n        LOG.debug(\"onAbnormalClose({})\", close);\r\n    ConnectionState event = null;\r\n    synchronized (this) {\r\n        if (this.state == ConnectionState.CLOSED) {\r\n            return;\r\n        }\r\n        if (this.state == ConnectionState.OPEN) {\r\n            this.cleanClose = false;\r\n        }\r\n        this.state = ConnectionState.CLOSED;\r\n        finalClose.compareAndSet(null, close);\r\n        this.inputAvailable = false;\r\n        this.outputAvailable = false;\r\n        this.closeHandshakeSource = CloseHandshakeSource.ABNORMAL;\r\n        event = this.state;\r\n    }\r\n    notifyStateListeners(event);\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getQualifiedSignature",
	"Comment": "the qualified signature of the method. it is composed by the qualified name of the declaring typefollowed by the signature of the method.",
	"Method": "String getQualifiedSignature(){\r\n    return declaringType().getId() + \".\" + this.getSignature();\r\n}"
}, {
	"Path": "com.github.javaparser.printer.lexicalpreservation.DifferenceElementCalculator.removeIndentationElements",
	"Comment": "remove from the difference all the elements related to indentation.this is mainly intended for test purposes.",
	"Method": "void removeIndentationElements(List<DifferenceElement> elements){\r\n    elements.removeIf(el -> el.getElement() instanceof CsmIndent || el.getElement() instanceof CsmUnindent);\r\n}"
}, {
	"Path": "org.eclipse.jetty.rewrite.handler.VirtualHostRuleContainer.getVirtualHosts",
	"Comment": "get the virtual hosts that the rules within this container will apply to",
	"Method": "String[] getVirtualHosts(){\r\n    return _virtualHosts;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.AcceptHash.hashKey",
	"Comment": "concatenate the provided key with the magic guid and return the base64 encoded form.",
	"Method": "String hashKey(String key){\r\n    try {\r\n        MessageDigest md = MessageDigest.getInstance(\"SHA1\");\r\n        md.update(key.getBytes(StandardCharsets.UTF_8));\r\n        md.update(MAGIC);\r\n        return new String(B64Code.encode(md.digest()));\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.utils.SourceRoot.setPrinter",
	"Comment": "set the printing function that transforms compilation units into a string to save.",
	"Method": "SourceRoot setPrinter(Function<CompilationUnit, String> printer){\r\n    assertNotNull(printer);\r\n    this.printer = printer;\r\n    return this;\r\n}"
}, {
	"Path": "com.github.javaparser.utils.Utils.nextWord",
	"Comment": "return the next word of the string, in other words it stops when a space is encountered.",
	"Method": "String nextWord(String string){\r\n    int index = 0;\r\n    while (index < string.length() && !Character.isWhitespace(string.charAt(index))) {\r\n        index++;\r\n    }\r\n    return string.substring(0, index);\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.client.WebSocketClient.getAsyncWriteTimeout",
	"Comment": "return the number of milliseconds for a timeout of an attempted write operation.",
	"Method": "long getAsyncWriteTimeout(){\r\n    return getPolicy().getAsyncWriteTimeout();\r\n}"
}, {
	"Path": "org.javaee7.ejb.stateless.AccountSessionBeanTest.deployment",
	"Comment": "arquillian specific method for creating a file which can be deployedwhile executing the test.",
	"Method": "Archive<?> deployment(){\r\n    return ShrinkWrap.create(JavaArchive.class).addClass(AccountSessionBean.class).addAsManifestResource(EmptyAsset.INSTANCE, \"beans.xml\");\r\n}"
}, {
	"Path": "com.github.javaparser.ast.CompilationUnit.addAnnotationDeclaration",
	"Comment": "add an annotation declaration to the types of this compilation unit",
	"Method": "AnnotationDeclaration addAnnotationDeclaration(String name,AnnotationDeclaration addAnnotationDeclaration,String name,Modifier modifiers){\r\n    AnnotationDeclaration annotationDeclaration = new AnnotationDeclaration(Arrays.stream(modifiers).collect(Collectors.toCollection(() -> EnumSet.noneOf(Modifier.class))), name);\r\n    getTypes().add(annotationDeclaration);\r\n    annotationDeclaration.setParentNode(this);\r\n    return annotationDeclaration;\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.utils.Util.fileNamesAsURLs",
	"Comment": "treating the string as a separated list of filenames,convert and return the list of urls.",
	"Method": "List<URL> fileNamesAsURLs(String val,String delims){\r\n    String separators = DEFAULT_DELIMS;\r\n    if (delims == null)\r\n        delims = separators;\r\n    StringTokenizer tokenizer = new StringTokenizer(val, delims, false);\r\n    List<URL> urls = new ArrayList();\r\n    while (tokenizer.hasMoreTokens()) {\r\n        urls.add(BundleFileLocatorHelperFactory.getFactory().getHelper().getLocalURL(new URL(tokenizer.nextToken())));\r\n    }\r\n    return urls;\r\n}"
}, {
	"Path": "com.github.javaparser.metamodel.PropertyMetaModel.getMetaModelFieldName",
	"Comment": "the name of the field in the containing basenodemetamodel for this property meta model.",
	"Method": "String getMetaModelFieldName(){\r\n    return getName() + \"PropertyMetaModel\";\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.gzip.GzipTester.setContentServlet",
	"Comment": "set the servlet that provides content for the gziphandler in being tested.",
	"Method": "void setContentServlet(Class<? extends Servlet> servletClass){\r\n    String resourceBase = testdir.toString();\r\n    tester.setContextPath(\"/context\");\r\n    tester.setResourceBase(resourceBase);\r\n    ServletHolder servletHolder = tester.addServlet(servletClass, \"/\");\r\n    servletHolder.setInitParameter(\"baseDir\", resourceBase);\r\n    servletHolder.setInitParameter(\"etags\", \"true\");\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.ServletContextHandler.dynamicHolderAdded",
	"Comment": "notification that a servletregistration has been created so we can track the annotations",
	"Method": "ServletRegistration.Dynamic dynamicHolderAdded(ServletHolder holder){\r\n    return holder.getRegistration();\r\n}"
}, {
	"Path": "org.eclipse.jetty.jaas.JAASLoginService.setLoginModuleName",
	"Comment": "set the name to use to index into the configfile of loginmodules.",
	"Method": "void setLoginModuleName(String name){\r\n    _loginModuleName = name;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.CustomRequestLog.log",
	"Comment": "writes the request and response information to the output stream.",
	"Method": "void log(Request request,Response response){\r\n    try {\r\n        if (_ignorePathMap != null && _ignorePathMap.getMatch(request.getRequestURI()) != null)\r\n            return;\r\n        StringBuilder sb = _buffers.get();\r\n        sb.setLength(0);\r\n        _logHandle.invoke(sb, request, response);\r\n        String log = sb.toString();\r\n        _requestLogWriter.write(log);\r\n    } catch (Throwable e) {\r\n        LOG.warn(e);\r\n    }\r\n}"
}, {
	"Path": "io.github.javiewer.view.SimpleSearchView.setSuggestions",
	"Comment": "set adapter for suggestions list with the given suggestion array",
	"Method": "void setSuggestions(String[] suggestions){\r\n    if (suggestions != null && suggestions.length > 0) {\r\n        mTintView.setVisibility(VISIBLE);\r\n        final SearchAdapter adapter = new SearchAdapter(mContext, suggestions, suggestionIcon, ellipsize);\r\n        setAdapter(adapter);\r\n        setOnItemClickListener(new AdapterView.OnItemClickListener() {\r\n            @Override\r\n            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\r\n                setQuery((String) adapter.getItem(position), submit);\r\n            }\r\n        });\r\n    } else {\r\n        mTintView.setVisibility(GONE);\r\n    }\r\n}"
}, {
	"Path": "io.github.javiewer.view.SimpleSearchView.setSuggestions",
	"Comment": "set adapter for suggestions list with the given suggestion array",
	"Method": "void setSuggestions(String[] suggestions){\r\n    setQuery((String) adapter.getItem(position), submit);\r\n}"
}, {
	"Path": "org.olamy.FieldVerifier.isValidName",
	"Comment": "verifies that the specified name is valid for our service.in this example, we only require that the name is at least fourcharacters. in your application, you can use more complex checks to ensurethat usernames, passwords, email addresses, urls, and other fields have theproper syntax.",
	"Method": "boolean isValidName(String name){\r\n    if (name == null) {\r\n        return false;\r\n    }\r\n    return name.length() > 3;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.expr.Expression.calculateResolvedType",
	"Comment": "this constructor is used by the parser and is considered private.",
	"Method": "ResolvedType calculateResolvedType(){\r\n    return getSymbolResolver().calculateType(this);\r\n}"
}, {
	"Path": "org.eclipse.jetty.annotations.PostConstructAnnotationHandler.supportsPostConstruct",
	"Comment": "check if the given class is permitted to have postconstruct annotation.",
	"Method": "boolean supportsPostConstruct(Class c){\r\n    if (javax.servlet.Servlet.class.isAssignableFrom(c) || javax.servlet.Filter.class.isAssignableFrom(c) || javax.servlet.ServletContextListener.class.isAssignableFrom(c) || javax.servlet.ServletContextAttributeListener.class.isAssignableFrom(c) || javax.servlet.ServletRequestListener.class.isAssignableFrom(c) || javax.servlet.ServletRequestAttributeListener.class.isAssignableFrom(c) || javax.servlet.http.HttpSessionListener.class.isAssignableFrom(c) || javax.servlet.http.HttpSessionAttributeListener.class.isAssignableFrom(c) || javax.servlet.http.HttpSessionIdListener.class.isAssignableFrom(c) || javax.servlet.AsyncListener.class.isAssignableFrom(c) || javax.servlet.http.HttpUpgradeHandler.class.isAssignableFrom(c))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.Session.willPassivate",
	"Comment": "call the passivation listeners. this must be called holding the lock",
	"Method": "void willPassivate(){\r\n    HttpSessionEvent event = new HttpSessionEvent(this);\r\n    for (Iterator<String> iter = _sessionData.getKeys().iterator(); iter.hasNext(); ) {\r\n        Object value = _sessionData.getAttribute(iter.next());\r\n        if (value instanceof HttpSessionActivationListener) {\r\n            HttpSessionActivationListener listener = (HttpSessionActivationListener) value;\r\n            listener.sessionWillPassivate(event);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration.getVisibleField",
	"Comment": "consider only field or inherited field which is not private.",
	"Method": "ResolvedFieldDeclaration getVisibleField(String name){\r\n    Optional<ResolvedFieldDeclaration> field = getVisibleFields().stream().filter(f -> f.getName().equals(name)).findFirst();\r\n    if (field.isPresent()) {\r\n        return field.get();\r\n    } else {\r\n        throw new IllegalArgumentException();\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration.asInterface",
	"Comment": "return this as a interfacedeclaration or throw unsupportedoperationexception.",
	"Method": "ResolvedInterfaceDeclaration asInterface(){\r\n    throw new UnsupportedOperationException(String.format(\"%s is not an interface\", this));\r\n}"
}, {
	"Path": "org.eclipse.jetty.rewrite.handler.ValidUrlRule.setReason",
	"Comment": "sets the reason for the response status code. reasons will only reflect if the code value is greater or equal to 400.",
	"Method": "void setReason(String reason){\r\n    _reason = reason;\r\n}"
}, {
	"Path": "org.eclipse.jetty.rewrite.handler.RegexRule.setRegex",
	"Comment": "sets the regular expression string used to match with string uri.",
	"Method": "void setRegex(String regex){\r\n    _regex = regex == null ? null : Pattern.compile(regex);\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.resource.URLResource.addPath",
	"Comment": "returns the resource contained inside the current resource with thegiven name",
	"Method": "Resource addPath(String path){\r\n    if (path == null)\r\n        return null;\r\n    path = URIUtil.canonicalPath(path);\r\n    return newResource(URIUtil.addEncodedPaths(_url.toExternalForm(), URIUtil.encodePath(path)), _useCaches);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.IdleTimeoutHandler.setApplyToAsync",
	"Comment": "should the adjusted idle time be maintained for asynchronous requests",
	"Method": "void setApplyToAsync(boolean applyToAsync){\r\n    _applyToAsync = applyToAsync;\r\n}"
}, {
	"Path": "org.eclipse.jetty.start.PathFinder.setBase",
	"Comment": "set the active basepath, used for resolving relative paths.when a hit arrives for a subsequent find that has the same relative path as a prior hit, the new hit overrides the prior path as the active hit.",
	"Method": "void setBase(Path basePath){\r\n    this.basePath = basePath;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.ssl.SslContextFactory.loadKeyStore",
	"Comment": "override this method to provide alternate way to load a keystore.",
	"Method": "KeyStore loadKeyStore(Resource resource){\r\n    String storePassword = Objects.toString(_keyStorePassword, null);\r\n    return CertificateUtils.getKeyStore(resource, getKeyStoreType(), getKeyStoreProvider(), storePassword);\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.pathmap.PathMappings.getMatches",
	"Comment": "return a list of mappedresource matches for the specified path.",
	"Method": "List<MappedResource<E>> getMatches(String path){\r\n    boolean isRootPath = \"/\".equals(path);\r\n    List<MappedResource<E>> ret = new ArrayList();\r\n    for (MappedResource<E> mr : _mappings) {\r\n        switch(mr.getPathSpec().group) {\r\n            case ROOT:\r\n                if (isRootPath)\r\n                    ret.add(mr);\r\n                break;\r\n            case DEFAULT:\r\n                if (isRootPath || mr.getPathSpec().matches(path))\r\n                    ret.add(mr);\r\n                break;\r\n            default:\r\n                if (mr.getPathSpec().matches(path))\r\n                    ret.add(mr);\r\n                break;\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.github.javaparser.metamodel.PropertyMetaModel.getValue",
	"Comment": "introspects the node to get the value from this field.note that an optional empty field will return null here.",
	"Method": "Object getValue(Node node){\r\n    try {\r\n        for (Class<?> c = node.getClass(); c != null; c = c.getSuperclass()) {\r\n            Field[] fields = c.getDeclaredFields();\r\n            for (Field classField : fields) {\r\n                if (classField.getName().equals(getName())) {\r\n                    classField.setAccessible(true);\r\n                    return classField.get(node);\r\n                }\r\n            }\r\n        }\r\n        throw new NoSuchFieldError(getName());\r\n    } catch (IllegalAccessException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.javaee7.jaspic.basicauthentication.BasicAuthenticationStatelessTest.testPublicAccessIsStateless",
	"Comment": "tests that access to a public page does not depend on the authenticated identity that was established in a previousrequest.",
	"Method": "void testPublicAccessIsStateless(){\r\n    String response = getFromServerPath(\"public/servlet\");\r\n    assertTrue(\"Not authenticated, but a username other than null was encountered. \" + \"This is not correct.\", response.contains(\"web username: null\"));\r\n    assertTrue(\"Not authenticated, but the user seems to have the role \\\"architect\\\". \" + \"This is not correct.\", response.contains(\"web user has role \\\"architect\\\": false\"));\r\n    response = getFromServerPath(\"public/servlet?doLogin=true\");\r\n    assertTrue(\"User should have been authenticated and given name \\\"test\\\", \" + \" but does not appear to have this name\", response.contains(\"web username: test\"));\r\n    assertTrue(response.contains(\"web user has role \\\"architect\\\": true\"));\r\n    response = getFromServerPath(\"public/servlet\");\r\n    assertTrue(\"Should not be authenticated, but a username other than null was encountered. \" + \"Did the container remember the authenticated identity that was set in the previous request?\", response.contains(\"web username: null\"));\r\n    assertTrue(\"The unauthenticated user has the role 'architect', which should not be the case. \" + \"The container seemed to have remembered it from the previous request.\", response.contains(\"web user has role \\\"architect\\\": false\"));\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.DatabaseAdaptor.isRowIdReserved",
	"Comment": "rowid is a reserved word for oracle, so change the name of this column",
	"Method": "boolean isRowIdReserved(){\r\n    if (_dbName == null)\r\n        throw new IllegalStateException(\"DbAdaptor missing metadata\");\r\n    return (_dbName != null && _dbName.startsWith(\"oracle\"));\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.JavaSymbolSolver.inject",
	"Comment": "register this symbolresolver into a compilationunit, so that symbol resolution becomes available toall nodes part of the compilationunit.",
	"Method": "void inject(CompilationUnit destination){\r\n    destination.setData(Node.SYMBOL_RESOLVER_KEY, this);\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.ParameterDeclaration.describeType",
	"Comment": "describe the type of the parameter. in practice add three dots to the type nameis the parameter is variadic.",
	"Method": "String describeType(){\r\n    if (isVariadic()) {\r\n        return getType().asArrayType().getComponentType().describe() + \"...\";\r\n    } else {\r\n        return getType().describe();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.IPAddressMap.getMatch",
	"Comment": "retrieve the first map entry that is associated with the specified internet address by taking into account the wildcard specifications.",
	"Method": "Map.Entry<String, TYPE> getMatch(String addr){\r\n    if (addr != null) {\r\n        for (Map.Entry<String, TYPE> entry : super.entrySet()) {\r\n            if (_patterns.get(entry.getKey()).match(addr)) {\r\n                return entry;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.javaee7.jaspic.basicauthentication.BasicAuthenticationStatelessTest.testProtectedThenPublicAccessIsStateless",
	"Comment": "tests independently from being able to access a protected resource if any details of a previously establishedauthenticated identity are remembered",
	"Method": "void testProtectedThenPublicAccessIsStateless(){\r\n    String response = getFromServerPath(\"protected/servlet?doLogin=true\");\r\n    response = getFromServerPath(\"public/servlet\");\r\n    assertFalse(\"User principal was 'test', but it should be null here. \" + \"The container seemed to have remembered it from the previous request.\", response.contains(\"web username: test\"));\r\n    assertTrue(\"User principal was not null, but it should be null here. \", response.contains(\"web username: null\"));\r\n    assertTrue(\"The unauthenticated user has the role 'architect', which should not be the case. \" + \"The container seemed to have remembered it from the previous request.\", response.contains(\"web user has role \\\"architect\\\": false\"));\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved",
	"Comment": "create an unsolved reference specifying the type of the value expected.",
	"Method": "SymbolReference<S> unsolved(Class<S2> clazz){\r\n    return new SymbolReference<S>(Optional.<S>empty());\r\n}"
}, {
	"Path": "com.github.javaparser.ast.nodeTypes.NodeWithParameters.addAndGetParameter",
	"Comment": "remember to import the class in the compilation unit yourself",
	"Method": "Parameter addAndGetParameter(Type type,String name,Parameter addAndGetParameter,Class<?> paramClass,String name,Parameter addAndGetParameter,String className,String name,Parameter addAndGetParameter,Parameter parameter){\r\n    getParameters().add(parameter);\r\n    parameter.setParentNode((Node) this);\r\n    return parameter;\r\n}"
}, {
	"Path": "org.eclipse.jetty.client.util.DeferredContentProvider.offer",
	"Comment": "adds the given content buffer to this content providerand notifies the listener that content is available.",
	"Method": "boolean offer(ByteBuffer buffer,boolean offer,ByteBuffer buffer,Callback callback,boolean offer,Chunk chunk){\r\n    Throwable failure;\r\n    boolean result = false;\r\n    synchronized (lock) {\r\n        failure = this.failure;\r\n        if (failure == null) {\r\n            result = chunks.offer(chunk);\r\n            if (result && chunk != CLOSE)\r\n                ++size;\r\n        }\r\n    }\r\n    if (failure != null)\r\n        chunk.callback.failed(failure);\r\n    else if (result)\r\n        notifyListener();\r\n    return result;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.nodeTypes.NodeWithMembers.addPublicField",
	"Comment": "add a public field to this and automatically add the import of the type ifneeded",
	"Method": "FieldDeclaration addPublicField(Class<?> typeClass,String name,FieldDeclaration addPublicField,String type,String name,FieldDeclaration addPublicField,Type type,String name){\r\n    return addField(type, name, Modifier.PUBLIC);\r\n}"
}, {
	"Path": "org.eclipse.jetty.ant.JettyRunTask.execute",
	"Comment": "executes this ant task. the build flow is being stopped until jettyserver stops.",
	"Method": "void execute(){\r\n    TaskLog.log(\"Configuring Jetty for project: \" + getProject().getName());\r\n    setSystemProperties();\r\n    List<Connector> connectorsList = null;\r\n    if (connectors != null)\r\n        connectorsList = connectors.getConnectors();\r\n    else\r\n        connectorsList = new Connectors(jettyPort, 30000).getDefaultConnectors();\r\n    List<LoginService> loginServicesList = (loginServices != null ? loginServices.getLoginServices() : new ArrayList<LoginService>());\r\n    ServerProxyImpl server = new ServerProxyImpl();\r\n    server.setConnectors(connectorsList);\r\n    server.setLoginServices(loginServicesList);\r\n    server.setRequestLog(requestLog);\r\n    server.setJettyXml(jettyXml);\r\n    server.setDaemon(daemon);\r\n    server.setStopPort(stopPort);\r\n    server.setStopKey(stopKey);\r\n    server.setContextHandlers(contextHandlers);\r\n    server.setTempDirectory(tempDirectory);\r\n    server.setScanIntervalSecs(scanIntervalSeconds);\r\n    try {\r\n        for (WebAppContext webapp : webapps) {\r\n            server.addWebApplication((AntWebAppContext) webapp);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new BuildException(e);\r\n    }\r\n    server.start();\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.hasVariadicParameter",
	"Comment": "has the method or construcor a variadic parameter?note that when a method has a variadic parameter it should have an array type.",
	"Method": "boolean hasVariadicParameter(){\r\n    if (getNumberOfParams() == 0) {\r\n        return false;\r\n    } else {\r\n        return getParam(getNumberOfParams() - 1).isVariadic();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.AsyncDelayHandler.startHandling",
	"Comment": "called to indicate that a request has been presented for handling",
	"Method": "boolean startHandling(Request request,boolean restart){\r\n    return true;\r\n}"
}, {
	"Path": "org.javaee7.ejb.stateless.AccountSessionBeanWithInterfaceTest.deployment",
	"Comment": "arquillian specific method for creating a file which can be deployedwhile executing the test.",
	"Method": "Archive<?> deployment(){\r\n    return ShrinkWrap.create(JavaArchive.class).addClass(AccountSessionBeanWithInterface.class).addClass(Account.class).addAsManifestResource(EmptyAsset.INSTANCE, \"beans.xml\");\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.gzip.GzipHandler.getDeflaterPoolCapacity",
	"Comment": "gets the maximum number of deflaters that the deflaterpool can hold.",
	"Method": "int getDeflaterPoolCapacity(){\r\n    return POOL_CAPACITY;\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.ServletHolder.initMultiPart",
	"Comment": "register a servletrequestlistener that will ensure tmp multipartfiles are deleted when the request goes out of scope.",
	"Method": "void initMultiPart(){\r\n    if (((Registration) getRegistration()).getMultipartConfig() != null) {\r\n        ContextHandler ch = ContextHandler.getContextHandler(getServletHandler().getServletContext());\r\n        ch.addEventListener(MultiPartCleanerListener.INSTANCE);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.HttpParser.quickStart",
	"Comment": "quick lookahead for the start state looking for a request method or a http version,otherwise skip white space until something else to parse.",
	"Method": "boolean quickStart(ByteBuffer buffer){\r\n    if (_requestHandler != null) {\r\n        _method = HttpMethod.lookAheadGet(buffer);\r\n        if (_method != null) {\r\n            _methodString = _method.asString();\r\n            buffer.position(buffer.position() + _methodString.length() + 1);\r\n            setState(State.SPACE1);\r\n            return false;\r\n        }\r\n    } else if (_responseHandler != null) {\r\n        _version = HttpVersion.lookAheadGet(buffer);\r\n        if (_version != null) {\r\n            buffer.position(buffer.position() + _version.asString().length() + 1);\r\n            setState(State.SPACE1);\r\n            return false;\r\n        }\r\n    }\r\n    while (_state == State.START && buffer.hasRemaining()) {\r\n        HttpTokens.Token t = next(buffer);\r\n        if (t == null)\r\n            break;\r\n        switch(t.getType()) {\r\n            case ALPHA:\r\n            case DIGIT:\r\n            case TCHAR:\r\n            case VCHAR:\r\n                {\r\n                    _string.setLength(0);\r\n                    _string.append(t.getChar());\r\n                    setState(_requestHandler != null ? State.METHOD : State.RESPONSE_VERSION);\r\n                    return false;\r\n                }\r\n            case OTEXT:\r\n            case SPACE:\r\n            case HTAB:\r\n                throw new IllegalCharacterException(_state, t, buffer);\r\n            default:\r\n                break;\r\n        }\r\n        if (_maxHeaderBytes > 0 && ++_headerBytes > _maxHeaderBytes) {\r\n            LOG.warn(\"padding is too large >\" + _maxHeaderBytes);\r\n            throw new BadMessageException(HttpStatus.BAD_REQUEST_400);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.DefaultServletTest.testWelcomeRedirect_DirWithQuestion",
	"Comment": "ensure that oddball directory names are served with proper escaping",
	"Method": "void testWelcomeRedirect_DirWithQuestion(){\r\n    FS.ensureDirExists(docRoot);\r\n    context.setBaseResource(new PathResource(docRoot));\r\n    Path dir = assumeMkDirSupported(docRoot, \"dir?\");\r\n    Path index = dir.resolve(\"index.html\");\r\n    createFile(index, \"<h1>Hello Index<\/h1>\");\r\n    ServletHolder defholder = context.addServlet(DefaultServlet.class, \"/\");\r\n    defholder.setInitParameter(\"dirAllowed\", \"false\");\r\n    defholder.setInitParameter(\"redirectWelcome\", \"true\");\r\n    defholder.setInitParameter(\"welcomeServlets\", \"false\");\r\n    defholder.setInitParameter(\"gzip\", \"false\");\r\n    String rawResponse;\r\n    HttpTester.Response response;\r\n    rawResponse = connector.getResponse(\"GET /context/dir? HTTP/1.0\\r\\n\\r\\n\");\r\n    response = HttpTester.parseResponse(rawResponse);\r\n    assertThat(response.toString(), response.getStatus(), is(HttpStatus.MOVED_TEMPORARILY_302));\r\n    assertThat(response, containsHeaderValue(\"Location\", \"http://0.0.0.0/context/dir?/\"));\r\n    rawResponse = connector.getResponse(\"GET /context/dir?/ HTTP/1.0\\r\\n\\r\\n\");\r\n    response = HttpTester.parseResponse(rawResponse);\r\n    assertThat(response.toString(), response.getStatus(), is(HttpStatus.MOVED_TEMPORARILY_302));\r\n    assertThat(response, containsHeaderValue(\"Location\", \"http://0.0.0.0/context/dir?/index.html\"));\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.BufferUtil.allocate",
	"Comment": "allocate bytebuffer in flush mode.the position and limit will both be zero, indicating that the buffer isempty and must be flipped before any data is put to it.",
	"Method": "ByteBuffer allocate(int capacity){\r\n    ByteBuffer buf = ByteBuffer.allocate(capacity);\r\n    buf.limit(0);\r\n    return buf;\r\n}"
}, {
	"Path": "com.github.javaparser.ASTHelper.addTypeDeclaration",
	"Comment": "adds the given type declaration to the compilation unit. the list oftypes will be initialized if it is null.",
	"Method": "void addTypeDeclaration(CompilationUnit cu,TypeDeclaration type){\r\n    List<TypeDeclaration> types = cu.getTypes();\r\n    if (types == null) {\r\n        types = new ArrayList<TypeDeclaration>();\r\n        cu.setTypes(types);\r\n    }\r\n    types.add(type);\r\n}"
}, {
	"Path": "com.github.javaparser.ParserConfiguration.setAttributeComments",
	"Comment": "whether to run commentsinserter, which will put the comments that were found in the source code into the commentand javadoc fields of the nodes it thinks they refer to.",
	"Method": "ParserConfiguration setAttributeComments(boolean attributeComments){\r\n    this.attributeComments = attributeComments;\r\n    return this;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.types.ResolvedReferenceType.getFieldType",
	"Comment": "the type of the field could be different from the one in the corresponding fielddeclaration becausetype variables would be solved.",
	"Method": "Optional<ResolvedType> getFieldType(String name){\r\n    if (!typeDeclaration.hasField(name)) {\r\n        return Optional.empty();\r\n    }\r\n    ResolvedType type = typeDeclaration.getField(name).getType();\r\n    type = useThisTypeParametersOnTheGivenType(type);\r\n    return Optional.of(type);\r\n}"
}, {
	"Path": "org.eclipse.jetty.jndi.NamingContext.composeName",
	"Comment": "join two names together. these are treated ascompoundnames.",
	"Method": "Name composeName(Name name,Name prefix,String composeName,String name,String prefix){\r\n    if (name == null)\r\n        throw new NamingException(\"Name cannot be null\");\r\n    if (prefix == null)\r\n        throw new NamingException(\"Prefix cannot be null\");\r\n    Name compoundName = _parser.parse(prefix);\r\n    compoundName.add(name);\r\n    return compoundName.toString();\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.HttpInput.eof",
	"Comment": "this method should be called to signal that all the expected content arrived.",
	"Method": "boolean eof(){\r\n    return addContent(EOF_CONTENT);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.HttpConfiguration.setOutputBufferSize",
	"Comment": "set the size of the buffer into which response content is aggregatedbefore being sent to the client.a larger buffer can improve performance by allowinga content producer to run without blocking, however larger buffers consume more memory andmay induce some latency before a client starts processing the content.",
	"Method": "void setOutputBufferSize(int outputBufferSize){\r\n    _outputBufferSize = outputBufferSize;\r\n    setOutputAggregationSize(outputBufferSize / 4);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.SessionCache.renewSessionId",
	"Comment": "change the id of a session.this method has been superceded by the 4 arg renewsessionid method andshould no longer be called.",
	"Method": "Session renewSessionId(String oldId,String newId,Session renewSessionId,String oldId,String newId,String oldExtendedId,String newExtendedId){\r\n    return renewSessionId(oldId, newId);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.Session.doInvalidate",
	"Comment": "call httpsessionattributelisteners as part of invalidating a session.",
	"Method": "void doInvalidate(){\r\n    finishInvalidate();\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.getQualifiedName",
	"Comment": "the qualified name of the type parameter.it is composed by the qualified name of the container followed by a dot and the name of the type parameter.the qualified name of a method is its qualified signature.",
	"Method": "String getQualifiedName(){\r\n    return String.format(\"%s.%s\", getContainerId(), getName());\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.LocalConnector.executeRequest",
	"Comment": "execute a request and return the endpoint through whichmultiple responses can be received or more input provided.",
	"Method": "LocalEndPoint executeRequest(String rawRequest,LocalEndPoint executeRequest,ByteBuffer rawRequest){\r\n    if (!isStarted())\r\n        throw new IllegalStateException(\"!STARTED\");\r\n    LocalEndPoint endp = new LocalEndPoint();\r\n    endp.addInput(rawRequest);\r\n    _connects.add(endp);\r\n    return endp;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.CompilationUnit.getAnnotationDeclarationByName",
	"Comment": "try to get a top level annotation type declaration by its name",
	"Method": "Optional<AnnotationDeclaration> getAnnotationDeclarationByName(String annotationName){\r\n    return (AnnotationDeclaration) getTypes().stream().filter(type -> type.getName().equals(annotationName) && type instanceof AnnotationDeclaration).findFirst().orElse(null);\r\n}"
}, {
	"Path": "org.eclipse.jetty.jaas.spi.LdapLoginModule.getUserInfo",
	"Comment": "get the available information about the userfor this loginmodule, the credential can be null which will result in abinding ldap authentication scenarioroles are also an optional concept if required",
	"Method": "UserInfo getUserInfo(String username){\r\n    Attributes attributes = getUserAttributes(username);\r\n    String pwdCredential = getUserCredentials(attributes);\r\n    if (pwdCredential == null) {\r\n        return null;\r\n    }\r\n    pwdCredential = convertCredentialLdapToJetty(pwdCredential);\r\n    Credential credential = Credential.getCredential(pwdCredential);\r\n    return new LDAPUserInfo(username, credential, attributes);\r\n}"
}, {
	"Path": "org.eclipse.jetty.proxy.ProxyServletTest.testCachingProxy",
	"Comment": "only tests overridden proxyservlet behavior, see cachingproxyservlet",
	"Method": "void testCachingProxy(){\r\n    final byte[] content = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF };\r\n    startServer(new HttpServlet() {\r\n        @Override\r\n        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n            if (req.getHeader(\"Via\") != null)\r\n                resp.addHeader(PROXIED_HEADER, \"true\");\r\n            resp.getOutputStream().write(content);\r\n        }\r\n    });\r\n    startProxy(CachingProxyServlet.class);\r\n    startClient();\r\n    ContentResponse response = client.newRequest(\"localhost\", serverConnector.getLocalPort()).timeout(5, TimeUnit.SECONDS).send();\r\n    assertEquals(200, response.getStatus());\r\n    assertThat(response.getHeaders(), containsHeader(PROXIED_HEADER));\r\n    assertArrayEquals(content, response.getContent());\r\n    response = client.newRequest(\"localhost\", serverConnector.getLocalPort()).timeout(5, TimeUnit.SECONDS).send();\r\n    assertEquals(200, response.getStatus());\r\n    assertThat(response.getHeaders(), containsHeader(CachingProxyServlet.CACHE_HEADER));\r\n    assertArrayEquals(content, response.getContent());\r\n}"
}, {
	"Path": "org.eclipse.jetty.proxy.ProxyServletTest.testCachingProxy",
	"Comment": "only tests overridden proxyservlet behavior, see cachingproxyservlet",
	"Method": "void testCachingProxy(){\r\n    if (req.getHeader(\"Via\") != null)\r\n        resp.addHeader(PROXIED_HEADER, \"true\");\r\n    resp.getOutputStream().write(content);\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.pathmap.PathMappingsTest.testMixedMatchUriOrder",
	"Comment": "test the match order rules with a mixed servlet and uri template path specsexact matchlongest prefix matchlongest suffix match",
	"Method": "void testMixedMatchUriOrder(){\r\n    PathMappings<String> p = new PathMappings();\r\n    p.put(new ServletPathSpec(\"/\"), \"default\");\r\n    p.put(new ServletPathSpec(\"/animal/bird/*\"), \"birds\");\r\n    p.put(new ServletPathSpec(\"/animal/fish/*\"), \"fishes\");\r\n    p.put(new ServletPathSpec(\"/animal/*\"), \"animals\");\r\n    p.put(new UriTemplatePathSpec(\"/animal/{type}/{name}/chat\"), \"animalChat\");\r\n    p.put(new UriTemplatePathSpec(\"/animal/{type}/{name}/cam\"), \"animalCam\");\r\n    p.put(new UriTemplatePathSpec(\"/entrance/cam\"), \"entranceCam\");\r\n    assertMatch(p, \"/animal/bird/eagle\", \"birds\");\r\n    assertMatch(p, \"/animal/fish/bass/sea\", \"fishes\");\r\n    assertMatch(p, \"/animal/peccary/javalina/evolution\", \"animals\");\r\n    assertMatch(p, \"/\", \"default\");\r\n    assertMatch(p, \"/animal/bird/eagle/chat\", \"animalChat\");\r\n    assertMatch(p, \"/animal/bird/penguin/chat\", \"animalChat\");\r\n    assertMatch(p, \"/animal/fish/trout/cam\", \"animalCam\");\r\n    assertMatch(p, \"/entrance/cam\", \"entranceCam\");\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.events.EventDriverFactory.wrap",
	"Comment": "wrap the given websocket object instance in a suitable eventdriver",
	"Method": "EventDriver wrap(Object websocket){\r\n    if (websocket == null) {\r\n        throw new InvalidWebSocketException(\"null websocket object\");\r\n    }\r\n    for (EventDriverImpl impl : implementations) {\r\n        if (impl.supports(websocket)) {\r\n            try {\r\n                return impl.create(websocket, containerScope.getPolicy().clonePolicy());\r\n            } catch (Throwable e) {\r\n                throw new InvalidWebSocketException(\"Unable to create websocket\", e);\r\n            }\r\n        }\r\n    }\r\n    StringBuilder err = new StringBuilder();\r\n    err.append(getClassName(websocket));\r\n    err.append(\" is not a valid WebSocket object.\");\r\n    err.append(\"  Object must obey one of the following rules: \");\r\n    int len = implementations.size();\r\n    for (int i = 0; i < len; i++) {\r\n        EventDriverImpl impl = implementations.get(i);\r\n        if (i > 0) {\r\n            err.append(\" or \");\r\n        }\r\n        err.append(\"\\n(\").append(i + 1).append(\") \");\r\n        err.append(impl.describeRule());\r\n    }\r\n    throw new InvalidWebSocketException(err.toString());\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.gzip.GzipHandler.isMimeTypeGzipable",
	"Comment": "test if the provided mime type is allowed based on the mime type filters.",
	"Method": "boolean isMimeTypeGzipable(String mimetype){\r\n    return _mimeTypes.test(mimetype);\r\n}"
}, {
	"Path": "com.github.javaparser.ast.stmt.IfStmt.hasElseBlock",
	"Comment": "this method returns true if the if statement has an else branch and that branch is a block statement.",
	"Method": "boolean hasElseBlock(){\r\n    return elseStmt instanceof BlockStmt;\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.pathmap.PathMappingsTest.testUriTemplateMatchOrder",
	"Comment": "test the match order rules for uri template based specsexact matchlongest prefix matchlongest suffix match",
	"Method": "void testUriTemplateMatchOrder(){\r\n    PathMappings<String> p = new PathMappings();\r\n    p.put(new UriTemplatePathSpec(\"/a/{var}/c\"), \"endpointA\");\r\n    p.put(new UriTemplatePathSpec(\"/a/b/c\"), \"endpointB\");\r\n    p.put(new UriTemplatePathSpec(\"/a/{var1}/{var2}\"), \"endpointC\");\r\n    p.put(new UriTemplatePathSpec(\"/{var1}/d\"), \"endpointD\");\r\n    p.put(new UriTemplatePathSpec(\"/b/{var2}\"), \"endpointE\");\r\n    assertMatch(p, \"/a/b/c\", \"endpointB\");\r\n    assertMatch(p, \"/a/d/c\", \"endpointA\");\r\n    assertMatch(p, \"/a/x/y\", \"endpointC\");\r\n    assertMatch(p, \"/b/d\", \"endpointE\");\r\n}"
}, {
	"Path": "org.javaee7.jaspic.common.TestAuthConfigProvider.getServerAuthConfig",
	"Comment": "the actual factory method that creates the factory used to eventually obtain the delegate for a sam.",
	"Method": "ServerAuthConfig getServerAuthConfig(String layer,String appContext,CallbackHandler handler){\r\n    return new TestServerAuthConfig(layer, appContext, handler == null ? createDefaultCallbackHandler() : handler, providerProperties, serverAuthModule);\r\n}"
}, {
	"Path": "org.javaee7.jaxrs.endpoint.MyResourceTest.createDeployment",
	"Comment": "arquillian specific method for creating a file which can be deployedwhile executing the test.",
	"Method": "WebArchive createDeployment(){\r\n    WebArchive war = ShrinkWrap.create(WebArchive.class).addClass(MyApplication.class).addClass(Database.class).addClass(MyResource.class);\r\n    System.out.println(war.toString(true));\r\n    return war;\r\n}"
}, {
	"Path": "org.eclipse.jetty.plus.webapp.EnvConfiguration.bindEnvEntries",
	"Comment": "bind all enventries that have been declared, so that the processing of theweb.xml file can potentially override them.we first bind enventries declared in server scope, then webappcontext scope.",
	"Method": "void bindEnvEntries(WebAppContext context){\r\n    LOG.debug(\"Binding env entries from the jvm scope\");\r\n    InitialContext ic = new InitialContext();\r\n    Context envCtx = (Context) ic.lookup(\"java:comp/env\");\r\n    Object scope = null;\r\n    List<Object> list = NamingEntryUtil.lookupNamingEntries(scope, EnvEntry.class);\r\n    Iterator<Object> itor = list.iterator();\r\n    while (itor.hasNext()) {\r\n        EnvEntry ee = (EnvEntry) itor.next();\r\n        ee.bindToENC(ee.getJndiName());\r\n        Name namingEntryName = NamingEntryUtil.makeNamingEntryName(null, ee);\r\n        NamingUtil.bind(envCtx, namingEntryName.toString(), ee);\r\n    }\r\n    LOG.debug(\"Binding env entries from the server scope\");\r\n    scope = context.getServer();\r\n    list = NamingEntryUtil.lookupNamingEntries(scope, EnvEntry.class);\r\n    itor = list.iterator();\r\n    while (itor.hasNext()) {\r\n        EnvEntry ee = (EnvEntry) itor.next();\r\n        ee.bindToENC(ee.getJndiName());\r\n        Name namingEntryName = NamingEntryUtil.makeNamingEntryName(null, ee);\r\n        NamingUtil.bind(envCtx, namingEntryName.toString(), ee);\r\n    }\r\n    LOG.debug(\"Binding env entries from the context scope\");\r\n    scope = context;\r\n    list = NamingEntryUtil.lookupNamingEntries(scope, EnvEntry.class);\r\n    itor = list.iterator();\r\n    while (itor.hasNext()) {\r\n        EnvEntry ee = (EnvEntry) itor.next();\r\n        ee.bindToENC(ee.getJndiName());\r\n        Name namingEntryName = NamingEntryUtil.makeNamingEntryName(null, ee);\r\n        NamingUtil.bind(envCtx, namingEntryName.toString(), ee);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.security.PropertyUserStore.registerUserListener",
	"Comment": "registers a listener to be notified of the contents of the property file",
	"Method": "void registerUserListener(UserListener listener){\r\n    if (_listeners == null)\r\n        _listeners = new ArrayList();\r\n    _listeners.add(listener);\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration.solveType",
	"Comment": "this method is deprecated because it receives the typessolver as a parameter.eventually we would like to remove all usages of typesolver as a parameter.also, resolution should move out of declarations, so that they are pure declarations and the resolution shouldwork for javaparser, reflection and javassist classes in the same way and not be specific to the threeimplementations.",
	"Method": "SymbolReference<ResolvedTypeDeclaration> solveType(String name){\r\n    if (this.wrappedNode.getName().getId().equals(name)) {\r\n        return SymbolReference.solved(this);\r\n    }\r\n    SymbolReference<TypeDeclaration> ref = javaParserTypeAdapter.solveType(name, typeSolver);\r\n    if (ref.isSolved()) {\r\n        return ref;\r\n    }\r\n    String prefix = wrappedNode.getName() + \".\";\r\n    if (name.startsWith(prefix) && name.length() > prefix.length()) {\r\n        return new JavaParserInterfaceDeclaration(this.wrappedNode, typeSolver).solveType(name.substring(prefix.length()), typeSolver);\r\n    }\r\n    return getContext().getParent().solveType(name, typeSolver);\r\n}"
}, {
	"Path": "com.github.javaparser.printer.lexicalpreservation.Difference.considerEnforcingIndentation",
	"Comment": "if we are at the beginning of a line, with just spaces or tabs before us we should force the space to bethe same as the indentation.",
	"Method": "int considerEnforcingIndentation(NodeText nodeText,int nodeTextIndex){\r\n    boolean hasOnlyWsBefore = true;\r\n    for (int i = nodeTextIndex; i >= 0 && hasOnlyWsBefore && i < nodeText.getElements().size(); i--) {\r\n        if (nodeText.getElements().get(i).isNewline()) {\r\n            break;\r\n        }\r\n        if (!nodeText.getElements().get(i).isSpaceOrTab()) {\r\n            hasOnlyWsBefore = false;\r\n        }\r\n    }\r\n    if (hasOnlyWsBefore) {\r\n        for (int i = nodeTextIndex; i >= 0 && i < nodeText.getElements().size(); i--) {\r\n            if (nodeText.getElements().get(i).isNewline()) {\r\n                break;\r\n            }\r\n            nodeText.removeElement(i);\r\n        }\r\n    }\r\n    return nodeTextIndex;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration.getWrappedNode",
	"Comment": "returns the javaparser node associated with this javaparserinterfacedeclaration.",
	"Method": "ClassOrInterfaceDeclaration getWrappedNode(){\r\n    return wrappedNode;\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.MultiPartFormInputStream.deleteParts",
	"Comment": "delete any tmp storage for parts, and clear out the parts list.",
	"Method": "void deleteParts(){\r\n    if (!_parsed)\r\n        return;\r\n    Collection<Part> parts;\r\n    try {\r\n        parts = getParts();\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    MultiException err = null;\r\n    for (Part p : parts) {\r\n        try {\r\n            ((MultiPart) p).cleanUp();\r\n        } catch (Exception e) {\r\n            if (err == null)\r\n                err = new MultiException();\r\n            err.add(e);\r\n        }\r\n    }\r\n    _parts.clear();\r\n    if (err != null)\r\n        err.ifExceptionThrowRuntime();\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.HttpOutput.closed",
	"Comment": "called to indicate that the last write has been performed.it updates the state and performs cleanup operations.",
	"Method": "void closed(){\r\n    while (true) {\r\n        OutputState state = _state.get();\r\n        switch(state) {\r\n            case CLOSED:\r\n                {\r\n                    return;\r\n                }\r\n            case UNREADY:\r\n                {\r\n                    if (_state.compareAndSet(state, OutputState.ERROR))\r\n                        _writeListener.onError(_onError == null ? new EofException(\"Async closed\") : _onError);\r\n                    break;\r\n                }\r\n            default:\r\n                {\r\n                    if (!_state.compareAndSet(state, OutputState.CLOSED))\r\n                        break;\r\n                    try {\r\n                        _channel.getResponse().closeOutput();\r\n                    } catch (Throwable x) {\r\n                        if (LOG.isDebugEnabled())\r\n                            LOG.debug(x);\r\n                        abort(x);\r\n                    } finally {\r\n                        releaseBuffer();\r\n                    }\r\n                    return;\r\n                }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.FileSessionDataStore.isOurContextSessionFilename",
	"Comment": "check if the filename matches our session patternand is a session for our context.",
	"Method": "boolean isOurContextSessionFilename(String filename){\r\n    if (StringUtil.isBlank(filename))\r\n        return false;\r\n    String[] parts = filename.split(\"_\");\r\n    if (parts.length < 4)\r\n        return false;\r\n    String context = getContextFromFilename(filename);\r\n    if (context == null)\r\n        return false;\r\n    return (_contextString.equals(context));\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.ContextHandler.setMaxFormKeys",
	"Comment": "set the maximum number of form keys to protect against dos attack from crafted hash keys.",
	"Method": "void setMaxFormKeys(int max){\r\n    _maxFormKeys = max;\r\n}"
}, {
	"Path": "org.eclipse.jetty.security.ConstraintSecurityHandler.processConstraintMapping",
	"Comment": "create and combine the constraint with the existing processedconstraints.",
	"Method": "void processConstraintMapping(ConstraintMapping mapping){\r\n    Map<String, RoleInfo> mappings = _constraintMap.get(mapping.getPathSpec());\r\n    if (mappings == null) {\r\n        mappings = new HashMap<String, RoleInfo>();\r\n        _constraintMap.put(mapping.getPathSpec(), mappings);\r\n    }\r\n    RoleInfo allMethodsRoleInfo = mappings.get(ALL_METHODS);\r\n    if (allMethodsRoleInfo != null && allMethodsRoleInfo.isForbidden())\r\n        return;\r\n    if (mapping.getMethodOmissions() != null && mapping.getMethodOmissions().length > 0) {\r\n        processConstraintMappingWithMethodOmissions(mapping, mappings);\r\n        return;\r\n    }\r\n    String httpMethod = mapping.getMethod();\r\n    if (httpMethod == null)\r\n        httpMethod = ALL_METHODS;\r\n    RoleInfo roleInfo = mappings.get(httpMethod);\r\n    if (roleInfo == null) {\r\n        roleInfo = new RoleInfo();\r\n        mappings.put(httpMethod, roleInfo);\r\n        if (allMethodsRoleInfo != null) {\r\n            roleInfo.combine(allMethodsRoleInfo);\r\n        }\r\n    }\r\n    if (roleInfo.isForbidden())\r\n        return;\r\n    configureRoleInfo(roleInfo, mapping);\r\n    if (roleInfo.isForbidden()) {\r\n        if (httpMethod.equals(ALL_METHODS)) {\r\n            mappings.clear();\r\n            mappings.put(ALL_METHODS, roleInfo);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.start.Classpath.overlay",
	"Comment": "overlay another classpath, copying its elements into place on this classpath, while eliminating duplicate entries on the classpath.",
	"Method": "void overlay(Classpath other){\r\n    for (File otherElement : other.elements) {\r\n        if (this.elements.contains(otherElement)) {\r\n            continue;\r\n        }\r\n        this.elements.add(otherElement);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.AbstractSessionCache.delete",
	"Comment": "remove a session object from this store and from any backing store.",
	"Method": "Session delete(String id){\r\n    Session session = get(id);\r\n    if (_sessionDataStore != null) {\r\n        boolean dsdel = _sessionDataStore.delete(id);\r\n        if (LOG.isDebugEnabled())\r\n            LOG.debug(\"Session {} deleted in session data store {}\", id, dsdel);\r\n    }\r\n    if (session != null) {\r\n        session.setResident(false);\r\n    }\r\n    return doDelete(id);\r\n}"
}, {
	"Path": "org.eclipse.jetty.maven.plugin.JettyWebAppContext.setResourceBases",
	"Comment": "this method is provided as a convenience for jetty maven plugin configuration",
	"Method": "void setResourceBases(String[] resourceBases){\r\n    List<String> resources = new ArrayList<String>();\r\n    for (String rl : resourceBases) {\r\n        String[] rs = StringUtil.csvSplit(rl);\r\n        for (String r : rs) resources.add(r);\r\n    }\r\n    setBaseResource(new ResourceCollection(resources.toArray(new String[resources.size()])));\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.ssl.SslContextFactory.loadTrustStore",
	"Comment": "override this method to provide alternate way to load a truststore.",
	"Method": "KeyStore loadTrustStore(Resource resource){\r\n    String type = Objects.toString(getTrustStoreType(), getKeyStoreType());\r\n    String provider = Objects.toString(getTrustStoreProvider(), getKeyStoreProvider());\r\n    Password passwd = _trustStorePassword;\r\n    if (resource == null || resource.equals(_keyStoreResource)) {\r\n        resource = _keyStoreResource;\r\n        if (passwd == null)\r\n            passwd = _keyStorePassword;\r\n    }\r\n    return CertificateUtils.getKeyStore(resource, type, provider, Objects.toString(passwd, null));\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.getId",
	"Comment": "the id corresponds most of the type to the qualified name. it differs only for localclasses which do not have a qualified name but have an id.",
	"Method": "String getId(){\r\n    String qname = getQualifiedName();\r\n    if (qname == null) {\r\n        return String.format(\"<localClass>:%s\", getName());\r\n    }\r\n    return qname;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.log.StdErrLog.getLogger",
	"Comment": "obtain a stderrlog reference for the specified class, a convenience method used most often during testing to allow for control over a specific logger.must be actively using stderrlog as the logger implementation.",
	"Method": "StdErrLog getLogger(Class<?> clazz){\r\n    Logger log = Log.getLogger(clazz);\r\n    if (log instanceof StdErrLog) {\r\n        return (StdErrLog) log;\r\n    }\r\n    throw new RuntimeException(\"Logger for \" + clazz + \" is not of type StdErrLog\");\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.ContextHandler.addAliasCheck",
	"Comment": "add an aliascheck instance to possibly permit aliased resources",
	"Method": "void addAliasCheck(AliasCheck check){\r\n    _aliasChecks.add(check);\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration.getWrappedNode",
	"Comment": "returns the javaparser node associated with this javaparsersymboldeclaration.",
	"Method": "Node getWrappedNode(){\r\n    return wrappedNode;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.resolution.typeinference.ExpressionHelper.appearsInAssignmentContext",
	"Comment": "not sure if should look if the parent is an assignment context",
	"Method": "boolean appearsInAssignmentContext(Expression expression){\r\n    if (expression.getParentNode().isPresent()) {\r\n        Node parent = expression.getParentNode().get();\r\n        if (parent instanceof ExpressionStmt) {\r\n            return false;\r\n        }\r\n        if (parent instanceof MethodCallExpr) {\r\n            return false;\r\n        }\r\n        if (parent instanceof ReturnStmt) {\r\n            return false;\r\n        }\r\n        throw new UnsupportedOperationException(parent.getClass().getCanonicalName());\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.javaee7.util.BatchTestHelper.keepTestAlive",
	"Comment": "we need to keep the test running because joboperator runs the batch job in an asynchronous way.returns when either the job execution completes or we have polled the maximum number of tries.",
	"Method": "JobExecution keepTestAlive(JobExecution jobExecution){\r\n    System.out.println(\" * Entering keepTestAlive, completed is: \" + jobExecution.getBatchStatus().equals(COMPLETED));\r\n    int maxTries = 0;\r\n    while (!jobExecution.getBatchStatus().equals(COMPLETED)) {\r\n        if (maxTries < MAX_TRIES) {\r\n            maxTries++;\r\n            Thread.sleep(THREAD_SLEEP);\r\n            jobExecution = BatchRuntime.getJobOperator().getJobExecution(jobExecution.getExecutionId());\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    Thread.sleep(THREAD_SLEEP);\r\n    System.out.println(\" * Exiting keepTestAlive, completed is: \" + jobExecution.getBatchStatus().equals(COMPLETED));\r\n    return jobExecution;\r\n}"
}, {
	"Path": "org.eclipse.jetty.ant.types.SystemProperties.setIfNotSetAlready",
	"Comment": "set a system.property with this value if it is not already set.",
	"Method": "boolean setIfNotSetAlready(Property property){\r\n    if (System.getProperty(property.getName()) == null) {\r\n        System.setProperty(property.getName(), (property.getValue() == null ? \"\" : property.getValue()));\r\n        TaskLog.log(\"Setting property '\" + property.getName() + \"' to value '\" + property.getValue() + \"'\");\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jetty.jstl.JspIncludeTest.getPotentialBody",
	"Comment": "attempt to obtain the body text if available. do not throw an exception if body is unable to be fetched.",
	"Method": "String getPotentialBody(HttpURLConnection connection){\r\n    InputStream in = null;\r\n    InputStreamReader reader = null;\r\n    try {\r\n        in = connection.getInputStream();\r\n        reader = new InputStreamReader(in);\r\n        StringWriter writer = new StringWriter();\r\n        IO.copy(reader, writer);\r\n        return writer.toString();\r\n    } catch (IOException e) {\r\n        return \"<no body:\" + e.getMessage() + \">\";\r\n    } finally {\r\n        IO.close(reader);\r\n        IO.close(in);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.security.authentication.ClientCertAuthenticator.getKeyStore",
	"Comment": "loads keystore using an input stream or a file path in the sameorder of precedence.required for integrations to be able to override the mechanismused to load a keystore in order to provide their own implementation.",
	"Method": "KeyStore getKeyStore(InputStream storeStream,String storePath,String storeType,String storeProvider,String storePassword,KeyStore getKeyStore,String storePath,String storeType,String storeProvider,String storePassword){\r\n    return CertificateUtils.getKeyStore(Resource.newResource(storePath), storeType, storeProvider, storePassword);\r\n}"
}, {
	"Path": "com.github.javaparser.ast.expr.Name.isTopLevel",
	"Comment": "a top level name is a name that is not contained in a larger name instance.",
	"Method": "boolean isTopLevel(){\r\n    return !isInternal();\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getFieldType",
	"Comment": "the type of the field could be different from the one in the corresponding fielddeclaration becausetype variables would be solved.",
	"Method": "Optional<Type> getFieldType(String name){\r\n    if (!typeDeclaration.hasField(name)) {\r\n        return Optional.empty();\r\n    }\r\n    Type type = typeDeclaration.getField(name).getType();\r\n    type = useThisTypeParametersOnTheGivenType(type);\r\n    return Optional.of(type);\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedInterfaceDeclaration.getAllInterfacesExtended",
	"Comment": "return the list of interfaces extended directly or indirectly by this one.",
	"Method": "List<ResolvedReferenceType> getAllInterfacesExtended(){\r\n    List<ResolvedReferenceType> interfaces = new ArrayList();\r\n    for (ResolvedReferenceType interfaceDeclaration : getInterfacesExtended()) {\r\n        interfaces.add(interfaceDeclaration);\r\n        interfaces.addAll(interfaceDeclaration.getAllInterfacesAncestors());\r\n    }\r\n    return interfaces;\r\n}"
}, {
	"Path": "com.github.javaparser.javadoc.Javadoc.toComment",
	"Comment": "create a javadoccomment, by formatting the text of the javadoc using the given indentation.",
	"Method": "JavadocComment toComment(JavadocComment toComment,String indentation){\r\n    for (char c : indentation.toCharArray()) {\r\n        if (!Character.isWhitespace(c)) {\r\n            throw new IllegalArgumentException(\"The indentation string should be composed only by whitespace characters\");\r\n        }\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(EOL);\r\n    final String text = toText();\r\n    if (!text.isEmpty()) {\r\n        for (String line : text.split(EOL)) {\r\n            sb.append(indentation);\r\n            sb.append(\" * \");\r\n            sb.append(line);\r\n            sb.append(EOL);\r\n        }\r\n    }\r\n    sb.append(indentation);\r\n    sb.append(\" \");\r\n    return new JavadocComment(sb.toString());\r\n}"
}, {
	"Path": "com.github.javaparser.ast.nodeTypes.NodeWithAnnotations.addSingleMemberAnnotation",
	"Comment": "annotates this with a single member annotation and automatically add the import",
	"Method": "N addSingleMemberAnnotation(String name,Expression expression,N addSingleMemberAnnotation,Class<? extends Annotation> clazz,Expression expression,N addSingleMemberAnnotation,String name,String value,N addSingleMemberAnnotation,Class<? extends Annotation> clazz,String value){\r\n    ((Node) this).tryAddImportToParentCompilationUnit(clazz);\r\n    return addSingleMemberAnnotation(clazz.getSimpleName(), value);\r\n}"
}, {
	"Path": "org.eclipse.jetty.jaas.spi.DataSourceLoginModule.initialize",
	"Comment": "init loginmodule.called once by jaas after new instance created.",
	"Method": "void initialize(Subject subject,CallbackHandler callbackHandler,Map<String, ?> sharedState,Map<String, ?> options){\r\n    try {\r\n        super.initialize(subject, callbackHandler, sharedState, options);\r\n        dbJNDIName = (String) options.get(\"dbJNDIName\");\r\n        InitialContext ic = new InitialContext();\r\n        dataSource = (DataSource) ic.lookup(\"java:comp/env/\" + dbJNDIName);\r\n    } catch (NamingException e) {\r\n        throw new IllegalStateException(e.toString());\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.overlays.OverlayedAppProvider.createContextHandler",
	"Comment": "create context handler.callback from the deployment manager to create a context handler instance.",
	"Method": "ContextHandler createContextHandler(App app){\r\n    final OverlayedApp overlayed = (OverlayedApp) app;\r\n    final String origin = overlayed.getOriginId();\r\n    final Instance instance = overlayed.getInstance();\r\n    final Template template = instance.getTemplate();\r\n    final Webapp webapp = template.getWebapp();\r\n    final Node node = _node;\r\n    ClassLoader orig_loader = Thread.currentThread().getContextClassLoader();\r\n    try {\r\n        String key = (node == null ? \"\" : node.getLoadedKey()) + template.getLoadedKey() + (webapp == null ? \"\" : webapp.getLoadedKey());\r\n        instance.setSharedKey(key);\r\n        TemplateContext shared = _shared.get(key);\r\n        if (shared == null)\r\n            shared = createTemplateContext(key, webapp, template, node, orig_loader);\r\n        ClassLoader shared_loader = shared.getWebappLoader() != null ? shared.getWebappLoader() : (shared.getLibLoader() != null ? shared.getLibLoader() : orig_loader);\r\n        ClassLoader loader = shared_loader;\r\n        Resource instance_lib = instance.getResource(LIB);\r\n        if (instance_lib.exists()) {\r\n            List<URL> libs = new ArrayList<URL>();\r\n            for (String jar : instance_lib.list()) {\r\n                if (!jar.toLowerCase(Locale.ENGLISH).endsWith(\".jar\"))\r\n                    continue;\r\n                libs.add(instance_lib.addPath(jar).getURL());\r\n            }\r\n            __log.debug(\"{}: libs={}\", origin, libs);\r\n            loader = URLClassLoader.newInstance(libs.toArray(new URL[] {}), loader);\r\n        }\r\n        Thread.currentThread().setContextClassLoader(loader);\r\n        Map<String, Object> idMap = new HashMap<String, Object>();\r\n        idMap.putAll(shared.getIdMap());\r\n        idMap.put(_serverID, getDeploymentManager().getServer());\r\n        ContextHandler context = null;\r\n        Resource template_context_xml = template.getResource(OVERLAY_XML);\r\n        if (template_context_xml.exists()) {\r\n            __log.debug(\"{}: overlay.xml={}\", origin, template_context_xml);\r\n            XmlConfiguration xmlc = newXmlConfiguration(template_context_xml.getURL(), idMap, template, instance);\r\n            context = (ContextHandler) xmlc.configure();\r\n            idMap = xmlc.getIdMap();\r\n        } else if (webapp == null)\r\n            context = new ContextHandler();\r\n        else\r\n            context = new WebAppContext();\r\n        final Resource instance_webapp = instance.getResource(WEBAPP);\r\n        if (instance_webapp.exists()) {\r\n            context.setBaseResource(new ResourceCollection(instance_webapp, shared.getBaseResource()));\r\n            ResourceCache cache = new ResourceCache(shared.getResourceCache(), instance_webapp, context.getMimeTypes(), false, false);\r\n            context.setAttribute(ResourceCache.class.getCanonicalName(), cache);\r\n        } else {\r\n            context.setBaseResource(shared.getBaseResource());\r\n            context.setAttribute(ResourceCache.class.getCanonicalName(), shared.getResourceCache());\r\n        }\r\n        __log.debug(\"{}: baseResource={}\", origin, context.getResourceBase());\r\n        context.setAttribute(\"org.eclipse.jetty.server.session.timer\", _sessionScavenger);\r\n        for (Resource context_xml : getLayeredResources(OVERLAY_XML, node, instance)) {\r\n            __log.debug(\"{}: overlay.xml={}\", origin, context_xml);\r\n            XmlConfiguration xmlc = newXmlConfiguration(context_xml.getURL(), idMap, template, instance);\r\n            xmlc.getIdMap().put(\"Cache\", context.getAttribute(ResourceCache.class.getCanonicalName()));\r\n            xmlc.configure(context);\r\n            idMap = xmlc.getIdMap();\r\n        }\r\n        if (context instanceof WebAppContext) {\r\n            final WebAppContext webappcontext = (WebAppContext) context;\r\n            if (Arrays.asList(((WebAppContext) context).getServerClasses()).toString().equals(Arrays.asList(WebAppContext.__dftServerClasses).toString())) {\r\n                __log.debug(\"clear server classes\");\r\n                webappcontext.setServerClasses(null);\r\n            }\r\n            webappcontext.setCopyWebDir(false);\r\n            webappcontext.setCopyWebInf(false);\r\n            webappcontext.setExtractWAR(false);\r\n            if (instance_webapp.exists()) {\r\n                final Resource classes = instance_webapp.addPath(\"WEB-INF/classes\");\r\n                final Resource lib = instance_webapp.addPath(\"WEB-INF/lib\");\r\n                if (classes.exists() || lib.exists()) {\r\n                    final AtomicBoolean locked = new AtomicBoolean(false);\r\n                    WebAppClassLoader webapp_loader = new WebAppClassLoader(loader, webappcontext) {\r\n                        @Override\r\n                        public void addClassPath(Resource resource) throws IOException {\r\n                            if (!locked.get())\r\n                                super.addClassPath(resource);\r\n                        }\r\n                        @Override\r\n                        public void addClassPath(String classPath) throws IOException {\r\n                            if (!locked.get())\r\n                                super.addClassPath(classPath);\r\n                        }\r\n                        @Override\r\n                        public void addJars(Resource lib) {\r\n                            if (!locked.get())\r\n                                super.addJars(lib);\r\n                        }\r\n                    };\r\n                    if (classes.exists())\r\n                        webapp_loader.addClassPath(classes);\r\n                    if (lib.exists())\r\n                        webapp_loader.addJars(lib);\r\n                    locked.set(true);\r\n                    loader = webapp_loader;\r\n                }\r\n            }\r\n            if (loader == shared_loader)\r\n                loader = new URLClassLoader(new URL[] {}, shared_loader);\r\n            List<Resource> webdefaults = getLayeredResources(WEB_DEFAULT_XML, instance, node, template);\r\n            if (webdefaults.size() > 0) {\r\n                Resource webdefault = webdefaults.get(0);\r\n                __log.debug(\"{}: defaultweb={}\", origin, webdefault);\r\n                webappcontext.setDefaultsDescriptor(webdefault.toString());\r\n            }\r\n            for (Resource override : getLayeredResources(WEB_FRAGMENT_XML, template, node, instance)) {\r\n                __log.debug(\"{}: web override={}\", origin, override);\r\n                webappcontext.addOverrideDescriptor(override.toString());\r\n            }\r\n        }\r\n        context.setClassLoader(loader);\r\n        __log.debug(\"{}: baseResource={}\", origin, context.getBaseResource());\r\n        Resource jetty_web_xml = context.getResource(\"/WEB-INF/\" + JettyWebXmlConfiguration.JETTY_WEB_XML);\r\n        if (jetty_web_xml != null && jetty_web_xml.exists())\r\n            context.setAttribute(JettyWebXmlConfiguration.XML_CONFIGURATION, newXmlConfiguration(jetty_web_xml.getURL(), idMap, template, instance));\r\n        Map<String, String> params = new HashMap<String, String>();\r\n        populateParameters(params, template, instance);\r\n        context.addEventListener(new ParameterExpander(params, context));\r\n        System.err.println(\"created:\\n\" + context.dump());\r\n        return context;\r\n    } finally {\r\n        Thread.currentThread().setContextClassLoader(orig_loader);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.overlays.OverlayedAppProvider.createContextHandler",
	"Comment": "create context handler.callback from the deployment manager to create a context handler instance.",
	"Method": "ContextHandler createContextHandler(App app){\r\n    if (!locked.get())\r\n        super.addClassPath(resource);\r\n}"
}, {
	"Path": "org.eclipse.jetty.overlays.OverlayedAppProvider.createContextHandler",
	"Comment": "create context handler.callback from the deployment manager to create a context handler instance.",
	"Method": "ContextHandler createContextHandler(App app){\r\n    if (!locked.get())\r\n        super.addClassPath(classPath);\r\n}"
}, {
	"Path": "org.eclipse.jetty.overlays.OverlayedAppProvider.createContextHandler",
	"Comment": "create context handler.callback from the deployment manager to create a context handler instance.",
	"Method": "ContextHandler createContextHandler(App app){\r\n    if (!locked.get())\r\n        super.addJars(lib);\r\n}"
}, {
	"Path": "com.github.javaparser.JavaToken.deleteToken",
	"Comment": "links the tokens around the current token together, making the current token disappear from the list.",
	"Method": "void deleteToken(){\r\n    final Optional<JavaToken> nextToken = getNextToken();\r\n    final Optional<JavaToken> previousToken = getPreviousToken();\r\n    previousToken.ifPresent(p -> p.nextToken = nextToken.orElse(null));\r\n    nextToken.ifPresent(n -> n.previousToken = previousToken.orElse(null));\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.MultiPartInputStreamParser.getParts",
	"Comment": "parse, if necessary, the multipart data and return the list of parts.",
	"Method": "Collection<Part> getParts(){\r\n    if (!_parsed)\r\n        parse();\r\n    throwIfError();\r\n    Collection<List<Part>> values = _parts.values();\r\n    List<Part> parts = new ArrayList();\r\n    for (List<Part> o : values) {\r\n        List<Part> asList = LazyList.getList(o, false);\r\n        parts.addAll(asList);\r\n    }\r\n    return parts;\r\n}"
}, {
	"Path": "org.eclipse.jetty.annotations.ResourceAnnotationHandler.handleMethod",
	"Comment": "process a resource annotation on a method.this will generate a jndi entry, and an injection to beprocessed when an instance of the class is created.",
	"Method": "void handleMethod(Class<?> clazz,Method method){\r\n    Resource resource = (Resource) method.getAnnotation(Resource.class);\r\n    if (resource != null) {\r\n        if (Modifier.isStatic(method.getModifiers())) {\r\n            LOG.warn(\"Skipping Resource annotation on \" + clazz.getName() + \".\" + method.getName() + \": cannot be static\");\r\n            return;\r\n        }\r\n        if (!method.getName().startsWith(\"set\")) {\r\n            LOG.warn(\"Skipping Resource annotation on \" + clazz.getName() + \".\" + method.getName() + \": invalid java bean, does not start with 'set'\");\r\n            return;\r\n        }\r\n        if (method.getParameterCount() != 1) {\r\n            LOG.warn(\"Skipping Resource annotation on \" + clazz.getName() + \".\" + method.getName() + \": invalid java bean, not single argument to method\");\r\n            return;\r\n        }\r\n        if (Void.TYPE != method.getReturnType()) {\r\n            LOG.warn(\"Skipping Resource annotation on \" + clazz.getName() + \".\" + method.getName() + \": invalid java bean, not void\");\r\n            return;\r\n        }\r\n        String name = method.getName().substring(3);\r\n        name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);\r\n        name = clazz.getCanonicalName() + \"/\" + name;\r\n        name = (resource.name() != null && !resource.name().trim().equals(\"\") ? resource.name() : name);\r\n        String mappedName = (resource.mappedName() != null && !resource.mappedName().trim().equals(\"\") ? resource.mappedName() : null);\r\n        Class<?> paramType = method.getParameterTypes()[0];\r\n        Class<?> resourceType = resource.type();\r\n        MetaData metaData = _context.getMetaData();\r\n        if (metaData.getOriginDescriptor(\"resource-ref.\" + name + \".injection\") != null) {\r\n            return;\r\n        }\r\n        InjectionCollection injections = (InjectionCollection) _context.getAttribute(InjectionCollection.INJECTION_COLLECTION);\r\n        if (injections == null) {\r\n            injections = new InjectionCollection();\r\n            _context.setAttribute(InjectionCollection.INJECTION_COLLECTION, injections);\r\n        }\r\n        Injection injection = injections.getInjection(name, clazz, method, paramType);\r\n        if (injection == null) {\r\n            try {\r\n                boolean bound = org.eclipse.jetty.plus.jndi.NamingEntryUtil.bindToENC(_context, name, mappedName);\r\n                if (!bound)\r\n                    bound = org.eclipse.jetty.plus.jndi.NamingEntryUtil.bindToENC(_context.getServer(), name, mappedName);\r\n                if (!bound)\r\n                    bound = org.eclipse.jetty.plus.jndi.NamingEntryUtil.bindToENC(null, name, mappedName);\r\n                if (!bound) {\r\n                    try {\r\n                        InitialContext ic = new InitialContext();\r\n                        String nameInEnvironment = (mappedName != null ? mappedName : name);\r\n                        ic.lookup(\"java:comp/env/\" + nameInEnvironment);\r\n                        bound = true;\r\n                    } catch (NameNotFoundException e) {\r\n                        bound = false;\r\n                    }\r\n                }\r\n                if (bound) {\r\n                    LOG.debug(\"Bound \" + (mappedName == null ? name : mappedName) + \" as \" + name);\r\n                    injection = new Injection();\r\n                    injection.setTarget(clazz, method, paramType, resourceType);\r\n                    injection.setJndiName(name);\r\n                    injection.setMappingName(mappedName);\r\n                    injections.add(injection);\r\n                    metaData.setOrigin(\"resource-ref.\" + name + \".injection\", resource, clazz);\r\n                } else if (!isEnvEntryType(paramType)) {\r\n                    throw new IllegalStateException(\"No resource at \" + (mappedName == null ? name : mappedName));\r\n                }\r\n            } catch (NamingException e) {\r\n                if (!isEnvEntryType(paramType))\r\n                    throw new IllegalStateException(e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlets.DoSFilter.setThrottledRequests",
	"Comment": "set number of requests over the rate limit able to beconsidered at once.",
	"Method": "void setThrottledRequests(int value){\r\n    int permits = _passes == null ? 0 : _passes.availablePermits();\r\n    _passes = new Semaphore((value - _throttledRequests + permits), true);\r\n    _throttledRequests = value;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration.getWrappedNode",
	"Comment": "returns the javaparser node associated with this javaparserclassdeclaration.",
	"Method": "com.github.javaparser.ast.body.ClassOrInterfaceDeclaration getWrappedNode(){\r\n    return wrappedNode;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl.transformTypeParameters",
	"Comment": "execute a transformation on all the type parameters of this element.",
	"Method": "ResolvedType transformTypeParameters(ResolvedTypeTransformer transformer){\r\n    ResolvedType result = this;\r\n    int i = 0;\r\n    for (ResolvedType tp : this.typeParametersValues()) {\r\n        ResolvedType transformedTp = transformer.transform(tp);\r\n        if (transformedTp != tp) {\r\n            List<ResolvedType> typeParametersCorrected = result.asReferenceType().typeParametersValues();\r\n            typeParametersCorrected.set(i, transformedTp);\r\n            result = create(typeDeclaration, typeParametersCorrected);\r\n        }\r\n        i++;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.javaee7.websocket.endpoint.singleton.MyEndpoint.concat",
	"Comment": "singleton instance of endpoint ensures that string concatenation would work",
	"Method": "String concat(String value){\r\n    this.newValue += value;\r\n    return newValue;\r\n}"
}, {
	"Path": "com.github.javaparser.printer.lexicalpreservation.RemovedGroup.processed",
	"Comment": "marks the removedgroup as processed which indicates that it should not be processed again",
	"Method": "void processed(){\r\n    isProcessed = true;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.resolution.SymbolSolver.solveTypeInType",
	"Comment": "try to solve a symbol just in the declaration, it does not delegate to the container.",
	"Method": "SymbolReference<ResolvedTypeDeclaration> solveTypeInType(ResolvedTypeDeclaration typeDeclaration,String name){\r\n    if (typeDeclaration instanceof JavaParserClassDeclaration) {\r\n        return ((JavaParserClassDeclaration) typeDeclaration).solveType(name, typeSolver);\r\n    }\r\n    if (typeDeclaration instanceof JavaParserInterfaceDeclaration) {\r\n        return ((JavaParserInterfaceDeclaration) typeDeclaration).solveType(name, typeSolver);\r\n    }\r\n    return SymbolReference.unsolved(ReferenceTypeDeclaration.class);\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "TypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return new TypeParameterDeclaration() {\r\n        @Override\r\n        public String getName() {\r\n            return name;\r\n        }\r\n        @Override\r\n        public boolean declaredOnType() {\r\n            return true;\r\n        }\r\n        @Override\r\n        public boolean declaredOnMethod() {\r\n            return false;\r\n        }\r\n        @Override\r\n        public boolean declaredOnConstructor() {\r\n            return false;\r\n        }\r\n        @Override\r\n        public String getContainerQualifiedName() {\r\n            return classQName;\r\n        }\r\n        @Override\r\n        public String getContainerId() {\r\n            return classQName;\r\n        }\r\n        @Override\r\n        public TypeParametrizable getContainer() {\r\n            return null;\r\n        }\r\n        @Override\r\n        public List<Bound> getBounds(TypeSolver typeSolver) {\r\n            return bounds;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"TypeParameter onType \" + name;\r\n        }\r\n        @Override\r\n        public Optional<ReferenceTypeDeclaration> containerType() {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "TypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return name;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "TypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return true;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "TypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return false;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "TypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return false;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "TypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return classQName;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "TypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return classQName;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "TypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return null;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "TypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return bounds;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "TypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    return \"TypeParameter onType \" + name;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeParameterDeclaration.onType",
	"Comment": "instantiate a typeparameter defined on a type with the given data.",
	"Method": "TypeParameterDeclaration onType(String name,String classQName,List<Bound> bounds){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.eclipse.jetty.webapp.FragmentConfiguration.findWebFragments",
	"Comment": "add in fragment descriptors that have already been discovered by metainfconfiguration",
	"Method": "void findWebFragments(WebAppContext context,MetaData metaData){\r\n    addWebFragments(context, metaData);\r\n}"
}, {
	"Path": "org.eclipse.jetty.annotations.PreDestroyAnnotationHandler.supportsPreDestroy",
	"Comment": "check if the spec permits the given class to use the predestroy annotation.",
	"Method": "boolean supportsPreDestroy(Class c){\r\n    if (javax.servlet.Servlet.class.isAssignableFrom(c) || javax.servlet.Filter.class.isAssignableFrom(c) || javax.servlet.ServletContextListener.class.isAssignableFrom(c) || javax.servlet.ServletContextAttributeListener.class.isAssignableFrom(c) || javax.servlet.ServletRequestListener.class.isAssignableFrom(c) || javax.servlet.ServletRequestAttributeListener.class.isAssignableFrom(c) || javax.servlet.http.HttpSessionListener.class.isAssignableFrom(c) || javax.servlet.http.HttpSessionAttributeListener.class.isAssignableFrom(c) || javax.servlet.http.HttpSessionIdListener.class.isAssignableFrom(c) || javax.servlet.AsyncListener.class.isAssignableFrom(c) || javax.servlet.http.HttpUpgradeHandler.class.isAssignableFrom(c))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jetty.io.AbstractConnection.onFillInterestedFailed",
	"Comment": "callback method invoked when the endpoint failed to be ready to be read.",
	"Method": "void onFillInterestedFailed(Throwable cause){\r\n    if (LOG.isDebugEnabled())\r\n        LOG.debug(\"{} onFillInterestedFailed {}\", this, cause);\r\n    if (_endPoint.isOpen()) {\r\n        boolean close = true;\r\n        if (cause instanceof TimeoutException)\r\n            close = onReadTimeout(cause);\r\n        if (close) {\r\n            if (_endPoint.isOutputShutdown())\r\n                _endPoint.close();\r\n            else {\r\n                _endPoint.shutdownOutput();\r\n                fillInterested();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.extensions.AbstractExtension.isRsv2User",
	"Comment": "used to indicate that the extension makes use of the rsv2 bit of the base websocket framing.this is used to adjust validation during parsing, as well as a checkpoint against 2 or more extensions all simultaneously claiming ownership of rsv2.",
	"Method": "boolean isRsv2User(){\r\n    return false;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.Declaration.asField",
	"Comment": "return this as a fielddeclaration or throw an unsupportedoperationexception",
	"Method": "FieldDeclaration asField(){\r\n    throw new UnsupportedOperationException(String.format(\"%s is not a FieldDeclaration\", this));\r\n}"
}, {
	"Path": "org.eclipse.jetty.deploy.providers.ScanningAppProvider.createApp",
	"Comment": "called by the scanner.discretelistener to create a new app object.isolated in a method so that it is possible to override the default appobject for specialized implementations of the appprovider.",
	"Method": "App createApp(String filename){\r\n    return new App(_deploymentManager, this, filename);\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.io.AbstractWebSocketConnection.onClose",
	"Comment": "physical connection disconnect.not related to websocket close handshake.",
	"Method": "void onClose(){\r\n    if (LOG.isDebugEnabled())\r\n        LOG.debug(\"{} onClose()\", policy.getBehavior());\r\n    super.onClose();\r\n    ioState.onDisconnected();\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.Session.getRequests",
	"Comment": "returns the current number of requests that are active in the session.",
	"Method": "long getRequests(){\r\n    try (Lock lock = _lock.lock()) {\r\n        return _requests;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.AtomicBiInteger.addAndGetHi",
	"Comment": "atomically adds the given delta to the current hi value, returning the updated hi value.",
	"Method": "int addAndGetHi(int delta){\r\n    while (true) {\r\n        long encoded = get();\r\n        int hi = getHi(encoded) + delta;\r\n        long update = encodeHi(encoded, hi);\r\n        if (compareAndSet(encoded, update))\r\n            return hi;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.deploy.providers.WebAppProvider.setTempDir",
	"Comment": "set the work directory where unpacked war files are managed from.default is the same as the java.io.tmpdir system property.",
	"Method": "void setTempDir(File directory){\r\n    _tempDirectory = directory;\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.utils.internal.PackageAdminServiceTracker.getFragments",
	"Comment": "helper to access the packageadmin and return the fragments hosted by abundle. when we drop the support for the older versions of osgi, we willstop using the packageadmin service.",
	"Method": "Bundle[] getFragments(Bundle bundle){\r\n    ServiceReference sr = _context.getServiceReference(PackageAdmin.class.getName());\r\n    if (sr == null) {\r\n        return null;\r\n    }\r\n    PackageAdmin admin = (PackageAdmin) _context.getService(sr);\r\n    return admin.getFragments(bundle);\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.Scanner.scanFile",
	"Comment": "get last modified time on a single file or recurse ifthe file is a directory.",
	"Method": "void scanFile(File f,Map<String, TimeNSize> scanInfoMap,int depth){\r\n    try {\r\n        if (!f.exists())\r\n            return;\r\n        if (f.isFile() || depth > 0 && _reportDirs && f.isDirectory()) {\r\n            if ((_filter == null) || ((_filter != null) && _filter.accept(f.getParentFile(), f.getName()))) {\r\n                if (LOG.isDebugEnabled())\r\n                    LOG.debug(\"scan accepted {}\", f);\r\n                String name = f.getCanonicalPath();\r\n                scanInfoMap.put(name, new TimeNSize(f.lastModified(), f.isDirectory() ? 0 : f.length()));\r\n            } else {\r\n                if (LOG.isDebugEnabled())\r\n                    LOG.debug(\"scan rejected {}\", f);\r\n            }\r\n        }\r\n        if (f.isDirectory() && (depth < _scanDepth || _scanDepth == -1 || _scanDirs.contains(f))) {\r\n            File[] files = f.listFiles();\r\n            if (files != null) {\r\n                for (int i = 0; i < files.length; i++) scanFile(files[i], scanInfoMap, depth + 1);\r\n            } else\r\n                LOG.warn(\"Error listing files in directory {}\", f);\r\n        }\r\n    } catch (IOException e) {\r\n        LOG.warn(\"Error scanning watched files\", e);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.HttpFields.addCSV",
	"Comment": "add comma separated values, but only if not alreadypresent.",
	"Method": "boolean addCSV(HttpHeader header,String values,boolean addCSV,String name,String values,String addCSV,QuotedCSV existing,String values){\r\n    boolean add = true;\r\n    if (existing != null && !existing.isEmpty()) {\r\n        add = false;\r\n        for (int i = values.length; i-- > 0; ) {\r\n            String unquoted = QuotedCSV.unquote(values[i]);\r\n            if (existing.getValues().contains(unquoted))\r\n                values[i] = null;\r\n            else\r\n                add = true;\r\n        }\r\n    }\r\n    if (add) {\r\n        StringBuilder value = new StringBuilder();\r\n        for (String v : values) {\r\n            if (v == null)\r\n                continue;\r\n            if (value.length() > 0)\r\n                value.append(\", \");\r\n            value.append(v);\r\n        }\r\n        if (value.length() > 0)\r\n            return value.toString();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.log.AbstractLogger.isBlank",
	"Comment": "a more robust form of name blank test. will return true for null names, and names that have only whitespace",
	"Method": "boolean isBlank(String name){\r\n    if (name == null) {\r\n        return true;\r\n    }\r\n    int size = name.length();\r\n    char c;\r\n    for (int i = 0; i < size; i++) {\r\n        c = name.charAt(i);\r\n        if (!Character.isWhitespace(c)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.ServletTester.createConnector",
	"Comment": "create a port based connector.this methods adds a port connector to the server",
	"Method": "String createConnector(boolean localhost){\r\n    ServerConnector connector = new ServerConnector(_server);\r\n    if (localhost)\r\n        connector.setHost(\"127.0.0.1\");\r\n    _server.addConnector(connector);\r\n    if (_server.isStarted())\r\n        connector.start();\r\n    else\r\n        connector.open();\r\n    return \"http://\" + (localhost ? \"127.0.0.1\" : InetAddress.getLocalHost().getHostAddress()) + \":\" + connector.getLocalPort();\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.QuotedStringTokenizer.quoteOnly",
	"Comment": "quote a string into an appendable.only quotes and backslash are escaped.",
	"Method": "void quoteOnly(Appendable buffer,String input){\r\n    if (input == null)\r\n        return;\r\n    try {\r\n        buffer.append('\"');\r\n        for (int i = 0; i < input.length(); ++i) {\r\n            char c = input.charAt(i);\r\n            if (c == '\"' || c == '\\\\')\r\n                buffer.append('\\\\');\r\n            buffer.append(c);\r\n        }\r\n        buffer.append('\"');\r\n    } catch (IOException x) {\r\n        throw new RuntimeException(x);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.SessionHandler.checkRequestedSessionId",
	"Comment": "look for a requested session id in cookies and uri parameters",
	"Method": "void checkRequestedSessionId(Request baseRequest,HttpServletRequest request){\r\n    String requested_session_id = request.getRequestedSessionId();\r\n    if (requested_session_id != null) {\r\n        HttpSession session = getHttpSession(requested_session_id);\r\n        if (session != null && isValid(session))\r\n            baseRequest.setSession(session);\r\n        return;\r\n    } else if (!DispatcherType.REQUEST.equals(baseRequest.getDispatcherType()))\r\n        return;\r\n    boolean requested_session_id_from_cookie = false;\r\n    HttpSession session = null;\r\n    if (isUsingCookies()) {\r\n        Cookie[] cookies = request.getCookies();\r\n        if (cookies != null && cookies.length > 0) {\r\n            final String sessionCookie = getSessionCookieConfig().getName();\r\n            for (int i = 0; i < cookies.length; i++) {\r\n                if (sessionCookie.equalsIgnoreCase(cookies[i].getName())) {\r\n                    requested_session_id = cookies[i].getValue();\r\n                    requested_session_id_from_cookie = true;\r\n                    if (LOG.isDebugEnabled())\r\n                        LOG.debug(\"Got Session ID {} from cookie\", requested_session_id);\r\n                    if (requested_session_id != null) {\r\n                        session = getHttpSession(requested_session_id);\r\n                        if (session != null && isValid(session)) {\r\n                            break;\r\n                        }\r\n                    } else {\r\n                        LOG.warn(\"null session id from cookie\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (isUsingURLs() && (requested_session_id == null || session == null)) {\r\n        String uri = request.getRequestURI();\r\n        String prefix = getSessionIdPathParameterNamePrefix();\r\n        if (prefix != null) {\r\n            int s = uri.indexOf(prefix);\r\n            if (s >= 0) {\r\n                s += prefix.length();\r\n                int i = s;\r\n                while (i < uri.length()) {\r\n                    char c = uri.charAt(i);\r\n                    if (c == ';' || c == '#' || c == '?' || c == '/')\r\n                        break;\r\n                    i++;\r\n                }\r\n                requested_session_id = uri.substring(s, i);\r\n                requested_session_id_from_cookie = false;\r\n                session = getHttpSession(requested_session_id);\r\n                if (LOG.isDebugEnabled())\r\n                    LOG.debug(\"Got Session ID {} from URL\", requested_session_id);\r\n            }\r\n        }\r\n    }\r\n    baseRequest.setRequestedSessionId(requested_session_id);\r\n    baseRequest.setRequestedSessionIdFromCookie(requested_session_id != null && requested_session_id_from_cookie);\r\n    if (session != null && isValid(session))\r\n        baseRequest.setSession(session);\r\n}"
}, {
	"Path": "org.eclipse.jetty.webapp.WebAppClassLoader.loadAsResource",
	"Comment": "look for the classname as a resource to avoid loading a class that is potentially a system resource.",
	"Method": "Class<?> loadAsResource(String name,boolean checkSystemResource){\r\n    Class<?> webapp_class = null;\r\n    String path = name.replace('.', '/').concat(\".class\");\r\n    URL webapp_url = findResource(path);\r\n    if (webapp_url != null && (!checkSystemResource || !_context.isSystemResource(name, webapp_url))) {\r\n        webapp_class = this.foundClass(name, webapp_url);\r\n        resolveClass(webapp_class);\r\n        if (LOG.isDebugEnabled())\r\n            LOG.debug(\"WAP webapp loaded {}\", webapp_class);\r\n    }\r\n    return webapp_class;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.InetAccessHandler.handle",
	"Comment": "checks the incoming request against the whitelist and blacklist",
	"Method": "void handle(String target,Request baseRequest,HttpServletRequest request,HttpServletResponse response){\r\n    HttpChannel channel = baseRequest.getHttpChannel();\r\n    if (channel != null) {\r\n        EndPoint endp = channel.getEndPoint();\r\n        if (endp != null) {\r\n            InetSocketAddress address = endp.getRemoteAddress();\r\n            if (address != null && !isAllowed(address.getAddress(), request)) {\r\n                response.sendError(HttpStatus.FORBIDDEN_403);\r\n                baseRequest.setHandled(true);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    getHandler().handle(target, baseRequest, request, response);\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.annotations.AnnotationParser.indexBundle",
	"Comment": "keep track of a jetty uri resource and its associated osgi bundle.",
	"Method": "Resource indexBundle(Bundle bundle){\r\n    File bundleFile = BundleFileLocatorHelperFactory.getFactory().getHelper().getBundleInstallLocation(bundle);\r\n    Resource resource = Resource.newResource(bundleFile.toURI());\r\n    URI uri = resource.getURI();\r\n    _uriToBundle.putIfAbsent(uri, bundle);\r\n    _bundleToUri.putIfAbsent(bundle, uri);\r\n    _bundleToResource.putIfAbsent(bundle, resource);\r\n    _resourceToBundle.putIfAbsent(resource, bundle);\r\n    return resource;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.MultiMap.getValue",
	"Comment": "get a value from a multiple value.if the value is not a multivalue, then index 0 retrieves thevalue or null.",
	"Method": "V getValue(String name,int i){\r\n    List<V> vals = getValues(name);\r\n    if (vals == null) {\r\n        return null;\r\n    }\r\n    if (i == 0 && vals.isEmpty()) {\r\n        return null;\r\n    }\r\n    return vals.get(i);\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.extensions.AbstractExtension.isRsv1User",
	"Comment": "used to indicate that the extension makes use of the rsv1 bit of the base websocket framing.this is used to adjust validation during parsing, as well as a checkpoint against 2 or more extensions all simultaneously claiming ownership of rsv1.",
	"Method": "boolean isRsv1User(){\r\n    return false;\r\n}"
}, {
	"Path": "net.bull.javamelody.internal.model.Base64Coder.decodeString",
	"Comment": "decodes a string from base64 format.\t no blanks or line breaks are allowed within the base64 encoded input data.",
	"Method": "String decodeString(String s){\r\n    return new String(decode(s));\r\n}"
}, {
	"Path": "com.github.javaparser.ast.body.FieldDeclaration.createGetter",
	"Comment": "create a getter for this field, will only work if this field declares only 1 identifier and if this field isalready added to a classorinterfacedeclaration",
	"Method": "MethodDeclaration createGetter(){\r\n    if (getVariables().size() != 1)\r\n        throw new IllegalStateException(\"You can use this only when the field declares only 1 variable name\");\r\n    ClassOrInterfaceDeclaration parentClass = getParentNodeOfType(ClassOrInterfaceDeclaration.class);\r\n    EnumDeclaration parentEnum = getParentNodeOfType(EnumDeclaration.class);\r\n    if ((parentClass == null && parentEnum == null) || (parentClass != null && parentClass.isInterface()))\r\n        throw new IllegalStateException(\"You can use this only when the field is attached to a class or an enum\");\r\n    VariableDeclarator variable = getVariables().get(0);\r\n    String fieldName = variable.getId().getName();\r\n    String fieldNameUpper = fieldName.toUpperCase().substring(0, 1) + fieldName.substring(1, fieldName.length());\r\n    final MethodDeclaration getter;\r\n    if (parentClass != null)\r\n        getter = parentClass.addMethod(\"get\" + fieldNameUpper, PUBLIC);\r\n    else\r\n        getter = parentEnum.addMethod(\"get\" + fieldNameUpper, PUBLIC);\r\n    getter.setType(variable.getType());\r\n    BlockStmt blockStmt = new BlockStmt();\r\n    getter.setBody(blockStmt);\r\n    blockStmt.addStatement(new ReturnStmt(name(fieldName)));\r\n    return getter;\r\n}"
}, {
	"Path": "org.eclipse.jetty.start.StartArgs.expandModules",
	"Comment": "build up the classpath and xml file references based on enabled module list.",
	"Method": "void expandModules(List<Module> activeModules){\r\n    StartLog.debug(\"Expanding Modules\");\r\n    for (Module module : activeModules) {\r\n        for (String rawlibref : module.getLibs()) {\r\n            StartLog.debug(\"rawlibref = \" + rawlibref);\r\n            String libref = properties.expand(rawlibref);\r\n            StartLog.debug(\"expanded = \" + libref);\r\n            for (Path libpath : baseHome.getPaths(libref)) {\r\n                classpath.addComponent(libpath.toFile());\r\n            }\r\n        }\r\n        for (String jvmArg : module.getJvmArgs()) {\r\n            exec = true;\r\n            jvmArgs.add(jvmArg);\r\n        }\r\n        for (String xmlRef : module.getXmls()) {\r\n            xmlRef = properties.expand(xmlRef);\r\n            Path xmlfile = baseHome.getPath(xmlRef);\r\n            addUniqueXmlFile(xmlRef, xmlfile);\r\n        }\r\n        for (String file : module.getFiles()) {\r\n            StartLog.debug(\"Adding module specified file: %s\", file);\r\n            addFile(module, file);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserConstructorDeclaration.getWrappedNode",
	"Comment": "returns the javaparser node associated with this javaparserconstructordeclaration.",
	"Method": "com.github.javaparser.ast.body.ConstructorDeclaration getWrappedNode(){\r\n    return wrappedNode;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getGenericParameterByName",
	"Comment": "get the type associated with the type parameter with the given name.it returns optional.empty unless the type declaration declares a type parameter with the given name.",
	"Method": "Optional<Type> getGenericParameterByName(String name){\r\n    for (TypeParameterDeclaration tp : typeDeclaration.getTypeParameters()) {\r\n        if (tp.getName().equals(name)) {\r\n            return Optional.of(this.typeParametersMap().getValue(tp));\r\n        }\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "com.github.javaparser.ASTParser.BlockStatement",
	"Comment": "classes inside block stametents can only be abstract or final. the semantic must check it.",
	"Method": "Statement BlockStatement(){\r\n    Statement ret;\r\n    Expression expr;\r\n    ClassOrInterfaceDeclaration typeDecl;\r\n    Modifier modifier;\r\n    if (jj_2_37(2147483647)) {\r\n        modifier = Modifiers();\r\n        typeDecl = ClassOrInterfaceDeclaration(modifier);\r\n        ret = new TypeDeclarationStmt(typeDecl.getBeginLine(), typeDecl.getBeginColumn(), token.endLine, token.endColumn, typeDecl);\r\n    } else if (jj_2_38(2147483647)) {\r\n        expr = VariableDeclarationExpression();\r\n        jj_consume_token(SEMICOLON);\r\n        ret = new ExpressionStmt(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr);\r\n    } else {\r\n        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\r\n            case ASSERT:\r\n            case BOOLEAN:\r\n            case BREAK:\r\n            case BYTE:\r\n            case CHAR:\r\n            case CONTINUE:\r\n            case DO:\r\n            case DOUBLE:\r\n            case FALSE:\r\n            case FLOAT:\r\n            case FOR:\r\n            case IF:\r\n            case INT:\r\n            case LONG:\r\n            case NEW:\r\n            case NULL:\r\n            case RETURN:\r\n            case SHORT:\r\n            case SUPER:\r\n            case SWITCH:\r\n            case SYNCHRONIZED:\r\n            case THIS:\r\n            case THROW:\r\n            case TRUE:\r\n            case TRY:\r\n            case VOID:\r\n            case WHILE:\r\n            case LONG_LITERAL:\r\n            case INTEGER_LITERAL:\r\n            case FLOATING_POINT_LITERAL:\r\n            case CHARACTER_LITERAL:\r\n            case STRING_LITERAL:\r\n            case IDENTIFIER:\r\n            case LPAREN:\r\n            case LBRACE:\r\n            case SEMICOLON:\r\n            case INCR:\r\n            case DECR:\r\n                ret = Statement();\r\n                break;\r\n            default:\r\n                jj_la1[141] = jj_gen;\r\n                jj_consume_token(-1);\r\n                throw new ParseException();\r\n        }\r\n    }\r\n    {\r\n        if (true)\r\n            return ret;\r\n    }\r\n    throw new Error(\"Missing return statement in function\");\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlets.DoSFilter.getThrottledRequests",
	"Comment": "get number of requests over the rate limit able to beconsidered at once.",
	"Method": "int getThrottledRequests(){\r\n    return _throttledRequests;\r\n}"
}, {
	"Path": "com.github.javaparser.printer.lexicalpreservation.RemovedGroup.isProcessed",
	"Comment": "returns whether the removedgroup was already processed and should not be processed again",
	"Method": "boolean isProcessed(){\r\n    return isProcessed;\r\n}"
}, {
	"Path": "org.eclipse.jetty.gcloud.session.GCloudSessionDataStore.checkIndexes",
	"Comment": "check to see if indexes are available, in which casewe can do more performant queries.",
	"Method": "boolean checkIndexes(){\r\n    try {\r\n        Query<ProjectionEntity> query = Query.newProjectionEntityQueryBuilder().setKind(_model.getKind()).setProjection(_model.getExpiry()).setFilter(PropertyFilter.eq(_model.getId(), \"-\")).build();\r\n        _datastore.run(query);\r\n        return true;\r\n    } catch (DatastoreException e) {\r\n        if (LOG.isDebugEnabled())\r\n            LOG.debug(\"Check for indexes\", e);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.javaee7.websocket.binary.test.MyEndpointTest.createDeployment",
	"Comment": "arquillian specific method for creating a file which can be deployedwhile executing the test.",
	"Method": "WebArchive createDeployment(){\r\n    return ShrinkWrap.create(WebArchive.class).addClasses(MyEndpointByteBuffer.class, MyEndpointByteArray.class, MyEndpointInputStream.class, MyEndpointClient.class);\r\n}"
}, {
	"Path": "net.bull.javamelody.TestJpa.createAllQuery",
	"Comment": "tests createnamedquery, createnativequery et createqery.",
	"Method": "void createAllQuery(){\r\n    try {\r\n        Class.forName(\"org.apache.openjpa.persistence.PersistenceProviderImpl\");\r\n    } catch (final ClassNotFoundException e) {\r\n        Logger.getRootLogger().info(e.toString());\r\n        return;\r\n    }\r\n    final EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"test-jse\");\r\n    try {\r\n        final EntityManager emInit = emf.createEntityManager();\r\n        try {\r\n            final EntityTransaction transaction = emInit.getTransaction();\r\n            transaction.begin();\r\n            try {\r\n                final Person p = new Person();\r\n                p.setName(PERSON_NAME);\r\n                emInit.persist(p);\r\n                emInit.flush();\r\n                transaction.commit();\r\n            } catch (final Exception e) {\r\n                transaction.rollback();\r\n            }\r\n        } finally {\r\n            emInit.close();\r\n        }\r\n        reset();\r\n        final EntityManager em = emf.createEntityManager();\r\n        try {\r\n            final Query namedQuery = em.createNamedQuery(\"Person.findByName\");\r\n            final String nameParameter = \"name\";\r\n            namedQuery.setParameter(nameParameter, PERSON_NAME).getSingleResult();\r\n            assertCounter(\"NamedQuery(Person.findByName)\");\r\n            final TypedQuery<Person> namedQuery2 = em.createNamedQuery(\"Person.findByName\", Person.class);\r\n            namedQuery2.setParameter(nameParameter, PERSON_NAME).getSingleResult();\r\n            assertCounter(\"NamedQuery(Person.findByName, Person)\");\r\n            final Query nativeQuery = em.createNativeQuery(\"select * from Person where name = ?\");\r\n            nativeQuery.setParameter(1, PERSON_NAME).getSingleResult();\r\n            assertCounter(\"NativeQuery(select * from Person where name = ?)\");\r\n            final Query nativeQuery2 = em.createNativeQuery(\"select * from Person where name = ?\", Person.class);\r\n            nativeQuery2.setParameter(1, PERSON_NAME).getSingleResult();\r\n            assertCounter(\"NativeQuery(select * from Person where name = ?, Person)\");\r\n            final Query query = em.createQuery(\"select p from Person p where p.name = :name\");\r\n            query.setParameter(nameParameter, PERSON_NAME).getSingleResult();\r\n            assertCounter(\"Query(select p from Person p where p.name = :name)\");\r\n            final TypedQuery<Person> query2 = em.createQuery(\"select p from Person p where p.name = :name\", Person.class);\r\n            query2.setParameter(nameParameter, PERSON_NAME).getSingleResult();\r\n            assertCounter(\"Query(select p from Person p where p.name = :name, Person)\");\r\n            final CriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\r\n            final CriteriaQuery<Object> criteriaQuery = criteriaBuilder.createQuery();\r\n            final Root<Person> from = criteriaQuery.from(Person.class);\r\n            criteriaQuery.select(from);\r\n            final CriteriaQuery<Object> criteriaQuery2 = criteriaQuery.where(criteriaBuilder.equal(from.get(nameParameter), PERSON_NAME));\r\n            em.createQuery(criteriaQuery2).getSingleResult();\r\n            assertCounter(\"Query(SELECT p FROM Person p WHERE p.name = '\" + PERSON_NAME + \"')\");\r\n        } finally {\r\n            em.close();\r\n        }\r\n    } finally {\r\n        emf.close();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.TypeUtil.parseInt",
	"Comment": "parse an int from a byte array of ascii characters.negative numbers are not handled.",
	"Method": "int parseInt(String s,int offset,int length,int base,int parseInt,byte[] b,int offset,int length,int base){\r\n    int value = 0;\r\n    if (length < 0)\r\n        length = b.length - offset;\r\n    for (int i = 0; i < length; i++) {\r\n        char c = (char) (0xff & b[offset + i]);\r\n        int digit = c - '0';\r\n        if (digit < 0 || digit >= base || digit >= 10) {\r\n            digit = 10 + c - 'A';\r\n            if (digit < 10 || digit >= base)\r\n                digit = 10 + c - 'a';\r\n        }\r\n        if (digit < 0 || digit >= base)\r\n            throw new NumberFormatException(new String(b, offset, length));\r\n        value = value * base + digit;\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.HandlerCollection.prependHandler",
	"Comment": "prepend a handler.this implementation adds the passed handler to the start of the existing collection of handlers.",
	"Method": "void prependHandler(Handler handler){\r\n    setHandlers(ArrayUtil.prependToArray(handler, getHandlers(), Handler.class));\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.Declaration.asParameter",
	"Comment": "return this as a parameterdeclaration or throw an unsupportedoperationexception",
	"Method": "ParameterDeclaration asParameter(){\r\n    throw new UnsupportedOperationException(String.format(\"%s is not a ParameterDeclaration\", this));\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration.asEnum",
	"Comment": "return this as a enumdeclaration or throw unsupportedoperationexception.",
	"Method": "ResolvedEnumDeclaration asEnum(){\r\n    throw new UnsupportedOperationException(String.format(\"%s is not an enum\", this));\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeParameter.getWrappedNode",
	"Comment": "returns the javaparser node associated with this javaparsertypeparameter.",
	"Method": "com.github.javaparser.ast.type.TypeParameter getWrappedNode(){\r\n    return wrappedNode;\r\n}"
}, {
	"Path": "org.eclipse.jetty.client.HostnameVerificationTest.trustAllDisablesHostnameVerificationTest",
	"Comment": "this test has hostname verification disabled by setting trustall to true and connecting,ssl handshake and sending the request should just work fine.",
	"Method": "void trustAllDisablesHostnameVerificationTest(){\r\n    clientSslContextFactory.setTrustAll(true);\r\n    String uri = \"https://localhost:\" + connector.getLocalPort() + \"/\";\r\n    try {\r\n        client.GET(uri);\r\n    } catch (ExecutionException e) {\r\n        fail(\"SSLHandshake should work just fine as hostname verification is disabled!\", e);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.SearchPattern.endsWith",
	"Comment": "search for a partial match of the pattern at the end of the data.",
	"Method": "int endsWith(byte[] data,int offset,int length){\r\n    validate(data, offset, length);\r\n    int skip = (pattern.length <= length) ? (offset + length - pattern.length) : offset;\r\n    while (skip < offset + length) {\r\n        for (int i = (offset + length - 1) - skip; data[skip + i] == pattern[i]; --i) if (i == 0)\r\n            return (offset + length - skip);\r\n        if (skip + pattern.length - 1 < data.length)\r\n            skip += table[0xff & data[skip + pattern.length - 1]];\r\n        else\r\n            skip++;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.MethodUsage.getNoParams",
	"Comment": "return the number of formal arguments accepted by this method.",
	"Method": "int getNoParams(){\r\n    return paramTypes.size();\r\n}"
}, {
	"Path": "org.eclipse.jetty.webapp.WebInfConfigurationTest.testFindAndFilterContainerPaths",
	"Comment": "assume targetjdk9. in this case, we should be able to extractthe urls from the application classloader, and we should not lookat the java.class.path property.",
	"Method": "void testFindAndFilterContainerPaths(){\r\n    WebInfConfiguration config = new WebInfConfiguration();\r\n    WebAppContext context = new WebAppContext();\r\n    context.setAttribute(WebInfConfiguration.CONTAINER_JAR_PATTERN, \".*/jetty-util-[^/]*\\\\.jar$|.*/jetty-util/target/classes/\");\r\n    WebAppClassLoader loader = new WebAppClassLoader(context);\r\n    context.setClassLoader(loader);\r\n    config.findAndFilterContainerPaths(context);\r\n    List<Resource> containerResources = context.getMetaData().getContainerResources();\r\n    assertEquals(1, containerResources.size());\r\n    assertThat(containerResources.get(0).toString(), containsString(\"jetty-util\"));\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.Session.callSessionAttributeListeners",
	"Comment": "call binding and attribute listeners based on the new and old values ofthe attribute.",
	"Method": "void callSessionAttributeListeners(String name,Object newValue,Object oldValue){\r\n    if (newValue == null || !newValue.equals(oldValue)) {\r\n        if (oldValue != null)\r\n            unbindValue(name, oldValue);\r\n        if (newValue != null)\r\n            bindValue(name, newValue);\r\n        if (_handler == null)\r\n            throw new IllegalStateException(\"No session manager for session \" + _sessionData.getId());\r\n        _handler.doSessionAttributeListeners(this, name, oldValue, newValue);\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.JavaToken.insert",
	"Comment": "inserts newtoken into the token list just before this token.",
	"Method": "void insert(JavaToken newToken){\r\n    assertNotNull(newToken);\r\n    getPreviousToken().ifPresent(p -> {\r\n        p.nextToken = newToken;\r\n        newToken.previousToken = p;\r\n    });\r\n    previousToken = newToken;\r\n    newToken.nextToken = this;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.resource.Resource.copyTo",
	"Comment": "copy the resource to the new destination file.will not replace existing destination file.",
	"Method": "void copyTo(File destination){\r\n    if (destination.exists())\r\n        throw new IllegalArgumentException(destination + \" exists\");\r\n    try (OutputStream out = new FileOutputStream(destination)) {\r\n        writeTo(out, 0, -1);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.Utf8Appendable.takePartialString",
	"Comment": "take the partial string an reset in internal buffer, but retainpartial code points.",
	"Method": "String takePartialString(){\r\n    String partial = getPartialString();\r\n    int save = _state;\r\n    reset();\r\n    _state = save;\r\n    return partial;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.canBeAssignedTo",
	"Comment": "can we assign instances of the type defined by this declaration to variables having the type definedby the given type?",
	"Method": "boolean canBeAssignedTo(ReferenceTypeDeclaration other){\r\n    return other.isAssignableBy(this);\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.client.WebSocketClientInitTest.testInit_HttpClient_SyntheticStart",
	"Comment": "this is the backward compatibility mode of websocketclient.this is also the primary mode that jsr356 standalone websocket client is initialized.",
	"Method": "void testInit_HttpClient_SyntheticStart(){\r\n    HttpClient http = null;\r\n    WebSocketClient ws = new WebSocketClient();\r\n    ws.start();\r\n    try {\r\n        http = ws.getHttpClient();\r\n        assertThat(\"WebSocketClient started\", ws.isStarted(), is(true));\r\n        assertThat(\"HttpClient started\", http.isStarted(), is(true));\r\n        HttpClient httpBean = ws.getBean(HttpClient.class);\r\n        assertThat(\"HttpClient bean found in WebSocketClient\", httpBean, is(http));\r\n        assertThat(\"HttpClient bean is managed\", ws.isManaged(httpBean), is(true));\r\n        assertThat(\"WebSocketClient should not be found in HttpClient\", http.getBean(WebSocketClient.class), nullValue());\r\n    } finally {\r\n        ws.stop();\r\n    }\r\n    assertThat(\"WebSocketClient stopped\", ws.isStopped(), is(true));\r\n    assertThat(\"HttpClient stopped\", http.isStopped(), is(true));\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.AbstractNCSARequestLog.logExtended",
	"Comment": "writes extended request and response information to the output stream.",
	"Method": "void logExtended(StringBuilder b,Request request,Response response){\r\n    String referer = request.getHeader(HttpHeader.REFERER.toString());\r\n    if (referer == null)\r\n        b.append(\"\\\"-\\\" \");\r\n    else {\r\n        b.append('\"');\r\n        b.append(referer);\r\n        b.append(\"\\\" \");\r\n    }\r\n    String agent = request.getHeader(HttpHeader.USER_AGENT.toString());\r\n    if (agent == null)\r\n        b.append(\"\\\"-\\\"\");\r\n    else {\r\n        b.append('\"');\r\n        b.append(agent);\r\n        b.append('\"');\r\n    }\r\n}"
}, {
	"Path": "net.bull.javamelody.Main.extractFromJar",
	"Comment": "extract a resource from jar, mark it for deletion upon exit, and return its location.",
	"Method": "File extractFromJar(String resource,String fileName,String suffix){\r\n    final URL res = Main.class.getResource(resource);\r\n    final File tmp;\r\n    try {\r\n        tmp = File.createTempFile(fileName, suffix);\r\n    } catch (final IOException e) {\r\n        final String tmpdir = System.getProperty(\"java.io.tmpdir\");\r\n        throw new IllegalStateException(\"JavaMelody has failed to create a temporary file in \" + tmpdir, e);\r\n    }\r\n    final InputStream is = res.openStream();\r\n    try {\r\n        final OutputStream os = new FileOutputStream(tmp);\r\n        try {\r\n            copyStream(is, os);\r\n        } finally {\r\n            os.close();\r\n        }\r\n    } finally {\r\n        is.close();\r\n    }\r\n    tmp.deleteOnExit();\r\n    return tmp;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeAdapter.solveType",
	"Comment": "this method is deprecated because it receives the typessolver as a parameter.eventually we would like to remove all usages of typesolver as a parameter.also, resolution should move out of declarations, so that they are pure declarations and the resolution shouldwork for javaparser, reflection and javassist classes in the same way and not be specific to the threeimplementations.",
	"Method": "SymbolReference<ResolvedTypeDeclaration> solveType(String name){\r\n    if (this.wrappedNode.getTypeParameters() != null) {\r\n        for (com.github.javaparser.ast.type.TypeParameter typeParameter : this.wrappedNode.getTypeParameters()) {\r\n            if (typeParameter.getName().getId().equals(name)) {\r\n                return SymbolReference.solved(new JavaParserTypeVariableDeclaration(typeParameter, typeSolver));\r\n            }\r\n        }\r\n    }\r\n    for (BodyDeclaration<?> member : this.wrappedNode.getMembers()) {\r\n        if (member instanceof com.github.javaparser.ast.body.TypeDeclaration) {\r\n            com.github.javaparser.ast.body.TypeDeclaration<?> internalType = (com.github.javaparser.ast.body.TypeDeclaration<?>) member;\r\n            String prefix = internalType.getName() + \".\";\r\n            if (internalType.getName().getId().equals(name)) {\r\n                if (internalType instanceof ClassOrInterfaceDeclaration) {\r\n                    return SymbolReference.solved(new JavaParserClassDeclaration((com.github.javaparser.ast.body.ClassOrInterfaceDeclaration) internalType, typeSolver));\r\n                } else if (internalType instanceof EnumDeclaration) {\r\n                    return SymbolReference.solved(new JavaParserEnumDeclaration((com.github.javaparser.ast.body.EnumDeclaration) internalType, typeSolver));\r\n                } else {\r\n                    throw new UnsupportedOperationException();\r\n                }\r\n            } else if (name.startsWith(prefix) && name.length() > prefix.length()) {\r\n                if (internalType instanceof ClassOrInterfaceDeclaration) {\r\n                    return new JavaParserClassDeclaration((com.github.javaparser.ast.body.ClassOrInterfaceDeclaration) internalType, typeSolver).solveType(name.substring(prefix.length()), typeSolver);\r\n                } else if (internalType instanceof EnumDeclaration) {\r\n                    return new SymbolSolver(typeSolver).solveTypeInType(new JavaParserEnumDeclaration((com.github.javaparser.ast.body.EnumDeclaration) internalType, typeSolver), name.substring(prefix.length()));\r\n                } else {\r\n                    throw new UnsupportedOperationException();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return SymbolReference.unsolved(TypeDeclaration.class);\r\n}"
}, {
	"Path": "com.github.javaparser.JavaParser.parseTypeDeclaration",
	"Comment": "parses a type declaration and returns it as a typedeclaration.",
	"Method": "TypeDeclaration<?> parseTypeDeclaration(String typeDeclaration){\r\n    return simplifiedParse(TYPE_DECLARATION, provider(typeDeclaration));\r\n}"
}, {
	"Path": "org.eclipse.jetty.jspc.plugin.JspcMojo.cleanupSrcs",
	"Comment": "until jasper supports the option to generate the srcs in a different dirthan the classes, this is the best we can do.",
	"Method": "void cleanupSrcs(){\r\n    if (!keepSources) {\r\n        File generatedClassesDir = new File(generatedClasses);\r\n        if (generatedClassesDir.exists() && generatedClassesDir.isDirectory()) {\r\n            delete(generatedClassesDir, pathname -> {\r\n                return pathname.isDirectory() || pathname.getName().endsWith(\".java\");\r\n            });\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.AtomicBiInteger.addAndGetLo",
	"Comment": "atomically adds the given delta to the current lo value, returning the updated lo value.",
	"Method": "int addAndGetLo(int delta){\r\n    while (true) {\r\n        long encoded = get();\r\n        int lo = getLo(encoded) + delta;\r\n        long update = encodeLo(encoded, lo);\r\n        if (compareAndSet(encoded, update))\r\n            return lo;\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration.canBeAssignedTo",
	"Comment": "can we assign instances of the type defined by this declaration to variables having the type definedby the given type?",
	"Method": "boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other){\r\n    return other.isAssignableBy(this);\r\n}"
}, {
	"Path": "org.javaee7.jms.batch.JmsItemReaderTest.worksInMultipleRuns",
	"Comment": "to verify that the durable subscription really collects messages we do few more runs.",
	"Method": "void worksInMultipleRuns(){\r\n    int sum = sendMessages(14);\r\n    runJob();\r\n    assertEquals(14, collector.getLastItemCount());\r\n    assertEquals(sum, collector.getLastSum());\r\n    assertEquals(2, collector.getNumberOfJobs());\r\n    sum = sendMessages(8);\r\n    sum += sendMessages(4);\r\n    runJob();\r\n    assertEquals(12, collector.getLastItemCount());\r\n    assertEquals(sum, collector.getLastSum());\r\n    assertEquals(3, collector.getNumberOfJobs());\r\n}"
}, {
	"Path": "com.github.javaparser.generator.Generator.removeMethodWithSameSignature",
	"Comment": "removes all methods from containingclassorinterface that have the same signature as callable. this is not used byany code, but it is useful when changing a generator and you need to get rid of a set of outdated methods.",
	"Method": "void removeMethodWithSameSignature(ClassOrInterfaceDeclaration containingClassOrInterface,CallableDeclaration<?> callable){\r\n    for (CallableDeclaration<?> existingCallable : containingClassOrInterface.getCallablesWithSignature(callable.getSignature())) {\r\n        containingClassOrInterface.remove(existingCallable);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.security.authentication.ConfigurableSpnegoAuthenticator.setAuthenticationDuration",
	"Comment": "sets the duration of the authentication.a negative duration means that the authentication is only valid for the current request.a zero duration means that the authentication is valid forever.a positive value means that the authentication is valid for the specified duration.",
	"Method": "void setAuthenticationDuration(Duration authenticationDuration){\r\n    _authenticationDuration = authenticationDuration;\r\n}"
}, {
	"Path": "io.github.javiewer.view.SimpleSearchView.setMenuItem",
	"Comment": "call this method and pass the menu item so this class can handle click events for the menu item.",
	"Method": "void setMenuItem(MenuItem menuItem){\r\n    this.mMenuItem = menuItem;\r\n    mMenuItem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\r\n        @Override\r\n        public boolean onMenuItemClick(MenuItem item) {\r\n            showSearch();\r\n            return true;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.github.javiewer.view.SimpleSearchView.setMenuItem",
	"Comment": "call this method and pass the menu item so this class can handle click events for the menu item.",
	"Method": "void setMenuItem(MenuItem menuItem){\r\n    showSearch();\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.util.TextUtil.hint",
	"Comment": "create a hint of what the text is like.used by logging and error messages to get a hint of what the text is like.",
	"Method": "String hint(String text){\r\n    if (text == null) {\r\n        return \"<null>\";\r\n    }\r\n    return '\"' + maxStringLength(30, text) + '\"';\r\n}"
}, {
	"Path": "com.github.javaparser.ast.expr.StringLiteralExpr.setString",
	"Comment": "escapes the given string from special characters and uses it as the literal value.",
	"Method": "StringLiteralExpr setString(String value){\r\n    this.value = StringEscapeUtils.escapeJava(value);\r\n    return this;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.gzip.GzipHandler.isPathGzipable",
	"Comment": "test if the provided request uri is allowed based on the path specs filters.",
	"Method": "boolean isPathGzipable(String requestURI){\r\n    if (requestURI == null)\r\n        return true;\r\n    return _paths.test(requestURI);\r\n}"
}, {
	"Path": "com.github.javaparser.utils.Utils.indent",
	"Comment": "make an indent by appending indentlevel tab characters to the builder.",
	"Method": "StringBuilder indent(StringBuilder builder,int indentLevel){\r\n    for (int i = 0; i < indentLevel; i++) {\r\n        builder.append(\"\\t\");\r\n    }\r\n    return builder;\r\n}"
}, {
	"Path": "org.eclipse.jetty.plus.security.DataSourceLoginService.initDb",
	"Comment": "lookup the datasource for the jndiname and formulate thenecessary sql query strings based on the configured tableand column names.",
	"Method": "void initDb(){\r\n    if (_datasource != null)\r\n        return;\r\n    @SuppressWarnings(\"unused\")\r\n    InitialContext ic = new InitialContext();\r\n    assert ic != null;\r\n    if (_server != null) {\r\n        try {\r\n            _datasource = (DataSource) NamingEntryUtil.lookup(_server, _jndiName);\r\n        } catch (NameNotFoundException e) {\r\n        }\r\n    }\r\n    if (_datasource == null) {\r\n        _datasource = (DataSource) NamingEntryUtil.lookup(null, _jndiName);\r\n    }\r\n    _userSql = \"select \" + _userTableKey + \",\" + _userTablePasswordField + \" from \" + _userTableName + \" where \" + _userTableUserField + \" = ?\";\r\n    _roleSql = \"select r.\" + _roleTableRoleField + \" from \" + _roleTableName + \" r, \" + _userRoleTableName + \" u where u.\" + _userRoleTableUserKey + \" = ?\" + \" and r.\" + _roleTableKey + \" = u.\" + _userRoleTableRoleKey;\r\n    prepareTables();\r\n}"
}, {
	"Path": "com.github.javaparser.ParserConfiguration.getSymbolResolver",
	"Comment": "retrieve the symbolresolver to be used while parsing, if any.",
	"Method": "Optional<SymbolResolver> getSymbolResolver(){\r\n    return Optional.ofNullable(symbolResolver);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.LocalConnector.getResponse",
	"Comment": "get a single response using a parser to search for the end of the message.",
	"Method": "ByteBuffer getResponse(ByteBuffer requestsBuffer,ByteBuffer getResponse,ByteBuffer requestBuffer,long time,TimeUnit unit,ByteBuffer getResponse,ByteBuffer requestBuffer,boolean head,long time,TimeUnit unit,String getResponse,String rawRequest,String getResponse,String rawRequest,long time,TimeUnit unit,String getResponse,String rawRequest,boolean head,long time,TimeUnit unit,String getResponse,String getResponse,boolean head,long time,TimeUnit unit){\r\n    ByteBuffer requestsBuffer = BufferUtil.toBuffer(rawRequest, StandardCharsets.ISO_8859_1);\r\n    if (LOG.isDebugEnabled())\r\n        LOG.debug(\"request {}\", BufferUtil.toUTF8String(requestsBuffer));\r\n    LocalEndPoint endp = executeRequest(requestsBuffer);\r\n    return BufferUtil.toString(endp.waitForResponse(head, time, unit), StandardCharsets.ISO_8859_1);\r\n}"
}, {
	"Path": "org.javaee7.jms.send.receive.classic.ClassicMessageReceiver.receiveMessage",
	"Comment": "waits to receive a message from the jms queue. times out after a givennumber of milliseconds.",
	"Method": "String receiveMessage(int timeoutInMillis){\r\n    String response = null;\r\n    try (Connection connection = connectionFactory.createConnection()) {\r\n        connection.start();\r\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\r\n        MessageConsumer messageConsumer = session.createConsumer(demoQueue);\r\n        Message message = messageConsumer.receive(timeoutInMillis);\r\n        if (message == null) {\r\n            throw new TimeoutException(\"No message received after \" + timeoutInMillis + \"ms\");\r\n        }\r\n        response = message.getBody(String.class);\r\n    }\r\n    return response;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.IPAccessHandler.isAddrUriAllowed",
	"Comment": "check if specified request is allowed by current ipaccess rules.",
	"Method": "boolean isAddrUriAllowed(String addr,String path){\r\n    if (_white.size() > 0) {\r\n        boolean match = false;\r\n        boolean matchedByPath = false;\r\n        for (Map.Entry<String, IPAddressMap<Boolean>> entry : _white.getMatches(path)) {\r\n            matchedByPath = true;\r\n            IPAddressMap<Boolean> addrMap = entry.getValue();\r\n            if ((addrMap != null && (addrMap.size() == 0 || addrMap.match(addr) != null))) {\r\n                match = true;\r\n                break;\r\n            }\r\n        }\r\n        if (_whiteListByPath) {\r\n            if (matchedByPath && !match)\r\n                return false;\r\n        } else {\r\n            if (!match)\r\n                return false;\r\n        }\r\n    }\r\n    if (_black.size() > 0) {\r\n        for (Map.Entry<String, IPAddressMap<Boolean>> entry : _black.getMatches(path)) {\r\n            IPAddressMap<Boolean> addrMap = entry.getValue();\r\n            if (addrMap != null && (addrMap.size() == 0 || addrMap.match(addr) != null))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.jetty.jspc.plugin.JspcMojo.setUpWebAppClassPath",
	"Comment": "set up the execution classpath for jasper.put everything in the classesdirectory and all of the dependencies on theclasspath.",
	"Method": "List<URL> setUpWebAppClassPath(){\r\n    List<URL> urls = new ArrayList<URL>();\r\n    String classesDir = classesDirectory.getCanonicalPath();\r\n    classesDir = classesDir + (classesDir.endsWith(File.pathSeparator) ? \"\" : File.separator);\r\n    urls.add(Resource.toURL(new File(classesDir)));\r\n    if (getLog().isDebugEnabled())\r\n        getLog().debug(\"Adding to classpath classes dir: \" + classesDir);\r\n    for (Iterator<Artifact> iter = project.getArtifacts().iterator(); iter.hasNext(); ) {\r\n        Artifact artifact = iter.next();\r\n        if (!Artifact.SCOPE_TEST.equals(artifact.getScope()) && !Artifact.SCOPE_PROVIDED.equals(artifact.getScope())) {\r\n            String filePath = artifact.getFile().getCanonicalPath();\r\n            if (getLog().isDebugEnabled())\r\n                getLog().debug(\"Adding to classpath dependency file: \" + filePath);\r\n            urls.add(Resource.toURL(artifact.getFile()));\r\n        }\r\n    }\r\n    return urls;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.HttpConnectionTest.testHttp11_ChunkedBodyTruncation",
	"Comment": "ensure that excessively large hexadecimal chunk body length is parsed properly.",
	"Method": "void testHttp11_ChunkedBodyTruncation(){\r\n    String request = \"POST /?id=123 HTTP/1.1\\r\\n\" + \"Host: local\\r\\n\" + \"Transfer-Encoding: chunked\\r\\n\" + \"Content-Type: text/plain\\r\\n\" + \"Connection: close\\r\\n\" + \"\\r\\n\" + \"1ff00000008\\r\\n\" + \"abcdefgh\\r\\n\" + \"\\r\\n\" + \"0\\r\\n\" + \"\\r\\n\" + \"POST /?id=bogus HTTP/1.1\\r\\n\" + \"Content-Length: 5\\r\\n\" + \"Host: dummy-host.example.com\\r\\n\" + \"\\r\\n\" + \"12345\";\r\n    String response = connector.getResponse(request);\r\n    assertThat(response, containsString(\" 200 OK\"));\r\n    assertThat(response, containsString(\"Connection: close\"));\r\n    assertThat(response, containsString(\"Early EOF\"));\r\n}"
}, {
	"Path": "com.github.javaparser.ParseResult.ifSuccessful",
	"Comment": "calls the consumer with the result if parsing was succesful.",
	"Method": "void ifSuccessful(Consumer<T> consumer){\r\n    if (isSuccessful()) {\r\n        consumer.accept(result);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.HandlerCollection.addHandler",
	"Comment": "add a handler.this implementation adds the passed handler to the end of the existing collection of handlers.",
	"Method": "void addHandler(Handler handler){\r\n    setHandlers(ArrayUtil.addToArray(getHandlers(), handler, Handler.class));\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.GracefulStopTest.testGracefulComplete",
	"Comment": "test of standard graceful timeout mechanism when a block request doescomplete. note that even though the request completes after 100ms, thestop always takes 1000ms",
	"Method": "void testGracefulComplete(){\r\n    Server server = new Server();\r\n    server.setStopTimeout(10000);\r\n    ServerConnector connector = new ServerConnector(server);\r\n    connector.setPort(0);\r\n    server.addConnector(connector);\r\n    TestHandler handler = new TestHandler();\r\n    StatisticsHandler stats = new StatisticsHandler();\r\n    server.setHandler(stats);\r\n    stats.setHandler(handler);\r\n    server.start();\r\n    final int port = connector.getLocalPort();\r\n    try (final Socket client1 = new Socket(\"127.0.0.1\", port);\r\n        final Socket client2 = new Socket(\"127.0.0.1\", port)) {\r\n        client1.getOutputStream().write((\"POST / HTTP/1.0\\r\\n\" + \"Host: localhost:\" + port + \"\\r\\n\" + \"Content-Type: plain/text\\r\\n\" + \"Content-Length: 10\\r\\n\" + \"\\r\\n\" + \"12345\").getBytes());\r\n        client1.getOutputStream().flush();\r\n        handler.latch.await();\r\n        new Thread() {\r\n            @Override\r\n            public void run() {\r\n                long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());\r\n                long end = now + 500;\r\n                try {\r\n                    Thread.sleep(100);\r\n                    try {\r\n                        try (Socket s = new Socket(\"127.0.0.1\", port)) {\r\n                        }\r\n                        throw new IllegalStateException();\r\n                    } catch (ConnectException e) {\r\n                    }\r\n                    client2.getOutputStream().write((\"GET / HTTP/1.0\\r\\n\" + \"Host: localhost:\" + port + \"\\r\\n\" + \"\\r\\n\").getBytes());\r\n                    client2.getOutputStream().flush();\r\n                    String response2 = IO.toString(client2.getInputStream());\r\n                    assertThat(response2, containsString(\" 503 \"));\r\n                    now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());\r\n                    Thread.sleep(Math.max(1, end - now));\r\n                    client1.getOutputStream().write(\"567890\".getBytes());\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }.start();\r\n        long start = System.nanoTime();\r\n        server.stop();\r\n        long stop = System.nanoTime();\r\n        assertThat(TimeUnit.NANOSECONDS.toMillis(stop - start), greaterThan(490L));\r\n        assertThat(TimeUnit.NANOSECONDS.toMillis(stop - start), lessThan(10000L));\r\n        String response = IO.toString(client1.getInputStream());\r\n        assertThat(handler.handling.get(), is(false));\r\n        assertThat(response, containsString(\" 200 OK\"));\r\n        assertThat(response, containsString(\"read 10/10\"));\r\n        assertThat(stats.getRequests(), is(2));\r\n        assertThat(stats.getResponses5xx(), is(1));\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.GracefulStopTest.testGracefulComplete",
	"Comment": "test of standard graceful timeout mechanism when a block request doescomplete. note that even though the request completes after 100ms, thestop always takes 1000ms",
	"Method": "void testGracefulComplete(){\r\n    long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());\r\n    long end = now + 500;\r\n    try {\r\n        Thread.sleep(100);\r\n        try {\r\n            try (Socket s = new Socket(\"127.0.0.1\", port)) {\r\n            }\r\n            throw new IllegalStateException();\r\n        } catch (ConnectException e) {\r\n        }\r\n        client2.getOutputStream().write((\"GET / HTTP/1.0\\r\\n\" + \"Host: localhost:\" + port + \"\\r\\n\" + \"\\r\\n\").getBytes());\r\n        client2.getOutputStream().flush();\r\n        String response2 = IO.toString(client2.getInputStream());\r\n        assertThat(response2, containsString(\" 503 \"));\r\n        now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());\r\n        Thread.sleep(Math.max(1, end - now));\r\n        client1.getOutputStream().write(\"567890\".getBytes());\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.ast.expr.FieldAccessExpr.isTopLevel",
	"Comment": "indicate if this fieldaccessexpr is top level, i.e., it is not directly contained in a larger fieldaccessexpr.",
	"Method": "boolean isTopLevel(){\r\n    return !isInternal();\r\n}"
}, {
	"Path": "com.github.javaparser.ast.nodeTypes.NodeWithAnnotations.addMarkerAnnotation",
	"Comment": "annotates this with a marker annotation and automatically add the import",
	"Method": "N addMarkerAnnotation(String name,N addMarkerAnnotation,Class<? extends Annotation> clazz){\r\n    ((Node) this).tryAddImportToParentCompilationUnit(clazz);\r\n    return addMarkerAnnotation(clazz.getSimpleName());\r\n}"
}, {
	"Path": "com.github.javaparser.JavaParser.parsePackageDeclaration",
	"Comment": "parses a package declaration and returns it as a packagedeclaration.",
	"Method": "PackageDeclaration parsePackageDeclaration(String packageDeclaration){\r\n    return simplifiedParse(PACKAGE_DECLARATION, provider(packageDeclaration));\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.BundleWebAppProvider.bundleRemoved",
	"Comment": "bundle has been removed. if it was a webapp we deployed, undeploy it.",
	"Method": "boolean bundleRemoved(Bundle bundle){\r\n    App app = _bundleMap.remove(bundle);\r\n    if (app != null) {\r\n        getDeploymentManager().removeApp(app);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.ServletRequestLogTest.testLogHandlerCollection_ErrorHandler_ServerBean",
	"Comment": "test a requestloghandler at the end of a handlercollection.and also with the default errorhandler as server bean in place.",
	"Method": "void testLogHandlerCollection_ErrorHandler_ServerBean(Servlet testServlet,String requestPath,String expectedLogEntry){\r\n    Server server = new Server();\r\n    ServerConnector connector = new ServerConnector(server);\r\n    connector.setPort(0);\r\n    server.setConnectors(new Connector[] { connector });\r\n    ErrorHandler errorHandler = new ErrorHandler();\r\n    server.addBean(errorHandler);\r\n    HandlerCollection handlers = new HandlerCollection();\r\n    ContextHandlerCollection contexts = new ContextHandlerCollection();\r\n    DefaultHandler defaultHandler = new DefaultHandler();\r\n    handlers.setHandlers(new Handler[] { contexts, defaultHandler });\r\n    server.setHandler(handlers);\r\n    CaptureLog captureLog = new CaptureLog();\r\n    server.setRequestLog(captureLog);\r\n    ServletContextHandler app = new ServletContextHandler(ServletContextHandler.SESSIONS);\r\n    app.setContextPath(\"/\");\r\n    contexts.addHandler(app);\r\n    ServletHolder testHolder = new ServletHolder(testServlet);\r\n    app.addServlet(testHolder, \"/test\");\r\n    try {\r\n        server.start();\r\n        Assertions.assertTimeoutPreemptively(ofSeconds(4), () -> {\r\n            String host = connector.getHost();\r\n            if (host == null) {\r\n                host = \"localhost\";\r\n            }\r\n            int port = connector.getLocalPort();\r\n            URI serverUri = new URI(\"http\", null, host, port, requestPath, null, null);\r\n            HttpURLConnection connection = (HttpURLConnection) serverUri.toURL().openConnection();\r\n            try {\r\n                connection.setAllowUserInteraction(false);\r\n                int statusCode = connection.getResponseCode();\r\n                LOG.debug(\"Response Status Code: {}\", statusCode);\r\n                if (statusCode == 200) {\r\n                    String content = getResponseContent(connection);\r\n                    LOG.debug(\"Response Content: {}\", content);\r\n                }\r\n            } finally {\r\n                connection.disconnect();\r\n            }\r\n            assertRequestLog(expectedLogEntry, captureLog);\r\n        });\r\n    } finally {\r\n        server.stop();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.ant.ServerProxyImpl.configure",
	"Comment": "configures jetty server before adding any web applications to it.",
	"Method": "void configure(){\r\n    if (configured)\r\n        return;\r\n    configured = true;\r\n    if (stopPort > 0 && stopKey != null) {\r\n        ShutdownMonitor monitor = ShutdownMonitor.getInstance();\r\n        monitor.setPort(stopPort);\r\n        monitor.setKey(stopKey);\r\n        monitor.setExitVm(false);\r\n    }\r\n    if (tempDirectory != null && !tempDirectory.exists())\r\n        tempDirectory.mkdirs();\r\n    applyJettyXml();\r\n    if (connectors != null) {\r\n        for (Connector c : connectors) {\r\n            ServerConnector jc = new ServerConnector(server);\r\n            jc.setPort(c.getPort());\r\n            jc.setIdleTimeout(c.getMaxIdleTime());\r\n            server.addConnector(jc);\r\n        }\r\n    }\r\n    if (loginServices != null) {\r\n        for (LoginService ls : loginServices) {\r\n            server.addBean(ls);\r\n        }\r\n    }\r\n    Resource.setDefaultUseCaches(false);\r\n    configureHandlers();\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.SessionHandler.recordSessionTime",
	"Comment": "record length of time session has been active. called when thesession is about to be invalidated.",
	"Method": "void recordSessionTime(Session session){\r\n    _sessionTimeStats.record(round((System.currentTimeMillis() - session.getSessionData().getCreated()) / 1000.0));\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.api.WebSocketPolicy.clonePolicy",
	"Comment": "make a copy of the policy, with current values, but a different behavior.",
	"Method": "WebSocketPolicy clonePolicy(WebSocketPolicy clonePolicy,WebSocketBehavior behavior,WebSocketPolicy clonePolicy,WebSocketPolicy clonePolicy,WebSocketBehavior behavior){\r\n    return delegateAs(behavior);\r\n}"
}, {
	"Path": "io.github.javiewer.view.SimpleSearchView.showVoice",
	"Comment": "if show is true, this will enable voice search. if voice is not available on the device, this method call has not effect.",
	"Method": "void showVoice(boolean show){\r\n    if (show && isVoiceAvailable() && allowVoiceSearch) {\r\n        mVoiceBtn.setVisibility(VISIBLE);\r\n    } else {\r\n        mVoiceBtn.setVisibility(GONE);\r\n    }\r\n}"
}, {
	"Path": "org.javaee7.websocket.encoder.client.MyClientTest.createDeployment",
	"Comment": "arquillian specific method for creating a file which can be deployedwhile executing the test.",
	"Method": "WebArchive createDeployment(){\r\n    return ShrinkWrap.create(WebArchive.class).addClasses(MyEndpoint.class, MyMessage.class, MyMessageEncoder.class, MyMessageDecoder.class);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.HttpConnection.getCurrentConnection",
	"Comment": "get the current connection that this thread is dispatched to.note that a thread may be processing a request asynchronously andthus not be dispatched to the connection.",
	"Method": "HttpConnection getCurrentConnection(){\r\n    return __currentConnection.get();\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.HttpURI.createHttpURI",
	"Comment": "construct a normalized uri.port is not set if it is the default port.",
	"Method": "HttpURI createHttpURI(String scheme,String host,int port,String path,String param,String query,String fragment){\r\n    if (port == 80 && HttpScheme.HTTP.is(scheme))\r\n        port = 0;\r\n    if (port == 443 && HttpScheme.HTTPS.is(scheme))\r\n        port = 0;\r\n    return new HttpURI(scheme, host, port, path, param, query, fragment);\r\n}"
}, {
	"Path": "org.javaee7.jaspic.basicauthentication.BasicAuthenticationStatelessTest.testProtectedAccessIsStateless",
	"Comment": "tests that access to a protected page does not depend on the authenticated identity that was established in a previousrequest.",
	"Method": "void testProtectedAccessIsStateless(){\r\n    String response = getFromServerPath(\"protected/servlet\");\r\n    assertFalse(response.contains(\"This is a protected servlet\"));\r\n    response = getFromServerPath(\"protected/servlet?doLogin=true\");\r\n    assertTrue(\"Could not access protected page, but should be able to. \" + \"Did the container remember the previously set 'unauthenticated identity'?\", response.contains(\"This is a protected servlet\"));\r\n    response = getFromServerPath(\"protected/servlet\");\r\n    assertFalse(\"Could access protected page, but should not be able to. \" + \"Did the container remember the authenticated identity that was set in previous request?\", response.contains(\"This is a protected servlet\"));\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.resource.FileResource.getFile",
	"Comment": "returns an file representing the given resource or null if thisis not possible.",
	"Method": "File getFile(){\r\n    return _file;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.AbstractSessionCache.contains",
	"Comment": "check to see if this cache contains an entry for the sessioncorresponding to the session id.",
	"Method": "boolean contains(String id){\r\n    return (doGet(id) != null);\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.core.resolution.Context.solveConstructor",
	"Comment": "we find the method declaration which is the best match for the given name and list of typeparametersvalues.",
	"Method": "SymbolReference<ResolvedConstructorDeclaration> solveConstructor(List<ResolvedType> argumentsTypes){\r\n    throw new IllegalArgumentException(\"Constructor resolution is available only on Class Context\");\r\n}"
}, {
	"Path": "org.eclipse.jetty.webapp.StandardDescriptorProcessor.visitDenyUncoveredHttpMethods",
	"Comment": "servlet spec 3.1. when present in web.xml, this means that http methods that arenot covered by security constraints should have access denied.see section 13.8.4, pg 145",
	"Method": "void visitDenyUncoveredHttpMethods(WebAppContext context,Descriptor descriptor,XmlParser.Node node){\r\n    if (context.getSecurityHandler() == null) {\r\n        LOG.warn(\"deny-uncovered-http-methods declared but SecurityHandler==null\");\r\n        return;\r\n    }\r\n    ((ConstraintAware) context.getSecurityHandler()).setDenyUncoveredHttpMethods(true);\r\n}"
}, {
	"Path": "org.eclipse.jetty.ant.types.Connectors.getDefaultConnectors",
	"Comment": "gets the default list of connectors to deploy when no connectorswere explicitly added to the list.",
	"Method": "List<Connector> getDefaultConnectors(){\r\n    return defaultConnectors;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.ContextHandler.setVirtualHosts",
	"Comment": "set the virtual hosts for the context. only requests that have a matching host header or fully qualified url will be passed to that context with avirtual host name. a context with no virtual host names or a null virtual host name is available to all requests that are not served by a context with amatching virtual host name.",
	"Method": "void setVirtualHosts(String[] vhosts){\r\n    if (vhosts == null) {\r\n        _vhosts = vhosts;\r\n    } else {\r\n        boolean hostMatch = false;\r\n        boolean connectorHostMatch = false;\r\n        _vhosts = new String[vhosts.length];\r\n        _vconnectors = new String[vhosts.length];\r\n        _vhostswildcard = new boolean[vhosts.length];\r\n        ArrayList<Integer> connectorOnlyIndexes = null;\r\n        for (int i = 0; i < vhosts.length; i++) {\r\n            boolean connectorMatch = false;\r\n            _vhosts[i] = vhosts[i];\r\n            if (vhosts[i] == null)\r\n                continue;\r\n            int connectorIndex = _vhosts[i].indexOf('@');\r\n            if (connectorIndex >= 0) {\r\n                connectorMatch = true;\r\n                _vconnectors[i] = _vhosts[i].substring(connectorIndex + 1);\r\n                _vhosts[i] = _vhosts[i].substring(0, connectorIndex);\r\n                if (connectorIndex == 0) {\r\n                    if (connectorOnlyIndexes == null)\r\n                        connectorOnlyIndexes = new ArrayList<Integer>();\r\n                    connectorOnlyIndexes.add(i);\r\n                }\r\n            }\r\n            if (_vhosts[i].startsWith(\"*.\")) {\r\n                _vhosts[i] = _vhosts[i].substring(1);\r\n                _vhostswildcard[i] = true;\r\n            }\r\n            if (_vhosts[i].isEmpty())\r\n                _vhosts[i] = null;\r\n            else {\r\n                hostMatch = true;\r\n                connectorHostMatch = connectorHostMatch || connectorMatch;\r\n            }\r\n            _vhosts[i] = normalizeHostname(_vhosts[i]);\r\n        }\r\n        if (connectorOnlyIndexes != null && hostMatch && !connectorHostMatch) {\r\n            LOG.warn(\"ContextHandler {} has a connector only entry e.g. \\\"@connector\\\" and one or more host only entries. \\n\" + \"The host entries will be ignored to match legacy behavior.  To clear this warning remove the host entries or update to us at least one host@connector syntax entry that will match a host for an specific connector\", Arrays.asList(vhosts));\r\n            String[] filteredHosts = new String[connectorOnlyIndexes.size()];\r\n            for (int i = 0; i < connectorOnlyIndexes.size(); i++) {\r\n                filteredHosts[i] = vhosts[connectorOnlyIndexes.get(i)];\r\n            }\r\n            setVirtualHosts(filteredHosts);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.HttpConfiguration.getIdleTimeout",
	"Comment": "the max idle time is applied to a http request for io operations anddelayed dispatch.",
	"Method": "long getIdleTimeout(){\r\n    return _idleTimeout;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.component.ContainerLifeCycle.destroy",
	"Comment": "destroys the managed destroyable beans in the reverse order they were added.",
	"Method": "void destroy(){\r\n    _destroyed = true;\r\n    List<Bean> reverse = new ArrayList(_beans);\r\n    Collections.reverse(reverse);\r\n    for (Bean b : reverse) {\r\n        if (b._bean instanceof Destroyable && (b._managed == Managed.MANAGED || b._managed == Managed.POJO)) {\r\n            Destroyable d = (Destroyable) b._bean;\r\n            try {\r\n                d.destroy();\r\n            } catch (Throwable th) {\r\n                LOG.warn(th);\r\n            }\r\n        }\r\n    }\r\n    _beans.clear();\r\n}"
}, {
	"Path": "org.eclipse.jetty.gcloud.session.GCloudSessionDataStore.sessionFromEntity",
	"Comment": "generate sessiondata from an entity retrieved from gcloud datastore.",
	"Method": "SessionData sessionFromEntity(Entity entity){\r\n    if (entity == null)\r\n        return null;\r\n    String id = entity.getString(_model.getId());\r\n    String contextPath = entity.getString(_model.getContextPath());\r\n    String vhost = entity.getString(_model.getVhost());\r\n    long accessed = entity.getLong(_model.getAccessed());\r\n    long lastAccessed = entity.getLong(_model.getLastAccessed());\r\n    long createTime = entity.getLong(_model.getCreateTime());\r\n    long cookieSet = entity.getLong(_model.getCookieSetTime());\r\n    String lastNode = entity.getString(_model.getLastNode());\r\n    long lastSaved = 0;\r\n    try {\r\n        lastSaved = entity.getLong(_model.getLastSaved());\r\n    } catch (DatastoreException e) {\r\n        LOG.ignore(e);\r\n    }\r\n    long expiry = entity.getLong(_model.getExpiry());\r\n    long maxInactive = entity.getLong(_model.getMaxInactive());\r\n    Blob blob = (Blob) entity.getBlob(_model.getAttributes());\r\n    SessionData session = newSessionData(id, createTime, accessed, lastAccessed, maxInactive);\r\n    session.setLastNode(lastNode);\r\n    session.setContextPath(contextPath);\r\n    session.setVhost(vhost);\r\n    session.setCookieSet(cookieSet);\r\n    session.setLastNode(lastNode);\r\n    session.setLastSaved(lastSaved);\r\n    session.setExpiry(expiry);\r\n    try (ClassLoadingObjectInputStream ois = new ClassLoadingObjectInputStream(blob.asInputStream())) {\r\n        SessionData.deserializeAttributes(session, ois);\r\n    } catch (Exception e) {\r\n        throw new UnreadableSessionDataException(id, _context, e);\r\n    }\r\n    return session;\r\n}"
}, {
	"Path": "com.github.javaparser.printer.lexicalpreservation.TextElementMatcher.and",
	"Comment": "this allows the combination of different textelementmatcher instances.if combined, all of the textelementmatchers have to return true.",
	"Method": "TextElementMatcher and(TextElementMatcher textElementMatcher){\r\n    return textElement -> this.match(textElement) && textElementMatcher.match(textElement);\r\n}"
}, {
	"Path": "org.eclipse.jetty.webapp.WebAppContext.setPersistTempDirectory",
	"Comment": "if true the temp directory for this webapp will be kept when the webapp stops. otherwise,it will be deleted.",
	"Method": "void setPersistTempDirectory(boolean persist){\r\n    _persistTmpDir = persist;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedDeclaration.asMethod",
	"Comment": "return this as a methoddeclaration or throw an unsupportedoperationexception",
	"Method": "ResolvedMethodDeclaration asMethod(){\r\n    throw new UnsupportedOperationException(String.format(\"%s is not a MethodDeclaration\", this));\r\n}"
}, {
	"Path": "com.github.javaparser.utils.Log.setAdapter",
	"Comment": "change how logging is handled. you can set your own implementation that forwards to your logging library.",
	"Method": "void setAdapter(Adapter adapter){\r\n    CURRENT_ADAPTER = adapter;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.MultiMap.add",
	"Comment": "add value to multi valued entry.if the entry is single valued, it is converted to the firstvalue of a multi valued entry.",
	"Method": "void add(String name,V value){\r\n    List<V> lo = get(name);\r\n    if (lo == null) {\r\n        lo = new ArrayList();\r\n    }\r\n    lo.add(value);\r\n    super.put(name, lo);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.HouseKeeper.findScheduler",
	"Comment": "get a scheduler. first try a common scheduler, failing thatcreate our own.",
	"Method": "void findScheduler(){\r\n    if (_scheduler == null) {\r\n        if (_sessionIdManager instanceof DefaultSessionIdManager) {\r\n            _scheduler = ((DefaultSessionIdManager) _sessionIdManager).getServer().getBean(Scheduler.class);\r\n        }\r\n        if (_scheduler == null) {\r\n            _scheduler = new ScheduledExecutorScheduler();\r\n            _ownScheduler = true;\r\n            _scheduler.start();\r\n            if (LOG.isDebugEnabled())\r\n                LOG.debug(\"Using own scheduler for scavenging\");\r\n        } else if (!_scheduler.isStarted())\r\n            throw new IllegalStateException(\"Shared scheduler not started\");\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.ServletRequestLogTest.testLogHandlerCollection",
	"Comment": "test a requestloghandler at the end of a handlercollection.this handler chain is setup to look like jetty versions up to 9.2. default configuration.",
	"Method": "void testLogHandlerCollection(Servlet testServlet,String requestPath,String expectedLogEntry){\r\n    Server server = new Server();\r\n    ServerConnector connector = new ServerConnector(server);\r\n    connector.setPort(0);\r\n    server.setConnectors(new Connector[] { connector });\r\n    HandlerCollection handlers = new HandlerCollection();\r\n    ContextHandlerCollection contexts = new ContextHandlerCollection();\r\n    DefaultHandler defaultHandler = new DefaultHandler();\r\n    handlers.setHandlers(new Handler[] { contexts, defaultHandler });\r\n    server.setHandler(handlers);\r\n    CaptureLog captureLog = new CaptureLog();\r\n    server.setRequestLog(captureLog);\r\n    ServletContextHandler app = new ServletContextHandler(ServletContextHandler.SESSIONS);\r\n    app.setContextPath(\"/\");\r\n    contexts.addHandler(app);\r\n    ServletHolder testHolder = new ServletHolder(testServlet);\r\n    app.addServlet(testHolder, \"/test\");\r\n    try {\r\n        Assertions.assertTimeoutPreemptively(ofSeconds(4), () -> {\r\n            server.start();\r\n            String host = connector.getHost();\r\n            if (host == null) {\r\n                host = \"localhost\";\r\n            }\r\n            int port = connector.getLocalPort();\r\n            URI serverUri = new URI(\"http\", null, host, port, requestPath, null, null);\r\n            HttpURLConnection connection = (HttpURLConnection) serverUri.toURL().openConnection();\r\n            try {\r\n                connection.setAllowUserInteraction(false);\r\n                int statusCode = connection.getResponseCode();\r\n                LOG.debug(\"Response Status Code: {}\", statusCode);\r\n                if (statusCode == 200) {\r\n                    String content = getResponseContent(connection);\r\n                    LOG.debug(\"Response Content: {}\", content);\r\n                }\r\n            } finally {\r\n                connection.disconnect();\r\n            }\r\n            assertRequestLog(expectedLogEntry, captureLog);\r\n        });\r\n    } finally {\r\n        server.stop();\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedMethodLikeDeclaration.getLastParam",
	"Comment": "utility method to get the last parameterdeclaration. it throws unsupportedoperationexception if the methodhas no parameters.the last parameter can be variadic and sometimes it needs to be handled in a special way.",
	"Method": "ResolvedParameterDeclaration getLastParam(){\r\n    if (getNumberOfParams() == 0) {\r\n        throw new UnsupportedOperationException(\"This method has no typeParametersValues, therefore it has no a last parameter\");\r\n    }\r\n    return getParam(getNumberOfParams() - 1);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.DefaultSessionIdManager.initRandom",
	"Comment": "set up a random number generator for the sessionids.by preference, use a securerandom but allow to be injected.",
	"Method": "void initRandom(){\r\n    if (_random == null) {\r\n        try {\r\n            _random = new SecureRandom();\r\n        } catch (Exception e) {\r\n            LOG.warn(\"Could not generate SecureRandom for session-id randomness\", e);\r\n            _random = new Random();\r\n            _weakRandom = true;\r\n        }\r\n    } else\r\n        _random.setSeed(_random.nextLong() ^ System.currentTimeMillis() ^ hashCode() ^ Runtime.getRuntime().freeMemory());\r\n}"
}, {
	"Path": "org.eclipse.jetty.annotations.AnnotationConfiguration.isFromContainerClassPath",
	"Comment": "test if the servletcontainerinitializer is from the container classpath",
	"Method": "boolean isFromContainerClassPath(WebAppContext context,ServletContainerInitializer sci){\r\n    if (sci == null)\r\n        return false;\r\n    return sci.getClass().getClassLoader() == context.getClassLoader().getParent();\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.UpgradeResponseAdapter.getExtensions",
	"Comment": "get the list of extensions that should be used for the websocket.",
	"Method": "List<ExtensionConfig> getExtensions(){\r\n    return extensions;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.resource.URLResource.getFile",
	"Comment": "returns an file representing the given resource or null if thisis not possible.",
	"Method": "File getFile(){\r\n    return null;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.CompilationUnit.getTypes",
	"Comment": "return the list of types declared in this compilation unit.if there is no types declared, null is returned.",
	"Method": "NodeList<TypeDeclaration<?>> getTypes(){\r\n    return types;\r\n}"
}, {
	"Path": "org.javaee7.jaspictest.customprincipal.CustomPrincipalStatelessTest.testProtectedAccessIsStateless2",
	"Comment": "tests that access to a protected page does not depend on the authenticated identity that was established in a previousrequest, but use a different request order than the previous test.",
	"Method": "void testProtectedAccessIsStateless2(){\r\n    String response = getFromServerPath(\"protected/servlet?doLogin=true\");\r\n    response = getFromServerPath(\"protected/servlet\");\r\n    assertFalse(\"Could access protected page, but should not be able to. \" + \"Did the container remember the authenticated identity that was set in previous request?\", response.contains(\"This is a protected servlet\"));\r\n}"
}, {
	"Path": "com.github.javaparser.ast.nodeTypes.NodeWithThrownExceptions.isThrown",
	"Comment": "check whether this elements throws this exception classnote that this is simply a text compare,no actual type resolution takes place.",
	"Method": "boolean isThrown(Class<? extends Throwable> clazz,boolean isThrown,String throwableName){\r\n    return getThrownExceptions().stream().anyMatch(t -> t.toString().equals(throwableName));\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.jsr356.server.StreamTest.assertFileUpload",
	"Comment": "verify that the file sha1sum matches the previously calculated sha1sum",
	"Method": "void assertFileUpload(File file,File sha1File){\r\n    assertThat(\"Path should exist: \" + file, file.exists(), is(true));\r\n    assertThat(\"Path should not be a directory:\" + file, file.isDirectory(), is(false));\r\n    String expectedSha1 = Sha1Sum.loadSha1(sha1File);\r\n    String actualSha1 = Sha1Sum.calculate(file);\r\n    assertThat(\"SHA1Sum of content: \" + file, expectedSha1, equalToIgnoringCase(actualSha1));\r\n}"
}, {
	"Path": "com.github.javaparser.ast.nodeTypes.NodeWithMembers.addFieldWithInitializer",
	"Comment": "add a field to this and automatically add the import of the type if needed",
	"Method": "FieldDeclaration addFieldWithInitializer(Class<?> typeClass,String name,Expression initializer,Modifier modifiers,FieldDeclaration addFieldWithInitializer,String type,String name,Expression initializer,Modifier modifiers,FieldDeclaration addFieldWithInitializer,Type type,String name,Expression initializer,Modifier modifiers){\r\n    FieldDeclaration declaration = addField(type, name, modifiers);\r\n    declaration.getVariables().iterator().next().setInitializer(initializer);\r\n    return declaration;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.visitor.EqualsVisitor.commonNodeEquality",
	"Comment": "check for equality that can be applied to each kind of node,to not repeat it in every method we store that here.",
	"Method": "boolean commonNodeEquality(Node n,Node n2){\r\n    if (!nodeEquals(n1.getComment(), n2.getComment())) {\r\n        return false;\r\n    }\r\n    if (!nodesEquals(n1.getOrphanComments(), n2.getOrphanComments())) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.MultiException.ifExceptionThrowRuntime",
	"Comment": "throw a runtime exception.if this multi exception is empty then no action is taken. if itcontains a single error or runtime exception that is thrown, otherwise the thismulti exception is thrown, wrapped in a runtime exception.",
	"Method": "void ifExceptionThrowRuntime(){\r\n    if (nested == null)\r\n        return;\r\n    switch(nested.size()) {\r\n        case 0:\r\n            break;\r\n        case 1:\r\n            Throwable th = nested.get(0);\r\n            if (th instanceof Error)\r\n                throw (Error) th;\r\n            else if (th instanceof RuntimeException)\r\n                throw (RuntimeException) th;\r\n            else\r\n                throw new RuntimeException(th);\r\n        default:\r\n            throw new RuntimeException(new MultiException(nested));\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllStaticFields",
	"Comment": "return a list of all the static fields, either declared or inherited.",
	"Method": "List<FieldDeclaration> getAllStaticFields(){\r\n    return getAllFields().stream().filter(it -> it.isStatic()).collect(Collectors.toList());\r\n}"
}, {
	"Path": "io.github.javiewer.view.SimpleSearchView.setAdapter",
	"Comment": "set adapter for suggestions list. should implement filterable.",
	"Method": "void setAdapter(ListAdapter adapter){\r\n    mAdapter = adapter;\r\n    mSuggestionsListView.setAdapter(adapter);\r\n    startFilter(mSearchSrcTextView.getText());\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlets.DoSFilter.isTrackSessions",
	"Comment": "get flag to have usage rate tracked by session if a session exists.",
	"Method": "boolean isTrackSessions(){\r\n    return _trackSessions;\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.internal.serverfactory.ServerInstanceWrapper.getParentClassLoaderForWebapps",
	"Comment": "the classloader that should be the parent classloader for each webappdeployed on this server.",
	"Method": "ClassLoader getParentClassLoaderForWebapps(){\r\n    return _commonParentClassLoaderForWebapps;\r\n}"
}, {
	"Path": "com.github.javaparser.GeneratedJavaParserBase.recover",
	"Comment": "called from within a catch block to skip forward to a known token,and report the occurred exception as a problem.",
	"Method": "TokenRange recover(int recoveryTokenType,ParseException p){\r\n    JavaToken begin = null;\r\n    if (p.currentToken != null) {\r\n        begin = token();\r\n    }\r\n    Token t;\r\n    do {\r\n        t = getNextToken();\r\n    } while (t.kind != recoveryTokenType && t.kind != EOF);\r\n    JavaToken end = token();\r\n    TokenRange tokenRange = null;\r\n    if (begin != null && end != null) {\r\n        tokenRange = range(begin, end);\r\n    }\r\n    problems.add(new Problem(makeMessageForParseException(p), tokenRange, p));\r\n    return tokenRange;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.core.resolution.Context.parametersExposedToChild",
	"Comment": "the parameters that are declared in this immediate context and made visible to a given child.this list could include values which are shadowed.",
	"Method": "List<Parameter> parametersExposedToChild(Node child){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "org.javaee7.jms.send.receive.simple.MessageReceiverSync.receiveMessage",
	"Comment": "waits to receive a message from the jms queue. times out after a givennumber of milliseconds.",
	"Method": "String receiveMessage(int timeoutInMillis){\r\n    String message = context.createConsumer(myQueue).receiveBody(String.class, timeoutInMillis);\r\n    if (message == null) {\r\n        throw new TimeoutException(\"No message received after \" + timeoutInMillis + \"ms\");\r\n    }\r\n    return message;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.thread.Invocable.invokeNonBlocking",
	"Comment": "invoke a task with the calling thread, tagged to indicatethat it will not block.",
	"Method": "void invokeNonBlocking(Runnable task){\r\n    Boolean was_non_blocking = __nonBlocking.get();\r\n    try {\r\n        __nonBlocking.set(Boolean.TRUE);\r\n        task.run();\r\n    } finally {\r\n        __nonBlocking.set(was_non_blocking);\r\n    }\r\n}"
}, {
	"Path": "net.bull.javamelody.internal.model.RemoteCall.collectData",
	"Comment": "result contains statistics in instances of counter and also an instance of javainformations",
	"Method": "List<Serializable> collectData(){\r\n    return collectForUrl(url);\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserParameterDeclaration.getWrappedNode",
	"Comment": "returns the javaparser node associated with this javaparserparameterdeclaration.",
	"Method": "Parameter getWrappedNode(){\r\n    return wrappedNode;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration.getAllAncestors",
	"Comment": "the list of all the ancestors of the current declaration, direct and indirect.this list does not contains duplicates with the exacting same type parameters.",
	"Method": "List<ResolvedReferenceType> getAllAncestors(){\r\n    List<ResolvedReferenceType> ancestors = new ArrayList();\r\n    if (!(Object.class.getCanonicalName().equals(getQualifiedName()))) {\r\n        for (ResolvedReferenceType ancestor : getAncestors()) {\r\n            ancestors.add(ancestor);\r\n            for (ResolvedReferenceType inheritedAncestor : ancestor.getAllAncestors()) {\r\n                if (!ancestors.contains(inheritedAncestor)) {\r\n                    ancestors.add(inheritedAncestor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return ancestors;\r\n}"
}, {
	"Path": "net.bull.javamelody.internal.model.Base64Coder.decode",
	"Comment": "decodes a byte array from base64 format.\t no blanks or line breaks are allowed within the base64 encoded input data.",
	"Method": "byte[] decode(String s,byte[] decode,char[] in,byte[] decode,char[] in,int iOff,int iLen){\r\n    if (iLen % 4 != 0) {\r\n        throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n    }\r\n    int iLength = iLen;\r\n    while (iLength > 0 && in[iOff + iLength - 1] == '=') {\r\n        iLength--;\r\n    }\r\n    final int oLen = iLength * 3 / 4;\r\n    final byte[] out = new byte[oLen];\r\n    int ip = iOff;\r\n    final int iEnd = iOff + iLength;\r\n    int op = 0;\r\n    while (ip < iEnd) {\r\n        final int i0 = in[ip++];\r\n        final int i1 = in[ip++];\r\n        final int i2 = ip < iEnd ? in[ip++] : 'A';\r\n        final int i3 = ip < iEnd ? in[ip++] : 'A';\r\n        if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127) {\r\n            throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n        }\r\n        final int b0 = MAP2[i0];\r\n        final int b1 = MAP2[i1];\r\n        final int b2 = MAP2[i2];\r\n        final int b3 = MAP2[i3];\r\n        if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0) {\r\n            throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n        }\r\n        final int o0 = b0 << 2 | b1 >>> 4;\r\n        final int o1 = (b1 & 0xf) << 4 | b2 >>> 2;\r\n        final int o2 = (b2 & 3) << 6 | b3;\r\n        out[op++] = (byte) o0;\r\n        if (op < oLen) {\r\n            out[op++] = (byte) o1;\r\n        }\r\n        if (op < oLen) {\r\n            out[op++] = (byte) o2;\r\n        }\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.nodeTypes.NodeWithMembers.addProtectedField",
	"Comment": "add a protected field to this and automatically add the import of the typeif needed",
	"Method": "FieldDeclaration addProtectedField(Class<?> typeClass,String name,FieldDeclaration addProtectedField,String type,String name,FieldDeclaration addProtectedField,Type type,String name){\r\n    return addField(type, name, Modifier.PROTECTED);\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedMethodLikeDeclaration.hasVariadicParameter",
	"Comment": "has the method or construcor a variadic parameter?note that when a method has a variadic parameter it should have an array type.",
	"Method": "boolean hasVariadicParameter(){\r\n    if (getNumberOfParams() == 0) {\r\n        return false;\r\n    } else {\r\n        return getParam(getNumberOfParams() - 1).isVariadic();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.spi.TestSPIServer.testUnboundHttpServer",
	"Comment": "create a server that has a null inetsocketaddress, thenbind before using.",
	"Method": "void testUnboundHttpServer(){\r\n    HttpServer server = null;\r\n    try {\r\n        server = new JettyHttpServerProvider().createHttpServer(null, 10);\r\n        final HttpContext httpContext = server.createContext(\"/\", exchange -> {\r\n            Headers responseHeaders = exchange.getResponseHeaders();\r\n            responseHeaders.set(\"Content-Type\", \"text/plain\");\r\n            exchange.sendResponseHeaders(200, 0);\r\n            OutputStream responseBody = exchange.getResponseBody();\r\n            Headers requestHeaders = exchange.getRequestHeaders();\r\n            Set<String> keySet = requestHeaders.keySet();\r\n            Iterator<String> iter = keySet.iterator();\r\n            while (iter.hasNext()) {\r\n                String key = iter.next();\r\n                List values = requestHeaders.get(key);\r\n                String s = key + \" = \" + values.toString() + \"\\n\";\r\n                responseBody.write(s.getBytes());\r\n            }\r\n            responseBody.close();\r\n        });\r\n        httpContext.setAuthenticator(new BasicAuthenticator(\"Test\") {\r\n            @Override\r\n            public boolean checkCredentials(String username, String password) {\r\n                if (\"username\".equals(username) && password.equals(\"password\"))\r\n                    return true;\r\n                return false;\r\n            }\r\n        });\r\n        server.bind(new InetSocketAddress(\"localhost\", 0), 10);\r\n        server.start();\r\n        Server jetty = ((JettyHttpServer) server).getServer();\r\n        int port = ((NetworkConnector) jetty.getConnectors()[0]).getLocalPort();\r\n        HttpClient client = new HttpClient();\r\n        client.start();\r\n        try {\r\n            Request request = client.newRequest(\"http://localhost:\" + port + \"/\");\r\n            client.getAuthenticationStore().addAuthentication(new BasicAuthentication(URI.create(\"http://localhost:\" + port), \"Test\", \"username\", \"password\"));\r\n            ContentResponse response = request.send();\r\n            assertEquals(HttpServletResponse.SC_OK, response.getStatus());\r\n        } finally {\r\n            client.stop();\r\n        }\r\n    } finally {\r\n        if (server != null)\r\n            server.stop(5);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.spi.TestSPIServer.testUnboundHttpServer",
	"Comment": "create a server that has a null inetsocketaddress, thenbind before using.",
	"Method": "void testUnboundHttpServer(){\r\n    if (\"username\".equals(username) && password.equals(\"password\"))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jetty.annotations.AnnotationConfiguration.isFromExcludedJar",
	"Comment": "check to see if the servletcontainerintializer loaded via the serviceloader camefrom a jar that is excluded by the fragment ordering. see servletspec 3.0 p.85.",
	"Method": "boolean isFromExcludedJar(WebAppContext context,ServletContainerInitializer sci,Resource sciResource){\r\n    if (sci == null)\r\n        throw new IllegalArgumentException(\"ServletContainerInitializer null\");\r\n    if (context == null)\r\n        throw new IllegalArgumentException(\"WebAppContext null\");\r\n    if (isFromContainerClassPath(context, sci)) {\r\n        if (LOG.isDebugEnabled())\r\n            LOG.debug(\"!Excluded {} from container classpath\", sci);\r\n        return false;\r\n    }\r\n    if (context.getMetaData().getOrdering() == null) {\r\n        if (LOG.isDebugEnabled())\r\n            LOG.debug(\"!Excluded {} no ordering\", sci);\r\n        return false;\r\n    }\r\n    List<Resource> orderedJars = context.getMetaData().getOrderedWebInfJars();\r\n    if (orderedJars.isEmpty()) {\r\n        if (LOG.isDebugEnabled())\r\n            LOG.debug(\"Excluded {} empty ordering\", sci);\r\n        return true;\r\n    }\r\n    if (sciResource == null) {\r\n        if (LOG.isDebugEnabled())\r\n            LOG.debug(\"!Excluded {} not from jar\", sci);\r\n        return false;\r\n    }\r\n    URI loadingJarURI = sciResource.getURI();\r\n    boolean found = false;\r\n    Iterator<Resource> itor = orderedJars.iterator();\r\n    while (!found && itor.hasNext()) {\r\n        Resource r = itor.next();\r\n        found = r.getURI().equals(loadingJarURI);\r\n    }\r\n    if (LOG.isDebugEnabled())\r\n        LOG.debug(\"{}Excluded {} found={}\", found ? \"!\" : \"\", sci, found);\r\n    return !found;\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlets.QoSFilter.setMaxRequests",
	"Comment": "set the maximum number of requests allowed to be processedat the same time.",
	"Method": "void setMaxRequests(int value){\r\n    _passes = new Semaphore((value - getMaxRequests() + _passes.availablePermits()), true);\r\n    _maxRequests = value;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllAncestors",
	"Comment": "the list of all the ancestors of the current declaration, direct and indirect.this list does not contains duplicates with the exacting same type parameters.",
	"Method": "List<ReferenceType> getAllAncestors(){\r\n    List<ReferenceType> ancestors = new ArrayList();\r\n    if (!(Object.class.getCanonicalName().equals(getQualifiedName()))) {\r\n        for (ReferenceType ancestor : getAncestors()) {\r\n            ancestors.add(ancestor);\r\n            for (ReferenceType inheritedAncestor : ancestor.getAllAncestors()) {\r\n                if (!ancestors.contains(inheritedAncestor)) {\r\n                    ancestors.add(inheritedAncestor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return ancestors;\r\n}"
}, {
	"Path": "org.javaee7.jaspic.basicauthentication.BasicAuthenticationStatelessTest.testProtectedAccessIsStateless2",
	"Comment": "tests that access to a protected page does not depend on the authenticated identity that was established in a previousrequest, but use a different request order than the previous test.",
	"Method": "void testProtectedAccessIsStateless2(){\r\n    String response = getFromServerPath(\"protected/servlet?doLogin=true\");\r\n    response = getFromServerPath(\"protected/servlet\");\r\n    assertFalse(\"Could access protected page, but should not be able to. \" + \"Did the container remember the authenticated identity that was set in the previous request?\", response.contains(\"This is a protected servlet\"));\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.ServletContextHandlerTest.testLegacyDecorator",
	"Comment": "test behavior of legacy servletcontexthandler.decorator, withnew decoratedobjectfactory class",
	"Method": "void testLegacyDecorator(){\r\n    ServletContextHandler context = new ServletContextHandler();\r\n    context.addDecorator(new DummyLegacyDecorator());\r\n    _server.setHandler(context);\r\n    context.addServlet(DecoratedObjectFactoryServlet.class, \"/objfactory/*\");\r\n    _server.start();\r\n    String response = _connector.getResponse(\"GET /objfactory/ HTTP/1.0\\r\\n\\r\\n\");\r\n    assertThat(\"Response status code\", response, containsString(\"200 OK\"));\r\n    String expected = String.format(\"Attribute[%s] = %s\", DecoratedObjectFactory.ATTR, DecoratedObjectFactory.class.getName());\r\n    assertThat(\"Has context attribute\", response, containsString(expected));\r\n    assertThat(\"Decorators size\", response, containsString(\"Decorators.size = [2]\"));\r\n    expected = String.format(\"decorator[] = %s\", DummyLegacyDecorator.class.getName());\r\n    assertThat(\"Specific Legacy Decorator\", response, containsString(expected));\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlets.DoSFilter.setTrackSessions",
	"Comment": "set flag to have usage rate tracked by session if a session exists.",
	"Method": "void setTrackSessions(boolean value){\r\n    _trackSessions = value;\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.DefaultServlet.getResource",
	"Comment": "get resource to serve.map a path to a resource. the default implementation callshttpcontext.getresource but derived servlets may providetheir own mapping.",
	"Method": "Resource getResource(String pathInContext){\r\n    Resource r = null;\r\n    if (_relativeResourceBase != null)\r\n        pathInContext = URIUtil.addPaths(_relativeResourceBase, pathInContext);\r\n    try {\r\n        if (_resourceBase != null) {\r\n            r = _resourceBase.addPath(pathInContext);\r\n            if (!_contextHandler.checkAlias(pathInContext, r))\r\n                r = null;\r\n        } else if (_servletContext instanceof ContextHandler.Context) {\r\n            r = _contextHandler.getResource(pathInContext);\r\n        } else {\r\n            URL u = _servletContext.getResource(pathInContext);\r\n            r = _contextHandler.newResource(u);\r\n        }\r\n        if (LOG.isDebugEnabled())\r\n            LOG.debug(\"Resource \" + pathInContext + \"=\" + r);\r\n    } catch (IOException e) {\r\n        LOG.ignore(e);\r\n    }\r\n    if ((r == null || !r.exists()) && pathInContext.endsWith(\"/jetty-dir.css\"))\r\n        r = _stylesheet;\r\n    return r;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.extensions.AbstractExtension.isRsv3User",
	"Comment": "used to indicate that the extension makes use of the rsv3 bit of the base websocket framing.this is used to adjust validation during parsing, as well as a checkpoint against 2 or more extensions all simultaneously claiming ownership of rsv3.",
	"Method": "boolean isRsv3User(){\r\n    return false;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.visitor.TreeVisitor.visitDirectChildren",
	"Comment": "performs a simple traversal over all nodes that have the passed node as their parent.",
	"Method": "void visitDirectChildren(Node node){\r\n    new ArrayList(node.getChildNodes()).forEach(this::process);\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getAllNonStaticFields",
	"Comment": "return a list of all the non static fields, either declared or inherited.",
	"Method": "List<FieldDeclaration> getAllNonStaticFields(){\r\n    return getAllFields().stream().filter(it -> !it.isStatic()).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.resource.Resource.newSystemResource",
	"Comment": "construct a system resource from a string.the resource is tried as classloader resource before beingtreated as a normal resource.",
	"Method": "Resource newSystemResource(String resource){\r\n    URL url = null;\r\n    ClassLoader loader = Thread.currentThread().getContextClassLoader();\r\n    if (loader != null) {\r\n        try {\r\n            url = loader.getResource(resource);\r\n            if (url == null && resource.startsWith(\"/\"))\r\n                url = loader.getResource(resource.substring(1));\r\n        } catch (IllegalArgumentException e) {\r\n            LOG.ignore(e);\r\n            url = null;\r\n        }\r\n    }\r\n    if (url == null) {\r\n        loader = Resource.class.getClassLoader();\r\n        if (loader != null) {\r\n            url = loader.getResource(resource);\r\n            if (url == null && resource.startsWith(\"/\"))\r\n                url = loader.getResource(resource.substring(1));\r\n        }\r\n    }\r\n    if (url == null) {\r\n        url = ClassLoader.getSystemResource(resource);\r\n        if (url == null && resource.startsWith(\"/\"))\r\n            url = ClassLoader.getSystemResource(resource.substring(1));\r\n    }\r\n    if (url == null)\r\n        return null;\r\n    return newResource(url);\r\n}"
}, {
	"Path": "org.javaee7.jaspictest.customprincipal.CustomPrincipalStatelessTest.testProtectedAccessIsStateless",
	"Comment": "tests that access to a protected page does not depend on the authenticated identity that was established in a previousrequest.",
	"Method": "void testProtectedAccessIsStateless(){\r\n    String response = getFromServerPath(\"protected/servlet\");\r\n    assertFalse(response.contains(\"This is a protected servlet\"));\r\n    response = getFromServerPath(\"protected/servlet?doLogin=true\");\r\n    assertTrue(\"Could not access protected page, but should be able to. \" + \"Did the container remember the previously set 'unauthenticated identity'?\", response.contains(\"This is a protected servlet\"));\r\n    response = getFromServerPath(\"protected/servlet\");\r\n    assertFalse(\"Could access protected page, but should not be able to. \" + \"Did the container remember the authenticated identity that was set in previous request?\", response.contains(\"This is a protected servlet\"));\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserFieldDeclaration.getWrappedNode",
	"Comment": "returns the javaparser node associated with this javaparserfielddeclaration.",
	"Method": "com.github.javaparser.ast.body.FieldDeclaration getWrappedNode(){\r\n    return wrappedNode;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.Scanner.setReportExistingFilesOnStartup",
	"Comment": "whether or not an initial scan will report all files as beingadded.",
	"Method": "void setReportExistingFilesOnStartup(boolean reportExisting){\r\n    _reportExisting = reportExisting;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.api.extensions.ExtensionConfig.init",
	"Comment": "initialize the parameters on this config from the other configuration.",
	"Method": "void init(ExtensionConfig other){\r\n    this.parameters.clear();\r\n    this.parameters.putAll(other.parameters);\r\n}"
}, {
	"Path": "com.github.javaparser.printer.lexicalpreservation.DifferenceElementCalculator.calculate",
	"Comment": "calculate the difference between two calculatedsyntaxmodel elements, determining which elements were kept,which were added and which were removed.",
	"Method": "List<DifferenceElement> calculate(LexicalDifferenceCalculator.CalculatedSyntaxModel original,LexicalDifferenceCalculator.CalculatedSyntaxModel after){\r\n    Map<Node, Integer> childrenInOriginal = findChildrenPositions(original);\r\n    Map<Node, Integer> childrenInAfter = findChildrenPositions(after);\r\n    List<Node> commonChildren = new LinkedList(childrenInOriginal.keySet());\r\n    commonChildren.retainAll(childrenInAfter.keySet());\r\n    commonChildren.sort(Comparator.comparingInt(childrenInOriginal::get));\r\n    List<DifferenceElement> elements = new LinkedList();\r\n    int originalIndex = 0;\r\n    int afterIndex = 0;\r\n    int commonChildrenIndex = 0;\r\n    while (commonChildrenIndex < commonChildren.size()) {\r\n        Node child = commonChildren.get(commonChildrenIndex++);\r\n        int posOfNextChildInOriginal = childrenInOriginal.get(child);\r\n        int posOfNextChildInAfter = childrenInAfter.get(child);\r\n        if (originalIndex < posOfNextChildInOriginal || afterIndex < posOfNextChildInAfter) {\r\n            elements.addAll(calculateImpl(original.sub(originalIndex, posOfNextChildInOriginal), after.sub(afterIndex, posOfNextChildInAfter)));\r\n        }\r\n        elements.add(new Kept(new LexicalDifferenceCalculator.CsmChild(child)));\r\n        originalIndex = posOfNextChildInOriginal + 1;\r\n        afterIndex = posOfNextChildInAfter + 1;\r\n    }\r\n    if (originalIndex < original.elements.size() || afterIndex < after.elements.size()) {\r\n        elements.addAll(calculateImpl(original.sub(originalIndex, original.elements.size()), after.sub(afterIndex, after.elements.size())));\r\n    }\r\n    return elements;\r\n}"
}, {
	"Path": "org.eclipse.jetty.annotations.AnnotationConfiguration.getMaxScanWait",
	"Comment": "work out how long we should wait for the async scanning to occur.",
	"Method": "int getMaxScanWait(WebAppContext context){\r\n    Object o = context.getAttribute(MAX_SCAN_WAIT);\r\n    if (o != null && o instanceof Number) {\r\n        return ((Number) o).intValue();\r\n    }\r\n    o = context.getServer().getAttribute(MAX_SCAN_WAIT);\r\n    if (o != null && o instanceof Number) {\r\n        return ((Number) o).intValue();\r\n    }\r\n    return Integer.getInteger(MAX_SCAN_WAIT, DEFAULT_MAX_SCAN_WAIT).intValue();\r\n}"
}, {
	"Path": "com.github.javaparser.ast.Node.getData",
	"Comment": "use this to retrieve additional information associated to this node.",
	"Method": "M getData(DataKey<M> key){\r\n    return data;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.BufferUtil.allocateDirect",
	"Comment": "allocate bytebuffer in flush mode.the position and limit will both be zero, indicating that the buffer isempty and in flush mode.",
	"Method": "ByteBuffer allocateDirect(int capacity){\r\n    ByteBuffer buf = ByteBuffer.allocateDirect(capacity);\r\n    buf.limit(0);\r\n    return buf;\r\n}"
}, {
	"Path": "org.eclipse.jetty.annotations.AnnotationConfiguration.matchesExclusionPattern",
	"Comment": "test if the servletcontainerintializer is excluded by the o.e.j.containerinitializerexclusionpattern",
	"Method": "boolean matchesExclusionPattern(ServletContainerInitializer sci){\r\n    if (_sciExcludePattern == null)\r\n        return false;\r\n    if (LOG.isDebugEnabled())\r\n        LOG.debug(\"Checking {} against containerInitializerExclusionPattern\", sci.getClass().getName());\r\n    return _sciExcludePattern.matcher(sci.getClass().getName()).matches();\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.ContextHandler.getLocaleEncoding",
	"Comment": "get the character encoding for a locale. the full locale name is first looked up in the map of encodings. if no encoding is found, then the localelanguage is looked up.",
	"Method": "String getLocaleEncoding(String locale,String getLocaleEncoding,Locale locale){\r\n    if (_localeEncodingMap == null)\r\n        return null;\r\n    String encoding = _localeEncodingMap.get(locale.toString());\r\n    if (encoding == null)\r\n        encoding = _localeEncodingMap.get(locale.getLanguage());\r\n    return encoding;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration.isClass",
	"Comment": "is this the declaration of a class?note that an enum is not considered a class in this case.",
	"Method": "boolean isClass(){\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jetty.webapp.WebAppContext.setTempDirectory",
	"Comment": "set temporary directory for context.the javax.servlet.context.tempdir attribute is also set.",
	"Method": "void setTempDirectory(File dir){\r\n    if (isStarted())\r\n        throw new IllegalStateException(\"Started\");\r\n    if (dir != null) {\r\n        try {\r\n            dir = new File(dir.getCanonicalPath());\r\n        } catch (IOException e) {\r\n            LOG.warn(Log.EXCEPTION, e);\r\n        }\r\n    }\r\n    _tmpDir = dir;\r\n    setAttribute(TEMPDIR, _tmpDir);\r\n}"
}, {
	"Path": "com.github.javaparser.printer.SourcePrinter.indent",
	"Comment": "add the default indentation to the current indentation and push it on the indentation stack.does not actually output anything.",
	"Method": "SourcePrinter indent(){\r\n    String currentIndent = indents.peek();\r\n    switch(indentType) {\r\n        case SPACES:\r\n        case TABS_WITH_SPACE_ALIGN:\r\n            indents.push(currentIndent + indentation);\r\n            break;\r\n        case TABS:\r\n            indents.push(indentation + currentIndent);\r\n            break;\r\n        default:\r\n            throw new AssertionError(\"Unhandled indent type\");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.github.javaparser.JavaParser.getStaticConfiguration",
	"Comment": "get the configuration for the static parse... methods.this is a static field, so modifying it will directly change how all static parse... methods work!",
	"Method": "ParserConfiguration getStaticConfiguration(){\r\n    return staticConfiguration;\r\n}"
}, {
	"Path": "org.javaee7.jaxws.endpoint.EBookStoreTest.createDeployment",
	"Comment": "arquillian specific method for creating a file which can be deployedwhile executing the test.",
	"Method": "WebArchive createDeployment(){\r\n    return ShrinkWrap.create(WebArchive.class).addPackage(\"org.javaee7.jaxws.endpoint\");\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration.getVisibleFields",
	"Comment": "return a list of all fields declared and the inherited ones which are not private.",
	"Method": "List<ResolvedFieldDeclaration> getVisibleFields(){\r\n    return getAllFields().stream().filter(f -> f.declaringType().equals(this) || f.accessSpecifier() != AccessSpecifier.PRIVATE).collect(Collectors.toList());\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration.hasName",
	"Comment": "necessary because parameters obtained through reflection could not have a name.",
	"Method": "boolean hasName(){\r\n    return true;\r\n}"
}, {
	"Path": "net.bull.javamelody.swing.util.ShadowPopupFactory.uninstall",
	"Comment": "uninstalls the shadowpopupfactory and restores the original\tpopup factory as the new shared popup factory.",
	"Method": "void uninstall(){\r\n    final PopupFactory factory = PopupFactory.getSharedInstance();\r\n    if (!(factory instanceof ShadowPopupFactory)) {\r\n        return;\r\n    }\r\n    final PopupFactory stored = ((ShadowPopupFactory) factory).storedFactory;\r\n    PopupFactory.setSharedInstance(stored);\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.security.UnixCrypt.des_cipher",
	"Comment": "returns the des encrypted code of the given word with the specifiedenvironment.",
	"Method": "long des_cipher(long in,int salt,int num_iter,long[] KS){\r\n    salt = to_six_bit(salt);\r\n    long L = in;\r\n    long R = L;\r\n    L &= 0x5555555555555555L;\r\n    R = (R & 0xaaaaaaaa00000000L) | ((R >> 1) & 0x0000000055555555L);\r\n    L = ((((L << 1) | (L << 32)) & 0xffffffff00000000L) | ((R | (R >> 32)) & 0x00000000ffffffffL));\r\n    L = perm3264((int) (L >> 32), IE3264);\r\n    R = perm3264((int) (L & 0xffffffff), IE3264);\r\n    while (--num_iter >= 0) {\r\n        for (int loop_count = 0; loop_count < 8; loop_count++) {\r\n            long kp;\r\n            long B;\r\n            long k;\r\n            kp = KS[(loop_count << 1)];\r\n            k = ((R >> 32) ^ R) & salt & 0xffffffffL;\r\n            k |= (k << 32);\r\n            B = (k ^ R ^ kp);\r\n            L ^= (SPE[0][(int) ((B >> 58) & 0x3f)] ^ SPE[1][(int) ((B >> 50) & 0x3f)] ^ SPE[2][(int) ((B >> 42) & 0x3f)] ^ SPE[3][(int) ((B >> 34) & 0x3f)] ^ SPE[4][(int) ((B >> 26) & 0x3f)] ^ SPE[5][(int) ((B >> 18) & 0x3f)] ^ SPE[6][(int) ((B >> 10) & 0x3f)] ^ SPE[7][(int) ((B >> 2) & 0x3f)]);\r\n            kp = KS[(loop_count << 1) + 1];\r\n            k = ((L >> 32) ^ L) & salt & 0xffffffffL;\r\n            k |= (k << 32);\r\n            B = (k ^ L ^ kp);\r\n            R ^= (SPE[0][(int) ((B >> 58) & 0x3f)] ^ SPE[1][(int) ((B >> 50) & 0x3f)] ^ SPE[2][(int) ((B >> 42) & 0x3f)] ^ SPE[3][(int) ((B >> 34) & 0x3f)] ^ SPE[4][(int) ((B >> 26) & 0x3f)] ^ SPE[5][(int) ((B >> 18) & 0x3f)] ^ SPE[6][(int) ((B >> 10) & 0x3f)] ^ SPE[7][(int) ((B >> 2) & 0x3f)]);\r\n        }\r\n        L ^= R;\r\n        R ^= L;\r\n        L ^= R;\r\n    }\r\n    L = ((((L >> 35) & 0x0f0f0f0fL) | (((L & 0xffffffff) << 1) & 0xf0f0f0f0L)) << 32 | (((R >> 35) & 0x0f0f0f0fL) | (((R & 0xffffffff) << 1) & 0xf0f0f0f0L)));\r\n    L = perm6464(L, CF6464);\r\n    return L;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.HttpConfiguration.setIdleTimeout",
	"Comment": "the max idle time is applied to a http request for io operations anddelayed dispatch.",
	"Method": "void setIdleTimeout(long timeoutMs){\r\n    _idleTimeout = timeoutMs;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.IPAccessHandler.set",
	"Comment": "helper method to process a list of new entries and replacethe content of the specified address pattern map",
	"Method": "void set(String[] entries,PathMap<IPAddressMap<Boolean>> patternMap){\r\n    patternMap.clear();\r\n    if (entries != null && entries.length > 0) {\r\n        for (String addrPath : entries) {\r\n            add(addrPath, patternMap);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.core.resolution.Context.fieldsExposedToChild",
	"Comment": "the fields that are declared and in this immediate context made visible to a given child.this list could include values which are shadowed.",
	"Method": "List<ResolvedFieldDeclaration> fieldsExposedToChild(Node child){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "org.eclipse.jetty.annotations.AnnotationParser.isValidClassFilePath",
	"Comment": "check that the given path does not contain hidden directories",
	"Method": "boolean isValidClassFilePath(String path){\r\n    if (path == null || path.length() == 0)\r\n        return false;\r\n    if (path.startsWith(\".\") || path.contains(\"/.\")) {\r\n        if (LOG.isDebugEnabled())\r\n            LOG.debug(\"Contains hidden dirs: \" + path);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.bull.javamelody.TestPayloadNameRequestWrapper.testSoap11MultipleRequestParameters",
	"Comment": "test parsing of soap 1.1 request with multiple request parameters.",
	"Method": "void testSoap11MultipleRequestParameters(){\r\n    contentType = CONTENT_TYPE_TEXT_XML;\r\n    headers.put(\"SOAPAction\", \"Some-URI\");\r\n    body = \"<SOAP-ENV:Envelope                                                        \\n\" + \"  xmlns:SOAP-ENV=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"         \\n\" + \"  SOAP-ENV:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\n\" + \"   <SOAP-ENV:Body>                                                     \\n\" + \"       <m:GetLastTradePriceDetailed xmlns:m=\\\"Some-URI\\\">              \\n\" + \"           <Symbol>DEF<\/Symbol>                                        \\n\" + \"           <Company>DEF Corp<\/Company>                                 \\n\" + \"           <Price>34.1<\/Price>                                         \\n\" + \"       <\/m:GetLastTradePriceDetailed>                                  \\n\" + \"   <\/SOAP-ENV:Body>                                                    \\n\" + \"<\/SOAP-ENV:Envelope>                                                    \";\r\n    final PayloadNameRequestWrapper wrapper = new PayloadNameRequestWrapper(request);\r\n    wrapper.initialize();\r\n    assertEquals(\"Could not parse SOAP 1.1 request with mutliple request parameters\", \".GetLastTradePriceDetailed\", wrapper.getPayloadRequestName());\r\n    assertEquals(\"SOAP request type unrecognized\", \"SOAP\", wrapper.getPayloadRequestType());\r\n    assertEquals(\"Content was changed\", body, slurp(wrapper.getInputStream()));\r\n}"
}, {
	"Path": "org.javaee7.jms.send.receive.simple.appmanaged.MessageReceiverAppManaged.receiveMessage",
	"Comment": "waits to receive a message from the jms queue. times out after a givennumber of milliseconds.",
	"Method": "String receiveMessage(int timeoutInMillis){\r\n    try (JMSContext context = factory.createContext()) {\r\n        String message = context.createConsumer(myQueue).receiveBody(String.class, timeoutInMillis);\r\n        if (message == null) {\r\n            throw new TimeoutException(\"No message received after \" + timeoutInMillis + \"ms\");\r\n        }\r\n        return message;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.plus.jndi.TestNamingEntries.after",
	"Comment": "after each test we should scrape out any lingering bindings to prevent cross test pollutionas observed when running java 7",
	"Method": "void after(){\r\n    InitialContext icontext = new InitialContext();\r\n    NamingEnumeration<Binding> bindings = icontext.listBindings(\"\");\r\n    List<String> names = new ArrayList<String>();\r\n    while (bindings.hasMore()) {\r\n        Binding bd = (Binding) bindings.next();\r\n        names.add(bd.getName());\r\n    }\r\n    for (String name : names) {\r\n        icontext.unbind(name);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.io.AbstractWebSocketConnection.onUpgradeTo",
	"Comment": "extra bytes from the initial http upgrade that need tobe processed by the websocket parser before startingto read bytes from the connection",
	"Method": "void onUpgradeTo(ByteBuffer prefilled){\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"onUpgradeTo({})\", BufferUtil.toDetailString(prefilled));\r\n    }\r\n    setInitialBuffer(prefilled);\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.MultiException.ifExceptionThrowSuppressed",
	"Comment": "throw an exception, potentially with suppress.if this multi exception is empty then no action is taken. if the firstexception added is an error or exception, then it is throw with any additional exceptions added as suppressed. otherwise a multiexceptionis thrown, with all exceptions added as suppressed.",
	"Method": "void ifExceptionThrowSuppressed(){\r\n    if (nested == null || nested.size() == 0)\r\n        return;\r\n    Throwable th = nested.get(0);\r\n    if (!Error.class.isInstance(th) && !Exception.class.isInstance(th))\r\n        th = new MultiException(Collections.emptyList());\r\n    for (Throwable s : nested) {\r\n        if (s != th)\r\n            th.addSuppressed(s);\r\n    }\r\n    if (Error.class.isInstance(th))\r\n        throw (Error) th;\r\n    throw (Exception) th;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.AbstractNCSARequestLog.getLogDateFormat",
	"Comment": "retrieve the timestamp format string for request log entries.",
	"Method": "String getLogDateFormat(){\r\n    return _logDateFormat;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.resolution.naming.NameLogic.isAName",
	"Comment": "does the node represent a name?note that while most specific ast classes either always represent names or never represent namesthere are exceptions as the fieldaccessexpr",
	"Method": "boolean isAName(Node node){\r\n    if (node instanceof FieldAccessExpr) {\r\n        FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\r\n        return isAName(fieldAccessExpr.getScope());\r\n    } else {\r\n        return node instanceof SimpleName || node instanceof Name || node instanceof ClassOrInterfaceType || node instanceof NameExpr;\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.asInterface",
	"Comment": "return this as a interfacedeclaration or throw unsupportedoperationexception.",
	"Method": "InterfaceDeclaration asInterface(){\r\n    throw new UnsupportedOperationException(String.format(\"%s is not an interface\", this));\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.HostMap.getLazyMatches",
	"Comment": "retrieve a lazy list of map entries associated with specifiedhostname by taking into account the domain suffix matches.",
	"Method": "Object getLazyMatches(String host){\r\n    if (host == null)\r\n        return LazyList.getList(super.entrySet());\r\n    int idx = 0;\r\n    String domain = host.trim();\r\n    HashSet<String> domains = new HashSet<String>();\r\n    do {\r\n        domains.add(domain);\r\n        if ((idx = domain.indexOf('.')) > 0) {\r\n            domain = domain.substring(idx + 1);\r\n        }\r\n    } while (idx > 0);\r\n    Object entries = null;\r\n    for (Map.Entry<String, TYPE> entry : super.entrySet()) {\r\n        if (domains.contains(entry.getKey())) {\r\n            entries = LazyList.add(entries, entry);\r\n        }\r\n    }\r\n    return entries;\r\n}"
}, {
	"Path": "com.github.javaparser.ASTParser.Modifiers",
	"Comment": "modifiers. we match all modifiers in a single rule to reduce the chances ofsyntax errors for simple modifier mistakes. it will also enable us to givebetter error messages.",
	"Method": "ModifierHolder Modifiers(){\r\n    int beginLine = -1;\r\n    int beginColumn = -1;\r\n    int modifiers = 0;\r\n    List annotations = null;\r\n    AnnotationExpr ann;\r\n    label_4: while (true) {\r\n        if (jj_2_2(2)) {\r\n            ;\r\n        } else {\r\n            break label_4;\r\n        }\r\n        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\r\n            case PUBLIC:\r\n                jj_consume_token(PUBLIC);\r\n                modifiers = addModifier(modifiers, ModifierSet.PUBLIC, token);\r\n                if (beginLine == -1) {\r\n                    beginLine = token.beginLine;\r\n                    beginColumn = token.beginColumn;\r\n                }\r\n                break;\r\n            case STATIC:\r\n                jj_consume_token(STATIC);\r\n                modifiers = addModifier(modifiers, ModifierSet.STATIC, token);\r\n                if (beginLine == -1) {\r\n                    beginLine = token.beginLine;\r\n                    beginColumn = token.beginColumn;\r\n                }\r\n                break;\r\n            case PROTECTED:\r\n                jj_consume_token(PROTECTED);\r\n                modifiers = addModifier(modifiers, ModifierSet.PROTECTED, token);\r\n                if (beginLine == -1) {\r\n                    beginLine = token.beginLine;\r\n                    beginColumn = token.beginColumn;\r\n                }\r\n                break;\r\n            case PRIVATE:\r\n                jj_consume_token(PRIVATE);\r\n                modifiers = addModifier(modifiers, ModifierSet.PRIVATE, token);\r\n                if (beginLine == -1) {\r\n                    beginLine = token.beginLine;\r\n                    beginColumn = token.beginColumn;\r\n                }\r\n                break;\r\n            case FINAL:\r\n                jj_consume_token(FINAL);\r\n                modifiers = addModifier(modifiers, ModifierSet.FINAL, token);\r\n                if (beginLine == -1) {\r\n                    beginLine = token.beginLine;\r\n                    beginColumn = token.beginColumn;\r\n                }\r\n                break;\r\n            case ABSTRACT:\r\n                jj_consume_token(ABSTRACT);\r\n                modifiers = addModifier(modifiers, ModifierSet.ABSTRACT, token);\r\n                if (beginLine == -1) {\r\n                    beginLine = token.beginLine;\r\n                    beginColumn = token.beginColumn;\r\n                }\r\n                break;\r\n            case SYNCHRONIZED:\r\n                jj_consume_token(SYNCHRONIZED);\r\n                modifiers = addModifier(modifiers, ModifierSet.SYNCHRONIZED, token);\r\n                if (beginLine == -1) {\r\n                    beginLine = token.beginLine;\r\n                    beginColumn = token.beginColumn;\r\n                }\r\n                break;\r\n            case NATIVE:\r\n                jj_consume_token(NATIVE);\r\n                modifiers = addModifier(modifiers, ModifierSet.NATIVE, token);\r\n                if (beginLine == -1) {\r\n                    beginLine = token.beginLine;\r\n                    beginColumn = token.beginColumn;\r\n                }\r\n                break;\r\n            case TRANSIENT:\r\n                jj_consume_token(TRANSIENT);\r\n                modifiers = addModifier(modifiers, ModifierSet.TRANSIENT, token);\r\n                if (beginLine == -1) {\r\n                    beginLine = token.beginLine;\r\n                    beginColumn = token.beginColumn;\r\n                }\r\n                break;\r\n            case VOLATILE:\r\n                jj_consume_token(VOLATILE);\r\n                modifiers = addModifier(modifiers, ModifierSet.VOLATILE, token);\r\n                if (beginLine == -1) {\r\n                    beginLine = token.beginLine;\r\n                    beginColumn = token.beginColumn;\r\n                }\r\n                break;\r\n            case STRICTFP:\r\n                jj_consume_token(STRICTFP);\r\n                modifiers = addModifier(modifiers, ModifierSet.STRICTFP, token);\r\n                if (beginLine == -1) {\r\n                    beginLine = token.beginLine;\r\n                    beginColumn = token.beginColumn;\r\n                }\r\n                break;\r\n            case AT:\r\n                ann = Annotation();\r\n                annotations = add(annotations, ann);\r\n                if (beginLine == -1) {\r\n                    beginLine = ann.getBeginLine();\r\n                    beginColumn = ann.getBeginColumn();\r\n                }\r\n                break;\r\n            default:\r\n                jj_la1[6] = jj_gen;\r\n                jj_consume_token(-1);\r\n                throw new ParseException();\r\n        }\r\n    }\r\n    {\r\n        if (true)\r\n            return new Modifier(beginLine, beginColumn, modifiers, annotations);\r\n    }\r\n    throw new Error(\"Missing return statement in function\");\r\n}"
}, {
	"Path": "org.eclipse.jetty.maven.plugin.AbstractJettyMojo.configureWebApplication",
	"Comment": "subclasses should invoke this to setup basic infoon the webapp",
	"Method": "void configureWebApplication(){\r\n    if (webApp == null)\r\n        webApp = new JettyWebAppContext();\r\n    if (contextXml != null) {\r\n        Path path = Paths.get(contextXml);\r\n        if (!path.isAbsolute()) {\r\n            Path workDir = Paths.get(System.getProperty(\"user.dir\"));\r\n            path = workDir.resolve(path);\r\n            contextXml = path.toFile().getAbsolutePath();\r\n        }\r\n        XmlConfiguration xmlConfiguration = new XmlConfiguration(Resource.toURL(path.toFile()));\r\n        getLog().info(\"Applying context xml file \" + contextXml);\r\n        xmlConfiguration.configure(webApp);\r\n    }\r\n    String cp = webApp.getContextPath();\r\n    if (cp == null || \"\".equals(cp)) {\r\n        cp = \"/\" + project.getArtifactId();\r\n        webApp.setContextPath(cp);\r\n    }\r\n    if (webApp.getTempDirectory() == null) {\r\n        File target = new File(project.getBuild().getDirectory());\r\n        File tmp = new File(target, \"tmp\");\r\n        if (!tmp.exists())\r\n            tmp.mkdirs();\r\n        webApp.setTempDirectory(tmp);\r\n    }\r\n    getLog().info(\"Context path = \" + webApp.getContextPath());\r\n    getLog().info(\"Tmp directory = \" + (webApp.getTempDirectory() == null ? \" determined at runtime\" : webApp.getTempDirectory()));\r\n    getLog().info(\"Web defaults = \" + (webApp.getDefaultsDescriptor() == null ? \" jetty default\" : webApp.getDefaultsDescriptor()));\r\n    getLog().info(\"Web overrides = \" + (webApp.getOverrideDescriptor() == null ? \" none\" : webApp.getOverrideDescriptor()));\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.SessionHandler.invalidate",
	"Comment": "called by sessionidmanager to remove a session that has been invalidated,either by this context or another context. also called bysessionidmanager when a session has expired in either this context oranother context.",
	"Method": "void invalidate(String id){\r\n    if (StringUtil.isBlank(id))\r\n        return;\r\n    try {\r\n        Session session = _sessionCache.delete(id);\r\n        if (session != null) {\r\n            try {\r\n                if (session.beginInvalidate()) {\r\n                    try {\r\n                        callSessionDestroyedListeners(session);\r\n                    } catch (Exception e) {\r\n                        LOG.warn(\"Session listener threw exception\", e);\r\n                    }\r\n                    session.finishInvalidate();\r\n                }\r\n            } catch (IllegalStateException e) {\r\n                if (LOG.isDebugEnabled())\r\n                    LOG.debug(\"Session {} already invalid\", session);\r\n                LOG.ignore(e);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        LOG.warn(e);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.maven.plugin.JettyRunDistro.configureCommand",
	"Comment": "make the command to spawn a process torun jetty from a distro.",
	"Method": "ProcessBuilder configureCommand(){\r\n    List<String> cmd = new ArrayList();\r\n    if (StringUtil.isNotBlank(javaPath)) {\r\n        cmd.add(javaPath);\r\n    } else {\r\n        cmd.add(getJavaBin());\r\n    }\r\n    cmd.add(\"-jar\");\r\n    cmd.add(new File(jettyHome, \"start.jar\").getAbsolutePath());\r\n    cmd.add(\"-DSTOP.PORT=\" + stopPort);\r\n    if (stopKey != null)\r\n        cmd.add(\"-DSTOP.KEY=\" + stopKey);\r\n    if (jvmArgs != null) {\r\n        String[] args = jvmArgs.split(\" \");\r\n        for (String a : args) {\r\n            if (!StringUtil.isBlank(a))\r\n                cmd.add(a.trim());\r\n        }\r\n    }\r\n    StringBuilder tmp = new StringBuilder();\r\n    tmp.append(\"--module=\");\r\n    tmp.append(\"server,http,webapp,deploy\");\r\n    if (modules != null) {\r\n        for (String m : modules) {\r\n            if (tmp.indexOf(m) < 0)\r\n                tmp.append(\",\" + m);\r\n        }\r\n    }\r\n    if (libExtJars != null && !libExtJars.isEmpty() && tmp.indexOf(\"ext\") < 0)\r\n        tmp.append(\",ext\");\r\n    tmp.append(\",maven\");\r\n    cmd.add(tmp.toString());\r\n    if (jettyProperties != null) {\r\n        for (String p : jettyProperties) cmd.add(p);\r\n    }\r\n    tokenFile = target.toPath().resolve(createToken() + \".txt\");\r\n    cmd.add(\"jetty.token.file=\" + tokenFile.toAbsolutePath().toString());\r\n    ProcessBuilder builder = new ProcessBuilder(cmd);\r\n    builder.directory(targetBase);\r\n    if (!env.isEmpty())\r\n        builder.environment().putAll(env);\r\n    return builder;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.SearchPattern.validate",
	"Comment": "performs legality checks for standard arguments input into searchpattern methods.",
	"Method": "void validate(byte[] data,int offset,int length){\r\n    if (offset < 0)\r\n        throw new IllegalArgumentException(\"offset was negative\");\r\n    else if (length < 0)\r\n        throw new IllegalArgumentException(\"length was negative\");\r\n    else if (offset + length > data.length)\r\n        throw new IllegalArgumentException(\"(offset+length) out of bounds of data[]\");\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration.solveType",
	"Comment": "resolution should move out of declarations, so that they are pure declarations and the resolution shouldwork for javaparser, reflection and javassist classes in the same way and not be specific to the threeimplementations.",
	"Method": "SymbolReference<ResolvedTypeDeclaration> solveType(String name){\r\n    if (this.wrappedNode.getName().getId().equals(name)) {\r\n        return SymbolReference.solved(this);\r\n    }\r\n    SymbolReference<TypeDeclaration> ref = javaParserTypeAdapter.solveType(name, typeSolver);\r\n    if (ref.isSolved()) {\r\n        return ref;\r\n    }\r\n    String prefix = wrappedNode.getName() + \".\";\r\n    if (name.startsWith(prefix) && name.length() > prefix.length()) {\r\n        return new JavaParserClassDeclaration(this.wrappedNode, typeSolver).solveType(name.substring(prefix.length()), typeSolver);\r\n    }\r\n    return getContext().getParent().solveType(name, typeSolver);\r\n}"
}, {
	"Path": "io.github.javiewer.view.SimpleSearchView.setOnSearchViewListener",
	"Comment": "set this listener to listen to search view open and close events",
	"Method": "void setOnSearchViewListener(SearchViewListener listener){\r\n    mSearchViewListener = listener;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedMethodLikeDeclaration.getQualifiedSignature",
	"Comment": "the qualified signature of the method. it is composed by the qualified name of the declaring typefollowed by the signature of the method.",
	"Method": "String getQualifiedSignature(){\r\n    return declaringType().getId() + \".\" + this.getSignature();\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.security.UnixCrypt.init_perm",
	"Comment": "initializes the given permutation table with the mapping table.",
	"Method": "void init_perm(long[][] perm,byte[] p,int chars_out){\r\n    for (int k = 0; k < chars_out * 8; k++) {\r\n        int l = p[k] - 1;\r\n        if (l < 0)\r\n            continue;\r\n        int i = l >> 2;\r\n        l = 1 << (l & 0x03);\r\n        for (int j = 0; j < 16; j++) {\r\n            int s = ((k & 0x07) + ((7 - (k >> 3)) << 3));\r\n            if ((j & l) != 0x00)\r\n                perm[i][j] |= (1L << s);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.ast.validator.Java10ValidatorTest.selfReferenceNotAllowed",
	"Comment": "this is pretty hard to impossible to implement correctly with just the ast.",
	"Method": "void selfReferenceNotAllowed(){\r\n    ParseResult<Statement> result = javaParser.parse(STATEMENT, provider(\"var a=a;\"));\r\n    assertProblems(result, \"\");\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.ServletHolder.setUserRoleLink",
	"Comment": "link a user role.translate the role name used by a servlet, to the link nameused by the container.",
	"Method": "void setUserRoleLink(String name,String link){\r\n    if (_roleMap == null)\r\n        _roleMap = new HashMap<String, String>();\r\n    _roleMap.put(name, link);\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.Declaration.asType",
	"Comment": "return this as a typedeclaration or throw an unsupportedoperationexception",
	"Method": "TypeDeclaration asType(){\r\n    throw new UnsupportedOperationException(String.format(\"%s is not a TypeDeclaration\", this));\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getLastParam",
	"Comment": "utility method to get the last parameterdeclaration. it throws unsupportedoperationexception if the methodhas no parameters.the last parameter can be variadic and sometimes it needs to be handled in a special way.",
	"Method": "ParameterDeclaration getLastParam(){\r\n    if (getNumberOfParams() == 0) {\r\n        throw new UnsupportedOperationException(\"This method has no typeParametersValues, therefore it has no a last parameter\");\r\n    }\r\n    return getParam(getNumberOfParams() - 1);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.HttpConfiguration.setSecureScheme",
	"Comment": "set theuri scheme used for confidential and integral redirections.",
	"Method": "void setSecureScheme(String secureScheme){\r\n    _secureScheme = secureScheme;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.log.AbstractLogger.lookupLoggingLevel",
	"Comment": "get the logging level for the provided log name. using the fqcn first, then each package segment from longest toshortest.",
	"Method": "int lookupLoggingLevel(Properties props,String name){\r\n    if ((props == null) || (props.isEmpty()) || name == null)\r\n        return LEVEL_DEFAULT;\r\n    String nameSegment = name;\r\n    while ((nameSegment != null) && (nameSegment.length() > 0)) {\r\n        String levelStr = props.getProperty(nameSegment + \".LEVEL\");\r\n        int level = getLevelId(nameSegment + \".LEVEL\", levelStr);\r\n        if (level != (-1)) {\r\n            return level;\r\n        }\r\n        int idx = nameSegment.lastIndexOf('.');\r\n        if (idx >= 0) {\r\n            nameSegment = nameSegment.substring(0, idx);\r\n        } else {\r\n            nameSegment = null;\r\n        }\r\n    }\r\n    return LEVEL_DEFAULT;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.nodeTypes.NodeWithJavadoc.getJavadoc",
	"Comment": "gets the javadoc for this node. you can set the javadoc by calling setjavadoccomment passing a javadoc.",
	"Method": "Optional<Javadoc> getJavadoc(){\r\n    return getJavadocComment().map(JavadocComment::parse);\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.methods.MethodUsage.getParamType",
	"Comment": "return the type of the formal argument at the given position.",
	"Method": "Type getParamType(int i){\r\n    return paramTypes.get(i);\r\n}"
}, {
	"Path": "org.eclipse.jetty.ant.AntWebInfConfiguration.configure",
	"Comment": "adds classpath files into web application classloader, andsets web.xml and base directory for the configured web application.",
	"Method": "void configure(WebAppContext context){\r\n    if (context instanceof AntWebAppContext) {\r\n        List<File> classPathFiles = ((AntWebAppContext) context).getClassPathFiles();\r\n        if (classPathFiles != null) {\r\n            for (File cpFile : classPathFiles) {\r\n                if (cpFile.exists()) {\r\n                    ((WebAppClassLoader) context.getClassLoader()).addClassPath(cpFile.getCanonicalPath());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    super.configure(context);\r\n}"
}, {
	"Path": "org.eclipse.jetty.maven.plugin.JettyWebAppContext.setOverlays",
	"Comment": "ordered list of wars to overlay on top of the current project. the listmay contain an overlay that represents the current project.",
	"Method": "void setOverlays(List<Overlay> overlays){\r\n    _overlays = overlays;\r\n}"
}, {
	"Path": "com.github.javaparser.javadoc.Javadoc.toText",
	"Comment": "return the text content of the document. it does not containing trailing spaces and asterisksat the start of the line.",
	"Method": "String toText(){\r\n    StringBuilder sb = new StringBuilder();\r\n    if (!description.isEmpty()) {\r\n        sb.append(description.toText());\r\n        sb.append(EOL);\r\n    }\r\n    if (!blockTags.isEmpty()) {\r\n        sb.append(EOL);\r\n    }\r\n    blockTags.forEach(bt -> {\r\n        sb.append(bt.toText());\r\n        sb.append(EOL);\r\n    });\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.asTypeParameter",
	"Comment": "return this as a typeparameterdeclaration or throw unsupportedoperationexception.",
	"Method": "TypeParameterDeclaration asTypeParameter(){\r\n    throw new UnsupportedOperationException(String.format(\"%s is not a type parameter\", this));\r\n}"
}, {
	"Path": "org.eclipse.jetty.client.HttpClient.newRequest",
	"Comment": "creates a new request with the specified absolute uri in string format.",
	"Method": "Request newRequest(String host,int port,Request newRequest,String uri,Request newRequest,URI uri){\r\n    return newHttpRequest(newConversation(), uri);\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.types.ResolvedReferenceType.getGenericParameterByName",
	"Comment": "get the type associated with the type parameter with the given name.it returns optional.empty unless the type declaration declares a type parameter with the given name.",
	"Method": "Optional<ResolvedType> getGenericParameterByName(String name){\r\n    for (ResolvedTypeParameterDeclaration tp : typeDeclaration.getTypeParameters()) {\r\n        if (tp.getName().equals(name)) {\r\n            return Optional.of(this.typeParametersMap().getValue(tp));\r\n        }\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.MultiException.ifExceptionThrow",
	"Comment": "throw a multiexception.if this multi exception is empty then no action is taken. if itcontains a single exception that is thrown, otherwise the thismulti exception is thrown.",
	"Method": "void ifExceptionThrow(){\r\n    if (nested == null)\r\n        return;\r\n    switch(nested.size()) {\r\n        case 0:\r\n            break;\r\n        case 1:\r\n            Throwable th = nested.get(0);\r\n            if (th instanceof Error)\r\n                throw (Error) th;\r\n            if (th instanceof Exception)\r\n                throw (Exception) th;\r\n        default:\r\n            throw new MultiException(nested);\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.JavaToken.invalid",
	"Comment": "used by the parser while constructing nodes. no tokens should be invalid when the parser is done.",
	"Method": "boolean invalid(){\r\n    return this == INVALID;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver.parseDirectory",
	"Comment": "note that this parse only files directly contained in this directory.it does not traverse recursively all children directory.",
	"Method": "List<CompilationUnit> parseDirectory(Path srcDirectory,List<CompilationUnit> parseDirectory,Path srcDirectory,boolean recursively){\r\n    if (!parsedDirectories.containsKey(srcDirectory.getAbsolutePath())) {\r\n        List<CompilationUnit> units = new ArrayList();\r\n        File[] files = srcDirectory.listFiles();\r\n        if (files == null)\r\n            throw new FileNotFoundException(srcDirectory.getAbsolutePath());\r\n        for (File file : files) {\r\n            if (file.getName().toLowerCase().endsWith(\".java\")) {\r\n                units.add(parse(file));\r\n            }\r\n        }\r\n        parsedDirectories.put(srcDirectory.getAbsolutePath(), units);\r\n    }\r\n    return parsedDirectories.get(srcDirectory.getAbsolutePath());\r\n}"
}, {
	"Path": "org.eclipse.jetty.deploy.providers.ScanningAppProviderRuntimeUpdatesTest.testAfterStartupThenRemoveContext",
	"Comment": "simple webapp deployment after startup of server, and then removal of the webapp.",
	"Method": "void testAfterStartupThenRemoveContext(){\r\n    jetty.copyWebapp(\"foo-webapp-1.war\", \"foo.war\");\r\n    jetty.copyWebapp(\"foo.xml\", \"foo.xml\");\r\n    waitForDirectoryScan();\r\n    waitForDirectoryScan();\r\n    jetty.assertWebAppContextsExists(\"/foo\");\r\n    jetty.removeWebapp(\"foo.war\");\r\n    jetty.removeWebapp(\"foo.xml\");\r\n    waitForDirectoryScan();\r\n    waitForDirectoryScan();\r\n    jetty.assertNoWebAppContexts();\r\n}"
}, {
	"Path": "com.github.javaparser.ast.CompilationUnit.getImports",
	"Comment": "retrieves the list of imports declared in this compilation unit ornull if there is no import.",
	"Method": "NodeList<ImportDeclaration> getImports(){\r\n    return imports;\r\n}"
}, {
	"Path": "com.github.javaparser.metamodel.BaseNodeMetaModel.getMetaModelFieldName",
	"Comment": "the name of the field in javaparsermetamodel for this node meta model.",
	"Method": "String getMetaModelFieldName(){\r\n    return decapitalize(getClass().getSimpleName());\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.Scanner.reportAddition",
	"Comment": "report a file addition to the registered fileaddedlisteners",
	"Method": "void reportAddition(String filename){\r\n    Iterator<Listener> itor = _listeners.iterator();\r\n    while (itor.hasNext()) {\r\n        Listener l = itor.next();\r\n        try {\r\n            if (l instanceof DiscreteListener)\r\n                ((DiscreteListener) l).fileAdded(filename);\r\n        } catch (Exception e) {\r\n            warn(l, filename, e);\r\n        } catch (Error e) {\r\n            warn(l, filename, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.GracefulStopTest.testGracefulTimeout",
	"Comment": "test of standard graceful timeout mechanism when a block request doesnot complete",
	"Method": "void testGracefulTimeout(){\r\n    Server server = new Server();\r\n    server.setStopTimeout(1000);\r\n    ServerConnector connector = new ServerConnector(server);\r\n    connector.setPort(0);\r\n    server.addConnector(connector);\r\n    TestHandler handler = new TestHandler();\r\n    StatisticsHandler stats = new StatisticsHandler();\r\n    server.setHandler(stats);\r\n    stats.setHandler(handler);\r\n    server.start();\r\n    final int port = connector.getLocalPort();\r\n    Socket client = new Socket(\"127.0.0.1\", port);\r\n    client.getOutputStream().write((\"POST / HTTP/1.0\\r\\n\" + \"Host: localhost:\" + port + \"\\r\\n\" + \"Content-Type: plain/text\\r\\n\" + \"Content-Length: 10\\r\\n\" + \"\\r\\n\" + \"12345\").getBytes());\r\n    client.getOutputStream().flush();\r\n    handler.latch.await();\r\n    long start = System.nanoTime();\r\n    assertThrows(TimeoutException.class, () -> server.stop());\r\n    long stop = System.nanoTime();\r\n    assertThat(TimeUnit.NANOSECONDS.toMillis(stop - start), greaterThan(900L));\r\n    assertThat(client.getInputStream().read(), is(-1));\r\n    assertThat(handler.handling.get(), is(false));\r\n    assertThat(handler.thrown.get(), instanceOf(ClosedChannelException.class));\r\n    client.close();\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.WebSocketRemoteEndpoint.getInetSocketAddress",
	"Comment": "get the inetsocketaddress for the established connection.",
	"Method": "InetSocketAddress getInetSocketAddress(){\r\n    if (connection == null)\r\n        return null;\r\n    return connection.getRemoteAddress();\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.log.Log.getLogger",
	"Comment": "obtain a named logger or the default logger if null is passed.",
	"Method": "Logger getLogger(Class<?> clazz,Logger getLogger,String name){\r\n    initialized();\r\n    if (name == null)\r\n        return LOG;\r\n    Logger logger = __loggers.get(name);\r\n    if (logger == null)\r\n        logger = LOG.getLogger(name);\r\n    return logger;\r\n}"
}, {
	"Path": "org.eclipse.jetty.apache.jsp.JettyJasperInitializer.newTldScanner",
	"Comment": "make a tldscanner, and prefeed it the tlds that have already been discovered in jar filesby the metainfconfiguration.",
	"Method": "TldScanner newTldScanner(ServletContext context,boolean namespaceAware,boolean validate,boolean blockExternal){\r\n    String tmp = context.getInitParameter(\"org.eclipse.jetty.jsp.precompiled\");\r\n    if (tmp != null && !tmp.equals(\"\") && Boolean.valueOf(tmp)) {\r\n        if (LOG.isDebugEnabled())\r\n            LOG.debug(\"Jsp precompilation detected\");\r\n        return new NullTldScanner(context, namespaceAware, validate, blockExternal);\r\n    }\r\n    Collection<URL> tldUrls = (Collection<URL>) context.getAttribute(\"org.eclipse.jetty.tlds\");\r\n    if (tldUrls != null) {\r\n        if (LOG.isDebugEnabled())\r\n            LOG.debug(\"Tld pre-scan detected\");\r\n        return new JettyTldPreScanned(context, namespaceAware, validate, blockExternal, tldUrls);\r\n    }\r\n    if (LOG.isDebugEnabled())\r\n        LOG.debug(\"Defaulting to jasper tld scanning\");\r\n    return super.newTldScanner(context, namespaceAware, validate, blockExternal);\r\n}"
}, {
	"Path": "org.eclipse.jetty.rewrite.handler.ResponsePatternRule.setReason",
	"Comment": "sets the reason for the response status code. reasons will only reflectif the code value is greater or equal to 400.",
	"Method": "void setReason(String reason){\r\n    _reason = reason;\r\n}"
}, {
	"Path": "org.eclipse.jetty.annotations.AnnotationParser.getParsedLocations",
	"Comment": "get the locations of the given classname. there may be more than onelocation if there are duplicates of the same class.",
	"Method": "List<String> getParsedLocations(String classname){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.DefaultSessionIdManager.renewSessionId",
	"Comment": "generate a new id for a session and update acrossall sessionmanagers.",
	"Method": "String renewSessionId(String oldClusterId,String oldNodeId,HttpServletRequest request){\r\n    String newClusterId = newSessionId(request.hashCode());\r\n    for (SessionHandler manager : getSessionHandlers()) {\r\n        manager.renewSessionId(oldClusterId, oldNodeId, newClusterId, getExtendedId(newClusterId, request));\r\n    }\r\n    return newClusterId;\r\n}"
}, {
	"Path": "org.eclipse.jetty.ant.types.FileMatchingConfiguration.isIncluded",
	"Comment": "checks if passed file is scanned by any of the directory scanners.",
	"Method": "boolean isIncluded(String pathToFile){\r\n    Iterator scanners = directoryScanners.iterator();\r\n    while (scanners.hasNext()) {\r\n        DirectoryScanner scanner = (DirectoryScanner) scanners.next();\r\n        scanner.scan();\r\n        String[] includedFiles = scanner.getIncludedFiles();\r\n        for (int i = 0; i < includedFiles.length; i++) {\r\n            File includedFile = new File(scanner.getBasedir(), includedFiles[i]);\r\n            if (pathToFile.equalsIgnoreCase(includedFile.getAbsolutePath())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jetty.webapp.WebAppClassLoader.addJars",
	"Comment": "add elements to the class path for the context from the jar and zip files found in the specified resource.",
	"Method": "void addJars(Resource lib){\r\n    if (lib.exists() && lib.isDirectory()) {\r\n        String[] files = lib.list();\r\n        if (files != null) {\r\n            Arrays.sort(files);\r\n        }\r\n        for (int f = 0; files != null && f < files.length; f++) {\r\n            try {\r\n                Resource fn = lib.addPath(files[f]);\r\n                if (LOG.isDebugEnabled())\r\n                    LOG.debug(\"addJar - {}\", fn);\r\n                String fnlc = fn.getName().toLowerCase(Locale.ENGLISH);\r\n                if (isFileSupported(fnlc)) {\r\n                    String jar = fn.toString();\r\n                    jar = StringUtil.replace(jar, \",\", \",\");\r\n                    jar = StringUtil.replace(jar, \";\", \";\");\r\n                    addClassPath(jar);\r\n                }\r\n            } catch (Exception ex) {\r\n                LOG.warn(Log.EXCEPTION, ex);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.bull.javamelody.internal.model.RrdNioBackend.sync",
	"Comment": "this method forces all data cached in memory but not yet stored in the file,\tto be stored in it.",
	"Method": "void sync(){\r\n    if (byteBuffer != null) {\r\n        byteBuffer.force();\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.types.ResolvedReferenceType.typeParametersValues",
	"Comment": "get the values for all type parameters declared on this type.the list can be empty for raw types.",
	"Method": "List<ResolvedType> typeParametersValues(){\r\n    return this.typeParametersMap.isEmpty() ? Collections.emptyList() : typeDeclaration.getTypeParameters().stream().map(tp -> typeParametersMap.getValue(tp)).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlets.DoSFilter.removeWhitelistAddress",
	"Comment": "removes the given address from the list of whitelisted ip addresses.",
	"Method": "boolean removeWhitelistAddress(String address){\r\n    return _whitelist.remove(address);\r\n}"
}, {
	"Path": "org.eclipse.jetty.maven.plugin.MavenWebInfConfiguration.findJars",
	"Comment": "get the jars to examine from the files from which we havesynthesized the classpath. note that the classpath is notset at this point, so we cannot get them from the classpath.",
	"Method": "List<Resource> findJars(WebAppContext context){\r\n    List<Resource> list = new ArrayList();\r\n    JettyWebAppContext jwac = (JettyWebAppContext) context;\r\n    List<File> files = jwac.getWebInfLib();\r\n    if (files != null) {\r\n        files.forEach(file -> {\r\n            if (file.getName().toLowerCase(Locale.ENGLISH).endsWith(\".jar\") || file.isDirectory()) {\r\n                try {\r\n                    LOG.debug(\" add  resource to resources to examine {}\", file);\r\n                    list.add(Resource.newResource(file.toURI()));\r\n                } catch (Exception e) {\r\n                    LOG.warn(\"Bad url \", e);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    List<Resource> superList = super.findJars(context);\r\n    if (superList != null)\r\n        list.addAll(superList);\r\n    return list;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration.getWrappedNode",
	"Comment": "returns the javaparser node associated with this javaparsertypevariabledeclaration.",
	"Method": "TypeParameter getWrappedNode(){\r\n    return wrappedNode;\r\n}"
}, {
	"Path": "com.github.javaparser.printer.lexicalpreservation.PhantomNodeLogic.inPhantomNode",
	"Comment": "a node contained in a phantom node is also a phantom node. we limit how many levels up we check just for performance reasons.",
	"Method": "boolean inPhantomNode(Node node,int levels){\r\n    return node.getParentNode().isPresent() && (isPhantomNode(node.getParentNode().get()) || inPhantomNode(node.getParentNode().get(), levels - 1));\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.gzip.GzipHandler.setDeflaterPoolCapacity",
	"Comment": "sets the maximum number of deflaters that the deflaterpool can hold.",
	"Method": "void setDeflaterPoolCapacity(int capacity){\r\n    if (isStarted())\r\n        throw new IllegalStateException(getState());\r\n    POOL_CAPACITY = capacity;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserMethodDeclaration.getWrappedNode",
	"Comment": "returns the javaparser node associated with this javaparsermethoddeclaration.",
	"Method": "com.github.javaparser.ast.body.MethodDeclaration getWrappedNode(){\r\n    return wrappedNode;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.gzip.GzipHandler.setMinGzipSize",
	"Comment": "set the minimum response size to trigger dynamic compression",
	"Method": "void setMinGzipSize(int minGzipSize){\r\n    _minGzipSize = minGzipSize;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.ContextHandler.getVirtualHosts",
	"Comment": "get the virtual hosts for the context. only requests that have a matching host header or fully qualified url will be passed to that context with avirtual host name. a context with no virtual host names or a null virtual host name is available to all requests that are not served by a context with amatching virtual host name.",
	"Method": "String[] getVirtualHosts(){\r\n    if (_vhosts == null)\r\n        return null;\r\n    String[] vhosts = new String[_vhosts.length];\r\n    for (int i = 0; i < _vhosts.length; i++) {\r\n        StringBuilder sb = new StringBuilder();\r\n        if (_vhostswildcard[i])\r\n            sb.append(\"*\");\r\n        if (_vhosts[i] != null)\r\n            sb.append(_vhosts[i]);\r\n        if (_vconnectors[i] != null)\r\n            sb.append(\"@\").append(_vconnectors[i]);\r\n        vhosts[i] = sb.toString();\r\n    }\r\n    return vhosts;\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.internal.serverfactory.DefaultJettyAtJettyHomeHelper.getJettyConfigurationURLs",
	"Comment": "minimum setup for the location of the configuration files given aconfiguration embedded inside a bundle. reads the system propertyjetty.etc.config.urls and look for the corresponding jetty configurationfiles that will be used to setup the jetty server.",
	"Method": "List<URL> getJettyConfigurationURLs(File jettyhome,List<URL> getJettyConfigurationURLs,Bundle configurationBundle,Dictionary properties){\r\n    List<URL> configURLs = new ArrayList();\r\n    String files = System.getProperty(JETTY_ETC_FILES, DEFAULT_JETTY_ETC_FILES);\r\n    StringTokenizer tokenizer = new StringTokenizer(files, \";,\", false);\r\n    while (tokenizer.hasMoreTokens()) {\r\n        String etcFile = tokenizer.nextToken().trim();\r\n        if (etcFile.startsWith(\"/\") || etcFile.indexOf(\":\") != -1)\r\n            configURLs.add(new URL(etcFile));\r\n        else {\r\n            Enumeration<URL> enUrls = BundleFileLocatorHelperFactory.getFactory().getHelper().findEntries(configurationBundle, etcFile);\r\n            String home = null;\r\n            if ((enUrls == null || !enUrls.hasMoreElements())) {\r\n                home = DEFAULT_JETTYHOME;\r\n                String tmp = DEFAULT_JETTYHOME + (DEFAULT_JETTYHOME.endsWith(\"/\") ? \"\" : \"/\") + etcFile;\r\n                enUrls = BundleFileLocatorHelperFactory.getFactory().getHelper().findEntries(configurationBundle, tmp);\r\n                LOG.info(\"Configuring jetty from bundle: {} with {}\", configurationBundle.getSymbolicName(), tmp);\r\n            }\r\n            if (properties.get(OSGiServerConstants.JETTY_HOME) == null) {\r\n                Resource res = findDir(configurationBundle, home);\r\n                if (res != null)\r\n                    properties.put(OSGiServerConstants.JETTY_HOME, res.toString());\r\n            }\r\n            if (enUrls == null || !enUrls.hasMoreElements())\r\n                throw new IllegalStateException(\"Unable to locate a jetty configuration file for \" + etcFile);\r\n            URL url = BundleFileLocatorHelperFactory.getFactory().getHelper().getFileURL(enUrls.nextElement());\r\n            configURLs.add(url);\r\n        }\r\n    }\r\n    return configURLs;\r\n}"
}, {
	"Path": "net.bull.javamelody.internal.model.CacheInformations.computeMemoryPercentUsed",
	"Comment": "otherwise serialization would not work in the collector server or in jenkins scripts",
	"Method": "int computeMemoryPercentUsed(Object cache){\r\n    final int maxElementsInMemory = ((Ehcache) cache).getCacheConfiguration().getMaxElementsInMemory();\r\n    if (maxElementsInMemory == 0) {\r\n        return -1;\r\n    }\r\n    return (int) (100 * inMemoryObjectCount / maxElementsInMemory);\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.MimeTypes.getMimeByExtension",
	"Comment": "get the mime type by filename extension.lookup the content and static default mime maps.",
	"Method": "String getMimeByExtension(String filename){\r\n    String type = null;\r\n    if (filename != null) {\r\n        int i = -1;\r\n        while (type == null) {\r\n            i = filename.indexOf(\".\", i + 1);\r\n            if (i < 0 || i >= filename.length())\r\n                break;\r\n            String ext = StringUtil.asciiToLowerCase(filename.substring(i + 1));\r\n            if (_mimeMap != null)\r\n                type = _mimeMap.get(ext);\r\n            if (type == null)\r\n                type = __dftMimeMap.get(ext);\r\n        }\r\n    }\r\n    if (type == null) {\r\n        if (_mimeMap != null)\r\n            type = _mimeMap.get(\"*\");\r\n        if (type == null)\r\n            type = __dftMimeMap.get(\"*\");\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.UrlEncoded.encode",
	"Comment": "encode multimap with % encoding for arbitrary charset sequences.",
	"Method": "String encode(String encode,Charset charset,String encode,Charset charset,boolean equalsForNullValue,String encode,MultiMap<String> map,Charset charset,boolean equalsForNullValue){\r\n    if (charset == null)\r\n        charset = ENCODING;\r\n    StringBuilder result = new StringBuilder(128);\r\n    boolean delim = false;\r\n    for (Map.Entry<String, List<String>> entry : map.entrySet()) {\r\n        String key = entry.getKey().toString();\r\n        List<String> list = entry.getValue();\r\n        int s = list.size();\r\n        if (delim) {\r\n            result.append('&');\r\n        }\r\n        if (s == 0) {\r\n            result.append(encodeString(key, charset));\r\n            if (equalsForNullValue)\r\n                result.append('=');\r\n        } else {\r\n            for (int i = 0; i < s; i++) {\r\n                if (i > 0)\r\n                    result.append('&');\r\n                String val = list.get(i);\r\n                result.append(encodeString(key, charset));\r\n                if (val != null) {\r\n                    String str = val.toString();\r\n                    if (str.length() > 0) {\r\n                        result.append('=');\r\n                        result.append(encodeString(str, charset));\r\n                    } else if (equalsForNullValue)\r\n                        result.append('=');\r\n                } else if (equalsForNullValue)\r\n                    result.append('=');\r\n            }\r\n        }\r\n        delim = true;\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.ServletContextHandler.setServletSecurity",
	"Comment": "delegate for servletregistration.dynamic.setservletsecurity method",
	"Method": "Set<String> setServletSecurity(ServletRegistration.Dynamic registration,ServletSecurityElement servletSecurityElement){\r\n    Collection<String> pathSpecs = registration.getMappings();\r\n    if (pathSpecs != null) {\r\n        for (String pathSpec : pathSpecs) {\r\n            List<ConstraintMapping> mappings = ConstraintSecurityHandler.createConstraintsWithMappingsForPath(registration.getName(), pathSpec, servletSecurityElement);\r\n            for (ConstraintMapping m : mappings) ((ConstraintAware) getSecurityHandler()).addConstraintMapping(m);\r\n        }\r\n    }\r\n    return Collections.emptySet();\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.MultiPartFormInputStream.getParts",
	"Comment": "parse, if necessary, the multipart data and return the list of parts.",
	"Method": "Collection<Part> getParts(){\r\n    if (!_parsed)\r\n        parse();\r\n    throwIfError();\r\n    Collection<List<Part>> values = _parts.values();\r\n    List<Part> parts = new ArrayList();\r\n    for (List<Part> o : values) {\r\n        List<Part> asList = LazyList.getList(o, false);\r\n        parts.addAll(asList);\r\n    }\r\n    return parts;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.typeParametersValues",
	"Comment": "get the values for all type parameters declared on this type.the list can be empty for raw types.",
	"Method": "List<Type> typeParametersValues(){\r\n    return this.typeParametersMap.isEmpty() ? Collections.emptyList() : typeDeclaration.getTypeParameters().stream().map(tp -> typeParametersMap.getValue(tp)).collect(Collectors.toList());\r\n}"
}, {
	"Path": "net.bull.javamelody.PayloadNameRequestWrapper.parseSoapMethodName",
	"Comment": "try to parse soap method name from request body stream.does not close the stream.",
	"Method": "String parseSoapMethodName(InputStream stream,String charEncoding){\r\n    try {\r\n        final XMLInputFactory factory = XMLInputFactory.newInstance();\r\n        factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\r\n        factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\r\n        final XMLStreamReader xmlReader;\r\n        if (charEncoding != null) {\r\n            xmlReader = factory.createXMLStreamReader(stream, charEncoding);\r\n        } else {\r\n            xmlReader = factory.createXMLStreamReader(stream);\r\n        }\r\n        xmlReader.nextTag();\r\n        if (!\"Envelope\".equals(xmlReader.getLocalName())) {\r\n            LOG.debug(\"Unexpected first tag of SOAP request: '\" + xmlReader.getLocalName() + \"' (expected 'Envelope')\");\r\n            return null;\r\n        }\r\n        if (!scanForChildTag(xmlReader, \"Body\")) {\r\n            LOG.debug(\"Unable to find SOAP 'Body' tag\");\r\n            return null;\r\n        }\r\n        xmlReader.nextTag();\r\n        return \".\" + xmlReader.getLocalName();\r\n    } catch (final XMLStreamException e) {\r\n        LOG.debug(\"Unable to parse SOAP request\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.start.Version.isInRange",
	"Comment": "check whether this version is in range of versions specified",
	"Method": "boolean isInRange(Version low,Version high){\r\n    return ((compareTo(low) >= 0) && (compareTo(high) <= 0));\r\n}"
}, {
	"Path": "com.github.javaparser.utils.SourceRoot.add",
	"Comment": "add a newly created java file to the cache of this source root. it will be saved when saveall is called. it needsto have its path set.",
	"Method": "SourceRoot add(String startPackage,String filename,CompilationUnit compilationUnit,SourceRoot add,CompilationUnit compilationUnit){\r\n    assertNotNull(compilationUnit);\r\n    if (compilationUnit.getStorage().isPresent()) {\r\n        final Path path = compilationUnit.getStorage().get().getPath();\r\n        Log.trace(\"Adding new file %s\", path);\r\n        final ParseResult<CompilationUnit> parseResult = new ParseResult(compilationUnit, new ArrayList(), null, null);\r\n        cache.put(path, parseResult);\r\n    } else {\r\n        throw new AssertionError(\"Files added with this method should have their path set.\");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.HttpInput.skip",
	"Comment": "consumes the given content. calls the content succeeded if all content consumed.",
	"Method": "void skip(Content content,int length,int skip,int length){\r\n    int l = content.skip(length);\r\n    _contentConsumed += l;\r\n    if (l > 0 && content.isEmpty())\r\n        nextNonSentinelContent();\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.annotations.AnnotationConfiguration.parseWebBundle",
	"Comment": "scan a bundle required by the webbundle for servlet annotations",
	"Method": "void parseWebBundle(WebAppContext context,AnnotationParser parser,Bundle webbundle){\r\n    parseBundle(context, parser, webbundle, webbundle);\r\n}"
}, {
	"Path": "org.javaee7.jms.temp.destination.JmsClient.process",
	"Comment": "we need to send message in the middle of the method, therefore we cannot be transactional",
	"Method": "String process(String request){\r\n    TextMessage requestMessage = jms.createTextMessage(request);\r\n    TemporaryQueue responseQueue = jms.createTemporaryQueue();\r\n    // <2> set the temporary queue as replyToDestination\r\n    jms.createProducer().setJMSReplyTo(// <3> immediately send the request message\r\n    responseQueue).send(requestQueue, requestMessage);\r\n    try (JMSConsumer consumer = jms.createConsumer(responseQueue)) {\r\n        String response = consumer.receiveBody(String.class, 20000);\r\n        if (response == null) {\r\n            throw new IllegalStateException(\"Message processing timed out\");\r\n        }\r\n        return response;\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.ast.expr.StringLiteralExpr.escape",
	"Comment": "utility method that creates a new stringliteralexpr. escapes eol characters.",
	"Method": "StringLiteralExpr escape(String string){\r\n    return new StringLiteralExpr(Utils.escapeEndOfLines(string));\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.AbstractSessionCache.checkInactiveSession",
	"Comment": "check a session for being inactive andthus being able to be evicted, if evictionis enabled.",
	"Method": "void checkInactiveSession(Session session){\r\n    if (session == null)\r\n        return;\r\n    if (LOG.isDebugEnabled())\r\n        LOG.debug(\"Checking for idle {}\", session.getId());\r\n    try (Lock s = session.lock()) {\r\n        if (getEvictionPolicy() > 0 && session.isIdleLongerThan(getEvictionPolicy()) && session.isValid() && session.isResident() && session.getRequests() <= 0) {\r\n            try {\r\n                if (LOG.isDebugEnabled())\r\n                    LOG.debug(\"Evicting idle session {}\", session.getId());\r\n                if (isSaveOnInactiveEviction() && _sessionDataStore != null) {\r\n                    if (_sessionDataStore.isPassivating())\r\n                        session.willPassivate();\r\n                    _sessionDataStore.store(session.getId(), session.getSessionData());\r\n                }\r\n                doDelete(session.getId());\r\n                session.setResident(false);\r\n            } catch (Exception e) {\r\n                LOG.warn(\"Passivation of idle session {} failed\", session.getId(), e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.client.util.DeferredContentProvider.close",
	"Comment": "no more content will be added to this content providerand notifies the listener that no more content is available.",
	"Method": "void close(){\r\n    if (closed.compareAndSet(false, true))\r\n        offer(CLOSE);\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.WebSocketFrame.setPayload",
	"Comment": "set the data payload.the provided buffer will be used as is, no copying of bytes performed.the provided buffer should be flipped and ready to read from.",
	"Method": "WebSocketFrame setPayload(ByteBuffer buf){\r\n    data = buf;\r\n    return this;\r\n}"
}, {
	"Path": "com.github.javaparser.printer.SourcePrinter.unindent",
	"Comment": "pop the last indentation of the indentation stack.does not actually output anything.",
	"Method": "SourcePrinter unindent(){\r\n    if (indents.isEmpty()) {\r\n        throw new IllegalStateException(\"Indent/unindent calls are not well-balanced.\");\r\n    }\r\n    indents.pop();\r\n    return this;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.getQualifiedName",
	"Comment": "the qualified name of the type parameter.it is composed by the qualified name of the container followed by a dot and the name of the type parameter.the qualified name of a method is its qualified signature.",
	"Method": "String getQualifiedName(){\r\n    return String.format(\"%s.%s\", getContainerId(), getName());\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.internal.serverfactory.DefaultJettyAtJettyHomeHelper.findDir",
	"Comment": "get a resource representing a directory inside a bundle. if the dir is null,return a resource representing the installation location of the bundle.",
	"Method": "Resource findDir(Bundle bundle,String dir){\r\n    if (bundle == null)\r\n        return null;\r\n    try {\r\n        File f = BundleFileLocatorHelperFactory.getFactory().getHelper().getBundleInstallLocation(bundle);\r\n        URL u = f.toURI().toURL();\r\n        u = BundleFileLocatorHelperFactory.getFactory().getHelper().getLocalURL(u);\r\n        Resource res = Resource.newResource(u);\r\n        String s = res.toString();\r\n        if (s.endsWith(\".jar\") && s.startsWith(\"file:\"))\r\n            res = JarResource.newJarResource(res);\r\n        if (dir != null)\r\n            res = res.addPath(dir);\r\n        return res;\r\n    } catch (Exception e) {\r\n        LOG.warn(\"Bad bundle location\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.resolution.naming.NameLogic.reclassificationOfContextuallyAmbiguousNames",
	"Comment": "jls 6.5.2. reclassification of contextually ambiguous names",
	"Method": "NameCategory reclassificationOfContextuallyAmbiguousNames(Node name,NameCategory ambiguousCategory,TypeSolver typeSolver){\r\n    if (!ambiguousCategory.isNeedingDisambiguation()) {\r\n        throw new IllegalArgumentException(\"The Name Category is not ambiguous: \" + ambiguousCategory);\r\n    }\r\n    if (ambiguousCategory == NameCategory.AMBIGUOUS_NAME && isSimpleName(name)) {\r\n        return reclassificationOfContextuallyAmbiguousSimpleAmbiguousName(name, typeSolver);\r\n    }\r\n    if (ambiguousCategory == NameCategory.AMBIGUOUS_NAME && isQualifiedName(name)) {\r\n        return reclassificationOfContextuallyAmbiguousQualifiedAmbiguousName(name, typeSolver);\r\n    }\r\n    if (ambiguousCategory == NameCategory.PACKAGE_OR_TYPE_NAME) {\r\n        return reclassificationOfContextuallyAmbiguosPackageOrTypeName(name, typeSolver);\r\n    }\r\n    throw new UnsupportedOperationException(\"I do not know how to handle this semantic reclassification of ambiguous name categories\");\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.io.IOState.onFailedUpgrade",
	"Comment": "a websocket connection has failed its upgrade handshake, and is now closed.",
	"Method": "void onFailedUpgrade(){\r\n    assert (this.state == ConnectionState.CONNECTING);\r\n    ConnectionState event = null;\r\n    synchronized (this) {\r\n        this.state = ConnectionState.CLOSED;\r\n        cleanClose = false;\r\n        inputAvailable = false;\r\n        outputAvailable = false;\r\n        event = this.state;\r\n    }\r\n    notifyStateListeners(event);\r\n}"
}, {
	"Path": "com.github.javaparser.ast.expr.Name.isInternal",
	"Comment": "an internal name is a name that constitutes a part of a larger name instance.",
	"Method": "boolean isInternal(){\r\n    return getParentNode().filter(parent -> parent instanceof Name).isPresent();\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.types.ResolvedReferenceType.getTypeParametersMap",
	"Comment": "get the values for all type parameters declared on this type.in case of raw types the values correspond to typevariables.",
	"Method": "List<Pair<ResolvedTypeParameterDeclaration, ResolvedType>> getTypeParametersMap(){\r\n    List<Pair<ResolvedTypeParameterDeclaration, ResolvedType>> typeParametersMap = new ArrayList();\r\n    if (!isRawType()) {\r\n        for (int i = 0; i < typeDeclaration.getTypeParameters().size(); i++) {\r\n            typeParametersMap.add(new Pair(typeDeclaration.getTypeParameters().get(0), typeParametersValues().get(i)));\r\n        }\r\n    }\r\n    return typeParametersMap;\r\n}"
}, {
	"Path": "org.eclipse.jetty.security.ConstraintSecurityHandler.getPathsWithUncoveredHttpMethods",
	"Comment": "servlet spec 3.1 pg. 147.the container must check all the combined security constraintinformation and log any methods that are not protected and theurls at which they are not protected",
	"Method": "Set<String> getPathsWithUncoveredHttpMethods(){\r\n    if (_denyUncoveredMethods)\r\n        return Collections.emptySet();\r\n    Set<String> uncoveredPaths = new HashSet<String>();\r\n    for (String path : _constraintMap.keySet()) {\r\n        Map<String, RoleInfo> methodMappings = _constraintMap.get(path);\r\n        if (methodMappings.get(ALL_METHODS) != null)\r\n            continue;\r\n        boolean hasOmissions = omissionsExist(path, methodMappings);\r\n        for (String method : methodMappings.keySet()) {\r\n            if (method.endsWith(OMISSION_SUFFIX)) {\r\n                Set<String> omittedMethods = getOmittedMethods(method);\r\n                for (String m : omittedMethods) {\r\n                    if (!methodMappings.containsKey(m))\r\n                        uncoveredPaths.add(path);\r\n                }\r\n            } else {\r\n                if (!hasOmissions)\r\n                    uncoveredPaths.add(path);\r\n            }\r\n        }\r\n    }\r\n    return uncoveredPaths;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.component.ContainerLifeCycle.doStop",
	"Comment": "stops the managed lifecycle beans in the reverse order they were added.",
	"Method": "void doStop(){\r\n    _doStarted = false;\r\n    super.doStop();\r\n    List<Bean> reverse = new ArrayList(_beans);\r\n    Collections.reverse(reverse);\r\n    MultiException mex = new MultiException();\r\n    for (Bean b : reverse) {\r\n        if (b._managed == Managed.MANAGED && b._bean instanceof LifeCycle) {\r\n            LifeCycle l = (LifeCycle) b._bean;\r\n            try {\r\n                stop(l);\r\n            } catch (Throwable th) {\r\n                mex.add(th);\r\n            }\r\n        }\r\n    }\r\n    mex.ifExceptionThrow();\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.RequestLogWriter.getRetainDays",
	"Comment": "retrieve the number of days before rotated log files are deleted.",
	"Method": "int getRetainDays(){\r\n    return _retainDays;\r\n}"
}, {
	"Path": "org.javaee7.jaspictest.dispatching.CDIForwardTest.testCDIForwardWithRequestInjectPublic",
	"Comment": "tests that the forwarded resource can utilize an injected httpservletrequest and thatthe value is correct.",
	"Method": "void testCDIForwardWithRequestInjectPublic(){\r\n    String response = getFromServerPath(\"public/servlet\");\r\n    assertTrue(\"Servletpath reported by servlet request after forward from SAM not as expected.\", response.contains(\"servletPath via Servlet - /forwardedServlet\"));\r\n    assertTrue(\"Response did not contain output from forwarded Servlet using CDI injected request. \" + \"Request appears not to be usable.\", response.contains(\"servletPath via CDI\"));\r\n    assertTrue(\"Servletpath reported by injected request after forward from SAM not as expected.\", response.contains(\"servletPath via CDI - /forwardedServlet\"));\r\n}"
}, {
	"Path": "org.eclipse.jetty.rewrite.handler.VirtualHostRuleContainer.setVirtualHosts",
	"Comment": "set the virtual hosts that the rules within this container will apply to",
	"Method": "void setVirtualHosts(String[] virtualHosts){\r\n    if (virtualHosts == null) {\r\n        _virtualHosts = virtualHosts;\r\n    } else {\r\n        _virtualHosts = new String[virtualHosts.length];\r\n        for (int i = 0; i < virtualHosts.length; i++) _virtualHosts[i] = normalizeHostname(virtualHosts[i]);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.ssl.SslContextFactory.checkIsStarted",
	"Comment": "check if the lifecycle has been started and throw runtime exception",
	"Method": "void checkIsStarted(){\r\n    if (!isStarted())\r\n        throw new IllegalStateException(\"!STARTED: \" + this);\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserVariableDeclaration.getWrappedNode",
	"Comment": "returns the javaparser node associated with this javaparserfielddeclaration.",
	"Method": "VariableDeclarationExpr getWrappedNode(){\r\n    return wrappedNode;\r\n}"
}, {
	"Path": "org.eclipse.jetty.proxy.AfterContentTransformer.getMaxOutputBufferSize",
	"Comment": "returns the maximum output buffer size, after which the output is overflown to disk.defaults to 1 mib, i.e. 1048576 bytes.",
	"Method": "long getMaxOutputBufferSize(){\r\n    return maxOutputBufferSize;\r\n}"
}, {
	"Path": "com.github.javaparser.JavaParser.setStaticConfiguration",
	"Comment": "set the configuration for the static parse... methods.this is a static field, so modifying it will directly change how all static parse... methods work!",
	"Method": "void setStaticConfiguration(ParserConfiguration staticConfiguration){\r\n    JavaParser.staticConfiguration = staticConfiguration;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.Node.findRootNode",
	"Comment": "finds the root node of this ast by finding the topmost parent.",
	"Method": "Node findRootNode(){\r\n    Node n = this;\r\n    while (n.getParentNode().isPresent()) {\r\n        n = n.getParentNode().get();\r\n    }\r\n    return n;\r\n}"
}, {
	"Path": "org.eclipse.jetty.maven.plugin.AbstractJettyMojo.startConsoleScanner",
	"Comment": "run a thread that monitors the console input to detect enter hits.",
	"Method": "void startConsoleScanner(){\r\n    if (\"manual\".equalsIgnoreCase(reload)) {\r\n        getLog().info(\"Console reloading is ENABLED. Hit ENTER on the console to restart the context.\");\r\n        consoleScanner = new ConsoleScanner(this);\r\n        consoleScanner.start();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlets.DoSFilter.setMaxRequestsPerSec",
	"Comment": "get maximum number of requests from a connection persecond. requests in excess of this are first delayed,then throttled.",
	"Method": "void setMaxRequestsPerSec(int value){\r\n    _maxRequestsPerSec = value;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.ContextHandler.shutdown",
	"Comment": "set shutdown status. this field allows for graceful shutdown of a context. a started context may be put into non accepting state so that existingrequests can complete, but no new requests are accepted.",
	"Method": "Future<Void> shutdown(){\r\n    _availability = isRunning() ? Availability.SHUTDOWN : Availability.UNAVAILABLE;\r\n    return new FutureCallback(true);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.ContextHandler.addProgrammaticListener",
	"Comment": "apply any necessary restrictions on a programmatic added listener.",
	"Method": "void addProgrammaticListener(EventListener listener){\r\n    _programmaticListeners.add(listener);\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.BufferUtil.toDetailString",
	"Comment": "convert buffer to a detail debug string of pointers and content",
	"Method": "String toDetailString(ByteBuffer[] buffer,String toDetailString,ByteBuffer buffer){\r\n    if (buffer == null)\r\n        return \"null\";\r\n    StringBuilder buf = new StringBuilder();\r\n    idString(buffer, buf);\r\n    buf.append(\"[p=\");\r\n    buf.append(buffer.position());\r\n    buf.append(\",l=\");\r\n    buf.append(buffer.limit());\r\n    buf.append(\",c=\");\r\n    buf.append(buffer.capacity());\r\n    buf.append(\",r=\");\r\n    buf.append(buffer.remaining());\r\n    buf.append(\"]={\");\r\n    appendDebugString(buf, buffer);\r\n    buf.append(\"}\");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.api.util.QuoteUtil.dequote",
	"Comment": "remove quotes from a string, only if the input string start with and end with the same quote character.",
	"Method": "String dequote(String str){\r\n    char start = str.charAt(0);\r\n    if ((start == '\\'') || (start == '\\\"')) {\r\n        char end = str.charAt(str.length() - 1);\r\n        if (start == end) {\r\n            return str.substring(1, str.length() - 1);\r\n        }\r\n    }\r\n    return str;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.typesystem.Type.replaceTypeVariables",
	"Comment": "replace all variables referring to the given typeparameter with the given value.by replacing these values i could also infer some type equivalence.those would be collected in the given map.",
	"Method": "Type replaceTypeVariables(TypeParameterDeclaration tp,Type replaced,Map<TypeParameterDeclaration, Type> inferredTypes,Type replaceTypeVariables,TypeParameterDeclaration tp,Type replaced){\r\n    return replaceTypeVariables(tp, replaced, new HashMap());\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration.getWrappedNode",
	"Comment": "returns the javaparser node associated with this javaparserenumdeclaration.",
	"Method": "com.github.javaparser.ast.body.EnumDeclaration getWrappedNode(){\r\n    return wrappedNode;\r\n}"
}, {
	"Path": "org.eclipse.jetty.plus.annotation.ContainerInitializer.addAnnotatedTypeName",
	"Comment": "a class has been found that has an annotation of interestto this initializer.",
	"Method": "void addAnnotatedTypeName(String className){\r\n    _annotatedTypeNames.add(className);\r\n}"
}, {
	"Path": "org.eclipse.jetty.io.AbstractConnection.onReadTimeout",
	"Comment": "callback method invoked when the endpoint failed to be ready to be read after a timeout",
	"Method": "boolean onReadTimeout(Throwable timeout){\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.jetty.jndi.ContextFactory.associateContext",
	"Comment": "associate the given context with the current thread.disassociate method should be called to reset the context.",
	"Method": "Context associateContext(Context ctx){\r\n    Context previous = (Context) __threadContext.get();\r\n    __threadContext.set(ctx);\r\n    return previous;\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.ServletHolder.checkInitOnStartup",
	"Comment": "check if there is a javax.servlet.annotation.servletsecurityannotation on the servlet class. if there is, then we forceit to be loaded on startup, because all of the securityconstraints must be calculated as the container starts.",
	"Method": "void checkInitOnStartup(){\r\n    if (_class == null)\r\n        return;\r\n    if ((_class.getAnnotation(javax.servlet.annotation.ServletSecurity.class) != null) && !_initOnStartup)\r\n        setInitOrder(Integer.MAX_VALUE);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.AbstractConnector.setAcceptorPriorityDelta",
	"Comment": "set the acceptor thread priority delta.this allows the acceptor thread to run at a different priority.typically this would be used to lower the priority to give preferenceto handling previously accepted connections rather than acceptingnew connections",
	"Method": "void setAcceptorPriorityDelta(int acceptorPriorityDelta){\r\n    int old = _acceptorPriorityDelta;\r\n    _acceptorPriorityDelta = acceptorPriorityDelta;\r\n    if (old != acceptorPriorityDelta && isStarted()) {\r\n        for (Thread thread : _acceptors) thread.setPriority(Math.max(Thread.MIN_PRIORITY, Math.min(Thread.MAX_PRIORITY, thread.getPriority() - old + acceptorPriorityDelta)));\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.PathWatcher.isNotifiable",
	"Comment": "check to see if the watcher is in a state where it should generatewatch events to the listeners. used to determine if watcher should generateevents for existing files and dirs on startup.",
	"Method": "boolean isNotifiable(){\r\n    return (isStarted() || (!isStarted() && isNotifyExistingOnStart()));\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.jmh.DateCacheNoTick.formatNow",
	"Comment": "format a date according to our stored formatter.the passed time is expected to be close to the current time, so it is compared to the last value passed and if it is within the same second,the format is reused.otherwise a new cached format is created.",
	"Method": "String formatNow(long now){\r\n    return format(now);\r\n}"
}, {
	"Path": "org.eclipse.jetty.deploy.providers.ScanningAppProviderRuntimeUpdatesTest.testAfterStartupThenUpdateContext",
	"Comment": "simple webapp deployment after startup of server, and then removal of the webapp.",
	"Method": "void testAfterStartupThenUpdateContext(){\r\n    jetty.copyWebapp(\"foo-webapp-1.war\", \"foo.war\");\r\n    jetty.copyWebapp(\"foo.xml\", \"foo.xml\");\r\n    waitForDirectoryScan();\r\n    waitForDirectoryScan();\r\n    jetty.assertWebAppContextsExists(\"/foo\");\r\n    jetty.assertResponseContains(\"/foo/info\", \"FooServlet-1\");\r\n    waitForDirectoryScan();\r\n    jetty.copyWebapp(\"foo.xml\", \"foo.xml\");\r\n    jetty.copyWebapp(\"foo-webapp-2.war\", \"foo.war\");\r\n    waitForDirectoryScan();\r\n    waitForDirectoryScan();\r\n    jetty.assertWebAppContextsExists(\"/foo\");\r\n    jetty.assertResponseContains(\"/foo/info\", \"FooServlet-2\");\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.thread.QueuedThreadPool.setIdleTimeout",
	"Comment": "set the maximum thread idle time.threads that are idle for longer than this period may bestopped.",
	"Method": "void setIdleTimeout(int idleTimeout){\r\n    _idleTimeout = idleTimeout;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.ContextHandler.setMaxFormContentSize",
	"Comment": "set the maximum size of a form post, to protect against dos attacks from large forms.",
	"Method": "void setMaxFormContentSize(int maxSize){\r\n    _maxFormContentSize = maxSize;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.thread.ExecutorThreadPool.setIdleTimeout",
	"Comment": "sets the maximum thread idle time in ms.threads that are idle for longer than thisperiod may be stopped.",
	"Method": "void setIdleTimeout(int idleTimeout){\r\n    _executor.setKeepAliveTime(idleTimeout, TimeUnit.MILLISECONDS);\r\n}"
}, {
	"Path": "org.eclipse.jetty.plus.annotation.LifeCycleCallback.findMethod",
	"Comment": "find a method of the given name either directly in the givenclass, or inherited.",
	"Method": "Method findMethod(Package pack,Class<?> clazz,String methodName,boolean checkInheritance){\r\n    if (clazz == null)\r\n        return null;\r\n    try {\r\n        Method method = clazz.getDeclaredMethod(methodName);\r\n        if (checkInheritance) {\r\n            int modifiers = method.getModifiers();\r\n            if (Modifier.isProtected(modifiers) || Modifier.isPublic(modifiers) || (!Modifier.isPrivate(modifiers) && (pack.equals(clazz.getPackage()))))\r\n                return method;\r\n            else\r\n                return findMethod(clazz.getPackage(), clazz.getSuperclass(), methodName, true);\r\n        }\r\n        return method;\r\n    } catch (NoSuchMethodException e) {\r\n        return findMethod(clazz.getPackage(), clazz.getSuperclass(), methodName, true);\r\n    }\r\n}"
}, {
	"Path": "net.bull.javamelody.internal.model.Base64Coder.encode",
	"Comment": "encodes a byte array into base64 format.\t no blanks or line breaks are inserted in the output.",
	"Method": "char[] encode(byte[] in,char[] encode,byte[] in,int iOff,int iLen){\r\n    final int oDataLen = (iLen * 4 + 2) / 3;\r\n    final int oLen = (iLen + 2) / 3 * 4;\r\n    final char[] out = new char[oLen];\r\n    int ip = iOff;\r\n    final int iEnd = iOff + iLen;\r\n    int op = 0;\r\n    while (ip < iEnd) {\r\n        final int i0 = in[ip++] & 0xff;\r\n        final int i1 = ip < iEnd ? in[ip++] & 0xff : 0;\r\n        final int i2 = ip < iEnd ? in[ip++] & 0xff : 0;\r\n        final int o0 = i0 >>> 2;\r\n        final int o1 = (i0 & 3) << 4 | i1 >>> 4;\r\n        final int o2 = (i1 & 0xf) << 2 | i2 >>> 6;\r\n        final int o3 = i2 & 0x3F;\r\n        out[op++] = MAP1[o0];\r\n        out[op++] = MAP1[o1];\r\n        out[op] = op < oDataLen ? MAP1[o2] : '=';\r\n        op++;\r\n        out[op] = op < oDataLen ? MAP1[o3] : '=';\r\n        op++;\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.MimeTypes.getDefaultMimeByExtension",
	"Comment": "get the mime type by filename extension.lookup only the static default mime map.",
	"Method": "String getDefaultMimeByExtension(String filename){\r\n    String type = null;\r\n    if (filename != null) {\r\n        int i = -1;\r\n        while (type == null) {\r\n            i = filename.indexOf(\".\", i + 1);\r\n            if (i < 0 || i >= filename.length())\r\n                break;\r\n            String ext = StringUtil.asciiToLowerCase(filename.substring(i + 1));\r\n            if (type == null)\r\n                type = __dftMimeMap.get(ext);\r\n        }\r\n    }\r\n    if (type == null) {\r\n        type = __dftMimeMap.get(\"*\");\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.resolution.typeinference.ControlFlowLogic.exitTheStatement",
	"Comment": "a reachable break statement exits a statement if, within the break target, either there are no try statementswhose try blocks contain the break statement, or there are try statements whose try blocks contain the breakstatement and all finally clauses of those try statements can complete normally.",
	"Method": "boolean exitTheStatement(BreakStmt breakStmt){\r\n    if (!isReachable(breakStmt)) {\r\n        return false;\r\n    }\r\n    Statement breakTarget = breakTarget(breakStmt);\r\n    for (TryStmt tryStmt : containedTryStmts(breakTarget)) {\r\n        if (contains(tryStmt.getTryBlock(), breakStmt)) {\r\n            if (!tryStmt.getFinallyBlock().isPresent() && !canCompleteNormally(tryStmt.getFinallyBlock().get())) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.BundleContextProvider.bundleRemoved",
	"Comment": "bundle has been removed. if it was a context we deployed, undeploy it.",
	"Method": "boolean bundleRemoved(Bundle bundle){\r\n    List<App> apps = _bundleMap.remove(bundle);\r\n    boolean removed = false;\r\n    if (apps != null) {\r\n        for (App app : apps) {\r\n            _appMap.remove(app.getOriginId());\r\n            getDeploymentManager().removeApp(app);\r\n            removed = true;\r\n        }\r\n    }\r\n    return removed;\r\n}"
}, {
	"Path": "org.eclipse.jetty.jndi.factories.MailSessionReference.getObjectInstance",
	"Comment": "create a javax.mail.session instance based on the information passed in the reference",
	"Method": "Object getObjectInstance(Object ref,Name arg1,Context arg2,Hashtable arg3){\r\n    if (ref == null)\r\n        return null;\r\n    Reference reference = (Reference) ref;\r\n    Properties props = new Properties();\r\n    String user = null;\r\n    String password = null;\r\n    Enumeration refs = reference.getAll();\r\n    while (refs.hasMoreElements()) {\r\n        RefAddr refAddr = (RefAddr) refs.nextElement();\r\n        String name = refAddr.getType();\r\n        String value = (String) refAddr.getContent();\r\n        if (name.equalsIgnoreCase(\"user\"))\r\n            user = value;\r\n        else if (name.equalsIgnoreCase(\"pwd\"))\r\n            password = value;\r\n        else\r\n            props.put(name, value);\r\n    }\r\n    if (password == null)\r\n        return Session.getInstance(props);\r\n    else\r\n        return Session.getInstance(props, new PasswordAuthenticator(user, password));\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.TypeDeclaration.isClass",
	"Comment": "is this the declaration of a class?note that an enum is not considered a class in this case.",
	"Method": "boolean isClass(){\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.GracefulStopTest.testGracefulNoWaiter",
	"Comment": "test of standard graceful timeout mechanism when a block request doesnot complete",
	"Method": "void testGracefulNoWaiter(){\r\n    Server server = new Server();\r\n    server.setStopTimeout(1000);\r\n    ServerConnector connector = new ServerConnector(server);\r\n    connector.setPort(0);\r\n    server.addConnector(connector);\r\n    TestHandler handler = new TestHandler();\r\n    server.setHandler(handler);\r\n    server.start();\r\n    final int port = connector.getLocalPort();\r\n    Socket client = new Socket(\"127.0.0.1\", port);\r\n    client.getOutputStream().write((\"POST / HTTP/1.0\\r\\n\" + \"Host: localhost:\" + port + \"\\r\\n\" + \"Content-Type: plain/text\\r\\n\" + \"Content-Length: 10\\r\\n\" + \"\\r\\n\" + \"12345\").getBytes());\r\n    client.getOutputStream().flush();\r\n    handler.latch.await();\r\n    long start = System.nanoTime();\r\n    server.stop();\r\n    long stop = System.nanoTime();\r\n    assertThat(TimeUnit.NANOSECONDS.toMillis(stop - start), lessThan(900L));\r\n    assertThat(client.getInputStream().read(), is(-1));\r\n    assertThat(handler.handling.get(), is(false));\r\n    assertThat(handler.thrown.get(), Matchers.notNullValue());\r\n    client.close();\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.Session.finishInvalidate",
	"Comment": "call httpsessionattributelisteners as part of invalidating a session.",
	"Method": "void finishInvalidate(){\r\n    try (Lock lock = _lock.lock()) {\r\n        try {\r\n            if (LOG.isDebugEnabled())\r\n                LOG.debug(\"invalidate {}\", _sessionData.getId());\r\n            if (_state == State.VALID || _state == State.INVALIDATING) {\r\n                Set<String> keys = null;\r\n                do {\r\n                    keys = _sessionData.getKeys();\r\n                    for (String key : keys) {\r\n                        Object old = _sessionData.setAttribute(key, null);\r\n                        if (old == null)\r\n                            continue;\r\n                        callSessionAttributeListeners(key, null, old);\r\n                    }\r\n                } while (!keys.isEmpty());\r\n            }\r\n        } finally {\r\n            _state = State.INVALID;\r\n            _handler.recordSessionTime(this);\r\n            _stateChangeCompleted.signalAll();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.DefaultServletTest.assumeMkDirSupported",
	"Comment": "attempt to create the directory, skip testcase if not supported on os.",
	"Method": "Path assumeMkDirSupported(Path path,String subpath){\r\n    Path ret = null;\r\n    try {\r\n        ret = path.resolve(subpath);\r\n        if (Files.exists(ret))\r\n            return ret;\r\n        Files.createDirectories(ret);\r\n    } catch (InvalidPathException | IOException ignore) {\r\n    }\r\n    assumeTrue(ret != null, \"Directory creation not supported on OS: \" + path + File.separator + subpath);\r\n    assumeTrue(Files.exists(ret), \"Directory creation not supported on OS: \" + ret);\r\n    return ret;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.types.ResolvedType.replaceTypeVariables",
	"Comment": "replace all variables referring to the given typeparameter with the given value.by replacing these values i could also infer some type equivalence.those would be collected in the given map.",
	"Method": "ResolvedType replaceTypeVariables(ResolvedTypeParameterDeclaration tp,ResolvedType replaced,Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes,ResolvedType replaceTypeVariables,ResolvedTypeParameterDeclaration tp,ResolvedType replaced){\r\n    return replaceTypeVariables(tp, replaced, new HashMap());\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlets.DoSFilter.getMaxRequestsPerSec",
	"Comment": "get maximum number of requests from a connection persecond. requests in excess of this are first delayed,then throttled.",
	"Method": "int getMaxRequestsPerSec(){\r\n    return _maxRequestsPerSec;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.stmt.IfStmt.hasElseBranch",
	"Comment": "this method returns true if the if statement has an else branch.",
	"Method": "boolean hasElseBranch(){\r\n    return elseStmt != null;\r\n}"
}, {
	"Path": "org.javaee7.jaspictest.customprincipal.CustomPrincipalStatelessTest.testProtectedThenPublicAccessIsStateless",
	"Comment": "tests independently from being able to access a protected resource if any details of a previously establishedauthenticated identity are remembered",
	"Method": "void testProtectedThenPublicAccessIsStateless(){\r\n    String response = getFromServerPath(\"protected/servlet?doLogin=true\");\r\n    response = getFromServerPath(\"public/servlet\");\r\n    assertFalse(\"User principal was 'test', but it should be null here. \" + \"The container seemed to have remembered it from the previous request.\", response.contains(\"web username: test\"));\r\n    assertTrue(\"User principal was not null, but it should be null here. \", response.contains(\"web username: null\"));\r\n    assertTrue(\"The unauthenticated user has the role 'architect', which should not be the case. \" + \"The container seemed to have remembered it from the previous request.\", response.contains(\"web user has role \\\"architect\\\": false\"));\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.io.IOState.onOpened",
	"Comment": "a websocket connection has finished its upgrade handshake, and is now open.",
	"Method": "void onOpened(){\r\n    if (LOG.isDebugEnabled())\r\n        LOG.debug(\"onOpened()\");\r\n    ConnectionState event = null;\r\n    synchronized (this) {\r\n        if (this.state == ConnectionState.OPEN) {\r\n            return;\r\n        }\r\n        if (this.state != ConnectionState.CONNECTED) {\r\n            LOG.debug(\"Unable to open, not in CONNECTED state: {}\", this.state);\r\n            return;\r\n        }\r\n        this.state = ConnectionState.OPEN;\r\n        this.inputAvailable = true;\r\n        this.outputAvailable = true;\r\n        event = this.state;\r\n    }\r\n    notifyStateListeners(event);\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.PathMap.containsMatch",
	"Comment": "return whether the path matches any entries in the pathmap,excluding the default entry",
	"Method": "boolean containsMatch(String path,boolean containsMatch,String s){\r\n    MappedEntry<?> match = getMatch(path);\r\n    return match != null && !match.equals(_default);\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.ssl.SslContextFactory.setExcludeCipherSuites",
	"Comment": "you can either use the exact cipher suite name or a a regular expression.",
	"Method": "void setExcludeCipherSuites(String cipherSuites){\r\n    _excludeCipherSuites.clear();\r\n    _excludeCipherSuites.addAll(Arrays.asList(cipherSuites));\r\n}"
}, {
	"Path": "org.eclipse.jetty.security.PropertyUserStore.notifyRemove",
	"Comment": "notifies the registered listeners that a user has been removed.",
	"Method": "void notifyRemove(String username){\r\n    if (_listeners != null) {\r\n        for (UserListener _listener : _listeners) _listener.remove(username);\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.resolution.naming.NameLogic.classifyRole",
	"Comment": "what is the role of the given name? does it represent a declaration or a reference?this classification is purely syntactical, i.e., it does not require symbol resolution. for this reason in thefuture this could be moved to the core module of javaparser.",
	"Method": "NameRole classifyRole(Node name){\r\n    if (!isAName(name)) {\r\n        throw new IllegalArgumentException(\"The given node is not a name\");\r\n    }\r\n    if (!name.getParentNode().isPresent()) {\r\n        throw new IllegalArgumentException(\"We cannot understand the role of a name if it has no parent\");\r\n    }\r\n    if (whenParentIs(Name.class, name, (p, c) -> p.getQualifier().isPresent() && p.getQualifier().get() == c)) {\r\n        return classifyRole(name.getParentNode().get());\r\n    }\r\n    if (whenParentIs(PackageDeclaration.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(ImportDeclaration.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(MarkerAnnotationExpr.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ClassOrInterfaceDeclaration.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(ClassOrInterfaceDeclaration.class, name, (p, c) -> p.getExtendedTypes().contains(c) || p.getImplementedTypes().contains(c))) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ClassOrInterfaceType.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(VariableDeclarator.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(NameExpr.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(FieldAccessExpr.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(MethodDeclaration.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(Parameter.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(MethodCallExpr.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ConstructorDeclaration.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(AnnotationDeclaration.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(AnnotationMemberDeclaration.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(AnnotationMemberDeclaration.class, name, (p, c) -> p.getType() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(MethodDeclaration.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(MethodDeclaration.class, name, (p, c) -> p.getType() == c || p.getThrownExceptions().contains(c))) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(Parameter.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(Parameter.class, name, (p, c) -> p.getType() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ReceiverParameter.class, name, (p, c) -> p.getType() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(MethodCallExpr.class, name, (p, c) -> p.getName() == c || (p.getTypeArguments().isPresent() && p.getTypeArguments().get().contains(c)) || (p.getScope().isPresent() && p.getScope().get() == c))) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ConstructorDeclaration.class, name, (p, c) -> p.getName() == c || p.getThrownExceptions().contains(c))) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(TypeParameter.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(EnumDeclaration.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(EnumConstantDeclaration.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(FieldAccessExpr.class, name, (p, c) -> p.getName() == c || p.getScope() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ObjectCreationExpr.class, name, (p, c) -> p.getType() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ReturnStmt.class, name, (p, c) -> p.getExpression().isPresent() && p.getExpression().get() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ModuleDeclaration.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(ModuleRequiresDirective.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ModuleExportsDirective.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ModuleExportsDirective.class, name, (p, c) -> p.getModuleNames().contains(c))) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ModuleOpensDirective.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ModuleOpensDirective.class, name, (p, c) -> p.getModuleNames().contains(c))) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ModuleUsesDirective.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ModuleProvidesDirective.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ClassExpr.class, name, (p, c) -> p.getType() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ThisExpr.class, name, (p, c) -> p.getClassExpr().isPresent() && p.getClassExpr().get() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(SuperExpr.class, name, (p, c) -> p.getClassExpr().isPresent() && p.getClassExpr().get() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(VariableDeclarator.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(VariableDeclarator.class, name, (p, c) -> p.getType() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ArrayCreationExpr.class, name, (p, c) -> p.getElementType() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(CastExpr.class, name, (p, c) -> p.getType() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(InstanceOfExpr.class, name, (p, c) -> p.getType() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(TypeExpr.class, name, (p, c) -> p.getType() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ArrayAccessExpr.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(UnaryExpr.class, name, (p, c) -> p.getExpression() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(AssignExpr.class, name, (p, c) -> p.getTarget() == c || p.getValue() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(TryStmt.class, name, (p, c) -> p.getResources().contains(c))) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(VariableDeclarator.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(VariableDeclarator.class, name, (p, c) -> p.getType() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(VariableDeclarator.class, name, (p, c) -> p.getInitializer().isPresent() && p.getInitializer().get() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(MemberValuePair.class, name, (p, c) -> p.getValue() == c)) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(MemberValuePair.class, name, (p, c) -> p.getName() == c)) {\r\n        return NameRole.DECLARATION;\r\n    }\r\n    if (whenParentIs(ExplicitConstructorInvocationStmt.class, name, (p, c) -> (p.getExpression().isPresent() && p.getExpression().get() == c) || (p.getTypeArguments().isPresent() && p.getTypeArguments().get().contains(c)))) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (whenParentIs(ObjectCreationExpr.class, name, (p, c) -> p.getType() == c || (p.getScope().isPresent() && p.getScope().get() == c))) {\r\n        return NameRole.REFERENCE;\r\n    }\r\n    if (name.getParentNode().isPresent() && NameLogic.isAName(name.getParentNode().get())) {\r\n        return classifyRole(name.getParentNode().get());\r\n    }\r\n    throw new UnsupportedOperationException(\"Unable to classify role of name contained in \" + name.getParentNode().get().getClass().getSimpleName());\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.InetAccessHandler.isAllowed",
	"Comment": "checks if specified address and request are allowed by current inetaddress rules.",
	"Method": "boolean isAllowed(InetAddress address,HttpServletRequest request){\r\n    boolean allowed = _set.test(address);\r\n    if (LOG.isDebugEnabled())\r\n        LOG.debug(\"{} {} {} for {}\", this, allowed ? \"allowed\" : \"denied\", address, request);\r\n    return allowed;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.resource.URLResource.list",
	"Comment": "returns a list of resource names contained in the given resource",
	"Method": "String[] list(){\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.UrlEncoded.decodeString",
	"Comment": "decode string with % encoding.this method makes the assumption that the majority of callswill need no decoding.",
	"Method": "String decodeString(String encoded,String decodeString,String encoded,int offset,int length,Charset charset){\r\n    if (charset == null || StandardCharsets.UTF_8.equals(charset)) {\r\n        Utf8StringBuffer buffer = null;\r\n        for (int i = 0; i < length; i++) {\r\n            char c = encoded.charAt(offset + i);\r\n            if (c < 0 || c > 0xff) {\r\n                if (buffer == null) {\r\n                    buffer = new Utf8StringBuffer(length);\r\n                    buffer.getStringBuffer().append(encoded, offset, offset + i + 1);\r\n                } else\r\n                    buffer.getStringBuffer().append(c);\r\n            } else if (c == '+') {\r\n                if (buffer == null) {\r\n                    buffer = new Utf8StringBuffer(length);\r\n                    buffer.getStringBuffer().append(encoded, offset, offset + i);\r\n                }\r\n                buffer.getStringBuffer().append(' ');\r\n            } else if (c == '%') {\r\n                if (buffer == null) {\r\n                    buffer = new Utf8StringBuffer(length);\r\n                    buffer.getStringBuffer().append(encoded, offset, offset + i);\r\n                }\r\n                if ((i + 2) < length) {\r\n                    int o = offset + i + 1;\r\n                    i += 2;\r\n                    byte b = (byte) TypeUtil.parseInt(encoded, o, 2, 16);\r\n                    buffer.append(b);\r\n                } else {\r\n                    buffer.getStringBuffer().append(Utf8Appendable.REPLACEMENT);\r\n                    i = length;\r\n                }\r\n            } else if (buffer != null)\r\n                buffer.getStringBuffer().append(c);\r\n        }\r\n        if (buffer == null) {\r\n            if (offset == 0 && encoded.length() == length)\r\n                return encoded;\r\n            return encoded.substring(offset, offset + length);\r\n        }\r\n        return buffer.toReplacedString();\r\n    } else {\r\n        StringBuffer buffer = null;\r\n        for (int i = 0; i < length; i++) {\r\n            char c = encoded.charAt(offset + i);\r\n            if (c < 0 || c > 0xff) {\r\n                if (buffer == null) {\r\n                    buffer = new StringBuffer(length);\r\n                    buffer.append(encoded, offset, offset + i + 1);\r\n                } else\r\n                    buffer.append(c);\r\n            } else if (c == '+') {\r\n                if (buffer == null) {\r\n                    buffer = new StringBuffer(length);\r\n                    buffer.append(encoded, offset, offset + i);\r\n                }\r\n                buffer.append(' ');\r\n            } else if (c == '%') {\r\n                if (buffer == null) {\r\n                    buffer = new StringBuffer(length);\r\n                    buffer.append(encoded, offset, offset + i);\r\n                }\r\n                byte[] ba = new byte[length];\r\n                int n = 0;\r\n                while (c >= 0 && c <= 0xff) {\r\n                    if (c == '%') {\r\n                        if (i + 2 < length) {\r\n                            int o = offset + i + 1;\r\n                            i += 3;\r\n                            ba[n] = (byte) TypeUtil.parseInt(encoded, o, 2, 16);\r\n                            n++;\r\n                        } else {\r\n                            ba[n++] = (byte) '?';\r\n                            i = length;\r\n                        }\r\n                    } else if (c == '+') {\r\n                        ba[n++] = (byte) ' ';\r\n                        i++;\r\n                    } else {\r\n                        ba[n++] = (byte) c;\r\n                        i++;\r\n                    }\r\n                    if (i >= length)\r\n                        break;\r\n                    c = encoded.charAt(offset + i);\r\n                }\r\n                i--;\r\n                buffer.append(new String(ba, 0, n, charset));\r\n            } else if (buffer != null)\r\n                buffer.append(c);\r\n        }\r\n        if (buffer == null) {\r\n            if (offset == 0 && encoded.length() == length)\r\n                return encoded;\r\n            return encoded.substring(offset, offset + length);\r\n        }\r\n        return buffer.toString();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.jmh.DateCacheSimpleDateFormat.format",
	"Comment": "format a date according to our stored formatter.if it happens to be in the same second as the last formatnowcall, then the format is reused.",
	"Method": "String format(Date inDate,String format,long inDate){\r\n    long seconds = inDate / 1000;\r\n    Tick tick = _tick;\r\n    if (tick == null || seconds != tick._seconds) {\r\n        Date d = new Date(inDate);\r\n        synchronized (this) {\r\n            return _tzFormat.format(d);\r\n        }\r\n    }\r\n    return tick._string;\r\n}"
}, {
	"Path": "com.github.javaparser.printer.lexicalpreservation.Difference.cleanTheLineOfLeftOverSpace",
	"Comment": "cleans the line of left over space if there is unnecessary indentation and the element will not be replaced",
	"Method": "void cleanTheLineOfLeftOverSpace(RemovedGroup removedGroup,Removed removed){\r\n    if (originalIndex >= originalElements.size()) {\r\n        return;\r\n    }\r\n    if (!removedGroup.isProcessed() && removedGroup.getLastElement() == removed && removedGroup.isACompleteLine()) {\r\n        Integer lastElementIndex = removedGroup.getLastElementIndex();\r\n        Optional<Integer> indentation = removedGroup.getIndentation();\r\n        if (indentation.isPresent() && !isReplaced(lastElementIndex)) {\r\n            for (int i = 0; i < indentation.get(); i++) {\r\n                if (originalElements.get(originalIndex).isSpaceOrTab()) {\r\n                    nodeText.removeElement(originalIndex);\r\n                } else if (originalIndex >= 1 && originalElements.get(originalIndex - 1).isSpaceOrTab()) {\r\n                    nodeText.removeElement(originalIndex - 1);\r\n                    originalIndex--;\r\n                }\r\n            }\r\n        }\r\n        removedGroup.processed();\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.GeneratedJavaParserTokenManagerBase.createCommentFromToken",
	"Comment": "since comments are completely captured in a single token, including their delimiters, deconstruct them here so wecan turn them into nodes later on.",
	"Method": "Comment createCommentFromToken(Token token){\r\n    String commentText = token.image;\r\n    if (token.kind == JAVADOC_COMMENT) {\r\n        return new JavadocComment(tokenRange(token), commentText.substring(3, commentText.length() - 2));\r\n    } else if (token.kind == MULTI_LINE_COMMENT) {\r\n        return new BlockComment(tokenRange(token), commentText.substring(2, commentText.length() - 2));\r\n    } else if (token.kind == SINGLE_LINE_COMMENT) {\r\n        Range range = new Range(pos(token.beginLine, token.beginColumn), pos(token.endLine, token.endColumn));\r\n        while (commentText.endsWith(\"\\r\") || commentText.endsWith(\"\\n\")) {\r\n            commentText = commentText.substring(0, commentText.length() - 1);\r\n        }\r\n        range = range.withEnd(pos(range.begin.line, range.begin.column + commentText.length()));\r\n        LineComment comment = new LineComment(tokenRange(token), commentText.substring(2));\r\n        comment.setRange(range);\r\n        return comment;\r\n    }\r\n    throw new AssertionError(\"Unexpectedly got passed a non-comment token.\");\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.HttpServerTestBase.testRequest1Fragments",
	"Comment": "feed the server fragmentary headers and see how it copes with it.",
	"Method": "void testRequest1Fragments(){\r\n    configureServer(new HelloWorldHandler());\r\n    try (Socket client = newSocket(_serverURI.getHost(), _serverURI.getPort())) {\r\n        OutputStream os = client.getOutputStream();\r\n        os.write(FRAGMENT1.getBytes());\r\n        os.flush();\r\n        Thread.sleep(PAUSE);\r\n        os.write(FRAGMENT2.getBytes());\r\n        os.flush();\r\n        Thread.sleep(PAUSE);\r\n        os.write(FRAGMENT3.getBytes());\r\n        os.flush();\r\n        String response = readResponse(client);\r\n        assertEquals(RESPONSE1, response, \"response\");\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.annotations.AnnotationConfiguration.createAnnotationParser",
	"Comment": "this parser scans the bundles using the osgi apis instead of assuming a jar.",
	"Method": "org.eclipse.jetty.annotations.AnnotationParser createAnnotationParser(int javaTargetVersion){\r\n    return new AnnotationParser(javaTargetVersion);\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.HttpParser.parseFields",
	"Comment": "parse the message headers and return true if the handler has signalled for a return",
	"Method": "boolean parseFields(ByteBuffer buffer){\r\n    while ((_state == State.HEADER || _state == State.TRAILER) && buffer.hasRemaining()) {\r\n        HttpTokens.Token t = next(buffer);\r\n        if (t == null)\r\n            break;\r\n        if (_maxHeaderBytes > 0 && ++_headerBytes > _maxHeaderBytes) {\r\n            boolean header = _state == State.HEADER;\r\n            LOG.warn(\"{} is too large {}>{}\", header ? \"Header\" : \"Trailer\", _headerBytes, _maxHeaderBytes);\r\n            throw new BadMessageException(header ? HttpStatus.REQUEST_HEADER_FIELDS_TOO_LARGE_431 : HttpStatus.PAYLOAD_TOO_LARGE_413);\r\n        }\r\n        switch(_fieldState) {\r\n            case FIELD:\r\n                switch(t.getType()) {\r\n                    case COLON:\r\n                    case SPACE:\r\n                    case HTAB:\r\n                        {\r\n                            if (complianceViolation(HttpComplianceSection.NO_FIELD_FOLDING, _headerString))\r\n                                throw new BadMessageException(HttpStatus.BAD_REQUEST_400, \"Header Folding\");\r\n                            if (_valueString == null || _valueString.isEmpty()) {\r\n                                _string.setLength(0);\r\n                                _length = 0;\r\n                            } else {\r\n                                setString(_valueString);\r\n                                _string.append(' ');\r\n                                _length++;\r\n                                _valueString = null;\r\n                            }\r\n                            setState(FieldState.VALUE);\r\n                            break;\r\n                        }\r\n                    case LF:\r\n                        {\r\n                            if (_state == State.HEADER)\r\n                                parsedHeader();\r\n                            else\r\n                                parsedTrailer();\r\n                            _contentPosition = 0;\r\n                            if (_state == State.TRAILER) {\r\n                                setState(State.END);\r\n                                return _handler.messageComplete();\r\n                            }\r\n                            if (!_host && _version == HttpVersion.HTTP_1_1 && _requestHandler != null) {\r\n                                throw new BadMessageException(HttpStatus.BAD_REQUEST_400, \"No Host\");\r\n                            }\r\n                            if (_responseHandler != null && (_responseStatus == 304 || _responseStatus == 204 || _responseStatus < 200))\r\n                                _endOfContent = EndOfContent.NO_CONTENT;\r\n                            else if (_endOfContent == EndOfContent.UNKNOWN_CONTENT) {\r\n                                if (_responseStatus == 0 || _responseStatus == 304 || _responseStatus == 204 || _responseStatus < 200)\r\n                                    _endOfContent = EndOfContent.NO_CONTENT;\r\n                                else\r\n                                    _endOfContent = EndOfContent.EOF_CONTENT;\r\n                            }\r\n                            switch(_endOfContent) {\r\n                                case EOF_CONTENT:\r\n                                    {\r\n                                        setState(State.EOF_CONTENT);\r\n                                        boolean handle = _handler.headerComplete();\r\n                                        _headerComplete = true;\r\n                                        return handle;\r\n                                    }\r\n                                case CHUNKED_CONTENT:\r\n                                    {\r\n                                        setState(State.CHUNKED_CONTENT);\r\n                                        boolean handle = _handler.headerComplete();\r\n                                        _headerComplete = true;\r\n                                        return handle;\r\n                                    }\r\n                                case NO_CONTENT:\r\n                                    {\r\n                                        setState(State.END);\r\n                                        return handleHeaderContentMessage();\r\n                                    }\r\n                                default:\r\n                                    {\r\n                                        setState(State.CONTENT);\r\n                                        boolean handle = _handler.headerComplete();\r\n                                        _headerComplete = true;\r\n                                        return handle;\r\n                                    }\r\n                            }\r\n                        }\r\n                    case ALPHA:\r\n                    case DIGIT:\r\n                    case TCHAR:\r\n                        {\r\n                            if (_state == State.HEADER)\r\n                                parsedHeader();\r\n                            else\r\n                                parsedTrailer();\r\n                            if (buffer.hasRemaining()) {\r\n                                HttpField cached_field = _fieldCache == null ? null : _fieldCache.getBest(buffer, -1, buffer.remaining());\r\n                                if (cached_field == null)\r\n                                    cached_field = CACHE.getBest(buffer, -1, buffer.remaining());\r\n                                if (cached_field != null) {\r\n                                    String n = cached_field.getName();\r\n                                    String v = cached_field.getValue();\r\n                                    if (!_compliances.contains(HttpComplianceSection.FIELD_NAME_CASE_INSENSITIVE)) {\r\n                                        String en = BufferUtil.toString(buffer, buffer.position() - 1, n.length(), StandardCharsets.US_ASCII);\r\n                                        if (!n.equals(en)) {\r\n                                            handleViolation(HttpComplianceSection.FIELD_NAME_CASE_INSENSITIVE, en);\r\n                                            n = en;\r\n                                            cached_field = new HttpField(cached_field.getHeader(), n, v);\r\n                                        }\r\n                                    }\r\n                                    if (v != null && !_compliances.contains(HttpComplianceSection.CASE_INSENSITIVE_FIELD_VALUE_CACHE)) {\r\n                                        String ev = BufferUtil.toString(buffer, buffer.position() + n.length() + 1, v.length(), StandardCharsets.ISO_8859_1);\r\n                                        if (!v.equals(ev)) {\r\n                                            handleViolation(HttpComplianceSection.CASE_INSENSITIVE_FIELD_VALUE_CACHE, ev + \"!=\" + v);\r\n                                            v = ev;\r\n                                            cached_field = new HttpField(cached_field.getHeader(), n, v);\r\n                                        }\r\n                                    }\r\n                                    _header = cached_field.getHeader();\r\n                                    _headerString = n;\r\n                                    if (v == null) {\r\n                                        setState(FieldState.VALUE);\r\n                                        _string.setLength(0);\r\n                                        _length = 0;\r\n                                        buffer.position(buffer.position() + n.length() + 1);\r\n                                        break;\r\n                                    }\r\n                                    int pos = buffer.position() + n.length() + v.length() + 1;\r\n                                    byte peek = buffer.get(pos);\r\n                                    if (peek == HttpTokens.CARRIAGE_RETURN || peek == HttpTokens.LINE_FEED) {\r\n                                        _field = cached_field;\r\n                                        _valueString = v;\r\n                                        setState(FieldState.IN_VALUE);\r\n                                        if (peek == HttpTokens.CARRIAGE_RETURN) {\r\n                                            _cr = true;\r\n                                            buffer.position(pos + 1);\r\n                                        } else\r\n                                            buffer.position(pos);\r\n                                        break;\r\n                                    }\r\n                                    setState(FieldState.IN_VALUE);\r\n                                    setString(v);\r\n                                    buffer.position(pos);\r\n                                    break;\r\n                                }\r\n                            }\r\n                            setState(FieldState.IN_NAME);\r\n                            _string.setLength(0);\r\n                            _string.append(t.getChar());\r\n                            _length = 1;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        throw new IllegalCharacterException(_state, t, buffer);\r\n                }\r\n                break;\r\n            case IN_NAME:\r\n                switch(t.getType()) {\r\n                    case SPACE:\r\n                    case HTAB:\r\n                        if (!complianceViolation(HttpComplianceSection.NO_WS_AFTER_FIELD_NAME, null)) {\r\n                            _headerString = takeString();\r\n                            _header = HttpHeader.CACHE.get(_headerString);\r\n                            _length = -1;\r\n                            setState(FieldState.WS_AFTER_NAME);\r\n                            break;\r\n                        }\r\n                        throw new IllegalCharacterException(_state, t, buffer);\r\n                    case COLON:\r\n                        _headerString = takeString();\r\n                        _header = HttpHeader.CACHE.get(_headerString);\r\n                        _length = -1;\r\n                        setState(FieldState.VALUE);\r\n                        break;\r\n                    case LF:\r\n                        _headerString = takeString();\r\n                        _header = HttpHeader.CACHE.get(_headerString);\r\n                        _string.setLength(0);\r\n                        _valueString = \"\";\r\n                        _length = -1;\r\n                        if (!complianceViolation(HttpComplianceSection.FIELD_COLON, _headerString)) {\r\n                            setState(FieldState.FIELD);\r\n                            break;\r\n                        }\r\n                        throw new IllegalCharacterException(_state, t, buffer);\r\n                    case ALPHA:\r\n                    case DIGIT:\r\n                    case TCHAR:\r\n                        _string.append(t.getChar());\r\n                        _length = _string.length();\r\n                        break;\r\n                    default:\r\n                        throw new IllegalCharacterException(_state, t, buffer);\r\n                }\r\n                break;\r\n            case WS_AFTER_NAME:\r\n                switch(t.getType()) {\r\n                    case SPACE:\r\n                    case HTAB:\r\n                        break;\r\n                    case COLON:\r\n                        setState(FieldState.VALUE);\r\n                        break;\r\n                    case LF:\r\n                        if (!complianceViolation(HttpComplianceSection.FIELD_COLON, _headerString)) {\r\n                            setState(FieldState.FIELD);\r\n                            break;\r\n                        }\r\n                        throw new IllegalCharacterException(_state, t, buffer);\r\n                    default:\r\n                        throw new IllegalCharacterException(_state, t, buffer);\r\n                }\r\n                break;\r\n            case VALUE:\r\n                switch(t.getType()) {\r\n                    case LF:\r\n                        _string.setLength(0);\r\n                        _valueString = \"\";\r\n                        _length = -1;\r\n                        setState(FieldState.FIELD);\r\n                        break;\r\n                    case SPACE:\r\n                    case HTAB:\r\n                        break;\r\n                    case ALPHA:\r\n                    case DIGIT:\r\n                    case TCHAR:\r\n                    case VCHAR:\r\n                    case COLON:\r\n                    case OTEXT:\r\n                        _string.append(t.getChar());\r\n                        _length = _string.length();\r\n                        setState(FieldState.IN_VALUE);\r\n                        break;\r\n                    default:\r\n                        throw new IllegalCharacterException(_state, t, buffer);\r\n                }\r\n                break;\r\n            case IN_VALUE:\r\n                switch(t.getType()) {\r\n                    case LF:\r\n                        if (_length > 0) {\r\n                            _valueString = takeString();\r\n                            _length = -1;\r\n                        }\r\n                        setState(FieldState.FIELD);\r\n                        break;\r\n                    case SPACE:\r\n                    case HTAB:\r\n                        _string.append(t.getChar());\r\n                        break;\r\n                    case ALPHA:\r\n                    case DIGIT:\r\n                    case TCHAR:\r\n                    case VCHAR:\r\n                    case COLON:\r\n                    case OTEXT:\r\n                        _string.append(t.getChar());\r\n                        _length = _string.length();\r\n                        break;\r\n                    default:\r\n                        throw new IllegalCharacterException(_state, t, buffer);\r\n                }\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(_state.toString());\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.resolution.TypeSolver.solveType",
	"Comment": "solve the given type. either the type is found and returned or an unsolvedsymbolexception is thrown.",
	"Method": "ResolvedReferenceTypeDeclaration solveType(String name){\r\n    SymbolReference<ReferenceTypeDeclaration> ref = tryToSolveType(name);\r\n    if (ref.isSolved()) {\r\n        return ref.getCorrespondingDeclaration();\r\n    } else {\r\n        throw new UnsolvedSymbolException(name, this);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.MultiMap.getValues",
	"Comment": "get multiple values.single valued entries are converted to singleton lists.",
	"Method": "List<V> getValues(String name){\r\n    List<V> vals = super.get(name);\r\n    if ((vals == null) || vals.isEmpty()) {\r\n        return null;\r\n    }\r\n    return vals;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.resolution.typeinference.ConstraintFormulaSet.reduce",
	"Comment": "takes a compatibility assertion about an expression or type, called a constraint formula, and reduces it to aset of bounds on inference variables. often, a constraint formula reduces to other constraint formulas,which must be recursively reduced. a procedure is followed to identify these additional constraint formulas and,ultimately, to express via a bound set the conditions under which the choices for inferred types would rendereach constraint formula true.",
	"Method": "BoundSet reduce(TypeSolver typeSolver){\r\n    List<ConstraintFormula> constraints = new LinkedList(constraintFormulas);\r\n    BoundSet boundSet = BoundSet.empty();\r\n    while (constraints.size() > 0) {\r\n        ConstraintFormula constraintFormula = constraints.remove(0);\r\n        ConstraintFormula.ReductionResult reductionResult = constraintFormula.reduce(boundSet);\r\n        constraints.addAll(reductionResult.getConstraintFormulas());\r\n        boundSet.incorporate(reductionResult.getBoundSet(), typeSolver);\r\n    }\r\n    return boundSet;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.Node.registerForSubtree",
	"Comment": "register the observer for the current node and all the contained node and nodelists, recursively.",
	"Method": "void registerForSubtree(AstObserver observer){\r\n    register(observer);\r\n    this.getChildNodes().forEach(c -> c.registerForSubtree(observer));\r\n    for (PropertyMetaModel property : getMetaModel().getAllPropertyMetaModels()) {\r\n        if (property.isNodeList()) {\r\n            NodeList<?> nodeList = (NodeList<?>) property.getValue(this);\r\n            if (nodeList != null)\r\n                nodeList.register(observer);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.SessionHandler.sessionInactivityTimerExpired",
	"Comment": "each session has a timer that is configured to go offwhen either the session has not been accessed for a configurable amount of time, or the session itselfhas passed its expiry.",
	"Method": "void sessionInactivityTimerExpired(Session session){\r\n    if (session == null)\r\n        return;\r\n    boolean expired = false;\r\n    try (Lock lock = session.lockIfNotHeld()) {\r\n        if (session.getRequests() > 0)\r\n            return;\r\n        if (LOG.isDebugEnabled())\r\n            LOG.debug(\"Inspecting session {}, valid={}\", session.getId(), session.isValid());\r\n        if (!session.isValid())\r\n            return;\r\n        if (session.isExpiredAt(System.currentTimeMillis()) && session.getRequests() <= 0)\r\n            expired = true;\r\n    }\r\n    if (expired) {\r\n        if (_sessionIdManager.getSessionHouseKeeper() != null && _sessionIdManager.getSessionHouseKeeper().getIntervalSec() > 0) {\r\n            _candidateSessionIdsForExpiry.add(session.getId());\r\n            if (LOG.isDebugEnabled())\r\n                LOG.debug(\"Session {} is candidate for expiry\", session.getId());\r\n        }\r\n    } else\r\n        _sessionCache.checkInactiveSession(session);\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.ServiceWebAppProvider.serviceAdded",
	"Comment": "a webapp that was deployed as an osgi service has been added,and we want to deploy it.",
	"Method": "boolean serviceAdded(ServiceReference serviceRef,ContextHandler context){\r\n    if (context == null || !(context instanceof WebAppContext))\r\n        return false;\r\n    String watermark = (String) serviceRef.getProperty(OSGiWebappConstants.WATERMARK);\r\n    if (watermark != null && !\"\".equals(watermark))\r\n        return false;\r\n    WebAppContext webApp = (WebAppContext) context;\r\n    Dictionary<String, String> properties = new Hashtable();\r\n    String contextPath = (String) serviceRef.getProperty(OSGiWebappConstants.RFC66_WEB_CONTEXTPATH);\r\n    if (contextPath == null)\r\n        contextPath = (String) serviceRef.getProperty(OSGiWebappConstants.SERVICE_PROP_CONTEXT_PATH);\r\n    if (contextPath == null)\r\n        return false;\r\n    String base = (String) serviceRef.getProperty(OSGiWebappConstants.JETTY_WAR_FOLDER_PATH);\r\n    if (base == null)\r\n        base = (String) serviceRef.getProperty(OSGiWebappConstants.JETTY_WAR_RESOURCE_PATH);\r\n    if (base == null)\r\n        base = (String) serviceRef.getProperty(OSGiWebappConstants.SERVICE_PROP_WAR);\r\n    if (base == null)\r\n        return false;\r\n    String webdefaultXml = (String) serviceRef.getProperty(OSGiWebappConstants.JETTY_DEFAULT_WEB_XML_PATH);\r\n    if (webdefaultXml == null)\r\n        webdefaultXml = (String) serviceRef.getProperty(OSGiWebappConstants.SERVICE_PROP_DEFAULT_WEB_XML_PATH);\r\n    if (webdefaultXml != null)\r\n        properties.put(OSGiWebappConstants.JETTY_DEFAULT_WEB_XML_PATH, webdefaultXml);\r\n    String webXml = (String) serviceRef.getProperty(OSGiWebappConstants.JETTY_WEB_XML_PATH);\r\n    if (webXml == null)\r\n        webXml = (String) serviceRef.getProperty(OSGiWebappConstants.SERVICE_PROP_WEB_XML_PATH);\r\n    if (webXml != null)\r\n        properties.put(OSGiWebappConstants.JETTY_WEB_XML_PATH, webXml);\r\n    String extraClassPath = (String) serviceRef.getProperty(OSGiWebappConstants.JETTY_EXTRA_CLASSPATH);\r\n    if (extraClassPath == null)\r\n        extraClassPath = (String) serviceRef.getProperty(OSGiWebappConstants.SERVICE_PROP_EXTRA_CLASSPATH);\r\n    if (extraClassPath != null)\r\n        properties.put(OSGiWebappConstants.JETTY_EXTRA_CLASSPATH, extraClassPath);\r\n    String bundleInstallOverride = (String) serviceRef.getProperty(OSGiWebappConstants.JETTY_BUNDLE_INSTALL_LOCATION_OVERRIDE);\r\n    if (bundleInstallOverride == null)\r\n        bundleInstallOverride = (String) serviceRef.getProperty(OSGiWebappConstants.SERVICE_PROP_BUNDLE_INSTALL_LOCATION_OVERRIDE);\r\n    if (bundleInstallOverride != null)\r\n        properties.put(OSGiWebappConstants.JETTY_BUNDLE_INSTALL_LOCATION_OVERRIDE, bundleInstallOverride);\r\n    String requiredTlds = (String) serviceRef.getProperty(OSGiWebappConstants.REQUIRE_TLD_BUNDLE);\r\n    if (requiredTlds == null)\r\n        requiredTlds = (String) serviceRef.getProperty(OSGiWebappConstants.SERVICE_PROP_REQUIRE_TLD_BUNDLE);\r\n    if (requiredTlds != null)\r\n        properties.put(OSGiWebappConstants.REQUIRE_TLD_BUNDLE, requiredTlds);\r\n    ClassLoader cl = Thread.currentThread().getContextClassLoader();\r\n    Thread.currentThread().setContextClassLoader(getServerInstanceWrapper().getParentClassLoaderForWebapps());\r\n    try {\r\n        String originId = getOriginId(serviceRef.getBundle(), base);\r\n        ServiceApp app = new ServiceApp(getDeploymentManager(), this, serviceRef.getBundle(), properties, originId);\r\n        app.setContextPath(contextPath);\r\n        app.setWebAppPath(base);\r\n        app.setWebAppContext(webApp);\r\n        _serviceMap.put(serviceRef, app);\r\n        getDeploymentManager().addApp(app);\r\n        return true;\r\n    } finally {\r\n        Thread.currentThread().setContextClassLoader(cl);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.IPAddressMap.get",
	"Comment": "retrieve the object mapped to the specified internet address literal",
	"Method": "TYPE get(Object key){\r\n    return super.get(key);\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration.getId",
	"Comment": "the id corresponds most of the type to the qualified name. it differs only for localclasses which do not have a qualified name but have an id.",
	"Method": "String getId(){\r\n    String qname = getQualifiedName();\r\n    if (qname == null) {\r\n        return String.format(\"<localClass>:%s\", getName());\r\n    }\r\n    return qname;\r\n}"
}, {
	"Path": "com.github.javaparser.utils.SourceRoot.saveAll",
	"Comment": "save all previously parsed files back to where they were found.",
	"Method": "SourceRoot saveAll(Path root,SourceRoot saveAll){\r\n    return saveAll(root);\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration.getAllNonStaticFields",
	"Comment": "return a list of all the non static fields, either declared or inherited.",
	"Method": "List<ResolvedFieldDeclaration> getAllNonStaticFields(){\r\n    return getAllFields().stream().filter(it -> !it.isStatic()).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.IncludedServletTest.getPotentialBody",
	"Comment": "attempt to obtain the body text if available. do not throw an exception if body is unable to be fetched.",
	"Method": "String getPotentialBody(HttpURLConnection connection){\r\n    InputStream in = null;\r\n    InputStreamReader reader = null;\r\n    try {\r\n        in = connection.getInputStream();\r\n        reader = new InputStreamReader(in);\r\n        StringWriter writer = new StringWriter();\r\n        IO.copy(reader, writer);\r\n        return writer.toString();\r\n    } catch (IOException e) {\r\n        return \"<no body:\" + e.getMessage() + \">\";\r\n    } finally {\r\n        IO.close(reader);\r\n        IO.close(in);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlets.QoSFilter.getMaxRequests",
	"Comment": "get the maximum number of requests allowed to be processedat the same time.",
	"Method": "int getMaxRequests(){\r\n    return _maxRequests;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getVisibleField",
	"Comment": "consider only field or inherited field which is not private.",
	"Method": "FieldDeclaration getVisibleField(String name){\r\n    Optional<FieldDeclaration> field = getVisibleFields().stream().filter(f -> f.getName().equals(name)).findFirst();\r\n    if (field.isPresent()) {\r\n        return field.get();\r\n    } else {\r\n        throw new IllegalArgumentException();\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.ast.Node.getAllContainedComments",
	"Comment": "this is the list of comment which are contained in the node either becausethey are properly associated to one of its children or because they are floatingaround inside the node",
	"Method": "List<Comment> getAllContainedComments(){\r\n    List<Comment> comments = new LinkedList<Comment>();\r\n    comments.addAll(getOrphanComments());\r\n    for (Node child : getChildrenNodes()) {\r\n        if (child.getComment() != null) {\r\n            comments.add(child.getComment());\r\n        }\r\n        comments.addAll(child.getAllContainedComments());\r\n    }\r\n    return comments;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.log.Log.setLog",
	"Comment": "set the root logger.note that if any classes have statically obtained their logger instance prior to this call, their logger will notbe affected by this call.",
	"Method": "void setLog(Logger log){\r\n    Log.LOG = log;\r\n    __logClass = null;\r\n}"
}, {
	"Path": "net.bull.javamelody.swing.util.SpringUtilities.makeGrid",
	"Comment": "aligns the first rowscols\tcomponents of parent in\ta grid. each component is as big as the maximum\tpreferred width and height of the components.\tthe parent is made just big enough to fit them all.",
	"Method": "void makeGrid(Container parent,int rows,int cols,int initialX,int initialY,int xPad,int yPad){\r\n    final SpringLayout layout;\r\n    try {\r\n        layout = (SpringLayout) parent.getLayout();\r\n    } catch (final ClassCastException exc) {\r\n        throw new IllegalArgumentException(\"The first argument to makeGrid must use SpringLayout.\", exc);\r\n    }\r\n    final Spring xPadSpring = Spring.constant(xPad);\r\n    final Spring yPadSpring = Spring.constant(yPad);\r\n    final Spring initialXSpring = Spring.constant(initialX);\r\n    final Spring initialYSpring = Spring.constant(initialY);\r\n    final int max = rows * cols;\r\n    Spring maxWidthSpring = layout.getConstraints(parent.getComponent(0)).getWidth();\r\n    Spring maxHeightSpring = layout.getConstraints(parent.getComponent(0)).getWidth();\r\n    for (int i = 1; i < max; i++) {\r\n        final SpringLayout.Constraints cons = layout.getConstraints(parent.getComponent(i));\r\n        maxWidthSpring = Spring.max(maxWidthSpring, cons.getWidth());\r\n        maxHeightSpring = Spring.max(maxHeightSpring, cons.getHeight());\r\n    }\r\n    for (int i = 0; i < max; i++) {\r\n        final SpringLayout.Constraints cons = layout.getConstraints(parent.getComponent(i));\r\n        cons.setWidth(maxWidthSpring);\r\n        cons.setHeight(maxHeightSpring);\r\n    }\r\n    SpringLayout.Constraints lastCons = null;\r\n    SpringLayout.Constraints lastRowCons = null;\r\n    for (int i = 0; i < max; i++) {\r\n        final SpringLayout.Constraints cons = layout.getConstraints(parent.getComponent(i));\r\n        if (i % cols == 0) {\r\n            lastRowCons = lastCons;\r\n            cons.setX(initialXSpring);\r\n        } else {\r\n            cons.setX(Spring.sum(lastCons.getConstraint(SpringLayout.EAST), xPadSpring));\r\n        }\r\n        if (i / cols == 0) {\r\n            cons.setY(initialYSpring);\r\n        } else {\r\n            cons.setY(Spring.sum(lastRowCons.getConstraint(SpringLayout.SOUTH), yPadSpring));\r\n        }\r\n        lastCons = cons;\r\n    }\r\n    final SpringLayout.Constraints pCons = layout.getConstraints(parent);\r\n    pCons.setConstraint(SpringLayout.SOUTH, Spring.sum(Spring.constant(yPad), lastCons.getConstraint(SpringLayout.SOUTH)));\r\n    pCons.setConstraint(SpringLayout.EAST, Spring.sum(Spring.constant(xPad), lastCons.getConstraint(SpringLayout.EAST)));\r\n}"
}, {
	"Path": "org.javaee7.jaspictest.dispatching.CDIForwardTest.testCDIForwardWithRequestPublic",
	"Comment": "tests that the forwarded resource has the correct servlet path",
	"Method": "void testCDIForwardWithRequestPublic(){\r\n    String response = getFromServerPath(\"public/servlet\");\r\n    assertTrue(\"Servletpath reported by servlet request after forward from SAM not as expected.\", response.contains(\"servletPath via Servlet - /forwardedServlet\"));\r\n}"
}, {
	"Path": "com.github.javaparser.ASTHelper.addArgument",
	"Comment": "adds the given argument to the method call. the list of arguments will beinitialized if it is null.",
	"Method": "void addArgument(MethodCallExpr call,Expression arg){\r\n    List<Expression> args = call.getArgs();\r\n    if (args == null) {\r\n        args = new ArrayList<Expression>();\r\n        call.setArgs(args);\r\n    }\r\n    args.add(arg);\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.Declaration.asMethod",
	"Comment": "return this as a methoddeclaration or throw an unsupportedoperationexception",
	"Method": "MethodDeclaration asMethod(){\r\n    throw new UnsupportedOperationException(String.format(\"%s is not a MethodDeclaration\", this));\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getTypeParametersMap",
	"Comment": "get the values for all type parameters declared on this type.in case of raw types the values correspond to typevariables.",
	"Method": "List<Tuple2<TypeParameterDeclaration, Type>> getTypeParametersMap(){\r\n    List<Tuple2<TypeParameterDeclaration, Type>> typeParametersMap = new ArrayList();\r\n    if (!isRawType()) {\r\n        for (int i = 0; i < typeDeclaration.getTypeParameters().size(); i++) {\r\n            typeParametersMap.add(new Tuple2(typeDeclaration.getTypeParameters().get(0), typeParametersValues().get(i)));\r\n        }\r\n    }\r\n    return typeParametersMap;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.type.ArrayType.wrapInArrayTypes",
	"Comment": "takes lists of arraybracketpairs, assumes the lists are ordered left to right and the pairs are ordered left to right, mirroring the actual code.the type gets wrapped in arraytypes so that the outermost arraytype corresponds to the rightmost arraybracketpair.",
	"Method": "Type wrapInArrayTypes(Type type,List<ArrayBracketPair> arrayBracketPairLists){\r\n    for (int i = arrayBracketPairLists.length - 1; i >= 0; i--) {\r\n        final List<ArrayBracketPair> arrayBracketPairList = arrayBracketPairLists[i];\r\n        if (arrayBracketPairList != null) {\r\n            for (int j = arrayBracketPairList.size() - 1; j >= 0; j--) {\r\n                type = new ArrayType(type, arrayBracketPairList.get(j).getAnnotations());\r\n            }\r\n        }\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "com.github.javaparser.JavaParser.parseModuleDeclaration",
	"Comment": "parses a module declaration and returns it as a moduledeclaration.",
	"Method": "ModuleDeclaration parseModuleDeclaration(String moduleDeclaration){\r\n    return simplifiedParse(MODULE_DECLARATION, provider(moduleDeclaration));\r\n}"
}, {
	"Path": "org.eclipse.jetty.annotations.ResourceAnnotationHandler.supportsResourceInjection",
	"Comment": "check if the given class is one that the specification allows to have a resource annotation.",
	"Method": "boolean supportsResourceInjection(Class<?> c){\r\n    if (javax.servlet.Servlet.class.isAssignableFrom(c) || javax.servlet.Filter.class.isAssignableFrom(c) || javax.servlet.ServletContextListener.class.isAssignableFrom(c) || javax.servlet.ServletContextAttributeListener.class.isAssignableFrom(c) || javax.servlet.ServletRequestListener.class.isAssignableFrom(c) || javax.servlet.ServletRequestAttributeListener.class.isAssignableFrom(c) || javax.servlet.http.HttpSessionListener.class.isAssignableFrom(c) || javax.servlet.http.HttpSessionAttributeListener.class.isAssignableFrom(c) || javax.servlet.http.HttpSessionIdListener.class.isAssignableFrom(c) || javax.servlet.AsyncListener.class.isAssignableFrom(c) || javax.servlet.http.HttpUpgradeHandler.class.isAssignableFrom(c))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedDeclaration.asField",
	"Comment": "return this as a fielddeclaration or throw an unsupportedoperationexception",
	"Method": "ResolvedFieldDeclaration asField(){\r\n    throw new UnsupportedOperationException(String.format(\"%s is not a FieldDeclaration\", this));\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.hasAnnotation",
	"Comment": "has the type at least one annotation declared or inherited having the specified qualified name?",
	"Method": "boolean hasAnnotation(String qualifiedName){\r\n    if (hasDirectlyAnnotation(qualifiedName)) {\r\n        return true;\r\n    }\r\n    return getAllAncestors().stream().anyMatch(it -> it.asReferenceType().getTypeDeclaration().hasDirectlyAnnotation(qualifiedName));\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.types.ResolvedType.mention",
	"Comment": "does this type mention at all, directly or indirectly, the given type parameters?",
	"Method": "boolean mention(List<ResolvedTypeParameterDeclaration> typeParameters){\r\n    throw new UnsupportedOperationException(this.getClass().getCanonicalName());\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.hasVisibleField",
	"Comment": "either a declared field or inherited field which is not private.",
	"Method": "boolean hasVisibleField(String name){\r\n    return getVisibleFields().stream().filter(f -> f.getName().equals(name)).findFirst().isPresent();\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.utils.OSGiClassLoader.getResource",
	"Comment": "get a resource from the classloadercopied from webappclassloader",
	"Method": "URL getResource(String name){\r\n    URL url = null;\r\n    boolean tried_parent = false;\r\n    if (url == null) {\r\n        url = _osgiBundleClassLoader.getResource(name);\r\n        if (url == null && name.startsWith(\"/\")) {\r\n            if (LOG.isDebugEnabled())\r\n                LOG.debug(\"HACK leading / off \" + name);\r\n            url = _osgiBundleClassLoader.getResource(name.substring(1));\r\n        }\r\n    }\r\n    if (url == null && !tried_parent) {\r\n        if (_parent != null)\r\n            url = _parent.getResource(name);\r\n    }\r\n    if (url != null)\r\n        if (LOG.isDebugEnabled())\r\n            LOG.debug(\"getResource(\" + name + \")=\" + url);\r\n    return url;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField",
	"Comment": "add a field to this and automatically add the import of the type if needed",
	"Method": "FieldDeclaration addField(Class<?> typeClass,String name,Modifier modifiers,FieldDeclaration addField,String type,String name,Modifier modifiers,FieldDeclaration addField,Type type,String name,Modifier modifiers){\r\n    FieldDeclaration fieldDeclaration = new FieldDeclaration();\r\n    fieldDeclaration.setParentNode((Node) this);\r\n    VariableDeclarator variable = new VariableDeclarator(new VariableDeclaratorId(name));\r\n    fieldDeclaration.getVariables().add(variable);\r\n    variable.setParentNode(fieldDeclaration);\r\n    fieldDeclaration.setModifiers(Arrays.stream(modifiers).collect(toCollection(() -> EnumSet.noneOf(Modifier.class))));\r\n    variable.setType(type);\r\n    getMembers().add(fieldDeclaration);\r\n    return fieldDeclaration;\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.DispatcherForwardTest.checkThat",
	"Comment": "replacement for assert that allows to check failures after the response has been sent.",
	"Method": "void checkThat(S item,Matcher<S> matcher){\r\n    try {\r\n        assertThat(item, matcher);\r\n    } catch (Throwable th) {\r\n        failures.add(th);\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.MethodUsage.getParamType",
	"Comment": "return the type of the formal argument at the given position.",
	"Method": "ResolvedType getParamType(int i){\r\n    return paramTypes.get(i);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.ContextHandler.addVirtualHosts",
	"Comment": "either set virtual hosts or add to an existing set of virtual hosts.",
	"Method": "void addVirtualHosts(String[] virtualHosts){\r\n    if (virtualHosts == null || virtualHosts.length == 0)\r\n        return;\r\n    if (_vhosts == null) {\r\n        setVirtualHosts(virtualHosts);\r\n    } else {\r\n        Set<String> currentVirtualHosts = new HashSet<String>(Arrays.asList(getVirtualHosts()));\r\n        for (String vh : virtualHosts) currentVirtualHosts.add(normalizeHostname(vh));\r\n        setVirtualHosts(currentVirtualHosts.toArray(new String[0]));\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.core.resolution.Context.solveMethodAsUsage",
	"Comment": "similar to solvemethod but we return a methodusage. a methodusage corresponds to a methoddeclaration plus theresolved type variables.",
	"Method": "Optional<MethodUsage> solveMethodAsUsage(String name,List<ResolvedType> argumentsTypes){\r\n    SymbolReference<MethodDeclaration> methodSolved = solveMethod(name, argumentsTypes, false, typeSolver);\r\n    if (methodSolved.isSolved()) {\r\n        MethodDeclaration methodDeclaration = methodSolved.getCorrespondingDeclaration();\r\n        MethodUsage methodUsage = ContextHelper.resolveTypeVariables(this, methodDeclaration, argumentsTypes);\r\n        return Optional.of(methodUsage);\r\n    } else {\r\n        return Optional.empty();\r\n    }\r\n}"
}, {
	"Path": "net.bull.javamelody.EmbeddedServer.start",
	"Comment": "start the server with a http port and optional javamelody parameters.",
	"Method": "void start(int port,Map<Parameter, String> parameters){\r\n    server = new Server(port);\r\n    final ContextHandlerCollection contexts = new ContextHandlerCollection();\r\n    final ServletContextHandler context = new ServletContextHandler(contexts, \"/\", ServletContextHandler.SESSIONS);\r\n    final net.bull.javamelody.MonitoringFilter monitoringFilter = new net.bull.javamelody.MonitoringFilter();\r\n    monitoringFilter.setApplicationType(\"Standalone\");\r\n    final FilterHolder filterHolder = new FilterHolder(monitoringFilter);\r\n    if (parameters != null) {\r\n        for (final Map.Entry<Parameter, String> entry : parameters.entrySet()) {\r\n            final net.bull.javamelody.Parameter parameter = entry.getKey();\r\n            final String value = entry.getValue();\r\n            filterHolder.setInitParameter(parameter.getCode(), value);\r\n        }\r\n    }\r\n    context.addFilter(filterHolder, \"/*\", EnumSet.of(DispatcherType.INCLUDE, DispatcherType.REQUEST));\r\n    final RequestLogHandler requestLogHandler = new RequestLogHandler();\r\n    contexts.addHandler(requestLogHandler);\r\n    final HandlerCollection handlers = new HandlerCollection();\r\n    handlers.setHandlers(new Handler[] { contexts });\r\n    server.setHandler(handlers);\r\n    server.start();\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet.performResolution",
	"Comment": "examines the bounds on an inference variable and determines an instantiation that is compatible with thosebounds. it also decides the order in which interdependent inference variables are to be resolved.",
	"Method": "Optional<InstantiationSet> performResolution(List<InferenceVariable> variablesToResolve,TypeSolver typeSolver){\r\n    if (this.containsFalse()) {\r\n        return Optional.empty();\r\n    }\r\n    List<VariableDependency> dependencies = new LinkedList();\r\n    for (Bound b : bounds) {\r\n        if (b instanceof CapturesBound) {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    }\r\n    for (Bound b : bounds) {\r\n        if (b instanceof CapturesBound) {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    }\r\n    for (int i = 0; i < dependencies.size(); i++) {\r\n        VariableDependency di = dependencies.get(i);\r\n        for (int j = i + 1; j < dependencies.size(); j++) {\r\n            VariableDependency dj = dependencies.get(j);\r\n            if (di.dependedOn.equals(dj.depending)) {\r\n                dependencies.add(new VariableDependency(di.getDepending(), dj.getDependedOn()));\r\n            }\r\n        }\r\n    }\r\n    for (InferenceVariable v : allInferenceVariables()) {\r\n        dependencies.add(new VariableDependency(v, v));\r\n    }\r\n    Set<InferenceVariable> V = new HashSet();\r\n    V.addAll(variablesToResolve);\r\n    for (VariableDependency dependency : dependencies) {\r\n        if (variablesToResolve.contains(dependency.depending)) {\r\n            V.add(dependency.dependedOn);\r\n        }\r\n    }\r\n    boolean ok = true;\r\n    for (InferenceVariable v : V) {\r\n        if (!hasInstantiationFor(v)) {\r\n            ok = false;\r\n        }\r\n    }\r\n    if (ok) {\r\n        InstantiationSet instantiationSet = InstantiationSet.empty();\r\n        for (InferenceVariable v : V) {\r\n            instantiationSet = instantiationSet.withInstantiation(getInstantiationFor(v));\r\n        }\r\n        return Optional.of(instantiationSet);\r\n    }\r\n    Set<InferenceVariable> uninstantiatedPortionOfV = new HashSet();\r\n    for (InferenceVariable v : V) {\r\n        if (!hasInstantiationFor(v)) {\r\n            uninstantiatedPortionOfV.add(v);\r\n        }\r\n    }\r\n    for (Set<InferenceVariable> alphas : allSetsWithProperty(uninstantiatedPortionOfV, dependencies)) {\r\n        boolean hasSomeCaptureForAlphas = alphas.stream().anyMatch(alphaI -> appearInLeftPartOfCapture(alphaI));\r\n        if (!hasSomeCaptureForAlphas) {\r\n            BoundSet newBounds = BoundSet.empty();\r\n            for (InferenceVariable alphaI : alphas) {\r\n                Set<ResolvedType> properLowerBounds = bounds.stream().filter(b -> b.isProperLowerBoundFor(alphaI).isPresent()).map(b -> b.isProperLowerBoundFor(alphaI).get().getProperType()).collect(Collectors.toSet());\r\n                ResolvedType Ti = null;\r\n                if (properLowerBounds.size() > 0) {\r\n                    Ti = leastUpperBound(properLowerBounds);\r\n                }\r\n                boolean throwsBound = bounds.stream().anyMatch(b -> b.isThrowsBoundOn(alphaI));\r\n                if (Ti == null && throwsBound && properUpperBoundsAreAtMostExceptionThrowableAndObject(alphaI)) {\r\n                    Ti = new ReferenceTypeImpl(typeSolver.solveType(RuntimeException.class.getCanonicalName()), typeSolver);\r\n                }\r\n                if (Ti == null) {\r\n                    Set<ResolvedType> properUpperBounds = bounds.stream().filter(b -> b.isProperUpperBoundFor(alphaI).isPresent()).map(b -> b.isProperUpperBoundFor(alphaI).get().getProperType()).collect(Collectors.toSet());\r\n                    if (properUpperBounds.size() == 0) {\r\n                        throw new IllegalStateException();\r\n                    }\r\n                    Ti = glb(properUpperBounds);\r\n                }\r\n                newBounds = newBounds.withBound(new SameAsBound(alphaI, Ti));\r\n            }\r\n            BoundSet incorporatedBoundSet = this.incorporate(newBounds, typeSolver);\r\n            if (!incorporatedBoundSet.containsFalse()) {\r\n                return incorporatedBoundSet.performResolution(variablesToResolve, typeSolver);\r\n            }\r\n            throw new UnsupportedOperationException();\r\n        } else {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.client.WebSocketClient.setMaxIdleTimeout",
	"Comment": "set the max idle timeout for new connections.existing connections will not have their max idle timeout adjusted.",
	"Method": "void setMaxIdleTimeout(long ms){\r\n    getPolicy().setIdleTimeout(ms);\r\n    this.httpClient.setIdleTimeout(ms);\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.ssl.SslContextFactory.selectCipherSuites",
	"Comment": "select cipher suites to be used by the connectorbased on configured inclusion and exclusion listsas well as enabled and supported cipher suite lists.",
	"Method": "void selectCipherSuites(String[] enabledCipherSuites,String[] supportedCipherSuites){\r\n    List<String> selected_ciphers = new ArrayList();\r\n    if (_includeCipherSuites.isEmpty())\r\n        selected_ciphers.addAll(Arrays.asList(enabledCipherSuites));\r\n    else\r\n        processIncludeCipherSuites(supportedCipherSuites, selected_ciphers);\r\n    removeExcludedCipherSuites(selected_ciphers);\r\n    if (selected_ciphers.isEmpty())\r\n        LOG.warn(\"No supported ciphers from {}\", Arrays.asList(supportedCipherSuites));\r\n    Comparator<String> comparator = getCipherComparator();\r\n    if (comparator != null) {\r\n        if (LOG.isDebugEnabled())\r\n            LOG.debug(\"Sorting selected ciphers with {}\", comparator);\r\n        selected_ciphers.sort(comparator);\r\n    }\r\n    _selectedCipherSuites = selected_ciphers.toArray(new String[0]);\r\n}"
}, {
	"Path": "org.eclipse.jetty.security.PropertyUserStore.doStart",
	"Comment": "depending on the value of the refresh interval, this method will either startup a scanner thread that will monitor the properties file for changes afterit has initially loaded it. otherwise the users will be loaded and there willbe no active monitoring thread so changes will not be detected.",
	"Method": "void doStart(){\r\n    super.doStart();\r\n    loadUsers();\r\n    if (isHotReload() && (_configPath != null)) {\r\n        this._pathWatcher = new PathWatcher();\r\n        this._pathWatcher.watch(_configPath);\r\n        this._pathWatcher.addListener(this);\r\n        this._pathWatcher.setNotifyExistingOnStart(false);\r\n        this._pathWatcher.start();\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.ParserConfiguration.setLexicalPreservationEnabled",
	"Comment": "disabled by default.when this is enabled, lexicalpreservingprinter.print can be used to reproducethe original formatting of the file.",
	"Method": "ParserConfiguration setLexicalPreservationEnabled(boolean lexicalPreservationEnabled){\r\n    this.lexicalPreservationEnabled = lexicalPreservationEnabled;\r\n    return this;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solve",
	"Comment": "given a method call find out to which method declaration it corresponds.",
	"Method": "SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr,SymbolReference<? extends ResolvedValueDeclaration> solve,SimpleName nameExpr,SymbolReference<? extends ResolvedValueDeclaration> solve,Expression expr,SymbolReference<ResolvedMethodDeclaration> solve,MethodCallExpr methodCallExpr,SymbolReference<ResolvedConstructorDeclaration> solve,ObjectCreationExpr objectCreationExpr,SymbolReference<ResolvedConstructorDeclaration> solve,ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt,SymbolReference<ResolvedConstructorDeclaration> solve,ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt,boolean solveLambdas,SymbolReference<ResolvedTypeDeclaration> solve,ThisExpr node,SymbolReference<ResolvedConstructorDeclaration> solve,ObjectCreationExpr objectCreationExpr,boolean solveLambdas,SymbolReference<ResolvedMethodDeclaration> solve,MethodCallExpr methodCallExpr,boolean solveLambdas,SymbolReference<ResolvedAnnotationDeclaration> solve,AnnotationExpr annotationExpr,SymbolReference<ResolvedValueDeclaration> solve,FieldAccessExpr fieldAccessExpr){\r\n    Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\r\n    SymbolReference<TypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString(), typeSolver);\r\n    AnnotationDeclaration annotationDeclaration = (AnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\r\n    if (typeDeclarationSymbolReference.isSolved()) {\r\n        return SymbolReference.solved(annotationDeclaration);\r\n    } else {\r\n        return SymbolReference.unsolved(AnnotationDeclaration.class);\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.ast.body.TypeDeclaration.addMember",
	"Comment": "adds the given declaration to the specified type. the list of members\twill be initialized if it is null.",
	"Method": "T addMember(BodyDeclaration<?> decl){\r\n    List<BodyDeclaration<?>> members = getMembers();\r\n    if (isNullOrEmpty(members)) {\r\n        members = new ArrayList();\r\n        setMembers(members);\r\n    }\r\n    members.add(decl);\r\n    decl.setParentNode(this);\r\n    return this;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.getId",
	"Comment": "id of the declaration. it corresponds to the qualified name, unless for local classes.",
	"Method": "String getId(){\r\n    return typeDeclaration.getId();\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration.getAllStaticFields",
	"Comment": "return a list of all the static fields, either declared or inherited.",
	"Method": "List<ResolvedFieldDeclaration> getAllStaticFields(){\r\n    return getAllFields().stream().filter(it -> it.isStatic()).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.log.StdErrLogTest.testParameterizedMessage_NullValues",
	"Comment": "test to make sure that using a null parameter on parameterized messages does not result in a npe",
	"Method": "void testParameterizedMessage_NullValues(){\r\n    StdErrLog log = new StdErrLog(StdErrLogTest.class.getName(), new Properties());\r\n    log.setLevel(StdErrLog.LEVEL_DEBUG);\r\n    try (StacklessLogging stackless = new StacklessLogging(log)) {\r\n        log.info(\"Testing info(msg,null,null) - {} {}\", \"arg0\", \"arg1\");\r\n        log.info(\"Testing info(msg,null,null) - {} {}\", null, null);\r\n        log.info(\"Testing info(msg,null,null) - {}\", null, null);\r\n        log.info(\"Testing info(msg,null,null)\", null, null);\r\n        log.info(null, \"Testing\", \"info(null,arg0,arg1)\");\r\n        log.info(null, null, null);\r\n        log.debug(\"Testing debug(msg,null,null) - {} {}\", \"arg0\", \"arg1\");\r\n        log.debug(\"Testing debug(msg,null,null) - {} {}\", null, null);\r\n        log.debug(\"Testing debug(msg,null,null) - {}\", null, null);\r\n        log.debug(\"Testing debug(msg,null,null)\", null, null);\r\n        log.debug(null, \"Testing\", \"debug(null,arg0,arg1)\");\r\n        log.debug(null, null, null);\r\n        log.debug(\"Testing debug(msg,null)\");\r\n        log.debug(null, new Throwable(\"Testing debug(null,thrw)\").fillInStackTrace());\r\n        log.warn(\"Testing warn(msg,null,null) - {} {}\", \"arg0\", \"arg1\");\r\n        log.warn(\"Testing warn(msg,null,null) - {} {}\", null, null);\r\n        log.warn(\"Testing warn(msg,null,null) - {}\", null, null);\r\n        log.warn(\"Testing warn(msg,null,null)\", null, null);\r\n        log.warn(null, \"Testing\", \"warn(msg,arg0,arg1)\");\r\n        log.warn(null, null, null);\r\n        log.warn(\"Testing warn(msg,null)\");\r\n        log.warn(null, new Throwable(\"Testing warn(msg,thrw)\").fillInStackTrace());\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.DateCache.formatNow",
	"Comment": "format a date according to our stored formatter.the passed time is expected to be close to the current time, so it is compared to the last value passed and if it is within the same second,the format is reused.otherwise a new cached format is created.",
	"Method": "String formatNow(long now){\r\n    long seconds = now / 1000;\r\n    Tick tick = _tick;\r\n    if (tick != null && tick._seconds == seconds)\r\n        return tick._string;\r\n    return formatTick(now)._string;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.jsr356.server.ConfiguratorTest.testOverrideConfigurator",
	"Comment": "test that a provided serverendpointconfig can override the annotation configurator",
	"Method": "void testOverrideConfigurator(){\r\n    URI uri = baseServerUri.resolve(\"/config-override\");\r\n    BlockheadClientRequest request = client.newWsRequest(uri);\r\n    Future<BlockheadConnection> connFut = request.sendAsync();\r\n    try (BlockheadConnection clientConn = connFut.get(Timeouts.CONNECT, Timeouts.CONNECT_UNIT)) {\r\n        clientConn.write(new TextFrame().setPayload(\"tellme\"));\r\n        LinkedBlockingQueue<WebSocketFrame> frames = clientConn.getFrameQueue();\r\n        WebSocketFrame frame = frames.poll(Timeouts.POLL_EVENT, Timeouts.POLL_EVENT_UNIT);\r\n        assertThat(\"Frame Response\", frame.getPayloadAsUTF8(), is(\"UserProperties[self.configurator] = \" + ConfigOverrideConfigurator.class.getName()));\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.component.ContainerLifeCycle.doStart",
	"Comment": "starts the managed lifecycle beans in the order they were added.",
	"Method": "void doStart(){\r\n    if (_destroyed)\r\n        throw new IllegalStateException(\"Destroyed container cannot be restarted\");\r\n    _doStarted = true;\r\n    for (Bean b : _beans) {\r\n        if (b._bean instanceof LifeCycle) {\r\n            LifeCycle l = (LifeCycle) b._bean;\r\n            switch(b._managed) {\r\n                case MANAGED:\r\n                    if (!l.isRunning())\r\n                        start(l);\r\n                    break;\r\n                case AUTO:\r\n                    if (l.isRunning())\r\n                        unmanage(b);\r\n                    else {\r\n                        manage(b);\r\n                        start(l);\r\n                    }\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    super.doStart();\r\n}"
}, {
	"Path": "com.github.javaparser.ast.stmt.IfStmt.hasCascadingIfStmt",
	"Comment": "this method returns true if the if statement has an else branch and that branch is another if statement.",
	"Method": "boolean hasCascadingIfStmt(){\r\n    return elseStmt instanceof IfStmt;\r\n}"
}, {
	"Path": "org.eclipse.jetty.start.Props.addPossibleProperty",
	"Comment": "add a potential argument as a property.if arg is not a property, ignore it.",
	"Method": "boolean addPossibleProperty(String arg,String source){\r\n    if (arg.startsWith(\"-D\")) {\r\n        String[] assign = arg.substring(2).split(\"=\", 2);\r\n        switch(assign.length) {\r\n            case 2:\r\n                setSystemProperty(assign[0], assign[1]);\r\n                setProperty(assign[0], assign[1], source);\r\n                return true;\r\n            case 1:\r\n                setSystemProperty(assign[0], \"\");\r\n                setProperty(assign[0], \"\", source);\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    int idx = arg.indexOf('=');\r\n    if (idx >= 0) {\r\n        String key = arg.substring(0, idx);\r\n        String value = arg.substring(idx + 1);\r\n        setProperty(key, value, source);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.PathWatcher.createWatchService",
	"Comment": "create a fresh watchservice and determine if it is a native implementation or not.",
	"Method": "void createWatchService(){\r\n    this.watchService = FileSystems.getDefault().newWatchService();\r\n    WatchEvent.Modifier[] modifiers = null;\r\n    boolean nativeService = true;\r\n    try {\r\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\r\n        Class<?> pollingWatchServiceClass = Class.forName(\"sun.nio.fs.PollingWatchService\", false, cl);\r\n        if (pollingWatchServiceClass.isAssignableFrom(this.watchService.getClass())) {\r\n            nativeService = false;\r\n            LOG.info(\"Using Non-Native Java {}\", pollingWatchServiceClass.getName());\r\n            Class<?> c = Class.forName(\"com.sun.nio.file.SensitivityWatchEventModifier\");\r\n            Field f = c.getField(\"HIGH\");\r\n            modifiers = new WatchEvent.Modifier[] { (WatchEvent.Modifier) f.get(c) };\r\n        }\r\n    } catch (Throwable t) {\r\n        LOG.ignore(t);\r\n    }\r\n    this.watchModifiers = modifiers;\r\n    this.nativeWatchService = nativeService;\r\n}"
}, {
	"Path": "org.eclipse.jetty.annotations.ServletContainerInitializersStarter.doStart",
	"Comment": "call the dostart method of the servletcontainerinitializers",
	"Method": "void doStart(){\r\n    List<ContainerInitializer> initializers = (List<ContainerInitializer>) _context.getAttribute(AnnotationConfiguration.CONTAINER_INITIALIZERS);\r\n    if (initializers == null)\r\n        return;\r\n    for (ContainerInitializer i : initializers) {\r\n        try {\r\n            if (LOG.isDebugEnabled())\r\n                LOG.debug(\"Calling ServletContainerInitializer \" + i.getTarget().getClass().getName());\r\n            i.callStartup(_context);\r\n        } catch (Exception e) {\r\n            LOG.warn(e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.bull.javamelody.JavaMelodyConfigurationProperties.isEnabled",
	"Comment": "returns if javamelody should be enabled within the application.",
	"Method": "boolean isEnabled(){\r\n    return enabled;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.frames.CloseFrame.truncate",
	"Comment": "truncate arbitrary reason into something that will fit into the closeframe limits.",
	"Method": "String truncate(String reason){\r\n    return StringUtil.truncate(reason, (ControlFrame.MAX_CONTROL_PAYLOAD - 2));\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.transformTypeParameters",
	"Comment": "execute a transformation on all the type parameters of this element.",
	"Method": "Type transformTypeParameters(TypeTransformer transformer){\r\n    Type result = this;\r\n    int i = 0;\r\n    for (Type tp : this.typeParametersValues()) {\r\n        Type transformedTp = transformer.transform(tp);\r\n        if (transformedTp != tp) {\r\n            List<Type> typeParametersCorrected = result.asReferenceType().typeParametersValues();\r\n            typeParametersCorrected.set(i, transformedTp);\r\n            result = create(typeDeclaration, typeParametersCorrected, typeSolver);\r\n        }\r\n        i++;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.DefaultSessionIdManager.expireAll",
	"Comment": "remove an id from use by telling all contexts to remove a session with this id.",
	"Method": "void expireAll(String id){\r\n    if (LOG.isDebugEnabled())\r\n        LOG.debug(\"Expiring {}\", id);\r\n    for (SessionHandler manager : getSessionHandlers()) {\r\n        manager.invalidate(id);\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration.describeType",
	"Comment": "describe the type of the parameter. in practice add three dots to the type nameif the parameter is variadic.",
	"Method": "String describeType(){\r\n    if (isVariadic()) {\r\n        return getType().asArrayType().getComponentType().describe() + \"...\";\r\n    } else {\r\n        return getType().describe();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.BufferUtil.clearToFill",
	"Comment": "clear the buffer to be empty in fill mode.the position is set to 0 and the limit is set to the capacity.",
	"Method": "void clearToFill(ByteBuffer buffer){\r\n    if (buffer != null) {\r\n        buffer.position(0);\r\n        buffer.limit(buffer.capacity());\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.AbstractSessionCache.isSaveOnInactiveEviction",
	"Comment": "whether we should save a session that has been inactive beforewe boot it from the cache.",
	"Method": "boolean isSaveOnInactiveEviction(){\r\n    return _saveOnInactiveEviction;\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.ServletContextHandler.insertHandler",
	"Comment": "insert a handlerwrapper before the first session,security or servlethandlerbut after any other handlerwrappers.",
	"Method": "void insertHandler(HandlerWrapper handler){\r\n    if (handler instanceof SessionHandler)\r\n        setSessionHandler((SessionHandler) handler);\r\n    else if (handler instanceof SecurityHandler)\r\n        setSecurityHandler((SecurityHandler) handler);\r\n    else if (handler instanceof GzipHandler)\r\n        setGzipHandler((GzipHandler) handler);\r\n    else if (handler instanceof ServletHandler)\r\n        setServletHandler((ServletHandler) handler);\r\n    else {\r\n        HandlerWrapper tail = handler;\r\n        while (tail.getHandler() instanceof HandlerWrapper) tail = (HandlerWrapper) tail.getHandler();\r\n        if (tail.getHandler() != null)\r\n            throw new IllegalArgumentException(\"bad tail of inserted wrapper chain\");\r\n        HandlerWrapper h = this;\r\n        while (h.getHandler() instanceof HandlerWrapper) {\r\n            HandlerWrapper wrapper = (HandlerWrapper) h.getHandler();\r\n            if (wrapper instanceof SessionHandler || wrapper instanceof SecurityHandler || wrapper instanceof ServletHandler)\r\n                break;\r\n            h = wrapper;\r\n        }\r\n        Handler next = h.getHandler();\r\n        doSetHandler(h, handler);\r\n        doSetHandler(tail, next);\r\n    }\r\n    relinkHandlers();\r\n}"
}, {
	"Path": "com.github.javaparser.ast.visitor.GenericVisitorWithDefaults.defaultAction",
	"Comment": "this will be called by the nodelist visit method when it is not overridden.",
	"Method": "R defaultAction(Node n,A arg,R defaultAction,NodeList n,A arg){\r\n    return null;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.expr.FieldAccessExpr.isInternal",
	"Comment": "indicate if this fieldaccessexpr is an element directly contained in a larger fieldaccessexpr.",
	"Method": "boolean isInternal(){\r\n    return this.getParentNode().isPresent() && this.getParentNode().get() instanceof FieldAccessExpr;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.typesystem.ReferenceType.hasName",
	"Comment": "has the typedeclaration a name? anonymous classes do not have one.",
	"Method": "boolean hasName(){\r\n    return typeDeclaration.hasName();\r\n}"
}, {
	"Path": "net.bull.javamelody.internal.model.Base64Coder.encodeLines",
	"Comment": "encodes a byte array into base 64 format and breaks the output into lines.",
	"Method": "String encodeLines(byte[] in,String encodeLines,byte[] in,int iOff,int iLen,int lineLen,String lineSeparator){\r\n    final int blockLen = lineLen * 3 / 4;\r\n    if (blockLen <= 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    final int lines = (iLen + blockLen - 1) / blockLen;\r\n    final int bufLen = (iLen + 2) / 3 * 4 + lines * lineSeparator.length();\r\n    final StringBuilder buf = new StringBuilder(bufLen);\r\n    int ip = 0;\r\n    while (ip < iLen) {\r\n        final int l = Math.min(iLen - ip, blockLen);\r\n        buf.append(encode(in, iOff + ip, l));\r\n        buf.append(lineSeparator);\r\n        ip += l;\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration.hasAnnotation",
	"Comment": "has the type at least one annotation declared or inherited having the specified qualified name?",
	"Method": "boolean hasAnnotation(String qualifiedName){\r\n    if (hasDirectlyAnnotation(qualifiedName)) {\r\n        return true;\r\n    }\r\n    return getAllAncestors().stream().anyMatch(it -> it.asReferenceType().getTypeDeclaration().hasDirectlyAnnotation(qualifiedName));\r\n}"
}, {
	"Path": "org.eclipse.jetty.security.ConstraintSecurityHandler.createConstraintsWithMappingsForPath",
	"Comment": "generate constraints and contraintmappings for the given url pattern and servletsecurityelement",
	"Method": "List<ConstraintMapping> createConstraintsWithMappingsForPath(String name,String pathSpec,ServletSecurityElement securityElement){\r\n    List<ConstraintMapping> mappings = new ArrayList<ConstraintMapping>();\r\n    Constraint httpConstraint = null;\r\n    ConstraintMapping httpConstraintMapping = null;\r\n    if (securityElement.getEmptyRoleSemantic() != EmptyRoleSemantic.PERMIT || securityElement.getRolesAllowed().length != 0 || securityElement.getTransportGuarantee() != TransportGuarantee.NONE) {\r\n        httpConstraint = ConstraintSecurityHandler.createConstraint(name, securityElement);\r\n        httpConstraintMapping = new ConstraintMapping();\r\n        httpConstraintMapping.setPathSpec(pathSpec);\r\n        httpConstraintMapping.setConstraint(httpConstraint);\r\n        mappings.add(httpConstraintMapping);\r\n    }\r\n    List<String> methodOmissions = new ArrayList<String>();\r\n    Collection<HttpMethodConstraintElement> methodConstraintElements = securityElement.getHttpMethodConstraints();\r\n    if (methodConstraintElements != null) {\r\n        for (HttpMethodConstraintElement methodConstraintElement : methodConstraintElements) {\r\n            Constraint methodConstraint = ConstraintSecurityHandler.createConstraint(name, methodConstraintElement);\r\n            ConstraintMapping mapping = new ConstraintMapping();\r\n            mapping.setConstraint(methodConstraint);\r\n            mapping.setPathSpec(pathSpec);\r\n            if (methodConstraintElement.getMethodName() != null) {\r\n                mapping.setMethod(methodConstraintElement.getMethodName());\r\n                methodOmissions.add(methodConstraintElement.getMethodName());\r\n            }\r\n            mappings.add(mapping);\r\n        }\r\n    }\r\n    if (methodOmissions.size() > 0 && httpConstraintMapping != null)\r\n        httpConstraintMapping.setMethodOmissions(methodOmissions.toArray(new String[methodOmissions.size()]));\r\n    return mappings;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.InterfaceDeclaration.getAllInterfacesExtended",
	"Comment": "return the list of interfaces extended directly or indirectly by this one.",
	"Method": "List<ReferenceType> getAllInterfacesExtended(){\r\n    List<ReferenceType> interfaces = new ArrayList();\r\n    for (ReferenceType interfaceDeclaration : getInterfacesExtended()) {\r\n        interfaces.add(interfaceDeclaration);\r\n        interfaces.addAll(interfaceDeclaration.getAllInterfacesAncestors());\r\n    }\r\n    return interfaces;\r\n}"
}, {
	"Path": "org.eclipse.jetty.jaas.spi.JDBCLoginModule.initialize",
	"Comment": "init loginmodule.called once by jaas after new instance created.",
	"Method": "void initialize(Subject subject,CallbackHandler callbackHandler,Map<String, ?> sharedState,Map<String, ?> options){\r\n    try {\r\n        super.initialize(subject, callbackHandler, sharedState, options);\r\n        dbDriver = (String) options.get(\"dbDriver\");\r\n        dbUrl = (String) options.get(\"dbUrl\");\r\n        dbUserName = (String) options.get(\"dbUserName\");\r\n        dbPassword = (String) options.get(\"dbPassword\");\r\n        if (dbUserName == null)\r\n            dbUserName = \"\";\r\n        if (dbPassword == null)\r\n            dbPassword = \"\";\r\n        if (dbDriver != null)\r\n            Loader.loadClass(dbDriver).getDeclaredConstructor().newInstance();\r\n    } catch (Exception e) {\r\n        throw new IllegalStateException(e.toString());\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.Range.contains",
	"Comment": "as strictlycontains, but two exactly matching ranges are also considered contained one in each other.",
	"Method": "boolean contains(Range other){\r\n    return begin.isBefore(other.begin) && end.isAfter(other.end);\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.typesystem.parametrization.TypeParameterValueProvider.useThisTypeParametersOnTheGivenType",
	"Comment": "replace the type typeparametersvalues present in the given type with the ones for which this typehas a value.",
	"Method": "Type useThisTypeParametersOnTheGivenType(Type type){\r\n    if (type.isTypeVariable()) {\r\n        TypeParameterDeclaration typeParameter = type.asTypeParameter();\r\n        if (typeParameter.declaredOnType()) {\r\n            Optional<Type> typeParam = typeParamValue(typeParameter);\r\n            if (typeParam.isPresent()) {\r\n                type = typeParam.get();\r\n            }\r\n        }\r\n    }\r\n    if (type.isWildcard() && type.asWildcard().isBounded()) {\r\n        if (type.asWildcard().isExtends()) {\r\n            return Wildcard.extendsBound(useThisTypeParametersOnTheGivenType(type.asWildcard().getBoundedType()));\r\n        } else {\r\n            return Wildcard.superBound(useThisTypeParametersOnTheGivenType(type.asWildcard().getBoundedType()));\r\n        }\r\n    }\r\n    if (type.isReferenceType()) {\r\n        type = type.asReferenceType().transformTypeParameters(tp -> useThisTypeParametersOnTheGivenType(tp));\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.core.resolution.Context.solveMethod",
	"Comment": "we find the method declaration which is the best match for the given name and list of typeparametersvalues.",
	"Method": "SymbolReference<ResolvedMethodDeclaration> solveMethod(String name,List<ResolvedType> argumentsTypes,boolean staticOnly){\r\n    return getParent().solveMethod(name, argumentsTypes, staticOnly);\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.MultiException.ifExceptionThrowMulti",
	"Comment": "throw a multiexception.if this multi exception is empty then no action is taken. if itcontains a any exceptions then thismulti exception is thrown.",
	"Method": "void ifExceptionThrowMulti(){\r\n    if (nested == null)\r\n        return;\r\n    if (nested.size() > 0) {\r\n        throw new MultiException(nested);\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.core.resolution.Context.localVariablesExposedToChild",
	"Comment": "the local variables that are declared in this immediate context and made visible to a given child.this list could include values which are shadowed.",
	"Method": "List<VariableDeclarator> localVariablesExposedToChild(Node child){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "com.github.javaparser.ParseException.add_escapes",
	"Comment": "used to convert raw characters to their escaped versionwhen these raw version cannot be used as part of an asciistring literal.",
	"Method": "String add_escapes(String str){\r\n    StringBuffer retval = new StringBuffer();\r\n    char ch;\r\n    for (int i = 0; i < str.length(); i++) {\r\n        switch(str.charAt(i)) {\r\n            case 0:\r\n                continue;\r\n            case '\\b':\r\n                retval.append(\"\\\\b\");\r\n                continue;\r\n            case '\\t':\r\n                retval.append(\"\\\\t\");\r\n                continue;\r\n            case '\\n':\r\n                retval.append(\"\\\\n\");\r\n                continue;\r\n            case '\\f':\r\n                retval.append(\"\\\\f\");\r\n                continue;\r\n            case '\\r':\r\n                retval.append(\"\\\\r\");\r\n                continue;\r\n            case '\\\"':\r\n                retval.append(\"\\\\\\\"\");\r\n                continue;\r\n            case '\\'':\r\n                retval.append(\"\\\\\\'\");\r\n                continue;\r\n            case '\\\\':\r\n                retval.append(\"\\\\\\\\\");\r\n                continue;\r\n            default:\r\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\r\n                    String s = \"0000\" + Integer.toString(ch, 16);\r\n                    retval.append(\"\\\%u\" + s.substring(s.length() - 4, s.length()));\r\n                } else {\r\n                    retval.append(ch);\r\n                }\r\n                continue;\r\n        }\r\n    }\r\n    return retval.toString();\r\n}"
}, {
	"Path": "org.eclipse.jetty.rewrite.handler.VirtualHostRuleContainer.matchAndApply",
	"Comment": "process the contained rules if the request is applicable to the virtual hosts of this rule",
	"Method": "String matchAndApply(String target,HttpServletRequest request,HttpServletResponse response){\r\n    if (_virtualHosts != null && _virtualHosts.length > 0) {\r\n        String requestHost = normalizeHostname(request.getServerName());\r\n        for (String ruleHost : _virtualHosts) {\r\n            if (ruleHost == null || ruleHost.equalsIgnoreCase(requestHost) || (ruleHost.startsWith(\"*.\") && ruleHost.regionMatches(true, 2, requestHost, requestHost.indexOf(\".\") + 1, ruleHost.length() - 2)))\r\n                return apply(target, request, response);\r\n        }\r\n    } else {\r\n        return apply(target, request, response);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.javaee7.websocket.atmosphere.ChatEndpoint.onDisconnect",
	"Comment": "invoked when the client disconnect or when an unexpected closing of the underlying connection happens.",
	"Method": "void onDisconnect(AtmosphereResourceEvent event){\r\n    if (event.isCancelled()) {\r\n        logger.info(\"Browser {} unexpectedly disconnected\", event.getResource().uuid());\r\n    } else if (event.isClosedByClient()) {\r\n        logger.info(\"Browser {} closed the connection\", event.getResource().uuid());\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.PathWatcher.setNotifyExistingOnStart",
	"Comment": "whether or not to issue notifications for directories and files thatalready exist when the watcher starts.",
	"Method": "void setNotifyExistingOnStart(boolean notify){\r\n    _notifyExistingOnStart = notify;\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.DatabaseAdaptor.convertIdentifier",
	"Comment": "convert a camel case identifier into either upper or lowerdepending on the way the db stores identifiers.",
	"Method": "String convertIdentifier(String identifier){\r\n    if (identifier == null)\r\n        return null;\r\n    if (_dbName == null)\r\n        throw new IllegalStateException(\"DbAdaptor missing metadata\");\r\n    if (_isLower)\r\n        return identifier.toLowerCase(Locale.ENGLISH);\r\n    if (_isUpper)\r\n        return identifier.toUpperCase(Locale.ENGLISH);\r\n    return identifier;\r\n}"
}, {
	"Path": "org.eclipse.jetty.proxy.ConnectHandler.handleAuthentication",
	"Comment": "handles the authentication before setting up the tunnel to the remote server.the default implementation returns true.",
	"Method": "boolean handleAuthentication(HttpServletRequest request,HttpServletResponse response,String address){\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.AtomicBiInteger.add",
	"Comment": "atomically adds the given deltas to the current hi and lo values.",
	"Method": "void add(int deltaHi,int deltaLo){\r\n    while (true) {\r\n        long encoded = get();\r\n        long update = encode(getHi(encoded) + deltaHi, getLo(encoded) + deltaLo);\r\n        if (compareAndSet(encoded, update))\r\n            return;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.jsr356.annotations.JsrCallable.findIndexForRole",
	"Comment": "search the list of parameters for first one matching the role specified.",
	"Method": "int findIndexForRole(Role role){\r\n    Param param = findParamForRole(role);\r\n    if (param != null) {\r\n        return param.index;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.io.AbstractWebSocketConnection.setInitialBuffer",
	"Comment": "extra bytes from the initial http upgrade that need tobe processed by the websocket parser before startingto read bytes from the connection",
	"Method": "void setInitialBuffer(ByteBuffer prefilled){\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"set Initial Buffer - {}\", BufferUtil.toDetailString(prefilled));\r\n    }\r\n    prefillBuffer = prefilled;\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlets.DoSFilter.getName",
	"Comment": "the unique name of the filter when there is more thanone dosfilter instance.",
	"Method": "String getName(){\r\n    return _name;\r\n}"
}, {
	"Path": "com.github.javaparser.JavaToken.valid",
	"Comment": "used by the parser while constructing nodes. no tokens should be invalid when the parser is done.",
	"Method": "boolean valid(){\r\n    return !invalid();\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.extensions.compress.CompressExtension.isRsv1User",
	"Comment": "indicates use of rsv1 flag for indicating deflation is in use.",
	"Method": "boolean isRsv1User(){\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.jmh.DateCacheNoTick.format",
	"Comment": "format a date according to our stored formatter.if it happens to be in the same second as the last formatnowcall, then the format is reused.",
	"Method": "String format(Date inDate,String format,long inDate){\r\n    return ZonedDateTime.ofInstant(Instant.ofEpochMilli(inDate), _zoneId).format(_tzFormat);\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.ReferenceTypeDeclaration.getVisibleFields",
	"Comment": "return a list of all fields declared and the inherited ones which are not private.",
	"Method": "List<FieldDeclaration> getVisibleFields(){\r\n    return getAllFields().stream().filter(f -> f.declaringType().equals(this) || f.accessLevel() != AccessLevel.PRIVATE).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.AbstractSessionCache.get",
	"Comment": "get a session object.if the session object is not in this session store, try gettingthe data for it from a sessiondatastore associated with the session manager.",
	"Method": "Session get(String id){\r\n    Session session = null;\r\n    Exception ex = null;\r\n    while (true) {\r\n        session = doGet(id);\r\n        if (_sessionDataStore == null)\r\n            break;\r\n        if (session == null) {\r\n            if (LOG.isDebugEnabled())\r\n                LOG.debug(\"Session {} not found locally, attempting to load\", id);\r\n            PlaceHolderSession phs = new PlaceHolderSession(_handler, new SessionData(id, null, null, 0, 0, 0, 0));\r\n            Lock phsLock = phs.lock();\r\n            Session s = doPutIfAbsent(id, phs);\r\n            if (s == null) {\r\n                try {\r\n                    session = loadSession(id);\r\n                    if (session == null) {\r\n                        doDelete(id);\r\n                        phsLock.close();\r\n                        break;\r\n                    }\r\n                    try (Lock lock = session.lock()) {\r\n                        boolean success = doReplace(id, phs, session);\r\n                        if (!success) {\r\n                            doDelete(id);\r\n                            session = null;\r\n                            LOG.warn(\"Replacement of placeholder for session {} failed\", id);\r\n                            phsLock.close();\r\n                            break;\r\n                        } else {\r\n                            session.setResident(true);\r\n                            phsLock.close();\r\n                            break;\r\n                        }\r\n                    }\r\n                } catch (Exception e) {\r\n                    ex = e;\r\n                    doDelete(id);\r\n                    phsLock.close();\r\n                    session = null;\r\n                    break;\r\n                }\r\n            } else {\r\n                phsLock.close();\r\n                try (Lock lock = s.lock()) {\r\n                    if (!s.isResident() || s instanceof PlaceHolderSession) {\r\n                        session = null;\r\n                        continue;\r\n                    }\r\n                    session = s;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            try (Lock lock = session.lock()) {\r\n                if (!session.isResident() || session instanceof PlaceHolderSession) {\r\n                    session = null;\r\n                    continue;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (ex != null)\r\n        throw ex;\r\n    return session;\r\n}"
}, {
	"Path": "org.eclipse.jetty.security.ConstraintSecurityHandler.removeConstraintMappingsForPath",
	"Comment": "take out of the constraint mappings those that match the given path.",
	"Method": "List<ConstraintMapping> removeConstraintMappingsForPath(String pathSpec,List<ConstraintMapping> constraintMappings){\r\n    if (pathSpec == null || \"\".equals(pathSpec.trim()) || constraintMappings == null || constraintMappings.size() == 0)\r\n        return Collections.emptyList();\r\n    List<ConstraintMapping> mappings = new ArrayList<ConstraintMapping>();\r\n    for (ConstraintMapping mapping : constraintMappings) {\r\n        if (!pathSpec.equals(mapping.getPathSpec())) {\r\n            mappings.add(mapping);\r\n        }\r\n    }\r\n    return mappings;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.type.ArrayType.unwrapArrayTypes",
	"Comment": "takes a type that may be an arraytype. unwraps arraytypes until the element type is found.",
	"Method": "Pair<Type, List<ArrayBracketPair>> unwrapArrayTypes(Type type){\r\n    final List<ArrayBracketPair> arrayBracketPairs = new ArrayList();\r\n    while (type instanceof ArrayType) {\r\n        ArrayType arrayType = (ArrayType) type;\r\n        arrayBracketPairs.add(new ArrayBracketPair(Range.UNKNOWN, arrayType.getAnnotations()));\r\n        type = arrayType.getComponentType();\r\n    }\r\n    return new Pair(type, arrayBracketPairs);\r\n}"
}, {
	"Path": "com.github.javaparser.printer.lexicalpreservation.RemovedGroup.getLastElementIndex",
	"Comment": "returns the difference index of the last element being removed with this removedgroup",
	"Method": "Integer getLastElementIndex(){\r\n    List<Integer> indicesBeingRemoved = getIndicesBeingRemoved();\r\n    return indicesBeingRemoved.get(indicesBeingRemoved.size() - 1);\r\n}"
}, {
	"Path": "org.eclipse.jetty.security.SecurityHandler.setSessionRenewedOnAuthentication",
	"Comment": "set renew the session on authentication.if set to true, then on authentication, the session associated with a reqeuest is invalidated and replaced with a new session.",
	"Method": "void setSessionRenewedOnAuthentication(boolean renew){\r\n    _renewSession = renew;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.resolution.typeinference.BoundSet.incorporate",
	"Comment": "maintains a set of inference variable bounds, ensuring that these are consistent as new bounds are added.because the bounds on one variable can sometimes impact the possible choices for another variable, this processpropagates bounds between such interdependent variables.",
	"Method": "BoundSet incorporate(BoundSet otherBounds,TypeSolver typeSolver){\r\n    BoundSet newBoundSet = this;\r\n    for (Bound b : otherBounds.bounds) {\r\n        newBoundSet = newBoundSet.withBound(b);\r\n    }\r\n    return newBoundSet.deriveImpliedBounds(typeSolver);\r\n}"
}, {
	"Path": "org.eclipse.jetty.io.ssl.ALPNProcessor.appliesTo",
	"Comment": "tests if this processor can be applied to the given sslengine.",
	"Method": "boolean appliesTo(SSLEngine sslEngine){\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.io.IOState.onCloseRemote",
	"Comment": "a close handshake has been received from the remote endpoint",
	"Method": "void onCloseRemote(CloseInfo closeInfo){\r\n    if (LOG.isDebugEnabled())\r\n        LOG.debug(\"onCloseRemote({})\", closeInfo);\r\n    ConnectionState event = null;\r\n    synchronized (this) {\r\n        if (this.state == ConnectionState.CLOSED) {\r\n            return;\r\n        }\r\n        if (LOG.isDebugEnabled())\r\n            LOG.debug(\"onCloseRemote(), input={}, output={}\", inputAvailable, outputAvailable);\r\n        this.closeInfo = closeInfo;\r\n        inputAvailable = false;\r\n        if (closeHandshakeSource == CloseHandshakeSource.NONE) {\r\n            closeHandshakeSource = CloseHandshakeSource.REMOTE;\r\n        }\r\n        if (!outputAvailable) {\r\n            LOG.debug(\"Close Handshake satisfied, disconnecting\");\r\n            cleanClose = true;\r\n            state = ConnectionState.CLOSED;\r\n            finalClose.compareAndSet(null, closeInfo);\r\n            event = this.state;\r\n        } else if (this.state == ConnectionState.OPEN) {\r\n            this.state = ConnectionState.CLOSING;\r\n            event = this.state;\r\n        }\r\n    }\r\n    if (event != null) {\r\n        notifyStateListeners(event);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.IPAccessHandler.handle",
	"Comment": "checks the incoming request against the whitelist and blacklist",
	"Method": "void handle(String target,Request baseRequest,HttpServletRequest request,HttpServletResponse response){\r\n    HttpChannel channel = baseRequest.getHttpChannel();\r\n    if (channel != null) {\r\n        EndPoint endp = channel.getEndPoint();\r\n        if (endp != null) {\r\n            InetSocketAddress address = endp.getRemoteAddress();\r\n            if (address != null && !isAddrUriAllowed(address.getHostString(), baseRequest.getPathInfo())) {\r\n                response.sendError(HttpStatus.FORBIDDEN_403);\r\n                baseRequest.setHandled(true);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    getHandler().handle(target, baseRequest, request, response);\r\n}"
}, {
	"Path": "com.github.javaparser.ASTParser.getTokens",
	"Comment": "return the list of tokens that have been encountered while parsing code usingthis parser.",
	"Method": "List<Token> getTokens(){\r\n    return token_source.getTokens();\r\n}"
}, {
	"Path": "com.github.javaparser.ast.Node.setParentNode",
	"Comment": "assign a new parent to this node, removing itfrom the list of children of the previous parent, if any.",
	"Method": "Node setParentNode(Node newParentNode){\r\n    if (this.parentNode != null) {\r\n        this.parentNode.childrenNodes.remove(this);\r\n    }\r\n    this.parentNode = parentNode;\r\n    if (this.parentNode != null) {\r\n        this.parentNode.childrenNodes.add(this);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.ssl.SslContextFactory.setIncludeCipherSuites",
	"Comment": "you can either use the exact cipher suite name or a a regular expression.",
	"Method": "void setIncludeCipherSuites(String cipherSuites){\r\n    _includeCipherSuites.clear();\r\n    _includeCipherSuites.addAll(Arrays.asList(cipherSuites));\r\n}"
}, {
	"Path": "org.eclipse.jetty.webapp.ClasspathPattern.setAll",
	"Comment": "initialize the matcher by parsing each classpath pattern in an array",
	"Method": "void setAll(String[] classes){\r\n    _entries.clear();\r\n    addAll(classes);\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration.hasVisibleField",
	"Comment": "either a declared field or inherited field which is not private.",
	"Method": "boolean hasVisibleField(String name){\r\n    return getVisibleFields().stream().filter(f -> f.getName().equals(name)).findFirst().isPresent();\r\n}"
}, {
	"Path": "org.eclipse.jetty.webapp.FragmentConfiguration.addWebFragments",
	"Comment": "add in fragment descriptors that have already been discovered by metainfconfiguration",
	"Method": "void addWebFragments(WebAppContext context,MetaData metaData){\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<Resource, Resource> frags = (Map<Resource, Resource>) context.getAttribute(FRAGMENT_RESOURCES);\r\n    if (frags != null) {\r\n        for (Resource key : frags.keySet()) {\r\n            if (key.isDirectory()) {\r\n                metaData.addFragment(key, frags.get(key));\r\n            } else {\r\n                metaData.addFragment(key, frags.get(key));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.ASTParser.TypeParameters",
	"Comment": "if the list inside the returned rangedlist is null, there are no brackets.if it is empty, there are brackets, but nothing is in them .the normal case is that it contains typeparameters, like .",
	"Method": "RangedList<TypeParameter> TypeParameters(){\r\n    List ret = new LinkedList();\r\n    TypeParameter tp;\r\n    List annotations = null;\r\n    AnnotationExpr ann;\r\n    jj_consume_token(LT);\r\n    ret.add(new int[] { token.beginLine, token.beginColumn });\r\n    label_12: while (true) {\r\n        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\r\n            case AT:\r\n                ;\r\n                break;\r\n            default:\r\n                jj_la1[25] = jj_gen;\r\n                break label_12;\r\n        }\r\n        ann = Annotation();\r\n        annotations = add(annotations, ann);\r\n    }\r\n    tp = TypeParameter();\r\n    ret.add(tp);\r\n    tp.setAnnotations(annotations);\r\n    annotations = null;\r\n    label_13: while (true) {\r\n        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\r\n            case COMMA:\r\n                ;\r\n                break;\r\n            default:\r\n                jj_la1[26] = jj_gen;\r\n                break label_13;\r\n        }\r\n        jj_consume_token(COMMA);\r\n        label_14: while (true) {\r\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\r\n                case AT:\r\n                    ;\r\n                    break;\r\n                default:\r\n                    jj_la1[27] = jj_gen;\r\n                    break label_14;\r\n            }\r\n            ann = Annotation();\r\n            annotations = add(annotations, ann);\r\n        }\r\n        tp = TypeParameter();\r\n        ret.add(tp);\r\n        tp.setAnnotations(annotations);\r\n        annotations = null;\r\n    }\r\n    jj_consume_token(GT);\r\n    {\r\n        if (true)\r\n            return ret;\r\n    }\r\n    throw new Error(\"Missing return statement in function\");\r\n}"
}, {
	"Path": "org.eclipse.jetty.client.HttpClient.setName",
	"Comment": "sets the name of this httpclient.the name is also used to generate the jmx objectname of this httpclientand must be set before the registration of the httpclient mbean in the mbeanserver.",
	"Method": "void setName(String name){\r\n    this.name = name;\r\n}"
}, {
	"Path": "com.github.javaparser.ast.expr.CharLiteralExpr.escape",
	"Comment": "utility method that creates a new stringliteralexpr. escapes eol characters.",
	"Method": "CharLiteralExpr escape(String string){\r\n    return new CharLiteralExpr(Utils.escapeEndOfLines(string));\r\n}"
}, {
	"Path": "com.github.javaparser.Range.strictlyContains",
	"Comment": "do this strictly contains other? it means that this has to be larger than other and it has to start as otheror before and end as other or after.",
	"Method": "boolean strictlyContains(Range other){\r\n    return begin.isBefore(other.begin) && end.isAfter(other.end);\r\n}"
}, {
	"Path": "com.github.javaparser.ast.expr.ArrayCreationExpr.createdType",
	"Comment": "takes the element type and wraps it in an arraytype for every array creation level.",
	"Method": "Type createdType(){\r\n    Type result = elementType;\r\n    for (int i = 0; i < levels.size(); i++) {\r\n        result = new ArrayType(result, ArrayType.Origin.TYPE, new NodeList());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "ru.lanwen.verbalregex.VerbalExpression.regex",
	"Comment": "creates new instance of verbalexpression builder from cloned builder",
	"Method": "Builder regex(Builder pBuilder,Builder regex){\r\n    return new Builder();\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlets.DoSFilter.isInsertHeaders",
	"Comment": "check flag to insert the dosfilter headers into the response.",
	"Method": "boolean isInsertHeaders(){\r\n    return _insertHeaders;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.MultiPartInputStreamParser.deleteParts",
	"Comment": "delete any tmp storage for parts, and clear out the parts list.",
	"Method": "void deleteParts(){\r\n    if (!_parsed)\r\n        return;\r\n    Collection<Part> parts = getParsedParts();\r\n    MultiException err = new MultiException();\r\n    for (Part p : parts) {\r\n        try {\r\n            ((MultiPartInputStreamParser.MultiPart) p).cleanUp();\r\n        } catch (Exception e) {\r\n            err.add(e);\r\n        }\r\n    }\r\n    _parts.clear();\r\n    err.ifExceptionThrowRuntime();\r\n}"
}, {
	"Path": "com.github.javaparser.utils.SeparatedItemStringBuilder.append",
	"Comment": "add one item. either pass a string, or a format for string.format and corresponding arguments.",
	"Method": "SeparatedItemStringBuilder append(CharSequence format,Object args){\r\n    if (hasItems) {\r\n        builder.append(separator);\r\n    }\r\n    builder.append(String.format(format.toString(), args));\r\n    hasItems = true;\r\n    return this;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration.asClass",
	"Comment": "return this as a classdeclaration or throw unsupportedoperationexception.",
	"Method": "ResolvedClassDeclaration asClass(){\r\n    throw new UnsupportedOperationException(String.format(\"%s is not a class\", this));\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.handler.ErrorHandler.badMessageError",
	"Comment": "bad message error bodygenerate a error response body to be sent for a bad message.in this case there is something wrong with the request, so eithera request cannot be built, or it is not safe to build a request.this method allows for a simple error page body to be returned and some response headers to be set.",
	"Method": "ByteBuffer badMessageError(int status,String reason,HttpFields fields){\r\n    if (reason == null)\r\n        reason = HttpStatus.getMessage(status);\r\n    fields.put(HttpHeader.CONTENT_TYPE, MimeTypes.Type.TEXT_HTML_8859_1.asString());\r\n    return BufferUtil.toBuffer(\"<h1>Bad Message \" + status + \"<\/h1><pre>reason: \" + reason + \"<\/pre>\");\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.io.IOState.onReadFailure",
	"Comment": "the local endpoint has reached a read failure.this could be a normal result after a proper close handshake, or even a premature close due to a connection disconnect.",
	"Method": "void onReadFailure(Throwable t){\r\n    ConnectionState event = null;\r\n    synchronized (this) {\r\n        if (this.state == ConnectionState.CLOSED) {\r\n            return;\r\n        }\r\n        String reason = \"WebSocket Read Failure\";\r\n        if (t instanceof EOFException) {\r\n            reason = \"WebSocket Read EOF\";\r\n            Throwable cause = t.getCause();\r\n            if ((cause != null) && (StringUtil.isNotBlank(cause.getMessage()))) {\r\n                reason = \"EOF: \" + cause.getMessage();\r\n            }\r\n        } else {\r\n            if (StringUtil.isNotBlank(t.getMessage())) {\r\n                reason = t.getMessage();\r\n            }\r\n        }\r\n        CloseInfo close = new CloseInfo(StatusCode.ABNORMAL, reason);\r\n        finalClose.compareAndSet(null, close);\r\n        this.cleanClose = false;\r\n        this.state = ConnectionState.CLOSED;\r\n        this.closeInfo = close;\r\n        this.inputAvailable = false;\r\n        this.outputAvailable = false;\r\n        this.closeHandshakeSource = CloseHandshakeSource.ABNORMAL;\r\n        event = this.state;\r\n    }\r\n    notifyStateListeners(event);\r\n}"
}, {
	"Path": "org.javaee7.ServerOperations.addUsersToContainerIdentityStore",
	"Comment": "add the default test user and credentials to the identity store of supported containers",
	"Method": "void addUsersToContainerIdentityStore(){\r\n    String javaEEServer = System.getProperty(\"javaEEServer\");\r\n    if (\"glassfish-remote\".equals(javaEEServer) || \"payara-remote\".equals(javaEEServer)) {\r\n        System.out.println(\"Adding user for glassfish-remote\");\r\n        List<String> cmd = new ArrayList();\r\n        cmd.add(\"create-file-user\");\r\n        cmd.add(\"--groups\");\r\n        cmd.add(\"g1\");\r\n        cmd.add(\"--passwordfile\");\r\n        cmd.add(Paths.get(\"\").toAbsolutePath() + \"/src/test/resources/password.txt\");\r\n        cmd.add(\"u1\");\r\n        CliCommands.payaraGlassFish(cmd);\r\n    } else {\r\n        if (javaEEServer == null) {\r\n            System.out.println(\"javaEEServer not specified\");\r\n        } else {\r\n            System.out.println(javaEEServer + \" not supported\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.ssl.SslContextFactory.customize",
	"Comment": "customize an sslparameters instance with the configuration of this factory.",
	"Method": "void customize(SSLEngine sslEngine,SSLParameters customize,SSLParameters sslParams){\r\n    sslParams.setEndpointIdentificationAlgorithm(getEndpointIdentificationAlgorithm());\r\n    sslParams.setUseCipherSuitesOrder(isUseCipherSuitesOrder());\r\n    if (!_certHosts.isEmpty() || !_certWilds.isEmpty())\r\n        sslParams.setSNIMatchers(Collections.singletonList(new AliasSNIMatcher()));\r\n    if (_selectedCipherSuites != null)\r\n        sslParams.setCipherSuites(_selectedCipherSuites);\r\n    if (_selectedProtocols != null)\r\n        sslParams.setProtocols(_selectedProtocols);\r\n    if (getWantClientAuth())\r\n        sslParams.setWantClientAuth(true);\r\n    if (getNeedClientAuth())\r\n        sslParams.setNeedClientAuth(true);\r\n    return sslParams;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedDeclaration.asParameter",
	"Comment": "return this as a parameterdeclaration or throw an unsupportedoperationexception",
	"Method": "ResolvedParameterDeclaration asParameter(){\r\n    throw new UnsupportedOperationException(String.format(\"%s is not a ParameterDeclaration\", this));\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.SearchPattern.compile",
	"Comment": "produces a searchpattern instance which can be usedto find matches of the pattern in data",
	"Method": "SearchPattern compile(byte[] pattern,SearchPattern compile,String pattern){\r\n    return new SearchPattern(pattern.getBytes(StandardCharsets.UTF_8));\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration.asTypeParameter",
	"Comment": "return this as a typeparameterdeclaration or throw unsupportedoperationexception.",
	"Method": "ResolvedTypeParameterDeclaration asTypeParameter(){\r\n    throw new UnsupportedOperationException(String.format(\"%s is not a type parameter\", this));\r\n}"
}, {
	"Path": "org.eclipse.jetty.servlet.ServletRequestLogTest.testLogHandlerCollection_SimpleErrorPageMapping",
	"Comment": "test a requestloghandler at the end of a handlercollectionusing servlet specific error page mapping.",
	"Method": "void testLogHandlerCollection_SimpleErrorPageMapping(Servlet testServlet,String requestPath,String expectedLogEntry){\r\n    Server server = new Server();\r\n    ServerConnector connector = new ServerConnector(server);\r\n    connector.setPort(0);\r\n    server.setConnectors(new Connector[] { connector });\r\n    HandlerCollection handlers = new HandlerCollection();\r\n    ContextHandlerCollection contexts = new ContextHandlerCollection();\r\n    DefaultHandler defaultHandler = new DefaultHandler();\r\n    handlers.setHandlers(new Handler[] { contexts, defaultHandler });\r\n    server.setHandler(handlers);\r\n    CaptureLog captureLog = new CaptureLog();\r\n    server.setRequestLog(captureLog);\r\n    ServletContextHandler app = new ServletContextHandler(ServletContextHandler.SESSIONS);\r\n    app.setContextPath(\"/\");\r\n    contexts.addHandler(app);\r\n    ServletHolder testHolder = new ServletHolder(testServlet);\r\n    app.addServlet(testHolder, \"/test\");\r\n    app.addServlet(CustomErrorServlet.class, \"/errorpage\");\r\n    ErrorPageErrorHandler errorMapper = new ErrorPageErrorHandler();\r\n    errorMapper.addErrorPage(500, \"/errorpage\");\r\n    app.setErrorHandler(errorMapper);\r\n    try {\r\n        server.start();\r\n        Assertions.assertTimeoutPreemptively(ofSeconds(4), () -> {\r\n            String host = connector.getHost();\r\n            if (host == null) {\r\n                host = \"localhost\";\r\n            }\r\n            int port = connector.getLocalPort();\r\n            URI serverUri = new URI(\"http\", null, host, port, requestPath, null, null);\r\n            HttpURLConnection connection = (HttpURLConnection) serverUri.toURL().openConnection();\r\n            try {\r\n                connection.setAllowUserInteraction(false);\r\n                int statusCode = connection.getResponseCode();\r\n                LOG.debug(\"Response Status Code: {}\", statusCode);\r\n                if (statusCode == 200) {\r\n                    String content = getResponseContent(connection);\r\n                    LOG.debug(\"Response Content: {}\", content);\r\n                }\r\n            } finally {\r\n                connection.disconnect();\r\n            }\r\n            assertRequestLog(expectedLogEntry, captureLog);\r\n        });\r\n    } finally {\r\n        server.stop();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.security.PropertyUserStore.notifyUpdate",
	"Comment": "notifies the registered listeners of potential updates to a user",
	"Method": "void notifyUpdate(String username,Credential credential,String[] roleArray){\r\n    if (_listeners != null) {\r\n        for (UserListener _listener : _listeners) _listener.update(username, credential, roleArray);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.jsp.TestJettyTldPreScanned.testIt",
	"Comment": "test that a tld inside a jar can be scanned, as can a tld not inside a jar.",
	"Method": "void testIt(){\r\n    File jar = MavenTestingUtils.getTestResourceFile(\"taglib.jar\");\r\n    File tld = MavenTestingUtils.getTestResourceFile(\"META-INF/foo-taglib.tld\");\r\n    List<URL> list = new ArrayList();\r\n    list.add(new URL(\"jar:\" + jar.toURI().toURL().toString() + \"!/META-INF/bar-taglib.tld\"));\r\n    list.add(tld.toURI().toURL());\r\n    JettyTldPreScanned preScanned = new JettyTldPreScanned(new ServletContextHandler().getServletContext(), false, false, false, list);\r\n    preScanned.scanJars();\r\n    Map<TldResourcePath, TaglibXml> map = preScanned.getTldResourcePathTaglibXmlMap();\r\n    assertNotNull(map);\r\n    assertEquals(2, map.size());\r\n    for (TldResourcePath p : map.keySet()) {\r\n        URL u = p.getUrl();\r\n        TaglibXml tlx = map.get(p);\r\n        assertNotNull(tlx);\r\n        if (!\"foo\".equals(tlx.getShortName()) && !\"bar\".equals(tlx.getShortName()))\r\n            fail(\"unknown tag\");\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.Session.didActivate",
	"Comment": "call the activation listeners. this must be called holding the lock.",
	"Method": "void didActivate(){\r\n    HttpSessionEvent event = new HttpSessionEvent(this);\r\n    for (Iterator<String> iter = _sessionData.getKeys().iterator(); iter.hasNext(); ) {\r\n        Object value = _sessionData.getAttribute(iter.next());\r\n        if (value instanceof HttpSessionActivationListener) {\r\n            HttpSessionActivationListener listener = (HttpSessionActivationListener) value;\r\n            listener.sessionDidActivate(event);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.methods.MethodUsage.getNoParams",
	"Comment": "return the number of formal arguments accepted by this method.",
	"Method": "int getNoParams(){\r\n    return paramTypes.size();\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.DefaultSessionIdManager.getWorkerName",
	"Comment": "get the workname. if set, the workername is dot appended to the sessionid and can be used to assist session affinity in a load balancer.",
	"Method": "String getWorkerName(){\r\n    return _workerName;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumConstantDeclaration.getWrappedNode",
	"Comment": "returns the javaparser node associated with this javaparserenumconstantdeclaration.",
	"Method": "com.github.javaparser.ast.body.EnumConstantDeclaration getWrappedNode(){\r\n    return wrappedNode;\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.types.ResolvedReferenceType.getAllFieldsVisibleToInheritors",
	"Comment": "fields which are visible to inheritors. they include all inherited fields which are visible to thistype plus all declared fields which are not private.",
	"Method": "List<ResolvedFieldDeclaration> getAllFieldsVisibleToInheritors(){\r\n    List<ResolvedFieldDeclaration> res = new LinkedList(this.getDeclaredFields().stream().filter(f -> f.accessSpecifier() != PRIVATE).collect(Collectors.toList()));\r\n    getDirectAncestors().forEach(a -> res.addAll(a.getAllFieldsVisibleToInheritors()));\r\n    return res;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.ssl.SslContextFactory.selectProtocols",
	"Comment": "select protocols to be used by the connectorbased on configured inclusion and exclusion listsas well as enabled and supported protocols.",
	"Method": "void selectProtocols(String[] enabledProtocols,String[] supportedProtocols){\r\n    Set<String> selected_protocols = new LinkedHashSet();\r\n    if (!_includeProtocols.isEmpty()) {\r\n        for (String protocol : _includeProtocols) {\r\n            if (Arrays.asList(supportedProtocols).contains(protocol))\r\n                selected_protocols.add(protocol);\r\n            else\r\n                LOG.info(\"Protocol {} not supported in {}\", protocol, Arrays.asList(supportedProtocols));\r\n        }\r\n    } else\r\n        selected_protocols.addAll(Arrays.asList(enabledProtocols));\r\n    selected_protocols.removeAll(_excludeProtocols);\r\n    if (selected_protocols.isEmpty())\r\n        LOG.warn(\"No selected protocols from {}\", Arrays.asList(supportedProtocols));\r\n    _selectedProtocols = selected_protocols.toArray(new String[0]);\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.model.declarations.MethodLikeDeclaration.getQualifiedName",
	"Comment": "the qualified name of the method composed by the qualfied name of the declaring typefollowed by a dot and the name of the method.",
	"Method": "String getQualifiedName(){\r\n    return declaringType().getQualifiedName() + \".\" + this.getName();\r\n}"
}, {
	"Path": "com.github.javaparser.ast.nodeTypes.NodeWithMembers.addPrivateField",
	"Comment": "add a private field to this and automatically add the import of the type ifneeded",
	"Method": "FieldDeclaration addPrivateField(Class<?> typeClass,String name,FieldDeclaration addPrivateField,String type,String name,FieldDeclaration addPrivateField,Type type,String name){\r\n    return addField(type, name, Modifier.PRIVATE);\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.resource.Resource.setDefaultUseCaches",
	"Comment": "change the default setting for url connection caches.subsequent urlconnections will use this default.",
	"Method": "void setDefaultUseCaches(boolean useCaches){\r\n    __defaultUseCaches = useCaches;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.resolution.naming.NameLogic.syntacticClassificationAccordingToContext",
	"Comment": "see jls 6.5.1 syntactic classification of a name according to context.most users do not want to call directly this method but call classifyreference instead.",
	"Method": "NameCategory syntacticClassificationAccordingToContext(Node name){\r\n    if (name.getParentNode().isPresent()) {\r\n        Node parent = name.getParentNode().get();\r\n        if (isAName(parent) && nameAsString(name).equals(nameAsString(parent))) {\r\n            return syntacticClassificationAccordingToContext(parent);\r\n        }\r\n    }\r\n    if (isSyntacticallyATypeName(name)) {\r\n        return NameCategory.TYPE_NAME;\r\n    }\r\n    if (isSyntacticallyAnExpressionName(name)) {\r\n        return NameCategory.EXPRESSION_NAME;\r\n    }\r\n    if (isSyntacticallyAMethodName(name)) {\r\n        return NameCategory.METHOD_NAME;\r\n    }\r\n    if (isSyntacticallyAPackageOrTypeName(name)) {\r\n        return NameCategory.PACKAGE_OR_TYPE_NAME;\r\n    }\r\n    if (isSyntacticallyAAmbiguousName(name)) {\r\n        return NameCategory.AMBIGUOUS_NAME;\r\n    }\r\n    if (isSyntacticallyAModuleName(name)) {\r\n        return NameCategory.MODULE_NAME;\r\n    }\r\n    if (isSyntacticallyAPackageName(name)) {\r\n        return NameCategory.PACKAGE_NAME;\r\n    }\r\n    if (name instanceof NameExpr) {\r\n        return NameCategory.EXPRESSION_NAME;\r\n    }\r\n    if (name instanceof FieldAccessExpr) {\r\n        return NameCategory.EXPRESSION_NAME;\r\n    }\r\n    if (name instanceof ClassOrInterfaceType) {\r\n        return NameCategory.TYPE_NAME;\r\n    }\r\n    if (name.getParentNode().isPresent() && name.getParentNode().get() instanceof ClassOrInterfaceType) {\r\n        return NameCategory.TYPE_NAME;\r\n    }\r\n    if (name.getParentNode().isPresent() && name.getParentNode().get() instanceof FieldAccessExpr) {\r\n        return NameCategory.EXPRESSION_NAME;\r\n    }\r\n    throw new UnsupportedOperationException(\"Unable to classify category of name contained in \" + name.getParentNode().get().getClass().getSimpleName() + \". See \" + name + \" at \" + name.getRange());\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.jsr356.server.ServerContainer.getWebSocketContainer",
	"Comment": "get the websocketcontainer out of the current threadlocal referenceof the active contexthandler.",
	"Method": "WebSocketContainer getWebSocketContainer(){\r\n    ContextHandler.Context context = ContextHandler.getCurrentContext();\r\n    if (context == null)\r\n        return null;\r\n    ContextHandler handler = ContextHandler.getContextHandler(context);\r\n    if (handler == null)\r\n        return null;\r\n    if (!(handler instanceof ServletContextHandler))\r\n        return null;\r\n    return (javax.websocket.WebSocketContainer) handler.getServletContext().getAttribute(\"javax.websocket.server.ServerContainer\");\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.session.SessionHandler.scavenge",
	"Comment": "called periodically by the housekeeper to handle the list ofsessions that have expired since the last call to scavenge.",
	"Method": "void scavenge(){\r\n    if (isStopping() || isStopped())\r\n        return;\r\n    if (LOG.isDebugEnabled())\r\n        LOG.debug(\"{} scavenging sessions\", this);\r\n    String[] ss = _candidateSessionIdsForExpiry.toArray(new String[0]);\r\n    Set<String> candidates = new HashSet(Arrays.asList(ss));\r\n    _candidateSessionIdsForExpiry.removeAll(candidates);\r\n    if (LOG.isDebugEnabled())\r\n        LOG.debug(\"{} scavenging session ids {}\", this, candidates);\r\n    try {\r\n        candidates = _sessionCache.checkExpiration(candidates);\r\n        for (String id : candidates) {\r\n            try {\r\n                getSessionIdManager().expireAll(id);\r\n            } catch (Exception e) {\r\n                LOG.warn(e);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        LOG.warn(e);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.PathWatcherTest.testDeployFiles_ModifyWar_LargeSlowCopy",
	"Comment": "pretend to modify a new war file that is large, and being copied into placeusing some sort of technique that is slow enough that it takes a while forthe entire war file to exist in place.this is to test the quiet time logic to ensure that only a single modified event occurs on this new war file",
	"Method": "void testDeployFiles_ModifyWar_LargeSlowCopy(){\r\n    Path dir = testdir.getEmptyPathDir();\r\n    Files.createFile(dir.resolve(\"foo.war\"));\r\n    Files.createFile(dir.resolve(\"hello.war\"));\r\n    Files.createDirectories(dir.resolve(\"bar/WEB-INF\"));\r\n    Files.createFile(dir.resolve(\"bar/WEB-INF/web.xml\"));\r\n    PathWatcher pathWatcher = new PathWatcher();\r\n    pathWatcher.setUpdateQuietTime(QUIET_TIME, TimeUnit.MILLISECONDS);\r\n    PathWatchEventCapture capture = new PathWatchEventCapture(dir);\r\n    pathWatcher.addListener(capture);\r\n    PathWatcher.Config baseDirConfig = new PathWatcher.Config(dir);\r\n    baseDirConfig.setRecurseDepth(2);\r\n    baseDirConfig.addExcludeHidden();\r\n    baseDirConfig.addIncludeGlobRelative(\"*.war\");\r\n    baseDirConfig.addIncludeGlobRelative(\"*/WEB-INF/web.xml\");\r\n    pathWatcher.watch(baseDirConfig);\r\n    try {\r\n        capture.setFinishTrigger(3);\r\n        pathWatcher.start();\r\n        assertTrue(capture.finishedLatch.await(LONG_TIME, TimeUnit.MILLISECONDS));\r\n        capture.setFinishTrigger(1);\r\n        Path warFile = dir.resolve(\"hello.war\");\r\n        long start = System.nanoTime();\r\n        new Thread(() -> {\r\n            updateFileOverTime(warFile, 2 * QUIET_TIME, TimeUnit.MILLISECONDS);\r\n        }).start();\r\n        assertTrue(capture.finishedLatch.await(4 * QUIET_TIME, TimeUnit.MILLISECONDS));\r\n        long end = System.nanoTime();\r\n        assertThat(end - start, greaterThan(TimeUnit.MILLISECONDS.toNanos(2 * QUIET_TIME)));\r\n        Map<String, PathWatchEventType[]> expected = new HashMap();\r\n        expected.put(\"bar/WEB-INF/web.xml\", new PathWatchEventType[] { ADDED });\r\n        expected.put(\"foo.war\", new PathWatchEventType[] { ADDED });\r\n        expected.put(\"hello.war\", new PathWatchEventType[] { ADDED, MODIFIED });\r\n        capture.assertEvents(expected);\r\n        TimeUnit.MILLISECONDS.sleep(WAIT_TIME);\r\n        capture.assertEvents(expected);\r\n    } finally {\r\n        pathWatcher.stop();\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.resolution.declarations.ResolvedMethodLikeDeclaration.getQualifiedName",
	"Comment": "the qualified name of the method composed by the qualfied name of the declaring typefollowed by a dot and the name of the method.",
	"Method": "String getQualifiedName(){\r\n    return declaringType().getQualifiedName() + \".\" + this.getName();\r\n}"
}, {
	"Path": "org.eclipse.jetty.maven.plugin.JettyRunDistro.configureJettyHome",
	"Comment": "if jetty home does not exist, download it andunpack to build dir.",
	"Method": "void configureJettyHome(){\r\n    if (jettyHome == null) {\r\n        Artifact jettyHomeArtifact = resolveArtifact(JETTY_HOME_GROUPID, JETTY_HOME_ARTIFACTID, pluginVersion, \"zip\");\r\n        JarResource res = (JarResource) JarResource.newJarResource(Resource.newResource(jettyHomeArtifact.getFile()));\r\n        res.copyTo(target);\r\n        jettyHome = new File(target, JETTY_HOME_ARTIFACTID + \"-\" + pluginVersion);\r\n    } else {\r\n        if (!jettyHome.exists())\r\n            throw new IllegalStateException(jettyHome.getAbsolutePath() + \" does not exist\");\r\n    }\r\n    getLog().info(\"jetty.home = \" + jettyHome.getAbsolutePath());\r\n}"
}, {
	"Path": "com.github.javaparser.ast.nodeTypes.NodeWithAnnotations.isAnnotationPresent",
	"Comment": "check whether an annotation with this class is present on this element",
	"Method": "boolean isAnnotationPresent(String annotationName,boolean isAnnotationPresent,Class<? extends Annotation> annotationClass){\r\n    return isAnnotationPresent(annotationClass.getSimpleName());\r\n}"
}, {
	"Path": "org.eclipse.jetty.websocket.common.UpgradeResponseAdapter.sendForbidden",
	"Comment": "issue a forbidden upgrade response.this means that the websocket endpoint was valid, but the conditions to use a websocket resulted in a forbiddenaccess.use this when the origin or authentication is invalid.",
	"Method": "void sendForbidden(String message){\r\n    throw new UnsupportedOperationException(\"Not supported\");\r\n}"
}, {
	"Path": "org.javaee7.jms.temp.destination.TempQueueTest.testRequestResposne",
	"Comment": "we invoke the client, and verify that the response is processed",
	"Method": "void testRequestResposne(){\r\n    assertEquals(\"Processed: Hello\", client.process(\"Hello\"));\r\n}"
}, {
	"Path": "org.eclipse.jetty.rewrite.handler.HeaderRegexRule.setValue",
	"Comment": "sets the header value. the value can be either a string or int value.",
	"Method": "void setValue(String value){\r\n    _value = value;\r\n}"
}, {
	"Path": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.find",
	"Comment": "for some reasons lambdaexprs are duplicate and the equals method is not implemented correctly.",
	"Method": "Optional<ResolvedType> find(DataKey<ResolvedType> dataKey,Node node){\r\n    for (Node key : map.keySet()) {\r\n        if (key instanceof LambdaExpr) {\r\n            LambdaExpr keyLambdaExpr = (LambdaExpr) key;\r\n            if (keyLambdaExpr.toString().equals(lambdaExpr.toString()) && getParentNode(keyLambdaExpr) == getParentNode(lambdaExpr)) {\r\n                return Optional.of(map.get(keyLambdaExpr));\r\n            }\r\n        }\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "net.bull.javamelody.internal.model.TestSamplingProfiler.testClassesInIncludeNoneMatching",
	"Comment": "test that classes from packages are included, where include pattern does not match any packages.",
	"Method": "void testClassesInIncludeNoneMatching(){\r\n    final SamplingProfiler samplingProfiler = new SamplingProfiler(null, Arrays.asList(\"not.matching.package,also.not.matching\"));\r\n    assertEmptyHotspots(samplingProfiler);\r\n    samplingProfiler.update();\r\n    assertEmptyHotspots(samplingProfiler);\r\n    doSomeWorkAndTakeSample(samplingProfiler);\r\n    assertEmptyHotspots(samplingProfiler);\r\n    samplingProfiler.clear();\r\n    assertEmptyHotspots(samplingProfiler);\r\n}"
}, {
	"Path": "org.eclipse.jetty.server.AbstractNCSARequestLog.log",
	"Comment": "writes the request and response information to the output stream.",
	"Method": "void log(Request request,Response response){\r\n    try {\r\n        if (_ignorePathMap != null && _ignorePathMap.getMatch(request.getRequestURI()) != null)\r\n            return;\r\n        if (!isEnabled())\r\n            return;\r\n        StringBuilder buf = _buffers.get();\r\n        buf.setLength(0);\r\n        if (_logServer) {\r\n            append(buf, request.getServerName());\r\n            buf.append(' ');\r\n        }\r\n        String addr = null;\r\n        if (_preferProxiedForAddress) {\r\n            addr = request.getHeader(HttpHeader.X_FORWARDED_FOR.toString());\r\n        }\r\n        if (addr == null)\r\n            addr = request.getRemoteAddr();\r\n        buf.append(addr);\r\n        buf.append(\" - \");\r\n        String auth = getAuthentication(request);\r\n        append(buf, auth == null ? \"-\" : auth);\r\n        buf.append(\" [\");\r\n        if (_logDateCache != null)\r\n            buf.append(_logDateCache.format(request.getTimeStamp()));\r\n        else\r\n            buf.append(request.getTimeStamp());\r\n        buf.append(\"] \\\"\");\r\n        append(buf, request.getMethod());\r\n        buf.append(' ');\r\n        append(buf, request.getOriginalURI());\r\n        buf.append(' ');\r\n        append(buf, request.getProtocol());\r\n        buf.append(\"\\\" \");\r\n        int status = response.getCommittedMetaData().getStatus();\r\n        if (status >= 0) {\r\n            buf.append((char) ('0' + ((status / 100) % 10)));\r\n            buf.append((char) ('0' + ((status / 10) % 10)));\r\n            buf.append((char) ('0' + (status % 10)));\r\n        } else\r\n            buf.append(status);\r\n        long written = response.getHttpChannel().getBytesWritten();\r\n        if (written >= 0) {\r\n            buf.append(' ');\r\n            if (written > 99999)\r\n                buf.append(written);\r\n            else {\r\n                if (written > 9999)\r\n                    buf.append((char) ('0' + ((written / 10000) % 10)));\r\n                if (written > 999)\r\n                    buf.append((char) ('0' + ((written / 1000) % 10)));\r\n                if (written > 99)\r\n                    buf.append((char) ('0' + ((written / 100) % 10)));\r\n                if (written > 9)\r\n                    buf.append((char) ('0' + ((written / 10) % 10)));\r\n                buf.append((char) ('0' + (written) % 10));\r\n            }\r\n            buf.append(' ');\r\n        } else\r\n            buf.append(\" - \");\r\n        if (_extended)\r\n            logExtended(buf, request, response);\r\n        if (_logCookies) {\r\n            Cookie[] cookies = request.getCookies();\r\n            if (cookies == null || cookies.length == 0)\r\n                buf.append(\" -\");\r\n            else {\r\n                buf.append(\" \\\"\");\r\n                for (int i = 0; i < cookies.length; i++) {\r\n                    if (i != 0)\r\n                        buf.append(';');\r\n                    buf.append(cookies[i].getName());\r\n                    buf.append('=');\r\n                    buf.append(cookies[i].getValue());\r\n                }\r\n                buf.append('\\\"');\r\n            }\r\n        }\r\n        if (_logLatency) {\r\n            long now = System.currentTimeMillis();\r\n            if (_logLatency) {\r\n                buf.append(' ');\r\n                buf.append(now - request.getTimeStamp());\r\n            }\r\n        }\r\n        String log = buf.toString();\r\n        write(log);\r\n    } catch (IOException e) {\r\n        LOG.warn(e);\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.utils.SourceRoot.getCache",
	"Comment": "the java files that have been parsed by this source root object, or have been added manually.",
	"Method": "List<ParseResult<CompilationUnit>> getCache(){\r\n    return new ArrayList(cache.values());\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.internal.webapp.OSGiWebappClassLoader.setWebappContext",
	"Comment": "in the case of the generation of a webapp via a jetty context file weneed a proper classloader to setup the app before we have thewebappcontext so we place a fake one there to start with. we replace itwith the actual webapp context with this method. we also apply theextraclasspath there at the same time.",
	"Method": "void setWebappContext(WebAppContext webappContext){\r\n    try {\r\n        if (_contextField == null) {\r\n            _contextField = WebAppClassLoader.class.getDeclaredField(\"_context\");\r\n            _contextField.setAccessible(true);\r\n        }\r\n        _contextField.set(this, webappContext);\r\n        if (webappContext.getExtraClasspath() != null) {\r\n            addClassPath(webappContext.getExtraClasspath());\r\n        }\r\n    } catch (Throwable t) {\r\n        __logger.warn(\"Unable to set webappcontext\", t);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.IPAddressMap.match",
	"Comment": "retrieve the first object that is associated with the specified internet address by taking into account the wildcard specifications.",
	"Method": "TYPE match(String addr,boolean match,String value,boolean match,String value,boolean match,int number){\r\n    Map.Entry<String, TYPE> entry = getMatch(addr);\r\n    return entry == null ? null : entry.getValue();\r\n}"
}, {
	"Path": "com.github.javaparser.serialization.JavaParserJsonDeserializer.deserializeObject",
	"Comment": "deserializes json, contained by jsonreader, into ast node.the root node and all its child nodes will be deserialized.",
	"Method": "Node deserializeObject(JsonReader reader,Node deserializeObject,JsonObject nodeJson){\r\n    try {\r\n        String serializedNodeType = nodeJson.getString(JsonNode.CLASS.propertyKey);\r\n        BaseNodeMetaModel nodeMetaModel = getNodeMetaModel(Class.forName(serializedNodeType)).orElseThrow(() -> new IllegalStateException(\"Trying to deserialize an unknown node type: \" + serializedNodeType));\r\n        Map<String, Object> parameters = new HashMap();\r\n        Map<String, JsonValue> deferredJsonValues = new HashMap();\r\n        for (String name : nodeJson.keySet()) {\r\n            if (name.equals(JsonNode.CLASS.propertyKey)) {\r\n                continue;\r\n            }\r\n            Optional<PropertyMetaModel> optionalPropertyMetaModel = nodeMetaModel.getAllPropertyMetaModels().stream().filter(mm -> mm.getName().equals(name)).findFirst();\r\n            if (!optionalPropertyMetaModel.isPresent()) {\r\n                deferredJsonValues.put(name, nodeJson.get(name));\r\n                continue;\r\n            }\r\n            PropertyMetaModel propertyMetaModel = optionalPropertyMetaModel.get();\r\n            if (propertyMetaModel.isNodeList()) {\r\n                JsonArray nodeListJson = nodeJson.getJsonArray(name);\r\n                parameters.put(name, deserializeNodeList(nodeListJson));\r\n            } else if (propertyMetaModel.isEnumSet()) {\r\n                JsonArray enumSetJson = nodeJson.getJsonArray(name);\r\n                parameters.put(name, deserializeEnumSet(enumSetJson));\r\n            } else if (propertyMetaModel.isNode()) {\r\n                parameters.put(name, deserializeObject(nodeJson.getJsonObject(name)));\r\n            } else {\r\n                Class<?> type = propertyMetaModel.getType();\r\n                if (type == String.class) {\r\n                    parameters.put(name, nodeJson.getString(name));\r\n                } else if (type == boolean.class) {\r\n                    parameters.put(name, Boolean.parseBoolean(nodeJson.getString(name)));\r\n                } else if (Enum.class.isAssignableFrom(type)) {\r\n                    parameters.put(name, Enum.valueOf((Class<? extends Enum>) type, nodeJson.getString(name)));\r\n                } else {\r\n                    throw new IllegalStateException(\"Don't know how to convert: \" + type);\r\n                }\r\n            }\r\n        }\r\n        Node node = nodeMetaModel.construct(parameters);\r\n        if (parameters.containsKey(JsonNode.COMMENT.propertyKey)) {\r\n            node.setComment((Comment) parameters.get(JsonNode.COMMENT.propertyKey));\r\n        }\r\n        for (String name : deferredJsonValues.keySet()) {\r\n            if (!readNonMetaProperties(name, deferredJsonValues.get(name), node)) {\r\n                throw new IllegalStateException(\"Unknown propertyKey: \" + nodeMetaModel.getQualifiedClassName() + \".\" + name);\r\n            }\r\n        }\r\n        setSymbolResolverIfCompilationUnit(node);\r\n        return node;\r\n    } catch (ClassNotFoundException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jetty.webapp.MetaData.addDiscoveredAnnotation",
	"Comment": "add an annotation that has been discovered on a class, method or field within a resourceeg a jar or dir.this method is synchronized as it is anticipated that it may be called by many threadsduring the annotation scanning phase.",
	"Method": "void addDiscoveredAnnotation(DiscoveredAnnotation annotation){\r\n    if (annotation == null)\r\n        return;\r\n    Resource resource = annotation.getResource();\r\n    if (resource == null || !_webInfJars.contains(resource))\r\n        resource = EmptyResource.INSTANCE;\r\n    List<DiscoveredAnnotation> list = _annotations.get(resource);\r\n    if (list == null) {\r\n        list = new ArrayList<DiscoveredAnnotation>();\r\n        _annotations.put(resource, list);\r\n    }\r\n    list.add(annotation);\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.warurl.internal.WarURLConnection.substitueManifest",
	"Comment": "use pipedouputstream and pipedinputstream to do the transformation without makinga new temporary file ust to replace the manifest.",
	"Method": "InputStream substitueManifest(Manifest newmanifest,InputStream rawIn){\r\n    final PipedOutputStream pOut = new PipedOutputStream();\r\n    PipedInputStream pIn = new PipedInputStream(pOut);\r\n    Runnable run = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            JarInputStream jin = null;\r\n            JarOutputStream dest = null;\r\n            try {\r\n                jin = new JarInputStream(rawIn, false);\r\n                dest = new JarOutputStream(pOut, newmanifest);\r\n                ZipEntry next = jin.getNextEntry();\r\n                while (next != null) {\r\n                    if (next.getName().equalsIgnoreCase(JarFile.MANIFEST_NAME)) {\r\n                        continue;\r\n                    }\r\n                    dest.putNextEntry(next);\r\n                    if (next.getSize() > 0) {\r\n                        IO.copy(jin, dest, next.getSize());\r\n                    }\r\n                    next = jin.getNextJarEntry();\r\n                }\r\n            } catch (IOException ioe) {\r\n                ioe.printStackTrace();\r\n            } finally {\r\n                if (dest != null)\r\n                    IO.close(dest);\r\n                if (jin != null)\r\n                    IO.close(jin);\r\n                IO.close(pOut);\r\n            }\r\n        }\r\n    };\r\n    Thread th = new Thread(run);\r\n    th.start();\r\n    return pIn;\r\n}"
}, {
	"Path": "org.eclipse.jetty.osgi.boot.warurl.internal.WarURLConnection.substitueManifest",
	"Comment": "use pipedouputstream and pipedinputstream to do the transformation without makinga new temporary file ust to replace the manifest.",
	"Method": "InputStream substitueManifest(Manifest newmanifest,InputStream rawIn){\r\n    JarInputStream jin = null;\r\n    JarOutputStream dest = null;\r\n    try {\r\n        jin = new JarInputStream(rawIn, false);\r\n        dest = new JarOutputStream(pOut, newmanifest);\r\n        ZipEntry next = jin.getNextEntry();\r\n        while (next != null) {\r\n            if (next.getName().equalsIgnoreCase(JarFile.MANIFEST_NAME)) {\r\n                continue;\r\n            }\r\n            dest.putNextEntry(next);\r\n            if (next.getSize() > 0) {\r\n                IO.copy(jin, dest, next.getSize());\r\n            }\r\n            next = jin.getNextJarEntry();\r\n        }\r\n    } catch (IOException ioe) {\r\n        ioe.printStackTrace();\r\n    } finally {\r\n        if (dest != null)\r\n            IO.close(dest);\r\n        if (jin != null)\r\n            IO.close(jin);\r\n        IO.close(pOut);\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.ParserConfiguration.setTabSize",
	"Comment": "when a tab character is encountered during parsing, the column position will be increased by this value.by default it is 1.",
	"Method": "ParserConfiguration setTabSize(int tabSize){\r\n    this.tabSize = tabSize;\r\n    return this;\r\n}"
}, {
	"Path": "org.eclipse.jetty.util.PathWatcherTest.testStartupFindFiles",
	"Comment": "when starting up the pathwatcher, the events should occurindicating files that are of interest that already existon the filesystem.",
	"Method": "void testStartupFindFiles(){\r\n    Path dir = testdir.getEmptyPathDir();\r\n    Files.createFile(dir.resolve(\"foo.war\"));\r\n    Files.createDirectories(dir.resolve(\"bar/WEB-INF\"));\r\n    Files.createFile(dir.resolve(\"bar/WEB-INF/web.xml\"));\r\n    Files.createFile(dir.resolve(\"foo.war.backup\"));\r\n    String hidden_war = \".hidden.war\";\r\n    if (org.junit.jupiter.api.condition.OS.WINDOWS.isCurrentOs())\r\n        hidden_war = \"hidden.war\";\r\n    Files.createFile(dir.resolve(hidden_war));\r\n    if (org.junit.jupiter.api.condition.OS.WINDOWS.isCurrentOs())\r\n        Files.setAttribute(dir.resolve(hidden_war), \"dos:hidden\", Boolean.TRUE);\r\n    Files.createDirectories(dir.resolve(\".wat/WEB-INF\"));\r\n    Files.createFile(dir.resolve(\".wat/huh.war\"));\r\n    Files.createFile(dir.resolve(\".wat/WEB-INF/web.xml\"));\r\n    PathWatcher pathWatcher = new PathWatcher();\r\n    pathWatcher.setUpdateQuietTime(QUIET_TIME, TimeUnit.MILLISECONDS);\r\n    PathWatchEventCapture capture = new PathWatchEventCapture(dir);\r\n    pathWatcher.addListener(capture);\r\n    PathWatcher.Config baseDirConfig = new PathWatcher.Config(dir);\r\n    baseDirConfig.setRecurseDepth(2);\r\n    baseDirConfig.addExcludeHidden();\r\n    baseDirConfig.addIncludeGlobRelative(\"*.war\");\r\n    baseDirConfig.addIncludeGlobRelative(\"*/WEB-INF/web.xml\");\r\n    pathWatcher.watch(baseDirConfig);\r\n    try {\r\n        capture.setFinishTrigger(2);\r\n        pathWatcher.start();\r\n        capture.finishedLatch.await(LONG_TIME, TimeUnit.MILLISECONDS);\r\n        Map<String, PathWatchEventType[]> expected = new HashMap();\r\n        expected.put(\"bar/WEB-INF/web.xml\", new PathWatchEventType[] { ADDED });\r\n        expected.put(\"foo.war\", new PathWatchEventType[] { ADDED });\r\n        capture.assertEvents(expected);\r\n        TimeUnit.MILLISECONDS.sleep(WAIT_TIME);\r\n        capture.assertEvents(expected);\r\n    } finally {\r\n        pathWatcher.stop();\r\n    }\r\n}"
}, {
	"Path": "com.github.javaparser.utils.SourceRoot.getCompilationUnits",
	"Comment": "the compilationunits of the java files that have been parsed succesfully by this source root object, or have beenadded manually.",
	"Method": "List<CompilationUnit> getCompilationUnits(){\r\n    return cache.values().stream().filter(ParseResult::isSuccessful).map(p -> p.getResult().get()).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.eclipse.jetty.security.HashLoginService.setConfig",
	"Comment": "load realm users from properties file.the property file maps usernames to password specs followed by an optional comma separated list of role names.",
	"Method": "void setConfig(String config){\r\n    _config = config;\r\n}"
}, {
	"Path": "org.eclipse.jetty.http.MultiPartParser.parseMimePartHeaders",
	"Comment": "parse the message headers and return true if the handler has signaled for a return",
	"Method": "boolean parseMimePartHeaders(ByteBuffer buffer){\r\n    while (_state == State.BODY_PART && hasNextByte(buffer)) {\r\n        HttpTokens.Token t = next(buffer);\r\n        if (t == null)\r\n            break;\r\n        if (t.getType() != HttpTokens.Type.LF)\r\n            _totalHeaderLineLength++;\r\n        if (_totalHeaderLineLength > MAX_HEADER_LINE_LENGTH)\r\n            throw new IllegalStateException(\"Header Line Exceeded Max Length\");\r\n        switch(_fieldState) {\r\n            case FIELD:\r\n                switch(t.getType()) {\r\n                    case SPACE:\r\n                    case HTAB:\r\n                        {\r\n                            if (_fieldName == null)\r\n                                throw new IllegalStateException(\"First field folded\");\r\n                            if (_fieldValue == null) {\r\n                                _string.reset();\r\n                                _length = 0;\r\n                            } else {\r\n                                setString(_fieldValue);\r\n                                _string.append(' ');\r\n                                _length++;\r\n                                _fieldValue = null;\r\n                            }\r\n                            setState(FieldState.VALUE);\r\n                            break;\r\n                        }\r\n                    case LF:\r\n                        handleField();\r\n                        setState(State.FIRST_OCTETS);\r\n                        _partialBoundary = 2;\r\n                        if (LOG.isDebugEnabled())\r\n                            LOG.debug(\"headerComplete {}\", this);\r\n                        if (_handler.headerComplete())\r\n                            return true;\r\n                        break;\r\n                    case ALPHA:\r\n                    case DIGIT:\r\n                    case TCHAR:\r\n                        handleField();\r\n                        setState(FieldState.IN_NAME);\r\n                        _string.reset();\r\n                        _string.append(t.getChar());\r\n                        _length = 1;\r\n                        break;\r\n                    default:\r\n                        throw new IllegalCharacterException(_state, t, buffer);\r\n                }\r\n                break;\r\n            case IN_NAME:\r\n                switch(t.getType()) {\r\n                    case COLON:\r\n                        _fieldName = takeString();\r\n                        _length = -1;\r\n                        setState(FieldState.VALUE);\r\n                        break;\r\n                    case SPACE:\r\n                        setState(FieldState.AFTER_NAME);\r\n                        break;\r\n                    case LF:\r\n                        {\r\n                            if (LOG.isDebugEnabled())\r\n                                LOG.debug(\"Line Feed in Name {}\", this);\r\n                            handleField();\r\n                            setState(FieldState.FIELD);\r\n                            break;\r\n                        }\r\n                    case ALPHA:\r\n                    case DIGIT:\r\n                    case TCHAR:\r\n                        _string.append(t.getChar());\r\n                        _length = _string.length();\r\n                        break;\r\n                    default:\r\n                        throw new IllegalCharacterException(_state, t, buffer);\r\n                }\r\n                break;\r\n            case AFTER_NAME:\r\n                switch(t.getType()) {\r\n                    case COLON:\r\n                        _fieldName = takeString();\r\n                        _length = -1;\r\n                        setState(FieldState.VALUE);\r\n                        break;\r\n                    case LF:\r\n                        _fieldName = takeString();\r\n                        _string.reset();\r\n                        _fieldValue = \"\";\r\n                        _length = -1;\r\n                        break;\r\n                    case SPACE:\r\n                        break;\r\n                    default:\r\n                        throw new IllegalCharacterException(_state, t, buffer);\r\n                }\r\n                break;\r\n            case VALUE:\r\n                switch(t.getType()) {\r\n                    case LF:\r\n                        _string.reset();\r\n                        _fieldValue = \"\";\r\n                        _length = -1;\r\n                        setState(FieldState.FIELD);\r\n                        break;\r\n                    case SPACE:\r\n                    case HTAB:\r\n                        break;\r\n                    case ALPHA:\r\n                    case DIGIT:\r\n                    case TCHAR:\r\n                    case VCHAR:\r\n                    case COLON:\r\n                    case OTEXT:\r\n                        _string.append(t.getByte());\r\n                        _length = _string.length();\r\n                        setState(FieldState.IN_VALUE);\r\n                        break;\r\n                    default:\r\n                        throw new IllegalCharacterException(_state, t, buffer);\r\n                }\r\n                break;\r\n            case IN_VALUE:\r\n                switch(t.getType()) {\r\n                    case SPACE:\r\n                    case HTAB:\r\n                        _string.append(' ');\r\n                        break;\r\n                    case LF:\r\n                        if (_length > 0) {\r\n                            _fieldValue = takeString();\r\n                            _length = -1;\r\n                            _totalHeaderLineLength = -1;\r\n                        }\r\n                        setState(FieldState.FIELD);\r\n                        break;\r\n                    case ALPHA:\r\n                    case DIGIT:\r\n                    case TCHAR:\r\n                    case VCHAR:\r\n                    case COLON:\r\n                    case OTEXT:\r\n                        _string.append(t.getByte());\r\n                        _length = _string.length();\r\n                        break;\r\n                    default:\r\n                        throw new IllegalCharacterException(_state, t, buffer);\r\n                }\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(_state.toString());\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.bull.javamelody.internal.model.RrdNioBackend.setLength",
	"Comment": "sets length of the underlying rrd file. this method is called only once, immediately\tafter a new rrd file gets created.",
	"Method": "void setLength(long newLength){\r\n    unmapFile();\r\n    super.setLength(newLength);\r\n    mapFile();\r\n}"
}]